<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no"
    />
    <link rel="shortcut icon" type="image/x-icon" href="/logo.png" />
    <link rel="stylesheet" href="/blog/umi.css" />
    <script>
      window.routerBase = "/blog";
    </script>
    <script>
      //! umi version: 3.5.17
    </script>
    <script>
      !(function () {
        var e = localStorage.getItem("dumi:prefers-color"),
          t = window.matchMedia("(prefers-color-scheme: dark)").matches,
          r = ["light", "dark", "auto"];
        document.documentElement.setAttribute(
          "data-prefers-color",
          e === r[2] ? (t ? r[1] : r[0]) : r.indexOf(e) > -1 ? e : r[0]
        );
      })();
    </script>
    <title>03 | 复杂基础类型：TypeScript 与 JavaScript 有何不同？</title>
  </head>
  <body>
    <div id="root"><div class="__dumi-default-layout" data-route="/type-script入门实战笔记/02.模块一type-script入门/03" data-show-sidemenu="true" data-show-slugs="true" data-site-mode="true" data-gapless="false"><div class="__dumi-default-navbar" data-mode="site"><button class="__dumi-default-navbar-toggle"></button><a class="__dumi-default-navbar-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog/">大师兄</a><nav><div class="__dumi-default-search"><input type="search" class="__dumi-default-search-input" value=""/><ul></ul></div><span>计算机基础<ul><li><a href="/blog/编译原理之美">编译原理之美</a></li><li><a href="/blog/编译原理实战">编译原理实战</a></li><li><a href="/blog/深入浅出计算机组成原理">深入浅出计算机组成原理</a></li><li><a href="/blog/详解http">详解http</a></li><li><a href="/blog/计算机网络通关29讲">计算机网络通关29讲</a></li><li><a href="/blog/网络排查案例课">网络排查案例课</a></li><li><a href="/blog/linux操作系统">linux操作系统</a></li><li><a href="/blog/linux性能优化实战">linux性能优化实战</a></li><li><a href="/blog/程序员数学基础">程序员数学基础</a></li><li><a href="/blog/趣谈网络协议">趣谈网络协议</a></li><li><a href="/blog/操作系统实战">操作系统实战</a></li><li><a href="/blog/软件工程之美">软件工程之美</a></li><li><a href="/blog/sql必知必会">sql必知必会</a></li><li><a href="/blog/操作系统实战45讲">操作系统实战45讲</a></li><li><a href="/blog/网络编程实战">网络编程实战</a></li></ul></span><span>算法<ul><li><a href="/blog/常用算法25讲">常用算法25讲</a></li><li><a href="/blog/数据结构与算法之美">数据结构与算法之美</a></li><li><a href="/blog/业务开发算法50讲">业务开发算法50讲</a></li><li><a href="/blog/动态规划面试宝典">动态规划面试宝典</a></li></ul></span><span>前端开发<ul><li><a href="/blog/浏览器工作原理与实践">浏览器工作原理与实践</a></li><li><a href="/blog/新时代产品经理进阶之路">新时代产品经理进阶之路</a></li><li><a href="/blog/全栈工程师修炼指南">全栈工程师修炼指南</a></li><li><a href="/blog/flutter核心技术与实战">flutter核心技术与实战</a></li><li><a href="/blog/java-script核心原理解析">java-script核心原理解析</a></li><li><a href="/blog/说透低代码">说透低代码</a></li><li><a href="/blog/nodejs应用开发实战">nodejs应用开发实战</a></li><li><a href="/blog/反爬虫兵法演绎20讲">反爬虫兵法演绎20讲</a></li><li><a href="/blog/reactnative新架构实战课">reactnative新架构实战课</a></li><li><a href="/blog/正则表达式入门">正则表达式入门</a></li><li><a href="/blog/重学前端">重学前端</a></li><li><a href="/blog/serverless入门课">serverless入门课</a></li><li><a aria-current="page" class="active" href="/blog/type-script入门实战笔记">type-script入门实战笔记</a></li><li><a href="/blog/图解googlev8">图解googlev8</a></li><li><a href="/blog/vue3源码分析">vue3源码分析</a></li><li><a href="/blog/玩转Vue3全家桶">玩转Vue3全家桶</a></li><li><a href="/blog/webassembly入门">webassembly入门</a></li><li><a href="/blog/手把手带你写一个Web框架">手把手带你写一个Web框架</a></li><li><a href="/blog/web漏洞挖掘实战">web漏洞挖掘实战</a></li><li><a href="/blog/跟月影学可视化">跟月影学可视化</a></li><li><a href="/blog/搞定音频技术">搞定音频技术</a></li><li><a href="/blog/攻克视频技术">攻克视频技术</a></li></ul></span><span>前端工程化<ul><li><a href="/blog/logger">logger</a></li><li><a href="/blog/webpack">webpack</a></li><li><a href="/blog/webpackChain">webpackChain</a></li></ul></span><span>前端性能优化<ul><li><a href="/blog/react性能调优">react性能调优</a></li></ul></span><span>软件测试<ul><li><a href="/blog/全链路压测实战30讲">全链路压测实战30讲</a></li><li><a href="/blog/性能测试实战30讲">性能测试实战30讲</a></li><li><a href="/blog/自动化测试高手课">自动化测试高手课</a></li><li><a href="/blog/软件测试52讲">软件测试52讲</a></li></ul></span><span>面试<ul><li><a href="/blog/面试现场">面试现场</a></li></ul></span><span>杂谈<ul><li><a href="/blog/超级访谈对话张雪峰">超级访谈对话张雪峰</a></li><li><a href="/blog/Git实战手册">Git实战手册</a></li><li><a href="/blog/NodeJS">NodeJS</a></li><li><a href="/blog/ReactJS">ReactJS</a></li><li><a href="/blog/UI设计">UI设计</a></li><li><a href="/blog/webpack4系列教程">webpack4系列教程</a></li><li><a href="/blog/前端知识体系">前端知识体系</a></li><li><a href="/blog/剑指offer刷题笔记">剑指offer刷题笔记</a></li><li><a href="/blog/思考与成长">思考与成长</a></li><li><a href="/blog/设计模式手册">设计模式手册</a></li></ul></span><div class="__dumi-default-navbar-tool"><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "></div></div></div></nav></div><div class="__dumi-default-menu" data-mode="site"><div class="__dumi-default-menu-inner"><div class="__dumi-default-menu-header"><a class="__dumi-default-menu-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog/"></a><h1>大师兄</h1><p></p></div><div class="__dumi-default-menu-mobile-area"><ul class="__dumi-default-menu-nav-list"><li>计算机基础<ul><li><a href="/blog/编译原理之美">编译原理之美</a></li><li><a href="/blog/编译原理实战">编译原理实战</a></li><li><a href="/blog/深入浅出计算机组成原理">深入浅出计算机组成原理</a></li><li><a href="/blog/详解http">详解http</a></li><li><a href="/blog/计算机网络通关29讲">计算机网络通关29讲</a></li><li><a href="/blog/网络排查案例课">网络排查案例课</a></li><li><a href="/blog/linux操作系统">linux操作系统</a></li><li><a href="/blog/linux性能优化实战">linux性能优化实战</a></li><li><a href="/blog/程序员数学基础">程序员数学基础</a></li><li><a href="/blog/趣谈网络协议">趣谈网络协议</a></li><li><a href="/blog/操作系统实战">操作系统实战</a></li><li><a href="/blog/软件工程之美">软件工程之美</a></li><li><a href="/blog/sql必知必会">sql必知必会</a></li><li><a href="/blog/操作系统实战45讲">操作系统实战45讲</a></li><li><a href="/blog/网络编程实战">网络编程实战</a></li></ul></li><li>算法<ul><li><a href="/blog/常用算法25讲">常用算法25讲</a></li><li><a href="/blog/数据结构与算法之美">数据结构与算法之美</a></li><li><a href="/blog/业务开发算法50讲">业务开发算法50讲</a></li><li><a href="/blog/动态规划面试宝典">动态规划面试宝典</a></li></ul></li><li>前端开发<ul><li><a href="/blog/浏览器工作原理与实践">浏览器工作原理与实践</a></li><li><a href="/blog/新时代产品经理进阶之路">新时代产品经理进阶之路</a></li><li><a href="/blog/全栈工程师修炼指南">全栈工程师修炼指南</a></li><li><a href="/blog/flutter核心技术与实战">flutter核心技术与实战</a></li><li><a href="/blog/java-script核心原理解析">java-script核心原理解析</a></li><li><a href="/blog/说透低代码">说透低代码</a></li><li><a href="/blog/nodejs应用开发实战">nodejs应用开发实战</a></li><li><a href="/blog/反爬虫兵法演绎20讲">反爬虫兵法演绎20讲</a></li><li><a href="/blog/reactnative新架构实战课">reactnative新架构实战课</a></li><li><a href="/blog/正则表达式入门">正则表达式入门</a></li><li><a href="/blog/重学前端">重学前端</a></li><li><a href="/blog/serverless入门课">serverless入门课</a></li><li><a aria-current="page" class="active" href="/blog/type-script入门实战笔记">type-script入门实战笔记</a></li><li><a href="/blog/图解googlev8">图解googlev8</a></li><li><a href="/blog/vue3源码分析">vue3源码分析</a></li><li><a href="/blog/玩转Vue3全家桶">玩转Vue3全家桶</a></li><li><a href="/blog/webassembly入门">webassembly入门</a></li><li><a href="/blog/手把手带你写一个Web框架">手把手带你写一个Web框架</a></li><li><a href="/blog/web漏洞挖掘实战">web漏洞挖掘实战</a></li><li><a href="/blog/跟月影学可视化">跟月影学可视化</a></li><li><a href="/blog/搞定音频技术">搞定音频技术</a></li><li><a href="/blog/攻克视频技术">攻克视频技术</a></li></ul></li><li>前端工程化<ul><li><a href="/blog/logger">logger</a></li><li><a href="/blog/webpack">webpack</a></li><li><a href="/blog/webpackChain">webpackChain</a></li></ul></li><li>前端性能优化<ul><li><a href="/blog/react性能调优">react性能调优</a></li></ul></li><li>软件测试<ul><li><a href="/blog/全链路压测实战30讲">全链路压测实战30讲</a></li><li><a href="/blog/性能测试实战30讲">性能测试实战30讲</a></li><li><a href="/blog/自动化测试高手课">自动化测试高手课</a></li><li><a href="/blog/软件测试52讲">软件测试52讲</a></li></ul></li><li>面试<ul><li><a href="/blog/面试现场">面试现场</a></li></ul></li><li>杂谈<ul><li><a href="/blog/超级访谈对话张雪峰">超级访谈对话张雪峰</a></li><li><a href="/blog/Git实战手册">Git实战手册</a></li><li><a href="/blog/NodeJS">NodeJS</a></li><li><a href="/blog/ReactJS">ReactJS</a></li><li><a href="/blog/UI设计">UI设计</a></li><li><a href="/blog/webpack4系列教程">webpack4系列教程</a></li><li><a href="/blog/前端知识体系">前端知识体系</a></li><li><a href="/blog/剑指offer刷题笔记">剑指offer刷题笔记</a></li><li><a href="/blog/思考与成长">思考与成长</a></li><li><a href="/blog/设计模式手册">设计模式手册</a></li></ul></li></ul><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "><button title="Dark theme" class="__dumi-default-dark-moon "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="3854" width="22" height="22"><path d="M991.816611 674.909091a69.166545 69.166545 0 0 0-51.665455-23.272727 70.795636 70.795636 0 0 0-27.438545 5.585454A415.674182 415.674182 0 0 1 754.993338 698.181818c-209.594182 0-393.472-184.785455-393.472-395.636363 0-52.363636 38.539636-119.621818 69.515637-173.614546 4.887273-8.610909 9.634909-16.756364 14.103272-24.901818A69.818182 69.818182 0 0 0 384.631156 0a70.842182 70.842182 0 0 0-27.438545 5.585455C161.678429 90.298182 14.362065 307.898182 14.362065 512c0 282.298182 238.824727 512 532.38691 512a522.286545 522.286545 0 0 0 453.957818-268.334545A69.818182 69.818182 0 0 0 991.816611 674.909091zM546.679156 954.181818c-248.785455 0-462.941091-192-462.941091-442.181818 0-186.647273 140.637091-372.829091 300.939637-442.181818-36.817455 65.629091-92.578909 151.970909-92.578909 232.727273 0 250.181818 214.109091 465.454545 462.917818 465.454545a488.331636 488.331636 0 0 0 185.181091-46.545455 453.003636 453.003636 0 0 1-393.565091 232.727273z m103.656728-669.323636l-14.266182 83.781818a34.909091 34.909091 0 0 0 50.362182 36.770909l74.775272-39.563636 74.752 39.563636a36.142545 36.142545 0 0 0 16.174546 3.956364 34.909091 34.909091 0 0 0 34.210909-40.727273l-14.289455-83.781818 60.509091-59.345455a35.025455 35.025455 0 0 0-19.223272-59.578182l-83.61891-12.101818-37.376-76.101818a34.56 34.56 0 0 0-62.254545 0l-37.376 76.101818-83.618909 12.101818a34.909091 34.909091 0 0 0-19.246546 59.578182z m70.423272-64.698182a34.280727 34.280727 0 0 0 26.135273-19.083636l14.312727-29.090909 14.336 29.090909a34.257455 34.257455 0 0 0 26.135273 19.083636l32.046546 4.887273-23.272728 22.574545a35.234909 35.234909 0 0 0-10.007272 30.952727l5.46909 32.116364-28.625454-15.127273a34.490182 34.490182 0 0 0-32.302546 0l-28.695272 15.127273 5.469091-32.116364a35.141818 35.141818 0 0 0-9.984-30.952727l-23.272728-22.574545z" p-id="3855"></path></svg></button><button title="Light theme" class="__dumi-default-dark-sun "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="4026" width="22" height="22"><path d="M915.2 476.16h-43.968c-24.704 0-44.736 16-44.736 35.84s20.032 35.904 44.736 35.904H915.2c24.768 0 44.8-16.064 44.8-35.904s-20.032-35.84-44.8-35.84zM512 265.6c-136.704 0-246.464 109.824-246.464 246.4 0 136.704 109.76 246.464 246.464 246.464S758.4 648.704 758.4 512c0-136.576-109.696-246.4-246.4-246.4z m0 425.6c-99.008 0-179.2-80.128-179.2-179.2 0-98.944 80.192-179.2 179.2-179.2S691.2 413.056 691.2 512c0 99.072-80.192 179.2-179.2 179.2zM197.44 512c0-19.84-19.136-35.84-43.904-35.84H108.8c-24.768 0-44.8 16-44.8 35.84s20.032 35.904 44.8 35.904h44.736c24.768 0 43.904-16.064 43.904-35.904zM512 198.464c19.776 0 35.84-20.032 35.84-44.8v-44.8C547.84 84.032 531.84 64 512 64s-35.904 20.032-35.904 44.8v44.8c0 24.768 16.128 44.864 35.904 44.864z m0 627.136c-19.776 0-35.904 20.032-35.904 44.8v44.736C476.096 940.032 492.16 960 512 960s35.84-20.032 35.84-44.8v-44.736c0-24.768-16.064-44.864-35.84-44.864z m329.92-592.832c17.472-17.536 20.288-43.072 6.4-57.024-14.016-14.016-39.488-11.2-57.024 6.336-4.736 4.864-26.496 26.496-31.36 31.36-17.472 17.472-20.288 43.008-6.336 57.024 13.952 14.016 39.488 11.2 57.024-6.336 4.8-4.864 26.496-26.56 31.296-31.36zM213.376 759.936c-4.864 4.8-26.56 26.624-31.36 31.36-17.472 17.472-20.288 42.944-6.4 56.96 14.016 13.952 39.552 11.2 57.024-6.336 4.8-4.736 26.56-26.496 31.36-31.36 17.472-17.472 20.288-43.008 6.336-56.96-14.016-13.952-39.552-11.072-56.96 6.336z m19.328-577.92c-17.536-17.536-43.008-20.352-57.024-6.336-14.08 14.016-11.136 39.488 6.336 57.024 4.864 4.864 26.496 26.56 31.36 31.424 17.536 17.408 43.008 20.288 56.96 6.336 14.016-14.016 11.264-39.488-6.336-57.024-4.736-4.864-26.496-26.56-31.296-31.424z m527.168 628.608c4.864 4.864 26.624 26.624 31.36 31.424 17.536 17.408 43.072 20.224 57.088 6.336 13.952-14.016 11.072-39.552-6.4-57.024-4.864-4.8-26.56-26.496-31.36-31.36-17.472-17.408-43.072-20.288-57.024-6.336-13.952 14.016-11.008 39.488 6.336 56.96z" p-id="4027"></path></svg></button><button title="Default to system" class="__dumi-default-dark-auto "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="11002" width="22" height="22"><path d="M127.658667 492.885333c0-51.882667 10.24-101.717333 30.378666-149.162666s47.786667-88.064 81.92-122.538667 75.093333-61.781333 122.538667-81.92 96.938667-30.378667 149.162667-30.378667 101.717333 10.24 149.162666 30.378667 88.405333 47.786667 122.88 81.92 61.781333 75.093333 81.92 122.538667 30.378667 96.938667 30.378667 149.162666-10.24 101.717333-30.378667 149.162667-47.786667 88.405333-81.92 122.88-75.093333 61.781333-122.88 81.92-97.28 30.378667-149.162666 30.378667-101.717333-10.24-149.162667-30.378667-88.064-47.786667-122.538667-81.92-61.781333-75.093333-81.92-122.88-30.378667-96.938667-30.378666-149.162667z m329.045333 0c0 130.048 13.994667 244.394667 41.984 343.381334h12.970667c46.762667 0 91.136-9.216 133.461333-27.306667s78.848-42.666667 109.568-73.386667 54.954667-67.242667 73.386667-109.568 27.306667-86.698667 27.306666-133.461333c0-46.421333-9.216-90.794667-27.306666-133.12s-42.666667-78.848-73.386667-109.568-67.242667-54.954667-109.568-73.386667-86.698667-27.306667-133.461333-27.306666h-11.605334c-28.672 123.562667-43.349333 237.909333-43.349333 343.722666z" p-id="11003"></path></svg></button></div></div></div><ul class="__dumi-default-menu-list"><li><a href="/blog/type-script入门实战笔记">type-script入门实战笔记</a></li><li><a href="/blog/type-script入门实战笔记/01.开篇词">01.开篇词</a><ul><li><a href="/blog/type-script入门实战笔记/01.开篇词/01"><span>开篇词 | 你为什么要选择 TypeScript？</span></a></li></ul></li><li><a aria-current="page" class="active" href="/blog/type-script入门实战笔记/02.模块一type-script入门">02.模块一TypeScript入门</a><ul><li><a href="/blog/type-script入门实战笔记/02.模块一type-script入门/01"><span>01 | 如何快速搭建 TypeScript 学习开发环境？</span></a></li><li><a href="/blog/type-script入门实战笔记/02.模块一type-script入门/02"><span>02 | 简单基础类型：TypeScript 与 JavaScript 有何不同？</span></a></li><li><a aria-current="page" class="active" href="/blog/type-script入门实战笔记/02.模块一type-script入门/03"><span>03 | 复杂基础类型：TypeScript 与 JavaScript 有何不同？</span></a></li><li><a href="/blog/type-script入门实战笔记/02.模块一type-script入门/04"><span>04 | 什么是字面量类型、类型推断、类型拓宽和类型缩小？</span></a></li><li><a href="/blog/type-script入门实战笔记/02.模块一type-script入门/05"><span>05 | 函数类型：返回值类型和参数类型到底如何定义？</span></a></li><li><a href="/blog/type-script入门实战笔记/02.模块一type-script入门/06"><span>06 | 类类型：如何高效使用类型化的面向对象编程利器？</span></a></li><li><a href="/blog/type-script入门实战笔记/02.模块一type-script入门/07"><span>07 | 接口类型与类型别名：这两者的用法与区别分别是什么？</span></a></li><li><a href="/blog/type-script入门实战笔记/02.模块一type-script入门/08"><span>08 | 高级类型：如何快速读懂联合类型和交叉类型的含义？</span></a></li><li><a href="/blog/type-script入门实战笔记/02.模块一type-script入门/09"><span>09 | 枚举类型：详解常见枚举类型的 7 种用法</span></a></li><li><a href="/blog/type-script入门实战笔记/02.模块一type-script入门/10"><span>10 | 泛型：如何正确使用泛型约束类型变量？</span></a></li></ul></li><li><a href="/blog/type-script入门实战笔记/03.模块二type-script进阶">03.模块二TypeScript进阶</a><ul><li><a href="/blog/type-script入门实战笔记/03.模块二type-script进阶/01"><span>11 | 类型守卫：如何有效地保障类型的安全性？</span></a></li><li><a href="/blog/type-script入门实战笔记/03.模块二type-script进阶/02"><span>12 | 类型兼容：如何判断一个类型是否可以赋值给其他类型？</span></a></li><li><a href="/blog/type-script入门实战笔记/03.模块二type-script进阶/03"><span>13 | 必备增强类型系统的方式大盘点，让你的开发如虎添翼</span></a></li><li><a href="/blog/type-script入门实战笔记/03.模块二type-script进阶/04"><span>14 | 掌握 TypeScript 这些官方工具类型，让你的开发事半功倍</span></a></li><li><a href="/blog/type-script入门实战笔记/03.模块二type-script进阶/05"><span>15 | 类型编程：如何打造属于自己的工具类型？</span></a></li></ul></li><li><a href="/blog/type-script入门实战笔记/04.模块三实战指南">04.模块三实战指南</a><ul><li><a href="/blog/type-script入门实战笔记/04.模块三实战指南/01"><span>16 | tsconfig.json 配置：如何定制 TypeScript 的行为？</span></a></li><li><a href="/blog/type-script入门实战笔记/04.模块三实战指南/02"><span>17 | 来自 100 +项目经历的常见 TypeScript 错误汇总分析</span></a></li><li><a href="/blog/type-script入门实战笔记/04.模块三实战指南/03"><span>18 | 手把手教你使用 TypeScript 开发 Node.js 应用</span></a></li><li><a href="/blog/type-script入门实战笔记/04.模块三实战指南/04"><span>19 | 使用 TypeScript 开发 Web 应用的最佳实践</span></a></li><li><a href="/blog/type-script入门实战笔记/04.模块三实战指南/05"><span>20 | 如何将 JavaScript 应用切换至 TypeScript？</span></a></li></ul></li><li><a href="/blog/type-script入门实战笔记/05.结束语">05.结束语</a><ul><li><a href="/blog/type-script入门实战笔记/05.结束语/01"><span>结束语 | TypeScript 的这些实用技能，你不得不知</span></a></li></ul></li><li><a href="/blog/type-script入门实战笔记/summary">type-script入门实战笔记</a></li></ul></div></div><ul role="slug-list" class="__dumi-default-layout-toc"><li title="数组" data-depth="3"><a href="/blog/type-script入门实战笔记/02.模块一type-script入门/03#数组"><span>数组</span></a></li><li title="特殊类型" data-depth="3"><a href="/blog/type-script入门实战笔记/02.模块一type-script入门/03#特殊类型"><span>特殊类型</span></a></li><li title="类型断言（Type Assertion）" data-depth="3"><a href="/blog/type-script入门实战笔记/02.模块一type-script入门/03#类型断言type-assertion"><span>类型断言（Type Assertion）</span></a></li><li title="小结与预告" data-depth="3"><a href="/blog/type-script入门实战笔记/02.模块一type-script入门/03#小结与预告"><span>小结与预告</span></a></li></ul><div class="__dumi-default-layout-content"><div class="markdown"><h1 id="03--复杂基础类型typescript-与-javascript-有何不同"><a aria-hidden="true" tabindex="-1" href="/blog/type-script入门实战笔记/02.模块一type-script入门/03#03--复杂基础类型typescript-与-javascript-有何不同"><span class="icon icon-link"></span></a>03 | 复杂基础类型：TypeScript 与 JavaScript 有何不同？</h1><p>学习完原始类型等知识点，你可能已经对 TypeScript 有了基本的认知。在接下来这一讲中，我将带你接触稍微复杂一点的类型结构（比如数组、any 等比较难理解的特殊类型）及其使用场景。</p><blockquote><p>学习建议：请使用 VS Code 新建一个 03.Basic.2.ts 文件，然后尝试课程中的所有示例。</p></blockquote><h3 id="数组"><a aria-hidden="true" tabindex="-1" href="/blog/type-script入门实战笔记/02.模块一type-script入门/03#数组"><span class="icon icon-link"></span></a>数组</h3><p>因为 TypeScript 的数组和元组转译为 JavaScript 后都是数组，所以这里我们把数组和元组这两个类型整合到一起介绍，也方便你更好地对比学习。</p><h4 id="数组类型array"><a aria-hidden="true" tabindex="-1" href="/blog/type-script入门实战笔记/02.模块一type-script入门/03#数组类型array"><span class="icon icon-link"></span></a>数组类型（Array）</h4><p>在 TypeScript 中，我们也可以像 JavaScript 一样定义数组类型，并且指定数组元素的类型。</p><p>首先，我们可以直接使用 [] 的形式定义数组类型，如下代码所示：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">/** 子元素是数字类型的数组 */</span></div><div class="token-line"><span class="token plain">    let arrayOfNumber: number[] = [1, 2, 3];</span></div><div class="token-line"><span class="token plain">    /** 子元素是字符串类型的数组 */</span></div><div class="token-line"><span class="token plain">    let arrayOfString: string[] = [&#x27;x&#x27;, &#x27;y&#x27;, &#x27;z&#x27;];</span></div></pre></div><p>同样，我们也可以使用 Array 泛型（在第 10 讲会详细介绍泛型）定义数组类型，如下代码所示：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">/** 子元素是数字类型的数组 */</span></div><div class="token-line"><span class="token plain">    let arrayOfNumber: Array&lt;number&gt; = [1, 2, 3];</span></div><div class="token-line"><span class="token plain">    /** 子元素是字符串类型的数组 */</span></div><div class="token-line"><span class="token plain">    let arrayOfString: Array&lt;string&gt; = [&#x27;x&#x27;, &#x27;y&#x27;, &#x27;z&#x27;];</span></div></pre></div><p>以上两种定义数组类型的方式虽然本质上没有任何区别，但是我更推荐使用 [] 这种形式来定义。<strong>一方面可以避免与 JSX 的语法冲突，另一方面可以减少不少代码量</strong>。</p><p>如果我们明确指定了数组元素的类型，以下所有操作都将因为不符合类型约定而提示错误。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">let arrayOfNumber: number[] = [&#x27;x&#x27;, &#x27;y&#x27;, &#x27;z&#x27;]; // 提示 ts(2322)</span></div><div class="token-line"><span class="token plain">    arrayOfNumber[3] = &#x27;a&#x27;; // 提示 ts(2322)</span></div><div class="token-line"><span class="token plain">    arrayOfNumber.push(&#x27;b&#x27;); // 提示 ts(2345)</span></div><div class="token-line"><span class="token plain">    let arrayOfString: string[] = [1, 2, 3]; // 提示 ts(2322)</span></div><div class="token-line"><span class="token plain">    arrayOfString[3] = 1; // 提示 ts(2322)</span></div><div class="token-line"><span class="token plain">    arrayOfString.push(2); // 提示 ts(2345)</span></div></pre></div><h4 id="元组类型tuple"><a aria-hidden="true" tabindex="-1" href="/blog/type-script入门实战笔记/02.模块一type-script入门/03#元组类型tuple"><span class="icon icon-link"></span></a>元组类型（Tuple）</h4><p>元组最重要的特性是可以限制数组元素的个数和类型，它特别适合用来实现多值返回。</p><p>我们熟知的一个使用元组的场景是 React Hooks（关于 React Hooks 的简介<a target="_blank" rel="noopener noreferrer" href="https://reactjs.org/docs/hooks-intro.html?fileGuid=xxQTRXtVcqtHK6j8">请点击这里查看<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>），例如 useState 示例：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">import { useState } from &#x27;react&#x27;;</span></div><div class="token-line"><span class="token plain">    function useCount() {</span></div><div class="token-line"><span class="token plain">      const [count, setCount] = useState(0);</span></div><div class="token-line"><span class="token plain">      return ....;</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>在 JavaScript 中并没有元组的概念，作为一门动态类型语言，它的优势是<strong>天然支持多类型元素数组</strong>。</p><p>我们假设以下两个数组的元素类型如下代码所示：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">[state, setState]</span></div><div class="token-line"><span class="token plain">    [setState, state]</span></div></pre></div><p>从上面可以看出，state 是一个类型为 State 的对象，而 setState 是一个类型为 SetState 的函数。</p><p><strong>注意：这里我们用全小写表示值，首字母大写表示（TypeScript）类型。</strong></p><p>对于 JavaScript 而言，上面的数组其实长的都一样，并没有一个有效的途径可以区分彼此。</p><p>不过，出于较好的扩展性、可读性和稳定性考虑，我们往往会更偏向于<strong>把不同类型的值通过键值对的形式塞到一个对象中，再返回这个对象</strong>（尽管这样会增加代码量），而不是使用没有任何限制的数组。比如我们可能会使用如下的对象结构来替换数组：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">{</span></div><div class="token-line"><span class="token plain">      state,</span></div><div class="token-line"><span class="token plain">      setState</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>而 TypeScript 的元组类型正好弥补了这个不足，使得定义包含固定个数元素、每个元素类型未必相同的数组成为可能。（需要注意的是，毕竟 TypeScript 会转译成 JavaScript，所以 TypeScript 的元组无法在运行时约束所谓的“元组”像真正的元组一样，保证元素类型、长度不可变更）。</p><p>对于 TypeScript 而言，如下所示的两个元组类型其实并不相同：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">[State, SetState]</span></div><div class="token-line"><span class="token plain">    [SetState, State]</span></div></pre></div><p>所以添加了不同元组类型注解的数组后，在 TypeScript 静态类型检测层面就变成了两个不相同的元组，如下代码所示：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">const x: [State, SetState] = [state, setState];</span></div><div class="token-line"><span class="token plain">    const y: [SetState, State] = [setState, state];</span></div></pre></div><p>下面我们还是使用所熟知的 React Hooks 来介绍 TypeScript 元组的应用场景。</p><p>比如 useState 的返回值类型是一个元组类型，如下代码所示（以下仅是简单的例子，事实上 useState 的类型定义更为复杂）：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">(state: State) =&gt; [State, SetState]</span></div></pre></div><p>元组相较对象而言，不仅为我们实现解构赋值提供了极大便利，还减少了不少代码量，这可能也是 React 官方如此设计核心 Hooks 的重要原因之一。</p><p>但事实上，许多第三方的 Hooks 往往会出于扩展性、稳定性等考虑，尤其是需要返回的值的个数超过 2 个时，会更偏向于使用对象作为返回值。</p><blockquote><p>这里需要注意：数组类型的值只有显示添加了元组类型注解后（或者使用 as const，声明为只读元组），TypeScript 才会把它当作元组，否则推荐出来的类型就是普通的数组类型（第 4 讲会介绍类型推断）。</p></blockquote><p>相对于以上熟悉的 JavaScript 一般味道的数组类型，接下来我们将介绍几种不一样且需要费点心力理解的类型——特殊类型（这是并不是 TypeScript 官方的定义，这么划分是为了更好地组织知识点）。</p><h3 id="特殊类型"><a aria-hidden="true" tabindex="-1" href="/blog/type-script入门实战笔记/02.模块一type-script入门/03#特殊类型"><span class="icon icon-link"></span></a>特殊类型</h3><h4 id="1-any"><a aria-hidden="true" tabindex="-1" href="/blog/type-script入门实战笔记/02.模块一type-script入门/03#1-any"><span class="icon icon-link"></span></a>1. any</h4><p>any 指的是一个任意类型，它是官方提供的一个选择性绕过静态类型检测的作弊方式。</p><p>我们可以对被注解为 any 类型的变量进行任何操作，包括获取事实上并不存在的属性、方法，并且 TypeScript 还无法检测其属性是否存在、类型是否正确。</p><p>比如我们可以把任何类型的值赋值给 any 类型的变量，也可以把 any 类型的值赋值给任意类型（除 never 以外）的变量，如下代码所示：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">let anything: any = {};</span></div><div class="token-line"><span class="token plain">    anything.doAnything(); // 不会提示错误</span></div><div class="token-line"><span class="token plain">    anything = 1; // 不会提示错误</span></div><div class="token-line"><span class="token plain">    anything = &#x27;x&#x27;; // 不会提示错误</span></div><div class="token-line"><span class="token plain">    let num: number = anything; // 不会提示错误</span></div><div class="token-line"><span class="token plain">    let str: string = anything; // 不会提示错误</span></div></pre></div><p>如果我们不想花费过高的成本为复杂的数据添加类型注解，或者已经引入了缺少类型注解的第三方组件库，这时就可以把这些值全部注解为 any 类型，并告诉 TypeScript 选择性地忽略静态类型检测。</p><p>尤其是在将一个基于 JavaScript 的应用改造成 TypeScript 的过程中，我们不得不借助 any 来选择性添加和忽略对某些 JavaScript 模块的静态类型检测，直至逐步替换掉所有的 JavaScript。</p><p>any 类型会在对象的调用链中进行传导，即所有 any 类型的任意属性的类型都是 any，如下代码所示：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">let anything: any = {};</span></div><div class="token-line"><span class="token plain">    let z = anything.x.y.z; // z 类型是 any，不会提示错误</span></div><div class="token-line"><span class="token plain">    z(); // 不会提示错误</span></div></pre></div><p>这里我们需要明白且记住：<strong>Any is Hell（Any 是地狱）</strong>。</p><p>从长远来看，使用 any 绝对是一个坏习惯。如果一个 TypeScript 应用中充满了 any，此时静态类型检测基本起不到任何作用，也就是说与直接使用 JavaScript 没有任何区别。<strong>因此，除非有充足的理由，否则我们应该尽量避免使用 any ，并且开启禁用隐式 any 的设置。</strong></p><h4 id="2-unknown"><a aria-hidden="true" tabindex="-1" href="/blog/type-script入门实战笔记/02.模块一type-script入门/03#2-unknown"><span class="icon icon-link"></span></a>2. unknown</h4><p>unknown 是 TypeScript 3.0 中添加的一个类型，它主要用来描述类型并不确定的变量。</p><p>比如在多个 if else 条件分支场景下，它可以用来接收不同条件下类型各异的返回值的临时变量，如下代码所示：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">let result: unknown;</span></div><div class="token-line"><span class="token plain">    if (x) {</span></div><div class="token-line"><span class="token plain">      result = x();</span></div><div class="token-line"><span class="token plain">    } else if (y) {</span></div><div class="token-line"><span class="token plain">      result = y();</span></div><div class="token-line"><span class="token plain">    } ...</span></div></pre></div><p>在 3.0 以前的版本中，只有使用 any 才能满足这种动态类型场景。</p><p>与 any 不同的是，unknown 在类型上更安全。比如我们可以将任意类型的值赋值给 unknown，但 unknown 类型的值只能赋值给 unknown 或 any，如下代码所示：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">let result: unknown;</span></div><div class="token-line"><span class="token plain">    let num: number = result; // 提示 ts(2322)</span></div><div class="token-line"><span class="token plain">    let anything: any = result; // 不会提示错误</span></div></pre></div><p>使用 unknown 后，TypeScript 会对它做类型检测。但是，如果不缩小类型（Type Narrowing），我们对 unknown 执行的任何操作都会出现如下所示错误：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">let result: unknown;</span></div><div class="token-line"><span class="token plain">    result.toFixed(); // 提示 ts(2571)</span></div></pre></div><p><strong>而所有的类型缩小手段对 unknown 都有效</strong>，如下代码所示：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">let result: unknown;</span></div><div class="token-line"><span class="token plain">    if (typeof result === &#x27;number&#x27;) {</span></div><div class="token-line"><span class="token plain">      result.toFixed(); // 此处 hover result 提示类型是 number，不会提示错误</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><h4 id="3-voidundefinednull"><a aria-hidden="true" tabindex="-1" href="/blog/type-script入门实战笔记/02.模块一type-script入门/03#3-voidundefinednull"><span class="icon icon-link"></span></a>3. void、undefined、null</h4><p>考虑再三，我们还是决定把 void、undefined 和 null “三废柴”特殊类型整合到一起介绍。</p><p>依照官方的说法，它们实际上并没有太大的用处，尤其是在本专栏中强烈推荐并要求的 strict 模式下，它们是名副其实的“废柴”。</p><p>首先我们来说一下 void 类型，它仅适用于表示没有返回值的函数。即如果该函数没有返回值，那它的类型就是 void。</p><p>在 strict 模式下，声明一个 void 类型的变量几乎没有任何实际用处，因为我们不能把 void 类型的变量值再赋值给除了 any 和 unkown 之外的任何类型变量。</p><p>然后我们说说 undefined 类型 和 null 类型，它们是 TypeScript 值与类型关键字同名的唯二例外。但这并不影响它们被称为“废柴”，因为单纯声明 undefined 或者 null 类型的变量也是无比鸡肋，示例如下所示：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">let undeclared: undefined = undefined; // 鸡肋</span></div><div class="token-line"><span class="token plain">    let nullable: null = null; // 鸡肋</span></div></pre></div><p>undefined 的最大价值主要体现在接口类型（第 7 讲会涉及）上，它表示一个可缺省、未定义的属性。</p><p>这里分享一个稍微有点费解的设计：<strong>我们可以把 undefined 值或类型是 undefined 的变量赋值给 void 类型变量，反过来，类型是 void 但值是 undefined 的变量不能赋值给 undefined 类型。</strong></p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">const userInfo: {</span></div><div class="token-line"><span class="token plain">      id?: number;</span></div><div class="token-line"><span class="token plain">    } = {};</span></div><div class="token-line"><span class="token plain">    let undeclared: undefined = undefined;</span></div><div class="token-line"><span class="token plain">    let unusable: void = undefined;</span></div><div class="token-line"><span class="token plain">    unusable = undeclared; // ok</span></div><div class="token-line"><span class="token plain">    undeclared = unusable; // ts(2322)</span></div></pre></div><p>而 null 的价值我认为主要体现在接口制定上，它表明对象或属性可能是空值。尤其是在前后端交互的接口，比如 Java Restful、Graphql，任何涉及查询的属性、对象都可能是 null 空对象，如下代码所示：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">const userInfo: {</span></div><div class="token-line"><span class="token plain">      name: null | string</span></div><div class="token-line"><span class="token plain">    } = { name: null };</span></div></pre></div><p>除此之外，undefined 和 null 类型还具备警示意义，它们可以提醒我们针对可能操作这两种（类型）值的情况做容错处理。</p><p>我们需要类型守卫（Type Guard，<strong>第 11 讲会专门讲解</strong>）在操作之前判断值的类型是否支持当前的操作。类型守卫既能通过类型缩小影响 TypeScript 的类型检测，也能保障 JavaScript 运行时的安全性，如下代码所示：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">const userInfo: {</span></div><div class="token-line"><span class="token plain">      id?: number;</span></div><div class="token-line"><span class="token plain">      name?: null | string</span></div><div class="token-line"><span class="token plain">    } = { id: 1, name: &#x27;Captain&#x27; };</span></div><div class="token-line"><span class="token plain">    if (userInfo.id !== undefined) { // Type Guard</span></div><div class="token-line"><span class="token plain">      userInfo.id.toFixed(); // id 的类型缩小成 number</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>我们不建议随意使用非空断言（下面要讲的“类型断言”中会详细介绍非空断言）来排除值可能为 null 或 undefined 的情况，因为这样很不安全。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">userInfo.id!.toFixed(); // ok，但不建议</span></div><div class="token-line"><span class="token plain">    userInfo.name!.toLowerCase() // ok，但不建议</span></div></pre></div><p>而比非空断言更安全、类型守卫更方便的做法是使用单问号（Optional Chain）、双问号（空值合并），我们可以使用它们来保障代码的安全性，如下代码所示：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">userInfo.id?.toFixed(); // Optional Chain</span></div><div class="token-line"><span class="token plain">    const myName = userInfo.name?? `my name is ${info.name}`; // 空值合并</span></div></pre></div><h4 id="4-never"><a aria-hidden="true" tabindex="-1" href="/blog/type-script入门实战笔记/02.模块一type-script入门/03#4-never"><span class="icon icon-link"></span></a>4. never</h4><p>never 表示永远不会发生值的类型，这里我们举一个实际的场景进行说明。</p><p>首先，我们定义一个统一抛出错误的函数，代码示例如下（圆括号后 : + 类型注解 表示函数返回值的类型，关于函数类型我们会在后续 <strong>“第 5 讲：函数类型”详细讲解</strong>）：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">function ThrowError(msg: string): never {</span></div><div class="token-line"><span class="token plain">      throw Error(msg);</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>以上函数因为永远不会有返回值，所以它的返回值类型就是 never。</p><p>同样，如果函数代码中是一个死循环，那么这个函数的返回值类型也是 never，如下代码所示。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">function InfiniteLoop(): never {</span></div><div class="token-line"><span class="token plain">      while (true) {}</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>never 是所有类型的子类型，它可以给所有类型赋值，如下代码所示。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">let Unreachable: never = 1; // ts(2322)</span></div><div class="token-line"><span class="token plain">    Unreachable = &#x27;string&#x27;; // ts(2322)</span></div><div class="token-line"><span class="token plain">    Unreachable = true; // ts(2322)</span></div><div class="token-line"><span class="token plain">    let num: number = Unreachable; // ok</span></div><div class="token-line"><span class="token plain">    let str: string = Unreachable; // ok</span></div><div class="token-line"><span class="token plain">    let bool: boolean = Unreachable; // ok</span></div></pre></div><p>但是反过来，除了 never 自身以外，其他类型（包括 any 在内的类型）都不能为 never 类型赋值。</p><p>在恒为 false 的类型守卫条件判断下，变量的类型将缩小为 never（never 是所有其他类型的子类型，所以是类型缩小为 never，而不是变成 never）。因此，条件判断中的相关操作始终会报无法更正的错误（我们可以把这理解为一种基于静态类型检测的 Dead Code 检测机制），如下代码所示：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">const str: string = &#x27;string&#x27;;</span></div><div class="token-line"><span class="token plain">    if (typeof str === &#x27;number&#x27;) {</span></div><div class="token-line"><span class="token plain">      str.toLowerCase(); // Property &#x27;toLowerCase&#x27; does not exist on type &#x27;never&#x27;.ts(2339)</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>基于 never 的特性，我们还可以使用 never 实现一些有意思的功能。比如我们可以把 never 作为接口类型下的属性类型，用来禁止写接口下特定的属性，示例代码如下：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">const props: {</span></div><div class="token-line"><span class="token plain">      id: number,</span></div><div class="token-line"><span class="token plain">      name?: never</span></div><div class="token-line"><span class="token plain">    } = {</span></div><div class="token-line"><span class="token plain">      id: 1</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    props.name = null; // ts(2322))</span></div><div class="token-line"><span class="token plain">    props.name = &#x27;str&#x27;; // ts(2322)</span></div><div class="token-line"><span class="token plain">    props.name = 1; // ts(2322)</span></div></pre></div><p>此时，无论我们给 props.name 赋什么类型的值，它都会提示类型错误，实际效果等同于 name 只读 。</p><h4 id="5-object"><a aria-hidden="true" tabindex="-1" href="/blog/type-script入门实战笔记/02.模块一type-script入门/03#5-object"><span class="icon icon-link"></span></a>5. object</h4><p>object 类型表示非原始类型的类型，即非 number、string、boolean、bigint、symbol、null、undefined 的类型。然而，它也是个没有什么用武之地的类型，如下所示的一个应用场景是用来表示 Object.create 的类型。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">declare function create(o: object | null): any;</span></div><div class="token-line"><span class="token plain">    create({}); // ok</span></div><div class="token-line"><span class="token plain">    create(() =&gt; null); // ok</span></div><div class="token-line"><span class="token plain">    create(2); // ts(2345)</span></div><div class="token-line"><span class="token plain">    create(&#x27;string&#x27;); // ts(2345)</span></div></pre></div><h3 id="类型断言type-assertion"><a aria-hidden="true" tabindex="-1" href="/blog/type-script入门实战笔记/02.模块一type-script入门/03#类型断言type-assertion"><span class="icon icon-link"></span></a>类型断言（Type Assertion）</h3><p>TypeScript 类型检测无法做到绝对智能，毕竟程序不能像人一样思考。有时会碰到我们比 TypeScript 更清楚实际类型的情况，比如下面的例子：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">const arrayNumber: number[] = [1, 2, 3, 4];</span></div><div class="token-line"><span class="token plain">    const greaterThan2: number = arrayNumber.find(num =&gt; num &gt; 2); // 提示 ts(2322)</span></div></pre></div><p>其中，greaterThan2 一定是一个数字（确切地讲是 3），因为 arrayNumber 中明显有大于 2 的成员，但静态类型对运行时的逻辑无能为力。</p><p>在 TypeScript 看来，greaterThan2 的类型既可能是数字，也可能是 undefined，所以上面的示例中提示了一个 ts(2322) 错误，此时我们不能把类型 undefined 分配给类型 number。</p><p>不过，我们可以使用一种笃定的方式——<strong>类型断言</strong>（类似仅作用在类型层面的强制类型转换）告诉 TypeScript 按照我们的方式做类型检查。</p><p>比如，我们可以使用 as 语法做类型断言，如下代码所示：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">const arrayNumber: number[] = [1, 2, 3, 4];</span></div><div class="token-line"><span class="token plain">    const greaterThan2: number = arrayNumber.find(num =&gt; num &gt; 2) as number;</span></div></pre></div><p>又或者是使用尖括号 + 类型的格式做类型断言，如下代码所示：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">const arrayNumber: number[] = [1, 2, 3, 4];</span></div><div class="token-line"><span class="token plain">    const greaterThan2: number = &lt;number&gt;arrayNumber.find(num =&gt; num &gt; 2);</span></div></pre></div><p>以上两种方式虽然没有任何区别，但是尖括号格式会与 JSX 产生语法冲突，因此我们更推荐使用 as 语法。</p><blockquote><p>注意：类型断言的操作对象必须满足某些约束关系，否则我们将得到一个 ts(2352) 错误，即从类型“源类型”到类型“目标类型”的转换是错误的，因为这两种类型不能充分重叠。</p></blockquote><p>我一度喜欢用“指鹿为马”来形容类型断言，但其实也不够准确。</p><p>从物种类型上看，鹿和马肯定不能转换，虽然它们都是动物（继承自同一个父类），但是鹿有“角属性”，马有“鬃毛属性”，所以两者不能充分重叠。</p><p><strong>如果我们把它换成“指白马为马”“指马为白马”，就可以很贴切地体现类型断言的约束条件：父子、子父类型之间可以使用类型断言进行转换。</strong></p><blockquote><p><strong>注意</strong>：这个结论完全适用于复杂类型，但是对于 number、string、boolean 原始类型来说，不仅父子类型可以相互断言，父类型相同的类型也可以相互断言，比如 1 as 2、&#x27;a&#x27; as &#x27;b&#x27;、true as false（这里的 2、&#x27;b&#x27;、false 被称之为字面量类型，在第 4 讲里会详细介绍），反过来 2 as 1、&#x27;b&#x27; as &#x27;a&#x27;、false as true 也是被允许的（这里的 1、&#x27;a&#x27;、true 是字面量类型），尽管这样的断言没有任何意义。</p></blockquote><p>另外，any 和 unknown 这两个特殊类型属于万金油，因为它们既可以被断言成任何类型，反过来任何类型也都可以被断言成 any 或 unknown。因此，如果我们想强行“指鹿为马”，就可以先把“鹿”断言为 any 或 unknown，然后再把 any 和 unknown 断言为“马”，比如鹿 as any as 马。</p><p>我们除了可以把特定类型断言成符合约束添加的其他类型之外，还可以使用“字面量值 + as const”语法结构进行常量断言，具体示例如下所示：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">/** str 类型是 &#x27;&quot;str&quot;&#x27; */</span></div><div class="token-line"><span class="token plain">    let str = &#x27;str&#x27; as const;</span></div><div class="token-line"><span class="token plain">    /** readOnlyArr 类型是 &#x27;readonly [0, 1]&#x27; */</span></div><div class="token-line"><span class="token plain">    const readOnlyArr = [0, 1] as const;</span></div></pre></div><p>常量断言所涉及的字面量（字面量即代码中，比如 &#x27;&quot;str&quot;&#x27;、&#x27;1&#x27;、&#x27;true&#x27;、&#x27;<!-- -->{<!-- -->}<!-- -->&#x27;）与字面量类型相关的知识点将在 <strong>“第 03 讲：字面量类型”</strong> 中详细讲解，这里我们就不对实例代码做原理解析了。你可以保持着好奇心，期待后续内容。</p><p>此外还有一种特殊非空断言，即在值（变量、属性）的后边添加 &#x27;!&#x27; 断言操作符，它可以用来排除值为 null、undefined 的情况，具体示例如下：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">let mayNullOrUndefinedOrString: null | undefined | string;</span></div><div class="token-line"><span class="token plain">    mayNullOrUndefinedOrString!.toString(); // ok</span></div><div class="token-line"><span class="token plain">    mayNullOrUndefinedOrString.toString(); // ts(2531)</span></div></pre></div><p>对于非空断言来说，我们同样应该把它视作和 any 一样危险的选择。</p><p>在复杂应用场景中，如果我们使用非空断言，就无法保证之前一定非空的值，比如页面中一定存在 id 为 feedback 的元素，数组中一定有满足 &gt; 2 条件的数字，这些都不会被其他人改变。而一旦保证被改变，错误只会在运行环境中抛出，而静态类型检测是发现不了这些错误的。</p><p>所以，我们建议使用类型守卫（更多讲解，见“第 11 讲：类型守卫”）来代替非空断言，比如如下所示的条件判断：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">let mayNullOrUndefinedOrString: null | undefined | string;</span></div><div class="token-line"><span class="token plain">    if (typeof mayNullOrUndefinedOrString === &#x27;string&#x27;) {</span></div><div class="token-line"><span class="token plain">      mayNullOrUndefinedOrString.toString(); // ok</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><h3 id="小结与预告"><a aria-hidden="true" tabindex="-1" href="/blog/type-script入门实战笔记/02.模块一type-script入门/03#小结与预告"><span class="icon icon-link"></span></a>小结与预告</h3><p>到这里，TypeScript 所有的基础类型就交代完了，你需要反复消化，夯实基础，为 04讲将要接触的稍微复杂的类型和应用场景做好准备。</p><p>这里插播一个思考题：类型断言需要满足什么约束条件？欢迎你在留言区与我进行互动、交流。另外，如果你觉得本专栏有价值，欢迎分享给更多的好友哦~</p></div><div class="__dumi-default-layout-footer-meta"><a target="_blank" rel="noopener noreferrer" href="https://github.com/GGwujun/blog/edit/master/docs/type-script入门实战笔记/02.模块一TypeScript入门/03.md">在 GitHub 上编辑此页<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a><span data-updated-text="最后更新时间：">5/2/2022 10:56:52</span></div></div></div></div>
	<script>
  window.g_useSSR = true;
  window.g_initialProps = {};
	</script>

    <script>
      (function () {
        if (!location.port) {
          (function (i, s, o, g, r, a, m) {
            i["GoogleAnalyticsObject"] = r;
            (i[r] =
              i[r] ||
              function () {
                (i[r].q = i[r].q || []).push(arguments);
              }),
              (i[r].l = 1 * new Date());
            (a = s.createElement(o)), (m = s.getElementsByTagName(o)[0]);
            a.async = 1;
            a.src = g;
            m.parentNode.insertBefore(a, m);
          })(
            window,
            document,
            "script",
            "//www.google-analytics.com/analytics.js",
            "ga"
          );
          ga("create", "UA-149864185-1", "auto");
          ga("send", "pageview");
        }
      })();
    </script>
    <script src="/blog/umi.js"></script>
  </body>
</html>
