<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no"
    />
    <link rel="shortcut icon" type="image/x-icon" href="/logo.png" />
    <link rel="stylesheet" href="/blog/umi.css" />
    <script>
      window.routerBase = "/blog";
    </script>
    <script>
      //! umi version: 3.5.17
    </script>
    <script>
      !(function () {
        var e = localStorage.getItem("dumi:prefers-color"),
          t = window.matchMedia("(prefers-color-scheme: dark)").matches,
          r = ["light", "dark", "auto"];
        document.documentElement.setAttribute(
          "data-prefers-color",
          e === r[2] ? (t ? r[1] : r[0]) : r.indexOf(e) > -1 ? e : r[0]
        );
      })();
    </script>
    <title>08 | 高级类型：如何快速读懂联合类型和交叉类型的含义？</title>
  </head>
  <body>
    <div id="root"><div class="__dumi-default-layout" data-route="/type-script入门实战笔记/02.模块一type-script入门/08" data-show-sidemenu="true" data-show-slugs="true" data-site-mode="true" data-gapless="false"><div class="__dumi-default-navbar" data-mode="site"><button class="__dumi-default-navbar-toggle"></button><a class="__dumi-default-navbar-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog/">大师兄</a><nav><div class="__dumi-default-search"><input type="search" class="__dumi-default-search-input" value=""/><ul></ul></div><span>计算机基础<ul><li><a href="/blog/编译原理之美">编译原理之美</a></li><li><a href="/blog/编译原理实战">编译原理实战</a></li><li><a href="/blog/深入浅出计算机组成原理">深入浅出计算机组成原理</a></li><li><a href="/blog/详解http">详解http</a></li><li><a href="/blog/计算机网络通关29讲">计算机网络通关29讲</a></li><li><a href="/blog/网络排查案例课">网络排查案例课</a></li><li><a href="/blog/linux操作系统">linux操作系统</a></li><li><a href="/blog/linux性能优化实战">linux性能优化实战</a></li><li><a href="/blog/程序员数学基础">程序员数学基础</a></li><li><a href="/blog/趣谈网络协议">趣谈网络协议</a></li><li><a href="/blog/操作系统实战">操作系统实战</a></li><li><a href="/blog/软件工程之美">软件工程之美</a></li><li><a href="/blog/sql必知必会">sql必知必会</a></li><li><a href="/blog/操作系统实战45讲">操作系统实战45讲</a></li><li><a href="/blog/网络编程实战">网络编程实战</a></li></ul></span><span>算法<ul><li><a href="/blog/常用算法25讲">常用算法25讲</a></li><li><a href="/blog/数据结构与算法之美">数据结构与算法之美</a></li><li><a href="/blog/业务开发算法50讲">业务开发算法50讲</a></li><li><a href="/blog/动态规划面试宝典">动态规划面试宝典</a></li></ul></span><span>前端开发<ul><li><a href="/blog/浏览器工作原理与实践">浏览器工作原理与实践</a></li><li><a href="/blog/新时代产品经理进阶之路">新时代产品经理进阶之路</a></li><li><a href="/blog/全栈工程师修炼指南">全栈工程师修炼指南</a></li><li><a href="/blog/flutter核心技术与实战">flutter核心技术与实战</a></li><li><a href="/blog/java-script核心原理解析">java-script核心原理解析</a></li><li><a href="/blog/说透低代码">说透低代码</a></li><li><a href="/blog/nodejs应用开发实战">nodejs应用开发实战</a></li><li><a href="/blog/反爬虫兵法演绎20讲">反爬虫兵法演绎20讲</a></li><li><a href="/blog/reactnative新架构实战课">reactnative新架构实战课</a></li><li><a href="/blog/正则表达式入门">正则表达式入门</a></li><li><a href="/blog/重学前端">重学前端</a></li><li><a href="/blog/serverless入门课">serverless入门课</a></li><li><a aria-current="page" class="active" href="/blog/type-script入门实战笔记">type-script入门实战笔记</a></li><li><a href="/blog/图解googlev8">图解googlev8</a></li><li><a href="/blog/vue3源码分析">vue3源码分析</a></li><li><a href="/blog/玩转Vue3全家桶">玩转Vue3全家桶</a></li><li><a href="/blog/webassembly入门">webassembly入门</a></li><li><a href="/blog/手把手带你写一个Web框架">手把手带你写一个Web框架</a></li><li><a href="/blog/web漏洞挖掘实战">web漏洞挖掘实战</a></li><li><a href="/blog/跟月影学可视化">跟月影学可视化</a></li><li><a href="/blog/搞定音频技术">搞定音频技术</a></li><li><a href="/blog/攻克视频技术">攻克视频技术</a></li></ul></span><span>前端工程化<ul><li><a href="/blog/logger">logger</a></li><li><a href="/blog/webpack">webpack</a></li><li><a href="/blog/webpackChain">webpackChain</a></li></ul></span><span>前端性能优化<ul><li><a href="/blog/react性能调优">react性能调优</a></li></ul></span><span>软件测试<ul><li><a href="/blog/全链路压测实战30讲">全链路压测实战30讲</a></li><li><a href="/blog/性能测试实战30讲">性能测试实战30讲</a></li><li><a href="/blog/自动化测试高手课">自动化测试高手课</a></li><li><a href="/blog/软件测试52讲">软件测试52讲</a></li></ul></span><span>面试<ul><li><a href="/blog/面试现场">面试现场</a></li></ul></span><span>杂谈<ul><li><a href="/blog/超级访谈对话张雪峰">超级访谈对话张雪峰</a></li><li><a href="/blog/Git实战手册">Git实战手册</a></li><li><a href="/blog/NodeJS">NodeJS</a></li><li><a href="/blog/ReactJS">ReactJS</a></li><li><a href="/blog/UI设计">UI设计</a></li><li><a href="/blog/webpack4系列教程">webpack4系列教程</a></li><li><a href="/blog/前端知识体系">前端知识体系</a></li><li><a href="/blog/剑指offer刷题笔记">剑指offer刷题笔记</a></li><li><a href="/blog/思考与成长">思考与成长</a></li><li><a href="/blog/设计模式手册">设计模式手册</a></li></ul></span><div class="__dumi-default-navbar-tool"><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "></div></div></div></nav></div><div class="__dumi-default-menu" data-mode="site"><div class="__dumi-default-menu-inner"><div class="__dumi-default-menu-header"><a class="__dumi-default-menu-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog/"></a><h1>大师兄</h1><p></p></div><div class="__dumi-default-menu-mobile-area"><ul class="__dumi-default-menu-nav-list"><li>计算机基础<ul><li><a href="/blog/编译原理之美">编译原理之美</a></li><li><a href="/blog/编译原理实战">编译原理实战</a></li><li><a href="/blog/深入浅出计算机组成原理">深入浅出计算机组成原理</a></li><li><a href="/blog/详解http">详解http</a></li><li><a href="/blog/计算机网络通关29讲">计算机网络通关29讲</a></li><li><a href="/blog/网络排查案例课">网络排查案例课</a></li><li><a href="/blog/linux操作系统">linux操作系统</a></li><li><a href="/blog/linux性能优化实战">linux性能优化实战</a></li><li><a href="/blog/程序员数学基础">程序员数学基础</a></li><li><a href="/blog/趣谈网络协议">趣谈网络协议</a></li><li><a href="/blog/操作系统实战">操作系统实战</a></li><li><a href="/blog/软件工程之美">软件工程之美</a></li><li><a href="/blog/sql必知必会">sql必知必会</a></li><li><a href="/blog/操作系统实战45讲">操作系统实战45讲</a></li><li><a href="/blog/网络编程实战">网络编程实战</a></li></ul></li><li>算法<ul><li><a href="/blog/常用算法25讲">常用算法25讲</a></li><li><a href="/blog/数据结构与算法之美">数据结构与算法之美</a></li><li><a href="/blog/业务开发算法50讲">业务开发算法50讲</a></li><li><a href="/blog/动态规划面试宝典">动态规划面试宝典</a></li></ul></li><li>前端开发<ul><li><a href="/blog/浏览器工作原理与实践">浏览器工作原理与实践</a></li><li><a href="/blog/新时代产品经理进阶之路">新时代产品经理进阶之路</a></li><li><a href="/blog/全栈工程师修炼指南">全栈工程师修炼指南</a></li><li><a href="/blog/flutter核心技术与实战">flutter核心技术与实战</a></li><li><a href="/blog/java-script核心原理解析">java-script核心原理解析</a></li><li><a href="/blog/说透低代码">说透低代码</a></li><li><a href="/blog/nodejs应用开发实战">nodejs应用开发实战</a></li><li><a href="/blog/反爬虫兵法演绎20讲">反爬虫兵法演绎20讲</a></li><li><a href="/blog/reactnative新架构实战课">reactnative新架构实战课</a></li><li><a href="/blog/正则表达式入门">正则表达式入门</a></li><li><a href="/blog/重学前端">重学前端</a></li><li><a href="/blog/serverless入门课">serverless入门课</a></li><li><a aria-current="page" class="active" href="/blog/type-script入门实战笔记">type-script入门实战笔记</a></li><li><a href="/blog/图解googlev8">图解googlev8</a></li><li><a href="/blog/vue3源码分析">vue3源码分析</a></li><li><a href="/blog/玩转Vue3全家桶">玩转Vue3全家桶</a></li><li><a href="/blog/webassembly入门">webassembly入门</a></li><li><a href="/blog/手把手带你写一个Web框架">手把手带你写一个Web框架</a></li><li><a href="/blog/web漏洞挖掘实战">web漏洞挖掘实战</a></li><li><a href="/blog/跟月影学可视化">跟月影学可视化</a></li><li><a href="/blog/搞定音频技术">搞定音频技术</a></li><li><a href="/blog/攻克视频技术">攻克视频技术</a></li></ul></li><li>前端工程化<ul><li><a href="/blog/logger">logger</a></li><li><a href="/blog/webpack">webpack</a></li><li><a href="/blog/webpackChain">webpackChain</a></li></ul></li><li>前端性能优化<ul><li><a href="/blog/react性能调优">react性能调优</a></li></ul></li><li>软件测试<ul><li><a href="/blog/全链路压测实战30讲">全链路压测实战30讲</a></li><li><a href="/blog/性能测试实战30讲">性能测试实战30讲</a></li><li><a href="/blog/自动化测试高手课">自动化测试高手课</a></li><li><a href="/blog/软件测试52讲">软件测试52讲</a></li></ul></li><li>面试<ul><li><a href="/blog/面试现场">面试现场</a></li></ul></li><li>杂谈<ul><li><a href="/blog/超级访谈对话张雪峰">超级访谈对话张雪峰</a></li><li><a href="/blog/Git实战手册">Git实战手册</a></li><li><a href="/blog/NodeJS">NodeJS</a></li><li><a href="/blog/ReactJS">ReactJS</a></li><li><a href="/blog/UI设计">UI设计</a></li><li><a href="/blog/webpack4系列教程">webpack4系列教程</a></li><li><a href="/blog/前端知识体系">前端知识体系</a></li><li><a href="/blog/剑指offer刷题笔记">剑指offer刷题笔记</a></li><li><a href="/blog/思考与成长">思考与成长</a></li><li><a href="/blog/设计模式手册">设计模式手册</a></li></ul></li></ul><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "><button title="Dark theme" class="__dumi-default-dark-moon "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="3854" width="22" height="22"><path d="M991.816611 674.909091a69.166545 69.166545 0 0 0-51.665455-23.272727 70.795636 70.795636 0 0 0-27.438545 5.585454A415.674182 415.674182 0 0 1 754.993338 698.181818c-209.594182 0-393.472-184.785455-393.472-395.636363 0-52.363636 38.539636-119.621818 69.515637-173.614546 4.887273-8.610909 9.634909-16.756364 14.103272-24.901818A69.818182 69.818182 0 0 0 384.631156 0a70.842182 70.842182 0 0 0-27.438545 5.585455C161.678429 90.298182 14.362065 307.898182 14.362065 512c0 282.298182 238.824727 512 532.38691 512a522.286545 522.286545 0 0 0 453.957818-268.334545A69.818182 69.818182 0 0 0 991.816611 674.909091zM546.679156 954.181818c-248.785455 0-462.941091-192-462.941091-442.181818 0-186.647273 140.637091-372.829091 300.939637-442.181818-36.817455 65.629091-92.578909 151.970909-92.578909 232.727273 0 250.181818 214.109091 465.454545 462.917818 465.454545a488.331636 488.331636 0 0 0 185.181091-46.545455 453.003636 453.003636 0 0 1-393.565091 232.727273z m103.656728-669.323636l-14.266182 83.781818a34.909091 34.909091 0 0 0 50.362182 36.770909l74.775272-39.563636 74.752 39.563636a36.142545 36.142545 0 0 0 16.174546 3.956364 34.909091 34.909091 0 0 0 34.210909-40.727273l-14.289455-83.781818 60.509091-59.345455a35.025455 35.025455 0 0 0-19.223272-59.578182l-83.61891-12.101818-37.376-76.101818a34.56 34.56 0 0 0-62.254545 0l-37.376 76.101818-83.618909 12.101818a34.909091 34.909091 0 0 0-19.246546 59.578182z m70.423272-64.698182a34.280727 34.280727 0 0 0 26.135273-19.083636l14.312727-29.090909 14.336 29.090909a34.257455 34.257455 0 0 0 26.135273 19.083636l32.046546 4.887273-23.272728 22.574545a35.234909 35.234909 0 0 0-10.007272 30.952727l5.46909 32.116364-28.625454-15.127273a34.490182 34.490182 0 0 0-32.302546 0l-28.695272 15.127273 5.469091-32.116364a35.141818 35.141818 0 0 0-9.984-30.952727l-23.272728-22.574545z" p-id="3855"></path></svg></button><button title="Light theme" class="__dumi-default-dark-sun "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="4026" width="22" height="22"><path d="M915.2 476.16h-43.968c-24.704 0-44.736 16-44.736 35.84s20.032 35.904 44.736 35.904H915.2c24.768 0 44.8-16.064 44.8-35.904s-20.032-35.84-44.8-35.84zM512 265.6c-136.704 0-246.464 109.824-246.464 246.4 0 136.704 109.76 246.464 246.464 246.464S758.4 648.704 758.4 512c0-136.576-109.696-246.4-246.4-246.4z m0 425.6c-99.008 0-179.2-80.128-179.2-179.2 0-98.944 80.192-179.2 179.2-179.2S691.2 413.056 691.2 512c0 99.072-80.192 179.2-179.2 179.2zM197.44 512c0-19.84-19.136-35.84-43.904-35.84H108.8c-24.768 0-44.8 16-44.8 35.84s20.032 35.904 44.8 35.904h44.736c24.768 0 43.904-16.064 43.904-35.904zM512 198.464c19.776 0 35.84-20.032 35.84-44.8v-44.8C547.84 84.032 531.84 64 512 64s-35.904 20.032-35.904 44.8v44.8c0 24.768 16.128 44.864 35.904 44.864z m0 627.136c-19.776 0-35.904 20.032-35.904 44.8v44.736C476.096 940.032 492.16 960 512 960s35.84-20.032 35.84-44.8v-44.736c0-24.768-16.064-44.864-35.84-44.864z m329.92-592.832c17.472-17.536 20.288-43.072 6.4-57.024-14.016-14.016-39.488-11.2-57.024 6.336-4.736 4.864-26.496 26.496-31.36 31.36-17.472 17.472-20.288 43.008-6.336 57.024 13.952 14.016 39.488 11.2 57.024-6.336 4.8-4.864 26.496-26.56 31.296-31.36zM213.376 759.936c-4.864 4.8-26.56 26.624-31.36 31.36-17.472 17.472-20.288 42.944-6.4 56.96 14.016 13.952 39.552 11.2 57.024-6.336 4.8-4.736 26.56-26.496 31.36-31.36 17.472-17.472 20.288-43.008 6.336-56.96-14.016-13.952-39.552-11.072-56.96 6.336z m19.328-577.92c-17.536-17.536-43.008-20.352-57.024-6.336-14.08 14.016-11.136 39.488 6.336 57.024 4.864 4.864 26.496 26.56 31.36 31.424 17.536 17.408 43.008 20.288 56.96 6.336 14.016-14.016 11.264-39.488-6.336-57.024-4.736-4.864-26.496-26.56-31.296-31.424z m527.168 628.608c4.864 4.864 26.624 26.624 31.36 31.424 17.536 17.408 43.072 20.224 57.088 6.336 13.952-14.016 11.072-39.552-6.4-57.024-4.864-4.8-26.56-26.496-31.36-31.36-17.472-17.408-43.072-20.288-57.024-6.336-13.952 14.016-11.008 39.488 6.336 56.96z" p-id="4027"></path></svg></button><button title="Default to system" class="__dumi-default-dark-auto "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="11002" width="22" height="22"><path d="M127.658667 492.885333c0-51.882667 10.24-101.717333 30.378666-149.162666s47.786667-88.064 81.92-122.538667 75.093333-61.781333 122.538667-81.92 96.938667-30.378667 149.162667-30.378667 101.717333 10.24 149.162666 30.378667 88.405333 47.786667 122.88 81.92 61.781333 75.093333 81.92 122.538667 30.378667 96.938667 30.378667 149.162666-10.24 101.717333-30.378667 149.162667-47.786667 88.405333-81.92 122.88-75.093333 61.781333-122.88 81.92-97.28 30.378667-149.162666 30.378667-101.717333-10.24-149.162667-30.378667-88.064-47.786667-122.538667-81.92-61.781333-75.093333-81.92-122.88-30.378667-96.938667-30.378666-149.162667z m329.045333 0c0 130.048 13.994667 244.394667 41.984 343.381334h12.970667c46.762667 0 91.136-9.216 133.461333-27.306667s78.848-42.666667 109.568-73.386667 54.954667-67.242667 73.386667-109.568 27.306667-86.698667 27.306666-133.461333c0-46.421333-9.216-90.794667-27.306666-133.12s-42.666667-78.848-73.386667-109.568-67.242667-54.954667-109.568-73.386667-86.698667-27.306667-133.461333-27.306666h-11.605334c-28.672 123.562667-43.349333 237.909333-43.349333 343.722666z" p-id="11003"></path></svg></button></div></div></div><ul class="__dumi-default-menu-list"><li><a href="/blog/type-script入门实战笔记">type-script入门实战笔记</a></li><li><a href="/blog/type-script入门实战笔记/01.开篇词">01.开篇词</a><ul><li><a href="/blog/type-script入门实战笔记/01.开篇词/01"><span>开篇词 | 你为什么要选择 TypeScript？</span></a></li></ul></li><li><a aria-current="page" class="active" href="/blog/type-script入门实战笔记/02.模块一type-script入门">02.模块一TypeScript入门</a><ul><li><a href="/blog/type-script入门实战笔记/02.模块一type-script入门/01"><span>01 | 如何快速搭建 TypeScript 学习开发环境？</span></a></li><li><a href="/blog/type-script入门实战笔记/02.模块一type-script入门/02"><span>02 | 简单基础类型：TypeScript 与 JavaScript 有何不同？</span></a></li><li><a href="/blog/type-script入门实战笔记/02.模块一type-script入门/03"><span>03 | 复杂基础类型：TypeScript 与 JavaScript 有何不同？</span></a></li><li><a href="/blog/type-script入门实战笔记/02.模块一type-script入门/04"><span>04 | 什么是字面量类型、类型推断、类型拓宽和类型缩小？</span></a></li><li><a href="/blog/type-script入门实战笔记/02.模块一type-script入门/05"><span>05 | 函数类型：返回值类型和参数类型到底如何定义？</span></a></li><li><a href="/blog/type-script入门实战笔记/02.模块一type-script入门/06"><span>06 | 类类型：如何高效使用类型化的面向对象编程利器？</span></a></li><li><a href="/blog/type-script入门实战笔记/02.模块一type-script入门/07"><span>07 | 接口类型与类型别名：这两者的用法与区别分别是什么？</span></a></li><li><a aria-current="page" class="active" href="/blog/type-script入门实战笔记/02.模块一type-script入门/08"><span>08 | 高级类型：如何快速读懂联合类型和交叉类型的含义？</span></a></li><li><a href="/blog/type-script入门实战笔记/02.模块一type-script入门/09"><span>09 | 枚举类型：详解常见枚举类型的 7 种用法</span></a></li><li><a href="/blog/type-script入门实战笔记/02.模块一type-script入门/10"><span>10 | 泛型：如何正确使用泛型约束类型变量？</span></a></li></ul></li><li><a href="/blog/type-script入门实战笔记/03.模块二type-script进阶">03.模块二TypeScript进阶</a><ul><li><a href="/blog/type-script入门实战笔记/03.模块二type-script进阶/01"><span>11 | 类型守卫：如何有效地保障类型的安全性？</span></a></li><li><a href="/blog/type-script入门实战笔记/03.模块二type-script进阶/02"><span>12 | 类型兼容：如何判断一个类型是否可以赋值给其他类型？</span></a></li><li><a href="/blog/type-script入门实战笔记/03.模块二type-script进阶/03"><span>13 | 必备增强类型系统的方式大盘点，让你的开发如虎添翼</span></a></li><li><a href="/blog/type-script入门实战笔记/03.模块二type-script进阶/04"><span>14 | 掌握 TypeScript 这些官方工具类型，让你的开发事半功倍</span></a></li><li><a href="/blog/type-script入门实战笔记/03.模块二type-script进阶/05"><span>15 | 类型编程：如何打造属于自己的工具类型？</span></a></li></ul></li><li><a href="/blog/type-script入门实战笔记/04.模块三实战指南">04.模块三实战指南</a><ul><li><a href="/blog/type-script入门实战笔记/04.模块三实战指南/01"><span>16 | tsconfig.json 配置：如何定制 TypeScript 的行为？</span></a></li><li><a href="/blog/type-script入门实战笔记/04.模块三实战指南/02"><span>17 | 来自 100 +项目经历的常见 TypeScript 错误汇总分析</span></a></li><li><a href="/blog/type-script入门实战笔记/04.模块三实战指南/03"><span>18 | 手把手教你使用 TypeScript 开发 Node.js 应用</span></a></li><li><a href="/blog/type-script入门实战笔记/04.模块三实战指南/04"><span>19 | 使用 TypeScript 开发 Web 应用的最佳实践</span></a></li><li><a href="/blog/type-script入门实战笔记/04.模块三实战指南/05"><span>20 | 如何将 JavaScript 应用切换至 TypeScript？</span></a></li></ul></li><li><a href="/blog/type-script入门实战笔记/05.结束语">05.结束语</a><ul><li><a href="/blog/type-script入门实战笔记/05.结束语/01"><span>结束语 | TypeScript 的这些实用技能，你不得不知</span></a></li></ul></li><li><a href="/blog/type-script入门实战笔记/summary">type-script入门实战笔记</a></li></ul></div></div><ul role="slug-list" class="__dumi-default-layout-toc"><li title="联合类型" data-depth="3"><a href="/blog/type-script入门实战笔记/02.模块一type-script入门/08#联合类型"><span>联合类型</span></a></li><li title="交叉类型" data-depth="3"><a href="/blog/type-script入门实战笔记/02.模块一type-script入门/08#交叉类型"><span>交叉类型</span></a></li><li title="联合、交叉组合" data-depth="3"><a href="/blog/type-script入门实战笔记/02.模块一type-script入门/08#联合交叉组合"><span>联合、交叉组合</span></a></li><li title="类型缩减" data-depth="3"><a href="/blog/type-script入门实战笔记/02.模块一type-script入门/08#类型缩减"><span>类型缩减</span></a></li><li title="小结与预告" data-depth="3"><a href="/blog/type-script入门实战笔记/02.模块一type-script入门/08#小结与预告"><span>小结与预告</span></a></li></ul><div class="__dumi-default-layout-content"><div class="markdown"><h1 id="08--高级类型如何快速读懂联合类型和交叉类型的含义"><a aria-hidden="true" tabindex="-1" href="/blog/type-script入门实战笔记/02.模块一type-script入门/08#08--高级类型如何快速读懂联合类型和交叉类型的含义"><span class="icon icon-link"></span></a>08 | 高级类型：如何快速读懂联合类型和交叉类型的含义？</h1><p>在前边课程中，我们介绍了基础类型、字面量类型、函数类型及接口类型等内容，它们都是单一、原子的类型元素。其实，如前边课程中一些稍微复杂、实际编程场景的示例所示，我们还需要通过组合/结合单一、原子类型构造更复杂的类型，以此描述更复杂的数据和结构。这就是这一讲中将介绍的内容——联合和交叉类型（Unions and Intersection Types）。</p><blockquote><p><strong>学习建议</strong>：请使用 VS Code 新建一个 08.ts 文件，并尝试这一讲中涉及的所有示例。</p></blockquote><h3 id="联合类型"><a aria-hidden="true" tabindex="-1" href="/blog/type-script入门实战笔记/02.模块一type-script入门/08#联合类型"><span class="icon icon-link"></span></a>联合类型</h3><p>联合类型（Unions）用来表示变量、参数的类型不是单一原子类型，而可能是多种不同的类型的组合。</p><p>我们主要通过“|”操作符分隔类型的语法来表示联合类型。这里，我们可以把“|”类比为 JavaScript 中的逻辑或 “||”，只不过前者表示可能的类型。</p><p>举个例子，我们封装了一个将 string 或者 number 类型的输入值转换成 &#x27;数字 + &quot;px&quot; 格式的函数，如下代码所示：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">function formatPX(size: unknown) {</span></div><div class="token-line"><span class="token plain">      if (typeof size === &#x27;number&#x27;) {</span></div><div class="token-line"><span class="token plain">        return `${size}px`;</span></div><div class="token-line"><span class="token plain">      }</span></div><div class="token-line"><span class="token plain">      if (typeof size === &#x27;string&#x27;) {</span></div><div class="token-line"><span class="token plain">        return `${parseInt(size) || 0}px`;</span></div><div class="token-line"><span class="token plain">      }</span></div><div class="token-line"><span class="token plain">      throw Error(` 仅支持 number 或者 string`);</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    formatPX(13);</span></div><div class="token-line"><span class="token plain">    formatPX(&#x27;13px&#x27;);</span></div></pre></div><p><strong>说明：在学习联合类型之前，我们可能免不了使用 any 或 unknown 类型来表示参数的类型（为了让大家养成好习惯，推荐使用 unknown）。</strong></p><p>通过这样的方式带来的问题是，在调用 formatPX 时，我们可以传递任意的值，并且可以通过静态类型检测（使用 any 亦如是），但是运行时还是会抛出一个错误，例如：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">formatPX(true);</span></div><div class="token-line"><span class="token plain">    formatPX(null);</span></div></pre></div><p>这显然不符合我们的预期，因为 size 应该是更明确的，即可能也只可能是 number 或 string 这两种可选类型的类型。</p><p>所幸有联合类型，我们可以使用一个更明确表示<strong>可能是 number 或 string 的联合类型</strong>来注解 size 参数，如下代码所示：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">function formatPX(size: number | string) {</span></div><div class="token-line"><span class="token plain">      // ...</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    formatPX(13); // ok</span></div><div class="token-line"><span class="token plain">    formatPX(&#x27;13px&#x27;); // ok</span></div><div class="token-line"><span class="token plain">    formatPX(true); // ts(2345) &#x27;true&#x27; 类型不能赋予 &#x27;number | string&#x27; 类型</span></div><div class="token-line"><span class="token plain">    formatPX(null); // ts(2345) &#x27;null&#x27; 类型不能赋予 &#x27;number | string&#x27; 类型</span></div></pre></div><p>在第 1 行，我们定义了函数 formatPX 的参数 size 既可以是 number 类型也可以是 string 类型，所以第 5 行和第 6 行传入数字 13 和字符串 &#x27;13px&#x27; 都正确，但在第 8 行和第 9 行传入布尔类型的 true 或者 null 类型都会提示一个 ts(2345) 错误。</p><p>当然，我们可以组合任意个、任意类型来构造更满足我们诉求的类型。比如，我们希望给前边的示例再加一个 unit 参数表示可能单位，这个时候就可以声明一个字符串字面类型组成的联合类型，如下代码所示：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">function formatUnit(size: number | string, unit: &#x27;px&#x27; | &#x27;em&#x27; | &#x27;rem&#x27; | &#x27;%&#x27; = &#x27;px&#x27;) {</span></div><div class="token-line"><span class="token plain">      // ...</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    formatUnit(1, &#x27;em&#x27;); // ok</span></div><div class="token-line"><span class="token plain">    formatUnit(&#x27;1px&#x27;, &#x27;rem&#x27;); // ok</span></div><div class="token-line"><span class="token plain">    formatUnit(&#x27;1px&#x27;, &#x27;bem&#x27;); // ts(2345)</span></div></pre></div><p>我们定义了 formatPX 函数的第二个参数 unit，它的类型是由 &#x27;px&#x27;、&#x27;em&#x27;、&#x27;rem&#x27;、&#x27;%&#x27; 字符串字面类型组成的类型集合。因此，我们可以在第 5 行和第 6 行传入字符串字面量 &#x27;em&#x27; 和 &#x27;rem&#x27; 作为第二个实参。如果在第 8 行我们传入一个不在类型集合中的字符串字面量 &#x27;bem&#x27; ，就会提示一个 ts(2345) 错误。</p><p>我们也可以使用类型别名抽离上边的联合类型，然后再将其进一步地联合，如下代码所示：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">type ModernUnit = &#x27;vh&#x27; | &#x27;vw&#x27;;</span></div><div class="token-line"><span class="token plain">    type Unit = &#x27;px&#x27; | &#x27;em&#x27; | &#x27;rem&#x27;;</span></div><div class="token-line"><span class="token plain">    type MessedUp = ModernUnit | Unit; // 类型是 &#x27;vh&#x27; | &#x27;vw&#x27; | &#x27;px&#x27; | &#x27;em&#x27; | &#x27;rem&#x27;</span></div></pre></div><p>这里我们定义了 ModernUnit 别名表示 &#x27;vh&#x27; 和 &#x27;vw&#x27; 这两个字面量类型的组合，且定义了 Unit 别名表示 &#x27;px&#x27; 和 &#x27;em&#x27; 和 &#x27;rem&#x27; 字面量类型组合，同时又定义了 MessedUp 别名表示 ModernUnit 和 Unit 两个类型别名的组合。</p><blockquote><p><strong>这里埋一个伏笔：</strong> 如果将 string 原始类型和“string 字面量类型”组合成一个联合类型会是什么效果？你可以自己尝试一下，答案将在这一讲的最后揭晓。</p></blockquote><p>我们也可以把接口类型联合起来表示更复杂的结构，如下所示示例（援引官方示例，顺带复习一下类型断言 as）：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">interface Bird {</span></div><div class="token-line"><span class="token plain">      fly(): void;</span></div><div class="token-line"><span class="token plain">      layEggs(): void;</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    interface Fish {</span></div><div class="token-line"><span class="token plain">      swim(): void;</span></div><div class="token-line"><span class="token plain">      layEggs(): void;</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    const getPet: () =&gt; Bird | Fish = () =&gt; {</span></div><div class="token-line"><span class="token plain">      return {</span></div><div class="token-line"><span class="token plain">       // ...</span></div><div class="token-line"><span class="token plain">      } as Bird | Fish;</span></div><div class="token-line"><span class="token plain">    };</span></div><div class="token-line"><span class="token plain">    const Pet = getPet();</span></div><div class="token-line"><span class="token plain">    Pet.layEggs(); // ok</span></div><div class="token-line"><span class="token plain">    Pet.fly(); // ts(2339) &#x27;Fish&#x27; 没有 &#x27;fly&#x27; 属性; &#x27;Bird | Fish&#x27; 没有 &#x27;fly&#x27; 属性</span></div></pre></div><p>从上边的示例可以看到，在联合类型中，我们可以直接访问各个接口成员都拥有的属性、方法，且不会提示类型错误。但是，如果是个别成员特有的属性、方法，我们就需要区分对待了，此时又要引入类型守卫（详见 11 讲）来区分不同的成员类型。</p><p>只不过，在这种情况下，我们还需要使用基于 in 操作符判断的类型守卫，如下代码所示：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">if (typeof Pet.fly === &#x27;function&#x27;) { // ts(2339)</span></div><div class="token-line"><span class="token plain">      Pet.fly(); // ts(2339)</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    if (&#x27;fly&#x27; in Pet) {</span></div><div class="token-line"><span class="token plain">      Pet.fly(); // ok</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>因为 Pet 的类型既可能是 Bird 也可能是 Fish，这就意味着在第 1 行可能会通过 Fish 类型获取 fly 属性，但 Fish 类型没有 fly 属性定义，所以会提示一个 ts(2339) 错误。</p><h3 id="交叉类型"><a aria-hidden="true" tabindex="-1" href="/blog/type-script入门实战笔记/02.模块一type-script入门/08#交叉类型"><span class="icon icon-link"></span></a>交叉类型</h3><p>前边我们使用了逻辑或“||” 类比联合类型，那是不是还有一个逻辑与“&amp;&amp;”可以类比类型？</p><p>在 TypeScript 中，确实还存在一种类似逻辑与行为的类型——交叉类型（Intersection Type），它可以把多个类型合并成一个类型，合并后的类型将拥有所有成员类型的特性。</p><p>在 TypeScript 中，我们可以使用“&amp;”操作符来声明交叉类型，如下代码所示：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">{</span></div><div class="token-line"><span class="token plain">      type Useless = string &amp; number;</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>很显然，如果我们仅仅把原始类型、字面量类型、函数类型等原子类型合并成交叉类型，是没有任何用处的，因为任何类型都不能满足同时属于多种原子类型，比如既是 string 类型又是 number 类型。因此，在上述的代码中，类型别名 Useless 的类型就是个 never。</p><h4 id="合并接口类型"><a aria-hidden="true" tabindex="-1" href="/blog/type-script入门实战笔记/02.模块一type-script入门/08#合并接口类型"><span class="icon icon-link"></span></a>合并接口类型</h4><p>联合类型真正的用武之地就是将多个接口类型合并成一个类型，从而实现等同接口继承的效果，也就是所谓的合并接口类型，如下代码所示：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">type IntersectionType = { id: number; name: string; } </span></div><div class="token-line"><span class="token plain">        &amp; { age: number };</span></div><div class="token-line"><span class="token plain">      const mixed: IntersectionType = {</span></div><div class="token-line"><span class="token plain">        id: 1,</span></div><div class="token-line"><span class="token plain">        name: &#x27;name&#x27;,</span></div><div class="token-line"><span class="token plain">        age: 18</span></div><div class="token-line"><span class="token plain">      }</span></div></pre></div><p>在上述示例中，我们通过交叉类型，使得 IntersectionType 同时拥有了 id、name、age 所有属性，这里我们可以试着将合并接口类型理解为求并集。</p><blockquote><p>这里，我们来发散思考一下：如果合并的多个接口类型存在同名属性会是什么效果呢？</p></blockquote><p>此时，我们可以根据同名属性的类型是否兼容（详见 12 讲）将这个问题分开来看。</p><p>如果同名属性的类型不兼容，比如上面示例中两个接口类型同名的 name 属性类型一个是 number，另一个是 string，合并后，name 属性的类型就是 number 和 string 两个原子类型的交叉类型，即 never，如下代码所示：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">type IntersectionTypeConfict = { id: number; name: string; } </span></div><div class="token-line"><span class="token plain">        &amp; { age: number; name: number; };</span></div><div class="token-line"><span class="token plain">      const mixedConflict: IntersectionTypeConfict = {</span></div><div class="token-line"><span class="token plain">        id: 1,</span></div><div class="token-line"><span class="token plain">        name: 2, // ts(2322) 错误，&#x27;number&#x27; 类型不能赋给 &#x27;never&#x27; 类型</span></div><div class="token-line"><span class="token plain">        age: 2</span></div><div class="token-line"><span class="token plain">      };</span></div></pre></div><p>此时，我们赋予 mixedConflict 任意类型的 name 属性值都会提示类型错误。而如果我们不设置 name 属性，又会提示一个缺少必选的 name 属性的错误。在这种情况下，就意味着上述代码中交叉出来的 IntersectionTypeConfict 类型是一个无用类型。</p><p>如果同名属性的类型兼容，比如一个是 number，另一个是 number 的子类型、数字字面量类型，合并后 name 属性的类型就是两者中的子类型。</p><p>如下所示示例中 name 属性的类型就是数字字面量类型 2，因此，我们不能把任何非 2 之外的值赋予 name 属性。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">type IntersectionTypeConfict = { id: number; name: 2; } </span></div><div class="token-line"><span class="token plain">      &amp; { age: number; name: number; };</span></div><div class="token-line"><span class="token plain">      let mixedConflict: IntersectionTypeConfict = {</span></div><div class="token-line"><span class="token plain">        id: 1,</span></div><div class="token-line"><span class="token plain">        name: 2, // ok</span></div><div class="token-line"><span class="token plain">        age: 2</span></div><div class="token-line"><span class="token plain">      };</span></div><div class="token-line"><span class="token plain">      mixedConflict = {</span></div><div class="token-line"><span class="token plain">        id: 1,</span></div><div class="token-line"><span class="token plain">        name: 22, // &#x27;22&#x27; 类型不能赋给 &#x27;2&#x27; 类型</span></div><div class="token-line"><span class="token plain">        age: 2</span></div><div class="token-line"><span class="token plain">      };</span></div></pre></div><h4 id="合并联合类型"><a aria-hidden="true" tabindex="-1" href="/blog/type-script入门实战笔记/02.模块一type-script入门/08#合并联合类型"><span class="icon icon-link"></span></a>合并联合类型</h4><p>另外，我们可以合并联合类型为一个交叉类型，这个交叉类型需要同时满足不同的联合类型限制，也就是提取了所有联合类型的相同类型成员。这里，我们也可以将合并联合类型理解为求交集。</p><p>在如下示例中，两个联合类型交叉出来的类型 IntersectionUnion 其实等价于 &#x27;em&#x27; | &#x27;rem&#x27;，所以我们只能把 &#x27;em&#x27; 或者 &#x27;rem&#x27; 字符串赋值给 IntersectionUnion 类型的变量。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">type UnionA = &#x27;px&#x27; | &#x27;em&#x27; | &#x27;rem&#x27; | &#x27;%&#x27;;</span></div><div class="token-line"><span class="token plain">      type UnionB = &#x27;vh&#x27; | &#x27;em&#x27; | &#x27;rem&#x27; | &#x27;pt&#x27;;</span></div><div class="token-line"><span class="token plain">      type IntersectionUnion = UnionA &amp; UnionB;</span></div><div class="token-line"><span class="token plain">      const intersectionA: IntersectionUnion = &#x27;em&#x27;; // ok</span></div><div class="token-line"><span class="token plain">      const intersectionB: IntersectionUnion = &#x27;rem&#x27;; // ok</span></div><div class="token-line"><span class="token plain">      const intersectionC: IntersectionUnion = &#x27;px&#x27;; // ts(2322)</span></div><div class="token-line"><span class="token plain">      const intersectionD: IntersectionUnion = &#x27;pt&#x27;; // ts(2322)</span></div></pre></div><p>既然是求交集，如果多个联合类型中没有相同的类型成员，交叉出来的类型自然就是 never 了，如下代码所示：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">type UnionC = &#x27;em&#x27; | &#x27;rem&#x27;;</span></div><div class="token-line"><span class="token plain">      type UnionD = &#x27;px&#x27; | &#x27;pt&#x27;;</span></div><div class="token-line"><span class="token plain">      type IntersectionUnionE = UnionC &amp; UnionD;</span></div><div class="token-line"><span class="token plain">      const intersectionE: IntersectionUnionE = &#x27;any&#x27; as any; // ts(2322) 不能赋予 &#x27;never&#x27; 类型</span></div></pre></div><p>在上述示例中，因为 UnionC 和 UnionD 没有交集，交叉出来的类型 IntersectionUnionE 就是 never，所以我们不能把任何类型的值赋予 IntersectionUnionE 类型的变量。</p><h3 id="联合交叉组合"><a aria-hidden="true" tabindex="-1" href="/blog/type-script入门实战笔记/02.模块一type-script入门/08#联合交叉组合"><span class="icon icon-link"></span></a>联合、交叉组合</h3><p>在前面的示例中，我们把一些联合、交叉类型抽离成了类型别名，再把它作为原子类型进行进一步的联合、交叉。其实，联合、交叉类型本身就可以直接组合使用，这就涉及 |、&amp; 操作符的优先级问题。实际上，联合、交叉运算符不仅在行为上表现一致，还在运算的优先级和 JavaScript 的逻辑或 ||、逻辑与 &amp;&amp; 运算符上表现一致 。</p><p>联合操作符 | 的优先级低于交叉操作符 &amp;，同样，我们可以通过使用小括弧 () 来调整操作符的优先级。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">type UnionIntersectionA = { id: number; } &amp; { name: string; } | { id: string; } &amp; { name: number; }; // 交叉操作符优先级高于联合操作符</span></div><div class="token-line"><span class="token plain">      type UnionIntersectionB = (&#x27;px&#x27; | &#x27;em&#x27; | &#x27;rem&#x27; | &#x27;%&#x27;) | (&#x27;vh&#x27; | &#x27;em&#x27; | &#x27;rem&#x27; | &#x27;pt&#x27;); // 调整优先级</span></div></pre></div><p>进而，我们也可以把分配率、交换律等基本规则引入类型组合中，然后优化出更简洁、清晰的类型，如下代码所示：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">type UnionIntersectionC = ({ id: number; } &amp; { name: string; } | { id: string; }) &amp; { name: number; };</span></div><div class="token-line"><span class="token plain">      type UnionIntersectionD = { id: number; } &amp; { name: string; } &amp; { name: number; } | { id: string; } &amp; { name: number; }; // 满足分配率</span></div><div class="token-line"><span class="token plain">      type UnionIntersectionE = ({ id: string; } | { id: number; } &amp; { name: string; }) &amp; { name: number; }; // 满足交换律</span></div></pre></div><p>在上述代码中，第 2 行是在第 1 行的基础上进行展开，说明 &amp; 满足分配率；第 3 行则是在第 1 行的基础上调整了成员的顺序，说明 | 操作满足交换律。</p><h3 id="类型缩减"><a aria-hidden="true" tabindex="-1" href="/blog/type-script入门实战笔记/02.模块一type-script入门/08#类型缩减"><span class="icon icon-link"></span></a>类型缩减</h3><p>这里呼应一下在介绍联合类型时埋下的伏笔：如果将 string 原始类型和“string字面量类型”组合成联合类型会是什么效果？效果就是类型缩减成 string 了。</p><p>同样，对于 number、boolean（其实还有枚举类型，详见第 9 讲）也是一样的缩减逻辑，如下所示示例：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">type URStr = &#x27;string&#x27; | string; // 类型是 string</span></div><div class="token-line"><span class="token plain">      type URNum = 2 | number; // 类型是 number</span></div><div class="token-line"><span class="token plain">      type URBoolen = true | boolean; // 类型是 boolean</span></div><div class="token-line"><span class="token plain">      enum EnumUR {</span></div><div class="token-line"><span class="token plain">        ONE,</span></div><div class="token-line"><span class="token plain">        TWO</span></div><div class="token-line"><span class="token plain">      }</span></div><div class="token-line"><span class="token plain">      type URE = EnumUR.ONE | EnumUR; // 类型是 EnumUR</span></div></pre></div><p>TypeScript 对这样的场景做了缩减，它把字面量类型、枚举成员类型缩减掉，只保留原始类型、枚举类型等父类型，这是合理的“优化”。</p><p>可是这个缩减，却极大地削弱了 IDE 自动提示的能力，如下代码所示：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">type BorderColor = &#x27;black&#x27; | &#x27;red&#x27; | &#x27;green&#x27; | &#x27;yellow&#x27; | &#x27;blue&#x27; | string; // 类型缩减成 string</span></div></pre></div><p>在上述代码中，我们希望 IDE 能自动提示显示注解的字符串字面量，但是因为类型被缩减成 string，所有的字符串字面量 black、red 等都无法自动提示出来了。<br/>不要慌，TypeScript 官方其实还提供了一个黑魔法，它可以让类型缩减被控制。如下代码所示，我们只需要给父类型添加“&amp; <!-- -->{<!-- -->}<!-- -->”即可。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">type BorderColor = &#x27;black&#x27; | &#x27;red&#x27; | &#x27;green&#x27; | &#x27;yellow&#x27; | &#x27;blue&#x27; | string &amp; {}; // 字面类型都被保留</span></div></pre></div><p><img src="https://s0.lgstatic.com/i/image6/M01/41/AB/Cgp9HWCtuN2AaTQhAAIsKJ6nHYA767.png" alt="图片1.png"/></p><div data-nodeid="4269"><p style="text-align:center">VS Code 自动提示效果图</p></div><p>此时，其他字面量类型就不会被缩减掉了，在 IDE 中字符串字面量 black、red 等也就自然地可以自动提示出来了。</p><p>此外，当联合类型的成员是接口类型，如果满足其中一个接口的属性是另外一个接口属性的子集，这个属性也会类型缩减，如下代码所示：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">type UnionInterce =</span></div><div class="token-line"><span class="token plain">      | {</span></div><div class="token-line"><span class="token plain">          age: &#x27;1&#x27;;</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">      | ({</span></div><div class="token-line"><span class="token plain">          age: &#x27;1&#x27; | &#x27;2&#x27;;</span></div><div class="token-line"><span class="token plain">          [key: string]: string;</span></div><div class="token-line"><span class="token plain">        });</span></div></pre></div><p>这里因为 &#x27;1&#x27; 是 &#x27;1&#x27; | &#x27;2&#x27; 的子集，所以 age 的属性变成 &#x27;1&#x27; | &#x27;2&#x27;：</p><p>利用这个特性，我们来实现 07 讲中埋下的那个伏笔，如何定义如下所示 age 属性是数字类型，而其他不确定的属性是字符串类型的数据结构的对象？</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">{</span></div><div class="token-line"><span class="token plain">      age: 1, // 数字类型</span></div><div class="token-line"><span class="token plain">      anyProperty: &#x27;str&#x27;, // 其他不确定的属性都是字符串类型</span></div><div class="token-line"><span class="token plain">      ...</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>在这里提到这个伏笔，想必你应该明白了，我们肯定要用到两个接口的联合类型及类型缩减，这个问题的核心在于找到一个既是 number 的子类型，这样 age 类型缩减之后的类型就是 number；同时也是 string 的子类型，这样才能满足属性和 string 索引类型的约束关系。</p><p>哪个类型满足这个条件呢？我们一起回忆一下 02 讲中介绍的特殊类型 never。</p><p>never 有一个特性是它是所有类型的子类型，自然也是 number 和 string 的子类型，所以答案如下代码所示：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">type UnionInterce =</span></div><div class="token-line"><span class="token plain">      | {</span></div><div class="token-line"><span class="token plain">          age: number;</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">      | ({</span></div><div class="token-line"><span class="token plain">          age: never;</span></div><div class="token-line"><span class="token plain">          [key: string]: string;</span></div><div class="token-line"><span class="token plain">        });</span></div><div class="token-line"><span class="token plain">      const O: UnionInterce = {</span></div><div class="token-line"><span class="token plain">        age: 2,</span></div><div class="token-line"><span class="token plain">        string: &#x27;string&#x27;</span></div><div class="token-line"><span class="token plain">      };</span></div></pre></div><p>在上述代码中，我们在第 3 行定义了 number 类型的 age 属性，第 6 行定义了 never 类型的 age 属性，等价于 age 属性的类型是由 number 和 never 类型组成的联合类型，所以我们可以把 number 类型的值（比如说数字字面量 1）赋予 age 属性；但是不能把其他任何类型的值（比如说字符串字面量 &#x27;string&#x27; ）赋予 age。</p><p>同时，我们在第 5 行~第 8 行定义的接口类型中，还额外定义了 string 类型的字符串索引签名。因为 never 同时又是 string 类型的子类型，所以 age 属性的类型和字符串索引签名类型不冲突。如第 9 行~第 12 行所示，我们可以把一个 age 属性是 2、string 属性是 &#x27;string&#x27; 的对象字面量赋值给 UnionInterce 类型的变量 O。</p><h3 id="小结与预告"><a aria-hidden="true" tabindex="-1" href="/blog/type-script入门实战笔记/02.模块一type-script入门/08#小结与预告"><span class="icon icon-link"></span></a>小结与预告</h3><p>这一讲中介绍的联合和交叉类型赋予了 TypeScript 类型最基本的“编程”（运算）能力，学习和掌握联合和交叉类型后，可以培养我们抽离、复用公共类型的意识和能力。</p><p>插播一个思考题：在联合类型中，类型缩减的规则是什么？欢迎你在留言区与我进行交流、互动。</p><p>09 讲我们将介绍如何定义常量集合的方法——枚举类型，敬请期待~</p><p>另外，如果你觉得本专栏有价值，欢迎分享给更多好友。</p></div><div class="__dumi-default-layout-footer-meta"><a target="_blank" rel="noopener noreferrer" href="https://github.com/GGwujun/blog/edit/master/docs/type-script入门实战笔记/02.模块一TypeScript入门/08.md">在 GitHub 上编辑此页<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a><span data-updated-text="最后更新时间：">5/2/2022 10:56:53</span></div></div></div></div>
	<script>
  window.g_useSSR = true;
  window.g_initialProps = {};
	</script>

    <script>
      (function () {
        if (!location.port) {
          (function (i, s, o, g, r, a, m) {
            i["GoogleAnalyticsObject"] = r;
            (i[r] =
              i[r] ||
              function () {
                (i[r].q = i[r].q || []).push(arguments);
              }),
              (i[r].l = 1 * new Date());
            (a = s.createElement(o)), (m = s.getElementsByTagName(o)[0]);
            a.async = 1;
            a.src = g;
            m.parentNode.insertBefore(a, m);
          })(
            window,
            document,
            "script",
            "//www.google-analytics.com/analytics.js",
            "ga"
          );
          ga("create", "UA-149864185-1", "auto");
          ga("send", "pageview");
        }
      })();
    </script>
    <script src="/blog/umi.js"></script>
  </body>
</html>
