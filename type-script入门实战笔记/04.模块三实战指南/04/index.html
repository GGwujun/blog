<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no"
    />
    <link rel="shortcut icon" type="image/x-icon" href="/logo.png" />
    <link rel="stylesheet" href="/blog/umi.css" />
    <script>
      window.routerBase = "/blog";
    </script>
    <script>
      //! umi version: 3.5.17
    </script>
    <script>
      !(function () {
        var e = localStorage.getItem("dumi:prefers-color"),
          t = window.matchMedia("(prefers-color-scheme: dark)").matches,
          r = ["light", "dark", "auto"];
        document.documentElement.setAttribute(
          "data-prefers-color",
          e === r[2] ? (t ? r[1] : r[0]) : r.indexOf(e) > -1 ? e : r[0]
        );
      })();
    </script>
    <title>19 | 使用 TypeScript 开发 Web 应用的最佳实践</title>
  </head>
  <body>
    <div id="root"><div class="__dumi-default-layout" data-route="/type-script入门实战笔记/04.模块三实战指南/04" data-show-sidemenu="true" data-show-slugs="true" data-site-mode="true" data-gapless="false"><div class="__dumi-default-navbar" data-mode="site"><button class="__dumi-default-navbar-toggle"></button><a class="__dumi-default-navbar-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog/">大师兄</a><nav><div class="__dumi-default-search"><input type="search" class="__dumi-default-search-input" value=""/><ul></ul></div><span>计算机基础<ul><li><a href="/blog/编译原理之美">编译原理之美</a></li><li><a href="/blog/编译原理实战">编译原理实战</a></li><li><a href="/blog/深入浅出计算机组成原理">深入浅出计算机组成原理</a></li><li><a href="/blog/详解http">详解http</a></li><li><a href="/blog/计算机网络通关29讲">计算机网络通关29讲</a></li><li><a href="/blog/网络排查案例课">网络排查案例课</a></li><li><a href="/blog/linux操作系统">linux操作系统</a></li><li><a href="/blog/linux性能优化实战">linux性能优化实战</a></li><li><a href="/blog/程序员数学基础">程序员数学基础</a></li><li><a href="/blog/趣谈网络协议">趣谈网络协议</a></li><li><a href="/blog/操作系统实战">操作系统实战</a></li><li><a href="/blog/软件工程之美">软件工程之美</a></li><li><a href="/blog/sql必知必会">sql必知必会</a></li><li><a href="/blog/操作系统实战45讲">操作系统实战45讲</a></li><li><a href="/blog/网络编程实战">网络编程实战</a></li></ul></span><span>算法<ul><li><a href="/blog/常用算法25讲">常用算法25讲</a></li><li><a href="/blog/数据结构与算法之美">数据结构与算法之美</a></li><li><a href="/blog/业务开发算法50讲">业务开发算法50讲</a></li><li><a href="/blog/动态规划面试宝典">动态规划面试宝典</a></li></ul></span><span>前端开发<ul><li><a href="/blog/浏览器工作原理与实践">浏览器工作原理与实践</a></li><li><a href="/blog/新时代产品经理进阶之路">新时代产品经理进阶之路</a></li><li><a href="/blog/全栈工程师修炼指南">全栈工程师修炼指南</a></li><li><a href="/blog/flutter核心技术与实战">flutter核心技术与实战</a></li><li><a href="/blog/java-script核心原理解析">java-script核心原理解析</a></li><li><a href="/blog/说透低代码">说透低代码</a></li><li><a href="/blog/nodejs应用开发实战">nodejs应用开发实战</a></li><li><a href="/blog/反爬虫兵法演绎20讲">反爬虫兵法演绎20讲</a></li><li><a href="/blog/reactnative新架构实战课">reactnative新架构实战课</a></li><li><a href="/blog/正则表达式入门">正则表达式入门</a></li><li><a href="/blog/重学前端">重学前端</a></li><li><a href="/blog/serverless入门课">serverless入门课</a></li><li><a aria-current="page" class="active" href="/blog/type-script入门实战笔记">type-script入门实战笔记</a></li><li><a href="/blog/图解googlev8">图解googlev8</a></li><li><a href="/blog/vue3源码分析">vue3源码分析</a></li><li><a href="/blog/玩转Vue3全家桶">玩转Vue3全家桶</a></li><li><a href="/blog/webassembly入门">webassembly入门</a></li><li><a href="/blog/手把手带你写一个Web框架">手把手带你写一个Web框架</a></li><li><a href="/blog/web漏洞挖掘实战">web漏洞挖掘实战</a></li><li><a href="/blog/跟月影学可视化">跟月影学可视化</a></li><li><a href="/blog/搞定音频技术">搞定音频技术</a></li><li><a href="/blog/攻克视频技术">攻克视频技术</a></li></ul></span><span>前端工程化<ul><li><a href="/blog/logger">logger</a></li><li><a href="/blog/webpack">webpack</a></li><li><a href="/blog/webpackChain">webpackChain</a></li></ul></span><span>前端性能优化<ul><li><a href="/blog/react性能调优">react性能调优</a></li></ul></span><span>软件测试<ul><li><a href="/blog/全链路压测实战30讲">全链路压测实战30讲</a></li><li><a href="/blog/性能测试实战30讲">性能测试实战30讲</a></li><li><a href="/blog/自动化测试高手课">自动化测试高手课</a></li><li><a href="/blog/软件测试52讲">软件测试52讲</a></li></ul></span><span>面试<ul><li><a href="/blog/面试现场">面试现场</a></li></ul></span><span>杂谈<ul><li><a href="/blog/超级访谈对话张雪峰">超级访谈对话张雪峰</a></li><li><a href="/blog/Git实战手册">Git实战手册</a></li><li><a href="/blog/NodeJS">NodeJS</a></li><li><a href="/blog/ReactJS">ReactJS</a></li><li><a href="/blog/UI设计">UI设计</a></li><li><a href="/blog/webpack4系列教程">webpack4系列教程</a></li><li><a href="/blog/前端知识体系">前端知识体系</a></li><li><a href="/blog/剑指offer刷题笔记">剑指offer刷题笔记</a></li><li><a href="/blog/思考与成长">思考与成长</a></li><li><a href="/blog/设计模式手册">设计模式手册</a></li></ul></span><div class="__dumi-default-navbar-tool"><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "></div></div></div></nav></div><div class="__dumi-default-menu" data-mode="site"><div class="__dumi-default-menu-inner"><div class="__dumi-default-menu-header"><a class="__dumi-default-menu-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog/"></a><h1>大师兄</h1><p></p></div><div class="__dumi-default-menu-mobile-area"><ul class="__dumi-default-menu-nav-list"><li>计算机基础<ul><li><a href="/blog/编译原理之美">编译原理之美</a></li><li><a href="/blog/编译原理实战">编译原理实战</a></li><li><a href="/blog/深入浅出计算机组成原理">深入浅出计算机组成原理</a></li><li><a href="/blog/详解http">详解http</a></li><li><a href="/blog/计算机网络通关29讲">计算机网络通关29讲</a></li><li><a href="/blog/网络排查案例课">网络排查案例课</a></li><li><a href="/blog/linux操作系统">linux操作系统</a></li><li><a href="/blog/linux性能优化实战">linux性能优化实战</a></li><li><a href="/blog/程序员数学基础">程序员数学基础</a></li><li><a href="/blog/趣谈网络协议">趣谈网络协议</a></li><li><a href="/blog/操作系统实战">操作系统实战</a></li><li><a href="/blog/软件工程之美">软件工程之美</a></li><li><a href="/blog/sql必知必会">sql必知必会</a></li><li><a href="/blog/操作系统实战45讲">操作系统实战45讲</a></li><li><a href="/blog/网络编程实战">网络编程实战</a></li></ul></li><li>算法<ul><li><a href="/blog/常用算法25讲">常用算法25讲</a></li><li><a href="/blog/数据结构与算法之美">数据结构与算法之美</a></li><li><a href="/blog/业务开发算法50讲">业务开发算法50讲</a></li><li><a href="/blog/动态规划面试宝典">动态规划面试宝典</a></li></ul></li><li>前端开发<ul><li><a href="/blog/浏览器工作原理与实践">浏览器工作原理与实践</a></li><li><a href="/blog/新时代产品经理进阶之路">新时代产品经理进阶之路</a></li><li><a href="/blog/全栈工程师修炼指南">全栈工程师修炼指南</a></li><li><a href="/blog/flutter核心技术与实战">flutter核心技术与实战</a></li><li><a href="/blog/java-script核心原理解析">java-script核心原理解析</a></li><li><a href="/blog/说透低代码">说透低代码</a></li><li><a href="/blog/nodejs应用开发实战">nodejs应用开发实战</a></li><li><a href="/blog/反爬虫兵法演绎20讲">反爬虫兵法演绎20讲</a></li><li><a href="/blog/reactnative新架构实战课">reactnative新架构实战课</a></li><li><a href="/blog/正则表达式入门">正则表达式入门</a></li><li><a href="/blog/重学前端">重学前端</a></li><li><a href="/blog/serverless入门课">serverless入门课</a></li><li><a aria-current="page" class="active" href="/blog/type-script入门实战笔记">type-script入门实战笔记</a></li><li><a href="/blog/图解googlev8">图解googlev8</a></li><li><a href="/blog/vue3源码分析">vue3源码分析</a></li><li><a href="/blog/玩转Vue3全家桶">玩转Vue3全家桶</a></li><li><a href="/blog/webassembly入门">webassembly入门</a></li><li><a href="/blog/手把手带你写一个Web框架">手把手带你写一个Web框架</a></li><li><a href="/blog/web漏洞挖掘实战">web漏洞挖掘实战</a></li><li><a href="/blog/跟月影学可视化">跟月影学可视化</a></li><li><a href="/blog/搞定音频技术">搞定音频技术</a></li><li><a href="/blog/攻克视频技术">攻克视频技术</a></li></ul></li><li>前端工程化<ul><li><a href="/blog/logger">logger</a></li><li><a href="/blog/webpack">webpack</a></li><li><a href="/blog/webpackChain">webpackChain</a></li></ul></li><li>前端性能优化<ul><li><a href="/blog/react性能调优">react性能调优</a></li></ul></li><li>软件测试<ul><li><a href="/blog/全链路压测实战30讲">全链路压测实战30讲</a></li><li><a href="/blog/性能测试实战30讲">性能测试实战30讲</a></li><li><a href="/blog/自动化测试高手课">自动化测试高手课</a></li><li><a href="/blog/软件测试52讲">软件测试52讲</a></li></ul></li><li>面试<ul><li><a href="/blog/面试现场">面试现场</a></li></ul></li><li>杂谈<ul><li><a href="/blog/超级访谈对话张雪峰">超级访谈对话张雪峰</a></li><li><a href="/blog/Git实战手册">Git实战手册</a></li><li><a href="/blog/NodeJS">NodeJS</a></li><li><a href="/blog/ReactJS">ReactJS</a></li><li><a href="/blog/UI设计">UI设计</a></li><li><a href="/blog/webpack4系列教程">webpack4系列教程</a></li><li><a href="/blog/前端知识体系">前端知识体系</a></li><li><a href="/blog/剑指offer刷题笔记">剑指offer刷题笔记</a></li><li><a href="/blog/思考与成长">思考与成长</a></li><li><a href="/blog/设计模式手册">设计模式手册</a></li></ul></li></ul><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "><button title="Dark theme" class="__dumi-default-dark-moon "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="3854" width="22" height="22"><path d="M991.816611 674.909091a69.166545 69.166545 0 0 0-51.665455-23.272727 70.795636 70.795636 0 0 0-27.438545 5.585454A415.674182 415.674182 0 0 1 754.993338 698.181818c-209.594182 0-393.472-184.785455-393.472-395.636363 0-52.363636 38.539636-119.621818 69.515637-173.614546 4.887273-8.610909 9.634909-16.756364 14.103272-24.901818A69.818182 69.818182 0 0 0 384.631156 0a70.842182 70.842182 0 0 0-27.438545 5.585455C161.678429 90.298182 14.362065 307.898182 14.362065 512c0 282.298182 238.824727 512 532.38691 512a522.286545 522.286545 0 0 0 453.957818-268.334545A69.818182 69.818182 0 0 0 991.816611 674.909091zM546.679156 954.181818c-248.785455 0-462.941091-192-462.941091-442.181818 0-186.647273 140.637091-372.829091 300.939637-442.181818-36.817455 65.629091-92.578909 151.970909-92.578909 232.727273 0 250.181818 214.109091 465.454545 462.917818 465.454545a488.331636 488.331636 0 0 0 185.181091-46.545455 453.003636 453.003636 0 0 1-393.565091 232.727273z m103.656728-669.323636l-14.266182 83.781818a34.909091 34.909091 0 0 0 50.362182 36.770909l74.775272-39.563636 74.752 39.563636a36.142545 36.142545 0 0 0 16.174546 3.956364 34.909091 34.909091 0 0 0 34.210909-40.727273l-14.289455-83.781818 60.509091-59.345455a35.025455 35.025455 0 0 0-19.223272-59.578182l-83.61891-12.101818-37.376-76.101818a34.56 34.56 0 0 0-62.254545 0l-37.376 76.101818-83.618909 12.101818a34.909091 34.909091 0 0 0-19.246546 59.578182z m70.423272-64.698182a34.280727 34.280727 0 0 0 26.135273-19.083636l14.312727-29.090909 14.336 29.090909a34.257455 34.257455 0 0 0 26.135273 19.083636l32.046546 4.887273-23.272728 22.574545a35.234909 35.234909 0 0 0-10.007272 30.952727l5.46909 32.116364-28.625454-15.127273a34.490182 34.490182 0 0 0-32.302546 0l-28.695272 15.127273 5.469091-32.116364a35.141818 35.141818 0 0 0-9.984-30.952727l-23.272728-22.574545z" p-id="3855"></path></svg></button><button title="Light theme" class="__dumi-default-dark-sun "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="4026" width="22" height="22"><path d="M915.2 476.16h-43.968c-24.704 0-44.736 16-44.736 35.84s20.032 35.904 44.736 35.904H915.2c24.768 0 44.8-16.064 44.8-35.904s-20.032-35.84-44.8-35.84zM512 265.6c-136.704 0-246.464 109.824-246.464 246.4 0 136.704 109.76 246.464 246.464 246.464S758.4 648.704 758.4 512c0-136.576-109.696-246.4-246.4-246.4z m0 425.6c-99.008 0-179.2-80.128-179.2-179.2 0-98.944 80.192-179.2 179.2-179.2S691.2 413.056 691.2 512c0 99.072-80.192 179.2-179.2 179.2zM197.44 512c0-19.84-19.136-35.84-43.904-35.84H108.8c-24.768 0-44.8 16-44.8 35.84s20.032 35.904 44.8 35.904h44.736c24.768 0 43.904-16.064 43.904-35.904zM512 198.464c19.776 0 35.84-20.032 35.84-44.8v-44.8C547.84 84.032 531.84 64 512 64s-35.904 20.032-35.904 44.8v44.8c0 24.768 16.128 44.864 35.904 44.864z m0 627.136c-19.776 0-35.904 20.032-35.904 44.8v44.736C476.096 940.032 492.16 960 512 960s35.84-20.032 35.84-44.8v-44.736c0-24.768-16.064-44.864-35.84-44.864z m329.92-592.832c17.472-17.536 20.288-43.072 6.4-57.024-14.016-14.016-39.488-11.2-57.024 6.336-4.736 4.864-26.496 26.496-31.36 31.36-17.472 17.472-20.288 43.008-6.336 57.024 13.952 14.016 39.488 11.2 57.024-6.336 4.8-4.864 26.496-26.56 31.296-31.36zM213.376 759.936c-4.864 4.8-26.56 26.624-31.36 31.36-17.472 17.472-20.288 42.944-6.4 56.96 14.016 13.952 39.552 11.2 57.024-6.336 4.8-4.736 26.56-26.496 31.36-31.36 17.472-17.472 20.288-43.008 6.336-56.96-14.016-13.952-39.552-11.072-56.96 6.336z m19.328-577.92c-17.536-17.536-43.008-20.352-57.024-6.336-14.08 14.016-11.136 39.488 6.336 57.024 4.864 4.864 26.496 26.56 31.36 31.424 17.536 17.408 43.008 20.288 56.96 6.336 14.016-14.016 11.264-39.488-6.336-57.024-4.736-4.864-26.496-26.56-31.296-31.424z m527.168 628.608c4.864 4.864 26.624 26.624 31.36 31.424 17.536 17.408 43.072 20.224 57.088 6.336 13.952-14.016 11.072-39.552-6.4-57.024-4.864-4.8-26.56-26.496-31.36-31.36-17.472-17.408-43.072-20.288-57.024-6.336-13.952 14.016-11.008 39.488 6.336 56.96z" p-id="4027"></path></svg></button><button title="Default to system" class="__dumi-default-dark-auto "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="11002" width="22" height="22"><path d="M127.658667 492.885333c0-51.882667 10.24-101.717333 30.378666-149.162666s47.786667-88.064 81.92-122.538667 75.093333-61.781333 122.538667-81.92 96.938667-30.378667 149.162667-30.378667 101.717333 10.24 149.162666 30.378667 88.405333 47.786667 122.88 81.92 61.781333 75.093333 81.92 122.538667 30.378667 96.938667 30.378667 149.162666-10.24 101.717333-30.378667 149.162667-47.786667 88.405333-81.92 122.88-75.093333 61.781333-122.88 81.92-97.28 30.378667-149.162666 30.378667-101.717333-10.24-149.162667-30.378667-88.064-47.786667-122.538667-81.92-61.781333-75.093333-81.92-122.88-30.378667-96.938667-30.378666-149.162667z m329.045333 0c0 130.048 13.994667 244.394667 41.984 343.381334h12.970667c46.762667 0 91.136-9.216 133.461333-27.306667s78.848-42.666667 109.568-73.386667 54.954667-67.242667 73.386667-109.568 27.306667-86.698667 27.306666-133.461333c0-46.421333-9.216-90.794667-27.306666-133.12s-42.666667-78.848-73.386667-109.568-67.242667-54.954667-109.568-73.386667-86.698667-27.306667-133.461333-27.306666h-11.605334c-28.672 123.562667-43.349333 237.909333-43.349333 343.722666z" p-id="11003"></path></svg></button></div></div></div><ul class="__dumi-default-menu-list"><li><a href="/blog/type-script入门实战笔记">type-script入门实战笔记</a></li><li><a href="/blog/type-script入门实战笔记/01.开篇词">01.开篇词</a><ul><li><a href="/blog/type-script入门实战笔记/01.开篇词/01"><span>开篇词 | 你为什么要选择 TypeScript？</span></a></li></ul></li><li><a href="/blog/type-script入门实战笔记/02.模块一type-script入门">02.模块一TypeScript入门</a><ul><li><a href="/blog/type-script入门实战笔记/02.模块一type-script入门/01"><span>01 | 如何快速搭建 TypeScript 学习开发环境？</span></a></li><li><a href="/blog/type-script入门实战笔记/02.模块一type-script入门/02"><span>02 | 简单基础类型：TypeScript 与 JavaScript 有何不同？</span></a></li><li><a href="/blog/type-script入门实战笔记/02.模块一type-script入门/03"><span>03 | 复杂基础类型：TypeScript 与 JavaScript 有何不同？</span></a></li><li><a href="/blog/type-script入门实战笔记/02.模块一type-script入门/04"><span>04 | 什么是字面量类型、类型推断、类型拓宽和类型缩小？</span></a></li><li><a href="/blog/type-script入门实战笔记/02.模块一type-script入门/05"><span>05 | 函数类型：返回值类型和参数类型到底如何定义？</span></a></li><li><a href="/blog/type-script入门实战笔记/02.模块一type-script入门/06"><span>06 | 类类型：如何高效使用类型化的面向对象编程利器？</span></a></li><li><a href="/blog/type-script入门实战笔记/02.模块一type-script入门/07"><span>07 | 接口类型与类型别名：这两者的用法与区别分别是什么？</span></a></li><li><a href="/blog/type-script入门实战笔记/02.模块一type-script入门/08"><span>08 | 高级类型：如何快速读懂联合类型和交叉类型的含义？</span></a></li><li><a href="/blog/type-script入门实战笔记/02.模块一type-script入门/09"><span>09 | 枚举类型：详解常见枚举类型的 7 种用法</span></a></li><li><a href="/blog/type-script入门实战笔记/02.模块一type-script入门/10"><span>10 | 泛型：如何正确使用泛型约束类型变量？</span></a></li></ul></li><li><a href="/blog/type-script入门实战笔记/03.模块二type-script进阶">03.模块二TypeScript进阶</a><ul><li><a href="/blog/type-script入门实战笔记/03.模块二type-script进阶/01"><span>11 | 类型守卫：如何有效地保障类型的安全性？</span></a></li><li><a href="/blog/type-script入门实战笔记/03.模块二type-script进阶/02"><span>12 | 类型兼容：如何判断一个类型是否可以赋值给其他类型？</span></a></li><li><a href="/blog/type-script入门实战笔记/03.模块二type-script进阶/03"><span>13 | 必备增强类型系统的方式大盘点，让你的开发如虎添翼</span></a></li><li><a href="/blog/type-script入门实战笔记/03.模块二type-script进阶/04"><span>14 | 掌握 TypeScript 这些官方工具类型，让你的开发事半功倍</span></a></li><li><a href="/blog/type-script入门实战笔记/03.模块二type-script进阶/05"><span>15 | 类型编程：如何打造属于自己的工具类型？</span></a></li></ul></li><li><a aria-current="page" class="active" href="/blog/type-script入门实战笔记/04.模块三实战指南">04.模块三实战指南</a><ul><li><a href="/blog/type-script入门实战笔记/04.模块三实战指南/01"><span>16 | tsconfig.json 配置：如何定制 TypeScript 的行为？</span></a></li><li><a href="/blog/type-script入门实战笔记/04.模块三实战指南/02"><span>17 | 来自 100 +项目经历的常见 TypeScript 错误汇总分析</span></a></li><li><a href="/blog/type-script入门实战笔记/04.模块三实战指南/03"><span>18 | 手把手教你使用 TypeScript 开发 Node.js 应用</span></a></li><li><a aria-current="page" class="active" href="/blog/type-script入门实战笔记/04.模块三实战指南/04"><span>19 | 使用 TypeScript 开发 Web 应用的最佳实践</span></a></li><li><a href="/blog/type-script入门实战笔记/04.模块三实战指南/05"><span>20 | 如何将 JavaScript 应用切换至 TypeScript？</span></a></li></ul></li><li><a href="/blog/type-script入门实战笔记/05.结束语">05.结束语</a><ul><li><a href="/blog/type-script入门实战笔记/05.结束语/01"><span>结束语 | TypeScript 的这些实用技能，你不得不知</span></a></li></ul></li><li><a href="/blog/type-script入门实战笔记/summary">type-script入门实战笔记</a></li></ul></div></div><ul role="slug-list" class="__dumi-default-layout-toc"><li title="DOM 原生操作" data-depth="3"><a href="/blog/type-script入门实战笔记/04.模块三实战指南/04#dom-原生操作"><span>DOM 原生操作</span></a></li><li title="React 框架" data-depth="3"><a href="/blog/type-script入门实战笔记/04.模块三实战指南/04#react-框架"><span>React 框架</span></a></li><li title="小结和预告" data-depth="3"><a href="/blog/type-script入门实战笔记/04.模块三实战指南/04#小结和预告"><span>小结和预告</span></a></li></ul><div class="__dumi-default-layout-content"><div class="markdown"><h1 id="19--使用-typescript-开发-web-应用的最佳实践"><a aria-hidden="true" tabindex="-1" href="/blog/type-script入门实战笔记/04.模块三实战指南/04#19--使用-typescript-开发-web-应用的最佳实践"><span class="icon icon-link"></span></a>19 | 使用 TypeScript 开发 Web 应用的最佳实践</h1><p>18 讲我们学习了如何使用 TypeScript 开发运行 Node.js 端的静态文件服务模块，然而对于大多数的前端人而言，Web 端可能才是主战场。因此，这一讲我们将从 DOM 原生操作和 React 框架这两个方面学习 Web + TypeScript 开发实践。</p><blockquote><p>学习建议：请按照这一讲中的操作步骤，实践一个完整的开发流程。</p></blockquote><h3 id="dom-原生操作"><a aria-hidden="true" tabindex="-1" href="/blog/type-script入门实战笔记/04.模块三实战指南/04#dom-原生操作"><span class="icon icon-link"></span></a>DOM 原生操作</h3><p>无论我们使用前端框架与否，都免不了需要使用原生操作接口，因此将 TypeScript 与 DOM 原生操作组合起来进行学习很有必要。</p><p>接下来，我们通过手写一个简单的待办管理应用来熟悉常见的操作接口。</p><h4 id="配置项目"><a aria-hidden="true" tabindex="-1" href="/blog/type-script入门实战笔记/04.模块三实战指南/04#配置项目"><span class="icon icon-link"></span></a>配置项目</h4><p>首先，我们可以参照 18 讲中初始化 Node.js 模块的步骤创建一个 todo-web 项目，并安装 TypeScript 依赖。</p><p>然后，我们可以按需调整 lib 和 alwaysStrict 参数配置 tsconfig，如下所示：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">{</span></div><div class="token-line"><span class="token plain">      &quot;compilerOptions&quot;: {</span></div><div class="token-line"><span class="token plain">        ...,</span></div><div class="token-line"><span class="token plain">        &quot;target&quot;: &quot;es5&quot;,</span></div><div class="token-line"><span class="token plain">        &quot;lib&quot;: [&quot;ESNext&quot;, &quot;DOM&quot;],                </span></div><div class="token-line"><span class="token plain">        &quot;strict&quot;: true,                       </span></div><div class="token-line"><span class="token plain">        &quot;alwaysStrict&quot;: false,</span></div><div class="token-line"><span class="token plain">        ...           </span></div><div class="token-line"><span class="token plain">      }</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>在以上配置的第 4 行，我们设置了 tagert 参数是“es5”。在第 5 行，我们设置了 lib 参数为 &quot;ESNext&quot; 和 &quot;DOM&quot;。这样，我们就可以在 TypeScript 中使用最新的语言特性了（比如 Promise.any 等）。</p><blockquote><p><strong>注意</strong>：因为设置了 target es5，所以这里我们还需要手动引入 ts-polyfill 为新特性打补丁，以兼容较低版本的浏览器。</p></blockquote><p>此外，如果我们想在函数中使用 this，则可以把 alwaysStrict 设置为 false，这样生成的代码中就不会有“use strict”（关闭严格模式）了。</p><p>配置好项目后，我们开始进行编码实现。</p><h4 id="编码实现"><a aria-hidden="true" tabindex="-1" href="/blog/type-script入门实战笔记/04.模块三实战指南/04#编码实现"><span class="icon icon-link"></span></a>编码实现</h4><p>首先我们可以创建一个模型 src/model.ts，用来维护待办数据层的增删操作，具体示例如下：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">class TodoModel {</span></div><div class="token-line"><span class="token plain">      private gid: number = 0;</span></div><div class="token-line"><span class="token plain">      public add = () =&gt; this.gid++;</span></div><div class="token-line"><span class="token plain">      public remove = (id: number) =&gt; void 0</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    declare var todoModel: TodoModel;</span></div><div class="token-line"><span class="token plain">    todoModel = new TodoModel;</span></div></pre></div><p>在上述示例中，我们定义了模型 TodoModel（示例中仅仅实现了架子，你可以按需丰富这个示例），并在第 7~8 行把模型实例赋值给了全局变量 todoModel。</p><p>接下来我们开始实现 src/view.ts，用来维护视图层操作 Dom 逻辑，具体示例如下：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">const list = document.getElementById(&#x27;todo&#x27;) as HTMLUListElement | null;</span></div><div class="token-line"><span class="token plain">    const addButton = document.querySelector&lt;HTMLButtonElement&gt;(&#x27;#add&#x27;);</span></div><div class="token-line"><span class="token plain">    addButton?.addEventListener(&#x27;click&#x27;, add);</span></div><div class="token-line"><span class="token plain">    function remove(this: HTMLButtonElement, id: number) {</span></div><div class="token-line"><span class="token plain">      const todo = this.parentElement;</span></div><div class="token-line"><span class="token plain">      todo &amp;&amp; list?.removeChild(todo) &amp;&amp; todoModel.remove(id);</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    function add() {</span></div><div class="token-line"><span class="token plain">      const id = todoModel.add();</span></div><div class="token-line"><span class="token plain">      const todoEle = document.createElement(&#x27;li&#x27;);</span></div><div class="token-line"><span class="token plain">      todoEle.innerHTML = `待办 ${id} &lt;button&gt;删除&lt;/button&gt;`;</span></div><div class="token-line"><span class="token plain">      const button = todoEle.getElementsByTagName(&#x27;button&#x27;)[0];</span></div><div class="token-line"><span class="token plain">      button.style.color = &#x27;red&#x27;;</span></div><div class="token-line"><span class="token plain">      if (button) {</span></div><div class="token-line"><span class="token plain">        button.onclick = remove.bind(button, id);</span></div><div class="token-line"><span class="token plain">      }</span></div><div class="token-line"><span class="token plain">      list?.appendChild(todoEle);</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>上述示例中，我们在 tsconfig 的 lib 参数中添加了 DOM（如果 lib 参数缺省，则默认包含了 DOM；如果显式设置了 lib 参数，那么一定要添加 DOM），TypeScript 便会自动引入内置的 DOM 类型声明（node_modules/typescript/lib/lib.dom.d.ts），这样所有的 DOM 原生操作都将支持静态类型检测。</p><p>在第 1 行，我们把通过 id 获取 HTMLElement | null 类型的元素断言为 HTMLUListElement | null，这是因为 HTMLUListElement 是 HTMLElement 的子类型。同样，第 6 行、12 行、14 行的相关元素都也有明确类型。尤其是第 12 行的 createElement、第 14 行的 getElementsByTagName，它们都可以根据标签名返回更确切的元素类型 HTMLLIElement、HTMLButtonElement。</p><p>然后，在第 2 行我们通过给 querySelector 指定了明确的类型入参，其获取的元素类型也就变成了更明确的 HTMLButtonElement。</p><p>此外，因为 DOM 元素的 style 属性也支持静态类型检测，所以我们在第 15 行可以把字符串 &#x27;red&#x27; 赋值给 color。但是，如果我们把数字 1 赋值给 color，则会提示一个 ts(2322) 错误。</p><p>接下来，我们就可以转译代码，并新建一个 index.html 引入转译后的 lib/model.js、lib/view.js 中，再使用 19 讲中开发的 http-serve CLI 启动服务预览页面。</p><p>通过这个简单的例子，我们感受到了 TypeScript 对 DOM 强大的支持，并且官方也根据 JavaScript 的发展十分及时地补齐了新语法特性。因此，即便开发原生应用，TypeScript 也会是一个不错的选择。</p><p>接下来，我们将学习 TypeScript 与前端主流框架 React 的搭配使用。</p><h3 id="react-框架"><a aria-hidden="true" tabindex="-1" href="/blog/type-script入门实战笔记/04.模块三实战指南/04#react-框架"><span class="icon icon-link"></span></a>React 框架</h3><p>React 作为目前非常流行的前端框架，TypeScript 对其支持也是超级完善。在 1.6 版本中，TypeScript 官方专门实现了对 React JSX 语法的静态类型支持，并在 tsconfig 中新增了一个 jsx 参数用来定制 JSX 的转译规则。</p><p>而且，React 官方及周边生态对 TypeScript 的支持也越来越完善，比如 create-react-app 支持 TypeScript 模板、babel 支持转译 TypeScript。要知道，在 2018 年我们还需要手动搭建 TypeScript 开发环境，现在通过以下命令即可快速创建 TypeScript 应用，并且还不用过分关心 tsconfig 和开发构建相关的配置，只需把重心放在 React 和 TypeScript 的使用上（坏处则是修改默认配置会比较麻烦）。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">npm i create-react-app -g;</span></div><div class="token-line"><span class="token plain">    create-react-app my-ts-app --template typescript;</span></div><div class="token-line"><span class="token plain">    cd my-ts-app;</span></div><div class="token-line"><span class="token plain">    npm start; // 或者 yarn start</span></div></pre></div><p>接下来我们将分别从 Service、Component、状态管理这三个分层介绍 TypeScript 在 React App 开发中的实践。</p><h4 id="service-类型化"><a aria-hidden="true" tabindex="-1" href="/blog/type-script入门实战笔记/04.模块三实战指南/04#service-类型化"><span class="icon icon-link"></span></a>Service 类型化</h4><p>首先我们介绍的是 TypeScript 在 Service 层的应用，称之为 Service 类型化，实际就是把 JavaScript 编写的接口调用代码使用 TypeScript 实现。</p><p>举个例子， 以下是使用 JavaScript 编写的 getUserById 方法：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">export const getUserById = id =&gt; fetch(`/api/get/user/by/${id}`, { method: &#x27;GET&#x27; });</span></div></pre></div><p>在这个示例中，除了知道参数名 id 以外，我们对该方法接收参数、返回数据的类型和格式一无所知。</p><p>以上示例换成 TypeScript 实现后效果如下：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">export const getUserById = (id: number): Promise&lt;{ id: number; name: string }&gt; =&gt;</span></div><div class="token-line"><span class="token plain">      fetch(`/api/get/user/by/${id}`, { method: &#x27;GET&#x27; }).then(res =&gt; res.json());</span></div><div class="token-line"><span class="token plain">    async function test() {</span></div><div class="token-line"><span class="token plain">      const { id2, name } = await getUserById(&#x27;string&#x27;); // ts(2339) ts(2345)</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>在使用 TypeScript 的示例中，我们可以清楚地知道 getUserById 方法接收了一个不可缺省、number 类型的参数 id，返回的数据是一个异步的包含数字类型属性 id 和字符串类型属性 name 的对象。而且如果我们错误地调用该方法，比如第 5 行解构了一个不存在的属性 id2，就提示了一个 ts(2339) 错误，入参 &#x27;string&#x27; 类型不匹配也提示了一个 ts(2345) 错误。</p><p>通过两个示例的对比，Service 类型化的优势十分明显。</p><p>但是，在实际项目中，我们需要调用的接口少则数十个，多则成百上千，如果想通过手写 TypeScript 代码的方式定义清楚参数和返回值的类型结构，肯定不是一件轻松的事情。此时，我们可以借助一些工具，并基于格式化的接口文档自动生成 TypeScript 接口调用代码。</p><p>在业务实践中，前后端需要约定统一的接口规范，并使用格式化的 Swagger 或者 YAPI 等方式定义接口格式，然后自动生成 TypeScript 接口调用代码。目前，这块已经有很多成熟、开源的技术方案，例如<a target="_blank" rel="noopener noreferrer" href="https://swagger.io/tools/swagger-codegen/">Swagger Codegen<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>、<a target="_blank" rel="noopener noreferrer" href="https://github.com/acacode/swagger-typescript-api">swagger-typescript-api<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>、<a target="_blank" rel="noopener noreferrer" href="https://gogoyqj.github.io/auto-service/">Autos<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>、<a target="_blank" rel="noopener noreferrer" href="https://github.com/fjc0k/yapi-to-typescript">yapi-to-typescript<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>。</p><p>此外，对于前后端使用 GraphQL 交互的业务场景，我们也可以使用<a target="_blank" rel="noopener noreferrer" href="https://graphql-code-generator.com/">GraphQL Code Generator<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>等工具生成 TypeScript 接口调用代码。你可以通过官方文档了解这些自动化工具的更多信息，这里就不做深入介绍了。</p><p><strong>以上提到的 Service 类型化其实并未与 React 深度耦合，因此我们也可以在 Vue 或者其他框架中使用 TypeScript 手写或者基于工具生成接口调用代码。</strong></p><p>接下来我们将学习 TypeScript 在 React Component 中的应用，将其称之为 Component 类型化。</p><h4 id="component-类型化"><a aria-hidden="true" tabindex="-1" href="/blog/type-script入门实战笔记/04.模块三实战指南/04#component-类型化"><span class="icon icon-link"></span></a>Component 类型化</h4><p>Component 类型化的本质在于清晰地表达组件的属性、状态以及 JSX 元素的类型和结构。</p><blockquote><p>注意：TypeScript 中有专门的 .tsx 文件用来编写 React 组件，并且不能使用与 JSX 语法冲突的尖括号类型断言（“&lt;类型&gt;”）。此外，我们还需要确保安装了 @types/react、@types/react-dom 类型声明，里边定义了 React 和 ReactDOM 模块所有的接口和类型。</p></blockquote><p>我们首先了解一下最常用的几个接口和类型。</p><p><strong>（1）class 组件</strong></p><p>所有的 class 组件都是基于****React.Component 和 React.PureComponent 基类创建的，下面我们看一个具体示例：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">interface IEProps {</span></div><div class="token-line"><span class="token plain">      Cp?: React.ComponentClass&lt;{ id?: number }&gt;;</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    interface IEState { id: number; }</span></div><div class="token-line"><span class="token plain">    const ClassCp: React.ComponentClass&lt;IEProps, IEState&gt; = class ClassCp extends React.Component&lt;IEProps, IEState&gt; {</span></div><div class="token-line"><span class="token plain">      public state: IEState = { id: 1 };</span></div><div class="token-line"><span class="token plain">      render() {</span></div><div class="token-line"><span class="token plain">        const { Cp } = this.props as Required&lt;IEProps&gt;;</span></div><div class="token-line"><span class="token plain">        return &lt;Cp id={`${this.state.id}`} /&gt;; // ts(2322)</span></div><div class="token-line"><span class="token plain">      }</span></div><div class="token-line"><span class="token plain">      static defaultProps: Partial&lt;IEProps&gt; = {</span></div><div class="token-line"><span class="token plain">        Cp: class extends React.Component { render = () =&gt; null }</span></div><div class="token-line"><span class="token plain">      }</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>在示例中的第 5~14 行，因为 React.Component 基类接收了 IEProps 和 IEState 两个类型入参，并且类型化了 class 组件 E 的 props、state 和 defaultProps 属性，所以如果我们错误地调用了组件 props 中 Cp 属性，第 9 行就会提示一个 ts(2322) 错误。</p><p>然后我们可以使用接口类型 React.ComponentClass 来指代所有 class 组件的类型。例如在第 5 行，我们可以把 class 组件 ClassCp 赋值给 React.ComponentClass 类型的变量 ClassCp。</p><p>但在业务实践中，我们往往只使用 React.ComponentClass 来描述外部组件或者高阶组件属性的类型。比如在示例中的第 2 行，我们使用了 React.ComponentClass 描述 class 组件 E 的 Cp 属性，而不会像第 5 行那样，把定义好的 class 组件赋值给一个 React.ComponentClass 类型的变量。</p><p>此外，在定义 class 组件时，使用 public/private 控制属性/方法的可见性，以及使用Readonly 标记 state、props 为只读，都是特别推荐的实践经验。</p><p>下面我们看一个具体的示例：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">class ClassCpWithModifier extends React.Component&lt;Readonly&lt;IEProps&gt;, Readonly&lt;IEState&gt;&gt; {</span></div><div class="token-line"><span class="token plain">      private gid: number = 1;</span></div><div class="token-line"><span class="token plain">      public state: Readonly&lt;IEState&gt; = { id: 1 };</span></div><div class="token-line"><span class="token plain">      render() { return this.state.id = 2; } // ts(2540)</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>在示例中的第 2 行，如果我们不希望对外暴露 gid 属性，就可以把它标记为 private 私有。</p><p>如果我们想禁止直接修改 state、props 属性，则可以在第 1 行中使用 Readonly 包裹 IEProps、IEState。此时，如果我们在第 4 行直接给 state id 属性赋值，就会提示一个 ts(2540) 错误。</p><p><strong>函数组件</strong></p><p>我们可以使用类型 React.FunctionComponent（简写为 React.FC）描述函数组件的类型。因为函数组件没有 state 属性，所以我们只需要类型化 props。</p><p>下面我们看一个具体的示例：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">interface IEProps { id?: number; }</span></div><div class="token-line"><span class="token plain">    const ExplicitFC: React.FC&lt;IEProps&gt; = props =&gt; &lt;&gt;{props.id}&lt;/&gt;; // ok</span></div><div class="token-line"><span class="token plain">    ExplicitFC.defaultProps = { id: 1 } // ok id must be number</span></div><div class="token-line"><span class="token plain">    const ExplicitFCEle = &lt;ExplicitFC id={1} /&gt;; // ok id must be number</span></div><div class="token-line"><span class="token plain">    const ExplicitFCWithError: React.FC&lt;IEProps&gt; = props =&gt; &lt;&gt;{props.id2}&lt;/&gt;; // ts(2399)</span></div><div class="token-line"><span class="token plain">    ExplicitFCWithError.defaultProps = { id2: 1 } // ts(2332)</span></div><div class="token-line"><span class="token plain">    const thisIsJSX2 = &lt;ExplicitFCWithError id2={2} /&gt;; // ts(2332)</span></div></pre></div><p>在上述示例中，因为我们定义了类型是 React.FC<code>&lt;IEProps&gt;</code> 的组件 ExplicitFC、ExplicitFCWithError，且类型入参 IEProps 可以同时约束 props 参数和 defaultProps 属性的类型，所以第 2~4 行把 number 类型值赋予接口中已定义的 id 属性可以通过静态类型检测。但是，在第 5~7 行，因为操作了未定义的属性 id2，所以提示了 ts(2399)、 ts(2332) 错误。</p><blockquote><p>注意：函数组件返回值类型必须是 React.Element（稍后会详细介绍） 或者 null，反过来如果函数返回值类型是 React.Element 或者 null，即便未显式声明类型，函数也是合法的函数组件。</p></blockquote><p>如以下示例中，因为我们定义了未显式声明类型、返回值分别是 null 和 JSX 的函数 ImplicitFCReturnNull、ImplicitFCReturnJSX，所以第 3 行、第 6 行的这两个组件都可以用来创建 JSX。但是，因为第 8 行定义的返回值类型是 number 的函数 NotAFC，所以被用来创建 JSX 时会在第 9 行提示一个 ts(2786) 错误。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">function ImplicitFCReturnNull() { return null; }</span></div><div class="token-line"><span class="token plain">    ImplicitFCReturnNull.defaultProps = { id: 1 }</span></div><div class="token-line"><span class="token plain">    const ImplicitFCReturnNullEle = &lt;ImplicitFCReturnNull id={1} /&gt;; // ok id must be number</span></div><div class="token-line"><span class="token plain">    const ImplicitFCReturnJSX = () =&gt; &lt;&gt;&lt;/&gt;;</span></div><div class="token-line"><span class="token plain">    ImplicitFCReturnJSX.defaultProps = { id2: 1 }</span></div><div class="token-line"><span class="token plain">    const ImplicitFCReturnJSXEle = &lt;ImplicitFCReturnJSX id2={2} /&gt;; // ok</span></div><div class="token-line"><span class="token plain">    /** 分界线 **/</span></div><div class="token-line"><span class="token plain">    const NotAFC = () =&gt; 1; // </span></div><div class="token-line"><span class="token plain">    const WithError = &lt;NotAFC /&gt;; // ts(2786)</span></div></pre></div><p>对于编写函数组件而言，显式注解类型是一个好的实践，另外一个好的实践是用 props 解构代替定义 defaultProps 来指定默认属性的值。</p><p>此外，组件和泛型 class、函数一样，也是可以定义成接收若干个入参的泛型组件。</p><p>以列表组件为例，<strong>我们希望可以根据列表里渲染条目的类型（比如说“User”或“Todo”），分别使用不同的视图组件渲染条目，这个时候就需要使用泛型来约束表示条目类型的入参和视图渲染组件之间的类型关系。</strong></p><p>下面看一个具体的示例：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">export interface IUserItem {</span></div><div class="token-line"><span class="token plain">      username: string;</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    export function RenderUser(props: IUserItem): React.ReactElement {</span></div><div class="token-line"><span class="token plain">      return &lt;&gt;{props.username}&lt;/&gt;</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    export interface ITodoItem {</span></div><div class="token-line"><span class="token plain">      taskName: string;</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    export function RenderTodo(props: ITodoItem): React.ReactElement {</span></div><div class="token-line"><span class="token plain">      return &lt;&gt;{props.taskName}&lt;/&gt;</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    export function ListCp&lt;Item extends {}&gt;(props: { Cp: React.ComponentType&lt;Item&gt; }): React.ReactElement {</span></div><div class="token-line"><span class="token plain">      return &lt;&gt;&lt;/&gt;;</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    const UserList = &lt;ListCp&lt;IUserItem&gt; Cp={RenderUser} /&gt;; // ok</span></div><div class="token-line"><span class="token plain">    const TodoList = &lt;ListCp&lt;ITodoItem&gt; Cp={RenderTodo} /&gt;; // ok</span></div><div class="token-line"><span class="token plain">    const UserListError = &lt;ListCp&lt;ITodoItem&gt; Cp={RenderUser} /&gt;; // ts(2322)</span></div><div class="token-line"><span class="token plain">    const TodoListError = &lt;ListCp&lt;IUserItem&gt; Cp={RenderTodo} /&gt;; // ts(2322)</span></div></pre></div><p>在示例中的第 13 行，定义的泛型组件 ListCp 通过类型入参 Item 约束接收了 props 的 Cp 属性的具体类型。在第 16 行、第 17 行，因为类型入参 IUserItem、ITodoItem 和 Cp 属性 RenderUser、RenderTodo 类型一一对应，所以可以通过静态类型检测。但是，在第 18 行、第 19 行，因为对应关系不正确，所以提示了一个 ts(2322) 错误。</p><p><strong>class 组件和函数组件类型组成的联合类型被称之为组件类型 React.ComponentType，组件类型一般用来定义高阶组件的属性</strong>，如下代码所示：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">React.ComponentType&lt;P&gt; = React.ComponentClass&lt;P&gt; | React.FunctionComponent&lt;P&gt;;</span></div></pre></div><p>最后介绍几个常用类型：</p><ul><li><p><strong>元素类型 React.ElementType</strong>：指的是所有可以通过 JSX 语法创建元素的类型组合，包括html 原生标签（比如 div、a 等）和 React.ComponentType，元素类型可以接收一个表示 props 的类型入参；</p></li><li><p><strong>元素节点类型 React.ReactElement</strong>：指的是元素类型通过 JSX 语法创建的节点类型，它可以接收两个分别表示 props 和元素类型的类型入参；</p></li><li><p><strong>节点类型 React.ReactNode</strong>：指的是由 string、number、boolean、undefined、null、React.ReactElement 和元素类型是 React.ReactElement 的数组类型组成的联合类型，合法的 class 组件 render 方法返回值类型必须是 React.ReactNode；</p></li><li><p><strong>JSX 元素类型 JSX.Element</strong>：指的是元素类型通过 JSX 语法创建的节点类型，JSX.Element 等于 React.ReactElement&lt;any, any&gt;。</p></li></ul><p>以上就是 React Component 相关的类型及简单的类型化。</p><p>在实际业务中，因为组件接收的 props 数据可能来自路由、Redux，所以我们还需要对类型进行更明确的分解。</p><p>下面我们看一个具体的示例：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">import React from &#x27;react&#x27;; </span></div><div class="token-line"><span class="token plain">    import { bindActionCreators, Dispatch } from &quot;redux&quot;;</span></div><div class="token-line"><span class="token plain">    import { connect } from &quot;react-redux&quot;;</span></div><div class="token-line"><span class="token plain">    import { RouteComponentProps } from &#x27;react-router-dom&#x27;;</span></div><div class="token-line"><span class="token plain">    /** 路由 Props */</span></div><div class="token-line"><span class="token plain">    type RouteProps = RouteComponentProps&lt;{ routeId: string }&gt;;</span></div><div class="token-line"><span class="token plain">    /** Redux Store Props */</span></div><div class="token-line"><span class="token plain">    type StateProps = ReturnType&lt;typeof mapStateToProps&gt;;</span></div><div class="token-line"><span class="token plain">    function mapStateToProps(state: {}) {</span></div><div class="token-line"><span class="token plain">      return {</span></div><div class="token-line"><span class="token plain">        reduxId: 1</span></div><div class="token-line"><span class="token plain">      };</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    /** Redux Actions Props */</span></div><div class="token-line"><span class="token plain">    type DispatchProps = ReturnType&lt;typeof mapDispatchToProps&gt;;</span></div><div class="token-line"><span class="token plain">    function mapDispatchToProps(dispatch: Dispatch) {</span></div><div class="token-line"><span class="token plain">      return {</span></div><div class="token-line"><span class="token plain">        actions: bindActionCreators({</span></div><div class="token-line"><span class="token plain">          doSomething: () =&gt; void 0</span></div><div class="token-line"><span class="token plain">        }, dispatch),</span></div><div class="token-line"><span class="token plain">      };</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    /** 组件属性 */</span></div><div class="token-line"><span class="token plain">    interface IOwnProps {</span></div><div class="token-line"><span class="token plain">      ownId: number;</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    /** 最终 Props */</span></div><div class="token-line"><span class="token plain">    type CpProps = IOwnProps &amp; RouteProps &amp; StateProps &amp; DispatchProps;</span></div><div class="token-line"><span class="token plain">    const OriginalCp = (props: CpProps) =&gt; {</span></div><div class="token-line"><span class="token plain">      const {</span></div><div class="token-line"><span class="token plain">        match: { params: { routeId } }, // 路由 Props</span></div><div class="token-line"><span class="token plain">        reduxId, // Redux Props</span></div><div class="token-line"><span class="token plain">        ownId, // 组件 Props</span></div><div class="token-line"><span class="token plain">        actions: {</span></div><div class="token-line"><span class="token plain">          doSomething // Action Props</span></div><div class="token-line"><span class="token plain">        },</span></div><div class="token-line"><span class="token plain">      } = props;</span></div><div class="token-line"><span class="token plain">      return null;</span></div><div class="token-line"><span class="token plain">    };</span></div><div class="token-line"><span class="token plain">    const ConnectedCp = connect&lt;StateProps, DispatchProps, IOwnProps&gt;(mapStateToProps, mapDispatchToProps)(OriginalCp as React.ComponentType&lt;IOwnProps&gt;);</span></div><div class="token-line"><span class="token plain">    const ConnectedCpJSX = &lt;ConnectedCp ownId={1} /&gt;; // ok</span></div></pre></div><p>在第 7 行，我们定义了 RouteProps，描述的是从路由中获取的属性。在第 9 行获取了 mapStateToProps 函数返回值类型 StateProps，描述的是从 Redux Store 中获取的属性。</p><p>在第 16 行，我们获取了 mapDispatchToProps 函数返回值类型 DispatchProps，描述的是 Redux Actions 属性。在第 25 行，我们定义的是组件自有的属性，所以最终组件 OriginalCp 的属性类型 CpProps 是 RouteProps、StateProps、DispatchProps 和 IOwnProps 四个类型的交叉类型。在第 31~38 行，我们解构了 props 中不同来源的属性、方法，并且可以通过静态类型检测。</p><p><strong>这里插播一道思考题：以上示例会提示一个缺少 react-redux、react-router-dom 类型声明的错误，应该如何解决呢？</strong></p><blockquote><p>注意：在示例中的第 41 行，connect 之前，我们把组件 OriginalCp 断言为 React.ComponentType 类型，这样在第 42 行使用组件的时候，就只需要传入 IOwnProps 中定义的属性（因为 RouteProps、StateProps、DispatchProps 属性可以通过路由或者 connect 自动注入）。</p></blockquote><p>这里使用的类型断言是开发 HOC 高阶组件（上边示例中 connect(mapStateToProps, mapDispatchToProps) 返回的是一个高阶组件）的一个惯用技巧，一般我们可以通过划分 HOCProps、IOwnProps 或 Omit 来剔除高阶组件注入的属性，如下示例中的第 4 行、第 5 行。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">interface IHOCProps { injectId: number; }</span></div><div class="token-line"><span class="token plain">    interface IOwnProps { ownId: number; }</span></div><div class="token-line"><span class="token plain">    const hoc = &lt;C extends React.ComponentType&lt;any&gt;&gt;(cp: C) =&gt; cp;</span></div><div class="token-line"><span class="token plain">    const InjectedCp1 = hoc(OriginalCp as React.ComponentType&lt;IOwnProps&gt;);</span></div><div class="token-line"><span class="token plain">    const InjectedCp2 = hoc(OriginalCp as React.ComponentType&lt;Omit&lt;IHOCProps &amp; IOwnProps, &#x27;injectId&#x27;&gt;&gt;);</span></div></pre></div><p>组件类型化还涉及 Hooks 等知识点，限于篇幅，本文就不继续展开了。</p><p>接下来我们简单了解一下使用 Redux 进行状态管理技术方案的类型化，将其称之为 Redux 类型化。</p><h4 id="redux-类型化"><a aria-hidden="true" tabindex="-1" href="/blog/type-script入门实战笔记/04.模块三实战指南/04#redux-类型化"><span class="icon icon-link"></span></a>Redux 类型化</h4><p>Redux 类型化涉及 state、action、reducer 三要素类型化，具体示例如下：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// src/redux/user.ts</span></div><div class="token-line"><span class="token plain">    // state</span></div><div class="token-line"><span class="token plain">    interface IUserInfoState {</span></div><div class="token-line"><span class="token plain">      userid?: number;</span></div><div class="token-line"><span class="token plain">      username?: string;</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    export const initialState: IUserInfoState = {};</span></div><div class="token-line"><span class="token plain">    // action</span></div><div class="token-line"><span class="token plain">    interface LoginAction {</span></div><div class="token-line"><span class="token plain">      type: &#x27;userinfo/login&#x27;;</span></div><div class="token-line"><span class="token plain">      payload: Required&lt;IUserInfoState&gt;;</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    interface LogoutAction {</span></div><div class="token-line"><span class="token plain">      type: &#x27;userinfo/logout&#x27;;</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    export function doLogin(): LoginAction {</span></div><div class="token-line"><span class="token plain">      return {</span></div><div class="token-line"><span class="token plain">        type: &#x27;userinfo/login&#x27;,</span></div><div class="token-line"><span class="token plain">        payload: {</span></div><div class="token-line"><span class="token plain">          userid: 101,</span></div><div class="token-line"><span class="token plain">          username: &#x27;乾元亨利贞&#x27;</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">      };</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    export function doLogout(): LogoutAction {</span></div><div class="token-line"><span class="token plain">      return {</span></div><div class="token-line"><span class="token plain">        type: &#x27;userinfo/logout&#x27;</span></div><div class="token-line"><span class="token plain">      };</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    // reducer</span></div><div class="token-line"><span class="token plain">    export function applyUserInfo(state = initialState, action: LoginAction | LogoutAction): IUserInfoState {</span></div><div class="token-line"><span class="token plain">      switch (action.type) {</span></div><div class="token-line"><span class="token plain">        case &#x27;userinfo/login&#x27;:</span></div><div class="token-line"><span class="token plain">          return {</span></div><div class="token-line"><span class="token plain">            ...action.payload</span></div><div class="token-line"><span class="token plain">          };</span></div><div class="token-line"><span class="token plain">        case &#x27;userinfo/logout&#x27;:</span></div><div class="token-line"><span class="token plain">          return {};</span></div><div class="token-line"><span class="token plain">      }</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>在示例中的第 2~7 行，我们定义了 state 的详细类型，并在第 8~29 行分别定义了表示登入、登出的 action 类型和函数，还在第 30~40 行定义了处理前边定义的 action 的 reducer 函数。</p><p>然后，我们就将类型化后的 state、action、reducer 合并到 redux store，再通过 react-redux 关联 React，这样组件在 connect 之后，就能和 Redux 交互了。</p><p>不过，因为 state、action、reducer 分别类型化的形式写起来十分复杂，所以我们可以借助 typesafe-actions、redux-actions、rematch、dvajs、@ekit/model 等工具更清晰、高效地组织 Redux 代码。限于篇幅，这里就不做深入介绍了，你可以自行到<a target="_blank" rel="noopener noreferrer" href="https://www.npmjs.com/">https://www.npmjs.com/<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>上查看更多信息。</p><h4 id="单元测试"><a aria-hidden="true" tabindex="-1" href="/blog/type-script入门实战笔记/04.模块三实战指南/04#单元测试"><span class="icon icon-link"></span></a>单元测试</h4><p>我们可以选择 Jest + Enzyme + jsdom + ReactTestUtils 作为 React + TypeScript 应用的单元测试技术方案，不过麻烦的地方在于需要手动配置 Jest、Enzyme。因此，我更推荐选择<a target="_blank" rel="noopener noreferrer" href="https://github.com/testing-library/react-testing-library">react-testing-library<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>这个方案，这也是 create-react-app 默认内置的单元测试方案。</p><p>如下示例，我们为前边定义的 RenderUser 组件编写了单元测试。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">import React from &#x27;react&#x27;;</span></div><div class="token-line"><span class="token plain">    import { render, screen } from &#x27;@testing-library/react&#x27;;</span></div><div class="token-line"><span class="token plain">    import { RenderUser } from &#x27;./Cp&#x27;;</span></div><div class="token-line"><span class="token plain">    test(&#x27;renders learn react link&#x27;, () =&gt; {</span></div><div class="token-line"><span class="token plain">      render(&lt;RenderUser username={&#x27;乾元亨利贞&#x27;} /&gt;);</span></div><div class="token-line"><span class="token plain">      const linkElement = screen.getByText(/乾元亨利贞/i);</span></div><div class="token-line"><span class="token plain">      expect(linkElement).toBeInTheDocument();</span></div><div class="token-line"><span class="token plain">    });</span></div></pre></div><blockquote><p>注意：以上介绍的单测执行环境是 Node.js，TypeScript 会被转译成 CommonJS 格式，而在浏览器端运行时，则会被转译成 ES 格式。因此，不同模块之间存在循环依赖时，转译后代码在浏览器端可以正确运行，而在 Node.js 端运行时可能会出现引入的其他模块成员未定义（undefined）的错误。</p></blockquote><h3 id="小结和预告"><a aria-hidden="true" tabindex="-1" href="/blog/type-script入门实战笔记/04.模块三实战指南/04#小结和预告"><span class="icon icon-link"></span></a>小结和预告</h3><p>以上就是 TypeScript 和 Dom 原生操作及结合 React 框架在 Web 侧开发的实践建议，其核心在于类型化 Dom API 和 React 组件、Redux 和 Service。</p><p>插播一道思考题：类型化 React 组件的要义是什么？欢迎你在留言区进行互动、交流。</p><p>20 讲我们将学习如何从 JavaScript 迁移到 TypeScript，敬请期待。</p><p>另外，如果你觉得本专栏有价值，欢迎分享给更多好友~</p></div><div class="__dumi-default-layout-footer-meta"><a target="_blank" rel="noopener noreferrer" href="https://github.com/GGwujun/blog/edit/master/docs/type-script入门实战笔记/04.模块三实战指南/04.md">在 GitHub 上编辑此页<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a><span data-updated-text="最后更新时间：">5/2/2022 10:56:53</span></div></div></div></div>
	<script>
  window.g_useSSR = true;
  window.g_initialProps = {};
	</script>

    <script>
      (function () {
        if (!location.port) {
          (function (i, s, o, g, r, a, m) {
            i["GoogleAnalyticsObject"] = r;
            (i[r] =
              i[r] ||
              function () {
                (i[r].q = i[r].q || []).push(arguments);
              }),
              (i[r].l = 1 * new Date());
            (a = s.createElement(o)), (m = s.getElementsByTagName(o)[0]);
            a.async = 1;
            a.src = g;
            m.parentNode.insertBefore(a, m);
          })(
            window,
            document,
            "script",
            "//www.google-analytics.com/analytics.js",
            "ga"
          );
          ga("create", "UA-149864185-1", "auto");
          ga("send", "pageview");
        }
      })();
    </script>
    <script src="/blog/umi.js"></script>
  </body>
</html>
