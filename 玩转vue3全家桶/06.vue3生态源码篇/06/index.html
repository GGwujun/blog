<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no"
    />
    <link rel="shortcut icon" type="image/x-icon" href="/logo.png" />
    <link rel="stylesheet" href="/blog/umi.css" />
    <script>
      window.routerBase = "/blog";
    </script>
    <script>
      //! umi version: 3.5.17
    </script>
    <script>
      !(function () {
        var e = localStorage.getItem("dumi:prefers-color"),
          t = window.matchMedia("(prefers-color-scheme: dark)").matches,
          r = ["light", "dark", "auto"];
        document.documentElement.setAttribute(
          "data-prefers-color",
          e === r[2] ? (t ? r[1] : r[0]) : r.indexOf(e) > -1 ? e : r[0]
        );
      })();
    </script>
    <title>33 | 编译原理（中）：Vue Compiler模块全解析</title>
  </head>
  <body>
    <div id="root"><div class="__dumi-default-layout" data-route="/玩转vue3全家桶/06.vue3生态源码篇/06" data-show-sidemenu="true" data-show-slugs="true" data-site-mode="true" data-gapless="false"><div class="__dumi-default-navbar" data-mode="site"><button class="__dumi-default-navbar-toggle"></button><a class="__dumi-default-navbar-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog/">大师兄</a><nav><div class="__dumi-default-search"><input type="search" class="__dumi-default-search-input" value=""/><ul></ul></div><span>计算机基础<ul><li><a href="/blog/编译原理之美">编译原理之美</a></li><li><a href="/blog/编译原理实战">编译原理实战</a></li><li><a href="/blog/深入浅出计算机组成原理">深入浅出计算机组成原理</a></li><li><a href="/blog/详解http">详解http</a></li><li><a href="/blog/计算机网络通关29讲">计算机网络通关29讲</a></li><li><a href="/blog/网络排查案例课">网络排查案例课</a></li><li><a href="/blog/linux操作系统">linux操作系统</a></li><li><a href="/blog/linux性能优化实战">linux性能优化实战</a></li><li><a href="/blog/程序员数学基础">程序员数学基础</a></li><li><a href="/blog/趣谈网络协议">趣谈网络协议</a></li><li><a href="/blog/操作系统实战">操作系统实战</a></li><li><a href="/blog/软件工程之美">软件工程之美</a></li><li><a href="/blog/sql必知必会">sql必知必会</a></li><li><a href="/blog/操作系统实战45讲">操作系统实战45讲</a></li><li><a href="/blog/网络编程实战">网络编程实战</a></li></ul></span><span>算法<ul><li><a href="/blog/常用算法25讲">常用算法25讲</a></li><li><a href="/blog/数据结构与算法之美">数据结构与算法之美</a></li><li><a href="/blog/业务开发算法50讲">业务开发算法50讲</a></li><li><a href="/blog/动态规划面试宝典">动态规划面试宝典</a></li></ul></span><span>前端开发<ul><li><a href="/blog/浏览器工作原理与实践">浏览器工作原理与实践</a></li><li><a href="/blog/新时代产品经理进阶之路">新时代产品经理进阶之路</a></li><li><a href="/blog/全栈工程师修炼指南">全栈工程师修炼指南</a></li><li><a href="/blog/flutter核心技术与实战">flutter核心技术与实战</a></li><li><a href="/blog/java-script核心原理解析">java-script核心原理解析</a></li><li><a href="/blog/说透低代码">说透低代码</a></li><li><a href="/blog/nodejs应用开发实战">nodejs应用开发实战</a></li><li><a href="/blog/反爬虫兵法演绎20讲">反爬虫兵法演绎20讲</a></li><li><a href="/blog/reactnative新架构实战课">reactnative新架构实战课</a></li><li><a href="/blog/正则表达式入门">正则表达式入门</a></li><li><a href="/blog/重学前端">重学前端</a></li><li><a href="/blog/serverless入门课">serverless入门课</a></li><li><a href="/blog/type-script入门实战笔记">type-script入门实战笔记</a></li><li><a href="/blog/图解googlev8">图解googlev8</a></li><li><a href="/blog/vue3源码分析">vue3源码分析</a></li><li><a aria-current="page" class="active" href="/blog/玩转Vue3全家桶">玩转Vue3全家桶</a></li><li><a href="/blog/webassembly入门">webassembly入门</a></li><li><a href="/blog/手把手带你写一个Web框架">手把手带你写一个Web框架</a></li><li><a href="/blog/web漏洞挖掘实战">web漏洞挖掘实战</a></li><li><a href="/blog/跟月影学可视化">跟月影学可视化</a></li><li><a href="/blog/搞定音频技术">搞定音频技术</a></li><li><a href="/blog/攻克视频技术">攻克视频技术</a></li></ul></span><span>前端工程化<ul><li><a href="/blog/logger">logger</a></li><li><a href="/blog/webpack">webpack</a></li><li><a href="/blog/webpackChain">webpackChain</a></li></ul></span><span>前端性能优化<ul><li><a href="/blog/react性能调优">react性能调优</a></li></ul></span><span>软件测试<ul><li><a href="/blog/全链路压测实战30讲">全链路压测实战30讲</a></li><li><a href="/blog/性能测试实战30讲">性能测试实战30讲</a></li><li><a href="/blog/自动化测试高手课">自动化测试高手课</a></li><li><a href="/blog/软件测试52讲">软件测试52讲</a></li></ul></span><span>面试<ul><li><a href="/blog/面试现场">面试现场</a></li></ul></span><span>杂谈<ul><li><a href="/blog/超级访谈对话张雪峰">超级访谈对话张雪峰</a></li><li><a href="/blog/Git实战手册">Git实战手册</a></li><li><a href="/blog/NodeJS">NodeJS</a></li><li><a href="/blog/ReactJS">ReactJS</a></li><li><a href="/blog/UI设计">UI设计</a></li><li><a href="/blog/webpack4系列教程">webpack4系列教程</a></li><li><a href="/blog/前端知识体系">前端知识体系</a></li><li><a href="/blog/剑指offer刷题笔记">剑指offer刷题笔记</a></li><li><a href="/blog/思考与成长">思考与成长</a></li><li><a href="/blog/设计模式手册">设计模式手册</a></li></ul></span><div class="__dumi-default-navbar-tool"><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "></div></div></div></nav></div><div class="__dumi-default-menu" data-mode="site"><div class="__dumi-default-menu-inner"><div class="__dumi-default-menu-header"><a class="__dumi-default-menu-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog/"></a><h1>大师兄</h1><p></p></div><div class="__dumi-default-menu-mobile-area"><ul class="__dumi-default-menu-nav-list"><li>计算机基础<ul><li><a href="/blog/编译原理之美">编译原理之美</a></li><li><a href="/blog/编译原理实战">编译原理实战</a></li><li><a href="/blog/深入浅出计算机组成原理">深入浅出计算机组成原理</a></li><li><a href="/blog/详解http">详解http</a></li><li><a href="/blog/计算机网络通关29讲">计算机网络通关29讲</a></li><li><a href="/blog/网络排查案例课">网络排查案例课</a></li><li><a href="/blog/linux操作系统">linux操作系统</a></li><li><a href="/blog/linux性能优化实战">linux性能优化实战</a></li><li><a href="/blog/程序员数学基础">程序员数学基础</a></li><li><a href="/blog/趣谈网络协议">趣谈网络协议</a></li><li><a href="/blog/操作系统实战">操作系统实战</a></li><li><a href="/blog/软件工程之美">软件工程之美</a></li><li><a href="/blog/sql必知必会">sql必知必会</a></li><li><a href="/blog/操作系统实战45讲">操作系统实战45讲</a></li><li><a href="/blog/网络编程实战">网络编程实战</a></li></ul></li><li>算法<ul><li><a href="/blog/常用算法25讲">常用算法25讲</a></li><li><a href="/blog/数据结构与算法之美">数据结构与算法之美</a></li><li><a href="/blog/业务开发算法50讲">业务开发算法50讲</a></li><li><a href="/blog/动态规划面试宝典">动态规划面试宝典</a></li></ul></li><li>前端开发<ul><li><a href="/blog/浏览器工作原理与实践">浏览器工作原理与实践</a></li><li><a href="/blog/新时代产品经理进阶之路">新时代产品经理进阶之路</a></li><li><a href="/blog/全栈工程师修炼指南">全栈工程师修炼指南</a></li><li><a href="/blog/flutter核心技术与实战">flutter核心技术与实战</a></li><li><a href="/blog/java-script核心原理解析">java-script核心原理解析</a></li><li><a href="/blog/说透低代码">说透低代码</a></li><li><a href="/blog/nodejs应用开发实战">nodejs应用开发实战</a></li><li><a href="/blog/反爬虫兵法演绎20讲">反爬虫兵法演绎20讲</a></li><li><a href="/blog/reactnative新架构实战课">reactnative新架构实战课</a></li><li><a href="/blog/正则表达式入门">正则表达式入门</a></li><li><a href="/blog/重学前端">重学前端</a></li><li><a href="/blog/serverless入门课">serverless入门课</a></li><li><a href="/blog/type-script入门实战笔记">type-script入门实战笔记</a></li><li><a href="/blog/图解googlev8">图解googlev8</a></li><li><a href="/blog/vue3源码分析">vue3源码分析</a></li><li><a aria-current="page" class="active" href="/blog/玩转Vue3全家桶">玩转Vue3全家桶</a></li><li><a href="/blog/webassembly入门">webassembly入门</a></li><li><a href="/blog/手把手带你写一个Web框架">手把手带你写一个Web框架</a></li><li><a href="/blog/web漏洞挖掘实战">web漏洞挖掘实战</a></li><li><a href="/blog/跟月影学可视化">跟月影学可视化</a></li><li><a href="/blog/搞定音频技术">搞定音频技术</a></li><li><a href="/blog/攻克视频技术">攻克视频技术</a></li></ul></li><li>前端工程化<ul><li><a href="/blog/logger">logger</a></li><li><a href="/blog/webpack">webpack</a></li><li><a href="/blog/webpackChain">webpackChain</a></li></ul></li><li>前端性能优化<ul><li><a href="/blog/react性能调优">react性能调优</a></li></ul></li><li>软件测试<ul><li><a href="/blog/全链路压测实战30讲">全链路压测实战30讲</a></li><li><a href="/blog/性能测试实战30讲">性能测试实战30讲</a></li><li><a href="/blog/自动化测试高手课">自动化测试高手课</a></li><li><a href="/blog/软件测试52讲">软件测试52讲</a></li></ul></li><li>面试<ul><li><a href="/blog/面试现场">面试现场</a></li></ul></li><li>杂谈<ul><li><a href="/blog/超级访谈对话张雪峰">超级访谈对话张雪峰</a></li><li><a href="/blog/Git实战手册">Git实战手册</a></li><li><a href="/blog/NodeJS">NodeJS</a></li><li><a href="/blog/ReactJS">ReactJS</a></li><li><a href="/blog/UI设计">UI设计</a></li><li><a href="/blog/webpack4系列教程">webpack4系列教程</a></li><li><a href="/blog/前端知识体系">前端知识体系</a></li><li><a href="/blog/剑指offer刷题笔记">剑指offer刷题笔记</a></li><li><a href="/blog/思考与成长">思考与成长</a></li><li><a href="/blog/设计模式手册">设计模式手册</a></li></ul></li></ul><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "><button title="Dark theme" class="__dumi-default-dark-moon "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="3854" width="22" height="22"><path d="M991.816611 674.909091a69.166545 69.166545 0 0 0-51.665455-23.272727 70.795636 70.795636 0 0 0-27.438545 5.585454A415.674182 415.674182 0 0 1 754.993338 698.181818c-209.594182 0-393.472-184.785455-393.472-395.636363 0-52.363636 38.539636-119.621818 69.515637-173.614546 4.887273-8.610909 9.634909-16.756364 14.103272-24.901818A69.818182 69.818182 0 0 0 384.631156 0a70.842182 70.842182 0 0 0-27.438545 5.585455C161.678429 90.298182 14.362065 307.898182 14.362065 512c0 282.298182 238.824727 512 532.38691 512a522.286545 522.286545 0 0 0 453.957818-268.334545A69.818182 69.818182 0 0 0 991.816611 674.909091zM546.679156 954.181818c-248.785455 0-462.941091-192-462.941091-442.181818 0-186.647273 140.637091-372.829091 300.939637-442.181818-36.817455 65.629091-92.578909 151.970909-92.578909 232.727273 0 250.181818 214.109091 465.454545 462.917818 465.454545a488.331636 488.331636 0 0 0 185.181091-46.545455 453.003636 453.003636 0 0 1-393.565091 232.727273z m103.656728-669.323636l-14.266182 83.781818a34.909091 34.909091 0 0 0 50.362182 36.770909l74.775272-39.563636 74.752 39.563636a36.142545 36.142545 0 0 0 16.174546 3.956364 34.909091 34.909091 0 0 0 34.210909-40.727273l-14.289455-83.781818 60.509091-59.345455a35.025455 35.025455 0 0 0-19.223272-59.578182l-83.61891-12.101818-37.376-76.101818a34.56 34.56 0 0 0-62.254545 0l-37.376 76.101818-83.618909 12.101818a34.909091 34.909091 0 0 0-19.246546 59.578182z m70.423272-64.698182a34.280727 34.280727 0 0 0 26.135273-19.083636l14.312727-29.090909 14.336 29.090909a34.257455 34.257455 0 0 0 26.135273 19.083636l32.046546 4.887273-23.272728 22.574545a35.234909 35.234909 0 0 0-10.007272 30.952727l5.46909 32.116364-28.625454-15.127273a34.490182 34.490182 0 0 0-32.302546 0l-28.695272 15.127273 5.469091-32.116364a35.141818 35.141818 0 0 0-9.984-30.952727l-23.272728-22.574545z" p-id="3855"></path></svg></button><button title="Light theme" class="__dumi-default-dark-sun "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="4026" width="22" height="22"><path d="M915.2 476.16h-43.968c-24.704 0-44.736 16-44.736 35.84s20.032 35.904 44.736 35.904H915.2c24.768 0 44.8-16.064 44.8-35.904s-20.032-35.84-44.8-35.84zM512 265.6c-136.704 0-246.464 109.824-246.464 246.4 0 136.704 109.76 246.464 246.464 246.464S758.4 648.704 758.4 512c0-136.576-109.696-246.4-246.4-246.4z m0 425.6c-99.008 0-179.2-80.128-179.2-179.2 0-98.944 80.192-179.2 179.2-179.2S691.2 413.056 691.2 512c0 99.072-80.192 179.2-179.2 179.2zM197.44 512c0-19.84-19.136-35.84-43.904-35.84H108.8c-24.768 0-44.8 16-44.8 35.84s20.032 35.904 44.8 35.904h44.736c24.768 0 43.904-16.064 43.904-35.904zM512 198.464c19.776 0 35.84-20.032 35.84-44.8v-44.8C547.84 84.032 531.84 64 512 64s-35.904 20.032-35.904 44.8v44.8c0 24.768 16.128 44.864 35.904 44.864z m0 627.136c-19.776 0-35.904 20.032-35.904 44.8v44.736C476.096 940.032 492.16 960 512 960s35.84-20.032 35.84-44.8v-44.736c0-24.768-16.064-44.864-35.84-44.864z m329.92-592.832c17.472-17.536 20.288-43.072 6.4-57.024-14.016-14.016-39.488-11.2-57.024 6.336-4.736 4.864-26.496 26.496-31.36 31.36-17.472 17.472-20.288 43.008-6.336 57.024 13.952 14.016 39.488 11.2 57.024-6.336 4.8-4.864 26.496-26.56 31.296-31.36zM213.376 759.936c-4.864 4.8-26.56 26.624-31.36 31.36-17.472 17.472-20.288 42.944-6.4 56.96 14.016 13.952 39.552 11.2 57.024-6.336 4.8-4.736 26.56-26.496 31.36-31.36 17.472-17.472 20.288-43.008 6.336-56.96-14.016-13.952-39.552-11.072-56.96 6.336z m19.328-577.92c-17.536-17.536-43.008-20.352-57.024-6.336-14.08 14.016-11.136 39.488 6.336 57.024 4.864 4.864 26.496 26.56 31.36 31.424 17.536 17.408 43.008 20.288 56.96 6.336 14.016-14.016 11.264-39.488-6.336-57.024-4.736-4.864-26.496-26.56-31.296-31.424z m527.168 628.608c4.864 4.864 26.624 26.624 31.36 31.424 17.536 17.408 43.072 20.224 57.088 6.336 13.952-14.016 11.072-39.552-6.4-57.024-4.864-4.8-26.56-26.496-31.36-31.36-17.472-17.408-43.072-20.288-57.024-6.336-13.952 14.016-11.008 39.488 6.336 56.96z" p-id="4027"></path></svg></button><button title="Default to system" class="__dumi-default-dark-auto "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="11002" width="22" height="22"><path d="M127.658667 492.885333c0-51.882667 10.24-101.717333 30.378666-149.162666s47.786667-88.064 81.92-122.538667 75.093333-61.781333 122.538667-81.92 96.938667-30.378667 149.162667-30.378667 101.717333 10.24 149.162666 30.378667 88.405333 47.786667 122.88 81.92 61.781333 75.093333 81.92 122.538667 30.378667 96.938667 30.378667 149.162666-10.24 101.717333-30.378667 149.162667-47.786667 88.405333-81.92 122.88-75.093333 61.781333-122.88 81.92-97.28 30.378667-149.162666 30.378667-101.717333-10.24-149.162667-30.378667-88.064-47.786667-122.538667-81.92-61.781333-75.093333-81.92-122.88-30.378667-96.938667-30.378666-149.162667z m329.045333 0c0 130.048 13.994667 244.394667 41.984 343.381334h12.970667c46.762667 0 91.136-9.216 133.461333-27.306667s78.848-42.666667 109.568-73.386667 54.954667-67.242667 73.386667-109.568 27.306667-86.698667 27.306666-133.461333c0-46.421333-9.216-90.794667-27.306666-133.12s-42.666667-78.848-73.386667-109.568-67.242667-54.954667-109.568-73.386667-86.698667-27.306667-133.461333-27.306666h-11.605334c-28.672 123.562667-43.349333 237.909333-43.349333 343.722666z" p-id="11003"></path></svg></button></div></div></div><ul class="__dumi-default-menu-list"><li><a href="/blog/">大师兄 - 前端架构师</a></li></ul></div></div><ul role="slug-list" class="__dumi-default-layout-toc"><li title="Vue compiler入口分析" data-depth="2"><a href="/blog/玩转vue3全家桶/06.vue3生态源码篇/06#vue-compiler入口分析"><span>Vue compiler入口分析</span></a></li><li title="Vue浏览器端编译的核心流程" data-depth="2"><a href="/blog/玩转vue3全家桶/06.vue3生态源码篇/06#vue浏览器端编译的核心流程"><span>Vue浏览器端编译的核心流程</span></a></li><li title="AST的语义化分析" data-depth="2"><a href="/blog/玩转vue3全家桶/06.vue3生态源码篇/06#ast的语义化分析"><span>AST的语义化分析</span></a></li><li title="template到render函数的转化" data-depth="2"><a href="/blog/玩转vue3全家桶/06.vue3生态源码篇/06#template到render函数的转化"><span>template到render函数的转化</span></a></li><li title="总结" data-depth="2"><a href="/blog/玩转vue3全家桶/06.vue3生态源码篇/06#总结"><span>总结</span></a></li><li title="思考题" data-depth="2"><a href="/blog/玩转vue3全家桶/06.vue3生态源码篇/06#思考题"><span>思考题</span></a></li></ul><div class="__dumi-default-layout-content"><div class="markdown"><h1 id="33--编译原理中vue-compiler模块全解析"><a aria-hidden="true" tabindex="-1" href="/blog/玩转vue3全家桶/06.vue3生态源码篇/06#33--编译原理中vue-compiler模块全解析"><span class="icon icon-link"></span></a>33 | 编译原理（中）：Vue Compiler模块全解析</h1><p>你好，我是大圣。</p><p>上一讲我带你手写了一个迷你的Vue compiler，还学习了编译原理的基础知识。通过实现这个迷你Vue compiler，我们知道了tokenizer可以用来做语句分析，而parse负责生成抽象语法树AST。然后我们一起分析AST中的Vue语法，最后通过generate函数生成最终的代码。</p><p>今天我就带你深入Vue的compiler源码之中，看看Vue内部到底是怎么实现的。有了上一讲编译原理的入门基础，你会对Compiler执行全流程有更深的理解。</p><h2 id="vue-compiler入口分析"><a aria-hidden="true" tabindex="-1" href="/blog/玩转vue3全家桶/06.vue3生态源码篇/06#vue-compiler入口分析"><span class="icon icon-link"></span></a>Vue compiler入口分析</h2><p>Vue 3内部有4个和compiler相关的包。compiler-dom和compiler-core负责实现浏览器端的编译，这两个包是我们需要深入研究的，compiler-ssr负责服务器端渲染，我们后面讲ssr的时候再研究，compiler-sfc是编译.vue单文件组件的，有兴趣的同学可以自行探索。</p><p>首先我们进入到vue-next/packages/compiler-dom/index.ts文件下，在<a target="_blank" rel="noopener noreferrer" href="https://github.com/vuejs/vue-next/blob/master/packages/compiler-dom/src/index.ts#L40">GitHub<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>上你可以找到下面这段代码。</p><p>compiler函数有两个参数，第一个参数template，它是我们项目中的模板字符串；第二个参数options是编译的配置，内部调用了baseCompile函数。我们可以看到，这里的调用关系和runtime-dom、runtime-core的关系类似，compiler-dom负责传入浏览器Dom相关的API，实际编译的baseCompile是由compiler-core提供的。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">export function compile(</span></div><div class="token-line"><span class="token plain">      template: string,</span></div><div class="token-line"><span class="token plain">      options: CompilerOptions = {}</span></div><div class="token-line"><span class="token plain">    ): CodegenResult {</span></div><div class="token-line"><span class="token plain">      return baseCompile(</span></div><div class="token-line"><span class="token plain">        template,</span></div><div class="token-line"><span class="token plain">        extend({}, parserOptions, options, {</span></div><div class="token-line"><span class="token plain">          nodeTransforms: [</span></div><div class="token-line"><span class="token plain">            // ignore &lt;script&gt; and &lt;tag&gt;</span></div><div class="token-line"><span class="token plain">            // this is not put inside DOMNodeTransforms because that list is used</span></div><div class="token-line"><span class="token plain">            // by compiler-ssr to generate vnode fallback branches</span></div><div class="token-line"><span class="token plain">            ignoreSideEffectTags,</span></div><div class="token-line"><span class="token plain">            ...DOMNodeTransforms,</span></div><div class="token-line"><span class="token plain">            ...(options.nodeTransforms || [])</span></div><div class="token-line"><span class="token plain">          ],</span></div><div class="token-line"><span class="token plain">          directiveTransforms: extend(</span></div><div class="token-line"><span class="token plain">            {},</span></div><div class="token-line"><span class="token plain">            DOMDirectiveTransforms,</span></div><div class="token-line"><span class="token plain">            options.directiveTransforms || {}</span></div><div class="token-line"><span class="token plain">          ),</span></div><div class="token-line"><span class="token plain">          transformHoist: __BROWSER__ ? null : stringifyStatic</span></div><div class="token-line"><span class="token plain">        })</span></div><div class="token-line"><span class="token plain">      )</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>我们先来看看compiler-dom做了哪些额外的配置。</p><p>首先，parserOption传入了parse的配置，通过parserOption传递的isNativeTag来区分element和component。这里的实现也非常简单，把所有html的标签名存储在一个对象中，然后就可以很轻松地判断出div是浏览器自带的element。</p><p>baseCompile传递的其他参数nodeTransforms和directiveTransforms，它们做的也是和上面代码类似的事。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">export const parserOptions: ParserOptions = {</span></div><div class="token-line"><span class="token plain">      isVoidTag,</span></div><div class="token-line"><span class="token plain">      isNativeTag: tag =&gt; isHTMLTag(tag) || isSVGTag(tag),</span></div><div class="token-line"><span class="token plain">      isPreTag: tag =&gt; tag === &#x27;pre&#x27;,</span></div><div class="token-line"><span class="token plain">      decodeEntities: __BROWSER__ ? decodeHtmlBrowser : decodeHtml,</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">      isBuiltInComponent: (tag: string): symbol | undefined =&gt; {</span></div><div class="token-line"><span class="token plain">        if (isBuiltInType(tag, `Transition`)) {</span></div><div class="token-line"><span class="token plain">          return TRANSITION</span></div><div class="token-line"><span class="token plain">        } else if (isBuiltInType(tag, `TransitionGroup`)) {</span></div><div class="token-line"><span class="token plain">          return TRANSITION_GROUP</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">      },</span></div><div class="token-line"><span class="token plain">      ...</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    const HTML_TAGS =</span></div><div class="token-line"><span class="token plain">      &#x27;html,body,base,head,link,meta,style,title,address,article,aside,footer,&#x27; +</span></div><div class="token-line"><span class="token plain">      &#x27;header,h1,h2,h3,h4,h5,h6,nav,section,div,dd,dl,dt,figcaption,&#x27; +</span></div><div class="token-line"><span class="token plain">      &#x27;figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,&#x27; +</span></div><div class="token-line"><span class="token plain">      &#x27;data,dfn,em,i,kbd,mark,q,rp,rt,ruby,s,samp,small,span,strong,sub,sup,&#x27; +</span></div><div class="token-line"><span class="token plain">      &#x27;time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,&#x27; +</span></div><div class="token-line"><span class="token plain">      &#x27;canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,&#x27; +</span></div><div class="token-line"><span class="token plain">      &#x27;th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,&#x27; +</span></div><div class="token-line"><span class="token plain">      &#x27;option,output,progress,select,textarea,details,dialog,menu,&#x27; +</span></div><div class="token-line"><span class="token plain">      &#x27;summary,template,blockquote,iframe,tfoot&#x27;</span></div><div class="token-line"><span class="token plain">    export const isHTMLTag = /*#__PURE__*/ makeMap(HTML_TAGS)</span></div></pre></div><h2 id="vue浏览器端编译的核心流程"><a aria-hidden="true" tabindex="-1" href="/blog/玩转vue3全家桶/06.vue3生态源码篇/06#vue浏览器端编译的核心流程"><span class="icon icon-link"></span></a>Vue浏览器端编译的核心流程</h2><p>然后，我们进入到baseCompile函数中，这就是Vue浏览器端编译的核心流程。</p><p>下面的代码中可以很清楚地看到，我们先通过baseParse把传递的template解析成AST，然后通过transform函数对AST进行语义化分析，最后通过generate函数生成代码。</p><p>这个主要逻辑和我们写的迷你compiler基本一致，这些函数大概要做的事你也心中有数了。这里你也能体验到，亲手实现一个迷你版本对我们阅读源码很有帮助。</p><p>接下来，我们就进入到这几个函数之中去，看一下跟迷你compiler里的实现相比，我们到底做了哪些优化。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">export function baseCompile(</span></div><div class="token-line"><span class="token plain">      template: string | RootNode,</span></div><div class="token-line"><span class="token plain">      options: CompilerOptions = {}</span></div><div class="token-line"><span class="token plain">    ): CodegenResult {</span></div><div class="token-line"><span class="token plain">      const ast = isString(template) ? baseParse(template, options) : template</span></div><div class="token-line"><span class="token plain">      const [nodeTransforms, directiveTransforms] =</span></div><div class="token-line"><span class="token plain">        getBaseTransformPreset(prefixIdentifiers)</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">      transform(</span></div><div class="token-line"><span class="token plain">        ast,</span></div><div class="token-line"><span class="token plain">        extend({}, options, {</span></div><div class="token-line"><span class="token plain">          prefixIdentifiers,</span></div><div class="token-line"><span class="token plain">          nodeTransforms: [</span></div><div class="token-line"><span class="token plain">            ...nodeTransforms,</span></div><div class="token-line"><span class="token plain">            ...(options.nodeTransforms || []) // user transforms</span></div><div class="token-line"><span class="token plain">          ],</span></div><div class="token-line"><span class="token plain">          directiveTransforms: extend(</span></div><div class="token-line"><span class="token plain">            {},</span></div><div class="token-line"><span class="token plain">            directiveTransforms,</span></div><div class="token-line"><span class="token plain">            options.directiveTransforms || {} // user transforms</span></div><div class="token-line"><span class="token plain">          )</span></div><div class="token-line"><span class="token plain">        })</span></div><div class="token-line"><span class="token plain">      )</span></div><div class="token-line"><span class="token plain">      return generate(</span></div><div class="token-line"><span class="token plain">        ast,</span></div><div class="token-line"><span class="token plain">        extend({}, options, {</span></div><div class="token-line"><span class="token plain">          prefixIdentifiers</span></div><div class="token-line"><span class="token plain">        })</span></div><div class="token-line"><span class="token plain">      )</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>上一讲中我们体验了Vue的在线模板编译环境，可以在console中看到Vue解析得到的AST。</p><p>如下图所示，可以看到这个AST比迷你版多了很多额外的属性。<strong>loc用来描述节点对应代码的信息，component和directive用来记录代码中出现的组件和指令等等</strong>。</p><p><img src="https://static001.geekbang.org/resource/image/0e/3f/0e264bc3ffcfa67babec3b1cf8047d3f.png?wh=1920x982" alt="图片"/></p><p>然后我们进入到baseParse函数中, 这里的createParserContext和createRoot用来生成上下文，其实就是创建了一个对象，保存当前parse函数中需要共享的数据和变量，最后调用parseChildren。</p><p>children内部开始判断&lt;开头的标识符，判断开始还是闭合标签后，接着会生成一个nodes数组。其中，advanceBy函数负责更新context中的source用来向前遍历代码，最终对不同的场景执行不同的函数。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">export function baseParse(</span></div><div class="token-line"><span class="token plain">      content: string,</span></div><div class="token-line"><span class="token plain">      options: ParserOptions = {}</span></div><div class="token-line"><span class="token plain">    ): RootNode {</span></div><div class="token-line"><span class="token plain">      const context = createParserContext(content, options)</span></div><div class="token-line"><span class="token plain">      const start = getCursor(context)</span></div><div class="token-line"><span class="token plain">      return createRoot(</span></div><div class="token-line"><span class="token plain">        parseChildren(context, TextModes.DATA, []),</span></div><div class="token-line"><span class="token plain">        getSelection(context, start)</span></div><div class="token-line"><span class="token plain">      )</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    function parseChildren(</span></div><div class="token-line"><span class="token plain">      context: ParserContext,</span></div><div class="token-line"><span class="token plain">      mode: TextModes,</span></div><div class="token-line"><span class="token plain">      ancestors: ElementNode[]</span></div><div class="token-line"><span class="token plain">    ): TemplateChildNode[] {</span></div><div class="token-line"><span class="token plain">      const parent = last(ancestors)</span></div><div class="token-line"><span class="token plain">      // 依次生成node</span></div><div class="token-line"><span class="token plain">      const nodes: TemplateChildNode[] = []</span></div><div class="token-line"><span class="token plain">      // 如果遍历没结束</span></div><div class="token-line"><span class="token plain">      while (!isEnd(context, mode, ancestors)) {</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        const s = context.source</span></div><div class="token-line"><span class="token plain">        let node: TemplateChildNode | TemplateChildNode[] | undefined = undefined</span></div><div class="token-line"><span class="token plain">        </span></div><div class="token-line"><span class="token plain">        if (mode === TextModes.DATA || mode === TextModes.RCDATA) {</span></div><div class="token-line"><span class="token plain">          if (!context.inVPre &amp;&amp; startsWith(s, context.options.delimiters[0])) {</span></div><div class="token-line"><span class="token plain">            // 处理vue的变量标识符，两个大括号 &#x27;{{&#x27;</span></div><div class="token-line"><span class="token plain">            node = parseInterpolation(context, mode)</span></div><div class="token-line"><span class="token plain">          } else if (mode === TextModes.DATA &amp;&amp; s[0] === &#x27;&lt;&#x27;) {</span></div><div class="token-line"><span class="token plain">            // 处理&lt;开头的代码，可能是&lt;div&gt;也有可能是&lt;/div&gt; 或者&lt;!的注释</span></div><div class="token-line"><span class="token plain">            if (s.length === 1) {</span></div><div class="token-line"><span class="token plain">              // 长度是1，只有一个&lt; 有问题 报错</span></div><div class="token-line"><span class="token plain">              emitError(context, ErrorCodes.EOF_BEFORE_TAG_NAME, 1)</span></div><div class="token-line"><span class="token plain">            } else if (s[1] === &#x27;!&#x27;) {</span></div><div class="token-line"><span class="token plain">              // html注释</span></div><div class="token-line"><span class="token plain">              if (startsWith(s, &#x27;&lt;!--&#x27;)) {</span></div><div class="token-line"><span class="token plain">                node = parseComment(context)</span></div><div class="token-line"><span class="token plain">              } else if (startsWith(s, &#x27;&lt;!DOCTYPE&#x27;)) {</span></div><div class="token-line"><span class="token plain">                  </span></div><div class="token-line"><span class="token plain">                // DOCTYPE</span></div><div class="token-line"><span class="token plain">                node = parseBogusComment(context)</span></div><div class="token-line"><span class="token plain">              }</span></div><div class="token-line"><span class="token plain">            } else if (s[1] === &#x27;/&#x27;) {</span></div><div class="token-line"><span class="token plain">               //&lt;/ 开头的标签，结束标签</span></div><div class="token-line"><span class="token plain">              // https://html.spec.whatwg.org/multipage/parsing.html#end-tag-open-state</span></div><div class="token-line"><span class="token plain">              if (/[a-z]/i.test(s[2])) {</span></div><div class="token-line"><span class="token plain">                emitError(context, ErrorCodes.X_INVALID_END_TAG)</span></div><div class="token-line"><span class="token plain">                parseTag(context, TagType.End, parent)</span></div><div class="token-line"><span class="token plain">                continue</span></div><div class="token-line"><span class="token plain">              } </span></div><div class="token-line"><span class="token plain">            } else if (/[a-z]/i.test(s[1])) {</span></div><div class="token-line"><span class="token plain">              // 解析节点</span></div><div class="token-line"><span class="token plain">              node = parseElement(context, ancestors)</span></div><div class="token-line"><span class="token plain">              // 2.x &lt;template&gt; with no directive compat</span></div><div class="token-line"><span class="token plain">              node = node.children</span></div><div class="token-line"><span class="token plain">              }</span></div><div class="token-line"><span class="token plain">            }</span></div><div class="token-line"><span class="token plain">          }</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        if (!node) {</span></div><div class="token-line"><span class="token plain">          // 文本</span></div><div class="token-line"><span class="token plain">          node = parseText(context, mode)</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        // node树数组，遍历puish</span></div><div class="token-line"><span class="token plain">        if (isArray(node)) {</span></div><div class="token-line"><span class="token plain">          for (let i = 0; i &lt; node.length; i++) {</span></div><div class="token-line"><span class="token plain">            pushNode(nodes, node[i])</span></div><div class="token-line"><span class="token plain">          }</span></div><div class="token-line"><span class="token plain">        } else {</span></div><div class="token-line"><span class="token plain">          pushNode(nodes, node)</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">      }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">      return removedWhitespace ? nodes.filter(Boolean) : nodes</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>parseInterpolation和parseText函数的逻辑比较简单。parseInterpolation负责识别变量的分隔符 <!-- -->{<!-- -->{<!-- --> 和<!-- -->}<!-- -->}<!-- --> ，然后通过parseTextData获取变量的值，并且通过innerStart和innerEnd去记录插值的位置；parseText负责处理模板中的普通文本，主要是把文本包裹成AST对象。</p><p>接着我们看看处理节点的parseElement函数都做了什么。首先要判断pre和v-pre标签，然后通过isVoidTag判断标签是否是自闭合标签，这个函数是从compiler-dom中传来的，之后会递归调用parseChildren，接着再解析开始标签、解析子节点，最后解析结束标签。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">const VOID_TAGS =</span></div><div class="token-line"><span class="token plain">      &#x27;area,base,br,col,embed,hr,img,input,link,meta,param,source,track,wbr&#x27;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    export const isVoidTag = /*#__PURE__*/ makeMap(VOID_TAGS)</span></div><div class="token-line"><span class="token plain">    function parseElement(</span></div><div class="token-line"><span class="token plain">      context: ParserContext,</span></div><div class="token-line"><span class="token plain">      ancestors: ElementNode[]</span></div><div class="token-line"><span class="token plain">    ): ElementNode | undefined {</span></div><div class="token-line"><span class="token plain">      // Start tag.</span></div><div class="token-line"><span class="token plain">      // 是不是pre标签和v-pre标签</span></div><div class="token-line"><span class="token plain">      const wasInPre = context.inPre</span></div><div class="token-line"><span class="token plain">      const wasInVPre = context.inVPre</span></div><div class="token-line"><span class="token plain">      const parent = last(ancestors)</span></div><div class="token-line"><span class="token plain">      // 解析标签节点</span></div><div class="token-line"><span class="token plain">      const element = parseTag(context, TagType.Start, parent)</span></div><div class="token-line"><span class="token plain">      const isPreBoundary = context.inPre &amp;&amp; !wasInPre</span></div><div class="token-line"><span class="token plain">      const isVPreBoundary = context.inVPre &amp;&amp; !wasInVPre</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">      if (element.isSelfClosing || context.options.isVoidTag(element.tag)) {</span></div><div class="token-line"><span class="token plain">        // #4030 self-closing &lt;pre&gt; tag</span></div><div class="token-line"><span class="token plain">        if (isPreBoundary) {</span></div><div class="token-line"><span class="token plain">          context.inPre = false</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        if (isVPreBoundary) {</span></div><div class="token-line"><span class="token plain">          context.inVPre = false</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        return element</span></div><div class="token-line"><span class="token plain">      }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">      // Children.</span></div><div class="token-line"><span class="token plain">      ancestors.push(element)</span></div><div class="token-line"><span class="token plain">      const mode = context.options.getTextMode(element, parent)</span></div><div class="token-line"><span class="token plain">      const children = parseChildren(context, mode, ancestors)</span></div><div class="token-line"><span class="token plain">      ancestors.pop()</span></div><div class="token-line"><span class="token plain">      element.children = children</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">      // End tag.</span></div><div class="token-line"><span class="token plain">      if (startsWithEndTagOpen(context.source, element.tag)) {</span></div><div class="token-line"><span class="token plain">        parseTag(context, TagType.End, parent)</span></div><div class="token-line"><span class="token plain">      } else {</span></div><div class="token-line"><span class="token plain">        emitError(context, ErrorCodes.X_MISSING_END_TAG, 0, element.loc.start)</span></div><div class="token-line"><span class="token plain">        if (context.source.length === 0 &amp;&amp; element.tag.toLowerCase() === &#x27;script&#x27;) {</span></div><div class="token-line"><span class="token plain">          const first = children[0]</span></div><div class="token-line"><span class="token plain">          if (first &amp;&amp; startsWith(first.loc.source, &#x27;&lt;!--&#x27;)) {</span></div><div class="token-line"><span class="token plain">            emitError(context, ErrorCodes.EOF_IN_SCRIPT_HTML_COMMENT_LIKE_TEXT)</span></div><div class="token-line"><span class="token plain">          }</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">      }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">      element.loc = getSelection(context, element.loc.start)</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">      if (isPreBoundary) {</span></div><div class="token-line"><span class="token plain">        context.inPre = false</span></div><div class="token-line"><span class="token plain">      }</span></div><div class="token-line"><span class="token plain">      if (isVPreBoundary) {</span></div><div class="token-line"><span class="token plain">        context.inVPre = false</span></div><div class="token-line"><span class="token plain">      }</span></div><div class="token-line"><span class="token plain">      return element</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>最后，我们来看下解析节点的parseTag函数的逻辑，匹配文本标签结束的位置后，先通过parseAttributes函数处理属性，然后对pre和v-pre标签进行检查，最后通过isComponent函数判断是否为组件。</p><p>isComponent内部会通过compiler-dom传递的isNativeTag来辅助判断结果，最终返回一个描述节点的对象，包含当前节点所有解析之后的信息，tag表示标签名，children表示子节点的数组，具体代码我放在了后面。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">function parseTag(</span></div><div class="token-line"><span class="token plain">      context: ParserContext,</span></div><div class="token-line"><span class="token plain">      type: TagType,</span></div><div class="token-line"><span class="token plain">      parent: ElementNode | undefined</span></div><div class="token-line"><span class="token plain">    ): ElementNode | undefined {</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">      // Tag open. </span></div><div class="token-line"><span class="token plain">      const start = getCursor(context)</span></div><div class="token-line"><span class="token plain">      //匹配标签结束的位置</span></div><div class="token-line"><span class="token plain">      const match = /^&lt;\/?([a-z][^\t\r\n\f /&gt;]*)/i.exec(context.source)!</span></div><div class="token-line"><span class="token plain">      const tag = match[1]</span></div><div class="token-line"><span class="token plain">      const ns = context.options.getNamespace(tag, parent)</span></div><div class="token-line"><span class="token plain">      // 向前遍历代码</span></div><div class="token-line"><span class="token plain">      advanceBy(context, match[0].length)</span></div><div class="token-line"><span class="token plain">      advanceSpaces(context)</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">      // save current state in case we need to re-parse attributes with v-pre</span></div><div class="token-line"><span class="token plain">      const cursor = getCursor(context)</span></div><div class="token-line"><span class="token plain">      const currentSource = context.source</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">      // check &lt;pre&gt; tag </span></div><div class="token-line"><span class="token plain">      if (context.options.isPreTag(tag)) {</span></div><div class="token-line"><span class="token plain">        context.inPre = true</span></div><div class="token-line"><span class="token plain">      }</span></div><div class="token-line"><span class="token plain">      // Attributes.</span></div><div class="token-line"><span class="token plain">      // 解析属性</span></div><div class="token-line"><span class="token plain">      let props = parseAttributes(context, type)</span></div><div class="token-line"><span class="token plain">      // check v-pre</span></div><div class="token-line"><span class="token plain">      if (){...}</span></div><div class="token-line"><span class="token plain">      // Tag close.</span></div><div class="token-line"><span class="token plain">      let isSelfClosing = false</span></div><div class="token-line"><span class="token plain">      if (type === TagType.End) {</span></div><div class="token-line"><span class="token plain">        return</span></div><div class="token-line"><span class="token plain">      }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">      let tagType = ElementTypes.ELEMENT</span></div><div class="token-line"><span class="token plain">      if (!context.inVPre) {</span></div><div class="token-line"><span class="token plain">        if (tag === &#x27;slot&#x27;) {</span></div><div class="token-line"><span class="token plain">          tagType = ElementTypes.SLOT</span></div><div class="token-line"><span class="token plain">        } else if (tag === &#x27;template&#x27;) {</span></div><div class="token-line"><span class="token plain">          if (</span></div><div class="token-line"><span class="token plain">            props.some(</span></div><div class="token-line"><span class="token plain">              p =&gt;</span></div><div class="token-line"><span class="token plain">                p.type === NodeTypes.DIRECTIVE &amp;&amp; isSpecialTemplateDirective(p.name)</span></div><div class="token-line"><span class="token plain">            )</span></div><div class="token-line"><span class="token plain">          ) {</span></div><div class="token-line"><span class="token plain">            tagType = ElementTypes.TEMPLATE</span></div><div class="token-line"><span class="token plain">          }</span></div><div class="token-line"><span class="token plain">        } else if (isComponent(tag, props, context)) {</span></div><div class="token-line"><span class="token plain">          tagType = ElementTypes.COMPONENT</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">      }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">      return {</span></div><div class="token-line"><span class="token plain">        type: NodeTypes.ELEMENT,</span></div><div class="token-line"><span class="token plain">        ns,</span></div><div class="token-line"><span class="token plain">        tag,</span></div><div class="token-line"><span class="token plain">        tagType,</span></div><div class="token-line"><span class="token plain">        props,</span></div><div class="token-line"><span class="token plain">        isSelfClosing,</span></div><div class="token-line"><span class="token plain">        children: [],</span></div><div class="token-line"><span class="token plain">        loc: getSelection(context, start),</span></div><div class="token-line"><span class="token plain">        codegenNode: undefined // to be created during transform phase</span></div><div class="token-line"><span class="token plain">      }</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>parse函数生成AST之后，我们就有了一个完整描述template的对象，它包含了template中所有的信息。</p><h2 id="ast的语义化分析"><a aria-hidden="true" tabindex="-1" href="/blog/玩转vue3全家桶/06.vue3生态源码篇/06#ast的语义化分析"><span class="icon icon-link"></span></a>AST的语义化分析</h2><p>下一步我们要对AST进行语义化的分析。transform函数的执行流程分支很多，<strong>核心的逻辑就是识别一个个的Vue的语法，并且进行编译器的优化，我们经常提到的静态标记就是这一步完成的</strong>。</p><p>我们进入到transform函数中，可以看到，内部通过createTransformContext创建上下文对象，这个对象包含当前分析的属性配置，包括是否ssr，是否静态提升还有工具函数等等，这个对象的属性你可以在 <a target="_blank" rel="noopener noreferrer" href="https://github.com/vuejs/vue-next/blob/0dc521b9e15ce4aa3d5229e90d2173644529e92b/packages/compiler-core/src/transforms/transformElement.ts">GitHub<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>上看到。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">export function transform(root: RootNode, options: TransformOptions) {</span></div><div class="token-line"><span class="token plain">      const context = createTransformContext(root, options)</span></div><div class="token-line"><span class="token plain">      traverseNode(root, context)</span></div><div class="token-line"><span class="token plain">      if (options.hoistStatic) {</span></div><div class="token-line"><span class="token plain">        hoistStatic(root, context)</span></div><div class="token-line"><span class="token plain">      }</span></div><div class="token-line"><span class="token plain">      if (!options.ssr) {</span></div><div class="token-line"><span class="token plain">        createRootCodegen(root, context)</span></div><div class="token-line"><span class="token plain">      }</span></div><div class="token-line"><span class="token plain">      // finalize meta information</span></div><div class="token-line"><span class="token plain">      root.helpers = [...context.helpers.keys()]</span></div><div class="token-line"><span class="token plain">      root.components = [...context.components]</span></div><div class="token-line"><span class="token plain">      root.directives = [...context.directives]</span></div><div class="token-line"><span class="token plain">      root.imports = context.imports</span></div><div class="token-line"><span class="token plain">      root.hoists = context.hoists</span></div><div class="token-line"><span class="token plain">      root.temps = context.temps</span></div><div class="token-line"><span class="token plain">      root.cached = context.cached</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">      if (__COMPAT__) {</span></div><div class="token-line"><span class="token plain">        root.filters = [...context.filters!]</span></div><div class="token-line"><span class="token plain">      }</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>然后通过traverseNode即可编译AST所有的节点。核心的转换流程是在遍历中实现，内部使用switch判断node.type执行不同的处理逻辑。比如如果是Interpolation，就需要在helper中导入toDisplayString工具函数，这个迷你版本中我们也实现过。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">export function traverseNode(</span></div><div class="token-line"><span class="token plain">      node: RootNode | TemplateChildNode,</span></div><div class="token-line"><span class="token plain">      context: TransformContext</span></div><div class="token-line"><span class="token plain">    ) {</span></div><div class="token-line"><span class="token plain">      context.currentNode = node</span></div><div class="token-line"><span class="token plain">      // apply transform plugins</span></div><div class="token-line"><span class="token plain">      const { nodeTransforms } = context</span></div><div class="token-line"><span class="token plain">      const exitFns = []</span></div><div class="token-line"><span class="token plain">      for (let i = 0; i &lt; nodeTransforms.length; i++) {</span></div><div class="token-line"><span class="token plain">        // 处理exitFns</span></div><div class="token-line"><span class="token plain">      }</span></div><div class="token-line"><span class="token plain">      swtch (node.type) {</span></div><div class="token-line"><span class="token plain">        case NodeTypes.COMMENT:</span></div><div class="token-line"><span class="token plain">          if (!context.ssr) {</span></div><div class="token-line"><span class="token plain">            context.helper(CREATE_COMMENT)</span></div><div class="token-line"><span class="token plain">          }</span></div><div class="token-line"><span class="token plain">          break</span></div><div class="token-line"><span class="token plain">        case NodeTypes.INTERPOLATION:</span></div><div class="token-line"><span class="token plain">          if (!context.ssr) {</span></div><div class="token-line"><span class="token plain">            context.helper(TO_DISPLAY_STRING)</span></div><div class="token-line"><span class="token plain">          }</span></div><div class="token-line"><span class="token plain">          break</span></div><div class="token-line"><span class="token plain">        case NodeTypes.IF:</span></div><div class="token-line"><span class="token plain">          for (let i = 0; i &lt; node.branches.length; i++) {</span></div><div class="token-line"><span class="token plain">            traverseNode(node.branches[i], context)</span></div><div class="token-line"><span class="token plain">          }</span></div><div class="token-line"><span class="token plain">          break</span></div><div class="token-line"><span class="token plain">        case NodeTypes.IF_BRANCH:</span></div><div class="token-line"><span class="token plain">        case NodeTypes.FOR:</span></div><div class="token-line"><span class="token plain">        case NodeTypes.ELEMENT:</span></div><div class="token-line"><span class="token plain">        case NodeTypes.ROOT:</span></div><div class="token-line"><span class="token plain">          traverseChildren(node, context)</span></div><div class="token-line"><span class="token plain">          break</span></div><div class="token-line"><span class="token plain">      }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">      // exit transforms</span></div><div class="token-line"><span class="token plain">      context.currentNode = node</span></div><div class="token-line"><span class="token plain">      let i = exitFns.length</span></div><div class="token-line"><span class="token plain">      while (i--) {</span></div><div class="token-line"><span class="token plain">        exitFns[i]()</span></div><div class="token-line"><span class="token plain">      }</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>transform中还会调用transformElement来转换节点，用来处理props和children的静态标记，transformText用来转换文本，这里的代码比较简单， 你可以自行在<a target="_blank" rel="noopener noreferrer" href="https://github.com/vuejs/vue-next/blob/0dc521b9e15ce4aa3d5229e90d2173644529e92b/packages/compiler-core/src/transforms/transformElement.ts">Github<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>上查阅。<br/>transform函数参数中的nodeTransforms和directiveTransforms传递了Vue中template语法的配置，这个两个函数由getBaseTransformPreset返回。</p><p>下面的代码中，transformIf和transformFor函数式解析Vue中v-if和v-for的语法转换，transformOn和transformModel是解析v-on和v-model的语法解析，这里我们只关注v-开头的语法。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">export function getBaseTransformPreset(</span></div><div class="token-line"><span class="token plain">      prefixIdentifiers?: boolean</span></div><div class="token-line"><span class="token plain">    ): TransformPreset {</span></div><div class="token-line"><span class="token plain">      return [</span></div><div class="token-line"><span class="token plain">        [</span></div><div class="token-line"><span class="token plain">          transformOnce,</span></div><div class="token-line"><span class="token plain">          transformIf,</span></div><div class="token-line"><span class="token plain">          transformMemo,</span></div><div class="token-line"><span class="token plain">          transformFor,</span></div><div class="token-line"><span class="token plain">          ...(__COMPAT__ ? [transformFilter] : []),</span></div><div class="token-line"><span class="token plain">          ...(!__BROWSER__ &amp;&amp; prefixIdentifiers</span></div><div class="token-line"><span class="token plain">            ? [</span></div><div class="token-line"><span class="token plain">                // order is important</span></div><div class="token-line"><span class="token plain">                trackVForSlotScopes,</span></div><div class="token-line"><span class="token plain">                transformExpression</span></div><div class="token-line"><span class="token plain">              ]</span></div><div class="token-line"><span class="token plain">            : __BROWSER__ &amp;&amp; __DEV__</span></div><div class="token-line"><span class="token plain">            ? [transformExpression]</span></div><div class="token-line"><span class="token plain">            : []),</span></div><div class="token-line"><span class="token plain">          transformSlotOutlet,</span></div><div class="token-line"><span class="token plain">          transformElement,</span></div><div class="token-line"><span class="token plain">          trackSlotScopes,</span></div><div class="token-line"><span class="token plain">          transformText</span></div><div class="token-line"><span class="token plain">        ],</span></div><div class="token-line"><span class="token plain">        {</span></div><div class="token-line"><span class="token plain">          on: transformOn,</span></div><div class="token-line"><span class="token plain">          bind: transformBind,</span></div><div class="token-line"><span class="token plain">          model: transformModel</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">      ]</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>然后我们再来看看transformIf的函数实现。首先判断v-if、v-else和v-else-if属性，内部通过createCodegenNodeForBranch来创建条件分支，在AST中标记当前v-if的处理逻辑。这段逻辑标记结束后，在generate中就会把v-if标签和后面的v-else标签解析成三元表达式。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">export const transformIf = createStructuralDirectiveTransform(</span></div><div class="token-line"><span class="token plain">      /^(if|else|else-if)$/,</span></div><div class="token-line"><span class="token plain">      (node, dir, context) =&gt; {</span></div><div class="token-line"><span class="token plain">        return processIf(node, dir, context, (ifNode, branch, isRoot) =&gt; {</span></div><div class="token-line"><span class="token plain">          const siblings = context.parent!.children</span></div><div class="token-line"><span class="token plain">          let i = siblings.indexOf(ifNode)</span></div><div class="token-line"><span class="token plain">          let key = 0</span></div><div class="token-line"><span class="token plain">          while (i-- &gt;= 0) {</span></div><div class="token-line"><span class="token plain">            const sibling = siblings[i]</span></div><div class="token-line"><span class="token plain">            if (sibling &amp;&amp; sibling.type === NodeTypes.IF) {</span></div><div class="token-line"><span class="token plain">              key += sibling.branches.length</span></div><div class="token-line"><span class="token plain">            }</span></div><div class="token-line"><span class="token plain">          }</span></div><div class="token-line"><span class="token plain">          return () =&gt; {</span></div><div class="token-line"><span class="token plain">            if (isRoot) {</span></div><div class="token-line"><span class="token plain">              ifNode.codegenNode = createCodegenNodeForBranch(</span></div><div class="token-line"><span class="token plain">                branch,</span></div><div class="token-line"><span class="token plain">                key,</span></div><div class="token-line"><span class="token plain">                context</span></div><div class="token-line"><span class="token plain">              ) as IfConditionalExpression</span></div><div class="token-line"><span class="token plain">            } else {</span></div><div class="token-line"><span class="token plain">              // attach this branch&#x27;s codegen node to the v-if root.</span></div><div class="token-line"><span class="token plain">              const parentCondition = getParentCondition(ifNode.codegenNode!)</span></div><div class="token-line"><span class="token plain">              parentCondition.alternate = createCodegenNodeForBranch(</span></div><div class="token-line"><span class="token plain">                branch,</span></div><div class="token-line"><span class="token plain">                key + ifNode.branches.length - 1,</span></div><div class="token-line"><span class="token plain">                context</span></div><div class="token-line"><span class="token plain">              )</span></div><div class="token-line"><span class="token plain">            }</span></div><div class="token-line"><span class="token plain">          }</span></div><div class="token-line"><span class="token plain">        })</span></div><div class="token-line"><span class="token plain">      }</span></div><div class="token-line"><span class="token plain">    )</span></div></pre></div><p>transform对AST分析结束之后，我们就得到了一个优化后的AST对象，最后我们需要调用generate函数最终生成render函数。</p><h2 id="template到render函数的转化"><a aria-hidden="true" tabindex="-1" href="/blog/玩转vue3全家桶/06.vue3生态源码篇/06#template到render函数的转化"><span class="icon icon-link"></span></a>template到render函数的转化</h2><p>结合下面的代码我们可以看到，generate首先通过createCodegenContext创建上下文对象，然后通过genModulePreamble生成预先定义好的代码模板，然后生成render函数，最后生成创建虚拟DOM的表达式。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">export function generate(</span></div><div class="token-line"><span class="token plain">      ast,</span></div><div class="token-line"><span class="token plain">      options</span></div><div class="token-line"><span class="token plain">    ): CodegenResult {</span></div><div class="token-line"><span class="token plain">      const context = createCodegenContext(ast, options)</span></div><div class="token-line"><span class="token plain">      const {</span></div><div class="token-line"><span class="token plain">        mode,</span></div><div class="token-line"><span class="token plain">        push,</span></div><div class="token-line"><span class="token plain">        prefixIdentifiers,</span></div><div class="token-line"><span class="token plain">        indent,</span></div><div class="token-line"><span class="token plain">        deindent,</span></div><div class="token-line"><span class="token plain">        newline,</span></div><div class="token-line"><span class="token plain">        scopeId,</span></div><div class="token-line"><span class="token plain">        ssr</span></div><div class="token-line"><span class="token plain">      } = context</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">      if (!__BROWSER__ &amp;&amp; mode === &#x27;module&#x27;) {</span></div><div class="token-line"><span class="token plain">        // 预设代码，module风格 就是import语句</span></div><div class="token-line"><span class="token plain">        genModulePreamble(ast, preambleContext, genScopeId, isSetupInlined)</span></div><div class="token-line"><span class="token plain">      } else {</span></div><div class="token-line"><span class="token plain">        // 预设代码，函数风格 就是import语句</span></div><div class="token-line"><span class="token plain">        genFunctionPreamble(ast, preambleContext)</span></div><div class="token-line"><span class="token plain">      }</span></div><div class="token-line"><span class="token plain">      // render还是ssrRender</span></div><div class="token-line"><span class="token plain">      const functionName = ssr ? `ssrRender` : `render`</span></div><div class="token-line"><span class="token plain">      const args = ssr ? [&#x27;_ctx&#x27;, &#x27;_push&#x27;, &#x27;_parent&#x27;, &#x27;_attrs&#x27;] : [&#x27;_ctx&#x27;, &#x27;_cache&#x27;]</span></div><div class="token-line"><span class="token plain">      if (!__BROWSER__ &amp;&amp; options.bindingMetadata &amp;&amp; !options.inline) {</span></div><div class="token-line"><span class="token plain">        // binding optimization args</span></div><div class="token-line"><span class="token plain">        args.push(&#x27;$props&#x27;, &#x27;$setup&#x27;, &#x27;$data&#x27;, &#x27;$options&#x27;)</span></div><div class="token-line"><span class="token plain">      }</span></div><div class="token-line"><span class="token plain">      const signature =</span></div><div class="token-line"><span class="token plain">        !__BROWSER__ &amp;&amp; options.isTS</span></div><div class="token-line"><span class="token plain">          ? args.map(arg =&gt; `${arg}: any`).join(&#x27;,&#x27;)</span></div><div class="token-line"><span class="token plain">          : args.join(&#x27;, &#x27;)</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">      if (isSetupInlined) {</span></div><div class="token-line"><span class="token plain">        push(`(${signature}) =&gt; {`)</span></div><div class="token-line"><span class="token plain">      } else {</span></div><div class="token-line"><span class="token plain">        push(`function ${functionName}(${signature}) {`)</span></div><div class="token-line"><span class="token plain">      }</span></div><div class="token-line"><span class="token plain">      indent()</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">      // 组件，指令声明代码</span></div><div class="token-line"><span class="token plain">      if (ast.components.length) {</span></div><div class="token-line"><span class="token plain">        genAssets(ast.components, &#x27;component&#x27;, context)</span></div><div class="token-line"><span class="token plain">        if (ast.directives.length || ast.temps &gt; 0) {</span></div><div class="token-line"><span class="token plain">          newline()</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">      }</span></div><div class="token-line"><span class="token plain">      if (ast.components.length || ast.directives.length || ast.temps) {</span></div><div class="token-line"><span class="token plain">        push(`\n`)</span></div><div class="token-line"><span class="token plain">        newline()</span></div><div class="token-line"><span class="token plain">      }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">      if (ast.codegenNode) {</span></div><div class="token-line"><span class="token plain">        genNode(ast.codegenNode, context)</span></div><div class="token-line"><span class="token plain">      } else {</span></div><div class="token-line"><span class="token plain">        push(`null`)</span></div><div class="token-line"><span class="token plain">      }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">      if (useWithBlock) {</span></div><div class="token-line"><span class="token plain">        deindent()</span></div><div class="token-line"><span class="token plain">        push(`}`)</span></div><div class="token-line"><span class="token plain">      }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">      deindent()</span></div><div class="token-line"><span class="token plain">      push(`}`)</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">      return {</span></div><div class="token-line"><span class="token plain">        ast,</span></div><div class="token-line"><span class="token plain">        code: context.code,</span></div><div class="token-line"><span class="token plain">        preamble: isSetupInlined ? preambleContext.code : ``,</span></div><div class="token-line"><span class="token plain">        // SourceMapGenerator does have toJSON() method but it&#x27;s not in the types</span></div><div class="token-line"><span class="token plain">        map: context.map ? (context.map as any).toJSON() : undefined</span></div><div class="token-line"><span class="token plain">      }</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>我们来看下关键的步骤，genModulePreamble函数生成import风格的代码，这也是我们迷你版本中的功能：通过遍历helpers，生成import字符串，这对应了代码的第二行。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// 生成这个 </span></div><div class="token-line"><span class="token plain">    // import { toDisplayString as _toDisplayString, createElementVNode as _createElementVNode, openBlock as _openBlock, createElementBlock as _createElementBlock } from &quot;vue&quot;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    function genModulePreamble(</span></div><div class="token-line"><span class="token plain">      ast: RootNode,</span></div><div class="token-line"><span class="token plain">      context: CodegenContext,</span></div><div class="token-line"><span class="token plain">      genScopeId: boolean,</span></div><div class="token-line"><span class="token plain">      inline?: boolean</span></div><div class="token-line"><span class="token plain">    ) {</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">      if (genScopeId &amp;&amp; ast.hoists.length) {</span></div><div class="token-line"><span class="token plain">        ast.helpers.push(PUSH_SCOPE_ID, POP_SCOPE_ID)</span></div><div class="token-line"><span class="token plain">      }</span></div><div class="token-line"><span class="token plain">      // generate import statements for helpers</span></div><div class="token-line"><span class="token plain">      if (ast.helpers.length) {</span></div><div class="token-line"><span class="token plain">          push(</span></div><div class="token-line"><span class="token plain">            `import { ${ast.helpers</span></div><div class="token-line"><span class="token plain">              .map(s =&gt; `${helperNameMap[s]} as _${helperNameMap[s]}`)</span></div><div class="token-line"><span class="token plain">              .join(&#x27;, &#x27;)} } from ${JSON.stringify(runtimeModuleName)}\n`</span></div><div class="token-line"><span class="token plain">          )</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">      }</span></div><div class="token-line"><span class="token plain">      ...</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>接下来的步骤就是生成渲染函数render和component的代码，最后通过genNode生成创建虚拟的代码，执行switch语句生成不同的代码，一共有十几种情况，这里就不一一赘述了。我们可以回顾上一讲中迷你代码的逻辑，总之针对变量，标签，v-if和v-for都有不同的代码生成逻辑，最终才实现了template到render函数的转化。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">function genNode(node: CodegenNode | symbol | string, context: CodegenContext) {</span></div><div class="token-line"><span class="token plain">      if (isString(node)) {</span></div><div class="token-line"><span class="token plain">        context.push(node)</span></div><div class="token-line"><span class="token plain">        return</span></div><div class="token-line"><span class="token plain">      }</span></div><div class="token-line"><span class="token plain">      if (isSymbol(node)) {</span></div><div class="token-line"><span class="token plain">        context.push(context.helper(node))</span></div><div class="token-line"><span class="token plain">        return</span></div><div class="token-line"><span class="token plain">      }</span></div><div class="token-line"><span class="token plain">      switch (node.type) {</span></div><div class="token-line"><span class="token plain">        case NodeTypes.ELEMENT:</span></div><div class="token-line"><span class="token plain">        case NodeTypes.IF:</span></div><div class="token-line"><span class="token plain">        case NodeTypes.FOR:</span></div><div class="token-line"><span class="token plain">          genNode(node.codegenNode!, context)</span></div><div class="token-line"><span class="token plain">          break</span></div><div class="token-line"><span class="token plain">        case NodeTypes.TEXT:</span></div><div class="token-line"><span class="token plain">          genText(node, context)</span></div><div class="token-line"><span class="token plain">          break</span></div><div class="token-line"><span class="token plain">        case NodeTypes.SIMPLE_EXPRESSION:</span></div><div class="token-line"><span class="token plain">          genExpression(node, context)</span></div><div class="token-line"><span class="token plain">          break</span></div><div class="token-line"><span class="token plain">        case NodeTypes.INTERPOLATION:</span></div><div class="token-line"><span class="token plain">          genInterpolation(node, context)</span></div><div class="token-line"><span class="token plain">          break</span></div><div class="token-line"><span class="token plain">        case NodeTypes.TEXT_CALL:</span></div><div class="token-line"><span class="token plain">          genNode(node.codegenNode, context)</span></div><div class="token-line"><span class="token plain">          break</span></div><div class="token-line"><span class="token plain">        case NodeTypes.COMPOUND_EXPRESSION:</span></div><div class="token-line"><span class="token plain">          genCompoundExpression(node, context)</span></div><div class="token-line"><span class="token plain">          break</span></div><div class="token-line"><span class="token plain">        case NodeTypes.COMMENT:</span></div><div class="token-line"><span class="token plain">          genComment(node, context)</span></div><div class="token-line"><span class="token plain">          break</span></div><div class="token-line"><span class="token plain">        case NodeTypes.VNODE_CALL:</span></div><div class="token-line"><span class="token plain">          genVNodeCall(node, context)</span></div><div class="token-line"><span class="token plain">          break</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        case NodeTypes.JS_CALL_EXPRESSION:</span></div><div class="token-line"><span class="token plain">          genCallExpression(node, context)</span></div><div class="token-line"><span class="token plain">          break</span></div><div class="token-line"><span class="token plain">        case NodeTypes.JS_OBJECT_EXPRESSION:</span></div><div class="token-line"><span class="token plain">          genObjectExpression(node, context)</span></div><div class="token-line"><span class="token plain">          break</span></div><div class="token-line"><span class="token plain">        case NodeTypes.JS_ARRAY_EXPRESSION:</span></div><div class="token-line"><span class="token plain">          genArrayExpression(node, context)</span></div><div class="token-line"><span class="token plain">          break</span></div><div class="token-line"><span class="token plain">        case NodeTypes.JS_FUNCTION_EXPRESSION:</span></div><div class="token-line"><span class="token plain">          genFunctionExpression(node, context)</span></div><div class="token-line"><span class="token plain">          break</span></div><div class="token-line"><span class="token plain">        case NodeTypes.JS_CONDITIONAL_EXPRESSION:</span></div><div class="token-line"><span class="token plain">          genConditionalExpression(node, context)</span></div><div class="token-line"><span class="token plain">          break</span></div><div class="token-line"><span class="token plain">        case NodeTypes.JS_CACHE_EXPRESSION:</span></div><div class="token-line"><span class="token plain">          genCacheExpression(node, context)</span></div><div class="token-line"><span class="token plain">          break</span></div><div class="token-line"><span class="token plain">        case NodeTypes.JS_BLOCK_STATEMENT:</span></div><div class="token-line"><span class="token plain">          genNodeList(node.body, context, true, false)</span></div><div class="token-line"><span class="token plain">          break</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        /* istanbul ignore next */</span></div><div class="token-line"><span class="token plain">        case NodeTypes.IF_BRANCH:</span></div><div class="token-line"><span class="token plain">          // noop</span></div><div class="token-line"><span class="token plain">          break</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">      }</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><h2 id="总结"><a aria-hidden="true" tabindex="-1" href="/blog/玩转vue3全家桶/06.vue3生态源码篇/06#总结"><span class="icon icon-link"></span></a>总结</h2><p>今天的内容到这就讲完了，我给你总结一下今天讲到的内容吧。</p><p>今天我们一起分析了Vue中的compiler执行全流程，有了上一讲编译入门知识的基础之后，今天的parse，transform和generate模块就是在上一讲的基础之上，更加全面地实现代码的编译和转化。</p><p><img src="https://static001.geekbang.org/resource/image/a9/1e/a995298a4422d287a57e342dc105471e.jpg?wh=3510x1214" alt=""/></p><p>上面的流程图中，我们代码中的template是通过compiler函数进行编译转换，compiler内部调用了compiler-core中的baseCompile函数，并且传递了浏览器平台的转换逻辑。</p><p>比如isNativeTag等函数，baseCompie函数中首先通过baseParse函数把template处理成为AST，并且由transform函数进行标记优化，transfom内部的transformIf，transformOn等函数会对Vue中的语法进行标记，这样在generate函数中就可以使用优化后的AST去生成最终的render函数。</p><p>最终，render函数会和我们写的setup函数一起组成组件对象，交给页面进行渲染。后面我特意为你绘制了一幅Vue全流程的架构图，你可以保存下来随时查阅。</p><p><img src="https://static001.geekbang.org/resource/image/3b/97/3b266af3c5f43d235a8ec0e687bc4c97.jpg?wh=8312x4611" alt=""/></p><p>Vue源码中的编译优化也是Vue框架的亮点之一，我们自己也要思考编译器优化的机制，可以提高浏览器运行时的性能，我们项目中该如何借鉴这种思路呢？下一讲我会详细剖析编译原理在实战里的应用，敬请期待。</p><h2 id="思考题"><a aria-hidden="true" tabindex="-1" href="/blog/玩转vue3全家桶/06.vue3生态源码篇/06#思考题"><span class="icon icon-link"></span></a>思考题</h2><p>最后留一个思考题，transform函数中针对Vue中的语法有很多的函数处理，比如transformIf会把v-if指令编译成为一个三元表达式，请你从其余的函数选一个在评论区分享transform处理的结果吧。欢迎在评论区分享你的答案，我们下一讲再见！</p></div><div class="__dumi-default-layout-footer-meta"><a target="_blank" rel="noopener noreferrer" href="https://github.com/GGwujun/blog/edit/master/docs/玩转Vue3全家桶/06.Vue3生态源码篇/06.md">在 GitHub 上编辑此页<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a><span data-updated-text="最后更新时间：">5/2/2022 10:56:57</span></div></div></div></div>
	<script>
  window.g_useSSR = true;
  window.g_initialProps = {};
	</script>

    <script>
      (function () {
        if (!location.port) {
          (function (i, s, o, g, r, a, m) {
            i["GoogleAnalyticsObject"] = r;
            (i[r] =
              i[r] ||
              function () {
                (i[r].q = i[r].q || []).push(arguments);
              }),
              (i[r].l = 1 * new Date());
            (a = s.createElement(o)), (m = s.getElementsByTagName(o)[0]);
            a.async = 1;
            a.src = g;
            m.parentNode.insertBefore(a, m);
          })(
            window,
            document,
            "script",
            "//www.google-analytics.com/analytics.js",
            "ga"
          );
          ga("create", "UA-149864185-1", "auto");
          ga("send", "pageview");
        }
      })();
    </script>
    <script src="/blog/umi.js"></script>
  </body>
</html>
