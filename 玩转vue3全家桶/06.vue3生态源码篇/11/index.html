<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no"
    />
    <link rel="shortcut icon" type="image/x-icon" href="/logo.png" />
    <link rel="stylesheet" href="/blog/umi.css" />
    <script>
      window.routerBase = "/blog";
    </script>
    <script>
      //! umi version: 3.5.17
    </script>
    <script>
      !(function () {
        var e = localStorage.getItem("dumi:prefers-color"),
          t = window.matchMedia("(prefers-color-scheme: dark)").matches,
          r = ["light", "dark", "auto"];
        document.documentElement.setAttribute(
          "data-prefers-color",
          e === r[2] ? (t ? r[1] : r[0]) : r.indexOf(e) > -1 ? e : r[0]
        );
      })();
    </script>
    <title>38｜服务端渲染原理：Vue 3中的SSR是如何实现的？</title>
  </head>
  <body>
    <div id="root"><div class="__dumi-default-layout" data-route="/玩转vue3全家桶/06.vue3生态源码篇/11" data-show-sidemenu="true" data-show-slugs="true" data-site-mode="true" data-gapless="false"><div class="__dumi-default-navbar" data-mode="site"><button class="__dumi-default-navbar-toggle"></button><a class="__dumi-default-navbar-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog/">大师兄</a><nav><div class="__dumi-default-search"><input type="search" class="__dumi-default-search-input" value=""/><ul></ul></div><span>计算机基础<ul><li><a href="/blog/编译原理之美">编译原理之美</a></li><li><a href="/blog/编译原理实战">编译原理实战</a></li><li><a href="/blog/深入浅出计算机组成原理">深入浅出计算机组成原理</a></li><li><a href="/blog/详解http">详解http</a></li><li><a href="/blog/计算机网络通关29讲">计算机网络通关29讲</a></li><li><a href="/blog/网络排查案例课">网络排查案例课</a></li><li><a href="/blog/linux操作系统">linux操作系统</a></li><li><a href="/blog/linux性能优化实战">linux性能优化实战</a></li><li><a href="/blog/程序员数学基础">程序员数学基础</a></li><li><a href="/blog/趣谈网络协议">趣谈网络协议</a></li><li><a href="/blog/操作系统实战">操作系统实战</a></li><li><a href="/blog/软件工程之美">软件工程之美</a></li><li><a href="/blog/sql必知必会">sql必知必会</a></li><li><a href="/blog/操作系统实战45讲">操作系统实战45讲</a></li><li><a href="/blog/网络编程实战">网络编程实战</a></li></ul></span><span>算法<ul><li><a href="/blog/常用算法25讲">常用算法25讲</a></li><li><a href="/blog/数据结构与算法之美">数据结构与算法之美</a></li><li><a href="/blog/业务开发算法50讲">业务开发算法50讲</a></li><li><a href="/blog/动态规划面试宝典">动态规划面试宝典</a></li></ul></span><span>前端开发<ul><li><a href="/blog/浏览器工作原理与实践">浏览器工作原理与实践</a></li><li><a href="/blog/新时代产品经理进阶之路">新时代产品经理进阶之路</a></li><li><a href="/blog/全栈工程师修炼指南">全栈工程师修炼指南</a></li><li><a href="/blog/flutter核心技术与实战">flutter核心技术与实战</a></li><li><a href="/blog/java-script核心原理解析">java-script核心原理解析</a></li><li><a href="/blog/说透低代码">说透低代码</a></li><li><a href="/blog/nodejs应用开发实战">nodejs应用开发实战</a></li><li><a href="/blog/反爬虫兵法演绎20讲">反爬虫兵法演绎20讲</a></li><li><a href="/blog/reactnative新架构实战课">reactnative新架构实战课</a></li><li><a href="/blog/正则表达式入门">正则表达式入门</a></li><li><a href="/blog/重学前端">重学前端</a></li><li><a href="/blog/serverless入门课">serverless入门课</a></li><li><a href="/blog/type-script入门实战笔记">type-script入门实战笔记</a></li><li><a href="/blog/图解googlev8">图解googlev8</a></li><li><a href="/blog/vue3源码分析">vue3源码分析</a></li><li><a aria-current="page" class="active" href="/blog/玩转Vue3全家桶">玩转Vue3全家桶</a></li><li><a href="/blog/webassembly入门">webassembly入门</a></li><li><a href="/blog/手把手带你写一个Web框架">手把手带你写一个Web框架</a></li><li><a href="/blog/web漏洞挖掘实战">web漏洞挖掘实战</a></li><li><a href="/blog/跟月影学可视化">跟月影学可视化</a></li><li><a href="/blog/搞定音频技术">搞定音频技术</a></li><li><a href="/blog/攻克视频技术">攻克视频技术</a></li></ul></span><span>前端工程化<ul><li><a href="/blog/logger">logger</a></li><li><a href="/blog/webpack">webpack</a></li><li><a href="/blog/webpackChain">webpackChain</a></li></ul></span><span>前端性能优化<ul><li><a href="/blog/react性能调优">react性能调优</a></li></ul></span><span>软件测试<ul><li><a href="/blog/全链路压测实战30讲">全链路压测实战30讲</a></li><li><a href="/blog/性能测试实战30讲">性能测试实战30讲</a></li><li><a href="/blog/自动化测试高手课">自动化测试高手课</a></li><li><a href="/blog/软件测试52讲">软件测试52讲</a></li></ul></span><span>面试<ul><li><a href="/blog/面试现场">面试现场</a></li></ul></span><span>杂谈<ul><li><a href="/blog/超级访谈对话张雪峰">超级访谈对话张雪峰</a></li><li><a href="/blog/Git实战手册">Git实战手册</a></li><li><a href="/blog/NodeJS">NodeJS</a></li><li><a href="/blog/ReactJS">ReactJS</a></li><li><a href="/blog/UI设计">UI设计</a></li><li><a href="/blog/webpack4系列教程">webpack4系列教程</a></li><li><a href="/blog/前端知识体系">前端知识体系</a></li><li><a href="/blog/剑指offer刷题笔记">剑指offer刷题笔记</a></li><li><a href="/blog/思考与成长">思考与成长</a></li><li><a href="/blog/设计模式手册">设计模式手册</a></li></ul></span><div class="__dumi-default-navbar-tool"><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "></div></div></div></nav></div><div class="__dumi-default-menu" data-mode="site"><div class="__dumi-default-menu-inner"><div class="__dumi-default-menu-header"><a class="__dumi-default-menu-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog/"></a><h1>大师兄</h1><p></p></div><div class="__dumi-default-menu-mobile-area"><ul class="__dumi-default-menu-nav-list"><li>计算机基础<ul><li><a href="/blog/编译原理之美">编译原理之美</a></li><li><a href="/blog/编译原理实战">编译原理实战</a></li><li><a href="/blog/深入浅出计算机组成原理">深入浅出计算机组成原理</a></li><li><a href="/blog/详解http">详解http</a></li><li><a href="/blog/计算机网络通关29讲">计算机网络通关29讲</a></li><li><a href="/blog/网络排查案例课">网络排查案例课</a></li><li><a href="/blog/linux操作系统">linux操作系统</a></li><li><a href="/blog/linux性能优化实战">linux性能优化实战</a></li><li><a href="/blog/程序员数学基础">程序员数学基础</a></li><li><a href="/blog/趣谈网络协议">趣谈网络协议</a></li><li><a href="/blog/操作系统实战">操作系统实战</a></li><li><a href="/blog/软件工程之美">软件工程之美</a></li><li><a href="/blog/sql必知必会">sql必知必会</a></li><li><a href="/blog/操作系统实战45讲">操作系统实战45讲</a></li><li><a href="/blog/网络编程实战">网络编程实战</a></li></ul></li><li>算法<ul><li><a href="/blog/常用算法25讲">常用算法25讲</a></li><li><a href="/blog/数据结构与算法之美">数据结构与算法之美</a></li><li><a href="/blog/业务开发算法50讲">业务开发算法50讲</a></li><li><a href="/blog/动态规划面试宝典">动态规划面试宝典</a></li></ul></li><li>前端开发<ul><li><a href="/blog/浏览器工作原理与实践">浏览器工作原理与实践</a></li><li><a href="/blog/新时代产品经理进阶之路">新时代产品经理进阶之路</a></li><li><a href="/blog/全栈工程师修炼指南">全栈工程师修炼指南</a></li><li><a href="/blog/flutter核心技术与实战">flutter核心技术与实战</a></li><li><a href="/blog/java-script核心原理解析">java-script核心原理解析</a></li><li><a href="/blog/说透低代码">说透低代码</a></li><li><a href="/blog/nodejs应用开发实战">nodejs应用开发实战</a></li><li><a href="/blog/反爬虫兵法演绎20讲">反爬虫兵法演绎20讲</a></li><li><a href="/blog/reactnative新架构实战课">reactnative新架构实战课</a></li><li><a href="/blog/正则表达式入门">正则表达式入门</a></li><li><a href="/blog/重学前端">重学前端</a></li><li><a href="/blog/serverless入门课">serverless入门课</a></li><li><a href="/blog/type-script入门实战笔记">type-script入门实战笔记</a></li><li><a href="/blog/图解googlev8">图解googlev8</a></li><li><a href="/blog/vue3源码分析">vue3源码分析</a></li><li><a aria-current="page" class="active" href="/blog/玩转Vue3全家桶">玩转Vue3全家桶</a></li><li><a href="/blog/webassembly入门">webassembly入门</a></li><li><a href="/blog/手把手带你写一个Web框架">手把手带你写一个Web框架</a></li><li><a href="/blog/web漏洞挖掘实战">web漏洞挖掘实战</a></li><li><a href="/blog/跟月影学可视化">跟月影学可视化</a></li><li><a href="/blog/搞定音频技术">搞定音频技术</a></li><li><a href="/blog/攻克视频技术">攻克视频技术</a></li></ul></li><li>前端工程化<ul><li><a href="/blog/logger">logger</a></li><li><a href="/blog/webpack">webpack</a></li><li><a href="/blog/webpackChain">webpackChain</a></li></ul></li><li>前端性能优化<ul><li><a href="/blog/react性能调优">react性能调优</a></li></ul></li><li>软件测试<ul><li><a href="/blog/全链路压测实战30讲">全链路压测实战30讲</a></li><li><a href="/blog/性能测试实战30讲">性能测试实战30讲</a></li><li><a href="/blog/自动化测试高手课">自动化测试高手课</a></li><li><a href="/blog/软件测试52讲">软件测试52讲</a></li></ul></li><li>面试<ul><li><a href="/blog/面试现场">面试现场</a></li></ul></li><li>杂谈<ul><li><a href="/blog/超级访谈对话张雪峰">超级访谈对话张雪峰</a></li><li><a href="/blog/Git实战手册">Git实战手册</a></li><li><a href="/blog/NodeJS">NodeJS</a></li><li><a href="/blog/ReactJS">ReactJS</a></li><li><a href="/blog/UI设计">UI设计</a></li><li><a href="/blog/webpack4系列教程">webpack4系列教程</a></li><li><a href="/blog/前端知识体系">前端知识体系</a></li><li><a href="/blog/剑指offer刷题笔记">剑指offer刷题笔记</a></li><li><a href="/blog/思考与成长">思考与成长</a></li><li><a href="/blog/设计模式手册">设计模式手册</a></li></ul></li></ul><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "><button title="Dark theme" class="__dumi-default-dark-moon "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="3854" width="22" height="22"><path d="M991.816611 674.909091a69.166545 69.166545 0 0 0-51.665455-23.272727 70.795636 70.795636 0 0 0-27.438545 5.585454A415.674182 415.674182 0 0 1 754.993338 698.181818c-209.594182 0-393.472-184.785455-393.472-395.636363 0-52.363636 38.539636-119.621818 69.515637-173.614546 4.887273-8.610909 9.634909-16.756364 14.103272-24.901818A69.818182 69.818182 0 0 0 384.631156 0a70.842182 70.842182 0 0 0-27.438545 5.585455C161.678429 90.298182 14.362065 307.898182 14.362065 512c0 282.298182 238.824727 512 532.38691 512a522.286545 522.286545 0 0 0 453.957818-268.334545A69.818182 69.818182 0 0 0 991.816611 674.909091zM546.679156 954.181818c-248.785455 0-462.941091-192-462.941091-442.181818 0-186.647273 140.637091-372.829091 300.939637-442.181818-36.817455 65.629091-92.578909 151.970909-92.578909 232.727273 0 250.181818 214.109091 465.454545 462.917818 465.454545a488.331636 488.331636 0 0 0 185.181091-46.545455 453.003636 453.003636 0 0 1-393.565091 232.727273z m103.656728-669.323636l-14.266182 83.781818a34.909091 34.909091 0 0 0 50.362182 36.770909l74.775272-39.563636 74.752 39.563636a36.142545 36.142545 0 0 0 16.174546 3.956364 34.909091 34.909091 0 0 0 34.210909-40.727273l-14.289455-83.781818 60.509091-59.345455a35.025455 35.025455 0 0 0-19.223272-59.578182l-83.61891-12.101818-37.376-76.101818a34.56 34.56 0 0 0-62.254545 0l-37.376 76.101818-83.618909 12.101818a34.909091 34.909091 0 0 0-19.246546 59.578182z m70.423272-64.698182a34.280727 34.280727 0 0 0 26.135273-19.083636l14.312727-29.090909 14.336 29.090909a34.257455 34.257455 0 0 0 26.135273 19.083636l32.046546 4.887273-23.272728 22.574545a35.234909 35.234909 0 0 0-10.007272 30.952727l5.46909 32.116364-28.625454-15.127273a34.490182 34.490182 0 0 0-32.302546 0l-28.695272 15.127273 5.469091-32.116364a35.141818 35.141818 0 0 0-9.984-30.952727l-23.272728-22.574545z" p-id="3855"></path></svg></button><button title="Light theme" class="__dumi-default-dark-sun "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="4026" width="22" height="22"><path d="M915.2 476.16h-43.968c-24.704 0-44.736 16-44.736 35.84s20.032 35.904 44.736 35.904H915.2c24.768 0 44.8-16.064 44.8-35.904s-20.032-35.84-44.8-35.84zM512 265.6c-136.704 0-246.464 109.824-246.464 246.4 0 136.704 109.76 246.464 246.464 246.464S758.4 648.704 758.4 512c0-136.576-109.696-246.4-246.4-246.4z m0 425.6c-99.008 0-179.2-80.128-179.2-179.2 0-98.944 80.192-179.2 179.2-179.2S691.2 413.056 691.2 512c0 99.072-80.192 179.2-179.2 179.2zM197.44 512c0-19.84-19.136-35.84-43.904-35.84H108.8c-24.768 0-44.8 16-44.8 35.84s20.032 35.904 44.8 35.904h44.736c24.768 0 43.904-16.064 43.904-35.904zM512 198.464c19.776 0 35.84-20.032 35.84-44.8v-44.8C547.84 84.032 531.84 64 512 64s-35.904 20.032-35.904 44.8v44.8c0 24.768 16.128 44.864 35.904 44.864z m0 627.136c-19.776 0-35.904 20.032-35.904 44.8v44.736C476.096 940.032 492.16 960 512 960s35.84-20.032 35.84-44.8v-44.736c0-24.768-16.064-44.864-35.84-44.864z m329.92-592.832c17.472-17.536 20.288-43.072 6.4-57.024-14.016-14.016-39.488-11.2-57.024 6.336-4.736 4.864-26.496 26.496-31.36 31.36-17.472 17.472-20.288 43.008-6.336 57.024 13.952 14.016 39.488 11.2 57.024-6.336 4.8-4.864 26.496-26.56 31.296-31.36zM213.376 759.936c-4.864 4.8-26.56 26.624-31.36 31.36-17.472 17.472-20.288 42.944-6.4 56.96 14.016 13.952 39.552 11.2 57.024-6.336 4.8-4.736 26.56-26.496 31.36-31.36 17.472-17.472 20.288-43.008 6.336-56.96-14.016-13.952-39.552-11.072-56.96 6.336z m19.328-577.92c-17.536-17.536-43.008-20.352-57.024-6.336-14.08 14.016-11.136 39.488 6.336 57.024 4.864 4.864 26.496 26.56 31.36 31.424 17.536 17.408 43.008 20.288 56.96 6.336 14.016-14.016 11.264-39.488-6.336-57.024-4.736-4.864-26.496-26.56-31.296-31.424z m527.168 628.608c4.864 4.864 26.624 26.624 31.36 31.424 17.536 17.408 43.072 20.224 57.088 6.336 13.952-14.016 11.072-39.552-6.4-57.024-4.864-4.8-26.56-26.496-31.36-31.36-17.472-17.408-43.072-20.288-57.024-6.336-13.952 14.016-11.008 39.488 6.336 56.96z" p-id="4027"></path></svg></button><button title="Default to system" class="__dumi-default-dark-auto "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="11002" width="22" height="22"><path d="M127.658667 492.885333c0-51.882667 10.24-101.717333 30.378666-149.162666s47.786667-88.064 81.92-122.538667 75.093333-61.781333 122.538667-81.92 96.938667-30.378667 149.162667-30.378667 101.717333 10.24 149.162666 30.378667 88.405333 47.786667 122.88 81.92 61.781333 75.093333 81.92 122.538667 30.378667 96.938667 30.378667 149.162666-10.24 101.717333-30.378667 149.162667-47.786667 88.405333-81.92 122.88-75.093333 61.781333-122.88 81.92-97.28 30.378667-149.162666 30.378667-101.717333-10.24-149.162667-30.378667-88.064-47.786667-122.538667-81.92-61.781333-75.093333-81.92-122.88-30.378667-96.938667-30.378666-149.162667z m329.045333 0c0 130.048 13.994667 244.394667 41.984 343.381334h12.970667c46.762667 0 91.136-9.216 133.461333-27.306667s78.848-42.666667 109.568-73.386667 54.954667-67.242667 73.386667-109.568 27.306667-86.698667 27.306666-133.461333c0-46.421333-9.216-90.794667-27.306666-133.12s-42.666667-78.848-73.386667-109.568-67.242667-54.954667-109.568-73.386667-86.698667-27.306667-133.461333-27.306666h-11.605334c-28.672 123.562667-43.349333 237.909333-43.349333 343.722666z" p-id="11003"></path></svg></button></div></div></div><ul class="__dumi-default-menu-list"><li><a href="/blog/">大师兄 - 前端架构师</a></li></ul></div></div><ul role="slug-list" class="__dumi-default-layout-toc"><li title="SSR是什么" data-depth="2"><a href="/blog/玩转vue3全家桶/06.vue3生态源码篇/11#ssr是什么"><span>SSR是什么</span></a></li><li title="怎么做SSR" data-depth="2"><a href="/blog/玩转vue3全家桶/06.vue3生态源码篇/11#怎么做ssr"><span>怎么做SSR</span></a></li><li title="Vue SSR源码剖析" data-depth="2"><a href="/blog/玩转vue3全家桶/06.vue3生态源码篇/11#vue-ssr源码剖析"><span>Vue SSR源码剖析</span></a></li><li title="同构应用和其他渲染方式" data-depth="2"><a href="/blog/玩转vue3全家桶/06.vue3生态源码篇/11#同构应用和其他渲染方式"><span>同构应用和其他渲染方式</span></a></li><li title="SSR+同构的问题" data-depth="3"><a href="/blog/玩转vue3全家桶/06.vue3生态源码篇/11#ssr同构的问题"><span>SSR+同构的问题</span></a></li><li title="解决方案" data-depth="3"><a href="/blog/玩转vue3全家桶/06.vue3生态源码篇/11#解决方案"><span>解决方案</span></a></li><li title="总结" data-depth="2"><a href="/blog/玩转vue3全家桶/06.vue3生态源码篇/11#总结"><span>总结</span></a></li><li title="思考题" data-depth="2"><a href="/blog/玩转vue3全家桶/06.vue3生态源码篇/11#思考题"><span>思考题</span></a></li></ul><div class="__dumi-default-layout-content"><div class="markdown"><h1 id="38服务端渲染原理vue-3中的ssr是如何实现的"><a aria-hidden="true" tabindex="-1" href="/blog/玩转vue3全家桶/06.vue3生态源码篇/11#38服务端渲染原理vue-3中的ssr是如何实现的"><span class="icon icon-link"></span></a>38｜服务端渲染原理：Vue 3中的SSR是如何实现的？</h1><p>你好，我是大圣，上一讲我们学完vue-router源码，Vue全家桶的生态就基本介绍完了，包括Vue的响应式、运行时、编译器，以及全家桶的vuex和vue-router。</p><p>今天我来给你介绍Vue中优化的一个进阶知识点：SSR（Server Side Rendering），也就是服务端渲染。</p><h2 id="ssr是什么"><a aria-hidden="true" tabindex="-1" href="/blog/玩转vue3全家桶/06.vue3生态源码篇/11#ssr是什么"><span class="icon icon-link"></span></a>SSR是什么</h2><p>要想搞清楚SSR是什么？我们需要先理解这个方案是为解决什么问题而产生的。</p><p>在现在MVVM盛行的时代，无论是Vue还是React的全家桶，都有路由框架的身影，所以，页面的渲染流程也全部都是浏览器加载完JavaScript文件后，由JavaScript获取当前的路由地址，再决定渲染哪个页面。</p><p>这种架构下，<strong>所有的路由和页面都是在客户端进行解析和渲染的，我们称之为Client Side Rendering，简写为CSR，也就是客户端渲染</strong>。</p><p>交互体验确实提升了，但同时也带来了两个小问题。</p><p>首先，如果采用CSR，我们在ailemente项目中执行<code>npm run build</code>命令后，可以在项目根目录下看到多了一个dist文件夹，打开其中的index.html文件，看到下面的代码：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">&lt;!DOCTYPE html&gt;</span></div><div class="token-line"><span class="token plain">    &lt;html lang=&quot;en&quot;&gt;</span></div><div class="token-line"><span class="token plain">      &lt;head&gt;</span></div><div class="token-line"><span class="token plain">        &lt;meta charset=&quot;UTF-8&quot; /&gt;</span></div><div class="token-line"><span class="token plain">        &lt;link rel=&quot;icon&quot; href=&quot;/favicon.ico&quot; /&gt;</span></div><div class="token-line"><span class="token plain">        &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt;</span></div><div class="token-line"><span class="token plain">        &lt;title&gt;Vite App&lt;/title&gt;</span></div><div class="token-line"><span class="token plain">        &lt;script type=&quot;module&quot; crossorigin src=&quot;/assets/index.c305634d.js&quot;&gt;&lt;/script&gt;</span></div><div class="token-line"><span class="token plain">        &lt;link rel=&quot;modulepreload&quot; href=&quot;/assets/vendor.9419ee42.js&quot;&gt;</span></div><div class="token-line"><span class="token plain">        &lt;link rel=&quot;stylesheet&quot; href=&quot;/assets/index.1826a359.css&quot;&gt;</span></div><div class="token-line"><span class="token plain">      &lt;/head&gt;</span></div><div class="token-line"><span class="token plain">      &lt;body&gt;</span></div><div class="token-line"><span class="token plain">        &lt;div id=&quot;app&quot;&gt;&lt;/div&gt;</span></div><div class="token-line"><span class="token plain">        </span></div><div class="token-line"><span class="token plain">      &lt;/body&gt;</span></div><div class="token-line"><span class="token plain">    &lt;/html&gt;</span></div></pre></div><p>这就是项目部署上线之后的入口文件，body内部就是一个空的div标签，用户访问这个页面后，页面的首屏需要等待JavaScript加载和执行完毕才能看到，这样白屏时间肯定比body内部写页面标签的要长一些，尤其在客户端网络环境差的情况下，等待JavaScript下载和执行的白屏时间是很伤害用户体验的。</p><p>其次，搜索引擎的爬虫抓取到你的页面数据后，发现body是空的，也会认为你这个页面是空的，这对于SEO是很不利的。即使现在基于Google的搜索引擎爬虫已经能够支持JavaScript的执行，但是爬虫不会等待页面的网络数据请求，何况国内主要的搜索引擎还是百度。</p><p>所以如果你的项目对白屏时间和搜索引擎有要求，<strong>我们就需要在用户访问页面的时候，能够把首屏渲染的HTML内容写入到body内部，也就是说我们需要在服务器端实现组件的渲染</strong>，这就是SSR的用武之地。</p><h2 id="怎么做ssr"><a aria-hidden="true" tabindex="-1" href="/blog/玩转vue3全家桶/06.vue3生态源码篇/11#怎么做ssr"><span class="icon icon-link"></span></a>怎么做SSR</h2><p>那怎么在服务器端实现组件渲染呢？Vue提供了@vue/server-renderer这个专门做服务端解析的库，我们来尝试使用一下。</p><p>首先创建一个新的文件夹vue-ssr，执行下面命令来安装server-renderer、vue和express：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">npm init -y </span></div><div class="token-line"><span class="token plain">    npm install @vue/server-renderer vue@next express --save</span></div></pre></div><p>然后新建server.js，核心就是要实现在服务器端解析Vue的组件，直接把渲染结果返回给浏览器。</p><p>下面的代码中我们使用express启动了一个服务器，监听9093端口，在用户访问首页的时候，通过createSSRApp创建一个Vue的实例，并且通过@vue/compiler-ssr对模板的template进行编译，返回的函数配置在vueapp的ssrRender属性上，最后通过@vue/server-renderer的renderToString方法渲染Vue的实例，把renderToString返回的字符串通过res.send返回给客户端。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// 引入express</span></div><div class="token-line"><span class="token plain">    const express = require(&#x27;express&#x27;) </span></div><div class="token-line"><span class="token plain">    const app = express()</span></div><div class="token-line"><span class="token plain">    const Vue = require(&#x27;vue&#x27;) // vue@next</span></div><div class="token-line"><span class="token plain">    const renderer3 = require(&#x27;@vue/server-renderer&#x27;)</span></div><div class="token-line"><span class="token plain">    const vue3Compile= require(&#x27;@vue/compiler-ssr&#x27;)</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    // 一个vue的组件</span></div><div class="token-line"><span class="token plain">    const vueapp = {</span></div><div class="token-line"><span class="token plain">      template: `&lt;div&gt;</span></div><div class="token-line"><span class="token plain">        &lt;h1 @click=&quot;add&quot;&gt;{{num}}&lt;/h1&gt;</span></div><div class="token-line"><span class="token plain">        &lt;ul &gt;</span></div><div class="token-line"><span class="token plain">          &lt;li v-for=&quot;(todo,n) in todos&quot; &gt;{{n+1}}--{{todo}}&lt;/li&gt;</span></div><div class="token-line"><span class="token plain">        &lt;/ul&gt;</span></div><div class="token-line"><span class="token plain">      &lt;/div&gt;`,</span></div><div class="token-line"><span class="token plain">      data(){</span></div><div class="token-line"><span class="token plain">        return {</span></div><div class="token-line"><span class="token plain">          num:1,</span></div><div class="token-line"><span class="token plain">          todos:[&#x27;吃饭&#x27;,&#x27;睡觉&#x27;,&#x27;学习Vue&#x27;]</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">      },</span></div><div class="token-line"><span class="token plain">      methods:{</span></div><div class="token-line"><span class="token plain">        add(){</span></div><div class="token-line"><span class="token plain">          this.num++</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">      } </span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    // 使用@vue/compiler-ssr解析template</span></div><div class="token-line"><span class="token plain">    vueapp.ssrRender = new Function(&#x27;require&#x27;,vue3Compile.compile(vueapp.template).code)(require)</span></div><div class="token-line"><span class="token plain">    // 路由首页返回结果</span></div><div class="token-line"><span class="token plain">    app.get(&#x27;/&#x27;,async function(req,res){</span></div><div class="token-line"><span class="token plain">        let vapp = Vue.createSSRApp(vueapp)</span></div><div class="token-line"><span class="token plain">        let html = await renderer3.renderToString(vapp)</span></div><div class="token-line"><span class="token plain">        const title = &quot;Vue SSR&quot;</span></div><div class="token-line"><span class="token plain">        let ret = `</span></div><div class="token-line"><span class="token plain">    &lt;!DOCTYPE html&gt;</span></div><div class="token-line"><span class="token plain">    &lt;html lang=&quot;en&quot;&gt;</span></div><div class="token-line"><span class="token plain">      &lt;head&gt;</span></div><div class="token-line"><span class="token plain">        &lt;meta charset=&quot;UTF-8&quot; /&gt;</span></div><div class="token-line"><span class="token plain">        &lt;link rel=&quot;icon&quot; href=&quot;/favicon.ico&quot; /&gt;</span></div><div class="token-line"><span class="token plain">        &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt;</span></div><div class="token-line"><span class="token plain">        &lt;title&gt;${title}&lt;/title&gt;</span></div><div class="token-line"><span class="token plain">      &lt;/head&gt;</span></div><div class="token-line"><span class="token plain">      &lt;body&gt;</span></div><div class="token-line"><span class="token plain">        &lt;div id=&quot;app&quot;&gt;</span></div><div class="token-line"><span class="token plain">          ${html}</span></div><div class="token-line"><span class="token plain">        &lt;/div&gt;</span></div><div class="token-line"><span class="token plain">      &lt;/body&gt;</span></div><div class="token-line"><span class="token plain">    &lt;/html&gt;`    </span></div><div class="token-line"><span class="token plain">        res.send(ret)</span></div><div class="token-line"><span class="token plain">    })</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    app.listen(9093,()=&gt;{</span></div><div class="token-line"><span class="token plain">        console.log(&#x27;listen 9093&#x27;)</span></div><div class="token-line"><span class="token plain">    })</span></div></pre></div><p>现在我们访问页面后，点击右键查看网页源代码，会出现下图所示的页面：<br/><img src="https://static001.geekbang.org/resource/image/7a/d2/7a345e1b518259e0b2fd7bb0d6c7f6d2.png?wh=1920x582" alt="图片"/></p><p>可以看到，首屏的body标签内部就出现了vue组件中v-for渲染后的标签结果，我们的第一步就完成了。</p><p>但具体SSR是怎么实现的呢？我们一起来看源码。</p><h2 id="vue-ssr源码剖析"><a aria-hidden="true" tabindex="-1" href="/blog/玩转vue3全家桶/06.vue3生态源码篇/11#vue-ssr源码剖析"><span class="icon icon-link"></span></a>Vue SSR源码剖析</h2><p>在CSR环境下，template解析的render函数用来返回组件的虚拟DOM，而SSR环境下template解析的ssrRender函数，函数内部是通过_push对字符串进行拼接，最终生成组件渲染的结果的。你可以在官方的[模板渲染演示页面](&lt;<a target="_blank" rel="noopener noreferrer" href="https://vue-next-template-explorer.netlify.app/#%7B%22src%22:%22">https://vue-next-template-explorer.netlify.app/#<!-- -->{<!-- -->&quot;src&quot;:&quot;<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p><div>\n    <ul>\n      &lt;li v-for=&quot;(todo,n) in todos&quot; &gt;<!-- -->{<!-- -->{<!-- -->n+1<!-- -->}<!-- -->}<!-- -->--<!-- -->{<!-- -->{<!-- -->todo<!-- -->}<!-- -->}<!-- -->\n    </ul>\n  </div>&quot;,&quot;ssr&quot;:true,&quot;options&quot;:<!-- -->{<!-- -->&quot;mode&quot;:&quot;function&quot;,&quot;filename&quot;:&quot;Foo.vue&quot;,&quot;prefixIdentifiers&quot;:false,&quot;hoistStatic&quot;:true,&quot;cacheHandlers&quot;:true,&quot;scopeId&quot;:null,&quot;inline&quot;:false,&quot;ssrCssVars&quot;:&quot;<!-- -->{<!-- --> color <!-- -->}<!-- -->&quot;,&quot;compatConfig&quot;:<!-- -->{<!-- -->&quot;MODE&quot;:3<!-- -->}<!-- -->,&quot;whitespace&quot;:&quot;condense&quot;,&quot;bindingMetadata&quot;:<!-- -->{<!-- -->&quot;TestComponent&quot;:&quot;setup-const&quot;,&quot;setupRef&quot;:&quot;setup-ref&quot;,&quot;setupConst&quot;:&quot;setup-const&quot;,&quot;setupLet&quot;:&quot;setup-let&quot;,&quot;setupMaybeRef&quot;:&quot;setup-maybe-ref&quot;,&quot;setupProp&quot;:&quot;props&quot;,&quot;vMySetupDir&quot;:&quot;setup-const&quot;<!-- -->}<!-- -->,&quot;optimizeBindings&quot;:false<!-- -->}<!-- -->}<!-- -->&gt;)选择ssr设置后，看到渲染的结果：<div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">const { mergeProps: _mergeProps } = require(&quot;vue&quot;)</span></div><div class="token-line"><span class="token plain">    const { ssrRenderAttrs: _ssrRenderAttrs, ssrInterpolate: _ssrInterpolate, ssrRenderList: _ssrRenderList } = require(&quot;vue/server-renderer&quot;)</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    return function ssrRender(_ctx, _push, _parent, _attrs, $props, $setup, $data, $options) {</span></div><div class="token-line"><span class="token plain">      const _cssVars = { style: { color: _ctx.color }}</span></div><div class="token-line"><span class="token plain">      _push(`&lt;div${_ssrRenderAttrs(_mergeProps(_attrs, _cssVars))}&gt;&lt;ul&gt;&lt;!--[--&gt;`)</span></div><div class="token-line"><span class="token plain">      _ssrRenderList(_ctx.todos, (todo, n) =&gt; {</span></div><div class="token-line"><span class="token plain">        _push(`&lt;li&gt;${</span></div><div class="token-line"><span class="token plain">          _ssrInterpolate(n+1)</span></div><div class="token-line"><span class="token plain">        }--${</span></div><div class="token-line"><span class="token plain">          _ssrInterpolate(todo)</span></div><div class="token-line"><span class="token plain">        }&lt;/li&gt;`)</span></div><div class="token-line"><span class="token plain">      })</span></div><div class="token-line"><span class="token plain">      _push(`&lt;!--]--&gt;&lt;/ul&gt;&lt;/div&gt;`)</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>可以看到ssrRender函数内部通过传递的_push函数拼接组件渲染的结果后，直接返回renderToString函数的执行结果。</p><p>那renderToString是如何工作的呢？</p><p>现在你已经拥有了源码阅读的技巧，我们进入到vue-next/packages/server-renderer文件中，打开<strong>renderToString文件</strong>：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">export async function renderToString(</span></div><div class="token-line"><span class="token plain">      input: App | VNode,</span></div><div class="token-line"><span class="token plain">      context: SSRContext = {}</span></div><div class="token-line"><span class="token plain">    ): Promise&lt;string&gt; {</span></div><div class="token-line"><span class="token plain">      if (isVNode(input)) {</span></div><div class="token-line"><span class="token plain">        // raw vnode, wrap with app (for context)</span></div><div class="token-line"><span class="token plain">        return renderToString(createApp({ render: () =&gt; input }), context)</span></div><div class="token-line"><span class="token plain">      }</span></div><div class="token-line"><span class="token plain">      const vnode = createVNode(input._component, input._props)</span></div><div class="token-line"><span class="token plain">      vnode.appContext = input._context</span></div><div class="token-line"><span class="token plain">      // provide the ssr context to the tree</span></div><div class="token-line"><span class="token plain">      input.provide(ssrContextKey, context)</span></div><div class="token-line"><span class="token plain">      const buffer = await renderComponentVNode(vnode)</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">      await resolveTeleports(context)</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">      return unrollBuffer(buffer as SSRBuffer)</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>这段代码可以看到，我们通过renderComponentVNode函数对创建的Vnode进行渲染，生成一个buffer变量，最后通过unrollBuffer返回字符串。</p><p>我们先继续看<strong>renderComponentVNode函数</strong>，它内部通过renderComponentSubTree进行虚拟DOM的子树渲染，而renderComponentSubTree内部调用组件内部的ssrRender函数，这个函数就是我们代码中通过@vue/compiler-ssr解析之后的ssrRender函数，传递的push参数是通过createBuffer传递的：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">export function renderComponentVNode(</span></div><div class="token-line"><span class="token plain">      vnode: VNode,</span></div><div class="token-line"><span class="token plain">      parentComponent: ComponentInternalInstance | null = null,</span></div><div class="token-line"><span class="token plain">      slotScopeId?: string</span></div><div class="token-line"><span class="token plain">    ): SSRBuffer | Promise&lt;SSRBuffer&gt; {</span></div><div class="token-line"><span class="token plain">      const instance = createComponentInstance(vnode, parentComponent, null)</span></div><div class="token-line"><span class="token plain">      const res = setupComponent(instance, true /* isSSR */)</span></div><div class="token-line"><span class="token plain">      if (hasAsyncSetup || prefetches) {</span></div><div class="token-line"><span class="token plain">        ....</span></div><div class="token-line"><span class="token plain">        return p.then(() =&gt; renderComponentSubTree(instance, slotScopeId))</span></div><div class="token-line"><span class="token plain">      } else {</span></div><div class="token-line"><span class="token plain">        return renderComponentSubTree(instance, slotScopeId)</span></div><div class="token-line"><span class="token plain">      }</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    function renderComponentSubTree(instance,slotScopeId){</span></div><div class="token-line"><span class="token plain">      const { getBuffer, push } = createBuffer()</span></div><div class="token-line"><span class="token plain">      const ssrRender = instance.ssrRender || comp.ssrRender</span></div><div class="token-line"><span class="token plain">      if (ssrRender) {</span></div><div class="token-line"><span class="token plain">          ssrRender(</span></div><div class="token-line"><span class="token plain">            instance.proxy,</span></div><div class="token-line"><span class="token plain">            push,</span></div><div class="token-line"><span class="token plain">            instance,</span></div><div class="token-line"><span class="token plain">            attrs,</span></div><div class="token-line"><span class="token plain">            // compiler-optimized bindings</span></div><div class="token-line"><span class="token plain">            instance.props,</span></div><div class="token-line"><span class="token plain">            instance.setupState,</span></div><div class="token-line"><span class="token plain">            instance.data,</span></div><div class="token-line"><span class="token plain">            instance.ctx</span></div><div class="token-line"><span class="token plain">          )</span></div><div class="token-line"><span class="token plain">      }</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p><strong>createBuffer的实现</strong>也很简单，buffer是一个数组，push函数就是不停地在数组最后新增数据，如果item是字符串，就在数组最后一个数据上直接拼接字符串，否则就在数组尾部新增一个元素，这种提前合并字符串的做法，也算是一个小优化。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">export function createBuffer() {</span></div><div class="token-line"><span class="token plain">      let appendable = false</span></div><div class="token-line"><span class="token plain">      const buffer: SSRBuffer = []</span></div><div class="token-line"><span class="token plain">      return {</span></div><div class="token-line"><span class="token plain">        getBuffer(): SSRBuffer {</span></div><div class="token-line"><span class="token plain">          // Return static buffer and await on items during unroll stage</span></div><div class="token-line"><span class="token plain">          return buffer</span></div><div class="token-line"><span class="token plain">        },</span></div><div class="token-line"><span class="token plain">        push(item: SSRBufferItem) {</span></div><div class="token-line"><span class="token plain">          const isStringItem = isString(item)</span></div><div class="token-line"><span class="token plain">          if (appendable &amp;&amp; isStringItem) {</span></div><div class="token-line"><span class="token plain">            buffer[buffer.length - 1] += item as string</span></div><div class="token-line"><span class="token plain">          } else {</span></div><div class="token-line"><span class="token plain">            buffer.push(item)</span></div><div class="token-line"><span class="token plain">          }</span></div><div class="token-line"><span class="token plain">          appendable = isStringItem</span></div><div class="token-line"><span class="token plain">          if (isPromise(item) || (isArray(item) &amp;&amp; item.hasAsync)) {</span></div><div class="token-line"><span class="token plain">            // promise, or child buffer with async, mark as async.</span></div><div class="token-line"><span class="token plain">            // this allows skipping unnecessary await ticks during unroll stage</span></div><div class="token-line"><span class="token plain">            buffer.hasAsync = true</span></div><div class="token-line"><span class="token plain">          }</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">      }</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>最后我们看下返回字符串的<strong>unrollBuffer函数</strong>，由于buffer数组中可能会有异步的组件，服务器返回渲染内容之前，我们要把组件依赖的异步任务使用await，等待执行完毕后，进行字符串的拼接，最后返回给浏览器。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">async function unrollBuffer(buffer: SSRBuffer): Promise&lt;string&gt; {</span></div><div class="token-line"><span class="token plain">      if (buffer.hasAsync) {</span></div><div class="token-line"><span class="token plain">        let ret = &#x27;&#x27;</span></div><div class="token-line"><span class="token plain">        for (let i = 0; i &lt; buffer.length; i++) {</span></div><div class="token-line"><span class="token plain">          let item = buffer[i]</span></div><div class="token-line"><span class="token plain">          if (isPromise(item)) {</span></div><div class="token-line"><span class="token plain">            item = await item</span></div><div class="token-line"><span class="token plain">          }</span></div><div class="token-line"><span class="token plain">          if (isString(item)) {</span></div><div class="token-line"><span class="token plain">            ret += item</span></div><div class="token-line"><span class="token plain">          } else {</span></div><div class="token-line"><span class="token plain">            ret += await unrollBuffer(item)</span></div><div class="token-line"><span class="token plain">          }</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        return ret</span></div><div class="token-line"><span class="token plain">      } else {</span></div><div class="token-line"><span class="token plain">        // sync buffer can be more efficiently unrolled without unnecessary await</span></div><div class="token-line"><span class="token plain">        // ticks</span></div><div class="token-line"><span class="token plain">        return unrollBufferSync(buffer)</span></div><div class="token-line"><span class="token plain">      }</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>至此我们就把Vue中SSR的渲染流程梳理完毕了，通过compiler-ssr模块把template解析成ssrRender函数后，整个组件通过renderToString把组件渲染成字符串返回给浏览器。</p><p>SSR最终实现了通过服务器端解析Vue组件的方式，提高首屏的响应时间和页面的SEO友好度。</p><h2 id="同构应用和其他渲染方式"><a aria-hidden="true" tabindex="-1" href="/blog/玩转vue3全家桶/06.vue3生态源码篇/11#同构应用和其他渲染方式"><span class="icon icon-link"></span></a>同构应用和其他渲染方式</h2><p>现在服务器渲染SSR的逻辑我们已经掌握了，但是现在页面中没有JavaScript的加入，我们既需要提供服务器渲染的首屏内容，又需要CSR带来的优秀交互体验，这个时候我们就需要使用同构的方式来构建Vue的应用。</p><p>什么是同构应用呢？看来自于Vue官网的同构应用的经典架构图：</p><p><img src="https://static001.geekbang.org/resource/image/13/6b/13ba7725eb1e2aaf07920ae5cbb9d26b.png?wh=1920x880" alt="图片"/></p><p>左边是我们的源码，无论项目有多么复杂，都可以拆分为component + store + router三大模块。这一部分的源码，设置了两个入口，分别是客户端入口 client entry 和服务器端入口 server entry。打包的过程中也有两个打包的配置文件，分别客户端的配置和服务器端的配置。</p><p>最终在服务端实现用户首次访问页面的时候通过服务器端入口进入，显示服务器渲染的结果，然后用户在后续的操作中由客户端接管，通过vue-router来提高页面跳转的交互体验，这就是<strong>同构应用</strong>的概念。</p><h3 id="ssr同构的问题"><a aria-hidden="true" tabindex="-1" href="/blog/玩转vue3全家桶/06.vue3生态源码篇/11#ssr同构的问题"><span class="icon icon-link"></span></a>SSR+同构的问题</h3><p>当然，没有任何一个技术架构是完美的，SSR和同构带来了很好的首屏速度和SEO友好度，但是也让我们的项目多了一个Node服务器模块。</p><p>首先，我们部署的难度会提高。之前的静态资源直接上传到服务器的Nginx目录下，做好版本管理即可，现在还需要在服务器上部署一个Node环境，额外带来了部署和监控的成本，工作量提升了。</p><p>其次，SSR和同构的架构，实际上，是把客户端渲染组件的计算逻辑移到了服务器端执行，在并发量大的场景中，会加大服务器的负载。所以，所有的同构应用下还需要有降级渲染的逻辑，在服务器负载过高或者服务器有异常报错的情况下，让页面恢复为客户端渲染。</p><p>总的来说，同构解决问题的同时，也带来了额外的系统复杂度。<strong>每个技术架构的出现都是为了解决一些特定的问题，但是它们的出现也必然会带来新的问题</strong>。</p><p>针对同构出现的问题目前也有一些解决方案来应对。</p><h3 id="解决方案"><a aria-hidden="true" tabindex="-1" href="/blog/玩转vue3全家桶/06.vue3生态源码篇/11#解决方案"><span class="icon icon-link"></span></a>解决方案</h3><p>针对SSR架构的问题，我们也可以使用**静态网站生成（Static Site Generation，SSG）**的方式来解决，针对页面中变动频率不高的页面，直接渲染成静态页面来展示。</p><p>比如极客时间的首页变化频率比较高，每次我们都需要对每个课程的销量和评分进行排序，这部分的每次访问都需要从后端读取数据；但是每个课程内部的页面，比如文章详情页，变化频率其实是很低的，虽然课程的文本是存储在数据库里，但是每次上线前，我们可以把课程详情页生成静态的HTML页面再上线。</p><p>Vue的SSR框架nuxt就提供了很好的SSG功能，由于这一部分页面变化频率低，我们静态化之后还可以通过部署到CDN来进行页面加速，每次新文章发布或者修改的时候，重新生成一遍即可。</p><p>当然SSG也不是完全没有问题，比如极客时间如果有一万门课了，每门课几十篇文章，每次部署都全量静态生成一遍，耗时是非常惊人的，所以也不断有新的解决方案出现。</p><p>如果你的页面是内嵌在客户端内部的，可以借助客户端的运算能力，把SSR的逻辑移动到客户端进行，使用**客户端渲染（Native Side Rendering，NSR）**的方式降低服务端的负载，同时也能提高首屏的响应时间。</p><p>针对SSG全量生成的性能问题，我们可以采用**增量渲染（Incremental Site Rendering，ISR）**的方式，每次只生成核心重点的页面，比如每个课程的开篇词，其他的页面访问的时候先通过CSR的方式渲染，然后把渲染结果存储在CDN中。</p><p>现在还有解决方案<strong>边缘渲染（Edge Side Rendering，ESR）</strong>，把静态内容和动态的内容都以流的方式返回给用户，在CDN节点上返回给用户缓存静态资源，同时在CDN上负责发起动态内容的请求。</p><p>今年还出现了在浏览器里跑node的<a target="_blank" rel="noopener noreferrer" href="https://blog.stackblitz.com/posts/introducing-webcontainers">webcontainer<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>技术，如果这个技术成熟后，我们甚至可以把Express、Egg.js等后端应用也部署到CDN节点上，在浏览器端实现服务器应用的ESR，一起期待webcontainer技术的发展。</p><h2 id="总结"><a aria-hidden="true" tabindex="-1" href="/blog/玩转vue3全家桶/06.vue3生态源码篇/11#总结"><span class="icon icon-link"></span></a>总结</h2><p>我们要聊的内容就讲完了，来回顾一下。</p><p>今天我们学习了Vue中服务器渲染的原理，Vue通过@vue/compiler-ssr库把template解析成ssrRender函数，并且用@vue/server-renderer库提供了在服务器端渲染组件的能力，让用户访问首屏页面的时候，能够有更快的首屏渲染结果，并且对SEO也是友好的，server-renderer通过提供renderToString函数，内部通过管理buffer数组实现组件的渲染。</p><p>然后我们学习了SSR之后的同构、静态网站生成SSG、增量渲染ISR和边缘渲染ESR等内容，Vue中的最成熟的SSR框架就是nuxt了，最新的nuxt3还没有正式发版，内部对于SSG和ESR都支持，等nuxt3发版后你可以自行学习。</p><p>每一个技术选型都是为了解决问题存在的，无论学习什么技术，我们都不要单纯地把它当做八股文，这样才能真正掌握好一个技术。</p><h2 id="思考题"><a aria-hidden="true" tabindex="-1" href="/blog/玩转vue3全家桶/06.vue3生态源码篇/11#思考题"><span class="icon icon-link"></span></a>思考题</h2><p>最后留个思考题，你现在负责的项目，是出于什么目的考虑使用SSR的呢？欢迎在评论区分享你的思考，我们下一讲再见。</p></div><div class="__dumi-default-layout-footer-meta"><a target="_blank" rel="noopener noreferrer" href="https://github.com/GGwujun/blog/edit/master/docs/玩转Vue3全家桶/06.Vue3生态源码篇/11.md">在 GitHub 上编辑此页<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a><span data-updated-text="最后更新时间：">5/2/2022 10:56:57</span></div></div></div></div>
	<script>
  window.g_useSSR = true;
  window.g_initialProps = {};
	</script>

    <script>
      (function () {
        if (!location.port) {
          (function (i, s, o, g, r, a, m) {
            i["GoogleAnalyticsObject"] = r;
            (i[r] =
              i[r] ||
              function () {
                (i[r].q = i[r].q || []).push(arguments);
              }),
              (i[r].l = 1 * new Date());
            (a = s.createElement(o)), (m = s.getElementsByTagName(o)[0]);
            a.async = 1;
            a.src = g;
            m.parentNode.insertBefore(a, m);
          })(
            window,
            document,
            "script",
            "//www.google-analytics.com/analytics.js",
            "ga"
          );
          ga("create", "UA-149864185-1", "auto");
          ga("send", "pageview");
        }
      })();
    </script>
    <script src="/blog/umi.js"></script>
  </body>
</html>
