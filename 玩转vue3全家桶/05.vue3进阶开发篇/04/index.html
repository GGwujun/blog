<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no"
    />
    <link rel="shortcut icon" type="image/x-icon" href="/logo.png" />
    <link rel="stylesheet" href="/blog/umi.css" />
    <script>
      window.routerBase = "/blog";
    </script>
    <script>
      //! umi version: 3.5.17
    </script>
    <script>
      !(function () {
        var e = localStorage.getItem("dumi:prefers-color"),
          t = window.matchMedia("(prefers-color-scheme: dark)").matches,
          r = ["light", "dark", "auto"];
        document.documentElement.setAttribute(
          "data-prefers-color",
          e === r[2] ? (t ? r[1] : r[0]) : r.indexOf(e) > -1 ? e : r[0]
        );
      })();
    </script>
    <title>23 | 弹窗：如何设计一个弹窗组件？</title>
  </head>
  <body>
    <div id="root"><div class="__dumi-default-layout" data-route="/玩转vue3全家桶/05.vue3进阶开发篇/04" data-show-sidemenu="true" data-show-slugs="true" data-site-mode="true" data-gapless="false"><div class="__dumi-default-navbar" data-mode="site"><button class="__dumi-default-navbar-toggle"></button><a class="__dumi-default-navbar-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog/">大师兄</a><nav><div class="__dumi-default-search"><input type="search" class="__dumi-default-search-input" value=""/><ul></ul></div><span>计算机基础<ul><li><a href="/blog/编译原理之美">编译原理之美</a></li><li><a href="/blog/编译原理实战">编译原理实战</a></li><li><a href="/blog/深入浅出计算机组成原理">深入浅出计算机组成原理</a></li><li><a href="/blog/详解http">详解http</a></li><li><a href="/blog/计算机网络通关29讲">计算机网络通关29讲</a></li><li><a href="/blog/网络排查案例课">网络排查案例课</a></li><li><a href="/blog/linux操作系统">linux操作系统</a></li><li><a href="/blog/linux性能优化实战">linux性能优化实战</a></li><li><a href="/blog/程序员数学基础">程序员数学基础</a></li><li><a href="/blog/趣谈网络协议">趣谈网络协议</a></li><li><a href="/blog/操作系统实战">操作系统实战</a></li><li><a href="/blog/软件工程之美">软件工程之美</a></li><li><a href="/blog/sql必知必会">sql必知必会</a></li><li><a href="/blog/操作系统实战45讲">操作系统实战45讲</a></li><li><a href="/blog/网络编程实战">网络编程实战</a></li></ul></span><span>算法<ul><li><a href="/blog/常用算法25讲">常用算法25讲</a></li><li><a href="/blog/数据结构与算法之美">数据结构与算法之美</a></li><li><a href="/blog/业务开发算法50讲">业务开发算法50讲</a></li><li><a href="/blog/动态规划面试宝典">动态规划面试宝典</a></li></ul></span><span>前端开发<ul><li><a href="/blog/浏览器工作原理与实践">浏览器工作原理与实践</a></li><li><a href="/blog/新时代产品经理进阶之路">新时代产品经理进阶之路</a></li><li><a href="/blog/全栈工程师修炼指南">全栈工程师修炼指南</a></li><li><a href="/blog/flutter核心技术与实战">flutter核心技术与实战</a></li><li><a href="/blog/java-script核心原理解析">java-script核心原理解析</a></li><li><a href="/blog/说透低代码">说透低代码</a></li><li><a href="/blog/nodejs应用开发实战">nodejs应用开发实战</a></li><li><a href="/blog/反爬虫兵法演绎20讲">反爬虫兵法演绎20讲</a></li><li><a href="/blog/reactnative新架构实战课">reactnative新架构实战课</a></li><li><a href="/blog/正则表达式入门">正则表达式入门</a></li><li><a href="/blog/重学前端">重学前端</a></li><li><a href="/blog/serverless入门课">serverless入门课</a></li><li><a href="/blog/type-script入门实战笔记">type-script入门实战笔记</a></li><li><a href="/blog/图解googlev8">图解googlev8</a></li><li><a href="/blog/vue3源码分析">vue3源码分析</a></li><li><a aria-current="page" class="active" href="/blog/玩转Vue3全家桶">玩转Vue3全家桶</a></li><li><a href="/blog/webassembly入门">webassembly入门</a></li><li><a href="/blog/手把手带你写一个Web框架">手把手带你写一个Web框架</a></li><li><a href="/blog/web漏洞挖掘实战">web漏洞挖掘实战</a></li><li><a href="/blog/跟月影学可视化">跟月影学可视化</a></li><li><a href="/blog/搞定音频技术">搞定音频技术</a></li><li><a href="/blog/攻克视频技术">攻克视频技术</a></li></ul></span><span>前端工程化<ul><li><a href="/blog/logger">logger</a></li><li><a href="/blog/webpack">webpack</a></li><li><a href="/blog/webpackChain">webpackChain</a></li></ul></span><span>前端性能优化<ul><li><a href="/blog/react性能调优">react性能调优</a></li></ul></span><span>软件测试<ul><li><a href="/blog/全链路压测实战30讲">全链路压测实战30讲</a></li><li><a href="/blog/性能测试实战30讲">性能测试实战30讲</a></li><li><a href="/blog/自动化测试高手课">自动化测试高手课</a></li><li><a href="/blog/软件测试52讲">软件测试52讲</a></li></ul></span><span>面试<ul><li><a href="/blog/面试现场">面试现场</a></li></ul></span><span>杂谈<ul><li><a href="/blog/超级访谈对话张雪峰">超级访谈对话张雪峰</a></li><li><a href="/blog/Git实战手册">Git实战手册</a></li><li><a href="/blog/NodeJS">NodeJS</a></li><li><a href="/blog/ReactJS">ReactJS</a></li><li><a href="/blog/UI设计">UI设计</a></li><li><a href="/blog/webpack4系列教程">webpack4系列教程</a></li><li><a href="/blog/前端知识体系">前端知识体系</a></li><li><a href="/blog/剑指offer刷题笔记">剑指offer刷题笔记</a></li><li><a href="/blog/思考与成长">思考与成长</a></li><li><a href="/blog/设计模式手册">设计模式手册</a></li></ul></span><div class="__dumi-default-navbar-tool"><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "></div></div></div></nav></div><div class="__dumi-default-menu" data-mode="site"><div class="__dumi-default-menu-inner"><div class="__dumi-default-menu-header"><a class="__dumi-default-menu-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog/"></a><h1>大师兄</h1><p></p></div><div class="__dumi-default-menu-mobile-area"><ul class="__dumi-default-menu-nav-list"><li>计算机基础<ul><li><a href="/blog/编译原理之美">编译原理之美</a></li><li><a href="/blog/编译原理实战">编译原理实战</a></li><li><a href="/blog/深入浅出计算机组成原理">深入浅出计算机组成原理</a></li><li><a href="/blog/详解http">详解http</a></li><li><a href="/blog/计算机网络通关29讲">计算机网络通关29讲</a></li><li><a href="/blog/网络排查案例课">网络排查案例课</a></li><li><a href="/blog/linux操作系统">linux操作系统</a></li><li><a href="/blog/linux性能优化实战">linux性能优化实战</a></li><li><a href="/blog/程序员数学基础">程序员数学基础</a></li><li><a href="/blog/趣谈网络协议">趣谈网络协议</a></li><li><a href="/blog/操作系统实战">操作系统实战</a></li><li><a href="/blog/软件工程之美">软件工程之美</a></li><li><a href="/blog/sql必知必会">sql必知必会</a></li><li><a href="/blog/操作系统实战45讲">操作系统实战45讲</a></li><li><a href="/blog/网络编程实战">网络编程实战</a></li></ul></li><li>算法<ul><li><a href="/blog/常用算法25讲">常用算法25讲</a></li><li><a href="/blog/数据结构与算法之美">数据结构与算法之美</a></li><li><a href="/blog/业务开发算法50讲">业务开发算法50讲</a></li><li><a href="/blog/动态规划面试宝典">动态规划面试宝典</a></li></ul></li><li>前端开发<ul><li><a href="/blog/浏览器工作原理与实践">浏览器工作原理与实践</a></li><li><a href="/blog/新时代产品经理进阶之路">新时代产品经理进阶之路</a></li><li><a href="/blog/全栈工程师修炼指南">全栈工程师修炼指南</a></li><li><a href="/blog/flutter核心技术与实战">flutter核心技术与实战</a></li><li><a href="/blog/java-script核心原理解析">java-script核心原理解析</a></li><li><a href="/blog/说透低代码">说透低代码</a></li><li><a href="/blog/nodejs应用开发实战">nodejs应用开发实战</a></li><li><a href="/blog/反爬虫兵法演绎20讲">反爬虫兵法演绎20讲</a></li><li><a href="/blog/reactnative新架构实战课">reactnative新架构实战课</a></li><li><a href="/blog/正则表达式入门">正则表达式入门</a></li><li><a href="/blog/重学前端">重学前端</a></li><li><a href="/blog/serverless入门课">serverless入门课</a></li><li><a href="/blog/type-script入门实战笔记">type-script入门实战笔记</a></li><li><a href="/blog/图解googlev8">图解googlev8</a></li><li><a href="/blog/vue3源码分析">vue3源码分析</a></li><li><a aria-current="page" class="active" href="/blog/玩转Vue3全家桶">玩转Vue3全家桶</a></li><li><a href="/blog/webassembly入门">webassembly入门</a></li><li><a href="/blog/手把手带你写一个Web框架">手把手带你写一个Web框架</a></li><li><a href="/blog/web漏洞挖掘实战">web漏洞挖掘实战</a></li><li><a href="/blog/跟月影学可视化">跟月影学可视化</a></li><li><a href="/blog/搞定音频技术">搞定音频技术</a></li><li><a href="/blog/攻克视频技术">攻克视频技术</a></li></ul></li><li>前端工程化<ul><li><a href="/blog/logger">logger</a></li><li><a href="/blog/webpack">webpack</a></li><li><a href="/blog/webpackChain">webpackChain</a></li></ul></li><li>前端性能优化<ul><li><a href="/blog/react性能调优">react性能调优</a></li></ul></li><li>软件测试<ul><li><a href="/blog/全链路压测实战30讲">全链路压测实战30讲</a></li><li><a href="/blog/性能测试实战30讲">性能测试实战30讲</a></li><li><a href="/blog/自动化测试高手课">自动化测试高手课</a></li><li><a href="/blog/软件测试52讲">软件测试52讲</a></li></ul></li><li>面试<ul><li><a href="/blog/面试现场">面试现场</a></li></ul></li><li>杂谈<ul><li><a href="/blog/超级访谈对话张雪峰">超级访谈对话张雪峰</a></li><li><a href="/blog/Git实战手册">Git实战手册</a></li><li><a href="/blog/NodeJS">NodeJS</a></li><li><a href="/blog/ReactJS">ReactJS</a></li><li><a href="/blog/UI设计">UI设计</a></li><li><a href="/blog/webpack4系列教程">webpack4系列教程</a></li><li><a href="/blog/前端知识体系">前端知识体系</a></li><li><a href="/blog/剑指offer刷题笔记">剑指offer刷题笔记</a></li><li><a href="/blog/思考与成长">思考与成长</a></li><li><a href="/blog/设计模式手册">设计模式手册</a></li></ul></li></ul><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "><button title="Dark theme" class="__dumi-default-dark-moon "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="3854" width="22" height="22"><path d="M991.816611 674.909091a69.166545 69.166545 0 0 0-51.665455-23.272727 70.795636 70.795636 0 0 0-27.438545 5.585454A415.674182 415.674182 0 0 1 754.993338 698.181818c-209.594182 0-393.472-184.785455-393.472-395.636363 0-52.363636 38.539636-119.621818 69.515637-173.614546 4.887273-8.610909 9.634909-16.756364 14.103272-24.901818A69.818182 69.818182 0 0 0 384.631156 0a70.842182 70.842182 0 0 0-27.438545 5.585455C161.678429 90.298182 14.362065 307.898182 14.362065 512c0 282.298182 238.824727 512 532.38691 512a522.286545 522.286545 0 0 0 453.957818-268.334545A69.818182 69.818182 0 0 0 991.816611 674.909091zM546.679156 954.181818c-248.785455 0-462.941091-192-462.941091-442.181818 0-186.647273 140.637091-372.829091 300.939637-442.181818-36.817455 65.629091-92.578909 151.970909-92.578909 232.727273 0 250.181818 214.109091 465.454545 462.917818 465.454545a488.331636 488.331636 0 0 0 185.181091-46.545455 453.003636 453.003636 0 0 1-393.565091 232.727273z m103.656728-669.323636l-14.266182 83.781818a34.909091 34.909091 0 0 0 50.362182 36.770909l74.775272-39.563636 74.752 39.563636a36.142545 36.142545 0 0 0 16.174546 3.956364 34.909091 34.909091 0 0 0 34.210909-40.727273l-14.289455-83.781818 60.509091-59.345455a35.025455 35.025455 0 0 0-19.223272-59.578182l-83.61891-12.101818-37.376-76.101818a34.56 34.56 0 0 0-62.254545 0l-37.376 76.101818-83.618909 12.101818a34.909091 34.909091 0 0 0-19.246546 59.578182z m70.423272-64.698182a34.280727 34.280727 0 0 0 26.135273-19.083636l14.312727-29.090909 14.336 29.090909a34.257455 34.257455 0 0 0 26.135273 19.083636l32.046546 4.887273-23.272728 22.574545a35.234909 35.234909 0 0 0-10.007272 30.952727l5.46909 32.116364-28.625454-15.127273a34.490182 34.490182 0 0 0-32.302546 0l-28.695272 15.127273 5.469091-32.116364a35.141818 35.141818 0 0 0-9.984-30.952727l-23.272728-22.574545z" p-id="3855"></path></svg></button><button title="Light theme" class="__dumi-default-dark-sun "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="4026" width="22" height="22"><path d="M915.2 476.16h-43.968c-24.704 0-44.736 16-44.736 35.84s20.032 35.904 44.736 35.904H915.2c24.768 0 44.8-16.064 44.8-35.904s-20.032-35.84-44.8-35.84zM512 265.6c-136.704 0-246.464 109.824-246.464 246.4 0 136.704 109.76 246.464 246.464 246.464S758.4 648.704 758.4 512c0-136.576-109.696-246.4-246.4-246.4z m0 425.6c-99.008 0-179.2-80.128-179.2-179.2 0-98.944 80.192-179.2 179.2-179.2S691.2 413.056 691.2 512c0 99.072-80.192 179.2-179.2 179.2zM197.44 512c0-19.84-19.136-35.84-43.904-35.84H108.8c-24.768 0-44.8 16-44.8 35.84s20.032 35.904 44.8 35.904h44.736c24.768 0 43.904-16.064 43.904-35.904zM512 198.464c19.776 0 35.84-20.032 35.84-44.8v-44.8C547.84 84.032 531.84 64 512 64s-35.904 20.032-35.904 44.8v44.8c0 24.768 16.128 44.864 35.904 44.864z m0 627.136c-19.776 0-35.904 20.032-35.904 44.8v44.736C476.096 940.032 492.16 960 512 960s35.84-20.032 35.84-44.8v-44.736c0-24.768-16.064-44.864-35.84-44.864z m329.92-592.832c17.472-17.536 20.288-43.072 6.4-57.024-14.016-14.016-39.488-11.2-57.024 6.336-4.736 4.864-26.496 26.496-31.36 31.36-17.472 17.472-20.288 43.008-6.336 57.024 13.952 14.016 39.488 11.2 57.024-6.336 4.8-4.864 26.496-26.56 31.296-31.36zM213.376 759.936c-4.864 4.8-26.56 26.624-31.36 31.36-17.472 17.472-20.288 42.944-6.4 56.96 14.016 13.952 39.552 11.2 57.024-6.336 4.8-4.736 26.56-26.496 31.36-31.36 17.472-17.472 20.288-43.008 6.336-56.96-14.016-13.952-39.552-11.072-56.96 6.336z m19.328-577.92c-17.536-17.536-43.008-20.352-57.024-6.336-14.08 14.016-11.136 39.488 6.336 57.024 4.864 4.864 26.496 26.56 31.36 31.424 17.536 17.408 43.008 20.288 56.96 6.336 14.016-14.016 11.264-39.488-6.336-57.024-4.736-4.864-26.496-26.56-31.296-31.424z m527.168 628.608c4.864 4.864 26.624 26.624 31.36 31.424 17.536 17.408 43.072 20.224 57.088 6.336 13.952-14.016 11.072-39.552-6.4-57.024-4.864-4.8-26.56-26.496-31.36-31.36-17.472-17.408-43.072-20.288-57.024-6.336-13.952 14.016-11.008 39.488 6.336 56.96z" p-id="4027"></path></svg></button><button title="Default to system" class="__dumi-default-dark-auto "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="11002" width="22" height="22"><path d="M127.658667 492.885333c0-51.882667 10.24-101.717333 30.378666-149.162666s47.786667-88.064 81.92-122.538667 75.093333-61.781333 122.538667-81.92 96.938667-30.378667 149.162667-30.378667 101.717333 10.24 149.162666 30.378667 88.405333 47.786667 122.88 81.92 61.781333 75.093333 81.92 122.538667 30.378667 96.938667 30.378667 149.162666-10.24 101.717333-30.378667 149.162667-47.786667 88.405333-81.92 122.88-75.093333 61.781333-122.88 81.92-97.28 30.378667-149.162666 30.378667-101.717333-10.24-149.162667-30.378667-88.064-47.786667-122.538667-81.92-61.781333-75.093333-81.92-122.88-30.378667-96.938667-30.378666-149.162667z m329.045333 0c0 130.048 13.994667 244.394667 41.984 343.381334h12.970667c46.762667 0 91.136-9.216 133.461333-27.306667s78.848-42.666667 109.568-73.386667 54.954667-67.242667 73.386667-109.568 27.306667-86.698667 27.306666-133.461333c0-46.421333-9.216-90.794667-27.306666-133.12s-42.666667-78.848-73.386667-109.568-67.242667-54.954667-109.568-73.386667-86.698667-27.306667-133.461333-27.306666h-11.605334c-28.672 123.562667-43.349333 237.909333-43.349333 343.722666z" p-id="11003"></path></svg></button></div></div></div><ul class="__dumi-default-menu-list"><li><a href="/blog/">大师兄 - 前端架构师</a></li></ul></div></div><ul role="slug-list" class="__dumi-default-layout-toc"><li title="组件需求分析" data-depth="2"><a href="/blog/玩转vue3全家桶/05.vue3进阶开发篇/04#组件需求分析"><span>组件需求分析</span></a></li><li title="弹窗组件实现" data-depth="2"><a href="/blog/玩转vue3全家桶/05.vue3进阶开发篇/04#弹窗组件实现"><span>弹窗组件实现</span></a></li><li title="组件渲染优化" data-depth="2"><a href="/blog/玩转vue3全家桶/05.vue3进阶开发篇/04#组件渲染优化"><span>组件渲染优化</span></a></li><li title="总结" data-depth="2"><a href="/blog/玩转vue3全家桶/05.vue3进阶开发篇/04#总结"><span>总结</span></a></li><li title="思考题" data-depth="2"><a href="/blog/玩转vue3全家桶/05.vue3进阶开发篇/04#思考题"><span>思考题</span></a></li></ul><div class="__dumi-default-layout-content"><div class="markdown"><h1 id="23--弹窗如何设计一个弹窗组件"><a aria-hidden="true" tabindex="-1" href="/blog/玩转vue3全家桶/05.vue3进阶开发篇/04#23--弹窗如何设计一个弹窗组件"><span class="icon icon-link"></span></a>23 | 弹窗：如何设计一个弹窗组件？</h1><p>你好，我是大圣。</p><p>上一讲我们剖析了表单组件的实现模式，相信学完之后，你已经掌握了表单类型组件设计的细节，表单组件的主要功能就是在页面上获取用户的输入。</p><p>不过，用户在交互完成之后，还需要知道交互的结果状态，这就需要我们提供专门用来反馈操作状态的组件。这类组件根据反馈的级别不同，也分成了很多种类型，比如全屏灰色遮罩、居中显示的对话框Dialog，在交互按钮侧面显示、用来做简单提示的tooltip，以及右上角显示信息的通知组件Notification等，这类组件的交互体验你都可以在<a target="_blank" rel="noopener noreferrer" href="https://e3.shengxinjing.cn/#">Element3官网<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>感受。</p><p>今天的代码也会用Element3的Dialog组件和Notification进行举例，在动手写代码实现之前，我们先从这个弹窗组件的需求开始说起。</p><h2 id="组件需求分析"><a aria-hidden="true" tabindex="-1" href="/blog/玩转vue3全家桶/05.vue3进阶开发篇/04#组件需求分析"><span class="icon icon-link"></span></a>组件需求分析</h2><p>我们先来设计一下要做的组件，通过这部分内容，还可以帮你继续加深一下对单元测试Jest框架的使用熟练度。我建议你在设计一个新的组件的时候，也试试采用这种方式，先把组件所有的功能都罗列出来，分析清楚需求再具体实现，这样能够让你后面的工作事半功倍。</p><p>首先无论是对话框Dialog，还是消息弹窗Notification，它们都由一个弹窗的标题，以及具体的弹窗的内容组成的。我们希望弹窗有一个关闭的按钮，点击之后就可以关闭弹窗，弹窗关闭之后还可以设置回调函数。</p><p>下面这段代码演示了dialog组件的使用方法，通过title显示标题，通过slot显示文本内容和交互按钮，而通过v-model就能控制显示状态。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">&lt;el-dialog</span></div><div class="token-line"><span class="token plain">      title=&quot;提示&quot;</span></div><div class="token-line"><span class="token plain">      :visible.sync=&quot;dialogVisible&quot;</span></div><div class="token-line"><span class="token plain">      width=&quot;30%&quot;</span></div><div class="token-line"><span class="token plain">      v-model:visible=&quot;dialogVisible&quot;</span></div><div class="token-line"><span class="token plain">    &gt;</span></div><div class="token-line"><span class="token plain">      &lt;span&gt;这是一段信息&lt;/span&gt;</span></div><div class="token-line"><span class="token plain">      &lt;template #footer&gt;</span></div><div class="token-line"><span class="token plain">        &lt;span class=&quot;dialog-footer&quot;&gt;</span></div><div class="token-line"><span class="token plain">          &lt;el-button @click=&quot;dialogVisible = false&quot;&gt;取 消&lt;/el-button&gt;</span></div><div class="token-line"><span class="token plain">          &lt;el-button type=&quot;primary&quot; @click=&quot;dialogVisible = false&quot;&gt;确 定&lt;/el-button&gt;</span></div><div class="token-line"><span class="token plain">        &lt;/span&gt;</span></div><div class="token-line"><span class="token plain">      &lt;/template&gt;</span></div><div class="token-line"><span class="token plain">    &lt;/el-dialog&gt;</span></div></pre></div><p>这类组件实现起来和表单类组件区别不是特别大，我们首先需要做的就是<strong>控制好组件的数据传递</strong>，并且使用Teleport渲染到页面顶层的body标签。</p><p>像Dialog和Notification类的组件，我们只是单纯想显示一个提示或者报错信息，过几秒就删除，如果在每个组件内部都需要写一个&lt;Dialog v-if&gt;，并且使用v-if绑定变量的方式控制显示就会显得很冗余。</p><p>所以，这里就要用到一种调用Vue组件的新方式：我们可以使用JavaScript的API动态地创建和渲染Vue的组件。具体如何实现呢？我们以Notification组件为例一起看一下。</p><p>下面的代码是Element3的Notification演示代码。组件内部只有两个button，我们不需要书写额外的组件标签，只需要在&lt;script setup&gt;中使用Notification.success函数，就会在页面动态创建Notification组件，并且显示在页面右上角。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">&lt;template&gt;</span></div><div class="token-line"><span class="token plain">      &lt;el-button plain @click=&quot;open1&quot;&gt; 成功 &lt;/el-button&gt;</span></div><div class="token-line"><span class="token plain">      &lt;el-button plain @click=&quot;open2&quot;&gt; 警告 &lt;/el-button&gt;</span></div><div class="token-line"><span class="token plain">    &lt;/template&gt;</span></div><div class="token-line"><span class="token plain">    &lt;script setup&gt;</span></div><div class="token-line"><span class="token plain">      import { Notification } from &#x27;element3&#x27;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">      function open1() {</span></div><div class="token-line"><span class="token plain">        Notification.success({</span></div><div class="token-line"><span class="token plain">          title: &#x27;成功&#x27;,</span></div><div class="token-line"><span class="token plain">          message: &#x27;这是一条成功的提示消息&#x27;,</span></div><div class="token-line"><span class="token plain">          type: &#x27;success&#x27;</span></div><div class="token-line"><span class="token plain">        })</span></div><div class="token-line"><span class="token plain">      }</span></div><div class="token-line"><span class="token plain">      function open2() {</span></div><div class="token-line"><span class="token plain">        Notification.warning({</span></div><div class="token-line"><span class="token plain">          title: &#x27;警告&#x27;,</span></div><div class="token-line"><span class="token plain">          message: &#x27;这是一条警告的提示消息&#x27;,</span></div><div class="token-line"><span class="token plain">          type: &#x27;warning&#x27;</span></div><div class="token-line"><span class="token plain">        })</span></div><div class="token-line"><span class="token plain">      }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    &lt;/script&gt;</span></div></pre></div><h2 id="弹窗组件实现"><a aria-hidden="true" tabindex="-1" href="/blog/玩转vue3全家桶/05.vue3进阶开发篇/04#弹窗组件实现"><span class="icon icon-link"></span></a>弹窗组件实现</h2><p>分析完需求之后，我们借助单元测试的方法来实现这个弹窗组件（单元测试的内容如果记不清了，你可以回顾<a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/464098">第20讲<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>）。</p><p>我们依次来分析Notification的代码，相比于写Demo逻辑的代码，这次我们体验一下实际的组件和演示组件的区别。我们来到element3下面的src/components/Notification/notifucation.vue代码中，下面的代码构成了组件的主体框架，我们不去直接写组件的逻辑，而是先从测试代码来梳理组件的功能。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">&lt;template&gt;</span></div><div class="token-line"><span class="token plain">      &lt;div class=&quot;el-nofication&quot;&gt;</span></div><div class="token-line"><span class="token plain">        &lt;slot /&gt;</span></div><div class="token-line"><span class="token plain">      &lt;/div&gt;</span></div><div class="token-line"><span class="token plain">    &lt;/template&gt;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    &lt;script&gt;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    &lt;/script&gt;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    &lt;style lang=&quot;scss&quot;&gt;</span></div><div class="token-line"><span class="token plain">    @import &#x27;../styles/mixin&#x27;;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    &lt;/style&gt;</span></div></pre></div><p>结合下面的代码可以看到，我们进入到了内部文件Notification.spec.js中。下面的测试代码中，我们期待Notification组件能够渲染el-notification样式类，并且内部能够通过属性title渲染标题；message属性用来渲染消息主体；position用来渲染组件的位置，让我们的弹窗组件可以显示在浏览器四个角。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">import Notification from &quot;./Notification.vue&quot;</span></div><div class="token-line"><span class="token plain">    import { mount } from &quot;@vue/test-utils&quot;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    describe(&quot;Notification&quot;, () =&gt; { </span></div><div class="token-line"><span class="token plain">      </span></div><div class="token-line"><span class="token plain">      it(&#x27;渲染标题title&#x27;, () =&gt; {</span></div><div class="token-line"><span class="token plain">        const title = &#x27;this is a title&#x27;</span></div><div class="token-line"><span class="token plain">        const wrapper = mount(Notification, {</span></div><div class="token-line"><span class="token plain">          props: {</span></div><div class="token-line"><span class="token plain">            title</span></div><div class="token-line"><span class="token plain">          }</span></div><div class="token-line"><span class="token plain">        })</span></div><div class="token-line"><span class="token plain">        expect(wrapper.get(&#x27;.el-notification__title&#x27;).text()).toContain(title)</span></div><div class="token-line"><span class="token plain">      })</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">      it(&#x27;信息message渲染&#x27;, () =&gt; {</span></div><div class="token-line"><span class="token plain">        const message = &#x27;this is a message&#x27;</span></div><div class="token-line"><span class="token plain">        const wrapper = mount(Notification, {</span></div><div class="token-line"><span class="token plain">          props: {</span></div><div class="token-line"><span class="token plain">            message</span></div><div class="token-line"><span class="token plain">          }</span></div><div class="token-line"><span class="token plain">        })</span></div><div class="token-line"><span class="token plain">        expect(wrapper.get(&#x27;.el-notification__content&#x27;).text()).toContain(message)</span></div><div class="token-line"><span class="token plain">      })</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">      it(&#x27;位置渲染&#x27;, () =&gt; {</span></div><div class="token-line"><span class="token plain">        const position = &#x27;bottom-right&#x27;</span></div><div class="token-line"><span class="token plain">        const wrapper = mount(Notification, {</span></div><div class="token-line"><span class="token plain">          props: {</span></div><div class="token-line"><span class="token plain">            position</span></div><div class="token-line"><span class="token plain">          }</span></div><div class="token-line"><span class="token plain">        })</span></div><div class="token-line"><span class="token plain">        expect(wrapper.find(&#x27;.el-notification&#x27;).classes()).toContain(&#x27;right&#x27;)</span></div><div class="token-line"><span class="token plain">        expect(wrapper.vm.verticalProperty).toBe(&#x27;bottom&#x27;)</span></div><div class="token-line"><span class="token plain">        expect(wrapper.find(&#x27;.el-notification&#x27;).element.style.bottom).toBe(&#x27;0px&#x27;)</span></div><div class="token-line"><span class="token plain">      })</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">      it(&#x27;位置偏移&#x27;, () =&gt; {</span></div><div class="token-line"><span class="token plain">        const verticalOffset = 50</span></div><div class="token-line"><span class="token plain">        const wrapper = mount(Notification, {</span></div><div class="token-line"><span class="token plain">          props: {</span></div><div class="token-line"><span class="token plain">            verticalOffset</span></div><div class="token-line"><span class="token plain">          }</span></div><div class="token-line"><span class="token plain">        })</span></div><div class="token-line"><span class="token plain">        expect(wrapper.vm.verticalProperty).toBe(&#x27;top&#x27;)</span></div><div class="token-line"><span class="token plain">        expect(wrapper.find(&#x27;.el-notification&#x27;).element.style.top).toBe(</span></div><div class="token-line"><span class="token plain">          `${verticalOffset}px`</span></div><div class="token-line"><span class="token plain">        )</span></div><div class="token-line"><span class="token plain">      })</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    })</span></div></pre></div><p>这时候毫无疑问，测试窗口会报错。我们需要进入notificatin.vue中实现代码逻辑。<br/>下面的代码中，我们在代码中接收title、message和position，使用notification__title和notification__message渲染标题和消息。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">&lt;template&gt;</span></div><div class="token-line"><span class="token plain">      &lt;div class=&quot;el-notification&quot; :style=&quot;positionStyle&quot; @click=&quot;onClickHandler&quot;&gt;</span></div><div class="token-line"><span class="token plain">        &lt;div class=&quot;el-notification__title&quot;&gt;</span></div><div class="token-line"><span class="token plain">          {{ title }}</span></div><div class="token-line"><span class="token plain">        &lt;/div&gt;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        &lt;div class=&quot;el-notification__message&quot;&gt;</span></div><div class="token-line"><span class="token plain">          {{ message }}</span></div><div class="token-line"><span class="token plain">        &lt;/div&gt;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        &lt;button</span></div><div class="token-line"><span class="token plain">          v-if=&quot;showClose&quot;</span></div><div class="token-line"><span class="token plain">          class=&quot;el-notification__close-button&quot;</span></div><div class="token-line"><span class="token plain">          @click=&quot;onCloseHandler&quot;</span></div><div class="token-line"><span class="token plain">        &gt;&lt;/button&gt;</span></div><div class="token-line"><span class="token plain">      &lt;/div&gt;</span></div><div class="token-line"><span class="token plain">    &lt;/template&gt;</span></div><div class="token-line"><span class="token plain">    &lt;script setup&gt;</span></div><div class="token-line"><span class="token plain">    const instance = getCurrentInstance()</span></div><div class="token-line"><span class="token plain">    const visible = ref(true)</span></div><div class="token-line"><span class="token plain">    const verticalOffsetVal = ref(props.verticalOffset)</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    const typeClass = computed(() =&gt; {</span></div><div class="token-line"><span class="token plain">      return props.type ? `el-icon-${props.type}` : &#x27;&#x27;</span></div><div class="token-line"><span class="token plain">    })</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    const horizontalClass = computed(() =&gt; {</span></div><div class="token-line"><span class="token plain">      return props.position.endsWith(&#x27;right&#x27;) ? &#x27;right&#x27; : &#x27;left&#x27;</span></div><div class="token-line"><span class="token plain">    })</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    const verticalProperty = computed(() =&gt; {</span></div><div class="token-line"><span class="token plain">      return props.position.startsWith(&#x27;top&#x27;) ? &#x27;top&#x27; : &#x27;bottom&#x27;</span></div><div class="token-line"><span class="token plain">    })</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    const positionStyle = computed(() =&gt; {</span></div><div class="token-line"><span class="token plain">      return {</span></div><div class="token-line"><span class="token plain">        [verticalProperty.value]: `${verticalOffsetVal.value}px`</span></div><div class="token-line"><span class="token plain">      }</span></div><div class="token-line"><span class="token plain">    })</span></div><div class="token-line"><span class="token plain">    &lt;/script&gt;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    &lt;style lang=&quot;scss&quot;&gt;</span></div><div class="token-line"><span class="token plain">    .el-notification {</span></div><div class="token-line"><span class="token plain">      position: fixed;</span></div><div class="token-line"><span class="token plain">      right: 10px;</span></div><div class="token-line"><span class="token plain">      top: 50px;</span></div><div class="token-line"><span class="token plain">      width: 330px;</span></div><div class="token-line"><span class="token plain">      padding: 14px 26px 14px 13px;</span></div><div class="token-line"><span class="token plain">      border-radius: 8px;</span></div><div class="token-line"><span class="token plain">      border: 1px solid #ebeef5;</span></div><div class="token-line"><span class="token plain">      background-color: #fff;</span></div><div class="token-line"><span class="token plain">      box-shadow: 0 2px 12px 0 rgba(0, 0, 0, 0.1);</span></div><div class="token-line"><span class="token plain">      overflow: hidden;</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    &lt;/style&gt;</span></div></pre></div><p>然后我们新增测试代码，设置弹窗是否显示关闭按钮以及关闭弹窗之后的回调函数。我们希望点击关闭按钮之后，就能够正确执行传入的onClose函数。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">it(&#x27;set the showClose &#x27;, () =&gt; {</span></div><div class="token-line"><span class="token plain">        const showClose = true</span></div><div class="token-line"><span class="token plain">        const wrapper = mount(Notification, {</span></div><div class="token-line"><span class="token plain">          props: {</span></div><div class="token-line"><span class="token plain">            showClose</span></div><div class="token-line"><span class="token plain">          }</span></div><div class="token-line"><span class="token plain">        })</span></div><div class="token-line"><span class="token plain">        expect(wrapper.find(&#x27;.el-notification__closeBtn&#x27;).exists()).toBe(true)</span></div><div class="token-line"><span class="token plain">        expect(wrapper.find(&#x27;.el-icon-close&#x27;).exists()).toBe(true)</span></div><div class="token-line"><span class="token plain">      })</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">      it(&#x27;点击关闭按钮&#x27;, async () =&gt; {</span></div><div class="token-line"><span class="token plain">        const showClose = true</span></div><div class="token-line"><span class="token plain">        const wrapper = mount(Notification, {</span></div><div class="token-line"><span class="token plain">          props: {</span></div><div class="token-line"><span class="token plain">            showClose</span></div><div class="token-line"><span class="token plain">          }</span></div><div class="token-line"><span class="token plain">        })</span></div><div class="token-line"><span class="token plain">        const closeBtn = wrapper.get(&#x27;.el-notification__closeBtn&#x27;)</span></div><div class="token-line"><span class="token plain">        await closeBtn.trigger(&#x27;click&#x27;)</span></div><div class="token-line"><span class="token plain">        expect(wrapper.get(&#x27;.el-notification&#x27;).isVisible()).toBe(false)</span></div><div class="token-line"><span class="token plain">      })</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">      it(&#x27;持续时间之后自动管理&#x27;, async () =&gt; {</span></div><div class="token-line"><span class="token plain">        jest.useFakeTimers()</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        const wrapper = mount(Notification, {</span></div><div class="token-line"><span class="token plain">          props: {</span></div><div class="token-line"><span class="token plain">            duration: 1000</span></div><div class="token-line"><span class="token plain">          }</span></div><div class="token-line"><span class="token plain">        })</span></div><div class="token-line"><span class="token plain">        jest.runTimersToTime(1000)</span></div><div class="token-line"><span class="token plain">        await flushPromises()</span></div><div class="token-line"><span class="token plain">        expect(wrapper.get(&#x27;.el-notification&#x27;).isVisible()).toBe(false)</span></div><div class="token-line"><span class="token plain">         })</span></div></pre></div><p>到这里，Notification组件测试的主体逻辑就实现完毕了，我们拥有了一个能够显示在右上角的组件，具体效果你可以参考后面这张截图。</p><p><img src="https://static001.geekbang.org/resource/image/aa/04/aa1506d30d0b4d641aa7175c2a4a5004.jpg?wh=1920x972" alt="图片"/></p><p>进行到这里，距离完成整体设计我们还差两个步骤。</p><p>首先，弹窗类的组件都需要直接渲染在body标签下面，弹窗类组件由于布局都是绝对定位，如果在组件内部渲染，组件的css属性（比如Transform）会影响弹窗组件的渲染样式，为了避免这种问题重复出现，弹窗组件Dialog、Notification都需要渲染在body内部。</p><p>Dialog组件可以直接使用Vue3自带的Teleport，很方便地渲染到body之上。在下面的代码中, 我们用teleport组件把dialog组件包裹之后，通过to属性把dialog渲染到body标签内部。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">&lt;teleport</span></div><div class="token-line"><span class="token plain">        :disabled=&quot;!appendToBody&quot;</span></div><div class="token-line"><span class="token plain">        to=&quot;body&quot;</span></div><div class="token-line"><span class="token plain">      &gt;</span></div><div class="token-line"><span class="token plain">        &lt;div class=&quot;el-dialog&quot;&gt;</span></div><div class="token-line"><span class="token plain">          &lt;div class=&quot;el-dialog__content&quot;&gt;</span></div><div class="token-line"><span class="token plain">            &lt;slot /&gt;</span></div><div class="token-line"><span class="token plain">          &lt;/div&gt;</span></div><div class="token-line"><span class="token plain">        &lt;/div&gt;</span></div><div class="token-line"><span class="token plain">      &lt;/teleport&gt;</span></div></pre></div><p>这时我们使用浏览器调试窗口，就可以看到Dialog标签已经从当前组件移动到了body标签内部，如下图所示。</p><p><img src="https://static001.geekbang.org/resource/image/d9/61/d9199199590871f811309f4c78963761.jpg?wh=1920x902" alt="图片"/></p><p>但是Notification组件并不会在当前组件以组件的形式直接调用，我们需要像Element3一样，能够使用js函数动态创建Notification组件，<strong>给Vue的组件提供Javascript的动态渲染方法，这是弹窗类组件的特殊需求</strong>。</p><h2 id="组件渲染优化"><a aria-hidden="true" tabindex="-1" href="/blog/玩转vue3全家桶/05.vue3进阶开发篇/04#组件渲染优化"><span class="icon icon-link"></span></a>组件渲染优化</h2><p>我们先把测试代码写好，具体如下。代码中分别测试函数创建组件，以及不同配置和样式的通知组件。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">it(&#x27;函数会创建组件&#x27;, () =&gt; {</span></div><div class="token-line"><span class="token plain">      const instanceProxy = Notification(&#x27;foo&#x27;)</span></div><div class="token-line"><span class="token plain">      expect(instanceProxy.close).toBeTruthy()</span></div><div class="token-line"><span class="token plain">    })</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    it(&#x27;默认配置 &#x27;, () =&gt; {</span></div><div class="token-line"><span class="token plain">      const instanceProxy = Notification(&#x27;foo&#x27;)</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">      expect(instanceProxy.$props.position).toBe(&#x27;top-right&#x27;)</span></div><div class="token-line"><span class="token plain">      expect(instanceProxy.$props.message).toBe(&#x27;foo&#x27;)</span></div><div class="token-line"><span class="token plain">      expect(instanceProxy.$props.duration).toBe(4500)</span></div><div class="token-line"><span class="token plain">      expect(instanceProxy.$props.verticalOffset).toBe(16)</span></div><div class="token-line"><span class="token plain">    })</span></div><div class="token-line"><span class="token plain">    test(&#x27;字符串信息&#x27;, () =&gt; {</span></div><div class="token-line"><span class="token plain">      const instanceProxy = Notification.info(&#x27;foo&#x27;)</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">      expect(instanceProxy.$props.type).toBe(&#x27;info&#x27;)</span></div><div class="token-line"><span class="token plain">      expect(instanceProxy.$props.message).toBe(&#x27;foo&#x27;)</span></div><div class="token-line"><span class="token plain">    })</span></div><div class="token-line"><span class="token plain">    test(&#x27;成功信息&#x27;, () =&gt; {</span></div><div class="token-line"><span class="token plain">      const instanceProxy = Notification.success(&#x27;foo&#x27;)</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">      expect(instanceProxy.$props.type).toBe(&#x27;success&#x27;)</span></div><div class="token-line"><span class="token plain">      expect(instanceProxy.$props.message).toBe(&#x27;foo&#x27;)</span></div><div class="token-line"><span class="token plain">    })</span></div></pre></div><p>现在测试写完后还是会报错，因为现在Notification函数还没有定义，我们要能通过Notification函数动态地创建Vue的组件，而不是在template中使用组件。</p><p>在<a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/444283">JSX那一讲<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>中我们讲过，template的本质就是使用h函数创建虚拟Dom，如果我们自己想动态创建组件时，使用相同的方式即可。</p><p>在下面的代码中我们使用Notification函数去执行createComponent函数，使用h函数动态创建组件，实现了动态组件的创建。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">function createComponent(Component, props, children) {</span></div><div class="token-line"><span class="token plain">      const vnode = h(Component, { ...props, ref: MOUNT_COMPONENT_REF }, children)</span></div><div class="token-line"><span class="token plain">      const container = document.createElement(&#x27;div&#x27;)</span></div><div class="token-line"><span class="token plain">      vnode[COMPONENT_CONTAINER_SYMBOL] = container</span></div><div class="token-line"><span class="token plain">      render(vnode, container)</span></div><div class="token-line"><span class="token plain">      return vnode.component</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    export function Notification(options) {</span></div><div class="token-line"><span class="token plain">      return createNotification(mergeProps(options))</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    function createNotification(options) {</span></div><div class="token-line"><span class="token plain">      const instance = createNotificationByOpts(options)</span></div><div class="token-line"><span class="token plain">      setZIndex(instance)</span></div><div class="token-line"><span class="token plain">      addToBody(instance)</span></div><div class="token-line"><span class="token plain">      return instance.proxy</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>创建组件后，由于Notification组件同时可能会出现多个弹窗，所以我们需要使用数组来管理通知组件的每一个实例，每一个弹窗的实例都存储在数组中进行管理。</p><p>下面的代码里，我演示了怎样用数组管理弹窗的实例。Notification函数最终会暴露给用户使用，在Notification函数内部我们通过createComponent函数创建渲染的容器，然后通过createNotification创建弹窗组件的实例，并且维护在instanceList中。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">const instanceList = []</span></div><div class="token-line"><span class="token plain">    function createNotification(options) {</span></div><div class="token-line"><span class="token plain">      ...</span></div><div class="token-line"><span class="token plain">      addInstance(instance)</span></div><div class="token-line"><span class="token plain">      return instance.proxy</span></div><div class="token-line"><span class="token plain">    }  </span></div><div class="token-line"><span class="token plain">    function addInstance(instance) {</span></div><div class="token-line"><span class="token plain">      instanceList.push(instance)</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    ;[&#x27;success&#x27;, &#x27;warning&#x27;, &#x27;info&#x27;, &#x27;error&#x27;].forEach((type) =&gt; {</span></div><div class="token-line"><span class="token plain">      Notification[type] = (options) =&gt; {</span></div><div class="token-line"><span class="token plain">        if (typeof options === &#x27;string&#x27; || isVNode(options)) {</span></div><div class="token-line"><span class="token plain">          options = {</span></div><div class="token-line"><span class="token plain">            message: options</span></div><div class="token-line"><span class="token plain">          }</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        options.type = type</span></div><div class="token-line"><span class="token plain">        return Notification(options)</span></div><div class="token-line"><span class="token plain">      }</span></div><div class="token-line"><span class="token plain">    })</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    // 有了instanceList， 可以很方便的关闭所有信息弹窗</span></div><div class="token-line"><span class="token plain">    Notification.closeAll = () =&gt; {</span></div><div class="token-line"><span class="token plain">      instanceList.forEach((instance) =&gt; {</span></div><div class="token-line"><span class="token plain">        instance.proxy.close()</span></div><div class="token-line"><span class="token plain">        removeInstance(instance)</span></div><div class="token-line"><span class="token plain">      })</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>最后，我带你简单回顾下我们都做了什么。在正式动手实现弹窗组件前，我们分析了弹窗类组件的风格。弹窗类组件主要负责用户交互的反馈。根据显示的级别不同，它可以划分成不同的种类：既有覆盖全屏的弹窗Dialog，也有负责提示消息的Notification。</p><p>这些组件除了负责渲染传递的数据和方法之外，还需要能够脱离当前组件进行渲染，<strong>防止当前组件的css样式影响布局</strong>。因此Notification组件需要渲染到body标签内部，而Vue提供了Teleport组件来完成这个任务，我们通过Teleport组件就能把内部的组件渲染到指定的dom标签。</p><p>之后，我们需要给组件提供JavaScript调用的方法。我们可以使用Notification()的方式动态创建组件，利用createNotification即可动态创建Vue组件的实例。</p><p>对于弹窗组件来说可以这样操作：首先通过createNotification函数创建弹窗的实例，并且给每个弹窗设置好唯一的id属性，然后存储在数组中进行管理。接着，我们通过对createNotification函数返回值的管理，即可实现弹窗动态的渲染、更新和删除功能。</p><h2 id="总结"><a aria-hidden="true" tabindex="-1" href="/blog/玩转vue3全家桶/05.vue3进阶开发篇/04#总结"><span class="icon icon-link"></span></a>总结</h2><p>正文里已经详细讲解和演示了弹窗组件的设计，所以今天的总结我想变个花样，再给你说说TDD的事儿。</p><p>很多同学会觉得写测试代码要花一定成本，有畏难心理，觉得自己不太会写测试，这些“假想”给我们造成了“TDD很难实施”的错觉。实际上入门TDD并没有这么难。按照我的实践经验来看，先学会怎么写测试，再学习怎么重构，基本上就可以入门写TDD了。</p><p>就拿我们这讲的实践来说，我们再次应用了<strong>测试驱动开发</strong>这个方式来实现弹窗组件，把整体需求拆分成一个个子任务，逐个击破。根据设计的需求写好测试代码之后，测试代码就会检查我们的业务逻辑有没有实现，指导我们做相应的修改。</p><p>咱们的实践过程抽象出来，一共包括四个步骤：写测试 -&gt; 运行测试(报错) -&gt; 写代码让测试通过 -&gt; 重构的方式。这样的开发模式，今后你在设计组件库时也可以借鉴，不但有助于提高代码的质量和可维护性，还能让代码有比较高的代码测试覆盖率。</p><h2 id="思考题"><a aria-hidden="true" tabindex="-1" href="/blog/玩转vue3全家桶/05.vue3进阶开发篇/04#思考题"><span class="icon icon-link"></span></a>思考题</h2><p>最后留一个思考题，现在我们设计的Notification组件的message只能支持文本消息，如果想支持传入其他组件，应该如何实现？</p><p>欢迎你在评论去分享你的答案，也欢迎你把这一讲的内容分享给你的同事和朋友们，我们下一讲再见。</p></div><div class="__dumi-default-layout-footer-meta"><a target="_blank" rel="noopener noreferrer" href="https://github.com/GGwujun/blog/edit/master/docs/玩转Vue3全家桶/05.Vue3进阶开发篇/04.md">在 GitHub 上编辑此页<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a><span data-updated-text="最后更新时间：">5/2/2022 10:56:56</span></div></div></div></div>
	<script>
  window.g_useSSR = true;
  window.g_initialProps = {};
	</script>

    <script>
      (function () {
        if (!location.port) {
          (function (i, s, o, g, r, a, m) {
            i["GoogleAnalyticsObject"] = r;
            (i[r] =
              i[r] ||
              function () {
                (i[r].q = i[r].q || []).push(arguments);
              }),
              (i[r].l = 1 * new Date());
            (a = s.createElement(o)), (m = s.getElementsByTagName(o)[0]);
            a.async = 1;
            a.src = g;
            m.parentNode.insertBefore(a, m);
          })(
            window,
            document,
            "script",
            "//www.google-analytics.com/analytics.js",
            "ga"
          );
          ga("create", "UA-149864185-1", "auto");
          ga("send", "pageview");
        }
      })();
    </script>
    <script src="/blog/umi.js"></script>
  </body>
</html>
