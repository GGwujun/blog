<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no"
    />
    <link rel="shortcut icon" type="image/x-icon" href="/logo.png" />
    <link rel="stylesheet" href="/blog/umi.css" />
    <script>
      window.routerBase = "/blog";
    </script>
    <script>
      //! umi version: 3.5.17
    </script>
    <script>
      !(function () {
        var e = localStorage.getItem("dumi:prefers-color"),
          t = window.matchMedia("(prefers-color-scheme: dark)").matches,
          r = ["light", "dark", "auto"];
        document.documentElement.setAttribute(
          "data-prefers-color",
          e === r[2] ? (t ? r[1] : r[0]) : r.indexOf(e) > -1 ? e : r[0]
        );
      })();
    </script>
    <title>08｜布局编辑器：如何做到鱼和熊掌兼得？</title>
  </head>
  <body>
    <div id="root"><div class="__dumi-default-layout" data-route="/说透低代码/03.核心功能开发/03" data-show-sidemenu="true" data-show-slugs="true" data-site-mode="true" data-gapless="false"><div class="__dumi-default-navbar" data-mode="site"><button class="__dumi-default-navbar-toggle"></button><a class="__dumi-default-navbar-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog/">大师兄</a><nav><div class="__dumi-default-search"><input type="search" class="__dumi-default-search-input" value=""/><ul></ul></div><span>计算机基础<ul><li><a href="/blog/编译原理之美">编译原理之美</a></li><li><a href="/blog/编译原理实战">编译原理实战</a></li><li><a href="/blog/深入浅出计算机组成原理">深入浅出计算机组成原理</a></li><li><a href="/blog/详解http">详解http</a></li><li><a href="/blog/计算机网络通关29讲">计算机网络通关29讲</a></li><li><a href="/blog/网络排查案例课">网络排查案例课</a></li><li><a href="/blog/linux操作系统">linux操作系统</a></li><li><a href="/blog/linux性能优化实战">linux性能优化实战</a></li><li><a href="/blog/程序员数学基础">程序员数学基础</a></li><li><a href="/blog/趣谈网络协议">趣谈网络协议</a></li><li><a href="/blog/操作系统实战">操作系统实战</a></li><li><a href="/blog/软件工程之美">软件工程之美</a></li><li><a href="/blog/sql必知必会">sql必知必会</a></li><li><a href="/blog/操作系统实战45讲">操作系统实战45讲</a></li><li><a href="/blog/网络编程实战">网络编程实战</a></li></ul></span><span>算法<ul><li><a href="/blog/常用算法25讲">常用算法25讲</a></li><li><a href="/blog/数据结构与算法之美">数据结构与算法之美</a></li><li><a href="/blog/业务开发算法50讲">业务开发算法50讲</a></li><li><a href="/blog/动态规划面试宝典">动态规划面试宝典</a></li></ul></span><span>前端开发<ul><li><a href="/blog/浏览器工作原理与实践">浏览器工作原理与实践</a></li><li><a href="/blog/新时代产品经理进阶之路">新时代产品经理进阶之路</a></li><li><a href="/blog/全栈工程师修炼指南">全栈工程师修炼指南</a></li><li><a href="/blog/flutter核心技术与实战">flutter核心技术与实战</a></li><li><a href="/blog/java-script核心原理解析">java-script核心原理解析</a></li><li><a aria-current="page" class="active" href="/blog/说透低代码">说透低代码</a></li><li><a href="/blog/nodejs应用开发实战">nodejs应用开发实战</a></li><li><a href="/blog/反爬虫兵法演绎20讲">反爬虫兵法演绎20讲</a></li><li><a href="/blog/reactnative新架构实战课">reactnative新架构实战课</a></li><li><a href="/blog/正则表达式入门">正则表达式入门</a></li><li><a href="/blog/重学前端">重学前端</a></li><li><a href="/blog/serverless入门课">serverless入门课</a></li><li><a href="/blog/type-script入门实战笔记">type-script入门实战笔记</a></li><li><a href="/blog/图解googlev8">图解googlev8</a></li><li><a href="/blog/vue3源码分析">vue3源码分析</a></li><li><a href="/blog/玩转Vue3全家桶">玩转Vue3全家桶</a></li><li><a href="/blog/webassembly入门">webassembly入门</a></li><li><a href="/blog/手把手带你写一个Web框架">手把手带你写一个Web框架</a></li><li><a href="/blog/web漏洞挖掘实战">web漏洞挖掘实战</a></li><li><a href="/blog/跟月影学可视化">跟月影学可视化</a></li><li><a href="/blog/搞定音频技术">搞定音频技术</a></li><li><a href="/blog/攻克视频技术">攻克视频技术</a></li></ul></span><span>前端工程化<ul><li><a href="/blog/logger">logger</a></li><li><a href="/blog/webpack">webpack</a></li><li><a href="/blog/webpackChain">webpackChain</a></li></ul></span><span>前端性能优化<ul><li><a href="/blog/react性能调优">react性能调优</a></li></ul></span><span>软件测试<ul><li><a href="/blog/全链路压测实战30讲">全链路压测实战30讲</a></li><li><a href="/blog/性能测试实战30讲">性能测试实战30讲</a></li><li><a href="/blog/自动化测试高手课">自动化测试高手课</a></li><li><a href="/blog/软件测试52讲">软件测试52讲</a></li></ul></span><span>面试<ul><li><a href="/blog/面试现场">面试现场</a></li></ul></span><span>杂谈<ul><li><a href="/blog/超级访谈对话张雪峰">超级访谈对话张雪峰</a></li><li><a href="/blog/Git实战手册">Git实战手册</a></li><li><a href="/blog/NodeJS">NodeJS</a></li><li><a href="/blog/ReactJS">ReactJS</a></li><li><a href="/blog/UI设计">UI设计</a></li><li><a href="/blog/webpack4系列教程">webpack4系列教程</a></li><li><a href="/blog/前端知识体系">前端知识体系</a></li><li><a href="/blog/剑指offer刷题笔记">剑指offer刷题笔记</a></li><li><a href="/blog/思考与成长">思考与成长</a></li><li><a href="/blog/设计模式手册">设计模式手册</a></li></ul></span><div class="__dumi-default-navbar-tool"><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "></div></div></div></nav></div><div class="__dumi-default-menu" data-mode="site"><div class="__dumi-default-menu-inner"><div class="__dumi-default-menu-header"><a class="__dumi-default-menu-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog/"></a><h1>大师兄</h1><p></p></div><div class="__dumi-default-menu-mobile-area"><ul class="__dumi-default-menu-nav-list"><li>计算机基础<ul><li><a href="/blog/编译原理之美">编译原理之美</a></li><li><a href="/blog/编译原理实战">编译原理实战</a></li><li><a href="/blog/深入浅出计算机组成原理">深入浅出计算机组成原理</a></li><li><a href="/blog/详解http">详解http</a></li><li><a href="/blog/计算机网络通关29讲">计算机网络通关29讲</a></li><li><a href="/blog/网络排查案例课">网络排查案例课</a></li><li><a href="/blog/linux操作系统">linux操作系统</a></li><li><a href="/blog/linux性能优化实战">linux性能优化实战</a></li><li><a href="/blog/程序员数学基础">程序员数学基础</a></li><li><a href="/blog/趣谈网络协议">趣谈网络协议</a></li><li><a href="/blog/操作系统实战">操作系统实战</a></li><li><a href="/blog/软件工程之美">软件工程之美</a></li><li><a href="/blog/sql必知必会">sql必知必会</a></li><li><a href="/blog/操作系统实战45讲">操作系统实战45讲</a></li><li><a href="/blog/网络编程实战">网络编程实战</a></li></ul></li><li>算法<ul><li><a href="/blog/常用算法25讲">常用算法25讲</a></li><li><a href="/blog/数据结构与算法之美">数据结构与算法之美</a></li><li><a href="/blog/业务开发算法50讲">业务开发算法50讲</a></li><li><a href="/blog/动态规划面试宝典">动态规划面试宝典</a></li></ul></li><li>前端开发<ul><li><a href="/blog/浏览器工作原理与实践">浏览器工作原理与实践</a></li><li><a href="/blog/新时代产品经理进阶之路">新时代产品经理进阶之路</a></li><li><a href="/blog/全栈工程师修炼指南">全栈工程师修炼指南</a></li><li><a href="/blog/flutter核心技术与实战">flutter核心技术与实战</a></li><li><a href="/blog/java-script核心原理解析">java-script核心原理解析</a></li><li><a aria-current="page" class="active" href="/blog/说透低代码">说透低代码</a></li><li><a href="/blog/nodejs应用开发实战">nodejs应用开发实战</a></li><li><a href="/blog/反爬虫兵法演绎20讲">反爬虫兵法演绎20讲</a></li><li><a href="/blog/reactnative新架构实战课">reactnative新架构实战课</a></li><li><a href="/blog/正则表达式入门">正则表达式入门</a></li><li><a href="/blog/重学前端">重学前端</a></li><li><a href="/blog/serverless入门课">serverless入门课</a></li><li><a href="/blog/type-script入门实战笔记">type-script入门实战笔记</a></li><li><a href="/blog/图解googlev8">图解googlev8</a></li><li><a href="/blog/vue3源码分析">vue3源码分析</a></li><li><a href="/blog/玩转Vue3全家桶">玩转Vue3全家桶</a></li><li><a href="/blog/webassembly入门">webassembly入门</a></li><li><a href="/blog/手把手带你写一个Web框架">手把手带你写一个Web框架</a></li><li><a href="/blog/web漏洞挖掘实战">web漏洞挖掘实战</a></li><li><a href="/blog/跟月影学可视化">跟月影学可视化</a></li><li><a href="/blog/搞定音频技术">搞定音频技术</a></li><li><a href="/blog/攻克视频技术">攻克视频技术</a></li></ul></li><li>前端工程化<ul><li><a href="/blog/logger">logger</a></li><li><a href="/blog/webpack">webpack</a></li><li><a href="/blog/webpackChain">webpackChain</a></li></ul></li><li>前端性能优化<ul><li><a href="/blog/react性能调优">react性能调优</a></li></ul></li><li>软件测试<ul><li><a href="/blog/全链路压测实战30讲">全链路压测实战30讲</a></li><li><a href="/blog/性能测试实战30讲">性能测试实战30讲</a></li><li><a href="/blog/自动化测试高手课">自动化测试高手课</a></li><li><a href="/blog/软件测试52讲">软件测试52讲</a></li></ul></li><li>面试<ul><li><a href="/blog/面试现场">面试现场</a></li></ul></li><li>杂谈<ul><li><a href="/blog/超级访谈对话张雪峰">超级访谈对话张雪峰</a></li><li><a href="/blog/Git实战手册">Git实战手册</a></li><li><a href="/blog/NodeJS">NodeJS</a></li><li><a href="/blog/ReactJS">ReactJS</a></li><li><a href="/blog/UI设计">UI设计</a></li><li><a href="/blog/webpack4系列教程">webpack4系列教程</a></li><li><a href="/blog/前端知识体系">前端知识体系</a></li><li><a href="/blog/剑指offer刷题笔记">剑指offer刷题笔记</a></li><li><a href="/blog/思考与成长">思考与成长</a></li><li><a href="/blog/设计模式手册">设计模式手册</a></li></ul></li></ul><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "><button title="Dark theme" class="__dumi-default-dark-moon "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="3854" width="22" height="22"><path d="M991.816611 674.909091a69.166545 69.166545 0 0 0-51.665455-23.272727 70.795636 70.795636 0 0 0-27.438545 5.585454A415.674182 415.674182 0 0 1 754.993338 698.181818c-209.594182 0-393.472-184.785455-393.472-395.636363 0-52.363636 38.539636-119.621818 69.515637-173.614546 4.887273-8.610909 9.634909-16.756364 14.103272-24.901818A69.818182 69.818182 0 0 0 384.631156 0a70.842182 70.842182 0 0 0-27.438545 5.585455C161.678429 90.298182 14.362065 307.898182 14.362065 512c0 282.298182 238.824727 512 532.38691 512a522.286545 522.286545 0 0 0 453.957818-268.334545A69.818182 69.818182 0 0 0 991.816611 674.909091zM546.679156 954.181818c-248.785455 0-462.941091-192-462.941091-442.181818 0-186.647273 140.637091-372.829091 300.939637-442.181818-36.817455 65.629091-92.578909 151.970909-92.578909 232.727273 0 250.181818 214.109091 465.454545 462.917818 465.454545a488.331636 488.331636 0 0 0 185.181091-46.545455 453.003636 453.003636 0 0 1-393.565091 232.727273z m103.656728-669.323636l-14.266182 83.781818a34.909091 34.909091 0 0 0 50.362182 36.770909l74.775272-39.563636 74.752 39.563636a36.142545 36.142545 0 0 0 16.174546 3.956364 34.909091 34.909091 0 0 0 34.210909-40.727273l-14.289455-83.781818 60.509091-59.345455a35.025455 35.025455 0 0 0-19.223272-59.578182l-83.61891-12.101818-37.376-76.101818a34.56 34.56 0 0 0-62.254545 0l-37.376 76.101818-83.618909 12.101818a34.909091 34.909091 0 0 0-19.246546 59.578182z m70.423272-64.698182a34.280727 34.280727 0 0 0 26.135273-19.083636l14.312727-29.090909 14.336 29.090909a34.257455 34.257455 0 0 0 26.135273 19.083636l32.046546 4.887273-23.272728 22.574545a35.234909 35.234909 0 0 0-10.007272 30.952727l5.46909 32.116364-28.625454-15.127273a34.490182 34.490182 0 0 0-32.302546 0l-28.695272 15.127273 5.469091-32.116364a35.141818 35.141818 0 0 0-9.984-30.952727l-23.272728-22.574545z" p-id="3855"></path></svg></button><button title="Light theme" class="__dumi-default-dark-sun "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="4026" width="22" height="22"><path d="M915.2 476.16h-43.968c-24.704 0-44.736 16-44.736 35.84s20.032 35.904 44.736 35.904H915.2c24.768 0 44.8-16.064 44.8-35.904s-20.032-35.84-44.8-35.84zM512 265.6c-136.704 0-246.464 109.824-246.464 246.4 0 136.704 109.76 246.464 246.464 246.464S758.4 648.704 758.4 512c0-136.576-109.696-246.4-246.4-246.4z m0 425.6c-99.008 0-179.2-80.128-179.2-179.2 0-98.944 80.192-179.2 179.2-179.2S691.2 413.056 691.2 512c0 99.072-80.192 179.2-179.2 179.2zM197.44 512c0-19.84-19.136-35.84-43.904-35.84H108.8c-24.768 0-44.8 16-44.8 35.84s20.032 35.904 44.8 35.904h44.736c24.768 0 43.904-16.064 43.904-35.904zM512 198.464c19.776 0 35.84-20.032 35.84-44.8v-44.8C547.84 84.032 531.84 64 512 64s-35.904 20.032-35.904 44.8v44.8c0 24.768 16.128 44.864 35.904 44.864z m0 627.136c-19.776 0-35.904 20.032-35.904 44.8v44.736C476.096 940.032 492.16 960 512 960s35.84-20.032 35.84-44.8v-44.736c0-24.768-16.064-44.864-35.84-44.864z m329.92-592.832c17.472-17.536 20.288-43.072 6.4-57.024-14.016-14.016-39.488-11.2-57.024 6.336-4.736 4.864-26.496 26.496-31.36 31.36-17.472 17.472-20.288 43.008-6.336 57.024 13.952 14.016 39.488 11.2 57.024-6.336 4.8-4.864 26.496-26.56 31.296-31.36zM213.376 759.936c-4.864 4.8-26.56 26.624-31.36 31.36-17.472 17.472-20.288 42.944-6.4 56.96 14.016 13.952 39.552 11.2 57.024-6.336 4.8-4.736 26.56-26.496 31.36-31.36 17.472-17.472 20.288-43.008 6.336-56.96-14.016-13.952-39.552-11.072-56.96 6.336z m19.328-577.92c-17.536-17.536-43.008-20.352-57.024-6.336-14.08 14.016-11.136 39.488 6.336 57.024 4.864 4.864 26.496 26.56 31.36 31.424 17.536 17.408 43.008 20.288 56.96 6.336 14.016-14.016 11.264-39.488-6.336-57.024-4.736-4.864-26.496-26.56-31.296-31.424z m527.168 628.608c4.864 4.864 26.624 26.624 31.36 31.424 17.536 17.408 43.072 20.224 57.088 6.336 13.952-14.016 11.072-39.552-6.4-57.024-4.864-4.8-26.56-26.496-31.36-31.36-17.472-17.408-43.072-20.288-57.024-6.336-13.952 14.016-11.008 39.488 6.336 56.96z" p-id="4027"></path></svg></button><button title="Default to system" class="__dumi-default-dark-auto "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="11002" width="22" height="22"><path d="M127.658667 492.885333c0-51.882667 10.24-101.717333 30.378666-149.162666s47.786667-88.064 81.92-122.538667 75.093333-61.781333 122.538667-81.92 96.938667-30.378667 149.162667-30.378667 101.717333 10.24 149.162666 30.378667 88.405333 47.786667 122.88 81.92 61.781333 75.093333 81.92 122.538667 30.378667 96.938667 30.378667 149.162666-10.24 101.717333-30.378667 149.162667-47.786667 88.405333-81.92 122.88-75.093333 61.781333-122.88 81.92-97.28 30.378667-149.162666 30.378667-101.717333-10.24-149.162667-30.378667-88.064-47.786667-122.538667-81.92-61.781333-75.093333-81.92-122.88-30.378667-96.938667-30.378666-149.162667z m329.045333 0c0 130.048 13.994667 244.394667 41.984 343.381334h12.970667c46.762667 0 91.136-9.216 133.461333-27.306667s78.848-42.666667 109.568-73.386667 54.954667-67.242667 73.386667-109.568 27.306667-86.698667 27.306666-133.461333c0-46.421333-9.216-90.794667-27.306666-133.12s-42.666667-78.848-73.386667-109.568-67.242667-54.954667-109.568-73.386667-86.698667-27.306667-133.461333-27.306666h-11.605334c-28.672 123.562667-43.349333 237.909333-43.349333 343.722666z" p-id="11003"></path></svg></button></div></div></div><ul class="__dumi-default-menu-list"><li><a href="/blog/说透低代码">说透低代码</a></li><li><a href="/blog/说透低代码/01.开篇词">01.开篇词</a><ul><li><a href="/blog/说透低代码/01.开篇词/01"><span>开篇词｜抛开争论，先来看看真正的低代码</span></a></li></ul></li><li><a href="/blog/说透低代码/02.认知基础与架构策略">02.认知基础与架构策略</a><ul><li><a href="/blog/说透低代码/02.认知基础与架构策略/01"><span>01｜低代码平台到底是什么样的？</span></a></li><li><a href="/blog/说透低代码/02.认知基础与架构策略/02"><span>02｜低代码到底是银弹，还是行业毒瘤？</span></a></li><li><a href="/blog/说透低代码/02.认知基础与架构策略/03"><span>03｜低代码的天花板：一个完备的低代码平台应该具备哪些条件？</span></a></li><li><a href="/blog/说透低代码/02.认知基础与架构策略/04"><span>04｜演进策略：先发展通用能力还是先满足业务需求？</span></a></li><li><a href="/blog/说透低代码/02.认知基础与架构策略/05"><span>05｜基础设施 ：启动低代码平台研发之前，你需要有什么家底？</span></a></li></ul></li><li><a aria-current="page" class="active" href="/blog/说透低代码/03.核心功能开发">03.核心功能开发</a><ul><li><a href="/blog/说透低代码/03.核心功能开发/01"><span>06｜踏出新手村便遭遇大Boss：如何架构低代码的引擎？</span></a></li><li><a href="/blog/说透低代码/03.核心功能开发/02"><span>07｜结构化代码生成法：代码如何生成代码？</span></a></li><li><a aria-current="page" class="active" href="/blog/说透低代码/03.核心功能开发/03"><span>08｜布局编辑器：如何做到鱼和熊掌兼得？</span></a></li><li><a href="/blog/说透低代码/03.核心功能开发/04"><span>09｜属性编辑器：如何解除Web组件属性与编辑器的耦合？</span></a></li><li><a href="/blog/说透低代码/03.核心功能开发/05"><span>10 | 可视化编程：如何有效降低App前后端逻辑开发的技能门槛？</span></a></li><li><a href="/blog/说透低代码/03.核心功能开发/06"><span>11｜亦敌亦友：Low Code与Pro Code混合使用怎样实现？</span></a></li><li><a href="/blog/说透低代码/03.核心功能开发/07"><span>12 | 业务数据：再好的App，没有数据也是白搭</span></a></li><li><a href="/blog/说透低代码/03.核心功能开发/08"><span>13｜多人协同编辑：野百合的春天为啥来得这么晚？</span></a></li><li><a href="/blog/说透低代码/03.核心功能开发/09"><span>14｜编辑历史：是对Git做改造，还是另辟蹊径？</span></a></li></ul></li><li><a href="/blog/说透低代码/04.平台功能拓展">04.平台功能拓展</a><ul><li><a href="/blog/说透低代码/04.平台功能拓展/01"><span>15｜低代码平台应该优先覆盖应用研发生命周期中的哪些功能？</span></a></li><li><a href="/blog/说透低代码/04.平台功能拓展/02"><span>16｜扩展与定制：如何实现插件系统并形成生态圈？</span></a></li></ul></li><li><a href="/blog/说透低代码/05.阶段性总结">05.阶段性总结</a><ul><li><a href="/blog/说透低代码/05.阶段性总结/01"><span>阶段测试｜这些低代码的知识，你都掌握了吗？</span></a></li><li><a href="/blog/说透低代码/05.阶段性总结/02"><span>总结与展望｜低代码之路，我们才刚刚开始</span></a></li></ul></li><li><a href="/blog/说透低代码/summary">说透低代码</a></li></ul></div></div><ul role="slug-list" class="__dumi-default-layout-toc"><li title="鱼和熊掌" data-depth="2"><a href="/blog/说透低代码/03.核心功能开发/03#鱼和熊掌"><span>鱼和熊掌</span></a></li><li title="我都要" data-depth="2"><a href="/blog/说透低代码/03.核心功能开发/03#我都要"><span>我都要</span></a></li><li title="各种布局器" data-depth="2"><a href="/blog/说透低代码/03.核心功能开发/03#各种布局器"><span>各种布局器</span></a></li><li title="小结" data-depth="2"><a href="/blog/说透低代码/03.核心功能开发/03#小结"><span>小结</span></a></li><li title="思考题" data-depth="2"><a href="/blog/说透低代码/03.核心功能开发/03#思考题"><span>思考题</span></a></li></ul><div class="__dumi-default-layout-content"><div class="markdown"><h1 id="08布局编辑器如何做到鱼和熊掌兼得"><a aria-hidden="true" tabindex="-1" href="/blog/说透低代码/03.核心功能开发/03#08布局编辑器如何做到鱼和熊掌兼得"><span class="icon icon-link"></span></a>08｜布局编辑器：如何做到鱼和熊掌兼得？</h1><p>你好，我是陈旭。</p><p>从这一节课开始，我们正式学习App开发三部曲相关的内容，这三部曲分别是布局、交互和数据。这是App开发过程的三个主要步骤，也是业务团队开发App的三个主要工作内容。在时序上，这三个步骤并非顺序执行，而是交织进行的。但布局多数出现在App生命周期的早中期，交互和数据则集中在中晚期。</p><p>所以今天我就先来说说三部曲中的布局篇。顾名思义，布局就是按照UX设计稿或需求说明书里的草图，把需要的组件逐个放到界面上，并按照要求排列整齐，形成App雏形的过程。</p><p>Pro Code开发模式下的布局过程是极抽象的过程，开发人员需要把形象化的UX设计稿转换为一行行抽象的指令，同时在脑海里想象这些指令的渲染效果。而在低代码模式下，布局过程是非常形象的过程。我们可以利用低代码编辑器的布局器，通过画布上的拖拉拽，可视化地完成这一过程。而且，由于新手初次尝试低代码开发所做的事儿就是布局，所以拖拉拽往往成了大家对低代码模式的第一印象。</p><p>显然，布局过程非常机械，低代码平台应该有能力自动化这个过程。所以，在专栏的最后一讲里，我会给你简单介绍实现一个D2C（Design to Code）的思路，实现低代码平台的自动化布局。</p><p>先别急着去翻最后一讲（当然现在还没更）！D2C再牛再酷，也只是辅助手段，从设计稿里自动识别出来的App布局，也需要微调，如果后面业务需求更新了，还需要手工维护布局。因此D2C并不能替代今天这讲的内容，请耐心学习这一讲。</p><h2 id="鱼和熊掌"><a aria-hidden="true" tabindex="-1" href="/blog/说透低代码/03.核心功能开发/03#鱼和熊掌"><span class="icon icon-link"></span></a>鱼和熊掌</h2><p>首先，我们要明确，<strong>不同类型的业务场景下的布局器会有很大差别</strong>。</p><p>比如，表单场景总体上是以行为单位，自上而下布局。而且一行之中同时包含多个元素：标签、编辑器、附加说明、出错提示，等等。基于这样的特点，我们可以设计出类似下面这样的布局器：</p><p><img src="https://static001.geekbang.org/resource/image/2f/30/2f1a5d173425aedba5409904c14bd830.gif?wh=1062x635" alt=""/></p><p>这样的布局器针对表单场景来说，无疑是高效、易用的。但如果我们要用这个方式来布局一个Dashboard类App，不仅毫无效率和易用可言，甚至连能否做到，都要打一个疑问号。因为，一个比较好的Dashboard场景布局器，应该是基于卡片的，要方便对大块的区域进行切分，从而快速获得尺寸合适的卡片，也要能方便地将小片区域融合成更大的卡片。</p><p>从前面举的两个例子可以看出，不同类型的业务场景的布局器确实会有很大差别。那么，有没有一种布局器能同时用于布局表单和Dashboard场景呢？</p><p>**有！基于绝对坐标的布局器就能胜任。**这种布局器很容易就能实现通过拖动来改变物体位置和尺寸的功能，比如下面这样的效果：</p><p><img src="https://static001.geekbang.org/resource/image/52/db/52bcf5217deea737776e3c0cd3959edb.gif?wh=436x297" alt=""/></p><p>不过，这里要注意的是，布局器是基于绝对坐标实现的，但这并不意味着App在运行时无法获得具有弹性尺寸的页面。你可以先思考一下，我们后面就会给出解决思路。</p><p>好，现在问题来了。既然网格布局器（布局器背景有网格线辅助对齐，由此得名）可以同时实现表单和Dashboard，那我们是否只实现网格布局器就好了呢？</p><p>当然不是。我们在关注功能的同时，还需要同时关注另一个维度：<strong>效率</strong>。我们可以很明显地看出来，基于行的布局方式开发表单的效率要远高于网格布局器，同理，基于卡片的布局方式来开发Dashboard的效率也远高于网格布局器。从这个角度看过去，网格布局器毫无优势。</p><p>好了，我们现在可以总结一下这部分了。效率和通用是两个相互制约的维度，无法同时获得，两者的关系可以定性地用下图来体现：</p><p><img src="https://static001.geekbang.org/resource/image/34/44/34ec65a45d4884c85ae0c23af7c59744.png?wh=612x428" alt="图片" title="鱼和熊掌不可兼得"/></p><p>而且，效率和通用性不仅会在不同场景下相互制约，即使在同一个场景下，它们也会相互制约。我们拿Dashboard来举例，布局之初，页面有大片的空白区域，基于卡片的布局器可以快速地将空白区域切分为多个小卡片。</p><p>你可以看看下图，红线示意了卡片的切分过程，我们可以非常迅速地实现下面布局：</p><p><img src="https://static001.geekbang.org/resource/image/9f/11/9f6da4c35b4f1dde1a5e64406f218611.png?wh=958x532" alt="图片"/></p><p>但如何在一个卡片内进行精细布局呢？如果继续采用切分的方式是否依然高效呢？</p><p>显然不是的。你看下上面这张图，随着布局越来越精细，一次操作可以影响到的界面面积越来越小。比如对一个卡片内部进行精细布局所需的操作次数，与对页面整体进行布局所需的次数可能还要更多。也就是说，对卡片内部的布局操作而言，相同布局操作的性价比就非常低了。</p><p>现在请你把目光聚焦在左下角那3个环形图上。对于这个区域，采用相同布局方式继续切分当然是可以做到的，但是效率并不高。下面这张图上，我把这个区域所需的布局操作用黄色线画出来了。你可以数一数，一共需要9次操作才能完成对这个小区域的布局，而在前面的图中，我们布局整个页面也才花了8次操作。</p><p><img src="https://static001.geekbang.org/resource/image/fd/ef/fded872cdb333c5aae610d94ff095cef.png?wh=647x443" alt="图片"/></p><p>此时，如果我们换成网格布局或类似自由式布局方式，是否效率会更高一些呢？效率会更高，借助网格布局的快速对齐和空间自动分布工具，我们可以更快地完成这个布局。</p><p>因此，效率和通用性不仅在不同场景下有相互约束，在同一个场景的不同阶段，也有相互约束。那么面对二者选其一，我们是要效率，还是要通用性呢？</p><h2 id="我都要"><a aria-hidden="true" tabindex="-1" href="/blog/说透低代码/03.核心功能开发/03#我都要"><span class="icon icon-link"></span></a>我都要</h2><p>有道是：只有小孩子才做选择，成年人当然是全都要。如何做到效率和通用全都要呢？这就是我们这部分要解决的主要问题。</p><p>根据前面的分析，我们得到了这样的结论：<strong>靠单一的布局器是无法同时获得效率和通用能力的</strong>。所以，我们很容易想到可以采用<strong>组合</strong>的方式，兼顾高效率和通用能力。</p><p>现在，我们继续以前面那个垃圾分类页面为例讨论一下。我们已经知道，卡片布局器和网格布局器都具有很好的通用性。但在布局初始阶段，显然采用卡片的方式效率高，而在布局的后期，使用网格布局器进行精细化布局的效率更高。那么，我们将这两种布局方式组合使用，就可以得到一个既高效又通用的布局器了。下面这张图就描述了这样的过程：</p><p><img src="https://static001.geekbang.org/resource/image/83/d6/83b6328068efca95454167dc8efcbdd6.png?wh=1534x888" alt="图片"/></p><p><strong>现在，问题就简化成了如何实现多种布局器自由组合使用了。</strong></p><p>为了更好地介绍具体的实现方法，我需要带你简要回顾一下<a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/498769">第6讲《踏出新手村便遭遇大Boss：如何架构低代码的引擎？》<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>中的相关内容。在第6讲中，我将代码生成器与编辑器之间的关系分成了4个Level，其中Level 3架构下，编辑器和代码生成器之间的关系变成了下面这样：</p><p><img src="https://static001.geekbang.org/resource/image/11/60/117ac0b9d6d21a9ffa9ea93806aafe60.jpg?wh=1871x996" alt=""/></p><p>这个阶段，代码生成器与编辑器之间没有直接耦合。它俩各自与编译器协议产生耦合，布局器是编辑器的一部分。在这个架构下，只要各种布局器能严格遵守编译器协议来实现，那代码生成器就可以识别各个布局器的布局输出。</p><p>简单地说，无论布局器之间有多大差异，只要<strong>遵守同一套编译器协议</strong>，它们就可以玩到一块去，从而实现自由组合。此时的架构图可以细化成下面这个样子：</p><p><img src="https://static001.geekbang.org/resource/image/c4/a0/c464eb3c9f3928cfebac192fee7342a0.jpg?wh=1620x1035" alt="图片"/></p><p>得益于编译器协议这层抽象，编辑器可以根据需要实现多种截然不同的布局器。并且，由于各个布局器都可以直接与代码生成器对接，所以从代码生成的角度来看，各个布局器之间已经是可以自由组合的了。这就好比是一片竹林，从地面上看有许许多多独立竹子，但他们的根是相同的。布局器就是地表一棵棵竹子，编译器协议就是它们的根。</p><p>相反地，如果你并未事先理清楚代码生成器与编辑器之间的关系，没有保持两者之间足够充分的松耦合关系，那此时此刻，你要做到任意布局器输出的数据都能和代码生成器无缝对接，就没那么容易了。</p><p>那这要怎么解决呢？一种原始做法是在代码生成器中采用if-else形式来处理不同布局器的差异。这当然是能走得通的，但问题是每多出一种布局器，判断的情况就会翻倍（指数增长），用不了三五种布局器，判断条件数量就将大到无法继续。相信我，这个过程将会相当痛苦。</p><p>现在，问题就进一步简化成了<strong>如何在编辑器的UI上实现各种布局器的相互嵌套使用的问题</strong>了。这样的问题，基本已经可以直接交给UX交互设计师和普通开发去处理了。实现方式也不止一种，这里我简要介绍一下我使用的方法，你可以参考一下。</p><p>我将布局器包装成了一种容器。容器也是一种组件，它具有组件的任何特性，但具备一个普通组件没有的能力：它能装得下其他组件或容器。容器支持相互嵌套的方式简直与布局器是天生一对。</p><p>最后，我们再以前面那个垃圾分类页面的布局过程做为例子，讨论一下多种布局器的配合使用过程。</p><p>首先上场的一般是卡片布局器，它可以快速地将页面横竖切分为多个卡片。在布局某个卡片内容时，开发人员可以根据卡片内容特征选择一种他认为更高效的方式来完成。他可以选择继续用卡片切分，也可以选择拖入一个网格布局器。</p><p>如果拖入了网格布局器，这个卡片的内容就变成了网格布局方式，可以发挥网格布局的优势实现高效精细化布局。同样地，如果该卡片的内容与表单更接近，他可以拖入一个表单容器，采用表单的方式进行布局。</p><p>可以看到，按页面特征挑选合适布局方式进行布局，可以发挥各种布局器的优势，又有效避免了它们的缺点，实现全程高效布局。鱼和熊掌你可以都要。</p><h2 id="各种布局器"><a aria-hidden="true" tabindex="-1" href="/blog/说透低代码/03.核心功能开发/03#各种布局器"><span class="icon icon-link"></span></a>各种布局器</h2><p>那现在，我们再来看看这几种常用的布局器特点、适用场景，以及关键实现思路。不过这里，我们先不深入介绍他们的实现细节，有机会我会再补充一下这方面的内容。</p><p>首先是<strong>网格布局器</strong>。</p><p>将网格布局器放第一个介绍，是因为它是我第一个做出来的布局器。第一个实现它是有原因的，因为它最主要特征就是通用。在不考虑效率的前提下，它可以在页面布局的各个阶段中用到，所以把它做出来之后，我们就可以一把搞定低代码编辑器的布局能力，非常划算。我推荐你也优先实现它。</p><p>在编辑态下，网格布局器采用绝对坐标来定位各个组件，所以非常容易实现鼠标点选、框选、拖动位置、拖动尺寸等基本编辑过程。当然，绝对坐标过于自由和精细，会导致很难实现画布上多组件的对齐，这点我们可以通过类似PPT那样的磁力线自动吸附来辅助解决。</p><p>虽然磁力线自动吸附很酷，但这不是最优解！主要有两方面原因：一是工作量，实际上这个功能还挺难实现的；但这不是关键，第二点才是关键否决票，UX规范对组件间留白有严格规定，UX小姑娘让你留8px，你就不能留7px或者9px。你想靠鼠标拖动来做到刚刚好8px？别开玩笑了。为了解决这个问题，我们就需要开发出更加复杂的磁力线。</p><p>那最优解是啥呢？很简单，固定拖动步长。那么固定多少合适呢？我的选择是8px。注意：一定一定要和UX团队取得一致意见，<strong>要求设计稿中，任何两个组件间的距离和尺寸必须是8px的整数倍</strong>。</p><p>其实，8px不是协商来的，而是对已有设计稿分析后得出的，UX团队也认为以8px做为基本单位约束所有UI是非常合适的。所以我们在画布上拖动组件位置和尺寸时，并不是丝滑的，而是以8px为单位一跳一跳的。这样做就省去了开发磁力线的麻烦，又可以很容易达成UX规范所需的留白要求，一举两得。</p><p>比如下图中的网格，就是8×8px的，网格布局器也由此得名：</p><p><img src="https://static001.geekbang.org/resource/image/52/db/52bcf5217deea737776e3c0cd3959edb.gif?wh=436x297" alt=""/></p><p>那是不是网格布局器只能生成绝对坐标的页面呢？</p><p>显然不是的。这里就涉及到一个复杂的分组算法。我们简要介绍一下，这个算法是根据平铺在画布上的各个组件的位置，对它们进行适当分组，同时对分出的各个组再进行相似的操作，直到无法再继续分组为止。这个时候我们就可以得到一颗有层级关系的树，之后我们再采用Flex布局就可以实现弹性了。如果要说清楚这个算法的实现，一讲内容可能都不够，所以我们只能留到以后再找机会补上了。</p><p>接下来是<strong>卡片布局器</strong>。</p><p>CSS的盒子模型把二维UI做了极致的抽象。在CSS中， 整个二维世界都是盒子组成的。无疑，这个抽象是成功的，但代价却是难用。</p><p>我在盒子模型的基础上做了一点点扩充，把盒子分成两种，一种是水平盒子，一种是垂直盒子：</p><p><img src="https://static001.geekbang.org/resource/image/1f/66/1f6c30fced6a745bc7971e2612e7b466.png?wh=1086x650" alt="" title="左边是水平盒子，右边是垂直盒子"/></p><p>布局规则极简单：水平盒子会将它的直接子级按照水平排列，垂直盒子则将其直接子级垂直排列。关键点是，水平和垂直盒子支持任意层级的自由组合。这样做后，不可思议的事情就这样发生了，两个极简单的盒子通过自由组合，居然可以产生无限种可能，从而可以用它们来描述整个二维UI。</p><p>这里我们还是以前面垃圾分类页面来举例。我们先看下面的动画：</p><p><img src="https://static001.geekbang.org/resource/image/e3/1d/e31958c253889da013d915aba2a2521d.gif?wh=1012x571" alt="图片"/></p><p>我们来数一数这个界面包含了哪些盒子：</p><ol><li>土色部分是一个垂直盒子，只有1个；</li><li>中间蓝色部分是水平盒子，有两个；</li><li>最里头红色部分是垂直盒子，有好多。</li></ol><p>是不是很简单？</p><p>这个盒子布局的<a target="_blank" rel="noopener noreferrer" href="https://github.com/rdkmaster/jigsaw/tree/master/src/jigsaw/pc-components/box">全部代码<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>，都随着我们的低代码<a target="_blank" rel="noopener noreferrer" href="https://github.com/rdkmaster/jigsaw">可视化组件集Jigsaw<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>一起开源在GitHub上了，如果你有兴趣的话，可以打开这里看看它的<a target="_blank" rel="noopener noreferrer" href="https://jigsaw-zte.gitee.io/latest/#/components/box/demo/middle-resize-line">其他demo<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>。这里有两个box实现，一个是用于运行时的<a target="_blank" rel="noopener noreferrer" href="https://github.com/rdkmaster/jigsaw/blob/master/src/jigsaw/pc-components/box/box.ts">轻量化box<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>，一个是用于<a target="_blank" rel="noopener noreferrer" href="https://github.com/rdkmaster/jigsaw/blob/master/src/jigsaw/pc-components/box/editable-box.ts">编辑时的box<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>，二者的实现差异非常大。</p><blockquote><p>帮忙点个星星哟！</p></blockquote><p>然后是<strong>表单布局器</strong>。</p><p>我在<a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/497779">第5讲《基础设施 ：启动低代码平台研发之前，你需要有什么家底？》<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>中将市面上的组件集的封装方式归为3类，分别是数据驱动型、模板驱动型、以及CSS样式模板。</p><p>如果要将表单封装成一个组件，那显然采用模板驱动方式封装会更合适。因为表单对UI定制的需求巨大，非常难以按照数据驱动的方式来封装。但在那一讲中我也说了，数据驱动型的组件更适合用在低代码平台上。</p><p>这对矛盾如何解决呢？难道我们硬着头皮按照数据驱动方式来封装表单吗？</p><p>不需要，开源社区里已经有优秀的解决方案了。我这里给你两个推荐方案。首先，我在用的是<a target="_blank" rel="noopener noreferrer" href="https://formly.dev/">ngx-formly<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>，这是一个非常强大的数据驱动型实现，能满足我99%的需要（扣1分是因为它在复杂异步校验方面并不完美）。如果你恰好采用的是Angular技术栈，那么可以选它。Jigsaw对应ngx-formly表单控件封装，我们也<a target="_blank" rel="noopener noreferrer" href="https://github.com/rdkmaster/jigsaw/tree/master/src/ngx-formly/jigsaw">开源<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>了，你可以看看。</p><p>另一个推荐的数据驱动表单的实现是阿里的<a target="_blank" rel="noopener noreferrer" href="https://formilyjs.org/">Formily<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>，支持React和Vue，也是非常优秀的一个作品。</p><p>有了数据驱动型的表单的帮助，低代码编辑器只要采用可视化的方式生成一个复杂的数据对象，然后将这个数据对象喂给表单组件，就可以渲染出表单视图了。甚至，<a target="_blank" rel="noopener noreferrer" href="https://formilyjs.org/">Formily<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>还提供了可视化生成数据对象的<a target="_blank" rel="noopener noreferrer" href="https://designable-antd.formilyjs.org/">设计器<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>，你也可以考虑直接将它集成到你的低代码平台上，节约更多工作。</p><p>最后是<strong>流程编排器</strong></p><p>这种布局器是特定场景下专用的，通用性不高，但和表单相似，在适用的场合下，会大幅提升布局效率。我主要将它用于流程审批类App的布局，简单地说就是开发一些流程审批类的App时，直接用它当做顶层布局器，然后各个流程环节配合使用表单等其他布局器，可以实现非常高效率的App开发效果。</p><p>同时，我们还可以将它用于数据编排场景（这不是App）。服务端给的数据不见得都是合适前端使用的，多数情况下都需要做一定的编排组合、结构转换后才能给前端组件使用，这个过程就需要用到数据编排了。数据编排过程和流程编排非常相似。我在第11讲《业务数据：巧妇难为无米之炊，再好的App没有数据也是白搭》中会对这个过程有专门介绍。</p><p>具体实现方面，同样地，我并未自行实现编排功能，而是集成了社区里的开源软件<a target="_blank" rel="noopener noreferrer" href="https://x6.antv.vision/zh">X6<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>，你可以参考一下。</p><h2 id="小结"><a aria-hidden="true" tabindex="-1" href="/blog/说透低代码/03.核心功能开发/03#小结"><span class="icon icon-link"></span></a>小结</h2><p>今天我详细介绍了App开发三部曲中的布局篇。我们知道，不同类型的App，布局方式迥异，即使相同的App在不同开发阶段也有不同的布局需求。我认为布局器最主要需要满足两方面的诉求，一是通用性，二是效率。通用性是我们在低代码编辑器研发早期主要关注的维度，随着低代码编辑器越发成熟，对效率的追求就逐渐超越了对通用性的追求。</p><p>得益于低代码编辑器早期充分发展了通用能力，因此在它成熟之后，我们就可以把效率作为唯一的追求，将效率发挥到极致。为了做到这一点，我们甚至需要关注不同布局方式在同一个App的不同开发阶段下的效率表现，通过组合的方式来发挥不同编辑器的最大效率，并规避各自的短板。从而得到鱼和熊掌兼得的效果。</p><p>这一讲中，我还给你介绍了网格、卡片、表单、编排等4种布局器的特征和实现要点，同时也介绍了相关的开源资源。多种布局方式需要相互组合才能发挥各自地最大效用，我建议你将各个布局器当做容器来实现。容器天然具有多层级相互嵌套的特性，这使得各个布局器可以自由组合使用，应用团队可以按需、按App特征挑选合适的布局器来实现快速布局。</p><h2 id="思考题"><a aria-hidden="true" tabindex="-1" href="/blog/说透低代码/03.核心功能开发/03#思考题"><span class="icon icon-link"></span></a>思考题</h2><p>在你的场景中，网格、卡片、表单、编排哪种布局器的需求是最大的？除了这4中布局器之外，你还需要哪些布局器？</p><p>欢迎在评论区留言。我是陈旭，我们下一讲再见。</p></div><div class="__dumi-default-layout-footer-meta"><a target="_blank" rel="noopener noreferrer" href="https://github.com/GGwujun/blog/edit/master/docs/说透低代码/03.核心功能开发/03.md">在 GitHub 上编辑此页<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a><span data-updated-text="最后更新时间：">5/2/2022 10:56:41</span></div></div></div></div>
	<script>
  window.g_useSSR = true;
  window.g_initialProps = {};
	</script>

    <script>
      (function () {
        if (!location.port) {
          (function (i, s, o, g, r, a, m) {
            i["GoogleAnalyticsObject"] = r;
            (i[r] =
              i[r] ||
              function () {
                (i[r].q = i[r].q || []).push(arguments);
              }),
              (i[r].l = 1 * new Date());
            (a = s.createElement(o)), (m = s.getElementsByTagName(o)[0]);
            a.async = 1;
            a.src = g;
            m.parentNode.insertBefore(a, m);
          })(
            window,
            document,
            "script",
            "//www.google-analytics.com/analytics.js",
            "ga"
          );
          ga("create", "UA-149864185-1", "auto");
          ga("send", "pageview");
        }
      })();
    </script>
    <script src="/blog/umi.js"></script>
  </body>
</html>
