<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no"
    />
    <link rel="shortcut icon" type="image/x-icon" href="/logo.png" />
    <link rel="stylesheet" href="/blog/umi.css" />
    <script>
      window.routerBase = "/blog";
    </script>
    <script>
      //! umi version: 3.5.17
    </script>
    <script>
      !(function () {
        var e = localStorage.getItem("dumi:prefers-color"),
          t = window.matchMedia("(prefers-color-scheme: dark)").matches,
          r = ["light", "dark", "auto"];
        document.documentElement.setAttribute(
          "data-prefers-color",
          e === r[2] ? (t ? r[1] : r[0]) : r.indexOf(e) > -1 ? e : r[0]
        );
      })();
    </script>
    <title>04 | GPU与渲染管线：如何用WebGL绘制最简单的几何图形？</title>
  </head>
  <body>
    <div id="root"><div class="__dumi-default-layout" data-route="/跟月影学可视化/02.图形基础篇/04" data-show-sidemenu="true" data-show-slugs="true" data-site-mode="true" data-gapless="false"><div class="__dumi-default-navbar" data-mode="site"><button class="__dumi-default-navbar-toggle"></button><a class="__dumi-default-navbar-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog/">大师兄</a><nav><div class="__dumi-default-search"><input type="search" class="__dumi-default-search-input" value=""/><ul></ul></div><span>计算机基础<ul><li><a href="/blog/编译原理之美">编译原理之美</a></li><li><a href="/blog/编译原理实战">编译原理实战</a></li><li><a href="/blog/深入浅出计算机组成原理">深入浅出计算机组成原理</a></li><li><a href="/blog/详解http">详解http</a></li><li><a href="/blog/计算机网络通关29讲">计算机网络通关29讲</a></li><li><a href="/blog/网络排查案例课">网络排查案例课</a></li><li><a href="/blog/linux操作系统">linux操作系统</a></li><li><a href="/blog/linux性能优化实战">linux性能优化实战</a></li><li><a href="/blog/程序员数学基础">程序员数学基础</a></li><li><a href="/blog/趣谈网络协议">趣谈网络协议</a></li><li><a href="/blog/操作系统实战">操作系统实战</a></li><li><a href="/blog/软件工程之美">软件工程之美</a></li><li><a href="/blog/sql必知必会">sql必知必会</a></li><li><a href="/blog/操作系统实战45讲">操作系统实战45讲</a></li><li><a href="/blog/网络编程实战">网络编程实战</a></li></ul></span><span>算法<ul><li><a href="/blog/常用算法25讲">常用算法25讲</a></li><li><a href="/blog/数据结构与算法之美">数据结构与算法之美</a></li><li><a href="/blog/业务开发算法50讲">业务开发算法50讲</a></li><li><a href="/blog/动态规划面试宝典">动态规划面试宝典</a></li></ul></span><span>前端开发<ul><li><a href="/blog/浏览器工作原理与实践">浏览器工作原理与实践</a></li><li><a href="/blog/新时代产品经理进阶之路">新时代产品经理进阶之路</a></li><li><a href="/blog/全栈工程师修炼指南">全栈工程师修炼指南</a></li><li><a href="/blog/flutter核心技术与实战">flutter核心技术与实战</a></li><li><a href="/blog/java-script核心原理解析">java-script核心原理解析</a></li><li><a href="/blog/说透低代码">说透低代码</a></li><li><a href="/blog/nodejs应用开发实战">nodejs应用开发实战</a></li><li><a href="/blog/反爬虫兵法演绎20讲">反爬虫兵法演绎20讲</a></li><li><a href="/blog/reactnative新架构实战课">reactnative新架构实战课</a></li><li><a href="/blog/正则表达式入门">正则表达式入门</a></li><li><a href="/blog/重学前端">重学前端</a></li><li><a href="/blog/serverless入门课">serverless入门课</a></li><li><a href="/blog/type-script入门实战笔记">type-script入门实战笔记</a></li><li><a href="/blog/图解googlev8">图解googlev8</a></li><li><a href="/blog/vue3源码分析">vue3源码分析</a></li><li><a href="/blog/玩转Vue3全家桶">玩转Vue3全家桶</a></li><li><a href="/blog/webassembly入门">webassembly入门</a></li><li><a href="/blog/手把手带你写一个Web框架">手把手带你写一个Web框架</a></li><li><a href="/blog/web漏洞挖掘实战">web漏洞挖掘实战</a></li><li><a aria-current="page" class="active" href="/blog/跟月影学可视化">跟月影学可视化</a></li><li><a href="/blog/搞定音频技术">搞定音频技术</a></li><li><a href="/blog/攻克视频技术">攻克视频技术</a></li></ul></span><span>前端工程化<ul><li><a href="/blog/logger">logger</a></li><li><a href="/blog/webpack">webpack</a></li><li><a href="/blog/webpackChain">webpackChain</a></li></ul></span><span>前端性能优化<ul><li><a href="/blog/react性能调优">react性能调优</a></li></ul></span><span>软件测试<ul><li><a href="/blog/全链路压测实战30讲">全链路压测实战30讲</a></li><li><a href="/blog/性能测试实战30讲">性能测试实战30讲</a></li><li><a href="/blog/自动化测试高手课">自动化测试高手课</a></li><li><a href="/blog/软件测试52讲">软件测试52讲</a></li></ul></span><span>面试<ul><li><a href="/blog/面试现场">面试现场</a></li></ul></span><span>杂谈<ul><li><a href="/blog/超级访谈对话张雪峰">超级访谈对话张雪峰</a></li><li><a href="/blog/Git实战手册">Git实战手册</a></li><li><a href="/blog/NodeJS">NodeJS</a></li><li><a href="/blog/ReactJS">ReactJS</a></li><li><a href="/blog/UI设计">UI设计</a></li><li><a href="/blog/webpack4系列教程">webpack4系列教程</a></li><li><a href="/blog/前端知识体系">前端知识体系</a></li><li><a href="/blog/剑指offer刷题笔记">剑指offer刷题笔记</a></li><li><a href="/blog/思考与成长">思考与成长</a></li><li><a href="/blog/设计模式手册">设计模式手册</a></li></ul></span><div class="__dumi-default-navbar-tool"><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "></div></div></div></nav></div><div class="__dumi-default-menu" data-mode="site"><div class="__dumi-default-menu-inner"><div class="__dumi-default-menu-header"><a class="__dumi-default-menu-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog/"></a><h1>大师兄</h1><p></p></div><div class="__dumi-default-menu-mobile-area"><ul class="__dumi-default-menu-nav-list"><li>计算机基础<ul><li><a href="/blog/编译原理之美">编译原理之美</a></li><li><a href="/blog/编译原理实战">编译原理实战</a></li><li><a href="/blog/深入浅出计算机组成原理">深入浅出计算机组成原理</a></li><li><a href="/blog/详解http">详解http</a></li><li><a href="/blog/计算机网络通关29讲">计算机网络通关29讲</a></li><li><a href="/blog/网络排查案例课">网络排查案例课</a></li><li><a href="/blog/linux操作系统">linux操作系统</a></li><li><a href="/blog/linux性能优化实战">linux性能优化实战</a></li><li><a href="/blog/程序员数学基础">程序员数学基础</a></li><li><a href="/blog/趣谈网络协议">趣谈网络协议</a></li><li><a href="/blog/操作系统实战">操作系统实战</a></li><li><a href="/blog/软件工程之美">软件工程之美</a></li><li><a href="/blog/sql必知必会">sql必知必会</a></li><li><a href="/blog/操作系统实战45讲">操作系统实战45讲</a></li><li><a href="/blog/网络编程实战">网络编程实战</a></li></ul></li><li>算法<ul><li><a href="/blog/常用算法25讲">常用算法25讲</a></li><li><a href="/blog/数据结构与算法之美">数据结构与算法之美</a></li><li><a href="/blog/业务开发算法50讲">业务开发算法50讲</a></li><li><a href="/blog/动态规划面试宝典">动态规划面试宝典</a></li></ul></li><li>前端开发<ul><li><a href="/blog/浏览器工作原理与实践">浏览器工作原理与实践</a></li><li><a href="/blog/新时代产品经理进阶之路">新时代产品经理进阶之路</a></li><li><a href="/blog/全栈工程师修炼指南">全栈工程师修炼指南</a></li><li><a href="/blog/flutter核心技术与实战">flutter核心技术与实战</a></li><li><a href="/blog/java-script核心原理解析">java-script核心原理解析</a></li><li><a href="/blog/说透低代码">说透低代码</a></li><li><a href="/blog/nodejs应用开发实战">nodejs应用开发实战</a></li><li><a href="/blog/反爬虫兵法演绎20讲">反爬虫兵法演绎20讲</a></li><li><a href="/blog/reactnative新架构实战课">reactnative新架构实战课</a></li><li><a href="/blog/正则表达式入门">正则表达式入门</a></li><li><a href="/blog/重学前端">重学前端</a></li><li><a href="/blog/serverless入门课">serverless入门课</a></li><li><a href="/blog/type-script入门实战笔记">type-script入门实战笔记</a></li><li><a href="/blog/图解googlev8">图解googlev8</a></li><li><a href="/blog/vue3源码分析">vue3源码分析</a></li><li><a href="/blog/玩转Vue3全家桶">玩转Vue3全家桶</a></li><li><a href="/blog/webassembly入门">webassembly入门</a></li><li><a href="/blog/手把手带你写一个Web框架">手把手带你写一个Web框架</a></li><li><a href="/blog/web漏洞挖掘实战">web漏洞挖掘实战</a></li><li><a aria-current="page" class="active" href="/blog/跟月影学可视化">跟月影学可视化</a></li><li><a href="/blog/搞定音频技术">搞定音频技术</a></li><li><a href="/blog/攻克视频技术">攻克视频技术</a></li></ul></li><li>前端工程化<ul><li><a href="/blog/logger">logger</a></li><li><a href="/blog/webpack">webpack</a></li><li><a href="/blog/webpackChain">webpackChain</a></li></ul></li><li>前端性能优化<ul><li><a href="/blog/react性能调优">react性能调优</a></li></ul></li><li>软件测试<ul><li><a href="/blog/全链路压测实战30讲">全链路压测实战30讲</a></li><li><a href="/blog/性能测试实战30讲">性能测试实战30讲</a></li><li><a href="/blog/自动化测试高手课">自动化测试高手课</a></li><li><a href="/blog/软件测试52讲">软件测试52讲</a></li></ul></li><li>面试<ul><li><a href="/blog/面试现场">面试现场</a></li></ul></li><li>杂谈<ul><li><a href="/blog/超级访谈对话张雪峰">超级访谈对话张雪峰</a></li><li><a href="/blog/Git实战手册">Git实战手册</a></li><li><a href="/blog/NodeJS">NodeJS</a></li><li><a href="/blog/ReactJS">ReactJS</a></li><li><a href="/blog/UI设计">UI设计</a></li><li><a href="/blog/webpack4系列教程">webpack4系列教程</a></li><li><a href="/blog/前端知识体系">前端知识体系</a></li><li><a href="/blog/剑指offer刷题笔记">剑指offer刷题笔记</a></li><li><a href="/blog/思考与成长">思考与成长</a></li><li><a href="/blog/设计模式手册">设计模式手册</a></li></ul></li></ul><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "><button title="Dark theme" class="__dumi-default-dark-moon "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="3854" width="22" height="22"><path d="M991.816611 674.909091a69.166545 69.166545 0 0 0-51.665455-23.272727 70.795636 70.795636 0 0 0-27.438545 5.585454A415.674182 415.674182 0 0 1 754.993338 698.181818c-209.594182 0-393.472-184.785455-393.472-395.636363 0-52.363636 38.539636-119.621818 69.515637-173.614546 4.887273-8.610909 9.634909-16.756364 14.103272-24.901818A69.818182 69.818182 0 0 0 384.631156 0a70.842182 70.842182 0 0 0-27.438545 5.585455C161.678429 90.298182 14.362065 307.898182 14.362065 512c0 282.298182 238.824727 512 532.38691 512a522.286545 522.286545 0 0 0 453.957818-268.334545A69.818182 69.818182 0 0 0 991.816611 674.909091zM546.679156 954.181818c-248.785455 0-462.941091-192-462.941091-442.181818 0-186.647273 140.637091-372.829091 300.939637-442.181818-36.817455 65.629091-92.578909 151.970909-92.578909 232.727273 0 250.181818 214.109091 465.454545 462.917818 465.454545a488.331636 488.331636 0 0 0 185.181091-46.545455 453.003636 453.003636 0 0 1-393.565091 232.727273z m103.656728-669.323636l-14.266182 83.781818a34.909091 34.909091 0 0 0 50.362182 36.770909l74.775272-39.563636 74.752 39.563636a36.142545 36.142545 0 0 0 16.174546 3.956364 34.909091 34.909091 0 0 0 34.210909-40.727273l-14.289455-83.781818 60.509091-59.345455a35.025455 35.025455 0 0 0-19.223272-59.578182l-83.61891-12.101818-37.376-76.101818a34.56 34.56 0 0 0-62.254545 0l-37.376 76.101818-83.618909 12.101818a34.909091 34.909091 0 0 0-19.246546 59.578182z m70.423272-64.698182a34.280727 34.280727 0 0 0 26.135273-19.083636l14.312727-29.090909 14.336 29.090909a34.257455 34.257455 0 0 0 26.135273 19.083636l32.046546 4.887273-23.272728 22.574545a35.234909 35.234909 0 0 0-10.007272 30.952727l5.46909 32.116364-28.625454-15.127273a34.490182 34.490182 0 0 0-32.302546 0l-28.695272 15.127273 5.469091-32.116364a35.141818 35.141818 0 0 0-9.984-30.952727l-23.272728-22.574545z" p-id="3855"></path></svg></button><button title="Light theme" class="__dumi-default-dark-sun "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="4026" width="22" height="22"><path d="M915.2 476.16h-43.968c-24.704 0-44.736 16-44.736 35.84s20.032 35.904 44.736 35.904H915.2c24.768 0 44.8-16.064 44.8-35.904s-20.032-35.84-44.8-35.84zM512 265.6c-136.704 0-246.464 109.824-246.464 246.4 0 136.704 109.76 246.464 246.464 246.464S758.4 648.704 758.4 512c0-136.576-109.696-246.4-246.4-246.4z m0 425.6c-99.008 0-179.2-80.128-179.2-179.2 0-98.944 80.192-179.2 179.2-179.2S691.2 413.056 691.2 512c0 99.072-80.192 179.2-179.2 179.2zM197.44 512c0-19.84-19.136-35.84-43.904-35.84H108.8c-24.768 0-44.8 16-44.8 35.84s20.032 35.904 44.8 35.904h44.736c24.768 0 43.904-16.064 43.904-35.904zM512 198.464c19.776 0 35.84-20.032 35.84-44.8v-44.8C547.84 84.032 531.84 64 512 64s-35.904 20.032-35.904 44.8v44.8c0 24.768 16.128 44.864 35.904 44.864z m0 627.136c-19.776 0-35.904 20.032-35.904 44.8v44.736C476.096 940.032 492.16 960 512 960s35.84-20.032 35.84-44.8v-44.736c0-24.768-16.064-44.864-35.84-44.864z m329.92-592.832c17.472-17.536 20.288-43.072 6.4-57.024-14.016-14.016-39.488-11.2-57.024 6.336-4.736 4.864-26.496 26.496-31.36 31.36-17.472 17.472-20.288 43.008-6.336 57.024 13.952 14.016 39.488 11.2 57.024-6.336 4.8-4.864 26.496-26.56 31.296-31.36zM213.376 759.936c-4.864 4.8-26.56 26.624-31.36 31.36-17.472 17.472-20.288 42.944-6.4 56.96 14.016 13.952 39.552 11.2 57.024-6.336 4.8-4.736 26.56-26.496 31.36-31.36 17.472-17.472 20.288-43.008 6.336-56.96-14.016-13.952-39.552-11.072-56.96 6.336z m19.328-577.92c-17.536-17.536-43.008-20.352-57.024-6.336-14.08 14.016-11.136 39.488 6.336 57.024 4.864 4.864 26.496 26.56 31.36 31.424 17.536 17.408 43.008 20.288 56.96 6.336 14.016-14.016 11.264-39.488-6.336-57.024-4.736-4.864-26.496-26.56-31.296-31.424z m527.168 628.608c4.864 4.864 26.624 26.624 31.36 31.424 17.536 17.408 43.072 20.224 57.088 6.336 13.952-14.016 11.072-39.552-6.4-57.024-4.864-4.8-26.56-26.496-31.36-31.36-17.472-17.408-43.072-20.288-57.024-6.336-13.952 14.016-11.008 39.488 6.336 56.96z" p-id="4027"></path></svg></button><button title="Default to system" class="__dumi-default-dark-auto "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="11002" width="22" height="22"><path d="M127.658667 492.885333c0-51.882667 10.24-101.717333 30.378666-149.162666s47.786667-88.064 81.92-122.538667 75.093333-61.781333 122.538667-81.92 96.938667-30.378667 149.162667-30.378667 101.717333 10.24 149.162666 30.378667 88.405333 47.786667 122.88 81.92 61.781333 75.093333 81.92 122.538667 30.378667 96.938667 30.378667 149.162666-10.24 101.717333-30.378667 149.162667-47.786667 88.405333-81.92 122.88-75.093333 61.781333-122.88 81.92-97.28 30.378667-149.162666 30.378667-101.717333-10.24-149.162667-30.378667-88.064-47.786667-122.538667-81.92-61.781333-75.093333-81.92-122.88-30.378667-96.938667-30.378666-149.162667z m329.045333 0c0 130.048 13.994667 244.394667 41.984 343.381334h12.970667c46.762667 0 91.136-9.216 133.461333-27.306667s78.848-42.666667 109.568-73.386667 54.954667-67.242667 73.386667-109.568 27.306667-86.698667 27.306666-133.461333c0-46.421333-9.216-90.794667-27.306666-133.12s-42.666667-78.848-73.386667-109.568-67.242667-54.954667-109.568-73.386667-86.698667-27.306667-133.461333-27.306666h-11.605334c-28.672 123.562667-43.349333 237.909333-43.349333 343.722666z" p-id="11003"></path></svg></button></div></div></div><ul class="__dumi-default-menu-list"><li><a href="/blog/跟月影学可视化">跟月影学可视化</a></li><li><a href="/blog/跟月影学可视化/01.课前必学">01.课前必学</a><ul><li><a href="/blog/跟月影学可视化/01.课前必学/01"><span>开篇词 | 不写网页的前端工程师，还能干什么？</span></a></li><li><a href="/blog/跟月影学可视化/01.课前必学/02"><span>预习 | Web前端与可视化到底有什么区别？</span></a></li></ul></li><li><a aria-current="page" class="active" href="/blog/跟月影学可视化/02.图形基础篇">02.图形基础篇</a><ul><li><a href="/blog/跟月影学可视化/02.图形基础篇/01"><span>01 | 浏览器中实现可视化的四种方式</span></a></li><li><a href="/blog/跟月影学可视化/02.图形基础篇/02"><span>02 |  指令式绘图系统：如何用Canvas绘制层次关系图？</span></a></li><li><a href="/blog/跟月影学可视化/02.图形基础篇/03"><span>03 | 声明式图形系统：如何用SVG图形元素绘制可视化图表？</span></a></li><li><a aria-current="page" class="active" href="/blog/跟月影学可视化/02.图形基础篇/04"><span>04 | GPU与渲染管线：如何用WebGL绘制最简单的几何图形？</span></a></li></ul></li><li><a href="/blog/跟月影学可视化/03.数学篇">03.数学篇</a><ul><li><a href="/blog/跟月影学可视化/03.数学篇/01"><span>05 | 如何用向量和坐标系描述点和线段？</span></a></li><li><a href="/blog/跟月影学可视化/03.数学篇/02"><span>06 |  可视化中你必须要掌握的向量乘法知识</span></a></li><li><a href="/blog/跟月影学可视化/03.数学篇/03"><span>07 | 如何用向量和参数方程描述曲线？</span></a></li><li><a href="/blog/跟月影学可视化/03.数学篇/04"><span>08 | 如何利用三角剖分和向量操作描述并处理多边形？</span></a></li><li><a href="/blog/跟月影学可视化/03.数学篇/05"><span>09 | 如何用仿射变换对几何图形进行坐标变换？</span></a></li></ul></li><li><a href="/blog/跟月影学可视化/04.视觉基础篇">04.视觉基础篇</a><ul><li><a href="/blog/跟月影学可视化/04.视觉基础篇/01"><span>10 | 图形系统如何表示颜色？</span></a></li><li><a href="/blog/跟月影学可视化/04.视觉基础篇/02"><span>11｜图案生成：如何生成重复图案、分形图案以及随机效果？</span></a></li><li><a href="/blog/跟月影学可视化/04.视觉基础篇/03"><span>12 | 如何使用滤镜函数实现美颜效果？</span></a></li><li><a href="/blog/跟月影学可视化/04.视觉基础篇/04"><span>13 | 如何给简单的图案添加纹理和复杂滤镜？</span></a></li><li><a href="/blog/跟月影学可视化/04.视觉基础篇/05"><span>14 | 如何使用片元着色器进行几何造型？</span></a></li><li><a href="/blog/跟月影学可视化/04.视觉基础篇/06"><span>15 | 如何用极坐标系绘制有趣图案？</span></a></li><li><a href="/blog/跟月影学可视化/04.视觉基础篇/07"><span>16 | 如何使用噪声生成复杂的纹理？</span></a></li><li><a href="/blog/跟月影学可视化/04.视觉基础篇/08"><span>17 | 如何使用后期处理通道增强图像效果？</span></a></li></ul></li><li><a href="/blog/跟月影学可视化/05.视觉高级篇">05.视觉高级篇</a><ul><li><a href="/blog/跟月影学可视化/05.视觉高级篇/01"><span>18 | 如何生成简单动画让图形动起来？</span></a></li><li><a href="/blog/跟月影学可视化/05.视觉高级篇/02"><span>19 | 如何用着色器实现像素动画？</span></a></li><li><a href="/blog/跟月影学可视化/05.视觉高级篇/03"><span>20 | 如何用WebGL绘制3D物体？</span></a></li><li><a href="/blog/跟月影学可视化/05.视觉高级篇/04"><span>21 | 如何添加相机，用透视原理对物体进行投影？</span></a></li><li><a href="/blog/跟月影学可视化/05.视觉高级篇/05"><span>22 | 如何用仿射变换来移动和旋转3D物体？</span></a></li><li><a href="/blog/跟月影学可视化/05.视觉高级篇/06"><span>23 | 如何模拟光照让3D场景更逼真？（上）</span></a></li><li><a href="/blog/跟月影学可视化/05.视觉高级篇/07"><span>24 |  如何模拟光照让3D场景更逼真？（下）</span></a></li><li><a href="/blog/跟月影学可视化/05.视觉高级篇/08"><span>25 | 如何用法线贴图模拟真实物体表面</span></a></li><li><a href="/blog/跟月影学可视化/05.视觉高级篇/09"><span>26 | 如何绘制带宽度的曲线？</span></a></li><li><a href="/blog/跟月影学可视化/05.视觉高级篇/10"><span>27 | 案例：如何实现简单的3D可视化图表？</span></a></li></ul></li><li><a href="/blog/跟月影学可视化/06.性能篇">06.性能篇</a><ul><li><a href="/blog/跟月影学可视化/06.性能篇/01"><span>28 | Canvas、SVG与WebGL在性能上的优势与劣势</span></a></li><li><a href="/blog/跟月影学可视化/06.性能篇/02"><span>29 | 怎么给Canvas绘制加速？</span></a></li><li><a href="/blog/跟月影学可视化/06.性能篇/03"><span>30｜怎么给WebGL绘制加速？</span></a></li></ul></li><li><a href="/blog/跟月影学可视化/07.数据篇">07.数据篇</a><ul><li><a href="/blog/跟月影学可视化/07.数据篇/01"><span>31 | 针对海量数据，如何优化性能？</span></a></li><li><a href="/blog/跟月影学可视化/07.数据篇/02"><span>32 | 数据之美：如何选择合适的方法对数据进行可视化处理？</span></a></li><li><a href="/blog/跟月影学可视化/07.数据篇/03"><span>33 | 数据处理（一）：可视化数据处理的一般方法是什么？</span></a></li><li><a href="/blog/跟月影学可视化/07.数据篇/04"><span>34 | 数据处理（二）：如何处理多元变量？</span></a></li><li><a href="/blog/跟月影学可视化/07.数据篇/05"><span>35| 设计（一）：如何让可视化设计更加清晰？</span></a></li><li><a href="/blog/跟月影学可视化/07.数据篇/06"><span>36 | 设计（二）：如何理解可视化设计原则？</span></a></li><li><a href="/blog/跟月影学可视化/07.数据篇/07"><span>37 | 实战（一）：如何使用图表库绘制常用数据图表？</span></a></li><li><a href="/blog/跟月影学可视化/07.数据篇/08"><span>38 | 实战（二）：如何使用数据驱动框架绘制常用数据图表？</span></a></li><li><a href="/blog/跟月影学可视化/07.数据篇/09"><span>39 | 实战（三）：如何实现地理信息的可视化？</span></a></li><li><a href="/blog/跟月影学可视化/07.数据篇/10"><span>40| 实战（四）：如何实现3D地球可视化（上）？</span></a></li><li><a href="/blog/跟月影学可视化/07.数据篇/11"><span>41 | 实战（五）：如何实现3D地球可视化（下）？</span></a></li><li><a href="/blog/跟月影学可视化/07.数据篇/12"><span>42 | 如何整理出我们自己的可视化工具集？</span></a></li></ul></li><li><a href="/blog/跟月影学可视化/08.国庆策划">08.国庆策划</a><ul><li><a href="/blog/跟月影学可视化/08.国庆策划/01"><span>国庆策划 | 假期别闲着，一起来挑战“手势密码”</span></a></li><li><a href="/blog/跟月影学可视化/08.国庆策划/02"><span>国庆策划 | 快来看看怎么用原生JavaScript实现手势解锁组件</span></a></li></ul></li><li><a href="/blog/跟月影学可视化/09.特别放送">09.特别放送</a><ul><li><a href="/blog/跟月影学可视化/09.特别放送/01"><span>加餐1 | 作为一名程序员，数学到底要多好？</span></a></li><li><a href="/blog/跟月影学可视化/09.特别放送/02"><span>加餐2 | SpriteJS：我是如何设计一个可视化图形渲染引擎的？</span></a></li><li><a href="/blog/跟月影学可视化/09.特别放送/03"><span>用户故事 | 非前端开发，我为什么要学可视化？</span></a></li><li><a href="/blog/跟月影学可视化/09.特别放送/04"><span>加餐3 | 轻松一刻：我想和你聊聊前端的未来</span></a></li><li><a href="/blog/跟月影学可视化/09.特别放送/05"><span>加餐4 | 一篇文章，带你快速理解函数式编程</span></a></li><li><a href="/blog/跟月影学可视化/09.特别放送/06"><span>加餐5｜周爱民：我想和你分享些学习的道理</span></a></li></ul></li><li><a href="/blog/跟月影学可视化/10.结束语">10.结束语</a><ul><li><a href="/blog/跟月影学可视化/10.结束语/01"><span>结束语 | 可视化工程师的未来之路</span></a></li><li><a href="/blog/跟月影学可视化/10.结束语/02"><span>有奖征集倒计时4天！你填写毕业问卷了吗？</span></a></li></ul></li><li><a href="/blog/跟月影学可视化/summary">跟月影学可视化</a></li></ul></div></div><ul role="slug-list" class="__dumi-default-layout-toc"><li title="图形系统是如何绘图的？" data-depth="2"><a href="/blog/跟月影学可视化/02.图形基础篇/04#图形系统是如何绘图的"><span>图形系统是如何绘图的？</span></a></li><li title="GPU是什么？" data-depth="2"><a href="/blog/跟月影学可视化/02.图形基础篇/04#gpu是什么"><span>GPU是什么？</span></a></li><li title="如何用WebGL绘制三角形？" data-depth="2"><a href="/blog/跟月影学可视化/02.图形基础篇/04#如何用webgl绘制三角形"><span>如何用WebGL绘制三角形？</span></a></li><li title="步骤一：创建WebGL上下文" data-depth="3"><a href="/blog/跟月影学可视化/02.图形基础篇/04#步骤一创建webgl上下文"><span>步骤一：创建WebGL上下文</span></a></li><li title="步骤二：创建WebGL程序" data-depth="3"><a href="/blog/跟月影学可视化/02.图形基础篇/04#步骤二创建webgl程序"><span>步骤二：创建WebGL程序</span></a></li><li title="步骤三：将数据存入缓冲区" data-depth="3"><a href="/blog/跟月影学可视化/02.图形基础篇/04#步骤三将数据存入缓冲区"><span>步骤三：将数据存入缓冲区</span></a></li><li title="步骤四：将缓冲区数据读取到GPU" data-depth="3"><a href="/blog/跟月影学可视化/02.图形基础篇/04#步骤四将缓冲区数据读取到gpu"><span>步骤四：将缓冲区数据读取到GPU</span></a></li><li title="步骤五：执行着色器程序完成绘制" data-depth="3"><a href="/blog/跟月影学可视化/02.图形基础篇/04#步骤五执行着色器程序完成绘制"><span>步骤五：执行着色器程序完成绘制</span></a></li><li title="顶点着色器的作用" data-depth="2"><a href="/blog/跟月影学可视化/02.图形基础篇/04#顶点着色器的作用"><span>顶点着色器的作用</span></a></li><li title="1. 通过gl_Position设置顶点" data-depth="3"><a href="/blog/跟月影学可视化/02.图形基础篇/04#1-通过gl_position设置顶点"><span>1. 通过gl_Position设置顶点</span></a></li><li title="2. 向片元着色器传递数据" data-depth="3"><a href="/blog/跟月影学可视化/02.图形基础篇/04#2-向片元着色器传递数据"><span>2. 向片元着色器传递数据</span></a></li><li title="要点总结" data-depth="2"><a href="/blog/跟月影学可视化/02.图形基础篇/04#要点总结"><span>要点总结</span></a></li><li title="小试牛刀" data-depth="2"><a href="/blog/跟月影学可视化/02.图形基础篇/04#小试牛刀"><span>小试牛刀</span></a></li><li title="源码" data-depth="2"><a href="/blog/跟月影学可视化/02.图形基础篇/04#源码"><span>源码</span></a></li><li title="推荐阅读" data-depth="2"><a href="/blog/跟月影学可视化/02.图形基础篇/04#推荐阅读"><span>推荐阅读</span></a></li></ul><div class="__dumi-default-layout-content"><div class="markdown"><h1 id="04--gpu与渲染管线如何用webgl绘制最简单的几何图形"><a aria-hidden="true" tabindex="-1" href="/blog/跟月影学可视化/02.图形基础篇/04#04--gpu与渲染管线如何用webgl绘制最简单的几何图形"><span class="icon icon-link"></span></a>04 | GPU与渲染管线：如何用WebGL绘制最简单的几何图形？</h1><p>你好，我是月影。今天，我们要讲WebGL。</p><p>WebGL是最后一个和可视化有关的图形系统，也是最难学的一个。为啥说它难学呢？我觉得这主要有两个原因。第一，WebGL这种技术本身就是用来解决最复杂的视觉呈现的。比如说，大批量绘制复杂图形和3D模型，这类比较有难度的问题就适合用WebGL来解决。第二，WebGL相对于其他图形系统来说，是一个更“开放”的系统。</p><p>我说的“开放”是针对于底层机制而言的。因为，不管是HTML/CSS、SVG还是Canvas，都主要是使用其API来绘制图形的，所以我们不必关心它们具体的底层机制。也就是说，我们只要理解创建SVG元素的绘图声明，学会执行Canvas对应的绘图指令，能够将图形输出，这就够了。但是，要使用WebGL绘图，我们必须要深入细节里。换句话说就是，我们必须要和内存、GPU打交道，真正控制图形输出的每一个细节。</p><p>所以，想要学好WebGL，我们必须先理解一些基本概念和原理。那今天这一节课，我会从图形系统的绘图原理开始讲起，主要来讲WebGL最基础的概念，包括GPU、渲染管线、着色器。然后，我会带你用WebGL绘制一个简单的几何图形。希望通过这个可视化的例子，能够帮助你理解WebGL绘制图形的基本原理，打好绘图的基础。</p><h2 id="图形系统是如何绘图的"><a aria-hidden="true" tabindex="-1" href="/blog/跟月影学可视化/02.图形基础篇/04#图形系统是如何绘图的"><span class="icon icon-link"></span></a>图形系统是如何绘图的？</h2><p>首先，我们来说说计算机图形系统的主要组成部分，以及它们在绘图过程中的作用。知道了这些，我们就能很容易理解计算机图形系统绘图的基本原理了。</p><p>一个通用计算机图形系统主要包括6个部分，分别是输入设备、中央处理单元、图形处理单元、存储器、帧缓存和输出设备。虽然我下面给出了绘图过程的示意图，不过这些设备在可视化中的作用，我要再跟你多啰嗦几句。</p><ul><li><strong>光栅</strong>（Raster）：几乎所有的现代图形系统都是基于光栅来绘制图形的，光栅就是指构成图像的像素阵列。</li><li><strong>像素</strong>（Pixel）：一个像素对应图像上的一个点，它通常保存图像上的某个具体位置的颜色等信息。</li><li><strong>帧缓存</strong>（Frame Buffer）：在绘图过程中，像素信息被存放于帧缓存中，帧缓存是一块内存地址。</li><li><strong>CPU</strong>（Central Processing Unit）：中央处理单元，负责逻辑计算。</li><li><strong>GPU</strong>（Graphics Processing Unit）：图形处理单元，负责图形计算。</li></ul><p><img src="https://static001.geekbang.org/resource/image/b5/56/b5e4f37e1c4fbyy6a2ea10624d143356.jpg?wh=1920*825" alt=""/></p><p>知道了这些概念，我带你来看一个典型的绘图过程，帮你来明晰一下这些概念的实际用途。</p><p>首先，数据经过CPU处理，成为具有特定结构的几何信息。然后，这些信息会被送到GPU中进行处理。在GPU中要经过两个步骤生成光栅信息。这些光栅信息会输出到帧缓存中，最后渲染到屏幕上。</p><p><img src="https://static001.geekbang.org/resource/image/9f/46/9f7d76cc9126036ef966dc236df01c46.jpeg?wh=1920*1080" alt="" title="图形数据经过GPU处理最终输出到屏幕上"/></p><p>这个绘图过程是现代计算机中任意一种图形系统处理图形的通用过程。它主要做了两件事，一是对给定的数据结合绘图的场景要素（例如相机、光源、遮挡物体等等）进行计算，最终将图形变为屏幕空间的2D坐标。二是为屏幕空间的每个像素点进行着色，把最终完成的图形输出到显示设备上。这整个过程是一步一步进行的，前一步的输出就是后一步的输入，所以我们也把这个过程叫做<strong>渲染管线</strong>（RenderPipelines）。</p><p>在这个过程中，CPU与GPU是最核心的两个处理单元，它们参与了计算的过程。CPU我相信你已经比较熟悉了，但是GPU又是什么呢？别着急，听我慢慢和你讲。</p><h2 id="gpu是什么"><a aria-hidden="true" tabindex="-1" href="/blog/跟月影学可视化/02.图形基础篇/04#gpu是什么"><span class="icon icon-link"></span></a>GPU是什么？</h2><p>CPU和GPU都属于处理单元，但是结构不同。形象点来说，CPU就像个大的工业管道，等待处理的任务就像是依次通过这个管道的货物。一条CPU流水线串行处理这些任务的速度，取决于CPU（管道）的处理能力。</p><p>实际上，一个计算机系统会有很多条CPU流水线，而且任何一个任务都可以随机地通过任意一个流水线，这样计算机就能够并行处理多个任务了。这样的一条流水线就是我们常说的<strong>线程</strong>（Thread）。</p><p><a target="_blank" rel="noopener noreferrer" href="https://thebookofshaders.com/"><img src="https://static001.geekbang.org/resource/image/1e/80/1e6479ef37138f051b7a6e5de6977580.jpeg?wh=1920*615" alt="" title="CPU"/></a></p><p>这样的结构用来处理大型任务是足够的，但是要处理图像应用就不太合适了。这是因为，处理图像应用，实际上就是在处理计算图片上的每一个像素点的颜色和其他信息。每处理一个像素点就相当于完成了一个简单的任务，而一个图片应用又是由成千上万个像素点组成的，所以，我们需要在同一时间处理成千上万个小任务。</p><p>要处理这么多的小任务，比起使用若干个强大的CPU，使用更小、更多的处理单元，是一种更好的处理方式。而GPU就是这样的处理单元。</p><p><a target="_blank" rel="noopener noreferrer" href="https://thebookofshaders.com/"><img src="https://static001.geekbang.org/resource/image/1a/e7/1ab1116e3742611f5cb26c942d67d5e7.jpeg?wh=1920*1080" alt="" title="GPU"/></a></p><p>GPU是由大量的小型处理单元构成的，它可能远远没有CPU那么强大，但胜在数量众多，可以保证每个单元处理一个简单的任务。即使我们要处理一张800 * 600大小的图片，GPU也可以保证这48万个像素点分别对应一个小单元，这样我们就可以<strong>同时</strong>对每个像素点进行计算了。</p><p>那GPU究竟是怎么完成像素点计算的呢？这就必须要和WebGL的绘图过程结合起来说了。</p><h2 id="如何用webgl绘制三角形"><a aria-hidden="true" tabindex="-1" href="/blog/跟月影学可视化/02.图形基础篇/04#如何用webgl绘制三角形"><span class="icon icon-link"></span></a>如何用WebGL绘制三角形？</h2><p>浏览器提供的WebGL API是OpenGL ES的JavaScript绑定版本，它赋予了开发者操作GPU的能力。这一特点也让WebGL的绘图方式和其他图形系统的“开箱即用”（直接调用绘图指令或者创建图形元素就可以完成绘图）的绘图方式完全不同，甚至要复杂得多。我们可以总结为以下5个步骤：</p><ol><li>创建WebGL上下文</li><li>创建WebGL程序（WebGL Program）</li><li>将数据存入缓冲区</li><li>将缓冲区数据读取到GPU</li><li>GPU执行WebGL程序，输出结果</li></ol><p>别看这些步骤看起来很简单，但其中会涉及许多你没听过的新概念、方法以及各种参数。不过，这也不用担心，我们今天的重点还是放在理解WebGL的基本用法和绘制原理上，对于新的方法具体怎么用，参数如何设置，这些我们都会在后面的课程中详细来讲。</p><p>接下来，我们就用一个绘制三角形的例子，来讲一下这些步骤的具体操作过程。</p><h3 id="步骤一创建webgl上下文"><a aria-hidden="true" tabindex="-1" href="/blog/跟月影学可视化/02.图形基础篇/04#步骤一创建webgl上下文"><span class="icon icon-link"></span></a>步骤一：创建WebGL上下文</h3><p>创建WebGL上下文这一步和Canvas2D的使用几乎一样，我们只要调用canvas元素的getContext即可，区别是将参数从’2d’换成’webgl’。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">const canvas = document.querySelector(&#x27;canvas&#x27;);</span></div><div class="token-line"><span class="token plain">    const gl = canvas.getContext(&#x27;webgl&#x27;);</span></div></pre></div><p>不过，有了WebGL上下文对象之后，我们并不能像使用Canvas2D的上下文那样，调用几个绘图指令就把图形画出来，还需要做很多工作。别着急，让我们一步一步来。</p><h3 id="步骤二创建webgl程序"><a aria-hidden="true" tabindex="-1" href="/blog/跟月影学可视化/02.图形基础篇/04#步骤二创建webgl程序"><span class="icon icon-link"></span></a>步骤二：创建WebGL程序</h3><p>接下来，我们要创建一个WebGL程序。你可能会觉得奇怪，我们不是正在写一个绘制三角形的程序吗？为什么这里又要创建一个WebGL程序呢？实际上，这里的WebGL程序是一个WebGLProgram对象，它是给GPU最终运行着色器的程序，而不是我们正在写的三角形的JavaScript程序。好了，解决了这个疑问，我们就正式开始创建一个WebGL程序吧！</p><p>首先，要创建这个WebGL程序，我们需要编写两个<strong>着色器</strong>（Shader）。着色器是用GLSL这种编程语言编写的代码片段，这里我们先不用过多纠结于GLSL语言，在后续的课程中我们会详细讲解。那在这里，我们只需要理解绘制三角形的这两个着色器的作用就可以了。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">const vertex = `</span></div><div class="token-line"><span class="token plain">      attribute vec2 position;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">      void main() {</span></div><div class="token-line"><span class="token plain">        gl_PointSize = 1.0;</span></div><div class="token-line"><span class="token plain">        gl_Position = vec4(position, 1.0, 1.0);</span></div><div class="token-line"><span class="token plain">      }</span></div><div class="token-line"><span class="token plain">    `;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    const fragment = `</span></div><div class="token-line"><span class="token plain">      precision mediump float;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">      void main()</span></div><div class="token-line"><span class="token plain">      {</span></div><div class="token-line"><span class="token plain">        gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);</span></div><div class="token-line"><span class="token plain">      }    </span></div><div class="token-line"><span class="token plain">    `;</span></div></pre></div><p>那我们为什么要创建两个着色器呢？这就需要我们先来理解<strong>顶点和图元</strong>这两个基本概念了。在绘图的时候，WebGL是以顶点和图元来描述图形几何信息的。顶点就是几何图形的顶点，比如，三角形有三个顶点，四边形有四个顶点。图元是WebGL可直接处理的图形单元，由WebGL的绘图模式决定，有点、线、三角形等等。</p><p>所以，顶点和图元是绘图过程中必不可少的。因此，WebGL绘制一个图形的过程，一般需要用到两段着色器，一段叫<strong>顶点着色器</strong>（Vertex Shader）负责处理图形的顶点信息，另一段叫<strong>片元着色器</strong>（Fragment Shader）负责处理图形的像素信息。</p><p>更具体点来说，我们可以把<strong>顶点着色器理解为处理顶点的GPU程序代码。它可以改变顶点的信息</strong>（如顶点的坐标、法线方向、材质等等），从而改变我们绘制出来的图形的形状或者大小等等。</p><p>顶点处理完成之后，WebGL就会根据顶点和绘图模式指定的图元，计算出需要着色的像素点，然后对它们执行片元着色器程序。简单来说，就是对指定图元中的像素点着色。</p><p>WebGL从顶点着色器和图元提取像素点给片元着色器执行代码的过程，就是我们前面说的生成光栅信息的过程，我们也叫它光栅化过程。所以，<strong>片元着色器的作用，就是处理光栅化后的像素信息。</strong></p><p>这么说可能比较抽象，我 来举个例子。我们可以将图元设为线段，那么片元着色器就会处理顶点之间的线段上的像素点信息，这样画出来的图形就是空心的。而如果我们把图元设为三角形，那么片元着色器就会处理三角形内部的所有像素点，这样画出来的图形就是实心的。</p><p><img src="https://static001.geekbang.org/resource/image/6c/6e/6c4390eb21e653274db092a9ba71946e.jpg?wh=1726*904" alt=""/></p><p>这里你要注意一点，因为图元是WebGL可以直接处理的图形单元，所以其他非图元的图形最终必须要转换为图元才可以被WebGL处理。举个例子，如果我们要绘制实心的四边形，我们就需要将四边形拆分成两个三角形，再交给WebGL分别绘制出来。</p><p>好了，那让我们回到片元着色器对像素点着色的过程。你还要注意，这个过程是并行的。也就是说，**无论有多少个像素点，片元着色器都可以同时处理。**这也是片元着色器一大特点。</p><p>以上就是片元着色器的作用和使用特点了，关于顶点着色器的作用我们一会儿再说。说了这么多，你可别忘了，创建着色器的目的是为了创建WebGL程序，那我们应该如何用顶点着色器和片元着色器代码，来创建WebGL程序呢？</p><p>首先，因为在JavaScript中，顶点着色器和片元着色器只是一段代码片段，所以我们要将它们分别创建成shader对象。代码如下所示：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">const vertexShader = gl.createShader(gl.VERTEX_SHADER);</span></div><div class="token-line"><span class="token plain">    gl.shaderSource(vertexShader, vertex);</span></div><div class="token-line"><span class="token plain">    gl.compileShader(vertexShader);</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);</span></div><div class="token-line"><span class="token plain">    gl.shaderSource(fragmentShader, fragment);</span></div><div class="token-line"><span class="token plain">    gl.compileShader(fragmentShader);</span></div></pre></div><p>接着，我们创建WebGLProgram对象，并将这两个shader关联到这个WebGL程序上。WebGLProgram对象的创建过程主要是添加vertexShader和fragmentShader，然后将这个WebGLProgram对象链接到WebGL上下文对象上。代码如下：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">const program = gl.createProgram();</span></div><div class="token-line"><span class="token plain">    gl.attachShader(program, vertexShader);</span></div><div class="token-line"><span class="token plain">    gl.attachShader(program, fragmentShader);</span></div><div class="token-line"><span class="token plain">    gl.linkProgram(program);</span></div></pre></div><p>最后，我们要通过useProgram选择启用这个WebGLProgram对象。这样，当我们绘制图形时，GPU就会执行我们通过WebGLProgram设定的 两个shader程序了。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">gl.useProgram(program);</span></div></pre></div><p>好了，现在我们已经创建并完成WebGL程序的配置。接下来， 我们只要将三角形的数据存入缓冲区，也就能将这些数据送入GPU了。那实现这一步之前呢，我们先来认识一下WebGL的坐标系。</p><h3 id="步骤三将数据存入缓冲区"><a aria-hidden="true" tabindex="-1" href="/blog/跟月影学可视化/02.图形基础篇/04#步骤三将数据存入缓冲区"><span class="icon icon-link"></span></a>步骤三：将数据存入缓冲区</h3><p>我们要知道WebGL的坐标系是一个三维空间坐标系，坐标原点是（0,0,0）。其中，x轴朝右，y轴朝上，z轴朝外。这是一个右手坐标系。</p><p><img src="https://static001.geekbang.org/resource/image/yy/b1/yy3e873beb7743096e3cc7b641e718b1.jpeg?wh=1920*1080" alt=""/></p><p>假设，我们要在这个坐标系上显示一个顶点坐标分别是（-1, -1）、（1, -1）、（0, 1）的三角形，如下图所示。因为这个三角形是二维的，所以我们可以直接忽略z轴。下面，我们来一起绘图。</p><p><img src="https://static001.geekbang.org/resource/image/83/c3/8311b485131497ce59cd1600b9a7f7c3.jpeg?wh=1920*1080" alt=""/></p><p><strong>首先，我们要定义这个三角形的三个顶点</strong>。WebGL使用的数据需要用类型数组定义，默认格式是Float32Array。Float32Array是JavaScript的一种类型化数组（TypedArray），JavaScript通常用类型化数组来处理二进制缓冲区。</p><p>因为平时我们在Web前端开发中，使用到类型化数组的机会并不多，你可能还不大熟悉，不过没关系，类型化数组的使用并不复杂，定义三角形顶点的过程，你直接看我下面给出的代码就能理解。不过，如果你之前完全没有接触过它，我还是建议你阅读<a target="_blank" rel="noopener noreferrer" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/TypedArray">MDN文档<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>，去详细了解一下类型化数组的使用方法。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">const points = new Float32Array([</span></div><div class="token-line"><span class="token plain">      -1, -1,</span></div><div class="token-line"><span class="token plain">      0, 1,</span></div><div class="token-line"><span class="token plain">      1, -1,</span></div><div class="token-line"><span class="token plain">    ]);</span></div></pre></div><p><strong>接着，我们要将定义好的数据写入WebGL的缓冲区</strong>。这个过程我们可以简单总结为三步，分别是创建一个缓存对象，将它绑定为当前操作对象，再把当前的数据写入缓存对象。这三个步骤主要是利用createBuffer、bindBuffer、bufferData方法来实现的，过程很简单你可以看一下我下面给出的实现代码。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">const bufferId = gl.createBuffer();</span></div><div class="token-line"><span class="token plain">    gl.bindBuffer(gl.ARRAY_BUFFER, bufferId);</span></div><div class="token-line"><span class="token plain">    gl.bufferData(gl.ARRAY_BUFFER, points, gl.STATIC_DRAW);</span></div></pre></div><h3 id="步骤四将缓冲区数据读取到gpu"><a aria-hidden="true" tabindex="-1" href="/blog/跟月影学可视化/02.图形基础篇/04#步骤四将缓冲区数据读取到gpu"><span class="icon icon-link"></span></a>步骤四：将缓冲区数据读取到GPU</h3><p>现在我们已经把数据写入缓存了，但是我们的shader现在还不能读取这个数据，还需要把数据绑定给顶点着色器中的position变量。</p><p>还记得我们的顶点着色器是什么样的吗？它是按如下的形式定义的：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">attribute vec2 position;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    void main() {</span></div><div class="token-line"><span class="token plain">      gl_PointSize = 1.0;</span></div><div class="token-line"><span class="token plain">      gl_Position = vec4(position, 1.0, 1.0);</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>在GLSL中，attribute表示声明变量，vec2是变量的类型，它表示一个二维向量，position是变量名。接下来我们将buffer的数据绑定给顶点着色器的position变量。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">const vPosition = gl.getAttribLocation(program, &#x27;position&#x27;);获取顶点着色器中的position变量的地址</span></div><div class="token-line"><span class="token plain">    gl.vertexAttribPointer(vPosition, 2, gl.FLOAT, false, 0, 0);给变量设置长度和类型</span></div><div class="token-line"><span class="token plain">    gl.enableVertexAttribArray(vPosition);激活这个变量</span></div></pre></div><p>经过这样的处理，在顶点着色器中，我们定义的points类型数组中对应的值，就能通过变量position读到了。</p><h3 id="步骤五执行着色器程序完成绘制"><a aria-hidden="true" tabindex="-1" href="/blog/跟月影学可视化/02.图形基础篇/04#步骤五执行着色器程序完成绘制"><span class="icon icon-link"></span></a>步骤五：执行着色器程序完成绘制</h3><p>现在，我们把数据传入缓冲区以后，GPU也可以读取绑定的数据到着色器变量了。接下来，我们只需要调用绘图指令，就可以执行着色器程序来完成绘制了。</p><p>我们先调用gl.clear将当前画布的内容清除，然后调用gl.drawArrays传入绘制模式。这里我们选择gl.TRIANGLES表示以三角形为图元绘制，再传入绘制的顶点偏移量和顶点数量，WebGL就会将对应的buffer数组传给顶点着色器，并且开始绘制。代码如下：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">gl.clear(gl.COLOR_BUFFER_BIT);</span></div><div class="token-line"><span class="token plain">    gl.drawArrays(gl.TRIANGLES, 0, points.length / 2);</span></div></pre></div><p>这样，我们就在Canvas画布上画出了一个红色三角形。</p><p><img src="https://static001.geekbang.org/resource/image/cc/61/ccdd298c45f80a9a00d23082cf637d61.jpeg?wh=1920*1080" alt=""/></p><p>为什么是红色三角形呢？因为我们在片元着色器中定义了像素点的颜色，代码如下：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">precision mediump float;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    void main()</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">      gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>在<strong>片元着色器</strong>里，我们可以通过设置gl_FragColor的值来定义和改变图形的颜色。gl_FragColor是WebGL片元着色器的内置变量，表示当前像素点颜色，它是一个用RGBA色值表示的四维向量数据。在上面的代码中，因为我们写入vec4(1.0, 0.0, 0.0, 1.0)对应的是红色，所以三角形是红色的。如果我们把这个值改成vec4(0.0, 0.0, 1.0, 1.0)，那三角形就是蓝色。</p><p>我为什么会强调颜色这个事儿呢？你会发现，刚才我们只更改了一个值，就把整个图片的所有像素颜色都改变了。所以，我们必须要认识到一点，WebGL可以并行地对整个三角形的所有像素点同时运行片元着色器。并行处理是WebGL程序非常重要的概念，所以我就多强调一下。</p><p>我们要记住，不论这个三角形是大还是小，有几十个像素点还是上百万个像素点，GPU都是<strong>同时处理</strong>每个像素点的。也就是说，图形中有多少个像素点，着色器程序在GPU中就会被同时执行多少次。</p><p>到这里，WebGL绘制三角形的过程我们就讲完了。借助这个过程，我们加深了对顶点着色器和片元着色器在使用上的理解。不过，因为后面我们会更多地讲解片元着色器的绘图方法，那今天，我们正好可以借着这个机会，多讲讲顶点着色器的应用，我希望你也能掌握好它。</p><h2 id="顶点着色器的作用"><a aria-hidden="true" tabindex="-1" href="/blog/跟月影学可视化/02.图形基础篇/04#顶点着色器的作用"><span class="icon icon-link"></span></a>顶点着色器的作用</h2><p>顶点着色器大体上可以总结为两个作用：一是通过gl_Position设置顶点，二是通过定义varying变量，向片元着色器传递数据。这么说还是有点抽象，我们还是通过三角形的例子来具体理解一下。</p><h3 id="1-通过gl_position设置顶点"><a aria-hidden="true" tabindex="-1" href="/blog/跟月影学可视化/02.图形基础篇/04#1-通过gl_position设置顶点"><span class="icon icon-link"></span></a>1. 通过gl_Position设置顶点</h3><p>假如，我想把三角形的周长缩小为原始大小的一半，有两种处理方式法：一种是修改points数组的值，另一种做法是直接对顶点着色器数据进行处理。第一种做法很简单，我就不讲了，如果不懂你可以在留言区提问。我们来详细说说第二种做法。</p><p>我们不需要修改points数据，只需要在顶点着色器中，将 gl_Position = vec4(position, 1.0, 1.0);修改为 gl_Position = vec4(position * 0.5, 1.0, 1.0);，代码如下所示。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">attribute vec2 position;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    void main() {</span></div><div class="token-line"><span class="token plain">      gl_PointSize = 1.0;</span></div><div class="token-line"><span class="token plain">      gl_Position = vec4(position * 0.5, 1.0, 1.0);</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>这样，三角形的周长就缩小为原来的一半了。在这个过程中，我们不需要遍历三角形的每一个顶点，只需要是利用GPU的并行特性，在顶点着色器中同时计算所有的顶点就可以了。在后续课程中，我们还会遇到更加复杂的例子，但在那之前，你一定要理解并牢记WebGL可以<strong>并行计算</strong>这一特点。</p><h3 id="2-向片元着色器传递数据"><a aria-hidden="true" tabindex="-1" href="/blog/跟月影学可视化/02.图形基础篇/04#2-向片元着色器传递数据"><span class="icon icon-link"></span></a>2. 向片元着色器传递数据</h3><p>除了计算顶点之外，顶点着色器还可以将数据通过varying变量传给片元着色器。然后，这些值会根据片元着色器的像素坐标与顶点像素坐标的相对位置做<strong>线性插值</strong>。这是什么意思呢？其实这很难用文字描述，我们还是来看一段代码：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">attribute vec2 position;</span></div><div class="token-line"><span class="token plain">    varying vec3 color;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    void main() {</span></div><div class="token-line"><span class="token plain">      gl_PointSize = 1.0;</span></div><div class="token-line"><span class="token plain">      color = vec3(0.5 + position * 0.5, 0.0);</span></div><div class="token-line"><span class="token plain">      gl_Position = vec4(position * 0.5, 1.0, 1.0);</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>在这段代码中，我们修改了顶点着色器，定义了一个color变量，它是一个三维的向量。我们通过数学技巧将顶点的值映射为一个RGB颜色值（关于顶点映射RGB颜色值的方法，在后续的课程中会有详细介绍），映射公式是 vec3(0.5 + position * 0.5, 0.0)。</p><p>这样一来，顶点[-1,-1]被映射为[0,0,0]也就是黑色，顶点[0,1]被映射为[0.5, 1, 0]也就是浅绿色，顶点[1,-1]被映射为[1,0,0]也就是红色。这样一来，三个顶点就会有三个不同的颜色值。</p><p>然后我们将color通过varying变量传给片元着色器。片元着色器中的代码如下：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">precision mediump float;</span></div><div class="token-line"><span class="token plain">    varying vec3 color;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    void main()</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">      gl_FragColor = vec4(color, 1.0);</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>我们将gl_FragColor的rgb值设为变量color的值，这样我们就能得到下面这个三角形：</p><p><img src="https://static001.geekbang.org/resource/image/5c/21/5c4c718eca069be33d8a1d5d1eb77821.jpeg?wh=1920*1080" alt=""/></p><p>我们可以看到，这个三角形是一个颜色均匀（线性）渐变的三角形，它的三个顶点的色值就是我们通过顶点着色器来设置的。而且你会发现，中间像素点的颜色是均匀过渡的。这就是因为WebGL在执行片元着色器程序的时候，顶点着色器传给片元着色器的变量，会根据片元着色器的像素坐标对变量进行线性插值。利用线性插值可以让像素点的颜色均匀渐变这一特点，我们就能绘制出颜色更丰富的图形了。</p><p>好了，到这里，我们就在Canvas画布上用WebGL绘制出了一个三角形。绘制三角形的过程，就像我们初学编程时去写出一个Hello World程序一样，按道理来说，应该非常简单才对。但事实上，用WebGL完成这个程序，我们一共用了好几十行代码。而如果我们用Canvas2D或者SVG实现类似的功能，只需要几行代码就可以了。</p><p>那我们为什么非要这么做呢？而且我们费了很大的劲，就只绘制出了一个最简单的三角形，这似乎离我们用WebGL实现复杂的可视化效果还非常遥远。我想告诉你的是，别失落，想要利用WebGL绘制更有趣、更复杂的图形，我们就必须要学会绘制三角形这个图元。还记得我们前面说过的，要在WebGL中绘制非图元的其他图形时，我们必须要把它们划分成三角形才行。学习了后面的课程之后，你就会对这一点有更深刻的理解了。</p><p>而且，用WebGL可以实现的视觉效果，远远超越其他三个图形系统。如果用驾驶技术来比喻的话，使用SVG和Canvas2D时，就像我们在开一辆自动挡的汽车，那么使用WebGL的时候，就像是在开战斗机！所以，千万别着急，随着对WebGL的不断深入理解，我们就能用它来实现更多有趣的实例了。</p><h2 id="要点总结"><a aria-hidden="true" tabindex="-1" href="/blog/跟月影学可视化/02.图形基础篇/04#要点总结"><span class="icon icon-link"></span></a>要点总结</h2><p>在这一节课，我们讲了WebGL的绘图过程以及顶点着色器和片元着色器的作用。</p><p>WebGL图形系统与用其他图形系统不同，它的API非常底层，使用起来比较复杂。想要学好WebGL，我们必须要从基础概念和原理学起。</p><p>一般来说，在WebGL中要完成图形的绘制，需要创建WebGL程序，然后将图形的几何数据存入数据缓冲区，在绘制过程中让WebGL从缓冲区读取数据，并且执行着色器程序。</p><p>WebGL的着色器程序有两个。一个是顶点着色器，负责处理图形的顶点数据。另一个是片元着色器，负责处理光栅化后的像素信息。此外，我们还要牢记，WebGL程序有一个非常重要的特点就是能够并行处理，无论图形中有多少个像素点，都可以通过着色器程序在GPU中被同时执行。</p><p>WebGL完整的绘图过程实在比较复杂，为了帮助你理解，我总结一个流程图，供你参考。</p><p><a target="_blank" rel="noopener noreferrer" href="https://juejin.im/post/5e7a042e6fb9a07cb96b1627"><img src="https://static001.geekbang.org/resource/image/d3/30/d31e6c50b55872f81aa70625538fb930.jpg?wh=1196*960" alt="" title="WebGL绘图流程"/></a></p><p>那到这里，可视化的四个图形系统我们就介绍完了。但是，好戏才刚刚开始哦，在后续的文章中我们会围绕着这四个图形系统，尤其是Canvas2D和WebGL逐渐深入，来实现更多有趣的图形。</p><h2 id="小试牛刀"><a aria-hidden="true" tabindex="-1" href="/blog/跟月影学可视化/02.图形基础篇/04#小试牛刀"><span class="icon icon-link"></span></a>小试牛刀</h2><ol><li><p>WebGL通过顶点和图元来绘制图形，我们在上面的例子中，调用gl.TRIANGLES 绘制出了实心的三角形。如果要绘制空心三角形，我们又应该怎么做呢？有哪些图元类型可以帮助我们完成这个绘制？</p></li><li><p>三角形是最简单的几何图形，如果我们要绘制其他的几何图形，我们可以通过用多个三角形拼接来实现。试着用WebGL绘制正四边形、正五边形和正六角星吧！</p></li></ol><p>欢迎在留言区和我讨论，分享你的答案和思考，也欢迎你把这一节课分享给你的朋友，我们下节课再见！</p><hr/><h2 id="源码"><a aria-hidden="true" tabindex="-1" href="/blog/跟月影学可视化/02.图形基础篇/04#源码"><span class="icon icon-link"></span></a>源码</h2><p><a target="_blank" rel="noopener noreferrer" href="https://github.com/akira-cn/graphics/tree/master/webgl">WebGL绘制三角形示例代码<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p><h2 id="推荐阅读"><a aria-hidden="true" tabindex="-1" href="/blog/跟月影学可视化/02.图形基础篇/04#推荐阅读"><span class="icon icon-link"></span></a>推荐阅读</h2><p>[1] <a target="_blank" rel="noopener noreferrer" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/TypedArray">类型化数组 MDN 文档<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a><br/>[2] <a target="_blank" rel="noopener noreferrer" href="https://developer.mozilla.org/zh-CN/docs/Web/API/WebGL_API">WebGL 的 MDN 文档<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p></div><div class="__dumi-default-layout-footer-meta"><a target="_blank" rel="noopener noreferrer" href="https://github.com/GGwujun/blog/edit/master/docs/跟月影学可视化/02.图形基础篇/04.md">在 GitHub 上编辑此页<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a><span data-updated-text="最后更新时间：">5/2/2022 10:57:00</span></div></div></div></div>
	<script>
  window.g_useSSR = true;
  window.g_initialProps = {};
	</script>

    <script>
      (function () {
        if (!location.port) {
          (function (i, s, o, g, r, a, m) {
            i["GoogleAnalyticsObject"] = r;
            (i[r] =
              i[r] ||
              function () {
                (i[r].q = i[r].q || []).push(arguments);
              }),
              (i[r].l = 1 * new Date());
            (a = s.createElement(o)), (m = s.getElementsByTagName(o)[0]);
            a.async = 1;
            a.src = g;
            m.parentNode.insertBefore(a, m);
          })(
            window,
            document,
            "script",
            "//www.google-analytics.com/analytics.js",
            "ga"
          );
          ga("create", "UA-149864185-1", "auto");
          ga("send", "pageview");
        }
      })();
    </script>
    <script src="/blog/umi.js"></script>
  </body>
</html>
