<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no"
    />
    <link rel="shortcut icon" type="image/x-icon" href="/logo.png" />
    <link rel="stylesheet" href="/blog/umi.css" />
    <script>
      window.routerBase = "/blog";
    </script>
    <script>
      //! umi version: 3.5.17
    </script>
    <script>
      !(function () {
        var e = localStorage.getItem("dumi:prefers-color"),
          t = window.matchMedia("(prefers-color-scheme: dark)").matches,
          r = ["light", "dark", "auto"];
        document.documentElement.setAttribute(
          "data-prefers-color",
          e === r[2] ? (t ? r[1] : r[0]) : r.indexOf(e) > -1 ? e : r[0]
        );
      })();
    </script>
    <title>JavaScript语法（二）：你知道哪些JavaScript语句？</title>
  </head>
  <body>
    <div id="root"><div class="__dumi-default-layout" data-route="/重学前端/02.模块一java-script/13" data-show-sidemenu="true" data-show-slugs="true" data-site-mode="true" data-gapless="false"><div class="__dumi-default-navbar" data-mode="site"><button class="__dumi-default-navbar-toggle"></button><a class="__dumi-default-navbar-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog/">大师兄</a><nav><div class="__dumi-default-search"><input type="search" class="__dumi-default-search-input" value=""/><ul></ul></div><span>计算机基础<ul><li><a href="/blog/编译原理之美">编译原理之美</a></li><li><a href="/blog/编译原理实战">编译原理实战</a></li><li><a href="/blog/深入浅出计算机组成原理">深入浅出计算机组成原理</a></li><li><a href="/blog/详解http">详解http</a></li><li><a href="/blog/计算机网络通关29讲">计算机网络通关29讲</a></li><li><a href="/blog/网络排查案例课">网络排查案例课</a></li><li><a href="/blog/linux操作系统">linux操作系统</a></li><li><a href="/blog/linux性能优化实战">linux性能优化实战</a></li><li><a href="/blog/程序员数学基础">程序员数学基础</a></li><li><a href="/blog/趣谈网络协议">趣谈网络协议</a></li><li><a href="/blog/操作系统实战">操作系统实战</a></li><li><a href="/blog/软件工程之美">软件工程之美</a></li><li><a href="/blog/sql必知必会">sql必知必会</a></li><li><a href="/blog/操作系统实战45讲">操作系统实战45讲</a></li><li><a href="/blog/网络编程实战">网络编程实战</a></li></ul></span><span>算法<ul><li><a href="/blog/常用算法25讲">常用算法25讲</a></li><li><a href="/blog/数据结构与算法之美">数据结构与算法之美</a></li><li><a href="/blog/业务开发算法50讲">业务开发算法50讲</a></li><li><a href="/blog/动态规划面试宝典">动态规划面试宝典</a></li></ul></span><span>前端开发<ul><li><a href="/blog/浏览器工作原理与实践">浏览器工作原理与实践</a></li><li><a href="/blog/新时代产品经理进阶之路">新时代产品经理进阶之路</a></li><li><a href="/blog/全栈工程师修炼指南">全栈工程师修炼指南</a></li><li><a href="/blog/flutter核心技术与实战">flutter核心技术与实战</a></li><li><a href="/blog/java-script核心原理解析">java-script核心原理解析</a></li><li><a href="/blog/说透低代码">说透低代码</a></li><li><a href="/blog/nodejs应用开发实战">nodejs应用开发实战</a></li><li><a href="/blog/反爬虫兵法演绎20讲">反爬虫兵法演绎20讲</a></li><li><a href="/blog/reactnative新架构实战课">reactnative新架构实战课</a></li><li><a href="/blog/正则表达式入门">正则表达式入门</a></li><li><a aria-current="page" class="active" href="/blog/重学前端">重学前端</a></li><li><a href="/blog/serverless入门课">serverless入门课</a></li><li><a href="/blog/type-script入门实战笔记">type-script入门实战笔记</a></li><li><a href="/blog/图解googlev8">图解googlev8</a></li><li><a href="/blog/vue3源码分析">vue3源码分析</a></li><li><a href="/blog/玩转Vue3全家桶">玩转Vue3全家桶</a></li><li><a href="/blog/webassembly入门">webassembly入门</a></li><li><a href="/blog/手把手带你写一个Web框架">手把手带你写一个Web框架</a></li><li><a href="/blog/web漏洞挖掘实战">web漏洞挖掘实战</a></li><li><a href="/blog/跟月影学可视化">跟月影学可视化</a></li><li><a href="/blog/搞定音频技术">搞定音频技术</a></li><li><a href="/blog/攻克视频技术">攻克视频技术</a></li></ul></span><span>前端工程化<ul><li><a href="/blog/logger">logger</a></li><li><a href="/blog/webpack">webpack</a></li><li><a href="/blog/webpackChain">webpackChain</a></li></ul></span><span>前端性能优化<ul><li><a href="/blog/react性能调优">react性能调优</a></li></ul></span><span>软件测试<ul><li><a href="/blog/全链路压测实战30讲">全链路压测实战30讲</a></li><li><a href="/blog/性能测试实战30讲">性能测试实战30讲</a></li><li><a href="/blog/自动化测试高手课">自动化测试高手课</a></li><li><a href="/blog/软件测试52讲">软件测试52讲</a></li></ul></span><span>面试<ul><li><a href="/blog/面试现场">面试现场</a></li></ul></span><span>杂谈<ul><li><a href="/blog/超级访谈对话张雪峰">超级访谈对话张雪峰</a></li><li><a href="/blog/Git实战手册">Git实战手册</a></li><li><a href="/blog/NodeJS">NodeJS</a></li><li><a href="/blog/ReactJS">ReactJS</a></li><li><a href="/blog/UI设计">UI设计</a></li><li><a href="/blog/webpack4系列教程">webpack4系列教程</a></li><li><a href="/blog/前端知识体系">前端知识体系</a></li><li><a href="/blog/剑指offer刷题笔记">剑指offer刷题笔记</a></li><li><a href="/blog/思考与成长">思考与成长</a></li><li><a href="/blog/设计模式手册">设计模式手册</a></li></ul></span><div class="__dumi-default-navbar-tool"><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "></div></div></div></nav></div><div class="__dumi-default-menu" data-mode="site"><div class="__dumi-default-menu-inner"><div class="__dumi-default-menu-header"><a class="__dumi-default-menu-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog/"></a><h1>大师兄</h1><p></p></div><div class="__dumi-default-menu-mobile-area"><ul class="__dumi-default-menu-nav-list"><li>计算机基础<ul><li><a href="/blog/编译原理之美">编译原理之美</a></li><li><a href="/blog/编译原理实战">编译原理实战</a></li><li><a href="/blog/深入浅出计算机组成原理">深入浅出计算机组成原理</a></li><li><a href="/blog/详解http">详解http</a></li><li><a href="/blog/计算机网络通关29讲">计算机网络通关29讲</a></li><li><a href="/blog/网络排查案例课">网络排查案例课</a></li><li><a href="/blog/linux操作系统">linux操作系统</a></li><li><a href="/blog/linux性能优化实战">linux性能优化实战</a></li><li><a href="/blog/程序员数学基础">程序员数学基础</a></li><li><a href="/blog/趣谈网络协议">趣谈网络协议</a></li><li><a href="/blog/操作系统实战">操作系统实战</a></li><li><a href="/blog/软件工程之美">软件工程之美</a></li><li><a href="/blog/sql必知必会">sql必知必会</a></li><li><a href="/blog/操作系统实战45讲">操作系统实战45讲</a></li><li><a href="/blog/网络编程实战">网络编程实战</a></li></ul></li><li>算法<ul><li><a href="/blog/常用算法25讲">常用算法25讲</a></li><li><a href="/blog/数据结构与算法之美">数据结构与算法之美</a></li><li><a href="/blog/业务开发算法50讲">业务开发算法50讲</a></li><li><a href="/blog/动态规划面试宝典">动态规划面试宝典</a></li></ul></li><li>前端开发<ul><li><a href="/blog/浏览器工作原理与实践">浏览器工作原理与实践</a></li><li><a href="/blog/新时代产品经理进阶之路">新时代产品经理进阶之路</a></li><li><a href="/blog/全栈工程师修炼指南">全栈工程师修炼指南</a></li><li><a href="/blog/flutter核心技术与实战">flutter核心技术与实战</a></li><li><a href="/blog/java-script核心原理解析">java-script核心原理解析</a></li><li><a href="/blog/说透低代码">说透低代码</a></li><li><a href="/blog/nodejs应用开发实战">nodejs应用开发实战</a></li><li><a href="/blog/反爬虫兵法演绎20讲">反爬虫兵法演绎20讲</a></li><li><a href="/blog/reactnative新架构实战课">reactnative新架构实战课</a></li><li><a href="/blog/正则表达式入门">正则表达式入门</a></li><li><a aria-current="page" class="active" href="/blog/重学前端">重学前端</a></li><li><a href="/blog/serverless入门课">serverless入门课</a></li><li><a href="/blog/type-script入门实战笔记">type-script入门实战笔记</a></li><li><a href="/blog/图解googlev8">图解googlev8</a></li><li><a href="/blog/vue3源码分析">vue3源码分析</a></li><li><a href="/blog/玩转Vue3全家桶">玩转Vue3全家桶</a></li><li><a href="/blog/webassembly入门">webassembly入门</a></li><li><a href="/blog/手把手带你写一个Web框架">手把手带你写一个Web框架</a></li><li><a href="/blog/web漏洞挖掘实战">web漏洞挖掘实战</a></li><li><a href="/blog/跟月影学可视化">跟月影学可视化</a></li><li><a href="/blog/搞定音频技术">搞定音频技术</a></li><li><a href="/blog/攻克视频技术">攻克视频技术</a></li></ul></li><li>前端工程化<ul><li><a href="/blog/logger">logger</a></li><li><a href="/blog/webpack">webpack</a></li><li><a href="/blog/webpackChain">webpackChain</a></li></ul></li><li>前端性能优化<ul><li><a href="/blog/react性能调优">react性能调优</a></li></ul></li><li>软件测试<ul><li><a href="/blog/全链路压测实战30讲">全链路压测实战30讲</a></li><li><a href="/blog/性能测试实战30讲">性能测试实战30讲</a></li><li><a href="/blog/自动化测试高手课">自动化测试高手课</a></li><li><a href="/blog/软件测试52讲">软件测试52讲</a></li></ul></li><li>面试<ul><li><a href="/blog/面试现场">面试现场</a></li></ul></li><li>杂谈<ul><li><a href="/blog/超级访谈对话张雪峰">超级访谈对话张雪峰</a></li><li><a href="/blog/Git实战手册">Git实战手册</a></li><li><a href="/blog/NodeJS">NodeJS</a></li><li><a href="/blog/ReactJS">ReactJS</a></li><li><a href="/blog/UI设计">UI设计</a></li><li><a href="/blog/webpack4系列教程">webpack4系列教程</a></li><li><a href="/blog/前端知识体系">前端知识体系</a></li><li><a href="/blog/剑指offer刷题笔记">剑指offer刷题笔记</a></li><li><a href="/blog/思考与成长">思考与成长</a></li><li><a href="/blog/设计模式手册">设计模式手册</a></li></ul></li></ul><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "><button title="Dark theme" class="__dumi-default-dark-moon "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="3854" width="22" height="22"><path d="M991.816611 674.909091a69.166545 69.166545 0 0 0-51.665455-23.272727 70.795636 70.795636 0 0 0-27.438545 5.585454A415.674182 415.674182 0 0 1 754.993338 698.181818c-209.594182 0-393.472-184.785455-393.472-395.636363 0-52.363636 38.539636-119.621818 69.515637-173.614546 4.887273-8.610909 9.634909-16.756364 14.103272-24.901818A69.818182 69.818182 0 0 0 384.631156 0a70.842182 70.842182 0 0 0-27.438545 5.585455C161.678429 90.298182 14.362065 307.898182 14.362065 512c0 282.298182 238.824727 512 532.38691 512a522.286545 522.286545 0 0 0 453.957818-268.334545A69.818182 69.818182 0 0 0 991.816611 674.909091zM546.679156 954.181818c-248.785455 0-462.941091-192-462.941091-442.181818 0-186.647273 140.637091-372.829091 300.939637-442.181818-36.817455 65.629091-92.578909 151.970909-92.578909 232.727273 0 250.181818 214.109091 465.454545 462.917818 465.454545a488.331636 488.331636 0 0 0 185.181091-46.545455 453.003636 453.003636 0 0 1-393.565091 232.727273z m103.656728-669.323636l-14.266182 83.781818a34.909091 34.909091 0 0 0 50.362182 36.770909l74.775272-39.563636 74.752 39.563636a36.142545 36.142545 0 0 0 16.174546 3.956364 34.909091 34.909091 0 0 0 34.210909-40.727273l-14.289455-83.781818 60.509091-59.345455a35.025455 35.025455 0 0 0-19.223272-59.578182l-83.61891-12.101818-37.376-76.101818a34.56 34.56 0 0 0-62.254545 0l-37.376 76.101818-83.618909 12.101818a34.909091 34.909091 0 0 0-19.246546 59.578182z m70.423272-64.698182a34.280727 34.280727 0 0 0 26.135273-19.083636l14.312727-29.090909 14.336 29.090909a34.257455 34.257455 0 0 0 26.135273 19.083636l32.046546 4.887273-23.272728 22.574545a35.234909 35.234909 0 0 0-10.007272 30.952727l5.46909 32.116364-28.625454-15.127273a34.490182 34.490182 0 0 0-32.302546 0l-28.695272 15.127273 5.469091-32.116364a35.141818 35.141818 0 0 0-9.984-30.952727l-23.272728-22.574545z" p-id="3855"></path></svg></button><button title="Light theme" class="__dumi-default-dark-sun "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="4026" width="22" height="22"><path d="M915.2 476.16h-43.968c-24.704 0-44.736 16-44.736 35.84s20.032 35.904 44.736 35.904H915.2c24.768 0 44.8-16.064 44.8-35.904s-20.032-35.84-44.8-35.84zM512 265.6c-136.704 0-246.464 109.824-246.464 246.4 0 136.704 109.76 246.464 246.464 246.464S758.4 648.704 758.4 512c0-136.576-109.696-246.4-246.4-246.4z m0 425.6c-99.008 0-179.2-80.128-179.2-179.2 0-98.944 80.192-179.2 179.2-179.2S691.2 413.056 691.2 512c0 99.072-80.192 179.2-179.2 179.2zM197.44 512c0-19.84-19.136-35.84-43.904-35.84H108.8c-24.768 0-44.8 16-44.8 35.84s20.032 35.904 44.8 35.904h44.736c24.768 0 43.904-16.064 43.904-35.904zM512 198.464c19.776 0 35.84-20.032 35.84-44.8v-44.8C547.84 84.032 531.84 64 512 64s-35.904 20.032-35.904 44.8v44.8c0 24.768 16.128 44.864 35.904 44.864z m0 627.136c-19.776 0-35.904 20.032-35.904 44.8v44.736C476.096 940.032 492.16 960 512 960s35.84-20.032 35.84-44.8v-44.736c0-24.768-16.064-44.864-35.84-44.864z m329.92-592.832c17.472-17.536 20.288-43.072 6.4-57.024-14.016-14.016-39.488-11.2-57.024 6.336-4.736 4.864-26.496 26.496-31.36 31.36-17.472 17.472-20.288 43.008-6.336 57.024 13.952 14.016 39.488 11.2 57.024-6.336 4.8-4.864 26.496-26.56 31.296-31.36zM213.376 759.936c-4.864 4.8-26.56 26.624-31.36 31.36-17.472 17.472-20.288 42.944-6.4 56.96 14.016 13.952 39.552 11.2 57.024-6.336 4.8-4.736 26.56-26.496 31.36-31.36 17.472-17.472 20.288-43.008 6.336-56.96-14.016-13.952-39.552-11.072-56.96 6.336z m19.328-577.92c-17.536-17.536-43.008-20.352-57.024-6.336-14.08 14.016-11.136 39.488 6.336 57.024 4.864 4.864 26.496 26.56 31.36 31.424 17.536 17.408 43.008 20.288 56.96 6.336 14.016-14.016 11.264-39.488-6.336-57.024-4.736-4.864-26.496-26.56-31.296-31.424z m527.168 628.608c4.864 4.864 26.624 26.624 31.36 31.424 17.536 17.408 43.072 20.224 57.088 6.336 13.952-14.016 11.072-39.552-6.4-57.024-4.864-4.8-26.56-26.496-31.36-31.36-17.472-17.408-43.072-20.288-57.024-6.336-13.952 14.016-11.008 39.488 6.336 56.96z" p-id="4027"></path></svg></button><button title="Default to system" class="__dumi-default-dark-auto "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="11002" width="22" height="22"><path d="M127.658667 492.885333c0-51.882667 10.24-101.717333 30.378666-149.162666s47.786667-88.064 81.92-122.538667 75.093333-61.781333 122.538667-81.92 96.938667-30.378667 149.162667-30.378667 101.717333 10.24 149.162666 30.378667 88.405333 47.786667 122.88 81.92 61.781333 75.093333 81.92 122.538667 30.378667 96.938667 30.378667 149.162666-10.24 101.717333-30.378667 149.162667-47.786667 88.405333-81.92 122.88-75.093333 61.781333-122.88 81.92-97.28 30.378667-149.162666 30.378667-101.717333-10.24-149.162667-30.378667-88.064-47.786667-122.538667-81.92-61.781333-75.093333-81.92-122.88-30.378667-96.938667-30.378666-149.162667z m329.045333 0c0 130.048 13.994667 244.394667 41.984 343.381334h12.970667c46.762667 0 91.136-9.216 133.461333-27.306667s78.848-42.666667 109.568-73.386667 54.954667-67.242667 73.386667-109.568 27.306667-86.698667 27.306666-133.461333c0-46.421333-9.216-90.794667-27.306666-133.12s-42.666667-78.848-73.386667-109.568-67.242667-54.954667-109.568-73.386667-86.698667-27.306667-133.461333-27.306666h-11.605334c-28.672 123.562667-43.349333 237.909333-43.349333 343.722666z" p-id="11003"></path></svg></button></div></div></div><ul class="__dumi-default-menu-list"><li><a href="/blog/重学前端">重学前端</a></li><li><a href="/blog/重学前端/01.开篇词+学习路线+架构图">01.开篇词+学习路线+架构图</a><ul><li><a href="/blog/重学前端/01.开篇词+学习路线+架构图/01"><span>开篇词 | 从今天起，重新理解前端</span></a></li><li><a href="/blog/重学前端/01.开篇词+学习路线+架构图/02"><span>明确你的前端学习路线与方法</span></a></li><li><a href="/blog/重学前端/01.开篇词+学习路线+架构图/03"><span>列一份前端知识架构图</span></a></li></ul></li><li><a aria-current="page" class="active" href="/blog/重学前端/02.模块一java-script">02.模块一JavaScript</a><ul><li><a href="/blog/重学前端/02.模块一java-script/01"><span>JavaScript类型：关于类型，有哪些你不知道的细节？</span></a></li><li><a href="/blog/重学前端/02.模块一java-script/02"><span>JavaScript对象：面向对象还是基于对象？</span></a></li><li><a href="/blog/重学前端/02.模块一java-script/03"><span>JavaScript对象：我们真的需要模拟类吗？</span></a></li><li><a href="/blog/重学前端/02.模块一java-script/04"><span>JavaScript对象：你知道全部的对象分类吗？</span></a></li><li><a href="/blog/重学前端/02.模块一java-script/05"><span>JavaScript执行（一）：Promise里的代码为什么比setTimeout先执行？</span></a></li><li><a href="/blog/重学前端/02.模块一java-script/06"><span>JavaScript执行（二）：闭包和执行上下文到底是怎么回事？</span></a></li><li><a href="/blog/重学前端/02.模块一java-script/07"><span>JavaScript执行（三）：你知道现在有多少种函数吗？</span></a></li><li><a href="/blog/重学前端/02.模块一java-script/08"><span>JavaScript执行（四）：try里面放return，finally还会执行吗？</span></a></li><li><a href="/blog/重学前端/02.模块一java-script/09"><span>JavaScript词法：为什么12.toString会报错？</span></a></li><li><a href="/blog/重学前端/02.模块一java-script/10"><span>（小实验）理解编译原理：一个四则运算的解释器</span></a></li><li><a href="/blog/重学前端/02.模块一java-script/11"><span>JavaScript语法（预备篇）：到底要不要写分号呢？</span></a></li><li><a href="/blog/重学前端/02.模块一java-script/12"><span>JavaScript语法（一）：在script标签写export为什么会抛错？</span></a></li><li><a aria-current="page" class="active" href="/blog/重学前端/02.模块一java-script/13"><span>JavaScript语法（二）：你知道哪些JavaScript语句？</span></a></li><li><a href="/blog/重学前端/02.模块一java-script/14"><span>JavaScript语法（三）：什么是表达式语句？</span></a></li><li><a href="/blog/重学前端/02.模块一java-script/15"><span>JavaScript语法（四）：新加入的**运算符，哪里有些不一样呢？</span></a></li></ul></li><li><a href="/blog/重学前端/03.模块二html和css">03.模块二HTML和CSS</a><ul><li><a href="/blog/重学前端/03.模块二html和css/01"><span>HTML语义：div和span不是够用了吗？</span></a></li><li><a href="/blog/重学前端/03.模块二html和css/02"><span>HTML语义：如何运用语义类标签来呈现Wiki网页？</span></a></li><li><a href="/blog/重学前端/03.模块二html和css/03"><span>CSS语法：除了属性和选择器，你还需要知道这些带@的规则</span></a></li><li><a href="/blog/重学前端/03.模块二html和css/04"><span>HTML元信息类标签：你知道head里一共能写哪几种标签吗？</span></a></li><li><a href="/blog/重学前端/03.模块二html和css/05"><span>CSS 选择器：如何选中svg里的a元素？</span></a></li><li><a href="/blog/重学前端/03.模块二html和css/06"><span>CSS选择器：伪元素是怎么回事儿？</span></a></li><li><a href="/blog/重学前端/03.模块二html和css/07"><span>HTML链接：除了a标签，还有哪些标签叫链接？</span></a></li><li><a href="/blog/重学前端/03.模块二html和css/08"><span>CSS排版：从毕升开始，我们就开始用正常流了</span></a></li><li><a href="/blog/重学前端/03.模块二html和css/09"><span>HTML替换型元素：为什么link一个CSS要用href，而引入js要用src呢？</span></a></li><li><a href="/blog/重学前端/03.模块二html和css/10"><span>HTML小实验：用代码分析HTML标准</span></a></li><li><a href="/blog/重学前端/03.模块二html和css/11"><span>CSS Flex排版：为什么垂直居中这么难？</span></a></li><li><a href="/blog/重学前端/03.模块二html和css/12"><span>CSS动画与交互：为什么动画要用贝塞尔曲线这么奇怪的东西？</span></a></li><li><a href="/blog/重学前端/03.模块二html和css/13"><span>HTML语言：DTD到底是什么？</span></a></li><li><a href="/blog/重学前端/03.模块二html和css/14"><span>CSS渲染：CSS是如何绘制颜色的？</span></a></li><li><a href="/blog/重学前端/03.模块二html和css/15"><span>CSS小实验：动手做，用代码挖掘CSS属性</span></a></li><li><a href="/blog/重学前端/03.模块二html和css/16"><span>HTML·ARIA：可访问性是只给盲人用的特性么？</span></a></li></ul></li><li><a href="/blog/重学前端/04.模块三浏览器实现原理与api">04.模块三浏览器实现原理与API</a><ul><li><a href="/blog/重学前端/04.模块三浏览器实现原理与api/01"><span>浏览器：一个浏览器是如何工作的？（阶段一）</span></a></li><li><a href="/blog/重学前端/04.模块三浏览器实现原理与api/02"><span>浏览器：一个浏览器是如何工作的？（阶段二）</span></a></li><li><a href="/blog/重学前端/04.模块三浏览器实现原理与api/03"><span>浏览器：一个浏览器是如何工作的（阶段三）</span></a></li><li><a href="/blog/重学前端/04.模块三浏览器实现原理与api/04"><span>浏览器：一个浏览器是如何工作的？（阶段四）</span></a></li><li><a href="/blog/重学前端/04.模块三浏览器实现原理与api/05"><span>浏览器：一个浏览器是如何工作的？（阶段五）</span></a></li><li><a href="/blog/重学前端/04.模块三浏览器实现原理与api/06"><span>浏览器DOM：你知道HTML的节点有哪几种吗？</span></a></li><li><a href="/blog/重学前端/04.模块三浏览器实现原理与api/07"><span>浏览器CSSOM：如何获取一个元素的准确位置</span></a></li><li><a href="/blog/重学前端/04.模块三浏览器实现原理与api/08"><span>浏览器事件：为什么会有捕获过程和冒泡过程？</span></a></li><li><a href="/blog/重学前端/04.模块三浏览器实现原理与api/09"><span>浏览器API（小实验）：动手整理全部API</span></a></li></ul></li><li><a href="/blog/重学前端/05.模块四前端综合应用">05.模块四前端综合应用</a><ul><li><a href="/blog/重学前端/05.模块四前端综合应用/01"><span>性能：前端的性能到底对业务数据有多大的影响？</span></a></li><li><a href="/blog/重学前端/05.模块四前端综合应用/02"><span>工具链：什么样的工具链才能提升团队效率？</span></a></li><li><a href="/blog/重学前端/05.模块四前端综合应用/03"><span>持续集成：几十个前端一起工作，如何保证工作质量？</span></a></li><li><a href="/blog/重学前端/05.模块四前端综合应用/04"><span>搭建系统：大量的低价值需求应该如何应对？</span></a></li><li><a href="/blog/重学前端/05.模块四前端综合应用/05"><span>前端架构：前端架构有哪些核心问题？</span></a></li></ul></li><li><a href="/blog/重学前端/06.特别加餐">06.特别加餐</a><ul><li><a href="/blog/重学前端/06.特别加餐/01"><span>新年彩蛋 | 2019，有哪些前端技术值得关注？</span></a></li><li><a href="/blog/重学前端/06.特别加餐/02"><span>用户故事 | 那些你与“重学前端”的不解之缘</span></a></li><li><a href="/blog/重学前端/06.特别加餐/03"><span>期中答疑 | name(){}与name: function() {}，两种写法有什么区别吗？</span></a></li><li><a href="/blog/重学前端/06.特别加餐/04"><span>答疑加餐 | 学了这么多前端的“小众”知识，到底对我有什么帮助？</span></a></li><li><a href="/blog/重学前端/06.特别加餐/05"><span>加餐 | 前端与图形学</span></a></li><li><a href="/blog/重学前端/06.特别加餐/06"><span>加餐 | 前端交互基础设施的建设</span></a></li><li><a href="/blog/重学前端/06.特别加餐/07"><span>期末答疑（一）：前端代码单元测试怎么做？</span></a></li><li><a href="/blog/重学前端/06.特别加餐/08"><span>期末答疑（二）：前端架构中，每个逻辑页面如何可以做到独立发布呢？</span></a></li><li><a href="/blog/重学前端/06.特别加餐/09"><span>加餐 | 一个前端工程师到底需要掌握哪些技能？</span></a></li><li><a href="/blog/重学前端/06.特别加餐/10"><span>免费学习 | 手把手带你实现一个极简的 React 框架</span></a></li></ul></li><li><a href="/blog/重学前端/07.尾声">07.尾声</a><ul><li><a href="/blog/重学前端/07.尾声/01"><span>尾声 | 长风破浪会有时，直挂云帆济沧海</span></a></li></ul></li><li><a href="/blog/重学前端/summary">重学前端</a></li></ul></div></div><ul role="slug-list" class="__dumi-default-layout-toc"><li title="语句块" data-depth="2"><a href="/blog/重学前端/02.模块一java-script/13#语句块"><span>语句块</span></a></li><li title="空语句" data-depth="2"><a href="/blog/重学前端/02.模块一java-script/13#空语句"><span>空语句</span></a></li><li title="if语句" data-depth="2"><a href="/blog/重学前端/02.模块一java-script/13#if语句"><span>if语句</span></a></li><li title="switch语句" data-depth="2"><a href="/blog/重学前端/02.模块一java-script/13#switch语句"><span>switch语句</span></a></li><li title="循环语句" data-depth="2"><a href="/blog/重学前端/02.模块一java-script/13#循环语句"><span>循环语句</span></a></li><li title="while循环和do while循环" data-depth="3"><a href="/blog/重学前端/02.模块一java-script/13#while循环和do-while循环"><span>while循环和do while循环</span></a></li><li title="普通for循环" data-depth="3"><a href="/blog/重学前端/02.模块一java-script/13#普通for循环"><span>普通for循环</span></a></li><li title="for in循环" data-depth="3"><a href="/blog/重学前端/02.模块一java-script/13#for-in循环"><span>for in循环</span></a></li><li title="for of循环和for await of循环" data-depth="3"><a href="/blog/重学前端/02.模块一java-script/13#for-of循环和for-await-of循环"><span>for of循环和for await of循环</span></a></li><li title="return" data-depth="2"><a href="/blog/重学前端/02.模块一java-script/13#return"><span>return</span></a></li><li title="break语句和continue语句" data-depth="2"><a href="/blog/重学前端/02.模块一java-script/13#break语句和continue语句"><span>break语句和continue语句</span></a></li><li title="with语句" data-depth="2"><a href="/blog/重学前端/02.模块一java-script/13#with语句"><span>with语句</span></a></li><li title="try语句和throw语句" data-depth="2"><a href="/blog/重学前端/02.模块一java-script/13#try语句和throw语句"><span>try语句和throw语句</span></a></li><li title="debugger语句" data-depth="2"><a href="/blog/重学前端/02.模块一java-script/13#debugger语句"><span>debugger语句</span></a></li><li title="var" data-depth="2"><a href="/blog/重学前端/02.模块一java-script/13#var"><span>var</span></a></li><li title="let和const" data-depth="2"><a href="/blog/重学前端/02.模块一java-script/13#let和const"><span>let和const</span></a></li><li title="class声明" data-depth="2"><a href="/blog/重学前端/02.模块一java-script/13#class声明"><span>class声明</span></a></li><li title="函数声明" data-depth="2"><a href="/blog/重学前端/02.模块一java-script/13#函数声明"><span>函数声明</span></a></li><li title="结语" data-depth="2"><a href="/blog/重学前端/02.模块一java-script/13#结语"><span>结语</span></a></li></ul><div class="__dumi-default-layout-content"><div class="markdown"><h1 id="javascript语法二你知道哪些javascript语句"><a aria-hidden="true" tabindex="-1" href="/blog/重学前端/02.模块一java-script/13#javascript语法二你知道哪些javascript语句"><span class="icon icon-link"></span></a>JavaScript语法（二）：你知道哪些JavaScript语句？</h1><p>你好，我是winter。</p><p>我们在上一节课中已经讲过了JavaScript语法的顶层设计，接下来我们进入到更具体的内容。</p><p>JavaScript遵循了一般编程语言的“语句-表达式”结构，多数编程语言都是这样设计的。我们在上节课讲的脚本，或者模块都是由语句列表构成的，这一节课，我们就来一起了解一下语句。</p><p>在JavaScript标准中，把语句分成了两种：声明和语句，不过，这里的区分逻辑比较奇怪，所以，这里我还是按照自己的思路给你整理一下。</p><p>普通语句：</p><p><img src="https://static001.geekbang.org/resource/image/81/55/8186219674547691cf59e5c095304d55.png" alt=""/></p><p>声明型语句：</p><p><img src="https://static001.geekbang.org/resource/image/0e/38/0e5327528df12d1eaad52c4005efff38.jpg" alt=""/></p><p>我们根据上面的分类，来遍历学习一下这些语句。</p><h2 id="语句块"><a aria-hidden="true" tabindex="-1" href="/blog/重学前端/02.模块一java-script/13#语句块"><span class="icon icon-link"></span></a>语句块</h2><p>我们可以这样去简单理解，语句块就是一对大括号。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">{</span></div><div class="token-line"><span class="token plain">        var x, y;</span></div><div class="token-line"><span class="token plain">        x = 10;</span></div><div class="token-line"><span class="token plain">        y = 20;</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>语句块的意义和好处在于：让我们可以把多行语句视为同一行语句，这样，if、for等语句定义起来就比较简单了。不过，我们需要注意的是，语句块会产生作用域，我们看一个例子：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">{</span></div><div class="token-line"><span class="token plain">        let x = 1;</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    console.log(x); // 报错</span></div></pre></div><p>这里我们的let声明，仅仅对语句块作用域生效，于是我们在语句块外试图访问语句块内的变量x就会报错。</p><h2 id="空语句"><a aria-hidden="true" tabindex="-1" href="/blog/重学前端/02.模块一java-script/13#空语句"><span class="icon icon-link"></span></a>空语句</h2><p>空语句就是一个独立的分号，实际上没什么大用。我们来看一下：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">;</span></div></pre></div><p>空语句的存在仅仅是从语言设计完备性的角度考虑，允许插入多个分号而不抛出错误。</p><h2 id="if语句"><a aria-hidden="true" tabindex="-1" href="/blog/重学前端/02.模块一java-script/13#if语句"><span class="icon icon-link"></span></a>if语句</h2><p>if语句是条件语句。我想，对多数人来说，if语句都是熟悉的老朋友了，也没有什么特别需要注意的用法，但是为了我们课程的完备性，这里还是要讲一下。</p><p>if语句示例如下：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">if(a &lt; b)</span></div><div class="token-line"><span class="token plain">        console.log(a);</span></div></pre></div><p>if语句的作用是，在满足条件时执行它的内容语句，这个语句可以是一个语句块，这样就可以实现有条件地执行多个语句了。</p><p>if语句还有else结构，用于不满足条件时执行，一种常见的用法是，利用语句的嵌套能力，把if和else连写成多分支条件判断：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">if(a &lt; 10) {</span></div><div class="token-line"><span class="token plain">        //...</span></div><div class="token-line"><span class="token plain">    } else if(a &lt; 20) {</span></div><div class="token-line"><span class="token plain">        //...</span></div><div class="token-line"><span class="token plain">    } else if(a &lt; 30) {</span></div><div class="token-line"><span class="token plain">        //...</span></div><div class="token-line"><span class="token plain">    } else {</span></div><div class="token-line"><span class="token plain">        //...</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>这段代码表示四个互斥的分支，分别在满足a&lt;10、a&lt;20、a&lt;30和其它情况时执行。</p><h2 id="switch语句"><a aria-hidden="true" tabindex="-1" href="/blog/重学前端/02.模块一java-script/13#switch语句"><span class="icon icon-link"></span></a>switch语句</h2><p>switch语句继承自Java，Java中的switch语句继承自C和C++，原本switch语句是跳转的变形，所以我们如果要用它来实现分支，必须要加上break。</p><p>其实switch原本的设计是类似goto的思维。我们看一个例子：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">switch(num) {</span></div><div class="token-line"><span class="token plain">    case 1:</span></div><div class="token-line"><span class="token plain">        print(1);</span></div><div class="token-line"><span class="token plain">    case 2:</span></div><div class="token-line"><span class="token plain">        print 2;</span></div><div class="token-line"><span class="token plain">    case 3:</span></div><div class="token-line"><span class="token plain">        print 3;</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>这段代码当num为1时输出1 2 3，当num为2时输出2 3，当num为3时输出3。如果我们要把它变成分支型，则需要在每个case后加上break。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">switch(num) {</span></div><div class="token-line"><span class="token plain">    case 1:</span></div><div class="token-line"><span class="token plain">        print 1;</span></div><div class="token-line"><span class="token plain">        break;</span></div><div class="token-line"><span class="token plain">    case 2:</span></div><div class="token-line"><span class="token plain">        print 2;</span></div><div class="token-line"><span class="token plain">        break;</span></div><div class="token-line"><span class="token plain">    case 3:</span></div><div class="token-line"><span class="token plain">        print 3;</span></div><div class="token-line"><span class="token plain">        break;</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>在C时代，switch生成的汇编代码性能是略优于if else的，但是对JavaScript来说，则无本质区别。我个人的看法是，现在switch已经完全没有必要使用了，应该用if else结构代替。</p><h2 id="循环语句"><a aria-hidden="true" tabindex="-1" href="/blog/重学前端/02.模块一java-script/13#循环语句"><span class="icon icon-link"></span></a>循环语句</h2><p>循环语句应该也是你所熟悉的语句了，这里我们把重点放在一些新用法上。</p><h3 id="while循环和do-while循环"><a aria-hidden="true" tabindex="-1" href="/blog/重学前端/02.模块一java-script/13#while循环和do-while循环"><span class="icon icon-link"></span></a>while循环和do while循环</h3><p>这两个都是历史悠久的JavaScript语法了，示例大概如下：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">let a = 100</span></div><div class="token-line"><span class="token plain">    while(a--) {</span></div><div class="token-line"><span class="token plain">        console.log(&quot;*&quot;);</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">let a = 101;</span></div><div class="token-line"><span class="token plain">    do {</span></div><div class="token-line"><span class="token plain">        console.log(a);</span></div><div class="token-line"><span class="token plain">    } while(a &lt; 100)</span></div></pre></div><p>注意，这里do while循环无论如何至少会执行一次。</p><h3 id="普通for循环"><a aria-hidden="true" tabindex="-1" href="/blog/重学前端/02.模块一java-script/13#普通for循环"><span class="icon icon-link"></span></a>普通for循环</h3><p>首先我们来看看普通的for循环。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">for(i = 0; i &lt; 100; i++)</span></div><div class="token-line"><span class="token plain">        console.log(i);</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    for(var i = 0; i &lt; 100; i++)</span></div><div class="token-line"><span class="token plain">        console.log(i);</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    for(let i = 0; i &lt; 100; i++)</span></div><div class="token-line"><span class="token plain">        console.log(i);</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    var j = 0;</span></div><div class="token-line"><span class="token plain">    for(const i = 0; j &lt; 100; j++)</span></div><div class="token-line"><span class="token plain">        console.log(i);</span></div></pre></div><p>这里为了配合新语法，加入了允许let和const，实际上，const在这里是非常奇葩的东西，因为这里声明和初始化的变量，按惯例是用于控制循环的，但是它如果是const就没法改了。</p><p>我想，这一点可能是从保持let和const一致性的角度考虑的吧。</p><h3 id="for-in循环"><a aria-hidden="true" tabindex="-1" href="/blog/重学前端/02.模块一java-script/13#for-in循环"><span class="icon icon-link"></span></a>for in循环</h3><p>for in 循环枚举对象的属性，这里体现了属性的enumerable特征。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">let o = { a: 10, b: 20}</span></div><div class="token-line"><span class="token plain">    Object.defineProperty(o, &quot;c&quot;, {enumerable:false, value:30})</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    for(let p in o)</span></div><div class="token-line"><span class="token plain">        console.log(p);</span></div></pre></div><p>这段代码中，我们定义了一个对象o，给它添加了不可枚举的属性c，之后我们用for in循环枚举它的属性，我们会发现，输出时得到的只有a和b。</p><p>如果我们定义c这个属性时，enumerable为true，则for in循环中也能枚举到它。</p><h3 id="for-of循环和for-await-of循环"><a aria-hidden="true" tabindex="-1" href="/blog/重学前端/02.模块一java-script/13#for-of循环和for-await-of循环"><span class="icon icon-link"></span></a>for of循环和for await of循环</h3><p>for of循环是非常棒的语法特性。</p><p>我们先看下基本用法，它可以用于数组：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">for(let e of [1, 2, 3, 4, 5])</span></div><div class="token-line"><span class="token plain">        console.log(e);</span></div></pre></div><p>但是实际上，它背后的机制是iterator机制。</p><p>我们可以给任何一个对象添加iterator，使它可以用于for of语句，看下示例：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">let o = {  </span></div><div class="token-line"><span class="token plain">        [Symbol.iterator]:() =&gt; ({</span></div><div class="token-line"><span class="token plain">            _value: 0,</span></div><div class="token-line"><span class="token plain">            next(){</span></div><div class="token-line"><span class="token plain">                if(this._value == 10)</span></div><div class="token-line"><span class="token plain">                    return {</span></div><div class="token-line"><span class="token plain">                        done: true</span></div><div class="token-line"><span class="token plain">                    }</span></div><div class="token-line"><span class="token plain">                else return {</span></div><div class="token-line"><span class="token plain">                    value: this._value++,</span></div><div class="token-line"><span class="token plain">                    done: false</span></div><div class="token-line"><span class="token plain">                };</span></div><div class="token-line"><span class="token plain">            }</span></div><div class="token-line"><span class="token plain">        })</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    for(let e of o)</span></div><div class="token-line"><span class="token plain">        console.log(e);</span></div></pre></div><p>这段代码展示了如何为一个对象添加iterator。但是，在实际操作中，我们一般不需要这样定义iterator，我们可以使用generator function。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">function* foo(){</span></div><div class="token-line"><span class="token plain">        yield 0;</span></div><div class="token-line"><span class="token plain">        yield 1;</span></div><div class="token-line"><span class="token plain">        yield 2;</span></div><div class="token-line"><span class="token plain">        yield 3;</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    for(let e of foo())</span></div><div class="token-line"><span class="token plain">        console.log(e);</span></div></pre></div><p>这段代码展示了generator function和foo的配合。</p><p>此外，JavaScript还为异步生成器函数配备了异步的for of，我们来看一个例子：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">function sleep(duration) {</span></div><div class="token-line"><span class="token plain">        return new Promise(function(resolve, reject) {</span></div><div class="token-line"><span class="token plain">            setTimeout(resolve,duration);</span></div><div class="token-line"><span class="token plain">        })</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    async function* foo(){</span></div><div class="token-line"><span class="token plain">        i = 0;</span></div><div class="token-line"><span class="token plain">        while(true) {</span></div><div class="token-line"><span class="token plain">            await sleep(1000);</span></div><div class="token-line"><span class="token plain">            yield i++;</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">            </span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    for await(let e of foo())</span></div><div class="token-line"><span class="token plain">        console.log(e);</span></div></pre></div><p>这段代码定义了一个异步生成器函数，异步生成器函数每隔一秒生成一个数字，这是一个无限的生成器。</p><p>接下来，我们使用for await of来访问这个异步生成器函数的结果，我们可以看到，这形成了一个每隔一秒打印一个数字的无限循环。</p><p>但是因为我们这个循环是异步的，并且有时间延迟，所以，这个无限循环的代码可以用于显示时钟等有意义的操作。</p><h2 id="return"><a aria-hidden="true" tabindex="-1" href="/blog/重学前端/02.模块一java-script/13#return"><span class="icon icon-link"></span></a>return</h2><p>return语句用于函数中，它终止函数的执行，并且指定函数的返回值，这是大家非常熟悉语句了，也没有什么特殊之处。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">function squre(x){</span></div><div class="token-line"><span class="token plain">        return x * x;</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>这段代码展示了return的基本用法。它后面可以跟一个表达式，计算结果就是函数返回值。</p><h2 id="break语句和continue语句"><a aria-hidden="true" tabindex="-1" href="/blog/重学前端/02.模块一java-script/13#break语句和continue语句"><span class="icon icon-link"></span></a>break语句和continue语句</h2><p>break语句用于跳出循环语句或者switch语句，continue语句用于结束本次循环并继续循环。</p><p>这两个语句都属于控制型语句，用法也比较相似，所以我们就一起讲了。需要注意的是，它们都有带标签的用法。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">outer:for(let i = 0; i &lt; 100; i++)</span></div><div class="token-line"><span class="token plain">        inner:for(let j = 0; j &lt; 100; j++)</span></div><div class="token-line"><span class="token plain">            if( i == 50 &amp;&amp; j == 50)</span></div><div class="token-line"><span class="token plain">                break outer;</span></div><div class="token-line"><span class="token plain">    outer:for(let i = 0; i &lt; 100; i++)</span></div><div class="token-line"><span class="token plain">        inner:for(let j = 0; j &lt; 100; j++)</span></div><div class="token-line"><span class="token plain">            if( i &gt;= 50 &amp;&amp; j == 50)</span></div><div class="token-line"><span class="token plain">                continue outer;</span></div></pre></div><p>带标签的break和continue可以控制自己被外层的哪个语句结构消费，这可以跳出复杂的语句结构。</p><h2 id="with语句"><a aria-hidden="true" tabindex="-1" href="/blog/重学前端/02.模块一java-script/13#with语句"><span class="icon icon-link"></span></a>with语句</h2><p>with语句是个非常巧妙的设计，但它把JavaScript的变量引用关系变得不可分析，所以一般都认为这种语句都属于糟粕。</p><p>但是历史无法改写，现在已经无法去除with了。我们来了解一下它的基本用法即可。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">let o = {a:1, b:2}</span></div><div class="token-line"><span class="token plain">    with(o){</span></div><div class="token-line"><span class="token plain">        console.log(a, b);</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>with语句把对象的属性在它内部的作用域内变成变量。</p><h2 id="try语句和throw语句"><a aria-hidden="true" tabindex="-1" href="/blog/重学前端/02.模块一java-script/13#try语句和throw语句"><span class="icon icon-link"></span></a>try语句和throw语句</h2><p>try语句和throw语句用于处理异常。它们是配合使用的，所以我们就放在一起讲了。在大型应用中，异常机制非常重要。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">try {</span></div><div class="token-line"><span class="token plain">        throw new Error(&quot;error&quot;);</span></div><div class="token-line"><span class="token plain">    } catch(e) {</span></div><div class="token-line"><span class="token plain">        console.log(e);</span></div><div class="token-line"><span class="token plain">    } finally {</span></div><div class="token-line"><span class="token plain">        console.log(&quot;finally&quot;);</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>一般来说，throw用于抛出异常，但是单纯从语言的角度，我们可以抛出任何值，也不一定是异常逻辑，但是为了保证语义清晰，不建议用throw表达任何非异常逻辑。</p><p>try语句用于捕获异常，用throw抛出的异常，可以在try语句的结构中被处理掉：try部分用于标识捕获异常的代码段，catch部分则用于捕获异常后做一些处理，而finally则是用于执行后做一些必须执行的清理工作。</p><p>catch结构会创建一个局部的作用域，并且把一个变量写入其中，需要注意，在这个作用域，不能再声明变量e了，否则会出错。</p><p>在catch中重新抛出错误的情况非常常见，在设计比较底层的函数时，常常会这样做，保证抛出的错误能被理解。</p><p>finally语句一般用于释放资源，它一定会被执行，我们在前面的课程中已经讨论过一些finally的特征，即使在try中出现了return，finally中的语句也一定要被执行。</p><h2 id="debugger语句"><a aria-hidden="true" tabindex="-1" href="/blog/重学前端/02.模块一java-script/13#debugger语句"><span class="icon icon-link"></span></a>debugger语句</h2><p>debugger语句的作用是：通知调试器在此断点。在没有调试器挂载时，它不产生任何效果。</p><p>介绍完普通语句，我们再来看看声明型语句。声明型语句跟普通语句最大区别就是声明型语句响应预处理过程，普通语句只有执行过程。</p><h2 id="var"><a aria-hidden="true" tabindex="-1" href="/blog/重学前端/02.模块一java-script/13#var"><span class="icon icon-link"></span></a>var</h2><p>var声明语句是古典的JavaScript中声明变量的方式。而现在，在绝大多数情况下，let和const都是更好的选择。</p><p>我们在上一节课已经讲解了var声明对全局作用域的影响，它是一种预处理机制。</p><p>如果我们仍然想要使用var，我的个人建议是，把它当做一种“保障变量是局部”的逻辑，遵循以下三条规则：</p><ul><li>声明同时必定初始化；</li><li>尽可能在离使用的位置近处声明；</li><li>不要在意重复声明。</li></ul><p>例如：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">var x = 1, y = 2;</span></div><div class="token-line"><span class="token plain">    doSth(x, y);</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    for(var x = 0; x &lt; 10; x++)</span></div><div class="token-line"><span class="token plain">        doSth2(x);</span></div></pre></div><p>这个例子中，两次声明了变量x，完成了两段逻辑，这两个x意义上可能不一定相关，这样，不论我们把代码复制粘贴在哪里，都不会出错。</p><p>当然，更好的办法是使用let改造，我们看看如何改造：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">{</span></div><div class="token-line"><span class="token plain">        let x = 1, y = 2;</span></div><div class="token-line"><span class="token plain">        doSth(x, y);</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    for(let x = 0; x &lt; 10; x++)</span></div><div class="token-line"><span class="token plain">        doSth2(x);</span></div></pre></div><p>这里我用代码块限制了第一个x的作用域，这样就更难发生变量命名冲突引起的错误了。</p><h2 id="let和const"><a aria-hidden="true" tabindex="-1" href="/blog/重学前端/02.模块一java-script/13#let和const"><span class="icon icon-link"></span></a>let和const</h2><p>let和const是都是变量的声明，它们的特性非常相似，所以我们放在一起讲了。let和const是新设计的语法，所以没有什么硬伤，非常地符合直觉。let和const的作用范围是if、for等结构型语句。</p><p>我们看下基本用法：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">const a = 2;</span></div><div class="token-line"><span class="token plain">    if(true){</span></div><div class="token-line"><span class="token plain">        const a = 1;</span></div><div class="token-line"><span class="token plain">        console.log(a);</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    console.log(a);</span></div></pre></div><p>这里的代码先在全局声明了变量a，接下来又在if内声明了a，if内构成了一个独立的作用域。</p><p>const和let语句在重复声明时会抛错，这能够有效地避免变量名无意中冲突：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">let a = 2</span></div><div class="token-line"><span class="token plain">    const a = 1;</span></div></pre></div><p>这段代码中，先用let声明了a，接下来又试图使用const声明变量a，这时，就会产生错误。</p><p>let和const声明虽然看上去是执行到了才会生效，但是实际上，它们还是会被预处理。如果当前作用域内有声明，就无法访问到外部的变量。我们来看这段代码：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">const a = 2;</span></div><div class="token-line"><span class="token plain">    if(true){</span></div><div class="token-line"><span class="token plain">        console.log(a); //抛错</span></div><div class="token-line"><span class="token plain">        const a = 1;   </span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>这里在if的作用域中，变量a声明执行到之前，我们访问了变量a，这时会抛出一个错误，这说明const声明仍然是有预处理机制的。</p><p>在执行到const语句前，我们的JavaScript引擎就已经知道后面的代码将会声明变量a，从而不允许我们访问外层作用域中的a。</p><h2 id="class声明"><a aria-hidden="true" tabindex="-1" href="/blog/重学前端/02.模块一java-script/13#class声明"><span class="icon icon-link"></span></a>class声明</h2><p>我们在之前的课程中，已经了解过class相关的用法。这里我们再从语法的角度来看一遍：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">class a {</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>class最基本的用法只需要class关键字、名称和一对大括号。它的声明特征跟const和let类似，都是作用于块级作用域，预处理阶段则会屏蔽外部变量。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">const a = 2;</span></div><div class="token-line"><span class="token plain">    if(true){</span></div><div class="token-line"><span class="token plain">        console.log(a); //抛错</span></div><div class="token-line"><span class="token plain">        class a {</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>class内部，可以使用constructor关键字来定义构造函数。还能定义getter/setter和方法。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">class Rectangle {</span></div><div class="token-line"><span class="token plain">      constructor(height, width) {</span></div><div class="token-line"><span class="token plain">        this.height = height;</span></div><div class="token-line"><span class="token plain">        this.width = width;</span></div><div class="token-line"><span class="token plain">      }</span></div><div class="token-line"><span class="token plain">      // Getter</span></div><div class="token-line"><span class="token plain">      get area() {</span></div><div class="token-line"><span class="token plain">        return this.calcArea();</span></div><div class="token-line"><span class="token plain">      }</span></div><div class="token-line"><span class="token plain">      // Method</span></div><div class="token-line"><span class="token plain">      calcArea() {</span></div><div class="token-line"><span class="token plain">        return this.height * this.width;</span></div><div class="token-line"><span class="token plain">      }</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>这个例子来自MDN，它展示了构造函数、getter和方法的定义。</p><p>以目前的兼容性，class中的属性只能写在构造函数中，相关标准正在TC39讨论。</p><p>需要注意，class默认内部的函数定义都是strict模式的。</p><h2 id="函数声明"><a aria-hidden="true" tabindex="-1" href="/blog/重学前端/02.模块一java-script/13#函数声明"><span class="icon icon-link"></span></a>函数声明</h2><p>函数声明使用 function 关键字。</p><p>在上一节课中，我们已经讨论过函数声明对全局作用域的影响了。这一节课，我们来看看函数声明具体的内容，我们先看一下函数声明的几种类型。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">function foo(){</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    function* foo(){</span></div><div class="token-line"><span class="token plain">        yield 1;</span></div><div class="token-line"><span class="token plain">        yield 2;</span></div><div class="token-line"><span class="token plain">        yield 3;</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    async function foo(){</span></div><div class="token-line"><span class="token plain">        await sleep(3000);</span></div><div class="token-line"><span class="token plain">        </span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    async function* foo(){</span></div><div class="token-line"><span class="token plain">        await sleep(3000);</span></div><div class="token-line"><span class="token plain">        yield 1;</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>带*的函数是generator，我们在前面的部分已经见过它了。生成器函数可以理解为返回一个序列的函数，它的底层是iterator机制。</p><p>async函数是可以暂停执行，等待异步操作的函数，它的底层是Promise机制。异步生成器函数则是二者的结合。</p><p>函数的参数，可以只写形参名，现在还可以写默认参数和指定多个参数，看下例子：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">function foo(a = 1, ...other) {</span></div><div class="token-line"><span class="token plain">        console.log(a, other)</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>这个形式可以代替一些对参数的处理代码，表意会更加清楚。</p><h2 id="结语"><a aria-hidden="true" tabindex="-1" href="/blog/重学前端/02.模块一java-script/13#结语"><span class="icon icon-link"></span></a>结语</h2><p>今天我们一起学习了语句家族，语句分成了普通语句和声明型语句。</p><p>普通语句部分，建议你把重点放在循环语句上面。声明型语句我觉得都很重要，尤其是它们的行为。熟练掌握了它们，我们就可以在工作中去综合运用它们，从而减少代码中的错误。新特性大多可以帮助我们发现代码中的错误。</p><p>最后留一个小作业，请你找出所有具有Symbol.iterator的原生对象，并且看看它们的for of遍历行为。</p></div><div class="__dumi-default-layout-footer-meta"><a target="_blank" rel="noopener noreferrer" href="https://github.com/GGwujun/blog/edit/master/docs/重学前端/02.模块一JavaScript/13.md">在 GitHub 上编辑此页<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a><span data-updated-text="最后更新时间：">5/2/2022 10:56:48</span></div></div></div></div>
	<script>
  window.g_useSSR = true;
  window.g_initialProps = {};
	</script>

    <script>
      (function () {
        if (!location.port) {
          (function (i, s, o, g, r, a, m) {
            i["GoogleAnalyticsObject"] = r;
            (i[r] =
              i[r] ||
              function () {
                (i[r].q = i[r].q || []).push(arguments);
              }),
              (i[r].l = 1 * new Date());
            (a = s.createElement(o)), (m = s.getElementsByTagName(o)[0]);
            a.async = 1;
            a.src = g;
            m.parentNode.insertBefore(a, m);
          })(
            window,
            document,
            "script",
            "//www.google-analytics.com/analytics.js",
            "ga"
          );
          ga("create", "UA-149864185-1", "auto");
          ga("send", "pageview");
        }
      })();
    </script>
    <script src="/blog/umi.js"></script>
  </body>
</html>
