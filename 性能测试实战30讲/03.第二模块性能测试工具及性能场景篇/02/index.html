<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no"
    />
    <link rel="shortcut icon" type="image/x-icon" href="/logo.png" />
    <link rel="stylesheet" href="/blog/umi.css" />
    <script>
      window.routerBase = "/blog";
    </script>
    <script>
      //! umi version: 3.5.17
    </script>
    <script>
      !(function () {
        var e = localStorage.getItem("dumi:prefers-color"),
          t = window.matchMedia("(prefers-color-scheme: dark)").matches,
          r = ["light", "dark", "auto"];
        document.documentElement.setAttribute(
          "data-prefers-color",
          e === r[2] ? (t ? r[1] : r[0]) : r.indexOf(e) > -1 ? e : r[0]
        );
      })();
    </script>
    <title>08丨案例： 手把手教你编写最简单的性能脚本</title>
  </head>
  <body>
    <div id="root"><div class="__dumi-default-layout" data-route="/性能测试实战30讲/03.第二模块性能测试工具及性能场景篇/02" data-show-sidemenu="true" data-show-slugs="true" data-site-mode="true" data-gapless="false"><div class="__dumi-default-navbar" data-mode="site"><button class="__dumi-default-navbar-toggle"></button><a class="__dumi-default-navbar-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog/">大师兄</a><nav><div class="__dumi-default-search"><input type="search" class="__dumi-default-search-input" value=""/><ul></ul></div><span>计算机基础<ul><li><a href="/blog/编译原理之美">编译原理之美</a></li><li><a href="/blog/编译原理实战">编译原理实战</a></li><li><a href="/blog/深入浅出计算机组成原理">深入浅出计算机组成原理</a></li><li><a href="/blog/详解http">详解http</a></li><li><a href="/blog/计算机网络通关29讲">计算机网络通关29讲</a></li><li><a href="/blog/网络排查案例课">网络排查案例课</a></li><li><a href="/blog/linux操作系统">linux操作系统</a></li><li><a href="/blog/linux性能优化实战">linux性能优化实战</a></li><li><a href="/blog/程序员数学基础">程序员数学基础</a></li><li><a href="/blog/趣谈网络协议">趣谈网络协议</a></li><li><a href="/blog/操作系统实战">操作系统实战</a></li><li><a href="/blog/软件工程之美">软件工程之美</a></li><li><a href="/blog/sql必知必会">sql必知必会</a></li><li><a href="/blog/操作系统实战45讲">操作系统实战45讲</a></li><li><a href="/blog/网络编程实战">网络编程实战</a></li></ul></span><span>算法<ul><li><a href="/blog/常用算法25讲">常用算法25讲</a></li><li><a href="/blog/数据结构与算法之美">数据结构与算法之美</a></li><li><a href="/blog/业务开发算法50讲">业务开发算法50讲</a></li><li><a href="/blog/动态规划面试宝典">动态规划面试宝典</a></li></ul></span><span>前端开发<ul><li><a href="/blog/浏览器工作原理与实践">浏览器工作原理与实践</a></li><li><a href="/blog/新时代产品经理进阶之路">新时代产品经理进阶之路</a></li><li><a href="/blog/全栈工程师修炼指南">全栈工程师修炼指南</a></li><li><a href="/blog/flutter核心技术与实战">flutter核心技术与实战</a></li><li><a href="/blog/java-script核心原理解析">java-script核心原理解析</a></li><li><a href="/blog/说透低代码">说透低代码</a></li><li><a href="/blog/nodejs应用开发实战">nodejs应用开发实战</a></li><li><a href="/blog/反爬虫兵法演绎20讲">反爬虫兵法演绎20讲</a></li><li><a href="/blog/reactnative新架构实战课">reactnative新架构实战课</a></li><li><a href="/blog/正则表达式入门">正则表达式入门</a></li><li><a href="/blog/重学前端">重学前端</a></li><li><a href="/blog/serverless入门课">serverless入门课</a></li><li><a href="/blog/type-script入门实战笔记">type-script入门实战笔记</a></li><li><a href="/blog/图解googlev8">图解googlev8</a></li><li><a href="/blog/vue3源码分析">vue3源码分析</a></li><li><a href="/blog/玩转Vue3全家桶">玩转Vue3全家桶</a></li><li><a href="/blog/webassembly入门">webassembly入门</a></li><li><a href="/blog/手把手带你写一个Web框架">手把手带你写一个Web框架</a></li><li><a href="/blog/web漏洞挖掘实战">web漏洞挖掘实战</a></li><li><a href="/blog/跟月影学可视化">跟月影学可视化</a></li><li><a href="/blog/搞定音频技术">搞定音频技术</a></li><li><a href="/blog/攻克视频技术">攻克视频技术</a></li></ul></span><span>前端工程化<ul><li><a href="/blog/logger">logger</a></li><li><a href="/blog/webpack">webpack</a></li><li><a href="/blog/webpackChain">webpackChain</a></li></ul></span><span>前端性能优化<ul><li><a href="/blog/react性能调优">react性能调优</a></li></ul></span><span>软件测试<ul><li><a href="/blog/全链路压测实战30讲">全链路压测实战30讲</a></li><li><a aria-current="page" class="active" href="/blog/性能测试实战30讲">性能测试实战30讲</a></li><li><a href="/blog/自动化测试高手课">自动化测试高手课</a></li><li><a href="/blog/软件测试52讲">软件测试52讲</a></li></ul></span><span>面试<ul><li><a href="/blog/面试现场">面试现场</a></li></ul></span><span>杂谈<ul><li><a href="/blog/超级访谈对话张雪峰">超级访谈对话张雪峰</a></li><li><a href="/blog/Git实战手册">Git实战手册</a></li><li><a href="/blog/NodeJS">NodeJS</a></li><li><a href="/blog/ReactJS">ReactJS</a></li><li><a href="/blog/UI设计">UI设计</a></li><li><a href="/blog/webpack4系列教程">webpack4系列教程</a></li><li><a href="/blog/前端知识体系">前端知识体系</a></li><li><a href="/blog/剑指offer刷题笔记">剑指offer刷题笔记</a></li><li><a href="/blog/思考与成长">思考与成长</a></li><li><a href="/blog/设计模式手册">设计模式手册</a></li></ul></span><div class="__dumi-default-navbar-tool"><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "></div></div></div></nav></div><div class="__dumi-default-menu" data-mode="site"><div class="__dumi-default-menu-inner"><div class="__dumi-default-menu-header"><a class="__dumi-default-menu-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog/"></a><h1>大师兄</h1><p></p></div><div class="__dumi-default-menu-mobile-area"><ul class="__dumi-default-menu-nav-list"><li>计算机基础<ul><li><a href="/blog/编译原理之美">编译原理之美</a></li><li><a href="/blog/编译原理实战">编译原理实战</a></li><li><a href="/blog/深入浅出计算机组成原理">深入浅出计算机组成原理</a></li><li><a href="/blog/详解http">详解http</a></li><li><a href="/blog/计算机网络通关29讲">计算机网络通关29讲</a></li><li><a href="/blog/网络排查案例课">网络排查案例课</a></li><li><a href="/blog/linux操作系统">linux操作系统</a></li><li><a href="/blog/linux性能优化实战">linux性能优化实战</a></li><li><a href="/blog/程序员数学基础">程序员数学基础</a></li><li><a href="/blog/趣谈网络协议">趣谈网络协议</a></li><li><a href="/blog/操作系统实战">操作系统实战</a></li><li><a href="/blog/软件工程之美">软件工程之美</a></li><li><a href="/blog/sql必知必会">sql必知必会</a></li><li><a href="/blog/操作系统实战45讲">操作系统实战45讲</a></li><li><a href="/blog/网络编程实战">网络编程实战</a></li></ul></li><li>算法<ul><li><a href="/blog/常用算法25讲">常用算法25讲</a></li><li><a href="/blog/数据结构与算法之美">数据结构与算法之美</a></li><li><a href="/blog/业务开发算法50讲">业务开发算法50讲</a></li><li><a href="/blog/动态规划面试宝典">动态规划面试宝典</a></li></ul></li><li>前端开发<ul><li><a href="/blog/浏览器工作原理与实践">浏览器工作原理与实践</a></li><li><a href="/blog/新时代产品经理进阶之路">新时代产品经理进阶之路</a></li><li><a href="/blog/全栈工程师修炼指南">全栈工程师修炼指南</a></li><li><a href="/blog/flutter核心技术与实战">flutter核心技术与实战</a></li><li><a href="/blog/java-script核心原理解析">java-script核心原理解析</a></li><li><a href="/blog/说透低代码">说透低代码</a></li><li><a href="/blog/nodejs应用开发实战">nodejs应用开发实战</a></li><li><a href="/blog/反爬虫兵法演绎20讲">反爬虫兵法演绎20讲</a></li><li><a href="/blog/reactnative新架构实战课">reactnative新架构实战课</a></li><li><a href="/blog/正则表达式入门">正则表达式入门</a></li><li><a href="/blog/重学前端">重学前端</a></li><li><a href="/blog/serverless入门课">serverless入门课</a></li><li><a href="/blog/type-script入门实战笔记">type-script入门实战笔记</a></li><li><a href="/blog/图解googlev8">图解googlev8</a></li><li><a href="/blog/vue3源码分析">vue3源码分析</a></li><li><a href="/blog/玩转Vue3全家桶">玩转Vue3全家桶</a></li><li><a href="/blog/webassembly入门">webassembly入门</a></li><li><a href="/blog/手把手带你写一个Web框架">手把手带你写一个Web框架</a></li><li><a href="/blog/web漏洞挖掘实战">web漏洞挖掘实战</a></li><li><a href="/blog/跟月影学可视化">跟月影学可视化</a></li><li><a href="/blog/搞定音频技术">搞定音频技术</a></li><li><a href="/blog/攻克视频技术">攻克视频技术</a></li></ul></li><li>前端工程化<ul><li><a href="/blog/logger">logger</a></li><li><a href="/blog/webpack">webpack</a></li><li><a href="/blog/webpackChain">webpackChain</a></li></ul></li><li>前端性能优化<ul><li><a href="/blog/react性能调优">react性能调优</a></li></ul></li><li>软件测试<ul><li><a href="/blog/全链路压测实战30讲">全链路压测实战30讲</a></li><li><a aria-current="page" class="active" href="/blog/性能测试实战30讲">性能测试实战30讲</a></li><li><a href="/blog/自动化测试高手课">自动化测试高手课</a></li><li><a href="/blog/软件测试52讲">软件测试52讲</a></li></ul></li><li>面试<ul><li><a href="/blog/面试现场">面试现场</a></li></ul></li><li>杂谈<ul><li><a href="/blog/超级访谈对话张雪峰">超级访谈对话张雪峰</a></li><li><a href="/blog/Git实战手册">Git实战手册</a></li><li><a href="/blog/NodeJS">NodeJS</a></li><li><a href="/blog/ReactJS">ReactJS</a></li><li><a href="/blog/UI设计">UI设计</a></li><li><a href="/blog/webpack4系列教程">webpack4系列教程</a></li><li><a href="/blog/前端知识体系">前端知识体系</a></li><li><a href="/blog/剑指offer刷题笔记">剑指offer刷题笔记</a></li><li><a href="/blog/思考与成长">思考与成长</a></li><li><a href="/blog/设计模式手册">设计模式手册</a></li></ul></li></ul><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "><button title="Dark theme" class="__dumi-default-dark-moon "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="3854" width="22" height="22"><path d="M991.816611 674.909091a69.166545 69.166545 0 0 0-51.665455-23.272727 70.795636 70.795636 0 0 0-27.438545 5.585454A415.674182 415.674182 0 0 1 754.993338 698.181818c-209.594182 0-393.472-184.785455-393.472-395.636363 0-52.363636 38.539636-119.621818 69.515637-173.614546 4.887273-8.610909 9.634909-16.756364 14.103272-24.901818A69.818182 69.818182 0 0 0 384.631156 0a70.842182 70.842182 0 0 0-27.438545 5.585455C161.678429 90.298182 14.362065 307.898182 14.362065 512c0 282.298182 238.824727 512 532.38691 512a522.286545 522.286545 0 0 0 453.957818-268.334545A69.818182 69.818182 0 0 0 991.816611 674.909091zM546.679156 954.181818c-248.785455 0-462.941091-192-462.941091-442.181818 0-186.647273 140.637091-372.829091 300.939637-442.181818-36.817455 65.629091-92.578909 151.970909-92.578909 232.727273 0 250.181818 214.109091 465.454545 462.917818 465.454545a488.331636 488.331636 0 0 0 185.181091-46.545455 453.003636 453.003636 0 0 1-393.565091 232.727273z m103.656728-669.323636l-14.266182 83.781818a34.909091 34.909091 0 0 0 50.362182 36.770909l74.775272-39.563636 74.752 39.563636a36.142545 36.142545 0 0 0 16.174546 3.956364 34.909091 34.909091 0 0 0 34.210909-40.727273l-14.289455-83.781818 60.509091-59.345455a35.025455 35.025455 0 0 0-19.223272-59.578182l-83.61891-12.101818-37.376-76.101818a34.56 34.56 0 0 0-62.254545 0l-37.376 76.101818-83.618909 12.101818a34.909091 34.909091 0 0 0-19.246546 59.578182z m70.423272-64.698182a34.280727 34.280727 0 0 0 26.135273-19.083636l14.312727-29.090909 14.336 29.090909a34.257455 34.257455 0 0 0 26.135273 19.083636l32.046546 4.887273-23.272728 22.574545a35.234909 35.234909 0 0 0-10.007272 30.952727l5.46909 32.116364-28.625454-15.127273a34.490182 34.490182 0 0 0-32.302546 0l-28.695272 15.127273 5.469091-32.116364a35.141818 35.141818 0 0 0-9.984-30.952727l-23.272728-22.574545z" p-id="3855"></path></svg></button><button title="Light theme" class="__dumi-default-dark-sun "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="4026" width="22" height="22"><path d="M915.2 476.16h-43.968c-24.704 0-44.736 16-44.736 35.84s20.032 35.904 44.736 35.904H915.2c24.768 0 44.8-16.064 44.8-35.904s-20.032-35.84-44.8-35.84zM512 265.6c-136.704 0-246.464 109.824-246.464 246.4 0 136.704 109.76 246.464 246.464 246.464S758.4 648.704 758.4 512c0-136.576-109.696-246.4-246.4-246.4z m0 425.6c-99.008 0-179.2-80.128-179.2-179.2 0-98.944 80.192-179.2 179.2-179.2S691.2 413.056 691.2 512c0 99.072-80.192 179.2-179.2 179.2zM197.44 512c0-19.84-19.136-35.84-43.904-35.84H108.8c-24.768 0-44.8 16-44.8 35.84s20.032 35.904 44.8 35.904h44.736c24.768 0 43.904-16.064 43.904-35.904zM512 198.464c19.776 0 35.84-20.032 35.84-44.8v-44.8C547.84 84.032 531.84 64 512 64s-35.904 20.032-35.904 44.8v44.8c0 24.768 16.128 44.864 35.904 44.864z m0 627.136c-19.776 0-35.904 20.032-35.904 44.8v44.736C476.096 940.032 492.16 960 512 960s35.84-20.032 35.84-44.8v-44.736c0-24.768-16.064-44.864-35.84-44.864z m329.92-592.832c17.472-17.536 20.288-43.072 6.4-57.024-14.016-14.016-39.488-11.2-57.024 6.336-4.736 4.864-26.496 26.496-31.36 31.36-17.472 17.472-20.288 43.008-6.336 57.024 13.952 14.016 39.488 11.2 57.024-6.336 4.8-4.864 26.496-26.56 31.296-31.36zM213.376 759.936c-4.864 4.8-26.56 26.624-31.36 31.36-17.472 17.472-20.288 42.944-6.4 56.96 14.016 13.952 39.552 11.2 57.024-6.336 4.8-4.736 26.56-26.496 31.36-31.36 17.472-17.472 20.288-43.008 6.336-56.96-14.016-13.952-39.552-11.072-56.96 6.336z m19.328-577.92c-17.536-17.536-43.008-20.352-57.024-6.336-14.08 14.016-11.136 39.488 6.336 57.024 4.864 4.864 26.496 26.56 31.36 31.424 17.536 17.408 43.008 20.288 56.96 6.336 14.016-14.016 11.264-39.488-6.336-57.024-4.736-4.864-26.496-26.56-31.296-31.424z m527.168 628.608c4.864 4.864 26.624 26.624 31.36 31.424 17.536 17.408 43.072 20.224 57.088 6.336 13.952-14.016 11.072-39.552-6.4-57.024-4.864-4.8-26.56-26.496-31.36-31.36-17.472-17.408-43.072-20.288-57.024-6.336-13.952 14.016-11.008 39.488 6.336 56.96z" p-id="4027"></path></svg></button><button title="Default to system" class="__dumi-default-dark-auto "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="11002" width="22" height="22"><path d="M127.658667 492.885333c0-51.882667 10.24-101.717333 30.378666-149.162666s47.786667-88.064 81.92-122.538667 75.093333-61.781333 122.538667-81.92 96.938667-30.378667 149.162667-30.378667 101.717333 10.24 149.162666 30.378667 88.405333 47.786667 122.88 81.92 61.781333 75.093333 81.92 122.538667 30.378667 96.938667 30.378667 149.162666-10.24 101.717333-30.378667 149.162667-47.786667 88.405333-81.92 122.88-75.093333 61.781333-122.88 81.92-97.28 30.378667-149.162666 30.378667-101.717333-10.24-149.162667-30.378667-88.064-47.786667-122.538667-81.92-61.781333-75.093333-81.92-122.88-30.378667-96.938667-30.378666-149.162667z m329.045333 0c0 130.048 13.994667 244.394667 41.984 343.381334h12.970667c46.762667 0 91.136-9.216 133.461333-27.306667s78.848-42.666667 109.568-73.386667 54.954667-67.242667 73.386667-109.568 27.306667-86.698667 27.306666-133.461333c0-46.421333-9.216-90.794667-27.306666-133.12s-42.666667-78.848-73.386667-109.568-67.242667-54.954667-109.568-73.386667-86.698667-27.306667-133.461333-27.306666h-11.605334c-28.672 123.562667-43.349333 237.909333-43.349333 343.722666z" p-id="11003"></path></svg></button></div></div></div><ul class="__dumi-default-menu-list"><li><a href="/blog/性能测试实战30讲">性能测试实战30讲</a></li><li><a href="/blog/性能测试实战30讲/01.开篇词">01.开篇词</a><ul><li><a href="/blog/性能测试实战30讲/01.开篇词/01"><span>开篇词丨“老板，之前咱TPS是100，我优化完是10000”</span></a></li></ul></li><li><a href="/blog/性能测试实战30讲/02.第一模块性能测试基础篇">02.第一模块性能测试基础篇</a><ul><li><a href="/blog/性能测试实战30讲/02.第一模块性能测试基础篇/01"><span>01丨性能综述：性能测试的概念到底是什么？</span></a></li><li><a href="/blog/性能测试实战30讲/02.第一模块性能测试基础篇/02"><span>02丨性能综述：TPS和响应时间之间是什么关系？</span></a></li><li><a href="/blog/性能测试实战30讲/02.第一模块性能测试基础篇/03"><span>03丨性能综述：怎么理解TPS、QPS、RT、吞吐量这些性能指标？</span></a></li><li><a href="/blog/性能测试实战30讲/02.第一模块性能测试基础篇/04"><span>04丨JMeter和LoadRunner：要知道工具仅仅只是工具</span></a></li><li><a href="/blog/性能测试实战30讲/02.第一模块性能测试基础篇/05"><span>05丨指标关系：你知道并发用户数应该怎么算吗？</span></a></li><li><a href="/blog/性能测试实战30讲/02.第一模块性能测试基础篇/06"><span>06丨倾囊相授：我毕生所学的性能分析思路都在这里了</span></a></li></ul></li><li><a aria-current="page" class="active" href="/blog/性能测试实战30讲/03.第二模块性能测试工具及性能场景篇">03.第二模块性能测试工具及性能场景篇</a><ul><li><a href="/blog/性能测试实战30讲/03.第二模块性能测试工具及性能场景篇/01"><span>07丨性能测试工具：如何录制脚本？</span></a></li><li><a aria-current="page" class="active" href="/blog/性能测试实战30讲/03.第二模块性能测试工具及性能场景篇/02"><span>08丨案例： 手把手教你编写最简单的性能脚本</span></a></li><li><a href="/blog/性能测试实战30讲/03.第二模块性能测试工具及性能场景篇/03"><span>09丨关联和断言：一动一静，核心都是在取数据</span></a></li><li><a href="/blog/性能测试实战30讲/03.第二模块性能测试工具及性能场景篇/04"><span>10丨案例：在JMeter中如何设置参数化数据？</span></a></li><li><a href="/blog/性能测试实战30讲/03.第二模块性能测试工具及性能场景篇/05"><span>11丨性能脚本：用案例和图示帮你理解HTTP协议</span></a></li><li><a href="/blog/性能测试实战30讲/03.第二模块性能测试工具及性能场景篇/06"><span>12丨性能场景：做参数化之前，我们需要考虑什么？</span></a></li><li><a href="/blog/性能测试实战30讲/03.第二模块性能测试工具及性能场景篇/07"><span>13丨性能测试场景：如何进行场景设计？</span></a></li><li><a href="/blog/性能测试实战30讲/03.第二模块性能测试工具及性能场景篇/08"><span>14丨性能测试场景：如何理解业务模型？</span></a></li><li><a href="/blog/性能测试实战30讲/03.第二模块性能测试工具及性能场景篇/09"><span>15丨性能测试场景：如何进行监控设计？</span></a></li></ul></li><li><a href="/blog/性能测试实战30讲/04.春节策划">04.春节策划</a><ul><li><a href="/blog/性能测试实战30讲/04.春节策划/01"><span>春节策划丨性能评估和性能分析试题，等你挑战！</span></a></li><li><a href="/blog/性能测试实战30讲/04.春节策划/02"><span>春节策划丨快来挑战一下自己的分析逻辑吧！</span></a></li></ul></li><li><a href="/blog/性能测试实战30讲/05.第三模块性能监控分析工具篇">05.第三模块性能监控分析工具篇</a><ul><li><a href="/blog/性能测试实战30讲/05.第三模块性能监控分析工具篇/01"><span>16丨案例：性能监控工具之Grafana+Prometheus+Exporters</span></a></li><li><a href="/blog/性能测试实战30讲/05.第三模块性能监控分析工具篇/02"><span>17丨CentOS：操作系统级监控及常用计数器解析（上）</span></a></li><li><a href="/blog/性能测试实战30讲/05.第三模块性能监控分析工具篇/03"><span>18丨CentOS：操作系统级监控及常用计数器解析（下）</span></a></li><li><a href="/blog/性能测试实战30讲/05.第三模块性能监控分析工具篇/04"><span>19丨Java &amp; C ++：代码级监控及常用计数器解析（上）</span></a></li><li><a href="/blog/性能测试实战30讲/05.第三模块性能监控分析工具篇/05"><span>20丨Java &amp; C ++：代码级监控及常用计数器解析（下）</span></a></li><li><a href="/blog/性能测试实战30讲/05.第三模块性能监控分析工具篇/06"><span>21丨Tomcat：中间件监控及常用计数器解析</span></a></li><li><a href="/blog/性能测试实战30讲/05.第三模块性能监控分析工具篇/07"><span>22丨MySQL：数据库级监控及常用计数器解析（上）</span></a></li><li><a href="/blog/性能测试实战30讲/05.第三模块性能监控分析工具篇/08"><span>23丨MySQL：数据库级监控及常用计数器解析（下）</span></a></li><li><a href="/blog/性能测试实战30讲/05.第三模块性能监控分析工具篇/09"><span>24丨Kafka：性能监控工具之队列级监控及常用计数器解析</span></a></li><li><a href="/blog/性能测试实战30讲/05.第三模块性能监控分析工具篇/10"><span>25丨SkyWalking：性能监控工具之链路级监控及常用计数器解析</span></a></li></ul></li><li><a href="/blog/性能测试实战30讲/06.第四模块性能测试分析实战篇">06.第四模块性能测试分析实战篇</a><ul><li><a href="/blog/性能测试实战30讲/06.第四模块性能测试分析实战篇/01"><span>26丨案例：手把手带你理解TPS趋势分析</span></a></li><li><a href="/blog/性能测试实战30讲/06.第四模块性能测试分析实战篇/02"><span>27丨案例：带宽消耗以及Swap（上）</span></a></li><li><a href="/blog/性能测试实战30讲/06.第四模块性能测试分析实战篇/03"><span>28丨案例：带宽消耗以及Swap（下）</span></a></li><li><a href="/blog/性能测试实战30讲/06.第四模块性能测试分析实战篇/04"><span>29丨案例：如何应对因网络参数导致的TPS呈锯齿状？</span></a></li><li><a href="/blog/性能测试实战30讲/06.第四模块性能测试分析实战篇/05"><span>30丨案例：为什么参数化数据会导致TPS突然下降？</span></a></li><li><a href="/blog/性能测试实战30讲/06.第四模块性能测试分析实战篇/06"><span>31丨案例：当磁盘参数导致I/O高的时候，应该怎么办？</span></a></li><li><a href="/blog/性能测试实战30讲/06.第四模块性能测试分析实战篇/07"><span>32丨当Postgres磁盘读引起I/O高的时候，应该怎么办？</span></a></li></ul></li><li><a href="/blog/性能测试实战30讲/07.结束语">07.结束语</a><ul><li><a href="/blog/性能测试实战30讲/07.结束语/01"><span>结束语丨见过林林总总的乱象，才知未来的无限可能</span></a></li></ul></li><li><a href="/blog/性能测试实战30讲/08.结课测试">08.结课测试</a><ul><li><a href="/blog/性能测试实战30讲/08.结课测试/01"><span>期末测试题丨快来测试一下你对性能掌握到何种程度了吧！</span></a></li></ul></li><li><a href="/blog/性能测试实战30讲/summary">性能测试实战30讲</a></li></ul></div></div><ul role="slug-list" class="__dumi-default-layout-toc"><li title="手工编写HTTP脚本" data-depth="2"><a href="/blog/性能测试实战30讲/03.第二模块性能测试工具及性能场景篇/02#手工编写http脚本"><span>手工编写HTTP脚本</span></a></li><li title="服务端代码逻辑说明" data-depth="3"><a href="/blog/性能测试实战30讲/03.第二模块性能测试工具及性能场景篇/02#服务端代码逻辑说明"><span>服务端代码逻辑说明</span></a></li><li title="1.编写JMeter脚本" data-depth="2"><a href="/blog/性能测试实战30讲/03.第二模块性能测试工具及性能场景篇/02#1编写jmeter脚本"><span>1.编写JMeter脚本</span></a></li><li title="1.1 创建线程组" data-depth="3"><a href="/blog/性能测试实战30讲/03.第二模块性能测试工具及性能场景篇/02#11-创建线程组"><span>1.1 创建线程组</span></a></li><li title="1.2 创建HTTP Sampler" data-depth="3"><a href="/blog/性能测试实战30讲/03.第二模块性能测试工具及性能场景篇/02#12-创建http-sampler"><span>1.2 创建HTTP Sampler</span></a></li><li title="1.2.1 GET接口" data-depth="3"><a href="/blog/性能测试实战30讲/03.第二模块性能测试工具及性能场景篇/02#121-get接口"><span>1.2.1 GET接口</span></a></li><li title="1.2.2 POST接口" data-depth="3"><a href="/blog/性能测试实战30讲/03.第二模块性能测试工具及性能场景篇/02#122-post接口"><span>1.2.2 POST接口</span></a></li><li title="手工编写TCP脚本" data-depth="2"><a href="/blog/性能测试实战30讲/03.第二模块性能测试工具及性能场景篇/02#手工编写tcp脚本"><span>手工编写TCP脚本</span></a></li><li title="服务端代码逻辑说明" data-depth="3"><a href="/blog/性能测试实战30讲/03.第二模块性能测试工具及性能场景篇/02#服务端代码逻辑说明-1"><span>服务端代码逻辑说明</span></a></li><li title="编写JMeter脚本" data-depth="3"><a href="/blog/性能测试实战30讲/03.第二模块性能测试工具及性能场景篇/02#编写jmeter脚本"><span>编写JMeter脚本</span></a></li><li title="添加断言" data-depth="3"><a href="/blog/性能测试实战30讲/03.第二模块性能测试工具及性能场景篇/02#添加断言"><span>添加断言</span></a></li><li title="长短连接的问题" data-depth="3"><a href="/blog/性能测试实战30讲/03.第二模块性能测试工具及性能场景篇/02#长短连接的问题"><span>长短连接的问题</span></a></li><li title="TCP连接超时" data-depth="3"><a href="/blog/性能测试实战30讲/03.第二模块性能测试工具及性能场景篇/02#tcp连接超时"><span>TCP连接超时</span></a></li><li title="编写LoadRunner脚本" data-depth="3"><a href="/blog/性能测试实战30讲/03.第二模块性能测试工具及性能场景篇/02#编写loadrunner脚本"><span>编写LoadRunner脚本</span></a></li><li title="总结" data-depth="2"><a href="/blog/性能测试实战30讲/03.第二模块性能测试工具及性能场景篇/02#总结"><span>总结</span></a></li><li title="思考题" data-depth="2"><a href="/blog/性能测试实战30讲/03.第二模块性能测试工具及性能场景篇/02#思考题"><span>思考题</span></a></li></ul><div class="__dumi-default-layout-content"><div class="markdown"><h1 id="08丨案例-手把手教你编写最简单的性能脚本"><a aria-hidden="true" tabindex="-1" href="/blog/性能测试实战30讲/03.第二模块性能测试工具及性能场景篇/02#08丨案例-手把手教你编写最简单的性能脚本"><span class="icon icon-link"></span></a>08丨案例： 手把手教你编写最简单的性能脚本</h1><p>通常我们会遇到要手写脚本的时候，就要针对一些接口编写脚本。这时候，我们需要知道接口规范和后台的数据是什么。而有些性能测试工程师写脚本时，并不知道后端的逻辑，只知道实现脚本，事实上，只知道实现脚本是远远不够的。</p><p>在这一篇文章中，我不打算讲复杂的内容，只想针对新手写一步步的操作，描述最简单的脚本编写。如果你已经具有丰富的脚本编写经验，会觉得本文很简单。</p><p>我没有打算把JMeter的功能点一一罗列出来，作为一个性能测试的专栏，不写一下脚本的实现似乎不像个样子。在脚本实现中，我们最常用的协议就是HTTP和TCP了吧，所以在今天的内容里，我简单地说一下如何编写HTTP和TCP脚本，以应测试主题。</p><p>我先画个图说明一下。</p><p><img src="https://static001.geekbang.org/resource/image/c9/e6/c99990fb1cfce0410b6bb2be24107be6.jpg" alt=""/></p><p>这样的图做性能的人一定要知道，相信很多人也画的出来。</p><p>我们知道HTTP是应用层的协议之一，现在很多场景都在用它，并且是用的HTTP1.1的版本，对应的是RFC2616，当然还有补充协议RFC7231、6265。</p><p>HTTP中只规定了传输的规则，规定了请求、响应、连接、方法、状态定义等。我们写脚本的时候，必须符合这些规则。比如为什么要在脚本中定义个Header？Header里为什么要那样写？这些在RFC中都说得明明白白了。</p><p>还有一点也需要注意，HTTP是通过Socket来使用TCP的，Socket做为套接层API，它本身不是协议，只规定了API。</p><p>而我们通常在JMeter中写TCP脚本，就是直接调用Socket层的API。TCP脚本和HTTP脚本最大的区别就是，TCP脚本中发送和接收的内容完全取决于Socket server是怎么处理的，并没有通用的规则。所以脚本中也就只有根据具体的项目来发挥了。</p><h2 id="手工编写http脚本"><a aria-hidden="true" tabindex="-1" href="/blog/性能测试实战30讲/03.第二模块性能测试工具及性能场景篇/02#手工编写http脚本"><span class="icon icon-link"></span></a>手工编写HTTP脚本</h2><h3 id="服务端代码逻辑说明"><a aria-hidden="true" tabindex="-1" href="/blog/性能测试实战30讲/03.第二模块性能测试工具及性能场景篇/02#服务端代码逻辑说明"><span class="icon icon-link"></span></a>服务端代码逻辑说明</h3><p>我们先自己编写一小段服务端代码的逻辑。现在用Spring Boot写一个示例，其实就是分分钟的事情。我们做性能测试的人至少要知道访问的是什么东西。</p><p>Controller关键代码如下：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">@RestController</span></div><div class="token-line"><span class="token plain">    @RequestMapping(value = &quot;pa&quot;)</span></div><div class="token-line"><span class="token plain">    public class PAController {</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">      @Autowired</span></div><div class="token-line"><span class="token plain">      private PAService paService;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">      //查询</span></div><div class="token-line"><span class="token plain">      @GetMapping(&quot;/query/{id}&quot;)</span></div><div class="token-line"><span class="token plain">      public ResultVO&lt;User&gt; getById(@PathVariable(&quot;id&quot;) String id) {</span></div><div class="token-line"><span class="token plain">        User user = paService.getById(id);</span></div><div class="token-line"><span class="token plain">        return ResultVO.&lt;User&gt;builder().success(user).build();</span></div><div class="token-line"><span class="token plain">      }</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>Service关键代码如下：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">public User getById(String id) {</span></div><div class="token-line"><span class="token plain">        return mapper.selectByPrimaryKey(id);</span></div><div class="token-line"><span class="token plain">      }</span></div></pre></div><p>用MyBatis组件实现对Mapper的操作。由于不是基础开发教程，这里只是为了说明逻辑，如果你感兴趣的话，可以自己编写一个接口示例。</p><p>逻辑调用关系如下：</p><p><img src="https://static001.geekbang.org/resource/image/5a/42/5a41a086e7756bc2bdb2dc834bd4b942.jpg" alt=""/></p><p>数据库中表的信息如下：</p><p><img src="https://static001.geekbang.org/resource/image/eb/be/ebdadf0672b21c631f7fc6af41eaefbe.png" alt=""/></p><p>我们先看这个接口的访问逻辑：JMeter——SprintBoot的应用——MySQL。</p><h2 id="1编写jmeter脚本"><a aria-hidden="true" tabindex="-1" href="/blog/性能测试实战30讲/03.第二模块性能测试工具及性能场景篇/02#1编写jmeter脚本"><span class="icon icon-link"></span></a>1.编写JMeter脚本</h2><h3 id="11-创建线程组"><a aria-hidden="true" tabindex="-1" href="/blog/性能测试实战30讲/03.第二模块性能测试工具及性能场景篇/02#11-创建线程组"><span class="icon icon-link"></span></a>1.1 创建线程组</h3><p>首先创建一个线程组，配置如下：</p><p><img src="https://static001.geekbang.org/resource/image/88/0d/8803e67574df9a393ab4a3f135052e0d.png" alt=""/></p><p>在这个线程组中，有几个关键配置，我来一一说明一下。</p><p>Number of Threads(users)：我们都知道这是JMeter中的线程数，也可以称之为用户数。但是在<a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/178076">第2篇文章<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>中，我已经说得非常明确了，这个线程数是产生TPS的，而一个线程产生多少TPS，取决于系统的响应时间有多快。所以我们用TPS这个概念来承载系统的负载能力，而不是用这里的线程数。</p><p>Ramp-up Period(in seconds)：递增时间，以秒为单位。指的就是上面配置的线程数将在多长时间内会全部递增完。如果我们配置了100线程，这里配置为10秒，那么就是100/(10s*1000ms)=1线程/100ms；如果我们配置了10线程，这里配置为1秒，则是10/1000=1线程/100ms。这时我们要注意了哦，在10线程启动的这个阶段中，对服务器的压力是一样的。示意图如下：</p><p><img src="https://static001.geekbang.org/resource/image/e4/67/e42a668bbdf2d80968af233dea816267.png" alt=""/></p><p>Loop Count这个值指的是一个线程中脚本迭代的次数。这里你需要注意，这个值和后面的Scheduler有一个判断关系，下面我们会提到。</p><p>Delay Thread creation until needed：这个含义从字面看不是特别清楚。这里有一个默认的知识点，那就是JMeter所有的线程是一开始就创建完成的，只是递增的时候会按照上面的规则递增。如果选择了这个选项，则不会在一开始创建所有线程，只有在需要时才会创建。这一点和LoadRunner中的初始化选项类似。只是不知道你有没有注意过，基本上，我们做性能测试的工程师，很少有选择这个选项的。选与不选之间，区别到底是什么呢？</p><p>如果不选择，在启动场景时，JMeter会用更多的CPU来创建线程，它会影响前面的一些请求的响应时间，因为压力机的CPU在做其他事情嘛。</p><p>如果选择了的话，就会在使用时再创建，CPU消耗会平均一些，但是这时会有另一个隐患，就是会稍微影响正在跑的线程。这个选项，选择与否，取决于压力机在执行过程中，它能产生多大的影响。如果你的线程数很多，一旦启动，压力机的CPU都被消耗在创建线程上了，那就可以考虑选择它，否则，可以不选择。</p><p>Scheduler Configuration：这里有一句重要的话，<code>If Loop Count is not \-1 or Forever, duration will be min(Duration, Loop Count * iteration duration)</code>。举例来说，如果设置了Loop Count 为100，而响应时间是0.1秒，那么Loop <code>Count * iteration duration(这个就是响应时间) = 100 * 0.1 = 10秒</code>。</p><p>即便设置了Scheduler的Duration为100秒，线程仍然会以10秒为结束点。</p><p>如果没有设置Scheduler的Duration，那么你会看到，在JMeter运行到10秒时，控制台中会出现如下信息：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">2019-11-26 10:39:20,521 INFO o.a.j.t.JMeterThread: Thread finished: Thread Group 1-10</span></div></pre></div><p>有些人不太理解这一点，经常会设置迭代次数，同时又设置Scheduler中的Duration。而对TPS来说，就会产生这样的图：</p><p><img src="https://static001.geekbang.org/resource/image/5e/16/5e341022b296dbda9b75ec504ab80e16.png" alt=""/></p><p>场景没执行完，结果TPS全掉下去了，于是开始查后端系统，其实和后端没有任何关系。</p><h3 id="12-创建http-sampler"><a aria-hidden="true" tabindex="-1" href="/blog/性能测试实战30讲/03.第二模块性能测试工具及性能场景篇/02#12-创建http-sampler"><span class="icon icon-link"></span></a>1.2 创建HTTP Sampler</h3><h3 id="121-get接口"><a aria-hidden="true" tabindex="-1" href="/blog/性能测试实战30讲/03.第二模块性能测试工具及性能场景篇/02#121-get接口"><span class="icon icon-link"></span></a>1.2.1 GET接口</h3><p><img src="https://static001.geekbang.org/resource/image/e5/9b/e550be089497bdbec158d906481ae99b.png" alt=""/></p><p>看上图，我将Method选择为GET。为什么要选择它？往上看我们的接口注解，这是一个GetMapping，所以这里要选择GET。</p><p>再看path中，这里是<code>/pa/query/0808050c-0ae0-11ea-af5f-00163e124cff</code>，对应着<code>“/query/<!-- -->{<!-- -->id<!-- -->}<!-- -->”</code>。</p><p>然后执行：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">User user = paService.getById(id);</span></div></pre></div><p>返回执行结果：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">return ResultVO.&lt;User&gt;builder().success(user).build();</span></div></pre></div><p>为什么要解释这一段呢？</p><p>做开发的人可能会觉得，你这个解释毫无意义呀，代码里已经写得很清楚了。事实上，在我的工作经历中，会发现很多做性能测试脚本的，实际上并不知道后端采用了什么样的技术，实现的是什么样的逻辑。</p><p>所以还是希望你可以自己写一些demo，去了解一些逻辑，然后在排除问题的时候，就非常清楚了。</p><p>接着我们执行脚本，就得到了如下结果：</p><p><img src="https://static001.geekbang.org/resource/image/08/c7/08896d4bb8e30b957bf14ae486197ac7.png" alt=""/></p><p>这样一个最简单的GET脚本就做好了。</p><p>前面我们提到过，URL中的ID是0808050c-0ae0-11ea-af5f-00163e124cff，这个数据来自于数据库中的第一条。</p><p>如果我们随便写一个数据，会得到什么结果呢？</p><p><img src="https://static001.geekbang.org/resource/image/3d/55/3d9a128860fc71bdc0132ce0b8350155.png" alt=""/></p><p>你会看到，结果一样得到了200的code，但是这个结果明显就不对了，明明没有查到，还是返回了成功。</p><p>所以说，业务的成功，只能靠业务来判断。这里只是查询成功了，没返回数据也是查询成功了。我将在后面给你说明如何加断言。</p><h3 id="122-post接口"><a aria-hidden="true" tabindex="-1" href="/blog/性能测试实战30讲/03.第二模块性能测试工具及性能场景篇/02#122-post接口"><span class="icon icon-link"></span></a>1.2.2 POST接口</h3><p>下面我将Method改为POST，POST接口与GET接口的区别有这么几处：</p><ol><li>要把Path改为/pa/add；</li><li>输入JSON格式的Body Data。</li></ol><p><img src="https://static001.geekbang.org/resource/image/70/1d/7005421905a969c081be038f7ab5541d.png" alt=""/></p><p>执行起来，查看下结果。</p><p><img src="https://static001.geekbang.org/resource/image/d0/87/d006b04df0746c5de5a122e8036a1487.png" alt=""/><br/>你会发现上来就错了，提示如下：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">&quot;status&quot;:415,&quot;error&quot;:&quot;Unsupported Media Type&quot;,&quot;message&quot;:&quot;Content type &#x27;text/plain;charset=UTF-8&#x27; not supported&quot;</span></div></pre></div><p>这里你需要注意，无论遇到什么问题，都要针对问题来处理。当看不懂问题信息时，先查资料，想办法看懂。这是处理问题的关键，我发现很多做性能测试的新同学，一旦碰到问题就懵了，晕头转向地瞎尝试。</p><p>我经常对我的团队成员说，先看懂问题，再处理问题，别瞎蒙！</p><p>上面这个问题其实提示得很清楚：“不支持的媒体类型”。这里就两个信息，一个是Content type，一个是charset。它们是JMeter中HTTP Header里默认自带的。我们要发送的是JSON数据，而JMeter默认是把它当成text发出去的，这就出现了问题。所以我们要加一个Header，将Content type指定为JSON。</p><p>加一个HTTP Header，如下所示：</p><p><img src="https://static001.geekbang.org/resource/image/25/4c/25c8208ec31c22c07fc3a5dfd3b77b4c.png" alt=""/></p><p>如果你不知道加什么样的Header，建议你用HTTP抓包工具抓一个看一看，比如说用Charles，抓到如下信息：</p><p><img src="https://static001.geekbang.org/resource/image/b0/57/b02a63bf056052304d1d9969a2556157.png" alt=""/></p><p>这时你就会知道头里的Content-Type原来是<code>application/json;charset=UTF-8</code>。这里的charset=UTF-8可以不用写，因为它和默认的一样。</p><p>这时再回放，你就会看到如下结果：</p><p><img src="https://static001.geekbang.org/resource/image/e3/19/e399b507bfb2af2996f1186c0d27e419.png" alt=""/></p><p>到此，一个POST脚本就完成了。是不是很简单。</p><p>在这里，我需要跟你强调的是，手工编写HTTP脚本时，要注意以下几点：</p><ol><li>要知道请求的类型，我们选择的类型和后端接口的实现类型要是一致的。</li><li>业务的成功要有明确的业务判断（在下面的TCP中，我们再加断言来判断）。</li><li>判断问题时，请求的逻辑路径要清晰。</li></ol><p>编写完HTTP脚本时，我们再来看一下如何编写TCP脚本。</p><h2 id="手工编写tcp脚本"><a aria-hidden="true" tabindex="-1" href="/blog/性能测试实战30讲/03.第二模块性能测试工具及性能场景篇/02#手工编写tcp脚本"><span class="icon icon-link"></span></a>手工编写TCP脚本</h2><h3 id="服务端代码逻辑说明-1"><a aria-hidden="true" tabindex="-1" href="/blog/性能测试实战30讲/03.第二模块性能测试工具及性能场景篇/02#服务端代码逻辑说明-1"><span class="icon icon-link"></span></a>服务端代码逻辑说明</h3><p>我在这里写一个非常简单的服务端接收线程（如果你是开发，不要笑话，我只是为了说明脚本怎么写）。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">package demo.socket;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    import java.io.IOException;</span></div><div class="token-line"><span class="token plain">    import java.io.InputStream;</span></div><div class="token-line"><span class="token plain">    import java.io.OutputStream;</span></div><div class="token-line"><span class="token plain">    import java.net.ServerSocket;</span></div><div class="token-line"><span class="token plain">    import java.net.Socket;</span></div><div class="token-line"><span class="token plain">    import java.util.concurrent.ArrayBlockingQueue;</span></div><div class="token-line"><span class="token plain">    import java.util.concurrent.ThreadPoolExecutor;</span></div><div class="token-line"><span class="token plain">    import java.util.concurrent.TimeUnit;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    public class SocketReceiver {</span></div><div class="token-line"><span class="token plain">      //定义初始</span></div><div class="token-line"><span class="token plain">      public static final int corePoolSize = 5;</span></div><div class="token-line"><span class="token plain">      //定义最大线程池</span></div><div class="token-line"><span class="token plain">      public static final int maximumPoolSize = 5;</span></div><div class="token-line"><span class="token plain">      //定义socket队列长度</span></div><div class="token-line"><span class="token plain">      public static final int blockingQueue = 50;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">      /**</span></div><div class="token-line"><span class="token plain">       * 初始化并启动服务</span></div><div class="token-line"><span class="token plain">       */</span></div><div class="token-line"><span class="token plain">      public void init() {</span></div><div class="token-line"><span class="token plain">        //定义线程池</span></div><div class="token-line"><span class="token plain">        ThreadPoolExecutor executor = new ThreadPoolExecutor(corePoolSize, maximumPoolSize, 0L,</span></div><div class="token-line"><span class="token plain">            TimeUnit.MILLISECONDS, new ArrayBlockingQueue(blockingQueue));</span></div><div class="token-line"><span class="token plain">        //定义serverSocket</span></div><div class="token-line"><span class="token plain">        ServerSocket serverSocket = null;</span></div><div class="token-line"><span class="token plain">        try {</span></div><div class="token-line"><span class="token plain">          //启动serverSocket</span></div><div class="token-line"><span class="token plain">          serverSocket = new ServerSocket(Constants.PORT);</span></div><div class="token-line"><span class="token plain">          //输出服务启动地址</span></div><div class="token-line"><span class="token plain">          System.out.println(&quot;服务已启动:&quot; + serverSocket.getLocalSocketAddress().toString());</span></div><div class="token-line"><span class="token plain">          //接收信息并传递给线程池</span></div><div class="token-line"><span class="token plain">          while (true) {</span></div><div class="token-line"><span class="token plain">            Socket socket = serverSocket.accept();</span></div><div class="token-line"><span class="token plain">            executor.submit(new Handler(socket));</span></div><div class="token-line"><span class="token plain">          }</span></div><div class="token-line"><span class="token plain">        } catch (IOException e) {</span></div><div class="token-line"><span class="token plain">          e.printStackTrace();</span></div><div class="token-line"><span class="token plain">        } finally {</span></div><div class="token-line"><span class="token plain">          if (serverSocket != null) {</span></div><div class="token-line"><span class="token plain">            try {</span></div><div class="token-line"><span class="token plain">              serverSocket.close(); //释放serverSocket</span></div><div class="token-line"><span class="token plain">            } catch (IOException e) {</span></div><div class="token-line"><span class="token plain">              e.printStackTrace();</span></div><div class="token-line"><span class="token plain">            }</span></div><div class="token-line"><span class="token plain">          }</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">      }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">      //处理请求类</span></div><div class="token-line"><span class="token plain">      class Handler implements Runnable {</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        private Socket socket;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        public Handler(Socket socket) {</span></div><div class="token-line"><span class="token plain">          this.socket = socket;</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        public void run() {</span></div><div class="token-line"><span class="token plain">          try {</span></div><div class="token-line"><span class="token plain">            // 接收客户端的信息</span></div><div class="token-line"><span class="token plain">            InputStream in = socket.getInputStream();</span></div><div class="token-line"><span class="token plain">            int count = 0;</span></div><div class="token-line"><span class="token plain">            while (count == 0) {</span></div><div class="token-line"><span class="token plain">              count = in.available();</span></div><div class="token-line"><span class="token plain">            }</span></div><div class="token-line"><span class="token plain">            byte[] b = new byte[count];</span></div><div class="token-line"><span class="token plain">            in.read(b);</span></div><div class="token-line"><span class="token plain">            String message = new String(b);</span></div><div class="token-line"><span class="token plain">            System.out.println(&quot; receive request: &quot; + socket.getInetAddress() + &quot; &quot; + message);</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">            // 睡2秒模拟思考时间，这里是为了模拟服务器端的业务处理时间</span></div><div class="token-line"><span class="token plain">            try {</span></div><div class="token-line"><span class="token plain">              Thread.sleep(2000);</span></div><div class="token-line"><span class="token plain">            } catch (InterruptedException e) {</span></div><div class="token-line"><span class="token plain">              e.printStackTrace();</span></div><div class="token-line"><span class="token plain">            }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">            // 向客户端发送确认消息</span></div><div class="token-line"><span class="token plain">            //定义输出流outer</span></div><div class="token-line"><span class="token plain">            OutputStream outer = socket.getOutputStream();</span></div><div class="token-line"><span class="token plain">            //将客户端发送的信息加上确认信息ok</span></div><div class="token-line"><span class="token plain">            String response = message + &quot; is OK&quot;;</span></div><div class="token-line"><span class="token plain">            //将输入信息保存到b_out中</span></div><div class="token-line"><span class="token plain">            byte[] b_out = response.getBytes();</span></div><div class="token-line"><span class="token plain">            //写入输入流</span></div><div class="token-line"><span class="token plain">            outer.write(b_out);</span></div><div class="token-line"><span class="token plain">            //推送输入流到客户端</span></div><div class="token-line"><span class="token plain">            outer.flush();</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">          } catch (IOException e) {</span></div><div class="token-line"><span class="token plain">            e.printStackTrace();</span></div><div class="token-line"><span class="token plain">          } finally {</span></div><div class="token-line"><span class="token plain">            // 关闭socket</span></div><div class="token-line"><span class="token plain">            try {</span></div><div class="token-line"><span class="token plain">              socket.close();</span></div><div class="token-line"><span class="token plain">            } catch (IOException e) {</span></div><div class="token-line"><span class="token plain">              e.printStackTrace();</span></div><div class="token-line"><span class="token plain">            }</span></div><div class="token-line"><span class="token plain">          }</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">      }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">      //程序入口</span></div><div class="token-line"><span class="token plain">      public static void main(String[] args) {</span></div><div class="token-line"><span class="token plain">        //定义服务端</span></div><div class="token-line"><span class="token plain">        SocketReceiver receiver = new SocketReceiver();</span></div><div class="token-line"><span class="token plain">        //启动服务端</span></div><div class="token-line"><span class="token plain">        receiver.init();</span></div><div class="token-line"><span class="token plain">      }</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><h3 id="编写jmeter脚本"><a aria-hidden="true" tabindex="-1" href="/blog/性能测试实战30讲/03.第二模块性能测试工具及性能场景篇/02#编写jmeter脚本"><span class="icon icon-link"></span></a>编写JMeter脚本</h3><p>首先创建TCP Sampler。右键点击Thread Group - Add - Sampler - TCP Sampler即可创建。</p><p><img src="https://static001.geekbang.org/resource/image/a2/b4/a2d7a5f2b0271416f54070d42719d6b4.png" alt=""/></p><p>输入配置和要发送的信息。</p><p><img src="https://static001.geekbang.org/resource/image/b6/b0/b6c6435fe31916d27e3934a911d781b0.png" alt=""/></p><p>IP地址和端口是必须要输入的。对于创建一个TCP协议的JMeter脚本来说，简单地说，过程就是这样的：创建连接 - 发数据 - 关闭连接。</p><p>就这样，这个手工的脚本就完成了。</p><p>你可能会问，就这么简单吗？是的，手工编写就是这么简单。</p><p>但是（对嘛，但是才是重点），通常我们在创建TCP协议的脚本时，都是根据业务接口规范来说的，<strong>复杂点其实不在脚本本身上，而是在接口的规则上</strong>。</p><h3 id="添加断言"><a aria-hidden="true" tabindex="-1" href="/blog/性能测试实战30讲/03.第二模块性能测试工具及性能场景篇/02#添加断言"><span class="icon icon-link"></span></a>添加断言</h3><p>我回放了一下脚本，发现如下情况：</p><p><img src="https://static001.geekbang.org/resource/image/2c/3d/2cbddf1bc190c167212f14b3c6bf193d.png" alt=""/></p><p>都执行对了呀，为什么下面的没有返回信息呢？这种情况下只有第一个请求有返回信息，但是下面也没有报错。这里就需要注意了。</p><p><strong>测试工具的成功，并不等于业务的成功</strong>。</p><p>所以我们必须要做的就是响应断言，也就是返回值的判断。在JMeter中，断言有以下这些：</p><p><img src="https://static001.geekbang.org/resource/image/d4/9b/d4b8c319a6ade1344f1cced91308079b.png" alt=""/></p><p>因为今天的文章不是工具的教程，所以我不打算全讲一遍。这里我只用最基础的响应断言。什么是断言呢？</p><p><img src="https://static001.geekbang.org/resource/image/34/84/343a993f00b5f289ed2fc76ed735c684.jpg" alt=""/></p><p>断言指的就是服务器端有一个业务成功的标识，会传递给客户端，客户端判断是否正常接收到了这个标识的过程。</p><p><img src="https://static001.geekbang.org/resource/image/97/c7/972884773c413e5b07ee74bf12a14ac7.png" alt=""/></p><p>在这里我添加了一个断言，用以判断服务器是否返回了OK。 你要注意这个“OK”是从哪来的哦，它是从服务端的这一行代码中来的。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">String response = message + &quot; is OK&quot;;</span></div></pre></div><p>请注意，这个断言的信息，一是可以判断出业务的正确性。我在工作中发现有些人用页面中一些并不必要的文字来判断，这样就不对了，我们应该用有业务含义的判断标识。</p><p>如果我们再次回放脚本，你会发现除了第一个请求，后面9个请求都错了。</p><p><img src="https://static001.geekbang.org/resource/image/31/37/318675c91ad46c36da9b7a9eab215737.png" alt=""/></p><p>所以，在做脚本时，请你一定要注意，<strong>断言是必须要加的</strong>。</p><h3 id="长短连接的问题"><a aria-hidden="true" tabindex="-1" href="/blog/性能测试实战30讲/03.第二模块性能测试工具及性能场景篇/02#长短连接的问题"><span class="icon icon-link"></span></a>长短连接的问题</h3><p>既然有错，肯定是要处理。我们查看一下JMeter的控制台错误信息：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">2019-11-26 09:51:51,587 ERROR o.a.j.p.t.s.TCPSampler: </span></div><div class="token-line"><span class="token plain">    java.net.SocketException: Broken pipe (Write failed)</span></div><div class="token-line"><span class="token plain">    	at java.net.SocketOutputStream.socketWrite0(Native Method) ~[?:1.8.0_111]</span></div><div class="token-line"><span class="token plain">    	at java.net.SocketOutputStream.socketWrite(SocketOutputStream.java:109) ~[?:1.8.0_111]</span></div><div class="token-line"><span class="token plain">    	at java.net.SocketOutputStream.write(SocketOutputStream.java:141) ~[?:1.8.0_111]</span></div><div class="token-line"><span class="token plain">    	at org.apache.jmeter.protocol.tcp.sampler.TCPClientImpl.write(TCPClientImpl.java:78) ~[ApacheJMeter_tcp.jar:5.1.1 r1855137]</span></div><div class="token-line"><span class="token plain">    	at org.apache.jmeter.protocol.tcp.sampler.TCPSampler.sample(TCPSampler.java:401) [ApacheJMeter_tcp.jar:5.1.1 r1855137]</span></div><div class="token-line"><span class="token plain">    	at org.apache.jmeter.threads.JMeterThread.doSampling(JMeterThread.java:622) [ApacheJMeter_core.jar:5.1.1 r1855137]</span></div><div class="token-line"><span class="token plain">    	at org.apache.jmeter.threads.JMeterThread.executeSamplePackage(JMeterThread.java:546) [ApacheJMeter_core.jar:5.1.1 r1855137]</span></div><div class="token-line"><span class="token plain">    	at org.apache.jmeter.threads.JMeterThread.processSampler(JMeterThread.java:486) [ApacheJMeter_core.jar:5.1.1 r1855137]</span></div><div class="token-line"><span class="token plain">    	at org.apache.jmeter.threads.JMeterThread.run(JMeterThread.java:253) [ApacheJMeter_core.jar:5.1.1 r1855137]</span></div><div class="token-line"><span class="token plain">      at java.lang.Thread.run(Thread.java:745) [?:1.8.0_111]</span></div></pre></div><p>从字面上来看，就是通道瓦塔（被破坏）了，Broken pipe。这个提示表明客户端上没有这个连接了，而JMeter还以为有这个链接，于是接着用这个链接来发，显然是找不到这个通道，于是就报错了。</p><p>这是一个典型的压力工具这边的问题。</p><p>而服务端，只收到了一条请求。</p><p><img src="https://static001.geekbang.org/resource/image/b1/d9/b1050e9a5920bdfd84b3c78a700615d9.png" alt=""/></p><p>为什么会报这个错呢？因为我们代码是短链接的，服务端处理完之后，就把这个链接给断掉了。</p><p>这里是压力机上的抓包信息：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">//从这里开始，上面已经看到了有Fin（结束）包了，后面还在发Push（发送数据）包。显然是通不了，还被服务端啪啪抽了两次reset。</span></div><div class="token-line"><span class="token plain">    11:58:07.042915 IP localhost.57677 &gt; 60.205.107.9.m-oap: Flags [P.], seq 34:67, ack 41, win 4119, options [nop,nop,TS val 163718903 ecr 2122793206], length 33</span></div><div class="token-line"><span class="token plain">    11:58:07.046075 IP localhost.57677 &gt; 60.205.107.9.m-oap: Flags [FP.], seq 67:331, ack 41, win 4119, options [nop,nop,TS val 163718906 ecr 2122793206], length 264</span></div><div class="token-line"><span class="token plain">    11:58:07.076393 IP 60.205.107.9.m-oap &gt; localhost.57677: Flags [R], seq 3986768192, win 0, length 0</span></div><div class="token-line"><span class="token plain">    11:58:07.079156 IP 60.205.107.9.m-oap &gt; localhost.57677: Flags [R], seq 3986768192, win 0, length 0</span></div></pre></div><p>服务端的抓包信息：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">//服务端也是没有办法，只能在看到了Push包之后，给回了个Reset包。</span></div><div class="token-line"><span class="token plain">    11:58:07.047001 IP 124.64.16.240.bones &gt; 7dgroup1.enc-eps-mc-sec: Flags [P.], seq 34:67, ack 41, win 4119, options [nop,nop,TS val 163718903 ecr 2122793206], length 33</span></div><div class="token-line"><span class="token plain">    11:58:07.047077 IP 7dgroup1.enc-eps-mc-sec &gt; 124.64.16.240.bones: Flags [R], seq 3986768192, win 0, length 0</span></div><div class="token-line"><span class="token plain">    11:58:07.054757 IP 124.64.16.240.bones &gt; 7dgroup1.enc-eps-mc-sec: Flags [FP.], seq 67:331, ack 41, win 4119, options [nop,nop,TS val 163718906 ecr 2122793206], length 264</span></div><div class="token-line"><span class="token plain">    11:58:07.054844 IP 7dgroup1.enc-eps-mc-sec &gt; 124.64.16.240.bones: Flags [R], seq 3986768192, win 0, length 0</span></div></pre></div><p>这是为什么呢？因为在JMeter中，默认是复用TCP连接的，但是在我们这个示例中，服务端并没有保存这个连接。所以，我们应该在脚本中，把下图中的Re-use connection给去掉。</p><p><img src="https://static001.geekbang.org/resource/image/71/75/71d1b52fe04ced4b3bd793b268ae5175.png" alt=""/></p><p>这时再回放脚本，你就会发现10次迭代全都对了。如下图所示：</p><p><img src="https://static001.geekbang.org/resource/image/d2/e1/d23dddf82d073b6bffb1a25f374b5de1.png" alt=""/></p><p>但是，这里还有一个知识点，希望你注意。短连接的时候，必然会产生更多的TCP连接的创建和销毁，对性能来说，这会让系统变得缓慢。</p><p>所以你可以看到上面10条迭代全都对了的同时，响应时间也增加了。</p><p>可能会有人问，那这怎么办呢？长短连接的选择取决于业务的需要，如果必须用短链接，那可能就需要更多的CPU来支撑；要是长连接，就需要更多的内存来支撑（用以保存TCP连接）。</p><p>根据业务需要，我们选择一个合适的就好。</p><h3 id="tcp连接超时"><a aria-hidden="true" tabindex="-1" href="/blog/性能测试实战30讲/03.第二模块性能测试工具及性能场景篇/02#tcp连接超时"><span class="icon icon-link"></span></a>TCP连接超时</h3><p>这个问题，应该说非常常见，我们这里只做问题的现象说明和解决，不做原理的探讨。原理的部分，我会在监控和分析部分加一说明。</p><p>下面这个错误，属于典型的主机连不上。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">java.net.ConnectException: Operation timed out (Connection timed out)</span></div><div class="token-line"><span class="token plain">    	at java.net.PlainSocketImpl.socketConnect(Native Method) ~[?:1.8.0_111]</span></div><div class="token-line"><span class="token plain">    	at java.net.AbstractPlainSocketImpl.doConnect(AbstractPlainSocketImpl.java:350) ~[?:1.8.0_111]</span></div><div class="token-line"><span class="token plain">    	at java.net.AbstractPlainSocketImpl.connectToAddress(AbstractPlainSocketImpl.java:206) ~[?:1.8.0_111]</span></div><div class="token-line"><span class="token plain">    	at java.net.AbstractPlainSocketImpl.connect(AbstractPlainSocketImpl.java:188) ~[?:1.8.0_111]</span></div><div class="token-line"><span class="token plain">    	at java.net.SocksSocketImpl.connect(SocksSocketImpl.java:392) ~[?:1.8.0_111]</span></div><div class="token-line"><span class="token plain">    	at java.net.Socket.connect(Socket.java:589) ~[?:1.8.0_111]</span></div><div class="token-line"><span class="token plain">    	at org.apache.jmeter.protocol.tcp.sampler.TCPSampler.getSocket(TCPSampler.java:168) [ApacheJMeter_tcp.jar:5.1.1 r1855137]</span></div><div class="token-line"><span class="token plain">    	at org.apache.jmeter.protocol.tcp.sampler.TCPSampler.sample(TCPSampler.java:384) [ApacheJMeter_tcp.jar:5.1.1 r1855137]</span></div><div class="token-line"><span class="token plain">    	at org.apache.jmeter.threads.JMeterThread.doSampling(JMeterThread.java:622) [ApacheJMeter_core.jar:5.1.1 r1855137]</span></div><div class="token-line"><span class="token plain">    	at org.apache.jmeter.threads.JMeterThread.executeSamplePackage(JMeterThread.java:546) [ApacheJMeter_core.jar:5.1.1 r1855137]</span></div><div class="token-line"><span class="token plain">    	at org.apache.jmeter.threads.JMeterThread.processSampler(JMeterThread.java:486) [ApacheJMeter_core.jar:5.1.1 r1855137]</span></div><div class="token-line"><span class="token plain">    	at org.apache.jmeter.threads.JMeterThread.run(JMeterThread.java:253) [ApacheJMeter_core.jar:5.1.1 r1855137]</span></div><div class="token-line"><span class="token plain">      at java.lang.Thread.run(Thread.java:745) [?:1.8.0_111]</span></div></pre></div><p>time out是个如果你理解了逻辑，就觉得很简单，如果没理解逻辑，就觉得非常复杂的问题。</p><p>要想解决这个问题，就要先确定服务端是可以正常连通的。</p><p>如果不能正常连通，那么通常都是IP不正确、端口不正确、防火墙阻止之类的问题。解决了网络连通性的问题，就可以解决connection timed out的问题。</p><h3 id="编写loadrunner脚本"><a aria-hidden="true" tabindex="-1" href="/blog/性能测试实战30讲/03.第二模块性能测试工具及性能场景篇/02#编写loadrunner脚本"><span class="icon icon-link"></span></a>编写LoadRunner脚本</h3><p>针对上面这个示例，如果你要想编写一个LoadRunner的示例脚本，也是简单到不行。</p><p>首先创建一个空的winsock脚本，复制下面代码到action里面。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">//创建socket1</span></div><div class="token-line"><span class="token plain">    lrs_create_socket(&quot;socket1&quot;, &quot;TCP&quot;, &quot;RemoteHost=60.205.10.9:5567&quot;, LrsLastArg); </span></div><div class="token-line"><span class="token plain">    //走socket1, 发送buf1中定义的数据</span></div><div class="token-line"><span class="token plain">    lrs_send (&quot;socket1&quot;, &quot;buf1&quot;, LrsLastArg ); </span></div><div class="token-line"><span class="token plain">    //走socket1，接收数据保存在buf2中</span></div><div class="token-line"><span class="token plain">    lrs_receive(&quot;socket1&quot;, &quot;buf2&quot;,  LrsLastArg); </span></div><div class="token-line"><span class="token plain">    //关掉socket1</span></div><div class="token-line"><span class="token plain">    lrs_close_socket(&quot;socket1&quot;);</span></div></pre></div><p>从上面的信息就可以看到，socket1这个标识是我们操作的基础。如果你在一个脚本中想处理两个socket，也是可以的，只要控制好你的标识不会乱就行。</p><p>接着再将下面的内容复制到data.ws里面。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">send buf1 5</span></div><div class="token-line"><span class="token plain">        &quot;12345&quot;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    recv buf2 10</span></div></pre></div><p>你可能会问，这个recv怎么不写返回的值是什么？</p><p>当你手写socket脚本的时候，都还没有运行，你怎么知道返回值是什么呢？所以这里，可以不用写。</p><p>而recv 后面的10是指接收10个字节。如果多了怎么办？截掉？！不会的，LoadRunner还是会把所有信息全部接收并保存下来，除非你提前定义了截取字符长度的函数。</p><p>最后看下我们回放的结果：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">Action.c(6): lrs_create_socket(socket1, TCP, ...)</span></div><div class="token-line"><span class="token plain">    Action.c(7): lrs_send(socket1, buf1)</span></div><div class="token-line"><span class="token plain">    Action.c(8): lrs_receive(socket1, buf2)</span></div><div class="token-line"><span class="token plain">    Action.c(8): Mismatch in buffer&#x27;s length (expected 10 bytes, 11 bytes actually received, difference in 1 bytes)</span></div><div class="token-line"><span class="token plain">    ================================EXPECTED BUFFER================================</span></div><div class="token-line"><span class="token plain">    ===============================================================================</span></div><div class="token-line"><span class="token plain">    ================================RECEIVED BUFFER================================</span></div><div class="token-line"><span class="token plain">    	&quot;12345 is OK&quot;</span></div><div class="token-line"><span class="token plain">    ===============================================================================</span></div><div class="token-line"><span class="token plain">    Action.c(8): callRecv:11 bytes were received</span></div><div class="token-line"><span class="token plain">    Action.c(9): lrs_close_socket(socket1)</span></div></pre></div><p>看，脚本正常执行了，只是报了一个Mismatch，这是因为我们定义了buf2 是10字节，而我们实际上接收了11字节，所以这里给出了Mismatch。</p><p>到此，一个LoadRunner的手工TCP脚本就完成了。后面我们就可以根据需要，增强脚本了，加个参数化、关联、检查点等等。</p><h2 id="总结"><a aria-hidden="true" tabindex="-1" href="/blog/性能测试实战30讲/03.第二模块性能测试工具及性能场景篇/02#总结"><span class="icon icon-link"></span></a>总结</h2><p>其实这篇文章只想告诉你一件事情，手工编写脚本，从基础上说，是非常简单的，只是有三点需要特别强调：</p><ol><li>涉及到业务规则和逻辑判断之后，编写脚本就复杂了起来。但是了解业务规则是做脚本的前提条件，也是性能测试工程师的第一步。</li><li>编写脚本的时候，要知道后端的逻辑。这里的意思不是说，你一开始写脚本的时候，就要去读后端的代码，而是说你在遇到问题的时候，要分析整个链路上每个环节使用到了什么技术，以便快速地分析判断。</li><li>写脚本是以<strong>最简为最佳</strong>，用不着故意复杂。</li></ol><p>脚本的细节功能有很多，而现在我们可以看到市场上的书籍也好，文档也好，基本上是在教人如何用工具，很少会从前到后地说明一个数据从哪发到哪，谁来处理这样的逻辑。</p><p>希望学习性能测试工具的你，不仅知其然，更知其所以然。</p><h2 id="思考题"><a aria-hidden="true" tabindex="-1" href="/blog/性能测试实战30讲/03.第二模块性能测试工具及性能场景篇/02#思考题"><span class="icon icon-link"></span></a>思考题</h2><p>学习完今天的内容，你不妨思考一下，HTTP的GET和POST请求，在后端处理中有什么不同？断言的作用是什么？如何使用断言呢？</p><p>欢迎你在评论区写下你的思考，也欢迎把这篇文章分享给你的朋友或者同事，一起交流一下。</p></div><div class="__dumi-default-layout-footer-meta"><a target="_blank" rel="noopener noreferrer" href="https://github.com/GGwujun/blog/edit/master/docs/性能测试实战30讲/03.第二模块性能测试工具及性能场景篇/02.md">在 GitHub 上编辑此页<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a><span data-updated-text="最后更新时间：">5/2/2022 10:57:06</span></div></div></div></div>
	<script>
  window.g_useSSR = true;
  window.g_initialProps = {};
	</script>

    <script>
      (function () {
        if (!location.port) {
          (function (i, s, o, g, r, a, m) {
            i["GoogleAnalyticsObject"] = r;
            (i[r] =
              i[r] ||
              function () {
                (i[r].q = i[r].q || []).push(arguments);
              }),
              (i[r].l = 1 * new Date());
            (a = s.createElement(o)), (m = s.getElementsByTagName(o)[0]);
            a.async = 1;
            a.src = g;
            m.parentNode.insertBefore(a, m);
          })(
            window,
            document,
            "script",
            "//www.google-analytics.com/analytics.js",
            "ga"
          );
          ga("create", "UA-149864185-1", "auto");
          ga("send", "pageview");
        }
      })();
    </script>
    <script src="/blog/umi.js"></script>
  </body>
</html>
