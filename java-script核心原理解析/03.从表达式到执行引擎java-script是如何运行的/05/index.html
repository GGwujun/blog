<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no"
    />
    <link rel="shortcut icon" type="image/x-icon" href="/logo.png" />
    <link rel="stylesheet" href="/blog/umi.css" />
    <script>
      window.routerBase = "/blog";
    </script>
    <script>
      //! umi version: 3.5.17
    </script>
    <script>
      !(function () {
        var e = localStorage.getItem("dumi:prefers-color"),
          t = window.matchMedia("(prefers-color-scheme: dark)").matches,
          r = ["light", "dark", "auto"];
        document.documentElement.setAttribute(
          "data-prefers-color",
          e === r[2] ? (t ? r[1] : r[0]) : r.indexOf(e) > -1 ? e : r[0]
        );
      })();
    </script>
    <title>10 | x = yield x：迭代过程的“函数式化”</title>
  </head>
  <body>
    <div id="root"><div class="__dumi-default-layout" data-route="/java-script核心原理解析/03.从表达式到执行引擎java-script是如何运行的/05" data-show-sidemenu="true" data-show-slugs="true" data-site-mode="true" data-gapless="false"><div class="__dumi-default-navbar" data-mode="site"><button class="__dumi-default-navbar-toggle"></button><a class="__dumi-default-navbar-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog/">大师兄</a><nav><div class="__dumi-default-search"><input type="search" class="__dumi-default-search-input" value=""/><ul></ul></div><span>计算机基础<ul><li><a href="/blog/编译原理之美">编译原理之美</a></li><li><a href="/blog/编译原理实战">编译原理实战</a></li><li><a href="/blog/深入浅出计算机组成原理">深入浅出计算机组成原理</a></li><li><a href="/blog/详解http">详解http</a></li><li><a href="/blog/计算机网络通关29讲">计算机网络通关29讲</a></li><li><a href="/blog/网络排查案例课">网络排查案例课</a></li><li><a href="/blog/linux操作系统">linux操作系统</a></li><li><a href="/blog/linux性能优化实战">linux性能优化实战</a></li><li><a href="/blog/程序员数学基础">程序员数学基础</a></li><li><a href="/blog/趣谈网络协议">趣谈网络协议</a></li><li><a href="/blog/操作系统实战">操作系统实战</a></li><li><a href="/blog/软件工程之美">软件工程之美</a></li><li><a href="/blog/sql必知必会">sql必知必会</a></li><li><a href="/blog/操作系统实战45讲">操作系统实战45讲</a></li><li><a href="/blog/网络编程实战">网络编程实战</a></li></ul></span><span>算法<ul><li><a href="/blog/常用算法25讲">常用算法25讲</a></li><li><a href="/blog/数据结构与算法之美">数据结构与算法之美</a></li><li><a href="/blog/业务开发算法50讲">业务开发算法50讲</a></li><li><a href="/blog/动态规划面试宝典">动态规划面试宝典</a></li></ul></span><span>前端开发<ul><li><a href="/blog/浏览器工作原理与实践">浏览器工作原理与实践</a></li><li><a href="/blog/新时代产品经理进阶之路">新时代产品经理进阶之路</a></li><li><a href="/blog/全栈工程师修炼指南">全栈工程师修炼指南</a></li><li><a href="/blog/flutter核心技术与实战">flutter核心技术与实战</a></li><li><a aria-current="page" class="active" href="/blog/java-script核心原理解析">java-script核心原理解析</a></li><li><a href="/blog/说透低代码">说透低代码</a></li><li><a href="/blog/nodejs应用开发实战">nodejs应用开发实战</a></li><li><a href="/blog/反爬虫兵法演绎20讲">反爬虫兵法演绎20讲</a></li><li><a href="/blog/reactnative新架构实战课">reactnative新架构实战课</a></li><li><a href="/blog/正则表达式入门">正则表达式入门</a></li><li><a href="/blog/重学前端">重学前端</a></li><li><a href="/blog/serverless入门课">serverless入门课</a></li><li><a href="/blog/type-script入门实战笔记">type-script入门实战笔记</a></li><li><a href="/blog/图解googlev8">图解googlev8</a></li><li><a href="/blog/vue3源码分析">vue3源码分析</a></li><li><a href="/blog/玩转Vue3全家桶">玩转Vue3全家桶</a></li><li><a href="/blog/webassembly入门">webassembly入门</a></li><li><a href="/blog/手把手带你写一个Web框架">手把手带你写一个Web框架</a></li><li><a href="/blog/web漏洞挖掘实战">web漏洞挖掘实战</a></li><li><a href="/blog/跟月影学可视化">跟月影学可视化</a></li><li><a href="/blog/搞定音频技术">搞定音频技术</a></li><li><a href="/blog/攻克视频技术">攻克视频技术</a></li></ul></span><span>前端工程化<ul><li><a href="/blog/logger">logger</a></li><li><a href="/blog/webpack">webpack</a></li><li><a href="/blog/webpackChain">webpackChain</a></li></ul></span><span>前端性能优化<ul><li><a href="/blog/react性能调优">react性能调优</a></li></ul></span><span>软件测试<ul><li><a href="/blog/全链路压测实战30讲">全链路压测实战30讲</a></li><li><a href="/blog/性能测试实战30讲">性能测试实战30讲</a></li><li><a href="/blog/自动化测试高手课">自动化测试高手课</a></li><li><a href="/blog/软件测试52讲">软件测试52讲</a></li></ul></span><span>面试<ul><li><a href="/blog/面试现场">面试现场</a></li></ul></span><span>杂谈<ul><li><a href="/blog/超级访谈对话张雪峰">超级访谈对话张雪峰</a></li><li><a href="/blog/Git实战手册">Git实战手册</a></li><li><a href="/blog/NodeJS">NodeJS</a></li><li><a href="/blog/ReactJS">ReactJS</a></li><li><a href="/blog/UI设计">UI设计</a></li><li><a href="/blog/webpack4系列教程">webpack4系列教程</a></li><li><a href="/blog/前端知识体系">前端知识体系</a></li><li><a href="/blog/剑指offer刷题笔记">剑指offer刷题笔记</a></li><li><a href="/blog/思考与成长">思考与成长</a></li><li><a href="/blog/设计模式手册">设计模式手册</a></li></ul></span><div class="__dumi-default-navbar-tool"><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "></div></div></div></nav></div><div class="__dumi-default-menu" data-mode="site"><div class="__dumi-default-menu-inner"><div class="__dumi-default-menu-header"><a class="__dumi-default-menu-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog/"></a><h1>大师兄</h1><p></p></div><div class="__dumi-default-menu-mobile-area"><ul class="__dumi-default-menu-nav-list"><li>计算机基础<ul><li><a href="/blog/编译原理之美">编译原理之美</a></li><li><a href="/blog/编译原理实战">编译原理实战</a></li><li><a href="/blog/深入浅出计算机组成原理">深入浅出计算机组成原理</a></li><li><a href="/blog/详解http">详解http</a></li><li><a href="/blog/计算机网络通关29讲">计算机网络通关29讲</a></li><li><a href="/blog/网络排查案例课">网络排查案例课</a></li><li><a href="/blog/linux操作系统">linux操作系统</a></li><li><a href="/blog/linux性能优化实战">linux性能优化实战</a></li><li><a href="/blog/程序员数学基础">程序员数学基础</a></li><li><a href="/blog/趣谈网络协议">趣谈网络协议</a></li><li><a href="/blog/操作系统实战">操作系统实战</a></li><li><a href="/blog/软件工程之美">软件工程之美</a></li><li><a href="/blog/sql必知必会">sql必知必会</a></li><li><a href="/blog/操作系统实战45讲">操作系统实战45讲</a></li><li><a href="/blog/网络编程实战">网络编程实战</a></li></ul></li><li>算法<ul><li><a href="/blog/常用算法25讲">常用算法25讲</a></li><li><a href="/blog/数据结构与算法之美">数据结构与算法之美</a></li><li><a href="/blog/业务开发算法50讲">业务开发算法50讲</a></li><li><a href="/blog/动态规划面试宝典">动态规划面试宝典</a></li></ul></li><li>前端开发<ul><li><a href="/blog/浏览器工作原理与实践">浏览器工作原理与实践</a></li><li><a href="/blog/新时代产品经理进阶之路">新时代产品经理进阶之路</a></li><li><a href="/blog/全栈工程师修炼指南">全栈工程师修炼指南</a></li><li><a href="/blog/flutter核心技术与实战">flutter核心技术与实战</a></li><li><a aria-current="page" class="active" href="/blog/java-script核心原理解析">java-script核心原理解析</a></li><li><a href="/blog/说透低代码">说透低代码</a></li><li><a href="/blog/nodejs应用开发实战">nodejs应用开发实战</a></li><li><a href="/blog/反爬虫兵法演绎20讲">反爬虫兵法演绎20讲</a></li><li><a href="/blog/reactnative新架构实战课">reactnative新架构实战课</a></li><li><a href="/blog/正则表达式入门">正则表达式入门</a></li><li><a href="/blog/重学前端">重学前端</a></li><li><a href="/blog/serverless入门课">serverless入门课</a></li><li><a href="/blog/type-script入门实战笔记">type-script入门实战笔记</a></li><li><a href="/blog/图解googlev8">图解googlev8</a></li><li><a href="/blog/vue3源码分析">vue3源码分析</a></li><li><a href="/blog/玩转Vue3全家桶">玩转Vue3全家桶</a></li><li><a href="/blog/webassembly入门">webassembly入门</a></li><li><a href="/blog/手把手带你写一个Web框架">手把手带你写一个Web框架</a></li><li><a href="/blog/web漏洞挖掘实战">web漏洞挖掘实战</a></li><li><a href="/blog/跟月影学可视化">跟月影学可视化</a></li><li><a href="/blog/搞定音频技术">搞定音频技术</a></li><li><a href="/blog/攻克视频技术">攻克视频技术</a></li></ul></li><li>前端工程化<ul><li><a href="/blog/logger">logger</a></li><li><a href="/blog/webpack">webpack</a></li><li><a href="/blog/webpackChain">webpackChain</a></li></ul></li><li>前端性能优化<ul><li><a href="/blog/react性能调优">react性能调优</a></li></ul></li><li>软件测试<ul><li><a href="/blog/全链路压测实战30讲">全链路压测实战30讲</a></li><li><a href="/blog/性能测试实战30讲">性能测试实战30讲</a></li><li><a href="/blog/自动化测试高手课">自动化测试高手课</a></li><li><a href="/blog/软件测试52讲">软件测试52讲</a></li></ul></li><li>面试<ul><li><a href="/blog/面试现场">面试现场</a></li></ul></li><li>杂谈<ul><li><a href="/blog/超级访谈对话张雪峰">超级访谈对话张雪峰</a></li><li><a href="/blog/Git实战手册">Git实战手册</a></li><li><a href="/blog/NodeJS">NodeJS</a></li><li><a href="/blog/ReactJS">ReactJS</a></li><li><a href="/blog/UI设计">UI设计</a></li><li><a href="/blog/webpack4系列教程">webpack4系列教程</a></li><li><a href="/blog/前端知识体系">前端知识体系</a></li><li><a href="/blog/剑指offer刷题笔记">剑指offer刷题笔记</a></li><li><a href="/blog/思考与成长">思考与成长</a></li><li><a href="/blog/设计模式手册">设计模式手册</a></li></ul></li></ul><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "><button title="Dark theme" class="__dumi-default-dark-moon "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="3854" width="22" height="22"><path d="M991.816611 674.909091a69.166545 69.166545 0 0 0-51.665455-23.272727 70.795636 70.795636 0 0 0-27.438545 5.585454A415.674182 415.674182 0 0 1 754.993338 698.181818c-209.594182 0-393.472-184.785455-393.472-395.636363 0-52.363636 38.539636-119.621818 69.515637-173.614546 4.887273-8.610909 9.634909-16.756364 14.103272-24.901818A69.818182 69.818182 0 0 0 384.631156 0a70.842182 70.842182 0 0 0-27.438545 5.585455C161.678429 90.298182 14.362065 307.898182 14.362065 512c0 282.298182 238.824727 512 532.38691 512a522.286545 522.286545 0 0 0 453.957818-268.334545A69.818182 69.818182 0 0 0 991.816611 674.909091zM546.679156 954.181818c-248.785455 0-462.941091-192-462.941091-442.181818 0-186.647273 140.637091-372.829091 300.939637-442.181818-36.817455 65.629091-92.578909 151.970909-92.578909 232.727273 0 250.181818 214.109091 465.454545 462.917818 465.454545a488.331636 488.331636 0 0 0 185.181091-46.545455 453.003636 453.003636 0 0 1-393.565091 232.727273z m103.656728-669.323636l-14.266182 83.781818a34.909091 34.909091 0 0 0 50.362182 36.770909l74.775272-39.563636 74.752 39.563636a36.142545 36.142545 0 0 0 16.174546 3.956364 34.909091 34.909091 0 0 0 34.210909-40.727273l-14.289455-83.781818 60.509091-59.345455a35.025455 35.025455 0 0 0-19.223272-59.578182l-83.61891-12.101818-37.376-76.101818a34.56 34.56 0 0 0-62.254545 0l-37.376 76.101818-83.618909 12.101818a34.909091 34.909091 0 0 0-19.246546 59.578182z m70.423272-64.698182a34.280727 34.280727 0 0 0 26.135273-19.083636l14.312727-29.090909 14.336 29.090909a34.257455 34.257455 0 0 0 26.135273 19.083636l32.046546 4.887273-23.272728 22.574545a35.234909 35.234909 0 0 0-10.007272 30.952727l5.46909 32.116364-28.625454-15.127273a34.490182 34.490182 0 0 0-32.302546 0l-28.695272 15.127273 5.469091-32.116364a35.141818 35.141818 0 0 0-9.984-30.952727l-23.272728-22.574545z" p-id="3855"></path></svg></button><button title="Light theme" class="__dumi-default-dark-sun "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="4026" width="22" height="22"><path d="M915.2 476.16h-43.968c-24.704 0-44.736 16-44.736 35.84s20.032 35.904 44.736 35.904H915.2c24.768 0 44.8-16.064 44.8-35.904s-20.032-35.84-44.8-35.84zM512 265.6c-136.704 0-246.464 109.824-246.464 246.4 0 136.704 109.76 246.464 246.464 246.464S758.4 648.704 758.4 512c0-136.576-109.696-246.4-246.4-246.4z m0 425.6c-99.008 0-179.2-80.128-179.2-179.2 0-98.944 80.192-179.2 179.2-179.2S691.2 413.056 691.2 512c0 99.072-80.192 179.2-179.2 179.2zM197.44 512c0-19.84-19.136-35.84-43.904-35.84H108.8c-24.768 0-44.8 16-44.8 35.84s20.032 35.904 44.8 35.904h44.736c24.768 0 43.904-16.064 43.904-35.904zM512 198.464c19.776 0 35.84-20.032 35.84-44.8v-44.8C547.84 84.032 531.84 64 512 64s-35.904 20.032-35.904 44.8v44.8c0 24.768 16.128 44.864 35.904 44.864z m0 627.136c-19.776 0-35.904 20.032-35.904 44.8v44.736C476.096 940.032 492.16 960 512 960s35.84-20.032 35.84-44.8v-44.736c0-24.768-16.064-44.864-35.84-44.864z m329.92-592.832c17.472-17.536 20.288-43.072 6.4-57.024-14.016-14.016-39.488-11.2-57.024 6.336-4.736 4.864-26.496 26.496-31.36 31.36-17.472 17.472-20.288 43.008-6.336 57.024 13.952 14.016 39.488 11.2 57.024-6.336 4.8-4.864 26.496-26.56 31.296-31.36zM213.376 759.936c-4.864 4.8-26.56 26.624-31.36 31.36-17.472 17.472-20.288 42.944-6.4 56.96 14.016 13.952 39.552 11.2 57.024-6.336 4.8-4.736 26.56-26.496 31.36-31.36 17.472-17.472 20.288-43.008 6.336-56.96-14.016-13.952-39.552-11.072-56.96 6.336z m19.328-577.92c-17.536-17.536-43.008-20.352-57.024-6.336-14.08 14.016-11.136 39.488 6.336 57.024 4.864 4.864 26.496 26.56 31.36 31.424 17.536 17.408 43.008 20.288 56.96 6.336 14.016-14.016 11.264-39.488-6.336-57.024-4.736-4.864-26.496-26.56-31.296-31.424z m527.168 628.608c4.864 4.864 26.624 26.624 31.36 31.424 17.536 17.408 43.072 20.224 57.088 6.336 13.952-14.016 11.072-39.552-6.4-57.024-4.864-4.8-26.56-26.496-31.36-31.36-17.472-17.408-43.072-20.288-57.024-6.336-13.952 14.016-11.008 39.488 6.336 56.96z" p-id="4027"></path></svg></button><button title="Default to system" class="__dumi-default-dark-auto "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="11002" width="22" height="22"><path d="M127.658667 492.885333c0-51.882667 10.24-101.717333 30.378666-149.162666s47.786667-88.064 81.92-122.538667 75.093333-61.781333 122.538667-81.92 96.938667-30.378667 149.162667-30.378667 101.717333 10.24 149.162666 30.378667 88.405333 47.786667 122.88 81.92 61.781333 75.093333 81.92 122.538667 30.378667 96.938667 30.378667 149.162666-10.24 101.717333-30.378667 149.162667-47.786667 88.405333-81.92 122.88-75.093333 61.781333-122.88 81.92-97.28 30.378667-149.162666 30.378667-101.717333-10.24-149.162667-30.378667-88.064-47.786667-122.538667-81.92-61.781333-75.093333-81.92-122.88-30.378667-96.938667-30.378666-149.162667z m329.045333 0c0 130.048 13.994667 244.394667 41.984 343.381334h12.970667c46.762667 0 91.136-9.216 133.461333-27.306667s78.848-42.666667 109.568-73.386667 54.954667-67.242667 73.386667-109.568 27.306667-86.698667 27.306666-133.461333c0-46.421333-9.216-90.794667-27.306666-133.12s-42.666667-78.848-73.386667-109.568-67.242667-54.954667-109.568-73.386667-86.698667-27.306667-133.461333-27.306666h-11.605334c-28.672 123.562667-43.349333 237.909333-43.349333 343.722666z" p-id="11003"></path></svg></button></div></div></div><ul class="__dumi-default-menu-list"><li><a href="/blog/java-script核心原理解析">java-script核心原理解析</a></li><li><a href="/blog/java-script核心原理解析/01.开篇词">01.开篇词</a><ul><li><a href="/blog/java-script核心原理解析/01.开篇词/01"><span>开篇词 | 如何解决语言问题？</span></a></li></ul></li><li><a href="/blog/java-script核心原理解析/02.从零开始java-script语言是如何构建起来的">02.从零开始JavaScript语言是如何构建起来的</a><ul><li><a href="/blog/java-script核心原理解析/02.从零开始java-script语言是如何构建起来的/01"><span>01 | delete 0：JavaScript中到底有什么是可以销毁的</span></a></li><li><a href="/blog/java-script核心原理解析/02.从零开始java-script语言是如何构建起来的/02"><span>02 | var x = y = 100：声明语句与语法改变了JavaScript语言核心性质</span></a></li><li><a href="/blog/java-script核心原理解析/02.从零开始java-script语言是如何构建起来的/03"><span>03 | a.x = a = {n:2}：一道被无数人无数次地解释过的经典面试题</span></a></li><li><a href="/blog/java-script核心原理解析/02.从零开始java-script语言是如何构建起来的/04"><span>04 | export default function() {}：你无法导出一个匿名函数表达式</span></a></li><li><a href="/blog/java-script核心原理解析/02.从零开始java-script语言是如何构建起来的/05"><span>05 | for (let x of [1,2,3]) ...：for循环并不比使用函数递归节省开销</span></a></li><li><a href="/blog/java-script核心原理解析/02.从零开始java-script语言是如何构建起来的/06"><span>加餐 | 捡豆吃豆的学问（上）：这门课讲的是什么？</span></a></li><li><a href="/blog/java-script核心原理解析/02.从零开始java-script语言是如何构建起来的/07"><span>加餐 | 捡豆吃豆的学问（下）：这门课该怎么学？</span></a></li></ul></li><li><a aria-current="page" class="active" href="/blog/java-script核心原理解析/03.从表达式到执行引擎java-script是如何运行的">03.从表达式到执行引擎JavaScript是如何运行的</a><ul><li><a href="/blog/java-script核心原理解析/03.从表达式到执行引擎java-script是如何运行的/01"><span>06 | x: break x;  搞懂如何在循环外使用break，方知语句执行真解</span></a></li><li><a href="/blog/java-script核心原理解析/03.从表达式到执行引擎java-script是如何运行的/02"><span>07 | ${1}：详解JavaScript中特殊的可执行结构</span></a></li><li><a href="/blog/java-script核心原理解析/03.从表达式到执行引擎java-script是如何运行的/03"><span>08 | x =&gt; x：函数式语言的核心抽象：函数与表达式的同一性</span></a></li><li><a href="/blog/java-script核心原理解析/03.从表达式到执行引擎java-script是如何运行的/04"><span>09 | (...x)：不是表达式、语句、函数，但它却能执行</span></a></li><li><a aria-current="page" class="active" href="/blog/java-script核心原理解析/03.从表达式到执行引擎java-script是如何运行的/05"><span>10 | x = yield x：迭代过程的“函数式化”</span></a></li><li><a href="/blog/java-script核心原理解析/03.从表达式到执行引擎java-script是如何运行的/06"><span>11 | throw 1;：它在“最简单语法榜”上排名第三</span></a></li><li><a href="/blog/java-script核心原理解析/03.从表达式到执行引擎java-script是如何运行的/07"><span>加餐 | 让JavaScript运行起来</span></a></li></ul></li><li><a href="/blog/java-script核心原理解析/04.从原型到类java-script是如何一步步走向应用编程语言的">04.从原型到类JavaScript是如何一步步走向应用编程语言的</a><ul><li><a href="/blog/java-script核心原理解析/04.从原型到类java-script是如何一步步走向应用编程语言的/01"><span>12 | 1 in 1..constructor：这行代码的结果，既可能是true，也可能是false</span></a></li><li><a href="/blog/java-script核心原理解析/04.从原型到类java-script是如何一步步走向应用编程语言的/02"><span>13 | new X：从构造器到类，为你揭密对象构造的全程</span></a></li><li><a href="/blog/java-script核心原理解析/04.从原型到类java-script是如何一步步走向应用编程语言的/03"><span>14 | super.xxx()：虽然直到ES10还是个半吊子实现，却也值得一讲</span></a></li><li><a href="/blog/java-script核心原理解析/04.从原型到类java-script是如何一步步走向应用编程语言的/04"><span>15 | return Object.create(new.target.prototype)：做框架设计的基本功：写一个根类</span></a></li><li><a href="/blog/java-script核心原理解析/04.从原型到类java-script是如何一步步走向应用编程语言的/05"><span>16 | [a, b] = {a, b}：让你从一行代码看到对象的本质</span></a></li><li><a href="/blog/java-script核心原理解析/04.从原型到类java-script是如何一步步走向应用编程语言的/06"><span>17 | Object.setPrototypeOf(x, null)：连Brendan Eich都认错，但null值还活着</span></a></li></ul></li><li><a href="/blog/java-script核心原理解析/05.从粗通到精通的进阶之路唯一不变的是变化本身">05.从粗通到精通的进阶之路唯一不变的是变化本身</a><ul><li><a href="/blog/java-script核心原理解析/05.从粗通到精通的进阶之路唯一不变的是变化本身/01"><span>18 | a + b：动态类型是灾难之源还是最好的特性？（上）</span></a></li><li><a href="/blog/java-script核心原理解析/05.从粗通到精通的进阶之路唯一不变的是变化本身/02"><span>19 | a + b：动态类型是灾难之源还是最好的特性？（下）</span></a></li><li><a href="/blog/java-script核心原理解析/05.从粗通到精通的进阶之路唯一不变的是变化本身/03"><span>20 | (0, eval)(&quot;x = 100&quot;) ：一行让严格模式形同虚设的破坏性设计（上）</span></a></li><li><a href="/blog/java-script核心原理解析/05.从粗通到精通的进阶之路唯一不变的是变化本身/04"><span>21 | (0, eval)(&quot;x = 100&quot;) ：一行让严格模式形同虚设的破坏性设计（下）</span></a></li><li><a href="/blog/java-script核心原理解析/05.从粗通到精通的进阶之路唯一不变的是变化本身/05"><span>22 | new Function(&#x27;x = 100&#x27;)();：函数的类化是对动态与静态系统的再次统一</span></a></li></ul></li><li><a href="/blog/java-script核心原理解析/06.结束语">06.结束语</a><ul><li><a href="/blog/java-script核心原理解析/06.结束语/01"><span>结束语 | 愿你能做一个真正“懂”的程序员</span></a></li><li><a href="/blog/java-script核心原理解析/06.结束语/02"><span>结课测试 | 这些JavaScript知识，你真的掌握了吗？</span></a></li></ul></li><li><a href="/blog/java-script核心原理解析/summary">java-script核心原理解析</a></li></ul></div></div><ul role="slug-list" class="__dumi-default-layout-toc"><li title="将迭代过程展开" data-depth="2"><a href="/blog/java-script核心原理解析/03.从表达式到执行引擎java-script是如何运行的/05#将迭代过程展开"><span>将迭代过程展开</span></a></li><li title="逻辑的重现" data-depth="2"><a href="/blog/java-script核心原理解析/03.从表达式到执行引擎java-script是如何运行的/05#逻辑的重现"><span>逻辑的重现</span></a></li><li title="有趣的.next()方法" data-depth="2"><a href="/blog/java-script核心原理解析/03.从表达式到执行引擎java-script是如何运行的/05#有趣的next方法"><span>有趣的.next()方法</span></a></li><li title="对传入参数的改造" data-depth="2"><a href="/blog/java-script核心原理解析/03.从表达式到执行引擎java-script是如何运行的/05#对传入参数的改造"><span>对传入参数的改造</span></a></li><li title="知识回顾" data-depth="2"><a href="/blog/java-script核心原理解析/03.从表达式到执行引擎java-script是如何运行的/05#知识回顾"><span>知识回顾</span></a></li><li title="思考题" data-depth="2"><a href="/blog/java-script核心原理解析/03.从表达式到执行引擎java-script是如何运行的/05#思考题"><span>思考题</span></a></li></ul><div class="__dumi-default-layout-content"><div class="markdown"><h1 id="10--x--yield-x迭代过程的函数式化"><a aria-hidden="true" tabindex="-1" href="/blog/java-script核心原理解析/03.从表达式到执行引擎java-script是如何运行的/05#10--x--yield-x迭代过程的函数式化"><span class="icon icon-link"></span></a>10 | x = yield x：迭代过程的“函数式化”</h1><p>你好，我是周爱民。欢迎回到我的专栏。</p><p>相信上一讲的迭代过程已经在许多人心中留下了巨大的阴影，所以很多人一看今天的标题，第一个反应是：“又来！”</p><p>其实我经常习惯用<strong>同一个例子</strong>，或者<strong>同类型示例的细微不同</strong>去分辨与反映语言特性上的核心与本质的不同。如同在<a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/165198">第2讲<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>和<a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/165985">第3讲<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>中都在讲的连续赋值，看起来形似，却根本上不同。</p><p>同样，我想你可能也已经注意到了，在<a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/167907">第5讲<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>（for (let x of [1,2,3]) ...）和<a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/172636">第9讲<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>（(...x)）中所讲述的内容是有一些相关性的。它们都是在讲循环。但第5讲主要讨论的是语句对循环的抽象和如何在循环中处理块。而第9讲则侧重于如何通过函数执行把（类似第5讲的）语句执行重新来实现一遍。事实上，仅仅是一个“循环过程”，在JavaScript中就实现了好几次。这些我将来都会具体地来为你分析。</p><p>至于今天，我还是回到函数的三个语义组件，也就是“参数、执行体和结果”来讨论。上一讲本质上讨论的是对“执行体”这个组件的重造，今天，则讨论对“参数和结果”的重构。</p><h2 id="将迭代过程展开"><a aria-hidden="true" tabindex="-1" href="/blog/java-script核心原理解析/03.从表达式到执行引擎java-script是如何运行的/05#将迭代过程展开"><span class="icon icon-link"></span></a>将迭代过程展开</h2><p>通过上一讲，你应该知道迭代器是可以表达为一组函数的连续执行的。那么，如果我们要把这一组函数展开来看的话，其实它们之间的相似性是极强的。例如上一讲中提到的迭代函数<code>foo()</code>，当你把它作为对象x的迭代器符号名属性，并通过对象x来调用它的迭代展开，事实上也就相当于只调用了多次的return语句。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// 迭代函数</span></div><div class="token-line"><span class="token plain">    function foo(x = 5) {</span></div><div class="token-line"><span class="token plain">      return {</span></div><div class="token-line"><span class="token plain">        next: () =&gt; {</span></div><div class="token-line"><span class="token plain">          return {done: !x, value: x &amp;&amp; x--};</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">      }</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    let x = new Object;</span></div><div class="token-line"><span class="token plain">    x[Symbol.iterator] = foo; // default `x` is 5</span></div><div class="token-line"><span class="token plain">    console.log(...x);</span></div></pre></div><p>事实上相当于只调用了5次return语句，可以展开如下：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// 上例在形式上可以表达为如下的逻辑</span></div><div class="token-line"><span class="token plain">    console.log(</span></div><div class="token-line"><span class="token plain">      /*return */{done: false, value: 5}.value,</span></div><div class="token-line"><span class="token plain">      /*return */{done: false, value: 4}.value,</span></div><div class="token-line"><span class="token plain">      /*return */{done: false, value: 3}.value,</span></div><div class="token-line"><span class="token plain">      /*return */{done: false, value: 2}.value,</span></div><div class="token-line"><span class="token plain">      /*return */{done: false, value: 1}.value</span></div><div class="token-line"><span class="token plain">    );</span></div></pre></div><p>在形式上，类似上面这样的例子也可以展开来，表现它作为“多个值”的输出过程。</p><p>事实上连续的tor.next()调用最终仅是为了获取它们的值（result.value），那么如果封装这些值的生成过程，就可以用一个新的函数来替代一批函数。</p><p>这样的一个函数就称为<strong>生成器函数</strong>。</p><p>但是，由于函数只有一个出口（RETURN），所以用“函数的退出”是无法映射“<strong>函数包含一个多次生成值的过程</strong>”这样的概念的。如果要实现这一点，就必须让函数可以多次进入和退出。而这，就是今天这一讲的标题上的这个<code>yield</code> 运算符的作用。这些作用有两个方面：</p><ol><li>逻辑上：它产生一次函数的退出，并接受下一次tor.next()调用所需要的进入；</li><li>数据上：它在退出时传出指定的值（结果），并在进入时携带传入的数据（参数）。</li></ol><p>所以，<code>yield</code>实际上就是在生成器函数中用较少的代价来实现一个完整“函数执行”过程所需的“参数和结果”。而至于“执行体”这个组件，如果你听过上一讲的话，相信你已经知道了：执行体就是tor.next()所推动的那个迭代逻辑。</p><p>例如，上面的例子用生成器来实现就是：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">function *foo() {</span></div><div class="token-line"><span class="token plain">      yield 5;</span></div><div class="token-line"><span class="token plain">      yield 4;</span></div><div class="token-line"><span class="token plain">      yield 3;</span></div><div class="token-line"><span class="token plain">      yield 2;</span></div><div class="token-line"><span class="token plain">      yield 1;</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>或者更通用的过程：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">function *foo2(x=5) {</span></div><div class="token-line"><span class="token plain">      while (x--) yield x;</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    // 测试</span></div><div class="token-line"><span class="token plain">    let x = new Object;</span></div><div class="token-line"><span class="token plain">    x[Symbol.iterator] = foo2; // default `x` is 5</span></div><div class="token-line"><span class="token plain">    console.log(...x); // 4 3 2 1 0</span></div></pre></div><p>我们又看到了循环，尽管它被所谓的生成器函数封装了一次。</p><h2 id="逻辑的重现"><a aria-hidden="true" tabindex="-1" href="/blog/java-script核心原理解析/03.从表达式到执行引擎java-script是如何运行的/05#逻辑的重现"><span class="icon icon-link"></span></a>逻辑的重现</h2><p>我想你已经注意到了，生成器的关键在于如何产生<code>yield</code>运算所需要的两个逻辑：（函数的）退出和进入。</p><p>事实上生成器内部是顺序的5行代码，还是一个循环逻辑，所以对于外部的使用者来说它是不可知的。生成器通过一个迭代器接口的界面与外部交互，只要<code>for..of</code>或<code>...x</code>以及其他任何语法、语句或表达式识别该迭代器接口，那么它们就可以用tor.next()以及result.done状态来组织外部的业务逻辑，而不必界面后面的（例如数据传入传出的）细节了。</p><p>然而，对于生成器来说，“（函数的）退出和进入”是如何实现的呢？</p><p>在<a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/168980">第6讲<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>（x: break x;）中提到过“<strong>执行现场</strong>”这个东西，事实上它包括三个层面的概念：</p><ol><li>块级作用域以及其他的作用域本质上就是一帧数据，交由所谓“环境”来管理；</li><li>函数是通过CALL/RETURN来模拟上述“数据帧”在栈上的入栈与出栈过程，也称为调用栈；</li><li>执行现场是上述环境和调用栈的一个瞬时快照（包括栈上数据的状态和执行的“位置”）。</li></ol><p>其中的“位置”是一个典型的与“（逻辑的）执行过程”相关的东西，第六讲中的“break”就主要在讲这个“位置”的控制——包括静态的标签，以及标签在执行过程中所映射到的位置。</p><p>函数的进入（CALL）意味着数据帧的建立以及该数据帧压入调用栈，而退出（RETURN）意味着它弹出栈和数据帧的销毁。从这个角度上来说，<code>yield</code>运算必然不能使该函数退出（或者说必须不能让数据帧从栈上移除和销毁）。因为<code>yield</code>之后还有其他代码，而一旦数据帧销毁了，那么其他代码就无法执行了。</p><p>所以，<code>yield</code>是为数不多的能“挂起”当前函数的运算。但这并不是<code>yield</code>主要的、标志性的行为。<code>yield</code>操作最大的特点是<strong>它在挂起当前函数时，还将函数所在栈上的执行现场移出了调用栈</strong>。由于<code>yield</code>可以存在于生成器函数内的第n层作用域中。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">function foo3() { // 块作用域1</span></div><div class="token-line"><span class="token plain">      if (true) {  // 块作用域2</span></div><div class="token-line"><span class="token plain">        while (true) { // 块作用域3</span></div><div class="token-line"><span class="token plain">          yield 100</span></div><div class="token-line"><span class="token plain">          ...</span></div></pre></div><p>所以，一个在多级的块作用域深处的<code>yield</code>运算发生时，需要向这个数据帧（作用域链）外层检索到第一个函数帧（即函数环境，FunctionEnvironment），挂起它以及它内部的全部环境。而执行位置，将会通过函数的调用关系，一次性地返回到上一次tor.next()的下一行代码。也就是说相当于在tor.next()内部执行了一次<code>return</code>。</p><p>为了简化所谓“向外层检索”这一行为，JavaScript通常是使用所谓“执行上下文”来管理这些数据帧（环境）与执行位置的。执行上下文与函数或代码块的词法上下文不同，因为执行上下文只与“可执行体”相关，是JavaScript引擎内部的数据结构，它总是被关联（且仅只关联）到一个函数入口。</p><p>由于JavaScript引擎将JavaScript代码理解为函数，因此事实上这个“执行上下文”能关联所有的用户代码文本。</p><p>“所有的代码文本”意味着“.js文件”的全局入口也会被封装成一个函数，且全部的模块顶层代码也会做相同的封装。这样一来，所有通过文件装载的代码文本都会只存在于同一个函数中。由于在Node.js或其他一些具体实现的引擎中，无法同时使用标准的ECMAScript模块装载和.js文件装载，因此事实上来说，这些引擎在运行JavaScript代码时（通常地）也就只有一个入口的函数。</p><p>而所有的代码其实也就只运行在该函数的、唯一的一个“执行上下文”中。</p><p>如果用户代码——通过任意的手段——试图挂起这唯一的执行上下文，那么也就意味着整个的JavaScript都停止了执行。因此，“挂起”这个上下文的操作是受限制的，被一系列特定的操作规范管理。这些规范我在这一讲的稍晚部分内容中会详细讲述，但这里，我们先关注一个关键问题：到底有多少个执行上下文？</p><p>如果模块与文件装载机制分开，那么模块入口和文件入口就是二选一的。当然在不同的引擎中这也不尽相同，只是在这里分开讨论会略为清晰一些。</p><p><strong>模块入口</strong>是所有模块的顶层代码的顺序组合，它们被封装为一个称为“顶层模块执行（TopLevelModule Evaluation Job）”的函数，作为模块加载的第一个执行上下文创建。类似的是，一般的.js文件装载也会创建一个称为“脚本执行（Script EvaluationJob）”的函数。后者，也是文件加载中所有全局代码块称为“Script块”的原因。</p><p>除了这两种执行上下文之外，eval()总是会开启一个执行上下文的。</p><p>JavaScript为eval()所分配的这个执行上下文，与调用eval()时的函数上下文享有同一个环境（包括词法环境和变量环境等等），并在退出eval()时释放它的引用，以确保同一个环境中“同时”只有一个逻辑在执行。</p><p>接下来，如果一个一般函数被调用，那么它也将形成一个对应的执行上下文，但是由于这个上下文是“被”调用而产生的，所以它会创建一个“调用者（caller）”函数的上下文的关联，并创建在caller之后。由于栈是后入先出的结构，因此总是立即执行这个“被调用者（callee）”函数的上下文。</p><p>这也是调用栈入栈“等义于”调用函数的原因。</p><p>但这个过程也就意味着这个“当前的（活动的）”调用栈是由一系列执行上下文以及它们所包含的数据帧所构成的。而且，就目前来说，这个调用栈的底部，要么是模块全局（_TopLevelModuleEvaluationJob_任务），要么就是脚本全局（_ScriptEvaluationJob_任务）。</p><p>一旦你了解了这些，那么你就很容易理解生成器的特殊之处了：</p><p>所有其他上下文都在执行栈上，而生成器的上下文（多数时间是）在栈的外面。</p><h2 id="有趣的next方法"><a aria-hidden="true" tabindex="-1" href="/blog/java-script核心原理解析/03.从表达式到执行引擎java-script是如何运行的/05#有趣的next方法"><span class="icon icon-link"></span></a>有趣的.next()方法</h2><p>如果有一行<code>yield</code>代码出现在生成器函数中，那么当这个生成器函数执行到<code>yield</code>表达式时会发生什么呢？</p><p>这个问题貌似不好回答，但是如果问：是什么让这个生成器函数执行到“<code>yeild</code>表达式”所在位置的呢？这个问题就好回答了：是tor.next()方法。如下例：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">function* foo3() {</span></div><div class="token-line"><span class="token plain">      yield 10;</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    let tor = foo3();</span></div><div class="token-line"><span class="token plain">    ...</span></div></pre></div><p>我们可以简单地写一个生成器函数<code>foo3()</code>，它的内部只有一行<code>yield</code>代码。在这样的一个示例中，调用foo3()函数之后，你就已经获得了来自foo3()的一个迭代器对象，在习惯上的，我称它为tor。并且，在语法形式上，貌似foo3()函数已经执行了一次。</p><p>但是，事实上foo3()所声明的函数体并没有执行（因为它是生成器函数），而是直到用户代码调用<code>tor.next()</code>的时候，foo3()所声明的函数体才正式执行并直到那唯一的一行代码：表达式<code>yeild</code>。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain"># 调用迭代器方法</span></div><div class="token-line"><span class="token plain">    &gt; tor.next()</span></div><div class="token-line"><span class="token plain">    { value: 10, done: false }</span></div></pre></div><p>这时，foo3()所声明的函数体正式执行，并直到表达式<code>yeild 10</code>，生成器函数才返回了第一个值<code>10</code>。</p><p>如同上一讲中所说到的，这表明在代码<code>tor = foo3()</code>中，函数调用“foo3()”的实际执行效果是：生成一个迭代过程，并将该过程交给了tor对象。</p><p>换而言之：tor是foo3()生成器（内部的）迭代过程的一个句柄。从引擎内的实现过程来说，tor其实包括状态（state）和执行上下文（context）两个信息，它是<code>GeneratorFunction.prototype</code>的一个实例。这个tor所代表的生成器在创建出来的时候将立即被挂起，因此状态值（state）初始化置为&quot;启动时挂起（suspendedStart）&quot;，而当在调用tor.next()因<code>yield</code>运算而导致的挂起称为&quot;Yield时挂起（suspendedYield）&quot;。</p><p>另一个信息，即context，就指向tor被创建时的上下文。上面已经说过了，所谓上下文一定指的是一个外部的、内部的或由全局/模块入口映射成的函数。</p><p>接下来，当tor.next()执行时，tor所包括的context信息被压到栈顶执行；当tor.next()退出时，这个context就被从栈上移除。这个过程与调用eval()是类似的，总是能保证指定栈是全局唯一活动的一个栈。</p><p>如果活动栈唯一，那么系统就是同步的。</p><p>因为只需要一个执行线程。</p><h2 id="对传入参数的改造"><a aria-hidden="true" tabindex="-1" href="/blog/java-script核心原理解析/03.从表达式到执行引擎java-script是如何运行的/05#对传入参数的改造"><span class="icon icon-link"></span></a>对传入参数的改造</h2><p>生成器对“函数执行”的执行体加以改造，使之变成由tor.next()管理的多个片断。用来映射多次函数调用的“每个body”。除此之外，它还对传入参数加以改造，使执行“每个body”时可以接受不同的参数。这些参数是通过tor.next()来传入，并作为yield运算的结果而使用的。</p><p>这里JavaScript偷偷地更换了概念。也就是说， 在：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">x = yield x</span></div></pre></div><p>这行表达式中，从语法上看是表达式<code>yield x</code>求值，实际的执行效果是：</p><ul><li><code>yield</code>向函数外发送计算表达式<code>x</code>的值；</li></ul><p>而 <code>x = ...</code>的赋值语义变成了：</p><ul><li><code>yield</code>接受外部传入的参数并作为结果赋给x。</li></ul><p>将tor.next()联合起来看，由于tor所对应的上下文在创建后总是挂起的，因此第一个tor.next()调用总是将执行过程“推进”到第一行<code>yield</code>并挂起。例如：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">function* foo4(x=5) {</span></div><div class="token-line"><span class="token plain">      console.log(x--); // `tor = foo4()`时传入的值5</span></div><div class="token-line"><span class="token plain">      // ...</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">      x = yield x; // 传出`x`的值</span></div><div class="token-line"><span class="token plain">      console.log(x); // 传入的arg</span></div><div class="token-line"><span class="token plain">      // ...</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    let tor = foo4(); // default `x` is 5</span></div><div class="token-line"><span class="token plain">    result = tor.next(); // 第一次调用.next()的参数将被忽略</span></div><div class="token-line"><span class="token plain">    console.log(result.value)</span></div></pre></div><p>执行结果将显示：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">5    // &lt;- defaut `5`</span></div><div class="token-line"><span class="token plain">    4    // &lt;- result.value `4`</span></div></pre></div><p>而foo4()函数在<code>yield</code>表达式执行后将挂起。而当在下一次调用tor.next(arg)时，一个已经被<code>yield</code>挂起的生成器将恢复（resume），这时传入的参数arg就将作为<code>yield</code>表达式（在它的上下文中）的结果。也就是上例中第二个console.log(x)中的<code>x</code>值。例如：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain"># 传入100，将作为foo4()内的yield表达式求值结果赋给`x = ...`</span></div><div class="token-line"><span class="token plain">    &gt; tor.next(100)</span></div><div class="token-line"><span class="token plain">    100</span></div></pre></div><h2 id="知识回顾"><a aria-hidden="true" tabindex="-1" href="/blog/java-script核心原理解析/03.从表达式到执行引擎java-script是如何运行的/05#知识回顾"><span class="icon icon-link"></span></a>知识回顾</h2><p>今天这一讲，谈的是将迭代过程展开并重新组织它的语义，然后变成生成器与<code>yield</code>运算的全过程。</p><p>在这个过程中，你需要关注的是JavaScript对“迭代过程”展开之后的代码体和参数处理。</p><p>事实上，这包含了对函数的全部三个组件的重新定义：代码体、参数传入、值传出。只不过，在<code>yield</code>中尤其展现了对传入传出的处理而已。</p><h2 id="思考题"><a aria-hidden="true" tabindex="-1" href="/blog/java-script核心原理解析/03.从表达式到执行引擎java-script是如何运行的/05#思考题"><span class="icon icon-link"></span></a>思考题</h2><p>今天的这一讲不安排什么特别的课后思考，我希望你能补充一下一个小知识点的内容：由于今天的内容中没有讲“委托的yield”这个话题，因此你可以安排一些时间查阅资料，对这个运算符——也就是“yeild*”的实现过程和特点做一些深入探索。</p><p>欢迎你在进行深入思考后，与其他同学分享自己的想法，也让我有机会能听听你的收获。</p></div><div class="__dumi-default-layout-footer-meta"><a target="_blank" rel="noopener noreferrer" href="https://github.com/GGwujun/blog/edit/master/docs/java-script核心原理解析/03.从表达式到执行引擎JavaScript是如何运行的/05.md">在 GitHub 上编辑此页<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a><span data-updated-text="最后更新时间：">5/2/2022 10:56:38</span></div></div></div></div>
	<script>
  window.g_useSSR = true;
  window.g_initialProps = {};
	</script>

    <script>
      (function () {
        if (!location.port) {
          (function (i, s, o, g, r, a, m) {
            i["GoogleAnalyticsObject"] = r;
            (i[r] =
              i[r] ||
              function () {
                (i[r].q = i[r].q || []).push(arguments);
              }),
              (i[r].l = 1 * new Date());
            (a = s.createElement(o)), (m = s.getElementsByTagName(o)[0]);
            a.async = 1;
            a.src = g;
            m.parentNode.insertBefore(a, m);
          })(
            window,
            document,
            "script",
            "//www.google-analytics.com/analytics.js",
            "ga"
          );
          ga("create", "UA-149864185-1", "auto");
          ga("send", "pageview");
        }
      })();
    </script>
    <script src="/blog/umi.js"></script>
  </body>
</html>
