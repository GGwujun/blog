<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no"
    />
    <link rel="shortcut icon" type="image/x-icon" href="/logo.png" />
    <link rel="stylesheet" href="/blog/umi.css" />
    <script>
      window.routerBase = "/blog";
    </script>
    <script>
      //! umi version: 3.5.17
    </script>
    <script>
      !(function () {
        var e = localStorage.getItem("dumi:prefers-color"),
          t = window.matchMedia("(prefers-color-scheme: dark)").matches,
          r = ["light", "dark", "auto"];
        document.documentElement.setAttribute(
          "data-prefers-color",
          e === r[2] ? (t ? r[1] : r[0]) : r.indexOf(e) > -1 ? e : r[0]
        );
      })();
    </script>
    <title>18 | a + b：动态类型是灾难之源还是最好的特性？（上）</title>
  </head>
  <body>
    <div id="root"><div class="__dumi-default-layout" data-route="/java-script核心原理解析/05.从粗通到精通的进阶之路唯一不变的是变化本身/01" data-show-sidemenu="true" data-show-slugs="true" data-site-mode="true" data-gapless="false"><div class="__dumi-default-navbar" data-mode="site"><button class="__dumi-default-navbar-toggle"></button><a class="__dumi-default-navbar-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog/">大师兄</a><nav><div class="__dumi-default-search"><input type="search" class="__dumi-default-search-input" value=""/><ul></ul></div><span>计算机基础<ul><li><a href="/blog/编译原理之美">编译原理之美</a></li><li><a href="/blog/编译原理实战">编译原理实战</a></li><li><a href="/blog/深入浅出计算机组成原理">深入浅出计算机组成原理</a></li><li><a href="/blog/详解http">详解http</a></li><li><a href="/blog/计算机网络通关29讲">计算机网络通关29讲</a></li><li><a href="/blog/网络排查案例课">网络排查案例课</a></li><li><a href="/blog/linux操作系统">linux操作系统</a></li><li><a href="/blog/linux性能优化实战">linux性能优化实战</a></li><li><a href="/blog/程序员数学基础">程序员数学基础</a></li><li><a href="/blog/趣谈网络协议">趣谈网络协议</a></li><li><a href="/blog/操作系统实战">操作系统实战</a></li><li><a href="/blog/软件工程之美">软件工程之美</a></li><li><a href="/blog/sql必知必会">sql必知必会</a></li><li><a href="/blog/操作系统实战45讲">操作系统实战45讲</a></li><li><a href="/blog/网络编程实战">网络编程实战</a></li></ul></span><span>算法<ul><li><a href="/blog/常用算法25讲">常用算法25讲</a></li><li><a href="/blog/数据结构与算法之美">数据结构与算法之美</a></li><li><a href="/blog/业务开发算法50讲">业务开发算法50讲</a></li><li><a href="/blog/动态规划面试宝典">动态规划面试宝典</a></li></ul></span><span>前端开发<ul><li><a href="/blog/浏览器工作原理与实践">浏览器工作原理与实践</a></li><li><a href="/blog/新时代产品经理进阶之路">新时代产品经理进阶之路</a></li><li><a href="/blog/全栈工程师修炼指南">全栈工程师修炼指南</a></li><li><a href="/blog/flutter核心技术与实战">flutter核心技术与实战</a></li><li><a aria-current="page" class="active" href="/blog/java-script核心原理解析">java-script核心原理解析</a></li><li><a href="/blog/说透低代码">说透低代码</a></li><li><a href="/blog/nodejs应用开发实战">nodejs应用开发实战</a></li><li><a href="/blog/反爬虫兵法演绎20讲">反爬虫兵法演绎20讲</a></li><li><a href="/blog/reactnative新架构实战课">reactnative新架构实战课</a></li><li><a href="/blog/正则表达式入门">正则表达式入门</a></li><li><a href="/blog/重学前端">重学前端</a></li><li><a href="/blog/serverless入门课">serverless入门课</a></li><li><a href="/blog/type-script入门实战笔记">type-script入门实战笔记</a></li><li><a href="/blog/图解googlev8">图解googlev8</a></li><li><a href="/blog/vue3源码分析">vue3源码分析</a></li><li><a href="/blog/玩转Vue3全家桶">玩转Vue3全家桶</a></li><li><a href="/blog/webassembly入门">webassembly入门</a></li><li><a href="/blog/手把手带你写一个Web框架">手把手带你写一个Web框架</a></li><li><a href="/blog/web漏洞挖掘实战">web漏洞挖掘实战</a></li><li><a href="/blog/跟月影学可视化">跟月影学可视化</a></li><li><a href="/blog/搞定音频技术">搞定音频技术</a></li><li><a href="/blog/攻克视频技术">攻克视频技术</a></li></ul></span><span>前端工程化<ul><li><a href="/blog/logger">logger</a></li><li><a href="/blog/webpack">webpack</a></li><li><a href="/blog/webpackChain">webpackChain</a></li></ul></span><span>前端性能优化<ul><li><a href="/blog/react性能调优">react性能调优</a></li></ul></span><span>软件测试<ul><li><a href="/blog/全链路压测实战30讲">全链路压测实战30讲</a></li><li><a href="/blog/性能测试实战30讲">性能测试实战30讲</a></li><li><a href="/blog/自动化测试高手课">自动化测试高手课</a></li><li><a href="/blog/软件测试52讲">软件测试52讲</a></li></ul></span><span>面试<ul><li><a href="/blog/面试现场">面试现场</a></li></ul></span><span>杂谈<ul><li><a href="/blog/超级访谈对话张雪峰">超级访谈对话张雪峰</a></li><li><a href="/blog/Git实战手册">Git实战手册</a></li><li><a href="/blog/NodeJS">NodeJS</a></li><li><a href="/blog/ReactJS">ReactJS</a></li><li><a href="/blog/UI设计">UI设计</a></li><li><a href="/blog/webpack4系列教程">webpack4系列教程</a></li><li><a href="/blog/前端知识体系">前端知识体系</a></li><li><a href="/blog/剑指offer刷题笔记">剑指offer刷题笔记</a></li><li><a href="/blog/思考与成长">思考与成长</a></li><li><a href="/blog/设计模式手册">设计模式手册</a></li></ul></span><div class="__dumi-default-navbar-tool"><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "></div></div></div></nav></div><div class="__dumi-default-menu" data-mode="site"><div class="__dumi-default-menu-inner"><div class="__dumi-default-menu-header"><a class="__dumi-default-menu-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog/"></a><h1>大师兄</h1><p></p></div><div class="__dumi-default-menu-mobile-area"><ul class="__dumi-default-menu-nav-list"><li>计算机基础<ul><li><a href="/blog/编译原理之美">编译原理之美</a></li><li><a href="/blog/编译原理实战">编译原理实战</a></li><li><a href="/blog/深入浅出计算机组成原理">深入浅出计算机组成原理</a></li><li><a href="/blog/详解http">详解http</a></li><li><a href="/blog/计算机网络通关29讲">计算机网络通关29讲</a></li><li><a href="/blog/网络排查案例课">网络排查案例课</a></li><li><a href="/blog/linux操作系统">linux操作系统</a></li><li><a href="/blog/linux性能优化实战">linux性能优化实战</a></li><li><a href="/blog/程序员数学基础">程序员数学基础</a></li><li><a href="/blog/趣谈网络协议">趣谈网络协议</a></li><li><a href="/blog/操作系统实战">操作系统实战</a></li><li><a href="/blog/软件工程之美">软件工程之美</a></li><li><a href="/blog/sql必知必会">sql必知必会</a></li><li><a href="/blog/操作系统实战45讲">操作系统实战45讲</a></li><li><a href="/blog/网络编程实战">网络编程实战</a></li></ul></li><li>算法<ul><li><a href="/blog/常用算法25讲">常用算法25讲</a></li><li><a href="/blog/数据结构与算法之美">数据结构与算法之美</a></li><li><a href="/blog/业务开发算法50讲">业务开发算法50讲</a></li><li><a href="/blog/动态规划面试宝典">动态规划面试宝典</a></li></ul></li><li>前端开发<ul><li><a href="/blog/浏览器工作原理与实践">浏览器工作原理与实践</a></li><li><a href="/blog/新时代产品经理进阶之路">新时代产品经理进阶之路</a></li><li><a href="/blog/全栈工程师修炼指南">全栈工程师修炼指南</a></li><li><a href="/blog/flutter核心技术与实战">flutter核心技术与实战</a></li><li><a aria-current="page" class="active" href="/blog/java-script核心原理解析">java-script核心原理解析</a></li><li><a href="/blog/说透低代码">说透低代码</a></li><li><a href="/blog/nodejs应用开发实战">nodejs应用开发实战</a></li><li><a href="/blog/反爬虫兵法演绎20讲">反爬虫兵法演绎20讲</a></li><li><a href="/blog/reactnative新架构实战课">reactnative新架构实战课</a></li><li><a href="/blog/正则表达式入门">正则表达式入门</a></li><li><a href="/blog/重学前端">重学前端</a></li><li><a href="/blog/serverless入门课">serverless入门课</a></li><li><a href="/blog/type-script入门实战笔记">type-script入门实战笔记</a></li><li><a href="/blog/图解googlev8">图解googlev8</a></li><li><a href="/blog/vue3源码分析">vue3源码分析</a></li><li><a href="/blog/玩转Vue3全家桶">玩转Vue3全家桶</a></li><li><a href="/blog/webassembly入门">webassembly入门</a></li><li><a href="/blog/手把手带你写一个Web框架">手把手带你写一个Web框架</a></li><li><a href="/blog/web漏洞挖掘实战">web漏洞挖掘实战</a></li><li><a href="/blog/跟月影学可视化">跟月影学可视化</a></li><li><a href="/blog/搞定音频技术">搞定音频技术</a></li><li><a href="/blog/攻克视频技术">攻克视频技术</a></li></ul></li><li>前端工程化<ul><li><a href="/blog/logger">logger</a></li><li><a href="/blog/webpack">webpack</a></li><li><a href="/blog/webpackChain">webpackChain</a></li></ul></li><li>前端性能优化<ul><li><a href="/blog/react性能调优">react性能调优</a></li></ul></li><li>软件测试<ul><li><a href="/blog/全链路压测实战30讲">全链路压测实战30讲</a></li><li><a href="/blog/性能测试实战30讲">性能测试实战30讲</a></li><li><a href="/blog/自动化测试高手课">自动化测试高手课</a></li><li><a href="/blog/软件测试52讲">软件测试52讲</a></li></ul></li><li>面试<ul><li><a href="/blog/面试现场">面试现场</a></li></ul></li><li>杂谈<ul><li><a href="/blog/超级访谈对话张雪峰">超级访谈对话张雪峰</a></li><li><a href="/blog/Git实战手册">Git实战手册</a></li><li><a href="/blog/NodeJS">NodeJS</a></li><li><a href="/blog/ReactJS">ReactJS</a></li><li><a href="/blog/UI设计">UI设计</a></li><li><a href="/blog/webpack4系列教程">webpack4系列教程</a></li><li><a href="/blog/前端知识体系">前端知识体系</a></li><li><a href="/blog/剑指offer刷题笔记">剑指offer刷题笔记</a></li><li><a href="/blog/思考与成长">思考与成长</a></li><li><a href="/blog/设计模式手册">设计模式手册</a></li></ul></li></ul><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "><button title="Dark theme" class="__dumi-default-dark-moon "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="3854" width="22" height="22"><path d="M991.816611 674.909091a69.166545 69.166545 0 0 0-51.665455-23.272727 70.795636 70.795636 0 0 0-27.438545 5.585454A415.674182 415.674182 0 0 1 754.993338 698.181818c-209.594182 0-393.472-184.785455-393.472-395.636363 0-52.363636 38.539636-119.621818 69.515637-173.614546 4.887273-8.610909 9.634909-16.756364 14.103272-24.901818A69.818182 69.818182 0 0 0 384.631156 0a70.842182 70.842182 0 0 0-27.438545 5.585455C161.678429 90.298182 14.362065 307.898182 14.362065 512c0 282.298182 238.824727 512 532.38691 512a522.286545 522.286545 0 0 0 453.957818-268.334545A69.818182 69.818182 0 0 0 991.816611 674.909091zM546.679156 954.181818c-248.785455 0-462.941091-192-462.941091-442.181818 0-186.647273 140.637091-372.829091 300.939637-442.181818-36.817455 65.629091-92.578909 151.970909-92.578909 232.727273 0 250.181818 214.109091 465.454545 462.917818 465.454545a488.331636 488.331636 0 0 0 185.181091-46.545455 453.003636 453.003636 0 0 1-393.565091 232.727273z m103.656728-669.323636l-14.266182 83.781818a34.909091 34.909091 0 0 0 50.362182 36.770909l74.775272-39.563636 74.752 39.563636a36.142545 36.142545 0 0 0 16.174546 3.956364 34.909091 34.909091 0 0 0 34.210909-40.727273l-14.289455-83.781818 60.509091-59.345455a35.025455 35.025455 0 0 0-19.223272-59.578182l-83.61891-12.101818-37.376-76.101818a34.56 34.56 0 0 0-62.254545 0l-37.376 76.101818-83.618909 12.101818a34.909091 34.909091 0 0 0-19.246546 59.578182z m70.423272-64.698182a34.280727 34.280727 0 0 0 26.135273-19.083636l14.312727-29.090909 14.336 29.090909a34.257455 34.257455 0 0 0 26.135273 19.083636l32.046546 4.887273-23.272728 22.574545a35.234909 35.234909 0 0 0-10.007272 30.952727l5.46909 32.116364-28.625454-15.127273a34.490182 34.490182 0 0 0-32.302546 0l-28.695272 15.127273 5.469091-32.116364a35.141818 35.141818 0 0 0-9.984-30.952727l-23.272728-22.574545z" p-id="3855"></path></svg></button><button title="Light theme" class="__dumi-default-dark-sun "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="4026" width="22" height="22"><path d="M915.2 476.16h-43.968c-24.704 0-44.736 16-44.736 35.84s20.032 35.904 44.736 35.904H915.2c24.768 0 44.8-16.064 44.8-35.904s-20.032-35.84-44.8-35.84zM512 265.6c-136.704 0-246.464 109.824-246.464 246.4 0 136.704 109.76 246.464 246.464 246.464S758.4 648.704 758.4 512c0-136.576-109.696-246.4-246.4-246.4z m0 425.6c-99.008 0-179.2-80.128-179.2-179.2 0-98.944 80.192-179.2 179.2-179.2S691.2 413.056 691.2 512c0 99.072-80.192 179.2-179.2 179.2zM197.44 512c0-19.84-19.136-35.84-43.904-35.84H108.8c-24.768 0-44.8 16-44.8 35.84s20.032 35.904 44.8 35.904h44.736c24.768 0 43.904-16.064 43.904-35.904zM512 198.464c19.776 0 35.84-20.032 35.84-44.8v-44.8C547.84 84.032 531.84 64 512 64s-35.904 20.032-35.904 44.8v44.8c0 24.768 16.128 44.864 35.904 44.864z m0 627.136c-19.776 0-35.904 20.032-35.904 44.8v44.736C476.096 940.032 492.16 960 512 960s35.84-20.032 35.84-44.8v-44.736c0-24.768-16.064-44.864-35.84-44.864z m329.92-592.832c17.472-17.536 20.288-43.072 6.4-57.024-14.016-14.016-39.488-11.2-57.024 6.336-4.736 4.864-26.496 26.496-31.36 31.36-17.472 17.472-20.288 43.008-6.336 57.024 13.952 14.016 39.488 11.2 57.024-6.336 4.8-4.864 26.496-26.56 31.296-31.36zM213.376 759.936c-4.864 4.8-26.56 26.624-31.36 31.36-17.472 17.472-20.288 42.944-6.4 56.96 14.016 13.952 39.552 11.2 57.024-6.336 4.8-4.736 26.56-26.496 31.36-31.36 17.472-17.472 20.288-43.008 6.336-56.96-14.016-13.952-39.552-11.072-56.96 6.336z m19.328-577.92c-17.536-17.536-43.008-20.352-57.024-6.336-14.08 14.016-11.136 39.488 6.336 57.024 4.864 4.864 26.496 26.56 31.36 31.424 17.536 17.408 43.008 20.288 56.96 6.336 14.016-14.016 11.264-39.488-6.336-57.024-4.736-4.864-26.496-26.56-31.296-31.424z m527.168 628.608c4.864 4.864 26.624 26.624 31.36 31.424 17.536 17.408 43.072 20.224 57.088 6.336 13.952-14.016 11.072-39.552-6.4-57.024-4.864-4.8-26.56-26.496-31.36-31.36-17.472-17.408-43.072-20.288-57.024-6.336-13.952 14.016-11.008 39.488 6.336 56.96z" p-id="4027"></path></svg></button><button title="Default to system" class="__dumi-default-dark-auto "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="11002" width="22" height="22"><path d="M127.658667 492.885333c0-51.882667 10.24-101.717333 30.378666-149.162666s47.786667-88.064 81.92-122.538667 75.093333-61.781333 122.538667-81.92 96.938667-30.378667 149.162667-30.378667 101.717333 10.24 149.162666 30.378667 88.405333 47.786667 122.88 81.92 61.781333 75.093333 81.92 122.538667 30.378667 96.938667 30.378667 149.162666-10.24 101.717333-30.378667 149.162667-47.786667 88.405333-81.92 122.88-75.093333 61.781333-122.88 81.92-97.28 30.378667-149.162666 30.378667-101.717333-10.24-149.162667-30.378667-88.064-47.786667-122.538667-81.92-61.781333-75.093333-81.92-122.88-30.378667-96.938667-30.378666-149.162667z m329.045333 0c0 130.048 13.994667 244.394667 41.984 343.381334h12.970667c46.762667 0 91.136-9.216 133.461333-27.306667s78.848-42.666667 109.568-73.386667 54.954667-67.242667 73.386667-109.568 27.306667-86.698667 27.306666-133.461333c0-46.421333-9.216-90.794667-27.306666-133.12s-42.666667-78.848-73.386667-109.568-67.242667-54.954667-109.568-73.386667-86.698667-27.306667-133.461333-27.306666h-11.605334c-28.672 123.562667-43.349333 237.909333-43.349333 343.722666z" p-id="11003"></path></svg></button></div></div></div><ul class="__dumi-default-menu-list"><li><a href="/blog/java-script核心原理解析">java-script核心原理解析</a></li><li><a href="/blog/java-script核心原理解析/01.开篇词">01.开篇词</a><ul><li><a href="/blog/java-script核心原理解析/01.开篇词/01"><span>开篇词 | 如何解决语言问题？</span></a></li></ul></li><li><a href="/blog/java-script核心原理解析/02.从零开始java-script语言是如何构建起来的">02.从零开始JavaScript语言是如何构建起来的</a><ul><li><a href="/blog/java-script核心原理解析/02.从零开始java-script语言是如何构建起来的/01"><span>01 | delete 0：JavaScript中到底有什么是可以销毁的</span></a></li><li><a href="/blog/java-script核心原理解析/02.从零开始java-script语言是如何构建起来的/02"><span>02 | var x = y = 100：声明语句与语法改变了JavaScript语言核心性质</span></a></li><li><a href="/blog/java-script核心原理解析/02.从零开始java-script语言是如何构建起来的/03"><span>03 | a.x = a = {n:2}：一道被无数人无数次地解释过的经典面试题</span></a></li><li><a href="/blog/java-script核心原理解析/02.从零开始java-script语言是如何构建起来的/04"><span>04 | export default function() {}：你无法导出一个匿名函数表达式</span></a></li><li><a href="/blog/java-script核心原理解析/02.从零开始java-script语言是如何构建起来的/05"><span>05 | for (let x of [1,2,3]) ...：for循环并不比使用函数递归节省开销</span></a></li><li><a href="/blog/java-script核心原理解析/02.从零开始java-script语言是如何构建起来的/06"><span>加餐 | 捡豆吃豆的学问（上）：这门课讲的是什么？</span></a></li><li><a href="/blog/java-script核心原理解析/02.从零开始java-script语言是如何构建起来的/07"><span>加餐 | 捡豆吃豆的学问（下）：这门课该怎么学？</span></a></li></ul></li><li><a href="/blog/java-script核心原理解析/03.从表达式到执行引擎java-script是如何运行的">03.从表达式到执行引擎JavaScript是如何运行的</a><ul><li><a href="/blog/java-script核心原理解析/03.从表达式到执行引擎java-script是如何运行的/01"><span>06 | x: break x;  搞懂如何在循环外使用break，方知语句执行真解</span></a></li><li><a href="/blog/java-script核心原理解析/03.从表达式到执行引擎java-script是如何运行的/02"><span>07 | ${1}：详解JavaScript中特殊的可执行结构</span></a></li><li><a href="/blog/java-script核心原理解析/03.从表达式到执行引擎java-script是如何运行的/03"><span>08 | x =&gt; x：函数式语言的核心抽象：函数与表达式的同一性</span></a></li><li><a href="/blog/java-script核心原理解析/03.从表达式到执行引擎java-script是如何运行的/04"><span>09 | (...x)：不是表达式、语句、函数，但它却能执行</span></a></li><li><a href="/blog/java-script核心原理解析/03.从表达式到执行引擎java-script是如何运行的/05"><span>10 | x = yield x：迭代过程的“函数式化”</span></a></li><li><a href="/blog/java-script核心原理解析/03.从表达式到执行引擎java-script是如何运行的/06"><span>11 | throw 1;：它在“最简单语法榜”上排名第三</span></a></li><li><a href="/blog/java-script核心原理解析/03.从表达式到执行引擎java-script是如何运行的/07"><span>加餐 | 让JavaScript运行起来</span></a></li></ul></li><li><a href="/blog/java-script核心原理解析/04.从原型到类java-script是如何一步步走向应用编程语言的">04.从原型到类JavaScript是如何一步步走向应用编程语言的</a><ul><li><a href="/blog/java-script核心原理解析/04.从原型到类java-script是如何一步步走向应用编程语言的/01"><span>12 | 1 in 1..constructor：这行代码的结果，既可能是true，也可能是false</span></a></li><li><a href="/blog/java-script核心原理解析/04.从原型到类java-script是如何一步步走向应用编程语言的/02"><span>13 | new X：从构造器到类，为你揭密对象构造的全程</span></a></li><li><a href="/blog/java-script核心原理解析/04.从原型到类java-script是如何一步步走向应用编程语言的/03"><span>14 | super.xxx()：虽然直到ES10还是个半吊子实现，却也值得一讲</span></a></li><li><a href="/blog/java-script核心原理解析/04.从原型到类java-script是如何一步步走向应用编程语言的/04"><span>15 | return Object.create(new.target.prototype)：做框架设计的基本功：写一个根类</span></a></li><li><a href="/blog/java-script核心原理解析/04.从原型到类java-script是如何一步步走向应用编程语言的/05"><span>16 | [a, b] = {a, b}：让你从一行代码看到对象的本质</span></a></li><li><a href="/blog/java-script核心原理解析/04.从原型到类java-script是如何一步步走向应用编程语言的/06"><span>17 | Object.setPrototypeOf(x, null)：连Brendan Eich都认错，但null值还活着</span></a></li></ul></li><li><a aria-current="page" class="active" href="/blog/java-script核心原理解析/05.从粗通到精通的进阶之路唯一不变的是变化本身">05.从粗通到精通的进阶之路唯一不变的是变化本身</a><ul><li><a aria-current="page" class="active" href="/blog/java-script核心原理解析/05.从粗通到精通的进阶之路唯一不变的是变化本身/01"><span>18 | a + b：动态类型是灾难之源还是最好的特性？（上）</span></a></li><li><a href="/blog/java-script核心原理解析/05.从粗通到精通的进阶之路唯一不变的是变化本身/02"><span>19 | a + b：动态类型是灾难之源还是最好的特性？（下）</span></a></li><li><a href="/blog/java-script核心原理解析/05.从粗通到精通的进阶之路唯一不变的是变化本身/03"><span>20 | (0, eval)(&quot;x = 100&quot;) ：一行让严格模式形同虚设的破坏性设计（上）</span></a></li><li><a href="/blog/java-script核心原理解析/05.从粗通到精通的进阶之路唯一不变的是变化本身/04"><span>21 | (0, eval)(&quot;x = 100&quot;) ：一行让严格模式形同虚设的破坏性设计（下）</span></a></li><li><a href="/blog/java-script核心原理解析/05.从粗通到精通的进阶之路唯一不变的是变化本身/05"><span>22 | new Function(&#x27;x = 100&#x27;)();：函数的类化是对动态与静态系统的再次统一</span></a></li></ul></li><li><a href="/blog/java-script核心原理解析/06.结束语">06.结束语</a><ul><li><a href="/blog/java-script核心原理解析/06.结束语/01"><span>结束语 | 愿你能做一个真正“懂”的程序员</span></a></li><li><a href="/blog/java-script核心原理解析/06.结束语/02"><span>结课测试 | 这些JavaScript知识，你真的掌握了吗？</span></a></li></ul></li><li><a href="/blog/java-script核心原理解析/summary">java-script核心原理解析</a></li></ul></div></div><ul role="slug-list" class="__dumi-default-layout-toc"><li title="类型系统的简化" data-depth="2"><a href="/blog/java-script核心原理解析/05.从粗通到精通的进阶之路唯一不变的是变化本身/01#类型系统的简化"><span>类型系统的简化</span></a></li><li title="先搞定一半" data-depth="2"><a href="/blog/java-script核心原理解析/05.从粗通到精通的进阶之路唯一不变的是变化本身/01#先搞定一半"><span>先搞定一半</span></a></li><li title="值VS原始值（Primitive values）" data-depth="2"><a href="/blog/java-script核心原理解析/05.从粗通到精通的进阶之路唯一不变的是变化本身/01#值vs原始值primitive-values"><span>值VS原始值（Primitive values）</span></a></li><li title="干掉那两个碍事儿的" data-depth="2"><a href="/blog/java-script核心原理解析/05.从粗通到精通的进阶之路唯一不变的是变化本身/01#干掉那两个碍事儿的"><span>干掉那两个碍事儿的</span></a></li><li title="隐式转换" data-depth="2"><a href="/blog/java-script核心原理解析/05.从粗通到精通的进阶之路唯一不变的是变化本身/01#隐式转换"><span>隐式转换</span></a></li><li title="好玩的" data-depth="2"><a href="/blog/java-script核心原理解析/05.从粗通到精通的进阶之路唯一不变的是变化本身/01#好玩的"><span>好玩的</span></a></li><li title="且听下回分解" data-depth="2"><a href="/blog/java-script核心原理解析/05.从粗通到精通的进阶之路唯一不变的是变化本身/01#且听下回分解"><span>且听下回分解</span></a></li></ul><div class="__dumi-default-layout-content"><div class="markdown"><h1 id="18--a--b动态类型是灾难之源还是最好的特性上"><a aria-hidden="true" tabindex="-1" href="/blog/java-script核心原理解析/05.从粗通到精通的进阶之路唯一不变的是变化本身/01#18--a--b动态类型是灾难之源还是最好的特性上"><span class="icon icon-link"></span></a>18 | a + b：动态类型是灾难之源还是最好的特性？（上）</h1><p>你好，我是周爱民，欢迎回到我的专栏。今天我们讲的主题是JavaScript的动态类型系统。</p><p><strong>动态类型</strong>是JavaScript的动态语言特性中最有代表性的一种。</p><p>动态执行与动态类型是天生根植于JavaScript语言核心设计中的基础组件，它们相辅相成，导致了JavaScript在学习上是易学难精，在使用中是易用易错。成兹败兹，难以得失论。</p><h2 id="类型系统的简化"><a aria-hidden="true" tabindex="-1" href="/blog/java-script核心原理解析/05.从粗通到精通的进阶之路唯一不变的是变化本身/01#类型系统的简化"><span class="icon icon-link"></span></a>类型系统的简化</h2><p>从根底上来说，JavaScript有着两套类型系统，如果仅以此论，那么还算不上复杂。</p><p>但是ECMAScript对语言类型的约定，又与JavaScript原生的、最初的语言设计不同，这导致了各种解释纷至沓来，很难统一成一个说法。而且，ECMAScript又为规范书写而订立了一套类型系统，并不停地演进它。这就如同雪上加霜，导致JavaScript的类型系统越发地说不清楚了。</p><p>在讨论动态类型的时候，可以将JavaScript类型系统做一些简化，从根底里来说，JavaScript也就是typeof()所支持的7种类型，其中的“<strong>对象</strong>（object）”与“<strong>函数</strong>（function）”算一大类，合称为<strong>引用类型</strong>，而其他类型作为<strong>值类型</strong>。</p><p>无论如何，我们就先以这种简单的类型划分为基础，来讨论JavaScript中的动态类型。因为这样一来，JavaScript中的类型转换变得很简单、很干净，也很易懂，可以用两条规则概括如下：</p><ol><li>从值x到引用，调用Object(x)函数。</li><li>从引用x到值，调用x.valueOf()方法；或调用4种值类型的包装类函数，例如Number(x)，或者String(x)等等。</li></ol><p>简单吧？当然不会这么简单。</p><h2 id="先搞定一半"><a aria-hidden="true" tabindex="-1" href="/blog/java-script核心原理解析/05.从粗通到精通的进阶之路唯一不变的是变化本身/01#先搞定一半"><span class="icon icon-link"></span></a>先搞定一半</h2><p>在<strong>类型转换</strong>这件事中，有“半件”是比较容易搞定的。</p><p>这个一半，就是“<strong>从值x到引用</strong>”。因为主要的值类型都有对应的引用类型，因此JavaScript可以用简单方法一一对应地将它们转换过去。</p><p>使用<code>Object(x)</code>来转换是很安全的方法，在用户代码中不需要特别关心其中的<code>x</code>是什么样的数据——它们可以是特殊值（例如null、undefined等），或是一般的值类型数据，又或者也可以是一个对象。所有使用<code>Object(x)</code>的转换结果，都将是一个尽可能接近你的预期的<strong>对象</strong>。例如，将数字值转换成数字对象：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">&gt; x = 1234;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    &gt; Object(x);</span></div><div class="token-line"><span class="token plain">    [Number: 1234]</span></div></pre></div><p>类似的还包括字符串、布尔值、符号等。而null、undefined将被转换为一个一般的、空白的对象，与<code>new Object</code>或一个空白字面量对象（也就是<code>{<!-- --> <!-- -->}</code>）的效果一样。这个运算非常好用的地方在于，如果x已经是一个对象，那么它只会返回原对象，而不会做任何操作。也就是说，它没有任何的副作用，对任何数据的预期效果也都是“返回一个对象”。而且在语法上，<code>Object(x)</code>也类似于一个类型转换运算，表达的是将<code>任意x</code>转换成<code>对象x</code>。</p><p>简单的这“半件事”说完后，我们反过来，接着讨论将<strong>对象转换成值</strong>的情况。</p><h2 id="值vs原始值primitive-values"><a aria-hidden="true" tabindex="-1" href="/blog/java-script核心原理解析/05.从粗通到精通的进阶之路唯一不变的是变化本身/01#值vs原始值primitive-values"><span class="icon icon-link"></span></a>值VS原始值（Primitive values）</h2><p>任何对象都会有继承自原型的两个方法，称为<code>toString()</code>和<code>valueOf()</code>，这是JavaScript中“对象转换为值”的关键。</p><p>一般而言，你可以认为“任何东西都是可以转换为<code>字符串</code>的”，这个很容易理解，比如<code>JSON.stringify()</code>就利用了这一个简单的假设，它“几乎”可以将JavaScript中的任何对象或数据，转换成JSON格式的文本。</p><p>所以，我的意思是说，在JavaScript中将任何东西都转换成字符串这一点，在核心的原理上，以及具体的处理技术上都并不存在什么障碍。</p><p>但是如何理解“<strong>将函数转换成字符串</strong>”呢？</p><p>从最基础的来说，函数有两个层面的含义，一个是它的可执行代码，也就是文本形式的源代码；另一个则是函数作为对象，也有自己的属性。</p><p>所以，“理论上来说”，函数也可以被作为一个对象来转换成字符串，或者说，序列化成文本形式。</p><p>又或者再举一个例子，我们需要如何来理解将一个“符号对象”转换成“符号”呢？是的，我想你一定会说，没有“符号对象”这个东西，因为符号是值，不是对象。其实这样讲只是对了一半，因为现实中确实可以将一个“符号值”转换为一个“符号对象”，只需要调用一下我们上面说过的<code>Object()</code>这个函数就好了。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">&gt; x = Object(Symbol())</span></div><div class="token-line"><span class="token plain">    [Symbol: Symbol()]</span></div></pre></div><p>那么在这种情况下，这个“符号对象x”又怎么能转换为字符串呢？</p><p>所以，“一切都能转换成字符串”只是理论上行得通，而实际上很多情况下是做不到的。</p><p>在这些“无法完成转换”的情况下，JavaScript仍然会尝试给出一个有效的字符串值。基本上，这种转换只能保证“不抛出异常”，而无法完成任何有效的计算。例如，你在通常情况下将对象转换为字符串，就只会得到一个“简单的描述”，仅能表示“这是一个对象”而没有任何其它实际意义。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">&gt; (new Object).toString()</span></div><div class="token-line"><span class="token plain">    &#x27;[object Object]&#x27;</span></div></pre></div><p>为了将这个问题“一致化”——也就是将问题收纳成更小的问题，JavaScript约定，所有“对象 -&gt; 值”的转换结果要尽量地趋近于string、number和boolean三者之一。不过这从来都不是“书面的约定”，而是因为JavaScript在早期的作用，就是用于浏览器上的开发，而：</p><ul><li>浏览器可以显示的东西，是string；</li><li>可以计算的东西，是number；</li><li>可以表达逻辑的东西，是boolean。</li></ul><p>因此，在一个“最小的、可以被普通人理解的、可计算的程序系统中”，支持的“值类型数据”的最小集合，就应该是这三种。</p><p>这个问题不仅仅是浏览器，就算是一台放在云端的主机，你想要去操作它，那么通过控制台登录之后的shell脚本，也必须支持它。更远一点地说，你远程操作一台计算机，与浏览器用户要使用gmail，这二者在计算的抽象上是一样的，只是程序实现的复杂性不一样而已。</p><p>所以，对于（ECMAScript 5以及之前的）JavaScript来说，当它支持值转换向“对应的”对象时，或者反过来从这些对象转换回值的时候，所需要处理的也无非是这三种类型而已。而处理的具体方法也很简单，就是在使用<code>Object(x)</code>来转换得到的对象实例中添加一个内部槽，存放这个<code>x</code>的值。更确切地说，下面两行代码在语义上的效果是一致的（它是在一个称为<code>PrimitiveValue</code>的内部槽中置入这个值的）：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">obj = Object(x);</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    // 等效于（如果能操作内部槽的话）</span></div><div class="token-line"><span class="token plain">    obj.[[PrimitiveValue]] = x;</span></div></pre></div><p>于是，当需要从对象中转换回来到值类型时，也就是把这个<code>PrimitiveValue</code>值取出来就可以了。而“<strong>取出这个值，并返回给用户代码</strong>”的方法，就称为<code>valueOf()</code>。</p><p>到了ECMAScript 6中，这个过程就稍稍有些不同，这个内部槽是区别值类型的，因此为每种值类型设计了一个独立的私有槽名字。加上ES8中出现的大整数类型（BigInt），一共就有了5个对应的私有槽：<code>[[BooleanData] [[NumberData]]</code>、<code>[[StringData] [[SymbolData]]</code>和<code>[[BigIntData]]</code>。其中除了<code>Symbol</code>类型之外，都是满足在上面所说的：</p><ul><li>一个“最小的、可以被普通人理解的、可计算的程序系统中”，支持的“值类型数据”的最小集合</li></ul><p>这样一个设定的。</p><p>那么“符号”这个东西出现的必要性何在呢？</p><p>这个问题我就不解释了，算作本讲的课后习题之一，希望你可以踊跃参与讨论。不过就问题的方向来说，仍然是出于<strong>计算系统的完备性</strong>。如果你非要说这个是因为张三李四喜欢，某个tc39提案者的心头好，这样的答案就算是当事人承认，我也是不认可的。：）</p><p>好。回到正题。那么在ECMAScript 6之后，除<code>[[PrimitiveValue]]</code>这个私有槽变成了5种值类型对应的、独立的私有槽之外，还有什么不同呢？</p><p>是的，这个你可能也已经注意到了。ECMAScript 6之后还出现了<code>Symbol.toPrimitive</code>这个符号。而它，正是将原本的<code>[[PrimitiveValue]]</code>这个私有槽以及其访问过程标准化，然后暴露给JavaScript用户编程的一个界面。</p><p>说到这里，就必须明确<strong>一般的值</strong>（Values）与<strong>原始值</strong>（Primitive values）之间的关系了。</p><p>不过，在下一步的讨论之前，我要先帮你总结一下前面的内容：</p><p>也就是说，从<code>typeof(x)</code>的7种结果类型来看，其中string、boolean、number、bigint和symbol的值类型与对象类型转换，就是将该值存入私有槽，或者从私有槽中把相应的值取出来就好了。</p><p>在语言中，这些对应的对象类型被称为“包装类”，与此相关的还有“装箱”与“拆箱”等等行为，这也是后续会涉及到的内容。</p><blockquote><p>NOTE: 在ECMAScript 6之前，由于<code>[PrimitiveValue]</code>来存放对应的封装类。也就是说，只有当<code>obj.[Class]</code>存放着<code>false</code>值时，它才是<code>false</code>值所对应的对象实例。</p></blockquote><blockquote><p>而ECMAScript 6将上述的依赖项变成了一个，也就是说只要有一个对象有内部槽<code>[[BooleanData]]</code>，那么它就是某个boolean值对应的对象。这样处理起来就简便了，不必每次做两项判断。</p></blockquote><p>所以，一种关于“原始值”的简单解释是：所有5种能放入私有槽（亦即是说它们有相应的包装类）的值（Values），都是原始值；并且，再加上两个特殊值undefined和null，那么就是所谓原始值（Primitive values）的完整集合了。</p><p>接下来，如果转换过程发生在“值与值”之间呢？</p><h2 id="干掉那两个碍事儿的"><a aria-hidden="true" tabindex="-1" href="/blog/java-script核心原理解析/05.从粗通到精通的进阶之路唯一不变的是变化本身/01#干掉那两个碍事儿的"><span class="icon icon-link"></span></a>干掉那两个碍事儿的</h2><p>bigint这个类型最好说，它跟number在语言特性上是一回事儿，所以它的转换没什么特殊性，下面我会在讲到number的时候，一并讲解。</p><p>除此之外，还有两个类型在与其他类型的转换中是简单而特殊的。</p><p>例如，<strong>symbol</strong>这个值类型，它其实既没有办法转换成别的类型，也没有办法从别的类型转换过来。无论是哪种方式转换，它在语义上都是丢失了的、是没有意义的。当然，现实中你也可以这么用，比如用<code>console.log()</code>来将一个符号显示出来，这在控制台里面，是有显示信息输出的。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">&gt; console.log(Symbol())</span></div><div class="token-line"><span class="token plain">    Symbol()</span></div></pre></div><p>这里的确发生了一个“symbol -&gt; string”的转换。但它的结果只能表示这是一个符号，至于是哪个符号，符号a还是符号b，全都分不出来。类似于此，所有“符号 -&gt; 其他值类型”的转换不需要太特别的讨论，由于所有能发生的转换都是定值，所以你可以做一张表格出来对照参考即可。当然，如果是“其他值类型 -&gt; symbol”的这种转换，实际结果就是创建一个新符号，而没有“转换”的语义了。</p><p>另外一个碍事儿的也特别简单，就是<strong>boolean</strong>。</p><p>ECMAScript为了兼容旧版本的JavaScript，直接将这个转换定义成了一张表格，这个表格在ECMAScript规范或者我们常用的<a target="_blank" rel="noopener noreferrer" href="https://developer.mozilla.org/">MDN<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>（Mozilla Developer Network）上可以直接查到。简单地说，就是除了undefined、null、0、NaN、&quot;&quot;（empty string）以及BigInt中的0n返回false之外，其他的值转换为boolean时，都将是true值。</p><p>当然，不管怎么说，要想记住这些类型转换并不容易（当然也不难），简单的做法，就是直接把它们的包装类当作函数来调用，转换一下就好了。在你的代码中也可以这么写，例如，使用“String(x)”就是将x转换成string类型，又或者“Boolean(x)”就是将x转换为true/false值。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">&gt; x = 100n;  // `bigint` value</span></div><div class="token-line"><span class="token plain">    &gt; String(x)  // to `string` value</span></div><div class="token-line"><span class="token plain">    &#x27;100n&#x27;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    &gt; Boolean(x); // to `boolean` value</span></div><div class="token-line"><span class="token plain">    true</span></div></pre></div><p>这些操作简单易行，也不容易出错，用在代码中还不影响效率，一切都很好。</p><blockquote><p>NOTE: 这些可以直接作为函数调用的包装类，一共有四个，包括String()、Number()、Boolean()和BigInt()。此外，Symbol()在形式上与此相同，但执行语义是略有区别的。</p></blockquote><p>但并不那么简单。因为我还没有跟你讨论过字符串和数字值的转换。</p><p>以及，还有特别要命的“隐式转换”。</p><h2 id="隐式转换"><a aria-hidden="true" tabindex="-1" href="/blog/java-script核心原理解析/05.从粗通到精通的进阶之路唯一不变的是变化本身/01#隐式转换"><span class="icon icon-link"></span></a>隐式转换</h2><p>由于函数的参数没有类型声明，所以用户代码可以传入任何类型的值。对于JavaScript核心库中的一些方法或操作来说，这表明它们需要一种统一、一致的方法来处理这种类型差异。例如说，要么拒绝“类型不太正确的参数”，抛出异常；要么用一种方式来使这些参数“变得正确”。</p><p>后一种方法就是“隐式转换”。但是就这两种方法的选择来说，JavaScript并没有编码风格层面上的约定。基本上，早期JavaScript以既有实现为核心的时候，倾向于让引擎吞掉类型异常（TypeError），尽量采用隐式转换来让程序在无异常的情况下运行；而后期，以ECMAScript规范为主导的时候，则倾向于抛出这些异常，让用户代码有机会处理类型问题。</p><p>隐式转换最主要的问题就是会带来大量的“潜规则”。</p><p>例如经典的<code>String.prototype.search(r)</code>方法，其中的参数从最初设计时就支持在<code>r</code>参数中传入一个字符串，并且将隐式地调用<code>r = new RegExp(r)</code>来产生最终被用来搜索的正则表达式。而<code>new RegExp(r)</code>这个运算中，由于<code>RegExp()</code>构造器又会隐式地将<code>r</code>从任何类型转换为字符串类型，因而在这整个过程中，向原始的<code>r</code>参数传入任何值都不会产生任何的异常。</p><p>例如，其实你写出下面这样的代码也是可以运行的：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">&gt; &quot;aa1aa&quot;.search(1)</span></div><div class="token-line"><span class="token plain">    2</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    &gt; &quot;000false111&quot;.search(0 &gt; 5)</span></div><div class="token-line"><span class="token plain">    3</span></div></pre></div><p>隐式转换导致的“潜规则”很大程度上增加了理解用户代码的难度，也不利于引擎实现。因此，ECMAScript在后期就倾向于抛弃这种做法，多数的“新方法”在发现类型不匹配的时候，都设计为显式地抛出类型错误。一个典型的结果就是，在ECMAScript 3的时代，TypeError这个词在规范中出现的次数是24次；到了ECMAScript 5，是114次；而ECMAScript 6开始就暴增到419次。</p><p>因此，越是早期的特性，越是更多地采用了带有“潜规则”的隐式转换规则。然而很不幸的是，几乎所有的“运算符”，以及大多数常用的原型方法，都是“早期的特性”。</p><p>所以在类型转换方面，JavaScript成了“潜规则”最多的语言之一。</p><h2 id="好玩的"><a aria-hidden="true" tabindex="-1" href="/blog/java-script核心原理解析/05.从粗通到精通的进阶之路唯一不变的是变化本身/01#好玩的"><span class="icon icon-link"></span></a>好玩的</h2><p>@graybernhardt 曾在2012年发布过一个<a target="_blank" rel="noopener noreferrer" href="https://www.destroyallsoftware.com/talks/wat">讲演<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>（A lightning talk by Gary Bernhardt from CodeMash 2012），提到一个非常非常著名的案例，来说明这个隐式转换，以及它所带来的“潜规则”有多么的不可预测。这个经典的示例是：</p><ul><li>将<code>[]</code>和<code>{<!-- -->}</code>相加，会发生什么？</li></ul><p>尝试一下这个case，你会看到：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">&gt; [] + {}</span></div><div class="token-line"><span class="token plain">    &#x27;[object Object]&#x27;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    &gt; {} + []</span></div><div class="token-line"><span class="token plain">    0</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    &gt; {} + {}</span></div><div class="token-line"><span class="token plain">    NaN</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    &gt; [] + []</span></div><div class="token-line"><span class="token plain">    &#x27;&#x27;</span></div></pre></div><p>嗯！四种情况居然没有一个是相同的！</p><p>不过有一点需要注意到的，就是输出的结果，总是会“收敛”到两种类型：字符串，或者数值。嗯，“隐式转换”其实只是表面现象，核心的问题是，这种转换的结果总是倾向于“string/number”两种值类型。</p><p>这个，才是我们这一讲要讲“大问题”。</p><h2 id="且听下回分解"><a aria-hidden="true" tabindex="-1" href="/blog/java-script核心原理解析/05.从粗通到精通的进阶之路唯一不变的是变化本身/01#且听下回分解"><span class="icon icon-link"></span></a>且听下回分解</h2><p>到现在为止，这一节课其实才开了个头，也就是对“a + b”这个标题做了一个题解而已。这主要是因为在JavaScript中有关类型处理的背景信息太多、太复杂，而且还处在不停的变化之中。许多稍早的信息，与现在的应用环境中的现状，或者你手边可备查的资料之间都存在着不可调和的矛盾冲突，因此对这些东西加以梳理还原，实在是大有必要的。这也就是为什么这一讲会说到现在，仍然没有切入正题的原因。</p><p>当然，一部分原因也在于：这些絮絮叨叨的东西，也原本就是“正题”的一部分。比如说，你至少应该知道的内容包括：</p><ul><li>语言中的引用类型和值类型，以及ECMAScript中的原始值类型（Primitive values）之间存在区别；</li><li>语言中的所谓“引用类型”，与ECMAScript中的“引用（规范类型）”是完全不同的概念；</li><li>所有值通过包装类转换成对象时，这个对象会具有一个内部槽，早期它统一称为<code>[[PrimitiveValue]]</code>，而后来JavaScript为每种包装类创建了一个专属的；</li><li>使用typeof(x)来检查x的数据类型，在JavaScript代码中是常用而有效方法；</li><li>原则上来说，系统只处理boolean/string/number三种值类型（bigint可以理解为number的特殊实现），其中boolean与其他值类型的转换是按对照表来处理的。</li></ul><p>总的来说，类型在JavaScript中的显式转换是比较容易处理的，而标题“a + b”其实包含了太多隐式转换的可能性，因此尤其复杂。关于这些细节，且听下回分解。</p><p>这一讲没有复习题。不过如果你愿意，可以把上面讲到的@graybernhardt 的四个示例尝试一下，解释一下它们为什么是这个结果。</p><p>而下一讲，我再来为你公布答案，并且做详细解说。</p></div><div class="__dumi-default-layout-footer-meta"><a target="_blank" rel="noopener noreferrer" href="https://github.com/GGwujun/blog/edit/master/docs/java-script核心原理解析/05.从粗通到精通的进阶之路唯一不变的是变化本身/01.md">在 GitHub 上编辑此页<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a><span data-updated-text="最后更新时间：">5/2/2022 10:56:38</span></div></div></div></div>
	<script>
  window.g_useSSR = true;
  window.g_initialProps = {};
	</script>

    <script>
      (function () {
        if (!location.port) {
          (function (i, s, o, g, r, a, m) {
            i["GoogleAnalyticsObject"] = r;
            (i[r] =
              i[r] ||
              function () {
                (i[r].q = i[r].q || []).push(arguments);
              }),
              (i[r].l = 1 * new Date());
            (a = s.createElement(o)), (m = s.getElementsByTagName(o)[0]);
            a.async = 1;
            a.src = g;
            m.parentNode.insertBefore(a, m);
          })(
            window,
            document,
            "script",
            "//www.google-analytics.com/analytics.js",
            "ga"
          );
          ga("create", "UA-149864185-1", "auto");
          ga("send", "pageview");
        }
      })();
    </script>
    <script src="/blog/umi.js"></script>
  </body>
</html>
