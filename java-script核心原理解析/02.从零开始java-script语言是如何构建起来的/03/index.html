<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no"
    />
    <link rel="shortcut icon" type="image/x-icon" href="/logo.png" />
    <link rel="stylesheet" href="/blog/umi.css" />
    <script>
      window.routerBase = "/blog";
    </script>
    <script>
      //! umi version: 3.5.17
    </script>
    <script>
      !(function () {
        var e = localStorage.getItem("dumi:prefers-color"),
          t = window.matchMedia("(prefers-color-scheme: dark)").matches,
          r = ["light", "dark", "auto"];
        document.documentElement.setAttribute(
          "data-prefers-color",
          e === r[2] ? (t ? r[1] : r[0]) : r.indexOf(e) > -1 ? e : r[0]
        );
      })();
    </script>
    <title>03 | a.x = a = {n:2}：一道被无数人无数次地解释过的经典面试题</title>
  </head>
  <body>
    <div id="root"><div class="__dumi-default-layout" data-route="/java-script核心原理解析/02.从零开始java-script语言是如何构建起来的/03" data-show-sidemenu="true" data-show-slugs="true" data-site-mode="true" data-gapless="false"><div class="__dumi-default-navbar" data-mode="site"><button class="__dumi-default-navbar-toggle"></button><a class="__dumi-default-navbar-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog/">大师兄</a><nav><div class="__dumi-default-search"><input type="search" class="__dumi-default-search-input" value=""/><ul></ul></div><span>计算机基础<ul><li><a href="/blog/编译原理之美">编译原理之美</a></li><li><a href="/blog/编译原理实战">编译原理实战</a></li><li><a href="/blog/深入浅出计算机组成原理">深入浅出计算机组成原理</a></li><li><a href="/blog/详解http">详解http</a></li><li><a href="/blog/计算机网络通关29讲">计算机网络通关29讲</a></li><li><a href="/blog/网络排查案例课">网络排查案例课</a></li><li><a href="/blog/linux操作系统">linux操作系统</a></li><li><a href="/blog/linux性能优化实战">linux性能优化实战</a></li><li><a href="/blog/程序员数学基础">程序员数学基础</a></li><li><a href="/blog/趣谈网络协议">趣谈网络协议</a></li><li><a href="/blog/操作系统实战">操作系统实战</a></li><li><a href="/blog/软件工程之美">软件工程之美</a></li><li><a href="/blog/sql必知必会">sql必知必会</a></li><li><a href="/blog/操作系统实战45讲">操作系统实战45讲</a></li><li><a href="/blog/网络编程实战">网络编程实战</a></li></ul></span><span>算法<ul><li><a href="/blog/常用算法25讲">常用算法25讲</a></li><li><a href="/blog/数据结构与算法之美">数据结构与算法之美</a></li><li><a href="/blog/业务开发算法50讲">业务开发算法50讲</a></li><li><a href="/blog/动态规划面试宝典">动态规划面试宝典</a></li></ul></span><span>前端开发<ul><li><a href="/blog/浏览器工作原理与实践">浏览器工作原理与实践</a></li><li><a href="/blog/新时代产品经理进阶之路">新时代产品经理进阶之路</a></li><li><a href="/blog/全栈工程师修炼指南">全栈工程师修炼指南</a></li><li><a href="/blog/flutter核心技术与实战">flutter核心技术与实战</a></li><li><a aria-current="page" class="active" href="/blog/java-script核心原理解析">java-script核心原理解析</a></li><li><a href="/blog/说透低代码">说透低代码</a></li><li><a href="/blog/nodejs应用开发实战">nodejs应用开发实战</a></li><li><a href="/blog/反爬虫兵法演绎20讲">反爬虫兵法演绎20讲</a></li><li><a href="/blog/reactnative新架构实战课">reactnative新架构实战课</a></li><li><a href="/blog/正则表达式入门">正则表达式入门</a></li><li><a href="/blog/重学前端">重学前端</a></li><li><a href="/blog/serverless入门课">serverless入门课</a></li><li><a href="/blog/type-script入门实战笔记">type-script入门实战笔记</a></li><li><a href="/blog/图解googlev8">图解googlev8</a></li><li><a href="/blog/vue3源码分析">vue3源码分析</a></li><li><a href="/blog/玩转Vue3全家桶">玩转Vue3全家桶</a></li><li><a href="/blog/webassembly入门">webassembly入门</a></li><li><a href="/blog/手把手带你写一个Web框架">手把手带你写一个Web框架</a></li><li><a href="/blog/web漏洞挖掘实战">web漏洞挖掘实战</a></li><li><a href="/blog/跟月影学可视化">跟月影学可视化</a></li><li><a href="/blog/搞定音频技术">搞定音频技术</a></li><li><a href="/blog/攻克视频技术">攻克视频技术</a></li></ul></span><span>前端工程化<ul><li><a href="/blog/logger">logger</a></li><li><a href="/blog/webpack">webpack</a></li><li><a href="/blog/webpackChain">webpackChain</a></li></ul></span><span>前端性能优化<ul><li><a href="/blog/react性能调优">react性能调优</a></li></ul></span><span>软件测试<ul><li><a href="/blog/全链路压测实战30讲">全链路压测实战30讲</a></li><li><a href="/blog/性能测试实战30讲">性能测试实战30讲</a></li><li><a href="/blog/自动化测试高手课">自动化测试高手课</a></li><li><a href="/blog/软件测试52讲">软件测试52讲</a></li></ul></span><span>面试<ul><li><a href="/blog/面试现场">面试现场</a></li></ul></span><span>杂谈<ul><li><a href="/blog/超级访谈对话张雪峰">超级访谈对话张雪峰</a></li><li><a href="/blog/Git实战手册">Git实战手册</a></li><li><a href="/blog/NodeJS">NodeJS</a></li><li><a href="/blog/ReactJS">ReactJS</a></li><li><a href="/blog/UI设计">UI设计</a></li><li><a href="/blog/webpack4系列教程">webpack4系列教程</a></li><li><a href="/blog/前端知识体系">前端知识体系</a></li><li><a href="/blog/剑指offer刷题笔记">剑指offer刷题笔记</a></li><li><a href="/blog/思考与成长">思考与成长</a></li><li><a href="/blog/设计模式手册">设计模式手册</a></li></ul></span><div class="__dumi-default-navbar-tool"><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "></div></div></div></nav></div><div class="__dumi-default-menu" data-mode="site"><div class="__dumi-default-menu-inner"><div class="__dumi-default-menu-header"><a class="__dumi-default-menu-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog/"></a><h1>大师兄</h1><p></p></div><div class="__dumi-default-menu-mobile-area"><ul class="__dumi-default-menu-nav-list"><li>计算机基础<ul><li><a href="/blog/编译原理之美">编译原理之美</a></li><li><a href="/blog/编译原理实战">编译原理实战</a></li><li><a href="/blog/深入浅出计算机组成原理">深入浅出计算机组成原理</a></li><li><a href="/blog/详解http">详解http</a></li><li><a href="/blog/计算机网络通关29讲">计算机网络通关29讲</a></li><li><a href="/blog/网络排查案例课">网络排查案例课</a></li><li><a href="/blog/linux操作系统">linux操作系统</a></li><li><a href="/blog/linux性能优化实战">linux性能优化实战</a></li><li><a href="/blog/程序员数学基础">程序员数学基础</a></li><li><a href="/blog/趣谈网络协议">趣谈网络协议</a></li><li><a href="/blog/操作系统实战">操作系统实战</a></li><li><a href="/blog/软件工程之美">软件工程之美</a></li><li><a href="/blog/sql必知必会">sql必知必会</a></li><li><a href="/blog/操作系统实战45讲">操作系统实战45讲</a></li><li><a href="/blog/网络编程实战">网络编程实战</a></li></ul></li><li>算法<ul><li><a href="/blog/常用算法25讲">常用算法25讲</a></li><li><a href="/blog/数据结构与算法之美">数据结构与算法之美</a></li><li><a href="/blog/业务开发算法50讲">业务开发算法50讲</a></li><li><a href="/blog/动态规划面试宝典">动态规划面试宝典</a></li></ul></li><li>前端开发<ul><li><a href="/blog/浏览器工作原理与实践">浏览器工作原理与实践</a></li><li><a href="/blog/新时代产品经理进阶之路">新时代产品经理进阶之路</a></li><li><a href="/blog/全栈工程师修炼指南">全栈工程师修炼指南</a></li><li><a href="/blog/flutter核心技术与实战">flutter核心技术与实战</a></li><li><a aria-current="page" class="active" href="/blog/java-script核心原理解析">java-script核心原理解析</a></li><li><a href="/blog/说透低代码">说透低代码</a></li><li><a href="/blog/nodejs应用开发实战">nodejs应用开发实战</a></li><li><a href="/blog/反爬虫兵法演绎20讲">反爬虫兵法演绎20讲</a></li><li><a href="/blog/reactnative新架构实战课">reactnative新架构实战课</a></li><li><a href="/blog/正则表达式入门">正则表达式入门</a></li><li><a href="/blog/重学前端">重学前端</a></li><li><a href="/blog/serverless入门课">serverless入门课</a></li><li><a href="/blog/type-script入门实战笔记">type-script入门实战笔记</a></li><li><a href="/blog/图解googlev8">图解googlev8</a></li><li><a href="/blog/vue3源码分析">vue3源码分析</a></li><li><a href="/blog/玩转Vue3全家桶">玩转Vue3全家桶</a></li><li><a href="/blog/webassembly入门">webassembly入门</a></li><li><a href="/blog/手把手带你写一个Web框架">手把手带你写一个Web框架</a></li><li><a href="/blog/web漏洞挖掘实战">web漏洞挖掘实战</a></li><li><a href="/blog/跟月影学可视化">跟月影学可视化</a></li><li><a href="/blog/搞定音频技术">搞定音频技术</a></li><li><a href="/blog/攻克视频技术">攻克视频技术</a></li></ul></li><li>前端工程化<ul><li><a href="/blog/logger">logger</a></li><li><a href="/blog/webpack">webpack</a></li><li><a href="/blog/webpackChain">webpackChain</a></li></ul></li><li>前端性能优化<ul><li><a href="/blog/react性能调优">react性能调优</a></li></ul></li><li>软件测试<ul><li><a href="/blog/全链路压测实战30讲">全链路压测实战30讲</a></li><li><a href="/blog/性能测试实战30讲">性能测试实战30讲</a></li><li><a href="/blog/自动化测试高手课">自动化测试高手课</a></li><li><a href="/blog/软件测试52讲">软件测试52讲</a></li></ul></li><li>面试<ul><li><a href="/blog/面试现场">面试现场</a></li></ul></li><li>杂谈<ul><li><a href="/blog/超级访谈对话张雪峰">超级访谈对话张雪峰</a></li><li><a href="/blog/Git实战手册">Git实战手册</a></li><li><a href="/blog/NodeJS">NodeJS</a></li><li><a href="/blog/ReactJS">ReactJS</a></li><li><a href="/blog/UI设计">UI设计</a></li><li><a href="/blog/webpack4系列教程">webpack4系列教程</a></li><li><a href="/blog/前端知识体系">前端知识体系</a></li><li><a href="/blog/剑指offer刷题笔记">剑指offer刷题笔记</a></li><li><a href="/blog/思考与成长">思考与成长</a></li><li><a href="/blog/设计模式手册">设计模式手册</a></li></ul></li></ul><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "><button title="Dark theme" class="__dumi-default-dark-moon "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="3854" width="22" height="22"><path d="M991.816611 674.909091a69.166545 69.166545 0 0 0-51.665455-23.272727 70.795636 70.795636 0 0 0-27.438545 5.585454A415.674182 415.674182 0 0 1 754.993338 698.181818c-209.594182 0-393.472-184.785455-393.472-395.636363 0-52.363636 38.539636-119.621818 69.515637-173.614546 4.887273-8.610909 9.634909-16.756364 14.103272-24.901818A69.818182 69.818182 0 0 0 384.631156 0a70.842182 70.842182 0 0 0-27.438545 5.585455C161.678429 90.298182 14.362065 307.898182 14.362065 512c0 282.298182 238.824727 512 532.38691 512a522.286545 522.286545 0 0 0 453.957818-268.334545A69.818182 69.818182 0 0 0 991.816611 674.909091zM546.679156 954.181818c-248.785455 0-462.941091-192-462.941091-442.181818 0-186.647273 140.637091-372.829091 300.939637-442.181818-36.817455 65.629091-92.578909 151.970909-92.578909 232.727273 0 250.181818 214.109091 465.454545 462.917818 465.454545a488.331636 488.331636 0 0 0 185.181091-46.545455 453.003636 453.003636 0 0 1-393.565091 232.727273z m103.656728-669.323636l-14.266182 83.781818a34.909091 34.909091 0 0 0 50.362182 36.770909l74.775272-39.563636 74.752 39.563636a36.142545 36.142545 0 0 0 16.174546 3.956364 34.909091 34.909091 0 0 0 34.210909-40.727273l-14.289455-83.781818 60.509091-59.345455a35.025455 35.025455 0 0 0-19.223272-59.578182l-83.61891-12.101818-37.376-76.101818a34.56 34.56 0 0 0-62.254545 0l-37.376 76.101818-83.618909 12.101818a34.909091 34.909091 0 0 0-19.246546 59.578182z m70.423272-64.698182a34.280727 34.280727 0 0 0 26.135273-19.083636l14.312727-29.090909 14.336 29.090909a34.257455 34.257455 0 0 0 26.135273 19.083636l32.046546 4.887273-23.272728 22.574545a35.234909 35.234909 0 0 0-10.007272 30.952727l5.46909 32.116364-28.625454-15.127273a34.490182 34.490182 0 0 0-32.302546 0l-28.695272 15.127273 5.469091-32.116364a35.141818 35.141818 0 0 0-9.984-30.952727l-23.272728-22.574545z" p-id="3855"></path></svg></button><button title="Light theme" class="__dumi-default-dark-sun "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="4026" width="22" height="22"><path d="M915.2 476.16h-43.968c-24.704 0-44.736 16-44.736 35.84s20.032 35.904 44.736 35.904H915.2c24.768 0 44.8-16.064 44.8-35.904s-20.032-35.84-44.8-35.84zM512 265.6c-136.704 0-246.464 109.824-246.464 246.4 0 136.704 109.76 246.464 246.464 246.464S758.4 648.704 758.4 512c0-136.576-109.696-246.4-246.4-246.4z m0 425.6c-99.008 0-179.2-80.128-179.2-179.2 0-98.944 80.192-179.2 179.2-179.2S691.2 413.056 691.2 512c0 99.072-80.192 179.2-179.2 179.2zM197.44 512c0-19.84-19.136-35.84-43.904-35.84H108.8c-24.768 0-44.8 16-44.8 35.84s20.032 35.904 44.8 35.904h44.736c24.768 0 43.904-16.064 43.904-35.904zM512 198.464c19.776 0 35.84-20.032 35.84-44.8v-44.8C547.84 84.032 531.84 64 512 64s-35.904 20.032-35.904 44.8v44.8c0 24.768 16.128 44.864 35.904 44.864z m0 627.136c-19.776 0-35.904 20.032-35.904 44.8v44.736C476.096 940.032 492.16 960 512 960s35.84-20.032 35.84-44.8v-44.736c0-24.768-16.064-44.864-35.84-44.864z m329.92-592.832c17.472-17.536 20.288-43.072 6.4-57.024-14.016-14.016-39.488-11.2-57.024 6.336-4.736 4.864-26.496 26.496-31.36 31.36-17.472 17.472-20.288 43.008-6.336 57.024 13.952 14.016 39.488 11.2 57.024-6.336 4.8-4.864 26.496-26.56 31.296-31.36zM213.376 759.936c-4.864 4.8-26.56 26.624-31.36 31.36-17.472 17.472-20.288 42.944-6.4 56.96 14.016 13.952 39.552 11.2 57.024-6.336 4.8-4.736 26.56-26.496 31.36-31.36 17.472-17.472 20.288-43.008 6.336-56.96-14.016-13.952-39.552-11.072-56.96 6.336z m19.328-577.92c-17.536-17.536-43.008-20.352-57.024-6.336-14.08 14.016-11.136 39.488 6.336 57.024 4.864 4.864 26.496 26.56 31.36 31.424 17.536 17.408 43.008 20.288 56.96 6.336 14.016-14.016 11.264-39.488-6.336-57.024-4.736-4.864-26.496-26.56-31.296-31.424z m527.168 628.608c4.864 4.864 26.624 26.624 31.36 31.424 17.536 17.408 43.072 20.224 57.088 6.336 13.952-14.016 11.072-39.552-6.4-57.024-4.864-4.8-26.56-26.496-31.36-31.36-17.472-17.408-43.072-20.288-57.024-6.336-13.952 14.016-11.008 39.488 6.336 56.96z" p-id="4027"></path></svg></button><button title="Default to system" class="__dumi-default-dark-auto "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="11002" width="22" height="22"><path d="M127.658667 492.885333c0-51.882667 10.24-101.717333 30.378666-149.162666s47.786667-88.064 81.92-122.538667 75.093333-61.781333 122.538667-81.92 96.938667-30.378667 149.162667-30.378667 101.717333 10.24 149.162666 30.378667 88.405333 47.786667 122.88 81.92 61.781333 75.093333 81.92 122.538667 30.378667 96.938667 30.378667 149.162666-10.24 101.717333-30.378667 149.162667-47.786667 88.405333-81.92 122.88-75.093333 61.781333-122.88 81.92-97.28 30.378667-149.162666 30.378667-101.717333-10.24-149.162667-30.378667-88.064-47.786667-122.538667-81.92-61.781333-75.093333-81.92-122.88-30.378667-96.938667-30.378666-149.162667z m329.045333 0c0 130.048 13.994667 244.394667 41.984 343.381334h12.970667c46.762667 0 91.136-9.216 133.461333-27.306667s78.848-42.666667 109.568-73.386667 54.954667-67.242667 73.386667-109.568 27.306667-86.698667 27.306666-133.461333c0-46.421333-9.216-90.794667-27.306666-133.12s-42.666667-78.848-73.386667-109.568-67.242667-54.954667-109.568-73.386667-86.698667-27.306667-133.461333-27.306666h-11.605334c-28.672 123.562667-43.349333 237.909333-43.349333 343.722666z" p-id="11003"></path></svg></button></div></div></div><ul class="__dumi-default-menu-list"><li><a href="/blog/java-script核心原理解析">java-script核心原理解析</a></li><li><a href="/blog/java-script核心原理解析/01.开篇词">01.开篇词</a><ul><li><a href="/blog/java-script核心原理解析/01.开篇词/01"><span>开篇词 | 如何解决语言问题？</span></a></li></ul></li><li><a aria-current="page" class="active" href="/blog/java-script核心原理解析/02.从零开始java-script语言是如何构建起来的">02.从零开始JavaScript语言是如何构建起来的</a><ul><li><a href="/blog/java-script核心原理解析/02.从零开始java-script语言是如何构建起来的/01"><span>01 | delete 0：JavaScript中到底有什么是可以销毁的</span></a></li><li><a href="/blog/java-script核心原理解析/02.从零开始java-script语言是如何构建起来的/02"><span>02 | var x = y = 100：声明语句与语法改变了JavaScript语言核心性质</span></a></li><li><a aria-current="page" class="active" href="/blog/java-script核心原理解析/02.从零开始java-script语言是如何构建起来的/03"><span>03 | a.x = a = {n:2}：一道被无数人无数次地解释过的经典面试题</span></a></li><li><a href="/blog/java-script核心原理解析/02.从零开始java-script语言是如何构建起来的/04"><span>04 | export default function() {}：你无法导出一个匿名函数表达式</span></a></li><li><a href="/blog/java-script核心原理解析/02.从零开始java-script语言是如何构建起来的/05"><span>05 | for (let x of [1,2,3]) ...：for循环并不比使用函数递归节省开销</span></a></li><li><a href="/blog/java-script核心原理解析/02.从零开始java-script语言是如何构建起来的/06"><span>加餐 | 捡豆吃豆的学问（上）：这门课讲的是什么？</span></a></li><li><a href="/blog/java-script核心原理解析/02.从零开始java-script语言是如何构建起来的/07"><span>加餐 | 捡豆吃豆的学问（下）：这门课该怎么学？</span></a></li></ul></li><li><a href="/blog/java-script核心原理解析/03.从表达式到执行引擎java-script是如何运行的">03.从表达式到执行引擎JavaScript是如何运行的</a><ul><li><a href="/blog/java-script核心原理解析/03.从表达式到执行引擎java-script是如何运行的/01"><span>06 | x: break x;  搞懂如何在循环外使用break，方知语句执行真解</span></a></li><li><a href="/blog/java-script核心原理解析/03.从表达式到执行引擎java-script是如何运行的/02"><span>07 | ${1}：详解JavaScript中特殊的可执行结构</span></a></li><li><a href="/blog/java-script核心原理解析/03.从表达式到执行引擎java-script是如何运行的/03"><span>08 | x =&gt; x：函数式语言的核心抽象：函数与表达式的同一性</span></a></li><li><a href="/blog/java-script核心原理解析/03.从表达式到执行引擎java-script是如何运行的/04"><span>09 | (...x)：不是表达式、语句、函数，但它却能执行</span></a></li><li><a href="/blog/java-script核心原理解析/03.从表达式到执行引擎java-script是如何运行的/05"><span>10 | x = yield x：迭代过程的“函数式化”</span></a></li><li><a href="/blog/java-script核心原理解析/03.从表达式到执行引擎java-script是如何运行的/06"><span>11 | throw 1;：它在“最简单语法榜”上排名第三</span></a></li><li><a href="/blog/java-script核心原理解析/03.从表达式到执行引擎java-script是如何运行的/07"><span>加餐 | 让JavaScript运行起来</span></a></li></ul></li><li><a href="/blog/java-script核心原理解析/04.从原型到类java-script是如何一步步走向应用编程语言的">04.从原型到类JavaScript是如何一步步走向应用编程语言的</a><ul><li><a href="/blog/java-script核心原理解析/04.从原型到类java-script是如何一步步走向应用编程语言的/01"><span>12 | 1 in 1..constructor：这行代码的结果，既可能是true，也可能是false</span></a></li><li><a href="/blog/java-script核心原理解析/04.从原型到类java-script是如何一步步走向应用编程语言的/02"><span>13 | new X：从构造器到类，为你揭密对象构造的全程</span></a></li><li><a href="/blog/java-script核心原理解析/04.从原型到类java-script是如何一步步走向应用编程语言的/03"><span>14 | super.xxx()：虽然直到ES10还是个半吊子实现，却也值得一讲</span></a></li><li><a href="/blog/java-script核心原理解析/04.从原型到类java-script是如何一步步走向应用编程语言的/04"><span>15 | return Object.create(new.target.prototype)：做框架设计的基本功：写一个根类</span></a></li><li><a href="/blog/java-script核心原理解析/04.从原型到类java-script是如何一步步走向应用编程语言的/05"><span>16 | [a, b] = {a, b}：让你从一行代码看到对象的本质</span></a></li><li><a href="/blog/java-script核心原理解析/04.从原型到类java-script是如何一步步走向应用编程语言的/06"><span>17 | Object.setPrototypeOf(x, null)：连Brendan Eich都认错，但null值还活着</span></a></li></ul></li><li><a href="/blog/java-script核心原理解析/05.从粗通到精通的进阶之路唯一不变的是变化本身">05.从粗通到精通的进阶之路唯一不变的是变化本身</a><ul><li><a href="/blog/java-script核心原理解析/05.从粗通到精通的进阶之路唯一不变的是变化本身/01"><span>18 | a + b：动态类型是灾难之源还是最好的特性？（上）</span></a></li><li><a href="/blog/java-script核心原理解析/05.从粗通到精通的进阶之路唯一不变的是变化本身/02"><span>19 | a + b：动态类型是灾难之源还是最好的特性？（下）</span></a></li><li><a href="/blog/java-script核心原理解析/05.从粗通到精通的进阶之路唯一不变的是变化本身/03"><span>20 | (0, eval)(&quot;x = 100&quot;) ：一行让严格模式形同虚设的破坏性设计（上）</span></a></li><li><a href="/blog/java-script核心原理解析/05.从粗通到精通的进阶之路唯一不变的是变化本身/04"><span>21 | (0, eval)(&quot;x = 100&quot;) ：一行让严格模式形同虚设的破坏性设计（下）</span></a></li><li><a href="/blog/java-script核心原理解析/05.从粗通到精通的进阶之路唯一不变的是变化本身/05"><span>22 | new Function(&#x27;x = 100&#x27;)();：函数的类化是对动态与静态系统的再次统一</span></a></li></ul></li><li><a href="/blog/java-script核心原理解析/06.结束语">06.结束语</a><ul><li><a href="/blog/java-script核心原理解析/06.结束语/01"><span>结束语 | 愿你能做一个真正“懂”的程序员</span></a></li><li><a href="/blog/java-script核心原理解析/06.结束语/02"><span>结课测试 | 这些JavaScript知识，你真的掌握了吗？</span></a></li></ul></li><li><a href="/blog/java-script核心原理解析/summary">java-script核心原理解析</a></li></ul></div></div><ul role="slug-list" class="__dumi-default-layout-toc"><li title="与声明语句的不同之处" data-depth="2"><a href="/blog/java-script核心原理解析/02.从零开始java-script语言是如何构建起来的/03#与声明语句的不同之处"><span>与声明语句的不同之处</span></a></li><li title="来自《JavaScript权威指南》的解释" data-depth="2"><a href="/blog/java-script核心原理解析/02.从零开始java-script语言是如何构建起来的/03#来自javascript权威指南的解释"><span>来自《JavaScript权威指南》的解释</span></a></li><li title="两个连续赋值的表达式" data-depth="2"><a href="/blog/java-script核心原理解析/02.从零开始java-script语言是如何构建起来的/03#两个连续赋值的表达式"><span>两个连续赋值的表达式</span></a></li><li title="复现现场" data-depth="2"><a href="/blog/java-script核心原理解析/02.从零开始java-script语言是如何构建起来的/03#复现现场"><span>复现现场</span></a></li><li title="回到标题中的示例" data-depth="2"><a href="/blog/java-script核心原理解析/02.从零开始java-script语言是如何构建起来的/03#回到标题中的示例"><span>回到标题中的示例</span></a></li><li title="知识回顾" data-depth="2"><a href="/blog/java-script核心原理解析/02.从零开始java-script语言是如何构建起来的/03#知识回顾"><span>知识回顾</span></a></li><li title="复习题" data-depth="2"><a href="/blog/java-script核心原理解析/02.从零开始java-script语言是如何构建起来的/03#复习题"><span>复习题</span></a></li></ul><div class="__dumi-default-layout-content"><div class="markdown"><h1 id="03--ax--a--n2一道被无数人无数次地解释过的经典面试题"><a aria-hidden="true" tabindex="-1" href="/blog/java-script核心原理解析/02.从零开始java-script语言是如何构建起来的/03#03--ax--a--n2一道被无数人无数次地解释过的经典面试题"><span class="icon icon-link"></span></a>03 | a.x = a = <!-- -->{<!-- -->n:2<!-- -->}<!-- -->：一道被无数人无数次地解释过的经典面试题</h1><p>你好，我是周爱民。</p><p>在前端的历史中，有很多人都曾经因为同一道面试题而彻夜不眠。这道题出现在9年之前，它的提出者“蔡mc（蔡美纯）”曾是JQuery的提交者之一，如今已经隐去多年，不复现身于前端。然而这道经典面试题仍然多年挂于各大论坛，被众多后来者一遍又一遍地分析。</p><p>在2010年10月，<a target="_blank" rel="noopener noreferrer" href="https://github.com/snandy">Snandy<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>于iteye/cnblogs上发起对这个话题的讨论之后，淘宝的玉伯（lifesinger）也随即成为这个问题早期的讨论者之一，并写了一篇“<strong>a.x = a = <!-- -->{<!-- --> <!-- -->}<!-- -->, 深入理解赋值表达式</strong>”来专门讨论它。再后来，随着它在各种面试题集中频繁出现，这个问题也就顺利登上了知乎，成为一桩很有历史的悬案。</p><p>蔡mc最初提出这个问题时用的标题是“<strong>赋值运算符:&quot;=&quot;, 写了10年javascript未必全了解的&quot;=&quot;</strong>”，原本的示例代码如下：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">var c = {};</span></div><div class="token-line"><span class="token plain">    c.a = c = [];</span></div><div class="token-line"><span class="token plain">    alert(c.a); //c.a是什么？</span></div></pre></div><p>蔡mc是在阅读JQuery代码的过程中发现了这一使用模式：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">elemData = {}</span></div><div class="token-line"><span class="token plain">    ...</span></div><div class="token-line"><span class="token plain">    elemData.events = elemData = function(){};</span></div><div class="token-line"><span class="token plain">    elemData.events  = {};</span></div></pre></div><p>并质疑，为什么<code>elemData.events</code>需要连续两次赋值。而Snandy在转述的时候，换了一个更经典、更有迷惑性的示例：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">var a = {n:1};</span></div><div class="token-line"><span class="token plain">    a.x = a = {n:2};</span></div><div class="token-line"><span class="token plain">    alert(a.x); // --&gt; undefined</span></div></pre></div><p>Okay，这就是今天的主题。</p><p>接下来，我就为你解释一下，为什么在第二行代码之后<code>a.x</code>成了undefined值。</p><h2 id="与声明语句的不同之处"><a aria-hidden="true" tabindex="-1" href="/blog/java-script核心原理解析/02.从零开始java-script语言是如何构建起来的/03#与声明语句的不同之处"><span class="icon icon-link"></span></a>与声明语句的不同之处</h2><p>你可能会想，三行代码中出问题的，为什么不是第1行代码？</p><p>在上一讲的讨论中，声明语句也可以是一个连等式，例如：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">var x = y = 100;</span></div></pre></div><p>在这个示例中，“var”关键字所声明的，事实上有且仅有“x”一个变量名。</p><p>在可能的情况下，变量“y”会因为赋值操作而导致JavaScript引擎“<strong>意外</strong>”创建一个全局变量。所以，声明语句“var/let/const”的一个关键点在于：语句的关键字var/let/const只是用来“声明”变量名x的，去除掉“var x”之后剩下的部分，并不是一个严格意义上的“赋值运算”，而是被称为“初始器（Initializer）”的语法组件，它的词法描述为：</p><blockquote><p><em>Initializer</em>: <strong>=</strong> <em>AssignmentExpression</em></p></blockquote><p>在这个描述中，“=”号并不是运算符，而是一个语法分隔符号。所以，之前我在讲述这个部分的时候，总是强调它“被实现为一个赋值操作”，而不是直接说“它是一个赋值操作”，原因就在这里。</p><p>如果说在语法“var x = 100”中，“= 100”是向x绑定值，那么“var x”就是单纯的标识符声明。这意味着非常重要的一点——<strong>“x”只是一个表达名字的、静态语法分析期作为标识符来理解的字面文本，而不是一个表达式</strong>。</p><p>而当我们从相同的代码中去除掉“var”关键字之后：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">x = y = 100;</span></div></pre></div><p>其中的“x”却是一个表达式了，它被严格地称为“赋值表达式的左手端（lhs）操作数”。</p><p>所以，关键的区别在于：（赋值表达式左侧的）操作数可以是另一个表达式——这在专栏的第一讲里就讲过了，而“var声明”语句中的等号左边，绝不可能是一个表达式！</p><p>也许你会质疑：难道ECMAScript 6之后的模板赋值的左侧，也不是表达式？确实，答案是：如果它用在声明语句中，那么就“不是”。</p><p>对于声明语句来说，紧随于“var/let/const”之后的，一定是变量名（标识符），且无论是一个或多个，都是在JavaScript语法分析阶段必须能够识别的。</p><p>如果这里是赋值模板，那么“var/let/const”语句也事实上只会解析那些用来声明的变量名，并在运行期使用“初始器（Initializer）”来为这些名字绑定值。这样，“变量声明语句”的语义才是确定的，不至于与赋值行为混淆在一起。</p><p>因此，根本上来说，在“var声明”语法中，变量名位置上就是写不成<code>a.x</code>的。例如：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">var a.x = ...   // &lt;- 这里将导致语法出错</span></div></pre></div><p>所以，在最初蔡mc提出这个问题时，以及其后Sanady和玉伯的转述中，都不约而同地在代码中绕过了第一行的声明，而将问题指向了第二行的连续赋值运算。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">var a = {n:1};   // 第一行</span></div><div class="token-line"><span class="token plain">    a.x = a = {n:2};  // 第二行</span></div><div class="token-line"><span class="token plain">    ...</span></div></pre></div><h2 id="来自javascript权威指南的解释"><a aria-hidden="true" tabindex="-1" href="/blog/java-script核心原理解析/02.从零开始java-script语言是如何构建起来的/03#来自javascript权威指南的解释"><span class="icon icon-link"></span></a>来自《JavaScript权威指南》的解释</h2><p>有人曾经引述《JavaScript权威指南》中的一段文字（4.7.7 运算顺序），来解释第二行的执行过程：</p><blockquote><p>JavaScript总是严格按照从左至右的顺序来计算表达式。</p></blockquote><p>并且还举了一个例子：</p><blockquote><p>例如，在表达式<code>w = x + y * z</code>中，将首先计算子表达式w，然后计算x、y和z；然后，y的值和z的值相乘，再加上x的值；最后将其赋值给表达式w所指代的变量或属性。</p></blockquote><p>《JavaScript权威指南》的解释是没有问题的。首先，在这个赋值表达式的右侧<code>x + y*z</code>中，<code>x</code>与<code>y*z</code>是求和运算的两个操作数，任何运算的操作数都是严格从左至右计算的，因此x先被处理，然后才会尝试对<code>y</code>和<code>z</code>求乘积。这里所谓的“x先被处理”是JavaScript中的一个特异现象，即：</p><blockquote><p>一切都是表达式，一切都是运算。</p></blockquote><p>这一现象在语言中是函数式的特性，类似“一切被操作的对象都是函数求值的结果，一切操作都是函数”。</p><p>这对于以过程式的，或编译型语言为基础的学习者来说是很难理解的，因为在这些传统的模式或语言范型中，所谓“标识符/变量”就是一个计算对象，它可能直接表达为某个内存地址、指针，或者是一个编译器处理的东西。对于程序员来说，将这个变量直接理解为“操作对象”就可以了，没有别的、附加的知识概念。例如：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">a = 100</span></div><div class="token-line"><span class="token plain">    b * c</span></div></pre></div><p>这两个例子中，a、b、c都是确定的操作数，我们只需要</p><ul><li>将第一行理解为“a有了值100”；</li><li>将第二行理解为“b与c的乘积”</li></ul><p>就可以了，至于引擎怎么处理这三个变量，我们是不管的。</p><p>然而在JavaScript中，上面一共是有六个操作的。以第二行为例，包括：</p><ul><li>将<code>b</code>理解为单值表达式，求值并得到<code>GetValue(evalute(&#x27;b&#x27;))</code>；</li><li>将<code>c</code>理解为单值表达式，求值并得到<code>GetValue(evalute(&#x27;c&#x27;))</code>；</li><li>将上述两个值理解为求积表达式’*&#x27;的两个操作数，计算</li></ul><blockquote><p><code>evalute(&#x27;*&#x27;, GetValue(evalute(&#x27;b&#x27;)), GetValue(evalute(&#x27;c&#x27;)))</code></p></blockquote><p>所以，关键在于<code>b</code>和<code>c</code>在表达式计算过程中都并不简单的是“一个变量”，而是“一个单值表达式的计算结果”。这意味着，在面对JavaScript这样的语言时，你需要关注“变量作为表达式是什么，以及这样的表达式如何求值（以得到变量）”。</p><p>那么，现在再比较一下今天这一讲和上一讲的示例：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">var x = y = 100;</span></div><div class="token-line"><span class="token plain">    a.x = a = {n:2}</span></div></pre></div><p>在这两个例子中，</p><ul><li>x是一个标识符（不是表达式），而y和100都是表达式，且<code>y = 100</code>是一个赋值表达式。</li><li>a.x是一个表达式，而<code>a = <!-- -->{<!-- -->n:2<!-- -->}</code>也是表达式，并且后者的每一个操作数（本质上）也都是表达式。</li></ul><p>这就是“语句与表达式”的不同。正如上一讲的所强调的：“<strong>var x”从来都不进行计算求值，所以也就不能写成“var a.x …</strong>”。</p><blockquote><p>所以严格地说，在上一讲的例子中，并不存在连续赋值运算，因为“var x = …”是<strong>值绑定操作</strong>，而不是“将…赋值给x”。在代码<code>var x = y = 100;</code>中实际只存在一个赋值运算，那就是“y = 100”。</p></blockquote><h2 id="两个连续赋值的表达式"><a aria-hidden="true" tabindex="-1" href="/blog/java-script核心原理解析/02.从零开始java-script语言是如何构建起来的/03#两个连续赋值的表达式"><span class="icon icon-link"></span></a>两个连续赋值的表达式</h2><p>所以，今天标题中的这行代码，是真正的、两个连续赋值的表达式：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">a.x = a = {n:2}</span></div></pre></div><p>并且，按照之前的理解，<code>a.x</code>总是最先被计算求值的（从左至右）。</p><p>回顾第一讲的内容，你也应该记得，所谓“a.x”也是一个表达式，其结果是一个“引用”。这个表达式“a.x”本身也要再计算它的左操作数，也就是“a”。完整地讲，“a.x”这个表达式的语义是：</p><ul><li>计算单值表达式<code>a</code>，得到<code>a</code>的引用；</li><li>将右侧的名字<code>x</code>理解为一个标识符，并作为“.”运算的右操作数；</li><li>计算“a.x”表达式的结果（Result）。</li></ul><p>表达式“a.x”的计算结果是一个引用，因此通过这个引用保存了一些计算过程中的信息——例如它保存了“a”这个对象，以备后续操作中“可能会”作为<code>this</code>来使用。所以现在，在整行代码的前三个表达式计算过程中，“a”是作为一个<strong>引用</strong>被暂存下来了的。</p><p>那么这个“a”现在是什么呢？</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">var a = {n:1};</span></div><div class="token-line"><span class="token plain">    a.x = ...</span></div></pre></div><p>从代码中可见，保存在“a.x”这个引用中的“a”是当前的“<!-- -->{<!-- -->n:1<!-- -->}<!-- -->”这个对象。好的，接下来再继续往下执行：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">var a = {n:1};</span></div><div class="token-line"><span class="token plain">    a.x =     // &lt;- `a` is {n:1}</span></div><div class="token-line"><span class="token plain">          a = // &lt;- `a` is {n:1}</span></div><div class="token-line"><span class="token plain">    ...</span></div></pre></div><p>这里的“a = …”中的<code>a</code>仍然是当前环境中的变量，与上一次暂存的值是相同的。这里仍然没有问题。</p><p>但接下来，发生了赋值：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">...</span></div><div class="token-line"><span class="token plain">    a.x =              // &lt;- `a` is {n:1}</span></div><div class="token-line"><span class="token plain">          a =          // &lt;- `a` is {n:1}</span></div><div class="token-line"><span class="token plain">              {n:2};   // 赋值，覆盖当前的左操作数（变量`a`）</span></div></pre></div><p>于是，左操作数<code>a</code>作为一个引用被覆盖了，这个引用仍然是当前上下文中的那个变量<code>a</code>。因此，这里真实地发生了一次<code>a = <!-- -->{<!-- -->n:2<!-- -->}</code>。</p><p>那么现在，表达式最开始被保留在“一个结果（Result）”中的引用<code>a</code>会更新吗？</p><p>不会的。这是因为那是一个“<strong>运算结果</strong>（Result）”，这个结果有且仅有引擎知道，它现在是一个引擎才理解的“<strong>引用</strong>（规范对象）”，对于它的可能操作只有：</p><ul><li>取值或置值（GetValue/PutValue），以及</li><li>作为一个引用向别的地方传递等。</li></ul><p>当然，如同第一讲里强调的，它也可以被typeof和delete等操作引用的运算来操作。但无论如何，在JavaScript用户代码层面，能做的主要还是<strong>取值</strong>和<strong>置值</strong>。</p><p>现在，在整个语句行的最左侧“<strong>空悬</strong>”了一个已经求值过的“a.x”。当它作为赋值表达式的左操作数时，它是一个被赋值的引用（这里是指将<code>a.x</code>的整体作为一个引用规范对象）。而它作为结果（Result）所保留的“a”，是在被第一次赋值操作覆盖之前的、那个“原始的变量<code>a</code>”。也就是说，如果你试图访问它的“a.n”，那应该是值“1”。</p><p>这个被赋值的引用“a.x”其实是一个未创建的属性，赋值操作将使得那个“原始的变量<code>a</code>”具有一个新属性，于是它变成了下面这样：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// a.x中的“原始的变量`a`”</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">      x: {n: 2},  // &lt;- 第一次赋值“a = {n:2}”的结果</span></div><div class="token-line"><span class="token plain">      n: 1</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>这就是第二次赋值操作的结果。</p><h2 id="复现现场"><a aria-hidden="true" tabindex="-1" href="/blog/java-script核心原理解析/02.从零开始java-script语言是如何构建起来的/03#复现现场"><span class="icon icon-link"></span></a>复现现场</h2><p>上面发生了两次赋值，第一次赋值发生于“a = <!-- -->{<!-- -->n: 2<!-- -->}<!-- -->”，它覆盖了“原始的变量<code>a</code>”；第二次赋值发生于被“a.x”引用暂存的“原始的变量<code>a</code>”。</p><p>我可以给出一段简单的代码，来复现这个现场，以便你看清这个结果。例如：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// 声明“原始的变量a”</span></div><div class="token-line"><span class="token plain">    var a = {n:1};</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    // 使它的属性表冻结（不能再添加属性）</span></div><div class="token-line"><span class="token plain">    Object.freeze(a);</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    try {</span></div><div class="token-line"><span class="token plain">      // 本节的示例代码</span></div><div class="token-line"><span class="token plain">      a.x = a = {n:2};</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    catch (x) {</span></div><div class="token-line"><span class="token plain">      // 异常发生，说明第二次赋值“a.x = ...”中操作的`a`正是原始的变量a</span></div><div class="token-line"><span class="token plain">      console.log(&#x27;第二次赋值导致异常.&#x27;);</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    // 第一次赋值是成功的</span></div><div class="token-line"><span class="token plain">    console.log(a.n); //</span></div></pre></div><p>第二次赋值操作中，将尝试向“原始的变量<code>a</code>”添加一个属性“a.x“，且如果它没有冻结的话，属性“a.x”会指向第一次赋值的结果。</p><h2 id="回到标题中的示例"><a aria-hidden="true" tabindex="-1" href="/blog/java-script核心原理解析/02.从零开始java-script语言是如何构建起来的/03#回到标题中的示例"><span class="icon icon-link"></span></a>回到标题中的示例</h2><p>那标题中的这行代码的最终结果是什么呢？答案是：</p><ul><li>有一个新的<code>a</code>产生，它覆盖了原始的变量<code>a</code>，它的值是<code>{<!-- -->n:2<!-- -->}</code>；</li><li>最左侧的“a.x”的计算结果中的“原始的变量<code>a</code>”在引用传递的过程中丢失了，且“a.x”被同时丢弃。</li></ul><p>所以，第二次赋值操作“a.x = …”实际是无意义的。因为它所操作的对象，也就是“原始的变量<code>a</code>”被废弃了。但是，如果有其它的东西，如变量、属性或者闭包等，持有了这个“原始的变量<code>a</code>”，那么上面的代码的影响仍然是可见的。</p><blockquote><p>事实上，由于JavaScript中支持属性读写器，因此向“a.x”置值的行为总是可能存在“某种执行效果”，而与“a”对象是否被覆盖或丢弃无关。</p></blockquote><p>例如：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">var a = {n:1}, ref = a;</span></div><div class="token-line"><span class="token plain">    a.x = a = {n:2};</span></div><div class="token-line"><span class="token plain">    console.log(a.x); // --&gt; undefined</span></div><div class="token-line"><span class="token plain">    console.log(ref.x); // {n:2}</span></div></pre></div><p>这也解释了最初“蔡mc”的疑问：连续两次赋值<code>elemData.events</code>有什么用？</p><p>如果<code>a</code>（或<code>elemData</code>）总是被重写的旧的变量，那么如下代码：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">a.x = a = {n:2}</span></div></pre></div><p>意味着给<strong>旧的变量</strong>添加一个<strong>指向新变量的属性</strong>。因此，一个链表是可以像下面这样来创建的：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">var i = 10, root = {index: &quot;NONE&quot;}, node = root;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    // 创建链表</span></div><div class="token-line"><span class="token plain">    while (i &gt; 0) {</span></div><div class="token-line"><span class="token plain">      node.next = node = new Object;</span></div><div class="token-line"><span class="token plain">      node.index = i--;  // 这里可以开始给新node添加成员</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    // 测试</span></div><div class="token-line"><span class="token plain">    node = root;</span></div><div class="token-line"><span class="token plain">    while (node = node.next) {</span></div><div class="token-line"><span class="token plain">      console.log(node.index);</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>最后，我做这道面试题做一点点细节上的补充：</p><ul><li>这道面试题与运算符优先级无关；</li><li>这里的运算过程与“栈”操作无关；</li><li>这里的“引用”与传统语言中的“指针”没有可比性；</li><li>这里没有变量泄漏；</li><li>这行代码与上一讲的例子有本质的不同；</li><li>上一讲的例子“var x = y = 100”严格说来并不是连续赋值。</li></ul><h2 id="知识回顾"><a aria-hidden="true" tabindex="-1" href="/blog/java-script核心原理解析/02.从零开始java-script语言是如何构建起来的/03#知识回顾"><span class="icon icon-link"></span></a>知识回顾</h2><p>前三讲中，我通过对几行特殊代码的分析，希望能帮助你理解“引用（规范类型）”在JavaScript引擎内部的基本运作原理，包括：</p><ul><li>引用在语言中出现的历史；</li><li>引用与值的创建与使用，以及它的销毁（delete）；</li><li>表达式（求值）和引用之间的关系；</li><li>引用如何在表达式连续运算中传递计算过程的信息；</li><li>仔细观察每一个表达式（及其操作数）计算的顺序；</li><li>所有声明，以及声明语句的共性。</li></ul><h2 id="复习题"><a aria-hidden="true" tabindex="-1" href="/blog/java-script核心原理解析/02.从零开始java-script语言是如何构建起来的/03#复习题"><span class="icon icon-link"></span></a>复习题</h2><p>下面有几道复习题，希望你尝试解答一下：</p><ol><li>试解析<code>with (<!-- -->{<!-- -->x:100<!-- -->}<!-- -->) delete x;</code> 将发生什么。</li><li>试说明<code>(eval)()</code>与<code>(0, eval)()</code>的不同。</li><li>设“a.x === 0”，试说明“(a.x) = 1”为什么可行。</li><li>为什么<code>with (obj=<!-- -->{<!-- -->}<!-- -->) x = 100;</code> 不会给obj添加一个属性’x’？</li></ol><p>希望你喜欢我的分享，也欢迎你把文章分享给你的朋友。</p></div><div class="__dumi-default-layout-footer-meta"><a target="_blank" rel="noopener noreferrer" href="https://github.com/GGwujun/blog/edit/master/docs/java-script核心原理解析/02.从零开始JavaScript语言是如何构建起来的/03.md">在 GitHub 上编辑此页<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a><span data-updated-text="最后更新时间：">5/2/2022 10:56:37</span></div></div></div></div>
	<script>
  window.g_useSSR = true;
  window.g_initialProps = {};
	</script>

    <script>
      (function () {
        if (!location.port) {
          (function (i, s, o, g, r, a, m) {
            i["GoogleAnalyticsObject"] = r;
            (i[r] =
              i[r] ||
              function () {
                (i[r].q = i[r].q || []).push(arguments);
              }),
              (i[r].l = 1 * new Date());
            (a = s.createElement(o)), (m = s.getElementsByTagName(o)[0]);
            a.async = 1;
            a.src = g;
            m.parentNode.insertBefore(a, m);
          })(
            window,
            document,
            "script",
            "//www.google-analytics.com/analytics.js",
            "ga"
          );
          ga("create", "UA-149864185-1", "auto");
          ga("send", "pageview");
        }
      })();
    </script>
    <script src="/blog/umi.js"></script>
  </body>
</html>
