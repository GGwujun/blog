<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no"
    />
    <link rel="shortcut icon" type="image/x-icon" href="/logo.png" />
    <link rel="stylesheet" href="/blog/umi.css" />
    <script>
      window.routerBase = "/blog";
    </script>
    <script>
      //! umi version: 3.5.17
    </script>
    <script>
      !(function () {
        var e = localStorage.getItem("dumi:prefers-color"),
          t = window.matchMedia("(prefers-color-scheme: dark)").matches,
          r = ["light", "dark", "auto"];
        document.documentElement.setAttribute(
          "data-prefers-color",
          e === r[2] ? (t ? r[1] : r[0]) : r.indexOf(e) > -1 ? e : r[0]
        );
      })();
    </script>
    <title>14 | super.xxx()：虽然直到ES10还是个半吊子实现，却也值得一讲</title>
  </head>
  <body>
    <div id="root"><div class="__dumi-default-layout" data-route="/java-script核心原理解析/04.从原型到类java-script是如何一步步走向应用编程语言的/03" data-show-sidemenu="true" data-show-slugs="true" data-site-mode="true" data-gapless="false"><div class="__dumi-default-navbar" data-mode="site"><button class="__dumi-default-navbar-toggle"></button><a class="__dumi-default-navbar-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog/">大师兄</a><nav><div class="__dumi-default-search"><input type="search" class="__dumi-default-search-input" value=""/><ul></ul></div><span>计算机基础<ul><li><a href="/blog/编译原理之美">编译原理之美</a></li><li><a href="/blog/编译原理实战">编译原理实战</a></li><li><a href="/blog/深入浅出计算机组成原理">深入浅出计算机组成原理</a></li><li><a href="/blog/详解http">详解http</a></li><li><a href="/blog/计算机网络通关29讲">计算机网络通关29讲</a></li><li><a href="/blog/网络排查案例课">网络排查案例课</a></li><li><a href="/blog/linux操作系统">linux操作系统</a></li><li><a href="/blog/linux性能优化实战">linux性能优化实战</a></li><li><a href="/blog/程序员数学基础">程序员数学基础</a></li><li><a href="/blog/趣谈网络协议">趣谈网络协议</a></li><li><a href="/blog/操作系统实战">操作系统实战</a></li><li><a href="/blog/软件工程之美">软件工程之美</a></li><li><a href="/blog/sql必知必会">sql必知必会</a></li><li><a href="/blog/操作系统实战45讲">操作系统实战45讲</a></li><li><a href="/blog/网络编程实战">网络编程实战</a></li></ul></span><span>算法<ul><li><a href="/blog/常用算法25讲">常用算法25讲</a></li><li><a href="/blog/数据结构与算法之美">数据结构与算法之美</a></li><li><a href="/blog/业务开发算法50讲">业务开发算法50讲</a></li><li><a href="/blog/动态规划面试宝典">动态规划面试宝典</a></li></ul></span><span>前端开发<ul><li><a href="/blog/浏览器工作原理与实践">浏览器工作原理与实践</a></li><li><a href="/blog/新时代产品经理进阶之路">新时代产品经理进阶之路</a></li><li><a href="/blog/全栈工程师修炼指南">全栈工程师修炼指南</a></li><li><a href="/blog/flutter核心技术与实战">flutter核心技术与实战</a></li><li><a aria-current="page" class="active" href="/blog/java-script核心原理解析">java-script核心原理解析</a></li><li><a href="/blog/说透低代码">说透低代码</a></li><li><a href="/blog/nodejs应用开发实战">nodejs应用开发实战</a></li><li><a href="/blog/反爬虫兵法演绎20讲">反爬虫兵法演绎20讲</a></li><li><a href="/blog/reactnative新架构实战课">reactnative新架构实战课</a></li><li><a href="/blog/正则表达式入门">正则表达式入门</a></li><li><a href="/blog/重学前端">重学前端</a></li><li><a href="/blog/serverless入门课">serverless入门课</a></li><li><a href="/blog/type-script入门实战笔记">type-script入门实战笔记</a></li><li><a href="/blog/图解googlev8">图解googlev8</a></li><li><a href="/blog/vue3源码分析">vue3源码分析</a></li><li><a href="/blog/玩转Vue3全家桶">玩转Vue3全家桶</a></li><li><a href="/blog/webassembly入门">webassembly入门</a></li><li><a href="/blog/手把手带你写一个Web框架">手把手带你写一个Web框架</a></li><li><a href="/blog/web漏洞挖掘实战">web漏洞挖掘实战</a></li><li><a href="/blog/跟月影学可视化">跟月影学可视化</a></li><li><a href="/blog/搞定音频技术">搞定音频技术</a></li><li><a href="/blog/攻克视频技术">攻克视频技术</a></li></ul></span><span>前端工程化<ul><li><a href="/blog/logger">logger</a></li><li><a href="/blog/webpack">webpack</a></li><li><a href="/blog/webpackChain">webpackChain</a></li></ul></span><span>前端性能优化<ul><li><a href="/blog/react性能调优">react性能调优</a></li></ul></span><span>软件测试<ul><li><a href="/blog/全链路压测实战30讲">全链路压测实战30讲</a></li><li><a href="/blog/性能测试实战30讲">性能测试实战30讲</a></li><li><a href="/blog/自动化测试高手课">自动化测试高手课</a></li><li><a href="/blog/软件测试52讲">软件测试52讲</a></li></ul></span><span>面试<ul><li><a href="/blog/面试现场">面试现场</a></li></ul></span><span>杂谈<ul><li><a href="/blog/超级访谈对话张雪峰">超级访谈对话张雪峰</a></li><li><a href="/blog/Git实战手册">Git实战手册</a></li><li><a href="/blog/NodeJS">NodeJS</a></li><li><a href="/blog/ReactJS">ReactJS</a></li><li><a href="/blog/UI设计">UI设计</a></li><li><a href="/blog/webpack4系列教程">webpack4系列教程</a></li><li><a href="/blog/前端知识体系">前端知识体系</a></li><li><a href="/blog/剑指offer刷题笔记">剑指offer刷题笔记</a></li><li><a href="/blog/思考与成长">思考与成长</a></li><li><a href="/blog/设计模式手册">设计模式手册</a></li></ul></span><div class="__dumi-default-navbar-tool"><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "></div></div></div></nav></div><div class="__dumi-default-menu" data-mode="site"><div class="__dumi-default-menu-inner"><div class="__dumi-default-menu-header"><a class="__dumi-default-menu-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog/"></a><h1>大师兄</h1><p></p></div><div class="__dumi-default-menu-mobile-area"><ul class="__dumi-default-menu-nav-list"><li>计算机基础<ul><li><a href="/blog/编译原理之美">编译原理之美</a></li><li><a href="/blog/编译原理实战">编译原理实战</a></li><li><a href="/blog/深入浅出计算机组成原理">深入浅出计算机组成原理</a></li><li><a href="/blog/详解http">详解http</a></li><li><a href="/blog/计算机网络通关29讲">计算机网络通关29讲</a></li><li><a href="/blog/网络排查案例课">网络排查案例课</a></li><li><a href="/blog/linux操作系统">linux操作系统</a></li><li><a href="/blog/linux性能优化实战">linux性能优化实战</a></li><li><a href="/blog/程序员数学基础">程序员数学基础</a></li><li><a href="/blog/趣谈网络协议">趣谈网络协议</a></li><li><a href="/blog/操作系统实战">操作系统实战</a></li><li><a href="/blog/软件工程之美">软件工程之美</a></li><li><a href="/blog/sql必知必会">sql必知必会</a></li><li><a href="/blog/操作系统实战45讲">操作系统实战45讲</a></li><li><a href="/blog/网络编程实战">网络编程实战</a></li></ul></li><li>算法<ul><li><a href="/blog/常用算法25讲">常用算法25讲</a></li><li><a href="/blog/数据结构与算法之美">数据结构与算法之美</a></li><li><a href="/blog/业务开发算法50讲">业务开发算法50讲</a></li><li><a href="/blog/动态规划面试宝典">动态规划面试宝典</a></li></ul></li><li>前端开发<ul><li><a href="/blog/浏览器工作原理与实践">浏览器工作原理与实践</a></li><li><a href="/blog/新时代产品经理进阶之路">新时代产品经理进阶之路</a></li><li><a href="/blog/全栈工程师修炼指南">全栈工程师修炼指南</a></li><li><a href="/blog/flutter核心技术与实战">flutter核心技术与实战</a></li><li><a aria-current="page" class="active" href="/blog/java-script核心原理解析">java-script核心原理解析</a></li><li><a href="/blog/说透低代码">说透低代码</a></li><li><a href="/blog/nodejs应用开发实战">nodejs应用开发实战</a></li><li><a href="/blog/反爬虫兵法演绎20讲">反爬虫兵法演绎20讲</a></li><li><a href="/blog/reactnative新架构实战课">reactnative新架构实战课</a></li><li><a href="/blog/正则表达式入门">正则表达式入门</a></li><li><a href="/blog/重学前端">重学前端</a></li><li><a href="/blog/serverless入门课">serverless入门课</a></li><li><a href="/blog/type-script入门实战笔记">type-script入门实战笔记</a></li><li><a href="/blog/图解googlev8">图解googlev8</a></li><li><a href="/blog/vue3源码分析">vue3源码分析</a></li><li><a href="/blog/玩转Vue3全家桶">玩转Vue3全家桶</a></li><li><a href="/blog/webassembly入门">webassembly入门</a></li><li><a href="/blog/手把手带你写一个Web框架">手把手带你写一个Web框架</a></li><li><a href="/blog/web漏洞挖掘实战">web漏洞挖掘实战</a></li><li><a href="/blog/跟月影学可视化">跟月影学可视化</a></li><li><a href="/blog/搞定音频技术">搞定音频技术</a></li><li><a href="/blog/攻克视频技术">攻克视频技术</a></li></ul></li><li>前端工程化<ul><li><a href="/blog/logger">logger</a></li><li><a href="/blog/webpack">webpack</a></li><li><a href="/blog/webpackChain">webpackChain</a></li></ul></li><li>前端性能优化<ul><li><a href="/blog/react性能调优">react性能调优</a></li></ul></li><li>软件测试<ul><li><a href="/blog/全链路压测实战30讲">全链路压测实战30讲</a></li><li><a href="/blog/性能测试实战30讲">性能测试实战30讲</a></li><li><a href="/blog/自动化测试高手课">自动化测试高手课</a></li><li><a href="/blog/软件测试52讲">软件测试52讲</a></li></ul></li><li>面试<ul><li><a href="/blog/面试现场">面试现场</a></li></ul></li><li>杂谈<ul><li><a href="/blog/超级访谈对话张雪峰">超级访谈对话张雪峰</a></li><li><a href="/blog/Git实战手册">Git实战手册</a></li><li><a href="/blog/NodeJS">NodeJS</a></li><li><a href="/blog/ReactJS">ReactJS</a></li><li><a href="/blog/UI设计">UI设计</a></li><li><a href="/blog/webpack4系列教程">webpack4系列教程</a></li><li><a href="/blog/前端知识体系">前端知识体系</a></li><li><a href="/blog/剑指offer刷题笔记">剑指offer刷题笔记</a></li><li><a href="/blog/思考与成长">思考与成长</a></li><li><a href="/blog/设计模式手册">设计模式手册</a></li></ul></li></ul><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "><button title="Dark theme" class="__dumi-default-dark-moon "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="3854" width="22" height="22"><path d="M991.816611 674.909091a69.166545 69.166545 0 0 0-51.665455-23.272727 70.795636 70.795636 0 0 0-27.438545 5.585454A415.674182 415.674182 0 0 1 754.993338 698.181818c-209.594182 0-393.472-184.785455-393.472-395.636363 0-52.363636 38.539636-119.621818 69.515637-173.614546 4.887273-8.610909 9.634909-16.756364 14.103272-24.901818A69.818182 69.818182 0 0 0 384.631156 0a70.842182 70.842182 0 0 0-27.438545 5.585455C161.678429 90.298182 14.362065 307.898182 14.362065 512c0 282.298182 238.824727 512 532.38691 512a522.286545 522.286545 0 0 0 453.957818-268.334545A69.818182 69.818182 0 0 0 991.816611 674.909091zM546.679156 954.181818c-248.785455 0-462.941091-192-462.941091-442.181818 0-186.647273 140.637091-372.829091 300.939637-442.181818-36.817455 65.629091-92.578909 151.970909-92.578909 232.727273 0 250.181818 214.109091 465.454545 462.917818 465.454545a488.331636 488.331636 0 0 0 185.181091-46.545455 453.003636 453.003636 0 0 1-393.565091 232.727273z m103.656728-669.323636l-14.266182 83.781818a34.909091 34.909091 0 0 0 50.362182 36.770909l74.775272-39.563636 74.752 39.563636a36.142545 36.142545 0 0 0 16.174546 3.956364 34.909091 34.909091 0 0 0 34.210909-40.727273l-14.289455-83.781818 60.509091-59.345455a35.025455 35.025455 0 0 0-19.223272-59.578182l-83.61891-12.101818-37.376-76.101818a34.56 34.56 0 0 0-62.254545 0l-37.376 76.101818-83.618909 12.101818a34.909091 34.909091 0 0 0-19.246546 59.578182z m70.423272-64.698182a34.280727 34.280727 0 0 0 26.135273-19.083636l14.312727-29.090909 14.336 29.090909a34.257455 34.257455 0 0 0 26.135273 19.083636l32.046546 4.887273-23.272728 22.574545a35.234909 35.234909 0 0 0-10.007272 30.952727l5.46909 32.116364-28.625454-15.127273a34.490182 34.490182 0 0 0-32.302546 0l-28.695272 15.127273 5.469091-32.116364a35.141818 35.141818 0 0 0-9.984-30.952727l-23.272728-22.574545z" p-id="3855"></path></svg></button><button title="Light theme" class="__dumi-default-dark-sun "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="4026" width="22" height="22"><path d="M915.2 476.16h-43.968c-24.704 0-44.736 16-44.736 35.84s20.032 35.904 44.736 35.904H915.2c24.768 0 44.8-16.064 44.8-35.904s-20.032-35.84-44.8-35.84zM512 265.6c-136.704 0-246.464 109.824-246.464 246.4 0 136.704 109.76 246.464 246.464 246.464S758.4 648.704 758.4 512c0-136.576-109.696-246.4-246.4-246.4z m0 425.6c-99.008 0-179.2-80.128-179.2-179.2 0-98.944 80.192-179.2 179.2-179.2S691.2 413.056 691.2 512c0 99.072-80.192 179.2-179.2 179.2zM197.44 512c0-19.84-19.136-35.84-43.904-35.84H108.8c-24.768 0-44.8 16-44.8 35.84s20.032 35.904 44.8 35.904h44.736c24.768 0 43.904-16.064 43.904-35.904zM512 198.464c19.776 0 35.84-20.032 35.84-44.8v-44.8C547.84 84.032 531.84 64 512 64s-35.904 20.032-35.904 44.8v44.8c0 24.768 16.128 44.864 35.904 44.864z m0 627.136c-19.776 0-35.904 20.032-35.904 44.8v44.736C476.096 940.032 492.16 960 512 960s35.84-20.032 35.84-44.8v-44.736c0-24.768-16.064-44.864-35.84-44.864z m329.92-592.832c17.472-17.536 20.288-43.072 6.4-57.024-14.016-14.016-39.488-11.2-57.024 6.336-4.736 4.864-26.496 26.496-31.36 31.36-17.472 17.472-20.288 43.008-6.336 57.024 13.952 14.016 39.488 11.2 57.024-6.336 4.8-4.864 26.496-26.56 31.296-31.36zM213.376 759.936c-4.864 4.8-26.56 26.624-31.36 31.36-17.472 17.472-20.288 42.944-6.4 56.96 14.016 13.952 39.552 11.2 57.024-6.336 4.8-4.736 26.56-26.496 31.36-31.36 17.472-17.472 20.288-43.008 6.336-56.96-14.016-13.952-39.552-11.072-56.96 6.336z m19.328-577.92c-17.536-17.536-43.008-20.352-57.024-6.336-14.08 14.016-11.136 39.488 6.336 57.024 4.864 4.864 26.496 26.56 31.36 31.424 17.536 17.408 43.008 20.288 56.96 6.336 14.016-14.016 11.264-39.488-6.336-57.024-4.736-4.864-26.496-26.56-31.296-31.424z m527.168 628.608c4.864 4.864 26.624 26.624 31.36 31.424 17.536 17.408 43.072 20.224 57.088 6.336 13.952-14.016 11.072-39.552-6.4-57.024-4.864-4.8-26.56-26.496-31.36-31.36-17.472-17.408-43.072-20.288-57.024-6.336-13.952 14.016-11.008 39.488 6.336 56.96z" p-id="4027"></path></svg></button><button title="Default to system" class="__dumi-default-dark-auto "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="11002" width="22" height="22"><path d="M127.658667 492.885333c0-51.882667 10.24-101.717333 30.378666-149.162666s47.786667-88.064 81.92-122.538667 75.093333-61.781333 122.538667-81.92 96.938667-30.378667 149.162667-30.378667 101.717333 10.24 149.162666 30.378667 88.405333 47.786667 122.88 81.92 61.781333 75.093333 81.92 122.538667 30.378667 96.938667 30.378667 149.162666-10.24 101.717333-30.378667 149.162667-47.786667 88.405333-81.92 122.88-75.093333 61.781333-122.88 81.92-97.28 30.378667-149.162666 30.378667-101.717333-10.24-149.162667-30.378667-88.064-47.786667-122.538667-81.92-61.781333-75.093333-81.92-122.88-30.378667-96.938667-30.378666-149.162667z m329.045333 0c0 130.048 13.994667 244.394667 41.984 343.381334h12.970667c46.762667 0 91.136-9.216 133.461333-27.306667s78.848-42.666667 109.568-73.386667 54.954667-67.242667 73.386667-109.568 27.306667-86.698667 27.306666-133.461333c0-46.421333-9.216-90.794667-27.306666-133.12s-42.666667-78.848-73.386667-109.568-67.242667-54.954667-109.568-73.386667-86.698667-27.306667-133.461333-27.306666h-11.605334c-28.672 123.562667-43.349333 237.909333-43.349333 343.722666z" p-id="11003"></path></svg></button></div></div></div><ul class="__dumi-default-menu-list"><li><a href="/blog/java-script核心原理解析">java-script核心原理解析</a></li><li><a href="/blog/java-script核心原理解析/01.开篇词">01.开篇词</a><ul><li><a href="/blog/java-script核心原理解析/01.开篇词/01"><span>开篇词 | 如何解决语言问题？</span></a></li></ul></li><li><a href="/blog/java-script核心原理解析/02.从零开始java-script语言是如何构建起来的">02.从零开始JavaScript语言是如何构建起来的</a><ul><li><a href="/blog/java-script核心原理解析/02.从零开始java-script语言是如何构建起来的/01"><span>01 | delete 0：JavaScript中到底有什么是可以销毁的</span></a></li><li><a href="/blog/java-script核心原理解析/02.从零开始java-script语言是如何构建起来的/02"><span>02 | var x = y = 100：声明语句与语法改变了JavaScript语言核心性质</span></a></li><li><a href="/blog/java-script核心原理解析/02.从零开始java-script语言是如何构建起来的/03"><span>03 | a.x = a = {n:2}：一道被无数人无数次地解释过的经典面试题</span></a></li><li><a href="/blog/java-script核心原理解析/02.从零开始java-script语言是如何构建起来的/04"><span>04 | export default function() {}：你无法导出一个匿名函数表达式</span></a></li><li><a href="/blog/java-script核心原理解析/02.从零开始java-script语言是如何构建起来的/05"><span>05 | for (let x of [1,2,3]) ...：for循环并不比使用函数递归节省开销</span></a></li><li><a href="/blog/java-script核心原理解析/02.从零开始java-script语言是如何构建起来的/06"><span>加餐 | 捡豆吃豆的学问（上）：这门课讲的是什么？</span></a></li><li><a href="/blog/java-script核心原理解析/02.从零开始java-script语言是如何构建起来的/07"><span>加餐 | 捡豆吃豆的学问（下）：这门课该怎么学？</span></a></li></ul></li><li><a href="/blog/java-script核心原理解析/03.从表达式到执行引擎java-script是如何运行的">03.从表达式到执行引擎JavaScript是如何运行的</a><ul><li><a href="/blog/java-script核心原理解析/03.从表达式到执行引擎java-script是如何运行的/01"><span>06 | x: break x;  搞懂如何在循环外使用break，方知语句执行真解</span></a></li><li><a href="/blog/java-script核心原理解析/03.从表达式到执行引擎java-script是如何运行的/02"><span>07 | ${1}：详解JavaScript中特殊的可执行结构</span></a></li><li><a href="/blog/java-script核心原理解析/03.从表达式到执行引擎java-script是如何运行的/03"><span>08 | x =&gt; x：函数式语言的核心抽象：函数与表达式的同一性</span></a></li><li><a href="/blog/java-script核心原理解析/03.从表达式到执行引擎java-script是如何运行的/04"><span>09 | (...x)：不是表达式、语句、函数，但它却能执行</span></a></li><li><a href="/blog/java-script核心原理解析/03.从表达式到执行引擎java-script是如何运行的/05"><span>10 | x = yield x：迭代过程的“函数式化”</span></a></li><li><a href="/blog/java-script核心原理解析/03.从表达式到执行引擎java-script是如何运行的/06"><span>11 | throw 1;：它在“最简单语法榜”上排名第三</span></a></li><li><a href="/blog/java-script核心原理解析/03.从表达式到执行引擎java-script是如何运行的/07"><span>加餐 | 让JavaScript运行起来</span></a></li></ul></li><li><a aria-current="page" class="active" href="/blog/java-script核心原理解析/04.从原型到类java-script是如何一步步走向应用编程语言的">04.从原型到类JavaScript是如何一步步走向应用编程语言的</a><ul><li><a href="/blog/java-script核心原理解析/04.从原型到类java-script是如何一步步走向应用编程语言的/01"><span>12 | 1 in 1..constructor：这行代码的结果，既可能是true，也可能是false</span></a></li><li><a href="/blog/java-script核心原理解析/04.从原型到类java-script是如何一步步走向应用编程语言的/02"><span>13 | new X：从构造器到类，为你揭密对象构造的全程</span></a></li><li><a aria-current="page" class="active" href="/blog/java-script核心原理解析/04.从原型到类java-script是如何一步步走向应用编程语言的/03"><span>14 | super.xxx()：虽然直到ES10还是个半吊子实现，却也值得一讲</span></a></li><li><a href="/blog/java-script核心原理解析/04.从原型到类java-script是如何一步步走向应用编程语言的/04"><span>15 | return Object.create(new.target.prototype)：做框架设计的基本功：写一个根类</span></a></li><li><a href="/blog/java-script核心原理解析/04.从原型到类java-script是如何一步步走向应用编程语言的/05"><span>16 | [a, b] = {a, b}：让你从一行代码看到对象的本质</span></a></li><li><a href="/blog/java-script核心原理解析/04.从原型到类java-script是如何一步步走向应用编程语言的/06"><span>17 | Object.setPrototypeOf(x, null)：连Brendan Eich都认错，但null值还活着</span></a></li></ul></li><li><a href="/blog/java-script核心原理解析/05.从粗通到精通的进阶之路唯一不变的是变化本身">05.从粗通到精通的进阶之路唯一不变的是变化本身</a><ul><li><a href="/blog/java-script核心原理解析/05.从粗通到精通的进阶之路唯一不变的是变化本身/01"><span>18 | a + b：动态类型是灾难之源还是最好的特性？（上）</span></a></li><li><a href="/blog/java-script核心原理解析/05.从粗通到精通的进阶之路唯一不变的是变化本身/02"><span>19 | a + b：动态类型是灾难之源还是最好的特性？（下）</span></a></li><li><a href="/blog/java-script核心原理解析/05.从粗通到精通的进阶之路唯一不变的是变化本身/03"><span>20 | (0, eval)(&quot;x = 100&quot;) ：一行让严格模式形同虚设的破坏性设计（上）</span></a></li><li><a href="/blog/java-script核心原理解析/05.从粗通到精通的进阶之路唯一不变的是变化本身/04"><span>21 | (0, eval)(&quot;x = 100&quot;) ：一行让严格模式形同虚设的破坏性设计（下）</span></a></li><li><a href="/blog/java-script核心原理解析/05.从粗通到精通的进阶之路唯一不变的是变化本身/05"><span>22 | new Function(&#x27;x = 100&#x27;)();：函数的类化是对动态与静态系统的再次统一</span></a></li></ul></li><li><a href="/blog/java-script核心原理解析/06.结束语">06.结束语</a><ul><li><a href="/blog/java-script核心原理解析/06.结束语/01"><span>结束语 | 愿你能做一个真正“懂”的程序员</span></a></li><li><a href="/blog/java-script核心原理解析/06.结束语/02"><span>结课测试 | 这些JavaScript知识，你真的掌握了吗？</span></a></li></ul></li><li><a href="/blog/java-script核心原理解析/summary">java-script核心原理解析</a></li></ul></div></div><ul role="slug-list" class="__dumi-default-layout-toc"><li title="为什么要有super？" data-depth="2"><a href="/blog/java-script核心原理解析/04.从原型到类java-script是如何一步步走向应用编程语言的/03#为什么要有super"><span>为什么要有super？</span></a></li><li title="super指向什么？" data-depth="2"><a href="/blog/java-script核心原理解析/04.从原型到类java-script是如何一步步走向应用编程语言的/03#super指向什么"><span>super指向什么？</span></a></li><li title="super.xxx()" data-depth="2"><a href="/blog/java-script核心原理解析/04.从原型到类java-script是如何一步步走向应用编程语言的/03#superxxx"><span>super.xxx()</span></a></li><li title="super.xxx()中的this值" data-depth="3"><a href="/blog/java-script核心原理解析/04.从原型到类java-script是如何一步步走向应用编程语言的/03#superxxx中的this值"><span>super.xxx()中的this值</span></a></li><li title="super()中的父类构造方法" data-depth="3"><a href="/blog/java-script核心原理解析/04.从原型到类java-script是如何一步步走向应用编程语言的/03#super中的父类构造方法"><span>super()中的父类构造方法</span></a></li><li title="为什么构造方法不是静态的？" data-depth="3"><a href="/blog/java-script核心原理解析/04.从原型到类java-script是如何一步步走向应用编程语言的/03#为什么构造方法不是静态的"><span>为什么构造方法不是静态的？</span></a></li><li title="知识回顾" data-depth="2"><a href="/blog/java-script核心原理解析/04.从原型到类java-script是如何一步步走向应用编程语言的/03#知识回顾"><span>知识回顾</span></a></li><li title="思考题" data-depth="2"><a href="/blog/java-script核心原理解析/04.从原型到类java-script是如何一步步走向应用编程语言的/03#思考题"><span>思考题</span></a></li></ul><div class="__dumi-default-layout-content"><div class="markdown"><h1 id="14--superxxx虽然直到es10还是个半吊子实现却也值得一讲"><a aria-hidden="true" tabindex="-1" href="/blog/java-script核心原理解析/04.从原型到类java-script是如何一步步走向应用编程语言的/03#14--superxxx虽然直到es10还是个半吊子实现却也值得一讲"><span class="icon icon-link"></span></a>14 | super.xxx()：虽然直到ES10还是个半吊子实现，却也值得一讲</h1><p>你好，我是周爱民，接下来我们继续讲述JavaScript中的那些奇幻代码。</p><p>今天要说的内容，打根儿里起还是得从JavaScript的1.0谈起。在此前我已经讲过了，JavaScript 1.0连继承都没有，但是它实现了以“类抄写”为基础的、基本的面向对象模型。而在此之后，才在JavaScript 1.1开始提出，并在后来逐渐完善了原型继承。</p><p>这样一来，在JavaScript中，从概念上来讲，所谓对象就是一个从原型对象衍生过来的实例，因此这个子级的对象也就具有原型对象的全部特征。</p><p>然而，既然是子级的对象，必然与它原型的对象有所不同。这一点很好理解，如果没有不同，那就没有必要派生出一级关系，直接使用原型的那一个抽象层级就可以了。</p><p>所以，有了原型继承带来的子级对象（这样的抽象层级），在这个子级对象上，就还需要有让它们跟原型表现得有所不同的方法。这时，JavaScript 1.0里面的那个“类抄写”的特性就跳出来了，它正好可以通过“抄写”往对象（也就是构造出来的那个this）上面添加些东西，来制造这种不同。</p><p>也就是说，JavaScript 1.1的面向对象系统的设计原则就是：<strong>用原型来实现继承，并在类（也就是构造器）中处理子一级的抽象差异</strong>。所以，从JavaScript 1.1开始，JavaScript有了自己的面向对象系统的完整方案，这个示例代码大概如下：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// 这里用于处理“不同的东西”</span></div><div class="token-line"><span class="token plain">    function CarEx(color) {</span></div><div class="token-line"><span class="token plain">      this.color = color;</span></div><div class="token-line"><span class="token plain">      ...</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    // 这里用于从父类继承“相同的东西”</span></div><div class="token-line"><span class="token plain">    CarEx.prototype = new Car(&quot;Eagle&quot;, &quot;Talon TSi&quot;, 1993);</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    // 创建对象</span></div><div class="token-line"><span class="token plain">    myCar = new CarEx(&quot;red&quot;)</span></div></pre></div><p>这个方案基本上来说，就是两个解决思路的集合：使用构造器函数来处理一些“不同的东西”；使用原型继承，来从父类继承“相同的东西”。最后，new运算符在创建对象的过程中分别处理“原型继承”和构造器函数中的“类抄写”，补齐了最后的一块木板。</p><p>你看，一个对象系统既能处理继承关系中那些“相同的东西”，又能处理“不同的东西”，所以显而易见：<strong>这个系统能处理基于对象的“全部的东西”</strong>。正是因为这种概念上的完整性，所以从JavaScript 1.1开始，一直到ECMAScript 5都在对象系统的设计上没能再有什么突破。</p><h2 id="为什么要有super"><a aria-hidden="true" tabindex="-1" href="/blog/java-script核心原理解析/04.从原型到类java-script是如何一步步走向应用编程语言的/03#为什么要有super"><span class="icon icon-link"></span></a>为什么要有super？</h2><p>但是有一个东西很奇怪，这也是对象继承的典型需求，就是说：子级的对象除了要继承父级的“全部的东西”之外，它还要继承“全部的能力”。</p><p>为什么只继承“全部的东西”还不够呢？如果只有全部的东西，那子级相对于父级，不过是一个系统的静态变化而已。就好像一棵枯死了的树，往上面添加些人造的塑料的叶子、假的果子，看起来还是树，可能还很好看，但根底里就是没有生命力的。而这样的一棵树，只有继承了原有的树的生命力，才可能是一棵活着的树。</p><p>如果继承来的树是活着的，那么装不装那些人造的叶子、果子，其实就不要紧了。</p><p>然而，传统的JavaScript却做不到“继承全部的能力”。那个时候的JavaScript其实是能够在一定程度上继承来自原型的“部分能力”的，譬如说原型有一个方法，那么子级的实例就可以使用这个方法，这时候子级也就继承了原型的能力。</p><p>然而这还不够。譬如说，如果子级的对象重写了这个方法，那么会怎么样呢？</p><p>在ECMAScript 6之前，如果发生这样的事，那么对不起：<strong>原型中的这个方法相对于子级对象来说，就失效了。</strong></p><p>原则上来讲，在子级对象中就再也找不到这个原型的方法了。这个问题非常地致命：这意味着子级对象必须重新实现原型中的能力，才能安全地覆盖原型中的方法。如果是这样，子级对象就等于要重新实现一遍原型，那继承性就毫无意义了。</p><p>这个问题追根溯源，还是要怪到JavaScript 1.0~1.1的时候，设计面向对象模型时偷了的那一次懒。也就是直接将“类抄写”用于实现子级差异的这个原始设计，太过于简陋。“类抄写”只能处理那些显而易见的属性、属性名、属性性质，等等，却无法处理那些“方法/行为”背后的逻辑的继承。</p><p>由于这个缘故，JavaScript 1.1之后的各种大规模系统中，都有人不断地在跳坑和补坑，致力于解决这么一个简单的问题：<strong>在“类抄写”导致的子类覆盖中，父类的能力丢失了</strong>。</p><p>为了解决这种继承问题，ECMAScript 6就提出了一个标准解决方案，这就是今天我们讲述的这一行代码中“super”这个关键字的由来。ECMAScript 6约定，如果父类中的名字被覆盖了，那么你可以在子类中用super来找到它们。</p><h2 id="super指向什么"><a aria-hidden="true" tabindex="-1" href="/blog/java-script核心原理解析/04.从原型到类java-script是如何一步步走向应用编程语言的/03#super指向什么"><span class="icon icon-link"></span></a>super指向什么？</h2><p>既然我们知道super出现的目的，就是解决父类的能力丢失这一问题，那么我们也就很容易理解一个特殊的语言设计了：在JavaScript中，super只能在方法中使用。所谓方法，其实就是“类的，或者对象的能力”，super正是用来弥补覆盖父类同名方法所导致的缺陷，因此只能出现在方法之中，这也就是很显而易见的事情了。</p><p>当然，从语言内核的角度上来说，这里还存在着一个严重的设计限制，这个问题是：怎么找到父类？</p><p>在传统的JavaScript中，所谓方法，就是函数类型的属性，也就是说它与一般属性并没有什么不同（可以被不同的对象抄写来抄写去）。其实，方法与普通属性没有区别，也是“类抄写”机制得以实现的核心依赖条件之一。然而，这也就意味着所谓“传统的方法”没有特殊性，也就没有“归属于哪个类或哪个对象”这样的性质。因此，这样的方法根本上也就找不到它自己所谓的类，进而也就找不到它的父类。</p><p>所以，实现super这个关键字的核心，在于为每一个方法添加一个“它所属的类”这样的性质，这个性质被称为“主对象（HomeObject）”。</p><p>所有在ECMAScript 6之后，通过方法声明语法得到的“方法”，虽然仍然是函数类型，但是与传统的“函数类型的属性（即传统的对象方法）”存在着一个根本上的不同：这些新的方法增加了一个内部槽，用来存放这个主对象，也就是ECMAScript规范中名为[[HomeObject]]的那个内部槽。这个主对象就用来对在类声明，或者字面量风格的对象声明中，（使用方法声明语法）所声明的那些方法的主对象做个登记。这有三种情况：</p><ol><li>在类声明中，如果是类静态声明，也就是使用static声明的方法，那么主对象就是这个类，例如AClass。</li><li>就是一般声明，那么该方法的主对象就是该类所使用的原型，也就是AClass.prototype。</li><li>第三种情况，如果是对象声明，那么方法的主对象就是对象本身。</li></ol><p>但这里就存在一个问题了：super指向的是父类，但是对象字面量并不是基于类继承的，那么为什么字面量中声明的方法又能使用<code>super.xxx</code>呢？既然对象本身不是类，那么super“指向父类”，或者“<strong>用于解决覆盖父类能力</strong>”的含义岂不是就没了？</p><p>这其实又回到了JavaScript 1.1的那项基础设计中，也就是“用原型来实现继承”。</p><p>原型就是一个对象，也就是说本质上子类或父类都是对象；而所谓的类声明只是这种继承关系的一个载体，真正继承的还是那个原型对象本身。既然子类和父类都可能是，或者说必须是对象，那么对象上的方法访问“父一级的原型上的方法”就是必然存在的逻辑了。</p><p>出于这个缘故，在JavaScript中，只要是方法——并且这个方法可以在声明时明确它的“主对象（HomeObject）”，那么它就可以使用super。这样一来，对象方法也就可以引用到它父级原型中的方法了。这一点，其实也是“利用原型继承和类抄写”来实现面向对象系统时，在概念设计上的一个额外的负担。</p><p>但接下来所谓“怎么找到父类”的问题就变得简单了：当每一个方法都在其内部登记了它的主对象之后，ECMAScript约定，只需要在方法中取出这个主对象HomeObject，那么它的原型就一定是所谓的父类。这很明显，因为方法登记的是它声明时所在的代码块的HomeObject，也就是声明时它所在的类或对象，所以这个HomeObject的原型就一定是父类。也就是把“通过原型继承得到子类”的概念反过来用一下，就得到了父类的概念。</p><h2 id="superxxx"><a aria-hidden="true" tabindex="-1" href="/blog/java-script核心原理解析/04.从原型到类java-script是如何一步步走向应用编程语言的/03#superxxx"><span class="icon icon-link"></span></a>super.xxx()</h2><p>我们今天讲的内容到现在为止，只说明了两件事。第一件，是为什么要有super；第二件，就是super指向什么。</p><p>接下来我们要讲super.xxx。简单地说，这就是个属性存取。这从语法上一看就明白了，似乎是没有什么特殊的，对吧？未必如此！</p><p>回顾一下我们在第7讲中讲述到的内容：super.xxx在语法上只是属性存取，但super.xxx()却是方法调用；而且，super.xxx()是表达式计算中罕见的、在双表达式连用中传递引用的一个语法。</p><p>所以，关键不是在于super.xxx如何存取属性，而在于super.xxx存取到的属性在JavaScript内核中是一个“引用”。按照语法设计，这个引用包括了左侧的对象，并且在它连用“函数调用（）”语法的时候，将这个左侧的对象作为this引用传入给后者。</p><p>更确切地说，假如我们要问“在 <code>super.xxx()</code>调用时，函数<code>xxx()</code>中得到的this是什么”，那么按照传统的属性存取语法可以推论出来的答案是：这个this值应该是super！</p><p>但是很不幸，这不是真的。</p><h3 id="superxxx中的this值"><a aria-hidden="true" tabindex="-1" href="/blog/java-script核心原理解析/04.从原型到类java-script是如何一步步走向应用编程语言的/03#superxxx中的this值"><span class="icon icon-link"></span></a>super.xxx()中的this值</h3><p>在super.xxx()这个语法中，xxx()函数中得到的this值与super——没有“一点”关系！不过，还是有“半点”关系的。不过在具体讲这“半点”关系之前呢，我需要先讲讲它会得到一个怎样的this，以及如何能得到这个this。</p><p>super总是在一个方法（如下例中的obj.foo函数）中才能引用。这是我们今天这一讲前半段中所讨论的。这个方法自己被调用的时候，理论上来说应该是在一个foo()方法内使用的、类似<code>super.xxx()</code>这样的代码。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">obj = {</span></div><div class="token-line"><span class="token plain">      foo() {</span></div><div class="token-line"><span class="token plain">        super.xxx();</span></div><div class="token-line"><span class="token plain">      }</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    // 调用foo方法</span></div><div class="token-line"><span class="token plain">    obj.foo();</span></div></pre></div><p>这样，在调用这个foo()方法时，它总是会将obj传入作为this，所以foo()函数内的this就该是obj。而我们看看其中的super.xxx()，我们期望它调用父类的xxx()方法时，传入的当前实例（也就是obj）正好在是在foo()函数内的那个this（其实，也就是obj）。继承来的行为，应该是施加给现实中的当前对象的，施加给原型（也就是这里的super）是没什么用的。所以，在这几个操作符的连续运算中，只需要把当前函数中的那个this传给父类xxx()方法就行了。</p><p>然而怎么传呢？</p><p>我们说过，super.xxx在语言内核上是一个“‘规范类型中的’引用”，ECMAScript约定将这个语法标记成“Super引用（SuperReference）”，并且为这个引用专门添加了一个thisValue域。这个域，其实在函数的上下文中也有一个（相同名字的，也是相同的含义）。然后，ECMAScript约定了优先取Super引用中的thisValue值，然后再取函数上下文中的。</p><p>所谓函数上下文，之前略讲过一点，就是函数在调用的时候创建的那个用于调度执行的东西，而这个thisValue值就放在它的环境记录里面，也就可以理解成函数执行环境的一部分。</p><p>如此一来，在函数（也就是我们这里的方法）中取super的this值时，就得到了为super专门设置的这个this对象。而且，事实上这个thisValue是在执行引擎发现super这个标识符（GetIdentifierReference）的时候，就从当前环境中取出来并绑定给super引用的。</p><p>回顾上述过程，super.xxx()这个调用中有两个细节需要你多加注意：</p><ol><li>super关键字所代表的父类对象，是通过当前方法的[[HomeObject]]的原型链来查找的；</li><li>this引用是从当前环境所绑定的this中抄写过来，并绑定给super的。</li></ol><p>为什么要关注上面这两个特别特别小的细节呢？</p><p>我们知道，在构造方法中，this引用（也就是将要构造出来的对象实例）事实上是由祖先类创建的。关于这一点如果你印象不深了，请回顾一下上一讲（也就是第13讲 “new X”）的内容。那么，既然this是祖先类创建的，也就意味着在刚刚进入构造方法时，this引用其实是没有值的，必须采用我们这里讲到的“继承父类的行为”的技术，让父类以及祖先类先把this构造出来才行。</p><p>所以这里就存在了一个矛盾，这是一个“先有鸡，还是先有蛋”的问题：一方面构造方法中要调用父类构造方法，来得到this；另一方面调用父类方法的super.xxx()需要先从环境中找到并绑定一个this。</p><p>概念上这是无解的。</p><p>ECMAScript为此约定：只能在调用了父类构造方法之后，才能使用super.xxx的方式来引用父类的属性，或者调用父类的方法，也就是访问SuperReference之前必须先调用父类构造方法（这称为SuperCall，在代码上就是直接的<code>super()</code>调用这一语法）。这其中也隐含了一个限制：在调用父类构造方法时，也就是<code>super()</code>这样的代码中，super是不绑定this值的，也不在调用中传入this值的。因为这个阶段根本还没有this。</p><h3 id="super中的父类构造方法"><a aria-hidden="true" tabindex="-1" href="/blog/java-script核心原理解析/04.从原型到类java-script是如何一步步走向应用编程语言的/03#super中的父类构造方法"><span class="icon icon-link"></span></a>super()中的父类构造方法</h3><p>事实上不仅仅如此。因为如果你打算调用父类构造方法（注意之前讲的是父类方法，这里是父类构造方法，也就是构造器），那么很不幸，事实上你也找不到super。</p><p>以new MyClass()为例，类MyClass的constructor()方法声明时，它的主对象其实是MyClass.prototype，而不是MyClass。因为，后者是静态类方法的主对象，而显然constructor()方法只是一般方法，而不是静态类方法（例如没有static关键字）。所以，在MyClass的构造方法中访问super时，通过HomeObject找到的将是原型的<strong>父级对象</strong>。而这并不是父类构造器，例如：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">class MyClass extends Object {</span></div><div class="token-line"><span class="token plain">      constructor() { ... }  // &lt;- [[HomeObject]]指向MyClass.prototype</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>我们知道，super()的语义是“调用父类构造方法”，也就应当是<code>extends</code>所指定的Object()。而上面讲述的意思是说，在当前构造方法中，无法通过[[HomeObject]]来找到父类构造方法。</p><p>那么JavaScript又是怎么做的呢？其实很简单，在这种情况下JavaScript会从当前调用栈上找到当前函数——也就是new MyClass()中的当前构造器，并且返回该构造器的原型作为super。</p><p>也就是说，类的原型就是它的父类。这又是我们在上面讨论过的：把“通过原型继承得到子类”的概念反过来用一下，就得到了父类的概念。</p><h3 id="为什么构造方法不是静态的"><a aria-hidden="true" tabindex="-1" href="/blog/java-script核心原理解析/04.从原型到类java-script是如何一步步走向应用编程语言的/03#为什么构造方法不是静态的"><span class="icon icon-link"></span></a>为什么构造方法不是静态的？</h3><p>也许你会提一个问题：为什么不直接将constructor()声明为类静态方法呢？事实上我在分析清楚这个<code>super()</code>逻辑的时候，第一反应也是如此。类静态方法中的[[HomeObject]]就是MyClass自己啊，如果这样的话，就不必换个法子来找到super了。</p><p>是的，这个逻辑没错。但是我们记得，在构造方法consturctor()中，也是可以使用super.xxx()的，与调用父类一般方法（即MyClass.prototype上的原型方法）的方式是类似的。</p><p>因此，根本问题在于：一方面super()需要将父类构造器作为super，另一方面super.xxx需要引用父类的原型上的属性。</p><p>这两个需求是无法通过同一个[[HomeObject]]来实现的。这个问题只会出现在构造方法中，并且也只与super()冲突。所以super()中的super采用了别的方法（这里是指在调用栈上查找当前函数的方式）来查找当前类以及父类，而且它也是作为特殊的语法来处理的。</p><p>现在，JavaScript通过当前方法的[[HomeObject]]找到了super，也找到了它的属性super.xxx，这个称为Super引用（SuperReference）；并且在背地里，为这个SuperReference绑定了一个thisValue。于是，接下来它只需要做一件事就可以了，调用super.xxx()。</p><h2 id="知识回顾"><a aria-hidden="true" tabindex="-1" href="/blog/java-script核心原理解析/04.从原型到类java-script是如何一步步走向应用编程语言的/03#知识回顾"><span class="icon icon-link"></span></a>知识回顾</h2><p>下面我来为第13讲做个总结，这一讲有4个要点：</p><ol><li>只能在方法中使用super，因为只有方法有[[HomeObject]]。</li><li>super.xxx()是对super.xxx这个引用（SuperReference）作函数调用操作，调用中传入的this引用是在<strong>当前环境的上下文</strong>中查找的。</li><li>super实际上是在通过原型链查找父一级的对象，而与它是不是<strong>类继承</strong>无关。</li><li>如果在类的声明头部没有声明extends，那么在构造方法中也就不能调用父类构造方法。</li></ol><blockquote><p>注：第4个要点涉及到两个问题：其一是它显然（显式的）没有所谓<code>super</code>，其二是没有声明extends的类其实是采用传统方式创建的构造器。但后者不是在本讲中讨论的内容。</p></blockquote><h2 id="思考题"><a aria-hidden="true" tabindex="-1" href="/blog/java-script核心原理解析/04.从原型到类java-script是如何一步步走向应用编程语言的/03#思考题"><span class="icon icon-link"></span></a>思考题</h2><ol><li>请问<code>x = super.xxx.bind(...)</code>会发生什么？这个过程中的thisValue会如何处理？</li><li>super引用是动态查找的，但类声明是静态声明，请问二者会有什么矛盾？（简单地说，super引用的并不一定是你所预期的（静态声明的）值，请尝试写一个这种示例）</li><li>super.xxx如果是属性（而不是函数/方法），那么绑定this有什么用呢？</li></ol><p>希望你能将自己的答案分享出来，让我也有机会听听你的收获。</p></div><div class="__dumi-default-layout-footer-meta"><a target="_blank" rel="noopener noreferrer" href="https://github.com/GGwujun/blog/edit/master/docs/java-script核心原理解析/04.从原型到类JavaScript是如何一步步走向应用编程语言的/03.md">在 GitHub 上编辑此页<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a><span data-updated-text="最后更新时间：">5/2/2022 10:56:38</span></div></div></div></div>
	<script>
  window.g_useSSR = true;
  window.g_initialProps = {};
	</script>

    <script>
      (function () {
        if (!location.port) {
          (function (i, s, o, g, r, a, m) {
            i["GoogleAnalyticsObject"] = r;
            (i[r] =
              i[r] ||
              function () {
                (i[r].q = i[r].q || []).push(arguments);
              }),
              (i[r].l = 1 * new Date());
            (a = s.createElement(o)), (m = s.getElementsByTagName(o)[0]);
            a.async = 1;
            a.src = g;
            m.parentNode.insertBefore(a, m);
          })(
            window,
            document,
            "script",
            "//www.google-analytics.com/analytics.js",
            "ga"
          );
          ga("create", "UA-149864185-1", "auto");
          ga("send", "pageview");
        }
      })();
    </script>
    <script src="/blog/umi.js"></script>
  </body>
</html>
