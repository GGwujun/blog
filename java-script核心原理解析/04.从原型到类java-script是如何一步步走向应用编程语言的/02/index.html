<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no"
    />
    <link rel="shortcut icon" type="image/x-icon" href="/logo.png" />
    <link rel="stylesheet" href="/blog/umi.css" />
    <script>
      window.routerBase = "/blog";
    </script>
    <script>
      //! umi version: 3.5.17
    </script>
    <script>
      !(function () {
        var e = localStorage.getItem("dumi:prefers-color"),
          t = window.matchMedia("(prefers-color-scheme: dark)").matches,
          r = ["light", "dark", "auto"];
        document.documentElement.setAttribute(
          "data-prefers-color",
          e === r[2] ? (t ? r[1] : r[0]) : r.indexOf(e) > -1 ? e : r[0]
        );
      })();
    </script>
    <title>13 | new X：从构造器到类，为你揭密对象构造的全程</title>
  </head>
  <body>
    <div id="root"><div class="__dumi-default-layout" data-route="/java-script核心原理解析/04.从原型到类java-script是如何一步步走向应用编程语言的/02" data-show-sidemenu="true" data-show-slugs="true" data-site-mode="true" data-gapless="false"><div class="__dumi-default-navbar" data-mode="site"><button class="__dumi-default-navbar-toggle"></button><a class="__dumi-default-navbar-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog/">大师兄</a><nav><div class="__dumi-default-search"><input type="search" class="__dumi-default-search-input" value=""/><ul></ul></div><span>计算机基础<ul><li><a href="/blog/编译原理之美">编译原理之美</a></li><li><a href="/blog/编译原理实战">编译原理实战</a></li><li><a href="/blog/深入浅出计算机组成原理">深入浅出计算机组成原理</a></li><li><a href="/blog/详解http">详解http</a></li><li><a href="/blog/计算机网络通关29讲">计算机网络通关29讲</a></li><li><a href="/blog/网络排查案例课">网络排查案例课</a></li><li><a href="/blog/linux操作系统">linux操作系统</a></li><li><a href="/blog/linux性能优化实战">linux性能优化实战</a></li><li><a href="/blog/程序员数学基础">程序员数学基础</a></li><li><a href="/blog/趣谈网络协议">趣谈网络协议</a></li><li><a href="/blog/操作系统实战">操作系统实战</a></li><li><a href="/blog/软件工程之美">软件工程之美</a></li><li><a href="/blog/sql必知必会">sql必知必会</a></li><li><a href="/blog/操作系统实战45讲">操作系统实战45讲</a></li><li><a href="/blog/网络编程实战">网络编程实战</a></li></ul></span><span>算法<ul><li><a href="/blog/常用算法25讲">常用算法25讲</a></li><li><a href="/blog/数据结构与算法之美">数据结构与算法之美</a></li><li><a href="/blog/业务开发算法50讲">业务开发算法50讲</a></li><li><a href="/blog/动态规划面试宝典">动态规划面试宝典</a></li></ul></span><span>前端开发<ul><li><a href="/blog/浏览器工作原理与实践">浏览器工作原理与实践</a></li><li><a href="/blog/新时代产品经理进阶之路">新时代产品经理进阶之路</a></li><li><a href="/blog/全栈工程师修炼指南">全栈工程师修炼指南</a></li><li><a href="/blog/flutter核心技术与实战">flutter核心技术与实战</a></li><li><a aria-current="page" class="active" href="/blog/java-script核心原理解析">java-script核心原理解析</a></li><li><a href="/blog/说透低代码">说透低代码</a></li><li><a href="/blog/nodejs应用开发实战">nodejs应用开发实战</a></li><li><a href="/blog/反爬虫兵法演绎20讲">反爬虫兵法演绎20讲</a></li><li><a href="/blog/reactnative新架构实战课">reactnative新架构实战课</a></li><li><a href="/blog/正则表达式入门">正则表达式入门</a></li><li><a href="/blog/重学前端">重学前端</a></li><li><a href="/blog/serverless入门课">serverless入门课</a></li><li><a href="/blog/type-script入门实战笔记">type-script入门实战笔记</a></li><li><a href="/blog/图解googlev8">图解googlev8</a></li><li><a href="/blog/vue3源码分析">vue3源码分析</a></li><li><a href="/blog/玩转Vue3全家桶">玩转Vue3全家桶</a></li><li><a href="/blog/webassembly入门">webassembly入门</a></li><li><a href="/blog/手把手带你写一个Web框架">手把手带你写一个Web框架</a></li><li><a href="/blog/web漏洞挖掘实战">web漏洞挖掘实战</a></li><li><a href="/blog/跟月影学可视化">跟月影学可视化</a></li><li><a href="/blog/搞定音频技术">搞定音频技术</a></li><li><a href="/blog/攻克视频技术">攻克视频技术</a></li></ul></span><span>前端工程化<ul><li><a href="/blog/logger">logger</a></li><li><a href="/blog/webpack">webpack</a></li><li><a href="/blog/webpackChain">webpackChain</a></li></ul></span><span>前端性能优化<ul><li><a href="/blog/react性能调优">react性能调优</a></li></ul></span><span>软件测试<ul><li><a href="/blog/全链路压测实战30讲">全链路压测实战30讲</a></li><li><a href="/blog/性能测试实战30讲">性能测试实战30讲</a></li><li><a href="/blog/自动化测试高手课">自动化测试高手课</a></li><li><a href="/blog/软件测试52讲">软件测试52讲</a></li></ul></span><span>面试<ul><li><a href="/blog/面试现场">面试现场</a></li></ul></span><span>杂谈<ul><li><a href="/blog/超级访谈对话张雪峰">超级访谈对话张雪峰</a></li><li><a href="/blog/Git实战手册">Git实战手册</a></li><li><a href="/blog/NodeJS">NodeJS</a></li><li><a href="/blog/ReactJS">ReactJS</a></li><li><a href="/blog/UI设计">UI设计</a></li><li><a href="/blog/webpack4系列教程">webpack4系列教程</a></li><li><a href="/blog/前端知识体系">前端知识体系</a></li><li><a href="/blog/剑指offer刷题笔记">剑指offer刷题笔记</a></li><li><a href="/blog/思考与成长">思考与成长</a></li><li><a href="/blog/设计模式手册">设计模式手册</a></li></ul></span><div class="__dumi-default-navbar-tool"><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "></div></div></div></nav></div><div class="__dumi-default-menu" data-mode="site"><div class="__dumi-default-menu-inner"><div class="__dumi-default-menu-header"><a class="__dumi-default-menu-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog/"></a><h1>大师兄</h1><p></p></div><div class="__dumi-default-menu-mobile-area"><ul class="__dumi-default-menu-nav-list"><li>计算机基础<ul><li><a href="/blog/编译原理之美">编译原理之美</a></li><li><a href="/blog/编译原理实战">编译原理实战</a></li><li><a href="/blog/深入浅出计算机组成原理">深入浅出计算机组成原理</a></li><li><a href="/blog/详解http">详解http</a></li><li><a href="/blog/计算机网络通关29讲">计算机网络通关29讲</a></li><li><a href="/blog/网络排查案例课">网络排查案例课</a></li><li><a href="/blog/linux操作系统">linux操作系统</a></li><li><a href="/blog/linux性能优化实战">linux性能优化实战</a></li><li><a href="/blog/程序员数学基础">程序员数学基础</a></li><li><a href="/blog/趣谈网络协议">趣谈网络协议</a></li><li><a href="/blog/操作系统实战">操作系统实战</a></li><li><a href="/blog/软件工程之美">软件工程之美</a></li><li><a href="/blog/sql必知必会">sql必知必会</a></li><li><a href="/blog/操作系统实战45讲">操作系统实战45讲</a></li><li><a href="/blog/网络编程实战">网络编程实战</a></li></ul></li><li>算法<ul><li><a href="/blog/常用算法25讲">常用算法25讲</a></li><li><a href="/blog/数据结构与算法之美">数据结构与算法之美</a></li><li><a href="/blog/业务开发算法50讲">业务开发算法50讲</a></li><li><a href="/blog/动态规划面试宝典">动态规划面试宝典</a></li></ul></li><li>前端开发<ul><li><a href="/blog/浏览器工作原理与实践">浏览器工作原理与实践</a></li><li><a href="/blog/新时代产品经理进阶之路">新时代产品经理进阶之路</a></li><li><a href="/blog/全栈工程师修炼指南">全栈工程师修炼指南</a></li><li><a href="/blog/flutter核心技术与实战">flutter核心技术与实战</a></li><li><a aria-current="page" class="active" href="/blog/java-script核心原理解析">java-script核心原理解析</a></li><li><a href="/blog/说透低代码">说透低代码</a></li><li><a href="/blog/nodejs应用开发实战">nodejs应用开发实战</a></li><li><a href="/blog/反爬虫兵法演绎20讲">反爬虫兵法演绎20讲</a></li><li><a href="/blog/reactnative新架构实战课">reactnative新架构实战课</a></li><li><a href="/blog/正则表达式入门">正则表达式入门</a></li><li><a href="/blog/重学前端">重学前端</a></li><li><a href="/blog/serverless入门课">serverless入门课</a></li><li><a href="/blog/type-script入门实战笔记">type-script入门实战笔记</a></li><li><a href="/blog/图解googlev8">图解googlev8</a></li><li><a href="/blog/vue3源码分析">vue3源码分析</a></li><li><a href="/blog/玩转Vue3全家桶">玩转Vue3全家桶</a></li><li><a href="/blog/webassembly入门">webassembly入门</a></li><li><a href="/blog/手把手带你写一个Web框架">手把手带你写一个Web框架</a></li><li><a href="/blog/web漏洞挖掘实战">web漏洞挖掘实战</a></li><li><a href="/blog/跟月影学可视化">跟月影学可视化</a></li><li><a href="/blog/搞定音频技术">搞定音频技术</a></li><li><a href="/blog/攻克视频技术">攻克视频技术</a></li></ul></li><li>前端工程化<ul><li><a href="/blog/logger">logger</a></li><li><a href="/blog/webpack">webpack</a></li><li><a href="/blog/webpackChain">webpackChain</a></li></ul></li><li>前端性能优化<ul><li><a href="/blog/react性能调优">react性能调优</a></li></ul></li><li>软件测试<ul><li><a href="/blog/全链路压测实战30讲">全链路压测实战30讲</a></li><li><a href="/blog/性能测试实战30讲">性能测试实战30讲</a></li><li><a href="/blog/自动化测试高手课">自动化测试高手课</a></li><li><a href="/blog/软件测试52讲">软件测试52讲</a></li></ul></li><li>面试<ul><li><a href="/blog/面试现场">面试现场</a></li></ul></li><li>杂谈<ul><li><a href="/blog/超级访谈对话张雪峰">超级访谈对话张雪峰</a></li><li><a href="/blog/Git实战手册">Git实战手册</a></li><li><a href="/blog/NodeJS">NodeJS</a></li><li><a href="/blog/ReactJS">ReactJS</a></li><li><a href="/blog/UI设计">UI设计</a></li><li><a href="/blog/webpack4系列教程">webpack4系列教程</a></li><li><a href="/blog/前端知识体系">前端知识体系</a></li><li><a href="/blog/剑指offer刷题笔记">剑指offer刷题笔记</a></li><li><a href="/blog/思考与成长">思考与成长</a></li><li><a href="/blog/设计模式手册">设计模式手册</a></li></ul></li></ul><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "><button title="Dark theme" class="__dumi-default-dark-moon "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="3854" width="22" height="22"><path d="M991.816611 674.909091a69.166545 69.166545 0 0 0-51.665455-23.272727 70.795636 70.795636 0 0 0-27.438545 5.585454A415.674182 415.674182 0 0 1 754.993338 698.181818c-209.594182 0-393.472-184.785455-393.472-395.636363 0-52.363636 38.539636-119.621818 69.515637-173.614546 4.887273-8.610909 9.634909-16.756364 14.103272-24.901818A69.818182 69.818182 0 0 0 384.631156 0a70.842182 70.842182 0 0 0-27.438545 5.585455C161.678429 90.298182 14.362065 307.898182 14.362065 512c0 282.298182 238.824727 512 532.38691 512a522.286545 522.286545 0 0 0 453.957818-268.334545A69.818182 69.818182 0 0 0 991.816611 674.909091zM546.679156 954.181818c-248.785455 0-462.941091-192-462.941091-442.181818 0-186.647273 140.637091-372.829091 300.939637-442.181818-36.817455 65.629091-92.578909 151.970909-92.578909 232.727273 0 250.181818 214.109091 465.454545 462.917818 465.454545a488.331636 488.331636 0 0 0 185.181091-46.545455 453.003636 453.003636 0 0 1-393.565091 232.727273z m103.656728-669.323636l-14.266182 83.781818a34.909091 34.909091 0 0 0 50.362182 36.770909l74.775272-39.563636 74.752 39.563636a36.142545 36.142545 0 0 0 16.174546 3.956364 34.909091 34.909091 0 0 0 34.210909-40.727273l-14.289455-83.781818 60.509091-59.345455a35.025455 35.025455 0 0 0-19.223272-59.578182l-83.61891-12.101818-37.376-76.101818a34.56 34.56 0 0 0-62.254545 0l-37.376 76.101818-83.618909 12.101818a34.909091 34.909091 0 0 0-19.246546 59.578182z m70.423272-64.698182a34.280727 34.280727 0 0 0 26.135273-19.083636l14.312727-29.090909 14.336 29.090909a34.257455 34.257455 0 0 0 26.135273 19.083636l32.046546 4.887273-23.272728 22.574545a35.234909 35.234909 0 0 0-10.007272 30.952727l5.46909 32.116364-28.625454-15.127273a34.490182 34.490182 0 0 0-32.302546 0l-28.695272 15.127273 5.469091-32.116364a35.141818 35.141818 0 0 0-9.984-30.952727l-23.272728-22.574545z" p-id="3855"></path></svg></button><button title="Light theme" class="__dumi-default-dark-sun "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="4026" width="22" height="22"><path d="M915.2 476.16h-43.968c-24.704 0-44.736 16-44.736 35.84s20.032 35.904 44.736 35.904H915.2c24.768 0 44.8-16.064 44.8-35.904s-20.032-35.84-44.8-35.84zM512 265.6c-136.704 0-246.464 109.824-246.464 246.4 0 136.704 109.76 246.464 246.464 246.464S758.4 648.704 758.4 512c0-136.576-109.696-246.4-246.4-246.4z m0 425.6c-99.008 0-179.2-80.128-179.2-179.2 0-98.944 80.192-179.2 179.2-179.2S691.2 413.056 691.2 512c0 99.072-80.192 179.2-179.2 179.2zM197.44 512c0-19.84-19.136-35.84-43.904-35.84H108.8c-24.768 0-44.8 16-44.8 35.84s20.032 35.904 44.8 35.904h44.736c24.768 0 43.904-16.064 43.904-35.904zM512 198.464c19.776 0 35.84-20.032 35.84-44.8v-44.8C547.84 84.032 531.84 64 512 64s-35.904 20.032-35.904 44.8v44.8c0 24.768 16.128 44.864 35.904 44.864z m0 627.136c-19.776 0-35.904 20.032-35.904 44.8v44.736C476.096 940.032 492.16 960 512 960s35.84-20.032 35.84-44.8v-44.736c0-24.768-16.064-44.864-35.84-44.864z m329.92-592.832c17.472-17.536 20.288-43.072 6.4-57.024-14.016-14.016-39.488-11.2-57.024 6.336-4.736 4.864-26.496 26.496-31.36 31.36-17.472 17.472-20.288 43.008-6.336 57.024 13.952 14.016 39.488 11.2 57.024-6.336 4.8-4.864 26.496-26.56 31.296-31.36zM213.376 759.936c-4.864 4.8-26.56 26.624-31.36 31.36-17.472 17.472-20.288 42.944-6.4 56.96 14.016 13.952 39.552 11.2 57.024-6.336 4.8-4.736 26.56-26.496 31.36-31.36 17.472-17.472 20.288-43.008 6.336-56.96-14.016-13.952-39.552-11.072-56.96 6.336z m19.328-577.92c-17.536-17.536-43.008-20.352-57.024-6.336-14.08 14.016-11.136 39.488 6.336 57.024 4.864 4.864 26.496 26.56 31.36 31.424 17.536 17.408 43.008 20.288 56.96 6.336 14.016-14.016 11.264-39.488-6.336-57.024-4.736-4.864-26.496-26.56-31.296-31.424z m527.168 628.608c4.864 4.864 26.624 26.624 31.36 31.424 17.536 17.408 43.072 20.224 57.088 6.336 13.952-14.016 11.072-39.552-6.4-57.024-4.864-4.8-26.56-26.496-31.36-31.36-17.472-17.408-43.072-20.288-57.024-6.336-13.952 14.016-11.008 39.488 6.336 56.96z" p-id="4027"></path></svg></button><button title="Default to system" class="__dumi-default-dark-auto "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="11002" width="22" height="22"><path d="M127.658667 492.885333c0-51.882667 10.24-101.717333 30.378666-149.162666s47.786667-88.064 81.92-122.538667 75.093333-61.781333 122.538667-81.92 96.938667-30.378667 149.162667-30.378667 101.717333 10.24 149.162666 30.378667 88.405333 47.786667 122.88 81.92 61.781333 75.093333 81.92 122.538667 30.378667 96.938667 30.378667 149.162666-10.24 101.717333-30.378667 149.162667-47.786667 88.405333-81.92 122.88-75.093333 61.781333-122.88 81.92-97.28 30.378667-149.162666 30.378667-101.717333-10.24-149.162667-30.378667-88.064-47.786667-122.538667-81.92-61.781333-75.093333-81.92-122.88-30.378667-96.938667-30.378666-149.162667z m329.045333 0c0 130.048 13.994667 244.394667 41.984 343.381334h12.970667c46.762667 0 91.136-9.216 133.461333-27.306667s78.848-42.666667 109.568-73.386667 54.954667-67.242667 73.386667-109.568 27.306667-86.698667 27.306666-133.461333c0-46.421333-9.216-90.794667-27.306666-133.12s-42.666667-78.848-73.386667-109.568-67.242667-54.954667-109.568-73.386667-86.698667-27.306667-133.461333-27.306666h-11.605334c-28.672 123.562667-43.349333 237.909333-43.349333 343.722666z" p-id="11003"></path></svg></button></div></div></div><ul class="__dumi-default-menu-list"><li><a href="/blog/java-script核心原理解析">java-script核心原理解析</a></li><li><a href="/blog/java-script核心原理解析/01.开篇词">01.开篇词</a><ul><li><a href="/blog/java-script核心原理解析/01.开篇词/01"><span>开篇词 | 如何解决语言问题？</span></a></li></ul></li><li><a href="/blog/java-script核心原理解析/02.从零开始java-script语言是如何构建起来的">02.从零开始JavaScript语言是如何构建起来的</a><ul><li><a href="/blog/java-script核心原理解析/02.从零开始java-script语言是如何构建起来的/01"><span>01 | delete 0：JavaScript中到底有什么是可以销毁的</span></a></li><li><a href="/blog/java-script核心原理解析/02.从零开始java-script语言是如何构建起来的/02"><span>02 | var x = y = 100：声明语句与语法改变了JavaScript语言核心性质</span></a></li><li><a href="/blog/java-script核心原理解析/02.从零开始java-script语言是如何构建起来的/03"><span>03 | a.x = a = {n:2}：一道被无数人无数次地解释过的经典面试题</span></a></li><li><a href="/blog/java-script核心原理解析/02.从零开始java-script语言是如何构建起来的/04"><span>04 | export default function() {}：你无法导出一个匿名函数表达式</span></a></li><li><a href="/blog/java-script核心原理解析/02.从零开始java-script语言是如何构建起来的/05"><span>05 | for (let x of [1,2,3]) ...：for循环并不比使用函数递归节省开销</span></a></li><li><a href="/blog/java-script核心原理解析/02.从零开始java-script语言是如何构建起来的/06"><span>加餐 | 捡豆吃豆的学问（上）：这门课讲的是什么？</span></a></li><li><a href="/blog/java-script核心原理解析/02.从零开始java-script语言是如何构建起来的/07"><span>加餐 | 捡豆吃豆的学问（下）：这门课该怎么学？</span></a></li></ul></li><li><a href="/blog/java-script核心原理解析/03.从表达式到执行引擎java-script是如何运行的">03.从表达式到执行引擎JavaScript是如何运行的</a><ul><li><a href="/blog/java-script核心原理解析/03.从表达式到执行引擎java-script是如何运行的/01"><span>06 | x: break x;  搞懂如何在循环外使用break，方知语句执行真解</span></a></li><li><a href="/blog/java-script核心原理解析/03.从表达式到执行引擎java-script是如何运行的/02"><span>07 | ${1}：详解JavaScript中特殊的可执行结构</span></a></li><li><a href="/blog/java-script核心原理解析/03.从表达式到执行引擎java-script是如何运行的/03"><span>08 | x =&gt; x：函数式语言的核心抽象：函数与表达式的同一性</span></a></li><li><a href="/blog/java-script核心原理解析/03.从表达式到执行引擎java-script是如何运行的/04"><span>09 | (...x)：不是表达式、语句、函数，但它却能执行</span></a></li><li><a href="/blog/java-script核心原理解析/03.从表达式到执行引擎java-script是如何运行的/05"><span>10 | x = yield x：迭代过程的“函数式化”</span></a></li><li><a href="/blog/java-script核心原理解析/03.从表达式到执行引擎java-script是如何运行的/06"><span>11 | throw 1;：它在“最简单语法榜”上排名第三</span></a></li><li><a href="/blog/java-script核心原理解析/03.从表达式到执行引擎java-script是如何运行的/07"><span>加餐 | 让JavaScript运行起来</span></a></li></ul></li><li><a aria-current="page" class="active" href="/blog/java-script核心原理解析/04.从原型到类java-script是如何一步步走向应用编程语言的">04.从原型到类JavaScript是如何一步步走向应用编程语言的</a><ul><li><a href="/blog/java-script核心原理解析/04.从原型到类java-script是如何一步步走向应用编程语言的/01"><span>12 | 1 in 1..constructor：这行代码的结果，既可能是true，也可能是false</span></a></li><li><a aria-current="page" class="active" href="/blog/java-script核心原理解析/04.从原型到类java-script是如何一步步走向应用编程语言的/02"><span>13 | new X：从构造器到类，为你揭密对象构造的全程</span></a></li><li><a href="/blog/java-script核心原理解析/04.从原型到类java-script是如何一步步走向应用编程语言的/03"><span>14 | super.xxx()：虽然直到ES10还是个半吊子实现，却也值得一讲</span></a></li><li><a href="/blog/java-script核心原理解析/04.从原型到类java-script是如何一步步走向应用编程语言的/04"><span>15 | return Object.create(new.target.prototype)：做框架设计的基本功：写一个根类</span></a></li><li><a href="/blog/java-script核心原理解析/04.从原型到类java-script是如何一步步走向应用编程语言的/05"><span>16 | [a, b] = {a, b}：让你从一行代码看到对象的本质</span></a></li><li><a href="/blog/java-script核心原理解析/04.从原型到类java-script是如何一步步走向应用编程语言的/06"><span>17 | Object.setPrototypeOf(x, null)：连Brendan Eich都认错，但null值还活着</span></a></li></ul></li><li><a href="/blog/java-script核心原理解析/05.从粗通到精通的进阶之路唯一不变的是变化本身">05.从粗通到精通的进阶之路唯一不变的是变化本身</a><ul><li><a href="/blog/java-script核心原理解析/05.从粗通到精通的进阶之路唯一不变的是变化本身/01"><span>18 | a + b：动态类型是灾难之源还是最好的特性？（上）</span></a></li><li><a href="/blog/java-script核心原理解析/05.从粗通到精通的进阶之路唯一不变的是变化本身/02"><span>19 | a + b：动态类型是灾难之源还是最好的特性？（下）</span></a></li><li><a href="/blog/java-script核心原理解析/05.从粗通到精通的进阶之路唯一不变的是变化本身/03"><span>20 | (0, eval)(&quot;x = 100&quot;) ：一行让严格模式形同虚设的破坏性设计（上）</span></a></li><li><a href="/blog/java-script核心原理解析/05.从粗通到精通的进阶之路唯一不变的是变化本身/04"><span>21 | (0, eval)(&quot;x = 100&quot;) ：一行让严格模式形同虚设的破坏性设计（下）</span></a></li><li><a href="/blog/java-script核心原理解析/05.从粗通到精通的进阶之路唯一不变的是变化本身/05"><span>22 | new Function(&#x27;x = 100&#x27;)();：函数的类化是对动态与静态系统的再次统一</span></a></li></ul></li><li><a href="/blog/java-script核心原理解析/06.结束语">06.结束语</a><ul><li><a href="/blog/java-script核心原理解析/06.结束语/01"><span>结束语 | 愿你能做一个真正“懂”的程序员</span></a></li><li><a href="/blog/java-script核心原理解析/06.结束语/02"><span>结课测试 | 这些JavaScript知识，你真的掌握了吗？</span></a></li></ul></li><li><a href="/blog/java-script核心原理解析/summary">java-script核心原理解析</a></li></ul></div></div><ul role="slug-list" class="__dumi-default-layout-toc"><li title="基于对象的JavaScript" data-depth="2"><a href="/blog/java-script核心原理解析/04.从原型到类java-script是如何一步步走向应用编程语言的/02#基于对象的javascript"><span>基于对象的JavaScript</span></a></li><li title="类与构造器" data-depth="2"><a href="/blog/java-script核心原理解析/04.从原型到类java-script是如何一步步走向应用编程语言的/02#类与构造器"><span>类与构造器</span></a></li><li title="ECMAScript 6之后的类" data-depth="2"><a href="/blog/java-script核心原理解析/04.从原型到类java-script是如何一步步走向应用编程语言的/02#ecmascript-6之后的类"><span>ECMAScript 6之后的类</span></a></li><li title="创建this的顺序问题" data-depth="2"><a href="/blog/java-script核心原理解析/04.从原型到类java-script是如何一步步走向应用编程语言的/02#创建this的顺序问题"><span>创建this的顺序问题</span></a></li><li title="用户返回new的结果" data-depth="2"><a href="/blog/java-script核心原理解析/04.从原型到类java-script是如何一步步走向应用编程语言的/02#用户返回new的结果"><span>用户返回new的结果</span></a></li><li title="知识回顾" data-depth="2"><a href="/blog/java-script核心原理解析/04.从原型到类java-script是如何一步步走向应用编程语言的/02#知识回顾"><span>知识回顾</span></a></li><li title="思考题" data-depth="2"><a href="/blog/java-script核心原理解析/04.从原型到类java-script是如何一步步走向应用编程语言的/02#思考题"><span>思考题</span></a></li></ul><div class="__dumi-default-layout-content"><div class="markdown"><h1 id="13--new-x从构造器到类为你揭密对象构造的全程"><a aria-hidden="true" tabindex="-1" href="/blog/java-script核心原理解析/04.从原型到类java-script是如何一步步走向应用编程语言的/02#13--new-x从构造器到类为你揭密对象构造的全程"><span class="icon icon-link"></span></a>13 | new X：从构造器到类，为你揭密对象构造的全程</h1><p>你好，我是周爱民。</p><p>今天我只跟你聊一件事，就是JavaScript构造器。标题中的这行代码中规中矩，是我这个专栏题目列表中难得的正经代码。</p><blockquote><p>NOTE：需要稍加说明的是：这行代码在JavaScript 1.x的某些版本或具体实现中是不能使用的。即使ECMAScript ed1开始就将它作为标准语法之一，当时也还是有许多语言并不支持它。</p></blockquote><p><strong>构造器</strong>这个东西，是JavaScript中面向对象系统的核心概念之一。跟“属性”相比，如果属性是静态的结构，那么“构造器”就是动态的逻辑。</p><p>没有构造器的JavaScript，就是一个充填了无数数据的、静态的对象空间。这些对象之间既没有关联，也不能衍生，更不可能发生交互。然而，这却真的就是JavaScript 1.0那个时代的所谓“面向对象系统”的基本面貌。</p><h2 id="基于对象的javascript"><a aria-hidden="true" tabindex="-1" href="/blog/java-script核心原理解析/04.从原型到类java-script是如何一步步走向应用编程语言的/02#基于对象的javascript"><span class="icon icon-link"></span></a>基于对象的JavaScript</h2><p>为什么呢？因为JavaScript1.0的时代，也就是最早最早的JavaScript其实是没有继承的。</p><p>你可能会说，既然是没有继承的，那么JavaScript为什么一开始就能声称自己是“面向对象”的、“类似Java”的一门语言呢？其实这个讲法是前半句对，后半句不对。JavaScript和Java名字相似，但语言特性却大是不同，这就跟北京的“海淀五路居”和“五路居”一样，差了得有20公里。</p><p>那前半句为什么是对的呢？JavaScript 1.0连继承都没有，为什么又能称为面向对象的语言呢？</p><p>其实从我在前两讲中讲过的内容来看，JavaScript 1.0确实已经可以将函数作为构造器，并且在函数中向它的实例（也就是<code>this</code>对象）抄写类声明的那些属性。在早期的面向对象理论里面，就已经可以称这个函数为<strong>类</strong>，而这个被创建出来的实例为<strong>对象</strong>了。</p><p>所以，有了类、对象，以及一个约定的构造过程，有了这三个东西，JavaScript就声称了自己是一门“面向对象”的语言，并且还是一门“有类语言”。</p><p>所以JavaScript从1.0开始就有类，在这个类（也就是构造器）中采用的是所谓“类抄写”的方案，将类所拥有的属性声明一项一项地抄写到对象上面，而这个对象，就是我们现在大家都知道的this引用。</p><p>这样一来，一段声明类和构造对象的代码，大概写出来就是下面这个样子，在一个函数里面不停地向this对象写属性，最后再用new运算符来创建一下它的实例就好了。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">function Car() {</span></div><div class="token-line"><span class="token plain">      this.name = &quot;Car&quot;;</span></div><div class="token-line"><span class="token plain">      this.color = &quot;Red&quot;;</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    var x = new Car();</span></div><div class="token-line"><span class="token plain">    ...</span></div></pre></div><h2 id="类与构造器"><a aria-hidden="true" tabindex="-1" href="/blog/java-script核心原理解析/04.从原型到类java-script是如何一步步走向应用编程语言的/02#类与构造器"><span class="icon icon-link"></span></a>类与构造器</h2><p>由于在这样的构造过程中，<code>this</code>是作为<code>new</code>运算所构造出来的那个实例来使用的，因此JavaScript 1.0约定全局环境中不能使用<code>this</code>的。因为全局环境与<code>new</code>运算无关，全局环境中也并不存在一个被<code>new</code>创建出来的实例。</p><p>然而随着<code>JavaScript 1.1</code>的到来，JavaScript支持“原型继承”了，于是“类抄写”成为了一个过时的方案。对于继承性来说，它显得无用；对于一个具体的实例来说，它又具有“类‘说明了’实例的结构”这样的语义。</p><p>因此，从“<strong>原型继承</strong>”在JavaScript中出现的第一天开始，“类继承VS原型继承”之间就存在不可调和的矛盾。在<code>JavaScript 1.1</code>中，类抄写是可以与原型继承混合使用的。</p><p>例如，你可以用类抄写的方式写一个Device()类，然后再写一个Car()类，最后你可以将Car()类的原型指向Device。这一切都是合理的、正常的写法。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">function Device() {</span></div><div class="token-line"><span class="token plain">      this.id = 0; // or increment</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    function Car() {</span></div><div class="token-line"><span class="token plain">      this.name = &quot;Car&quot;;</span></div><div class="token-line"><span class="token plain">      this.color = &quot;Red&quot;;</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    Car.prototype = new Device();</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    var x = new Car();</span></div><div class="token-line"><span class="token plain">    console.log(x.id); //</span></div></pre></div><p>于是现在，你可以用new运算来创建子类Car()的实例了，例如按照以前的习惯，我们称这个实例为x，这也仍然没有问题。</p><p>但是在面向对象编程（OOP）中，<code>x</code>既是<code>Car()</code>的子类实例，也是“Device()”的子类实例，这是OOP的继承性所约定的基本概念。这正是这门语言很有趣的地方：**一方面使用了类继承的基础结构和概念，另一方面又要实现原型继承和基于原型链检查的逻辑。**例如，你用<code>x instanceof Device</code>这样的代码来检查一下，看看“<code>x</code>是不是<code>Device()</code>的子类实例”。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain"># `x`是`Device()`的子类实例吗？</span></div><div class="token-line"><span class="token plain">    &gt; x instanceof Device</span></div><div class="token-line"><span class="token plain">    true</span></div></pre></div><p>于是，这里的<code>instanceof</code>运算被实现为一个<strong>动态地访问原型链</strong>的过程：它将从<code>Car.prototype</code>属性逆向地在原型链中查到你指定的——“原型”。</p><p>首先，JavaScript从对象<code>x</code>的内部结构中取得它的原型。这个原型的存在，与<code>new</code>运算是直接相关的——在早期的JavaScript中，有且仅有<code>new</code>运算会向对象内部写“原型”这个属性（称为&quot;[[Prototype]]&quot;内部槽）。由于new运算是依据它运算时所使用的构造器来填写这个属性的，所以这意味着它在实际实现时，将Car.prototype这个值，直接给填到x对象的内部属性去了。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// x = new Car()</span></div><div class="token-line"><span class="token plain">    x.[[Prototype]] === Car.prototype</span></div></pre></div><p>在<code>instanceof</code>运算中，<code>x instanceof AClass</code>表达式的右侧是一个类名（对于之前的例子来说，它指向构造器Car），但实际上JavaScript是使用<code>AClass.prototype</code>来做比对的，对于“Car()构造器”来说，就是“Car.prototype”。但是，如果上一个例子需要检查的是<code>x instanceof Device</code>，也就是“Device.prototype”，那么这二者显然是不等值的。</p><p>所以，<code>instanceof</code>运算会再次取“x.[[Prototype] [[Prototype]]”这个内部原型，也就是顺着原型链向上查找，并且你将找到一个等值于“x的内部原型”的东西。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// 因为</span></div><div class="token-line"><span class="token plain">    x.[[Prototype]] === Car.prototype</span></div><div class="token-line"><span class="token plain">    // 且</span></div><div class="token-line"><span class="token plain">    Car.prototype = new Device()</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    // 所以</span></div><div class="token-line"><span class="token plain">    x.[[Prototype]].[[Prototype]] === Device.prototype</span></div></pre></div><p>现在，由于在<code>x</code>的原型链上发现了“x instanceof Device”运算右侧的“Device.prototype”，所以这个表达式将返回True值，表明：</p><p>对象<code>x</code>是<code>Device()</code>或其子类的一个实例。</p><p>现在，对于大多数JavaScript程序员来说，上述过程应该都不是秘密，也并不是特别难解的核心技术。但是在它的实现过程中所带有的语言设计方面的这些历史痕迹，却不是那么容易一望即知的了。</p><h2 id="ecmascript-6之后的类"><a aria-hidden="true" tabindex="-1" href="/blog/java-script核心原理解析/04.从原型到类java-script是如何一步步走向应用编程语言的/02#ecmascript-6之后的类"><span class="icon icon-link"></span></a>ECMAScript 6之后的类</h2><p>在ECMAScript 6之前，JavaScript中的<strong>函数</strong>、<strong>类</strong>和<strong>构造器</strong>这三个概念是混用的。一般来说，它们都被统一为“<strong>函数Car()</strong>”这个基础概念，而当它用作“x = new Car()”这样的运算，或从<code>x.constructor</code>这样的属性中读取时，它被理解为<strong>构造器</strong>；当它用作“x instanceof Car”这样的运算，或者讨论OOP的继承关系时，它被理解为<strong>类</strong>。</p><p>习惯上，如果程序要显式地、字面风格地说明一个函数是构造器、或者用作构造过程，那么它的函数名应该首字母大写。同时，如果一个函数要被明确声明为“静态类（也就不需要创建实例的类，例如Math）”，那么它的函数名也应该首字母大写。</p><blockquote><p>NOTE: 仅从函数名的大小写来判断，只是惯例。没有任何方法来确认一个函数是不是“被设计为”构造器，或者静态类，又或者“事实上”是不是二者之一。</p></blockquote><p>从ECMAScript 6开始，JavaScript有了使用<code>class</code>来声明“类”的语法。例如：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">class AClass {</span></div><div class="token-line"><span class="token plain">      ...</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>自此之后，JavaScript的“类”与“函数”有了明确的区别：**类只能用new运算来创建，而不能使用“()”来做函数调用。**例如：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">&gt; new AClass()</span></div><div class="token-line"><span class="token plain">    AClass {}</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    &gt; AClass()</span></div><div class="token-line"><span class="token plain">    TypeError: Class constructor AClass cannot be invoked without &#x27;new&#x27;</span></div></pre></div><p>如果你尝试将“ES6的类”作为函数调用，那么JavaScript就会抛出一个异常。</p><p>在ECMAScript 6之后，JavaScript内部是明确区分方法与函数的：不能对方法做new运算。如果你尝试这样做，JavaScript也会抛一个异常出来，提示你“这个函数不是一个构造器（is not a constructor）”。例如：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain"># 声明一个带有方法的对象字面量</span></div><div class="token-line"><span class="token plain">    &gt; obj = { foo() {} }</span></div><div class="token-line"><span class="token plain">    { foo: [Function: foo] }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    # 对方法使用new运算会导致异常</span></div><div class="token-line"><span class="token plain">    &gt; new obj.foo()</span></div><div class="token-line"><span class="token plain">    TypeError: obj.foo is not a constructor</span></div></pre></div><p>注意这个异常中又出现了关键字“constructor”。这让我们的讨论又一次回到了开始的话题：<strong>什么是构造器？</strong></p><p>在ECMAScript 6之后，函数可以简单地分为三个大类：</p><ol><li>类：只可以做new运算；</li><li>方法：只可以做调用“( )”运算；</li><li>一般函数：（除部分函数有特殊限制外，）同时可以做new和调用运算。</li></ol><p>其中，典型的“方法”在内部声明时，有三个主要特征：</p><ol><li>具有一个名为“主对象<code>[[HomeObject]]</code>”的内部槽；</li><li>没有名为“构造器<code>[[Construct]]</code>”的内部槽；</li><li>没有名为“<code>prototype</code>”的属性。</li></ol><p>后两种特征（没有<code>[[Construct]]</code>内部槽和<code>prototype</code>属性）完全排除了一个普通方法用作构造器的可能。对照来看，所谓“类”其实也是作为方法来创建的，但它有独立的构造过程和原型属性。</p><p>函数的“.prototype”的属性描述符中的设置比较特殊，它不能删除，但可以修改（‘writable’ is true）。当这个值被修改成null值时，它的子类对象是以null值为原型的；当它被修改成非对象值时，它的子类对象是以Object.prototype为原型的；否则，当它是一个对象类型的值时，它的子类才会使用该对象作为原型来创建实例。</p><p>运算符“new”总是依照这一规则来创建对象实例<code>this</code>。</p><p>不过，对于“类”和一般的“构造器（函数）”，这个创建过程会略有不同。</p><h2 id="创建this的顺序问题"><a aria-hidden="true" tabindex="-1" href="/blog/java-script核心原理解析/04.从原型到类java-script是如何一步步走向应用编程语言的/02#创建this的顺序问题"><span class="icon icon-link"></span></a>创建<code>this</code>的顺序问题</h2><p>如前所述，如果对ECMAScript 6之前的构造器函数（例如<code>f</code>）使用<code>new</code>运算，那么这个new运算会使用<code>f.prototype</code>作为原型来创建一个<code>this</code>对象，然后才是调用<code>f()</code>函数，并将这个函数的执行过程理解为“类抄写（向用户实例抄写类所声明的属性）”。从用户代码的视角上来看，这个新对象就是由当前<code>new</code>运算所操作的那个函数<code>f()</code>创建的。</p><p>这在语义上非常简洁明了：由于<code>f()</code>是this的类，因此<code>f.prototype</code>决定了this的原型，而<code>f()</code>执行过程决定了初始化this实例的方式。但是它带来了一个问题，一个从JavaScript 1.1开始至今都困扰JavaScript程序员的问题：</p><p>无法创建一个有特殊性质的对象，也无法声明一个具有这类特殊性质的类。</p><p>这是什么意思呢？比如说，所有的函数有一个公共的父类/祖先类，称为<code>Function()</code>。所以你可以用<code>new Function()</code>来创建一个普通函数，这个普通函数也是可以调用的，在JavaScript中这是很正常的用法，例如：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">&gt; f = new Function;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    &gt; f instanceof Function</span></div><div class="token-line"><span class="token plain">    true</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    &gt; f()</span></div><div class="token-line"><span class="token plain">    undefine</span></div></pre></div><p>接下来，你也确实可以用传统方法写一个<code>Function()</code>的子类，但这样的子类创建的实例就不能调用。例如：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">&gt; MyFunction = function() {};</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    &gt; MyFunction.prototype = new Function;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    &gt; f = new MyFunction;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    &gt; [f instanceof MyFunction, f instanceof Functcion]</span></div><div class="token-line"><span class="token plain">    [ true, true ]</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    &gt; f()</span></div><div class="token-line"><span class="token plain">    TypeError: f is not a funct</span></div></pre></div><p>至于原因，你可能也已经知道了：JavaScript所谓的函数，其实是“一个有<code>[[Call]]</code>内部槽的对象”。而<code>Function()</code>作为JavaScript原生的函数构造器，它能够在创建的对象（例如<code>this</code>）中添加这个内部槽，而当使用上面的继承逻辑时，用户代码（例如<code>MyFunction()</code>）就只是创建了一个普通的对象，因为用户代码没有能力操作JavaScript引擎层面才支持的那些“内部槽”。</p><p>所以，有一些“类/构造器”在ECMAScript 6之前是不能派生子类的，例如Function，又例如Date。</p><p>而到了ECMAScript 6，它的“类声明”采用了不同的构造逻辑。ECMAScript 6要求所有子类的构造过程都不得创建这个<code>this</code>实例，并主动的把这个创建的权力“交还”给父类、乃至祖先类。这也就是ECMAScript 6中类的两个著名特性的由来，即，如果类声明中通过extends指定了父类，那么：</p><ol><li>必须在构造器方法（constructor）中显式地使用<code>super()</code>来调用父类的构造过程；</li><li>在上述调用结束之前，是不能使用<code>this</code>引用的。</li></ol><p>显然，真实的<code>this</code>创建就通过层层的<code>super()</code>交给了父类或祖先类中支持创建这个实例的构造过程。这样一来，子类中也能得到一个“拥有父类所创建的带有内部槽的”实例，因此上述的<code>Function()</code>和<code>Date()</code>等等的子类也就可以实现了。例如，你可以在class MyFunction的声明中直接用extends指示父类为Function。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">&gt; class MyFunction extends Function { }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    &gt; f = new MyFunction;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    &gt; f()</span></div><div class="token-line"><span class="token plain">    undefine</span></div></pre></div><p>这样一来，即使<code>MyFunction()</code>的类声明中缺省了“constructor()”构造方法，这种情况下JavaScript会在这种情况下为它自动创建一个，并且其内部也仅有一个“super()”代码。关于这些过程的细节，我将留待下一讲再具体地与你解析。在这里，你最应该关注的是这个过程带来的必然结果：</p><p>ECMAScript 6的类是由父类或祖先类创建<code>this</code>实例的。</p><p>不过仍然有一点是需要补充的：如果类声明<code>class</code>中不带有<code>extends</code>子句，那么它所创建出来的类与传统JavaScript的函数/构造器是一样的，也就是由自己来创建<code>this</code>对象。很显然，这是因为它无法找到一个显式指示的父类。不过关于这种情况，仍然隐藏了许多实现细节，我将会在下一讲中与你一起来学习它。</p><h2 id="用户返回new的结果"><a aria-hidden="true" tabindex="-1" href="/blog/java-script核心原理解析/04.从原型到类java-script是如何一步步走向应用编程语言的/02#用户返回new的结果"><span class="icon icon-link"></span></a>用户返回new的结果</h2><p>在JavaScript中关于new运算与构造函数的最后一个有趣的设计，就是<strong>用户代码可以干涉new运算的结果</strong>。默认情况下，这个结果就是上述过程所创建出来的<code>this</code>对象实例，但是用户可以通过在构造器函数/方法中使用<code>return</code>语句来显式地重置它。</p><p>这也是从JavaScript 1.0就开始具有的特性。因为JavaScript 1.x中的函数、类与构造器是混用的，所以用户代码在函数中“返回些什么东西”是正常的语法，也是正常的逻辑需求。但是JavaScript要求在构造器中返回的数据必须是一个对象，否则就将抛出一个运行期的异常。</p><p>这个处理的约定，从ECMAScript ed3开始有了些变化。从ECMAScript ed3开始，检测构造器返回值的逻辑从<code>new</code>运算符中移到了<code>[[Construct]]</code>的处理过程中，并且重新约定：当构造器返回无效值（非对象值或null）时，使用原有已经创建的<code>this</code>对象作为构造过程<code>[[Constuct]]</code>的返回值。</p><p>因此到了ECMAScript 6之后，那些一般函数，以及非派生类，就延续了这一约定：<strong>使用已经创建的<code>this</code>对象来替代返回的无效值</strong>。这意味着它们总是能返回一个对象，要么是new运算按规则创建的this，要么是用户代码返回的对象。</p><blockquote><p>NOTE: 关于为什么非派生类也支持这一约定的问题，我后续的课程中会再次讲到。基本上来说，你可以认为这是为了让它与一般构造器保持足够的“相似性”。</p></blockquote><p>然而严格来说，引擎是不能理解“为什么用户代码会在构造器中返回一个一般的值类型数据”的。因为对于类的预期是返回一个对象，返回这种“无效值”是与预期矛盾的。因此，对于那些派生的子类（即声明中使用了<code>extends</code>子句的类），ECMAScript要求严格遵循“不得在构造器中返回非对象值（以及null值）”的设计约定，并在这种情况下直接抛出异常。例如：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">## (注：ES3之前将抛出异常）</span></div><div class="token-line"><span class="token plain">    &gt; new (function() {return 1});</span></div><div class="token-line"><span class="token plain">    {}</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    ## 非派生类的构造方法返回无效值</span></div><div class="token-line"><span class="token plain">    &gt; new (class { constructor() { return 1 } })</span></div><div class="token-line"><span class="token plain">    {}</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    ## 派生类的构造方法返回无效值</span></div><div class="token-line"><span class="token plain">    &gt; new (class extends Object { constructor() { return 1 } })</span></div><div class="token-line"><span class="token plain">    TypeError: Derived constructors may only return object or undefine</span></div></pre></div><h2 id="知识回顾"><a aria-hidden="true" tabindex="-1" href="/blog/java-script核心原理解析/04.从原型到类java-script是如何一步步走向应用编程语言的/02#知识回顾"><span class="icon icon-link"></span></a>知识回顾</h2><p>今天这一讲的一些知识点，是与你学习后续的专栏内容有关的。包括：</p><ol><li>在使用类声明来创建对象时，对象是由父类或祖先类创建的实例，并使用<code>this</code>引用传递到当前（子级的）类的。</li><li>在类的构造方法和一般构造器（函数）中返回值，是可以影响new运算的结果的，但JavaScript确保new运算不会得到一个非对象值。</li><li>类或构造器（函数）的首字母大写是一种惯例，而不是语言规范层面的约束。</li><li>类继承过程也依赖内部构造过程（<code>[[Contruct]]</code>）和原型属性（prototype），并且类继承实际上是原型继承的应用与扩展，不同于早期JavaScript1.0使用的类抄写。</li></ol><p>无论如何，从JavaScript 1.0开始的“类抄写”这一特性依然是可用的。无论是在普通函数、类还是构造器中，都可以向<code>this</code>引用上抄写属性，但这个过程变得与“如何实现继承性”完全无关。这里的<code>this</code>可以是函数调用时传入的，而不再仅仅来自于new运算的内置的构造过程创建。</p><h2 id="思考题"><a aria-hidden="true" tabindex="-1" href="/blog/java-script核心原理解析/04.从原型到类java-script是如何一步步走向应用编程语言的/02#思考题"><span class="icon icon-link"></span></a>思考题</h2><ol><li>除了使用new X运算，还有什么方法可以创建新的对象？</li><li>在ECMAScript 6之后，除了new X之外，还有哪些方法可以操作原型/原型链？</li></ol><p>这些问题既是对本小节内容的回顾，也是下一阶段的课程中会用到的一些基础知识。建议你好好地寻求一下答案。</p><p>最后，希望你喜欢我的分享，也欢迎你把文章分享给你的朋友。</p></div><div class="__dumi-default-layout-footer-meta"><a target="_blank" rel="noopener noreferrer" href="https://github.com/GGwujun/blog/edit/master/docs/java-script核心原理解析/04.从原型到类JavaScript是如何一步步走向应用编程语言的/02.md">在 GitHub 上编辑此页<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a><span data-updated-text="最后更新时间：">5/2/2022 10:56:38</span></div></div></div></div>
	<script>
  window.g_useSSR = true;
  window.g_initialProps = {};
	</script>

    <script>
      (function () {
        if (!location.port) {
          (function (i, s, o, g, r, a, m) {
            i["GoogleAnalyticsObject"] = r;
            (i[r] =
              i[r] ||
              function () {
                (i[r].q = i[r].q || []).push(arguments);
              }),
              (i[r].l = 1 * new Date());
            (a = s.createElement(o)), (m = s.getElementsByTagName(o)[0]);
            a.async = 1;
            a.src = g;
            m.parentNode.insertBefore(a, m);
          })(
            window,
            document,
            "script",
            "//www.google-analytics.com/analytics.js",
            "ga"
          );
          ga("create", "UA-149864185-1", "auto");
          ga("send", "pageview");
        }
      })();
    </script>
    <script src="/blog/umi.js"></script>
  </body>
</html>
