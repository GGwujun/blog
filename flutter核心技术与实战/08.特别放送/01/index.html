<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no"
    />
    <link rel="shortcut icon" type="image/x-icon" href="/logo.png" />
    <link rel="stylesheet" href="/blog/umi.css" />
    <script>
      window.routerBase = "/blog";
    </script>
    <script>
      //! umi version: 3.5.17
    </script>
    <script>
      !(function () {
        var e = localStorage.getItem("dumi:prefers-color"),
          t = window.matchMedia("(prefers-color-scheme: dark)").matches,
          r = ["light", "dark", "auto"];
        document.documentElement.setAttribute(
          "data-prefers-color",
          e === r[2] ? (t ? r[1] : r[0]) : r.indexOf(e) > -1 ? e : r[0]
        );
      })();
    </script>
    <title>特别放送 ｜ 温故而知新，与你说说专栏的那些思考题</title>
  </head>
  <body>
    <div id="root"><div class="__dumi-default-layout" data-route="/flutter核心技术与实战/08.特别放送/01" data-show-sidemenu="true" data-show-slugs="true" data-site-mode="true" data-gapless="false"><div class="__dumi-default-navbar" data-mode="site"><button class="__dumi-default-navbar-toggle"></button><a class="__dumi-default-navbar-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog/">大师兄</a><nav><div class="__dumi-default-search"><input type="search" class="__dumi-default-search-input" value=""/><ul></ul></div><span>计算机基础<ul><li><a href="/blog/编译原理之美">编译原理之美</a></li><li><a href="/blog/编译原理实战">编译原理实战</a></li><li><a href="/blog/深入浅出计算机组成原理">深入浅出计算机组成原理</a></li><li><a href="/blog/详解http">详解http</a></li><li><a href="/blog/计算机网络通关29讲">计算机网络通关29讲</a></li><li><a href="/blog/网络排查案例课">网络排查案例课</a></li><li><a href="/blog/linux操作系统">linux操作系统</a></li><li><a href="/blog/linux性能优化实战">linux性能优化实战</a></li><li><a href="/blog/程序员数学基础">程序员数学基础</a></li><li><a href="/blog/趣谈网络协议">趣谈网络协议</a></li><li><a href="/blog/操作系统实战">操作系统实战</a></li><li><a href="/blog/软件工程之美">软件工程之美</a></li><li><a href="/blog/sql必知必会">sql必知必会</a></li><li><a href="/blog/操作系统实战45讲">操作系统实战45讲</a></li><li><a href="/blog/网络编程实战">网络编程实战</a></li></ul></span><span>算法<ul><li><a href="/blog/常用算法25讲">常用算法25讲</a></li><li><a href="/blog/数据结构与算法之美">数据结构与算法之美</a></li><li><a href="/blog/业务开发算法50讲">业务开发算法50讲</a></li><li><a href="/blog/动态规划面试宝典">动态规划面试宝典</a></li></ul></span><span>前端开发<ul><li><a href="/blog/浏览器工作原理与实践">浏览器工作原理与实践</a></li><li><a href="/blog/新时代产品经理进阶之路">新时代产品经理进阶之路</a></li><li><a href="/blog/全栈工程师修炼指南">全栈工程师修炼指南</a></li><li><a aria-current="page" class="active" href="/blog/flutter核心技术与实战">flutter核心技术与实战</a></li><li><a href="/blog/java-script核心原理解析">java-script核心原理解析</a></li><li><a href="/blog/说透低代码">说透低代码</a></li><li><a href="/blog/nodejs应用开发实战">nodejs应用开发实战</a></li><li><a href="/blog/反爬虫兵法演绎20讲">反爬虫兵法演绎20讲</a></li><li><a href="/blog/reactnative新架构实战课">reactnative新架构实战课</a></li><li><a href="/blog/正则表达式入门">正则表达式入门</a></li><li><a href="/blog/重学前端">重学前端</a></li><li><a href="/blog/serverless入门课">serverless入门课</a></li><li><a href="/blog/type-script入门实战笔记">type-script入门实战笔记</a></li><li><a href="/blog/图解googlev8">图解googlev8</a></li><li><a href="/blog/vue3源码分析">vue3源码分析</a></li><li><a href="/blog/玩转Vue3全家桶">玩转Vue3全家桶</a></li><li><a href="/blog/webassembly入门">webassembly入门</a></li><li><a href="/blog/手把手带你写一个Web框架">手把手带你写一个Web框架</a></li><li><a href="/blog/web漏洞挖掘实战">web漏洞挖掘实战</a></li><li><a href="/blog/跟月影学可视化">跟月影学可视化</a></li><li><a href="/blog/搞定音频技术">搞定音频技术</a></li><li><a href="/blog/攻克视频技术">攻克视频技术</a></li></ul></span><span>前端工程化<ul><li><a href="/blog/logger">logger</a></li><li><a href="/blog/webpack">webpack</a></li><li><a href="/blog/webpackChain">webpackChain</a></li></ul></span><span>前端性能优化<ul><li><a href="/blog/react性能调优">react性能调优</a></li></ul></span><span>软件测试<ul><li><a href="/blog/全链路压测实战30讲">全链路压测实战30讲</a></li><li><a href="/blog/性能测试实战30讲">性能测试实战30讲</a></li><li><a href="/blog/自动化测试高手课">自动化测试高手课</a></li><li><a href="/blog/软件测试52讲">软件测试52讲</a></li></ul></span><span>面试<ul><li><a href="/blog/面试现场">面试现场</a></li></ul></span><span>杂谈<ul><li><a href="/blog/超级访谈对话张雪峰">超级访谈对话张雪峰</a></li><li><a href="/blog/Git实战手册">Git实战手册</a></li><li><a href="/blog/NodeJS">NodeJS</a></li><li><a href="/blog/ReactJS">ReactJS</a></li><li><a href="/blog/UI设计">UI设计</a></li><li><a href="/blog/webpack4系列教程">webpack4系列教程</a></li><li><a href="/blog/前端知识体系">前端知识体系</a></li><li><a href="/blog/剑指offer刷题笔记">剑指offer刷题笔记</a></li><li><a href="/blog/思考与成长">思考与成长</a></li><li><a href="/blog/设计模式手册">设计模式手册</a></li></ul></span><div class="__dumi-default-navbar-tool"><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "></div></div></div></nav></div><div class="__dumi-default-menu" data-mode="site"><div class="__dumi-default-menu-inner"><div class="__dumi-default-menu-header"><a class="__dumi-default-menu-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog/"></a><h1>大师兄</h1><p></p></div><div class="__dumi-default-menu-mobile-area"><ul class="__dumi-default-menu-nav-list"><li>计算机基础<ul><li><a href="/blog/编译原理之美">编译原理之美</a></li><li><a href="/blog/编译原理实战">编译原理实战</a></li><li><a href="/blog/深入浅出计算机组成原理">深入浅出计算机组成原理</a></li><li><a href="/blog/详解http">详解http</a></li><li><a href="/blog/计算机网络通关29讲">计算机网络通关29讲</a></li><li><a href="/blog/网络排查案例课">网络排查案例课</a></li><li><a href="/blog/linux操作系统">linux操作系统</a></li><li><a href="/blog/linux性能优化实战">linux性能优化实战</a></li><li><a href="/blog/程序员数学基础">程序员数学基础</a></li><li><a href="/blog/趣谈网络协议">趣谈网络协议</a></li><li><a href="/blog/操作系统实战">操作系统实战</a></li><li><a href="/blog/软件工程之美">软件工程之美</a></li><li><a href="/blog/sql必知必会">sql必知必会</a></li><li><a href="/blog/操作系统实战45讲">操作系统实战45讲</a></li><li><a href="/blog/网络编程实战">网络编程实战</a></li></ul></li><li>算法<ul><li><a href="/blog/常用算法25讲">常用算法25讲</a></li><li><a href="/blog/数据结构与算法之美">数据结构与算法之美</a></li><li><a href="/blog/业务开发算法50讲">业务开发算法50讲</a></li><li><a href="/blog/动态规划面试宝典">动态规划面试宝典</a></li></ul></li><li>前端开发<ul><li><a href="/blog/浏览器工作原理与实践">浏览器工作原理与实践</a></li><li><a href="/blog/新时代产品经理进阶之路">新时代产品经理进阶之路</a></li><li><a href="/blog/全栈工程师修炼指南">全栈工程师修炼指南</a></li><li><a aria-current="page" class="active" href="/blog/flutter核心技术与实战">flutter核心技术与实战</a></li><li><a href="/blog/java-script核心原理解析">java-script核心原理解析</a></li><li><a href="/blog/说透低代码">说透低代码</a></li><li><a href="/blog/nodejs应用开发实战">nodejs应用开发实战</a></li><li><a href="/blog/反爬虫兵法演绎20讲">反爬虫兵法演绎20讲</a></li><li><a href="/blog/reactnative新架构实战课">reactnative新架构实战课</a></li><li><a href="/blog/正则表达式入门">正则表达式入门</a></li><li><a href="/blog/重学前端">重学前端</a></li><li><a href="/blog/serverless入门课">serverless入门课</a></li><li><a href="/blog/type-script入门实战笔记">type-script入门实战笔记</a></li><li><a href="/blog/图解googlev8">图解googlev8</a></li><li><a href="/blog/vue3源码分析">vue3源码分析</a></li><li><a href="/blog/玩转Vue3全家桶">玩转Vue3全家桶</a></li><li><a href="/blog/webassembly入门">webassembly入门</a></li><li><a href="/blog/手把手带你写一个Web框架">手把手带你写一个Web框架</a></li><li><a href="/blog/web漏洞挖掘实战">web漏洞挖掘实战</a></li><li><a href="/blog/跟月影学可视化">跟月影学可视化</a></li><li><a href="/blog/搞定音频技术">搞定音频技术</a></li><li><a href="/blog/攻克视频技术">攻克视频技术</a></li></ul></li><li>前端工程化<ul><li><a href="/blog/logger">logger</a></li><li><a href="/blog/webpack">webpack</a></li><li><a href="/blog/webpackChain">webpackChain</a></li></ul></li><li>前端性能优化<ul><li><a href="/blog/react性能调优">react性能调优</a></li></ul></li><li>软件测试<ul><li><a href="/blog/全链路压测实战30讲">全链路压测实战30讲</a></li><li><a href="/blog/性能测试实战30讲">性能测试实战30讲</a></li><li><a href="/blog/自动化测试高手课">自动化测试高手课</a></li><li><a href="/blog/软件测试52讲">软件测试52讲</a></li></ul></li><li>面试<ul><li><a href="/blog/面试现场">面试现场</a></li></ul></li><li>杂谈<ul><li><a href="/blog/超级访谈对话张雪峰">超级访谈对话张雪峰</a></li><li><a href="/blog/Git实战手册">Git实战手册</a></li><li><a href="/blog/NodeJS">NodeJS</a></li><li><a href="/blog/ReactJS">ReactJS</a></li><li><a href="/blog/UI设计">UI设计</a></li><li><a href="/blog/webpack4系列教程">webpack4系列教程</a></li><li><a href="/blog/前端知识体系">前端知识体系</a></li><li><a href="/blog/剑指offer刷题笔记">剑指offer刷题笔记</a></li><li><a href="/blog/思考与成长">思考与成长</a></li><li><a href="/blog/设计模式手册">设计模式手册</a></li></ul></li></ul><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "><button title="Dark theme" class="__dumi-default-dark-moon "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="3854" width="22" height="22"><path d="M991.816611 674.909091a69.166545 69.166545 0 0 0-51.665455-23.272727 70.795636 70.795636 0 0 0-27.438545 5.585454A415.674182 415.674182 0 0 1 754.993338 698.181818c-209.594182 0-393.472-184.785455-393.472-395.636363 0-52.363636 38.539636-119.621818 69.515637-173.614546 4.887273-8.610909 9.634909-16.756364 14.103272-24.901818A69.818182 69.818182 0 0 0 384.631156 0a70.842182 70.842182 0 0 0-27.438545 5.585455C161.678429 90.298182 14.362065 307.898182 14.362065 512c0 282.298182 238.824727 512 532.38691 512a522.286545 522.286545 0 0 0 453.957818-268.334545A69.818182 69.818182 0 0 0 991.816611 674.909091zM546.679156 954.181818c-248.785455 0-462.941091-192-462.941091-442.181818 0-186.647273 140.637091-372.829091 300.939637-442.181818-36.817455 65.629091-92.578909 151.970909-92.578909 232.727273 0 250.181818 214.109091 465.454545 462.917818 465.454545a488.331636 488.331636 0 0 0 185.181091-46.545455 453.003636 453.003636 0 0 1-393.565091 232.727273z m103.656728-669.323636l-14.266182 83.781818a34.909091 34.909091 0 0 0 50.362182 36.770909l74.775272-39.563636 74.752 39.563636a36.142545 36.142545 0 0 0 16.174546 3.956364 34.909091 34.909091 0 0 0 34.210909-40.727273l-14.289455-83.781818 60.509091-59.345455a35.025455 35.025455 0 0 0-19.223272-59.578182l-83.61891-12.101818-37.376-76.101818a34.56 34.56 0 0 0-62.254545 0l-37.376 76.101818-83.618909 12.101818a34.909091 34.909091 0 0 0-19.246546 59.578182z m70.423272-64.698182a34.280727 34.280727 0 0 0 26.135273-19.083636l14.312727-29.090909 14.336 29.090909a34.257455 34.257455 0 0 0 26.135273 19.083636l32.046546 4.887273-23.272728 22.574545a35.234909 35.234909 0 0 0-10.007272 30.952727l5.46909 32.116364-28.625454-15.127273a34.490182 34.490182 0 0 0-32.302546 0l-28.695272 15.127273 5.469091-32.116364a35.141818 35.141818 0 0 0-9.984-30.952727l-23.272728-22.574545z" p-id="3855"></path></svg></button><button title="Light theme" class="__dumi-default-dark-sun "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="4026" width="22" height="22"><path d="M915.2 476.16h-43.968c-24.704 0-44.736 16-44.736 35.84s20.032 35.904 44.736 35.904H915.2c24.768 0 44.8-16.064 44.8-35.904s-20.032-35.84-44.8-35.84zM512 265.6c-136.704 0-246.464 109.824-246.464 246.4 0 136.704 109.76 246.464 246.464 246.464S758.4 648.704 758.4 512c0-136.576-109.696-246.4-246.4-246.4z m0 425.6c-99.008 0-179.2-80.128-179.2-179.2 0-98.944 80.192-179.2 179.2-179.2S691.2 413.056 691.2 512c0 99.072-80.192 179.2-179.2 179.2zM197.44 512c0-19.84-19.136-35.84-43.904-35.84H108.8c-24.768 0-44.8 16-44.8 35.84s20.032 35.904 44.8 35.904h44.736c24.768 0 43.904-16.064 43.904-35.904zM512 198.464c19.776 0 35.84-20.032 35.84-44.8v-44.8C547.84 84.032 531.84 64 512 64s-35.904 20.032-35.904 44.8v44.8c0 24.768 16.128 44.864 35.904 44.864z m0 627.136c-19.776 0-35.904 20.032-35.904 44.8v44.736C476.096 940.032 492.16 960 512 960s35.84-20.032 35.84-44.8v-44.736c0-24.768-16.064-44.864-35.84-44.864z m329.92-592.832c17.472-17.536 20.288-43.072 6.4-57.024-14.016-14.016-39.488-11.2-57.024 6.336-4.736 4.864-26.496 26.496-31.36 31.36-17.472 17.472-20.288 43.008-6.336 57.024 13.952 14.016 39.488 11.2 57.024-6.336 4.8-4.864 26.496-26.56 31.296-31.36zM213.376 759.936c-4.864 4.8-26.56 26.624-31.36 31.36-17.472 17.472-20.288 42.944-6.4 56.96 14.016 13.952 39.552 11.2 57.024-6.336 4.8-4.736 26.56-26.496 31.36-31.36 17.472-17.472 20.288-43.008 6.336-56.96-14.016-13.952-39.552-11.072-56.96 6.336z m19.328-577.92c-17.536-17.536-43.008-20.352-57.024-6.336-14.08 14.016-11.136 39.488 6.336 57.024 4.864 4.864 26.496 26.56 31.36 31.424 17.536 17.408 43.008 20.288 56.96 6.336 14.016-14.016 11.264-39.488-6.336-57.024-4.736-4.864-26.496-26.56-31.296-31.424z m527.168 628.608c4.864 4.864 26.624 26.624 31.36 31.424 17.536 17.408 43.072 20.224 57.088 6.336 13.952-14.016 11.072-39.552-6.4-57.024-4.864-4.8-26.56-26.496-31.36-31.36-17.472-17.408-43.072-20.288-57.024-6.336-13.952 14.016-11.008 39.488 6.336 56.96z" p-id="4027"></path></svg></button><button title="Default to system" class="__dumi-default-dark-auto "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="11002" width="22" height="22"><path d="M127.658667 492.885333c0-51.882667 10.24-101.717333 30.378666-149.162666s47.786667-88.064 81.92-122.538667 75.093333-61.781333 122.538667-81.92 96.938667-30.378667 149.162667-30.378667 101.717333 10.24 149.162666 30.378667 88.405333 47.786667 122.88 81.92 61.781333 75.093333 81.92 122.538667 30.378667 96.938667 30.378667 149.162666-10.24 101.717333-30.378667 149.162667-47.786667 88.405333-81.92 122.88-75.093333 61.781333-122.88 81.92-97.28 30.378667-149.162666 30.378667-101.717333-10.24-149.162667-30.378667-88.064-47.786667-122.538667-81.92-61.781333-75.093333-81.92-122.88-30.378667-96.938667-30.378666-149.162667z m329.045333 0c0 130.048 13.994667 244.394667 41.984 343.381334h12.970667c46.762667 0 91.136-9.216 133.461333-27.306667s78.848-42.666667 109.568-73.386667 54.954667-67.242667 73.386667-109.568 27.306667-86.698667 27.306666-133.461333c0-46.421333-9.216-90.794667-27.306666-133.12s-42.666667-78.848-73.386667-109.568-67.242667-54.954667-109.568-73.386667-86.698667-27.306667-133.461333-27.306666h-11.605334c-28.672 123.562667-43.349333 237.909333-43.349333 343.722666z" p-id="11003"></path></svg></button></div></div></div><ul class="__dumi-default-menu-list"><li><a href="/blog/flutter核心技术与实战">flutter核心技术与实战</a></li><li><a href="/blog/flutter核心技术与实战/01.课前必读">01.课前必读</a><ul><li><a href="/blog/flutter核心技术与实战/01.课前必读/01"><span>开篇词 | 为什么每一位大前端从业者都应该学习Flutter？</span></a></li><li><a href="/blog/flutter核心技术与实战/01.课前必读/02"><span>01 | 预习篇 · 从0开始搭建Flutter工程环境</span></a></li><li><a href="/blog/flutter核心技术与实战/01.课前必读/03"><span>02 | 预习篇 · Dart语言概览</span></a></li></ul></li><li><a href="/blog/flutter核心技术与实战/02.flutter开发起步">02.Flutter开发起步</a><ul><li><a href="/blog/flutter核心技术与实战/02.flutter开发起步/01"><span>03 | 深入理解跨平台方案的历史发展逻辑</span></a></li><li><a href="/blog/flutter核心技术与实战/02.flutter开发起步/02"><span>04 | Flutter区别于其他方案的关键技术是什么？</span></a></li><li><a href="/blog/flutter核心技术与实战/02.flutter开发起步/03"><span>05 | 从标准模板入手，体会Flutter代码是如何运行在原生系统上的</span></a></li></ul></li><li><a href="/blog/flutter核心技术与实战/03.dart语言基础">03.Dart语言基础</a><ul><li><a href="/blog/flutter核心技术与实战/03.dart语言基础/01"><span>06 | 基础语法与类型变量：Dart是如何表示信息的？</span></a></li><li><a href="/blog/flutter核心技术与实战/03.dart语言基础/02"><span>07 | 函数、类与运算符：Dart是如何处理信息的？</span></a></li><li><a href="/blog/flutter核心技术与实战/03.dart语言基础/03"><span>08 | 综合案例：掌握Dart核心特性</span></a></li></ul></li><li><a href="/blog/flutter核心技术与实战/04.flutter基础">04.Flutter基础</a><ul><li><a href="/blog/flutter核心技术与实战/04.flutter基础/01"><span>09 | Widget，构建Flutter界面的基石</span></a></li><li><a href="/blog/flutter核心技术与实战/04.flutter基础/02"><span>10 | Widget中的State到底是什么？</span></a></li><li><a href="/blog/flutter核心技术与实战/04.flutter基础/03"><span>11 | 提到生命周期，我们是在说什么？</span></a></li><li><a href="/blog/flutter核心技术与实战/04.flutter基础/04"><span>12 | 经典控件（一）：文本、图片和按钮在Flutter中怎么用？</span></a></li><li><a href="/blog/flutter核心技术与实战/04.flutter基础/05"><span>13 | 经典控件（二）：UITableView/ListView在Flutter中是什么？</span></a></li><li><a href="/blog/flutter核心技术与实战/04.flutter基础/06"><span>14 | 经典布局：如何定义子控件在父容器中排版的位置？</span></a></li><li><a href="/blog/flutter核心技术与实战/04.flutter基础/07"><span>15 | 组合与自绘，我该选用何种方式自定义Widget？</span></a></li><li><a href="/blog/flutter核心技术与实战/04.flutter基础/08"><span>16 | 从夜间模式说起，如何定制不同风格的App主题？</span></a></li><li><a href="/blog/flutter核心技术与实战/04.flutter基础/09"><span>17 | 依赖管理（一）：图片、配置和字体在Flutter中怎么用？</span></a></li><li><a href="/blog/flutter核心技术与实战/04.flutter基础/10"><span>18 | 依赖管理（二）：第三方组件库在Flutter中要如何管理？</span></a></li><li><a href="/blog/flutter核心技术与实战/04.flutter基础/11"><span>19 | 用户交互事件该如何响应？</span></a></li><li><a href="/blog/flutter核心技术与实战/04.flutter基础/12"><span>20 | 关于跨组件传递数据，你只需要记住这三招</span></a></li><li><a href="/blog/flutter核心技术与实战/04.flutter基础/13"><span>21 | 路由与导航，Flutter是这样实现页面切换的</span></a></li></ul></li><li><a href="/blog/flutter核心技术与实战/05.flutter进阶">05.Flutter进阶</a><ul><li><a href="/blog/flutter核心技术与实战/05.flutter进阶/01"><span>22 | 如何构造炫酷的动画效果？</span></a></li><li><a href="/blog/flutter核心技术与实战/05.flutter进阶/02"><span>23 | 单线程模型怎么保证UI运行流畅？</span></a></li><li><a href="/blog/flutter核心技术与实战/05.flutter进阶/03"><span>24 | HTTP网络编程与JSON解析</span></a></li><li><a href="/blog/flutter核心技术与实战/05.flutter进阶/04"><span>25 | 本地存储与数据库的使用和优化</span></a></li><li><a href="/blog/flutter核心技术与实战/05.flutter进阶/05"><span>26 | 如何在Dart层兼容Android/iOS平台特定实现？（一）</span></a></li><li><a href="/blog/flutter核心技术与实战/05.flutter进阶/06"><span>27 | 如何在Dart层兼容Android/iOS平台特定实现？（二）</span></a></li><li><a href="/blog/flutter核心技术与实战/05.flutter进阶/07"><span>28 | 如何在原生应用中混编Flutter工程？</span></a></li><li><a href="/blog/flutter核心技术与实战/05.flutter进阶/08"><span>29 | 混合开发，该用何种方案管理导航栈？</span></a></li><li><a href="/blog/flutter核心技术与实战/05.flutter进阶/09"><span>30 | 为什么需要做状态管理，怎么做？</span></a></li><li><a href="/blog/flutter核心技术与实战/05.flutter进阶/10"><span>31 | 如何实现原生推送能力？</span></a></li><li><a href="/blog/flutter核心技术与实战/05.flutter进阶/11"><span>32 | 适配国际化，除了多语言我们还需要注意什么?</span></a></li><li><a href="/blog/flutter核心技术与实战/05.flutter进阶/12"><span>33 | 如何适配不同分辨率的手机屏幕？</span></a></li><li><a href="/blog/flutter核心技术与实战/05.flutter进阶/13"><span>34 | 如何理解Flutter的编译模式？</span></a></li><li><a href="/blog/flutter核心技术与实战/05.flutter进阶/14"><span>35 | Hot Reload是怎么做到的？</span></a></li><li><a href="/blog/flutter核心技术与实战/05.flutter进阶/15"><span>36 | 如何通过工具链优化开发调试效率？</span></a></li><li><a href="/blog/flutter核心技术与实战/05.flutter进阶/16"><span>37 | 如何检测并优化Flutter App的整体性能表现？</span></a></li><li><a href="/blog/flutter核心技术与实战/05.flutter进阶/17"><span>38 | 如何通过自动化测试提高交付质量？</span></a></li></ul></li><li><a href="/blog/flutter核心技术与实战/06.flutter综合应用">06.Flutter综合应用</a><ul><li><a href="/blog/flutter核心技术与实战/06.flutter综合应用/01"><span>39 | 线上出现问题，该如何做好异常捕获与信息采集？</span></a></li><li><a href="/blog/flutter核心技术与实战/06.flutter综合应用/02"><span>40 | 衡量Flutter App线上质量，我们需要关注这三个指标</span></a></li><li><a href="/blog/flutter核心技术与实战/06.flutter综合应用/03"><span>41 | 组件化和平台化，该如何组织合理稳定的Flutter工程结构？</span></a></li><li><a href="/blog/flutter核心技术与实战/06.flutter综合应用/04"><span>42 | 如何构建高效的Flutter App打包发布环境？</span></a></li><li><a href="/blog/flutter核心技术与实战/06.flutter综合应用/05"><span>43 | 如何构建自己的Flutter混合开发框架（一）？</span></a></li><li><a href="/blog/flutter核心技术与实战/06.flutter综合应用/06"><span>44 | 如何构建自己的Flutter混合开发框架（二）？</span></a></li></ul></li><li><a href="/blog/flutter核心技术与实战/07.结束语">07.结束语</a><ul><li><a href="/blog/flutter核心技术与实战/07.结束语/01"><span>结束语 | 勿畏难，勿轻略</span></a></li><li><a href="/blog/flutter核心技术与实战/07.结束语/02"><span>结课测试 | 关于Flutter的这些知识，你都掌握了吗？</span></a></li></ul></li><li><a aria-current="page" class="active" href="/blog/flutter核心技术与实战/08.特别放送">08.特别放送</a><ul><li><a aria-current="page" class="active" href="/blog/flutter核心技术与实战/08.特别放送/01"><span>特别放送 ｜ 温故而知新，与你说说专栏的那些思考题</span></a></li></ul></li><li><a href="/blog/flutter核心技术与实战/summary">flutter核心技术与实战</a></li></ul></div></div><ul role="slug-list" class="__dumi-default-layout-toc"></ul><div class="__dumi-default-layout-content"><div class="markdown"><h1 id="特别放送--温故而知新与你说说专栏的那些思考题"><a aria-hidden="true" tabindex="-1" href="/blog/flutter核心技术与实战/08.特别放送/01#特别放送--温故而知新与你说说专栏的那些思考题"><span class="icon icon-link"></span></a>特别放送 ｜ 温故而知新，与你说说专栏的那些思考题</h1><p>你好，我是陈航。专栏上线以来，我在评论区看到了很多同学写的心得、经验和建议，当然更多的还是大家提的问题。</p><p>为了能够让大家更好地理解我们专栏的核心知识点，我今天特意整理了每篇文章的课后思考题，并结合大家在留言区的回答情况做一次分析与扩展。</p><p>当然 ，我也希望你能把这篇答疑文章作为对整个专栏所讲知识点的一次复习，如果你在学习或者使用Flutter的过程中，遇到哪些问题，欢迎继续给我留言。我们一起交流，共同进步！</p><p>需要注意的是，这些课后题并不存在标准答案。就算是同一个功能、同一个界面，不同人也会有完全不一样的实现方案，只要你的解决方案的输入和输出满足题目要求，在我看来你就已经掌握了相应的知识点。因此，<strong>在这篇文章中，我会更侧重于介绍方案、实现思路、原理和关键细节，而不是讲具体实操的方方面面。</strong></p><p>接下来，我们就具体看看这些思考题的答案吧。</p><p>问题1：直接在build函数里以内联的方式实现Scaffold页面元素的构建，好处是什么？</p><p>这个问题选自第5篇文章“<a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/106199">从标准模板入手，体会Flutter代码是如何运行在原生系统上的<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>”，你可以先回顾下这篇文章的相关知识点。</p><p>然后，我来说说这样做的最大好处是，各个组件之间可以直接共享页面的状态和方法，页面和组件间不再需要把状态数据传来传去、多级回调了。</p><p>不过这种方式也有缺点，一旦数据发生变更，Flutter会重建整个大Widget（而不是变化的那部分），所以会对性能产生些影响。</p><p>问题2：对于集合类型List和Map，如何让其内部元素支持多种类型？</p><p>这个问题来自第6篇文章“<a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/106816">基础语法与类型变量：Dart是如何表示信息的？<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>”，你可以先回顾下这篇文章的相关知识点。</p><p>如果集合中多个类型之间存在共同的父类（比如double和int），可以使用父类进行容器类型声明，从而增加类型的安全校验，在取出对象时根据runtimeType转换成实际类型即可。如果容器中的类型比较多，想省掉类型转换的步骤，也可以使用动态类型dynamic为元素添加不同类型的元素。</p><p>而在判断元素真实类型时，我们可以使用is关键字或runtimeType。</p><p>问题3：继承、接口与混入的相关问题。</p><p>这个问题来自第7篇文章“<a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/107399">函数、类与运算符：Dart是如何处理信息的？<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>”，你可以先回顾下这篇文章的相关知识点。</p><p><strong>第一</strong>，你是怎样理解父类继承、接口实现和混入的？我们应该在什么场景下使用它们？</p><p>父类继承、接口实现和混入都是实现代码复用的手段，我们在代码中应该根据不同的需求去使用。其中：</p><ul><li>在父类继承中，子类复用了父类的实现，适用于两个类的整体存在逻辑层次关系的场景；</li><li>在接口实现中，类复用了接口的参数、返回值和方法名，但不复用其方法实现，适用于接口和类在行为存在逻辑层次关系的场景；</li><li>而混入则可以使一个类复用多个类的实现，这些类之间无需存在父子关系，适用于多个类的局部存在逻辑层次关系的场景。</li></ul><p><strong>第二</strong>，在父类继承的场景中，父类子类之间的构造函数执行顺序是怎样的？如果父类有多个构造函数，子类也有多个构造函数，如何从代码层面确保父类子类之间构造函数的正确调用？</p><p>默认情况下，子类的构造函数会自动调用父类的默认构造函数，如果需要显式地调用父类的构造函数，则需要在子类构造函数的函数体开头位置调用。但，如果子类提供了初始化参数列表，则初始化参数列表会在父类构造函数之前执行。</p><p>构造函数之间，有时候会有一些相同的逻辑。如果把这些逻辑分别写在各个构造函数中，会有些累赘，所以构造函数之间是可以传递的，相当于填充了某个构造函数的参数，从而实现类的初始化。因此可以传递的构造函数是没有方法体的，它们只会在初始化列表中，去调用另一个构造函数。</p><p>如果子类与父类存在多个构造函数，通常是为了简化类的初始化代码，将部分不需要的属性设置为默认值。因此，我们只要能确保每条构造函数的初始化路径都不会有属性被遗漏即可。<strong>一个好的做法是</strong>，依照构造函数的参数个数，将参数少的构造函数转发至参数多的构造函数中，由参数最多的构造函数统一调用父类参数最多的那个构造函数。</p><p>问题4：扩展购物车案例的程序，使其支持商品数量属性，并输出商品列表信息（包括商品名称、数量及单价）。</p><p>这个问题来自第8篇文章“<a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/107315">综合案例：掌握Dart核心特性<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>”，你可以先回顾下这篇文章的相关知识点。</p><p>要实现这个扩展功能，如我所说，每个人都可能有完全不一样的解决方案。在这里，我给你的提示是，在Item类中增加数量属性，在做小票打印时，循环购物车内的商品信息即可实现。</p><p>需要注意的是，增加数量属性后，商品在做合并计算价格时，count需要置为1，而不能做累加。比如，五斤苹果和三盒巧克力做合并，结果是一份巧克力苹果套餐，而不是八份巧克力苹果套餐。</p><p>问题5：Widget、Element 和 RenderObject之间是什么关系？你能否在Android/iOS/Web中找到对应的概念呢？</p><p>这个问题来自第9篇文章“<a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/108522">Widget，构建Flutter界面的基石<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>”。</p><p>Widget是数据配置，RenderObject负责渲染，而Element是一个介于它们之间的中间类，用于渲染资源复用。</p><p>Widget和Element是一一对应的，但RenderObject不是，只有实际需要布局和绘制的控件才会有RenderObject。</p><p>这三个概念在iOS、Android和Web开发中，对应的概念分别是：</p><ul><li>在iOS中，Xib相当于Widget，UIView相当于Element，CALayer相当于renderObject；</li><li>在Android中，XML相当于Widget，View相当于Element，Canvas相当于renderObject；</li><li>在Web中，以Vue为例，Vue的模板相当于Widget，virtual DOM相当于Element，DOM相当于RenderObject。</li></ul><p>问题6：State构造函数和initState的差异是什么？</p><p>这个问题来自第11篇文章“<a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/109490">提到生命周期，我们是在说什么？<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>”。</p><p>State构造函数调用时，Widget还未完成初始化，因此仅适用于一些与UI无关的数据初始化，比如父类传入的参数加工。</p><p>而initState函数调用时，StatefulWidget已经完成了Widget树的插入工作，因此与Widget相关的一些初始化工作，比如设置滚动监听器则必须放在initState。</p><p>问题7：Text、Image以及按钮控件，真正承载其视觉功能的控件分别是什么？</p><p>这个问题来自第12篇文章“<a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/110292">经典控件（一）：文本、图片和按钮在Flutter中怎么用？<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>”。</p><p>Text是封装了RichText的StatelessWidget，Image是封装了RawImage的StatefulWidget，而按钮则是封装了RawMaterialButton的StatelessWidget。</p><p>可以看到，StatelessWidget和StatefulWidget只是封装了控件的容器，并不参与实际绘制，真正负责渲染的是继承自RenderObject的视觉功能组件们，比如RichText与RawImage。</p><p>问题8：在ListView中，如何提前缓存子元素？</p><p>这个问题来自第13篇文章“<a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/110859">经典控件（二）：UITableView/ListView在Flutter中是什么？<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>”。</p><p>ListView构造函数中有一个cacheExtent参数，即预渲染区域长度。ListView会在其可视区域的两边留一个cacheExtent长度的区域作为预渲染区域，相当于提前缓存些元素，这样当滑动时就可以迅速呈现了。</p><p>问题9：Row与Column自身的大小是如何决定的？当它们嵌套时，又会出现怎样的情况呢？</p><p>这个问题来自第14篇文章“<a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/110848">经典布局：如何定义子控件在父容器中排版的位置？<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>”。</p><p>Row与Column自身的大小由父Widget的大小、子Widget的大小，以及mainSize共同决定。</p><p>Row和Column只会在主轴方向占用尽可能大的空间（max：屏幕方向主轴大小或父Widget主轴方向大小；min：所有子Widget组合在一起的主轴方向大小），而纵轴的长度则取决于它们最大子元素的长度。</p><p>如果Row里面嵌套Row，或者Column里面嵌套Column，只有最外层的Row或Colum才会占用尽可能大的空间，里层Row或Column占用的空间为实际大小。</p><p>问题10：在 UpdatedItem 控件的基础上，增加切换夜间模式的功能。</p><p>这个问题来自第16篇文章“<a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/112148">从夜间模式说起，如何定制不同风格的App主题？<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>”。</p><p>这是一道实践题。同样地，我在这里也只提示你实现思路：你可以在ThemeData中，通过增加变量来判断当前使用何种主题，然后在State中驱动变量更新即可。</p><p>问题11：像素密度为3.0及1.0设备，如何根据资源图片像素进行处理？</p><p>这个问题来自第17篇文章“<a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/113495">依赖管理（一）：图片、配置和字体在Flutter中怎么用？<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>”。</p><p>设备根据资源图片像素进行适配的原则是：调整为使用最合适的分辨率资源，即像素密度为3.0的设备会选择2.0而不是1.0的资源图片；而像素密度为1.0的设备，对于像素密度大于1.0的资源图片会进行压缩。</p><p>问题12：.packages 与 pubspec.lock 是否需要做代码版本管理？</p><p>这个问题来自第18篇文章“<a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/114180">依赖管理（二）：第三方组件库在Flutter中要如何管理？<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>”。</p><p>pubspec.lock需要做版本管理，因为lock文件记录了Dart在计算项目依赖时，当前工程所有显式和隐私的依赖关系。我们可以直接使用这个结果去统一工程开发环境。</p><p>而.packages不需要版本管理，因为这个文件记录了Dart在计算项目依赖时，当前工程所有依赖的本地缓存文件。与本地环境有关，无需统一。</p><p>问题13：GestureDetector内嵌FlatButton后，事件是如何响应的？</p><p>这个问题来自第19篇文章“<a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/116326">用户交互事件该如何响应？<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>”。</p><p>对于一个父容器中存在按钮FlatButton的界面，在父容器使用GestureDetector监听了onTap事件的情况下，我们点击按钮是不会被父Widget响应的。因为，手势竞技场只会同时响应一个（子Widget）。</p><p>如果监听的是onDoubleTap事件，在按钮上双击后，父容器的双击事件会被识别。因为，子Widget没有处理双击事件，不需要经历手势竞技场的PK过程。</p><p>问题14：请分别概括属性传值、InheritedWidget、Notification 与 EventBus的特点。</p><p>这个问题来自第20篇文章“<a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/116382">关于跨组件传递数据，你只需要记住这三招<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>”。</p><p><strong>属性传值</strong>适合在同一个视图树中使用，传递方向由父及子，通过构造方法将值以属性的方式传递过去，简单高效。其缺点是，涉及跨层传递时，属性可能需要跨越很多层才能传递给子组件，导致中间很多并不需要这个属性的组件，也得接收其子Widget的数据，繁琐且冗余。</p><p><strong>InheritedWidget</strong>适用于子Widget主动向上层拿数据的场景，传递方向由父及子，可以实现跨层的数据读共享。InheritedWidget也可以实现写共享，需要在上层封装写数据的方法供下层调用。其优点是，数据传输方便，无代码侵入即可达到逻辑和视图解耦的效果；而其缺点是，如果层次较深，刷新范围过大会影响性能。</p><p><strong>Notification</strong>适用于子Widget向父Widget推送数据的场景，传递方向由子及父，可以实现跨层的数据变更共享。其优点是，多个子元素的同一事件可由父元素统一处理，多对一简单；而其缺点是，Notification的自定义过程略繁琐。</p><p><strong>EventBus</strong>适用于无需存在父子关系的实体之间通信，订阅者需要显式地订阅和取消。其优点是，能够支持任意对象的传递，一对多的方式实现简单；而其缺点是，订阅管理略显繁琐。</p><p>问题15：实现一个计算页面，这个页面可以对前一个页面传入的 2 个数值参数进行求和，并在该页面关闭时告知上一页面计算的结果。</p><p>这个问题来自第21篇文章“<a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/118421">路由与导航，Flutter是这样实现页面切换的<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>”。</p><p>这是一个实践题，还需要你动手去实现。这里，我给你的提示是：基本路由可以通过构造函数属性传值的方式，或是在MaterialPageRoute中加入参数setting，来传递页面参数。</p><p>打开页面时，我们可以使用上述机制为基本路由传递参数（2个数值），并注册then回调监听页面的关闭事件；而页面需要关闭时，我们将2个数值参数取出，求和后调用pop函数即可。</p><p>问题16：AnimatedBuilder中，外层的child参数与内层builder函数中的child参数的作用分别是什么？</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">AnimatedBuilder(</span></div><div class="token-line"><span class="token plain">      animation: animation,</span></div><div class="token-line"><span class="token plain">      child:FlutterLogo(),</span></div><div class="token-line"><span class="token plain">      builder: (context, child) =&gt; Container(</span></div><div class="token-line"><span class="token plain">        width: animation.value,</span></div><div class="token-line"><span class="token plain">        height: animation.value,</span></div><div class="token-line"><span class="token plain">        child: child</span></div><div class="token-line"><span class="token plain">      )</span></div><div class="token-line"><span class="token plain">    )</span></div></pre></div><p>这个问题来自第22篇文章“<a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/119148">如何构造炫酷的动画效果？<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>”。</p><p>外层的child参数定义渲染，内层builder中的child参数定义动画，实现了动画和渲染的分离。通过builder函数，限定了重建rebuild的范围，做动画时不必每次重新构建整个Widget。</p><p>问题17：并发 Isolate 计算阶乘例子里给并发Isolate两个SendPort的原因？</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">//并发计算阶乘</span></div><div class="token-line"><span class="token plain">    Future&lt;dynamic&gt; asyncFactoriali(n) async{</span></div><div class="token-line"><span class="token plain">      final response = ReceivePort();//创建管道</span></div><div class="token-line"><span class="token plain">      //创建并发Isolate，并传入管道</span></div><div class="token-line"><span class="token plain">      await Isolate.spawn(_isolate,response.sendPort);</span></div><div class="token-line"><span class="token plain">      //等待Isolate回传管道</span></div><div class="token-line"><span class="token plain">      final sendPort = await response.first as SendPort;</span></div><div class="token-line"><span class="token plain">      //创建了另一个管道answer</span></div><div class="token-line"><span class="token plain">      final answer = ReceivePort();</span></div><div class="token-line"><span class="token plain">      //往Isolate回传的管道中发送参数，同时传入answer管道</span></div><div class="token-line"><span class="token plain">      sendPort.send([n,answer.sendPort]);</span></div><div class="token-line"><span class="token plain">      return answer.first;//等待Isolate通过answer管道回传执行结果</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    //Isolate函数体，参数是主Isolate传入的管道</span></div><div class="token-line"><span class="token plain">    _isolate(initialReplyTo) async {</span></div><div class="token-line"><span class="token plain">      final port = ReceivePort();//创建管道</span></div><div class="token-line"><span class="token plain">      initialReplyTo.send(port.sendPort);//往主Isolate回传管道</span></div><div class="token-line"><span class="token plain">      final message = await port.first as List;//等待主Isolate发送消息(参数和回传结果的管道)</span></div><div class="token-line"><span class="token plain">      final data = message[0] as int;//参数</span></div><div class="token-line"><span class="token plain">      final send = message[1] as SendPort;//回传结果的管道 </span></div><div class="token-line"><span class="token plain">      send.send(syncFactorial(data));//调用同步计算阶乘的函数回传结果</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    //同步计算阶乘</span></div><div class="token-line"><span class="token plain">    int syncFactorial(n) =&gt; n &lt; 2 ? n : n * syncFactorial(n-1);</span></div><div class="token-line"><span class="token plain">    main() async =&gt; print(await asyncFactoriali(4));//等待并发计算阶乘结果</span></div></pre></div><p>这个问题来自第23篇文章“<a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/120014">单线程模型怎么保证UI运行流畅？<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>”。</p><p>SendPort/ReceivePort是一个单向管道，帮助我们<strong>实现并发Isolate往主Isolate回传执行结果</strong>：并发Isolate负责用SendPort发，而主Isolate负责用ReceivePort收。对于回传执行结果这个过程而言，主Isolate除了被动等待没有别的办法。</p><p>在这个例子中，并发Isolate用SendPort发了两次数据，意味着主Isolate也需要用SendPort对应的ReceivePort等待两次。如果并发Isolate用SenderPort发了三次数据，那主Isolate也需要用ReceivePort等待三次。</p><p>那么，主Isolate怎么知道自己需要等待几次呢，总不能一直等着吧？</p><p>所以更好的办法是，只使用SendPort/ReceivePort一次，发/收完了就不用了。但，如果下次还要发/收怎么办？</p><p>这时，我们就可以参考这个计算阶乘案例的做法，在发数据的时候把下一次用到的SendPort也当做参数传过去。</p><p>问题18：自定义dio拦截器，检查并刷新token。</p><p>这个问题来自第24篇文章“<a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/121163">HTTP网络编程与JSON解析<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>”。</p><p>这也是一个实践题，我同样只提示你关键思路：在拦截器的onRequest方法中，检查header中是否存在token，如果没有，则发起一个新的请求去获取token，更新header。考虑到可能会有多个request同时发出，token会请求多次，我们可以通过调用拦截器的 lock/unlock 方法来锁定/解锁拦截器。</p><p>一旦请求/响应拦截器被锁定，接下来的请求/响应将会在进入请求/响应拦截器之前排队等待，直到解锁后，这些入队的请求才会继续执行（进入拦截器）。</p><p>问题19：持久化存储的相关问题。</p><p>这个问题来自来第25篇文章“<a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/126460">本地存储与数据库的使用和优化<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>”。</p><p><strong>首先</strong>，我们先看看文件、SharedPreferences 和数据库，这三种持久化数据存储方式的适用场景。</p><ul><li>文件比较适合大量的、有序的数据持久化；</li><li>SharedPreferences，适用于缓存少量键值对信息；</li><li>数据库，则用来存储大量格式化后的数据，并且这些数据需要以较高频率更新。</li></ul><p><strong>接下来</strong>，我们看看如何做数据库跨版本升级？</p><p>数据库升级，实际上就是改表结构。如果升级过程是连续的，我们只需要在每个版本执行修改表结构的语句就可以了。如果升级过程不是连续的，比如直接从1.0升到5.0，中间2.0、3.0和4.0都直接跳过的：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">1.0-&gt;2.0：执行表结构修改语句A</span></div><div class="token-line"><span class="token plain">    2.0-&gt;3.0：执行表结构修改语句B</span></div><div class="token-line"><span class="token plain">    3.0-&gt;4.0：执行表结构修改语句C</span></div><div class="token-line"><span class="token plain">    4.0-&gt;5.0：执行表结构修改语句D</span></div></pre></div><p>因此，我们在5.0的数据库迁移中，不能只考虑5.0的表结构，单独执行4.0的升级逻辑D，还需要考虑2.0、3.0、4.0的表结构，把1.0升级到4.0之间的所有升级逻辑执行一遍：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">switch(oldVersion) {</span></div><div class="token-line"><span class="token plain">     case &#x27;1.0&#x27;: do A;</span></div><div class="token-line"><span class="token plain">     case &#x27;2.0&#x27;: do B;</span></div><div class="token-line"><span class="token plain">     case &#x27;3.0&#x27;: do C;</span></div><div class="token-line"><span class="token plain">     case &#x27;4.0&#x27;: do D;</span></div><div class="token-line"><span class="token plain">     default: print(&#x27;done&#x27;);</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>这样就万无一失了。</p><p>不过需要注意的是，在Dart的switch里，条件判断break语句是不能省的。关于如何在Dart中写出类似C++的fallthrough switch，你可以再思考一下。</p><p>问题20：扩展openAppMarket的实现，使得我们可以跳转到任意一个App的应用市场。</p><p>这个问题来自第26篇文章“<a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/127601">如何在Dart层兼容Android/iOS平台特定实现？（一）<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>”。</p><p>对于这个问题，我给你的提示是：Dart调用invokeMethod方法时，可传入Map类型的键值对参数（包含iOS的bundleID和Android包名），然后在原生代码宿主将参数取出即可。</p><p>问题21：扩展内嵌原生视图的实现，实现动态变更原生视图颜色的需求。</p><p>这个问题来自第27篇文章“<a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/128510">如何在Dart层兼容Android/iOS平台特定实现？（二）<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>”。</p><p>对于这个问题，我给你提示与上一问题类似：Dart调用invokeMethod方法时，可传入Map类型的键值对参数（颜色的RGB信息），然后在原生代码宿主将参数取出即可。</p><p>问题22：对于有资源依赖的Flutter模块工程，其打包构建的产物，以及抽离组件库的过程是否有不同？</p><p>这个问题来自第28篇文章“<a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/129754">如何在原生应用中混编Flutter工程？<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>”。</p><p>答案是没什么不同。因为Flutter模块的文件本身就包含了资源文件。</p><p>如果模块工程有原生插件依赖，则其抽离过程还需要借助记录了插件本地依赖缓存地址的.flutter-plugins文件，来实现组件依赖的原生部分的封装。具体细节，你可以参考<a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/129754">第44篇文章<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>。</p><p>问题23：如何确保混合工程中两种页面过渡动画在应用整体的效果一致？</p><p>这个问题来自第29篇文章“<a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/131234">混合开发，该用何种方案管理导航栈？<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>”</p><p>首先，这两种页面过渡动画分别是：原生页面之间的切换动画和Flutter页面之间的切换动画。</p><p>保证整体效果一致，有两种方案：</p><ul><li>一是，分别定制原生工程（主要是Android）的切换动画，及Flutter的切换动画；</li><li>二是，使用类似闲鱼的共享FlutterView的机制，将页面切换统一交由原生处理，FlutterView只负责刷新界面。</li></ul><p>问题24：如何使用Provider实现2个同样类型的对象共享？</p><p>这个问题来自第30篇文章“<a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/131890">为什么需要做状态管理，怎么做？<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>”</p><p>答案很简单，你可以封装1个大对象，将2个同样类型的对象封装为其内部属性。</p><p>问题25：如何让Flutter代码能够更快地收到推送消息？</p><p>这个问题来自第31篇文章“<a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/132818">如何实现原生推送能力？<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>”。</p><p>我们需要先判断当前应用是处于前台还是后台，然后再用对应的方式去处理：</p><ul><li>如果应用处于前台，并且已经完成初始化，则原生代码直接调用方法通道通知Flutter；如果应用未完成初始化，则原生代码将消息存在本地，待Flutter应用初始化完成后，调用方法通道主动拉取。</li><li>如果应用处于后台，则原生代码将消息存在本地，唤醒Flutter应用，待Flutter应用初始化完成后，调用方法通道主动拉取。</li></ul><p>问题26：如何实现图片资源的国际化？</p><p>这个问题来自第32篇文章“<a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/134163">适配国际化，除了多语言我们还需要注意什么？<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>”。</p><p>其实，图片资源国际化与文本资源，本质上并无区别，只需要在arb文件中对不同的图片进行单独声明即可。具体的实现细节，你可以再回顾下这篇文章的相关内容。</p><p>问题27：相邻页面的横竖屏切换如何实现？</p><p>这个问题来自第33篇文章“<a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/135098">如何适配不同分辨率的手机屏幕？<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>”。</p><p>这个实现方式很简单。你可以在initState中设置屏幕支持方向，在dispose时将屏幕方向还原即可。</p><p>问题28：在保持生产环境代码不变的情况下，如何支持不同配置的切换？</p><p>这个问题来自第34篇文章“<a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/135865">如何理解Flutter的编译模式？<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>”。</p><p>与配置夜间模式类似，我们可以通过增加状态开关来判断当前使用何种配置，设置入口，然后在State中驱动变量更新即可。关于夜间模式的配置，你可以再回顾下第16篇文章“<a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/112148">从夜间模式说起，如何定制不同风格的App主题？<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>”中的相关内容。</p><p>问题29：将debugPrint改为循环写日志。</p><p>这个问题来自第36篇文章“<a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/137789">如何通过工具链优化开发调试效率？<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>”</p><p>关于这个问题，我给你的提示是，用不同的main文件定义debugPrint行为：main-dev.dart定义为日志输出至控制台，而main.dart定义为输出至文件。当前操作的文件名默认为0，写满后文件名按5取模递增，同步更新至SharedPreferences中，并将文件清空，重新写入。</p><p>问题30：使用并发Isolate完成MD5的计算。</p><p>这个问题来自第37篇文章“<a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/138877">如何检测并优化Flutter App的整体性能表现？<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>”。</p><p>关于这个问题，我给你的提示是：将界面改造为StatefulWidget，把MD5的计算启动放在StatefulWidget的初始化中，使用compute去启动计算。在build函数中，判断是否存在MD5数据，如果没有，展示CircularProgressIndicator，如果有，则展示ListView。</p><p>问题31：如何使用mockito为SharedPreferences增加单元测试用例？</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">Future&lt;bool&gt;updateSP(SharedPreferences prefs, int counter) async {</span></div><div class="token-line"><span class="token plain">      bool result = await prefs.setInt(&#x27;counter&#x27;, counter);</span></div><div class="token-line"><span class="token plain">      return result;</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    Future&lt;int&gt;increaseSPCounter(SharedPreferences prefs) async {</span></div><div class="token-line"><span class="token plain">      int counter = (prefs.getInt(&#x27;counter&#x27;) ?? 0) + 1;</span></div><div class="token-line"><span class="token plain">      await updateSP(prefs, counter);</span></div><div class="token-line"><span class="token plain">      return counter;</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>这个问题来自第38篇文章“<a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/140079">如何通过自动化测试提高交付质量？<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>”。</p><p>待测函数updateSP与increaseSPCounter，其内部依赖了SharedPreferences的setInt方法与getInt方法，其中前者是异步函数，后者是同步函数。</p><p>因此，我们只需要为setInt与getInt模拟对应的数据返回即可。对于setInt，我们只需要在参数为1的时候返回true：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">when(prefs.setInt(&#x27;counter&#x27;, 1)).thenAnswer((_) async =&gt; true);</span></div></pre></div><p>对于getInt，我们只需要返回2：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">when(prefs.getInt(&#x27;counter&#x27;)).thenAnswer((_) =&gt; 2);</span></div></pre></div><p>其他部分与普通的单元测试并无不同。</p><p>问题32：并发Isolate的异常如何采集？</p><p>这个问题来自第39篇文章“<a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/141164">线上出现问题，该如何做好异常捕获与信息采集？<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>”。</p><p>并发Isolate的异常是无法通过try-catch来捕获的。并发Isolate与主Isolate通信是采用SendPort的消息机制，而异常本质上也可以视作一种消息传递机制。所以，如果主Isolate想要捕获并发Isolate中的异常消息，可以给并发Isolate传入SendPort。</p><p>而创建Isolate的函数spawn中就恰好有一个类型为SendPort的onError参数，因此并发Isolate可以通过往这个参数里发送消息，实现异常通知。</p><p>问题33：依赖单个或多个网络接口数据的页面加载时长应该如何统计？</p><p>这个问题来自第40篇文章“<a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/142509">衡量Flutter App线上质量，我们需要关注这三个指标<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>”。</p><p>页面加载时长=页面完成渲染的时间-页面初始化的时间。所以，我们只需要在进入页面时记录启动页面初始化时间，在接口返回数据刷新界面的同时，开启单次帧绘制回调，检测到页面完成渲染后记录页面渲染完成时间，两者相减即可。如果页面的渲染涉及到多个接口也类似。</p><p>问题34：如何设置Travis的Flutter版本？</p><p>这个问题来自第42篇文章“<a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/144156">如何构建高效的Flutter App打包发布环境？<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>”。</p><p>设置方式很简单。在before_install字段里，克隆Flutter SDK时，直接指定特定的分支即可：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">git clone -b &#x27;v1.5.4-hotfix.2&#x27; --depth 1 https://github.com/flutter/flutter.git</span></div></pre></div><p>问题35：如何通过反射快速实现插件定义的标准化？</p><p>这个问题来自第44篇文章“<a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/144243">如何构建自己的Flutter混合开发框架（二）？<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>”。</p><p>在Dart层调用不存在的接口（或未实现的接口），可以通过noSuchMethod方法进行统一处理。这个方法会携带一个类型为Invocation的参数invocation，我们可以通过它得到调用的函数名及参数：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">//获取方法名</span></div><div class="token-line"><span class="token plain">    String methodName = invocation.memberName.toString().substring(8, string.length - 2);</span></div><div class="token-line"><span class="token plain">    //获取参数</span></div><div class="token-line"><span class="token plain">    dynamic args = invocation.positionalArguments;</span></div></pre></div><p>其中，参数args是一个List类型的变量，我们可以在原生代码宿主把相关的参数依次解析出来。有了函数名和参数，我们在插件类实例上，就可以利用反射去动态地调用原生方法了。</p><p>与传统的方法调用相比，以反射的方式执行方法调用，其步骤相对繁琐一些，我们需要依次找到并初始化反射调用过程的类示例对象、方法对象、参数列表对象，然后执行反射调用，并根据方法声明获取执行结果。不过这些步骤都是固定的，我们依葫芦画瓢就好。</p><p>Android端的调用方式：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">public void onMethodCall(MethodCall call, Result result) {</span></div><div class="token-line"><span class="token plain">      ...</span></div><div class="token-line"><span class="token plain">      String method = call.argument(&quot;method&quot;); //获取函数名</span></div><div class="token-line"><span class="token plain">      ArrayList params = call.argument(&quot;params&quot;); //获取参数列表</span></div><div class="token-line"><span class="token plain">      Class&lt;?&gt; c = FlutterPluginDemoPlugin.class; //反射施加对象</span></div><div class="token-line"><span class="token plain">      Method m = c.getMethod(method, ArrayList.class); //获取方法对象</span></div><div class="token-line"><span class="token plain">      Object ret = m.invoke(this,params); //在插件实例上调用反射方法，获取返回值</span></div><div class="token-line"><span class="token plain">      result.success(ret); //返回执行结果</span></div><div class="token-line"><span class="token plain">      ...</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>iOS端的调用方式：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">- (void)handleMethodCall:(FlutterMethodCall*)call result:(FlutterResult)result {</span></div><div class="token-line"><span class="token plain">     ...</span></div><div class="token-line"><span class="token plain">      NSArray *arguments = call.arguments[@&quot;params&quot;]; //获取函数名</span></div><div class="token-line"><span class="token plain">      NSString *methodName = call.arguments[@&quot;method&quot;]; //获取参数列表</span></div><div class="token-line"><span class="token plain">      SEL selector = NSSelectorFromString([NSString stringWithFormat:@&quot;%@:&quot;,methodName]); //获取函数对应的Slector</span></div><div class="token-line"><span class="token plain">      NSMethodSignature *signature = [[self class] instanceMethodSignatureForSelector:selector]; //在插件实例上获取方法签名</span></div><div class="token-line"><span class="token plain">      NSInvocation *invocation = [NSInvocation invocationWithMethodSignature:signature]; //通过方法签名生成反射的invocation对象</span></div><div class="token-line"><span class="token plain">            </span></div><div class="token-line"><span class="token plain">      invocation.target = self; //设置invocation的执行对象</span></div><div class="token-line"><span class="token plain">      invocation.selector = selector; //设置invocation的selector     </span></div><div class="token-line"><span class="token plain">      [invocation setArgument:&amp;arguments atIndex:2]; //设置invocation的参数</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">      [invocation invoke]; //执行反射</span></div><div class="token-line"><span class="token plain">            </span></div><div class="token-line"><span class="token plain">      NSObject *ret = nil;</span></div><div class="token-line"><span class="token plain">      if (signature.methodReturnLength) {</span></div><div class="token-line"><span class="token plain">          void *returnValue = nil;</span></div><div class="token-line"><span class="token plain">          [invocation getReturnValue:&amp;returnValue];</span></div><div class="token-line"><span class="token plain">          ret = (__bridge NSObject *)returnValue; //获取反射调用结果</span></div><div class="token-line"><span class="token plain">      }    </span></div><div class="token-line"><span class="token plain">                  </span></div><div class="token-line"><span class="token plain">      result(ret); //返回执行结果</span></div><div class="token-line"><span class="token plain">      ...      </span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>以上，就是“Flutter核心技术与实战”专栏，全部思考题的答案了。你如果还有其他问题的话，欢迎给我留言，我们一起讨论。</p></div><div class="__dumi-default-layout-footer-meta"><a target="_blank" rel="noopener noreferrer" href="https://github.com/GGwujun/blog/edit/master/docs/flutter核心技术与实战/08.特别放送/01.md">在 GitHub 上编辑此页<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a><span data-updated-text="最后更新时间：">5/2/2022 10:56:34</span></div></div></div></div>
	<script>
  window.g_useSSR = true;
  window.g_initialProps = {};
	</script>

    <script>
      (function () {
        if (!location.port) {
          (function (i, s, o, g, r, a, m) {
            i["GoogleAnalyticsObject"] = r;
            (i[r] =
              i[r] ||
              function () {
                (i[r].q = i[r].q || []).push(arguments);
              }),
              (i[r].l = 1 * new Date());
            (a = s.createElement(o)), (m = s.getElementsByTagName(o)[0]);
            a.async = 1;
            a.src = g;
            m.parentNode.insertBefore(a, m);
          })(
            window,
            document,
            "script",
            "//www.google-analytics.com/analytics.js",
            "ga"
          );
          ga("create", "UA-149864185-1", "auto");
          ga("send", "pageview");
        }
      })();
    </script>
    <script src="/blog/umi.js"></script>
  </body>
</html>
