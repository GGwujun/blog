<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no"
    />
    <link rel="shortcut icon" type="image/x-icon" href="/logo.png" />
    <link rel="stylesheet" href="/blog/umi.css" />
    <script>
      window.routerBase = "/blog";
    </script>
    <script>
      //! umi version: 3.5.17
    </script>
    <script>
      !(function () {
        var e = localStorage.getItem("dumi:prefers-color"),
          t = window.matchMedia("(prefers-color-scheme: dark)").matches,
          r = ["light", "dark", "auto"];
        document.documentElement.setAttribute(
          "data-prefers-color",
          e === r[2] ? (t ? r[1] : r[0]) : r.indexOf(e) > -1 ? e : r[0]
        );
      })();
    </script>
    <title>02｜3KU法则：如何找出最优自动化实施截面？</title>
  </head>
  <body>
    <div id="root"><div class="__dumi-default-layout" data-route="/自动化测试高手课/02.活着还是死去-价值篇/02" data-show-sidemenu="true" data-show-slugs="true" data-site-mode="true" data-gapless="false"><div class="__dumi-default-navbar" data-mode="site"><button class="__dumi-default-navbar-toggle"></button><a class="__dumi-default-navbar-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog/">大师兄</a><nav><div class="__dumi-default-search"><input type="search" class="__dumi-default-search-input" value=""/><ul></ul></div><span>计算机基础<ul><li><a href="/blog/编译原理之美">编译原理之美</a></li><li><a href="/blog/编译原理实战">编译原理实战</a></li><li><a href="/blog/深入浅出计算机组成原理">深入浅出计算机组成原理</a></li><li><a href="/blog/详解http">详解http</a></li><li><a href="/blog/计算机网络通关29讲">计算机网络通关29讲</a></li><li><a href="/blog/网络排查案例课">网络排查案例课</a></li><li><a href="/blog/linux操作系统">linux操作系统</a></li><li><a href="/blog/linux性能优化实战">linux性能优化实战</a></li><li><a href="/blog/程序员数学基础">程序员数学基础</a></li><li><a href="/blog/趣谈网络协议">趣谈网络协议</a></li><li><a href="/blog/操作系统实战">操作系统实战</a></li><li><a href="/blog/软件工程之美">软件工程之美</a></li><li><a href="/blog/sql必知必会">sql必知必会</a></li><li><a href="/blog/操作系统实战45讲">操作系统实战45讲</a></li><li><a href="/blog/网络编程实战">网络编程实战</a></li></ul></span><span>算法<ul><li><a href="/blog/常用算法25讲">常用算法25讲</a></li><li><a href="/blog/数据结构与算法之美">数据结构与算法之美</a></li><li><a href="/blog/业务开发算法50讲">业务开发算法50讲</a></li><li><a href="/blog/动态规划面试宝典">动态规划面试宝典</a></li></ul></span><span>前端开发<ul><li><a href="/blog/浏览器工作原理与实践">浏览器工作原理与实践</a></li><li><a href="/blog/新时代产品经理进阶之路">新时代产品经理进阶之路</a></li><li><a href="/blog/全栈工程师修炼指南">全栈工程师修炼指南</a></li><li><a href="/blog/flutter核心技术与实战">flutter核心技术与实战</a></li><li><a href="/blog/java-script核心原理解析">java-script核心原理解析</a></li><li><a href="/blog/说透低代码">说透低代码</a></li><li><a href="/blog/nodejs应用开发实战">nodejs应用开发实战</a></li><li><a href="/blog/反爬虫兵法演绎20讲">反爬虫兵法演绎20讲</a></li><li><a href="/blog/reactnative新架构实战课">reactnative新架构实战课</a></li><li><a href="/blog/正则表达式入门">正则表达式入门</a></li><li><a href="/blog/重学前端">重学前端</a></li><li><a href="/blog/serverless入门课">serverless入门课</a></li><li><a href="/blog/type-script入门实战笔记">type-script入门实战笔记</a></li><li><a href="/blog/图解googlev8">图解googlev8</a></li><li><a href="/blog/vue3源码分析">vue3源码分析</a></li><li><a href="/blog/玩转Vue3全家桶">玩转Vue3全家桶</a></li><li><a href="/blog/webassembly入门">webassembly入门</a></li><li><a href="/blog/手把手带你写一个Web框架">手把手带你写一个Web框架</a></li><li><a href="/blog/web漏洞挖掘实战">web漏洞挖掘实战</a></li><li><a href="/blog/跟月影学可视化">跟月影学可视化</a></li><li><a href="/blog/搞定音频技术">搞定音频技术</a></li><li><a href="/blog/攻克视频技术">攻克视频技术</a></li></ul></span><span>前端工程化<ul><li><a href="/blog/logger">logger</a></li><li><a href="/blog/webpack">webpack</a></li><li><a href="/blog/webpackChain">webpackChain</a></li></ul></span><span>前端性能优化<ul><li><a href="/blog/react性能调优">react性能调优</a></li></ul></span><span>软件测试<ul><li><a href="/blog/全链路压测实战30讲">全链路压测实战30讲</a></li><li><a href="/blog/性能测试实战30讲">性能测试实战30讲</a></li><li><a aria-current="page" class="active" href="/blog/自动化测试高手课">自动化测试高手课</a></li><li><a href="/blog/软件测试52讲">软件测试52讲</a></li></ul></span><span>面试<ul><li><a href="/blog/面试现场">面试现场</a></li></ul></span><span>杂谈<ul><li><a href="/blog/超级访谈对话张雪峰">超级访谈对话张雪峰</a></li><li><a href="/blog/Git实战手册">Git实战手册</a></li><li><a href="/blog/NodeJS">NodeJS</a></li><li><a href="/blog/ReactJS">ReactJS</a></li><li><a href="/blog/UI设计">UI设计</a></li><li><a href="/blog/webpack4系列教程">webpack4系列教程</a></li><li><a href="/blog/前端知识体系">前端知识体系</a></li><li><a href="/blog/剑指offer刷题笔记">剑指offer刷题笔记</a></li><li><a href="/blog/思考与成长">思考与成长</a></li><li><a href="/blog/设计模式手册">设计模式手册</a></li></ul></span><div class="__dumi-default-navbar-tool"><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "></div></div></div></nav></div><div class="__dumi-default-menu" data-mode="site"><div class="__dumi-default-menu-inner"><div class="__dumi-default-menu-header"><a class="__dumi-default-menu-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog/"></a><h1>大师兄</h1><p></p></div><div class="__dumi-default-menu-mobile-area"><ul class="__dumi-default-menu-nav-list"><li>计算机基础<ul><li><a href="/blog/编译原理之美">编译原理之美</a></li><li><a href="/blog/编译原理实战">编译原理实战</a></li><li><a href="/blog/深入浅出计算机组成原理">深入浅出计算机组成原理</a></li><li><a href="/blog/详解http">详解http</a></li><li><a href="/blog/计算机网络通关29讲">计算机网络通关29讲</a></li><li><a href="/blog/网络排查案例课">网络排查案例课</a></li><li><a href="/blog/linux操作系统">linux操作系统</a></li><li><a href="/blog/linux性能优化实战">linux性能优化实战</a></li><li><a href="/blog/程序员数学基础">程序员数学基础</a></li><li><a href="/blog/趣谈网络协议">趣谈网络协议</a></li><li><a href="/blog/操作系统实战">操作系统实战</a></li><li><a href="/blog/软件工程之美">软件工程之美</a></li><li><a href="/blog/sql必知必会">sql必知必会</a></li><li><a href="/blog/操作系统实战45讲">操作系统实战45讲</a></li><li><a href="/blog/网络编程实战">网络编程实战</a></li></ul></li><li>算法<ul><li><a href="/blog/常用算法25讲">常用算法25讲</a></li><li><a href="/blog/数据结构与算法之美">数据结构与算法之美</a></li><li><a href="/blog/业务开发算法50讲">业务开发算法50讲</a></li><li><a href="/blog/动态规划面试宝典">动态规划面试宝典</a></li></ul></li><li>前端开发<ul><li><a href="/blog/浏览器工作原理与实践">浏览器工作原理与实践</a></li><li><a href="/blog/新时代产品经理进阶之路">新时代产品经理进阶之路</a></li><li><a href="/blog/全栈工程师修炼指南">全栈工程师修炼指南</a></li><li><a href="/blog/flutter核心技术与实战">flutter核心技术与实战</a></li><li><a href="/blog/java-script核心原理解析">java-script核心原理解析</a></li><li><a href="/blog/说透低代码">说透低代码</a></li><li><a href="/blog/nodejs应用开发实战">nodejs应用开发实战</a></li><li><a href="/blog/反爬虫兵法演绎20讲">反爬虫兵法演绎20讲</a></li><li><a href="/blog/reactnative新架构实战课">reactnative新架构实战课</a></li><li><a href="/blog/正则表达式入门">正则表达式入门</a></li><li><a href="/blog/重学前端">重学前端</a></li><li><a href="/blog/serverless入门课">serverless入门课</a></li><li><a href="/blog/type-script入门实战笔记">type-script入门实战笔记</a></li><li><a href="/blog/图解googlev8">图解googlev8</a></li><li><a href="/blog/vue3源码分析">vue3源码分析</a></li><li><a href="/blog/玩转Vue3全家桶">玩转Vue3全家桶</a></li><li><a href="/blog/webassembly入门">webassembly入门</a></li><li><a href="/blog/手把手带你写一个Web框架">手把手带你写一个Web框架</a></li><li><a href="/blog/web漏洞挖掘实战">web漏洞挖掘实战</a></li><li><a href="/blog/跟月影学可视化">跟月影学可视化</a></li><li><a href="/blog/搞定音频技术">搞定音频技术</a></li><li><a href="/blog/攻克视频技术">攻克视频技术</a></li></ul></li><li>前端工程化<ul><li><a href="/blog/logger">logger</a></li><li><a href="/blog/webpack">webpack</a></li><li><a href="/blog/webpackChain">webpackChain</a></li></ul></li><li>前端性能优化<ul><li><a href="/blog/react性能调优">react性能调优</a></li></ul></li><li>软件测试<ul><li><a href="/blog/全链路压测实战30讲">全链路压测实战30讲</a></li><li><a href="/blog/性能测试实战30讲">性能测试实战30讲</a></li><li><a aria-current="page" class="active" href="/blog/自动化测试高手课">自动化测试高手课</a></li><li><a href="/blog/软件测试52讲">软件测试52讲</a></li></ul></li><li>面试<ul><li><a href="/blog/面试现场">面试现场</a></li></ul></li><li>杂谈<ul><li><a href="/blog/超级访谈对话张雪峰">超级访谈对话张雪峰</a></li><li><a href="/blog/Git实战手册">Git实战手册</a></li><li><a href="/blog/NodeJS">NodeJS</a></li><li><a href="/blog/ReactJS">ReactJS</a></li><li><a href="/blog/UI设计">UI设计</a></li><li><a href="/blog/webpack4系列教程">webpack4系列教程</a></li><li><a href="/blog/前端知识体系">前端知识体系</a></li><li><a href="/blog/剑指offer刷题笔记">剑指offer刷题笔记</a></li><li><a href="/blog/思考与成长">思考与成长</a></li><li><a href="/blog/设计模式手册">设计模式手册</a></li></ul></li></ul><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "><button title="Dark theme" class="__dumi-default-dark-moon "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="3854" width="22" height="22"><path d="M991.816611 674.909091a69.166545 69.166545 0 0 0-51.665455-23.272727 70.795636 70.795636 0 0 0-27.438545 5.585454A415.674182 415.674182 0 0 1 754.993338 698.181818c-209.594182 0-393.472-184.785455-393.472-395.636363 0-52.363636 38.539636-119.621818 69.515637-173.614546 4.887273-8.610909 9.634909-16.756364 14.103272-24.901818A69.818182 69.818182 0 0 0 384.631156 0a70.842182 70.842182 0 0 0-27.438545 5.585455C161.678429 90.298182 14.362065 307.898182 14.362065 512c0 282.298182 238.824727 512 532.38691 512a522.286545 522.286545 0 0 0 453.957818-268.334545A69.818182 69.818182 0 0 0 991.816611 674.909091zM546.679156 954.181818c-248.785455 0-462.941091-192-462.941091-442.181818 0-186.647273 140.637091-372.829091 300.939637-442.181818-36.817455 65.629091-92.578909 151.970909-92.578909 232.727273 0 250.181818 214.109091 465.454545 462.917818 465.454545a488.331636 488.331636 0 0 0 185.181091-46.545455 453.003636 453.003636 0 0 1-393.565091 232.727273z m103.656728-669.323636l-14.266182 83.781818a34.909091 34.909091 0 0 0 50.362182 36.770909l74.775272-39.563636 74.752 39.563636a36.142545 36.142545 0 0 0 16.174546 3.956364 34.909091 34.909091 0 0 0 34.210909-40.727273l-14.289455-83.781818 60.509091-59.345455a35.025455 35.025455 0 0 0-19.223272-59.578182l-83.61891-12.101818-37.376-76.101818a34.56 34.56 0 0 0-62.254545 0l-37.376 76.101818-83.618909 12.101818a34.909091 34.909091 0 0 0-19.246546 59.578182z m70.423272-64.698182a34.280727 34.280727 0 0 0 26.135273-19.083636l14.312727-29.090909 14.336 29.090909a34.257455 34.257455 0 0 0 26.135273 19.083636l32.046546 4.887273-23.272728 22.574545a35.234909 35.234909 0 0 0-10.007272 30.952727l5.46909 32.116364-28.625454-15.127273a34.490182 34.490182 0 0 0-32.302546 0l-28.695272 15.127273 5.469091-32.116364a35.141818 35.141818 0 0 0-9.984-30.952727l-23.272728-22.574545z" p-id="3855"></path></svg></button><button title="Light theme" class="__dumi-default-dark-sun "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="4026" width="22" height="22"><path d="M915.2 476.16h-43.968c-24.704 0-44.736 16-44.736 35.84s20.032 35.904 44.736 35.904H915.2c24.768 0 44.8-16.064 44.8-35.904s-20.032-35.84-44.8-35.84zM512 265.6c-136.704 0-246.464 109.824-246.464 246.4 0 136.704 109.76 246.464 246.464 246.464S758.4 648.704 758.4 512c0-136.576-109.696-246.4-246.4-246.4z m0 425.6c-99.008 0-179.2-80.128-179.2-179.2 0-98.944 80.192-179.2 179.2-179.2S691.2 413.056 691.2 512c0 99.072-80.192 179.2-179.2 179.2zM197.44 512c0-19.84-19.136-35.84-43.904-35.84H108.8c-24.768 0-44.8 16-44.8 35.84s20.032 35.904 44.8 35.904h44.736c24.768 0 43.904-16.064 43.904-35.904zM512 198.464c19.776 0 35.84-20.032 35.84-44.8v-44.8C547.84 84.032 531.84 64 512 64s-35.904 20.032-35.904 44.8v44.8c0 24.768 16.128 44.864 35.904 44.864z m0 627.136c-19.776 0-35.904 20.032-35.904 44.8v44.736C476.096 940.032 492.16 960 512 960s35.84-20.032 35.84-44.8v-44.736c0-24.768-16.064-44.864-35.84-44.864z m329.92-592.832c17.472-17.536 20.288-43.072 6.4-57.024-14.016-14.016-39.488-11.2-57.024 6.336-4.736 4.864-26.496 26.496-31.36 31.36-17.472 17.472-20.288 43.008-6.336 57.024 13.952 14.016 39.488 11.2 57.024-6.336 4.8-4.864 26.496-26.56 31.296-31.36zM213.376 759.936c-4.864 4.8-26.56 26.624-31.36 31.36-17.472 17.472-20.288 42.944-6.4 56.96 14.016 13.952 39.552 11.2 57.024-6.336 4.8-4.736 26.56-26.496 31.36-31.36 17.472-17.472 20.288-43.008 6.336-56.96-14.016-13.952-39.552-11.072-56.96 6.336z m19.328-577.92c-17.536-17.536-43.008-20.352-57.024-6.336-14.08 14.016-11.136 39.488 6.336 57.024 4.864 4.864 26.496 26.56 31.36 31.424 17.536 17.408 43.008 20.288 56.96 6.336 14.016-14.016 11.264-39.488-6.336-57.024-4.736-4.864-26.496-26.56-31.296-31.424z m527.168 628.608c4.864 4.864 26.624 26.624 31.36 31.424 17.536 17.408 43.072 20.224 57.088 6.336 13.952-14.016 11.072-39.552-6.4-57.024-4.864-4.8-26.56-26.496-31.36-31.36-17.472-17.408-43.072-20.288-57.024-6.336-13.952 14.016-11.008 39.488 6.336 56.96z" p-id="4027"></path></svg></button><button title="Default to system" class="__dumi-default-dark-auto "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="11002" width="22" height="22"><path d="M127.658667 492.885333c0-51.882667 10.24-101.717333 30.378666-149.162666s47.786667-88.064 81.92-122.538667 75.093333-61.781333 122.538667-81.92 96.938667-30.378667 149.162667-30.378667 101.717333 10.24 149.162666 30.378667 88.405333 47.786667 122.88 81.92 61.781333 75.093333 81.92 122.538667 30.378667 96.938667 30.378667 149.162666-10.24 101.717333-30.378667 149.162667-47.786667 88.405333-81.92 122.88-75.093333 61.781333-122.88 81.92-97.28 30.378667-149.162666 30.378667-101.717333-10.24-149.162667-30.378667-88.064-47.786667-122.538667-81.92-61.781333-75.093333-81.92-122.88-30.378667-96.938667-30.378666-149.162667z m329.045333 0c0 130.048 13.994667 244.394667 41.984 343.381334h12.970667c46.762667 0 91.136-9.216 133.461333-27.306667s78.848-42.666667 109.568-73.386667 54.954667-67.242667 73.386667-109.568 27.306667-86.698667 27.306666-133.461333c0-46.421333-9.216-90.794667-27.306666-133.12s-42.666667-78.848-73.386667-109.568-67.242667-54.954667-109.568-73.386667-86.698667-27.306667-133.461333-27.306666h-11.605334c-28.672 123.562667-43.349333 237.909333-43.349333 343.722666z" p-id="11003"></path></svg></button></div></div></div><ul class="__dumi-default-menu-list"><li><a href="/blog/自动化测试高手课">自动化测试高手课</a></li><li><a href="/blog/自动化测试高手课/01.开篇词">01.开篇词</a><ul><li><a href="/blog/自动化测试高手课/01.开篇词/01"><span>开篇词 | 做性价比最高的自动化测试</span></a></li></ul></li><li><a aria-current="page" class="active" href="/blog/自动化测试高手课/02.活着还是死去-价值篇">02.活着还是死去-价值篇</a><ul><li><a href="/blog/自动化测试高手课/02.活着还是死去-价值篇/01"><span>01｜ROI价值内核：自动化测试的价值可以量化么？</span></a></li><li><a aria-current="page" class="active" href="/blog/自动化测试高手课/02.活着还是死去-价值篇/02"><span>02｜3KU法则：如何找出最优自动化实施截面？</span></a></li><li><a href="/blog/自动化测试高手课/02.活着还是死去-价值篇/03"><span>03｜工具选择：什么工具框架值得用？</span></a></li><li><a href="/blog/自动化测试高手课/02.活着还是死去-价值篇/04"><span>04｜脚本复用：什么样的代码才值得写？</span></a></li><li><a href="/blog/自动化测试高手课/02.活着还是死去-价值篇/05"><span>05｜Auto Gen Auto：所有测试工作即代码</span></a></li><li><a href="/blog/自动化测试高手课/02.活着还是死去-价值篇/06"><span>06｜左移&amp;右移：测试如何在Dev和Ops领域大展身手？</span></a></li></ul></li><li><a href="/blog/自动化测试高手课/03.大开也能大合-策略篇">03.大开也能大合-策略篇</a><ul><li><a href="/blog/自动化测试高手课/03.大开也能大合-策略篇/01"><span>07｜需求提炼（一）：单体应用要测什么？</span></a></li><li><a href="/blog/自动化测试高手课/03.大开也能大合-策略篇/02"><span>08｜需求提炼（二）：微服务集群要测什么？</span></a></li><li><a href="/blog/自动化测试高手课/03.大开也能大合-策略篇/03"><span>09｜3KU法则：为一个订餐系统设计全栈测试方案</span></a></li><li><a href="/blog/自动化测试高手课/03.大开也能大合-策略篇/04"><span>10｜单元测试（一）：原来测试可以这么高效</span></a></li><li><a href="/blog/自动化测试高手课/03.大开也能大合-策略篇/05"><span>11｜单元测试（二）：四象限法让你的单测火力全开</span></a></li><li><a href="/blog/自动化测试高手课/03.大开也能大合-策略篇/06"><span>12｜集成测试（一）：一条Happy Path扫天下</span></a></li><li><a href="/blog/自动化测试高手课/03.大开也能大合-策略篇/07"><span>13｜集成测试（二）：携手开发，集测省力又省心</span></a></li><li><a href="/blog/自动化测试高手课/03.大开也能大合-策略篇/08"><span>14｜集成测试（三）：护航微服务集群迭代升级</span></a></li><li><a href="/blog/自动化测试高手课/03.大开也能大合-策略篇/09"><span>15｜UI测试：如何让UI测试更轻快便捷？</span></a></li><li><a href="/blog/自动化测试高手课/03.大开也能大合-策略篇/10"><span>16｜概念重识：如何用3KU为端到端&amp;验收测试赋能？</span></a></li></ul></li><li><a href="/blog/自动化测试高手课/04.优化还是腐化-设计篇">04.优化还是腐化-设计篇</a><ul><li><a href="/blog/自动化测试高手课/04.优化还是腐化-设计篇/01"><span>17｜元数据模型（一）：小Job模型构建大蓝图</span></a></li><li><a href="/blog/自动化测试高手课/04.优化还是腐化-设计篇/02"><span>18｜元数据模型（二）：小Job模型构建大蓝图</span></a></li></ul></li><li><a href="/blog/自动化测试高手课/summary">自动化测试高手课</a></li></ul></div></div><ul role="slug-list" class="__dumi-default-layout-toc"><li title="测试ROI金字塔" data-depth="2"><a href="/blog/自动化测试高手课/02.活着还是死去-价值篇/02#测试roi金字塔"><span>测试ROI金字塔</span></a></li><li title="寻找最优ROI策略" data-depth="2"><a href="/blog/自动化测试高手课/02.活着还是死去-价值篇/02#寻找最优roi策略"><span>寻找最优ROI策略</span></a></li><li title="分层测试为啥会“内卷”" data-depth="3"><a href="/blog/自动化测试高手课/02.活着还是死去-价值篇/02#分层测试为啥会内卷"><span>分层测试为啥会“内卷”</span></a></li><li title="需求/策略矩阵" data-depth="3"><a href="/blog/自动化测试高手课/02.活着还是死去-价值篇/02#需求策略矩阵"><span>需求/策略矩阵</span></a></li><li title="3KU整体策略" data-depth="3"><a href="/blog/自动化测试高手课/02.活着还是死去-价值篇/02#3ku整体策略"><span>3KU整体策略</span></a></li><li title="小结" data-depth="2"><a href="/blog/自动化测试高手课/02.活着还是死去-价值篇/02#小结"><span>小结</span></a></li><li title="思考题" data-depth="2"><a href="/blog/自动化测试高手课/02.活着还是死去-价值篇/02#思考题"><span>思考题</span></a></li></ul><div class="__dumi-default-layout-content"><div class="markdown"><h1 id="023ku法则如何找出最优自动化实施截面"><a aria-hidden="true" tabindex="-1" href="/blog/自动化测试高手课/02.活着还是死去-价值篇/02#023ku法则如何找出最优自动化实施截面"><span class="icon icon-link"></span></a>02｜3KU法则：如何找出最优自动化实施截面？</h1><p>你好，我是柳胜。</p><p>上一讲我们提出了自动化测试ROI模型，在回归测试中的应用。回归测试是一个笼统的概念，单元测试、接口测试以及UI测试里都有回归测试，甚至性能测试也已经成为回归测试的一部分。</p><p>今天我们要关注一个具体场景，给你一个软件系统，作为自动化测试人员，你怎么找出测试截面，制定自动化测试方案？这些事可能你都做过，觉得并不稀奇，但既然我们已经学习了ROI思维，今天要再加上一个小目标，<strong>制定策略，能够让这个自动化测试设计获得尽可能大的ROI</strong>。换句话说，能干还不够，还要干得好，既要马儿跑，又要马儿少吃草。</p><p>有挑战不？那就跟我进入这一讲的学习，一起找到最佳策略吧。</p><h2 id="测试roi金字塔"><a aria-hidden="true" tabindex="-1" href="/blog/自动化测试高手课/02.活着还是死去-价值篇/02#测试roi金字塔"><span class="icon icon-link"></span></a>测试ROI金字塔</h2><p>在测试设计领域，经常提到的方法是分层。具体就是给定一个系统，结构上划分三个层级，单元在最小圈；服务包含多个单元，在中圈；而系统又包含多个服务，是外部的最大圈。结构图如下：</p><p><img src="https://static001.geekbang.org/resource/image/77/c3/7713a7081ac2723a2cfc35d3277b21c3.jpg?wh=1920x1050" alt="图片" title="软件结构圈图"/></p><p>相应地，我们的测试结构是在代码层做单元测试，服务层做接口测试，系统层做UI功能测试。</p><p>在实践中，这三种测试该怎么组合安排呢？迈克·科恩在2009年他的新书《敏捷成功之道》中首次提出了测试金字塔模型。单元测试自动化在金字塔底部，接口测试自动化在中部，而UI测试自动化在金字塔顶部。</p><p><img src="https://static001.geekbang.org/resource/image/bd/68/bdyy34691cc7a36c8e50f13e3bbaca68.jpg?wh=1920x1050" alt="图片" title="分层测试金字塔"/></p><p>迈克·科恩讲到自动化测试工作量配比时，认为应该按照层面积分配。也就是说，单元测试案例的数目应该多于接口测试案例数目，接口测试案例数目应该多于UI测试自动化测试案例数目。</p><p>后来，金字塔模型又被业界发展，赋予了不同的测试策略，比如自底向上执行速度减慢，自顶向下业务属性减弱，技术属性增强。</p><p>但迈克·科恩没有解释，为什么各层工作量配比要按照测试金字塔分布？按照软件结构图，系统在最大圈，测试案例应该最多，而到了自动化测试金字塔，UI自动化测试案例却最少；单元测试在小圈，测试案例应该最少，但到了自动化测试金字塔，单元测试案例却最多。</p><p>为什么是金字塔？要是不去理解规律背后这个“为什么”，你就用不好这个规律。上一讲我们知道了“ROI其实是自动化测试的隐式命脉”，现在我们就利用ROI思维，分析一下测试金字塔规律。</p><p><img src="https://static001.geekbang.org/resource/image/cd/00/cd34280bc70b3633e696a7ba16f9e300.jpg?wh=1920x868" alt="图片" title="ROI公式"/></p><p>下面，我们分别看看每层的ROI。单元测试可以在开发人员每次code commit触发运行，回归频率高；接口测试在每轮集成测试运行，回归频率中；UI自动化测试在用户验收测试，回归频率低。</p><p>按照ROI模型，我们可以得出3种类型自动化测试的ROI排序，如下表：</p><p><img src="https://static001.geekbang.org/resource/image/71/08/713a743c26347d08d561d5a77ab27608.jpg?wh=3363x1379" alt=""/></p><p>对照测试金字塔不难发现，实际上三类自动化测试的ROI是自底向上由高到低的。</p><p><img src="https://static001.geekbang.org/resource/image/7e/af/7ebe91f53e1fc7a84e53a26d68c4baaf.jpg?wh=1920x1050" alt="图片" title="分层测试ROI金字塔"/></p><p>按照第一讲得出的规律“自动化测试顺序从ROI高到低”，我们优先投入精力做ROI最高的单元测试，再做ROI中的接口测试，最后完成UI测试。</p><p>现在就可以轻松解释迈克·科恩的金字塔了，因为ROI存在差异，所以按照高ROI大投入，中ROI中投入，低ROI小投入，工作量比例呈金字塔分布，底层面积最大，顶层面积最小。发现没？<strong>根源在于ROI，金字塔是表现出来的形态而已</strong>。</p><p>好，到这里，总结一下。各种软件理论学派，大致可以分为两种，一种是理论基础，讲的是做什么，比如软件测试定义、软件过程，另外一种是实践经验，讲的是该怎么做，比如金字塔模型。</p><p>实践和理论很大的不同就是在现实商业中，我们不可能完全按照理想来工作，而是要加入很多制约因素，其中最大的制约就是钱。明白这个道理，你就会知道为什么ROI是根源，你也会知道怎么能够在工作中做出业绩了，不是耍两个工具，忽悠一下领导就算成功，而是认认真真地去思考，踏踏实实地去提高ROI，直到边际效应ROI无法提高为止。</p><h2 id="寻找最优roi策略"><a aria-hidden="true" tabindex="-1" href="/blog/自动化测试高手课/02.活着还是死去-价值篇/02#寻找最优roi策略"><span class="icon icon-link"></span></a>寻找最优ROI策略</h2><p>刚才说了分层测试和各层ROI，业界也很认可这种分层理论，但实际落地时却存在问题：一批人做UI测试自动化，另外一批人去做接口测试，然后开发人员做单元测试。三路人马忙得不亦乐乎，都说自己贡献大，等到bug发生了泄漏到生产环境，又开始甩锅。</p><h3 id="分层测试为啥会内卷"><a aria-hidden="true" tabindex="-1" href="/blog/自动化测试高手课/02.活着还是死去-价值篇/02#分层测试为啥会内卷"><span class="icon icon-link"></span></a>分层测试为啥会“内卷”</h3><p>很明显，这是一个内卷的场景，让我们结合例子具体看看内卷发生在哪里？</p><p>以一个Web登录操作为例，用户在UI上输入用户名和密码，点击“登录”按钮。Selenium UI 自动化会这样实现：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">@Test</span></div><div class="token-line"><span class="token plain">    public void login() {</span></div><div class="token-line"><span class="token plain">      WebDriver driver=new ChromeDriver();</span></div><div class="token-line"><span class="token plain">      driver.manage().window().maximize();</span></div><div class="token-line"><span class="token plain">      //打开页面</span></div><div class="token-line"><span class="token plain">      driver.get(&quot;https://www.example.com/users/sign_in&quot;);</span></div><div class="token-line"><span class="token plain">      WebElement username=driver.findElement(By.id(&quot;user_email_Login&quot;));</span></div><div class="token-line"><span class="token plain">      WebElement password=driver.findElement(By.id(&quot;user_password&quot;));</span></div><div class="token-line"><span class="token plain">      WebElement login=driver.findElement(By.name(&quot;login&quot;));</span></div><div class="token-line"><span class="token plain">      //输入用户名</span></div><div class="token-line"><span class="token plain">      username.sendKeys(&quot;liusheng@example.com&quot;);</span></div><div class="token-line"><span class="token plain">      //输入密码</span></div><div class="token-line"><span class="token plain">      password.sendKeys(&quot;123456&quot;);</span></div><div class="token-line"><span class="token plain">      //点击登录按钮</span></div><div class="token-line"><span class="token plain">      login.click();</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>上面UI的操作被Web服务转化成Rest请求，进入到API网关，是这样的：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">curl --location --request POST &#x27;http://auth.example.com/auth/realms/Test/users&#x27; \</span></div><div class="token-line"><span class="token plain">    --header &#x27;Content-Type: application/x-www-form-urlencoded&#x27; \</span></div><div class="token-line"><span class="token plain">    --header &#x27;username=liusheng@example.com&#x27; \</span></div><div class="token-line"><span class="token plain">    --header &#x27;password=123456&#x27;</span></div></pre></div><p>在单元上执行的则是这样的代码：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">public Future&lt;ResponseData&gt; login(String userName, String password) {</span></div><div class="token-line"><span class="token plain">        //入口参数检验</span></div><div class="token-line"><span class="token plain">        if (StringUtil.isBlank(userName)||StringUtil.isBlank(password)){</span></div><div class="token-line"><span class="token plain">          return new AsyncResult&lt;&gt;(ResponseData.error(&quot;账号密码不能为空&quot;));</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        //查询用户是否存在</span></div><div class="token-line"><span class="token plain">        List&lt;User&gt; userList = baseMapper.getUserInfo(userName);</span></div><div class="token-line"><span class="token plain">        if (CollectionUtils.isEmpty(userList)){</span></div><div class="token-line"><span class="token plain">            return new AsyncResult&lt;&gt;(ResponseData.error(&quot;账号不存在&quot;));</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        //验证账号密码是否正确</span></div><div class="token-line"><span class="token plain">        User user = userList.get(0);</span></div><div class="token-line"><span class="token plain">        String requestMd5 = SaltUtil.md5Encrypt(password, user.getSalt());</span></div><div class="token-line"><span class="token plain">        String dbMd5 = user.getPassword();</span></div><div class="token-line"><span class="token plain">        if (dbMd5 == null || !dbMd5.equalsIgnoreCase(requestMd5)) {</span></div><div class="token-line"><span class="token plain">            return new AsyncResult&lt;&gt;(ResponseData.error(&quot;账户密码不正确&quot;));</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        //生成 access token，并返回</span></div><div class="token-line"><span class="token plain">        String token = JwtTokenUtil.generateToken(user);</span></div><div class="token-line"><span class="token plain">        return new (ResponseData.success(token));</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>可以看到，一个请求，从浏览器页面发起，进入API网关，再传递到服务里的Login函数，经过了UI测试、API测试和单元测试三个测试截面。</p><p><img src="https://static001.geekbang.org/resource/image/0a/ce/0a1af39ca343083b14fe1472c5610cce.jpg?wh=1920x1045" alt="图片" title="三个测试截面示意图"/></p><p>三个测试截面测的是一个请求在不同层面上的形态，那么每一个截面都可以测试全部的案例，也可以测试部分的案例。就像3个人负责1个项目一样，如果没有经过事先的协调和安排，3个人可能做了重复的事情，造成浪费，也可能存在一件事3个人都没干，形成测试盲区。</p><h3 id="需求策略矩阵"><a aria-hidden="true" tabindex="-1" href="/blog/自动化测试高手课/02.活着还是死去-价值篇/02#需求策略矩阵"><span class="icon icon-link"></span></a>需求/策略矩阵</h3><p>这种“内卷”是不是一个问题？可能你会说没问题，各层独立测试能够加强质量保障。说这话的底气在于测试上的投入充足，不计内卷成本。实际上，在DevOps风行的今天，趋势是追求效果和效率。所以，在资源有限的条件下，我们需要在整体上看待分层测试的最优ROI。</p><p>咱们先看看测试需求是什么，用 <a target="_blank" rel="noopener noreferrer" href="https://zh.wikipedia.org/wiki/FURPS">FURPS模型<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>来理一下需求。FURPS是用5个维度来描述一个软件的功能需求，FURPS这个单词对应着每个需求的英文首字母：</p><ul><li>F=Function 功能</li><li>U=Usability 易用性</li><li>R=Reliability 可靠性</li><li>P=Performance 性能</li><li>S=Supportability 可支持性</li></ul><p>把测试需求和测试类型组合在一起，就整合了后面这个矩阵表格：</p><p><img src="https://static001.geekbang.org/resource/image/44/21/443b6845a599a19d27704a3f89b44b21.jpg?wh=4000x1410" alt="" title="3KU测试矩阵"/></p><p>结合表格，可以看到UI测试、接口测试和单元测试每个截面的测试能力。</p><ul><li>在UI层面上，功能性最强，所有测试需求都可以做。这个可以理解，因为软件本身就是满足用户需求，没有一个需求不可以从用户层面感受到。如果真的存在一个需求，用户却无法体验到，那根据<a target="_blank" rel="noopener noreferrer" href="https://zh.wikipedia.org/wiki/%E5%A5%A5%E5%8D%A1%E5%A7%86%E5%89%83%E5%88%80">奥卡姆剃须刀原理<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>，这种用户无法体验到的需求就是无效的。</li><li>接口层面上，功能性减弱，技术性增强。</li><li>单元层面上，技术性最强，功能性主要体现在数据的处理，算法逻辑上。</li></ul><h3 id="3ku整体策略"><a aria-hidden="true" tabindex="-1" href="/blog/自动化测试高手课/02.活着还是死去-价值篇/02#3ku整体策略"><span class="icon icon-link"></span></a>3KU整体策略</h3><p>好，有了需求/策略矩阵后，结合上面讲到的自动化测试ROI金字塔，我们的整体最优ROI策略就呼之欲出了。什么是整体最优ROI呢？</p><p>有3个Key（关键因素）：</p><ul><li><strong>U</strong>seful: 每个测试需求都是有效的；</li><li><strong>U</strong>ltimate: 每个测试需求的验证都在优先寻找自动化ROI高的层面去实现，如果不可行，按照ROI高到低回退，直到UI层；</li><li><strong>U</strong>nique: 每个层面上验证的测试需求都和别的层面都不是重复的。<br/>这样分配的工作，既不重复，又没遗漏，还遵循了ROI的原则。我管它叫<strong>3KU原则。</strong></li></ul><p><img src="https://static001.geekbang.org/resource/image/7e/af/7ebe91f53e1fc7a84e53a26d68c4baaf.jpg?wh=1920x1050" alt="图片" title="3KU测试金字塔"/></p><p>3KU策略该怎么执行呢?按照3KU策略，我们把表格里的测试需求，对照下面这三个问题，按顺序检查一遍：</p><p>1.能在单元测试验证么？<br/>2.能在接口测试验证么？<br/>3.能在UI测试验证么？</p><p>这样检查以后，就能得出各个需求的自动化实现截面了。</p><p>UI测试关注功能场景测试，易用性测试和可执行性测试；而接口测试关注不同数据的循环，接口的性能和错误恢复能力；单元测试关注算法的正确性和性能。</p><p>恭喜你看到这里，最后就是我们收割成果的环节了。我们又得出了一个满足3KU原则的自动化测试实施金字塔，各层有自己的关注点，又在整体上实现了互相配合补偿。</p><p><img src="https://static001.geekbang.org/resource/image/95/a7/950bdb1892c70d0598cd0657e2ca92a7.jpg?wh=1920x1064" alt="图片" title="3KU测试金字塔"/></p><p>在3KU测试金字塔下，每一个测试需求都会选择最大的ROI测试截面，通过这样的安排，实现了整体最优ROI的目标。对不对？</p><h2 id="小结"><a aria-hidden="true" tabindex="-1" href="/blog/自动化测试高手课/02.活着还是死去-价值篇/02#小结"><span class="icon icon-link"></span></a>小结</h2><p>这一讲，我们从ROI角度分析了一下分层测试的原理和在实践中的应用。先入为主地，分层理论上的分层测试的特性，必然会造成重叠和错失。这给测试从业者带来了挑战。但挑战也是机会，如何解决这个问题？</p><p>这就需要我们遵循回归到效益的原则，思考怎么用最少的资源干最多的事，能达到这个效果，就是好的实践。因此，我们提出了分层但协调实现整体最优ROI的解决方案，3KU测试矩阵和3KU测试金字塔。</p><p><img src="https://static001.geekbang.org/resource/image/44/21/443b6845a599a19d27704a3f89b44b21.jpg?wh=4000x1410" alt="" title="3KU测试矩阵"/></p><p><img src="https://static001.geekbang.org/resource/image/95/a7/950bdb1892c70d0598cd0657e2ca92a7.jpg?wh=1920x1064" alt="图片" title="3KU测试金字塔"/></p><p>沿着这个思路，各层做好自己具有优势能力的测试需求，比起全部需求系于端到端的测试上，更有效率和效益，<strong>分层是追求整体ROI的结果</strong>。之后的课程里我们还会反复提到ROI，最后你也会不由感叹，ROI是背后无形的大手，大道无形，无处不在。</p><h2 id="思考题"><a aria-hidden="true" tabindex="-1" href="/blog/自动化测试高手课/02.活着还是死去-价值篇/02#思考题"><span class="icon icon-link"></span></a>思考题</h2><p>1 软件大师马丁·福勒曾经说过：“在微服务时代，分层测试不再呈现金字塔形状。”这是为什么？试着用ROI来解释一下。</p><p>2 学完今天的内容，如果你是测试主管，你希望你的团队是全栈（一个人负责一个模块的所有层面测试），还是精细分工（一个人负责所有模块的一个层面测试）？有什么优劣?</p><p>欢迎你在留言区跟我交流互动，如果这一讲对你有启发，也推荐你分享给身边更多同事和朋友。</p></div><div class="__dumi-default-layout-footer-meta"><a target="_blank" rel="noopener noreferrer" href="https://github.com/GGwujun/blog/edit/master/docs/自动化测试高手课/02.活着还是死去-价值篇/02.md">在 GitHub 上编辑此页<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a><span data-updated-text="最后更新时间：">5/2/2022 10:57:10</span></div></div></div></div>
	<script>
  window.g_useSSR = true;
  window.g_initialProps = {};
	</script>

    <script>
      (function () {
        if (!location.port) {
          (function (i, s, o, g, r, a, m) {
            i["GoogleAnalyticsObject"] = r;
            (i[r] =
              i[r] ||
              function () {
                (i[r].q = i[r].q || []).push(arguments);
              }),
              (i[r].l = 1 * new Date());
            (a = s.createElement(o)), (m = s.getElementsByTagName(o)[0]);
            a.async = 1;
            a.src = g;
            m.parentNode.insertBefore(a, m);
          })(
            window,
            document,
            "script",
            "//www.google-analytics.com/analytics.js",
            "ga"
          );
          ga("create", "UA-149864185-1", "auto");
          ga("send", "pageview");
        }
      })();
    </script>
    <script src="/blog/umi.js"></script>
  </body>
</html>
