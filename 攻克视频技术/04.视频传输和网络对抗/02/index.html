<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no"
    />
    <link rel="shortcut icon" type="image/x-icon" href="/logo.png" />
    <link rel="stylesheet" href="/blog/umi.css" />
    <script>
      window.routerBase = "/blog";
    </script>
    <script>
      //! umi version: 3.5.17
    </script>
    <script>
      !(function () {
        var e = localStorage.getItem("dumi:prefers-color"),
          t = window.matchMedia("(prefers-color-scheme: dark)").matches,
          r = ["light", "dark", "auto"];
        document.documentElement.setAttribute(
          "data-prefers-color",
          e === r[2] ? (t ? r[1] : r[0]) : r.indexOf(e) > -1 ? e : r[0]
        );
      })();
    </script>
    <title>10｜带宽预测：3大算法准确预估网络带宽</title>
  </head>
  <body>
    <div id="root"><div class="__dumi-default-layout" data-route="/攻克视频技术/04.视频传输和网络对抗/02" data-show-sidemenu="true" data-show-slugs="true" data-site-mode="true" data-gapless="false"><div class="__dumi-default-navbar" data-mode="site"><button class="__dumi-default-navbar-toggle"></button><a class="__dumi-default-navbar-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog/">大师兄</a><nav><div class="__dumi-default-search"><input type="search" class="__dumi-default-search-input" value=""/><ul></ul></div><span>计算机基础<ul><li><a href="/blog/编译原理之美">编译原理之美</a></li><li><a href="/blog/编译原理实战">编译原理实战</a></li><li><a href="/blog/深入浅出计算机组成原理">深入浅出计算机组成原理</a></li><li><a href="/blog/详解http">详解http</a></li><li><a href="/blog/计算机网络通关29讲">计算机网络通关29讲</a></li><li><a href="/blog/网络排查案例课">网络排查案例课</a></li><li><a href="/blog/linux操作系统">linux操作系统</a></li><li><a href="/blog/linux性能优化实战">linux性能优化实战</a></li><li><a href="/blog/程序员数学基础">程序员数学基础</a></li><li><a href="/blog/趣谈网络协议">趣谈网络协议</a></li><li><a href="/blog/操作系统实战">操作系统实战</a></li><li><a href="/blog/软件工程之美">软件工程之美</a></li><li><a href="/blog/sql必知必会">sql必知必会</a></li><li><a href="/blog/操作系统实战45讲">操作系统实战45讲</a></li><li><a href="/blog/网络编程实战">网络编程实战</a></li></ul></span><span>算法<ul><li><a href="/blog/常用算法25讲">常用算法25讲</a></li><li><a href="/blog/数据结构与算法之美">数据结构与算法之美</a></li><li><a href="/blog/业务开发算法50讲">业务开发算法50讲</a></li><li><a href="/blog/动态规划面试宝典">动态规划面试宝典</a></li></ul></span><span>前端开发<ul><li><a href="/blog/浏览器工作原理与实践">浏览器工作原理与实践</a></li><li><a href="/blog/新时代产品经理进阶之路">新时代产品经理进阶之路</a></li><li><a href="/blog/全栈工程师修炼指南">全栈工程师修炼指南</a></li><li><a href="/blog/flutter核心技术与实战">flutter核心技术与实战</a></li><li><a href="/blog/java-script核心原理解析">java-script核心原理解析</a></li><li><a href="/blog/说透低代码">说透低代码</a></li><li><a href="/blog/nodejs应用开发实战">nodejs应用开发实战</a></li><li><a href="/blog/反爬虫兵法演绎20讲">反爬虫兵法演绎20讲</a></li><li><a href="/blog/reactnative新架构实战课">reactnative新架构实战课</a></li><li><a href="/blog/正则表达式入门">正则表达式入门</a></li><li><a href="/blog/重学前端">重学前端</a></li><li><a href="/blog/serverless入门课">serverless入门课</a></li><li><a href="/blog/type-script入门实战笔记">type-script入门实战笔记</a></li><li><a href="/blog/图解googlev8">图解googlev8</a></li><li><a href="/blog/vue3源码分析">vue3源码分析</a></li><li><a href="/blog/玩转Vue3全家桶">玩转Vue3全家桶</a></li><li><a href="/blog/webassembly入门">webassembly入门</a></li><li><a href="/blog/手把手带你写一个Web框架">手把手带你写一个Web框架</a></li><li><a href="/blog/web漏洞挖掘实战">web漏洞挖掘实战</a></li><li><a href="/blog/跟月影学可视化">跟月影学可视化</a></li><li><a href="/blog/搞定音频技术">搞定音频技术</a></li><li><a aria-current="page" class="active" href="/blog/攻克视频技术">攻克视频技术</a></li></ul></span><span>前端工程化<ul><li><a href="/blog/logger">logger</a></li><li><a href="/blog/webpack">webpack</a></li><li><a href="/blog/webpackChain">webpackChain</a></li></ul></span><span>前端性能优化<ul><li><a href="/blog/react性能调优">react性能调优</a></li></ul></span><span>软件测试<ul><li><a href="/blog/全链路压测实战30讲">全链路压测实战30讲</a></li><li><a href="/blog/性能测试实战30讲">性能测试实战30讲</a></li><li><a href="/blog/自动化测试高手课">自动化测试高手课</a></li><li><a href="/blog/软件测试52讲">软件测试52讲</a></li></ul></span><span>面试<ul><li><a href="/blog/面试现场">面试现场</a></li></ul></span><span>杂谈<ul><li><a href="/blog/超级访谈对话张雪峰">超级访谈对话张雪峰</a></li><li><a href="/blog/Git实战手册">Git实战手册</a></li><li><a href="/blog/NodeJS">NodeJS</a></li><li><a href="/blog/ReactJS">ReactJS</a></li><li><a href="/blog/UI设计">UI设计</a></li><li><a href="/blog/webpack4系列教程">webpack4系列教程</a></li><li><a href="/blog/前端知识体系">前端知识体系</a></li><li><a href="/blog/剑指offer刷题笔记">剑指offer刷题笔记</a></li><li><a href="/blog/思考与成长">思考与成长</a></li><li><a href="/blog/设计模式手册">设计模式手册</a></li></ul></span><div class="__dumi-default-navbar-tool"><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "></div></div></div></nav></div><div class="__dumi-default-menu" data-mode="site"><div class="__dumi-default-menu-inner"><div class="__dumi-default-menu-header"><a class="__dumi-default-menu-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog/"></a><h1>大师兄</h1><p></p></div><div class="__dumi-default-menu-mobile-area"><ul class="__dumi-default-menu-nav-list"><li>计算机基础<ul><li><a href="/blog/编译原理之美">编译原理之美</a></li><li><a href="/blog/编译原理实战">编译原理实战</a></li><li><a href="/blog/深入浅出计算机组成原理">深入浅出计算机组成原理</a></li><li><a href="/blog/详解http">详解http</a></li><li><a href="/blog/计算机网络通关29讲">计算机网络通关29讲</a></li><li><a href="/blog/网络排查案例课">网络排查案例课</a></li><li><a href="/blog/linux操作系统">linux操作系统</a></li><li><a href="/blog/linux性能优化实战">linux性能优化实战</a></li><li><a href="/blog/程序员数学基础">程序员数学基础</a></li><li><a href="/blog/趣谈网络协议">趣谈网络协议</a></li><li><a href="/blog/操作系统实战">操作系统实战</a></li><li><a href="/blog/软件工程之美">软件工程之美</a></li><li><a href="/blog/sql必知必会">sql必知必会</a></li><li><a href="/blog/操作系统实战45讲">操作系统实战45讲</a></li><li><a href="/blog/网络编程实战">网络编程实战</a></li></ul></li><li>算法<ul><li><a href="/blog/常用算法25讲">常用算法25讲</a></li><li><a href="/blog/数据结构与算法之美">数据结构与算法之美</a></li><li><a href="/blog/业务开发算法50讲">业务开发算法50讲</a></li><li><a href="/blog/动态规划面试宝典">动态规划面试宝典</a></li></ul></li><li>前端开发<ul><li><a href="/blog/浏览器工作原理与实践">浏览器工作原理与实践</a></li><li><a href="/blog/新时代产品经理进阶之路">新时代产品经理进阶之路</a></li><li><a href="/blog/全栈工程师修炼指南">全栈工程师修炼指南</a></li><li><a href="/blog/flutter核心技术与实战">flutter核心技术与实战</a></li><li><a href="/blog/java-script核心原理解析">java-script核心原理解析</a></li><li><a href="/blog/说透低代码">说透低代码</a></li><li><a href="/blog/nodejs应用开发实战">nodejs应用开发实战</a></li><li><a href="/blog/反爬虫兵法演绎20讲">反爬虫兵法演绎20讲</a></li><li><a href="/blog/reactnative新架构实战课">reactnative新架构实战课</a></li><li><a href="/blog/正则表达式入门">正则表达式入门</a></li><li><a href="/blog/重学前端">重学前端</a></li><li><a href="/blog/serverless入门课">serverless入门课</a></li><li><a href="/blog/type-script入门实战笔记">type-script入门实战笔记</a></li><li><a href="/blog/图解googlev8">图解googlev8</a></li><li><a href="/blog/vue3源码分析">vue3源码分析</a></li><li><a href="/blog/玩转Vue3全家桶">玩转Vue3全家桶</a></li><li><a href="/blog/webassembly入门">webassembly入门</a></li><li><a href="/blog/手把手带你写一个Web框架">手把手带你写一个Web框架</a></li><li><a href="/blog/web漏洞挖掘实战">web漏洞挖掘实战</a></li><li><a href="/blog/跟月影学可视化">跟月影学可视化</a></li><li><a href="/blog/搞定音频技术">搞定音频技术</a></li><li><a aria-current="page" class="active" href="/blog/攻克视频技术">攻克视频技术</a></li></ul></li><li>前端工程化<ul><li><a href="/blog/logger">logger</a></li><li><a href="/blog/webpack">webpack</a></li><li><a href="/blog/webpackChain">webpackChain</a></li></ul></li><li>前端性能优化<ul><li><a href="/blog/react性能调优">react性能调优</a></li></ul></li><li>软件测试<ul><li><a href="/blog/全链路压测实战30讲">全链路压测实战30讲</a></li><li><a href="/blog/性能测试实战30讲">性能测试实战30讲</a></li><li><a href="/blog/自动化测试高手课">自动化测试高手课</a></li><li><a href="/blog/软件测试52讲">软件测试52讲</a></li></ul></li><li>面试<ul><li><a href="/blog/面试现场">面试现场</a></li></ul></li><li>杂谈<ul><li><a href="/blog/超级访谈对话张雪峰">超级访谈对话张雪峰</a></li><li><a href="/blog/Git实战手册">Git实战手册</a></li><li><a href="/blog/NodeJS">NodeJS</a></li><li><a href="/blog/ReactJS">ReactJS</a></li><li><a href="/blog/UI设计">UI设计</a></li><li><a href="/blog/webpack4系列教程">webpack4系列教程</a></li><li><a href="/blog/前端知识体系">前端知识体系</a></li><li><a href="/blog/剑指offer刷题笔记">剑指offer刷题笔记</a></li><li><a href="/blog/思考与成长">思考与成长</a></li><li><a href="/blog/设计模式手册">设计模式手册</a></li></ul></li></ul><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "><button title="Dark theme" class="__dumi-default-dark-moon "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="3854" width="22" height="22"><path d="M991.816611 674.909091a69.166545 69.166545 0 0 0-51.665455-23.272727 70.795636 70.795636 0 0 0-27.438545 5.585454A415.674182 415.674182 0 0 1 754.993338 698.181818c-209.594182 0-393.472-184.785455-393.472-395.636363 0-52.363636 38.539636-119.621818 69.515637-173.614546 4.887273-8.610909 9.634909-16.756364 14.103272-24.901818A69.818182 69.818182 0 0 0 384.631156 0a70.842182 70.842182 0 0 0-27.438545 5.585455C161.678429 90.298182 14.362065 307.898182 14.362065 512c0 282.298182 238.824727 512 532.38691 512a522.286545 522.286545 0 0 0 453.957818-268.334545A69.818182 69.818182 0 0 0 991.816611 674.909091zM546.679156 954.181818c-248.785455 0-462.941091-192-462.941091-442.181818 0-186.647273 140.637091-372.829091 300.939637-442.181818-36.817455 65.629091-92.578909 151.970909-92.578909 232.727273 0 250.181818 214.109091 465.454545 462.917818 465.454545a488.331636 488.331636 0 0 0 185.181091-46.545455 453.003636 453.003636 0 0 1-393.565091 232.727273z m103.656728-669.323636l-14.266182 83.781818a34.909091 34.909091 0 0 0 50.362182 36.770909l74.775272-39.563636 74.752 39.563636a36.142545 36.142545 0 0 0 16.174546 3.956364 34.909091 34.909091 0 0 0 34.210909-40.727273l-14.289455-83.781818 60.509091-59.345455a35.025455 35.025455 0 0 0-19.223272-59.578182l-83.61891-12.101818-37.376-76.101818a34.56 34.56 0 0 0-62.254545 0l-37.376 76.101818-83.618909 12.101818a34.909091 34.909091 0 0 0-19.246546 59.578182z m70.423272-64.698182a34.280727 34.280727 0 0 0 26.135273-19.083636l14.312727-29.090909 14.336 29.090909a34.257455 34.257455 0 0 0 26.135273 19.083636l32.046546 4.887273-23.272728 22.574545a35.234909 35.234909 0 0 0-10.007272 30.952727l5.46909 32.116364-28.625454-15.127273a34.490182 34.490182 0 0 0-32.302546 0l-28.695272 15.127273 5.469091-32.116364a35.141818 35.141818 0 0 0-9.984-30.952727l-23.272728-22.574545z" p-id="3855"></path></svg></button><button title="Light theme" class="__dumi-default-dark-sun "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="4026" width="22" height="22"><path d="M915.2 476.16h-43.968c-24.704 0-44.736 16-44.736 35.84s20.032 35.904 44.736 35.904H915.2c24.768 0 44.8-16.064 44.8-35.904s-20.032-35.84-44.8-35.84zM512 265.6c-136.704 0-246.464 109.824-246.464 246.4 0 136.704 109.76 246.464 246.464 246.464S758.4 648.704 758.4 512c0-136.576-109.696-246.4-246.4-246.4z m0 425.6c-99.008 0-179.2-80.128-179.2-179.2 0-98.944 80.192-179.2 179.2-179.2S691.2 413.056 691.2 512c0 99.072-80.192 179.2-179.2 179.2zM197.44 512c0-19.84-19.136-35.84-43.904-35.84H108.8c-24.768 0-44.8 16-44.8 35.84s20.032 35.904 44.8 35.904h44.736c24.768 0 43.904-16.064 43.904-35.904zM512 198.464c19.776 0 35.84-20.032 35.84-44.8v-44.8C547.84 84.032 531.84 64 512 64s-35.904 20.032-35.904 44.8v44.8c0 24.768 16.128 44.864 35.904 44.864z m0 627.136c-19.776 0-35.904 20.032-35.904 44.8v44.736C476.096 940.032 492.16 960 512 960s35.84-20.032 35.84-44.8v-44.736c0-24.768-16.064-44.864-35.84-44.864z m329.92-592.832c17.472-17.536 20.288-43.072 6.4-57.024-14.016-14.016-39.488-11.2-57.024 6.336-4.736 4.864-26.496 26.496-31.36 31.36-17.472 17.472-20.288 43.008-6.336 57.024 13.952 14.016 39.488 11.2 57.024-6.336 4.8-4.864 26.496-26.56 31.296-31.36zM213.376 759.936c-4.864 4.8-26.56 26.624-31.36 31.36-17.472 17.472-20.288 42.944-6.4 56.96 14.016 13.952 39.552 11.2 57.024-6.336 4.8-4.736 26.56-26.496 31.36-31.36 17.472-17.472 20.288-43.008 6.336-56.96-14.016-13.952-39.552-11.072-56.96 6.336z m19.328-577.92c-17.536-17.536-43.008-20.352-57.024-6.336-14.08 14.016-11.136 39.488 6.336 57.024 4.864 4.864 26.496 26.56 31.36 31.424 17.536 17.408 43.008 20.288 56.96 6.336 14.016-14.016 11.264-39.488-6.336-57.024-4.736-4.864-26.496-26.56-31.296-31.424z m527.168 628.608c4.864 4.864 26.624 26.624 31.36 31.424 17.536 17.408 43.072 20.224 57.088 6.336 13.952-14.016 11.072-39.552-6.4-57.024-4.864-4.8-26.56-26.496-31.36-31.36-17.472-17.408-43.072-20.288-57.024-6.336-13.952 14.016-11.008 39.488 6.336 56.96z" p-id="4027"></path></svg></button><button title="Default to system" class="__dumi-default-dark-auto "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="11002" width="22" height="22"><path d="M127.658667 492.885333c0-51.882667 10.24-101.717333 30.378666-149.162666s47.786667-88.064 81.92-122.538667 75.093333-61.781333 122.538667-81.92 96.938667-30.378667 149.162667-30.378667 101.717333 10.24 149.162666 30.378667 88.405333 47.786667 122.88 81.92 61.781333 75.093333 81.92 122.538667 30.378667 96.938667 30.378667 149.162666-10.24 101.717333-30.378667 149.162667-47.786667 88.405333-81.92 122.88-75.093333 61.781333-122.88 81.92-97.28 30.378667-149.162666 30.378667-101.717333-10.24-149.162667-30.378667-88.064-47.786667-122.538667-81.92-61.781333-75.093333-81.92-122.88-30.378667-96.938667-30.378666-149.162667z m329.045333 0c0 130.048 13.994667 244.394667 41.984 343.381334h12.970667c46.762667 0 91.136-9.216 133.461333-27.306667s78.848-42.666667 109.568-73.386667 54.954667-67.242667 73.386667-109.568 27.306667-86.698667 27.306666-133.461333c0-46.421333-9.216-90.794667-27.306666-133.12s-42.666667-78.848-73.386667-109.568-67.242667-54.954667-109.568-73.386667-86.698667-27.306667-133.461333-27.306666h-11.605334c-28.672 123.562667-43.349333 237.909333-43.349333 343.722666z" p-id="11003"></path></svg></button></div></div></div><ul class="__dumi-default-menu-list"><li><a href="/blog/攻克视频技术">攻克视频技术</a></li><li><a href="/blog/攻克视频技术/01.开篇词">01.开篇词</a><ul><li><a href="/blog/攻克视频技术/01.开篇词/01"><span>开篇词｜为什么说视频开发是程序员的一片蓝海？</span></a></li></ul></li><li><a href="/blog/攻克视频技术/02.图像基础和前处理">02.图像基础和前处理</a><ul><li><a href="/blog/攻克视频技术/02.图像基础和前处理/01"><span>01｜基本概念：从参数的角度看视频图像</span></a></li><li><a href="/blog/攻克视频技术/02.图像基础和前处理/02"><span>02｜YUV &amp; RGB：原来图像是这么丰富多彩的</span></a></li><li><a href="/blog/攻克视频技术/02.图像基础和前处理/03"><span>03｜缩放算法：如何高质量地缩放图像？</span></a></li></ul></li><li><a href="/blog/攻克视频技术/03.视频编码">03.视频编码</a><ul><li><a href="/blog/攻克视频技术/03.视频编码/01"><span>04｜编码原理：视频究竟是怎么编码压缩的？</span></a></li><li><a href="/blog/攻克视频技术/03.视频编码/02"><span>05｜码流结构：原来你是这样的H264</span></a></li><li><a href="/blog/攻克视频技术/03.视频编码/03"><span>06｜帧内预测：如何减少空间冗余？</span></a></li><li><a href="/blog/攻克视频技术/03.视频编码/04"><span>07｜帧间预测：如何减少时间冗余？</span></a></li><li><a href="/blog/攻克视频技术/03.视频编码/05"><span>08｜变换量化：如何减少视觉冗余？</span></a></li></ul></li><li><a aria-current="page" class="active" href="/blog/攻克视频技术/04.视频传输和网络对抗">04.视频传输和网络对抗</a><ul><li><a href="/blog/攻克视频技术/04.视频传输和网络对抗/01"><span>09｜RTP &amp; RTCP：如何正确地将视频装进RTP中？</span></a></li><li><a aria-current="page" class="active" href="/blog/攻克视频技术/04.视频传输和网络对抗/02"><span>10｜带宽预测：3大算法准确预估网络带宽</span></a></li><li><a href="/blog/攻克视频技术/04.视频传输和网络对抗/03"><span>11｜码控算法：如何控制视频的编码码率？</span></a></li><li><a href="/blog/攻克视频技术/04.视频传输和网络对抗/04"><span>12｜Jitter Buffer：拿什么拯救你，花屏卡顿问题</span></a></li><li><a href="/blog/攻克视频技术/04.视频传输和网络对抗/05"><span>13｜SVC：如何实现视频编码可伸缩？</span></a></li></ul></li><li><a href="/blog/攻克视频技术/05.视频封装和播放">05.视频封装和播放</a><ul><li><a href="/blog/攻克视频技术/05.视频封装和播放/01"><span>14｜MP4 &amp; FLV：不要再说AVI了</span></a></li><li><a href="/blog/攻克视频技术/05.视频封装和播放/02"><span>加餐｜基于纯浏览器的视频会议方案探究</span></a></li><li><a href="/blog/攻克视频技术/05.视频封装和播放/03"><span>15｜音画同步：如何让声音和画面手拉手前进？</span></a></li></ul></li><li><a href="/blog/攻克视频技术/06.结束语">06.结束语</a><ul><li><a href="/blog/攻克视频技术/06.结束语/01"><span>结束语｜信心比黄金更重要</span></a></li><li><a href="/blog/攻克视频技术/06.结束语/02"><span>期末测试｜来赴一场满分之约吧！</span></a></li></ul></li><li><a href="/blog/攻克视频技术/summary">攻克视频技术</a></li></ul></div></div><ul role="slug-list" class="__dumi-default-layout-toc"><li title="带宽预测" data-depth="2"><a href="/blog/攻克视频技术/04.视频传输和网络对抗/02#带宽预测"><span>带宽预测</span></a></li><li title="基于延时的带宽预测算法" data-depth="3"><a href="/blog/攻克视频技术/04.视频传输和网络对抗/02#基于延时的带宽预测算法"><span>基于延时的带宽预测算法</span></a></li><li title="基于丢包的带宽预测算法" data-depth="3"><a href="/blog/攻克视频技术/04.视频传输和网络对抗/02#基于丢包的带宽预测算法"><span>基于丢包的带宽预测算法</span></a></li><li title="最大带宽探测算法" data-depth="3"><a href="/blog/攻克视频技术/04.视频传输和网络对抗/02#最大带宽探测算法"><span>最大带宽探测算法</span></a></li><li title="小结" data-depth="2"><a href="/blog/攻克视频技术/04.视频传输和网络对抗/02#小结"><span>小结</span></a></li><li title="思考题" data-depth="2"><a href="/blog/攻克视频技术/04.视频传输和网络对抗/02#思考题"><span>思考题</span></a></li></ul><div class="__dumi-default-layout-content"><div class="markdown"><h1 id="10带宽预测3大算法准确预估网络带宽"><a aria-hidden="true" tabindex="-1" href="/blog/攻克视频技术/04.视频传输和网络对抗/02#10带宽预测3大算法准确预估网络带宽"><span class="icon icon-link"></span></a>10｜带宽预测：3大算法准确预估网络带宽</h1><p>你好，我是李江。</p><p>上一节我们详细地讲述了RTP和RTCP协议。RTP协议用来封装传输的音视频数据并带上一些基本的信息，而RTCP协议则用来统计这些RTP包的传输情况。RTP和RTCP一般是使用UDP协议作为传输层协议的。因为音视频数据需要比较高的实时性，TCP协议不太适合，所以我们一般使用UDP协议。但是UDP协议没有实现拥塞控制算法。因此，我们使用UDP协议作为传输层协议的话，需要自己实现拥塞控制算法。</p><p>比如说，我们声网就是自己实现了一个全球实时通信网SD-RTN，并研发了Agora Universal Transport（AUT）传输算法。我们的SD-RTN和AUT内部实现了适合不同网络模型的拥塞控制和丢包重传等一整套高质量的传输算法和策略。如果你使用了我们的音视频SDK，则无需自己关注拥塞控制和丢包重传等一系列弱网对抗算法，SD-RTN和AUT会保证你在进行音视频通信时的流畅度和实时性要求。</p><p><img src="https://static001.geekbang.org/resource/image/dd/55/ddd0ac38f97976c5f875f2yy10d0cd55.jpeg?wh=1920x1080" alt=""/></p><p>一般情况下，音视频场景中的拥塞控制和丢包重传等算法的基础就是RTP和RTCP协议。我们需要通过RTP包的信息和RTCP包中传输的统计信息来做拥塞控制和丢包重传等操作。因此，我再强调一下，上一节课是我们之后几节课的基础，你需要完全掌握。</p><p>今天，我们主要讨论拥塞控制中的带宽预测算法，在之后的课程中我们还会介绍码控算法和丢包重传算法。带宽预测几乎是整个音视频传输和弱网对抗中最重要的环节，也是最难的一个环节。因此，你可能需要多看几遍今天的课程才能完全掌握。</p><p>而且，带宽预测算法涉及到很多阈值设置等细节问题。为了能够更好地带你了解带宽预测的思想，我们在讨论的过程中会将一部分细节省略，这样更加方便你理解核心思想。同时，由于WebRTC在实时音视频中占据绝对的领导地位，它的带宽预测算法非常的成熟，因此，我们今天将以WebRTC的带宽预测算法作为讨论的对象，对其进行深入剖析和探讨。</p><h2 id="带宽预测"><a aria-hidden="true" tabindex="-1" href="/blog/攻克视频技术/04.视频传输和网络对抗/02#带宽预测"><span class="icon icon-link"></span></a>带宽预测</h2><p>带宽预测，顾名思义，就是实时预测当前的网络带宽大小。**预测出实际的带宽之后，我们就可以控制音视频数据的发送数据量。**比如说，控制音视频数据的编码码率或者直接控制发送RTP包的速度，这都是可以的。控制住音视频发送的数据量是为了不会在网络带宽不够的时候，我们还发送超过网络带宽承受能力的数据量，最后导致网络出现长延时和高丢包等问题，继而引发接收端出现延时高或者卡顿的问题。因此，带宽预测是非常重要的。</p><p>而现在的网络中，大多存在两种类型的网络设备：一种是有较大缓存的；一种是没有缓存或者缓存很小的。</p><ul><li>前者在网络中需要转发数据过多的时候，会把数据先缓存在自己的缓冲队列中，等待前面的数据发送完之后再发送当前数据。这种情况就会在网络带宽不够的时候，需要当前数据等一段时间才能发送，因此<strong>表现出来的现象就是网络不好时，延时会加大。</strong></li><li>后者在网络中需要发送的数据过多的时候，会直接将超过带宽承受能力的数据丢弃掉。<strong>这种情况就会在网络带宽不够的时候，出现高丢包的现象。</strong></li></ul><p>通过下面的图你可以很容易理解：</p><p><img src="https://static001.geekbang.org/resource/image/c8/d0/c844c9dbe2a0d958bcb4cb61b19529d0.jpeg?wh=1920x1080" alt=""/><img src="https://static001.geekbang.org/resource/image/d8/0f/d89b5fceeb0a2b86c2b2044041e1680f.jpeg?wh=1920x1080" alt=""/></p><p>因为互联网中这两种类型的网络设备都存在，为了能够兼顾这两种类型的网络，WebRTC中设计了两个主要的带宽预测算法：一个是基于延时的带宽预测算法；一个是基于丢包的带宽预测算法。下面我们逐一讨论一下。</p><h3 id="基于延时的带宽预测算法"><a aria-hidden="true" tabindex="-1" href="/blog/攻克视频技术/04.视频传输和网络对抗/02#基于延时的带宽预测算法"><span class="icon icon-link"></span></a>基于延时的带宽预测算法</h3><p>基于延时的带宽预测算法主要是通过计算一组RTP包它们的发送时长和接收时长，来判断当前延时的变化趋势，并根据当前的延时变化趋势来调整更新预测的带宽值。比如说：</p><ul><li>如果延时有明显变大的趋势就说明实际带宽值应该比当前的发送码率要小，则需要降低预测的带宽值。</li><li>如果说延时没有变大，说明当前带宽良好，可能实际带宽值比当前的发送码率还要大，则可以提高预测的带宽值，直到延时有明显变大的趋势再降低预测的带宽值。我们不断这样实时调整更新带宽，来实现带宽预测。</li></ul><p>从上面的讲述我们可以看到，基于延时的带宽预测算法，主要有4个步骤：</p><ol><li>计算一组RTP包的发送时长和接收时长，并计算延时；</li><li>需要根据当前延时和历史延时的大小来计算延时变化的趋势；</li><li>根据延时变化趋势判断网络状况；</li><li>根据网络状况调整更新预测带宽值。</li></ol><p><img src="https://static001.geekbang.org/resource/image/a3/cf/a3f84d6a7a80705551dd7a5f8462becf.jpeg?wh=1911x506" alt=""/></p><p>下面，我们一个个步骤来展开详细讲解。</p><p><strong>计算延时</strong></p><p>WebRTC中计算延时的时候是将RTP包按照发送时间来分组的，并且要求当前组中的第一个包和最后一个包的发送时间相差不能大于5ms，而大于5ms则是新的一组的开始。同时，由于UDP会出现包乱序到达的情况，可能导致后面包的发送时间比前面包的还小。为了防止这种情况的发生，我们要求乱序的包不参与计算。</p><p>并且发送端在发送每一个RTP包的时候会记录每一个包的包序号和实际发送时间，并把这些信息记录到一个发送历史数据里面方便之后计算使用（这个发送历史数据好几个计算需要用到，挺重要的）。</p><p><img src="https://static001.geekbang.org/resource/image/e1/17/e1f36fecdcd4a402c84f4458f92cbd17.jpeg?wh=1920x1080" alt=""/></p><p><img src="https://static001.geekbang.org/resource/image/51/51/514cb5c090aeb5ec52f830cb09bd9651.jpeg?wh=1920x1080" alt=""/></p><p>同时，接收端收到每一个包的时候也会记录包的包序号和实际的接收时间。每隔一段时间就会将</p><p>这些统计信息发送到发送端。现在的WebRTC版本中接收端是通过RTCP协议的Transport-CC报文反馈接收信息的，这个报文主要包含两个信息：</p><ol><li>每一个包序号对应的包是不是接收到了；</li><li>实际的这个包相比前一个包的接收间隔。</li></ol><p>接收端将这些信息组成Transport-CC报文发送给发送端。</p><p>如果发送端收到这个报文，就可以知道每一个RTP包有没有接收到了。如果没有接收到就是丢包了。同时也可以知道没有丢失的RTP包的接收时间。</p><p>发送端就可以根据发送历史数据中各个包的发送时间和Transport-CC报文中计算得到的各个包的接收时间，来计算出前后两组包之间的发送时长和接收时长了。计算方法如下。</p><p><img src="https://static001.geekbang.org/resource/image/af/59/afayy53db3f7041e01dd5bff17dcfc59.jpeg?wh=1920x1080" alt=""/></p><p>其中Transport-CC报文格式可以参考下图，具体各字段的解释可以参考这个<a target="_blank" rel="noopener noreferrer" href="https://datatracker.ietf.org/doc/html/draft-holmer-rmcat-transport-wide-cc-extensions-01">RFC文档<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>和<a target="_blank" rel="noopener noreferrer" href="https://blog.jianchihu.net/webrtc-research-transport-cc-rtp-rtcp.html">这篇文章<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>。总的来说，就是通过Transport-CC报文，我们可以计算得到每一个包是不是丢失了，以及没有丢失的每一个包的接收时间。这里我们不做过多展开。</p><p><img src="https://static001.geekbang.org/resource/image/56/e3/563861306be7175ac5a5c8919cba76e3.png?wh=1124x818" alt="" title="图片来源RFC文档"/></p><p>有了发送时长和接收时长，我们<strong>将接收时长减去发送时长就是延时</strong>了。</p><ul><li>如果接收时长大于发送时长，延时就大于0，说明当前网络有点承受不了当前的发送数据量，产生了缓存，继而产生了延时。</li><li>如果接收时长几乎等于发送时长，延时就几乎为0，说明当前网络可以承受当前的发送量，因此几乎没有延时。</li><li>如果接收时长小于发送时长，也就是延时小于0呢？这种情况比较特殊，一般出现在之前因为网络带宽不够已经缓存了一部分数据，但是网络在明显变好，从而网络设备快速地将缓存中的数据发送出去的时候。这种情况下就会出现接收时长很短，导致接收时长还小于发送时长，这个时候延时就是一个负数。</li></ul><p>这三种情况具体可参考下图：</p><p><img src="https://static001.geekbang.org/resource/image/e7/db/e79de2971b32e5f1d5492892bbefb9db.jpeg?wh=1920x1080" alt=""/></p><p>好了，这就是延时的计算方法。有了延时之后，我们还不能直接使用这个延时来判断网络的好坏，因为网络变化很快而且存在噪声，有的时候延时会因为网络噪声突然变大或变小。因此，<strong>我们需要通过当前延时和历史延时数据来判断延时变化的趋势，来平滑掉网络噪声引起的单个延时抖动。</strong></p><p>说到这里就必须引入一个重要的滤波器了，那就是Trendline Filter。这个滤波器就是用来计算得到延时变化趋势的。</p><p><strong>延时变化的趋势计算</strong></p><p>Trendline Filter中保存了20个最近的延时数据，这些延时数据跟前面直接计算的延时还不完全一样。它们包含了两个部分：一个是当前这个RTP包组所属的Transport-CC报文到达发送端的时间；另一个是经过平滑后的累积延时，它是通过前面计算得到的延时和历史累积延时加权平均计算之后得到的。这样也可以一定程度上防止延时波动太大的问题。</p><p>在WebRTC看来，如果设RTP包组所属的Transport-CC报文的到达时间为x，累积延时为y的话，那么x和y应该是呈线性关系，也就是说y = kx + b。Trendline Filter就是使用20个延时数据，通过线性回归的方法，求得其中的k值，也就是斜率。这个斜率就表示延时变化的趋势。其中线性回归的求解方式用的是最小二乘法。示意图和求解公式如下：</p><p><img src="https://static001.geekbang.org/resource/image/f8/71/f808d5b35039cfd1fb189980e3f65771.jpeg?wh=1084x892" alt="图片"/></p><p><img src="https://static001.geekbang.org/resource/image/27/f2/2735c395c7c7a0c0733061cf39b125f2.jpeg?wh=894x398" alt="图片"/></p><p><img src="https://static001.geekbang.org/resource/image/98/96/98a1b9614be82fbc40a29402d3f44196.jpeg?wh=1584x1352" alt="图片"/></p><p>当斜率k &gt; 0时，表示有延时；当k = 0时，表示几乎没有延时；当k &lt; 0时，表示不仅没有延时，反而接收速度更快。</p><p>当然了，我们计算出来的延时变化趋势还不能直接说明网络当前的变化方向。因为网络是变化无常的，不能因为测到延时稍有变大就认为网络变差，延时稍有变小就认为网络变好。我们需要一个根据当前延时趋势和延时阈值，来判断网络是不是真的变好和变坏的模块，这个模块就是我们下一个讨论的重点，叫做过载检测器。</p><p><strong>网络状态判断</strong></p><p>过载检测器有两个主要的工作：一个是通过当前的延时趋势和延时阈值来判断当前网络是处于过载、欠载还是正常状态；一个是通过当前的延时趋势来更新延时阈值，是的，延时阈值不是静态不变的，阈值是跟着延时趋势不断自适应调整的。</p><p>我们下面先来看看网络状态的判断，之后再来讨论一下阈值的更新。</p><p>网络状态的判断其实比较简单。就是将延时趋势k乘以一个固定增益4和包组的数量（包组数量最大是60）作为当前的修改后延时值。将当前的修改后延时值跟延时阈值进行比较，然后根据比较的结果来判断网络状态。步骤如下图所示：</p><p><img src="https://static001.geekbang.org/resource/image/8d/d4/8d55ef099f40f3ebf8e74a25f09cdbd4.jpeg?wh=1920x1080" alt=""/></p><p>得到网络状态之后，我们会使用当前的修改后的延时值去更新当前的延时阈值。为什么需要这样做呢？</p><p>我认为，延时阈值的更新是因为网络是不断变化的，延时变化也很快，而有的时候延时很大，有的时候又很小。为了防止阈值太大，网络状况检测不够灵敏，同时也防止阈值太小，网络状况检测太敏感了。所以<strong>延时阈值会随着当前的延时做缓慢的调整</strong>。其调整的公式如下：</p><p><img src="https://static001.geekbang.org/resource/image/67/f2/677043013895576352140650b0d0yyf2.jpeg?wh=1640x552" alt="图片"/></p><p>有了修改后延时和延时阈值之后，我们就可以计算网络状态了。又根据网络所处的具体状态，我们就可以调整更新当前的带宽值了。而负责更新带宽值的模块就是速率控制器。下面我们就来详细讨论一下如何将网络状态转化到实际带宽的调整上去的吧。</p><p><strong>带宽调整更新</strong></p><p>速率控制器的主要工作就是更新预测带宽值。它里面维护着一个状态机。这个状态机主要是用来干什么的呢？其实，<strong>状态机主要用来根据过载检测器检测到的网络状态和状态机目前所处的状态，来更新状态机的状态的。</strong></p><p>状态机有三个状态，分别是上升、保持和下降状态。当处于上升状态时，速率控制器需要提升带宽值；当处于下降状态时，需要降低带宽值；当处于保持状态时，则不更新带宽值。我们通过下图来看一下过载检测器检测到的网络状态是如何影响状态机状态变化的。</p><p><img src="https://static001.geekbang.org/resource/image/90/99/90dedbd2666a8d402a7bc42a1cfde899.jpeg?wh=1920x1080" alt=""/></p><p>我们可以看到，当过载检测器检测到过载时，状态机都切换到下降状态。这个很好理解，因为过载意味着实际带宽值小于发送码率了，需要调低带宽值，继而发送码率因为预估带宽值下降了也会下降。</p><p>当过载检测器检测到正常时，状态机都向上调一个状态。什么意思呢？</p><p>就是如果之前状态机处于下降状态，则更改为保持状态；如果状态机之前处于保持状态，则更改为上升状态；如果是上升状态那就不用变化了。这个也很好理解，因为过载检测器检测到正常，说明当前实际发送数据量还没有达到网络的最大承受量，则可以继续调高预估带宽值，或者之前在降低带宽值的话，就不再继续降低预估带宽值了。</p><p>当过载检测器处于欠载的状态时，状态机全部切换到保持状态。这个有点不好理解。欠载了不是需要直接提高预估带宽值的吗？为什么保持带宽不变呢？</p><p>这是因为WebRTC认为欠载主要发生前面因为过载了在网络设备中缓存了一定数据，之后网络状况变好了的时候，网络设备可以快速的发送完缓存中的数据，从而排空缓存。这个时候不要提高发送码率，等缓存排空之后，因为缓存带来的延时就会接近于0了，这对于降低端到端延时是很有用的，而过载检测器自然就会进入到正常状态。这样状态机就可以切换到上升状态，从而也就可以调高预估带宽值了。</p><p>好了，我们讲解了什么时候需要调高、什么时候需要降低带宽值。但是我们还没有讲到底调高多少以及降低多少。下面我们就来介绍一下具体调节预估带宽的公式。</p><p>带宽调整更新逻辑中，上调带宽逻辑比较复杂。因此，我们先介绍相对简单点的下降带宽调整。下降带宽其实很简单，就是预估带宽等于0.85倍的接收码率。</p><p><img src="https://static001.geekbang.org/resource/image/26/46/269be1c1b3564f8b7381ef8d8fde6b46.jpeg?wh=1901x344" alt=""/></p><p>但是下降带宽的时候需要做另外一个事情就是更新当前网络的最大带宽。因为处于下降带宽的过程中，说明当前发送数据量已经达到甚至超过了网络的承受能力。这个时候适合更新网络的最大带宽，将当前的接收码率与之前的最大带宽做加权平均求得当前的最大带宽，并更新最大带宽的标准差。这两个值之后调高带宽的时候需要用。</p><p>这个地方需要提一下，为什么预估带宽和最大带宽都是用接收码率来来计算的，那是因为发送码率可能会超出网络承受能力，不一定能很好的反映真实的网络带宽，相比而言，<strong>接收端的接收码率更能够表示真实的网络带宽。</strong></p><p>在上升带宽的时候，是有两种情况的。</p><p>当前接收码率离最大带宽比较远，具体就是当前接收码率大于最大带宽加上3倍的最大带宽标准差，或者小于最大带宽减去3倍的标准差。这个时候应该快速调高预估带宽，我们使用的是乘性增的方式增加带宽值，就是每隔一秒钟将预估带宽乘以1.08倍。但是为了防止带宽大幅增长，预估带宽不能大于1.5倍的接收码率。</p><p>当前接收码率离最大带宽很近，具体就是当前接收码率大于最大带宽减去3倍标准差，并小于最大带宽加上3倍标准差。这时使用更小的幅度增加带宽，使用加性增的方式增加带宽值。预估带宽是每隔一个RTT（往返时间，由其它模块计算得到，这里不展开讲）增加半个包的大小。如果一个包按照1400字节算的话，那就是每过一个RTT的时间就增加700字节。</p><p><img src="https://static001.geekbang.org/resource/image/d8/9a/d8013889966de404aa2a24710afcd89a.jpeg?wh=1920x712" alt=""/></p><p>好了，以上就是基于延时的带宽预测算法。</p><h3 id="基于丢包的带宽预测算法"><a aria-hidden="true" tabindex="-1" href="/blog/攻克视频技术/04.视频传输和网络对抗/02#基于丢包的带宽预测算法"><span class="icon icon-link"></span></a>基于丢包的带宽预测算法</h3><p>前面我们讲过，网络设备主要有两种：一种是有较大缓存的；一种是没有缓存或者缓存很小的。有较大缓存的网络设备在遇到数据量太大的时候会把数据放在缓存中，延迟发送。其表现就是网络延时加大。因此这种情况下我们基于延时做带宽预测是比较准确的。</p><p>而没有缓存或者缓存很小的网络设备，在遇到数据量太大的时候是直接将数据丢弃的，这会引起丢包率上升。为了能够更快更准确地做带宽预测，WebRTC针对这种情况设计了基于丢包的带宽预测算法。</p><p>基于丢包的带宽预测算法相比基于延时的带宽预测算法简单很多，没有那么多步骤。<strong>其整体思路就是根据Transport-CC报文反馈的信息计算丢包率，然后再根据丢包率的多少直接进行带宽调整更新。</strong></p><p><strong>丢包率的计算</strong></p><p>接收端会将接收到的每一个包的信息放到Transport-CC报文中，包括每一个RTP包的序号以及这个包有没有接收到。而没有接收到就代表这个包丢失了。这样就很简单了，发送端收到这个Transport-CC报文之后只需要统计这个Transport-CC报文总共有多少个包，以及丢失了多少个包，就可以计算得到丢包率了。</p><p><img src="https://static001.geekbang.org/resource/image/ee/a6/ee56c2c259b1535ffcba1ecaf49047a6.jpeg?wh=822x324" alt="图片"/></p><p><strong>带宽调整</strong></p><p>有了丢包率之后，我们就可以做带宽调整了。根据丢包率可以分三种情况。具体如下：</p><ul><li>如果丢包率 &lt; 2 %，认为当前网络状况很好，需要调高带宽值，带宽值等于过去1秒钟所有预测得到的带宽值的最小值 * 1.08；</li><li>如果2% &lt; 丢包率 &lt; 10%，认为当前网络状况正常，不做带宽调整；</li><li>如果丢包率 &gt; 10%，认为网络状况不好，需要降低带宽值，带宽值等于当前预估带宽值 * (1 - 0.5 * 丢包率)。</li></ul><p>如果不太明白，没关系，下面的图能让你一目了然。</p><p><img src="https://static001.geekbang.org/resource/image/cf/86/cf473ee753cc4c10a61980e4d13a4e86.jpeg?wh=1912x740" alt=""/></p><p>这就是基于丢包的带宽预测算法。</p><p>现在我们有了基于延时的带宽预测算法，主要用于有大缓存网络设备存在时的带宽预测；同时也有了基于丢包的带宽预测算法，主要用于有小缓存或无缓存网络设备存在时的带宽预测。由于互联网中一般是两种网络设备都有，因此，最终的预估带宽值等于这两者中的最小值。</p><p>**到这里，我们的带宽预测算法最核心的部分就完成了。**但是不知道你有没有发现一个问题，就是我们在网络变差的时候，预估带宽会快速的被下调，但是网络变好的时候预估带宽会比较缓慢的上升，同时如果当前发送码率比较小的话，预估带宽还会被限制，不能超过1.5倍的接收码率。</p><p>也就是说，如果我们当前视频处于静止画面的状态，发送的码率会很小。这样预估带宽就很难从一个比较小的带宽调整上去。如果此时画面突然动起来，即便实际网络带宽足够，还是会因为预估带宽不够而限制发送码率，从而导致画面出现模糊和马赛克等问题。</p><p>还有就是程序刚开始启动的时候，预估带宽的爬升也需要慢慢的加上去。但是在做音视频通信的时候，有可能一开始就会出现视频画面变化比较快的情况，这样可能刚开始的时候视频画面就会是模糊的或者有很多马赛克。</p><p>这种问题有没有方法解决呢？答案是有的，下面我们就来讲讲第三种带宽预测的算法，它可以帮助我们快速的探测出当前网络的最大带宽。</p><h3 id="最大带宽探测算法"><a aria-hidden="true" tabindex="-1" href="/blog/攻克视频技术/04.视频传输和网络对抗/02#最大带宽探测算法"><span class="icon icon-link"></span></a>最大带宽探测算法</h3><p>最大带宽探测算法相对来说思路也比较简单。它的主要过程是：</p><p>第一步，发送端设定一个探测的目标带宽，一般设置为当前带宽的2倍、3倍或者6倍。发送端在发送数据的时候就以这个探测目标带宽的速度快速发送RTP包，一般发送时间（也叫做探测时间）是15ms，同时将这段时间用于探测使用的RTP包信息保存在发送端（前面基于延时的带宽预测的时候，也需要保存发送的RTP包的发送时间等信息，其实都是保存在发送历史数据里面，只是探测的RTP包会多保存一些信息），并给这些RTP包标上是探测包的标记以及探测的cluster_id，每一次探测使用的cluster_id都不同，用于区分每次探测的RTP包，防止多次探测时弄混了。</p><p><img src="https://static001.geekbang.org/resource/image/04/b0/0499e00a594ae7436e8a9bb80a6c60b0.jpeg?wh=1920x1080" alt=""/></p><p>第二步，接收端并不关注当前包是不是探测包，而是直接统计每一个包的序号和接收时间，将统计结果组成Transport-CC报文反馈给发送端。</p><p>第三步，发送端接收到Transport-CC报文之后，会看报文中的每一个包是不是探测包，如果是探测包，就从发送端发送的历史数据中，取出其cluster_id和发送时间，并且从Transport-CC报文中得到接收时间，再把这些信息送入到探测带宽计算器中，当探测带宽计算器中相同cluster_id的RTP包信息数量达到一定值之后，就可以计算最终探测到的带宽值了。计算方法如下：</p><ul><li>首先，根据发送的探测RTP包总大小，和探测RTP包的总发送时间，相除就得到了发送端的最大带宽值了。</li><li>然后，再根据接收端接收到的探测RTP包总大小，和探测RTP包的总接收时间，相除就得到了接收端的最大带宽值了。</li><li>之后，取两者中的最小值作为探测到的网络最大带宽值。同时，如果接收端的最大带宽小于0.9倍的发送带宽，说明当前探测目标带宽已经到了最大带宽了，为了保险一些，最后将最大带宽取为接收端最大带宽的0.95倍。</li><li>最后，如果当前过载检测器检测不是在过载状态的话，预估带宽值更新为探测到的最大带宽值。<br/>具体如图所示：</li></ul><p><img src="https://static001.geekbang.org/resource/image/80/0f/80213731d8e28b36c80fa71094fbe30f.jpeg?wh=1920x1080" alt=""/><img src="https://static001.geekbang.org/resource/image/be/39/be46e15e04377f85b8b6fcd7df8c0f39.jpeg?wh=1920x1080" alt=""/></p><p>这就是最大带宽探测算法，它一般是在程序刚开始启动的时候使用并在程序运行的过程中进行周期性的探测，每隔一段时间定时探测一下。其实如果你自己设计带宽预测算法的话，也可以在实际发送带宽很小的时候探测一下，防止出现因为实际发送码率很小，而无法准确预测网络当前最大带宽值的问题。</p><h2 id="小结"><a aria-hidden="true" tabindex="-1" href="/blog/攻克视频技术/04.视频传输和网络对抗/02#小结"><span class="icon icon-link"></span></a>小结</h2><p>为了帮助你记忆，这里我用图帮你总结了一下这节课的知识点。</p><p><img src="https://static001.geekbang.org/resource/image/8e/69/8ea064dfb262226a239240c22d1f0969.jpg?wh=1598x1222" alt=""/></p><p>WebRTC中带宽预测主要分为基于延时的带宽预测算法、基于丢包的带宽预测算法以及最大带宽探测算法。</p><p>基于延时的带宽预测算法主要是解决网络中含有大缓冲网络设备场景的带宽预测。基于丢包的带宽预测算法主要是解决网络中有小缓冲或无缓冲网络设备场景的带宽预测。最终预估带宽等于这两者预测到的带宽值中的最小值。</p><p>同时，为了防止出现发送码率大幅低于实际网络带宽而导致网络带宽预估偏低的问题，我们还引入了最大带宽探测算法，可以周期性的探测网络的最大带宽。如果当前网络不是处于过载状态同时又探测到了最大带宽的话，就将预估带宽更新为探测到的最大带宽。</p><h2 id="思考题"><a aria-hidden="true" tabindex="-1" href="/blog/攻克视频技术/04.视频传输和网络对抗/02#思考题"><span class="icon icon-link"></span></a>思考题</h2><p>对于视频来说，带宽预测的最终目的是什么？</p><p>你可以把你的答案和感受写下来，分享到留言区，与我一起讨论。我们下节课再见！</p></div><div class="__dumi-default-layout-footer-meta"><a target="_blank" rel="noopener noreferrer" href="https://github.com/GGwujun/blog/edit/master/docs/攻克视频技术/04.视频传输和网络对抗/02.md">在 GitHub 上编辑此页<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a><span data-updated-text="最后更新时间：">5/2/2022 10:57:09</span></div></div></div></div>
	<script>
  window.g_useSSR = true;
  window.g_initialProps = {};
	</script>

    <script>
      (function () {
        if (!location.port) {
          (function (i, s, o, g, r, a, m) {
            i["GoogleAnalyticsObject"] = r;
            (i[r] =
              i[r] ||
              function () {
                (i[r].q = i[r].q || []).push(arguments);
              }),
              (i[r].l = 1 * new Date());
            (a = s.createElement(o)), (m = s.getElementsByTagName(o)[0]);
            a.async = 1;
            a.src = g;
            m.parentNode.insertBefore(a, m);
          })(
            window,
            document,
            "script",
            "//www.google-analytics.com/analytics.js",
            "ga"
          );
          ga("create", "UA-149864185-1", "auto");
          ga("send", "pageview");
        }
      })();
    </script>
    <script src="/blog/umi.js"></script>
  </body>
</html>
