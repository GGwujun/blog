<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no"
    />
    <link rel="shortcut icon" type="image/x-icon" href="/logo.png" />
    <link rel="stylesheet" href="/blog/umi.css" />
    <script>
      window.routerBase = "/blog";
    </script>
    <script>
      //! umi version: 3.5.17
    </script>
    <script>
      !(function () {
        var e = localStorage.getItem("dumi:prefers-color"),
          t = window.matchMedia("(prefers-color-scheme: dark)").matches,
          r = ["light", "dark", "auto"];
        document.documentElement.setAttribute(
          "data-prefers-color",
          e === r[2] ? (t ? r[1] : r[0]) : r.indexOf(e) > -1 ? e : r[0]
        );
      })();
    </script>
    <title>24 | 压测平台：如何改造分布式调度平台？</title>
  </head>
  <body>
    <div id="root"><div class="__dumi-default-layout" data-route="/全链路压测实战30讲/04.实践环境/04" data-show-sidemenu="true" data-show-slugs="true" data-site-mode="true" data-gapless="false"><div class="__dumi-default-navbar" data-mode="site"><button class="__dumi-default-navbar-toggle"></button><a class="__dumi-default-navbar-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog/">大师兄</a><nav><div class="__dumi-default-search"><input type="search" class="__dumi-default-search-input" value=""/><ul></ul></div><span>计算机基础<ul><li><a href="/blog/编译原理之美">编译原理之美</a></li><li><a href="/blog/编译原理实战">编译原理实战</a></li><li><a href="/blog/深入浅出计算机组成原理">深入浅出计算机组成原理</a></li><li><a href="/blog/详解http">详解http</a></li><li><a href="/blog/计算机网络通关29讲">计算机网络通关29讲</a></li><li><a href="/blog/网络排查案例课">网络排查案例课</a></li><li><a href="/blog/linux操作系统">linux操作系统</a></li><li><a href="/blog/linux性能优化实战">linux性能优化实战</a></li><li><a href="/blog/程序员数学基础">程序员数学基础</a></li><li><a href="/blog/趣谈网络协议">趣谈网络协议</a></li><li><a href="/blog/操作系统实战">操作系统实战</a></li><li><a href="/blog/软件工程之美">软件工程之美</a></li><li><a href="/blog/sql必知必会">sql必知必会</a></li><li><a href="/blog/操作系统实战45讲">操作系统实战45讲</a></li><li><a href="/blog/网络编程实战">网络编程实战</a></li></ul></span><span>算法<ul><li><a href="/blog/常用算法25讲">常用算法25讲</a></li><li><a href="/blog/数据结构与算法之美">数据结构与算法之美</a></li><li><a href="/blog/业务开发算法50讲">业务开发算法50讲</a></li><li><a href="/blog/动态规划面试宝典">动态规划面试宝典</a></li></ul></span><span>前端开发<ul><li><a href="/blog/浏览器工作原理与实践">浏览器工作原理与实践</a></li><li><a href="/blog/新时代产品经理进阶之路">新时代产品经理进阶之路</a></li><li><a href="/blog/全栈工程师修炼指南">全栈工程师修炼指南</a></li><li><a href="/blog/flutter核心技术与实战">flutter核心技术与实战</a></li><li><a href="/blog/java-script核心原理解析">java-script核心原理解析</a></li><li><a href="/blog/说透低代码">说透低代码</a></li><li><a href="/blog/nodejs应用开发实战">nodejs应用开发实战</a></li><li><a href="/blog/反爬虫兵法演绎20讲">反爬虫兵法演绎20讲</a></li><li><a href="/blog/reactnative新架构实战课">reactnative新架构实战课</a></li><li><a href="/blog/正则表达式入门">正则表达式入门</a></li><li><a href="/blog/重学前端">重学前端</a></li><li><a href="/blog/serverless入门课">serverless入门课</a></li><li><a href="/blog/type-script入门实战笔记">type-script入门实战笔记</a></li><li><a href="/blog/图解googlev8">图解googlev8</a></li><li><a href="/blog/vue3源码分析">vue3源码分析</a></li><li><a href="/blog/玩转Vue3全家桶">玩转Vue3全家桶</a></li><li><a href="/blog/webassembly入门">webassembly入门</a></li><li><a href="/blog/手把手带你写一个Web框架">手把手带你写一个Web框架</a></li><li><a href="/blog/web漏洞挖掘实战">web漏洞挖掘实战</a></li><li><a href="/blog/跟月影学可视化">跟月影学可视化</a></li><li><a href="/blog/搞定音频技术">搞定音频技术</a></li><li><a href="/blog/攻克视频技术">攻克视频技术</a></li></ul></span><span>前端工程化<ul><li><a href="/blog/logger">logger</a></li><li><a href="/blog/webpack">webpack</a></li><li><a href="/blog/webpackChain">webpackChain</a></li></ul></span><span>前端性能优化<ul><li><a href="/blog/react性能调优">react性能调优</a></li></ul></span><span>软件测试<ul><li><a aria-current="page" class="active" href="/blog/全链路压测实战30讲">全链路压测实战30讲</a></li><li><a href="/blog/性能测试实战30讲">性能测试实战30讲</a></li><li><a href="/blog/自动化测试高手课">自动化测试高手课</a></li><li><a href="/blog/软件测试52讲">软件测试52讲</a></li></ul></span><span>面试<ul><li><a href="/blog/面试现场">面试现场</a></li></ul></span><span>杂谈<ul><li><a href="/blog/超级访谈对话张雪峰">超级访谈对话张雪峰</a></li><li><a href="/blog/Git实战手册">Git实战手册</a></li><li><a href="/blog/NodeJS">NodeJS</a></li><li><a href="/blog/ReactJS">ReactJS</a></li><li><a href="/blog/UI设计">UI设计</a></li><li><a href="/blog/webpack4系列教程">webpack4系列教程</a></li><li><a href="/blog/前端知识体系">前端知识体系</a></li><li><a href="/blog/剑指offer刷题笔记">剑指offer刷题笔记</a></li><li><a href="/blog/思考与成长">思考与成长</a></li><li><a href="/blog/设计模式手册">设计模式手册</a></li></ul></span><div class="__dumi-default-navbar-tool"><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "></div></div></div></nav></div><div class="__dumi-default-menu" data-mode="site"><div class="__dumi-default-menu-inner"><div class="__dumi-default-menu-header"><a class="__dumi-default-menu-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog/"></a><h1>大师兄</h1><p></p></div><div class="__dumi-default-menu-mobile-area"><ul class="__dumi-default-menu-nav-list"><li>计算机基础<ul><li><a href="/blog/编译原理之美">编译原理之美</a></li><li><a href="/blog/编译原理实战">编译原理实战</a></li><li><a href="/blog/深入浅出计算机组成原理">深入浅出计算机组成原理</a></li><li><a href="/blog/详解http">详解http</a></li><li><a href="/blog/计算机网络通关29讲">计算机网络通关29讲</a></li><li><a href="/blog/网络排查案例课">网络排查案例课</a></li><li><a href="/blog/linux操作系统">linux操作系统</a></li><li><a href="/blog/linux性能优化实战">linux性能优化实战</a></li><li><a href="/blog/程序员数学基础">程序员数学基础</a></li><li><a href="/blog/趣谈网络协议">趣谈网络协议</a></li><li><a href="/blog/操作系统实战">操作系统实战</a></li><li><a href="/blog/软件工程之美">软件工程之美</a></li><li><a href="/blog/sql必知必会">sql必知必会</a></li><li><a href="/blog/操作系统实战45讲">操作系统实战45讲</a></li><li><a href="/blog/网络编程实战">网络编程实战</a></li></ul></li><li>算法<ul><li><a href="/blog/常用算法25讲">常用算法25讲</a></li><li><a href="/blog/数据结构与算法之美">数据结构与算法之美</a></li><li><a href="/blog/业务开发算法50讲">业务开发算法50讲</a></li><li><a href="/blog/动态规划面试宝典">动态规划面试宝典</a></li></ul></li><li>前端开发<ul><li><a href="/blog/浏览器工作原理与实践">浏览器工作原理与实践</a></li><li><a href="/blog/新时代产品经理进阶之路">新时代产品经理进阶之路</a></li><li><a href="/blog/全栈工程师修炼指南">全栈工程师修炼指南</a></li><li><a href="/blog/flutter核心技术与实战">flutter核心技术与实战</a></li><li><a href="/blog/java-script核心原理解析">java-script核心原理解析</a></li><li><a href="/blog/说透低代码">说透低代码</a></li><li><a href="/blog/nodejs应用开发实战">nodejs应用开发实战</a></li><li><a href="/blog/反爬虫兵法演绎20讲">反爬虫兵法演绎20讲</a></li><li><a href="/blog/reactnative新架构实战课">reactnative新架构实战课</a></li><li><a href="/blog/正则表达式入门">正则表达式入门</a></li><li><a href="/blog/重学前端">重学前端</a></li><li><a href="/blog/serverless入门课">serverless入门课</a></li><li><a href="/blog/type-script入门实战笔记">type-script入门实战笔记</a></li><li><a href="/blog/图解googlev8">图解googlev8</a></li><li><a href="/blog/vue3源码分析">vue3源码分析</a></li><li><a href="/blog/玩转Vue3全家桶">玩转Vue3全家桶</a></li><li><a href="/blog/webassembly入门">webassembly入门</a></li><li><a href="/blog/手把手带你写一个Web框架">手把手带你写一个Web框架</a></li><li><a href="/blog/web漏洞挖掘实战">web漏洞挖掘实战</a></li><li><a href="/blog/跟月影学可视化">跟月影学可视化</a></li><li><a href="/blog/搞定音频技术">搞定音频技术</a></li><li><a href="/blog/攻克视频技术">攻克视频技术</a></li></ul></li><li>前端工程化<ul><li><a href="/blog/logger">logger</a></li><li><a href="/blog/webpack">webpack</a></li><li><a href="/blog/webpackChain">webpackChain</a></li></ul></li><li>前端性能优化<ul><li><a href="/blog/react性能调优">react性能调优</a></li></ul></li><li>软件测试<ul><li><a aria-current="page" class="active" href="/blog/全链路压测实战30讲">全链路压测实战30讲</a></li><li><a href="/blog/性能测试实战30讲">性能测试实战30讲</a></li><li><a href="/blog/自动化测试高手课">自动化测试高手课</a></li><li><a href="/blog/软件测试52讲">软件测试52讲</a></li></ul></li><li>面试<ul><li><a href="/blog/面试现场">面试现场</a></li></ul></li><li>杂谈<ul><li><a href="/blog/超级访谈对话张雪峰">超级访谈对话张雪峰</a></li><li><a href="/blog/Git实战手册">Git实战手册</a></li><li><a href="/blog/NodeJS">NodeJS</a></li><li><a href="/blog/ReactJS">ReactJS</a></li><li><a href="/blog/UI设计">UI设计</a></li><li><a href="/blog/webpack4系列教程">webpack4系列教程</a></li><li><a href="/blog/前端知识体系">前端知识体系</a></li><li><a href="/blog/剑指offer刷题笔记">剑指offer刷题笔记</a></li><li><a href="/blog/思考与成长">思考与成长</a></li><li><a href="/blog/设计模式手册">设计模式手册</a></li></ul></li></ul><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "><button title="Dark theme" class="__dumi-default-dark-moon "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="3854" width="22" height="22"><path d="M991.816611 674.909091a69.166545 69.166545 0 0 0-51.665455-23.272727 70.795636 70.795636 0 0 0-27.438545 5.585454A415.674182 415.674182 0 0 1 754.993338 698.181818c-209.594182 0-393.472-184.785455-393.472-395.636363 0-52.363636 38.539636-119.621818 69.515637-173.614546 4.887273-8.610909 9.634909-16.756364 14.103272-24.901818A69.818182 69.818182 0 0 0 384.631156 0a70.842182 70.842182 0 0 0-27.438545 5.585455C161.678429 90.298182 14.362065 307.898182 14.362065 512c0 282.298182 238.824727 512 532.38691 512a522.286545 522.286545 0 0 0 453.957818-268.334545A69.818182 69.818182 0 0 0 991.816611 674.909091zM546.679156 954.181818c-248.785455 0-462.941091-192-462.941091-442.181818 0-186.647273 140.637091-372.829091 300.939637-442.181818-36.817455 65.629091-92.578909 151.970909-92.578909 232.727273 0 250.181818 214.109091 465.454545 462.917818 465.454545a488.331636 488.331636 0 0 0 185.181091-46.545455 453.003636 453.003636 0 0 1-393.565091 232.727273z m103.656728-669.323636l-14.266182 83.781818a34.909091 34.909091 0 0 0 50.362182 36.770909l74.775272-39.563636 74.752 39.563636a36.142545 36.142545 0 0 0 16.174546 3.956364 34.909091 34.909091 0 0 0 34.210909-40.727273l-14.289455-83.781818 60.509091-59.345455a35.025455 35.025455 0 0 0-19.223272-59.578182l-83.61891-12.101818-37.376-76.101818a34.56 34.56 0 0 0-62.254545 0l-37.376 76.101818-83.618909 12.101818a34.909091 34.909091 0 0 0-19.246546 59.578182z m70.423272-64.698182a34.280727 34.280727 0 0 0 26.135273-19.083636l14.312727-29.090909 14.336 29.090909a34.257455 34.257455 0 0 0 26.135273 19.083636l32.046546 4.887273-23.272728 22.574545a35.234909 35.234909 0 0 0-10.007272 30.952727l5.46909 32.116364-28.625454-15.127273a34.490182 34.490182 0 0 0-32.302546 0l-28.695272 15.127273 5.469091-32.116364a35.141818 35.141818 0 0 0-9.984-30.952727l-23.272728-22.574545z" p-id="3855"></path></svg></button><button title="Light theme" class="__dumi-default-dark-sun "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="4026" width="22" height="22"><path d="M915.2 476.16h-43.968c-24.704 0-44.736 16-44.736 35.84s20.032 35.904 44.736 35.904H915.2c24.768 0 44.8-16.064 44.8-35.904s-20.032-35.84-44.8-35.84zM512 265.6c-136.704 0-246.464 109.824-246.464 246.4 0 136.704 109.76 246.464 246.464 246.464S758.4 648.704 758.4 512c0-136.576-109.696-246.4-246.4-246.4z m0 425.6c-99.008 0-179.2-80.128-179.2-179.2 0-98.944 80.192-179.2 179.2-179.2S691.2 413.056 691.2 512c0 99.072-80.192 179.2-179.2 179.2zM197.44 512c0-19.84-19.136-35.84-43.904-35.84H108.8c-24.768 0-44.8 16-44.8 35.84s20.032 35.904 44.8 35.904h44.736c24.768 0 43.904-16.064 43.904-35.904zM512 198.464c19.776 0 35.84-20.032 35.84-44.8v-44.8C547.84 84.032 531.84 64 512 64s-35.904 20.032-35.904 44.8v44.8c0 24.768 16.128 44.864 35.904 44.864z m0 627.136c-19.776 0-35.904 20.032-35.904 44.8v44.736C476.096 940.032 492.16 960 512 960s35.84-20.032 35.84-44.8v-44.736c0-24.768-16.064-44.864-35.84-44.864z m329.92-592.832c17.472-17.536 20.288-43.072 6.4-57.024-14.016-14.016-39.488-11.2-57.024 6.336-4.736 4.864-26.496 26.496-31.36 31.36-17.472 17.472-20.288 43.008-6.336 57.024 13.952 14.016 39.488 11.2 57.024-6.336 4.8-4.864 26.496-26.56 31.296-31.36zM213.376 759.936c-4.864 4.8-26.56 26.624-31.36 31.36-17.472 17.472-20.288 42.944-6.4 56.96 14.016 13.952 39.552 11.2 57.024-6.336 4.8-4.736 26.56-26.496 31.36-31.36 17.472-17.472 20.288-43.008 6.336-56.96-14.016-13.952-39.552-11.072-56.96 6.336z m19.328-577.92c-17.536-17.536-43.008-20.352-57.024-6.336-14.08 14.016-11.136 39.488 6.336 57.024 4.864 4.864 26.496 26.56 31.36 31.424 17.536 17.408 43.008 20.288 56.96 6.336 14.016-14.016 11.264-39.488-6.336-57.024-4.736-4.864-26.496-26.56-31.296-31.424z m527.168 628.608c4.864 4.864 26.624 26.624 31.36 31.424 17.536 17.408 43.072 20.224 57.088 6.336 13.952-14.016 11.072-39.552-6.4-57.024-4.864-4.8-26.56-26.496-31.36-31.36-17.472-17.408-43.072-20.288-57.024-6.336-13.952 14.016-11.008 39.488 6.336 56.96z" p-id="4027"></path></svg></button><button title="Default to system" class="__dumi-default-dark-auto "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="11002" width="22" height="22"><path d="M127.658667 492.885333c0-51.882667 10.24-101.717333 30.378666-149.162666s47.786667-88.064 81.92-122.538667 75.093333-61.781333 122.538667-81.92 96.938667-30.378667 149.162667-30.378667 101.717333 10.24 149.162666 30.378667 88.405333 47.786667 122.88 81.92 61.781333 75.093333 81.92 122.538667 30.378667 96.938667 30.378667 149.162666-10.24 101.717333-30.378667 149.162667-47.786667 88.405333-81.92 122.88-75.093333 61.781333-122.88 81.92-97.28 30.378667-149.162666 30.378667-101.717333-10.24-149.162667-30.378667-88.064-47.786667-122.538667-81.92-61.781333-75.093333-81.92-122.88-30.378667-96.938667-30.378666-149.162667z m329.045333 0c0 130.048 13.994667 244.394667 41.984 343.381334h12.970667c46.762667 0 91.136-9.216 133.461333-27.306667s78.848-42.666667 109.568-73.386667 54.954667-67.242667 73.386667-109.568 27.306667-86.698667 27.306666-133.461333c0-46.421333-9.216-90.794667-27.306666-133.12s-42.666667-78.848-73.386667-109.568-67.242667-54.954667-109.568-73.386667-86.698667-27.306667-133.461333-27.306666h-11.605334c-28.672 123.562667-43.349333 237.909333-43.349333 343.722666z" p-id="11003"></path></svg></button></div></div></div><ul class="__dumi-default-menu-list"><li><a href="/blog/全链路压测实战30讲">全链路压测实战30讲</a></li><li><a href="/blog/全链路压测实战30讲/01.开篇词">01.开篇词</a><ul><li><a href="/blog/全链路压测实战30讲/01.开篇词/01"><span>开篇词 | 打破认知神话，做接地气的全链路压测</span></a></li></ul></li><li><a href="/blog/全链路压测实战30讲/02.核心理论">02.核心理论</a><ul><li><a href="/blog/全链路压测实战30讲/02.核心理论/01"><span>01 | 全链路压测：为什么很多测试人员迷信它？</span></a></li><li><a href="/blog/全链路压测实战30讲/02.核心理论/02"><span>02 | RESAR 全链路流程：如何搞定所有容量场景？</span></a></li></ul></li><li><a href="/blog/全链路压测实战30讲/03.实践需求">03.实践需求</a><ul><li><a href="/blog/全链路压测实战30讲/03.实践需求/01"><span>03 | 压测方案：你是否忽略了一个重量级文档？</span></a></li><li><a href="/blog/全链路压测实战30讲/03.实践需求/02"><span>04 | 核心链路：如何梳理符合真实业务场景的核心链路？</span></a></li><li><a href="/blog/全链路压测实战30讲/03.实践需求/03"><span>05 | 铺底数据：真实的压测数据应该做成什么样子？</span></a></li><li><a href="/blog/全链路压测实战30讲/03.实践需求/04"><span>06 | 流量构建：流量平台如何选型？</span></a></li><li><a href="/blog/全链路压测实战30讲/03.实践需求/05"><span>07 | 全栈监控：如何设计全栈监控策略？</span></a></li><li><a href="/blog/全链路压测实战30讲/03.实践需求/06"><span>08 | 基础设施：全链路压测的环境有什么特点？</span></a></li><li><a href="/blog/全链路压测实战30讲/03.实践需求/07"><span>09 | 压测模型：如何建立一套完整的全链路压测模型？</span></a></li><li><a href="/blog/全链路压测实战30讲/03.实践需求/08"><span>10 | 场景执行：压测执行过程中的关键步骤是什么？</span></a></li><li><a href="/blog/全链路压测实战30讲/03.实践需求/09"><span>11 | 链路追踪：如何选择一款适合自己项目的工具？</span></a></li><li><a href="/blog/全链路压测实战30讲/03.实践需求/10"><span>12 | 链路追踪：如何对一个具体的项目进行追踪改造？</span></a></li><li><a href="/blog/全链路压测实战30讲/03.实践需求/11"><span>13 | 标记透传：微服务系统如何做标记透传方案选型？</span></a></li><li><a href="/blog/全链路压测实战30讲/03.实践需求/12"><span>14 | 标记透传：如何基于微服务技术进行标记透传？</span></a></li><li><a href="/blog/全链路压测实战30讲/03.实践需求/13"><span>15 | 流量隔离：MySQL数据库隔离是怎么做的？</span></a></li><li><a href="/blog/全链路压测实战30讲/03.实践需求/14"><span>16 | 流量隔离：Redis 缓存隔离是怎么做的？</span></a></li><li><a href="/blog/全链路压测实战30讲/03.实践需求/15"><span>17 | 流量隔离：MongoDB 数据库隔离是怎么做的？</span></a></li><li><a href="/blog/全链路压测实战30讲/03.实践需求/16"><span>18 | 流量隔离：RabbitMQ 消息隔离是怎么做的？</span></a></li><li><a href="/blog/全链路压测实战30讲/03.实践需求/17"><span>19｜日志隔离：如何落地日志隔离？</span></a></li><li><a href="/blog/全链路压测实战30讲/03.实践需求/18"><span>20 | Mock：如何屏蔽第三方接口的影响？</span></a></li></ul></li><li><a aria-current="page" class="active" href="/blog/全链路压测实战30讲/04.实践环境">04.实践环境</a><ul><li><a href="/blog/全链路压测实战30讲/04.实践环境/01"><span>21 | 压测平台：高效搭建 GoReplay 压测平台</span></a></li><li><a href="/blog/全链路压测实战30讲/04.实践环境/02"><span>22 | 压测平台：如何解决 GoReplay 动态数据关联？</span></a></li><li><a href="/blog/全链路压测实战30讲/04.实践环境/03"><span>23 | 压测平台：如何改造对象存储和性能监控？</span></a></li><li><a aria-current="page" class="active" href="/blog/全链路压测实战30讲/04.实践环境/04"><span>24 | 压测平台：如何改造分布式调度平台？</span></a></li><li><a href="/blog/全链路压测实战30讲/04.实践环境/05"><span>25 | 环境搭建：我们的系统是怎么搭建起来的？</span></a></li><li><a href="/blog/全链路压测实战30讲/04.实践环境/06"><span>26 | 全局监控（上）：如何快速落地全局监控？</span></a></li><li><a href="/blog/全链路压测实战30讲/04.实践环境/07"><span>27 | 全局监控（下）：如何快速落地全局监控？</span></a></li><li><a href="/blog/全链路压测实战30讲/04.实践环境/08"><span>28 | 定向监控：怎样快速发现业务异常？</span></a></li></ul></li><li><a href="/blog/全链路压测实战30讲/05.实践性能场景执行">05.实践性能场景执行</a><ul><li><a href="/blog/全链路压测实战30讲/05.实践性能场景执行/01"><span>29 | 基准场景：一个案例，带你搞懂基准场景的关键要点</span></a></li><li><a href="/blog/全链路压测实战30讲/05.实践性能场景执行/02"><span>30 | 预压测：如何基于小流量快速验证容量压测效果？</span></a></li><li><a href="/blog/全链路压测实战30讲/05.实践性能场景执行/03"><span>31 | 容量场景：决定线上容量场景的关键因素是什么？</span></a></li><li><a href="/blog/全链路压测实战30讲/05.实践性能场景执行/04"><span>32 | 稳定性场景：怎样搞定线上稳定性场景？</span></a></li><li><a href="/blog/全链路压测实战30讲/05.实践性能场景执行/05"><span>33 | 异常场景：如何模拟线上不同组件的异常场景？</span></a></li><li><a href="/blog/全链路压测实战30讲/05.实践性能场景执行/06"><span>34 | 容量规划：如何精准地对生产系统做容量预估？</span></a></li></ul></li><li><a href="/blog/全链路压测实战30讲/06.性能结果报告">06.性能结果报告</a><ul><li><a href="/blog/全链路压测实战30讲/06.性能结果报告/01"><span>35 | 压测报告：怎样写出一份让老板满意的报告？</span></a></li></ul></li><li><a href="/blog/全链路压测实战30讲/07.结束语">07.结束语</a><ul><li><a href="/blog/全链路压测实战30讲/07.结束语/01"><span>结束语 | 做能落地的全链路压测项目</span></a></li><li><a href="/blog/全链路压测实战30讲/07.结束语/02"><span>期末考试 |《全链路压测实战30讲》满分试卷，等你来挑战！</span></a></li></ul></li><li><a href="/blog/全链路压测实战30讲/summary">全链路压测实战30讲</a></li></ul></div></div><ul role="slug-list" class="__dumi-default-layout-toc"><li title="分布式调度平台的选型" data-depth="2"><a href="/blog/全链路压测实战30讲/04.实践环境/04#分布式调度平台的选型"><span>分布式调度平台的选型</span></a></li><li title="XXL-JOB 基本概念" data-depth="2"><a href="/blog/全链路压测实战30讲/04.实践环境/04#xxl-job-基本概念"><span>XXL-JOB 基本概念</span></a></li><li title="分布式调度平台的落地思路" data-depth="2"><a href="/blog/全链路压测实战30讲/04.实践环境/04#分布式调度平台的落地思路"><span>分布式调度平台的落地思路</span></a></li><li title="分布式调度平台的落地实践" data-depth="2"><a href="/blog/全链路压测实战30讲/04.实践环境/04#分布式调度平台的落地实践"><span>分布式调度平台的落地实践</span></a></li><li title="" data-depth="3"><a href="/blog/全链路压测实战30讲/04.实践环境/04"><span></span></a></li><li title="通用 RESTful API 支持" data-depth="2"><a href="/blog/全链路压测实战30讲/04.实践环境/04#通用-restful-api-支持"><span>通用 RESTful API 支持</span></a></li><li title="总结" data-depth="2"><a href="/blog/全链路压测实战30讲/04.实践环境/04#总结"><span>总结</span></a></li><li title="思考题" data-depth="2"><a href="/blog/全链路压测实战30讲/04.实践环境/04#思考题"><span>思考题</span></a></li></ul><div class="__dumi-default-layout-content"><div class="markdown"><h1 id="24--压测平台如何改造分布式调度平台"><a aria-hidden="true" tabindex="-1" href="/blog/全链路压测实战30讲/04.实践环境/04#24--压测平台如何改造分布式调度平台"><span class="icon icon-link"></span></a>24 | 压测平台：如何改造分布式调度平台？</h1><p>你好，我是高楼。</p><p>这节课，我们继续来讲分布式压测平台的改造。在上一讲，我们已经知道了对象存储和性能监控的实现步骤，这节课，我们来看看分布式调度的改造。</p><h2 id="分布式调度平台的选型"><a aria-hidden="true" tabindex="-1" href="/blog/全链路压测实战30讲/04.实践环境/04#分布式调度平台的选型"><span class="icon icon-link"></span></a>分布式调度平台的选型</h2><p>在 Java 技术栈中，传统的任务调度实现方案，比如 Quartz、Timer，都存在一些问题，例如：</p><ul><li>仅单点，不支持集群任务分发；</li><li>无法统计任务执行数据；</li><li>没有监控任务执行状态；</li><li>没有任务异常告警；</li><li>没有 web 后台管理。</li></ul><p>但在如今的全链路压测场景中，大部分的压测平台都是分布式架构，它对任务调度的需求也更高，例如：</p><ul><li>当同一个压力机或多个压力机的下发任务互斥时，需要做到统一的调度；</li><li>下发的任务需要支持高可用、实时监控、异常告警等功能；</li><li>压力机集群需要支持动态、协同进行压测，能应付高并发海量流量的场景；</li><li>需要统一的管理并能够追踪各压力机任务执行结果，需要快速记录各种任务的属性数据。</li></ul><p>也就是说，传统的任务调度实现方案已经不能满足全链路压测平台的需求了。这时候，我们就需要一个分布式任务调度平台。目前业界比较主流的中间件有哪些呢？<br/><img src="https://static001.geekbang.org/resource/image/7e/f2/7e6d4yy6334c6c5e02a21144056934f2.jpg?wh=1920x2462" alt=""/><br/>目前业界比较主流的中间件主要有<a target="_blank" rel="noopener noreferrer" href="https://link.segmentfault.com/?url=http%3A%2F%2Felasticjob.io%2F">Elastic-Job<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>、<a target="_blank" rel="noopener noreferrer" href="https://link.segmentfault.com/?url=https%3A%2F%2Fwww.xuxueli.com%2Fxxl-job%2F">XXL-JOB<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>和Quartz三种。由于 XXL-JOB 的热度足够（目前关于 XXL-JOB 的 GitHub Stars 有 20.1k 个，登记在用的公司有 446 个），另外它的开发迅速、学习简单、轻量级、易扩展，这些特性都挺适合我们这个全链路压测项目的。综合考虑后，最后我们选择了<strong>XXL-JOB</strong>。</p><h2 id="xxl-job-基本概念"><a aria-hidden="true" tabindex="-1" href="/blog/全链路压测实战30讲/04.实践环境/04#xxl-job-基本概念"><span class="icon icon-link"></span></a>XXL-JOB 基本概念</h2><p>既然选定了 XXL-JOB，就要先了解一下 XXL-JOB 的基本结构。</p><p>下面是一张 XXL-JOB （V2.1.0）的官网架构图。</p><p><img src="https://static001.geekbang.org/resource/image/c8/a0/c897f1feea1a144b751f456ea916efa0.png?wh=1500x822" alt="图片"/></p><p>从图中我们也可以很直观地看到，XXL-JOB 主要包括两大模块：</p><ul><li><strong>调度模块（调度中心）</strong>：负责管理调度信息，按照调度配置发出调度请求，它自身不承担业务代码。这种调度系统与任务解耦的方式，提高了系统可用性和稳定性，也让调度系统性能不再受限于任务模块。另外，调度中心支持可视化、简单且动态地管理调度信息，例如任务新建、更新、删除、GLUE 开发和任务报警等，所有上述操作都会实时生效。调度中心还支持监控调度结果以及执行日志，支持执行器 Failover。</li><li><strong>执行模块（执行器）</strong>：负责接收调度请求并执行任务逻辑。它可以让任务模块专注于任务的执行等操作，让开发和维护更加简单高效。</li></ul><p>为了方便理解，我这里画了一个更加精简的逻辑图：</p><p><img src="https://static001.geekbang.org/resource/image/f6/7a/f689a85fc158522b8fa93e20a8a1f17a.jpg?wh=1920x1878" alt="图片"/></p><p>可以看到，调度器和执行器是独立的。调度器决定任务的调度，并且通过 HTTP 的方式调用执行器接口，执行相应任务。</p><h2 id="分布式调度平台的落地思路"><a aria-hidden="true" tabindex="-1" href="/blog/全链路压测实战30讲/04.实践环境/04#分布式调度平台的落地思路"><span class="icon icon-link"></span></a>分布式调度平台的落地思路</h2><p>那么，我们要怎么通过分布式调度平台来满足我们的需求呢？要清楚这一点，我们就要先理清执行器在流量平台的主要用途，它可以：</p><ol><li>管理 GoReplay 的生命周期 ，可以调起和终止 GoReplay 程序；</li><li>回传状态（在 GoReplay 启动、结束、或其他标志性事件结束后都会向调度服务回传状态）；</li><li>对录制和回放的相关文件进行下载、处理和回传；</li><li>实时 Rolling 日志，记录 GoReplay 输出的状态数据，便于实时监控。</li></ol><p>对于我们分布式流量平台来说，主要的需求就是流量录制和流量回放操作的调度。我们先来熟悉一下这两种调度方式的落地思路，再来进行具体的实战演示。</p><p>流量录制主要过程：</p><ol><li>用户设置录制参数，定义录制命令，创建录制任务；</li><li>调度中心生成录制任务，并下发到对应网关的执行器上；</li><li>执行器收到录制命令，回传状态给调度中心，随即执行对应录制命令，拉起 GoReplay 程序；</li><li>录制结束后，GoReplay 程序退出，执行器回传状态给调度中心；</li><li>调度中心判定录制任务结束后，下发上传文件子任务到相关执行器上，执行器执行上传命令将对应的流量文件通过 HTTP 上传到对象存储中；</li><li>流量录制任务结束。</li></ol><p>流量回放的主要过程：</p><ol><li>用户设置回放参数，定义回放命令，创建回放任务；</li><li>调度中心生成回放任务，并下发到对应压力机的执行器上；</li><li>执行器收到回放命令，回传状态给调度服务，随即拉起 GoReplay 程序；</li><li>回放结束，GoReplay 退出，执行器回传状态给调度中心；</li><li>流量回放任务结束。</li></ol><p>好了，了解了流量平台的调度使用过程，我们就来一起看看具体怎样去落地。</p><h2 id="分布式调度平台的落地实践"><a aria-hidden="true" tabindex="-1" href="/blog/全链路压测实战30讲/04.实践环境/04#分布式调度平台的落地实践"><span class="icon icon-link"></span></a>分布式调度平台的落地实践</h2><p>首先，我们需要搭建 XXL-JOB 调度平台，具体的搭建和系统初始化步骤你可以参考<a target="_blank" rel="noopener noreferrer" href="https://www.xuxueli.com/index.html">官方文档<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>。</p><p>搭建成功后，登录调度中心，运行界面如下：</p><p><img src="https://static001.geekbang.org/resource/image/ce/6e/ceb0eb9ba6ed756ebd2f7be9060ce76e.png?wh=1500x783" alt="图片"/></p><p>调度中心支持集群部署，这可以提升调度系统的容灾和可用性。不过，在调度中心集群部署时我有几点建议：</p><ul><li>DB 配置保持一致；</li><li>集群机器时钟保持一致（单机集群忽视）；</li><li>通过 Nginx 为调度中心集群做负载均衡，分配域名（调度中心访问、执行器回调配置、调用 API 服务等操作均通过该域名进行）。</li></ul><p>有了调度平台，我们就可以进行具体的实践了：</p><ul><li>创建执行器</li></ul><p>执行器相当于是包工头，它可以是一个单独项目，也可以集成在其它业务项目里面。要注意的是，执行器首先需要注册到调度中心，这样调度中心才能发现执行器。执行器的执行结果，也需要通过回调的方式反馈给调度中心。</p><p>在源码的 xxl-job-executor-samples 里，有 2 个执行的 demo 教我们如何去创建执行器。</p><p><img src="https://static001.geekbang.org/resource/image/c0/f5/c01677c778cfb355cb12abacf0c8baf5.png?wh=818x1370" alt="图片"/></p><p>这里我用 SpringBoot 项目用来举个例子。首先，要单独拷一个项目出来，如果你想在自己的项目里集成的话，同样也是参考这个 demo，只要在项目 pom 里加上 xxl-job-core 的依赖即可。</p><p><img src="https://static001.geekbang.org/resource/image/54/f0/544998255f82118017e48b1615b7aef0.png?wh=736x1192" alt="图片"/></p><p>然后我们需要修改配置文件 application.properties：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain"># web port</span></div><div class="token-line"><span class="token plain">    server.port=8089</span></div><div class="token-line"><span class="token plain">    # no web</span></div><div class="token-line"><span class="token plain">    #spring.main.web-environment=false</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    # log config</span></div><div class="token-line"><span class="token plain">    logging.config=classpath:logback.xml</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    ### 注册到调度中心</span></div><div class="token-line"><span class="token plain">    ### xxl-job admin address list, such as &quot;http://address&quot; or &quot;http://address01,http://address02&quot;</span></div><div class="token-line"><span class="token plain">    xxl.job.admin.addresses=http://127.0.0.1:8080/xxl-job-admin</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    ### xxl-job, access token</span></div><div class="token-line"><span class="token plain">    xxl.job.accessToken=</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    ### 集群部署，这两项配置要一致</span></div><div class="token-line"><span class="token plain">    ### xxl-job executor appname</span></div><div class="token-line"><span class="token plain">    xxl.job.executor.appname=xxl-job-executor-sample</span></div><div class="token-line"><span class="token plain">    ### xxl-job executor registry-address: default use address to registry , otherwise use ip:port if address is null</span></div><div class="token-line"><span class="token plain">    xxl.job.executor.address=</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    ### xxl-job executor server-info</span></div><div class="token-line"><span class="token plain">    xxl.job.executor.ip=127.0.0.1</span></div><div class="token-line"><span class="token plain">    ### 如果要模拟执行器集群部署，打包后单击运行多次，为服务设置随机端口，${random.int[10000,19999]}</span></div><div class="token-line"><span class="token plain">    xxl.job.executor.port=9999</span></div><div class="token-line"><span class="token plain">    ### 日志存放路径</span></div><div class="token-line"><span class="token plain">    ### xxl-job executor log-path</span></div><div class="token-line"><span class="token plain">    xxl.job.executor.logpath=./data/applogs/xxl-job/jobhandler</span></div><div class="token-line"><span class="token plain">    ### xxl-job executor log-retention-days</span></div><div class="token-line"><span class="token plain">    xxl.job.executor.logretentiondays=30</span></div></pre></div><p>接着，我们在 IDEA 启动项目。</p><p><img src="https://static001.geekbang.org/resource/image/a3/7e/a3a7254c614f0afa8761c330da2b2e7e.png?wh=1500x842" alt="图片"/></p><p>最后，我们在调度中心的【执行器管理】模块里新增一个执行器。</p><p><img src="https://static001.geekbang.org/resource/image/e2/14/e264f40c313d9c22e4ffd7bd0e34f314.png?wh=899x764" alt="图片"/></p><p>刷新之后就可以看到我们注册好的的执行器了。</p><p><img src="https://static001.geekbang.org/resource/image/5e/7d/5ed834a4c0f7d993caebd3703eaf007d.png?wh=1500x547" alt="图片"/></p><p>到这里，我们的执行器就已经成功被调度中心注册和发现了，下面我们需要创建对应的任务。</p><ul><li>创建流量录制任务</li></ul><p>我们在调度中心新建一个调度任务。这里的运行模式我们选择 GLUE 模式(Shell)。</p><p><img src="https://static001.geekbang.org/resource/image/e2/14/e264f40c313d9c22e4ffd7bd0e34f314.png?wh=899x764" alt="图片"/></p><p>简单说明一下，运行模式主要分为两种，一种是 BEAN，一种是 GLUE：</p><ul><li>BEAN 模式：在项目中写 Java 类，然后在 JobHandler 里填上 @XxlJob 里面的名字，它是在执行器端代码编写的；</li><li>GLUE 模式：支持 Java、Shell、Python、PHP、Nodejs、PowerShell，以源码方式直接维护在调度中心，该任务实际上是一段对应脚本的执行。</li></ul><p>我们知道 GoReplay 的所有操作都是通过命令行组织的，所以 GLUE模式的Shell脚本是满足我们的需求的，且能做到集中式管理。</p><p>首先创建任务，点击该任务右侧的“GLUE”按钮，前往 GLUE 任务的 Web IDE 界面。这个界面支持对任务代码进行开发（也可以在 IDE 中开发完成后，复制粘贴到 Web IDE 中）。</p><p><img src="https://static001.geekbang.org/resource/image/5f/2d/5fccd03d6438b93b15c4cdc07a1eb02d.png?wh=1905x676" alt="图片"/></p><p>你可以看看我们在 IDE 中开发的流量录制命令。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">#!/bin/bash</span></div><div class="token-line"><span class="token plain">    echo &quot;xxl-job: hello shell&quot;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    echo &quot;脚本位置：$0&quot;</span></div><div class="token-line"><span class="token plain">    echo &quot;任务参数：$1&quot;</span></div><div class="token-line"><span class="token plain">    echo &quot;分片序号 = $2&quot;</span></div><div class="token-line"><span class="token plain">    echo &quot;分片总数 = $3&quot;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    cd /Users/GoProjects/src/goreplay/examples/middleware</span></div><div class="token-line"><span class="token plain">    ./goreplay --input-raw :8201 --output-file=request-mall-all.gor -output-file-append --http-set-header &quot;dunshan:7DGroup&quot; --http-set-header &quot;User-Agent:Replayed-by-Gor&quot; --input-raw-track-response --prettify-http --http-disallow-url /actuator/health</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    echo &quot;Good bye!&quot;</span></div><div class="token-line"><span class="token plain">    exit 0</span></div></pre></div><p>刚才我们说过，因为GLUE这个模式的任务实际上是一段 “Shell” 脚本，所以任务建好后会存在一个安全问题：我们没有做鉴权。要解决这个问题方法也很简单，只需要在调度中心和执行器的 application.properties 里加上相同的 token 即可。</p><p>任务建好后，在执行时，我们可以传入任务参数，这里我们传入的是监听端口号8081。</p><p><img src="https://static001.geekbang.org/resource/image/f3/dc/f31020b359cff249081a882b56f3b2dc.png?wh=601x317" alt="图片"/></p><p>好了，开发完成后，我们点击启动：</p><p><img src="https://static001.geekbang.org/resource/image/0f/c8/0fb3a118815427f20792798fbae5e0c8.png?wh=1500x474" alt="图片"/></p><p>点击执行日志右侧的 “执行日志” 按钮，可跳转至执行日志界面查看业务代码中打印的完整日志：</p><p><img src="https://static001.geekbang.org/resource/image/5f/09/5f646acef4d995397952189a0aaae409.png?wh=1500x547" alt="图片"/></p><p>点击“日志”按钮，可以查看任务历史调度日志，每次任务调度的调度结果、执行结果等。点击“执行日志”按钮可查看执行器完整日志。</p><p><img src="https://static001.geekbang.org/resource/image/bc/04/bc3b848848135b61f163bb8bd65ebc04.png?wh=1916x513" alt="图片"/></p><p>好了，到这里我们的流量录制任务就已经定义完了。至于流量回放、文件上传等其它任务的套路和这个类似。你可以按照差不多的步骤进行操作，遇到问题的话也可以来跟我讨论。</p><ul><li>使用子任务</li></ul><p>当我们需要做流量录制时，首先我们需要执行程序初始化任务，然后再执行流量录制任务，最后，我们需要将产生的流量文件上传到对象存储（流量仓库）中。那么，我们要怎么保证数据在三个任务之间顺利传递呢？</p><p><img src="https://static001.geekbang.org/resource/image/fc/6e/fc57cd3d513e89b80d69342b6b373e6e.jpg?wh=1436x229" alt=""/></p><p>解决这种问题的思路一般有两种：</p><ul><li>第一种就是写成一个大 job，让任务串行化执行；</li><li>第二种就是使用多个子任务，在一个上游任务末尾触发另一个子任务。</li></ul><p>如果我们想要在本任务成功执行后触发另外一个任务，可以把另外的任务作为本任务的子任务执行，它的操作也很简单，只需要在子任务一栏填上任务 id 即可：</p><h3 id=""><a aria-hidden="true" tabindex="-1" href="/blog/全链路压测实战30讲/04.实践环境/04"><span class="icon icon-link"></span></a><img src="https://static001.geekbang.org/resource/image/23/a5/23e099333f90b8d67b5f1b0f3910bea5.png?wh=1500x1277" alt="图片"/></h3><ul><li>压测任务分片</li></ul><p>全链路压测中一个显著的特点就是能够实现海量数据的并发请求，但这对于单线程的普通的任务来说是存在瓶颈的。这个时候如果你想提高并发，那么自然就要多线程跑嘛。但是用多线程跑数据也会存在问题，比如我开 3 个执行器，但你会发现只有个别执行器在拼命工作，其它的都处在休息状态。这是一个典型的任务分配不均的问题。</p><p><img src="https://static001.geekbang.org/resource/image/40/ca/40203d86a2322aa9e91975a405f1dcca.jpg?wh=1920x1600" alt="图片"/></p><p>这时候就要用到我们的分片任务了，也就是要多台执行器共同完成任务。</p><p><img src="https://static001.geekbang.org/resource/image/9c/5c/9cc041a7a910759e9d77e192b354db5c.jpg?wh=1920x1619" alt="图片"/></p><p>但这里又有一个问题。比如流量回放的时候，多台压力机都执行同一个流量文件，相同的请求三台压力机都发一遍，那岂不是乱套了。</p><p>这里的解决思路也很简单，我们让每台执行器处理1/3的流量，大家把需要回放的流量文件平均切分了嘛，我干 1/3，你干 1/3，它干 1/3，这样就不会产生冲突了。</p><p>分片任务在运行的时候，调度器会给每个执行器发送一个不同的分片序号，分片的最大序号跟执行器的总数量是一样的，这样可以确保每个执行器都会执行到这个任务。</p><p>比如上图中第一个执行器拿到分片序号 0，第二台执行器拿到分片序号 1，第三台执行器拿到分片序号 2。那现在就好办了，我们只需要把处理的流量文件进行模 3 取余，余数为 0 的文件就由执行器 1 跑，余数为 1 的文件就由执行器 2 跑，余数为 2 的文件就由执行器 3 跑。</p><p>具体的解决方案，我们可以使用路由策略「分片广播」来调度任务：</p><ol><li>通过“任务参数”传入执行任务压力机数量；</li><li>在定时任务逻辑中，根据获取到的分片参数、执行任务压力机数量，决策当前节点是否需要执行，切分流量文件并处理：<ul><li>如果 分片序号 &gt; (执行压力机数量 - 1)，则当前节点不执行任务，直接返回；</li><li>否则，取「分片序号」和 「压力机数量」 作为分片参数，流量文件并处理。</li></ul></li></ol><p>这样，我们可以实现灵活调度 [1, N] 个节点并行执行压测任务。</p><p>我们切分流量文件的代码可以这样写。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">package com.xxl.job.executor.until;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    import cn.hutool.core.io.file.FileReader;</span></div><div class="token-line"><span class="token plain">    import cn.hutool.core.io.file.FileWriter;</span></div><div class="token-line"><span class="token plain">    import org.junit.jupiter.api.Test;</span></div><div class="token-line"><span class="token plain">    import org.junit.platform.commons.util.StringUtils;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    import java.util.*;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    /**</span></div><div class="token-line"><span class="token plain">     * @author dunshan</span></div><div class="token-line"><span class="token plain">     * @description: 分割流量文件</span></div><div class="token-line"><span class="token plain">     * @date 2021-12-04 11:11:11</span></div><div class="token-line"><span class="token plain">     */</span></div><div class="token-line"><span class="token plain">    public class NcountGor {</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        @Test</span></div><div class="token-line"><span class="token plain">        public void countTxt() {</span></div><div class="token-line"><span class="token plain">            //分组</span></div><div class="token-line"><span class="token plain">            int n = 3;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">            LinkedHashSet&lt;String&gt; total = new LinkedHashSet&lt;&gt;();</span></div><div class="token-line"><span class="token plain">            //读取文件</span></div><div class="token-line"><span class="token plain">            FileReader fileReader = new FileReader(&quot;/Users/2021/10/request-mall-all.gor&quot;);</span></div><div class="token-line"><span class="token plain">            String result = countTotal(total, fileReader);</span></div><div class="token-line"><span class="token plain">            System.out.println(&quot;total:&quot; + total.size());</span></div><div class="token-line"><span class="token plain">            //放入 list 中进行分组使用</span></div><div class="token-line"><span class="token plain">            List&lt;String&gt; list = new ArrayList&lt;&gt;();</span></div><div class="token-line"><span class="token plain">            //组装分割文件</span></div><div class="token-line"><span class="token plain">            for (String str : total) {</span></div><div class="token-line"><span class="token plain">                list.add(str);</span></div><div class="token-line"><span class="token plain">            }</span></div><div class="token-line"><span class="token plain">            saveFile(n, result, list);</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        /**</span></div><div class="token-line"><span class="token plain">         * 根据分割数据把文件切割文件</span></div><div class="token-line"><span class="token plain">         *</span></div><div class="token-line"><span class="token plain">         * @param n      切割数据</span></div><div class="token-line"><span class="token plain">         * @param result 文件内容</span></div><div class="token-line"><span class="token plain">         * @param list   分组数据</span></div><div class="token-line"><span class="token plain">         */</span></div><div class="token-line"><span class="token plain">        private void saveFile(int n, String result, List&lt;String&gt; list) {</span></div><div class="token-line"><span class="token plain">            int number = (list.size() / n) + 1;</span></div><div class="token-line"><span class="token plain">            List&lt;List&lt;String&gt;&gt; lists = groupList(list, number);</span></div><div class="token-line"><span class="token plain">            for (int i = 0; i &lt; lists.size(); i++) {</span></div><div class="token-line"><span class="token plain">                //保存文件</span></div><div class="token-line"><span class="token plain">                String path = String.format(&quot;/Users/2021/10/11/request_%s.gor&quot;, i);</span></div><div class="token-line"><span class="token plain">                FileWriter writer = new FileWriter(path);</span></div><div class="token-line"><span class="token plain">                for (int j = 0; j &lt; lists.get(i).size(); j++) {</span></div><div class="token-line"><span class="token plain">                    //分割数据</span></div><div class="token-line"><span class="token plain">                    String[] content = result.split(&quot;\uD83D\uDC35\uD83D\uDE48\uD83D\uDE49&quot;);</span></div><div class="token-line"><span class="token plain">                    for (String s : content) {</span></div><div class="token-line"><span class="token plain">                        if (s.contains(lists.get(i).get(j))) {</span></div><div class="token-line"><span class="token plain">                            writer.append(s);</span></div><div class="token-line"><span class="token plain">                            //拼接切割文件</span></div><div class="token-line"><span class="token plain">                            writer.append(&quot;\uD83D\uDC35\uD83D\uDE48\uD83D\uDE49&quot;);</span></div><div class="token-line"><span class="token plain">                        }</span></div><div class="token-line"><span class="token plain">                    }</span></div><div class="token-line"><span class="token plain">                }</span></div><div class="token-line"><span class="token plain">            }</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        /**</span></div><div class="token-line"><span class="token plain">         * 统计流量文件总数</span></div><div class="token-line"><span class="token plain">         *</span></div><div class="token-line"><span class="token plain">         * @param total</span></div><div class="token-line"><span class="token plain">         * @param fileReader</span></div><div class="token-line"><span class="token plain">         * @return</span></div><div class="token-line"><span class="token plain">         */</span></div><div class="token-line"><span class="token plain">        private String countTotal(LinkedHashSet&lt;String&gt; total, FileReader fileReader) {</span></div><div class="token-line"><span class="token plain">            String result = fileReader.readString();</span></div><div class="token-line"><span class="token plain">            String[] twoLine = result.split(&quot;\r\n&quot;);</span></div><div class="token-line"><span class="token plain">            for (String str : twoLine) {</span></div><div class="token-line"><span class="token plain">                if (StringUtils.isNotBlank(str)) {</span></div><div class="token-line"><span class="token plain">                    //转换字符数组</span></div><div class="token-line"><span class="token plain">                    char[] chars = str.toCharArray();</span></div><div class="token-line"><span class="token plain">                    //判断第一个字母是否是一</span></div><div class="token-line"><span class="token plain">                    if (String.valueOf(chars[0]).equals(&quot;1&quot;)) {</span></div><div class="token-line"><span class="token plain">                        total.add(str.substring(2, 26));</span></div><div class="token-line"><span class="token plain">                    }</span></div><div class="token-line"><span class="token plain">                }</span></div><div class="token-line"><span class="token plain">            }</span></div><div class="token-line"><span class="token plain">            return result;</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        /**</span></div><div class="token-line"><span class="token plain">         * 流量文件分组</span></div><div class="token-line"><span class="token plain">         *</span></div><div class="token-line"><span class="token plain">         * @param list 流量文件</span></div><div class="token-line"><span class="token plain">         * @param n    每个数组多少</span></div><div class="token-line"><span class="token plain">         * @return 分组</span></div><div class="token-line"><span class="token plain">         */</span></div><div class="token-line"><span class="token plain">        private static List&lt;List&lt;String&gt;&gt; groupList(List&lt;String&gt; list, Integer n) {</span></div><div class="token-line"><span class="token plain">            // 求余数</span></div><div class="token-line"><span class="token plain">            int remainder = list.size() % n;</span></div><div class="token-line"><span class="token plain">            // 求分组数</span></div><div class="token-line"><span class="token plain">            int count0 = list.size() / n;</span></div><div class="token-line"><span class="token plain">            boolean flag = false;</span></div><div class="token-line"><span class="token plain">            if (remainder &gt;= n / 1) {</span></div><div class="token-line"><span class="token plain">                flag = true;</span></div><div class="token-line"><span class="token plain">            }</span></div><div class="token-line"><span class="token plain">            List&lt;List&lt;String&gt;&gt; data = new ArrayList&lt;&gt;();</span></div><div class="token-line"><span class="token plain">            // 获取多余 list</span></div><div class="token-line"><span class="token plain">            List&lt;String&gt; sub = new ArrayList&lt;&gt;(list.subList(list.size() - remainder, list.size()));</span></div><div class="token-line"><span class="token plain">            // 遍历 list 到余数前</span></div><div class="token-line"><span class="token plain">            for (int i = 0; i &lt; count0 + 1; i++) {</span></div><div class="token-line"><span class="token plain">                List&lt;String&gt; ls;</span></div><div class="token-line"><span class="token plain">                if (flag) {</span></div><div class="token-line"><span class="token plain">                    if (i == count0) {</span></div><div class="token-line"><span class="token plain">                        break;</span></div><div class="token-line"><span class="token plain">                    }</span></div><div class="token-line"><span class="token plain">                    ls = new ArrayList&lt;&gt;(list.subList(i * n, i * n + n));</span></div><div class="token-line"><span class="token plain">                    // 将余出的数据加入分组</span></div><div class="token-line"><span class="token plain">                    if (i &lt; sub.size()) {</span></div><div class="token-line"><span class="token plain">                        ls.add(sub.get(i));</span></div><div class="token-line"><span class="token plain">                    }</span></div><div class="token-line"><span class="token plain">                } else {</span></div><div class="token-line"><span class="token plain">                    int endex = i * n + n;</span></div><div class="token-line"><span class="token plain">                    if (endex &gt;= list.size()) {</span></div><div class="token-line"><span class="token plain">                        endex = list.size();</span></div><div class="token-line"><span class="token plain">                    }</span></div><div class="token-line"><span class="token plain">                    ls = new ArrayList&lt;&gt;(list.subList(i * n, endex));</span></div><div class="token-line"><span class="token plain">                }</span></div><div class="token-line"><span class="token plain">                if (ls.size() != 0) {</span></div><div class="token-line"><span class="token plain">                    data.add(ls);</span></div><div class="token-line"><span class="token plain">                }</span></div><div class="token-line"><span class="token plain">            }</span></div><div class="token-line"><span class="token plain">            return data;</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>切分的文件效果如下：</p><p><img src="https://static001.geekbang.org/resource/image/56/fe/5631878728d5a595270be192dc16a2fe.png?wh=481x149" alt="图片"/></p><p>JobHandler 中的实现可以参考下面这种写法：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">/**</span></div><div class="token-line"><span class="token plain">         * 2、分片广播任务</span></div><div class="token-line"><span class="token plain">         */</span></div><div class="token-line"><span class="token plain">        @XxlJob(&quot;shardingJobHandler&quot;)</span></div><div class="token-line"><span class="token plain">        public void multiMachineMultiTasks() throws Exception {</span></div><div class="token-line"><span class="token plain">            String param = XxlJobHelper.getJobParam();</span></div><div class="token-line"><span class="token plain">            if (StringUtils.isBlank(param)) {</span></div><div class="token-line"><span class="token plain">                XxlJobHelper.log(&quot;任务参数为空&quot;);</span></div><div class="token-line"><span class="token plain">                XxlJobHelper.handleFail();</span></div><div class="token-line"><span class="token plain">                return;</span></div><div class="token-line"><span class="token plain">            }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">            //读取文件</span></div><div class="token-line"><span class="token plain">            FileReader fileReader = new FileReader(param);</span></div><div class="token-line"><span class="token plain">            //总分片数</span></div><div class="token-line"><span class="token plain">            String shardTotal = countTotal(total, fileReader);</span></div><div class="token-line"><span class="token plain">            //分片参数</span></div><div class="token-line"><span class="token plain">            int shardIndex = XxlJobHelper.getShardIndex();</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">            XxlJobHelper.log(&quot;分片参数：当前分片序号 = {}, 总分片数 = {}&quot;, shardIndex, shardTotal);</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">            LinkedHashSet&lt;String&gt; total = new LinkedHashSet&lt;&gt;();</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">            //放入 list 中进行分组使用</span></div><div class="token-line"><span class="token plain">            List&lt;String&gt; list = new ArrayList&lt;&gt;();</span></div><div class="token-line"><span class="token plain">            //组装分割文件</span></div><div class="token-line"><span class="token plain">            for (String str : total) {</span></div><div class="token-line"><span class="token plain">                list.add(str);</span></div><div class="token-line"><span class="token plain">            }</span></div><div class="token-line"><span class="token plain">            saveFile(n, result, list);</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">            // 业务逻辑</span></div><div class="token-line"><span class="token plain">            for (int i = 0; i &lt; shardTotal; i++) {</span></div><div class="token-line"><span class="token plain">                if (i == shardIndex) {</span></div><div class="token-line"><span class="token plain">                    XxlJobHelper.log(&quot;第 {} 片, 命中分片开始处理&quot;, i);</span></div><div class="token-line"><span class="token plain">                    //分片流量回放</span></div><div class="token-line"><span class="token plain">                    process(shardIndex, shardTotal);</span></div><div class="token-line"><span class="token plain">                } else {</span></div><div class="token-line"><span class="token plain">                    XxlJobHelper.log(&quot;第 {} 片, 忽略&quot;, i);</span></div><div class="token-line"><span class="token plain">                }</span></div><div class="token-line"><span class="token plain">            }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        }</span></div></pre></div><p>新建任务的时候，我们选择分片任务，填上对应的 JobHandler 即可。</p><p><img src="https://static001.geekbang.org/resource/image/e9/37/e9ec293b698424a858d85bc2cae1fa37.png?wh=1500x1273" alt="图片"/></p><p>最后需要说明一下，分片的数据量不一定是完全均等的，上面的取模只是一个例子、一个思路。我们也可以把 0、1、2 替换成其他条件去从所有数据中获取部分数据。比如分片序号是 0 的压力机回放网关 1 的流量文件，分片序号是 1 的压力机回放网关 2 的流量文件，分片序号是 2 的压力机我回放网关 3 的流量文件，具体怎么分我们可以自由选择。</p><h2 id="通用-restful-api-支持"><a aria-hidden="true" tabindex="-1" href="/blog/全链路压测实战30讲/04.实践环境/04#通用-restful-api-支持"><span class="icon icon-link"></span></a>通用 RESTful API 支持</h2><p>我们知道，线上压测是一项对风险管控要求更高的活动，压测平台需要有更及时的异常预警机制，也就是说，必须要有压测实时监控和异常熔断能力。这就要求我们的调度任务能实时对接第三方的监控系统。</p><p>而XXL-JOB 目标就是一种跨平台、跨语言的任务调度规范和协议。针对第三方监控系统，比如Prometheus，我们可以借助 XXL-JOB 的标准 RESTful API 方便地实现任务回调支持。</p><p>标准 RESTful API 主要包括两部分：</p><ul><li>调度中心 RESTful API：调度中心提供给执行器使用的 API；不局限于官方执行器使用，第三方可使用该 API 来实现执行器。主要包括：执行器注册、任务结果回调等API；</li><li>执行器 RESTful API：执行器提供给调度中心使用的 API；官方执行器默认已实现，第三方执行器需要实现并对接提供给调度中心，任务触发、任务终止、任务日志查询等API。</li></ul><p>除此之外，如果我们有需要通过 API 操作调度中心，可以个性化扩展 “调度中心 RESTful API” 并使用。</p><h2 id="总结"><a aria-hidden="true" tabindex="-1" href="/blog/全链路压测实战30讲/04.实践环境/04#总结"><span class="icon icon-link"></span></a>总结</h2><p>流量平台是一个全链路压测项目的引擎。但对于一个大企业来说，分布式的流量平台是一个必要的条件。</p><p>在全链路分布式流量平台改造中，我强调了几个特性：高可靠、高性能、低成本、高效率。</p><p>我们在做技术改造的时候，一定要牢记下面几项关键原则：</p><ul><li>基于开源，拥抱开源，尽量使用成熟的第三方框架，不重复造轮子；</li><li>技术栈和组件要适合研发团队技术能力及主流技术方向；</li><li>KISS 原则(Keep It Simple and Stupid)；</li><li>尽量考虑 ROI（投入产出比）；</li><li>不断演进迎合公司业务发展。大公司方案不一定是适合的，要避免为技术而技术；</li><li>任何方案不必追求大而全，可以在实践中不断完善和演进；</li><li>需求导向，借力开源，科学选型，快速集成，重视扩展，演进改善。</li></ul><p>刚才，我还把一个分布式流量平台的需求以及需要改造到什么地步，都给你梳理了一遍。希望能给你一些借鉴。</p><h2 id="思考题"><a aria-hidden="true" tabindex="-1" href="/blog/全链路压测实战30讲/04.实践环境/04#思考题"><span class="icon icon-link"></span></a>思考题</h2><p>学完这节课，请你思考两个问题：</p><ol><li>你有没有接触过分布式流量平台的改造工作，请谈谈你的心得。</li><li>关于分布式调度框架，你有没有接触过其它的项目？</li></ol><p>欢迎你在留言区与我交流讨论。当然了，你也可以把这节课分享给你身边的朋友，他们的一些想法或许会让你有更大的收获。我们下节课见！</p></div><div class="__dumi-default-layout-footer-meta"><a target="_blank" rel="noopener noreferrer" href="https://github.com/GGwujun/blog/edit/master/docs/全链路压测实战30讲/04.实践环境/04.md">在 GitHub 上编辑此页<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a><span data-updated-text="最后更新时间：">5/2/2022 10:57:05</span></div></div></div></div>
	<script>
  window.g_useSSR = true;
  window.g_initialProps = {};
	</script>

    <script>
      (function () {
        if (!location.port) {
          (function (i, s, o, g, r, a, m) {
            i["GoogleAnalyticsObject"] = r;
            (i[r] =
              i[r] ||
              function () {
                (i[r].q = i[r].q || []).push(arguments);
              }),
              (i[r].l = 1 * new Date());
            (a = s.createElement(o)), (m = s.getElementsByTagName(o)[0]);
            a.async = 1;
            a.src = g;
            m.parentNode.insertBefore(a, m);
          })(
            window,
            document,
            "script",
            "//www.google-analytics.com/analytics.js",
            "ga"
          );
          ga("create", "UA-149864185-1", "auto");
          ga("send", "pageview");
        }
      })();
    </script>
    <script src="/blog/umi.js"></script>
  </body>
</html>
