<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no"
    />
    <link rel="shortcut icon" type="image/x-icon" href="/logo.png" />
    <link rel="stylesheet" href="/blog/umi.css" />
    <script>
      window.routerBase = "/blog";
    </script>
    <script>
      //! umi version: 3.5.17
    </script>
    <script>
      !(function () {
        var e = localStorage.getItem("dumi:prefers-color"),
          t = window.matchMedia("(prefers-color-scheme: dark)").matches,
          r = ["light", "dark", "auto"];
        document.documentElement.setAttribute(
          "data-prefers-color",
          e === r[2] ? (t ? r[1] : r[0]) : r.indexOf(e) > -1 ? e : r[0]
        );
      })();
    </script>
    <title>21 | 压测平台：高效搭建 GoReplay 压测平台</title>
  </head>
  <body>
    <div id="root"><div class="__dumi-default-layout" data-route="/全链路压测实战30讲/04.实践环境/01" data-show-sidemenu="true" data-show-slugs="true" data-site-mode="true" data-gapless="false"><div class="__dumi-default-navbar" data-mode="site"><button class="__dumi-default-navbar-toggle"></button><a class="__dumi-default-navbar-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog/">大师兄</a><nav><div class="__dumi-default-search"><input type="search" class="__dumi-default-search-input" value=""/><ul></ul></div><span>计算机基础<ul><li><a href="/blog/编译原理之美">编译原理之美</a></li><li><a href="/blog/编译原理实战">编译原理实战</a></li><li><a href="/blog/深入浅出计算机组成原理">深入浅出计算机组成原理</a></li><li><a href="/blog/详解http">详解http</a></li><li><a href="/blog/计算机网络通关29讲">计算机网络通关29讲</a></li><li><a href="/blog/网络排查案例课">网络排查案例课</a></li><li><a href="/blog/linux操作系统">linux操作系统</a></li><li><a href="/blog/linux性能优化实战">linux性能优化实战</a></li><li><a href="/blog/程序员数学基础">程序员数学基础</a></li><li><a href="/blog/趣谈网络协议">趣谈网络协议</a></li><li><a href="/blog/操作系统实战">操作系统实战</a></li><li><a href="/blog/软件工程之美">软件工程之美</a></li><li><a href="/blog/sql必知必会">sql必知必会</a></li><li><a href="/blog/操作系统实战45讲">操作系统实战45讲</a></li><li><a href="/blog/网络编程实战">网络编程实战</a></li></ul></span><span>算法<ul><li><a href="/blog/常用算法25讲">常用算法25讲</a></li><li><a href="/blog/数据结构与算法之美">数据结构与算法之美</a></li><li><a href="/blog/业务开发算法50讲">业务开发算法50讲</a></li><li><a href="/blog/动态规划面试宝典">动态规划面试宝典</a></li></ul></span><span>前端开发<ul><li><a href="/blog/浏览器工作原理与实践">浏览器工作原理与实践</a></li><li><a href="/blog/新时代产品经理进阶之路">新时代产品经理进阶之路</a></li><li><a href="/blog/全栈工程师修炼指南">全栈工程师修炼指南</a></li><li><a href="/blog/flutter核心技术与实战">flutter核心技术与实战</a></li><li><a href="/blog/java-script核心原理解析">java-script核心原理解析</a></li><li><a href="/blog/说透低代码">说透低代码</a></li><li><a href="/blog/nodejs应用开发实战">nodejs应用开发实战</a></li><li><a href="/blog/反爬虫兵法演绎20讲">反爬虫兵法演绎20讲</a></li><li><a href="/blog/reactnative新架构实战课">reactnative新架构实战课</a></li><li><a href="/blog/正则表达式入门">正则表达式入门</a></li><li><a href="/blog/重学前端">重学前端</a></li><li><a href="/blog/serverless入门课">serverless入门课</a></li><li><a href="/blog/type-script入门实战笔记">type-script入门实战笔记</a></li><li><a href="/blog/图解googlev8">图解googlev8</a></li><li><a href="/blog/vue3源码分析">vue3源码分析</a></li><li><a href="/blog/玩转Vue3全家桶">玩转Vue3全家桶</a></li><li><a href="/blog/webassembly入门">webassembly入门</a></li><li><a href="/blog/手把手带你写一个Web框架">手把手带你写一个Web框架</a></li><li><a href="/blog/web漏洞挖掘实战">web漏洞挖掘实战</a></li><li><a href="/blog/跟月影学可视化">跟月影学可视化</a></li><li><a href="/blog/搞定音频技术">搞定音频技术</a></li><li><a href="/blog/攻克视频技术">攻克视频技术</a></li></ul></span><span>前端工程化<ul><li><a href="/blog/logger">logger</a></li><li><a href="/blog/webpack">webpack</a></li><li><a href="/blog/webpackChain">webpackChain</a></li></ul></span><span>前端性能优化<ul><li><a href="/blog/react性能调优">react性能调优</a></li></ul></span><span>软件测试<ul><li><a aria-current="page" class="active" href="/blog/全链路压测实战30讲">全链路压测实战30讲</a></li><li><a href="/blog/性能测试实战30讲">性能测试实战30讲</a></li><li><a href="/blog/自动化测试高手课">自动化测试高手课</a></li><li><a href="/blog/软件测试52讲">软件测试52讲</a></li></ul></span><span>面试<ul><li><a href="/blog/面试现场">面试现场</a></li></ul></span><span>杂谈<ul><li><a href="/blog/超级访谈对话张雪峰">超级访谈对话张雪峰</a></li><li><a href="/blog/Git实战手册">Git实战手册</a></li><li><a href="/blog/NodeJS">NodeJS</a></li><li><a href="/blog/ReactJS">ReactJS</a></li><li><a href="/blog/UI设计">UI设计</a></li><li><a href="/blog/webpack4系列教程">webpack4系列教程</a></li><li><a href="/blog/前端知识体系">前端知识体系</a></li><li><a href="/blog/剑指offer刷题笔记">剑指offer刷题笔记</a></li><li><a href="/blog/思考与成长">思考与成长</a></li><li><a href="/blog/设计模式手册">设计模式手册</a></li></ul></span><div class="__dumi-default-navbar-tool"><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "></div></div></div></nav></div><div class="__dumi-default-menu" data-mode="site"><div class="__dumi-default-menu-inner"><div class="__dumi-default-menu-header"><a class="__dumi-default-menu-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog/"></a><h1>大师兄</h1><p></p></div><div class="__dumi-default-menu-mobile-area"><ul class="__dumi-default-menu-nav-list"><li>计算机基础<ul><li><a href="/blog/编译原理之美">编译原理之美</a></li><li><a href="/blog/编译原理实战">编译原理实战</a></li><li><a href="/blog/深入浅出计算机组成原理">深入浅出计算机组成原理</a></li><li><a href="/blog/详解http">详解http</a></li><li><a href="/blog/计算机网络通关29讲">计算机网络通关29讲</a></li><li><a href="/blog/网络排查案例课">网络排查案例课</a></li><li><a href="/blog/linux操作系统">linux操作系统</a></li><li><a href="/blog/linux性能优化实战">linux性能优化实战</a></li><li><a href="/blog/程序员数学基础">程序员数学基础</a></li><li><a href="/blog/趣谈网络协议">趣谈网络协议</a></li><li><a href="/blog/操作系统实战">操作系统实战</a></li><li><a href="/blog/软件工程之美">软件工程之美</a></li><li><a href="/blog/sql必知必会">sql必知必会</a></li><li><a href="/blog/操作系统实战45讲">操作系统实战45讲</a></li><li><a href="/blog/网络编程实战">网络编程实战</a></li></ul></li><li>算法<ul><li><a href="/blog/常用算法25讲">常用算法25讲</a></li><li><a href="/blog/数据结构与算法之美">数据结构与算法之美</a></li><li><a href="/blog/业务开发算法50讲">业务开发算法50讲</a></li><li><a href="/blog/动态规划面试宝典">动态规划面试宝典</a></li></ul></li><li>前端开发<ul><li><a href="/blog/浏览器工作原理与实践">浏览器工作原理与实践</a></li><li><a href="/blog/新时代产品经理进阶之路">新时代产品经理进阶之路</a></li><li><a href="/blog/全栈工程师修炼指南">全栈工程师修炼指南</a></li><li><a href="/blog/flutter核心技术与实战">flutter核心技术与实战</a></li><li><a href="/blog/java-script核心原理解析">java-script核心原理解析</a></li><li><a href="/blog/说透低代码">说透低代码</a></li><li><a href="/blog/nodejs应用开发实战">nodejs应用开发实战</a></li><li><a href="/blog/反爬虫兵法演绎20讲">反爬虫兵法演绎20讲</a></li><li><a href="/blog/reactnative新架构实战课">reactnative新架构实战课</a></li><li><a href="/blog/正则表达式入门">正则表达式入门</a></li><li><a href="/blog/重学前端">重学前端</a></li><li><a href="/blog/serverless入门课">serverless入门课</a></li><li><a href="/blog/type-script入门实战笔记">type-script入门实战笔记</a></li><li><a href="/blog/图解googlev8">图解googlev8</a></li><li><a href="/blog/vue3源码分析">vue3源码分析</a></li><li><a href="/blog/玩转Vue3全家桶">玩转Vue3全家桶</a></li><li><a href="/blog/webassembly入门">webassembly入门</a></li><li><a href="/blog/手把手带你写一个Web框架">手把手带你写一个Web框架</a></li><li><a href="/blog/web漏洞挖掘实战">web漏洞挖掘实战</a></li><li><a href="/blog/跟月影学可视化">跟月影学可视化</a></li><li><a href="/blog/搞定音频技术">搞定音频技术</a></li><li><a href="/blog/攻克视频技术">攻克视频技术</a></li></ul></li><li>前端工程化<ul><li><a href="/blog/logger">logger</a></li><li><a href="/blog/webpack">webpack</a></li><li><a href="/blog/webpackChain">webpackChain</a></li></ul></li><li>前端性能优化<ul><li><a href="/blog/react性能调优">react性能调优</a></li></ul></li><li>软件测试<ul><li><a aria-current="page" class="active" href="/blog/全链路压测实战30讲">全链路压测实战30讲</a></li><li><a href="/blog/性能测试实战30讲">性能测试实战30讲</a></li><li><a href="/blog/自动化测试高手课">自动化测试高手课</a></li><li><a href="/blog/软件测试52讲">软件测试52讲</a></li></ul></li><li>面试<ul><li><a href="/blog/面试现场">面试现场</a></li></ul></li><li>杂谈<ul><li><a href="/blog/超级访谈对话张雪峰">超级访谈对话张雪峰</a></li><li><a href="/blog/Git实战手册">Git实战手册</a></li><li><a href="/blog/NodeJS">NodeJS</a></li><li><a href="/blog/ReactJS">ReactJS</a></li><li><a href="/blog/UI设计">UI设计</a></li><li><a href="/blog/webpack4系列教程">webpack4系列教程</a></li><li><a href="/blog/前端知识体系">前端知识体系</a></li><li><a href="/blog/剑指offer刷题笔记">剑指offer刷题笔记</a></li><li><a href="/blog/思考与成长">思考与成长</a></li><li><a href="/blog/设计模式手册">设计模式手册</a></li></ul></li></ul><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "><button title="Dark theme" class="__dumi-default-dark-moon "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="3854" width="22" height="22"><path d="M991.816611 674.909091a69.166545 69.166545 0 0 0-51.665455-23.272727 70.795636 70.795636 0 0 0-27.438545 5.585454A415.674182 415.674182 0 0 1 754.993338 698.181818c-209.594182 0-393.472-184.785455-393.472-395.636363 0-52.363636 38.539636-119.621818 69.515637-173.614546 4.887273-8.610909 9.634909-16.756364 14.103272-24.901818A69.818182 69.818182 0 0 0 384.631156 0a70.842182 70.842182 0 0 0-27.438545 5.585455C161.678429 90.298182 14.362065 307.898182 14.362065 512c0 282.298182 238.824727 512 532.38691 512a522.286545 522.286545 0 0 0 453.957818-268.334545A69.818182 69.818182 0 0 0 991.816611 674.909091zM546.679156 954.181818c-248.785455 0-462.941091-192-462.941091-442.181818 0-186.647273 140.637091-372.829091 300.939637-442.181818-36.817455 65.629091-92.578909 151.970909-92.578909 232.727273 0 250.181818 214.109091 465.454545 462.917818 465.454545a488.331636 488.331636 0 0 0 185.181091-46.545455 453.003636 453.003636 0 0 1-393.565091 232.727273z m103.656728-669.323636l-14.266182 83.781818a34.909091 34.909091 0 0 0 50.362182 36.770909l74.775272-39.563636 74.752 39.563636a36.142545 36.142545 0 0 0 16.174546 3.956364 34.909091 34.909091 0 0 0 34.210909-40.727273l-14.289455-83.781818 60.509091-59.345455a35.025455 35.025455 0 0 0-19.223272-59.578182l-83.61891-12.101818-37.376-76.101818a34.56 34.56 0 0 0-62.254545 0l-37.376 76.101818-83.618909 12.101818a34.909091 34.909091 0 0 0-19.246546 59.578182z m70.423272-64.698182a34.280727 34.280727 0 0 0 26.135273-19.083636l14.312727-29.090909 14.336 29.090909a34.257455 34.257455 0 0 0 26.135273 19.083636l32.046546 4.887273-23.272728 22.574545a35.234909 35.234909 0 0 0-10.007272 30.952727l5.46909 32.116364-28.625454-15.127273a34.490182 34.490182 0 0 0-32.302546 0l-28.695272 15.127273 5.469091-32.116364a35.141818 35.141818 0 0 0-9.984-30.952727l-23.272728-22.574545z" p-id="3855"></path></svg></button><button title="Light theme" class="__dumi-default-dark-sun "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="4026" width="22" height="22"><path d="M915.2 476.16h-43.968c-24.704 0-44.736 16-44.736 35.84s20.032 35.904 44.736 35.904H915.2c24.768 0 44.8-16.064 44.8-35.904s-20.032-35.84-44.8-35.84zM512 265.6c-136.704 0-246.464 109.824-246.464 246.4 0 136.704 109.76 246.464 246.464 246.464S758.4 648.704 758.4 512c0-136.576-109.696-246.4-246.4-246.4z m0 425.6c-99.008 0-179.2-80.128-179.2-179.2 0-98.944 80.192-179.2 179.2-179.2S691.2 413.056 691.2 512c0 99.072-80.192 179.2-179.2 179.2zM197.44 512c0-19.84-19.136-35.84-43.904-35.84H108.8c-24.768 0-44.8 16-44.8 35.84s20.032 35.904 44.8 35.904h44.736c24.768 0 43.904-16.064 43.904-35.904zM512 198.464c19.776 0 35.84-20.032 35.84-44.8v-44.8C547.84 84.032 531.84 64 512 64s-35.904 20.032-35.904 44.8v44.8c0 24.768 16.128 44.864 35.904 44.864z m0 627.136c-19.776 0-35.904 20.032-35.904 44.8v44.736C476.096 940.032 492.16 960 512 960s35.84-20.032 35.84-44.8v-44.736c0-24.768-16.064-44.864-35.84-44.864z m329.92-592.832c17.472-17.536 20.288-43.072 6.4-57.024-14.016-14.016-39.488-11.2-57.024 6.336-4.736 4.864-26.496 26.496-31.36 31.36-17.472 17.472-20.288 43.008-6.336 57.024 13.952 14.016 39.488 11.2 57.024-6.336 4.8-4.864 26.496-26.56 31.296-31.36zM213.376 759.936c-4.864 4.8-26.56 26.624-31.36 31.36-17.472 17.472-20.288 42.944-6.4 56.96 14.016 13.952 39.552 11.2 57.024-6.336 4.8-4.736 26.56-26.496 31.36-31.36 17.472-17.472 20.288-43.008 6.336-56.96-14.016-13.952-39.552-11.072-56.96 6.336z m19.328-577.92c-17.536-17.536-43.008-20.352-57.024-6.336-14.08 14.016-11.136 39.488 6.336 57.024 4.864 4.864 26.496 26.56 31.36 31.424 17.536 17.408 43.008 20.288 56.96 6.336 14.016-14.016 11.264-39.488-6.336-57.024-4.736-4.864-26.496-26.56-31.296-31.424z m527.168 628.608c4.864 4.864 26.624 26.624 31.36 31.424 17.536 17.408 43.072 20.224 57.088 6.336 13.952-14.016 11.072-39.552-6.4-57.024-4.864-4.8-26.56-26.496-31.36-31.36-17.472-17.408-43.072-20.288-57.024-6.336-13.952 14.016-11.008 39.488 6.336 56.96z" p-id="4027"></path></svg></button><button title="Default to system" class="__dumi-default-dark-auto "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="11002" width="22" height="22"><path d="M127.658667 492.885333c0-51.882667 10.24-101.717333 30.378666-149.162666s47.786667-88.064 81.92-122.538667 75.093333-61.781333 122.538667-81.92 96.938667-30.378667 149.162667-30.378667 101.717333 10.24 149.162666 30.378667 88.405333 47.786667 122.88 81.92 61.781333 75.093333 81.92 122.538667 30.378667 96.938667 30.378667 149.162666-10.24 101.717333-30.378667 149.162667-47.786667 88.405333-81.92 122.88-75.093333 61.781333-122.88 81.92-97.28 30.378667-149.162666 30.378667-101.717333-10.24-149.162667-30.378667-88.064-47.786667-122.538667-81.92-61.781333-75.093333-81.92-122.88-30.378667-96.938667-30.378666-149.162667z m329.045333 0c0 130.048 13.994667 244.394667 41.984 343.381334h12.970667c46.762667 0 91.136-9.216 133.461333-27.306667s78.848-42.666667 109.568-73.386667 54.954667-67.242667 73.386667-109.568 27.306667-86.698667 27.306666-133.461333c0-46.421333-9.216-90.794667-27.306666-133.12s-42.666667-78.848-73.386667-109.568-67.242667-54.954667-109.568-73.386667-86.698667-27.306667-133.461333-27.306666h-11.605334c-28.672 123.562667-43.349333 237.909333-43.349333 343.722666z" p-id="11003"></path></svg></button></div></div></div><ul class="__dumi-default-menu-list"><li><a href="/blog/全链路压测实战30讲">全链路压测实战30讲</a></li><li><a href="/blog/全链路压测实战30讲/01.开篇词">01.开篇词</a><ul><li><a href="/blog/全链路压测实战30讲/01.开篇词/01"><span>开篇词 | 打破认知神话，做接地气的全链路压测</span></a></li></ul></li><li><a href="/blog/全链路压测实战30讲/02.核心理论">02.核心理论</a><ul><li><a href="/blog/全链路压测实战30讲/02.核心理论/01"><span>01 | 全链路压测：为什么很多测试人员迷信它？</span></a></li><li><a href="/blog/全链路压测实战30讲/02.核心理论/02"><span>02 | RESAR 全链路流程：如何搞定所有容量场景？</span></a></li></ul></li><li><a href="/blog/全链路压测实战30讲/03.实践需求">03.实践需求</a><ul><li><a href="/blog/全链路压测实战30讲/03.实践需求/01"><span>03 | 压测方案：你是否忽略了一个重量级文档？</span></a></li><li><a href="/blog/全链路压测实战30讲/03.实践需求/02"><span>04 | 核心链路：如何梳理符合真实业务场景的核心链路？</span></a></li><li><a href="/blog/全链路压测实战30讲/03.实践需求/03"><span>05 | 铺底数据：真实的压测数据应该做成什么样子？</span></a></li><li><a href="/blog/全链路压测实战30讲/03.实践需求/04"><span>06 | 流量构建：流量平台如何选型？</span></a></li><li><a href="/blog/全链路压测实战30讲/03.实践需求/05"><span>07 | 全栈监控：如何设计全栈监控策略？</span></a></li><li><a href="/blog/全链路压测实战30讲/03.实践需求/06"><span>08 | 基础设施：全链路压测的环境有什么特点？</span></a></li><li><a href="/blog/全链路压测实战30讲/03.实践需求/07"><span>09 | 压测模型：如何建立一套完整的全链路压测模型？</span></a></li><li><a href="/blog/全链路压测实战30讲/03.实践需求/08"><span>10 | 场景执行：压测执行过程中的关键步骤是什么？</span></a></li><li><a href="/blog/全链路压测实战30讲/03.实践需求/09"><span>11 | 链路追踪：如何选择一款适合自己项目的工具？</span></a></li><li><a href="/blog/全链路压测实战30讲/03.实践需求/10"><span>12 | 链路追踪：如何对一个具体的项目进行追踪改造？</span></a></li><li><a href="/blog/全链路压测实战30讲/03.实践需求/11"><span>13 | 标记透传：微服务系统如何做标记透传方案选型？</span></a></li><li><a href="/blog/全链路压测实战30讲/03.实践需求/12"><span>14 | 标记透传：如何基于微服务技术进行标记透传？</span></a></li><li><a href="/blog/全链路压测实战30讲/03.实践需求/13"><span>15 | 流量隔离：MySQL数据库隔离是怎么做的？</span></a></li><li><a href="/blog/全链路压测实战30讲/03.实践需求/14"><span>16 | 流量隔离：Redis 缓存隔离是怎么做的？</span></a></li><li><a href="/blog/全链路压测实战30讲/03.实践需求/15"><span>17 | 流量隔离：MongoDB 数据库隔离是怎么做的？</span></a></li><li><a href="/blog/全链路压测实战30讲/03.实践需求/16"><span>18 | 流量隔离：RabbitMQ 消息隔离是怎么做的？</span></a></li><li><a href="/blog/全链路压测实战30讲/03.实践需求/17"><span>19｜日志隔离：如何落地日志隔离？</span></a></li><li><a href="/blog/全链路压测实战30讲/03.实践需求/18"><span>20 | Mock：如何屏蔽第三方接口的影响？</span></a></li></ul></li><li><a aria-current="page" class="active" href="/blog/全链路压测实战30讲/04.实践环境">04.实践环境</a><ul><li><a aria-current="page" class="active" href="/blog/全链路压测实战30讲/04.实践环境/01"><span>21 | 压测平台：高效搭建 GoReplay 压测平台</span></a></li><li><a href="/blog/全链路压测实战30讲/04.实践环境/02"><span>22 | 压测平台：如何解决 GoReplay 动态数据关联？</span></a></li><li><a href="/blog/全链路压测实战30讲/04.实践环境/03"><span>23 | 压测平台：如何改造对象存储和性能监控？</span></a></li><li><a href="/blog/全链路压测实战30讲/04.实践环境/04"><span>24 | 压测平台：如何改造分布式调度平台？</span></a></li><li><a href="/blog/全链路压测实战30讲/04.实践环境/05"><span>25 | 环境搭建：我们的系统是怎么搭建起来的？</span></a></li><li><a href="/blog/全链路压测实战30讲/04.实践环境/06"><span>26 | 全局监控（上）：如何快速落地全局监控？</span></a></li><li><a href="/blog/全链路压测实战30讲/04.实践环境/07"><span>27 | 全局监控（下）：如何快速落地全局监控？</span></a></li><li><a href="/blog/全链路压测实战30讲/04.实践环境/08"><span>28 | 定向监控：怎样快速发现业务异常？</span></a></li></ul></li><li><a href="/blog/全链路压测实战30讲/05.实践性能场景执行">05.实践性能场景执行</a><ul><li><a href="/blog/全链路压测实战30讲/05.实践性能场景执行/01"><span>29 | 基准场景：一个案例，带你搞懂基准场景的关键要点</span></a></li><li><a href="/blog/全链路压测实战30讲/05.实践性能场景执行/02"><span>30 | 预压测：如何基于小流量快速验证容量压测效果？</span></a></li><li><a href="/blog/全链路压测实战30讲/05.实践性能场景执行/03"><span>31 | 容量场景：决定线上容量场景的关键因素是什么？</span></a></li><li><a href="/blog/全链路压测实战30讲/05.实践性能场景执行/04"><span>32 | 稳定性场景：怎样搞定线上稳定性场景？</span></a></li><li><a href="/blog/全链路压测实战30讲/05.实践性能场景执行/05"><span>33 | 异常场景：如何模拟线上不同组件的异常场景？</span></a></li><li><a href="/blog/全链路压测实战30讲/05.实践性能场景执行/06"><span>34 | 容量规划：如何精准地对生产系统做容量预估？</span></a></li></ul></li><li><a href="/blog/全链路压测实战30讲/06.性能结果报告">06.性能结果报告</a><ul><li><a href="/blog/全链路压测实战30讲/06.性能结果报告/01"><span>35 | 压测报告：怎样写出一份让老板满意的报告？</span></a></li></ul></li><li><a href="/blog/全链路压测实战30讲/07.结束语">07.结束语</a><ul><li><a href="/blog/全链路压测实战30讲/07.结束语/01"><span>结束语 | 做能落地的全链路压测项目</span></a></li><li><a href="/blog/全链路压测实战30讲/07.结束语/02"><span>期末考试 |《全链路压测实战30讲》满分试卷，等你来挑战！</span></a></li></ul></li><li><a href="/blog/全链路压测实战30讲/summary">全链路压测实战30讲</a></li></ul></div></div><ul role="slug-list" class="__dumi-default-layout-toc"><li title="GoReplay 是什么？" data-depth="2"><a href="/blog/全链路压测实战30讲/04.实践环境/01#goreplay-是什么"><span>GoReplay 是什么？</span></a></li><li title="Golang 环境安装" data-depth="2"><a href="/blog/全链路压测实战30讲/04.实践环境/01#golang-环境安装"><span>Golang 环境安装</span></a></li><li title="GoReplay 安装" data-depth="2"><a href="/blog/全链路压测实战30讲/04.实践环境/01#goreplay-安装"><span>GoReplay 安装</span></a></li><li title="流量录制" data-depth="2"><a href="/blog/全链路压测实战30讲/04.实践环境/01#流量录制"><span>流量录制</span></a></li><li title="流量回放" data-depth="2"><a href="/blog/全链路压测实战30讲/04.实践环境/01#流量回放"><span>流量回放</span></a></li><li title="总结" data-depth="2"><a href="/blog/全链路压测实战30讲/04.实践环境/01#总结"><span>总结</span></a></li><li title="思考题" data-depth="2"><a href="/blog/全链路压测实战30讲/04.实践环境/01#思考题"><span>思考题</span></a></li></ul><div class="__dumi-default-layout-content"><div class="markdown"><h1 id="21--压测平台高效搭建-goreplay-压测平台"><a aria-hidden="true" tabindex="-1" href="/blog/全链路压测实战30讲/04.实践环境/01#21--压测平台高效搭建-goreplay-压测平台"><span class="icon icon-link"></span></a>21 | 压测平台：高效搭建 GoReplay 压测平台</h1><p>你好，我是高楼。</p><p>从这里开始，我们就进入全链路压测的第三部分“实践环境”了。</p><p>在接下来的三讲，我会详细讲讲如何搭建压测平台。要搭建压测平台，首先，我们就要选择一款适合自己项目的流量工具。在第 6 讲，我们已经详细了解了流量工具的选型。综合对比评估后，最后我们这个项目选择了老牌流量回放工具 GoReplay，因为它简单、轻量、热度够，而且完全能满足我们目前项目的要求。</p><p>所以这节课，我们就来聊一聊怎样搭建 GoReplay 压测平台。如果你对GoReplay非常熟悉，那可以跳过下面的概念讲解，如果你之前没有接触过 GoReplay，可以跟着我一起先大概了解下这个工具。</p><h2 id="goreplay-是什么"><a aria-hidden="true" tabindex="-1" href="/blog/全链路压测实战30讲/04.实践环境/01#goreplay-是什么"><span class="icon icon-link"></span></a>GoReplay 是什么？</h2><p><a target="_blank" rel="noopener noreferrer" href="https://github.com/buger/goreplay">GoReplay<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 的简称是 Gor，它是一个简单的 TCP/HTTP 流量录制和回放的工具，主要用 Golang 语言编写。</p><p>GoReplay 的<a target="_blank" rel="noopener noreferrer" href="https://github.com/buger/goreplay">工作原理图<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>可以参考下面这张：</p><p><img src="https://static001.geekbang.org/resource/image/3e/55/3e135a37319e7e926f1ac2d410ea1b55.jpg?wh=1082x663" alt="图片"/></p><p>GoReplay 可以在服务器上启动一个 Gor 进程，它负责的工作包括<strong>监听、过滤、转发、回放</strong>等。通过监听网卡，它可以直接录制请求。后续它还支持实现<strong>流量回放、压力测试、性能监控</strong>等功能。</p><p>如果我们简化一下核心流程图，它会是下面这个样子：</p><p><img src="https://static001.geekbang.org/resource/image/c4/99/c4eb7cb7c07de1f45212e45bf4897099.jpg?wh=1920x773" alt="图片"/></p><p>GoReplay 从数据流中抽象出了两个概念，即<strong>输入（Input）<strong>和</strong>输出（Output ）</strong>，它用这两个概念来表示数据来源与去向，统称为 Plugin。</p><p>GoReplay 用介于输入和输出模块之间的 Middleware（中间件）实现拓展机制，而 Emitter 则是核心处理器，实现对于 Input 输入流的读取，并判断是否需要进行 Middleware 的处理、请求修改等。完成这一步后，Emitter会异步复制流量到所有 Output，同时将所有 Output 中有 Response 的数据复制到所有 Outputs 中。</p><h2 id="golang-环境安装"><a aria-hidden="true" tabindex="-1" href="/blog/全链路压测实战30讲/04.实践环境/01#golang-环境安装"><span class="icon icon-link"></span></a>Golang 环境安装</h2><p>好了，理清 GoReplay 的工作原理之后，我们来看下Golang的环境安装。只有安装好Golang才能运行 GoReplay。</p><p>第一步，安装 Golang 及相关依赖环境，你可以在<a target="_blank" rel="noopener noreferrer" href="https://golang.org/dl">官网<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>或者 Go 的一些<a target="_blank" rel="noopener noreferrer" href="https://studygolang.com/dl">中文网站<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>上下载安装包。</p><p>我这里下载的是: go1.15.5.linux-amd64.tar.gz。</p><p>第二步，解压到服务器 /usr/local 目录下。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">rm -rf /usr/local/go &amp;&amp; tar -C /usr/local -xzf go1.15.5.linux-amd64.tar.gz</span></div></pre></div><p>第三步，配置环境变量。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain"># 打开</span></div><div class="token-line"><span class="token plain">    vim /etc/profile</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    # 添加</span></div><div class="token-line"><span class="token plain">    export GOROOT=/usr/local/go</span></div><div class="token-line"><span class="token plain">    export PATH=$PATH:$GOROOT/bin</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    # 编译生效</span></div><div class="token-line"><span class="token plain">    source /etc/profile</span></div></pre></div><p>最后，我们验证 Golang 环境是否生效。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">[root@vm ~]# go version</span></div><div class="token-line"><span class="token plain">    go version go1.15.5 linux/amd64</span></div></pre></div><p>我们看到，版本已经显示成功了，这说明我们的环境已经安装成功了。</p><h2 id="goreplay-安装"><a aria-hidden="true" tabindex="-1" href="/blog/全链路压测实战30讲/04.实践环境/01#goreplay-安装"><span class="icon icon-link"></span></a>GoReplay 安装</h2><p>接下来，我们安装GoReplay。在我们这个项目中，因为要在网关服务上录制流量，所以需要在网关容器内安装GoReplay。</p><p>我们从 <a target="_blank" rel="noopener noreferrer" href="https://github.com/buger/gor/releases">https://github.com/buger/gor/releases<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 下载 Gor 二进制文件（提供 Windows、Linux x64 和 macOS 的预编译二进制文件），也可以自己源码<a target="_blank" rel="noopener noreferrer" href="https://github.com/buger/goreplay/wiki/Compilation">编译<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>安装。</p><p><img src="https://static001.geekbang.org/resource/image/06/76/069e2b52cae0e28f2d7140f2636b5a76.png?wh=1258x701" alt="图片"/></p><p>这里，我简单演示一下如何通过 curl 下载二进制包。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">$ curl -L -O https://github.com/buger/goreplay/releases/download/v1.3.1/gor_1.3.1_x64.tar.gz</span></div><div class="token-line"><span class="token plain">      % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current</span></div><div class="token-line"><span class="token plain">                                     Dload  Upload   Total   Spent    Left  Speed</span></div><div class="token-line"><span class="token plain">    100   626  100   626    0     0    741      0 --:--:-- --:--:-- --:--:--   741</span></div><div class="token-line"><span class="token plain">    100 10.5M  100 10.5M    0     0  3258k      0  0:00:03  0:00:03 --:--:-- 5951k</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    $ tar xvzf gor_1.3.1_x64.tar.gz </span></div><div class="token-line"><span class="token plain">    gor</span></div></pre></div><p>解压缩包后，我们可以直接从当前目录运行 Gor 二进制文件，或者更方便的是将二进制文件复制到系统的 PATH（对于 Linux 和 macOS，它可以是 /usr/local/bin）中。</p><p>同时我们也要记得安装抓包工具 libpcap：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">yum install libpcap libpcap-devel</span></div></pre></div><p>这里我演示的是 yum 安装方式。</p><p>这样，我们就可以使用 Gor 命令进行各种操作了。</p><p>在正式介绍流量录制和流量回放的逻辑之前，我还想带你熟悉一下 GoReplay 常用的参数。市面上对这些常用参数的介绍，比较齐全的不多，所以我在这里做个总结。</p><p>这里我按照使用类型划分，整理了常用的参数：</p><p><img src="https://static001.geekbang.org/resource/image/db/03/db66558ace720aa61c42ccfa0c41a103.jpg?wh=1920x906" alt="图片"/></p><p>其中标星的参数是压测中的必选项。</p><p>好了，知道了常用的参数，特别是在压测中必然会用到的参数，接下来我们就看下如何在具体项目中使用。</p><h2 id="流量录制"><a aria-hidden="true" tabindex="-1" href="/blog/全链路压测实战30讲/04.实践环境/01#流量录制"><span class="icon icon-link"></span></a>流量录制</h2><p>我们知道流量录制工具的核心原理就是将线上集群环境的流量复制多份发送到指定的仓库，然后使用指定压力机器进行放大回放以达到压力测试的目的。</p><p>那么 GoReplay 是如何实现流量复制的呢？</p><ul><li>核心原理</li></ul><p>你可以先来看下这张 GoReplay 的录制原理图：</p><p><img src="https://static001.geekbang.org/resource/image/06/ac/069f66babeb0614f7dfa6f8e99b35bac.jpg?wh=1696x1353" alt="图片"/></p><p>GoReplay 通过调用 <a target="_blank" rel="noopener noreferrer" href="https://link.zhihu.com/?target=https%3A//github.com/google/gopacket">Google/gopacket<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 来实现抓包，这里的 gopacket 是基于 libpcap 库的。GoReplay 可以做到捕捉指定端口的网卡流量，它既可以实现 TCP 协议（RAW_SOCKET）的抓包，也可以实现 HTTP 的录制、回放，同时还支持多实例之间的级联。</p><p>录制的时候，每个 TCP 包被抽象为 packet。当数据量较大、数据需要被分拆成多个包发送时，接收端需要把这些包按顺序组合起来，同时还要处理乱序、重复等问题，保证向下传递的是一个完整无误的数据包。这些逻辑统封装在了 tcp_message 中，tcp_message 与 packet 是一对多的关系。后续会将 tcp_message 中的数据取出，打上标记，传递给中间件（如果有）或者是 Output 插件。</p><p>要做到这些，我们来看下GoReplay 基于 libpcap 库的核心函数。</p><p>首先，GoReplay 的 <a target="_blank" rel="noopener noreferrer" href="https://github.com/buger/goreplay/blob/master/capture/capture.go">capture.go<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 类中定义了 pcap 处理引擎函数：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">func (l *Listener) activatePcap() error {</span></div><div class="token-line"><span class="token plain">    	var e error</span></div><div class="token-line"><span class="token plain">    	var msg string</span></div><div class="token-line"><span class="token plain">    	for _, ifi := range l.Interfaces {</span></div><div class="token-line"><span class="token plain">    		var handle *pcap.Handle</span></div><div class="token-line"><span class="token plain">    		handle, e = l.PcapHandle(ifi)</span></div><div class="token-line"><span class="token plain">    		if e != nil {</span></div><div class="token-line"><span class="token plain">    			msg += (&quot;\n&quot; + e.Error())</span></div><div class="token-line"><span class="token plain">    			continue</span></div><div class="token-line"><span class="token plain">    		}</span></div><div class="token-line"><span class="token plain">    		l.Handles[ifi.Name] = packetHandle{</span></div><div class="token-line"><span class="token plain">    			handler: handle,</span></div><div class="token-line"><span class="token plain">    			ips:     interfaceIPs(ifi),</span></div><div class="token-line"><span class="token plain">    		}</span></div><div class="token-line"><span class="token plain">    	}</span></div><div class="token-line"><span class="token plain">    	if len(l.Handles) == 0 {</span></div><div class="token-line"><span class="token plain">    		return fmt.Errorf(&quot;pcap handles error:%s&quot;, msg)</span></div><div class="token-line"><span class="token plain">    	}</span></div><div class="token-line"><span class="token plain">    	return nil</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p><a target="_blank" rel="noopener noreferrer" href="https://github.com/buger/goreplay/blob/master/capture/capture.go">capture.go<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 类描述的几种引擎包括 libpcap、pcap_file、raw_socket 等：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// Set is here so that EngineType can implement flag.Var</span></div><div class="token-line"><span class="token plain">    func (eng *EngineType) Set(v string) error {</span></div><div class="token-line"><span class="token plain">    	switch v {</span></div><div class="token-line"><span class="token plain">    	case &quot;&quot;, &quot;libpcap&quot;:</span></div><div class="token-line"><span class="token plain">    		*eng = EnginePcap</span></div><div class="token-line"><span class="token plain">    	case &quot;pcap_file&quot;:</span></div><div class="token-line"><span class="token plain">    		*eng = EnginePcapFile</span></div><div class="token-line"><span class="token plain">    	case &quot;raw_socket&quot;:</span></div><div class="token-line"><span class="token plain">    		*eng = EngineRawSocket</span></div><div class="token-line"><span class="token plain">    	case &quot;af_packet&quot;:</span></div><div class="token-line"><span class="token plain">    		*eng = EngineAFPacket</span></div><div class="token-line"><span class="token plain">    	default:</span></div><div class="token-line"><span class="token plain">    		return fmt.Errorf(&quot;invalid engine %s&quot;, v)</span></div><div class="token-line"><span class="token plain">    	}</span></div><div class="token-line"><span class="token plain">    	return nil</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>好了，知道了录制的原理，接下来我们看下如何在具体项目中做录制。</p><ul><li>录制实例</li></ul><p>这里我们演示的例子是除健康检查（/actuator/health）之外，录制网关服务的所有接口请求。</p><p>录制逻辑图：</p><p><img src="https://static001.geekbang.org/resource/image/4b/e6/4b2edec5d0116eb2b365bf8a9cbd56e6.jpg?wh=1888x344" alt="图片"/></p><p>我们主要会使用下面这些命令：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain"># --input-raw：捕获指定端口 HTTP 流量</span></div><div class="token-line"><span class="token plain">    # --output-file：将获取的流量记录保存到文件</span></div><div class="token-line"><span class="token plain">    # -output-file-append：单独文件 Append 存储</span></div><div class="token-line"><span class="token plain">    # --http-set-header：为请求添加 header 信息</span></div><div class="token-line"><span class="token plain">    # --input-raw-track-response：收集返回结果</span></div><div class="token-line"><span class="token plain">    # --prettify-http：自动解码 Content-Encoding:gzip 和 Transfer-Encoding:chunked 的请求和响应 </span></div><div class="token-line"><span class="token plain">    # --http-disallow-url：不允许正则 URL</span></div><div class="token-line"><span class="token plain">    sudo nohup ./gor --input-raw :8201 \ </span></div><div class="token-line"><span class="token plain">    	--output-file=request-mall-all.gor \</span></div><div class="token-line"><span class="token plain">    	-output-file-append \</span></div><div class="token-line"><span class="token plain">    	--http-set-header &quot;dunshan:7DGroup&quot; \</span></div><div class="token-line"><span class="token plain">    	--http-set-header &quot;User-Agent:Replayed-by-Gor&quot; \</span></div><div class="token-line"><span class="token plain">    	--input-raw-track-response \</span></div><div class="token-line"><span class="token plain">    	--prettify-http \</span></div><div class="token-line"><span class="token plain">    	--http-disallow-url /actuator/health &gt; /dev/null 2&gt;&amp;1 &amp;</span></div></pre></div><p>这些命令的意思是我们要监听网关实例的 8201 端口，录制除 /actuator/health 之外的所有请求，然后捕获响应报文并把请求追加到唯一文件中，像这里生成的流量文件名叫“request-mall-all.gor”。同时，我们还要对 Header 信息重写并打上压测标记 “dunshan:7DGroup”。</p><p>这里有一些需要说明的是：</p><ul><li>sudo：以 root 身份运行，这是监听网络流量所必需的 <a target="_blank" rel="noopener noreferrer" href="https://github.com/buger/goreplay/wiki/Running-as-non-root-user">（除非另行配置）<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> ；</li><li>nohup：允许该命令后台运行；</li><li>/dev/null：让 GoReplay 进程监听 /dev/null。/dev/null 表示的是一个黑洞，用于丢弃不需要的输出。如果日志文件太大，并且你对自己的设置有足够的信心，可以选择重定向到 /dev/null。</li><li>2&gt;&amp;1：将 stderr（标准错误） 输出重定向到 stdout（标准输出），允许我们在上面指定的同一日志文件中收集错误输出。</li><li>&amp;：在后台运行进程。这样我们就可以在运行 GoReplay 时继续使用 Shell了。</li></ul><p>命令执行后，输出的是下面的结果：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">[root@s12 ~]# sudo nohup ./gor --input-raw :8201 \ </span></div><div class="token-line"><span class="token plain">    	--output-file=request-mall-all.gor \</span></div><div class="token-line"><span class="token plain">    	-output-file-append \</span></div><div class="token-line"><span class="token plain">    	--http-set-header &quot;dunshan:7DGroup&quot; \</span></div><div class="token-line"><span class="token plain">    	--http-set-header &quot;User-Agent:Replayed-by-Gor&quot; \</span></div><div class="token-line"><span class="token plain">    	--input-raw-track-response \</span></div><div class="token-line"><span class="token plain">    	--prettify-http \</span></div><div class="token-line"><span class="token plain">    	--http-disallow-url /actuator/health &gt; /dev/null 2&gt;&amp;1 &amp;</span></div><div class="token-line"><span class="token plain">    [1] 26251</span></div></pre></div><p>这里显示的数字 26251 是 Gor 程序的进程 PID，在我们录制完成后，可以使用这个 PID 终止 Gor 的录制进程。</p><p>现在， Gor 已经开始流量录制了，这段时间网关转发的所有请求会被录制。</p><p>在录制了一段时间的流量后，我们可以执行下面的命令终止 Gor 的录制。录制终止之后，可以看到执行录制指令的目录下有了一份文件名为 “request-mall-all.gor ”的流量文件。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain"># 手动输入 PID 方式</span></div><div class="token-line"><span class="token plain">    sudo kill -9 ${gor 进程 PID}</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    # 自动化获取 PID 方式</span></div><div class="token-line"><span class="token plain">    for i in `ps -ef|grep gor|grep -v grep |awk &#x27;{print $2}&#x27;`; do  kill -9 $i; done</span></div></pre></div><p>其实如果我们考虑限时录制的话，也可以参考下面这段命令：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain"># timeout 60 表示只录制 60 秒后自动停止</span></div><div class="token-line"><span class="token plain">    sudo nohup timeout 60 ./gor --input-raw :8201 \ </span></div><div class="token-line"><span class="token plain">    	--output-file=request-mall-all.gor \</span></div><div class="token-line"><span class="token plain">    	-output-file-append \</span></div><div class="token-line"><span class="token plain">    	--http-set-header &quot;dunshan:7DGroup&quot; \</span></div><div class="token-line"><span class="token plain">    	--http-set-header &quot;User-Agent:Replayed-by-Gor&quot; \</span></div><div class="token-line"><span class="token plain">    	--input-raw-track-response \</span></div><div class="token-line"><span class="token plain">    	--prettify-http \</span></div><div class="token-line"><span class="token plain">    	--http-disallow-url /actuator/health &gt; /dev/null 2&gt;&amp;1 &amp;</span></div><div class="token-line"><span class="token plain">     </span></div><div class="token-line"><span class="token plain">    # 按小时切割日志文件，并且开启日志追加模式，不会进行日志默认小分片</span></div><div class="token-line"><span class="token plain">    sudo nohup timeout 60 ./gor --input-raw :8201 \ </span></div><div class="token-line"><span class="token plain">    	--output-file=request-mall-all-%Y-%m-%d-%H.gor \</span></div><div class="token-line"><span class="token plain">    	-output-file-append \</span></div><div class="token-line"><span class="token plain">    	--http-set-header &quot;dunshan:7DGroup&quot; \</span></div><div class="token-line"><span class="token plain">    	--http-set-header &quot;User-Agent:Replayed-by-Gor&quot; \</span></div><div class="token-line"><span class="token plain">    	--input-raw-track-response \</span></div><div class="token-line"><span class="token plain">    	--prettify-http \</span></div><div class="token-line"><span class="token plain">    	--http-disallow-url /actuator/health &gt; /dev/null 2&gt;&amp;1 &amp;</span></div><div class="token-line"><span class="token plain">     </span></div><div class="token-line"><span class="token plain">    # 按小时切割日志文件，并且开启日志追加模式，不会进行日志默认小分片,.gz 压缩文件格式</span></div><div class="token-line"><span class="token plain">    sudo nohup timeout 60 ./gor --input-raw :8201 \ </span></div><div class="token-line"><span class="token plain">    	--output-file=request-mall-all-%Y-%m-%d-%H.gz \</span></div><div class="token-line"><span class="token plain">    	-output-file-append \</span></div><div class="token-line"><span class="token plain">    	--http-set-header &quot;dunshan:7DGroup&quot; \</span></div><div class="token-line"><span class="token plain">    	--http-set-header &quot;User-Agent:Replayed-by-Gor&quot; \</span></div><div class="token-line"><span class="token plain">    	--input-raw-track-response \</span></div><div class="token-line"><span class="token plain">    	--prettify-http \</span></div><div class="token-line"><span class="token plain">    	--http-disallow-url /actuator/health &gt; /dev/null 2&gt;&amp;1 &amp;</span></div></pre></div><p>接下来，我们尝试打开“request-mall-all.gor ”的流量文件，分析一下里面的结构。</p><p>因为GoReplay 用三个猴头 🐵🙈🙉 作为请求分隔符，所以我们的流量文件是下面这个样子：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain"># 请求类型，请求 ID 为 80a820090a6423c03994b9f3，时间戳</span></div><div class="token-line"><span class="token plain">    1 80a820090a6423c03994b9f3 1635694104268073719 0</span></div><div class="token-line"><span class="token plain">    # 请求的类型及 URL 地址</span></div><div class="token-line"><span class="token plain">    POST /api/member/sso/login HTTP/1.1</span></div><div class="token-line"><span class="token plain">    Connection: keep-alive</span></div><div class="token-line"><span class="token plain">    # 压测标记</span></div><div class="token-line"><span class="token plain">    dunshan: 7DGroup</span></div><div class="token-line"><span class="token plain">    Content-Length: 34</span></div><div class="token-line"><span class="token plain">    Content-Type: application/x-www-form-urlencoded; charset=UTF-8</span></div><div class="token-line"><span class="token plain">    Host: 172.31.184.225:30001</span></div><div class="token-line"><span class="token plain">    # header 重写</span></div><div class="token-line"><span class="token plain">    User-Agent: Replayed-by-Gor</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    # 请求参数</span></div><div class="token-line"><span class="token plain">    username=7dTest006&amp;password=123456</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    🐵🙈🙉 # 请求分隔符</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    # 响应类型，请求 ID 为 80a820090a6423c03994b9f3，时间戳</span></div><div class="token-line"><span class="token plain">    2 80a820090a6423c03994b9f3 1635694104291403073 392247</span></div><div class="token-line"><span class="token plain">    HTTP/1.1 200 OK</span></div><div class="token-line"><span class="token plain">    Content-Length: 1053</span></div><div class="token-line"><span class="token plain">    Vary: Origin</span></div><div class="token-line"><span class="token plain">    Vary: Access-Control-Request-Method</span></div><div class="token-line"><span class="token plain">    Vary: Access-Control-Request-Headers</span></div><div class="token-line"><span class="token plain">    Content-Type: application/json</span></div><div class="token-line"><span class="token plain">    Date: Sun, 31 Oct 2021 15:28:24 GMT</span></div><div class="token-line"><span class="token plain">    Cache-Control: no-cache, no-store, max-age=0, must-revalidate</span></div><div class="token-line"><span class="token plain">    Pragma: no-cache</span></div><div class="token-line"><span class="token plain">    Expires: 0</span></div><div class="token-line"><span class="token plain">    X-Content-Type-Options: nosniff</span></div><div class="token-line"><span class="token plain">    X-Frame-Options: DENY</span></div><div class="token-line"><span class="token plain">    X-XSS-Protection: 1 ; mode=block</span></div><div class="token-line"><span class="token plain">    Referrer-Policy: no-referrer</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    # 响应体</span></div><div class="token-line"><span class="token plain">    {&quot;code&quot;:200,&quot;message&quot;:&quot;操作成功&quot;,&quot;data&quot;:{&quot;token&quot;:&quot;eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyX25hbWUiOiI3ZFRlc3QwMDYiLCJzY29wZSI6WyJhbGwiXSwiaWQiOjI0MzQ0MjUsImV4cCI6MTYzNTc4MDUwNCwiYXV0aG9yaXRpZXMiOlsi5YmN5Y-w5Lya5ZGYIl0sImp0aSI6IjBhYjQ3OWU5LWYwOWQtNDI1YS04YWQyLTgwNTE4MDg3MmU4ZiIsImNsaWVudF9pZCI6InBvcnRhbC1hcHAifQ.WzOKDhWEu00nXBMghYwxTW6xW8M1CLdqEt63xeS6MwJME2QJg1rIxAsUKRo4KxgbFPoybax3O36xnpMDLAiRskQj6VRil-WaqYFBvTeC3iGfI2whKW8FsySUQh6WU2Vf5SsvA9HhMKLl3S4PS-aIY9bElxFjajeNoVGn4KB1Rwg&quot;,&quot;refreshToken&quot;:&quot;eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyX25hbWUiOiI3ZFRlc3QwMDYiLCJzY29wZSI6WyJhbGwiXSwiYXRpIjoiMGFiNDc5ZTktZjA5ZC00MjVhLThhZDItODA1MTgwODcyZThmIiwiaWQiOjI0MzQ0MjUsImV4cCI6MTYzNjI5ODkwNCwiYXV0aG9yaXRpZXMiOlsi5YmN5Y-w5Lya5ZGYIl0sImp0aSI6IjAwYTIxYTFiLTJjZDMtNDk0Yi1hNzkxLWE3MTlhMDViN2YxYyIsImNsaWVudF9pZCI6InBvcnRhbC1hcHAifQ.IRSQvTOQpyRAjwp6owpdcYyjLLV8oZ_J39FNv7J4sZVGGnl3o5GEv51cnP89msTa7MXIC9E0k7mUqjiHJKJ-RFPDlHne1k-hP_ZJSCg9GS35cMiVb7jYQV-rVnG3j-yqiJb9g2gsCLVcsF-KnCMwWyV46C8pH2Tiajeee-Io9F8&quot;,&quot;tokenHead&quot;:&quot;Bearer &quot;,&quot;expiresIn&quot;:86399}}</span></div></pre></div><p>从流量文件中可以看出，对于每个请求，应该收到 3 个有效 Payload(1-Request, 2-Response, 3-Replayed Response)，它们具有相同的请求 ID（Request和 Response 具有相同的)。</p><p>到此，流量录制就结束了。</p><p>还有一点需要注意的是，在录制大流量的的时候，有可能会出现丢失部分请求的情况。这是因为 Gor 是基于 pcap 和操作系统 BufferSize 进行录制的，当 BufferSize 溢出的时候，请求就会丢失。</p><p>这个时候我们必须设置参数：–input-raw-buffer-size。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">-input-raw-buffer-size value</span></div><div class="token-line"><span class="token plain">            Controls size of the OS buffer which holds packets until they dispatched. Default value depends by system: in Linux around 2MB. If you see big package drop, increase this value</span></div></pre></div><p>我们可以在 <a target="_blank" rel="noopener noreferrer" href="https://github.com/buger/goreplay/blob/master/capture/capture.go">capture.go<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 中找到 BufferSize 相关的这段代码：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">if l.BufferSize &gt; 0 {</span></div><div class="token-line"><span class="token plain">    		err = inactive.SetBufferSize(int(l.BufferSize))</span></div><div class="token-line"><span class="token plain">    		if err != nil {</span></div><div class="token-line"><span class="token plain">    			return nil, fmt.Errorf(&quot;handle buffer size error: %q, interface: %q&quot;, err, ifi.Name)</span></div><div class="token-line"><span class="token plain">    		}</span></div><div class="token-line"><span class="token plain">    	}</span></div><div class="token-line"><span class="token plain">    	if l.BufferTimeout == 0 {</span></div><div class="token-line"><span class="token plain">    		l.BufferTimeout = 2000 * time.Millisecond</span></div><div class="token-line"><span class="token plain">    	}</span></div><div class="token-line"><span class="token plain">    	err = inactive.SetTimeout(l.BufferTimeout)</span></div><div class="token-line"><span class="token plain">    	if err != nil {</span></div><div class="token-line"><span class="token plain">    		return nil, fmt.Errorf(&quot;handle buffer timeout error: %q, interface: %q&quot;, err, ifi.Name)</span></div><div class="token-line"><span class="token plain">    	}</span></div><div class="token-line"><span class="token plain">    	handle, err = inactive.Activate()</span></div></pre></div><p>要注意的是，操作系统缓冲区（ BufferSize ）的默认值是用来保存数据包的，它在不同的操作系统上有所不同。例如，在 Linux 上这个值是 2 MB，在 Windows 是 1 MB。如果设置更大的缓冲区或减少 MTU（接口层的最大数据包数据大小） 不能减少丢失的请求数据，那么很有可能是 GoReplay Bug。</p><h2 id="流量回放"><a aria-hidden="true" tabindex="-1" href="/blog/全链路压测实战30讲/04.实践环境/01#流量回放"><span class="icon icon-link"></span></a>流量回放</h2><p>接下来，我们再看下流量回放。流量回放的核心原理是通过 Limiter 实现变速回放，通过 Output 插件输出到目标机器。</p><p>这里我们主要使用的是HTTP输出的插件<a target="_blank" rel="noopener noreferrer" href="https://github.com/buger/goreplay/blob/master/output_http.go">output_http.go<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> ，它通过实现 HTTP 协议， 进而实现 io.Writer 接口，最后根据配置注册到 Plugin.outputs 队列里。</p><p>GoReplay 回放原理图：</p><p><img src="https://static001.geekbang.org/resource/image/fe/2b/fe26839250a99a3b2001a95a6cc7902b.jpg?wh=1656x1313" alt="图片"/></p><p>流量回放主要通过 Limiter 类执行各种变速。默认情况下，Gor 会创建一个动态协程池。初始协程数是 10 ，因为协程数量（N）等于该协程池的队列长度，所以当 HTTP 输出队列长度大于 10 时，Gor 会创建更多的协程数。</p><p>在产生 N 个协程的请求得到满足之前，不会再有协程创建。如果动态协程数当时不能处理消息，它将会睡眠一会。如果动态协程数无法处理消息，它就会死亡。我们可以用 --output-http-workers=20 选项指定并发协程数。</p><p>这里我们演示的例子是，倍数回放网关服务的所有接口请求。</p><p>回放逻辑图：</p><p><img src="https://static001.geekbang.org/resource/image/c9/01/c98c32493c7ca010a06944c55f8f4801.jpg?wh=1873x331" alt="图片"/></p><p>我们主要会使用下面这些命令：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain"># --input-file：从文件中获取请求数据，重放的时候 100x 倍速</span></div><div class="token-line"><span class="token plain">    # --input-file-loop：无限循环，而不是读完这个文件就停止</span></div><div class="token-line"><span class="token plain">    # --output-http：发送请求到网关</span></div><div class="token-line"><span class="token plain">    # --output-http-workers：并发 100 协程发送请求</span></div><div class="token-line"><span class="token plain">    # --stats --output-http-stats：每 5 秒输出一次 TPS 数据</span></div><div class="token-line"><span class="token plain">    # --output-http-track-response：获取响应报文</span></div><div class="token-line"><span class="token plain">    $ sudo ./gor --input-file &#x27;request-mall-all.gor|10000%&#x27; \  </span></div><div class="token-line"><span class="token plain">    --input-file-loop \ </span></div><div class="token-line"><span class="token plain">    --output-http &#x27;http://10.96.136.36:8201&#x27; \ </span></div><div class="token-line"><span class="token plain">    --output-http-workers 100 \ </span></div><div class="token-line"><span class="token plain">    --stats \ </span></div><div class="token-line"><span class="token plain">    --output-http-stats \  </span></div><div class="token-line"><span class="token plain">    --output-http-track-response</span></div></pre></div><p>因为我们是性能压测，可以要求无限循环。可以看到，我们向网关服务回放了 100 倍的流量。</p><h2 id="总结"><a aria-hidden="true" tabindex="-1" href="/blog/全链路压测实战30讲/04.实践环境/01#总结"><span class="icon icon-link"></span></a>总结</h2><p>好了，这节课就讲到这里。刚才，我们一起梳理了 GoReplay 的基本概念、核心原理、常用参数。我们还一起认识了GoReplay 两个主要的功能：流量录制和流量回放。下面几个知识点希望你能记住。</p><ol><li>GoReplay 主要依赖Golang环境运行，它通过命令行组织各个参数进行具体的操作；</li><li>GoReplay 底层依赖的是 libpcap 库， Gor 进程可以负责所有的工作，包括监听、过滤、重写、回放等；</li><li>通过参数：-stats 和 --out-http-stats，GoReplay 原生只支持由控制台统计发送请求队列信息，如果想要更复杂的测试统计还需要我们自己去埋点丰富监控指标；</li><li>使用 Middleware 可以让我们在输入输出间做一些复杂的请求增强工作。</li></ol><p>下一节课，我们将进入具体实践环节，我会通过案例演示如何做动态数据关联改造工作。</p><h2 id="思考题"><a aria-hidden="true" tabindex="-1" href="/blog/全链路压测实战30讲/04.实践环境/01#思考题"><span class="icon icon-link"></span></a>思考题</h2><p>学完这节课，请你思考两个问题：</p><ol><li>你有没有使用过 GoReplay，谈谈你使用这个工具的一些心得。</li><li>相比 Java 语言的压测工具，你觉得 Golang 的压测工具有什么优势？</li></ol><p>欢迎你在留言区与我交流讨论。当然了，你也可以把这节课分享给你身边的朋友，他们的一些想法或许会让你有更大的收获。我们下节课见！</p></div><div class="__dumi-default-layout-footer-meta"><a target="_blank" rel="noopener noreferrer" href="https://github.com/GGwujun/blog/edit/master/docs/全链路压测实战30讲/04.实践环境/01.md">在 GitHub 上编辑此页<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a><span data-updated-text="最后更新时间：">5/2/2022 10:57:05</span></div></div></div></div>
	<script>
  window.g_useSSR = true;
  window.g_initialProps = {};
	</script>

    <script>
      (function () {
        if (!location.port) {
          (function (i, s, o, g, r, a, m) {
            i["GoogleAnalyticsObject"] = r;
            (i[r] =
              i[r] ||
              function () {
                (i[r].q = i[r].q || []).push(arguments);
              }),
              (i[r].l = 1 * new Date());
            (a = s.createElement(o)), (m = s.getElementsByTagName(o)[0]);
            a.async = 1;
            a.src = g;
            m.parentNode.insertBefore(a, m);
          })(
            window,
            document,
            "script",
            "//www.google-analytics.com/analytics.js",
            "ga"
          );
          ga("create", "UA-149864185-1", "auto");
          ga("send", "pageview");
        }
      })();
    </script>
    <script src="/blog/umi.js"></script>
  </body>
</html>
