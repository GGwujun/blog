<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no"
    />
    <link rel="shortcut icon" type="image/x-icon" href="/logo.png" />
    <link rel="stylesheet" href="/blog/umi.css" />
    <script>
      window.routerBase = "/blog";
    </script>
    <script>
      //! umi version: 3.5.17
    </script>
    <script>
      !(function () {
        var e = localStorage.getItem("dumi:prefers-color"),
          t = window.matchMedia("(prefers-color-scheme: dark)").matches,
          r = ["light", "dark", "auto"];
        document.documentElement.setAttribute(
          "data-prefers-color",
          e === r[2] ? (t ? r[1] : r[0]) : r.indexOf(e) > -1 ? e : r[0]
        );
      })();
    </script>
    <title>18 | 流量隔离：RabbitMQ 消息隔离是怎么做的？</title>
  </head>
  <body>
    <div id="root"><div class="__dumi-default-layout" data-route="/全链路压测实战30讲/03.实践需求/16" data-show-sidemenu="true" data-show-slugs="true" data-site-mode="true" data-gapless="false"><div class="__dumi-default-navbar" data-mode="site"><button class="__dumi-default-navbar-toggle"></button><a class="__dumi-default-navbar-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog/">大师兄</a><nav><div class="__dumi-default-search"><input type="search" class="__dumi-default-search-input" value=""/><ul></ul></div><span>计算机基础<ul><li><a href="/blog/编译原理之美">编译原理之美</a></li><li><a href="/blog/编译原理实战">编译原理实战</a></li><li><a href="/blog/深入浅出计算机组成原理">深入浅出计算机组成原理</a></li><li><a href="/blog/详解http">详解http</a></li><li><a href="/blog/计算机网络通关29讲">计算机网络通关29讲</a></li><li><a href="/blog/网络排查案例课">网络排查案例课</a></li><li><a href="/blog/linux操作系统">linux操作系统</a></li><li><a href="/blog/linux性能优化实战">linux性能优化实战</a></li><li><a href="/blog/程序员数学基础">程序员数学基础</a></li><li><a href="/blog/趣谈网络协议">趣谈网络协议</a></li><li><a href="/blog/操作系统实战">操作系统实战</a></li><li><a href="/blog/软件工程之美">软件工程之美</a></li><li><a href="/blog/sql必知必会">sql必知必会</a></li><li><a href="/blog/操作系统实战45讲">操作系统实战45讲</a></li><li><a href="/blog/网络编程实战">网络编程实战</a></li></ul></span><span>算法<ul><li><a href="/blog/常用算法25讲">常用算法25讲</a></li><li><a href="/blog/数据结构与算法之美">数据结构与算法之美</a></li><li><a href="/blog/业务开发算法50讲">业务开发算法50讲</a></li><li><a href="/blog/动态规划面试宝典">动态规划面试宝典</a></li></ul></span><span>前端开发<ul><li><a href="/blog/浏览器工作原理与实践">浏览器工作原理与实践</a></li><li><a href="/blog/新时代产品经理进阶之路">新时代产品经理进阶之路</a></li><li><a href="/blog/全栈工程师修炼指南">全栈工程师修炼指南</a></li><li><a href="/blog/flutter核心技术与实战">flutter核心技术与实战</a></li><li><a href="/blog/java-script核心原理解析">java-script核心原理解析</a></li><li><a href="/blog/说透低代码">说透低代码</a></li><li><a href="/blog/nodejs应用开发实战">nodejs应用开发实战</a></li><li><a href="/blog/反爬虫兵法演绎20讲">反爬虫兵法演绎20讲</a></li><li><a href="/blog/reactnative新架构实战课">reactnative新架构实战课</a></li><li><a href="/blog/正则表达式入门">正则表达式入门</a></li><li><a href="/blog/重学前端">重学前端</a></li><li><a href="/blog/serverless入门课">serverless入门课</a></li><li><a href="/blog/type-script入门实战笔记">type-script入门实战笔记</a></li><li><a href="/blog/图解googlev8">图解googlev8</a></li><li><a href="/blog/vue3源码分析">vue3源码分析</a></li><li><a href="/blog/玩转Vue3全家桶">玩转Vue3全家桶</a></li><li><a href="/blog/webassembly入门">webassembly入门</a></li><li><a href="/blog/手把手带你写一个Web框架">手把手带你写一个Web框架</a></li><li><a href="/blog/web漏洞挖掘实战">web漏洞挖掘实战</a></li><li><a href="/blog/跟月影学可视化">跟月影学可视化</a></li><li><a href="/blog/搞定音频技术">搞定音频技术</a></li><li><a href="/blog/攻克视频技术">攻克视频技术</a></li></ul></span><span>前端工程化<ul><li><a href="/blog/logger">logger</a></li><li><a href="/blog/webpack">webpack</a></li><li><a href="/blog/webpackChain">webpackChain</a></li></ul></span><span>前端性能优化<ul><li><a href="/blog/react性能调优">react性能调优</a></li></ul></span><span>软件测试<ul><li><a aria-current="page" class="active" href="/blog/全链路压测实战30讲">全链路压测实战30讲</a></li><li><a href="/blog/性能测试实战30讲">性能测试实战30讲</a></li><li><a href="/blog/自动化测试高手课">自动化测试高手课</a></li><li><a href="/blog/软件测试52讲">软件测试52讲</a></li></ul></span><span>面试<ul><li><a href="/blog/面试现场">面试现场</a></li></ul></span><span>杂谈<ul><li><a href="/blog/超级访谈对话张雪峰">超级访谈对话张雪峰</a></li><li><a href="/blog/Git实战手册">Git实战手册</a></li><li><a href="/blog/NodeJS">NodeJS</a></li><li><a href="/blog/ReactJS">ReactJS</a></li><li><a href="/blog/UI设计">UI设计</a></li><li><a href="/blog/webpack4系列教程">webpack4系列教程</a></li><li><a href="/blog/前端知识体系">前端知识体系</a></li><li><a href="/blog/剑指offer刷题笔记">剑指offer刷题笔记</a></li><li><a href="/blog/思考与成长">思考与成长</a></li><li><a href="/blog/设计模式手册">设计模式手册</a></li></ul></span><div class="__dumi-default-navbar-tool"><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "></div></div></div></nav></div><div class="__dumi-default-menu" data-mode="site"><div class="__dumi-default-menu-inner"><div class="__dumi-default-menu-header"><a class="__dumi-default-menu-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog/"></a><h1>大师兄</h1><p></p></div><div class="__dumi-default-menu-mobile-area"><ul class="__dumi-default-menu-nav-list"><li>计算机基础<ul><li><a href="/blog/编译原理之美">编译原理之美</a></li><li><a href="/blog/编译原理实战">编译原理实战</a></li><li><a href="/blog/深入浅出计算机组成原理">深入浅出计算机组成原理</a></li><li><a href="/blog/详解http">详解http</a></li><li><a href="/blog/计算机网络通关29讲">计算机网络通关29讲</a></li><li><a href="/blog/网络排查案例课">网络排查案例课</a></li><li><a href="/blog/linux操作系统">linux操作系统</a></li><li><a href="/blog/linux性能优化实战">linux性能优化实战</a></li><li><a href="/blog/程序员数学基础">程序员数学基础</a></li><li><a href="/blog/趣谈网络协议">趣谈网络协议</a></li><li><a href="/blog/操作系统实战">操作系统实战</a></li><li><a href="/blog/软件工程之美">软件工程之美</a></li><li><a href="/blog/sql必知必会">sql必知必会</a></li><li><a href="/blog/操作系统实战45讲">操作系统实战45讲</a></li><li><a href="/blog/网络编程实战">网络编程实战</a></li></ul></li><li>算法<ul><li><a href="/blog/常用算法25讲">常用算法25讲</a></li><li><a href="/blog/数据结构与算法之美">数据结构与算法之美</a></li><li><a href="/blog/业务开发算法50讲">业务开发算法50讲</a></li><li><a href="/blog/动态规划面试宝典">动态规划面试宝典</a></li></ul></li><li>前端开发<ul><li><a href="/blog/浏览器工作原理与实践">浏览器工作原理与实践</a></li><li><a href="/blog/新时代产品经理进阶之路">新时代产品经理进阶之路</a></li><li><a href="/blog/全栈工程师修炼指南">全栈工程师修炼指南</a></li><li><a href="/blog/flutter核心技术与实战">flutter核心技术与实战</a></li><li><a href="/blog/java-script核心原理解析">java-script核心原理解析</a></li><li><a href="/blog/说透低代码">说透低代码</a></li><li><a href="/blog/nodejs应用开发实战">nodejs应用开发实战</a></li><li><a href="/blog/反爬虫兵法演绎20讲">反爬虫兵法演绎20讲</a></li><li><a href="/blog/reactnative新架构实战课">reactnative新架构实战课</a></li><li><a href="/blog/正则表达式入门">正则表达式入门</a></li><li><a href="/blog/重学前端">重学前端</a></li><li><a href="/blog/serverless入门课">serverless入门课</a></li><li><a href="/blog/type-script入门实战笔记">type-script入门实战笔记</a></li><li><a href="/blog/图解googlev8">图解googlev8</a></li><li><a href="/blog/vue3源码分析">vue3源码分析</a></li><li><a href="/blog/玩转Vue3全家桶">玩转Vue3全家桶</a></li><li><a href="/blog/webassembly入门">webassembly入门</a></li><li><a href="/blog/手把手带你写一个Web框架">手把手带你写一个Web框架</a></li><li><a href="/blog/web漏洞挖掘实战">web漏洞挖掘实战</a></li><li><a href="/blog/跟月影学可视化">跟月影学可视化</a></li><li><a href="/blog/搞定音频技术">搞定音频技术</a></li><li><a href="/blog/攻克视频技术">攻克视频技术</a></li></ul></li><li>前端工程化<ul><li><a href="/blog/logger">logger</a></li><li><a href="/blog/webpack">webpack</a></li><li><a href="/blog/webpackChain">webpackChain</a></li></ul></li><li>前端性能优化<ul><li><a href="/blog/react性能调优">react性能调优</a></li></ul></li><li>软件测试<ul><li><a aria-current="page" class="active" href="/blog/全链路压测实战30讲">全链路压测实战30讲</a></li><li><a href="/blog/性能测试实战30讲">性能测试实战30讲</a></li><li><a href="/blog/自动化测试高手课">自动化测试高手课</a></li><li><a href="/blog/软件测试52讲">软件测试52讲</a></li></ul></li><li>面试<ul><li><a href="/blog/面试现场">面试现场</a></li></ul></li><li>杂谈<ul><li><a href="/blog/超级访谈对话张雪峰">超级访谈对话张雪峰</a></li><li><a href="/blog/Git实战手册">Git实战手册</a></li><li><a href="/blog/NodeJS">NodeJS</a></li><li><a href="/blog/ReactJS">ReactJS</a></li><li><a href="/blog/UI设计">UI设计</a></li><li><a href="/blog/webpack4系列教程">webpack4系列教程</a></li><li><a href="/blog/前端知识体系">前端知识体系</a></li><li><a href="/blog/剑指offer刷题笔记">剑指offer刷题笔记</a></li><li><a href="/blog/思考与成长">思考与成长</a></li><li><a href="/blog/设计模式手册">设计模式手册</a></li></ul></li></ul><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "><button title="Dark theme" class="__dumi-default-dark-moon "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="3854" width="22" height="22"><path d="M991.816611 674.909091a69.166545 69.166545 0 0 0-51.665455-23.272727 70.795636 70.795636 0 0 0-27.438545 5.585454A415.674182 415.674182 0 0 1 754.993338 698.181818c-209.594182 0-393.472-184.785455-393.472-395.636363 0-52.363636 38.539636-119.621818 69.515637-173.614546 4.887273-8.610909 9.634909-16.756364 14.103272-24.901818A69.818182 69.818182 0 0 0 384.631156 0a70.842182 70.842182 0 0 0-27.438545 5.585455C161.678429 90.298182 14.362065 307.898182 14.362065 512c0 282.298182 238.824727 512 532.38691 512a522.286545 522.286545 0 0 0 453.957818-268.334545A69.818182 69.818182 0 0 0 991.816611 674.909091zM546.679156 954.181818c-248.785455 0-462.941091-192-462.941091-442.181818 0-186.647273 140.637091-372.829091 300.939637-442.181818-36.817455 65.629091-92.578909 151.970909-92.578909 232.727273 0 250.181818 214.109091 465.454545 462.917818 465.454545a488.331636 488.331636 0 0 0 185.181091-46.545455 453.003636 453.003636 0 0 1-393.565091 232.727273z m103.656728-669.323636l-14.266182 83.781818a34.909091 34.909091 0 0 0 50.362182 36.770909l74.775272-39.563636 74.752 39.563636a36.142545 36.142545 0 0 0 16.174546 3.956364 34.909091 34.909091 0 0 0 34.210909-40.727273l-14.289455-83.781818 60.509091-59.345455a35.025455 35.025455 0 0 0-19.223272-59.578182l-83.61891-12.101818-37.376-76.101818a34.56 34.56 0 0 0-62.254545 0l-37.376 76.101818-83.618909 12.101818a34.909091 34.909091 0 0 0-19.246546 59.578182z m70.423272-64.698182a34.280727 34.280727 0 0 0 26.135273-19.083636l14.312727-29.090909 14.336 29.090909a34.257455 34.257455 0 0 0 26.135273 19.083636l32.046546 4.887273-23.272728 22.574545a35.234909 35.234909 0 0 0-10.007272 30.952727l5.46909 32.116364-28.625454-15.127273a34.490182 34.490182 0 0 0-32.302546 0l-28.695272 15.127273 5.469091-32.116364a35.141818 35.141818 0 0 0-9.984-30.952727l-23.272728-22.574545z" p-id="3855"></path></svg></button><button title="Light theme" class="__dumi-default-dark-sun "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="4026" width="22" height="22"><path d="M915.2 476.16h-43.968c-24.704 0-44.736 16-44.736 35.84s20.032 35.904 44.736 35.904H915.2c24.768 0 44.8-16.064 44.8-35.904s-20.032-35.84-44.8-35.84zM512 265.6c-136.704 0-246.464 109.824-246.464 246.4 0 136.704 109.76 246.464 246.464 246.464S758.4 648.704 758.4 512c0-136.576-109.696-246.4-246.4-246.4z m0 425.6c-99.008 0-179.2-80.128-179.2-179.2 0-98.944 80.192-179.2 179.2-179.2S691.2 413.056 691.2 512c0 99.072-80.192 179.2-179.2 179.2zM197.44 512c0-19.84-19.136-35.84-43.904-35.84H108.8c-24.768 0-44.8 16-44.8 35.84s20.032 35.904 44.8 35.904h44.736c24.768 0 43.904-16.064 43.904-35.904zM512 198.464c19.776 0 35.84-20.032 35.84-44.8v-44.8C547.84 84.032 531.84 64 512 64s-35.904 20.032-35.904 44.8v44.8c0 24.768 16.128 44.864 35.904 44.864z m0 627.136c-19.776 0-35.904 20.032-35.904 44.8v44.736C476.096 940.032 492.16 960 512 960s35.84-20.032 35.84-44.8v-44.736c0-24.768-16.064-44.864-35.84-44.864z m329.92-592.832c17.472-17.536 20.288-43.072 6.4-57.024-14.016-14.016-39.488-11.2-57.024 6.336-4.736 4.864-26.496 26.496-31.36 31.36-17.472 17.472-20.288 43.008-6.336 57.024 13.952 14.016 39.488 11.2 57.024-6.336 4.8-4.864 26.496-26.56 31.296-31.36zM213.376 759.936c-4.864 4.8-26.56 26.624-31.36 31.36-17.472 17.472-20.288 42.944-6.4 56.96 14.016 13.952 39.552 11.2 57.024-6.336 4.8-4.736 26.56-26.496 31.36-31.36 17.472-17.472 20.288-43.008 6.336-56.96-14.016-13.952-39.552-11.072-56.96 6.336z m19.328-577.92c-17.536-17.536-43.008-20.352-57.024-6.336-14.08 14.016-11.136 39.488 6.336 57.024 4.864 4.864 26.496 26.56 31.36 31.424 17.536 17.408 43.008 20.288 56.96 6.336 14.016-14.016 11.264-39.488-6.336-57.024-4.736-4.864-26.496-26.56-31.296-31.424z m527.168 628.608c4.864 4.864 26.624 26.624 31.36 31.424 17.536 17.408 43.072 20.224 57.088 6.336 13.952-14.016 11.072-39.552-6.4-57.024-4.864-4.8-26.56-26.496-31.36-31.36-17.472-17.408-43.072-20.288-57.024-6.336-13.952 14.016-11.008 39.488 6.336 56.96z" p-id="4027"></path></svg></button><button title="Default to system" class="__dumi-default-dark-auto "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="11002" width="22" height="22"><path d="M127.658667 492.885333c0-51.882667 10.24-101.717333 30.378666-149.162666s47.786667-88.064 81.92-122.538667 75.093333-61.781333 122.538667-81.92 96.938667-30.378667 149.162667-30.378667 101.717333 10.24 149.162666 30.378667 88.405333 47.786667 122.88 81.92 61.781333 75.093333 81.92 122.538667 30.378667 96.938667 30.378667 149.162666-10.24 101.717333-30.378667 149.162667-47.786667 88.405333-81.92 122.88-75.093333 61.781333-122.88 81.92-97.28 30.378667-149.162666 30.378667-101.717333-10.24-149.162667-30.378667-88.064-47.786667-122.538667-81.92-61.781333-75.093333-81.92-122.88-30.378667-96.938667-30.378666-149.162667z m329.045333 0c0 130.048 13.994667 244.394667 41.984 343.381334h12.970667c46.762667 0 91.136-9.216 133.461333-27.306667s78.848-42.666667 109.568-73.386667 54.954667-67.242667 73.386667-109.568 27.306667-86.698667 27.306666-133.461333c0-46.421333-9.216-90.794667-27.306666-133.12s-42.666667-78.848-73.386667-109.568-67.242667-54.954667-109.568-73.386667-86.698667-27.306667-133.461333-27.306666h-11.605334c-28.672 123.562667-43.349333 237.909333-43.349333 343.722666z" p-id="11003"></path></svg></button></div></div></div><ul class="__dumi-default-menu-list"><li><a href="/blog/全链路压测实战30讲">全链路压测实战30讲</a></li><li><a href="/blog/全链路压测实战30讲/01.开篇词">01.开篇词</a><ul><li><a href="/blog/全链路压测实战30讲/01.开篇词/01"><span>开篇词 | 打破认知神话，做接地气的全链路压测</span></a></li></ul></li><li><a href="/blog/全链路压测实战30讲/02.核心理论">02.核心理论</a><ul><li><a href="/blog/全链路压测实战30讲/02.核心理论/01"><span>01 | 全链路压测：为什么很多测试人员迷信它？</span></a></li><li><a href="/blog/全链路压测实战30讲/02.核心理论/02"><span>02 | RESAR 全链路流程：如何搞定所有容量场景？</span></a></li></ul></li><li><a aria-current="page" class="active" href="/blog/全链路压测实战30讲/03.实践需求">03.实践需求</a><ul><li><a href="/blog/全链路压测实战30讲/03.实践需求/01"><span>03 | 压测方案：你是否忽略了一个重量级文档？</span></a></li><li><a href="/blog/全链路压测实战30讲/03.实践需求/02"><span>04 | 核心链路：如何梳理符合真实业务场景的核心链路？</span></a></li><li><a href="/blog/全链路压测实战30讲/03.实践需求/03"><span>05 | 铺底数据：真实的压测数据应该做成什么样子？</span></a></li><li><a href="/blog/全链路压测实战30讲/03.实践需求/04"><span>06 | 流量构建：流量平台如何选型？</span></a></li><li><a href="/blog/全链路压测实战30讲/03.实践需求/05"><span>07 | 全栈监控：如何设计全栈监控策略？</span></a></li><li><a href="/blog/全链路压测实战30讲/03.实践需求/06"><span>08 | 基础设施：全链路压测的环境有什么特点？</span></a></li><li><a href="/blog/全链路压测实战30讲/03.实践需求/07"><span>09 | 压测模型：如何建立一套完整的全链路压测模型？</span></a></li><li><a href="/blog/全链路压测实战30讲/03.实践需求/08"><span>10 | 场景执行：压测执行过程中的关键步骤是什么？</span></a></li><li><a href="/blog/全链路压测实战30讲/03.实践需求/09"><span>11 | 链路追踪：如何选择一款适合自己项目的工具？</span></a></li><li><a href="/blog/全链路压测实战30讲/03.实践需求/10"><span>12 | 链路追踪：如何对一个具体的项目进行追踪改造？</span></a></li><li><a href="/blog/全链路压测实战30讲/03.实践需求/11"><span>13 | 标记透传：微服务系统如何做标记透传方案选型？</span></a></li><li><a href="/blog/全链路压测实战30讲/03.实践需求/12"><span>14 | 标记透传：如何基于微服务技术进行标记透传？</span></a></li><li><a href="/blog/全链路压测实战30讲/03.实践需求/13"><span>15 | 流量隔离：MySQL数据库隔离是怎么做的？</span></a></li><li><a href="/blog/全链路压测实战30讲/03.实践需求/14"><span>16 | 流量隔离：Redis 缓存隔离是怎么做的？</span></a></li><li><a href="/blog/全链路压测实战30讲/03.实践需求/15"><span>17 | 流量隔离：MongoDB 数据库隔离是怎么做的？</span></a></li><li><a aria-current="page" class="active" href="/blog/全链路压测实战30讲/03.实践需求/16"><span>18 | 流量隔离：RabbitMQ 消息隔离是怎么做的？</span></a></li><li><a href="/blog/全链路压测实战30讲/03.实践需求/17"><span>19｜日志隔离：如何落地日志隔离？</span></a></li><li><a href="/blog/全链路压测实战30讲/03.实践需求/18"><span>20 | Mock：如何屏蔽第三方接口的影响？</span></a></li></ul></li><li><a href="/blog/全链路压测实战30讲/04.实践环境">04.实践环境</a><ul><li><a href="/blog/全链路压测实战30讲/04.实践环境/01"><span>21 | 压测平台：高效搭建 GoReplay 压测平台</span></a></li><li><a href="/blog/全链路压测实战30讲/04.实践环境/02"><span>22 | 压测平台：如何解决 GoReplay 动态数据关联？</span></a></li><li><a href="/blog/全链路压测实战30讲/04.实践环境/03"><span>23 | 压测平台：如何改造对象存储和性能监控？</span></a></li><li><a href="/blog/全链路压测实战30讲/04.实践环境/04"><span>24 | 压测平台：如何改造分布式调度平台？</span></a></li><li><a href="/blog/全链路压测实战30讲/04.实践环境/05"><span>25 | 环境搭建：我们的系统是怎么搭建起来的？</span></a></li><li><a href="/blog/全链路压测实战30讲/04.实践环境/06"><span>26 | 全局监控（上）：如何快速落地全局监控？</span></a></li><li><a href="/blog/全链路压测实战30讲/04.实践环境/07"><span>27 | 全局监控（下）：如何快速落地全局监控？</span></a></li><li><a href="/blog/全链路压测实战30讲/04.实践环境/08"><span>28 | 定向监控：怎样快速发现业务异常？</span></a></li></ul></li><li><a href="/blog/全链路压测实战30讲/05.实践性能场景执行">05.实践性能场景执行</a><ul><li><a href="/blog/全链路压测实战30讲/05.实践性能场景执行/01"><span>29 | 基准场景：一个案例，带你搞懂基准场景的关键要点</span></a></li><li><a href="/blog/全链路压测实战30讲/05.实践性能场景执行/02"><span>30 | 预压测：如何基于小流量快速验证容量压测效果？</span></a></li><li><a href="/blog/全链路压测实战30讲/05.实践性能场景执行/03"><span>31 | 容量场景：决定线上容量场景的关键因素是什么？</span></a></li><li><a href="/blog/全链路压测实战30讲/05.实践性能场景执行/04"><span>32 | 稳定性场景：怎样搞定线上稳定性场景？</span></a></li><li><a href="/blog/全链路压测实战30讲/05.实践性能场景执行/05"><span>33 | 异常场景：如何模拟线上不同组件的异常场景？</span></a></li><li><a href="/blog/全链路压测实战30讲/05.实践性能场景执行/06"><span>34 | 容量规划：如何精准地对生产系统做容量预估？</span></a></li></ul></li><li><a href="/blog/全链路压测实战30讲/06.性能结果报告">06.性能结果报告</a><ul><li><a href="/blog/全链路压测实战30讲/06.性能结果报告/01"><span>35 | 压测报告：怎样写出一份让老板满意的报告？</span></a></li></ul></li><li><a href="/blog/全链路压测实战30讲/07.结束语">07.结束语</a><ul><li><a href="/blog/全链路压测实战30讲/07.结束语/01"><span>结束语 | 做能落地的全链路压测项目</span></a></li><li><a href="/blog/全链路压测实战30讲/07.结束语/02"><span>期末考试 |《全链路压测实战30讲》满分试卷，等你来挑战！</span></a></li></ul></li><li><a href="/blog/全链路压测实战30讲/summary">全链路压测实战30讲</a></li></ul></div></div><ul role="slug-list" class="__dumi-default-layout-toc"><li title="消息隔离方案" data-depth="2"><a href="/blog/全链路压测实战30讲/03.实践需求/16#消息隔离方案"><span>消息隔离方案</span></a></li><li title="技术预演" data-depth="2"><a href="/blog/全链路压测实战30讲/03.实践需求/16#技术预演"><span>技术预演</span></a></li><li title="影子队列实现" data-depth="3"><a href="/blog/全链路压测实战30讲/03.实践需求/16#影子队列实现"><span>影子队列实现</span></a></li><li title="数据偏移实现" data-depth="3"><a href="/blog/全链路压测实战30讲/03.实践需求/16#数据偏移实现"><span>数据偏移实现</span></a></li><li title="真实系统改造" data-depth="2"><a href="/blog/全链路压测实战30讲/03.实践需求/16#真实系统改造"><span>真实系统改造</span></a></li><li title="总结" data-depth="2"><a href="/blog/全链路压测实战30讲/03.实践需求/16#总结"><span>总结</span></a></li><li title="课后题" data-depth="2"><a href="/blog/全链路压测实战30讲/03.实践需求/16#课后题"><span>课后题</span></a></li></ul><div class="__dumi-default-layout-content"><div class="markdown"><h1 id="18--流量隔离rabbitmq-消息隔离是怎么做的"><a aria-hidden="true" tabindex="-1" href="/blog/全链路压测实战30讲/03.实践需求/16#18--流量隔离rabbitmq-消息隔离是怎么做的"><span class="icon icon-link"></span></a>18 | 流量隔离：RabbitMQ 消息隔离是怎么做的？</h1><p>你好，我是高楼。</p><p>这节课，我们详细来讲讲如何基于微服务技术落地 RabbitMQ 消息隔离。</p><p>我们的项目中选择的消息中间件是 RabbitMQ。它是最受欢迎的开源消息中间件之一。RabbitMQ 量级轻，而且易于部署，能支持多种消息协议。它还可以部署在分布式系统中，满足大规模、高可用、削峰填谷的要求。所有消息中间件的根本目标是相同的，那就是：<strong>将同步处理转成异步处理。</strong></p><p>首先，我们来了解一下 Spring 中 RabbitMQ 的消息传递解决方案。</p><p>Spring 生态中提供了<a target="_blank" rel="noopener noreferrer" href="https://spring.io/projects/spring-amqp">Spring-AMQP<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 项目，可以让我们更简便地使用 AMQP。它提供了一个“template”作为发送消息的高级抽象。同时它还通过“Listener Container”为消息驱动的 POJO 提供支持。这些库简化了 AMQP 资源的开发使用。</p><p>这个项目主要包括两个部分：</p><ul><li><a target="_blank" rel="noopener noreferrer" href="https://mvnrepository.com/artifact/org.springframework.amqp/spring-amqp">Spring-AMQP<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> ：是 AMQP 的基础抽象；</li><li><a target="_blank" rel="noopener noreferrer" href="https://mvnrepository.com/artifact/org.springframework.amqp/spring-rabbit">Spring-Rabbit<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> ：是基于 RabbitMQ 对 AMQP 的具体实现。</li></ul><p>它的主要功能包括：</p><ul><li>Listener Container：异步处理接收到的消息；</li><li><a target="_blank" rel="noopener noreferrer" href="https://github.com/spring-projects/spring-amqp/blob/master/spring-rabbit/src/main/java/org/springframework/amqp/rabbit/core/RabbitTemplate.java">RabbitTemplate<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> ：发送和接收消息；</li><li><a target="_blank" rel="noopener noreferrer" href="https://github.com/spring-projects/spring-amqp/blob/master/spring-rabbit/src/main/java/org/springframework/amqp/rabbit/core/RabbitAdmin.java">RabbitAdmin<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> ​：自动创建队列、交换机、绑定器。</li></ul><p>因为我们的项目采用 SpringBoot，而它默认提供了 AMQP 和 RabbitMQ 的自动化配置，所以我们仅需引入 spring-boot-starter-amqp 依赖，即可快速装配使用了。</p><h2 id="消息隔离方案"><a aria-hidden="true" tabindex="-1" href="/blog/全链路压测实战30讲/03.实践需求/16#消息隔离方案"><span class="icon icon-link"></span></a>消息隔离方案</h2><p>刚才，我们简单介绍了 RabbitMQ，并了解了如何在 SpringBoot 中使用 RabbitMQ。接下来，我们回到这节课的主题：如何在 SpringBoot 中落地 MQ 消息隔离方案。</p><p>在这里我梳理了目前业界对于消息中间件隔离的主要解决方案，你可以参考下面的表格：<br/><img src="https://static001.geekbang.org/resource/image/1b/3f/1b11259057e92939e336ef01b748183f.jpg?wh=1920x1080" alt="图片"/></p><p>其中，数据偏移方式会让压测消息跟正常消息都进入到生产队列。压测消息在发送端加上标记，然后在接收端加上识别。</p><p>而影子队列方式则会把压测消息发送到另一个影子队列里，跟生产队列完全隔离开。接受端同时监听生产队列和影子队列，然后从接收的消息判断是哪个队列发过来的，再根据判断的结果做对应的处理。</p><p>根据不同的项目情况，我们可以选择不同的技术方案，当然，<strong>这里我们首推影子队列，因为它相对安全</strong>。</p><p>为了方便你参考，我会对影子队列和数据偏移方案分别进行演示。</p><h2 id="技术预演"><a aria-hidden="true" tabindex="-1" href="/blog/全链路压测实战30讲/03.实践需求/16#技术预演"><span class="icon icon-link"></span></a>技术预演</h2><p>在正式预演之前，我们先要知道 RabbitMQ 消息模式的实现方式，<a target="_blank" rel="noopener noreferrer" href="https://www.rabbitmq.com/getstarted.html">RabbitMQ 的 7 种消息模式<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>是构建消息应用的基础，我们一定要牢牢掌握它们。</p><p><img src="https://static001.geekbang.org/resource/image/5c/b0/5ccdcca63d340c8dc1179eb6a1acb7b0.png?wh=999x602" alt="图片"/></p><p>学过 RabbitMQ 的朋友应该了解过这些消息模式的 Java 实现方式，这里的 demo 预演我们使用 Spring AMQP 的形式来实现它们。</p><p>在 AMQP 中，发布者将消息发送到交换机，再由交换机将消息路由到一个或多个消息队列中（或者丢弃）。</p><p>交换机会根据路由键和绑定的键将消息路由到消息队列。目前常用的交换器类型有 Direct、Topic、Fanout、Headers 四种类型。</p><h3 id="影子队列实现"><a aria-hidden="true" tabindex="-1" href="/blog/全链路压测实战30讲/03.实践需求/16#影子队列实现"><span class="icon icon-link"></span></a>影子队列实现</h3><p>我们先来看一下影子队列的实现方式。</p><p>影子队列我们主要通过 RabbitMQ 的路由模式（Direct）实现：</p><blockquote><p>路由模式是可以根据路由键选择性给多个消费者发送消息的模式。它包含一个发布者、两个消费者、两个队列和一个交换机。两个消费者同时绑定到不同的队列上去，两个队列通过路由键绑定到交换机上去，发布者发送消息到交换机，交换机通过路由键转发到不同队列，队列绑定的消费者接收并消费消息。</p></blockquote><p>为了方便你更直观地理解路由模式的原理，我给你画了一张示意图。</p><p><img src="https://static001.geekbang.org/resource/image/51/42/51c5cacb48d3f00edcf24ea389e0ca42.jpg?wh=1920x569" alt="图片"/></p><p>通过这张图我们可以很直观的看到：</p><ul><li>如果我们以 routingKey=“produce” 发送消息到交换机，消息会路由到 7dQueue。</li><li>如果我们以 routingKey=“shadow”  发送消息到交换机，消息会路由到 7dQueue_shadow。</li></ul><p>也就是说，如果我们在交换机设置对应路由键，那么消息就只会路由到最多一个消息队列中。如果没有相应的匹配，消息就会发送到“空气”（丢弃）中，不会进入任何消息队列中了。</p><p>我们还是来看一下具体的操作步骤吧。</p><p>这里使用的 demo 工程还是 14 讲的示例，主要包括网关和消息系统 2 个服务：</p><p><img src="https://static001.geekbang.org/resource/image/9d/51/9dfd614cb25639683ea8f441cb431551.jpg?wh=847x226" alt=""/></p><p>下面我们主要改造消息系统，实现 RabbitMQ 消息隔离技术预演。</p><p><strong>第一步，引入相关依赖。</strong></p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">&lt;dependencies&gt;</span></div><div class="token-line"><span class="token plain">        &lt;dependency&gt;</span></div><div class="token-line"><span class="token plain">            &lt;groupId&gt;com.dunshan&lt;/groupId&gt;</span></div><div class="token-line"><span class="token plain">            &lt;artifactId&gt;dunshan-common&lt;/artifactId&gt;</span></div><div class="token-line"><span class="token plain">            &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;</span></div><div class="token-line"><span class="token plain">            &lt;scope&gt;compile&lt;/scope&gt;</span></div><div class="token-line"><span class="token plain">            &lt;exclusions&gt;</span></div><div class="token-line"><span class="token plain">                &lt;exclusion&gt;</span></div><div class="token-line"><span class="token plain">                    &lt;artifactId&gt;jsr305&lt;/artifactId&gt;</span></div><div class="token-line"><span class="token plain">                    &lt;groupId&gt;com.google.code.findbugs&lt;/groupId&gt;</span></div><div class="token-line"><span class="token plain">                &lt;/exclusion&gt;</span></div><div class="token-line"><span class="token plain">            &lt;/exclusions&gt;</span></div><div class="token-line"><span class="token plain">        &lt;/dependency&gt;</span></div><div class="token-line"><span class="token plain">        &lt;dependency&gt;</span></div><div class="token-line"><span class="token plain">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span></div><div class="token-line"><span class="token plain">            &lt;artifactId&gt;spring-boot-starter-aop&lt;/artifactId&gt;</span></div><div class="token-line"><span class="token plain">        &lt;/dependency&gt;</span></div><div class="token-line"><span class="token plain">        &lt;dependency&gt;</span></div><div class="token-line"><span class="token plain">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span></div><div class="token-line"><span class="token plain">            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;</span></div><div class="token-line"><span class="token plain">            &lt;scope&gt;test&lt;/scope&gt;</span></div><div class="token-line"><span class="token plain">        &lt;/dependency&gt;</span></div><div class="token-line"><span class="token plain">        &lt;!--Swagger-UI API 文档生产工具--&gt;</span></div><div class="token-line"><span class="token plain">        &lt;dependency&gt;</span></div><div class="token-line"><span class="token plain">            &lt;groupId&gt;io.springfox&lt;/groupId&gt;</span></div><div class="token-line"><span class="token plain">            &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt;</span></div><div class="token-line"><span class="token plain">            &lt;version&gt;2.7.0&lt;/version&gt;</span></div><div class="token-line"><span class="token plain">        &lt;/dependency&gt;</span></div><div class="token-line"><span class="token plain">        &lt;dependency&gt;</span></div><div class="token-line"><span class="token plain">            &lt;groupId&gt;io.springfox&lt;/groupId&gt;</span></div><div class="token-line"><span class="token plain">            &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt;</span></div><div class="token-line"><span class="token plain">            &lt;version&gt;2.7.0&lt;/version&gt;</span></div><div class="token-line"><span class="token plain">        &lt;/dependency&gt;</span></div><div class="token-line"><span class="token plain">        &lt;!--hutool 工具包--&gt;</span></div><div class="token-line"><span class="token plain">        &lt;dependency&gt;</span></div><div class="token-line"><span class="token plain">            &lt;groupId&gt;cn.hutool&lt;/groupId&gt;</span></div><div class="token-line"><span class="token plain">            &lt;artifactId&gt;hutool-all&lt;/artifactId&gt;</span></div><div class="token-line"><span class="token plain">            &lt;version&gt;4.6.3&lt;/version&gt;</span></div><div class="token-line"><span class="token plain">        &lt;/dependency&gt;</span></div><div class="token-line"><span class="token plain">        &lt;!--Spring AMQP 依赖--&gt;</span></div><div class="token-line"><span class="token plain">        &lt;dependency&gt;</span></div><div class="token-line"><span class="token plain">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span></div><div class="token-line"><span class="token plain">            &lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt;</span></div><div class="token-line"><span class="token plain">        &lt;/dependency&gt;</span></div><div class="token-line"><span class="token plain">        &lt;dependency&gt;</span></div><div class="token-line"><span class="token plain">            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;</span></div><div class="token-line"><span class="token plain">            &lt;artifactId&gt;lombok&lt;/artifactId&gt;</span></div><div class="token-line"><span class="token plain">            &lt;version&gt;1.18.10&lt;/version&gt;</span></div><div class="token-line"><span class="token plain">            &lt;scope&gt;provided&lt;/scope&gt;</span></div><div class="token-line"><span class="token plain">        &lt;/dependency&gt;</span></div><div class="token-line"><span class="token plain">    &lt;/dependencies&gt;</span></div></pre></div><p><strong>第二步，在 resources 目录下，创建 application.yaml 配置文件。</strong></p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">server:</span></div><div class="token-line"><span class="token plain">      port: 8008</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    spring:</span></div><div class="token-line"><span class="token plain">      rabbitmq:</span></div><div class="token-line"><span class="token plain">        host: localhost</span></div><div class="token-line"><span class="token plain">        port: 5672</span></div><div class="token-line"><span class="token plain">        virtual-host: /</span></div><div class="token-line"><span class="token plain">        username: guest</span></div><div class="token-line"><span class="token plain">        password: guest</span></div><div class="token-line"><span class="token plain">        publisher-confirms: true #消息发送到交换器确认</span></div><div class="token-line"><span class="token plain">        publisher-returns: true #消息发送到队列确认</span></div></pre></div><p>这里，我们在 spring.rabbitmq 配置项，设置了 RabbitMQ 的配置，对应的是 RabbitProperties 配置类。</p><p>然后，我们可以利用 SpringBoot 提供的 RabbitAutoConfiguration 自动化配置类，实现 RabbitMQ 的自动配置，创建相应的发布者和消费者。</p><p><strong>第三步，创建 RabbitConfig 配置类，添加和 Direct Exchange 相关的 Exchange、Queue、Binding 配置。</strong></p><p>这一步主要是添加和路由模式相关 Java 配置，创建一个名为 exchange.7d 的交换机、一个发布者、两个消费者和两个消息队列。其中，队列通过路由键都绑定到交换机。</p><ul><li>消息队列 7dQueue 的路由键为 produce；</li><li>消息队列 7dQueue_shadow 的路由键为 shadow。</li></ul><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">package com.dunshan.direct;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    import org.springframework.amqp.core.Binding;</span></div><div class="token-line"><span class="token plain">    import org.springframework.amqp.core.BindingBuilder;</span></div><div class="token-line"><span class="token plain">    import org.springframework.amqp.core.DirectExchange;</span></div><div class="token-line"><span class="token plain">    import org.springframework.amqp.core.Queue;</span></div><div class="token-line"><span class="token plain">    import org.springframework.context.annotation.Bean;</span></div><div class="token-line"><span class="token plain">    import org.springframework.context.annotation.Configuration;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    /**</span></div><div class="token-line"><span class="token plain">     *</span></div><div class="token-line"><span class="token plain">     * @author dunshan</span></div><div class="token-line"><span class="token plain">     * @date 2021/10/1</span></div><div class="token-line"><span class="token plain">     */</span></div><div class="token-line"><span class="token plain">    @Configuration</span></div><div class="token-line"><span class="token plain">    public class DirectRabbitConfig {</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        @Bean</span></div><div class="token-line"><span class="token plain">        public DirectExchange direct() {</span></div><div class="token-line"><span class="token plain">            return new DirectExchange(&quot;exchange.7d&quot;);</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        </span></div><div class="token-line"><span class="token plain">        @Bean</span></div><div class="token-line"><span class="token plain">        public Queue directQueue() {</span></div><div class="token-line"><span class="token plain">            return new Queue(&quot;7dQueue&quot;);</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        </span></div><div class="token-line"><span class="token plain">        @Bean</span></div><div class="token-line"><span class="token plain">        public Queue directQueueShadow() {</span></div><div class="token-line"><span class="token plain">            return new Queue(&quot;7dQueue_shadow&quot;);</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        @Bean</span></div><div class="token-line"><span class="token plain">        public Binding directBinding1a(DirectExchange direct, Queue directQueue) {</span></div><div class="token-line"><span class="token plain">            return BindingBuilder.bind(directQueue).to(direct).with(&quot;produce&quot;);</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        </span></div><div class="token-line"><span class="token plain">        @Bean</span></div><div class="token-line"><span class="token plain">        public Binding directBinding1b(DirectExchange direct, Queue directQueueShadow) {</span></div><div class="token-line"><span class="token plain">            return BindingBuilder.bind(directQueueShadow).to(direct).with(&quot;shadow&quot;);</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        </span></div><div class="token-line"><span class="token plain">        @Bean</span></div><div class="token-line"><span class="token plain">        public DirectReceiver receiver() {</span></div><div class="token-line"><span class="token plain">            return new DirectReceiver();</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        </span></div><div class="token-line"><span class="token plain">        @Bean</span></div><div class="token-line"><span class="token plain">        public DirectSender directSender() {</span></div><div class="token-line"><span class="token plain">            return new DirectSender();</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>从这段代码中可以看到，在 DirectExchangeDemoConfiguration 内部静态类中，我们创建了 Exchange、Queue、Binding 三个 Bean，后续 RabbitAdmin 会自动创建交换机、消息队列、绑定器。</p><p><strong>第四步，实现获取压测标记。</strong></p><p>接下来我们就要考虑如何获取压测请求 Header 标记了。</p><p>首先还是实现一个全局 Filter 过滤器，只要从 Span Baggage 获取压测标记放入 Context （数据上下文），就能在服务中使用了。</p><p>全局 Filter 过滤器代码如下：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">package com.dunshan.config;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    import brave.Span;</span></div><div class="token-line"><span class="token plain">    import brave.Tracer;</span></div><div class="token-line"><span class="token plain">    import brave.baggage.BaggageField;</span></div><div class="token-line"><span class="token plain">    import lombok.extern.log4j.Log4j2;</span></div><div class="token-line"><span class="token plain">    import org.apache.commons.lang3.StringUtils;</span></div><div class="token-line"><span class="token plain">    import org.springframework.stereotype.Component;</span></div><div class="token-line"><span class="token plain">    import javax.servlet.*;</span></div><div class="token-line"><span class="token plain">    import java.io.IOException;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    /**</span></div><div class="token-line"><span class="token plain">     * @author dunshan</span></div><div class="token-line"><span class="token plain">     * @description: 全局过滤器</span></div><div class="token-line"><span class="token plain">     * @date 2021-10-03 17:45:30</span></div><div class="token-line"><span class="token plain">     */</span></div><div class="token-line"><span class="token plain">    @Log4j2</span></div><div class="token-line"><span class="token plain">    @Component</span></div><div class="token-line"><span class="token plain">    public class ContextFilter implements Filter {</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        private final Tracer tracer;</span></div><div class="token-line"><span class="token plain">        ContextFilter(Tracer tracer) {</span></div><div class="token-line"><span class="token plain">            this.tracer = tracer;</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        </span></div><div class="token-line"><span class="token plain">        @Override</span></div><div class="token-line"><span class="token plain">        public void init(FilterConfig filterConfig) throws ServletException {</span></div><div class="token-line"><span class="token plain">            Filter.super.init(filterConfig);</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        </span></div><div class="token-line"><span class="token plain">        @Override</span></div><div class="token-line"><span class="token plain">        public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException {</span></div><div class="token-line"><span class="token plain">            BaggageField dunshan = BaggageField.getByName(&quot;dunshan&quot;);</span></div><div class="token-line"><span class="token plain">            String flag = dunshan.getValue();</span></div><div class="token-line"><span class="token plain">            Span currentSpan = this.tracer.currentSpan();</span></div><div class="token-line"><span class="token plain">            AppContext appContext = new AppContext();</span></div><div class="token-line"><span class="token plain">            if (StringUtils.isNotBlank(flag)) {</span></div><div class="token-line"><span class="token plain">                log.info(&quot;压测流量: &quot; + flag);</span></div><div class="token-line"><span class="token plain">                currentSpan.tag(&quot;flag&quot;, flag);</span></div><div class="token-line"><span class="token plain">                appContext.setFlag(flag);</span></div><div class="token-line"><span class="token plain">                AppContext.setContext(appContext);</span></div><div class="token-line"><span class="token plain">            } else {</span></div><div class="token-line"><span class="token plain">                log.info(&quot;正常流量: &quot; + flag);</span></div><div class="token-line"><span class="token plain">                AppContext.setContext(appContext);</span></div><div class="token-line"><span class="token plain">            }</span></div><div class="token-line"><span class="token plain">            filterChain.doFilter(servletRequest, servletResponse);</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        </span></div><div class="token-line"><span class="token plain">        @Override</span></div><div class="token-line"><span class="token plain">        public void destroy() {</span></div><div class="token-line"><span class="token plain">            AppContext.removeContext();</span></div><div class="token-line"><span class="token plain">            Filter.super.destroy();</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        </span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>数据上下文代码如下：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">package com.dunshan.config;</span></div><div class="token-line"><span class="token plain">    import com.alibaba.ttl.TransmittableThreadLocal;</span></div><div class="token-line"><span class="token plain">    import java.io.Serializable;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    /**</span></div><div class="token-line"><span class="token plain">     * @author dunshan</span></div><div class="token-line"><span class="token plain">     * @description: 数据上下文</span></div><div class="token-line"><span class="token plain">     * @date 2021-11-12 17:53:39</span></div><div class="token-line"><span class="token plain">     */</span></div><div class="token-line"><span class="token plain">    public class AppContext implements Serializable {</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        private static final TransmittableThreadLocal&lt;AppContext&gt; contextdunshan = new TransmittableThreadLocal&lt;&gt;();</span></div><div class="token-line"><span class="token plain">        private String flag;</span></div><div class="token-line"><span class="token plain">        </span></div><div class="token-line"><span class="token plain">        public static AppContext getContext() {</span></div><div class="token-line"><span class="token plain">            return contextdunshan.get();</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        </span></div><div class="token-line"><span class="token plain">        public static void setContext(AppContext context) {</span></div><div class="token-line"><span class="token plain">            contextdunshan.set(context);</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        </span></div><div class="token-line"><span class="token plain">        public static void removeContext() {</span></div><div class="token-line"><span class="token plain">            contextdunshan.remove();</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        </span></div><div class="token-line"><span class="token plain">        public String getFlag() {</span></div><div class="token-line"><span class="token plain">            return flag;</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        </span></div><div class="token-line"><span class="token plain">        public void setFlag(String flag) {</span></div><div class="token-line"><span class="token plain">            this.flag = flag;</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        </span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>后面，我们只要在业务方通过从 getContext().getFlag() 中取出 Header 标记即可。</p><p>代码如下：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// 获取标记</span></div><div class="token-line"><span class="token plain">    String header = AppContext.getContext().getFlag();</span></div></pre></div><p><strong>第五步，创建 DirectSender 类。</strong></p><p>它会使用 Spring-AMQP 封装提供的 RabbitTemplate 来发送消息。发布者通过 send 方法向交换机 exchange.7d 发送消息。交换机通过判断是否为压测标记，来选择使用不同的路由键，然后，这些消息会根据不同的路由键被转发到不同的队列。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">package com.dunshan.direct;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    import com.dunshan.config.AppContext;</span></div><div class="token-line"><span class="token plain">    import lombok.extern.slf4j.Slf4j;</span></div><div class="token-line"><span class="token plain">    import org.springframework.amqp.rabbit.core.RabbitTemplate;</span></div><div class="token-line"><span class="token plain">    import org.springframework.beans.factory.annotation.Autowired;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    /**</span></div><div class="token-line"><span class="token plain">     *</span></div><div class="token-line"><span class="token plain">     * @author dunshan</span></div><div class="token-line"><span class="token plain">     * @date 2021/10/1</span></div><div class="token-line"><span class="token plain">     */</span></div><div class="token-line"><span class="token plain">    @Slf4j</span></div><div class="token-line"><span class="token plain">    public class DirectSender {</span></div><div class="token-line"><span class="token plain">       </span></div><div class="token-line"><span class="token plain">       @Autowired</span></div><div class="token-line"><span class="token plain">       private RabbitTemplate template;</span></div><div class="token-line"><span class="token plain">       </span></div><div class="token-line"><span class="token plain">       private static final String exchangeName = &quot;exchange.7d&quot;;</span></div><div class="token-line"><span class="token plain">       </span></div><div class="token-line"><span class="token plain">       public void send(int index) {</span></div><div class="token-line"><span class="token plain">          // 获取标记</span></div><div class="token-line"><span class="token plain">          String header = AppContext.getContext().getFlag();</span></div><div class="token-line"><span class="token plain">          StringBuilder builder = new StringBuilder(&quot;Hello to &quot;);</span></div><div class="token-line"><span class="token plain">          String message = builder.toString();</span></div><div class="token-line"><span class="token plain">         </span></div><div class="token-line"><span class="token plain">           // 判断标记</span></div><div class="token-line"><span class="token plain">          if (&quot;7DGroup&quot;.equals(header)) {</span></div><div class="token-line"><span class="token plain">             template.convertAndSend(exchangeName, &quot;shadow&quot;, message);</span></div><div class="token-line"><span class="token plain">          } else {</span></div><div class="token-line"><span class="token plain">             template.convertAndSend(exchangeName, &quot;produce&quot;, message);</span></div><div class="token-line"><span class="token plain">          }</span></div><div class="token-line"><span class="token plain">          log.info(&quot; [x] Sent &#x27;{}&#x27;&quot;, message);</span></div><div class="token-line"><span class="token plain">       }</span></div><div class="token-line"><span class="token plain">       </span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>在具体的代码实现上，因为 RabbitTemplate 是 AmqpTemplate 接口的实现类，所以使用 AmqpTemplate 也可以。不过因为 RabbitTemplate 还实现了其它接口，操作会更为丰富一些。所以这里我们还是选择注入了 RabbitTemplate 属性。</p><p><strong>第六步，创建 DirectReceiver 类，消费消息。</strong></p><p>消费者从自己绑定的匿名队列中获取消息，由于该消费者可以从两个队列中获取并消费消息，所以可以看做是两个消费者，名称分别是 instance 1 和 instance 2。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">package com.dunshan.direct;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    import cn.hutool.core.thread.ThreadUtil;</span></div><div class="token-line"><span class="token plain">    import lombok.extern.slf4j.Slf4j;</span></div><div class="token-line"><span class="token plain">    import org.springframework.amqp.rabbit.annotation.RabbitListener;</span></div><div class="token-line"><span class="token plain">    import org.springframework.util.StopWatch;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    /**</span></div><div class="token-line"><span class="token plain">     *</span></div><div class="token-line"><span class="token plain">     * @author dunshan</span></div><div class="token-line"><span class="token plain">     * @date 2021/10/1</span></div><div class="token-line"><span class="token plain">     */</span></div><div class="token-line"><span class="token plain">    @Slf4j</span></div><div class="token-line"><span class="token plain">    public class DirectReceiver {</span></div><div class="token-line"><span class="token plain">        </span></div><div class="token-line"><span class="token plain">        @RabbitListener(queues = &quot;#{directQueue.name}&quot;)</span></div><div class="token-line"><span class="token plain">        public void receive1(String in){</span></div><div class="token-line"><span class="token plain">            receive(in, 1);</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        </span></div><div class="token-line"><span class="token plain">        @RabbitListener(queues = &quot;#{directQueueShadow.name}&quot;)</span></div><div class="token-line"><span class="token plain">        public void receive2(String in){</span></div><div class="token-line"><span class="token plain">            receive(in, 2);</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">       </span></div><div class="token-line"><span class="token plain">        private void receive(String in, int receiver){</span></div><div class="token-line"><span class="token plain">            StopWatch watch = new StopWatch();</span></div><div class="token-line"><span class="token plain">            watch.start();</span></div><div class="token-line"><span class="token plain">            log.info(&quot;instance {} [x] Received &#x27;{}&#x27;&quot;, receiver, in);</span></div><div class="token-line"><span class="token plain">            doWork(in);</span></div><div class="token-line"><span class="token plain">            watch.stop();</span></div><div class="token-line"><span class="token plain">            log.info(&quot;instance {} [x] Done in {}s&quot;, receiver, watch.getTotalTimeSeconds());</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        </span></div><div class="token-line"><span class="token plain">        private void doWork(String in){</span></div><div class="token-line"><span class="token plain">            for (char ch : in.toCharArray()) {</span></div><div class="token-line"><span class="token plain">                if (ch == &#x27;.&#x27;) {</span></div><div class="token-line"><span class="token plain">                    ThreadUtil.sleep(1000);</span></div><div class="token-line"><span class="token plain">                }</span></div><div class="token-line"><span class="token plain">            }</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        </span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>可以看到，我们在类上添加了 <a target="_blank" rel="noopener noreferrer" href="https:///RabbitListener">@RabbitListener<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 注解，声明了消费的队列。</p><p><strong>第七步，在 Controller 中添加测试接口。</strong></p><p>这里主要实现调用该接口，开始发送消息。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">package com.dunshan.controller;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    import cn.hutool.core.thread.ThreadUtil;</span></div><div class="token-line"><span class="token plain">    import com.dunshan.common.api.CommonResult;</span></div><div class="token-line"><span class="token plain">    import com.dunshan.direct.DirectSender;</span></div><div class="token-line"><span class="token plain">    import com.dunshan.directheader.DirectHeaderSender;</span></div><div class="token-line"><span class="token plain">    import io.swagger.annotations.Api;</span></div><div class="token-line"><span class="token plain">    import io.swagger.annotations.ApiOperation;</span></div><div class="token-line"><span class="token plain">    import org.slf4j.Logger;</span></div><div class="token-line"><span class="token plain">    import org.slf4j.LoggerFactory;</span></div><div class="token-line"><span class="token plain">    import org.springframework.beans.factory.annotation.Autowired;</span></div><div class="token-line"><span class="token plain">    import org.springframework.stereotype.Controller;</span></div><div class="token-line"><span class="token plain">    import org.springframework.web.bind.annotation.RequestMapping;</span></div><div class="token-line"><span class="token plain">    import org.springframework.web.bind.annotation.RequestMethod;</span></div><div class="token-line"><span class="token plain">    import org.springframework.web.bind.annotation.ResponseBody;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    /**</span></div><div class="token-line"><span class="token plain">     * Created by dunshan on 2020/5/19.</span></div><div class="token-line"><span class="token plain">     */</span></div><div class="token-line"><span class="token plain">    @Api(tags = &quot;RabbitController&quot;, description = &quot;RabbitMQ 消息隔离测试&quot;)</span></div><div class="token-line"><span class="token plain">    @Controller</span></div><div class="token-line"><span class="token plain">    @RequestMapping(&quot;/rabbit&quot;)</span></div><div class="token-line"><span class="token plain">    @Slf4j</span></div><div class="token-line"><span class="token plain">    public class RabbitController {</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        @Autowired</span></div><div class="token-line"><span class="token plain">        private DirectSender directSender;</span></div><div class="token-line"><span class="token plain">        </span></div><div class="token-line"><span class="token plain">        @ApiOperation(&quot;路由模式&quot;)</span></div><div class="token-line"><span class="token plain">        @RequestMapping(value = &quot;/direct&quot;, method = RequestMethod.GET)</span></div><div class="token-line"><span class="token plain">        @ResponseBody</span></div><div class="token-line"><span class="token plain">        public CommonResult directTest() {</span></div><div class="token-line"><span class="token plain">            for(int i=0;i&lt;10;i++){</span></div><div class="token-line"><span class="token plain">                directSender.send(i);</span></div><div class="token-line"><span class="token plain">                ThreadUtil.sleep(1000);</span></div><div class="token-line"><span class="token plain">            }</span></div><div class="token-line"><span class="token plain">            return CommonResult.success(null);</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        </span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p><strong>第八步，接口测试验证。</strong></p><p>我们可以通过 Postman 做接口测试，往队列中发送包含不同路由键的消息。</p><ul><li>发送正常请求（不带压测标记）<br/><img src="https://static001.geekbang.org/resource/image/21/1d/2164868fba308d6c696c2e154805391d.png?wh=1920x1461" alt="图片"/></li></ul><p>服务端的控制台日志如下：</p><p><img src="https://static001.geekbang.org/resource/image/b2/3a/b21c23d49yy292cbc76518d59cc5223a.png?wh=1401x604" alt="图片"/></p><ul><li>发送压测请求（带压测标记）<br/><img src="https://static001.geekbang.org/resource/image/bb/3a/bb11d1acf0685bf4046194bc87812c3a.png?wh=1920x1474" alt="图片"/></li></ul><p>服务端的控制台日志如下：</p><p><img src="https://static001.geekbang.org/resource/image/d0/44/d0f5c3eed95edd56bfcf541a3c9e4144.png?wh=1407x623" alt="图片"/></p><p>可以看到，instance 1 获取到了正常消息，instance 2 获取到了压测消息，这说明测试成功了。</p><p>这样的话，后续业务我们就可以判断消息是不是从影子队列发过来的了。我们还可以将压测标记设置到数据上下文，最后根据这个标记来写数据库或进行其他操作。</p><h3 id="数据偏移实现"><a aria-hidden="true" tabindex="-1" href="/blog/全链路压测实战30讲/03.实践需求/16#数据偏移实现"><span class="icon icon-link"></span></a>数据偏移实现</h3><p>好了，接下来，我们再来看下数据偏移的实现方式。</p><p>数据偏移方式会让压测请求和正常请求都进入到生产队列。我们要在压测消息的发布端加上标记，消费端加上识别。</p><p>你可以通过下面这张图片更直观地理解数据偏移的工作原理。</p><p><img src="https://static001.geekbang.org/resource/image/8b/b1/8b37915e1d056fbb989916f978e025b1.jpg?wh=1920x575" alt="图片"/></p><p><strong>第一步，改造 RabbitConfig 配置类。</strong></p><p>在影子队列方案的基础上，我们还需要改造 RabbitConfig 配置类，创建一个名为 exchange.7d 的交换机、一个生产者、两个消费者和一个消息队列。队列需要通过路由键绑定到交换机，其中队列 7dQueue 的路由键为 produce。</p><p>因为消息的标记识别实际上就是对发布和消费做一个拦截处理，所以我们还要配置 1 个 Bean，在 Bean 的方法里面实现拦截的逻辑。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">package com.dunshan.directheader;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    import lombok.extern.slf4j.Slf4j;</span></div><div class="token-line"><span class="token plain">    import org.springframework.amqp.AmqpException;</span></div><div class="token-line"><span class="token plain">    import org.springframework.amqp.core.*;</span></div><div class="token-line"><span class="token plain">    import org.springframework.amqp.rabbit.config.SimpleRabbitListenerContainerFactory;</span></div><div class="token-line"><span class="token plain">    import org.springframework.amqp.rabbit.connection.CachingConnectionFactory;</span></div><div class="token-line"><span class="token plain">    import org.springframework.amqp.rabbit.connection.ConnectionFactory;</span></div><div class="token-line"><span class="token plain">    import org.springframework.amqp.rabbit.core.RabbitTemplate;</span></div><div class="token-line"><span class="token plain">    import org.springframework.boot.autoconfigure.amqp.SimpleRabbitListenerContainerFactoryConfigurer;</span></div><div class="token-line"><span class="token plain">    import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;</span></div><div class="token-line"><span class="token plain">    import org.springframework.context.annotation.Bean;</span></div><div class="token-line"><span class="token plain">    import org.springframework.context.annotation.Configuration;</span></div><div class="token-line"><span class="token plain">    import org.springframework.web.context.request.RequestContextHolder;</span></div><div class="token-line"><span class="token plain">    import org.springframework.web.context.request.ServletRequestAttributes;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    import javax.servlet.http.HttpServletRequest;</span></div><div class="token-line"><span class="token plain">    import java.util.Map;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    /**</span></div><div class="token-line"><span class="token plain">     * @author dunshan</span></div><div class="token-line"><span class="token plain">     */</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    @Configuration</span></div><div class="token-line"><span class="token plain">    @Slf4j</span></div><div class="token-line"><span class="token plain">    public class DirectRabbitHeaderConfig {</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        @Bean</span></div><div class="token-line"><span class="token plain">        public DirectExchange directheader() {</span></div><div class="token-line"><span class="token plain">            return new DirectExchange(&quot;exchange.7dHeader&quot;);</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        @Bean</span></div><div class="token-line"><span class="token plain">        public Queue directheaderQueue() {</span></div><div class="token-line"><span class="token plain">            return new Queue(&quot;7dHeaderQueue&quot;);</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        @Bean</span></div><div class="token-line"><span class="token plain">        public Binding directheaderBinding1a(DirectExchange directheader, Queue directheaderQueue) {</span></div><div class="token-line"><span class="token plain">            return BindingBuilder.bind(directheaderQueue).to(directheader).with(&quot;produce&quot;);</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        @Bean</span></div><div class="token-line"><span class="token plain">        public DirectHeaderReceiver headerreceiver() {</span></div><div class="token-line"><span class="token plain">            return new DirectHeaderReceiver();</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        @Bean</span></div><div class="token-line"><span class="token plain">        public DirectHeaderSender directHeaderSender() {</span></div><div class="token-line"><span class="token plain">            return new DirectHeaderSender();</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        @Bean(name = &quot;rabbitListenerContainerFactory&quot;)</span></div><div class="token-line"><span class="token plain">        @ConditionalOnProperty(prefix = &quot;spring.rabbitmq.listener&quot;, name = &quot;type&quot;, havingValue = &quot;simple&quot;, matchIfMissing = true)</span></div><div class="token-line"><span class="token plain">        public SimpleRabbitListenerContainerFactory simpleRabbitListenerContainerFactory(SimpleRabbitListenerContainerFactoryConfigurer configurer,</span></div><div class="token-line"><span class="token plain">                                                                                         ConnectionFactory connectionFactory) {</span></div><div class="token-line"><span class="token plain">            SimpleRabbitListenerContainerFactory factory = new SimpleRabbitListenerContainerFactory();</span></div><div class="token-line"><span class="token plain">            factory.setAfterReceivePostProcessors(new MessagePostProcessor() {</span></div><div class="token-line"><span class="token plain">                @Override</span></div><div class="token-line"><span class="token plain">                public Message postProcessMessage(Message message) throws AmqpException {</span></div><div class="token-line"><span class="token plain">                    Map header = message.getMessageProperties().getHeaders();</span></div><div class="token-line"><span class="token plain">                    //判断是否压测消息，是的话要动态切换影子库跟后续操作</span></div><div class="token-line"><span class="token plain">                    if (header.containsKey(&quot;test&quot;)){</span></div><div class="token-line"><span class="token plain">                        log.info(&quot;带压测标记！&quot;);</span></div><div class="token-line"><span class="token plain">                    }</span></div><div class="token-line"><span class="token plain">                    return message;</span></div><div class="token-line"><span class="token plain">                }</span></div><div class="token-line"><span class="token plain">            });</span></div><div class="token-line"><span class="token plain">            configurer.configure(factory, connectionFactory);</span></div><div class="token-line"><span class="token plain">            return factory;</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>每次接收消息都会调用拦截器对消息进行拦截处理，有压测消息标记的，就先存到数据上下文中，后续数据库会根据这个上下文切换影子库。</p><p><strong>第二步，改造 DirectSender 类。</strong></p><p>然后改造 DirectSender 类，发布消息时判断是否为压测标记，使用 MessageProperties 构建自定义 Header，以达到数据偏移的目的。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">package com.dunshan.directheader;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    import lombok.extern.slf4j.Slf4j;</span></div><div class="token-line"><span class="token plain">    import org.springframework.amqp.core.Message;</span></div><div class="token-line"><span class="token plain">    import org.springframework.amqp.core.MessageProperties;</span></div><div class="token-line"><span class="token plain">    import org.springframework.amqp.rabbit.core.RabbitTemplate;</span></div><div class="token-line"><span class="token plain">    import org.springframework.beans.factory.annotation.Autowired;</span></div><div class="token-line"><span class="token plain">    import org.springframework.web.context.request.RequestContextHolder;</span></div><div class="token-line"><span class="token plain">    import org.springframework.web.context.request.ServletRequestAttributes;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    import javax.servlet.http.HttpServletRequest;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    /**</span></div><div class="token-line"><span class="token plain">     *</span></div><div class="token-line"><span class="token plain">     * @author dunshan</span></div><div class="token-line"><span class="token plain">     * @date 2021/10/1</span></div><div class="token-line"><span class="token plain">     */</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    @Slf4j</span></div><div class="token-line"><span class="token plain">    public class DirectHeaderSender {</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    	@Autowired</span></div><div class="token-line"><span class="token plain">    	private RabbitTemplate template;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    	private static final String exchangeName = &quot;exchange.7dHeader&quot;;</span></div><div class="token-line"><span class="token plain">    	private final String key = &quot;produce&quot;;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    	public void send(int index) {</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    		// 获取标记</span></div><div class="token-line"><span class="token plain">    		String header = AppContext.getContext().getFlag();</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    		String messageStr = &quot;Hello to &quot;;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    		MessageProperties messageProperties = new MessageProperties();</span></div><div class="token-line"><span class="token plain">    		// 判断标记</span></div><div class="token-line"><span class="token plain">    		if (header != null &amp;&amp; &quot;7DGroup&quot;.equals(header)) {</span></div><div class="token-line"><span class="token plain">    			messageProperties.setHeader(&quot;test&quot;,true);</span></div><div class="token-line"><span class="token plain">    			Message message = new Message(messageStr.getBytes(), messageProperties);</span></div><div class="token-line"><span class="token plain">    			template.convertAndSend(exchangeName, key, message);</span></div><div class="token-line"><span class="token plain">    			log.info(&quot; [x] Sent &#x27;{}&#x27;&quot;, message);</span></div><div class="token-line"><span class="token plain">    		} else {</span></div><div class="token-line"><span class="token plain">    			template.convertAndSend(exchangeName, key, messageStr);</span></div><div class="token-line"><span class="token plain">    			log.info(&quot; [x] Sent &#x27;{}&#x27;&quot;, messageStr);</span></div><div class="token-line"><span class="token plain">    		}</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    	}</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p><strong>第三步，在 Controller 中添加测试接口。</strong></p><p>在 Controller 中添加测试接口，调用该接口，发布消息。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">package com.dunshan.controller;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    import cn.hutool.core.thread.ThreadUtil;</span></div><div class="token-line"><span class="token plain">    import com.dunshan.common.api.CommonResult;</span></div><div class="token-line"><span class="token plain">    import com.dunshan.direct.DirectSender;</span></div><div class="token-line"><span class="token plain">    import io.swagger.annotations.Api;</span></div><div class="token-line"><span class="token plain">    import io.swagger.annotations.ApiOperation;</span></div><div class="token-line"><span class="token plain">    import org.springframework.beans.factory.annotation.Autowired;</span></div><div class="token-line"><span class="token plain">    import org.springframework.stereotype.Controller;</span></div><div class="token-line"><span class="token plain">    import org.springframework.web.bind.annotation.RequestMapping;</span></div><div class="token-line"><span class="token plain">    import org.springframework.web.bind.annotation.RequestMethod;</span></div><div class="token-line"><span class="token plain">    import org.springframework.web.bind.annotation.ResponseBody;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    /**</span></div><div class="token-line"><span class="token plain">     *</span></div><div class="token-line"><span class="token plain">     * @author dunshan</span></div><div class="token-line"><span class="token plain">     * @date 2021/10/1</span></div><div class="token-line"><span class="token plain">     */</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    @Api(tags = &quot;RabbitController&quot;, description = &quot;RabbitMQ 隔离测试&quot;)</span></div><div class="token-line"><span class="token plain">    @Controller</span></div><div class="token-line"><span class="token plain">    @RequestMapping(&quot;/rabbit&quot;)</span></div><div class="token-line"><span class="token plain">    public class RabbitController {</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        @Autowired</span></div><div class="token-line"><span class="token plain">        private DirectSender directSender;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        @ApiOperation(&quot;数据偏移模式&quot;)</span></div><div class="token-line"><span class="token plain">        @RequestMapping(value = &quot;/header&quot;, method = RequestMethod.GET)</span></div><div class="token-line"><span class="token plain">        @ResponseBody</span></div><div class="token-line"><span class="token plain">        public CommonResult headerTest() throws InterruptedException {</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">            for(int i=0;i&lt;10;i++){</span></div><div class="token-line"><span class="token plain">                directHeaderSender.send(i);</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">                ThreadUtil.sleep(1000);</span></div><div class="token-line"><span class="token plain">            }</span></div><div class="token-line"><span class="token plain">            return CommonResult.success(null);</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p><strong>第四步，接口测试验证。</strong></p><p>运行后，可以通过 Postman 做接口测试，往队列中发送包含不同路由键的消息。</p><ul><li>发送正常请求（不带压测标记）<br/><img src="https://static001.geekbang.org/resource/image/c4/20/c46dac88e60476dfdcd0404f4a657520.png?wh=1920x1227" alt="图片"/></li></ul><p>服务端的控制台日志如下：</p><p><img src="https://static001.geekbang.org/resource/image/53/f3/5330a85903fd3807542cbcde3b7228f3.png?wh=1516x600" alt="图片"/></p><ul><li>发送压测请求（带压测标记）<br/><img src="https://static001.geekbang.org/resource/image/66/91/66549483007e9cee6bfc95a53byyba91.png?wh=1920x1363" alt="图片"/></li></ul><p>服务端的控制台日志如下：</p><p><img src="https://static001.geekbang.org/resource/image/5f/95/5f12f1f4f589f53127f43b7f69fd8a95.png?wh=1535x635" alt="图片"/></p><p>我们可以看到，instance 1 第一次获取到了正常消息，第二次获取到了压测标记的消息，这说明测试成功了。</p><p>刚才我们介绍了影子队列和数据偏移两种数据隔离方案并分别进行了 demo 预演。预演成功，接下来，我们就要将 demo 移植到真实系统进行改造了。</p><h2 id="真实系统改造"><a aria-hidden="true" tabindex="-1" href="/blog/全链路压测实战30讲/03.实践需求/16#真实系统改造"><span class="icon icon-link"></span></a>真实系统改造</h2><p>在进行改造之前，先来看下我们项目的实际情况。</p><p>我们项目的消息队列主要是用于解决用户下单以后，订单超时想要取消订单的问题的。</p><p><img src="https://static001.geekbang.org/resource/image/7c/a8/7cc80114df44be83b9c2743e80b0a3a8.jpg?wh=1920x742" alt="图片"/></p><p>项目主要的业务流程是：</p><ul><li>用户进行下单操作（会有锁定商品库存、使用优惠券、积分一系列的操作）；</li><li>生成订单，获取订单的 id；</li><li>获取到设置的订单超时时间（假设设置的为 60 分钟不支付取消订单）；</li><li>按订单超时时间发送一个延迟消息给 RabbitMQ，让它在订单超时后触发取消订单的操作；</li><li>如果用户没有支付，进行取消订单操作（释放锁定商品库存、返还优惠券、返回积分一系列操作）。</li></ul><p>RabbitMQ 实现延迟消息的方式有两种，一种是用死信队列实现，另一种是用延迟插件实现，我们这个项目使用的是死信队列的方式。</p><p>查看添加消息队列的枚举配置类 QueueEnum。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">import lombok.Getter;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    /**</span></div><div class="token-line"><span class="token plain">     * 消息队列枚举配置</span></div><div class="token-line"><span class="token plain">     * Created by dunshan on 2018/9/14.</span></div><div class="token-line"><span class="token plain">     */</span></div><div class="token-line"><span class="token plain">    @Getter</span></div><div class="token-line"><span class="token plain">    public enum QueueEnum {</span></div><div class="token-line"><span class="token plain">        /**</span></div><div class="token-line"><span class="token plain">         * 消息通知队列</span></div><div class="token-line"><span class="token plain">         */</span></div><div class="token-line"><span class="token plain">        QUEUE_ORDER_CANCEL(&quot;mall.order.direct&quot;, &quot;mall.order.cancel&quot;, &quot;mall.order.cancel&quot;),</span></div><div class="token-line"><span class="token plain">        </span></div><div class="token-line"><span class="token plain">        /**</span></div><div class="token-line"><span class="token plain">         * 消息通知 ttl 队列</span></div><div class="token-line"><span class="token plain">         */</span></div><div class="token-line"><span class="token plain">        QUEUE_TTL_ORDER_CANCEL(&quot;mall.order.direct.ttl&quot;, &quot;mall.order.cancel.ttl&quot;, &quot;mall.order.cancel.ttl&quot;);</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        /**</span></div><div class="token-line"><span class="token plain">         * 交换名称</span></div><div class="token-line"><span class="token plain">         */</span></div><div class="token-line"><span class="token plain">        private String exchange;</span></div><div class="token-line"><span class="token plain">       </span></div><div class="token-line"><span class="token plain">         /**</span></div><div class="token-line"><span class="token plain">         * 队列名称</span></div><div class="token-line"><span class="token plain">         */</span></div><div class="token-line"><span class="token plain">        private String name;</span></div><div class="token-line"><span class="token plain">        </span></div><div class="token-line"><span class="token plain">        /**</span></div><div class="token-line"><span class="token plain">         * 路由键</span></div><div class="token-line"><span class="token plain">         */</span></div><div class="token-line"><span class="token plain">        private String routeKey;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        QueueEnum(String exchange, String name, String routeKey) {</span></div><div class="token-line"><span class="token plain">            this.exchange = exchange;</span></div><div class="token-line"><span class="token plain">            this.name = name;</span></div><div class="token-line"><span class="token plain">            this.routeKey = routeKey;</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>这里，我们定义了两个消息队列，即 mall.order.cancel 和 mall.order.cancel.ttl。</p><ul><li>**mall.order.direct（取消订单消息队列所绑定的交换机）：**绑定的队列为 mall.order.cancel，一旦有消息以 mall.order.cancel 为路由键发过来，就会发送到这个队列。</li><li>**mall.order.direct.ttl（订单延迟消息队列所绑定的交换机）：**绑定的队列为 mall.order.cancel.ttl，一旦有消息以 mall.order.cancel.ttl 为路由键发送过来，就会转发到此队列，并在此队列保存一定时间，等到超时后会自动将消息发送到 mall.order.cancel（取消订单消息消费队列）。</li></ul><p>启动服务后，我们去 RabbitMQ 控制台确认一下。</p><p><img src="https://static001.geekbang.org/resource/image/ed/a4/ed80a1f0867b62ca2923d21a605488a4.png?wh=1920x600" alt="图片"/></p><p>这里我们选择的改造方案是使用<strong>数据偏移</strong>，因为相对影子队列的方式来说，数据偏移要改造的代码更少。</p><p><strong>第一步，移植获取标记类。</strong></p><p>快速移植 demo 中的全局 Filter 过滤器和数据上下文类：</p><ul><li>AppContext；</li><li>ContextFilter。</li></ul><p>这个操作前面说过很多次了，这里就不再多赘述了。</p><p>​<strong>第二步，改造 CancelOrderSender 类。</strong></p><p>改造 CancelOrderSender 类，发送时判断是否为压测标记，使用 MessageProperties 构建自定义 Header。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">package com.dunshan.mall.order.component;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    import com.dunshan.mall.order.domain.QueueEnum;</span></div><div class="token-line"><span class="token plain">    import com.dunshan.mall.order.config.AppContext;</span></div><div class="token-line"><span class="token plain">    import lombok.extern.slf4j.Slf4j;</span></div><div class="token-line"><span class="token plain">    import org.slf4j.Logger;</span></div><div class="token-line"><span class="token plain">    import org.slf4j.LoggerFactory;</span></div><div class="token-line"><span class="token plain">    import org.springframework.amqp.AmqpException;</span></div><div class="token-line"><span class="token plain">    import org.springframework.amqp.core.AmqpTemplate;</span></div><div class="token-line"><span class="token plain">    import org.springframework.amqp.core.Message;</span></div><div class="token-line"><span class="token plain">    import org.springframework.amqp.core.MessagePostProcessor;</span></div><div class="token-line"><span class="token plain">    import org.springframework.beans.factory.annotation.Autowired;</span></div><div class="token-line"><span class="token plain">    import org.springframework.stereotype.Component;</span></div><div class="token-line"><span class="token plain">    import org.springframework.web.context.request.RequestContextHolder;</span></div><div class="token-line"><span class="token plain">    import org.springframework.web.context.request.ServletRequestAttributes;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    import javax.servlet.http.HttpServletRequest;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    /**</span></div><div class="token-line"><span class="token plain">     * 取消订单消息的发出者</span></div><div class="token-line"><span class="token plain">     * Created by dunshan on 2018/9/14.</span></div><div class="token-line"><span class="token plain">     */</span></div><div class="token-line"><span class="token plain">    @Component</span></div><div class="token-line"><span class="token plain">    @Slf4j</span></div><div class="token-line"><span class="token plain">    public class CancelOrderSender {</span></div><div class="token-line"><span class="token plain">        private static Logger LOGGER =LoggerFactory.getLogger(CancelOrderSender.class);</span></div><div class="token-line"><span class="token plain">        </span></div><div class="token-line"><span class="token plain">        @Autowired</span></div><div class="token-line"><span class="token plain">        private AmqpTemplate amqpTemplate;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        public void sendMessage(Long orderId,final long delayTimes){</span></div><div class="token-line"><span class="token plain">        </span></div><div class="token-line"><span class="token plain">            // 获取标记</span></div><div class="token-line"><span class="token plain">            String header = AppContext.getContext().getFlag();</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">            LOGGER.info(&quot;RabbitMQ 获取标记 header:{}&quot;,header);</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">            //给延迟队列发送消息</span></div><div class="token-line"><span class="token plain">            amqpTemplate.convertAndSend(QueueEnum.QUEUE_TTL_ORDER_CANCEL.getExchange(), QueueEnum.QUEUE_TTL_ORDER_CANCEL.getRouteKey(), orderId, new MessagePostProcessor() {</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">                @Override</span></div><div class="token-line"><span class="token plain">                public Message postProcessMessage(Message message) throws AmqpException {</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">                    if (&quot;7DGroup&quot;.equals(header)) {</span></div><div class="token-line"><span class="token plain">                        message.getMessageProperties().setHeader(&quot;test&quot;,true);</span></div><div class="token-line"><span class="token plain">                    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">                    //给消息设置延迟毫秒值</span></div><div class="token-line"><span class="token plain">                    message.getMessageProperties().setExpiration(String.valueOf(delayTimes));</span></div><div class="token-line"><span class="token plain">                    return message;</span></div><div class="token-line"><span class="token plain">                }</span></div><div class="token-line"><span class="token plain">            });</span></div><div class="token-line"><span class="token plain">            LOGGER.info(&quot;send orderId:{}&quot;,orderId);</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>​<strong>第三步，改造 RabbitMqConfig 类。</strong></p><p>然后，改造 RabbitMqConfig 配置类。配置 1 个 Bean，在 Bean 的方法里面实现拦截的逻辑。</p><p>每次接收消息都会调用拦截器对消息进行拦截处理，有压测消息标记的，就先存到数据上下文中，后续数据库会根据这个上下文切换影子库。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">package com.dunshan.mall.order.config;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    import com.dunshan.mall.order.config.AppContext;</span></div><div class="token-line"><span class="token plain">    import com.dunshan.mall.order.domain.QueueEnum;</span></div><div class="token-line"><span class="token plain">    import lombok.extern.slf4j.Slf4j;</span></div><div class="token-line"><span class="token plain">    import org.springframework.amqp.AmqpException;</span></div><div class="token-line"><span class="token plain">    import org.springframework.amqp.core.*;</span></div><div class="token-line"><span class="token plain">    import org.springframework.amqp.rabbit.config.SimpleRabbitListenerContainerFactory;</span></div><div class="token-line"><span class="token plain">    import org.springframework.amqp.rabbit.connection.ConnectionFactory;</span></div><div class="token-line"><span class="token plain">    import org.springframework.boot.autoconfigure.amqp.SimpleRabbitListenerContainerFactoryConfigurer;</span></div><div class="token-line"><span class="token plain">    import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;</span></div><div class="token-line"><span class="token plain">    import org.springframework.context.annotation.Bean;</span></div><div class="token-line"><span class="token plain">    import org.springframework.context.annotation.Configuration;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    import java.util.Map;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    /**</span></div><div class="token-line"><span class="token plain">     * 消息队列配置</span></div><div class="token-line"><span class="token plain">     * Created by dunshan on 2018/9/14.</span></div><div class="token-line"><span class="token plain">     */</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    @Configuration</span></div><div class="token-line"><span class="token plain">    @Slf4j</span></div><div class="token-line"><span class="token plain">    public class RabbitMqConfig {</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        /**</span></div><div class="token-line"><span class="token plain">         * 订单消息实际消费队列所绑定的交换机</span></div><div class="token-line"><span class="token plain">         */</span></div><div class="token-line"><span class="token plain">        @Bean</span></div><div class="token-line"><span class="token plain">        DirectExchange orderDirect() {</span></div><div class="token-line"><span class="token plain">            return (DirectExchange) ExchangeBuilder</span></div><div class="token-line"><span class="token plain">                    .directExchange(QueueEnum.QUEUE_ORDER_CANCEL.getExchange())</span></div><div class="token-line"><span class="token plain">                    .durable(true)</span></div><div class="token-line"><span class="token plain">                    .build();</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        /**</span></div><div class="token-line"><span class="token plain">         * 订单延迟队列队列所绑定的交换机</span></div><div class="token-line"><span class="token plain">         */</span></div><div class="token-line"><span class="token plain">        @Bean</span></div><div class="token-line"><span class="token plain">        DirectExchange orderTtlDirect() {</span></div><div class="token-line"><span class="token plain">            return (DirectExchange) ExchangeBuilder</span></div><div class="token-line"><span class="token plain">                    .directExchange(QueueEnum.QUEUE_TTL_ORDER_CANCEL.getExchange())</span></div><div class="token-line"><span class="token plain">                    .build();</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        /**</span></div><div class="token-line"><span class="token plain">         * 订单实际消费队列</span></div><div class="token-line"><span class="token plain">         */</span></div><div class="token-line"><span class="token plain">        @Bean</span></div><div class="token-line"><span class="token plain">        public Queue orderQueue() {</span></div><div class="token-line"><span class="token plain">            return new Queue(QueueEnum.QUEUE_ORDER_CANCEL.getName());</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        /**</span></div><div class="token-line"><span class="token plain">         * 订单延迟队列（死信队列）</span></div><div class="token-line"><span class="token plain">         */</span></div><div class="token-line"><span class="token plain">        @Bean</span></div><div class="token-line"><span class="token plain">        public Queue orderTtlQueue() {</span></div><div class="token-line"><span class="token plain">            return QueueBuilder</span></div><div class="token-line"><span class="token plain">                    .durable(QueueEnum.QUEUE_TTL_ORDER_CANCEL.getName())</span></div><div class="token-line"><span class="token plain">                    .withArgument(&quot;x-dead-letter-exchange&quot;, QueueEnum.QUEUE_ORDER_CANCEL.getExchange())//到期后转发的交换机</span></div><div class="token-line"><span class="token plain">                    .withArgument(&quot;x-dead-letter-routing-key&quot;, QueueEnum.QUEUE_ORDER_CANCEL.getRouteKey())//到期后转发的路由键</span></div><div class="token-line"><span class="token plain">                    .build();</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        /**</span></div><div class="token-line"><span class="token plain">         * 将订单队列绑定到交换机</span></div><div class="token-line"><span class="token plain">         */</span></div><div class="token-line"><span class="token plain">        @Bean</span></div><div class="token-line"><span class="token plain">        Binding orderBinding(DirectExchange orderDirect,Queue orderQueue){</span></div><div class="token-line"><span class="token plain">            return BindingBuilder</span></div><div class="token-line"><span class="token plain">                    .bind(orderQueue)</span></div><div class="token-line"><span class="token plain">                    .to(orderDirect)</span></div><div class="token-line"><span class="token plain">                    .with(QueueEnum.QUEUE_ORDER_CANCEL.getRouteKey());</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        /**</span></div><div class="token-line"><span class="token plain">         * 将订单延迟队列绑定到交换机</span></div><div class="token-line"><span class="token plain">         */</span></div><div class="token-line"><span class="token plain">        @Bean</span></div><div class="token-line"><span class="token plain">        Binding orderTtlBinding(DirectExchange orderTtlDirect,Queue orderTtlQueue){</span></div><div class="token-line"><span class="token plain">            return BindingBuilder</span></div><div class="token-line"><span class="token plain">                    .bind(orderTtlQueue)</span></div><div class="token-line"><span class="token plain">                    .to(orderTtlDirect)</span></div><div class="token-line"><span class="token plain">                    .with(QueueEnum.QUEUE_TTL_ORDER_CANCEL.getRouteKey());</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        @Bean(name = &quot;rabbitListenerContainerFactory&quot;)</span></div><div class="token-line"><span class="token plain">        @ConditionalOnProperty(prefix = &quot;spring.rabbitmq.listener&quot;, name = &quot;type&quot;, havingValue = &quot;simple&quot;, matchIfMissing = true)</span></div><div class="token-line"><span class="token plain">        public SimpleRabbitListenerContainerFactory simpleRabbitListenerContainerFactory(SimpleRabbitListenerContainerFactoryConfigurer configurer,</span></div><div class="token-line"><span class="token plain">                                                                                         ConnectionFactory connectionFactory) {</span></div><div class="token-line"><span class="token plain">            SimpleRabbitListenerContainerFactory factory = new SimpleRabbitListenerContainerFactory();</span></div><div class="token-line"><span class="token plain">            //消息接收之前加拦截处理，每次接收消息都会调用，是有压测消息标记的，先存到副本变量，后续的操作数据库根据这个变量进行切换影子库</span></div><div class="token-line"><span class="token plain">            factory.setAfterReceivePostProcessors(new MessagePostProcessor() {</span></div><div class="token-line"><span class="token plain">                @Override</span></div><div class="token-line"><span class="token plain">                public Message postProcessMessage(Message message) throws AmqpException {</span></div><div class="token-line"><span class="token plain">                    Map header = message.getMessageProperties().getHeaders();</span></div><div class="token-line"><span class="token plain">                    //判断是压测的消息，动态切换影子库跟后续操作</span></div><div class="token-line"><span class="token plain">                    if (header.containsKey(&quot;test&quot;)){</span></div><div class="token-line"><span class="token plain">                        AppContext.getContext().setFlag(&quot;7DGroup&quot;);</span></div><div class="token-line"><span class="token plain">                        log.info(&quot;RabbitMQ 收到压测标记！&quot;);</span></div><div class="token-line"><span class="token plain">                    }</span></div><div class="token-line"><span class="token plain">                    return message;</span></div><div class="token-line"><span class="token plain">                }</span></div><div class="token-line"><span class="token plain">            });</span></div><div class="token-line"><span class="token plain">            configurer.configure(factory, connectionFactory);</span></div><div class="token-line"><span class="token plain">            return factory;</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>这样我们的改造就完成了，接着我们来测试验证下。</p><p>​<strong>第四步，接口测试验证。</strong></p><p>使用 curl 命令调用下单接口，这里带上了 Header 压测标记。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">~  curl -X POST -H  &quot;Accept:*/*&quot; -H  &quot;Authorization:eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyX25hbWUiOiJsaXNpIiwic2NvcGUiOlsiYWxsIl0sImlkIjo1LCJleHAiOjE2MzMzNjA1ODYsImF1dGhvcml0aWVzIjpbIuWJjeWPsOS8muWRmCJdLCJqdGkiOiJiZGU3MWE4Mi0zZmIzLTRkOWMtODBhZC1lZDVkNzQyYjk3YjUiLCJjbGllbnRfaWQiOiJwb3J0YWwtYXBwIn0.QmQ4nH6kGkj-yLRanUGno8ET8Vh10Sku1YUGBmZdlosZwPFAYpJNjfejBoP7OLBryXg6ilgYs6fOuydJXS28PAozNb086lxWlJtDgSIvqNN0vPtr2u5Hw-DUVww4xDX2ER_ZkHHmgj7B2fVHpD0wRdjxg49lVAcA_QoNOoN1R70&quot; -H  &quot;Request-Origion:Knife4j&quot; -H  &quot;Content-Type:application/json&quot; -H &quot;dunshan:7DGroup&quot; -d &quot;{\&quot;cartIds\&quot;:[12677173],\&quot;couponId\&quot;:null,\&quot;memberReceiveAddressId\&quot;:2503350,\&quot;payType\&quot;:0,\&quot;useIntegration\&quot;:null}&quot; &quot;http://127.0.0.1:8201/api/order/order/generateOrder&quot;</span></div><div class="token-line"><span class="token plain">    {&quot;code&quot;:200,&quot;message&quot;:&quot;下单成功&quot;,&quot;data&quot;:{&quot;orderItemList&quot;:[{&quot;orderId&quot;:31813547,&quot;orderSn&quot;:&quot;202110050100000004&quot;,&quot;productId&quot;:16,&quot;productPic&quot;:&quot;https://perfo7d.oss-cn-beijing.aliyuncs.com/mall/images/20200923/1522738681.jpg&quot;,&quot;productName&quot;:&quot;毛衫测试&quot;,&quot;productBrand&quot;:&quot;小米&quot;,&quot;productSn&quot;:&quot;NO.1098&quot;,&quot;productPrice&quot;:99.00,&quot;productQuantity&quot;:2,&quot;productSkuId&quot;:16,&quot;productSkuCode&quot;:&quot;202008270027016&quot;,&quot;productCategoryId&quot;:19,&quot;promotionName&quot;:&quot;无优惠&quot;,&quot;promotionAmount&quot;:0,&quot;giftIntegration&quot;:99,&quot;giftGrowth&quot;:99,&quot;productAttr&quot;:&quot;[{\&quot;key\&quot;:\&quot;颜色\&quot;,\&quot;value\&quot;:\&quot;银色\&quot;},{\&quot;key\&quot;:\&quot;容量\&quot;,\&quot;value\&quot;:\&quot;32G\&quot;}]&quot;}],&quot;order&quot;:{&quot;id&quot;:31813547,&quot;memberId&quot;:5,&quot;orderSn&quot;:&quot;202110050100000004&quot;,&quot;createTime&quot;:&quot;2021-10-05T09:30:30.314+00:00&quot;,&quot;memberUsername&quot;:&quot;lisi&quot;,&quot;totalAmount&quot;:198.00,&quot;payAmount&quot;:198.00,&quot;freightAmount&quot;:0,&quot;promotionAmount&quot;:0,&quot;integrationAmount&quot;:0,&quot;couponAmount&quot;:0,&quot;discountAmount&quot;:0,&quot;payType&quot;:0,&quot;sourceType&quot;:1,&quot;status&quot;:0,&quot;orderType&quot;:0,&quot;autoConfirmDay&quot;:15,&quot;integration&quot;:198,&quot;growth&quot;:198,&quot;promotionInfo&quot;:&quot;无优惠&quot;,&quot;receiverName&quot;:&quot;test&quot;,&quot;receiverPhone&quot;:&quot;186xxxx8888&quot;,&quot;receiverPostCode&quot;:&quot;123&quot;,&quot;receiverProvince&quot;:&quot;北京&quot;,&quot;receiverCity&quot;:&quot;北京&quot;,&quot;receiverRegion&quot;:&quot;海淀区&quot;,&quot;receiverDetailAddress&quot;:&quot;北京&quot;,&quot;confirmStatus&quot;:0,&quot;deleteStatus&quot;:0}}}%</span></div></pre></div><p>注意：为了方便我们测试验证，这里已经将延迟消息时间调小了。</p><p>查看下 RabbitMQ 控制台。</p><p><img src="https://static001.geekbang.org/resource/image/41/69/417ccb81358184df849201a932433c69.png?wh=1920x652" alt="图片"/></p><p>等待一会，查看下 order 服务的控制台日志。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">2021-10-05 17:30:30.705  INFO [mall-order,04190964bd8bce42,249e170cadf982e8,true] 17792 --- [nio-8084-exec-4] c.d.m.order.component.CancelOrderSender  : RabbitMQ 获取标记 header:7DGroup</span></div><div class="token-line"><span class="token plain">    2021-10-05 17:30:30.706  INFO [mall-order,04190964bd8bce42,249e170cadf982e8,true] 17792 --- [nio-8084-exec-4] c.d.m.order.component.CancelOrderSender  : send orderId:31813547</span></div><div class="token-line"><span class="token plain">    2021-10-05 17:30:30.706  INFO [mall-order,04190964bd8bce42,249e170cadf982e8,true] 17792 --- [nio-8084-exec-4] c.d.m.o.s.impl.PortalOrderServiceImpl    : 结果：{&quot;orderItemList&quot;:[{&quot;productSkuCode&quot;:&quot;202008270027016&quot;,&quot;productSkuId&quot;:16,&quot;productId&quot;:16,&quot;productSn&quot;:&quot;NO.1098&quot;,&quot;orderId&quot;:31813547,&quot;orderSn&quot;:&quot;202110050100000004&quot;,&quot;productBrand&quot;:&quot;小米&quot;,&quot;productPic&quot;:&quot;https://perfo7d.oss-cn-beijing.aliyuncs.com/mall/images/20200923/1522738681.jpg&quot;,&quot;giftIntegration&quot;:99,&quot;productName&quot;:&quot;毛衫测试&quot;,&quot;productAttr&quot;:&quot;[{\&quot;key\&quot;:\&quot;颜色\&quot;,\&quot;value\&quot;:\&quot;银色\&quot;},{\&quot;key\&quot;:\&quot;容量\&quot;,\&quot;value\&quot;:\&quot;32G\&quot;}]&quot;,&quot;productQuantity&quot;:2,&quot;promotionName&quot;:&quot;无优惠&quot;,&quot;productCategoryId&quot;:19,&quot;giftGrowth&quot;:99,&quot;promotionAmount&quot;:0,&quot;productPrice&quot;:99.00}],&quot;order&quot;:{&quot;orderType&quot;:0,&quot;integrationAmount&quot;:0,&quot;orderSn&quot;:&quot;202110050100000004&quot;,&quot;discountAmount&quot;:0,&quot;receiverProvince&quot;:&quot;北京&quot;,&quot;receiverCity&quot;:&quot;北京&quot;,&quot;autoConfirmDay&quot;:15,&quot;couponAmount&quot;:0,&quot;payAmount&quot;:198.00,&quot;payType&quot;:0,&quot;receiverPhone&quot;:&quot;186xxxx8888&quot;,&quot;receiverPostCode&quot;:&quot;123&quot;,&quot;receiverRegion&quot;:&quot;海淀区&quot;,&quot;deleteStatus&quot;:0,&quot;memberUsername&quot;:&quot;lisi&quot;,&quot;confirmStatus&quot;:0,&quot;id&quot;:31813547,&quot;memberId&quot;:5,&quot;freightAmount&quot;:0,&quot;receiverName&quot;:&quot;test&quot;,&quot;promotionInfo&quot;:&quot;无优惠&quot;,&quot;receiverDetailAddress&quot;:&quot;北京&quot;,&quot;totalAmount&quot;:198.00,&quot;createTime&quot;:1633426230314,&quot;sourceType&quot;:1,&quot;integration&quot;:198,&quot;growth&quot;:198,&quot;promotionAmount&quot;:0,&quot;status&quot;:0}}</span></div><div class="token-line"><span class="token plain">    2021-10-05 17:34:30.769  INFO [mall-order,,,] 17792 --- [ntContainer#0-1] c.dunshan.mall.order.context.AppContext  : 打印压测标记：7DGroup</span></div><div class="token-line"><span class="token plain">    2021-10-05 17:34:30.772  INFO [mall-order,,,] 17792 --- [ntContainer#0-1] c.d.mall.order.config.RabbitMqConfig     : RabbitMQ 收到压测标记！</span></div><div class="token-line"><span class="token plain">    2021-10-05 17:34:30.902  INFO [mall-order,04190964bd8bce42,c0e11235f08391aa,true] 17792 --- [ntContainer#0-1] c.d.m.o.s.impl.PortalOrderServiceImpl    : 收到取消订单！31813547</span></div><div class="token-line"><span class="token plain">    2021-10-05 17:34:30.991  INFO [mall-order,04190964bd8bce42,c0e11235f08391aa,true] 17792 --- [ntContainer#0-1] c.d.m.o.component.CancelOrderReceiver    : process orderId:31813547</span></div></pre></div><p>可以看到，压测标记已经被透传下去了。<br/>再次确认下 RabbitMQ 控制台。</p><p><img src="https://static001.geekbang.org/resource/image/8d/72/8d90ddd05c96369dffcba44133cd7572.png?wh=1920x745" alt="图片"/></p><p>截图显示，延迟的消息已经被成功消费。</p><p>接下来，我们测试一下正常请求，使用 web API 文档调用下单接口。</p><p><img src="https://static001.geekbang.org/resource/image/f1/83/f1d089aeae99ac532455665570025a83.png?wh=1920x1106" alt="图片"/></p><p>等待一会，查看下 Order 服务的控制台日志。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">18:15:58.108  INFO [mall-order,682d3874c34b8dca,f8f6916562572089,true] 18776 --- [nio-8084-exec-9] c.d.m.order.component.CancelOrderSender  : RabbitMQ 获取标记 header:null</span></div><div class="token-line"><span class="token plain">    2021-10-05 18:15:58.114  INFO [mall-order,682d3874c34b8dca,f8f6916562572089,true] 18776 --- [nio-8084-exec-9] c.d.m.order.component.CancelOrderSender  : send orderId:31813549</span></div><div class="token-line"><span class="token plain">    2021-10-05 18:15:58.117  INFO [mall-order,682d3874c34b8dca,f8f6916562572089,true] 18776 --- [nio-8084-exec-9] c.d.m.o.s.impl.PortalOrderServiceImpl    : 结果：{&quot;orderItemList&quot;:[{&quot;productSkuCode&quot;:&quot;202008270027016&quot;,&quot;productSkuId&quot;:16,&quot;productId&quot;:16,&quot;productSn&quot;:&quot;NO.1098&quot;,&quot;orderId&quot;:31813549,&quot;orderSn&quot;:&quot;202110050100000006&quot;,&quot;productBrand&quot;:&quot;小米&quot;,&quot;productPic&quot;:&quot;https://perfo7d.oss-cn-beijing.aliyuncs.com/mall/images/20200923/1522738681.jpg&quot;,&quot;giftIntegration&quot;:99,&quot;productName&quot;:&quot;毛衫测试&quot;,&quot;productAttr&quot;:&quot;[{\&quot;key\&quot;:\&quot;颜色\&quot;,\&quot;value\&quot;:\&quot;银色\&quot;},{\&quot;key\&quot;:\&quot;容量\&quot;,\&quot;value\&quot;:\&quot;32G\&quot;}]&quot;,&quot;productQuantity&quot;:2,&quot;promotionName&quot;:&quot;无优惠&quot;,&quot;productCategoryId&quot;:19,&quot;giftGrowth&quot;:99,&quot;promotionAmount&quot;:0,&quot;productPrice&quot;:99.00}],&quot;order&quot;:{&quot;orderType&quot;:0,&quot;integrationAmount&quot;:0,&quot;orderSn&quot;:&quot;202110050100000006&quot;,&quot;discountAmount&quot;:0,&quot;receiverProvince&quot;:&quot;北京&quot;,&quot;receiverCity&quot;:&quot;北京&quot;,&quot;autoConfirmDay&quot;:15,&quot;couponAmount&quot;:0,&quot;payAmount&quot;:198.00,&quot;payType&quot;:0,&quot;receiverPhone&quot;:&quot;186xxxx8888&quot;,&quot;receiverPostCode&quot;:&quot;123&quot;,&quot;receiverRegion&quot;:&quot;海淀区&quot;,&quot;deleteStatus&quot;:0,&quot;memberUsername&quot;:&quot;lisi&quot;,&quot;confirmStatus&quot;:0,&quot;id&quot;:31813549,&quot;memberId&quot;:5,&quot;freightAmount&quot;:0,&quot;receiverName&quot;:&quot;test&quot;,&quot;promotionInfo&quot;:&quot;无优惠&quot;,&quot;receiverDetailAddress&quot;:&quot;北京&quot;,&quot;totalAmount&quot;:198.00,&quot;createTime&quot;:1633428957701,&quot;sourceType&quot;:1,&quot;integration&quot;:198,&quot;growth&quot;:198,&quot;promotionAmount&quot;:0,&quot;status&quot;:0}}</span></div><div class="token-line"><span class="token plain">    2021-10-05 18:19:58.562  INFO [mall-order,682d3874c34b8dca,f1942f9153ec7729,true] 18776 --- [ntContainer#0-1] c.d.m.o.s.impl.PortalOrderServiceImpl    : 收到取消订单！31813549</span></div><div class="token-line"><span class="token plain">    2021-10-05 18:19:58.650  INFO [mall-order,682d3874c34b8dca,f1942f9153ec7729,true] 18776 --- [ntContainer#0-1] c.d.m.o.component.CancelOrderReceiver    : process orderId:31813549</span></div></pre></div><p>可以看到，消息是正常处理的，这说明我们的消息隔离改造成功了。</p><h2 id="总结"><a aria-hidden="true" tabindex="-1" href="/blog/全链路压测实战30讲/03.实践需求/16#总结"><span class="icon icon-link"></span></a>总结</h2><p>好了，这节课就讲到这里。刚才，我们完整演示了 RabbitMQ 消息隔离的技术预演和真实系统改造过程。这节课有几个要点，我希望你能够记住：</p><ol><li>RabbitMQ 消息隔离主要解决的是异步任务之间标记透传的需求；</li><li>引入数据上下文对象能够兼容不同的应用协议，同时能够支持跨线程间及MQ异步任务的透传，最重要的是能支持随时存取；</li><li>相比数据库隔离，消息隔离的方案较少，主要为<strong>影子队列</strong>和<strong>数据偏移</strong>。</li></ol><p>我们这里只是介绍了 RabbitMQ 消息隔离方案。从技术实现来看，其它 MQ 产品的隔离逻辑是一致的。你也可以根据自己项目的实际情况和需求灵活选择，也欢迎有问题来和我讨论。</p><h2 id="课后题"><a aria-hidden="true" tabindex="-1" href="/blog/全链路压测实战30讲/03.实践需求/16#课后题"><span class="icon icon-link"></span></a>课后题</h2><p>学完这节课，我想请你思考两个问题：</p><ol><li>除了 RabbitMQ，你在工作中还接触过哪些 MQ 产品，它们有什么区别？</li><li>相比数据库隔离，你觉得 MQ 消息隔离的难点在哪里？</li></ol><p>欢迎你在留言区与我交流讨论。我们下节课见！</p></div><div class="__dumi-default-layout-footer-meta"><a target="_blank" rel="noopener noreferrer" href="https://github.com/GGwujun/blog/edit/master/docs/全链路压测实战30讲/03.实践需求/16.md">在 GitHub 上编辑此页<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a><span data-updated-text="最后更新时间：">5/2/2022 10:57:04</span></div></div></div></div>
	<script>
  window.g_useSSR = true;
  window.g_initialProps = {};
	</script>

    <script>
      (function () {
        if (!location.port) {
          (function (i, s, o, g, r, a, m) {
            i["GoogleAnalyticsObject"] = r;
            (i[r] =
              i[r] ||
              function () {
                (i[r].q = i[r].q || []).push(arguments);
              }),
              (i[r].l = 1 * new Date());
            (a = s.createElement(o)), (m = s.getElementsByTagName(o)[0]);
            a.async = 1;
            a.src = g;
            m.parentNode.insertBefore(a, m);
          })(
            window,
            document,
            "script",
            "//www.google-analytics.com/analytics.js",
            "ga"
          );
          ga("create", "UA-149864185-1", "auto");
          ga("send", "pageview");
        }
      })();
    </script>
    <script src="/blog/umi.js"></script>
  </body>
</html>
