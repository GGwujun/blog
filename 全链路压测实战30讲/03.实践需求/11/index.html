<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no"
    />
    <link rel="shortcut icon" type="image/x-icon" href="/logo.png" />
    <link rel="stylesheet" href="/blog/umi.css" />
    <script>
      window.routerBase = "/blog";
    </script>
    <script>
      //! umi version: 3.5.17
    </script>
    <script>
      !(function () {
        var e = localStorage.getItem("dumi:prefers-color"),
          t = window.matchMedia("(prefers-color-scheme: dark)").matches,
          r = ["light", "dark", "auto"];
        document.documentElement.setAttribute(
          "data-prefers-color",
          e === r[2] ? (t ? r[1] : r[0]) : r.indexOf(e) > -1 ? e : r[0]
        );
      })();
    </script>
    <title>13 | 标记透传：微服务系统如何做标记透传方案选型？</title>
  </head>
  <body>
    <div id="root"><div class="__dumi-default-layout" data-route="/全链路压测实战30讲/03.实践需求/11" data-show-sidemenu="true" data-show-slugs="true" data-site-mode="true" data-gapless="false"><div class="__dumi-default-navbar" data-mode="site"><button class="__dumi-default-navbar-toggle"></button><a class="__dumi-default-navbar-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog/">大师兄</a><nav><div class="__dumi-default-search"><input type="search" class="__dumi-default-search-input" value=""/><ul></ul></div><span>计算机基础<ul><li><a href="/blog/编译原理之美">编译原理之美</a></li><li><a href="/blog/编译原理实战">编译原理实战</a></li><li><a href="/blog/深入浅出计算机组成原理">深入浅出计算机组成原理</a></li><li><a href="/blog/详解http">详解http</a></li><li><a href="/blog/计算机网络通关29讲">计算机网络通关29讲</a></li><li><a href="/blog/网络排查案例课">网络排查案例课</a></li><li><a href="/blog/linux操作系统">linux操作系统</a></li><li><a href="/blog/linux性能优化实战">linux性能优化实战</a></li><li><a href="/blog/程序员数学基础">程序员数学基础</a></li><li><a href="/blog/趣谈网络协议">趣谈网络协议</a></li><li><a href="/blog/操作系统实战">操作系统实战</a></li><li><a href="/blog/软件工程之美">软件工程之美</a></li><li><a href="/blog/sql必知必会">sql必知必会</a></li><li><a href="/blog/操作系统实战45讲">操作系统实战45讲</a></li><li><a href="/blog/网络编程实战">网络编程实战</a></li></ul></span><span>算法<ul><li><a href="/blog/常用算法25讲">常用算法25讲</a></li><li><a href="/blog/数据结构与算法之美">数据结构与算法之美</a></li><li><a href="/blog/业务开发算法50讲">业务开发算法50讲</a></li><li><a href="/blog/动态规划面试宝典">动态规划面试宝典</a></li></ul></span><span>前端开发<ul><li><a href="/blog/浏览器工作原理与实践">浏览器工作原理与实践</a></li><li><a href="/blog/新时代产品经理进阶之路">新时代产品经理进阶之路</a></li><li><a href="/blog/全栈工程师修炼指南">全栈工程师修炼指南</a></li><li><a href="/blog/flutter核心技术与实战">flutter核心技术与实战</a></li><li><a href="/blog/java-script核心原理解析">java-script核心原理解析</a></li><li><a href="/blog/说透低代码">说透低代码</a></li><li><a href="/blog/nodejs应用开发实战">nodejs应用开发实战</a></li><li><a href="/blog/反爬虫兵法演绎20讲">反爬虫兵法演绎20讲</a></li><li><a href="/blog/reactnative新架构实战课">reactnative新架构实战课</a></li><li><a href="/blog/正则表达式入门">正则表达式入门</a></li><li><a href="/blog/重学前端">重学前端</a></li><li><a href="/blog/serverless入门课">serverless入门课</a></li><li><a href="/blog/type-script入门实战笔记">type-script入门实战笔记</a></li><li><a href="/blog/图解googlev8">图解googlev8</a></li><li><a href="/blog/vue3源码分析">vue3源码分析</a></li><li><a href="/blog/玩转Vue3全家桶">玩转Vue3全家桶</a></li><li><a href="/blog/webassembly入门">webassembly入门</a></li><li><a href="/blog/手把手带你写一个Web框架">手把手带你写一个Web框架</a></li><li><a href="/blog/web漏洞挖掘实战">web漏洞挖掘实战</a></li><li><a href="/blog/跟月影学可视化">跟月影学可视化</a></li><li><a href="/blog/搞定音频技术">搞定音频技术</a></li><li><a href="/blog/攻克视频技术">攻克视频技术</a></li></ul></span><span>前端工程化<ul><li><a href="/blog/logger">logger</a></li><li><a href="/blog/webpack">webpack</a></li><li><a href="/blog/webpackChain">webpackChain</a></li></ul></span><span>前端性能优化<ul><li><a href="/blog/react性能调优">react性能调优</a></li></ul></span><span>软件测试<ul><li><a aria-current="page" class="active" href="/blog/全链路压测实战30讲">全链路压测实战30讲</a></li><li><a href="/blog/性能测试实战30讲">性能测试实战30讲</a></li><li><a href="/blog/自动化测试高手课">自动化测试高手课</a></li><li><a href="/blog/软件测试52讲">软件测试52讲</a></li></ul></span><span>面试<ul><li><a href="/blog/面试现场">面试现场</a></li></ul></span><span>杂谈<ul><li><a href="/blog/超级访谈对话张雪峰">超级访谈对话张雪峰</a></li><li><a href="/blog/Git实战手册">Git实战手册</a></li><li><a href="/blog/NodeJS">NodeJS</a></li><li><a href="/blog/ReactJS">ReactJS</a></li><li><a href="/blog/UI设计">UI设计</a></li><li><a href="/blog/webpack4系列教程">webpack4系列教程</a></li><li><a href="/blog/前端知识体系">前端知识体系</a></li><li><a href="/blog/剑指offer刷题笔记">剑指offer刷题笔记</a></li><li><a href="/blog/思考与成长">思考与成长</a></li><li><a href="/blog/设计模式手册">设计模式手册</a></li></ul></span><div class="__dumi-default-navbar-tool"><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "></div></div></div></nav></div><div class="__dumi-default-menu" data-mode="site"><div class="__dumi-default-menu-inner"><div class="__dumi-default-menu-header"><a class="__dumi-default-menu-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog/"></a><h1>大师兄</h1><p></p></div><div class="__dumi-default-menu-mobile-area"><ul class="__dumi-default-menu-nav-list"><li>计算机基础<ul><li><a href="/blog/编译原理之美">编译原理之美</a></li><li><a href="/blog/编译原理实战">编译原理实战</a></li><li><a href="/blog/深入浅出计算机组成原理">深入浅出计算机组成原理</a></li><li><a href="/blog/详解http">详解http</a></li><li><a href="/blog/计算机网络通关29讲">计算机网络通关29讲</a></li><li><a href="/blog/网络排查案例课">网络排查案例课</a></li><li><a href="/blog/linux操作系统">linux操作系统</a></li><li><a href="/blog/linux性能优化实战">linux性能优化实战</a></li><li><a href="/blog/程序员数学基础">程序员数学基础</a></li><li><a href="/blog/趣谈网络协议">趣谈网络协议</a></li><li><a href="/blog/操作系统实战">操作系统实战</a></li><li><a href="/blog/软件工程之美">软件工程之美</a></li><li><a href="/blog/sql必知必会">sql必知必会</a></li><li><a href="/blog/操作系统实战45讲">操作系统实战45讲</a></li><li><a href="/blog/网络编程实战">网络编程实战</a></li></ul></li><li>算法<ul><li><a href="/blog/常用算法25讲">常用算法25讲</a></li><li><a href="/blog/数据结构与算法之美">数据结构与算法之美</a></li><li><a href="/blog/业务开发算法50讲">业务开发算法50讲</a></li><li><a href="/blog/动态规划面试宝典">动态规划面试宝典</a></li></ul></li><li>前端开发<ul><li><a href="/blog/浏览器工作原理与实践">浏览器工作原理与实践</a></li><li><a href="/blog/新时代产品经理进阶之路">新时代产品经理进阶之路</a></li><li><a href="/blog/全栈工程师修炼指南">全栈工程师修炼指南</a></li><li><a href="/blog/flutter核心技术与实战">flutter核心技术与实战</a></li><li><a href="/blog/java-script核心原理解析">java-script核心原理解析</a></li><li><a href="/blog/说透低代码">说透低代码</a></li><li><a href="/blog/nodejs应用开发实战">nodejs应用开发实战</a></li><li><a href="/blog/反爬虫兵法演绎20讲">反爬虫兵法演绎20讲</a></li><li><a href="/blog/reactnative新架构实战课">reactnative新架构实战课</a></li><li><a href="/blog/正则表达式入门">正则表达式入门</a></li><li><a href="/blog/重学前端">重学前端</a></li><li><a href="/blog/serverless入门课">serverless入门课</a></li><li><a href="/blog/type-script入门实战笔记">type-script入门实战笔记</a></li><li><a href="/blog/图解googlev8">图解googlev8</a></li><li><a href="/blog/vue3源码分析">vue3源码分析</a></li><li><a href="/blog/玩转Vue3全家桶">玩转Vue3全家桶</a></li><li><a href="/blog/webassembly入门">webassembly入门</a></li><li><a href="/blog/手把手带你写一个Web框架">手把手带你写一个Web框架</a></li><li><a href="/blog/web漏洞挖掘实战">web漏洞挖掘实战</a></li><li><a href="/blog/跟月影学可视化">跟月影学可视化</a></li><li><a href="/blog/搞定音频技术">搞定音频技术</a></li><li><a href="/blog/攻克视频技术">攻克视频技术</a></li></ul></li><li>前端工程化<ul><li><a href="/blog/logger">logger</a></li><li><a href="/blog/webpack">webpack</a></li><li><a href="/blog/webpackChain">webpackChain</a></li></ul></li><li>前端性能优化<ul><li><a href="/blog/react性能调优">react性能调优</a></li></ul></li><li>软件测试<ul><li><a aria-current="page" class="active" href="/blog/全链路压测实战30讲">全链路压测实战30讲</a></li><li><a href="/blog/性能测试实战30讲">性能测试实战30讲</a></li><li><a href="/blog/自动化测试高手课">自动化测试高手课</a></li><li><a href="/blog/软件测试52讲">软件测试52讲</a></li></ul></li><li>面试<ul><li><a href="/blog/面试现场">面试现场</a></li></ul></li><li>杂谈<ul><li><a href="/blog/超级访谈对话张雪峰">超级访谈对话张雪峰</a></li><li><a href="/blog/Git实战手册">Git实战手册</a></li><li><a href="/blog/NodeJS">NodeJS</a></li><li><a href="/blog/ReactJS">ReactJS</a></li><li><a href="/blog/UI设计">UI设计</a></li><li><a href="/blog/webpack4系列教程">webpack4系列教程</a></li><li><a href="/blog/前端知识体系">前端知识体系</a></li><li><a href="/blog/剑指offer刷题笔记">剑指offer刷题笔记</a></li><li><a href="/blog/思考与成长">思考与成长</a></li><li><a href="/blog/设计模式手册">设计模式手册</a></li></ul></li></ul><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "><button title="Dark theme" class="__dumi-default-dark-moon "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="3854" width="22" height="22"><path d="M991.816611 674.909091a69.166545 69.166545 0 0 0-51.665455-23.272727 70.795636 70.795636 0 0 0-27.438545 5.585454A415.674182 415.674182 0 0 1 754.993338 698.181818c-209.594182 0-393.472-184.785455-393.472-395.636363 0-52.363636 38.539636-119.621818 69.515637-173.614546 4.887273-8.610909 9.634909-16.756364 14.103272-24.901818A69.818182 69.818182 0 0 0 384.631156 0a70.842182 70.842182 0 0 0-27.438545 5.585455C161.678429 90.298182 14.362065 307.898182 14.362065 512c0 282.298182 238.824727 512 532.38691 512a522.286545 522.286545 0 0 0 453.957818-268.334545A69.818182 69.818182 0 0 0 991.816611 674.909091zM546.679156 954.181818c-248.785455 0-462.941091-192-462.941091-442.181818 0-186.647273 140.637091-372.829091 300.939637-442.181818-36.817455 65.629091-92.578909 151.970909-92.578909 232.727273 0 250.181818 214.109091 465.454545 462.917818 465.454545a488.331636 488.331636 0 0 0 185.181091-46.545455 453.003636 453.003636 0 0 1-393.565091 232.727273z m103.656728-669.323636l-14.266182 83.781818a34.909091 34.909091 0 0 0 50.362182 36.770909l74.775272-39.563636 74.752 39.563636a36.142545 36.142545 0 0 0 16.174546 3.956364 34.909091 34.909091 0 0 0 34.210909-40.727273l-14.289455-83.781818 60.509091-59.345455a35.025455 35.025455 0 0 0-19.223272-59.578182l-83.61891-12.101818-37.376-76.101818a34.56 34.56 0 0 0-62.254545 0l-37.376 76.101818-83.618909 12.101818a34.909091 34.909091 0 0 0-19.246546 59.578182z m70.423272-64.698182a34.280727 34.280727 0 0 0 26.135273-19.083636l14.312727-29.090909 14.336 29.090909a34.257455 34.257455 0 0 0 26.135273 19.083636l32.046546 4.887273-23.272728 22.574545a35.234909 35.234909 0 0 0-10.007272 30.952727l5.46909 32.116364-28.625454-15.127273a34.490182 34.490182 0 0 0-32.302546 0l-28.695272 15.127273 5.469091-32.116364a35.141818 35.141818 0 0 0-9.984-30.952727l-23.272728-22.574545z" p-id="3855"></path></svg></button><button title="Light theme" class="__dumi-default-dark-sun "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="4026" width="22" height="22"><path d="M915.2 476.16h-43.968c-24.704 0-44.736 16-44.736 35.84s20.032 35.904 44.736 35.904H915.2c24.768 0 44.8-16.064 44.8-35.904s-20.032-35.84-44.8-35.84zM512 265.6c-136.704 0-246.464 109.824-246.464 246.4 0 136.704 109.76 246.464 246.464 246.464S758.4 648.704 758.4 512c0-136.576-109.696-246.4-246.4-246.4z m0 425.6c-99.008 0-179.2-80.128-179.2-179.2 0-98.944 80.192-179.2 179.2-179.2S691.2 413.056 691.2 512c0 99.072-80.192 179.2-179.2 179.2zM197.44 512c0-19.84-19.136-35.84-43.904-35.84H108.8c-24.768 0-44.8 16-44.8 35.84s20.032 35.904 44.8 35.904h44.736c24.768 0 43.904-16.064 43.904-35.904zM512 198.464c19.776 0 35.84-20.032 35.84-44.8v-44.8C547.84 84.032 531.84 64 512 64s-35.904 20.032-35.904 44.8v44.8c0 24.768 16.128 44.864 35.904 44.864z m0 627.136c-19.776 0-35.904 20.032-35.904 44.8v44.736C476.096 940.032 492.16 960 512 960s35.84-20.032 35.84-44.8v-44.736c0-24.768-16.064-44.864-35.84-44.864z m329.92-592.832c17.472-17.536 20.288-43.072 6.4-57.024-14.016-14.016-39.488-11.2-57.024 6.336-4.736 4.864-26.496 26.496-31.36 31.36-17.472 17.472-20.288 43.008-6.336 57.024 13.952 14.016 39.488 11.2 57.024-6.336 4.8-4.864 26.496-26.56 31.296-31.36zM213.376 759.936c-4.864 4.8-26.56 26.624-31.36 31.36-17.472 17.472-20.288 42.944-6.4 56.96 14.016 13.952 39.552 11.2 57.024-6.336 4.8-4.736 26.56-26.496 31.36-31.36 17.472-17.472 20.288-43.008 6.336-56.96-14.016-13.952-39.552-11.072-56.96 6.336z m19.328-577.92c-17.536-17.536-43.008-20.352-57.024-6.336-14.08 14.016-11.136 39.488 6.336 57.024 4.864 4.864 26.496 26.56 31.36 31.424 17.536 17.408 43.008 20.288 56.96 6.336 14.016-14.016 11.264-39.488-6.336-57.024-4.736-4.864-26.496-26.56-31.296-31.424z m527.168 628.608c4.864 4.864 26.624 26.624 31.36 31.424 17.536 17.408 43.072 20.224 57.088 6.336 13.952-14.016 11.072-39.552-6.4-57.024-4.864-4.8-26.56-26.496-31.36-31.36-17.472-17.408-43.072-20.288-57.024-6.336-13.952 14.016-11.008 39.488 6.336 56.96z" p-id="4027"></path></svg></button><button title="Default to system" class="__dumi-default-dark-auto "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="11002" width="22" height="22"><path d="M127.658667 492.885333c0-51.882667 10.24-101.717333 30.378666-149.162666s47.786667-88.064 81.92-122.538667 75.093333-61.781333 122.538667-81.92 96.938667-30.378667 149.162667-30.378667 101.717333 10.24 149.162666 30.378667 88.405333 47.786667 122.88 81.92 61.781333 75.093333 81.92 122.538667 30.378667 96.938667 30.378667 149.162666-10.24 101.717333-30.378667 149.162667-47.786667 88.405333-81.92 122.88-75.093333 61.781333-122.88 81.92-97.28 30.378667-149.162666 30.378667-101.717333-10.24-149.162667-30.378667-88.064-47.786667-122.538667-81.92-61.781333-75.093333-81.92-122.88-30.378667-96.938667-30.378666-149.162667z m329.045333 0c0 130.048 13.994667 244.394667 41.984 343.381334h12.970667c46.762667 0 91.136-9.216 133.461333-27.306667s78.848-42.666667 109.568-73.386667 54.954667-67.242667 73.386667-109.568 27.306667-86.698667 27.306666-133.461333c0-46.421333-9.216-90.794667-27.306666-133.12s-42.666667-78.848-73.386667-109.568-67.242667-54.954667-109.568-73.386667-86.698667-27.306667-133.461333-27.306666h-11.605334c-28.672 123.562667-43.349333 237.909333-43.349333 343.722666z" p-id="11003"></path></svg></button></div></div></div><ul class="__dumi-default-menu-list"><li><a href="/blog/全链路压测实战30讲">全链路压测实战30讲</a></li><li><a href="/blog/全链路压测实战30讲/01.开篇词">01.开篇词</a><ul><li><a href="/blog/全链路压测实战30讲/01.开篇词/01"><span>开篇词 | 打破认知神话，做接地气的全链路压测</span></a></li></ul></li><li><a href="/blog/全链路压测实战30讲/02.核心理论">02.核心理论</a><ul><li><a href="/blog/全链路压测实战30讲/02.核心理论/01"><span>01 | 全链路压测：为什么很多测试人员迷信它？</span></a></li><li><a href="/blog/全链路压测实战30讲/02.核心理论/02"><span>02 | RESAR 全链路流程：如何搞定所有容量场景？</span></a></li></ul></li><li><a aria-current="page" class="active" href="/blog/全链路压测实战30讲/03.实践需求">03.实践需求</a><ul><li><a href="/blog/全链路压测实战30讲/03.实践需求/01"><span>03 | 压测方案：你是否忽略了一个重量级文档？</span></a></li><li><a href="/blog/全链路压测实战30讲/03.实践需求/02"><span>04 | 核心链路：如何梳理符合真实业务场景的核心链路？</span></a></li><li><a href="/blog/全链路压测实战30讲/03.实践需求/03"><span>05 | 铺底数据：真实的压测数据应该做成什么样子？</span></a></li><li><a href="/blog/全链路压测实战30讲/03.实践需求/04"><span>06 | 流量构建：流量平台如何选型？</span></a></li><li><a href="/blog/全链路压测实战30讲/03.实践需求/05"><span>07 | 全栈监控：如何设计全栈监控策略？</span></a></li><li><a href="/blog/全链路压测实战30讲/03.实践需求/06"><span>08 | 基础设施：全链路压测的环境有什么特点？</span></a></li><li><a href="/blog/全链路压测实战30讲/03.实践需求/07"><span>09 | 压测模型：如何建立一套完整的全链路压测模型？</span></a></li><li><a href="/blog/全链路压测实战30讲/03.实践需求/08"><span>10 | 场景执行：压测执行过程中的关键步骤是什么？</span></a></li><li><a href="/blog/全链路压测实战30讲/03.实践需求/09"><span>11 | 链路追踪：如何选择一款适合自己项目的工具？</span></a></li><li><a href="/blog/全链路压测实战30讲/03.实践需求/10"><span>12 | 链路追踪：如何对一个具体的项目进行追踪改造？</span></a></li><li><a aria-current="page" class="active" href="/blog/全链路压测实战30讲/03.实践需求/11"><span>13 | 标记透传：微服务系统如何做标记透传方案选型？</span></a></li><li><a href="/blog/全链路压测实战30讲/03.实践需求/12"><span>14 | 标记透传：如何基于微服务技术进行标记透传？</span></a></li><li><a href="/blog/全链路压测实战30讲/03.实践需求/13"><span>15 | 流量隔离：MySQL数据库隔离是怎么做的？</span></a></li><li><a href="/blog/全链路压测实战30讲/03.实践需求/14"><span>16 | 流量隔离：Redis 缓存隔离是怎么做的？</span></a></li><li><a href="/blog/全链路压测实战30讲/03.实践需求/15"><span>17 | 流量隔离：MongoDB 数据库隔离是怎么做的？</span></a></li><li><a href="/blog/全链路压测实战30讲/03.实践需求/16"><span>18 | 流量隔离：RabbitMQ 消息隔离是怎么做的？</span></a></li><li><a href="/blog/全链路压测实战30讲/03.实践需求/17"><span>19｜日志隔离：如何落地日志隔离？</span></a></li><li><a href="/blog/全链路压测实战30讲/03.实践需求/18"><span>20 | Mock：如何屏蔽第三方接口的影响？</span></a></li></ul></li><li><a href="/blog/全链路压测实战30讲/04.实践环境">04.实践环境</a><ul><li><a href="/blog/全链路压测实战30讲/04.实践环境/01"><span>21 | 压测平台：高效搭建 GoReplay 压测平台</span></a></li><li><a href="/blog/全链路压测实战30讲/04.实践环境/02"><span>22 | 压测平台：如何解决 GoReplay 动态数据关联？</span></a></li><li><a href="/blog/全链路压测实战30讲/04.实践环境/03"><span>23 | 压测平台：如何改造对象存储和性能监控？</span></a></li><li><a href="/blog/全链路压测实战30讲/04.实践环境/04"><span>24 | 压测平台：如何改造分布式调度平台？</span></a></li><li><a href="/blog/全链路压测实战30讲/04.实践环境/05"><span>25 | 环境搭建：我们的系统是怎么搭建起来的？</span></a></li><li><a href="/blog/全链路压测实战30讲/04.实践环境/06"><span>26 | 全局监控（上）：如何快速落地全局监控？</span></a></li><li><a href="/blog/全链路压测实战30讲/04.实践环境/07"><span>27 | 全局监控（下）：如何快速落地全局监控？</span></a></li><li><a href="/blog/全链路压测实战30讲/04.实践环境/08"><span>28 | 定向监控：怎样快速发现业务异常？</span></a></li></ul></li><li><a href="/blog/全链路压测实战30讲/05.实践性能场景执行">05.实践性能场景执行</a><ul><li><a href="/blog/全链路压测实战30讲/05.实践性能场景执行/01"><span>29 | 基准场景：一个案例，带你搞懂基准场景的关键要点</span></a></li><li><a href="/blog/全链路压测实战30讲/05.实践性能场景执行/02"><span>30 | 预压测：如何基于小流量快速验证容量压测效果？</span></a></li><li><a href="/blog/全链路压测实战30讲/05.实践性能场景执行/03"><span>31 | 容量场景：决定线上容量场景的关键因素是什么？</span></a></li><li><a href="/blog/全链路压测实战30讲/05.实践性能场景执行/04"><span>32 | 稳定性场景：怎样搞定线上稳定性场景？</span></a></li><li><a href="/blog/全链路压测实战30讲/05.实践性能场景执行/05"><span>33 | 异常场景：如何模拟线上不同组件的异常场景？</span></a></li><li><a href="/blog/全链路压测实战30讲/05.实践性能场景执行/06"><span>34 | 容量规划：如何精准地对生产系统做容量预估？</span></a></li></ul></li><li><a href="/blog/全链路压测实战30讲/06.性能结果报告">06.性能结果报告</a><ul><li><a href="/blog/全链路压测实战30讲/06.性能结果报告/01"><span>35 | 压测报告：怎样写出一份让老板满意的报告？</span></a></li></ul></li><li><a href="/blog/全链路压测实战30讲/07.结束语">07.结束语</a><ul><li><a href="/blog/全链路压测实战30讲/07.结束语/01"><span>结束语 | 做能落地的全链路压测项目</span></a></li><li><a href="/blog/全链路压测实战30讲/07.结束语/02"><span>期末考试 |《全链路压测实战30讲》满分试卷，等你来挑战！</span></a></li></ul></li><li><a href="/blog/全链路压测实战30讲/summary">全链路压测实战30讲</a></li></ul></div></div><ul role="slug-list" class="__dumi-default-layout-toc"><li title="跨线程间的透传" data-depth="2"><a href="/blog/全链路压测实战30讲/03.实践需求/11#跨线程间的透传"><span>跨线程间的透传</span></a></li><li title="跨服务间的透传" data-depth="2"><a href="/blog/全链路压测实战30讲/03.实践需求/11#跨服务间的透传"><span>跨服务间的透传</span></a></li><li title="总结" data-depth="2"><a href="/blog/全链路压测实战30讲/03.实践需求/11#总结"><span>总结</span></a></li><li title="思考题" data-depth="2"><a href="/blog/全链路压测实战30讲/03.实践需求/11#思考题"><span>思考题</span></a></li></ul><div class="__dumi-default-layout-content"><div class="markdown"><h1 id="13--标记透传微服务系统如何做标记透传方案选型"><a aria-hidden="true" tabindex="-1" href="/blog/全链路压测实战30讲/03.实践需求/11#13--标记透传微服务系统如何做标记透传方案选型"><span class="icon icon-link"></span></a>13 | 标记透传：微服务系统如何做标记透传方案选型？</h1><p>你好，我是高楼。</p><p>接下来的两节课，我们会详细讲讲标记透传。这节课呢，我会带你看看，在微服务系统中如何对标记透传方案进行选型。下节课我们会进入实战，讲解如何基于微服务技术进行标记透传的落地。</p><p>在微服务系统中，服务之间可以通过各种方式和协议进行通信，而且一般链路都很长。在全链路压测的系统中，线上压测要保证压测安全且可控，不会对真实用户产生影响，也不会对线上环境造成数据的污染，我们首要解决的就是压测标记在整条链路中透传和识别的问题。</p><p>分布式系统的压测流量透传主要包含两大方面：</p><ul><li>**跨线程间的透传：**能够做到跨线程间对压测标记进行传递，同时可以兼容不同的协议类型，支持对标记的存取操作；</li><li>**跨服务间的透传：**能够通过网络在上下游服务间进行标记传递，有点像“击鼓传花”的感觉，而且可以做到全链路双向传递。</li></ul><p>接下来，我们分别看看这两大方面都有哪些可供选择的标记透传方案。</p><h2 id="跨线程间的透传"><a aria-hidden="true" tabindex="-1" href="/blog/全链路压测实战30讲/03.实践需求/11#跨线程间的透传"><span class="icon icon-link"></span></a>跨线程间的透传</h2><p>我们先来看下跨线程间的透传。对于涉及多线程调用的服务来说，一个重点就是要保证压测标识在跨线程的情况下不丢失。</p><p>这个时候，我们就不得不提到本地线程专属变量 ThreadLocal 了。ThreadLocal 能够提供线程局部专属变量，这些变量和普通变量的不同之处在于，我们访问的每个变量(通过 Get 或 Set 的方法)的线程都有独立初始化的变量副本。ThreadLocal将状态与线程关联起来的私有静态字段(例如Request ID 或 TraceID)保存起来。</p><p>我们通过这张图片快速了解下 ThreadLocal 的内部存储结构。</p><p><img src="https://static001.geekbang.org/resource/image/3e/3d/3e56a00e590fb56365cd5b3b6f64de3d.jpg?wh=1920x1754" alt="图片"/></p><p>在这张图里，我们可以看到 ThreadLocal 的存储结构是这样的：</p><ul><li>每个 Thread 维护一个 ThreadLocalMap 映射表，这个映射表的 key 是 ThreadLocal 实例本身，value 是真正需要存储的 Object；</li><li>ThreadLocal 本身并不存储值，它只是作为一个 key 来让线程从 ThreadLocalMap 中获取 value；</li><li>ThreadLocal 能在每个线程间进行隔离，这主要是靠在每个 Thread 对象中维护一个 ThreadLocalMap 来实现的。</li></ul><p>虽然 ThreadLocal 能够提供线程局部专属变量，但也有它的局限性，那就是它无法在父子线程之间传递。</p><p>你可以参考一下我给出的代码。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">package com.dunshan.threadlocaldemo.demo;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    /**</span></div><div class="token-line"><span class="token plain">     * @author: dunshan</span></div><div class="token-line"><span class="token plain">     * @date: 2021-4-2 13:13</span></div><div class="token-line"><span class="token plain">     */</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    public class ThreadLocalDemo {</span></div><div class="token-line"><span class="token plain">        private static final ThreadLocal&lt;Integer&gt; flagThreadLocal = new ThreadLocal&lt;&gt;();</span></div><div class="token-line"><span class="token plain">        public static void main(String[] args) {</span></div><div class="token-line"><span class="token plain">            Integer flagId = new Integer(5);</span></div><div class="token-line"><span class="token plain">            ThreadLocalDemo threadLocalExample = new ThreadLocalDemo();</span></div><div class="token-line"><span class="token plain">            threadLocalExample.setRequestId(flagId);</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        public void setRequestId(Integer flagId) {</span></div><div class="token-line"><span class="token plain">            flagThreadLocal.set(flagId);</span></div><div class="token-line"><span class="token plain">            doRun();</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        public void doRun() {</span></div><div class="token-line"><span class="token plain">            System.out.println(&quot;首先打印 flagId:&quot; + flagThreadLocal.get());</span></div><div class="token-line"><span class="token plain">            (new Thread(new Runnable() {</span></div><div class="token-line"><span class="token plain">                @Override</span></div><div class="token-line"><span class="token plain">                public void run() {</span></div><div class="token-line"><span class="token plain">                    System.out.println(&quot;子线程启动&quot;);</span></div><div class="token-line"><span class="token plain">                    System.out.println(&quot;在子线程中访问 flagId:&quot; + flagThreadLocal.get());</span></div><div class="token-line"><span class="token plain">                }</span></div><div class="token-line"><span class="token plain">            })).start();</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>在代码中你可以看到，我在 doRun 方法中又启动了一个子线程来执行业务(模拟异步处理)。</p><p>运行结果如下：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">首先打印 flagId:5</span></div><div class="token-line"><span class="token plain">    子线程启动</span></div><div class="token-line"><span class="token plain">    在子线程中访问 flagId:null</span></div></pre></div><p>从运行结果中也能看出来，在子线程中是不能获取父线程中的变量值的。就像前面分析存储原理时提到的，因为子线程拥有自己的 ThreadLocalMap，所以不能获取父线程 ThreadLocalMap 中的值。</p><p>但是在实际业务中呢，很多业务都是需要异步操作的，所以我们需要父子线程能够直接共享 ThreadLocal 中的值。怎么解决这个问题呢？</p><p>这个时候，我们可以考虑引入另外一个线程对象 <strong>InheritableThreadLocal</strong>。</p><p>我们通过下面这段代码，看看它是怎么实现父子线程之间共享 ThreadLocal 值的。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">package com.dunshan.threadlocaldemo.demo;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    /**</span></div><div class="token-line"><span class="token plain">     * @author: dunshan</span></div><div class="token-line"><span class="token plain">     * @date: 2021-4-2 13:13</span></div><div class="token-line"><span class="token plain">     */</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    public class InheritableThreadLocalDemo {</span></div><div class="token-line"><span class="token plain">        private static final InheritableThreadLocal&lt;Integer&gt; flagThreadLocal = new InheritableThreadLocal&lt;&gt;();</span></div><div class="token-line"><span class="token plain">        public static void main(String[] args) {</span></div><div class="token-line"><span class="token plain">            Integer flagId = new Integer(5);</span></div><div class="token-line"><span class="token plain">            InheritableThreadLocalDemo threadLocalExample = new InheritableThreadLocalDemo();</span></div><div class="token-line"><span class="token plain">            threadLocalExample.setRequestId(flagId);</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        public void setRequestId(Integer flagId) {</span></div><div class="token-line"><span class="token plain">            flagThreadLocal.set(flagId);</span></div><div class="token-line"><span class="token plain">            doBussiness();</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        public void doRun() {</span></div><div class="token-line"><span class="token plain">            System.out.println(&quot;首先打印 flagId:&quot; + flagThreadLocal.get());</span></div><div class="token-line"><span class="token plain">            (new Thread(new Runnable() {</span></div><div class="token-line"><span class="token plain">                @Override</span></div><div class="token-line"><span class="token plain">                public void run() {</span></div><div class="token-line"><span class="token plain">                    System.out.println(&quot;子线程启动&quot;);</span></div><div class="token-line"><span class="token plain">                    System.out.println(&quot;在子线程中访问 flagId:&quot; + flagThreadLocal.get());</span></div><div class="token-line"><span class="token plain">                }</span></div><div class="token-line"><span class="token plain">            })).start();</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>运行结果如下：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">首先打印 flagId:5</span></div><div class="token-line"><span class="token plain">    子线程启动</span></div><div class="token-line"><span class="token plain">    在子线程中访问 flagId:5</span></div></pre></div><p>从运行结果可以看出，子线程成功获取到了父线程 ThreadLocal 的值，这样也就解决了父子线程值传递的问题。<br/>不过，在大部分业务场景下，业务应用不可能每一个异步请求都要 new 一个单独的子线程来处理，这样会导致内存被撑爆。所以，通常情况下，我们还会使用到线程池，而线程池中又存在线程复用的情况。假设线程池复用线程变量值，就会导致父子线程变量复制混乱。</p><p>你可以看下这段示例代码：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">package com.dunshan.threadlocaldemo.demo;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    import java.util.concurrent.ExecutorService;</span></div><div class="token-line"><span class="token plain">    import java.util.concurrent.Executors;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    /**</span></div><div class="token-line"><span class="token plain">     * 演示 InheritableThreadLocal 的缺陷</span></div><div class="token-line"><span class="token plain">     * @author: dunshan</span></div><div class="token-line"><span class="token plain">     * @date: 2020-4-4</span></div><div class="token-line"><span class="token plain">     */</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    public class InheritableThreadLocalWeaknessDemo {</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        private static final InheritableThreadLocal&lt;Integer&gt; INHERITABLE_THREAD_LOCAL = new InheritableThreadLocal&lt;&gt;();</span></div><div class="token-line"><span class="token plain">        //模拟业务线程池</span></div><div class="token-line"><span class="token plain">        private static final ExecutorService threadPool = Executors.newFixedThreadPool(5);</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        public static void main(String[] args) throws InterruptedException {</span></div><div class="token-line"><span class="token plain">            //模拟同时 10 个 web 请求，一个请求一个线程</span></div><div class="token-line"><span class="token plain">            for (int i = 0; i &lt; 10; i++) {</span></div><div class="token-line"><span class="token plain">                new TomcatThread(i).start();</span></div><div class="token-line"><span class="token plain">            }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">            Thread.sleep(3000);</span></div><div class="token-line"><span class="token plain">            threadPool.shutdown();</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        static class TomcatThread extends Thread{</span></div><div class="token-line"><span class="token plain">            //线程下标</span></div><div class="token-line"><span class="token plain">            int index;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">            public TomcatThread(int index) {</span></div><div class="token-line"><span class="token plain">                this.index = index;</span></div><div class="token-line"><span class="token plain">            }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">            @Override</span></div><div class="token-line"><span class="token plain">            public void run() {</span></div><div class="token-line"><span class="token plain">                String parentThreadName = Thread.currentThread().getName();</span></div><div class="token-line"><span class="token plain">                //父线程中将 index 值塞入线程上下文变量</span></div><div class="token-line"><span class="token plain">                System.out.println( parentThreadName+ &quot;:&quot; + index);</span></div><div class="token-line"><span class="token plain">                INHERITABLE_THREAD_LOCAL.set(index);</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">                threadPool.submit(new BusinessThread(parentThreadName));</span></div><div class="token-line"><span class="token plain">            }</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        static class BusinessThread implements Runnable{</span></div><div class="token-line"><span class="token plain">            //父进程名称</span></div><div class="token-line"><span class="token plain">            private String parentThreadName;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">            public BusinessThread(String parentThreadName) {</span></div><div class="token-line"><span class="token plain">                this.parentThreadName = parentThreadName;</span></div><div class="token-line"><span class="token plain">            }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">            @Override</span></div><div class="token-line"><span class="token plain">            public void run() {</span></div><div class="token-line"><span class="token plain">                System.out.println(&quot;parent:&quot;+parentThreadName+&quot;:&quot;+INHERITABLE_THREAD_LOCAL.get());</span></div><div class="token-line"><span class="token plain">            }</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>这段代码模拟了同时有 10 个 web 请求（启动 10 个线程），每个线程内部都向线程池中提交一个异步任务的情况。</p><p>运行结果：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">Thread-1:1</span></div><div class="token-line"><span class="token plain">    Thread-4:4</span></div><div class="token-line"><span class="token plain">    Thread-5:5</span></div><div class="token-line"><span class="token plain">    Thread-6:6</span></div><div class="token-line"><span class="token plain">    Thread-7:7</span></div><div class="token-line"><span class="token plain">    Thread-8:8</span></div><div class="token-line"><span class="token plain">    Thread-9:9</span></div><div class="token-line"><span class="token plain">    parent:Thread-1:1</span></div><div class="token-line"><span class="token plain">    parent:Thread-0:0</span></div><div class="token-line"><span class="token plain">    parent:Thread-4:4</span></div><div class="token-line"><span class="token plain">    parent:Thread-3:0</span></div><div class="token-line"><span class="token plain">    parent:Thread-8:1</span></div><div class="token-line"><span class="token plain">    parent:Thread-7:7</span></div><div class="token-line"><span class="token plain">    parent:Thread-9:0</span></div><div class="token-line"><span class="token plain">    parent:Thread-2:2</span></div><div class="token-line"><span class="token plain">    parent:Thread-5:4</span></div><div class="token-line"><span class="token plain">    parent:Thread-6:1</span></div></pre></div><p>在运行结果中我们也能看到，子线程中输出的父线程名称和它们下标的 index 无法一一对应，在子线程中出现了线程本地变量混乱的现象。在全链路压测中，出现这种情况是致命的。</p><p>那我们要怎么解决这个问题呢？</p><p>当然你可以实现自己的工具类，将要传递的变量封装到对象里，在启动子线程时将对象传递进去，这样子线程就可以拿到父线程的变量了。</p><p>我们这里选择的是 <a target="_blank" rel="noopener noreferrer" href="https://github.com/alibaba/transmittable-thread-local">TransmittableThreadLocal<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> （TTL）。</p><p>TransmittableThreadLocal 是阿里开源的一个增强 InheritableThreadLocal 的库，能够很好地解决使用线程池在线程之间复制值混乱的问题。</p><p>接下来，我们一起验证一下， TransmittableThreadLocal 是不是真的能解决上面的问题。</p><p>首先需要引包：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">&lt;dependency&gt;</span></div><div class="token-line"><span class="token plain">         &lt;groupId&gt;com.alibaba&lt;/groupId&gt;</span></div><div class="token-line"><span class="token plain">         &lt;artifactId&gt;transmittable-thread-local&lt;/artifactId&gt;</span></div><div class="token-line"><span class="token plain">         &lt;version&gt;2.12.0&lt;/version&gt;</span></div><div class="token-line"><span class="token plain">     &lt;/dependency&gt;</span></div></pre></div><p>示例代码如下：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">package com.dunshan.threadlocaldemo.demo;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    import com.alibaba.ttl.TransmittableThreadLocal;</span></div><div class="token-line"><span class="token plain">    import com.alibaba.ttl.TtlRunnable;</span></div><div class="token-line"><span class="token plain">    import java.util.concurrent.ExecutorService;</span></div><div class="token-line"><span class="token plain">    import java.util.concurrent.Executors;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    /**</span></div><div class="token-line"><span class="token plain">     * @author: dunshan</span></div><div class="token-line"><span class="token plain">     * @date: 2021-4-2 13:13</span></div><div class="token-line"><span class="token plain">     */</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    public class TransmittableThreadLocalDemo {</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        private static final TransmittableThreadLocal&lt;Integer&gt; INHERITABLE_THREAD_LOCAL = new TransmittableThreadLocal&lt;&gt;();</span></div><div class="token-line"><span class="token plain">        //模拟业务线程池</span></div><div class="token-line"><span class="token plain">        private static final ExecutorService threadPool = Executors.newFixedThreadPool(5);</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        public static void main(String[] args) throws InterruptedException {</span></div><div class="token-line"><span class="token plain">            //模拟同时 10 个 web 请求，一个请求一个线程</span></div><div class="token-line"><span class="token plain">            for (int i = 0; i &lt; 10; i++) {</span></div><div class="token-line"><span class="token plain">                new TomcatThread(i).start();</span></div><div class="token-line"><span class="token plain">            }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">            Thread.sleep(3000);</span></div><div class="token-line"><span class="token plain">            threadPool.shutdown();</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        static class TomcatThread extends Thread{</span></div><div class="token-line"><span class="token plain">            //线程下标</span></div><div class="token-line"><span class="token plain">            int index;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">            public TomcatThread(int index) {</span></div><div class="token-line"><span class="token plain">                this.index = index;</span></div><div class="token-line"><span class="token plain">            }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">            @Override</span></div><div class="token-line"><span class="token plain">            public void run() {</span></div><div class="token-line"><span class="token plain">                String parentThreadName = Thread.currentThread().getName();</span></div><div class="token-line"><span class="token plain">                //父线程中将 index 值塞入线程上下文变量</span></div><div class="token-line"><span class="token plain">                System.out.println( parentThreadName+ &quot;:&quot; + index);</span></div><div class="token-line"><span class="token plain">                INHERITABLE_THREAD_LOCAL.set(index);</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">                threadPool.submit(TtlRunnable.get(new BusinessThread(parentThreadName)));</span></div><div class="token-line"><span class="token plain">            }</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        static class BusinessThread implements Runnable{</span></div><div class="token-line"><span class="token plain">            //父进程名称</span></div><div class="token-line"><span class="token plain">            private String parentThreadName;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">            public BusinessThread(String parentThreadName) {</span></div><div class="token-line"><span class="token plain">                this.parentThreadName = parentThreadName;</span></div><div class="token-line"><span class="token plain">            }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">            @Override</span></div><div class="token-line"><span class="token plain">            public void run() {</span></div><div class="token-line"><span class="token plain">                System.out.println(&quot;parent:&quot;+parentThreadName+&quot;:&quot;+INHERITABLE_THREAD_LOCAL.get());</span></div><div class="token-line"><span class="token plain">            }</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>运行结果如下：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">Thread-1:0</span></div><div class="token-line"><span class="token plain">    Thread-3:2</span></div><div class="token-line"><span class="token plain">    Thread-2:1</span></div><div class="token-line"><span class="token plain">    Thread-4:3</span></div><div class="token-line"><span class="token plain">    Thread-5:4</span></div><div class="token-line"><span class="token plain">    Thread-6:5</span></div><div class="token-line"><span class="token plain">    Thread-7:6</span></div><div class="token-line"><span class="token plain">    Thread-8:7</span></div><div class="token-line"><span class="token plain">    Thread-9:8</span></div><div class="token-line"><span class="token plain">    Thread-10:9</span></div><div class="token-line"><span class="token plain">    parent:Thread-5:4</span></div><div class="token-line"><span class="token plain">    parent:Thread-2:1</span></div><div class="token-line"><span class="token plain">    parent:Thread-6:5</span></div><div class="token-line"><span class="token plain">    parent:Thread-10:9</span></div><div class="token-line"><span class="token plain">    parent:Thread-8:7</span></div><div class="token-line"><span class="token plain">    parent:Thread-1:0</span></div><div class="token-line"><span class="token plain">    parent:Thread-7:6</span></div><div class="token-line"><span class="token plain">    parent:Thread-3:2</span></div><div class="token-line"><span class="token plain">    parent:Thread-9:8</span></div><div class="token-line"><span class="token plain">    parent:Thread-4:3</span></div></pre></div><p>我们可以看到，子线程中输出的内容和父线程一致，<strong>没有出现线程变量复制混乱的情况</strong>。</p><p>通过刚才的学习，我们能够知道，在跨线程间透传的场景下，使用 ThreadLocal 库友好地解决了线程专属变量的问题，但是它还不能真正解决父子线程值传递丢失的问题，于是 JDK 又引入了 InheritableThreadLocal 对象。然后呢，这又引出了下一个问题，那就是涉及到线程池等复用线程场景时，还是会存在变量复制混乱的缺陷。我们的解决方案是，在全链路压测标记透传改造方案中直接引入 TransmittableThreadLocal 来增强 InheritableThreadLocal 对象。</p><p>虽然跨线程间透传的过程有点复杂，我们也看到了，问题一个接着一个，但这些问题都被我们很好地解决了。压测标识在跨线程的情况下始终保持不丢失，我们的目的就达到了。</p><h2 id="跨服务间的透传"><a aria-hidden="true" tabindex="-1" href="/blog/全链路压测实战30讲/03.实践需求/11#跨服务间的透传"><span class="icon icon-link"></span></a>跨服务间的透传</h2><p>好了，讲完了跨线程间的透传，我们再来看下跨服务间的透传有哪些可供选择的方案。</p><p>跨服务透传的方案有很多，其中，基于 HTTP 请求的数据传递类型主要有两种：一、作为参数传递；二、作为 Header 传递。</p><p>而作为 Header 传递的类型，细分下来大概有下面这四种方案：</p><ul><li>放入 HttpRequest Header</li><li>改造 TraceId</li><li>使用字节码增强技术</li><li>使用 Sleuth Baggage</li></ul><p>下面，我们就来仔细说一说这几种方案。</p><h4 id="方案一作为接口参数"><a aria-hidden="true" tabindex="-1" href="/blog/全链路压测实战30讲/03.实践需求/11#方案一作为接口参数"><span class="icon icon-link"></span></a>方案一：作为接口参数</h4><p>实现思路就是把压测标记追加到接口参数里面。这样做的优点是思路比较简单，开发改起来也没有学习的成本。但缺点还是比较明显的：对业务侵入性强，代码高度耦合，后续维护会有一定困难，如果我们想要增加一个参数，那么所有的接口都需要跟着改动，工作量很大。</p><h4 id="方案二放入-httprequest-header"><a aria-hidden="true" tabindex="-1" href="/blog/全链路压测实战30讲/03.实践需求/11#方案二放入-httprequest-header"><span class="icon icon-link"></span></a>方案二：放入 HttpRequest Header</h4><p>我们都知道现在的微服务结构大部分情况下都是通过 HTTP 调用的，所以说， HTTP Header 好像天生就是做标记透传载体的料。</p><p>一般我们的实现思路是：先自定义一个 Filter，获取 Request 中自定义的 request header。然后将这些信息放入 ThreadLocal 中。最后实现 feign.Client(暂时忽略 RestTemplate)的 execute() 方法，在调用下级服务前把标记塞入 Request 的 Header 中。</p><p>我们可以通过 Spring 提供的方法从任意地方获取 HttpServletRequest 里的 Header，当然了，因为我们使用了ThreadLocal，所以上述操作要保证在同一线程中。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">ServletRequestAttributes requestAttributes = (ServletRequestAttributes) RequestContextHolder</span></div><div class="token-line"><span class="token plain">                    .getRequestAttributes();</span></div><div class="token-line"><span class="token plain">            HttpServletRequest request = requestAttributes.getRequest();</span></div><div class="token-line"><span class="token plain">            //获取头标记</span></div><div class="token-line"><span class="token plain">            String header = request.getHeader(&quot;headerKey&quot;);</span></div></pre></div><p>这种方式的优点是显而易见的，因为它对业务是透明的。</p><p>但缺点也比较多，比如链路中有父子线程的话，我们就没有办法从 RequestContextHolder 中拿到标记信息了。同时， Request Header 和 HTTP 是绑定的，就算大部分业务都在用 HTTP 协议进行交互，总还是有些应用会使用 TCP 协议的 RPC 框架，比方说 Thrift、Dubbo等，这时候，这个方案就不适用了。</p><p>除此之外，还有许多应用间使用消息队列来做异步任务的情况，它们也希望做到标记透传。另外，大多数情况下，利用这个方案我们只能对 Request Header 做取得操作，而不能对 HttpServletRequest 进行修改。</p><p>所以说，如果使用这个方案的话，这些问题都需要考虑到，做到根据项目的实际需求灵活选择，切不可蒙头转向干活，到最后发现方案满足不了要求又推翻返工。</p><h4 id="方案三改造-traceid"><a aria-hidden="true" tabindex="-1" href="/blog/全链路压测实战30讲/03.实践需求/11#方案三改造-traceid"><span class="icon icon-link"></span></a>方案三：改造 TraceId</h4><p>分布式系统中的服务调用链路追踪在理论上并不复杂，它有两个关键点，一个是为请求链路创建唯一的追踪标识，二是统计各个处理单元的延迟时间。</p><p>主要实现原理如下图：</p><p><img src="https://static001.geekbang.org/resource/image/75/4a/7528e659e35788cf6f257bb8993aba4a.png?wh=970x536" alt="图片"/></p><p>在<a target="_blank" rel="noopener noreferrer" href="https://docs.spring.io/spring-cloud-sleuth/docs/2.2.8.RELEASE/reference/html/#propagating-extra-fields">这张图<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>中，每个颜色的注解表明一个 Span(总计 7 个 Span，从 A 到 G )，如果注解显示：Trace Id = X；Span Id = D；Client Sent。这就表明当前 Span 将 Trace Id 设置为了 X，将 Span Id 设置为了 D，同时它还表明了 Client Sent（客户端发起一个请求）事件。</p><p>我们将这些 Span 的关系（Parent/Child）图形化：</p><p><img src="https://static001.geekbang.org/resource/image/05/b0/05ca7dacd2e73005c08a84bb4e26dbb0.png?wh=716x247" alt="图片"/></p><p>从这张图中我们可以看到，一次链路调用 TraceId 作为唯一的请求 ID，而 Span 标识了各节点发起的请求信息，最后各个子 Span 通过 Parent Id 与父 Span 关联起来。</p><p>那么 Sleuth 在服务内部是如何对TraceId进行处理的呢？</p><p>下面是一个使用多 Header 的 HTTP 请求传递流程图:</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">Client Tracer                                                  Server Tracer     </span></div><div class="token-line"><span class="token plain">    ┌───────────────────────┐                                       ┌───────────────────────┐</span></div><div class="token-line"><span class="token plain">    │                       │                                       │                       │</span></div><div class="token-line"><span class="token plain">    │   TraceContext        │          Http Request Headers         │   TraceContext        │</span></div><div class="token-line"><span class="token plain">    │ ┌───────────────────┐ │         ┌───────────────────┐         │ ┌───────────────────┐ │</span></div><div class="token-line"><span class="token plain">    │ │ TraceId           │ │         │ X-B3-TraceId      │         │ │ TraceId           │ │</span></div><div class="token-line"><span class="token plain">    │ │                   │ │         │                   │         │ │                   │ │</span></div><div class="token-line"><span class="token plain">    │ │ ParentSpanId      │ │ Inject  │ X-B3-ParentSpanId │ Extract │ │ ParentSpanId      │ │</span></div><div class="token-line"><span class="token plain">    │ │                   ├─┼────────&gt;│                   ├─────────┼&gt;│                   │ │</span></div><div class="token-line"><span class="token plain">    │ │ SpanId            │ │         │ X-B3-SpanId       │         │ │ SpanId            │ │</span></div><div class="token-line"><span class="token plain">    │ │                   │ │         │                   │         │ │                   │ │</span></div><div class="token-line"><span class="token plain">    │ │ Sampling decision │ │         │ X-B3-Sampled      │         │ │ Sampling decision │ │</span></div><div class="token-line"><span class="token plain">    │ └───────────────────┘ │         └───────────────────┘         │ └───────────────────┘ │</span></div><div class="token-line"><span class="token plain">    │                       │                                       │                       │</span></div><div class="token-line"><span class="token plain">    └───────────────────────┘                                       └───────────────────────┘</span></div></pre></div><p>在这张图中，Sleuth 通过 Filter 对 Header 进行处理，先检测 Header 中是否存在 “X-B3-TraceId” 标识，如果存在就传入新的 TraceId，如果不存在就生成新的值。</p><p>我们再来看下，在跨服务过程中 Sleuth 具体是如何处理 TraceId 的？</p><p>首先网关接收请求后，TraceWebFilterr 中将 TraceId 添加到 Header 中，以便所转发的请求对应的服务能从头中获取到 Header。同时网关还将 TraceId 放到 MDC (Mapped Diagnostic Context)中，以便应用在输出日志时携带 TraceId。</p><p>然后，服务在 execute 请求前，Sleuth 将 TraceId 存放到 X-B3-TraceId 头中来实现 Feign.Client（具体参见 <a target="_blank" rel="noopener noreferrer" href="https://github.com/vaquarkhan/spring-cloud-sleuth-Zipkins/blob/master/spring-cloud-sleuth-core/src/main/java/org/springframework/cloud/sleuth/instrument/web/client/feign/TraceFeignClient.java">TraceFeignClient<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> ），具体的步骤是：</p><ul><li>用 Sleuth 创建 TraceFilter，对所有的网络请求进行拦截，如果请求的 Header 中没有 Span 信息，那就创建 Span 对象，生成 Span id、Trace id 等。如果 Header 中有Span信息，就直接使用 Header 中的数据创建 Span 对象，之后将 Span id、Trace id 设置到 MDC 中。</li><li>当使用 RestTemplate 发送请求时，RestTemplate 和 Interceptor Injector 会拦截请求。我们可以将新生成的 Span id、Trace id 等信息设置到请求的 Header 中，这样服务端收到请求后就可以从 Header 中解析出 Span 信息了。</li></ul><p>其他场景的执行原理都是差不多的，这里就不多介绍了 。</p><p>我们看到，微服务调用链框架 <a target="_blank" rel="noopener noreferrer" href="https://github.com/spring-cloud/spring-cloud-sleuth.git">Sleuth<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 的核心功能就是跨服务追踪调用全过程，它原生就可以对Traceld进行标记、识别并传递。所以，我们可以复用 Sleuth 的相关功能同时顺带修改 Sleuth 源码，将 TraceId 识别并改造后一起往下游服务透传。</p><p>讲完了原理，我们再来看下具体如何改造 TraceId。首先我们需要了解下 TraceId 的组成结构。</p><p>比如下面这个示例。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">X-B3-TraceId: 80f198ee56343ba864fe8b2a57d3eff7</span></div><div class="token-line"><span class="token plain">    X-B3-ParentSpanId: 05e3ac9a4f6e3b90</span></div><div class="token-line"><span class="token plain">    X-B3-SpanId: e457b5a2e4d86bd1</span></div><div class="token-line"><span class="token plain">    X-B3-Sampled: 1</span></div></pre></div><p>可以看到，在 Header 中有 4 个属性：</p><ul><li>X-B3-SpanId：一次链路调用唯一 ID（可以是 RPC，DB 等，没有特定的限制）；</li><li>X-B3-ParentSpanId：上层服务的调用 Span_ID，最上层服务 Parent_ID 为 null；</li><li>X-B3-TraceId：用于标示一次完整且唯一的请求 ID，一般为 64 位或 128 位的数字；</li><li>X-B3-Sampled：是否被抽样为输出的标志，1 为需要被输出，0 为不需要被输出。</li></ul><p>所以，做 TraceId 改造我们可以这样考虑，如果是正常标记，则是以 1 开头，后面全为零。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">“b3”、“1000000000000000e457b5a2e4d86bd1-e457b5a2e4d86bd1”</span></div></pre></div><p>如果是压测标记，那就全部是以 2 开头，后面全为零。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">“b3”、“2000000000000000e457b5a2e4d86bd1-e457b5a2e4d86bd1”</span></div></pre></div><p>你可以使用符合 TraceId 格式的数字，只要有效就可以了。<br/>到这里，我们已经解决了获取标记的技术问题，通常的做法就是实现一个 Filter 就行了，而后面就是重写 TraceId 并传递给下游服务。</p><p>在 Sleuth 2.2中， 我们可以这样实现：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">@Bean </span></div><div class="token-line"><span class="token plain">    ExtraFieldPropagation.Factory customPropagationFactory() {</span></div><div class="token-line"><span class="token plain">      return ExtraFieldPropagation.newFactory(</span></div><div class="token-line"><span class="token plain">          CustomTraceIdPropagation.create(B3Propagation.FACTORY, &quot;my_trace_id&quot;));</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>在 Sleuth 3.0中， 我们可以这样实现：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">@Bean </span></div><div class="token-line"><span class="token plain">    BaggagePropagation.Factory customPropagationFactory() {</span></div><div class="token-line"><span class="token plain">      return BaggagePropagation.newFactory(</span></div><div class="token-line"><span class="token plain">          CustomTraceIdPropagation.create(B3Propagation.FACTORY, &quot;my_trace_id&quot;));</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>这种方式的优点是原理比较简单，不用考虑底层实现，也不用考虑兼容性等问题，因为 Sleuth 都已经实现好了，实现起来比较快。<br/>但是实际上，TraceId 加零是一个坏主意，因为它跟正常 TraceId 没有明显区别，还有可能会随机出现重复的情况。另外，后期维护也很困难，我们很容易忘了以前修改了哪些地方，移交给别人维护就更加困难了。而且程序升级也比较困难，以后每次 Spring 或者 Sleuth 要升级的时候，都要重新修改源码。</p><p>最后，我们放弃了这个方案，主要的原因就是可能会影响现有的正常 TraceId，对我们来说并不是性价比最高的选择。</p><h4 id="方案四使用字节码增强技术"><a aria-hidden="true" tabindex="-1" href="/blog/全链路压测实战30讲/03.实践需求/11#方案四使用字节码增强技术"><span class="icon icon-link"></span></a>方案四：使用字节码增强技术</h4><p>Java 还有一种基于字节码增强技术的埋点方式，就是依赖 Java Agent 技术在目标程序启动时加上 -javaagent 参数，或者运行时 attach 进程，两种做法都可以做到将对应的 SDK 注入到目标应用，完成埋点。它们整体来说对服务应用是透明的，对业务代码无侵入。</p><p>关于字节码的基础知识你可以参考美团的<a target="_blank" rel="noopener noreferrer" href="https://tech.meituan.com/2019/09/05/java-bytecode-enhancement.html">《字节码增强技术探索》<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>这篇文章，已经讲得很清楚了，我就不多赘述了。</p><p>在项目具体落地的过程中，我们可以考虑在框架或中间件层做统一的 SDK Jar 包托管，将 SDK 包直接打入 Base 镜像内，然后，借助 Jar 包容器提供的入口，将封装好的 TransmittableThreadLocal SDK 在应用启动之前完成埋点工作，这样的话，就能够实现应用无感知透传了。</p><p>整个 SDK 带起过程你可以参考这张<a target="_blank" rel="noopener noreferrer" href="https://www.infoq.cn/article/z503AvLZyA0SXJCkY61o">示意图<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>。</p><p><img src="https://static001.geekbang.org/resource/image/f9/20/f90c9473584fd8f4a0ba51b0402byy20.png?wh=1080x777" alt="图片"/></p><p>这样做的优点是，对业务代码无侵入，可以做到用户无感的热升级；缺点是对开发人员要求比较高，开发成本也比较高，同时，SDK 引入可能还会遇到包冲突等问题。</p><p>在实践方面更加具体的例子你可以参考这篇文章：<a target="_blank" rel="noopener noreferrer" href="https://mp.weixin.qq.com/s/gf8-2DXSNLJ5lhFv7bmN6Q">《JVM 字节码增强技术之 Java Agent 入门》。<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p><h4 id="方案五使用-sleuth-baggage"><a aria-hidden="true" tabindex="-1" href="/blog/全链路压测实战30讲/03.实践需求/11#方案五使用-sleuth-baggage"><span class="icon icon-link"></span></a>方案五：使用 Sleuth Baggage</h4><p>既然我们可以在程序里获取到 Trace 和 Span 相关信息，那为什么不把信息直接放到 Span 里呢？在 Span 中能放点额外信息，这样就不用自己实现了。事实上，只要 Sleuth 里有 Baggage ，我们确实可以这样做。</p><p>Baggage 是一组存储在 Span Context（上下文）中的 key:value（键值对）。Baggage 和 Trace 一起传递并附加在每个 Span 上。Spring Cloud Sleuth 可以识别以 Baggage 为前缀的 Header，消息传递以 baggage_ 开始。</p><p>需要注意的是，Baggage 的数据和大小没有明显的限制，但是太多会拖慢整个系统的性能。</p><p>Baggage 跟随 Trace 一起传递(每个子 Span 都包含父 Span 的 Baggage)。默认情况下，因为 Zipkin 不知道 Baggage，所以也不接收这些信息。</p><p>需要注意的是，从 Sleuth 2.0.0 开始，我们就必须在项目配置中明确传递 baggage keys 的名称了。Tags 会附加到指定的 Span，也就是该标签只在指定的 Span 中呈现。但是，如果包含 Tag 的 Span 存在，我们可以根据 Tag 搜索对应的 Trace。所以说，你如果希望通过 Baggage 查找 Span ，就应该在 root span 中添加相应的 Tag。</p><p>比如下面这个例子。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">spring.sleuth.baggage-keys=baz,bizarrecase</span></div><div class="token-line"><span class="token plain">    spring.sleuth.propagation-keys=foo,upper_case</span></div><div class="token-line"><span class="token plain">    initialSpan.tag(&quot;foo&quot;,ExtraFieldPropagation.get(initialSpan.context(), &quot;foo&quot;));</span></div><div class="token-line"><span class="token plain">    initialSpan.tag(&quot;UPPER_CASE&quot;,ExtraFieldPropagation.get(initialSpan.context(), &quot;UPPER_CASE&quot;));</span></div></pre></div><p>这里有关 Baggage 的配置，还有几点需要说明：</p><ul><li>我们在使用 spring.sleuth.baggage-keys 时，可以设置以 baggage-为前缀的键，用于 HTTP 调用和 baggage- 的消息传递。</li><li>还可以使用该 spring.sleuth.propagation-keys 属性传递带前缀的键列表，这些键被传播到远程服务而没有任何前缀。</li><li>另外，还可以使用该 spring.sleuth.local-keys 属性来传递将在本地服务传播但不会通过网络传播的列表键。</li></ul><p>使用 Sleuth Baggage 的优点是它很容易实现，而且也支持 RestTemplate 的调用，同时它还原生就兼容其他的 SpringCloud 组件。但它也存在和 Sleuth 一样的缺点，也就是对业务代码有侵入性、维护有些困难，而且程序升级后都要重新修改源码。注意哦，Sleuth 底层使用的是 ThreadLocal，后续在跨线程透传方面我们还是需要单独做增强处理的。</p><h2 id="总结"><a aria-hidden="true" tabindex="-1" href="/blog/全链路压测实战30讲/03.实践需求/11#总结"><span class="icon icon-link"></span></a>总结</h2><p>好了，这节课就讲到这里。我们刚才一起梳理了标记透传的背景、目标和几种常见的方案，这里我们做个总结。</p><p>从标记透传的对象来说，我们主要可以分为两个方面，也就是跨线程间的透传和跨服务间的透传。</p><p>跨线程透传主要解决的是线程间的变量复制传递的问题，比如父子线程、线程池复用等场景，最后我们看到 TransmittableThreadLocal （TTL）是 Java 语言一个比较优雅且通用的解决方案。</p><p>而跨服务透传主要的方式就是参数传递和 Header 传递，在 Header 传递方案内，有诸如 HttpRequest Header、改造 TraceId、Java Agent、Sleuth Baggage等技术方案，它们都各有特点，各有用场。你可以看看我给你画的这张思维导图，上面有非常详细的概述和总结，希望对你有帮助。</p><p><img src="https://static001.geekbang.org/resource/image/4a/d6/4a68c7365ab94b8c2509fed93160b5d6.jpg?wh=1920x3103" alt="图片"/></p><p>最后，需要强调是，在做具体标记透传技术选型时，我们还是要根据自身项目特点，仔细衡量各各项指标，选择一款适合自己项目的技术方案，技术过于纯粹，适用才是王道。</p><p>下一节课，我们进入实践环节，我会通过案例给你演示如何实现标记透传改造。</p><h2 id="思考题"><a aria-hidden="true" tabindex="-1" href="/blog/全链路压测实战30讲/03.实践需求/11#思考题"><span class="icon icon-link"></span></a>思考题</h2><p>在课程的最后，我还是照例给你留两道思考题：</p><ol><li>除了我上面列出的这些技术方案，你还接触过哪些？</li><li>如果是异构系统，说说你对技术方案选型的考虑？</li></ol><p>欢迎你在留言区和我交流讨论，我们下节课见！</p></div><div class="__dumi-default-layout-footer-meta"><a target="_blank" rel="noopener noreferrer" href="https://github.com/GGwujun/blog/edit/master/docs/全链路压测实战30讲/03.实践需求/11.md">在 GitHub 上编辑此页<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a><span data-updated-text="最后更新时间：">5/2/2022 10:57:03</span></div></div></div></div>
	<script>
  window.g_useSSR = true;
  window.g_initialProps = {};
	</script>

    <script>
      (function () {
        if (!location.port) {
          (function (i, s, o, g, r, a, m) {
            i["GoogleAnalyticsObject"] = r;
            (i[r] =
              i[r] ||
              function () {
                (i[r].q = i[r].q || []).push(arguments);
              }),
              (i[r].l = 1 * new Date());
            (a = s.createElement(o)), (m = s.getElementsByTagName(o)[0]);
            a.async = 1;
            a.src = g;
            m.parentNode.insertBefore(a, m);
          })(
            window,
            document,
            "script",
            "//www.google-analytics.com/analytics.js",
            "ga"
          );
          ga("create", "UA-149864185-1", "auto");
          ga("send", "pageview");
        }
      })();
    </script>
    <script src="/blog/umi.js"></script>
  </body>
</html>
