<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no"
    />
    <link rel="shortcut icon" type="image/x-icon" href="/logo.png" />
    <link rel="stylesheet" href="/blog/umi.css" />
    <script>
      window.routerBase = "/blog";
    </script>
    <script>
      //! umi version: 3.5.17
    </script>
    <script>
      !(function () {
        var e = localStorage.getItem("dumi:prefers-color"),
          t = window.matchMedia("(prefers-color-scheme: dark)").matches,
          r = ["light", "dark", "auto"];
        document.documentElement.setAttribute(
          "data-prefers-color",
          e === r[2] ? (t ? r[1] : r[0]) : r.indexOf(e) > -1 ? e : r[0]
        );
      })();
    </script>
    <title>01 | V8是如何执行一段JavaScript代码的？</title>
  </head>
  <body>
    <div id="root"><div class="__dumi-default-layout" data-route="/图解googlev8/01.宏观视角/02" data-show-sidemenu="true" data-show-slugs="true" data-site-mode="true" data-gapless="false"><div class="__dumi-default-navbar" data-mode="site"><button class="__dumi-default-navbar-toggle"></button><a class="__dumi-default-navbar-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog/">大师兄</a><nav><div class="__dumi-default-search"><input type="search" class="__dumi-default-search-input" value=""/><ul></ul></div><span>计算机基础<ul><li><a href="/blog/编译原理之美">编译原理之美</a></li><li><a href="/blog/编译原理实战">编译原理实战</a></li><li><a href="/blog/深入浅出计算机组成原理">深入浅出计算机组成原理</a></li><li><a href="/blog/详解http">详解http</a></li><li><a href="/blog/计算机网络通关29讲">计算机网络通关29讲</a></li><li><a href="/blog/网络排查案例课">网络排查案例课</a></li><li><a href="/blog/linux操作系统">linux操作系统</a></li><li><a href="/blog/linux性能优化实战">linux性能优化实战</a></li><li><a href="/blog/程序员数学基础">程序员数学基础</a></li><li><a href="/blog/趣谈网络协议">趣谈网络协议</a></li><li><a href="/blog/操作系统实战">操作系统实战</a></li><li><a href="/blog/软件工程之美">软件工程之美</a></li><li><a href="/blog/sql必知必会">sql必知必会</a></li><li><a href="/blog/操作系统实战45讲">操作系统实战45讲</a></li><li><a href="/blog/网络编程实战">网络编程实战</a></li></ul></span><span>算法<ul><li><a href="/blog/常用算法25讲">常用算法25讲</a></li><li><a href="/blog/数据结构与算法之美">数据结构与算法之美</a></li><li><a href="/blog/业务开发算法50讲">业务开发算法50讲</a></li><li><a href="/blog/动态规划面试宝典">动态规划面试宝典</a></li></ul></span><span>前端开发<ul><li><a href="/blog/浏览器工作原理与实践">浏览器工作原理与实践</a></li><li><a href="/blog/新时代产品经理进阶之路">新时代产品经理进阶之路</a></li><li><a href="/blog/全栈工程师修炼指南">全栈工程师修炼指南</a></li><li><a href="/blog/flutter核心技术与实战">flutter核心技术与实战</a></li><li><a href="/blog/java-script核心原理解析">java-script核心原理解析</a></li><li><a href="/blog/说透低代码">说透低代码</a></li><li><a href="/blog/nodejs应用开发实战">nodejs应用开发实战</a></li><li><a href="/blog/反爬虫兵法演绎20讲">反爬虫兵法演绎20讲</a></li><li><a href="/blog/reactnative新架构实战课">reactnative新架构实战课</a></li><li><a href="/blog/正则表达式入门">正则表达式入门</a></li><li><a href="/blog/重学前端">重学前端</a></li><li><a href="/blog/serverless入门课">serverless入门课</a></li><li><a href="/blog/type-script入门实战笔记">type-script入门实战笔记</a></li><li><a aria-current="page" class="active" href="/blog/图解googlev8">图解googlev8</a></li><li><a href="/blog/vue3源码分析">vue3源码分析</a></li><li><a href="/blog/玩转Vue3全家桶">玩转Vue3全家桶</a></li><li><a href="/blog/webassembly入门">webassembly入门</a></li><li><a href="/blog/手把手带你写一个Web框架">手把手带你写一个Web框架</a></li><li><a href="/blog/web漏洞挖掘实战">web漏洞挖掘实战</a></li><li><a href="/blog/跟月影学可视化">跟月影学可视化</a></li><li><a href="/blog/搞定音频技术">搞定音频技术</a></li><li><a href="/blog/攻克视频技术">攻克视频技术</a></li></ul></span><span>前端工程化<ul><li><a href="/blog/logger">logger</a></li><li><a href="/blog/webpack">webpack</a></li><li><a href="/blog/webpackChain">webpackChain</a></li></ul></span><span>前端性能优化<ul><li><a href="/blog/react性能调优">react性能调优</a></li></ul></span><span>软件测试<ul><li><a href="/blog/全链路压测实战30讲">全链路压测实战30讲</a></li><li><a href="/blog/性能测试实战30讲">性能测试实战30讲</a></li><li><a href="/blog/自动化测试高手课">自动化测试高手课</a></li><li><a href="/blog/软件测试52讲">软件测试52讲</a></li></ul></span><span>面试<ul><li><a href="/blog/面试现场">面试现场</a></li></ul></span><span>杂谈<ul><li><a href="/blog/超级访谈对话张雪峰">超级访谈对话张雪峰</a></li><li><a href="/blog/Git实战手册">Git实战手册</a></li><li><a href="/blog/NodeJS">NodeJS</a></li><li><a href="/blog/ReactJS">ReactJS</a></li><li><a href="/blog/UI设计">UI设计</a></li><li><a href="/blog/webpack4系列教程">webpack4系列教程</a></li><li><a href="/blog/前端知识体系">前端知识体系</a></li><li><a href="/blog/剑指offer刷题笔记">剑指offer刷题笔记</a></li><li><a href="/blog/思考与成长">思考与成长</a></li><li><a href="/blog/设计模式手册">设计模式手册</a></li></ul></span><div class="__dumi-default-navbar-tool"><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "></div></div></div></nav></div><div class="__dumi-default-menu" data-mode="site"><div class="__dumi-default-menu-inner"><div class="__dumi-default-menu-header"><a class="__dumi-default-menu-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog/"></a><h1>大师兄</h1><p></p></div><div class="__dumi-default-menu-mobile-area"><ul class="__dumi-default-menu-nav-list"><li>计算机基础<ul><li><a href="/blog/编译原理之美">编译原理之美</a></li><li><a href="/blog/编译原理实战">编译原理实战</a></li><li><a href="/blog/深入浅出计算机组成原理">深入浅出计算机组成原理</a></li><li><a href="/blog/详解http">详解http</a></li><li><a href="/blog/计算机网络通关29讲">计算机网络通关29讲</a></li><li><a href="/blog/网络排查案例课">网络排查案例课</a></li><li><a href="/blog/linux操作系统">linux操作系统</a></li><li><a href="/blog/linux性能优化实战">linux性能优化实战</a></li><li><a href="/blog/程序员数学基础">程序员数学基础</a></li><li><a href="/blog/趣谈网络协议">趣谈网络协议</a></li><li><a href="/blog/操作系统实战">操作系统实战</a></li><li><a href="/blog/软件工程之美">软件工程之美</a></li><li><a href="/blog/sql必知必会">sql必知必会</a></li><li><a href="/blog/操作系统实战45讲">操作系统实战45讲</a></li><li><a href="/blog/网络编程实战">网络编程实战</a></li></ul></li><li>算法<ul><li><a href="/blog/常用算法25讲">常用算法25讲</a></li><li><a href="/blog/数据结构与算法之美">数据结构与算法之美</a></li><li><a href="/blog/业务开发算法50讲">业务开发算法50讲</a></li><li><a href="/blog/动态规划面试宝典">动态规划面试宝典</a></li></ul></li><li>前端开发<ul><li><a href="/blog/浏览器工作原理与实践">浏览器工作原理与实践</a></li><li><a href="/blog/新时代产品经理进阶之路">新时代产品经理进阶之路</a></li><li><a href="/blog/全栈工程师修炼指南">全栈工程师修炼指南</a></li><li><a href="/blog/flutter核心技术与实战">flutter核心技术与实战</a></li><li><a href="/blog/java-script核心原理解析">java-script核心原理解析</a></li><li><a href="/blog/说透低代码">说透低代码</a></li><li><a href="/blog/nodejs应用开发实战">nodejs应用开发实战</a></li><li><a href="/blog/反爬虫兵法演绎20讲">反爬虫兵法演绎20讲</a></li><li><a href="/blog/reactnative新架构实战课">reactnative新架构实战课</a></li><li><a href="/blog/正则表达式入门">正则表达式入门</a></li><li><a href="/blog/重学前端">重学前端</a></li><li><a href="/blog/serverless入门课">serverless入门课</a></li><li><a href="/blog/type-script入门实战笔记">type-script入门实战笔记</a></li><li><a aria-current="page" class="active" href="/blog/图解googlev8">图解googlev8</a></li><li><a href="/blog/vue3源码分析">vue3源码分析</a></li><li><a href="/blog/玩转Vue3全家桶">玩转Vue3全家桶</a></li><li><a href="/blog/webassembly入门">webassembly入门</a></li><li><a href="/blog/手把手带你写一个Web框架">手把手带你写一个Web框架</a></li><li><a href="/blog/web漏洞挖掘实战">web漏洞挖掘实战</a></li><li><a href="/blog/跟月影学可视化">跟月影学可视化</a></li><li><a href="/blog/搞定音频技术">搞定音频技术</a></li><li><a href="/blog/攻克视频技术">攻克视频技术</a></li></ul></li><li>前端工程化<ul><li><a href="/blog/logger">logger</a></li><li><a href="/blog/webpack">webpack</a></li><li><a href="/blog/webpackChain">webpackChain</a></li></ul></li><li>前端性能优化<ul><li><a href="/blog/react性能调优">react性能调优</a></li></ul></li><li>软件测试<ul><li><a href="/blog/全链路压测实战30讲">全链路压测实战30讲</a></li><li><a href="/blog/性能测试实战30讲">性能测试实战30讲</a></li><li><a href="/blog/自动化测试高手课">自动化测试高手课</a></li><li><a href="/blog/软件测试52讲">软件测试52讲</a></li></ul></li><li>面试<ul><li><a href="/blog/面试现场">面试现场</a></li></ul></li><li>杂谈<ul><li><a href="/blog/超级访谈对话张雪峰">超级访谈对话张雪峰</a></li><li><a href="/blog/Git实战手册">Git实战手册</a></li><li><a href="/blog/NodeJS">NodeJS</a></li><li><a href="/blog/ReactJS">ReactJS</a></li><li><a href="/blog/UI设计">UI设计</a></li><li><a href="/blog/webpack4系列教程">webpack4系列教程</a></li><li><a href="/blog/前端知识体系">前端知识体系</a></li><li><a href="/blog/剑指offer刷题笔记">剑指offer刷题笔记</a></li><li><a href="/blog/思考与成长">思考与成长</a></li><li><a href="/blog/设计模式手册">设计模式手册</a></li></ul></li></ul><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "><button title="Dark theme" class="__dumi-default-dark-moon "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="3854" width="22" height="22"><path d="M991.816611 674.909091a69.166545 69.166545 0 0 0-51.665455-23.272727 70.795636 70.795636 0 0 0-27.438545 5.585454A415.674182 415.674182 0 0 1 754.993338 698.181818c-209.594182 0-393.472-184.785455-393.472-395.636363 0-52.363636 38.539636-119.621818 69.515637-173.614546 4.887273-8.610909 9.634909-16.756364 14.103272-24.901818A69.818182 69.818182 0 0 0 384.631156 0a70.842182 70.842182 0 0 0-27.438545 5.585455C161.678429 90.298182 14.362065 307.898182 14.362065 512c0 282.298182 238.824727 512 532.38691 512a522.286545 522.286545 0 0 0 453.957818-268.334545A69.818182 69.818182 0 0 0 991.816611 674.909091zM546.679156 954.181818c-248.785455 0-462.941091-192-462.941091-442.181818 0-186.647273 140.637091-372.829091 300.939637-442.181818-36.817455 65.629091-92.578909 151.970909-92.578909 232.727273 0 250.181818 214.109091 465.454545 462.917818 465.454545a488.331636 488.331636 0 0 0 185.181091-46.545455 453.003636 453.003636 0 0 1-393.565091 232.727273z m103.656728-669.323636l-14.266182 83.781818a34.909091 34.909091 0 0 0 50.362182 36.770909l74.775272-39.563636 74.752 39.563636a36.142545 36.142545 0 0 0 16.174546 3.956364 34.909091 34.909091 0 0 0 34.210909-40.727273l-14.289455-83.781818 60.509091-59.345455a35.025455 35.025455 0 0 0-19.223272-59.578182l-83.61891-12.101818-37.376-76.101818a34.56 34.56 0 0 0-62.254545 0l-37.376 76.101818-83.618909 12.101818a34.909091 34.909091 0 0 0-19.246546 59.578182z m70.423272-64.698182a34.280727 34.280727 0 0 0 26.135273-19.083636l14.312727-29.090909 14.336 29.090909a34.257455 34.257455 0 0 0 26.135273 19.083636l32.046546 4.887273-23.272728 22.574545a35.234909 35.234909 0 0 0-10.007272 30.952727l5.46909 32.116364-28.625454-15.127273a34.490182 34.490182 0 0 0-32.302546 0l-28.695272 15.127273 5.469091-32.116364a35.141818 35.141818 0 0 0-9.984-30.952727l-23.272728-22.574545z" p-id="3855"></path></svg></button><button title="Light theme" class="__dumi-default-dark-sun "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="4026" width="22" height="22"><path d="M915.2 476.16h-43.968c-24.704 0-44.736 16-44.736 35.84s20.032 35.904 44.736 35.904H915.2c24.768 0 44.8-16.064 44.8-35.904s-20.032-35.84-44.8-35.84zM512 265.6c-136.704 0-246.464 109.824-246.464 246.4 0 136.704 109.76 246.464 246.464 246.464S758.4 648.704 758.4 512c0-136.576-109.696-246.4-246.4-246.4z m0 425.6c-99.008 0-179.2-80.128-179.2-179.2 0-98.944 80.192-179.2 179.2-179.2S691.2 413.056 691.2 512c0 99.072-80.192 179.2-179.2 179.2zM197.44 512c0-19.84-19.136-35.84-43.904-35.84H108.8c-24.768 0-44.8 16-44.8 35.84s20.032 35.904 44.8 35.904h44.736c24.768 0 43.904-16.064 43.904-35.904zM512 198.464c19.776 0 35.84-20.032 35.84-44.8v-44.8C547.84 84.032 531.84 64 512 64s-35.904 20.032-35.904 44.8v44.8c0 24.768 16.128 44.864 35.904 44.864z m0 627.136c-19.776 0-35.904 20.032-35.904 44.8v44.736C476.096 940.032 492.16 960 512 960s35.84-20.032 35.84-44.8v-44.736c0-24.768-16.064-44.864-35.84-44.864z m329.92-592.832c17.472-17.536 20.288-43.072 6.4-57.024-14.016-14.016-39.488-11.2-57.024 6.336-4.736 4.864-26.496 26.496-31.36 31.36-17.472 17.472-20.288 43.008-6.336 57.024 13.952 14.016 39.488 11.2 57.024-6.336 4.8-4.864 26.496-26.56 31.296-31.36zM213.376 759.936c-4.864 4.8-26.56 26.624-31.36 31.36-17.472 17.472-20.288 42.944-6.4 56.96 14.016 13.952 39.552 11.2 57.024-6.336 4.8-4.736 26.56-26.496 31.36-31.36 17.472-17.472 20.288-43.008 6.336-56.96-14.016-13.952-39.552-11.072-56.96 6.336z m19.328-577.92c-17.536-17.536-43.008-20.352-57.024-6.336-14.08 14.016-11.136 39.488 6.336 57.024 4.864 4.864 26.496 26.56 31.36 31.424 17.536 17.408 43.008 20.288 56.96 6.336 14.016-14.016 11.264-39.488-6.336-57.024-4.736-4.864-26.496-26.56-31.296-31.424z m527.168 628.608c4.864 4.864 26.624 26.624 31.36 31.424 17.536 17.408 43.072 20.224 57.088 6.336 13.952-14.016 11.072-39.552-6.4-57.024-4.864-4.8-26.56-26.496-31.36-31.36-17.472-17.408-43.072-20.288-57.024-6.336-13.952 14.016-11.008 39.488 6.336 56.96z" p-id="4027"></path></svg></button><button title="Default to system" class="__dumi-default-dark-auto "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="11002" width="22" height="22"><path d="M127.658667 492.885333c0-51.882667 10.24-101.717333 30.378666-149.162666s47.786667-88.064 81.92-122.538667 75.093333-61.781333 122.538667-81.92 96.938667-30.378667 149.162667-30.378667 101.717333 10.24 149.162666 30.378667 88.405333 47.786667 122.88 81.92 61.781333 75.093333 81.92 122.538667 30.378667 96.938667 30.378667 149.162666-10.24 101.717333-30.378667 149.162667-47.786667 88.405333-81.92 122.88-75.093333 61.781333-122.88 81.92-97.28 30.378667-149.162666 30.378667-101.717333-10.24-149.162667-30.378667-88.064-47.786667-122.538667-81.92-61.781333-75.093333-81.92-122.88-30.378667-96.938667-30.378666-149.162667z m329.045333 0c0 130.048 13.994667 244.394667 41.984 343.381334h12.970667c46.762667 0 91.136-9.216 133.461333-27.306667s78.848-42.666667 109.568-73.386667 54.954667-67.242667 73.386667-109.568 27.306667-86.698667 27.306666-133.461333c0-46.421333-9.216-90.794667-27.306666-133.12s-42.666667-78.848-73.386667-109.568-67.242667-54.954667-109.568-73.386667-86.698667-27.306667-133.461333-27.306666h-11.605334c-28.672 123.562667-43.349333 237.909333-43.349333 343.722666z" p-id="11003"></path></svg></button></div></div></div><ul class="__dumi-default-menu-list"><li><a href="/blog/图解googlev8">图解googlev8</a></li><li><a aria-current="page" class="active" href="/blog/图解googlev8/01.宏观视角">01.宏观视角</a><ul><li><a href="/blog/图解googlev8/01.宏观视角/01"><span>开篇词 | 如何学习谷歌高性能 JavaScript 引擎V8？</span></a></li><li><a aria-current="page" class="active" href="/blog/图解googlev8/01.宏观视角/02"><span>01 | V8是如何执行一段JavaScript代码的？</span></a></li></ul></li><li><a href="/blog/图解googlev8/02.java-script设计思想篇">02.JavaScript设计思想篇</a><ul><li><a href="/blog/图解googlev8/02.java-script设计思想篇/01"><span>02 | 函数即对象：一篇文章彻底搞懂JavaScript的函数特点</span></a></li><li><a href="/blog/图解googlev8/02.java-script设计思想篇/02"><span>03 | 快属性和慢属性：V8是怎样提升对象属性访问速度的？</span></a></li><li><a href="/blog/图解googlev8/02.java-script设计思想篇/03"><span>04 | 函数表达式：涉及大量概念，函数表达式到底该怎么学？</span></a></li><li><a href="/blog/图解googlev8/02.java-script设计思想篇/04"><span>05｜原型链：V8是如何实现对象继承的？</span></a></li><li><a href="/blog/图解googlev8/02.java-script设计思想篇/05"><span>06｜作用域链：V8是如何查找变量的？</span></a></li><li><a href="/blog/图解googlev8/02.java-script设计思想篇/06"><span>07｜类型转换：V8是怎么实现1+“2”的？</span></a></li><li><a href="/blog/图解googlev8/02.java-script设计思想篇/07"><span>08｜答疑：如何构建和使用V8的调试工具d8？</span></a></li></ul></li><li><a href="/blog/图解googlev8/03.v8编译流水线">03.V8编译流水线</a><ul><li><a href="/blog/图解googlev8/03.v8编译流水线/01"><span>09 | 运行时环境：运行JavaScript代码的基石</span></a></li><li><a href="/blog/图解googlev8/03.v8编译流水线/02"><span>10 | 机器代码：二进制机器码究竟是如何被CPU执行的？</span></a></li><li><a href="/blog/图解googlev8/03.v8编译流水线/03"><span>11 | 堆和栈：函数调用是如何影响到内存布局的？</span></a></li><li><a href="/blog/图解googlev8/03.v8编译流水线/04"><span>12 | 延迟解析：V8是如何实现闭包的？</span></a></li><li><a href="/blog/图解googlev8/03.v8编译流水线/05"><span>13 | 字节码（一）：V8为什么又重新引入字节码？</span></a></li><li><a href="/blog/图解googlev8/03.v8编译流水线/06"><span>14｜字节码（二）：解释器是如何解释执行字节码的？</span></a></li><li><a href="/blog/图解googlev8/03.v8编译流水线/07"><span>15 | 隐藏类：如何在内存中快速查找对象属性？</span></a></li><li><a href="/blog/图解googlev8/03.v8编译流水线/08"><span>16 | 答疑： V8是怎么通过内联缓存来提升函数执行效率的？</span></a></li></ul></li><li><a href="/blog/图解googlev8/04.事件循环和垃圾回收">04.事件循环和垃圾回收</a><ul><li><a href="/blog/图解googlev8/04.事件循环和垃圾回收/01"><span>17 | 消息队列：V8是怎么实现回调函数的？</span></a></li><li><a href="/blog/图解googlev8/04.事件循环和垃圾回收/02"><span>18 | 异步编程（一）：V8是如何实现微任务的？</span></a></li><li><a href="/blog/图解googlev8/04.事件循环和垃圾回收/03"><span>19｜异步编程（二）：V8是如何实现async/await的？</span></a></li><li><a href="/blog/图解googlev8/04.事件循环和垃圾回收/04"><span>20 | 垃圾回收（一）：V8的两个垃圾回收器是如何工作的？</span></a></li><li><a href="/blog/图解googlev8/04.事件循环和垃圾回收/05"><span>21 | 垃圾回收（二）：V8是如何优化垃圾回收器执行效率的？</span></a></li><li><a href="/blog/图解googlev8/04.事件循环和垃圾回收/06"><span>22｜答疑：几种常见内存问题的解决策略</span></a></li></ul></li><li><a href="/blog/图解googlev8/05.结束语">05.结束语</a><ul><li><a href="/blog/图解googlev8/05.结束语/01"><span>结束语 | 我的前端学习踩坑史</span></a></li><li><a href="/blog/图解googlev8/05.结束语/02"><span>结课测试 | 这些V8的知识你都掌握了吗？</span></a></li></ul></li><li><a href="/blog/图解googlev8/summary">图解googlev8</a></li></ul></div></div><ul role="slug-list" class="__dumi-default-layout-toc"><li title="什么是V8？" data-depth="2"><a href="/blog/图解googlev8/01.宏观视角/02#什么是v8"><span>什么是V8？</span></a></li><li title="高级代码为什么需要先编译再执行？" data-depth="2"><a href="/blog/图解googlev8/01.宏观视角/02#高级代码为什么需要先编译再执行"><span>高级代码为什么需要先编译再执行？</span></a></li><li title="V8是怎么执行JavaScript代码的？" data-depth="2"><a href="/blog/图解googlev8/01.宏观视角/02#v8是怎么执行javascript代码的"><span>V8是怎么执行JavaScript代码的？</span></a></li><li title="跟踪一段实际代码的执行流程" data-depth="2"><a href="/blog/图解googlev8/01.宏观视角/02#跟踪一段实际代码的执行流程"><span>跟踪一段实际代码的执行流程</span></a></li><li title="总结" data-depth="2"><a href="/blog/图解googlev8/01.宏观视角/02#总结"><span>总结</span></a></li><li title="课后思考" data-depth="2"><a href="/blog/图解googlev8/01.宏观视角/02#课后思考"><span>课后思考</span></a></li></ul><div class="__dumi-default-layout-content"><div class="markdown"><h1 id="01--v8是如何执行一段javascript代码的"><a aria-hidden="true" tabindex="-1" href="/blog/图解googlev8/01.宏观视角/02#01--v8是如何执行一段javascript代码的"><span class="icon icon-link"></span></a>01 | V8是如何执行一段JavaScript代码的？</h1><p>你好，我是李兵。</p><p>今天是我们整个课程的第一讲，我会从一个高层的宏观视角来解释什么是V8，以及V8又是怎么执行一段JavaScript代码的。在这个过程中，我会引入一些核心概念，诸如JIT、作用域、词法环境、执行上下文等，理解了这些概念，能够帮助你更好地理解V8是如何工作的，同时也能帮助你写出更加高效的JavaScript代码。</p><p>由于本节的目的是对V8做一个宏观的、全面的介绍，其目的是让你对V8的执行流程有个整体上的认识，所以涉及到的概念会比较多，如果你对其中一些概念不太理解也没有关系，在后面的章节中我会展开了详细地介绍。</p><h2 id="什么是v8"><a aria-hidden="true" tabindex="-1" href="/blog/图解googlev8/01.宏观视角/02#什么是v8"><span class="icon icon-link"></span></a>什么是V8？</h2><p>首先我们来看看什么是V8。</p><p>V8是一个由Google开发的开源JavaScript引擎，目前用在Chrome浏览器和Node.js中，其核心功能是执行易于人类理解的JavaScript代码。</p><p><img src="https://static001.geekbang.org/resource/image/ca/4d/ca2cf22c8b2b322022666a3183db1b4d.jpg" alt="" title="V8执行JavaScript"/></p><p>那么V8又是怎么执行JavaScript代码的呢？</p><p>其主要核心流程分为编译和执行两步。首先需要将JavaScript代码转换为低级中间代码或者机器能够理解的机器代码，然后再执行转换后的代码并输出执行结果。</p><p><img src="https://static001.geekbang.org/resource/image/b7/bf/b77593de2fc7754d146e1218c45ef2bf.jpg" alt="" title="转换为中间代码"/></p><p>你可以把V8看成是一个虚构出来的计算机，也称为虚拟机，虚拟机通过模拟实际计算机的各种功能来实现代码的执行，如模拟实际计算机的CPU、堆栈、寄存器等，虚拟机还具有它自己的一套指令系统。</p><p>所以对于JavaScript代码来说，V8就是它的整个世界，当V8执行JavaScript代码时，你并不需要担心现实中不同操作系统的差异，也不需要担心不同体系结构计算机的差异，你只需要按照虚拟机的规范写好代码就可以了。</p><p>既然V8是虚构出来的计算机，用来编译和执行JavaScript代码，那么接下来我们就看看，为什么计算机需要对JavaScript这样的高级语言进行编译，以及编译完成后又是如何执行的。</p><h2 id="高级代码为什么需要先编译再执行"><a aria-hidden="true" tabindex="-1" href="/blog/图解googlev8/01.宏观视角/02#高级代码为什么需要先编译再执行"><span class="icon icon-link"></span></a>高级代码为什么需要先编译再执行？</h2><p>我们先从CPU是怎么执行机器代码讲起，你可以把CPU看成是一个非常小的运算机器，我们可以通过二进制的指令和CPU进行沟通，比如我们给CPU发出“1000100111011000”的二进制指令，这条指令的意思是将一个寄存器中的数据移动到另外一个寄存器中，当处理器执行到这条指令的时候，便会按照指令的意思去实现相关的操作。</p><p>为了能够完成复杂的任务，工程师们为CPU提供了一大堆指令，来实现各种功能，我们就把这一大堆指令称为<strong>指令集（Instructions）</strong>，也就是<strong>机器语言</strong>。</p><p>注意，CPU只能识别二进制的指令，但是对程序员来说，二进制代码难以阅读和记忆，于是我们又将二进制指令集转换为人类可以识别和记忆的符号，这就是<strong>汇编指令集</strong>，你可以参考下面的代码：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">1000100111011000  机器指令</span></div><div class="token-line"><span class="token plain">    mov ax,bx         汇编指令</span></div></pre></div><p>那么你可能会问，CPU能直接识别汇编语言吗？</p><p>答案是“不能”，所以如果你使用汇编编写了一段程序，你还需要一个汇编编译器，其作用是将汇编代码编程成机器代码，具体流程你可以参考下图：</p><p><img src="https://static001.geekbang.org/resource/image/6b/1f/6bb6d19ec37ea1a7d2cab2a25ea62b1f.jpg" alt="" title="汇编编译器"/></p><p>虽然汇编语言对机器语言做了一层抽象，减少了程序员理解机器语言的复杂度，但是汇编语言依然是复杂且繁琐的，即便你写一个非常简单的功能，也需要实现大量的汇编代码，这主要表现在以下两点。</p><p>首先，<strong>不同的CPU有着不同的指令集</strong>，如果要使用机器语言或者汇编语言来实现一个功能，那么你需要为每种架构的CPU编写特定的汇编代码，这会带来巨大的、枯燥繁琐的操作，你可以参看下图：</p><p><img src="https://static001.geekbang.org/resource/image/75/70/75f4f88099f82bec62def94541189b70.jpg" alt="" title="需要为每种架构的CPU编写特定的汇编代码"/></p><p>其次，<strong>在编写汇编代码时，我们还需要了解和处理器架构相关的硬件知识</strong>，比如你需要使用寄存器、内存、操作CPU等。大部分程序员在编写应用的时候，只想专心处理业务逻辑，并不想要过多地理会这些处理器架构相关的细节。</p><p>因此我们需要一种屏蔽了计算机架构细节的语言，能适应多种不同CPU架构的语言，能专心处理业务逻辑的语言，诸如C、C++、Java、C#、Python、JavaScript等，这些“高级语言”就应运而生了。</p><p>和汇编语言一样，处理器也不能直接识别由高级语言所编写的代码，那怎么办呢？通常，要有两种方式来执行这些代码。</p><p>第一种是解释执行，需要先将输入的源代码通过解析器编译成中间代码，之后直接使用解释器解释执行中间代码，然后直接输出结果。具体流程如下图所示：</p><p><img src="https://static001.geekbang.org/resource/image/33/5e/330ad69589d898f6609dfc083bfbe95e.jpg" alt="" title="解释执行流程图"/></p><p>第二种是编译执行。采用这种方式时，也需要先将源代码转换为中间代码，然后我们的编译器再将中间代码编译成机器代码。通常编译成的机器代码是以二进制文件形式存储的，需要执行这段程序的时候直接执行二进制文件就可以了。还可以使用虚拟机将编译后的机器代码保存在内存中，然后直接执行内存中的二进制代码。</p><p><img src="https://static001.geekbang.org/resource/image/1f/d3/1f933e42e81dacc8f4f2d86e01a914d3.jpg" alt="" title="编译执行流程图"/><br/>以上就是计算机执行高级语言的两种基本的方式：解释执行和编译执行。但是针对不同的高级语言，这个实现方式还是有很大差异的，比如要执行C语言编写的代码，你需要将其编译为二进制代码的文件，然后再直接执行二进制代码。而对于像Java语言、JavaScript语言等，则需要不同虚拟机，模拟计算机的这个编译执行流程。执行Java语言，需要经过Java虚拟机的转换，执行JavaScript需要经过JavaScript虚拟机的转换。</p><p>即便是JavaScript一门语言，也有好几种流行的虚拟机，它们之间的实现方式也存在着一部分差异，比如苹果公司在Safari中就是用JavaScriptCore虚拟机，Firefox使用了TraceMonkey虚拟机，而Chrome则使用了V8虚拟机。</p><h2 id="v8是怎么执行javascript代码的"><a aria-hidden="true" tabindex="-1" href="/blog/图解googlev8/01.宏观视角/02#v8是怎么执行javascript代码的"><span class="icon icon-link"></span></a>V8是怎么执行JavaScript代码的？</h2><p>那么，V8作为JavaScript的虚拟机的一种，它到底是怎么执行JavaScript代码的呢？是解释执行，还是编译执行呢？</p><p>实际上，V8并没有采用某种单一的技术，而是混合编译执行和解释执行这两种手段，我们把这种混合使用编译器和解释器的技术称为JIT（Just In Time）技术。</p><p>这是一种权衡策略，因为这两种方法都各自有各自的优缺点，解释执行的启动速度快，但是执行时的速度慢，而编译执行的启动速度慢，但是执行时的速度快。你可以参考下面完整的V8执行JavaScript的流程图：</p><p><img src="https://static001.geekbang.org/resource/image/8a/54/8a34ae8c1a7a0f87e19b1384a025e354.jpg" alt="" title="V8执行一段JavaScript流程图"/></p><p>我们先看上图中的最左边的部分，在V8启动执行JavaScript之前，它还需要准备执行JavaScript时所需要的一些基础环境，这些基础环境包括了“堆空间”“栈空间”“全局执行上下文”“全局作用域”“消息循环系统”“内置函数”等，这些内容都是在执行JavaScript过程中需要使用到的，比如：</p><ul><li>JavaScript全局执行上下文就包含了执行过程中的全局信息，比如一些内置函数，全局变量等信息；</li><li>全局作用域包含了一些全局变量，在执行过程中的数据都需要存放在内存中；</li><li>而V8是采用了经典的堆和栈的内存管理模式，所以V8还需要初始化内存中的堆和栈结构；</li><li>另外，想要我们的V8系统活起来，还需要初始化消息循环系统，消息循环系统包含了消息驱动器和消息队列，它如同V8的心脏，不断接受消息并决策如何处理消息。</li></ul><p>基础环境准备好之后，接下来就可以向V8提交要执行的JavaScript代码了。</p><p>首先V8会接收到要执行的JavaScript源代码，不过这对V8来说只是一堆字符串，V8并不能直接理解这段字符串的含义，它需要<strong>结构化</strong>这段字符串。结构化，是指信息经过分析后可分解成多个互相关联的组成部分，各组成部分间有明确的层次结构，方便使用和维护，并有一定的操作规范。</p><p>V8源代码的结构化之后，就生成了抽象语法树(AST)，我们称为AST，AST是便于V8理解的结构。</p><p>这里还需要注意一点，在生成AST的同时，V8还会生成相关的作用域，作用域中存放相关变量，我们会在《 <a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/217027">06 | 作用域链：V8是如何查找变量的？<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>》和《<a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/223168">12 | 延迟解析：V8是如何实现闭包的？<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>》这两节课中详细分析。</p><p>有了AST和作用域之后，接下来就可以生成字节码了，字节码是介于AST和机器代码的中间代码。但是与特定类型的机器代码无关，解释器可以直接解释执行字节码，或者通过编译器将其编译为二进制的机器代码再执行。我们会在 《<a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/224206">13｜字节码（一）：V8为什么又重新引入字节码？<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>》这节课中详细介绍字节码的前世今生。</p><p>好了，生成了字节码之后，解释器就登场了，它会按照顺序解释执行字节码，并输出执行结果。</p><p>相信你注意到了，我们在解释器附近画了个监控机器人，这是一个监控解释器执行状态的模块，在解释执行字节码的过程中，如果发现了某一段代码会被重复多次执行，那么监控机器人就会将这段代码标记为热点代码。</p><p>当某段代码被标记为热点代码后，V8就会将这段字节码丢给优化编译器，优化编译器会在后台将字节码编译为二进制代码，然后再对编译后的二进制代码执行优化操作，优化后的二进制机器代码的执行效率会得到大幅提升。如果下面再执行到这段代码时，那么V8会优先选择优化之后的二进制代码，这样代码的执行速度就会大幅提升。</p><p>不过，和静态语言不同的是，JavaScript是一种非常灵活的动态语言，对象的结构和属性是可以在运行时任意修改的，而经过优化编译器优化过的代码只能针对某种固定的结构，一旦在执行过程中，对象的结构被动态修改了，那么优化之后的代码势必会变成无效的代码，这时候优化编译器就需要执行反优化操作，经过反优化的代码，下次执行时就会回退到解释器解释执行。</p><h2 id="跟踪一段实际代码的执行流程"><a aria-hidden="true" tabindex="-1" href="/blog/图解googlev8/01.宏观视角/02#跟踪一段实际代码的执行流程"><span class="icon icon-link"></span></a>跟踪一段实际代码的执行流程</h2><p>我们以一段最简单的JavaScript代码为例，如果将这段非常简单的代码提交给V8引擎，V8在处理过程中，中间所产生的结果是怎样的呢？下面我们就一步一步详细“追踪”下。</p><p>代码如下所示：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">var test = &#x27;GeekTime&#x27;</span></div></pre></div><p>我们知道，首先这段代码会被解析器结构化成AST，下面我们就来看看第一阶段生成的AST是什么样子的？</p><p>要查看V8中间生成的一些结构，可以使用V8提供的调试工具D8来查看，你可以将上面那段代码保存到test.js的文件中，然后执行下面命令：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">d8 --print-ast test.js</span></div></pre></div><p>执行这段命令之后，D8会打印出如下内容：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">--- AST ---</span></div><div class="token-line"><span class="token plain">    FUNC at 0</span></div><div class="token-line"><span class="token plain">    . KIND 0</span></div><div class="token-line"><span class="token plain">    . LITERAL ID 0</span></div><div class="token-line"><span class="token plain">    . SUSPEND COUNT 0</span></div><div class="token-line"><span class="token plain">    . NAME &quot;&quot;</span></div><div class="token-line"><span class="token plain">    . INFERRED NAME &quot;&quot;</span></div><div class="token-line"><span class="token plain">    . DECLS</span></div><div class="token-line"><span class="token plain">    . . VARIABLE (0x7ff0e3022298) (mode = VAR, assigned = true) &quot;test&quot;</span></div><div class="token-line"><span class="token plain">    . BLOCK NOCOMPLETIONS at -1</span></div><div class="token-line"><span class="token plain">    . . EXPRESSION STATEMENT at 11</span></div><div class="token-line"><span class="token plain">    . . . INIT at 11</span></div><div class="token-line"><span class="token plain">    . . . . VAR PROXY unallocated (0x7ff0e3022298) (mode = VAR, assigned = true) &quot;test&quot;</span></div><div class="token-line"><span class="token plain">    . . . . LITERAL &quot;GeekTime&quot;</span></div></pre></div><p>上面这个结构就是AST，它就是JS源代码的结构化表述，AST是个树状结构，直观地理解，你可以将其转换为一个图形树，如下图所示：</p><p><img src="https://static001.geekbang.org/resource/image/57/87/57018772d9a93d367c07ce51b91e1f87.jpg" alt="" title="将源码解析为AST"/></p><p>从图中可以看出，AST和代码结构也是一一对应关系，并且后续所有的操作都会直接或者间接基于它。</p><p>上面我们还提到了，在生成AST的同时，还会生成作用域，同样我们使用D8来看看它生成的作用域是什么样子，你可以使用下面的命令来查看作用域：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">d8 --print-scopes test.js</span></div></pre></div><p>执行这段命令之后，D8会打印出如下内容：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">Global scope:</span></div><div class="token-line"><span class="token plain">    global { // (0x7fd974022048) (0, 24)</span></div><div class="token-line"><span class="token plain">      // will be compiled</span></div><div class="token-line"><span class="token plain">      // 1 stack slots</span></div><div class="token-line"><span class="token plain">      // temporary vars:</span></div><div class="token-line"><span class="token plain">      TEMPORARY .result;  // (0x7fd9740223c8) local[0]</span></div><div class="token-line"><span class="token plain">      // local vars:</span></div><div class="token-line"><span class="token plain">      VAR test;  // (0x7fd974022298)</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>上面这行代码生成了一个全局作用域，我们可以看到test变量被添加进了这个全局作用域中。</p><p>生成了AST和作用域之后，就可以使用解释器生成字节码了，同样你可以使用D8来打印生成后的字节码，打印的命令如下所示：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">d8 --print-bytecode test.js</span></div></pre></div><p>执行这段语句，最终打印出来的结果如下所示：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">[generated bytecode for function:  (0x2b510824fd55 &lt;SharedFunctionInfo&gt;)]</span></div><div class="token-line"><span class="token plain">    Parameter count 1</span></div><div class="token-line"><span class="token plain">    Register count 4</span></div><div class="token-line"><span class="token plain">    Frame size 32</span></div><div class="token-line"><span class="token plain">             0x2b510824fdd2 @    0 : a7                StackCheck</span></div><div class="token-line"><span class="token plain">             0x2b510824fdd3 @    1 : 12 00             LdaConstant [0]</span></div><div class="token-line"><span class="token plain">             0x2b510824fdd5 @    3 : 26 fa             Star r1</span></div><div class="token-line"><span class="token plain">             0x2b510824fdd7 @    5 : 0b                LdaZero</span></div><div class="token-line"><span class="token plain">             0x2b510824fdd8 @    6 : 26 f9             Star r2</span></div><div class="token-line"><span class="token plain">             0x2b510824fdda @    8 : 27 fe f8          Mov &lt;closure&gt;, r3</span></div><div class="token-line"><span class="token plain">             0x2b510824fddd @   11 : 61 32 01 fa 03    CallRuntime [DeclareGlobals], r1-r3</span></div><div class="token-line"><span class="token plain">             0x2b510824fde2 @   16 : 12 01             LdaConstant [1]</span></div><div class="token-line"><span class="token plain">             0x2b510824fde4 @   18 : 15 02 02          StaGlobal [2], [2]</span></div><div class="token-line"><span class="token plain">             0x2b510824fde7 @   21 : 0d                LdaUndefined</span></div><div class="token-line"><span class="token plain">             0x2b510824fde8 @   22 : ab                Return</span></div><div class="token-line"><span class="token plain">    Constant pool (size = 3)</span></div><div class="token-line"><span class="token plain">    0x2b510824fd9d: [FixedArray] in OldSpace</span></div><div class="token-line"><span class="token plain">     - map: 0x2b51080404b1 &lt;Map&gt;</span></div><div class="token-line"><span class="token plain">     - length: 3</span></div><div class="token-line"><span class="token plain">               0: 0x2b510824fd7d &lt;FixedArray[4]&gt;</span></div><div class="token-line"><span class="token plain">               1: 0x2b510824fd1d &lt;String[#8]: GeekTime&gt;</span></div><div class="token-line"><span class="token plain">               2: 0x2b51081c8549 &lt;String[#4]: test&gt;</span></div><div class="token-line"><span class="token plain">    Handler Table (size = 0)</span></div><div class="token-line"><span class="token plain">    Source Position Table (size = 0)</span></div></pre></div><p>上面就是这段代码生成的中间字节码，关于字节码，我们会在后续课程《<a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/224908">14 | 字节码（二）：解释器是如何解释执行字节码的？<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>》来介绍，在这里我们先有一个大致认知就可以了。</p><p>生成字节码之后，解释器会解释执行这段字节码，如果重复执行了某段代码，监控器就会将其标记为热点代码，并提交给编译器优化执行，如果你想要查看那些代码被优化了，可以使用下面的命令：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">d8 --trace-opt test.js</span></div></pre></div><p>如果要查看那些代码被反优化了，可以使用如下命令行来查看：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">pt --trace-deopt test.js</span></div></pre></div><p>由于我们这段代码过于简单，没有触发V8的优化机制，在这里我们也就不展开介绍优化机制了，具体的流程。我会在《<a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/226417">15 | 隐藏类：如何在内存中快速查找对象属性？<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>》这一节展开详细介绍。</p><h2 id="总结"><a aria-hidden="true" tabindex="-1" href="/blog/图解googlev8/01.宏观视角/02#总结"><span class="icon icon-link"></span></a>总结</h2><p>V8是由Google开发的开源JavaScript引擎，也被称为虚拟机，模拟实际计算机各种功能来实现代码的编译和执行。那么，要想搞清楚V8内部的工作流程和原理，我们可以从分析计算机对语言的编译和执行过程入手。</p><p>因为计算机只能识别二进制指令，所以要让计算机执行一段高级语言通常有两种手段，第一种是将高级代码转换为二进制代码，再让计算机去执行；另外一种方式是在计算机安装一个解释器，并由解释器来解释执行。</p><p>解释执行和编译执行都有各自的优缺点，解释执行启动速度快，但是执行时速度慢，而编译执行启动速度慢，但是执行速度快。为了充分地利用解释执行和编译执行的优点，规避其缺点，V8采用了一种权衡策略，在启动过程中采用了解释执行的策略，但是如果某段代码的执行频率超过一个值，那么V8就会采用优化编译器将其编译成执行效率更加高效的机器代码。</p><p>理解了这一点，我们就可以来深入分析V8执行一段JavaScript代码所经历的主要流程了，这包括了：</p><ul><li>初始化基础环境；</li><li>解析源码生成AST和作用域；</li><li>依据AST和作用域生成字节码；</li><li>解释执行字节码；</li><li>监听热点代码；</li><li>优化热点代码为二进制的机器代码；</li><li>反优化生成的二进制机器代码。</li></ul><p>这里你需要注意的是，JavaScript是一门动态语言，在运行过程中，某些被优化的结构可能会被V8动态修改了，这会导致之前被优化的代码失效，如果某块优化之后的代码失效了，那么编译器需要执行反优化操作。</p><h2 id="课后思考"><a aria-hidden="true" tabindex="-1" href="/blog/图解googlev8/01.宏观视角/02#课后思考"><span class="icon icon-link"></span></a>课后思考</h2><p>最后，给你留一道思考题：除了V8采用了JIT技术，还有哪些虚拟机采用了JIT技术？欢迎你在留言区与我分享讨论。</p><p>感谢你的阅读，如果你觉得这一讲的内容对你有所启发，也欢迎把它分享给你的朋友。</p></div><div class="__dumi-default-layout-footer-meta"><a target="_blank" rel="noopener noreferrer" href="https://github.com/GGwujun/blog/edit/master/docs/图解googlev8/01.宏观视角/02.md">在 GitHub 上编辑此页<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a><span data-updated-text="最后更新时间：">5/2/2022 10:56:53</span></div></div></div></div>
	<script>
  window.g_useSSR = true;
  window.g_initialProps = {};
	</script>

    <script>
      (function () {
        if (!location.port) {
          (function (i, s, o, g, r, a, m) {
            i["GoogleAnalyticsObject"] = r;
            (i[r] =
              i[r] ||
              function () {
                (i[r].q = i[r].q || []).push(arguments);
              }),
              (i[r].l = 1 * new Date());
            (a = s.createElement(o)), (m = s.getElementsByTagName(o)[0]);
            a.async = 1;
            a.src = g;
            m.parentNode.insertBefore(a, m);
          })(
            window,
            document,
            "script",
            "//www.google-analytics.com/analytics.js",
            "ga"
          );
          ga("create", "UA-149864185-1", "auto");
          ga("send", "pageview");
        }
      })();
    </script>
    <script src="/blog/umi.js"></script>
  </body>
</html>
