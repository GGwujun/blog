<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no"
    />
    <link rel="shortcut icon" type="image/x-icon" href="/logo.png" />
    <link rel="stylesheet" href="/blog/umi.css" />
    <script>
      window.routerBase = "/blog";
    </script>
    <script>
      //! umi version: 3.5.17
    </script>
    <script>
      !(function () {
        var e = localStorage.getItem("dumi:prefers-color"),
          t = window.matchMedia("(prefers-color-scheme: dark)").matches,
          r = ["light", "dark", "auto"];
        document.documentElement.setAttribute(
          "data-prefers-color",
          e === r[2] ? (t ? r[1] : r[0]) : r.indexOf(e) > -1 ? e : r[0]
        );
      })();
    </script>
    <title>04 | Setup：组件渲染前的初始化过程是怎样的？</title>
  </head>
  <body>
    <div id="root"><div class="__dumi-default-layout" data-route="/vue3源码分析/03.模块二学会新设计composition-api/02" data-show-sidemenu="true" data-show-slugs="true" data-site-mode="true" data-gapless="false"><div class="__dumi-default-navbar" data-mode="site"><button class="__dumi-default-navbar-toggle"></button><a class="__dumi-default-navbar-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog/">大师兄</a><nav><div class="__dumi-default-search"><input type="search" class="__dumi-default-search-input" value=""/><ul></ul></div><span>计算机基础<ul><li><a href="/blog/编译原理之美">编译原理之美</a></li><li><a href="/blog/编译原理实战">编译原理实战</a></li><li><a href="/blog/深入浅出计算机组成原理">深入浅出计算机组成原理</a></li><li><a href="/blog/详解http">详解http</a></li><li><a href="/blog/计算机网络通关29讲">计算机网络通关29讲</a></li><li><a href="/blog/网络排查案例课">网络排查案例课</a></li><li><a href="/blog/linux操作系统">linux操作系统</a></li><li><a href="/blog/linux性能优化实战">linux性能优化实战</a></li><li><a href="/blog/程序员数学基础">程序员数学基础</a></li><li><a href="/blog/趣谈网络协议">趣谈网络协议</a></li><li><a href="/blog/操作系统实战">操作系统实战</a></li><li><a href="/blog/软件工程之美">软件工程之美</a></li><li><a href="/blog/sql必知必会">sql必知必会</a></li><li><a href="/blog/操作系统实战45讲">操作系统实战45讲</a></li><li><a href="/blog/网络编程实战">网络编程实战</a></li></ul></span><span>算法<ul><li><a href="/blog/常用算法25讲">常用算法25讲</a></li><li><a href="/blog/数据结构与算法之美">数据结构与算法之美</a></li><li><a href="/blog/业务开发算法50讲">业务开发算法50讲</a></li><li><a href="/blog/动态规划面试宝典">动态规划面试宝典</a></li></ul></span><span>前端开发<ul><li><a href="/blog/浏览器工作原理与实践">浏览器工作原理与实践</a></li><li><a href="/blog/新时代产品经理进阶之路">新时代产品经理进阶之路</a></li><li><a href="/blog/全栈工程师修炼指南">全栈工程师修炼指南</a></li><li><a href="/blog/flutter核心技术与实战">flutter核心技术与实战</a></li><li><a href="/blog/java-script核心原理解析">java-script核心原理解析</a></li><li><a href="/blog/说透低代码">说透低代码</a></li><li><a href="/blog/nodejs应用开发实战">nodejs应用开发实战</a></li><li><a href="/blog/反爬虫兵法演绎20讲">反爬虫兵法演绎20讲</a></li><li><a href="/blog/reactnative新架构实战课">reactnative新架构实战课</a></li><li><a href="/blog/正则表达式入门">正则表达式入门</a></li><li><a href="/blog/重学前端">重学前端</a></li><li><a href="/blog/serverless入门课">serverless入门课</a></li><li><a href="/blog/type-script入门实战笔记">type-script入门实战笔记</a></li><li><a href="/blog/图解googlev8">图解googlev8</a></li><li><a aria-current="page" class="active" href="/blog/vue3源码分析">vue3源码分析</a></li><li><a href="/blog/玩转Vue3全家桶">玩转Vue3全家桶</a></li><li><a href="/blog/webassembly入门">webassembly入门</a></li><li><a href="/blog/手把手带你写一个Web框架">手把手带你写一个Web框架</a></li><li><a href="/blog/web漏洞挖掘实战">web漏洞挖掘实战</a></li><li><a href="/blog/跟月影学可视化">跟月影学可视化</a></li><li><a href="/blog/搞定音频技术">搞定音频技术</a></li><li><a href="/blog/攻克视频技术">攻克视频技术</a></li></ul></span><span>前端工程化<ul><li><a href="/blog/logger">logger</a></li><li><a href="/blog/webpack">webpack</a></li><li><a href="/blog/webpackChain">webpackChain</a></li></ul></span><span>前端性能优化<ul><li><a href="/blog/react性能调优">react性能调优</a></li></ul></span><span>软件测试<ul><li><a href="/blog/全链路压测实战30讲">全链路压测实战30讲</a></li><li><a href="/blog/性能测试实战30讲">性能测试实战30讲</a></li><li><a href="/blog/自动化测试高手课">自动化测试高手课</a></li><li><a href="/blog/软件测试52讲">软件测试52讲</a></li></ul></span><span>面试<ul><li><a href="/blog/面试现场">面试现场</a></li></ul></span><span>杂谈<ul><li><a href="/blog/超级访谈对话张雪峰">超级访谈对话张雪峰</a></li><li><a href="/blog/Git实战手册">Git实战手册</a></li><li><a href="/blog/NodeJS">NodeJS</a></li><li><a href="/blog/ReactJS">ReactJS</a></li><li><a href="/blog/UI设计">UI设计</a></li><li><a href="/blog/webpack4系列教程">webpack4系列教程</a></li><li><a href="/blog/前端知识体系">前端知识体系</a></li><li><a href="/blog/剑指offer刷题笔记">剑指offer刷题笔记</a></li><li><a href="/blog/思考与成长">思考与成长</a></li><li><a href="/blog/设计模式手册">设计模式手册</a></li></ul></span><div class="__dumi-default-navbar-tool"><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "></div></div></div></nav></div><div class="__dumi-default-menu" data-mode="site"><div class="__dumi-default-menu-inner"><div class="__dumi-default-menu-header"><a class="__dumi-default-menu-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog/"></a><h1>大师兄</h1><p></p></div><div class="__dumi-default-menu-mobile-area"><ul class="__dumi-default-menu-nav-list"><li>计算机基础<ul><li><a href="/blog/编译原理之美">编译原理之美</a></li><li><a href="/blog/编译原理实战">编译原理实战</a></li><li><a href="/blog/深入浅出计算机组成原理">深入浅出计算机组成原理</a></li><li><a href="/blog/详解http">详解http</a></li><li><a href="/blog/计算机网络通关29讲">计算机网络通关29讲</a></li><li><a href="/blog/网络排查案例课">网络排查案例课</a></li><li><a href="/blog/linux操作系统">linux操作系统</a></li><li><a href="/blog/linux性能优化实战">linux性能优化实战</a></li><li><a href="/blog/程序员数学基础">程序员数学基础</a></li><li><a href="/blog/趣谈网络协议">趣谈网络协议</a></li><li><a href="/blog/操作系统实战">操作系统实战</a></li><li><a href="/blog/软件工程之美">软件工程之美</a></li><li><a href="/blog/sql必知必会">sql必知必会</a></li><li><a href="/blog/操作系统实战45讲">操作系统实战45讲</a></li><li><a href="/blog/网络编程实战">网络编程实战</a></li></ul></li><li>算法<ul><li><a href="/blog/常用算法25讲">常用算法25讲</a></li><li><a href="/blog/数据结构与算法之美">数据结构与算法之美</a></li><li><a href="/blog/业务开发算法50讲">业务开发算法50讲</a></li><li><a href="/blog/动态规划面试宝典">动态规划面试宝典</a></li></ul></li><li>前端开发<ul><li><a href="/blog/浏览器工作原理与实践">浏览器工作原理与实践</a></li><li><a href="/blog/新时代产品经理进阶之路">新时代产品经理进阶之路</a></li><li><a href="/blog/全栈工程师修炼指南">全栈工程师修炼指南</a></li><li><a href="/blog/flutter核心技术与实战">flutter核心技术与实战</a></li><li><a href="/blog/java-script核心原理解析">java-script核心原理解析</a></li><li><a href="/blog/说透低代码">说透低代码</a></li><li><a href="/blog/nodejs应用开发实战">nodejs应用开发实战</a></li><li><a href="/blog/反爬虫兵法演绎20讲">反爬虫兵法演绎20讲</a></li><li><a href="/blog/reactnative新架构实战课">reactnative新架构实战课</a></li><li><a href="/blog/正则表达式入门">正则表达式入门</a></li><li><a href="/blog/重学前端">重学前端</a></li><li><a href="/blog/serverless入门课">serverless入门课</a></li><li><a href="/blog/type-script入门实战笔记">type-script入门实战笔记</a></li><li><a href="/blog/图解googlev8">图解googlev8</a></li><li><a aria-current="page" class="active" href="/blog/vue3源码分析">vue3源码分析</a></li><li><a href="/blog/玩转Vue3全家桶">玩转Vue3全家桶</a></li><li><a href="/blog/webassembly入门">webassembly入门</a></li><li><a href="/blog/手把手带你写一个Web框架">手把手带你写一个Web框架</a></li><li><a href="/blog/web漏洞挖掘实战">web漏洞挖掘实战</a></li><li><a href="/blog/跟月影学可视化">跟月影学可视化</a></li><li><a href="/blog/搞定音频技术">搞定音频技术</a></li><li><a href="/blog/攻克视频技术">攻克视频技术</a></li></ul></li><li>前端工程化<ul><li><a href="/blog/logger">logger</a></li><li><a href="/blog/webpack">webpack</a></li><li><a href="/blog/webpackChain">webpackChain</a></li></ul></li><li>前端性能优化<ul><li><a href="/blog/react性能调优">react性能调优</a></li></ul></li><li>软件测试<ul><li><a href="/blog/全链路压测实战30讲">全链路压测实战30讲</a></li><li><a href="/blog/性能测试实战30讲">性能测试实战30讲</a></li><li><a href="/blog/自动化测试高手课">自动化测试高手课</a></li><li><a href="/blog/软件测试52讲">软件测试52讲</a></li></ul></li><li>面试<ul><li><a href="/blog/面试现场">面试现场</a></li></ul></li><li>杂谈<ul><li><a href="/blog/超级访谈对话张雪峰">超级访谈对话张雪峰</a></li><li><a href="/blog/Git实战手册">Git实战手册</a></li><li><a href="/blog/NodeJS">NodeJS</a></li><li><a href="/blog/ReactJS">ReactJS</a></li><li><a href="/blog/UI设计">UI设计</a></li><li><a href="/blog/webpack4系列教程">webpack4系列教程</a></li><li><a href="/blog/前端知识体系">前端知识体系</a></li><li><a href="/blog/剑指offer刷题笔记">剑指offer刷题笔记</a></li><li><a href="/blog/思考与成长">思考与成长</a></li><li><a href="/blog/设计模式手册">设计模式手册</a></li></ul></li></ul><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "><button title="Dark theme" class="__dumi-default-dark-moon "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="3854" width="22" height="22"><path d="M991.816611 674.909091a69.166545 69.166545 0 0 0-51.665455-23.272727 70.795636 70.795636 0 0 0-27.438545 5.585454A415.674182 415.674182 0 0 1 754.993338 698.181818c-209.594182 0-393.472-184.785455-393.472-395.636363 0-52.363636 38.539636-119.621818 69.515637-173.614546 4.887273-8.610909 9.634909-16.756364 14.103272-24.901818A69.818182 69.818182 0 0 0 384.631156 0a70.842182 70.842182 0 0 0-27.438545 5.585455C161.678429 90.298182 14.362065 307.898182 14.362065 512c0 282.298182 238.824727 512 532.38691 512a522.286545 522.286545 0 0 0 453.957818-268.334545A69.818182 69.818182 0 0 0 991.816611 674.909091zM546.679156 954.181818c-248.785455 0-462.941091-192-462.941091-442.181818 0-186.647273 140.637091-372.829091 300.939637-442.181818-36.817455 65.629091-92.578909 151.970909-92.578909 232.727273 0 250.181818 214.109091 465.454545 462.917818 465.454545a488.331636 488.331636 0 0 0 185.181091-46.545455 453.003636 453.003636 0 0 1-393.565091 232.727273z m103.656728-669.323636l-14.266182 83.781818a34.909091 34.909091 0 0 0 50.362182 36.770909l74.775272-39.563636 74.752 39.563636a36.142545 36.142545 0 0 0 16.174546 3.956364 34.909091 34.909091 0 0 0 34.210909-40.727273l-14.289455-83.781818 60.509091-59.345455a35.025455 35.025455 0 0 0-19.223272-59.578182l-83.61891-12.101818-37.376-76.101818a34.56 34.56 0 0 0-62.254545 0l-37.376 76.101818-83.618909 12.101818a34.909091 34.909091 0 0 0-19.246546 59.578182z m70.423272-64.698182a34.280727 34.280727 0 0 0 26.135273-19.083636l14.312727-29.090909 14.336 29.090909a34.257455 34.257455 0 0 0 26.135273 19.083636l32.046546 4.887273-23.272728 22.574545a35.234909 35.234909 0 0 0-10.007272 30.952727l5.46909 32.116364-28.625454-15.127273a34.490182 34.490182 0 0 0-32.302546 0l-28.695272 15.127273 5.469091-32.116364a35.141818 35.141818 0 0 0-9.984-30.952727l-23.272728-22.574545z" p-id="3855"></path></svg></button><button title="Light theme" class="__dumi-default-dark-sun "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="4026" width="22" height="22"><path d="M915.2 476.16h-43.968c-24.704 0-44.736 16-44.736 35.84s20.032 35.904 44.736 35.904H915.2c24.768 0 44.8-16.064 44.8-35.904s-20.032-35.84-44.8-35.84zM512 265.6c-136.704 0-246.464 109.824-246.464 246.4 0 136.704 109.76 246.464 246.464 246.464S758.4 648.704 758.4 512c0-136.576-109.696-246.4-246.4-246.4z m0 425.6c-99.008 0-179.2-80.128-179.2-179.2 0-98.944 80.192-179.2 179.2-179.2S691.2 413.056 691.2 512c0 99.072-80.192 179.2-179.2 179.2zM197.44 512c0-19.84-19.136-35.84-43.904-35.84H108.8c-24.768 0-44.8 16-44.8 35.84s20.032 35.904 44.8 35.904h44.736c24.768 0 43.904-16.064 43.904-35.904zM512 198.464c19.776 0 35.84-20.032 35.84-44.8v-44.8C547.84 84.032 531.84 64 512 64s-35.904 20.032-35.904 44.8v44.8c0 24.768 16.128 44.864 35.904 44.864z m0 627.136c-19.776 0-35.904 20.032-35.904 44.8v44.736C476.096 940.032 492.16 960 512 960s35.84-20.032 35.84-44.8v-44.736c0-24.768-16.064-44.864-35.84-44.864z m329.92-592.832c17.472-17.536 20.288-43.072 6.4-57.024-14.016-14.016-39.488-11.2-57.024 6.336-4.736 4.864-26.496 26.496-31.36 31.36-17.472 17.472-20.288 43.008-6.336 57.024 13.952 14.016 39.488 11.2 57.024-6.336 4.8-4.864 26.496-26.56 31.296-31.36zM213.376 759.936c-4.864 4.8-26.56 26.624-31.36 31.36-17.472 17.472-20.288 42.944-6.4 56.96 14.016 13.952 39.552 11.2 57.024-6.336 4.8-4.736 26.56-26.496 31.36-31.36 17.472-17.472 20.288-43.008 6.336-56.96-14.016-13.952-39.552-11.072-56.96 6.336z m19.328-577.92c-17.536-17.536-43.008-20.352-57.024-6.336-14.08 14.016-11.136 39.488 6.336 57.024 4.864 4.864 26.496 26.56 31.36 31.424 17.536 17.408 43.008 20.288 56.96 6.336 14.016-14.016 11.264-39.488-6.336-57.024-4.736-4.864-26.496-26.56-31.296-31.424z m527.168 628.608c4.864 4.864 26.624 26.624 31.36 31.424 17.536 17.408 43.072 20.224 57.088 6.336 13.952-14.016 11.072-39.552-6.4-57.024-4.864-4.8-26.56-26.496-31.36-31.36-17.472-17.408-43.072-20.288-57.024-6.336-13.952 14.016-11.008 39.488 6.336 56.96z" p-id="4027"></path></svg></button><button title="Default to system" class="__dumi-default-dark-auto "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="11002" width="22" height="22"><path d="M127.658667 492.885333c0-51.882667 10.24-101.717333 30.378666-149.162666s47.786667-88.064 81.92-122.538667 75.093333-61.781333 122.538667-81.92 96.938667-30.378667 149.162667-30.378667 101.717333 10.24 149.162666 30.378667 88.405333 47.786667 122.88 81.92 61.781333 75.093333 81.92 122.538667 30.378667 96.938667 30.378667 149.162666-10.24 101.717333-30.378667 149.162667-47.786667 88.405333-81.92 122.88-75.093333 61.781333-122.88 81.92-97.28 30.378667-149.162666 30.378667-101.717333-10.24-149.162667-30.378667-88.064-47.786667-122.538667-81.92-61.781333-75.093333-81.92-122.88-30.378667-96.938667-30.378666-149.162667z m329.045333 0c0 130.048 13.994667 244.394667 41.984 343.381334h12.970667c46.762667 0 91.136-9.216 133.461333-27.306667s78.848-42.666667 109.568-73.386667 54.954667-67.242667 73.386667-109.568 27.306667-86.698667 27.306666-133.461333c0-46.421333-9.216-90.794667-27.306666-133.12s-42.666667-78.848-73.386667-109.568-67.242667-54.954667-109.568-73.386667-86.698667-27.306667-133.461333-27.306666h-11.605334c-28.672 123.562667-43.349333 237.909333-43.349333 343.722666z" p-id="11003"></path></svg></button></div></div></div><ul class="__dumi-default-menu-list"><li><a href="/blog/vue3源码分析">vue3源码分析</a></li><li><a href="/blog/vue3源码分析/01.开篇词">01.开篇词</a><ul><li><a href="/blog/vue3源码分析/01.开篇词/01"><span>开篇词 | 解析 Vue.js 源码，提升编码能力</span></a></li><li><a href="/blog/vue3源码分析/01.开篇词/02"><span>导读 | 一文看懂 Vue.js 3.0 的优化</span></a></li></ul></li><li><a href="/blog/vue3源码分析/02.模块一直击vue.js核心组件的实现">02.模块一直击Vue.js核心组件的实现</a><ul><li><a href="/blog/vue3源码分析/02.模块一直击vue.js核心组件的实现/01"><span>模块一导读 | 组件的实现：直击 Vue 核心的实现</span></a></li><li><a href="/blog/vue3源码分析/02.模块一直击vue.js核心组件的实现/02"><span>01 | 组件渲染：vnode 到真实 DOM 是如何转变的？</span></a></li><li><a href="/blog/vue3源码分析/02.模块一直击vue.js核心组件的实现/03"><span>02 | 组件更新：完整的 DOM diff 流程是怎样的？（上）</span></a></li><li><a href="/blog/vue3源码分析/02.模块一直击vue.js核心组件的实现/04"><span>03 | 组件更新：完整的 DOM diff 流程是怎样的？（下）</span></a></li></ul></li><li><a aria-current="page" class="active" href="/blog/vue3源码分析/03.模块二学会新设计composition-api">03.模块二学会新设计CompositionAPI</a><ul><li><a href="/blog/vue3源码分析/03.模块二学会新设计composition-api/01"><span>模块二导读 | 逻辑复用最佳实践：Composition API</span></a></li><li><a aria-current="page" class="active" href="/blog/vue3源码分析/03.模块二学会新设计composition-api/02"><span>04 | Setup：组件渲染前的初始化过程是怎样的？</span></a></li><li><a href="/blog/vue3源码分析/03.模块二学会新设计composition-api/03"><span>05 | 响应式：响应式内部的实现原理是怎样的？（上）</span></a></li><li><a href="/blog/vue3源码分析/03.模块二学会新设计composition-api/04"><span>06 | 响应式：响应式内部的实现原理是怎样的？（下）</span></a></li><li><a href="/blog/vue3源码分析/03.模块二学会新设计composition-api/05"><span>07 | 计算属性：计算属性比普通函数好在哪里？</span></a></li><li><a href="/blog/vue3源码分析/03.模块二学会新设计composition-api/06"><span>08 | 侦听器：侦听器的实现原理和使用场景是什么？（上）</span></a></li><li><a href="/blog/vue3源码分析/03.模块二学会新设计composition-api/07"><span>09 | 侦听器：侦听器的实现原理和使用场景是什么？（下）</span></a></li><li><a href="/blog/vue3源码分析/03.模块二学会新设计composition-api/08"><span>10 | 生命周期：各个生命周期的执行时机和应用场景是怎样的？</span></a></li><li><a href="/blog/vue3源码分析/03.模块二学会新设计composition-api/09"><span>11 | 依赖注入：子孙组件如何共享数据？</span></a></li></ul></li><li><a href="/blog/vue3源码分析/04.模块三编译过程和背后的优化思想">04.模块三编译过程和背后的优化思想</a><ul><li><a href="/blog/vue3源码分析/04.模块三编译过程和背后的优化思想/01"><span>模块三导读 | 编译和优化：了解编译过程和背后的优化思想</span></a></li><li><a href="/blog/vue3源码分析/04.模块三编译过程和背后的优化思想/02"><span>12 | 模板解析：构造 AST 的完整流程是怎样的？（上）</span></a></li><li><a href="/blog/vue3源码分析/04.模块三编译过程和背后的优化思想/03"><span>13 | 模板解析：构造 AST 的完整流程是怎样的？（下）</span></a></li><li><a href="/blog/vue3源码分析/04.模块三编译过程和背后的优化思想/04"><span>14 | AST 转换：AST 节点内部做了哪些转换？（上）</span></a></li><li><a href="/blog/vue3源码分析/04.模块三编译过程和背后的优化思想/05"><span>15 | AST 转换：AST 节点内部做了哪些转换？（下）</span></a></li><li><a href="/blog/vue3源码分析/04.模块三编译过程和背后的优化思想/06"><span>16 | 生成代码：AST 如何生成可运行的代码？（上）</span></a></li><li><a href="/blog/vue3源码分析/04.模块三编译过程和背后的优化思想/07"><span>17 | 生成代码：AST 如何生成可运行的代码？（下）</span></a></li></ul></li><li><a href="/blog/vue3源码分析/05.模块四探索更多实用特性背后的实现原理">05.模块四探索更多实用特性背后的实现原理</a><ul><li><a href="/blog/vue3源码分析/05.模块四探索更多实用特性背后的实现原理/01"><span>模块四导读 | 实用特性：探索更多实用特性背后的原理</span></a></li><li><a href="/blog/vue3源码分析/05.模块四探索更多实用特性背后的实现原理/02"><span>18 | Props：Props 的初始化和更新流程是怎样的？</span></a></li><li><a href="/blog/vue3源码分析/05.模块四探索更多实用特性背后的实现原理/03"><span>19 | 插槽：如何实现内容分发？</span></a></li><li><a href="/blog/vue3源码分析/05.模块四探索更多实用特性背后的实现原理/04"><span>20 | 指令：指令完整的生命周期是怎样的？</span></a></li><li><a href="/blog/vue3源码分析/05.模块四探索更多实用特性背后的实现原理/05"><span>21 | v-model：双向绑定到底是怎么实现的？</span></a></li></ul></li><li><a href="/blog/vue3源码分析/06.模块五学习vue内置组件的实现原理">06.模块五学习Vue内置组件的实现原理</a><ul><li><a href="/blog/vue3源码分析/06.模块五学习vue内置组件的实现原理/01"><span>模块五导读 | 内置组件：学习 Vue 内置组件的实现原理</span></a></li><li><a href="/blog/vue3源码分析/06.模块五学习vue内置组件的实现原理/02"><span>22 | Teleport 组件：如何脱离当前组件渲染子组件？</span></a></li><li><a href="/blog/vue3源码分析/06.模块五学习vue内置组件的实现原理/03"><span>23 | KeepAlive 组件：如何让组件在内存中缓存和调度？</span></a></li><li><a href="/blog/vue3源码分析/06.模块五学习vue内置组件的实现原理/04"><span>24 | Transition 组件：过渡动画的实现原理是怎样的？（上）</span></a></li><li><a href="/blog/vue3源码分析/06.模块五学习vue内置组件的实现原理/05"><span>25 | Transition 组件：过渡动画的实现原理是怎样的？（下）</span></a></li></ul></li><li><a href="/blog/vue3源码分析/07.特别放送研究vue官方生态的实现原理">07.特别放送研究Vue官方生态的实现原理</a><ul><li><a href="/blog/vue3源码分析/07.特别放送研究vue官方生态的实现原理/01"><span>特别放送导读 | 研究 Vue 官方生态的实现原理</span></a></li><li><a href="/blog/vue3源码分析/07.特别放送研究vue官方生态的实现原理/02"><span>26 | Vue Router：如何实现一个前端路由？（上）</span></a></li><li><a href="/blog/vue3源码分析/07.特别放送研究vue官方生态的实现原理/03"><span>27 |  Vue Router：如何实现一个前端路由？（下）</span></a></li></ul></li><li><a href="/blog/vue3源码分析/08.结束语">08.结束语</a><ul><li><a href="/blog/vue3源码分析/08.结束语/01"><span>结束语 | 终点也是起点</span></a></li></ul></li><li><a href="/blog/vue3源码分析/summary">vue3源码分析</a></li></ul></div></div><ul role="slug-list" class="__dumi-default-layout-toc"><li title="创建和设置组件实例" data-depth="3"><a href="/blog/vue3源码分析/03.模块二学会新设计composition-api/02#创建和设置组件实例"><span>创建和设置组件实例</span></a></li><li title="创建渲染上下文代理" data-depth="3"><a href="/blog/vue3源码分析/03.模块二学会新设计composition-api/02#创建渲染上下文代理"><span>创建渲染上下文代理</span></a></li><li title="判断处理 setup 函数" data-depth="3"><a href="/blog/vue3源码分析/03.模块二学会新设计composition-api/02#判断处理-setup-函数"><span>判断处理 setup 函数</span></a></li><li title="完成组件实例设置" data-depth="3"><a href="/blog/vue3源码分析/03.模块二学会新设计composition-api/02#完成组件实例设置"><span>完成组件实例设置</span></a></li><li title="总结" data-depth="3"><a href="/blog/vue3源码分析/03.模块二学会新设计composition-api/02#总结"><span>总结</span></a></li></ul><div class="__dumi-default-layout-content"><div class="markdown"><h1 id="04--setup组件渲染前的初始化过程是怎样的"><a aria-hidden="true" tabindex="-1" href="/blog/vue3源码分析/03.模块二学会新设计composition-api/02#04--setup组件渲染前的初始化过程是怎样的"><span class="icon icon-link"></span></a>04 | Setup：组件渲染前的初始化过程是怎样的？</h1><p>Vue.js 3.0 允许我们在编写组件的时候添加一个 setup 启动函数，它是 Composition API 逻辑组织的入口，本节课我们就来分析一下这个函数。</p><p>我们先通过一段代码认识它，在这里编写一个 button 组件：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">&lt;template&gt;</span></div><div class="token-line"><span class="token plain">      &lt;button @click=&quot;increment&quot;&gt;</span></div><div class="token-line"><span class="token plain">        Count is: {{ state.count }}, double is: {{ state.double }}</span></div><div class="token-line"><span class="token plain">      &lt;/button&gt;</span></div><div class="token-line"><span class="token plain">    &lt;/template&gt;</span></div><div class="token-line"><span class="token plain">    &lt;script&gt;</span></div><div class="token-line"><span class="token plain">    import { reactive, computed } from &#x27;vue&#x27;</span></div><div class="token-line"><span class="token plain">    export default {</span></div><div class="token-line"><span class="token plain">      setup() {</span></div><div class="token-line"><span class="token plain">        const state = reactive({</span></div><div class="token-line"><span class="token plain">          count: 0,</span></div><div class="token-line"><span class="token plain">          double: computed(() =&gt; state.count * 2)</span></div><div class="token-line"><span class="token plain">        })</span></div><div class="token-line"><span class="token plain">        function increment() {</span></div><div class="token-line"><span class="token plain">          state.count++</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        return {</span></div><div class="token-line"><span class="token plain">          state,</span></div><div class="token-line"><span class="token plain">          increment</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">      }</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    &lt;/script&gt;</span></div></pre></div><p>可以看到，这段代码和 Vue.js 2.x 组件的写法相比，多了一个 setup 启动函数，另外组件中也没有定义 props、data、computed 这些 options。</p><p>在 setup 函数内部，定义了一个响应式对象 state，它是通过 reactive API 创建的。state 对象有 count 和 double 两个属性，其中 count 对应一个数字属性的值；而double 通过 computed API 创建，对应一个计算属性的值。reactive API 和 computed API 不是我们关注的重点，在后续响应式章节我会详细介绍。</p><p>这里需要注意的是，<strong>模板中引用到的变量 state 和 increment 包含在 setup 函数的返回对象中，那么它们是如何建立联系的呢？</strong></p><p>我们先来回想一下 Vue.js 2.x 编写组件的时候，会在 props、data、methods、computed 等 options 中定义一些变量。在组件初始化阶段，Vue.js 内部会处理这些 options，即把定义的变量添加到了组件实例上。等模板编译成 render 函数的时候，内部通过 with(this)<!-- -->{<!-- -->}<!-- --> 的语法去访问在组件实例中的变量。</p><p>那么到了 Vue.js 3.0，既支持组件定义 setup 函数，而且在模板 render 的时候，又可以访问到 setup 函数返回的值，这是如何实现的？我们来一探究竟。</p><h3 id="创建和设置组件实例"><a aria-hidden="true" tabindex="-1" href="/blog/vue3源码分析/03.模块二学会新设计composition-api/02#创建和设置组件实例"><span class="icon icon-link"></span></a>创建和设置组件实例</h3><p>首先，我们来回顾一下组件的渲染流程：创建 vnode 、渲染 vnode 和生成 DOM。</p><p><img src="https://s0.lgstatic.com/i/image/M00/35/74/Ciqc1F8VZpKAVYWOAABLt08AfuQ883.png" alt="4.png"/></p><p>其中渲染 vnode 的过程主要就是在挂载组件：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">const mountComponent = (initialVNode, container, anchor, parentComponent, parentSuspense, isSVG, optimized) =&gt; {</span></div><div class="token-line"><span class="token plain">      // 创建组件实例</span></div><div class="token-line"><span class="token plain">      const instance = (initialVNode.component = createComponentInstance(initialVNode, parentComponent, parentSuspense))</span></div><div class="token-line"><span class="token plain">      // 设置组件实例</span></div><div class="token-line"><span class="token plain">      setupComponent(instance)</span></div><div class="token-line"><span class="token plain">      // 设置并运行带副作用的渲染函数</span></div><div class="token-line"><span class="token plain">      setupRenderEffect(instance, initialVNode, container, anchor, parentSuspense, isSVG, optimized)</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>可以看到，这段挂载组件的代码主要做了三件事情：创建组件实例、设置组件实例和设置并运行带副作用的渲染函数。前两个流程就跟我们今天提到的问题息息相关，所以这一节课我们将重点分析它们。</p><p>先看<strong>创建组件实例</strong>的流程，我们要关注 createComponentInstance 方法的实现：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">function createComponentInstance (vnode, parent, suspense) {</span></div><div class="token-line"><span class="token plain">      // 继承父组件实例上的 appContext，如果是根组件，则直接从根 vnode 中取。</span></div><div class="token-line"><span class="token plain">      const appContext = (parent ? parent.appContext : vnode.appContext) || emptyAppContext;</span></div><div class="token-line"><span class="token plain">      const instance = {</span></div><div class="token-line"><span class="token plain">        // 组件唯一 id</span></div><div class="token-line"><span class="token plain">        uid: uid++,</span></div><div class="token-line"><span class="token plain">        // 组件 vnode</span></div><div class="token-line"><span class="token plain">        vnode,</span></div><div class="token-line"><span class="token plain">        // 父组件实例</span></div><div class="token-line"><span class="token plain">        parent,</span></div><div class="token-line"><span class="token plain">        // app 上下文</span></div><div class="token-line"><span class="token plain">        appContext,</span></div><div class="token-line"><span class="token plain">        // vnode 节点类型</span></div><div class="token-line"><span class="token plain">        type: vnode.type,</span></div><div class="token-line"><span class="token plain">        // 根组件实例</span></div><div class="token-line"><span class="token plain">        root: null,</span></div><div class="token-line"><span class="token plain">        // 新的组件 vnode</span></div><div class="token-line"><span class="token plain">        next: null,</span></div><div class="token-line"><span class="token plain">        // 子节点 vnode</span></div><div class="token-line"><span class="token plain">        subTree: null,</span></div><div class="token-line"><span class="token plain">        // 带副作用更新函数</span></div><div class="token-line"><span class="token plain">        update: null,</span></div><div class="token-line"><span class="token plain">        // 渲染函数</span></div><div class="token-line"><span class="token plain">        render: null,</span></div><div class="token-line"><span class="token plain">        // 渲染上下文代理</span></div><div class="token-line"><span class="token plain">        proxy: null,</span></div><div class="token-line"><span class="token plain">        // 带有 with 区块的渲染上下文代理</span></div><div class="token-line"><span class="token plain">        withProxy: null,</span></div><div class="token-line"><span class="token plain">        // 响应式相关对象</span></div><div class="token-line"><span class="token plain">        effects: null,</span></div><div class="token-line"><span class="token plain">        // 依赖注入相关</span></div><div class="token-line"><span class="token plain">        provides: parent ? parent.provides : Object.create(appContext.provides),</span></div><div class="token-line"><span class="token plain">        // 渲染代理的属性访问缓存</span></div><div class="token-line"><span class="token plain">        accessCache: null,</span></div><div class="token-line"><span class="token plain">        // 渲染缓存</span></div><div class="token-line"><span class="token plain">        renderCache: [],</span></div><div class="token-line"><span class="token plain">        // 渲染上下文</span></div><div class="token-line"><span class="token plain">        ctx: EMPTY_OBJ,</span></div><div class="token-line"><span class="token plain">        // data 数据</span></div><div class="token-line"><span class="token plain">        data: EMPTY_OBJ,</span></div><div class="token-line"><span class="token plain">        // props 数据</span></div><div class="token-line"><span class="token plain">        props: EMPTY_OBJ,</span></div><div class="token-line"><span class="token plain">        // 普通属性</span></div><div class="token-line"><span class="token plain">        attrs: EMPTY_OBJ,</span></div><div class="token-line"><span class="token plain">        // 插槽相关</span></div><div class="token-line"><span class="token plain">        slots: EMPTY_OBJ,</span></div><div class="token-line"><span class="token plain">        // 组件或者 DOM 的 ref 引用</span></div><div class="token-line"><span class="token plain">        refs: EMPTY_OBJ,</span></div><div class="token-line"><span class="token plain">        // setup 函数返回的响应式结果</span></div><div class="token-line"><span class="token plain">        setupState: EMPTY_OBJ,</span></div><div class="token-line"><span class="token plain">        // setup 函数上下文数据</span></div><div class="token-line"><span class="token plain">        setupContext: null,</span></div><div class="token-line"><span class="token plain">        // 注册的组件</span></div><div class="token-line"><span class="token plain">        components: Object.create(appContext.components),</span></div><div class="token-line"><span class="token plain">        // 注册的指令</span></div><div class="token-line"><span class="token plain">        directives: Object.create(appContext.directives),</span></div><div class="token-line"><span class="token plain">        // suspense 相关</span></div><div class="token-line"><span class="token plain">        suspense,</span></div><div class="token-line"><span class="token plain">        // suspense 异步依赖</span></div><div class="token-line"><span class="token plain">        asyncDep: null,</span></div><div class="token-line"><span class="token plain">        // suspense 异步依赖是否都已处理</span></div><div class="token-line"><span class="token plain">        asyncResolved: false,</span></div><div class="token-line"><span class="token plain">        // 是否挂载</span></div><div class="token-line"><span class="token plain">        isMounted: false,</span></div><div class="token-line"><span class="token plain">        // 是否卸载</span></div><div class="token-line"><span class="token plain">        isUnmounted: false,</span></div><div class="token-line"><span class="token plain">        // 是否激活</span></div><div class="token-line"><span class="token plain">        isDeactivated: false,</span></div><div class="token-line"><span class="token plain">        // 生命周期，before create</span></div><div class="token-line"><span class="token plain">        bc: null,</span></div><div class="token-line"><span class="token plain">        // 生命周期，created</span></div><div class="token-line"><span class="token plain">        c: null,</span></div><div class="token-line"><span class="token plain">        // 生命周期，before mount</span></div><div class="token-line"><span class="token plain">        bm: null,</span></div><div class="token-line"><span class="token plain">        // 生命周期，mounted</span></div><div class="token-line"><span class="token plain">        m: null,</span></div><div class="token-line"><span class="token plain">        // 生命周期，before update</span></div><div class="token-line"><span class="token plain">        bu: null,</span></div><div class="token-line"><span class="token plain">        // 生命周期，updated</span></div><div class="token-line"><span class="token plain">        u: null,</span></div><div class="token-line"><span class="token plain">        // 生命周期，unmounted</span></div><div class="token-line"><span class="token plain">        um: null,</span></div><div class="token-line"><span class="token plain">        // 生命周期，before unmount</span></div><div class="token-line"><span class="token plain">        bum: null,</span></div><div class="token-line"><span class="token plain">        // 生命周期, deactivated</span></div><div class="token-line"><span class="token plain">        da: null,</span></div><div class="token-line"><span class="token plain">        // 生命周期 activated</span></div><div class="token-line"><span class="token plain">        a: null,</span></div><div class="token-line"><span class="token plain">        // 生命周期 render triggered</span></div><div class="token-line"><span class="token plain">        rtg: null,</span></div><div class="token-line"><span class="token plain">        // 生命周期 render tracked</span></div><div class="token-line"><span class="token plain">        rtc: null,</span></div><div class="token-line"><span class="token plain">        // 生命周期 error captured</span></div><div class="token-line"><span class="token plain">        ec: null,</span></div><div class="token-line"><span class="token plain">        // 派发事件方法</span></div><div class="token-line"><span class="token plain">        emit: null</span></div><div class="token-line"><span class="token plain">      }</span></div><div class="token-line"><span class="token plain">      // 初始化渲染上下文</span></div><div class="token-line"><span class="token plain">      instance.ctx = { _: instance }</span></div><div class="token-line"><span class="token plain">      // 初始化根组件指针</span></div><div class="token-line"><span class="token plain">      instance.root = parent ? parent.root : instance</span></div><div class="token-line"><span class="token plain">      // 初始化派发事件方法</span></div><div class="token-line"><span class="token plain">      instance.emit = emit.bind(null, instance)</span></div><div class="token-line"><span class="token plain">      return instance</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>从上述代码中可以看到，组件实例 instance 上定义了很多属性，你千万不要被这茫茫多的属性吓到，因为其中一些属性是为了实现某个场景或者某个功能所定义的，你只需要通过我在代码中的注释大概知道它们是做什么的即可。</p><p>Vue.js 2.x 使用 new Vue 来初始化一个组件的实例，到了 Vue.js 3.0，我们直接通过创建对象去创建组件的实例。这两种方式并无本质的区别，都是引用一个对象，在整个组件的生命周期中去维护组件的状态数据和上下文环境。</p><p>创建好 instance 实例后，接下来就是设置它的一些属性。目前已完成了组件的上下文、根组件指针以及派发事件方法的设置。我们在后面会继续分析更多 instance 实例属性的设置逻辑。</p><p>接着是<strong>组件实例的设置流程</strong>，对 setup 函数的处理就在这里完成，我们来看一下 setupComponent 方法的实现：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">function setupComponent (instance, isSSR = false) {</span></div><div class="token-line"><span class="token plain">      const { props, children, shapeFlag } = instance.vnode</span></div><div class="token-line"><span class="token plain">      // 判断是否是一个有状态的组件</span></div><div class="token-line"><span class="token plain">      const isStateful = shapeFlag &amp; 4</span></div><div class="token-line"><span class="token plain">      // 初始化 props</span></div><div class="token-line"><span class="token plain">      initProps(instance, props, isStateful, isSSR)</span></div><div class="token-line"><span class="token plain">      // 初始化 插槽</span></div><div class="token-line"><span class="token plain">      initSlots(instance, children)</span></div><div class="token-line"><span class="token plain">      // 设置有状态的组件实例</span></div><div class="token-line"><span class="token plain">      const setupResult = isStateful</span></div><div class="token-line"><span class="token plain">        ? setupStatefulComponent(instance, isSSR)</span></div><div class="token-line"><span class="token plain">        : undefined</span></div><div class="token-line"><span class="token plain">      return setupResult</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>可以看到，我们从组件 vnode 中获取了 props、children、shapeFlag 等属性，然后分别对 props 和插槽进行初始化，这两部分逻辑在后续的章节再详细分析。根据 shapeFlag 的值，我们可以判断这是不是一个有状态组件，如果是则要进一步去设置有状态组件的实例。</p><p>接下来我们要关注到 setupStatefulComponent 函数，它主要做了三件事：创建渲染上下文代理、判断处理 setup 函数和完成组件实例设置。它代码如下所示：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">function setupStatefulComponent (instance, isSSR) {</span></div><div class="token-line"><span class="token plain">      const Component = instance.type</span></div><div class="token-line"><span class="token plain">      // 创建渲染代理的属性访问缓存</span></div><div class="token-line"><span class="token plain">      instance.accessCache = {}</span></div><div class="token-line"><span class="token plain">      // 创建渲染上下文代理</span></div><div class="token-line"><span class="token plain">      instance.proxy = new Proxy(instance.ctx, PublicInstanceProxyHandlers)</span></div><div class="token-line"><span class="token plain">      // 判断处理 setup 函数</span></div><div class="token-line"><span class="token plain">      const { setup } = Component</span></div><div class="token-line"><span class="token plain">      if (setup) {</span></div><div class="token-line"><span class="token plain">        // 如果 setup 函数带参数，则创建一个 setupContext</span></div><div class="token-line"><span class="token plain">        const setupContext = (instance.setupContext =</span></div><div class="token-line"><span class="token plain">          setup.length &gt; 1 ? createSetupContext(instance) : null)</span></div><div class="token-line"><span class="token plain">        // 执行 setup 函数，获取结果</span></div><div class="token-line"><span class="token plain">        const setupResult = callWithErrorHandling(setup, instance, 0 /* SETUP_FUNCTION */, [instance.props, setupContext])</span></div><div class="token-line"><span class="token plain">        // 处理 setup 执行结果</span></div><div class="token-line"><span class="token plain">        handleSetupResult(instance, setupResult)</span></div><div class="token-line"><span class="token plain">      }</span></div><div class="token-line"><span class="token plain">      else {</span></div><div class="token-line"><span class="token plain">        // 完成组件实例设置</span></div><div class="token-line"><span class="token plain">        finishComponentSetup(instance)</span></div><div class="token-line"><span class="token plain">      }</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><h3 id="创建渲染上下文代理"><a aria-hidden="true" tabindex="-1" href="/blog/vue3源码分析/03.模块二学会新设计composition-api/02#创建渲染上下文代理"><span class="icon icon-link"></span></a>创建渲染上下文代理</h3><p>首先是创建渲染上下文代理的流程，它主要对 instance.ctx 做了代理。在分析实现前，我们需要思考一个问题，这里为什么需要代理呢？</p><p>其实在 Vue.js 2.x 中，也有类似的数据代理逻辑，比如 props 求值后的数据，实际上存储在 this._props 上，而 data 中定义的数据存储在 this._data 上。举个例子：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">&lt;template&gt;</span></div><div class="token-line"><span class="token plain">      &lt;p&gt;{{ msg }}&lt;/p&gt;</span></div><div class="token-line"><span class="token plain">    &lt;/template&gt;</span></div><div class="token-line"><span class="token plain">    &lt;script&gt;</span></div><div class="token-line"><span class="token plain">    export default {</span></div><div class="token-line"><span class="token plain">      data() {</span></div><div class="token-line"><span class="token plain">        msg: 1</span></div><div class="token-line"><span class="token plain">      }</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    &lt;/script&gt;</span></div></pre></div><p>在初始化组件的时候，data 中定义的 msg 在组件内部是存储在 this._data 上的，而模板渲染的时候访问 this.msg，实际上访问的是 this._data.msg，这是因为 Vue.js 2.x 在初始化 data 的时候，做了一层 proxy 代理。</p><p>到了 Vue.js 3.0，为了方便维护，我们把组件中不同状态的数据存储到不同的属性中，比如存储到 setupState、ctx、data、props 中。我们在执行组件渲染函数的时候，为了方便用户使用，会直接访问渲染上下文 instance.ctx 中的属性，所以我们也要做一层 proxy，对渲染上下文 instance.ctx 属性的访问和修改，代理到对 setupState、ctx、data、props 中的数据的访问和修改。</p><p>明确了代理的需求后，我们接下来就要分析 proxy 的几个方法： get、set 和 has。</p><p>当我们<strong>访问 instance.ctx 渲染上下文中的属性</strong>时，就会<strong>进入 get 函数</strong>。我们来看一下它的实现：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">const PublicInstanceProxyHandlers = {</span></div><div class="token-line"><span class="token plain">      get ({ _: instance }, key) {</span></div><div class="token-line"><span class="token plain">        const { ctx, setupState, data, props, accessCache, type, appContext } = instance</span></div><div class="token-line"><span class="token plain">        if (key[0] !== &#x27;$&#x27;) {</span></div><div class="token-line"><span class="token plain">          // setupState / data / props / ctx</span></div><div class="token-line"><span class="token plain">          // 渲染代理的属性访问缓存中</span></div><div class="token-line"><span class="token plain">          const n = accessCache[key]</span></div><div class="token-line"><span class="token plain">          if (n !== undefined) {</span></div><div class="token-line"><span class="token plain">            // 从缓存中取</span></div><div class="token-line"><span class="token plain">            switch (n) {</span></div><div class="token-line"><span class="token plain">              case 0: /* SETUP */</span></div><div class="token-line"><span class="token plain">                return setupState[key]</span></div><div class="token-line"><span class="token plain">              case 1 :/* DATA */</span></div><div class="token-line"><span class="token plain">                return data[key]</span></div><div class="token-line"><span class="token plain">              case 3 :/* CONTEXT */</span></div><div class="token-line"><span class="token plain">                return ctx[key]</span></div><div class="token-line"><span class="token plain">              case 2: /* PROPS */</span></div><div class="token-line"><span class="token plain">                return props[key]</span></div><div class="token-line"><span class="token plain">            }</span></div><div class="token-line"><span class="token plain">          }</span></div><div class="token-line"><span class="token plain">          else if (setupState !== EMPTY_OBJ &amp;&amp; hasOwn(setupState, key)) {</span></div><div class="token-line"><span class="token plain">            accessCache[key] = 0</span></div><div class="token-line"><span class="token plain">            // 从 setupState 中取数据</span></div><div class="token-line"><span class="token plain">            return setupState[key]</span></div><div class="token-line"><span class="token plain">          }</span></div><div class="token-line"><span class="token plain">          else if (data !== EMPTY_OBJ &amp;&amp; hasOwn(data, key)) {</span></div><div class="token-line"><span class="token plain">            accessCache[key] = 1</span></div><div class="token-line"><span class="token plain">            // 从 data 中取数据</span></div><div class="token-line"><span class="token plain">            return data[key]</span></div><div class="token-line"><span class="token plain">          }</span></div><div class="token-line"><span class="token plain">          else if (</span></div><div class="token-line"><span class="token plain">            type.props &amp;&amp;</span></div><div class="token-line"><span class="token plain">            hasOwn(normalizePropsOptions(type.props)[0], key)) {</span></div><div class="token-line"><span class="token plain">            accessCache[key] = 2</span></div><div class="token-line"><span class="token plain">            // 从 props 中取数据</span></div><div class="token-line"><span class="token plain">            return props[key]</span></div><div class="token-line"><span class="token plain">          }</span></div><div class="token-line"><span class="token plain">          else if (ctx !== EMPTY_OBJ &amp;&amp; hasOwn(ctx, key)) {</span></div><div class="token-line"><span class="token plain">            accessCache[key] = 3</span></div><div class="token-line"><span class="token plain">            // 从 ctx 中取数据</span></div><div class="token-line"><span class="token plain">            return ctx[key]</span></div><div class="token-line"><span class="token plain">          }</span></div><div class="token-line"><span class="token plain">          else {</span></div><div class="token-line"><span class="token plain">            // 都取不到</span></div><div class="token-line"><span class="token plain">            accessCache[key] = 4</span></div><div class="token-line"><span class="token plain">          }</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        const publicGetter = publicPropertiesMap[key]</span></div><div class="token-line"><span class="token plain">        let cssModule, globalProperties</span></div><div class="token-line"><span class="token plain">        // 公开的 $xxx 属性或方法</span></div><div class="token-line"><span class="token plain">        if (publicGetter) {</span></div><div class="token-line"><span class="token plain">          return publicGetter(instance)</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        else if (</span></div><div class="token-line"><span class="token plain">          // css 模块，通过 vue-loader 编译的时候注入</span></div><div class="token-line"><span class="token plain">          (cssModule = type.__cssModules) &amp;&amp;</span></div><div class="token-line"><span class="token plain">          (cssModule = cssModule[key])) {</span></div><div class="token-line"><span class="token plain">          return cssModule</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        else if (ctx !== EMPTY_OBJ &amp;&amp; hasOwn(ctx, key)) {</span></div><div class="token-line"><span class="token plain">          // 用户自定义的属性，也用 `$` 开头</span></div><div class="token-line"><span class="token plain">          accessCache[key] = 3</span></div><div class="token-line"><span class="token plain">          return ctx[key]</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        else if (</span></div><div class="token-line"><span class="token plain">          // 全局定义的属性</span></div><div class="token-line"><span class="token plain">          ((globalProperties = appContext.config.globalProperties),</span></div><div class="token-line"><span class="token plain">            hasOwn(globalProperties, key))) {</span></div><div class="token-line"><span class="token plain">          return globalProperties[key]</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        else if ((process.env.NODE_ENV !== &#x27;production&#x27;) &amp;&amp;</span></div><div class="token-line"><span class="token plain">          currentRenderingInstance &amp;&amp; key.indexOf(&#x27;__v&#x27;) !== 0) {</span></div><div class="token-line"><span class="token plain">          if (data !== EMPTY_OBJ &amp;&amp; key[0] === &#x27;$&#x27; &amp;&amp; hasOwn(data, key)) {</span></div><div class="token-line"><span class="token plain">            // 如果在 data 中定义的数据以 $ 开头，会报警告，因为 $ 是保留字符，不会做代理</span></div><div class="token-line"><span class="token plain">            warn(`Property ${JSON.stringify(key)} must be accessed via $data because it starts with a reserved ` +</span></div><div class="token-line"><span class="token plain">              `character and is not proxied on the render context.`)</span></div><div class="token-line"><span class="token plain">          }</span></div><div class="token-line"><span class="token plain">          else {</span></div><div class="token-line"><span class="token plain">            // 在模板中使用的变量如果没有定义，报警告</span></div><div class="token-line"><span class="token plain">            warn(`Property ${JSON.stringify(key)} was accessed during render ` +</span></div><div class="token-line"><span class="token plain">              `but is not defined on instance.`)</span></div><div class="token-line"><span class="token plain">          }</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">      }</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>可以看到，函数首先判断 key 不以 $ 开头的情况，这部分数据可能是 setupState、data、props、ctx 中的一种，其中 data、props 我们已经很熟悉了；setupState 就是 setup 函数返回的数据，稍后我们会详细说；ctx 包括了计算属性、组件方法和用户自定义的一些数据。</p><p>如果 key 不以 $ 开头，那么就依次判断 setupState、data、props、ctx 中是否包含这个 key，如果包含就返回对应值。<strong>注意这个判断顺序很重要</strong>，<strong>在 key 相同时它会决定数据获取的优先级</strong>，举个例子：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">&lt;template&gt;</span></div><div class="token-line"><span class="token plain">      &lt;p&gt;{{msg}}&lt;/p&gt;</span></div><div class="token-line"><span class="token plain">    &lt;/template&gt;</span></div><div class="token-line"><span class="token plain">    &lt;script&gt;</span></div><div class="token-line"><span class="token plain">      import { ref } from &#x27;vue&#x27;</span></div><div class="token-line"><span class="token plain">      export default {</span></div><div class="token-line"><span class="token plain">        data() {</span></div><div class="token-line"><span class="token plain">          return {</span></div><div class="token-line"><span class="token plain">            msg: &#x27;msg from data&#x27;</span></div><div class="token-line"><span class="token plain">          }</span></div><div class="token-line"><span class="token plain">        },</span></div><div class="token-line"><span class="token plain">        setup() {</span></div><div class="token-line"><span class="token plain">          const msg = ref(&#x27;msg from setup&#x27;)</span></div><div class="token-line"><span class="token plain">          return {</span></div><div class="token-line"><span class="token plain">            msg</span></div><div class="token-line"><span class="token plain">          }</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">      }</span></div><div class="token-line"><span class="token plain">    &lt;/script&gt;</span></div></pre></div><p>我们在 data 和 setup 中都定义了 msg 变量，但最终输出到界面上的是&quot;msg from setup&quot;，这是因为 setupState 的判断优先级要高于 data。</p><p>再回到 get 函数中，我们可以看到这里定义了 accessCache 作为渲染代理的属性访问缓存，它具体是干什么的呢？组件在渲染时会经常访问数据进而触发 get 函数，这其中最昂贵的部分就是多次调用 hasOwn 去判断 key 在不在某个类型的数据中，但是在普通对象上执行简单的属性访问相对要快得多。所以在第一次获取 key 对应的数据后，我们利用 accessCache[key] 去缓存数据，下一次再次根据 key 查找数据，我们就可以直接通过 accessCache[key] 获取对应的值，就不需要依次调用 hasOwn 去判断了。这也是一个性能优化的小技巧。</p><p>如果 key 以 $ 开头，那么接下来又会有一系列的判断，首先判断是不是 Vue.js 内部公开的 $xxx 属性或方法（比如 $parent）；然后判断是不是 vue-loader 编译注入的 css 模块内部的 key；接着判断是不是用户自定义以 $ 开头的 key；最后判断是不是全局属性。如果都不满足，就剩两种情况了，即在非生产环境下就会报两种类型的警告，第一种是在 data 中定义的数据以 $ 开头的警告，因为 $ 是保留字符，不会做代理；第二种是在模板中使用的变量没有定义的警告。</p><p>接下来是 set 代理过程，当我们<strong>修改 instance.ctx 渲染上下文中的属性</strong>的时候，就会<strong>进入 set 函数</strong>。我们来看一下 set 函数的实现：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">const PublicInstanceProxyHandlers = {</span></div><div class="token-line"><span class="token plain">      set ({ _: instance }, key, value) {</span></div><div class="token-line"><span class="token plain">        const { data, setupState, ctx } = instance</span></div><div class="token-line"><span class="token plain">        if (setupState !== EMPTY_OBJ &amp;&amp; hasOwn(setupState, key)) {</span></div><div class="token-line"><span class="token plain">          // 给 setupState 赋值</span></div><div class="token-line"><span class="token plain">          setupState[key] = value</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        else if (data !== EMPTY_OBJ &amp;&amp; hasOwn(data, key)) {</span></div><div class="token-line"><span class="token plain">          // 给 data 赋值</span></div><div class="token-line"><span class="token plain">          data[key] = value</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        else if (key in instance.props) {</span></div><div class="token-line"><span class="token plain">          // 不能直接给 props 赋值</span></div><div class="token-line"><span class="token plain">          (process.env.NODE_ENV !== &#x27;production&#x27;) &amp;&amp;</span></div><div class="token-line"><span class="token plain">          warn(`Attempting to mutate prop &quot;${key}&quot;. Props are readonly.`, instance)</span></div><div class="token-line"><span class="token plain">          return false</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        if (key[0] === &#x27;$&#x27; &amp;&amp; key.slice(1) in instance) {</span></div><div class="token-line"><span class="token plain">          // 不能给 Vue 内部以 $ 开头的保留属性赋值</span></div><div class="token-line"><span class="token plain">          (process.env.NODE_ENV !== &#x27;production&#x27;) &amp;&amp;</span></div><div class="token-line"><span class="token plain">          warn(`Attempting to mutate public property &quot;${key}&quot;. ` +</span></div><div class="token-line"><span class="token plain">            `Properties starting with $ are reserved and readonly.`, instance)</span></div><div class="token-line"><span class="token plain">          return false</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        else {</span></div><div class="token-line"><span class="token plain">          // 用户自定义数据赋值</span></div><div class="token-line"><span class="token plain">          ctx[key] = value</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        return true</span></div><div class="token-line"><span class="token plain">      }</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>结合代码来看，函数主要做的事情就是对渲染上下文 instance.ctx 中的属性赋值，它实际上是代理到对应的数据类型中去完成赋值操作的。这里仍然要注意顺序问题，和 get 一样，优先判断 setupState，然后是 data，接着是 props。</p><p>我们对之前的例子做点修改，添加一个方法：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">&lt;template&gt;</span></div><div class="token-line"><span class="token plain">      &lt;p&gt;{{ msg }}&lt;/p&gt;</span></div><div class="token-line"><span class="token plain">      &lt;button @click=&quot;random&quot;&gt;Random msg&lt;/button&gt;</span></div><div class="token-line"><span class="token plain">    &lt;/template&gt;</span></div><div class="token-line"><span class="token plain">    &lt;script&gt;</span></div><div class="token-line"><span class="token plain">      import { ref } from &#x27;vue&#x27;</span></div><div class="token-line"><span class="token plain">      export default {</span></div><div class="token-line"><span class="token plain">        data() {</span></div><div class="token-line"><span class="token plain">          return {</span></div><div class="token-line"><span class="token plain">            msg: &#x27;msg from data&#x27;</span></div><div class="token-line"><span class="token plain">          }</span></div><div class="token-line"><span class="token plain">        },</span></div><div class="token-line"><span class="token plain">        setup() {</span></div><div class="token-line"><span class="token plain">          const msg = ref(&#x27;msg from setup&#x27;)</span></div><div class="token-line"><span class="token plain">          return {</span></div><div class="token-line"><span class="token plain">            msg</span></div><div class="token-line"><span class="token plain">          }</span></div><div class="token-line"><span class="token plain">        },</span></div><div class="token-line"><span class="token plain">        methods: {</span></div><div class="token-line"><span class="token plain">          random() {</span></div><div class="token-line"><span class="token plain">            this.msg = Math.random()</span></div><div class="token-line"><span class="token plain">          }</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">      }</span></div><div class="token-line"><span class="token plain">    &lt;/script&gt;</span></div></pre></div><p>我们点击按钮会执行 random 函数，这里的 this 指向的就是 instance.ctx，我们修改 this.msg 会触发 set 函数，所以最终修改的是 setupState 中的 msg 对应的值。</p><p>注意，如果我们直接对 props 中的数据赋值，在非生产环境中会收到一条警告，这是因为直接修改 props 不符合数据单向流动的设计思想；如果对 Vue.js 内部以 $ 开头的保留属性赋值，同样也会收到一条警告。</p><p>如果是用户自定义的数据，比如在 created 生命周期内定义的数据，它仅用于组件上下文的共享，如下所示：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">export default {</span></div><div class="token-line"><span class="token plain">      created() {</span></div><div class="token-line"><span class="token plain">        this.userMsg = &#x27;msg from user&#x27;</span></div><div class="token-line"><span class="token plain">      }</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>当执行 this.userMsg 赋值的时候，会触发 set 函数，最终 userMsg 会被保留到 ctx 中。</p><p>最后是 has 代理过程，当我们<strong>判断属性是否存在于 instance.ctx 渲染上下文中</strong>时，就<strong>会进入 has 函数</strong>，这个在平时项目中用的比较少，同样来举个例子，当执行 created 钩子函数中的 &#x27;msg&#x27; in this 时，就会触发 has 函数。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">export default {</span></div><div class="token-line"><span class="token plain">      created () {</span></div><div class="token-line"><span class="token plain">        console.log(&#x27;msg&#x27; in this)</span></div><div class="token-line"><span class="token plain">      }</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>下面我们来看一下 has 函数的实现：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">const PublicInstanceProxyHandlers = {</span></div><div class="token-line"><span class="token plain">      has</span></div><div class="token-line"><span class="token plain">        ({ _: { data, setupState, accessCache, ctx, type, appContext } }, key) {</span></div><div class="token-line"><span class="token plain">        // 依次判断</span></div><div class="token-line"><span class="token plain">        return (accessCache[key] !== undefined ||</span></div><div class="token-line"><span class="token plain">          (data !== EMPTY_OBJ &amp;&amp; hasOwn(data, key)) ||</span></div><div class="token-line"><span class="token plain">          (setupState !== EMPTY_OBJ &amp;&amp; hasOwn(setupState, key)) ||</span></div><div class="token-line"><span class="token plain">          (type.props &amp;&amp; hasOwn(normalizePropsOptions(type.props)[0], key)) ||</span></div><div class="token-line"><span class="token plain">          hasOwn(ctx, key) ||</span></div><div class="token-line"><span class="token plain">          hasOwn(publicPropertiesMap, key) ||</span></div><div class="token-line"><span class="token plain">          hasOwn(appContext.config.globalProperties, key))</span></div><div class="token-line"><span class="token plain">      }</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>这个函数的实现很简单，依次判断 key 是否存在于 accessCache、data、setupState、props 、用户数据、公开属性以及全局属性中，然后返回结果。</p><p>至此，我们就搞清楚了创建上下文代理的过程，让我们回到 setupStatefulComponent 函数中，接下来分析第二个流程——判断处理 setup 函数。</p><h3 id="判断处理-setup-函数"><a aria-hidden="true" tabindex="-1" href="/blog/vue3源码分析/03.模块二学会新设计composition-api/02#判断处理-setup-函数"><span class="icon icon-link"></span></a>判断处理 setup 函数</h3><p>我们看一下整个逻辑涉及的代码：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// 判断处理 setup 函数</span></div><div class="token-line"><span class="token plain">    const { setup } = Component</span></div><div class="token-line"><span class="token plain">    if (setup) {</span></div><div class="token-line"><span class="token plain">      // 如果 setup 函数带参数，则创建一个 setupContext</span></div><div class="token-line"><span class="token plain">      const setupContext = (instance.setupContext =</span></div><div class="token-line"><span class="token plain">        setup.length &gt; 1 ? createSetupContext(instance) : null)</span></div><div class="token-line"><span class="token plain">      // 执行 setup 函数获取结果</span></div><div class="token-line"><span class="token plain">      const setupResult = callWithErrorHandling(setup, instance, 0 /* SETUP_FUNCTION */, [instance.props, setupContext])</span></div><div class="token-line"><span class="token plain">      // 处理 setup 执行结果</span></div><div class="token-line"><span class="token plain">      handleSetupResult(instance, setupResult)</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>如果我们在组件中定义了 setup 函数，接下来就是处理 setup 函数的流程，主要是三个步骤：创建 setup 函数上下文、执行 setup 函数并获取结果和处理 setup 函数的执行结果。接下来我们就逐个来分析。</p><p>首先<strong>判断 setup 函数的参数长度</strong>，<strong>如果大于 1</strong>，<strong>则创建 setupContext 上下文</strong>。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">const setupContext = (instance.setupContext =</span></div><div class="token-line"><span class="token plain">        setup.length &gt; 1 ? createSetupContext(instance) : null)</span></div></pre></div><p>举个例子，我们有个 HelloWorld 子组件，如下：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">&lt;template&gt;</span></div><div class="token-line"><span class="token plain">      &lt;p&gt;{{ msg }}&lt;/p&gt;</span></div><div class="token-line"><span class="token plain">      &lt;button @click=&quot;onClick&quot;&gt;Toggle&lt;/button&gt;</span></div><div class="token-line"><span class="token plain">    &lt;/template&gt;</span></div><div class="token-line"><span class="token plain">    &lt;script&gt;</span></div><div class="token-line"><span class="token plain">      export default {</span></div><div class="token-line"><span class="token plain">        props: {</span></div><div class="token-line"><span class="token plain">          msg: String</span></div><div class="token-line"><span class="token plain">        },</span></div><div class="token-line"><span class="token plain">        setup (props, { emit }) {</span></div><div class="token-line"><span class="token plain">          function onClick () {</span></div><div class="token-line"><span class="token plain">            emit(&#x27;toggle&#x27;)</span></div><div class="token-line"><span class="token plain">          }</span></div><div class="token-line"><span class="token plain">          return {</span></div><div class="token-line"><span class="token plain">            onClick</span></div><div class="token-line"><span class="token plain">          }</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">      }</span></div><div class="token-line"><span class="token plain">    &lt;/script&gt;</span></div></pre></div><p>我们在父组件引用这个组件：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">&lt;template&gt;</span></div><div class="token-line"><span class="token plain">      &lt;HelloWorld @toggle=&quot;toggle&quot; :msg=&quot;msg&quot;&gt;&lt;/HelloWorld&gt;</span></div><div class="token-line"><span class="token plain">    &lt;/template&gt;</span></div><div class="token-line"><span class="token plain">    &lt;script&gt;</span></div><div class="token-line"><span class="token plain">      import { ref } from &#x27;vue&#x27;</span></div><div class="token-line"><span class="token plain">      import HelloWorld from &quot;./components/HelloWorld&quot;;</span></div><div class="token-line"><span class="token plain">      export default {</span></div><div class="token-line"><span class="token plain">        components: { HelloWorld },</span></div><div class="token-line"><span class="token plain">        setup () {</span></div><div class="token-line"><span class="token plain">          const msg = ref(&#x27;Hello World&#x27;)</span></div><div class="token-line"><span class="token plain">          function toggle () {</span></div><div class="token-line"><span class="token plain">            msg.value = msg.value === &#x27;Hello World&#x27; ? &#x27;Hello Vue&#x27; : &#x27;Hello World&#x27;</span></div><div class="token-line"><span class="token plain">          }</span></div><div class="token-line"><span class="token plain">          return {</span></div><div class="token-line"><span class="token plain">            toggle,</span></div><div class="token-line"><span class="token plain">            msg</span></div><div class="token-line"><span class="token plain">          }</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">      }</span></div><div class="token-line"><span class="token plain">    &lt;/script&gt;</span></div></pre></div><p>可以看到，HelloWorld 子组件的 setup 函数接收两个参数，第一个参数 props 对应父组件传入的 props 数据，第二个参数 emit 是一个对象，实际上就是 setupContext。</p><p>下面我们来看一下用 createSetupContext 函数来创建 setupContext：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">function createSetupContext (instance) {</span></div><div class="token-line"><span class="token plain">      return {</span></div><div class="token-line"><span class="token plain">        attrs: instance.attrs,</span></div><div class="token-line"><span class="token plain">        slots: instance.slots,</span></div><div class="token-line"><span class="token plain">        emit: instance.emit</span></div><div class="token-line"><span class="token plain">      }</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>这里返回了一个对象，包括 attrs、slots 和 emit 三个属性。setupContext 让我们在 setup 函数内部可以获取到组件的属性、插槽以及派发事件的方法 emit。</p><p>可以预见的是，这个 setupContext 对应的就是 setup 函数第二个参数，我们接下来看一下 setup 函数具体是如何执行的。</p><p>我们通过下面这行代码来<strong>执行 setup 函数并获取结果</strong>：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">const setupResult = callWithErrorHandling(setup, instance, 0 /* SETUP_FUNCTION */, [instance.props, setupContext])</span></div></pre></div><p>我们具体来看一下 callWithErrorHandling 函数的实现：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">function callWithErrorHandling (fn, instance, type, args) {</span></div><div class="token-line"><span class="token plain">      let res</span></div><div class="token-line"><span class="token plain">      try {</span></div><div class="token-line"><span class="token plain">        res = args ? fn(...args) : fn()</span></div><div class="token-line"><span class="token plain">      }</span></div><div class="token-line"><span class="token plain">      catch (err) {</span></div><div class="token-line"><span class="token plain">        handleError(err, instance, type)</span></div><div class="token-line"><span class="token plain">      }</span></div><div class="token-line"><span class="token plain">      return res</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>可以看到，它其实就是对 fn 做的一层包装，内部还是执行了 fn，并在有参数的时候传入参数，所以 setup 的第一个参数是 instance.props，第二个参数是 setupContext。函数执行过程中如果有 JavaScript 执行错误就会捕获错误，并执行 handleError 函数来处理。</p><p>执行 setup 函数并拿到了返回的结果，那么接下来就要<strong>用 handleSetupResult 函数来处理结果</strong>。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">handleSetupResult(instance, setupResult)</span></div></pre></div><p>我们详细看一下 handleSetupResult 函数的实现：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">function handleSetupResult(instance, setupResult) {</span></div><div class="token-line"><span class="token plain">      if (isFunction(setupResult)) {</span></div><div class="token-line"><span class="token plain">        // setup 返回渲染函数</span></div><div class="token-line"><span class="token plain">        instance.render = setupResult</span></div><div class="token-line"><span class="token plain">      }</span></div><div class="token-line"><span class="token plain">      else if (isObject(setupResult)) {</span></div><div class="token-line"><span class="token plain">        // 把 setup 返回结果变成响应式</span></div><div class="token-line"><span class="token plain">        instance.setupState = reactive(setupResult)</span></div><div class="token-line"><span class="token plain">      }</span></div><div class="token-line"><span class="token plain">      finishComponentSetup(instance)</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>可以看到，当 setupResult 是一个对象的时候，我们把它变成了响应式并赋值给 instance.setupState，这样在模板渲染的时候，依据前面的代理规则，instance.ctx 就可以从 instance.setupState 上获取到对应的数据，这就在 setup 函数与模板渲染间建立了联系。</p><p>另外 setup 不仅仅支持返回一个对象，也可以返回一个函数作为组件的渲染函数。我们可以改写前面的示例，来看一下这时的情况：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">&lt;script&gt;</span></div><div class="token-line"><span class="token plain">      import { h } from &#x27;vue&#x27;</span></div><div class="token-line"><span class="token plain">      export default {</span></div><div class="token-line"><span class="token plain">        props: {</span></div><div class="token-line"><span class="token plain">          msg: String</span></div><div class="token-line"><span class="token plain">        },</span></div><div class="token-line"><span class="token plain">        setup (props, { emit }) {</span></div><div class="token-line"><span class="token plain">          function onClick () {</span></div><div class="token-line"><span class="token plain">            emit(&#x27;toggle&#x27;)</span></div><div class="token-line"><span class="token plain">          }</span></div><div class="token-line"><span class="token plain">          return (ctx) =&gt; {</span></div><div class="token-line"><span class="token plain">            return [</span></div><div class="token-line"><span class="token plain">              h(&#x27;p&#x27;, null, ctx.msg),</span></div><div class="token-line"><span class="token plain">              h(&#x27;button&#x27;, { onClick: onClick }, &#x27;Toggle&#x27;)</span></div><div class="token-line"><span class="token plain">            ]</span></div><div class="token-line"><span class="token plain">          }</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">      }</span></div><div class="token-line"><span class="token plain">    &lt;/script&gt;</span></div></pre></div><p>这里，我们删除了 HelloWorld 子组件的 template 部分，并把 setup 函数的返回结果改成了函数，也就是说它会作为组件的渲染函数，一切运行正常。</p><p>在 handleSetupResult 的最后，会执行 finishComponentSetup 函数完成组件实例的设置，其实这个函数和 setup 函数的执行结果已经没什么关系了，提取到外面放在 handleSetupResult 函数后面执行更合理一些。</p><p>另外当组件没有定义的 setup 的时候，也会执行 finishComponentSetup 函数去完成组件实例的设置。</p><h3 id="完成组件实例设置"><a aria-hidden="true" tabindex="-1" href="/blog/vue3源码分析/03.模块二学会新设计composition-api/02#完成组件实例设置"><span class="icon icon-link"></span></a>完成组件实例设置</h3><p>接下来我们来看一下 finishComponentSetup 函数的实现：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">function finishComponentSetup (instance) {</span></div><div class="token-line"><span class="token plain">      const Component = instance.type</span></div><div class="token-line"><span class="token plain">      // 对模板或者渲染函数的标准化</span></div><div class="token-line"><span class="token plain">      if (!instance.render) {</span></div><div class="token-line"><span class="token plain">        if (compile &amp;&amp; Component.template &amp;&amp; !Component.render) {</span></div><div class="token-line"><span class="token plain">          // 运行时编译</span></div><div class="token-line"><span class="token plain">          Component.render = compile(Component.template, {</span></div><div class="token-line"><span class="token plain">            isCustomElement: instance.appContext.config.isCustomElement || NO</span></div><div class="token-line"><span class="token plain">          })</span></div><div class="token-line"><span class="token plain">          Component.render._rc = true</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        if ((process.env.NODE_ENV !== &#x27;production&#x27;) &amp;&amp; !Component.render) {</span></div><div class="token-line"><span class="token plain">          if (!compile &amp;&amp; Component.template) {</span></div><div class="token-line"><span class="token plain">            // 只编写了 template 但使用了 runtime-only 的版本</span></div><div class="token-line"><span class="token plain">            warn(`Component provided template option but ` +</span></div><div class="token-line"><span class="token plain">              `runtime compilation is not supported in this build of Vue.` +</span></div><div class="token-line"><span class="token plain">              (` Configure your bundler to alias &quot;vue&quot; to &quot;vue/dist/vue.esm-bundler.js&quot;.`</span></div><div class="token-line"><span class="token plain">              ) /* should not happen */)</span></div><div class="token-line"><span class="token plain">          }</span></div><div class="token-line"><span class="token plain">          else {</span></div><div class="token-line"><span class="token plain">            // 既没有写 render 函数，也没有写 template 模板</span></div><div class="token-line"><span class="token plain">            warn(`Component is missing template or render function.`)</span></div><div class="token-line"><span class="token plain">          }</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        // 组件对象的 render 函数赋值给 instance</span></div><div class="token-line"><span class="token plain">        instance.render = (Component.render || NOOP)</span></div><div class="token-line"><span class="token plain">        if (instance.render._rc) {</span></div><div class="token-line"><span class="token plain">          // 对于使用 with 块的运行时编译的渲染函数，使用新的渲染上下文的代理</span></div><div class="token-line"><span class="token plain">          instance.withProxy = new Proxy(instance.ctx, RuntimeCompiledPublicInstanceProxyHandlers)</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">      }</span></div><div class="token-line"><span class="token plain">      // 兼容 Vue.js 2.x Options API</span></div><div class="token-line"><span class="token plain">      {</span></div><div class="token-line"><span class="token plain">        currentInstance = instance</span></div><div class="token-line"><span class="token plain">        applyOptions(instance, Component)</span></div><div class="token-line"><span class="token plain">        currentInstance = null</span></div><div class="token-line"><span class="token plain">      }</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>函数主要做了两件事情：<strong>标准化模板或者渲染函数和兼容 Options API</strong>。接下来我们详细分析这两个流程。</p><h4 id="标准化模板或者渲染函数"><a aria-hidden="true" tabindex="-1" href="/blog/vue3源码分析/03.模块二学会新设计composition-api/02#标准化模板或者渲染函数"><span class="icon icon-link"></span></a>标准化模板或者渲染函数</h4><p>在分析这个过程之前，我们需要了解一些背景知识。组件最终通过运行 render 函数生成子树 vnode，但是我们很少直接去编写 render 函数，通常会使用两种方式开发组件。</p><p><strong>第一种是使用 SFC（Single File Components）单文件的开发方式来开发组件</strong>，即通过编写组件的 template 模板去描述一个组件的 DOM 结构。我们知道 .vue 类型的文件无法在 Web 端直接加载，因此在 webpack 的编译阶段，它会通过 vue-loader 编译生成组件相关的 JavaScript 和 CSS，并把 template 部分转换成 render 函数添加到组件对象的属性中。</p><p><strong>另外一种开发方式</strong>是不借助 webpack 编译，<strong>直接引入 Vue.js</strong>，开箱即用，我们直接在组件对象 template 属性中编写组件的模板，然后在运行阶段编译生成 render 函数，这种方式通常用于有一定历史包袱的古老项目。</p><p>因此 Vue.js 在 Web 端有两个版本：runtime-only 和 runtime-compiled。我们更推荐用 runtime-only 版本的 Vue.js，因为相对而言它体积更小，而且在运行时不用编译，不仅耗时更少而且性能更优秀。遇到一些不得已的情况比如上述提到的古老项目，我们也可以选择 runtime-compiled 版本。</p><p>runtime-only 和 runtime-compiled 的主要区别在于是否注册了这个 compile 方法。</p><p>在 Vue.js 3.0 中，compile 方法是通过外部注册的：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">let compile;</span></div><div class="token-line"><span class="token plain">    function registerRuntimeCompiler(_compile) {</span></div><div class="token-line"><span class="token plain">        compile = _compile;</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>回到标准化模板或者渲染函数逻辑，我们先看 instance.render 是否存在，如果不存在则开始标准化流程，这里主要需要处理以下三种情况。</p><ol><li><p><strong>compile 和组件 template 属性存在</strong>，<strong>render 方法不存在的情况</strong>。此时， runtime-compiled 版本会在 JavaScript 运行时进行模板编译，生成 render 函数。</p></li><li><p><strong>compile 和 render 方法不存在，组件 template 属性存在的情况</strong>。此时由于没有 compile，这里用的是 runtime-only 的版本，因此要报一个警告来告诉用户，想要运行时编译得使用 runtime-compiled 版本的 Vue.js。</p></li><li><p><strong>组件既没有写 render 函数，也没有写 template 模板</strong>，此时要报一个警告，告诉用户组件缺少了 render 函数或者 template 模板。</p></li></ol><p>处理完以上情况后，就要把组件的 render 函数赋值给 instance.render。到了组件渲染的时候，就可以运行 instance.render 函数生成组件的子树 vnode 了。</p><p>另外对于使用 with 块运行时编译的渲染函数，渲染上下文的代理是 RuntimeCompiledPublicInstanceProxyHandlers，它是在之前渲染上下文代理 PublicInstanceProxyHandlers 的基础上进行的扩展，主要对 has 函数的实现做了优化：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">const RuntimeCompiledPublicInstanceProxyHandlers = {</span></div><div class="token-line"><span class="token plain">      ...PublicInstanceProxyHandlers,</span></div><div class="token-line"><span class="token plain">      get(target, key) {</span></div><div class="token-line"><span class="token plain">        if (key === Symbol.unscopables) {</span></div><div class="token-line"><span class="token plain">          return</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        return PublicInstanceProxyHandlers.get(target, key, target)</span></div><div class="token-line"><span class="token plain">      },</span></div><div class="token-line"><span class="token plain">      has(_, key) {</span></div><div class="token-line"><span class="token plain">        // 如果 key 以 _ 开头或者 key 在全局变量白名单内，则 has 为 false</span></div><div class="token-line"><span class="token plain">        const has = key[0] !== &#x27;_&#x27; &amp;&amp; !isGloballyWhitelisted(key)</span></div><div class="token-line"><span class="token plain">        if ((process.env.NODE_ENV !== &#x27;production&#x27;) &amp;&amp; !has &amp;&amp; PublicInstanceProxyHandlers.has(_, key)) {</span></div><div class="token-line"><span class="token plain">          warn(`Property ${JSON.stringify(key)} should not start with _ which is a reserved prefix for Vue internals.`)</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        return has</span></div><div class="token-line"><span class="token plain">      }</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>这里如果 key 以 _ 开头，或者 key 在全局变量的白名单内，则 has 为 false，此时则直接命中警告，不用再进行之前那一系列的判断了。</p><p>了解完标准化模板或者渲染函数流程，我们来看完成组件实例设置的最后一个流程——兼容 Vue.js 2.x 的 Options API。</p><h4 id="options-api兼容-vuejs-2x"><a aria-hidden="true" tabindex="-1" href="/blog/vue3源码分析/03.模块二学会新设计composition-api/02#options-api兼容-vuejs-2x"><span class="icon icon-link"></span></a>Options API：兼容 Vue.js 2.x</h4><p>我们知道 Vue.js 2.x 是通过组件对象的方式去描述一个组件，之前我们也说过，Vue.js 3.0 仍然支持 Vue.js 2.x Options API 的写法，这主要就是通过 applyOptions方法实现的。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">function applyOptions(instance, options, deferredData = [], deferredWatch = [], asMixin = false) {</span></div><div class="token-line"><span class="token plain">      const {</span></div><div class="token-line"><span class="token plain">        // 组合</span></div><div class="token-line"><span class="token plain">        mixins, extends: extendsOptions,</span></div><div class="token-line"><span class="token plain">        // 数组状态</span></div><div class="token-line"><span class="token plain">        props: propsOptions, data: dataOptions, computed: computedOptions, methods, watch: watchOptions, provide: provideOptions, inject: injectOptions,</span></div><div class="token-line"><span class="token plain">        // 组件和指令</span></div><div class="token-line"><span class="token plain">        components, directives,</span></div><div class="token-line"><span class="token plain">        // 生命周期</span></div><div class="token-line"><span class="token plain">        beforeMount, mounted, beforeUpdate, updated, activated, deactivated, beforeUnmount, unmounted, renderTracked, renderTriggered, errorCaptured } = options;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">      // instance.proxy 作为 this</span></div><div class="token-line"><span class="token plain">      const publicThis = instance.proxy;</span></div><div class="token-line"><span class="token plain">      const ctx = instance.ctx;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">      // 处理全局 mixin</span></div><div class="token-line"><span class="token plain">      // 处理 extend</span></div><div class="token-line"><span class="token plain">      // 处理本地 mixins</span></div><div class="token-line"><span class="token plain">      // props 已经在外面处理过了</span></div><div class="token-line"><span class="token plain">      // 处理 inject</span></div><div class="token-line"><span class="token plain">      // 处理 方法</span></div><div class="token-line"><span class="token plain">      // 处理 data</span></div><div class="token-line"><span class="token plain">      // 处理计算属性</span></div><div class="token-line"><span class="token plain">      // 处理 watch</span></div><div class="token-line"><span class="token plain">      // 处理 provide</span></div><div class="token-line"><span class="token plain">      // 处理组件</span></div><div class="token-line"><span class="token plain">      // 处理指令</span></div><div class="token-line"><span class="token plain">      // 处理生命周期 option</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>由于 applyOptions 的代码特别长，所以这里我用注释列出了它主要做的事情，感兴趣的同学可以去翻阅它的源码。</p><h3 id="总结"><a aria-hidden="true" tabindex="-1" href="/blog/vue3源码分析/03.模块二学会新设计composition-api/02#总结"><span class="icon icon-link"></span></a>总结</h3><p>这节课我们主要分析了组件的初始化流程，主要包括创建组件实例和设置组件实例。通过进一步细节的深入，我们也了解了渲染上下文的代理过程；了解了 Composition API 中的 setup 启动函数执行的时机，以及如何建立 setup 返回结果和模板渲染之间的联系；了解了组件定义的模板或者渲染函数的标准化过程；了解了如何兼容 Vue.js 2.x 的 Options API。</p><p>我们通过一张图再直观感受一下 Vue.js 3.0 组件的初始化流程：</p><p><img src="https://s0.lgstatic.com/i/image/M00/35/74/Ciqc1F8VZvaAYCgKAAHVSzimXjw614.png" alt="3.png"/></p><p>最后，给你留一道思考题目，在执行 setup 函数并获取结果的时候，我们使用 callWithErrorHandling 把 setup 包装了一层，它有哪些好处？欢迎你在留言区与我分享。</p><blockquote><p><strong>本节课的相关代码在源代码中的位置如下：</strong><br/>packages/runtime-core/src/renderer.ts<br/>packages/runtime-core/src/component.ts<br/>packages/runtime-core/src/componentProxy.ts<br/>packages/runtime-core/src/errorHandling.ts</p></blockquote></div><div class="__dumi-default-layout-footer-meta"><a target="_blank" rel="noopener noreferrer" href="https://github.com/GGwujun/blog/edit/master/docs/vue3源码分析/03.模块二学会新设计CompositionAPI/02.md">在 GitHub 上编辑此页<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a><span data-updated-text="最后更新时间：">5/2/2022 10:56:54</span></div></div></div></div>
	<script>
  window.g_useSSR = true;
  window.g_initialProps = {};
	</script>

    <script>
      (function () {
        if (!location.port) {
          (function (i, s, o, g, r, a, m) {
            i["GoogleAnalyticsObject"] = r;
            (i[r] =
              i[r] ||
              function () {
                (i[r].q = i[r].q || []).push(arguments);
              }),
              (i[r].l = 1 * new Date());
            (a = s.createElement(o)), (m = s.getElementsByTagName(o)[0]);
            a.async = 1;
            a.src = g;
            m.parentNode.insertBefore(a, m);
          })(
            window,
            document,
            "script",
            "//www.google-analytics.com/analytics.js",
            "ga"
          );
          ga("create", "UA-149864185-1", "auto");
          ga("send", "pageview");
        }
      })();
    </script>
    <script src="/blog/umi.js"></script>
  </body>
</html>
