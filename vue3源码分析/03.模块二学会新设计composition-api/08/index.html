<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no"
    />
    <link rel="shortcut icon" type="image/x-icon" href="/logo.png" />
    <link rel="stylesheet" href="/blog/umi.css" />
    <script>
      window.routerBase = "/blog";
    </script>
    <script>
      //! umi version: 3.5.17
    </script>
    <script>
      !(function () {
        var e = localStorage.getItem("dumi:prefers-color"),
          t = window.matchMedia("(prefers-color-scheme: dark)").matches,
          r = ["light", "dark", "auto"];
        document.documentElement.setAttribute(
          "data-prefers-color",
          e === r[2] ? (t ? r[1] : r[0]) : r.indexOf(e) > -1 ? e : r[0]
        );
      })();
    </script>
    <title>10 | 生命周期：各个生命周期的执行时机和应用场景是怎样的？</title>
  </head>
  <body>
    <div id="root"><div class="__dumi-default-layout" data-route="/vue3源码分析/03.模块二学会新设计composition-api/08" data-show-sidemenu="true" data-show-slugs="true" data-site-mode="true" data-gapless="false"><div class="__dumi-default-navbar" data-mode="site"><button class="__dumi-default-navbar-toggle"></button><a class="__dumi-default-navbar-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog/">大师兄</a><nav><div class="__dumi-default-search"><input type="search" class="__dumi-default-search-input" value=""/><ul></ul></div><span>计算机基础<ul><li><a href="/blog/编译原理之美">编译原理之美</a></li><li><a href="/blog/编译原理实战">编译原理实战</a></li><li><a href="/blog/深入浅出计算机组成原理">深入浅出计算机组成原理</a></li><li><a href="/blog/详解http">详解http</a></li><li><a href="/blog/计算机网络通关29讲">计算机网络通关29讲</a></li><li><a href="/blog/网络排查案例课">网络排查案例课</a></li><li><a href="/blog/linux操作系统">linux操作系统</a></li><li><a href="/blog/linux性能优化实战">linux性能优化实战</a></li><li><a href="/blog/程序员数学基础">程序员数学基础</a></li><li><a href="/blog/趣谈网络协议">趣谈网络协议</a></li><li><a href="/blog/操作系统实战">操作系统实战</a></li><li><a href="/blog/软件工程之美">软件工程之美</a></li><li><a href="/blog/sql必知必会">sql必知必会</a></li><li><a href="/blog/操作系统实战45讲">操作系统实战45讲</a></li><li><a href="/blog/网络编程实战">网络编程实战</a></li></ul></span><span>算法<ul><li><a href="/blog/常用算法25讲">常用算法25讲</a></li><li><a href="/blog/数据结构与算法之美">数据结构与算法之美</a></li><li><a href="/blog/业务开发算法50讲">业务开发算法50讲</a></li><li><a href="/blog/动态规划面试宝典">动态规划面试宝典</a></li></ul></span><span>前端开发<ul><li><a href="/blog/浏览器工作原理与实践">浏览器工作原理与实践</a></li><li><a href="/blog/新时代产品经理进阶之路">新时代产品经理进阶之路</a></li><li><a href="/blog/全栈工程师修炼指南">全栈工程师修炼指南</a></li><li><a href="/blog/flutter核心技术与实战">flutter核心技术与实战</a></li><li><a href="/blog/java-script核心原理解析">java-script核心原理解析</a></li><li><a href="/blog/说透低代码">说透低代码</a></li><li><a href="/blog/nodejs应用开发实战">nodejs应用开发实战</a></li><li><a href="/blog/反爬虫兵法演绎20讲">反爬虫兵法演绎20讲</a></li><li><a href="/blog/reactnative新架构实战课">reactnative新架构实战课</a></li><li><a href="/blog/正则表达式入门">正则表达式入门</a></li><li><a href="/blog/重学前端">重学前端</a></li><li><a href="/blog/serverless入门课">serverless入门课</a></li><li><a href="/blog/type-script入门实战笔记">type-script入门实战笔记</a></li><li><a href="/blog/图解googlev8">图解googlev8</a></li><li><a aria-current="page" class="active" href="/blog/vue3源码分析">vue3源码分析</a></li><li><a href="/blog/玩转Vue3全家桶">玩转Vue3全家桶</a></li><li><a href="/blog/webassembly入门">webassembly入门</a></li><li><a href="/blog/手把手带你写一个Web框架">手把手带你写一个Web框架</a></li><li><a href="/blog/web漏洞挖掘实战">web漏洞挖掘实战</a></li><li><a href="/blog/跟月影学可视化">跟月影学可视化</a></li><li><a href="/blog/搞定音频技术">搞定音频技术</a></li><li><a href="/blog/攻克视频技术">攻克视频技术</a></li></ul></span><span>前端工程化<ul><li><a href="/blog/logger">logger</a></li><li><a href="/blog/webpack">webpack</a></li><li><a href="/blog/webpackChain">webpackChain</a></li></ul></span><span>前端性能优化<ul><li><a href="/blog/react性能调优">react性能调优</a></li></ul></span><span>软件测试<ul><li><a href="/blog/全链路压测实战30讲">全链路压测实战30讲</a></li><li><a href="/blog/性能测试实战30讲">性能测试实战30讲</a></li><li><a href="/blog/自动化测试高手课">自动化测试高手课</a></li><li><a href="/blog/软件测试52讲">软件测试52讲</a></li></ul></span><span>面试<ul><li><a href="/blog/面试现场">面试现场</a></li></ul></span><span>杂谈<ul><li><a href="/blog/超级访谈对话张雪峰">超级访谈对话张雪峰</a></li><li><a href="/blog/Git实战手册">Git实战手册</a></li><li><a href="/blog/NodeJS">NodeJS</a></li><li><a href="/blog/ReactJS">ReactJS</a></li><li><a href="/blog/UI设计">UI设计</a></li><li><a href="/blog/webpack4系列教程">webpack4系列教程</a></li><li><a href="/blog/前端知识体系">前端知识体系</a></li><li><a href="/blog/剑指offer刷题笔记">剑指offer刷题笔记</a></li><li><a href="/blog/思考与成长">思考与成长</a></li><li><a href="/blog/设计模式手册">设计模式手册</a></li></ul></span><div class="__dumi-default-navbar-tool"><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "></div></div></div></nav></div><div class="__dumi-default-menu" data-mode="site"><div class="__dumi-default-menu-inner"><div class="__dumi-default-menu-header"><a class="__dumi-default-menu-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog/"></a><h1>大师兄</h1><p></p></div><div class="__dumi-default-menu-mobile-area"><ul class="__dumi-default-menu-nav-list"><li>计算机基础<ul><li><a href="/blog/编译原理之美">编译原理之美</a></li><li><a href="/blog/编译原理实战">编译原理实战</a></li><li><a href="/blog/深入浅出计算机组成原理">深入浅出计算机组成原理</a></li><li><a href="/blog/详解http">详解http</a></li><li><a href="/blog/计算机网络通关29讲">计算机网络通关29讲</a></li><li><a href="/blog/网络排查案例课">网络排查案例课</a></li><li><a href="/blog/linux操作系统">linux操作系统</a></li><li><a href="/blog/linux性能优化实战">linux性能优化实战</a></li><li><a href="/blog/程序员数学基础">程序员数学基础</a></li><li><a href="/blog/趣谈网络协议">趣谈网络协议</a></li><li><a href="/blog/操作系统实战">操作系统实战</a></li><li><a href="/blog/软件工程之美">软件工程之美</a></li><li><a href="/blog/sql必知必会">sql必知必会</a></li><li><a href="/blog/操作系统实战45讲">操作系统实战45讲</a></li><li><a href="/blog/网络编程实战">网络编程实战</a></li></ul></li><li>算法<ul><li><a href="/blog/常用算法25讲">常用算法25讲</a></li><li><a href="/blog/数据结构与算法之美">数据结构与算法之美</a></li><li><a href="/blog/业务开发算法50讲">业务开发算法50讲</a></li><li><a href="/blog/动态规划面试宝典">动态规划面试宝典</a></li></ul></li><li>前端开发<ul><li><a href="/blog/浏览器工作原理与实践">浏览器工作原理与实践</a></li><li><a href="/blog/新时代产品经理进阶之路">新时代产品经理进阶之路</a></li><li><a href="/blog/全栈工程师修炼指南">全栈工程师修炼指南</a></li><li><a href="/blog/flutter核心技术与实战">flutter核心技术与实战</a></li><li><a href="/blog/java-script核心原理解析">java-script核心原理解析</a></li><li><a href="/blog/说透低代码">说透低代码</a></li><li><a href="/blog/nodejs应用开发实战">nodejs应用开发实战</a></li><li><a href="/blog/反爬虫兵法演绎20讲">反爬虫兵法演绎20讲</a></li><li><a href="/blog/reactnative新架构实战课">reactnative新架构实战课</a></li><li><a href="/blog/正则表达式入门">正则表达式入门</a></li><li><a href="/blog/重学前端">重学前端</a></li><li><a href="/blog/serverless入门课">serverless入门课</a></li><li><a href="/blog/type-script入门实战笔记">type-script入门实战笔记</a></li><li><a href="/blog/图解googlev8">图解googlev8</a></li><li><a aria-current="page" class="active" href="/blog/vue3源码分析">vue3源码分析</a></li><li><a href="/blog/玩转Vue3全家桶">玩转Vue3全家桶</a></li><li><a href="/blog/webassembly入门">webassembly入门</a></li><li><a href="/blog/手把手带你写一个Web框架">手把手带你写一个Web框架</a></li><li><a href="/blog/web漏洞挖掘实战">web漏洞挖掘实战</a></li><li><a href="/blog/跟月影学可视化">跟月影学可视化</a></li><li><a href="/blog/搞定音频技术">搞定音频技术</a></li><li><a href="/blog/攻克视频技术">攻克视频技术</a></li></ul></li><li>前端工程化<ul><li><a href="/blog/logger">logger</a></li><li><a href="/blog/webpack">webpack</a></li><li><a href="/blog/webpackChain">webpackChain</a></li></ul></li><li>前端性能优化<ul><li><a href="/blog/react性能调优">react性能调优</a></li></ul></li><li>软件测试<ul><li><a href="/blog/全链路压测实战30讲">全链路压测实战30讲</a></li><li><a href="/blog/性能测试实战30讲">性能测试实战30讲</a></li><li><a href="/blog/自动化测试高手课">自动化测试高手课</a></li><li><a href="/blog/软件测试52讲">软件测试52讲</a></li></ul></li><li>面试<ul><li><a href="/blog/面试现场">面试现场</a></li></ul></li><li>杂谈<ul><li><a href="/blog/超级访谈对话张雪峰">超级访谈对话张雪峰</a></li><li><a href="/blog/Git实战手册">Git实战手册</a></li><li><a href="/blog/NodeJS">NodeJS</a></li><li><a href="/blog/ReactJS">ReactJS</a></li><li><a href="/blog/UI设计">UI设计</a></li><li><a href="/blog/webpack4系列教程">webpack4系列教程</a></li><li><a href="/blog/前端知识体系">前端知识体系</a></li><li><a href="/blog/剑指offer刷题笔记">剑指offer刷题笔记</a></li><li><a href="/blog/思考与成长">思考与成长</a></li><li><a href="/blog/设计模式手册">设计模式手册</a></li></ul></li></ul><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "><button title="Dark theme" class="__dumi-default-dark-moon "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="3854" width="22" height="22"><path d="M991.816611 674.909091a69.166545 69.166545 0 0 0-51.665455-23.272727 70.795636 70.795636 0 0 0-27.438545 5.585454A415.674182 415.674182 0 0 1 754.993338 698.181818c-209.594182 0-393.472-184.785455-393.472-395.636363 0-52.363636 38.539636-119.621818 69.515637-173.614546 4.887273-8.610909 9.634909-16.756364 14.103272-24.901818A69.818182 69.818182 0 0 0 384.631156 0a70.842182 70.842182 0 0 0-27.438545 5.585455C161.678429 90.298182 14.362065 307.898182 14.362065 512c0 282.298182 238.824727 512 532.38691 512a522.286545 522.286545 0 0 0 453.957818-268.334545A69.818182 69.818182 0 0 0 991.816611 674.909091zM546.679156 954.181818c-248.785455 0-462.941091-192-462.941091-442.181818 0-186.647273 140.637091-372.829091 300.939637-442.181818-36.817455 65.629091-92.578909 151.970909-92.578909 232.727273 0 250.181818 214.109091 465.454545 462.917818 465.454545a488.331636 488.331636 0 0 0 185.181091-46.545455 453.003636 453.003636 0 0 1-393.565091 232.727273z m103.656728-669.323636l-14.266182 83.781818a34.909091 34.909091 0 0 0 50.362182 36.770909l74.775272-39.563636 74.752 39.563636a36.142545 36.142545 0 0 0 16.174546 3.956364 34.909091 34.909091 0 0 0 34.210909-40.727273l-14.289455-83.781818 60.509091-59.345455a35.025455 35.025455 0 0 0-19.223272-59.578182l-83.61891-12.101818-37.376-76.101818a34.56 34.56 0 0 0-62.254545 0l-37.376 76.101818-83.618909 12.101818a34.909091 34.909091 0 0 0-19.246546 59.578182z m70.423272-64.698182a34.280727 34.280727 0 0 0 26.135273-19.083636l14.312727-29.090909 14.336 29.090909a34.257455 34.257455 0 0 0 26.135273 19.083636l32.046546 4.887273-23.272728 22.574545a35.234909 35.234909 0 0 0-10.007272 30.952727l5.46909 32.116364-28.625454-15.127273a34.490182 34.490182 0 0 0-32.302546 0l-28.695272 15.127273 5.469091-32.116364a35.141818 35.141818 0 0 0-9.984-30.952727l-23.272728-22.574545z" p-id="3855"></path></svg></button><button title="Light theme" class="__dumi-default-dark-sun "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="4026" width="22" height="22"><path d="M915.2 476.16h-43.968c-24.704 0-44.736 16-44.736 35.84s20.032 35.904 44.736 35.904H915.2c24.768 0 44.8-16.064 44.8-35.904s-20.032-35.84-44.8-35.84zM512 265.6c-136.704 0-246.464 109.824-246.464 246.4 0 136.704 109.76 246.464 246.464 246.464S758.4 648.704 758.4 512c0-136.576-109.696-246.4-246.4-246.4z m0 425.6c-99.008 0-179.2-80.128-179.2-179.2 0-98.944 80.192-179.2 179.2-179.2S691.2 413.056 691.2 512c0 99.072-80.192 179.2-179.2 179.2zM197.44 512c0-19.84-19.136-35.84-43.904-35.84H108.8c-24.768 0-44.8 16-44.8 35.84s20.032 35.904 44.8 35.904h44.736c24.768 0 43.904-16.064 43.904-35.904zM512 198.464c19.776 0 35.84-20.032 35.84-44.8v-44.8C547.84 84.032 531.84 64 512 64s-35.904 20.032-35.904 44.8v44.8c0 24.768 16.128 44.864 35.904 44.864z m0 627.136c-19.776 0-35.904 20.032-35.904 44.8v44.736C476.096 940.032 492.16 960 512 960s35.84-20.032 35.84-44.8v-44.736c0-24.768-16.064-44.864-35.84-44.864z m329.92-592.832c17.472-17.536 20.288-43.072 6.4-57.024-14.016-14.016-39.488-11.2-57.024 6.336-4.736 4.864-26.496 26.496-31.36 31.36-17.472 17.472-20.288 43.008-6.336 57.024 13.952 14.016 39.488 11.2 57.024-6.336 4.8-4.864 26.496-26.56 31.296-31.36zM213.376 759.936c-4.864 4.8-26.56 26.624-31.36 31.36-17.472 17.472-20.288 42.944-6.4 56.96 14.016 13.952 39.552 11.2 57.024-6.336 4.8-4.736 26.56-26.496 31.36-31.36 17.472-17.472 20.288-43.008 6.336-56.96-14.016-13.952-39.552-11.072-56.96 6.336z m19.328-577.92c-17.536-17.536-43.008-20.352-57.024-6.336-14.08 14.016-11.136 39.488 6.336 57.024 4.864 4.864 26.496 26.56 31.36 31.424 17.536 17.408 43.008 20.288 56.96 6.336 14.016-14.016 11.264-39.488-6.336-57.024-4.736-4.864-26.496-26.56-31.296-31.424z m527.168 628.608c4.864 4.864 26.624 26.624 31.36 31.424 17.536 17.408 43.072 20.224 57.088 6.336 13.952-14.016 11.072-39.552-6.4-57.024-4.864-4.8-26.56-26.496-31.36-31.36-17.472-17.408-43.072-20.288-57.024-6.336-13.952 14.016-11.008 39.488 6.336 56.96z" p-id="4027"></path></svg></button><button title="Default to system" class="__dumi-default-dark-auto "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="11002" width="22" height="22"><path d="M127.658667 492.885333c0-51.882667 10.24-101.717333 30.378666-149.162666s47.786667-88.064 81.92-122.538667 75.093333-61.781333 122.538667-81.92 96.938667-30.378667 149.162667-30.378667 101.717333 10.24 149.162666 30.378667 88.405333 47.786667 122.88 81.92 61.781333 75.093333 81.92 122.538667 30.378667 96.938667 30.378667 149.162666-10.24 101.717333-30.378667 149.162667-47.786667 88.405333-81.92 122.88-75.093333 61.781333-122.88 81.92-97.28 30.378667-149.162666 30.378667-101.717333-10.24-149.162667-30.378667-88.064-47.786667-122.538667-81.92-61.781333-75.093333-81.92-122.88-30.378667-96.938667-30.378666-149.162667z m329.045333 0c0 130.048 13.994667 244.394667 41.984 343.381334h12.970667c46.762667 0 91.136-9.216 133.461333-27.306667s78.848-42.666667 109.568-73.386667 54.954667-67.242667 73.386667-109.568 27.306667-86.698667 27.306666-133.461333c0-46.421333-9.216-90.794667-27.306666-133.12s-42.666667-78.848-73.386667-109.568-67.242667-54.954667-109.568-73.386667-86.698667-27.306667-133.461333-27.306666h-11.605334c-28.672 123.562667-43.349333 237.909333-43.349333 343.722666z" p-id="11003"></path></svg></button></div></div></div><ul class="__dumi-default-menu-list"><li><a href="/blog/vue3源码分析">vue3源码分析</a></li><li><a href="/blog/vue3源码分析/01.开篇词">01.开篇词</a><ul><li><a href="/blog/vue3源码分析/01.开篇词/01"><span>开篇词 | 解析 Vue.js 源码，提升编码能力</span></a></li><li><a href="/blog/vue3源码分析/01.开篇词/02"><span>导读 | 一文看懂 Vue.js 3.0 的优化</span></a></li></ul></li><li><a href="/blog/vue3源码分析/02.模块一直击vue.js核心组件的实现">02.模块一直击Vue.js核心组件的实现</a><ul><li><a href="/blog/vue3源码分析/02.模块一直击vue.js核心组件的实现/01"><span>模块一导读 | 组件的实现：直击 Vue 核心的实现</span></a></li><li><a href="/blog/vue3源码分析/02.模块一直击vue.js核心组件的实现/02"><span>01 | 组件渲染：vnode 到真实 DOM 是如何转变的？</span></a></li><li><a href="/blog/vue3源码分析/02.模块一直击vue.js核心组件的实现/03"><span>02 | 组件更新：完整的 DOM diff 流程是怎样的？（上）</span></a></li><li><a href="/blog/vue3源码分析/02.模块一直击vue.js核心组件的实现/04"><span>03 | 组件更新：完整的 DOM diff 流程是怎样的？（下）</span></a></li></ul></li><li><a aria-current="page" class="active" href="/blog/vue3源码分析/03.模块二学会新设计composition-api">03.模块二学会新设计CompositionAPI</a><ul><li><a href="/blog/vue3源码分析/03.模块二学会新设计composition-api/01"><span>模块二导读 | 逻辑复用最佳实践：Composition API</span></a></li><li><a href="/blog/vue3源码分析/03.模块二学会新设计composition-api/02"><span>04 | Setup：组件渲染前的初始化过程是怎样的？</span></a></li><li><a href="/blog/vue3源码分析/03.模块二学会新设计composition-api/03"><span>05 | 响应式：响应式内部的实现原理是怎样的？（上）</span></a></li><li><a href="/blog/vue3源码分析/03.模块二学会新设计composition-api/04"><span>06 | 响应式：响应式内部的实现原理是怎样的？（下）</span></a></li><li><a href="/blog/vue3源码分析/03.模块二学会新设计composition-api/05"><span>07 | 计算属性：计算属性比普通函数好在哪里？</span></a></li><li><a href="/blog/vue3源码分析/03.模块二学会新设计composition-api/06"><span>08 | 侦听器：侦听器的实现原理和使用场景是什么？（上）</span></a></li><li><a href="/blog/vue3源码分析/03.模块二学会新设计composition-api/07"><span>09 | 侦听器：侦听器的实现原理和使用场景是什么？（下）</span></a></li><li><a aria-current="page" class="active" href="/blog/vue3源码分析/03.模块二学会新设计composition-api/08"><span>10 | 生命周期：各个生命周期的执行时机和应用场景是怎样的？</span></a></li><li><a href="/blog/vue3源码分析/03.模块二学会新设计composition-api/09"><span>11 | 依赖注入：子孙组件如何共享数据？</span></a></li></ul></li><li><a href="/blog/vue3源码分析/04.模块三编译过程和背后的优化思想">04.模块三编译过程和背后的优化思想</a><ul><li><a href="/blog/vue3源码分析/04.模块三编译过程和背后的优化思想/01"><span>模块三导读 | 编译和优化：了解编译过程和背后的优化思想</span></a></li><li><a href="/blog/vue3源码分析/04.模块三编译过程和背后的优化思想/02"><span>12 | 模板解析：构造 AST 的完整流程是怎样的？（上）</span></a></li><li><a href="/blog/vue3源码分析/04.模块三编译过程和背后的优化思想/03"><span>13 | 模板解析：构造 AST 的完整流程是怎样的？（下）</span></a></li><li><a href="/blog/vue3源码分析/04.模块三编译过程和背后的优化思想/04"><span>14 | AST 转换：AST 节点内部做了哪些转换？（上）</span></a></li><li><a href="/blog/vue3源码分析/04.模块三编译过程和背后的优化思想/05"><span>15 | AST 转换：AST 节点内部做了哪些转换？（下）</span></a></li><li><a href="/blog/vue3源码分析/04.模块三编译过程和背后的优化思想/06"><span>16 | 生成代码：AST 如何生成可运行的代码？（上）</span></a></li><li><a href="/blog/vue3源码分析/04.模块三编译过程和背后的优化思想/07"><span>17 | 生成代码：AST 如何生成可运行的代码？（下）</span></a></li></ul></li><li><a href="/blog/vue3源码分析/05.模块四探索更多实用特性背后的实现原理">05.模块四探索更多实用特性背后的实现原理</a><ul><li><a href="/blog/vue3源码分析/05.模块四探索更多实用特性背后的实现原理/01"><span>模块四导读 | 实用特性：探索更多实用特性背后的原理</span></a></li><li><a href="/blog/vue3源码分析/05.模块四探索更多实用特性背后的实现原理/02"><span>18 | Props：Props 的初始化和更新流程是怎样的？</span></a></li><li><a href="/blog/vue3源码分析/05.模块四探索更多实用特性背后的实现原理/03"><span>19 | 插槽：如何实现内容分发？</span></a></li><li><a href="/blog/vue3源码分析/05.模块四探索更多实用特性背后的实现原理/04"><span>20 | 指令：指令完整的生命周期是怎样的？</span></a></li><li><a href="/blog/vue3源码分析/05.模块四探索更多实用特性背后的实现原理/05"><span>21 | v-model：双向绑定到底是怎么实现的？</span></a></li></ul></li><li><a href="/blog/vue3源码分析/06.模块五学习vue内置组件的实现原理">06.模块五学习Vue内置组件的实现原理</a><ul><li><a href="/blog/vue3源码分析/06.模块五学习vue内置组件的实现原理/01"><span>模块五导读 | 内置组件：学习 Vue 内置组件的实现原理</span></a></li><li><a href="/blog/vue3源码分析/06.模块五学习vue内置组件的实现原理/02"><span>22 | Teleport 组件：如何脱离当前组件渲染子组件？</span></a></li><li><a href="/blog/vue3源码分析/06.模块五学习vue内置组件的实现原理/03"><span>23 | KeepAlive 组件：如何让组件在内存中缓存和调度？</span></a></li><li><a href="/blog/vue3源码分析/06.模块五学习vue内置组件的实现原理/04"><span>24 | Transition 组件：过渡动画的实现原理是怎样的？（上）</span></a></li><li><a href="/blog/vue3源码分析/06.模块五学习vue内置组件的实现原理/05"><span>25 | Transition 组件：过渡动画的实现原理是怎样的？（下）</span></a></li></ul></li><li><a href="/blog/vue3源码分析/07.特别放送研究vue官方生态的实现原理">07.特别放送研究Vue官方生态的实现原理</a><ul><li><a href="/blog/vue3源码分析/07.特别放送研究vue官方生态的实现原理/01"><span>特别放送导读 | 研究 Vue 官方生态的实现原理</span></a></li><li><a href="/blog/vue3源码分析/07.特别放送研究vue官方生态的实现原理/02"><span>26 | Vue Router：如何实现一个前端路由？（上）</span></a></li><li><a href="/blog/vue3源码分析/07.特别放送研究vue官方生态的实现原理/03"><span>27 |  Vue Router：如何实现一个前端路由？（下）</span></a></li></ul></li><li><a href="/blog/vue3源码分析/08.结束语">08.结束语</a><ul><li><a href="/blog/vue3源码分析/08.结束语/01"><span>结束语 | 终点也是起点</span></a></li></ul></li><li><a href="/blog/vue3源码分析/summary">vue3源码分析</a></li></ul></div></div><ul role="slug-list" class="__dumi-default-layout-toc"><li title="注册钩子函数" data-depth="3"><a href="/blog/vue3源码分析/03.模块二学会新设计composition-api/08#注册钩子函数"><span>注册钩子函数</span></a></li><li title="onBeforeMount 和 onMounted" data-depth="3"><a href="/blog/vue3源码分析/03.模块二学会新设计composition-api/08#onbeforemount-和-onmounted"><span>onBeforeMount 和 onMounted</span></a></li><li title="onBeforeUpdate 和 onUpdated" data-depth="3"><a href="/blog/vue3源码分析/03.模块二学会新设计composition-api/08#onbeforeupdate-和-onupdated"><span>onBeforeUpdate 和 onUpdated</span></a></li><li title="onBeforeUnmount 和 onUnmounted" data-depth="3"><a href="/blog/vue3源码分析/03.模块二学会新设计composition-api/08#onbeforeunmount-和-onunmounted"><span>onBeforeUnmount 和 onUnmounted</span></a></li><li title="onErrorCaptured" data-depth="3"><a href="/blog/vue3源码分析/03.模块二学会新设计composition-api/08#onerrorcaptured"><span>onErrorCaptured</span></a></li><li title="onRenderTracked 和 onRenderTriggered" data-depth="3"><a href="/blog/vue3源码分析/03.模块二学会新设计composition-api/08#onrendertracked-和-onrendertriggered"><span>onRenderTracked 和 onRenderTriggered</span></a></li><li title="总结" data-depth="3"><a href="/blog/vue3源码分析/03.模块二学会新设计composition-api/08#总结"><span>总结</span></a></li></ul><div class="__dumi-default-layout-content"><div class="markdown"><h1 id="10--生命周期各个生命周期的执行时机和应用场景是怎样的"><a aria-hidden="true" tabindex="-1" href="/blog/vue3源码分析/03.模块二学会新设计composition-api/08#10--生命周期各个生命周期的执行时机和应用场景是怎样的"><span class="icon icon-link"></span></a>10 | 生命周期：各个生命周期的执行时机和应用场景是怎样的？</h1><p>Vue.js 组件的生命周期包括创建、更新、销毁等过程。在这些过程中也会运行叫生命周期钩子的函数，这给了用户在不同阶段添加自己的代码的机会。</p><p>在 Vue.js 2.x 中，我们通常会在组件对象中定义一些生命周期钩子函数，到了 Vue.js 3.0，依然兼容 Vue.js 2.x 生命周期的语法，但是 Composition API 提供了一些生命周期函数的 API，让我们可以主动注册不同的生命周期。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// Vue.js 2.x 定义生命周期钩子函数 </span></div><div class="token-line"><span class="token plain">    export default { </span></div><div class="token-line"><span class="token plain">      created() { </span></div><div class="token-line"><span class="token plain">        // 做一些初始化工作 </span></div><div class="token-line"><span class="token plain">      }, </span></div><div class="token-line"><span class="token plain">      mounted() { </span></div><div class="token-line"><span class="token plain">        // 可以拿到 DOM 节点 </span></div><div class="token-line"><span class="token plain">      }, </span></div><div class="token-line"><span class="token plain">      beforeDestroy() { </span></div><div class="token-line"><span class="token plain">        // 做一些清理操作 </span></div><div class="token-line"><span class="token plain">      } </span></div><div class="token-line"><span class="token plain">    } </span></div><div class="token-line"><span class="token plain">    //  Vue.js 3.x 生命周期 API 改写上例 </span></div><div class="token-line"><span class="token plain">    import { onMounted, onBeforeUnmount } from &#x27;vue&#x27; </span></div><div class="token-line"><span class="token plain">    export default { </span></div><div class="token-line"><span class="token plain">      setup() { </span></div><div class="token-line"><span class="token plain">        // 做一些初始化工作 </span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        onMounted(() =&gt; { </span></div><div class="token-line"><span class="token plain">          // 可以拿到 DOM 节点 </span></div><div class="token-line"><span class="token plain">        }) </span></div><div class="token-line"><span class="token plain">        onBeforeUnmount(()=&gt;{ </span></div><div class="token-line"><span class="token plain">          // 做一些清理操作 </span></div><div class="token-line"><span class="token plain">        }) </span></div><div class="token-line"><span class="token plain">      } </span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>可以看到，在 Vue.js 3.0 中，setup 函数已经替代了 Vue.js 2.x 的 beforeCreate 和 created 钩子函数，我们可以在 setup 函数做一些初始化工作，比如发送一个异步 Ajax 请求获取数据。</p><p>我们用 onMounted API 替代了 Vue.js 2.x 的 mounted 钩子函数，用 onBeforeUnmount API 替代了 Vue.js 2.x 的 beforeDestroy 钩子函数。</p><p>其实，Vue.js 3.0 针对 Vue.js 2.x 的生命周期钩子函数做了全面替换，映射关系如下：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">beforeCreate -&gt; 使用 setup() </span></div><div class="token-line"><span class="token plain">    created -&gt; 使用 use setup() </span></div><div class="token-line"><span class="token plain">    beforeMount -&gt; onBeforeMount </span></div><div class="token-line"><span class="token plain">    mounted -&gt; onMounted </span></div><div class="token-line"><span class="token plain">    beforeUpdate -&gt; onBeforeUpdate </span></div><div class="token-line"><span class="token plain">    updated -&gt; onUpdated </span></div><div class="token-line"><span class="token plain">    beforeDestroy-&gt; onBeforeUnmount </span></div><div class="token-line"><span class="token plain">    destroyed -&gt; onUnmounted </span></div><div class="token-line"><span class="token plain">    activated -&gt; onActivated </span></div><div class="token-line"><span class="token plain">    deactivated -&gt; onDeactivated </span></div><div class="token-line"><span class="token plain">    errorCaptured -&gt; onErrorCaptured</span></div></pre></div><p>除此之外，Vue.js 3.0 还新增了两个用于调试的生命周期 API：onRenderTracked 和 onRenderTriggered。</p><p>那么，这些生命周期钩子函数内部是如何实现的？它们又分别在组件生命周期的哪些阶段执行的？分别适用于哪些开发场景？</p><p>带着这些疑问，我们来深入学习生命周期钩子函数背后的实现原理。</p><h3 id="注册钩子函数"><a aria-hidden="true" tabindex="-1" href="/blog/vue3源码分析/03.模块二学会新设计composition-api/08#注册钩子函数"><span class="icon icon-link"></span></a>注册钩子函数</h3><p>首先，我们来看这些钩子函数是如何注册的，先来看一下它们的实现：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">const onBeforeMount = createHook(&#x27;bm&#x27; /* BEFORE_MOUNT */) </span></div><div class="token-line"><span class="token plain">    const onMounted = createHook(&#x27;m&#x27; /* MOUNTED */) </span></div><div class="token-line"><span class="token plain">    const onBeforeUpdate = createHook(&#x27;bu&#x27; /* BEFORE_UPDATE */) </span></div><div class="token-line"><span class="token plain">    const onUpdated = createHook(&#x27;u&#x27; /* UPDATED */) </span></div><div class="token-line"><span class="token plain">    const onBeforeUnmount = createHook(&#x27;bum&#x27; /* BEFORE_UNMOUNT */) </span></div><div class="token-line"><span class="token plain">    const onUnmounted = createHook(&#x27;um&#x27; /* UNMOUNTED */) </span></div><div class="token-line"><span class="token plain">    const onRenderTriggered = createHook(&#x27;rtg&#x27; /* RENDER_TRIGGERED */) </span></div><div class="token-line"><span class="token plain">    const onRenderTracked = createHook(&#x27;rtc&#x27; /* RENDER_TRACKED */) </span></div><div class="token-line"><span class="token plain">    const onErrorCaptured = (hook, target = currentInstance) =&gt; { </span></div><div class="token-line"><span class="token plain">      injectHook(&#x27;ec&#x27; /* ERROR_CAPTURED */, hook, target) </span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>我们发现除了 onErrorCaptured，其他钩子函数都是通过 createHook 函数创建的，通过传入不同的字符串来表示不同的钩子函数。</p><p>那么，我们就来分析一下 createHook 钩子函数的实现原理：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">const createHook = function(lifecycle)  { </span></div><div class="token-line"><span class="token plain">      return function (hook, target = currentInstance) { </span></div><div class="token-line"><span class="token plain">        injectHook(lifecycle, hook, target) </span></div><div class="token-line"><span class="token plain">      } </span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>createHook 会返回一个函数，它的内部通过 injectHook 注册钩子函数。你可能会问，这里为什么要用 createHook 做一层封装而不直接使用 injectHook API 呢？比如：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">const onBeforeMount = function(hook,target = currentInstance) { </span></div><div class="token-line"><span class="token plain">      injectHook(&#x27;bm&#x27;, hook, target) </span></div><div class="token-line"><span class="token plain">    } </span></div><div class="token-line"><span class="token plain">    const onMounted = function(hook,target = currentInstance) { </span></div><div class="token-line"><span class="token plain">      injectHook(&#x27;m&#x27;, hook, target) </span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>这样实现当然也是可以的，不过，我们可以发现，这些钩子函数内部执行逻辑很类似，都是执行 injectHook，唯一的区别是第一个参数字符串不同，所以这样的代码是可以进一步封装的，即用 createHook 封装，这就是一个典型的函数柯里化技巧。</p><p>在调用 createHook 返回的函数时，也就不需要传入 lifecycle 字符串，因为它在执行 createHook 函数时就已经实现了该参数的保留。</p><p>所以，当我们通过 <code>onMounted(hook)</code> 注册一个钩子函数时，内部就是通过 <code>injectHook(&#x27;m&#x27;, hook)</code> 去注册的，接下来我们来进一步看 injectHook 函数的实现原理：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">function injectHook(type, hook, target = currentInstance, prepend = false) { </span></div><div class="token-line"><span class="token plain">      const hooks = target[type] || (target[type] = []) </span></div><div class="token-line"><span class="token plain">      // 封装 hook 钩子函数并缓存 </span></div><div class="token-line"><span class="token plain">      const wrappedHook = hook.__weh || </span></div><div class="token-line"><span class="token plain">        (hook.__weh = (...args) =&gt; { </span></div><div class="token-line"><span class="token plain">          if (target.isUnmounted) { </span></div><div class="token-line"><span class="token plain">            return </span></div><div class="token-line"><span class="token plain">          } </span></div><div class="token-line"><span class="token plain">          // 停止依赖收集 </span></div><div class="token-line"><span class="token plain">          pauseTracking() </span></div><div class="token-line"><span class="token plain">          // 设置 target 为当前运行的组件实例 </span></div><div class="token-line"><span class="token plain">          setCurrentInstance(target) </span></div><div class="token-line"><span class="token plain">          // 执行钩子函数 </span></div><div class="token-line"><span class="token plain">          const res = callWithAsyncErrorHandling(hook, target, type, args) </span></div><div class="token-line"><span class="token plain">          setCurrentInstance(null) </span></div><div class="token-line"><span class="token plain">          // 恢复依赖收集 </span></div><div class="token-line"><span class="token plain">          resetTracking() </span></div><div class="token-line"><span class="token plain">          return res </span></div><div class="token-line"><span class="token plain">        }) </span></div><div class="token-line"><span class="token plain">      if (prepend) { </span></div><div class="token-line"><span class="token plain">        hooks.unshift(wrappedHook) </span></div><div class="token-line"><span class="token plain">      } </span></div><div class="token-line"><span class="token plain">      else { </span></div><div class="token-line"><span class="token plain">        hooks.push(wrappedHook) </span></div><div class="token-line"><span class="token plain">      } </span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>结合代码来看，该函数主要是对用户注册的钩子函数 hook 做了一层封装，然后添加到一个数组中，把数组保存在当前组件实例的 target 上，这里，key 是用来区分钩子函数的字符串。比如， onMounted 注册的钩子函数在组件实例上就是通过 instance.m 来保存。</p><p>这样的设计其实非常好理解，因为生命周期的钩子函数，是在组件生命周期的各个阶段执行，所以钩子函数必须要保存在当前的组件实例上，这样后面就可以在组件实例上通过不同的字符串 key 找到对应的钩子函数数组并执行。</p><p>对于相同的钩子函数，会把封装的 wrappedHook 钩子函数缓存到 hook.__weh 中，这样后续通过 scheduler 方式执行的钩子函数就会被去重。</p><p>在后续执行 wrappedHook 函数时，会先停止依赖收集，因为钩子函数内部访问的响应式对象，通常都已经执行过依赖收集，所以钩子函数执行的时候没有必要再次收集依赖，毕竟这个过程也有一定的性能消耗。</p><p>接着是设置 target 为当前组件实例。在 Vue.js 的内部，会一直维护当前运行的组件实例 currentInstance，在注册钩子函数的过程中，我们可以拿到当前运行组件实例 currentInstance，并用 target 保存，然后在钩子函数执行时，为了确保此时的 currentInstance 和注册钩子函数时一致，会通过 <code>setCurrentInstance(target)</code> 设置 target 为当前组件实例。</p><p>接下来就是通过 callWithAsyncErrorHandling 方法去执行我们注册的 hook 钩子函数，函数执行完毕则设置当前运行组件实例为 null，并恢复依赖收集。</p><p>到这里，我们就了解了生命周期钩子函数是如何注册以及如何执行的，接下来，我们来依次分析各个钩子函数的执行时机和应用场景。</p><p>首先，我们来看通过 onBeforeMount 和 onMounted 注册的钩子函数。</p><h3 id="onbeforemount-和-onmounted"><a aria-hidden="true" tabindex="-1" href="/blog/vue3源码分析/03.模块二学会新设计composition-api/08#onbeforemount-和-onmounted"><span class="icon icon-link"></span></a>onBeforeMount 和 onMounted</h3><p><strong>onBeforeMount 注册的 beforeMount 钩子函数会在组件挂载之前执行</strong>，<strong>onMounted 注册的 mounted 钩子函数会在组件挂载之后执行</strong>。我们来回顾一下组件副作用渲染函数关于组件挂载部分的实现：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">const setupRenderEffect = (instance, initialVNode, container, anchor, parentSuspense, isSVG, optimized) =&gt; { </span></div><div class="token-line"><span class="token plain">      // 创建响应式的副作用渲染函数 </span></div><div class="token-line"><span class="token plain">      instance.update = effect(function componentEffect() { </span></div><div class="token-line"><span class="token plain">        if (!instance.isMounted) { </span></div><div class="token-line"><span class="token plain">          // 获取组件实例上通过 onBeforeMount 钩子函数和 onMounted 注册的钩子函数 </span></div><div class="token-line"><span class="token plain">          const { bm, m } = instance; </span></div><div class="token-line"><span class="token plain">          // 渲染组件生成子树 vnode </span></div><div class="token-line"><span class="token plain">          const subTree = (instance.subTree = renderComponentRoot(instance)) </span></div><div class="token-line"><span class="token plain">          // 执行 beforemount 钩子函数 </span></div><div class="token-line"><span class="token plain">          if (bm) { </span></div><div class="token-line"><span class="token plain">            invokeArrayFns(bm) </span></div><div class="token-line"><span class="token plain">          } </span></div><div class="token-line"><span class="token plain">          // 把子树 vnode 挂载到 container 中 </span></div><div class="token-line"><span class="token plain">          patch(null, subTree, container, anchor, instance, parentSuspense, isSVG) </span></div><div class="token-line"><span class="token plain">          // 保留渲染生成的子树根 DOM 节点 </span></div><div class="token-line"><span class="token plain">          initialVNode.el = subTree.el </span></div><div class="token-line"><span class="token plain">          // 执行 mounted 钩子函数 </span></div><div class="token-line"><span class="token plain">          if (m) { </span></div><div class="token-line"><span class="token plain">            queuePostRenderEffect(m, parentSuspense) </span></div><div class="token-line"><span class="token plain">          } </span></div><div class="token-line"><span class="token plain">          instance.isMounted = true </span></div><div class="token-line"><span class="token plain">        } </span></div><div class="token-line"><span class="token plain">        else { </span></div><div class="token-line"><span class="token plain">          // 更新组件 </span></div><div class="token-line"><span class="token plain">        } </span></div><div class="token-line"><span class="token plain">      }, prodEffectOptions) </span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>在执行 patch 挂载组件之前，会检测组件实例上是有否有注册的 beforeMount 钩子函数 bm，如果有则通过 invokeArrayFns 执行它，因为用户可以通过多次执行 onBeforeMount 函数注册多个 beforeMount 钩子函数，所以这里 instance.bm 是一个数组，通过遍历这个数组来依次执行 beforeMount 钩子函数。</p><p>在执行 patch 挂载组件之后，会检查组件实例上是否有注册的 mounted 钩子函数 m，如果有的话则执行 queuePostRenderEffect，把 mounted 钩子函数推入 postFlushCbs 中，然后在整个应用 render 完毕后，同步执行 flushPostFlushCbs 函数调用 mounted 钩子函数。</p><p>我经常在社区里听到一种争论：在组件初始化阶段，对于发送一些 Ajax 异步请求的逻辑，是应该放在 created 钩子函数中，还是应该放在 mounted 钩子函数中？</p><p>其实都可以，因为 created 和 mounted 钩子函数执行的时候都能拿到组件数据，它们执行的顺序虽然有先后，但都会在一个 Tick 内执行完毕，而异步请求是有网络耗时的，其耗时远远大于一个 Tick 的时间。所以，你无论在 created 还是在 mounted 里发请求，都要等请求的响应回来，然后更新数据，再触发组件的重新渲染。</p><p>前面说过，Vue.js 2.x 中的 beforeCreate 和 created 钩子函数可以用 setup 函数替代。所以，对于组件初始化阶段发送异步请求的逻辑，放在 setup 函数中、beforeMount 钩子函数中或者 mounted 钩子函数中都可以，它们都可以拿到组件相关的数据。当然，我更推荐在 setup 函数中执行，因为从语义化的角度来看这样更合适。</p><p>不过，如果你想依赖 DOM 去做一些初始化操作，那就只能把相关逻辑放在 mounted 钩子函数中了，这样你才能拿到组件渲染后的 DOM。</p><p>对于嵌套组件，组件在挂载相关的生命周期钩子函数时，先执行父组件的 beforeMount，然后是子组件的 beforeMount，接着是子组件的 mounted ，最后执行父组件的 mounted。</p><p>接下来，我们来看通过 onBeforeUpdate 和 onUpdated 注册的钩子函数。</p><h3 id="onbeforeupdate-和-onupdated"><a aria-hidden="true" tabindex="-1" href="/blog/vue3源码分析/03.模块二学会新设计composition-api/08#onbeforeupdate-和-onupdated"><span class="icon icon-link"></span></a>onBeforeUpdate 和 onUpdated</h3><p><strong>onBeforeUpdate 注册的 beforeUpdate 钩子函数会在组件更新之前执行</strong>，<strong>onUpdated 注册的 updated 钩子函数会在组件更新之后执行</strong>。我们来回顾一下组件副作用渲染函数关于组件更新的实现：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">const setupRenderEffect = (instance, initialVNode, container, anchor, parentSuspense, isSVG, optimized) =&gt; { </span></div><div class="token-line"><span class="token plain">      // 创建响应式的副作用渲染函数 </span></div><div class="token-line"><span class="token plain">      instance.update = effect(function componentEffect() { </span></div><div class="token-line"><span class="token plain">        if (!instance.isMounted) { </span></div><div class="token-line"><span class="token plain">          // 渲染组件 </span></div><div class="token-line"><span class="token plain">        } </span></div><div class="token-line"><span class="token plain">        else { </span></div><div class="token-line"><span class="token plain">          // 更新组件 </span></div><div class="token-line"><span class="token plain">          // 获取组件实例上通过 onBeforeUpdate 钩子函数和 onUpdated 注册的钩子函数 </span></div><div class="token-line"><span class="token plain">          let { next, vnode, bu, u } = instance </span></div><div class="token-line"><span class="token plain">          // next 表示新的组件 vnode </span></div><div class="token-line"><span class="token plain">          if (next) { </span></div><div class="token-line"><span class="token plain">            // 更新组件 vnode 节点信息 </span></div><div class="token-line"><span class="token plain">            updateComponentPreRender(instance, next, optimized) </span></div><div class="token-line"><span class="token plain">          } </span></div><div class="token-line"><span class="token plain">          else { </span></div><div class="token-line"><span class="token plain">            next = vnode </span></div><div class="token-line"><span class="token plain">          } </span></div><div class="token-line"><span class="token plain">          // 渲染新的子树 vnode </span></div><div class="token-line"><span class="token plain">          const nextTree = renderComponentRoot(instance) </span></div><div class="token-line"><span class="token plain">          // 缓存旧的子树 vnode </span></div><div class="token-line"><span class="token plain">          const prevTree = instance.subTree </span></div><div class="token-line"><span class="token plain">          // 更新子树 vnode </span></div><div class="token-line"><span class="token plain">          instance.subTree = nextTree </span></div><div class="token-line"><span class="token plain">          // 执行 beforeUpdate 钩子函数 </span></div><div class="token-line"><span class="token plain">          if (bu) { </span></div><div class="token-line"><span class="token plain">            invokeArrayFns(bu) </span></div><div class="token-line"><span class="token plain">          } </span></div><div class="token-line"><span class="token plain">          // 组件更新核心逻辑，根据新旧子树 vnode 做 patch </span></div><div class="token-line"><span class="token plain">          patch(prevTree, nextTree, </span></div><div class="token-line"><span class="token plain">     // 如果在 teleport 组件中父节点可能已经改变，所以容器直接找旧树 DOM 元素的父节点 </span></div><div class="token-line"><span class="token plain">            hostParentNode(prevTree.el), </span></div><div class="token-line"><span class="token plain">       // 缓存更新后的 DOM 节点 </span></div><div class="token-line"><span class="token plain">            getNextHostNode(prevTree), </span></div><div class="token-line"><span class="token plain">            instance, </span></div><div class="token-line"><span class="token plain">            parentSuspense, </span></div><div class="token-line"><span class="token plain">            isSVG) </span></div><div class="token-line"><span class="token plain">          // 缓存更新后的 DOM 节点 </span></div><div class="token-line"><span class="token plain">          next.el = nextTree.el </span></div><div class="token-line"><span class="token plain">          // 执行 updated 钩子函数 </span></div><div class="token-line"><span class="token plain">          if (u) { </span></div><div class="token-line"><span class="token plain">            queuePostRenderEffect(u, parentSuspense) </span></div><div class="token-line"><span class="token plain">          } </span></div><div class="token-line"><span class="token plain">        } </span></div><div class="token-line"><span class="token plain">      }, prodEffectOptions) </span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>在执行 patch 更新组件之前，会检测组件实例上是有否有注册的 beforeUpdate 钩子函数 bu，如果有则通过 invokeArrayFns 执行它。</p><p>在执行 patch 更新组件之后，会检查组件实例上是否有注册的 updated 钩子函数 u，如果有，则通过 queuePostRenderEffect 把 updated 钩子函数推入 postFlushCbs 中，因为组件的更新本身就是在 nextTick 后进行 flushJobs，因此此时再次执行 queuePostRenderEffect 推入到队列的任务，会在同一个 Tick 内执行这些 postFlushCbs，也就是执行所有 updated 的钩子函数。</p><p>在 beforeUpdate 钩子函数执行时，组件的 DOM 还未更新，如果你想在组件更新前访问 DOM，比如手动移除已添加的事件监听器，你可以注册这个钩子函数。</p><p>在 updated 钩子函数执行时，组件 DOM 已经更新，所以你现在可以执行依赖于 DOM 的操作。如果要监听数据的改变并执行某些逻辑，最好不要使用 updated 钩子函数而用计算属性或 watcher 取而代之，因为任何数据的变化导致的组件更新都会执行 updated 钩子函数。另外注意， <strong>不要在 updated 钩子函数中更改数据，因为这样会再次触发组件更新，导致无限递归更新</strong> 。</p><p>还有，父组件的更新不一定会导致子组件的更新，因为 Vue.js 的更新粒度是组件级别的。</p><p>接下来，我们来看通过 onBeforeUnmount 和 onUnmounted 注册的钩子函数。</p><h3 id="onbeforeunmount-和-onunmounted"><a aria-hidden="true" tabindex="-1" href="/blog/vue3源码分析/03.模块二学会新设计composition-api/08#onbeforeunmount-和-onunmounted"><span class="icon icon-link"></span></a>onBeforeUnmount 和 onUnmounted</h3><p><strong>onBeforeUnmount 注册的 beforeUnMount 钩子函数会在组件销毁之前执行</strong>，onUnmounted <strong>注册的 unmounted 钩子函数会在组件销毁之后执行</strong> 。我们来看一下组件销毁相关逻辑实现：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">const unmountComponent = (instance, parentSuspense, doRemove) =&gt; { </span></div><div class="token-line"><span class="token plain">      const { bum, effects, update, subTree, um } = instance </span></div><div class="token-line"><span class="token plain">      // 执行 beforeUnmount 钩子函数 </span></div><div class="token-line"><span class="token plain">      if (bum) { </span></div><div class="token-line"><span class="token plain">        invokeArrayFns(bum) </span></div><div class="token-line"><span class="token plain">      } </span></div><div class="token-line"><span class="token plain">      // 清理组件引用的 effects 副作用函数 </span></div><div class="token-line"><span class="token plain">      if (effects) { </span></div><div class="token-line"><span class="token plain">        for (let i = 0; i &lt; effects.length; i++) { </span></div><div class="token-line"><span class="token plain">          stop(effects[i]) </span></div><div class="token-line"><span class="token plain">        } </span></div><div class="token-line"><span class="token plain">      } </span></div><div class="token-line"><span class="token plain">      // 如果一个异步组件在加载前就销毁了，则不会注册副作用渲染函数 </span></div><div class="token-line"><span class="token plain">      if (update) { </span></div><div class="token-line"><span class="token plain">        stop(update) </span></div><div class="token-line"><span class="token plain">        // 调用 unmount 销毁子树 </span></div><div class="token-line"><span class="token plain">        unmount(subTree, instance, parentSuspense, doRemove) </span></div><div class="token-line"><span class="token plain">      } </span></div><div class="token-line"><span class="token plain">      // 执行 unmounted 钩子函数 </span></div><div class="token-line"><span class="token plain">      if (um) { </span></div><div class="token-line"><span class="token plain">        queuePostRenderEffect(um, parentSuspense) </span></div><div class="token-line"><span class="token plain">      } </span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>其实整个组件销毁的逻辑很简单，主要就是<strong>清理组件实例上绑定的 effects 副作用函数和注册的副作用渲染函数 update</strong>，以及<strong>调用 unmount 销毁子树</strong>。</p><p>unmount 主要就是遍历子树，它会通过递归的方式来销毁子节点，遇到组件节点时执行 unmountComponent，遇到普通节点时则删除 DOM 元素。组件的销毁过程和渲染过程类似，都是递归的过程。</p><p>在组件销毁前，会检测组件实例上是有否有注册的 beforeUnmount 钩子函数 bum，如果有则通过 invokeArrayFns 执行。</p><p>在组件销毁后，会检测组件实例上是否有注册的 unmounted 钩子函数 um，如果有则通过 queuePostRenderEffect 把 unmounted 钩子函数推入到 postFlushCbs 中，因为组件的销毁就是组件更新的一个分支逻辑，所以在 nextTick 后进行 flushJobs，因此此时再次执行 queuePostRenderEffect 推入队列的任务，会在同一个 Tick 内执行这些 postFlushCbs，也就是执行所有的 unmounted 钩子函数。</p><p>对于嵌套组件，组件在执行销毁相关的生命周期钩子函数时，先执行父组件的 beforeUnmount，再执行子组件的 beforeUnmount，然后执行子组件的 unmounted ，最后执行父组件的 unmounted。</p><p>虽然组件在销毁阶段会清理一些定义的 effects 函数，删除组件内部的 DOM 元素，但是有一些需要清理的对象，组件并不能自动完成它们的清理，比如你在组件内部创建一个定时器，就应该在 beforeUnmount 或者 unmounted 钩子函数中清除，举个例子：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">&lt;template&gt; </span></div><div class="token-line"><span class="token plain">      &lt;div&gt; </span></div><div class="token-line"><span class="token plain">        &lt;div&gt; </span></div><div class="token-line"><span class="token plain">          &lt;p&gt;{{count}}&lt;/p&gt; </span></div><div class="token-line"><span class="token plain">        &lt;/div&gt; </span></div><div class="token-line"><span class="token plain">      &lt;/div&gt; </span></div><div class="token-line"><span class="token plain">    &lt;/template&gt; </span></div><div class="token-line"><span class="token plain">    &lt;script&gt; </span></div><div class="token-line"><span class="token plain">      import { ref, onBeforeUnmount } from &#x27;vue&#x27; </span></div><div class="token-line"><span class="token plain">      export default { </span></div><div class="token-line"><span class="token plain">        setup () { </span></div><div class="token-line"><span class="token plain">          const count = ref(0) </span></div><div class="token-line"><span class="token plain">          const timer = setInterval(() =&gt; { </span></div><div class="token-line"><span class="token plain">            console.log(count.value++) </span></div><div class="token-line"><span class="token plain">          }, 1000) </span></div><div class="token-line"><span class="token plain">          onBeforeUnmount(() =&gt; { </span></div><div class="token-line"><span class="token plain">            clearInterval(timer) </span></div><div class="token-line"><span class="token plain">          }) </span></div><div class="token-line"><span class="token plain">          return { </span></div><div class="token-line"><span class="token plain">            count </span></div><div class="token-line"><span class="token plain">          } </span></div><div class="token-line"><span class="token plain">        } </span></div><div class="token-line"><span class="token plain">      } </span></div><div class="token-line"><span class="token plain">    &lt;/script&gt;</span></div></pre></div><p>可以看到，这里我们在 setup 函数内部定义了一个 timer 计时器， count 每秒会加 1 并在控制台中输出。如果这个组件被销毁，就会触发 onBeforeUnmount 注册的 beforeUnmount 钩子函数，然后清除定时器。如果你不清除，就会发现组件销毁后，虽然 DOM 被移除了，计时器仍然存在，并且会一直计时并在控制台输出，这就造成了不必要的内存泄漏。</p><p>接下来，我们来看通过 onErrorCaptured 注册的钩子函数。</p><h3 id="onerrorcaptured"><a aria-hidden="true" tabindex="-1" href="/blog/vue3源码分析/03.模块二学会新设计composition-api/08#onerrorcaptured"><span class="icon icon-link"></span></a>onErrorCaptured</h3><p>在前面的课时中，我们多次接触过一个方法 callWithErrorHandling，它就是执行一段函数并通过 handleError 处理错误。那么，handleError 具体做了哪些事情呢？</p><p>我们先来看一下它的实现：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">function handleError(err, instance, type) { </span></div><div class="token-line"><span class="token plain">      const contextVNode = instance ? instance.vnode : null </span></div><div class="token-line"><span class="token plain">      if (instance) { </span></div><div class="token-line"><span class="token plain">        let cur = instance.parent </span></div><div class="token-line"><span class="token plain">        // 为了兼容 2.x 版本，暴露组件实例给钩子函数 </span></div><div class="token-line"><span class="token plain">        const exposedInstance = instance.proxy </span></div><div class="token-line"><span class="token plain">        // 获取错误信息 </span></div><div class="token-line"><span class="token plain">        const errorInfo = (process.env.NODE_ENV !== &#x27;production&#x27;) ? ErrorTypeStrings[type] : type </span></div><div class="token-line"><span class="token plain">        // 尝试向上查找所有父组件，执行 errorCaptured 钩子函数 </span></div><div class="token-line"><span class="token plain">        while (cur) { </span></div><div class="token-line"><span class="token plain">          const errorCapturedHooks = cur.ec </span></div><div class="token-line"><span class="token plain">          if (errorCapturedHooks) { </span></div><div class="token-line"><span class="token plain">            for (let i = 0; i &lt; errorCapturedHooks.length; i++) { </span></div><div class="token-line"><span class="token plain">              // 如果执行的 errorCaptured 钩子函数并返回 true，则停止向上查找。、 </span></div><div class="token-line"><span class="token plain">              if (errorCapturedHooks[i](err, exposedInstance, errorInfo)) { </span></div><div class="token-line"><span class="token plain">                return </span></div><div class="token-line"><span class="token plain">              } </span></div><div class="token-line"><span class="token plain">            } </span></div><div class="token-line"><span class="token plain">          } </span></div><div class="token-line"><span class="token plain">          cur = cur.parent </span></div><div class="token-line"><span class="token plain">        } </span></div><div class="token-line"><span class="token plain">      } </span></div><div class="token-line"><span class="token plain">      // 往控制台输出未处理的错误 </span></div><div class="token-line"><span class="token plain">      logError(err, type, contextVNode) </span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>handleError 的实现其实很简单，它会从当前报错的组件的父组件实例开始，尝试去查找注册的 errorCaptured 钩子函数，如果有则遍历执行并且判断 errorCaptured 钩子函数的返回值是否为 true，如果是则说明这个错误已经得到了正确的处理，就会直接结束。</p><p>否则会继续遍历，遍历完当前组件实例的 errorCaptured 钩子函数后，如果这个错误还没得到正确处理，则向上查找它的父组件实例，以同样的逻辑去查找是否有正确处理该错误的 errorCaptured 钩子函数，直到查找完毕。</p><p>如果整个链路上都没有正确处理错误的 errorCaptured 钩子函数，则通过 logError 往控制台输出未处理的错误。所以 <strong>errorCaptured 本质上是捕获一个来自子孙组件的错误</strong>，<strong>它返回 true 就可以阻止错误继续向上传播</strong>。</p><p>errorCaptured 在平时工作中可能用的不多，但它的确是一个很实用的功能，比如你可以在根组件注册一个 errorCaptured 钩子函数，去捕获所有子孙组件的错误，并且可以根据错误的类型和信息统计和上报错误。</p><p>接下来，我们来看通过 onRenderTracked 和 onRenderTriggered 注册的钩子函数。</p><h3 id="onrendertracked-和-onrendertriggered"><a aria-hidden="true" tabindex="-1" href="/blog/vue3源码分析/03.模块二学会新设计composition-api/08#onrendertracked-和-onrendertriggered"><span class="icon icon-link"></span></a>onRenderTracked 和 onRenderTriggered</h3><p>onRenderTracked 和 onRenderTriggered 是 Vue.js 3.0 新增的生命周期 API，它们是在开发阶段渲染调试用的。这里再次回顾一下我们创建的副作用渲染函数的第二个参数（这里你可以去 06 课时“ 响应式：响应式内部的实现原理是怎样的？ ”中复习一下），在开发环境下它的代码是这样的：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">instance.update = effect(function componentEffect() { </span></div><div class="token-line"><span class="token plain">    // 创建或者更组件 </span></div><div class="token-line"><span class="token plain">    }, createDevEffectOptions(instance)) </span></div><div class="token-line"><span class="token plain">    function createDevEffectOptions(instance) { </span></div><div class="token-line"><span class="token plain">      return { </span></div><div class="token-line"><span class="token plain">        scheduler: queueJob, </span></div><div class="token-line"><span class="token plain">        onTrack: instance.rtc ? e =&gt; invokeArrayFns(instance.rtc, e) : void 0, </span></div><div class="token-line"><span class="token plain">        onTrigger: instance.rtg ? e =&gt; invokeArrayFns(instance.rtg, e) : void 0 </span></div><div class="token-line"><span class="token plain">      } </span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>通过上述代码我们发现，onRenderTracked 和 onRenderTriggered 注册的钩子函数，原来是在副作用渲染函数的 onTrack 和 onTrigger 对应的函数中执行的。</p><p>我们当时介绍 effect 副作用函数的配置时并没有介绍这两个属性，那么它们是做什么用的呢？</p><p>这就要先来看 onTrack 函数的执行时机。我们知道当访问一个响应式对象时，会执行 track 函数做依赖收集，我们来回顾一下它的实现：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">function track(target, type, key) { </span></div><div class="token-line"><span class="token plain">      // 执行一些依赖收集的操作 </span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">      if (!dep.has(activeEffect)) { </span></div><div class="token-line"><span class="token plain">        dep.add(activeEffect) </span></div><div class="token-line"><span class="token plain">        activeEffect.deps.push(dep) </span></div><div class="token-line"><span class="token plain">        if ((process.env.NODE_ENV !== &#x27;production&#x27;) &amp;&amp; activeEffect.options.onTrack) { </span></div><div class="token-line"><span class="token plain">          // 执行 onTrack 函数 </span></div><div class="token-line"><span class="token plain">          activeEffect.options.onTrack({ </span></div><div class="token-line"><span class="token plain">            effect: activeEffect, </span></div><div class="token-line"><span class="token plain">            target, </span></div><div class="token-line"><span class="token plain">            type, </span></div><div class="token-line"><span class="token plain">            key </span></div><div class="token-line"><span class="token plain">          }) </span></div><div class="token-line"><span class="token plain">        } </span></div><div class="token-line"><span class="token plain">      } </span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>可以看到，track 函数先执行依赖收集，然后在非生产环境下检测当前的 activeEffect 的配置有没有定义 onTrack 函数，如果有的则执行该方法。</p><p>因此对应到副作用渲染函数，当它执行的时候，activeEffect 就是这个副作用渲染函数，这时访问响应式数据就会触发 track 函数，<strong>在执行完依赖收集后</strong>，<strong>会执行 onTrack 函数</strong>，<strong>也就是遍历执行我们注册的 renderTracked 钩子函数</strong>。</p><p>接下来，我们再来回顾一下 trigger 函数的实现：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">function trigger (target, type, key, newValue) { </span></div><div class="token-line"><span class="token plain">      // 添加要运行的 effects 集合 </span></div><div class="token-line"><span class="token plain">      const run = (effect) =&gt; { </span></div><div class="token-line"><span class="token plain">        if ((process.env.NODE_ENV !== &#x27;production&#x27;) &amp;&amp; effect.options.onTrigger) { </span></div><div class="token-line"><span class="token plain">            // 执行 onTrigger </span></div><div class="token-line"><span class="token plain">          effect.options.onTrigger({ </span></div><div class="token-line"><span class="token plain">            effect, </span></div><div class="token-line"><span class="token plain">            target, </span></div><div class="token-line"><span class="token plain">            key, </span></div><div class="token-line"><span class="token plain">            type, </span></div><div class="token-line"><span class="token plain">            newValue, </span></div><div class="token-line"><span class="token plain">            oldValue, </span></div><div class="token-line"><span class="token plain">            oldTarget </span></div><div class="token-line"><span class="token plain">          }) </span></div><div class="token-line"><span class="token plain">        } </span></div><div class="token-line"><span class="token plain">        if (effect.options.scheduler) { </span></div><div class="token-line"><span class="token plain">          effect.options.scheduler(effect) </span></div><div class="token-line"><span class="token plain">        } </span></div><div class="token-line"><span class="token plain">        else { </span></div><div class="token-line"><span class="token plain">          effect() </span></div><div class="token-line"><span class="token plain">        } </span></div><div class="token-line"><span class="token plain">      } </span></div><div class="token-line"><span class="token plain">      // 遍历执行 effects </span></div><div class="token-line"><span class="token plain">      effects.forEach(run) </span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>我们知道，trigger 函数首先要创建运行的 effects 集合，然后遍历执行，在执行的过程中，会在非生产环境下检测待执行的 effect 配置中有没有定义 onTrigger 函数，如果有则执行该方法。</p><p>因此对应到我们的副作用渲染函数，当它内部依赖的响应式对象值被修改后，就会触发 trigger 函数 ，这个时候副作用渲染函数就会被添加到要运行的 effects 集合中，<strong>在遍历执行 effects 的时候会执行 onTrigger 函数</strong>，<strong>也就是遍历执行我们注册的 renderTriggered 钩子函数</strong>。</p><p>了解完 renderTracked 和 renderTriggered 钩子函数的执行时机后，我们来看一下实际场景的应用：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">&lt;template&gt; </span></div><div class="token-line"><span class="token plain">      &lt;div&gt; </span></div><div class="token-line"><span class="token plain">        &lt;div&gt; </span></div><div class="token-line"><span class="token plain">          &lt;p&gt;{{count}}&lt;/p&gt; </span></div><div class="token-line"><span class="token plain">          &lt;button @click=&quot;increase&quot;&gt;Increase&lt;/button&gt; </span></div><div class="token-line"><span class="token plain">        &lt;/div&gt; </span></div><div class="token-line"><span class="token plain">      &lt;/div&gt; </span></div><div class="token-line"><span class="token plain">    &lt;/template&gt; </span></div><div class="token-line"><span class="token plain">    &lt;script&gt; </span></div><div class="token-line"><span class="token plain">      import { ref, onRenderTracked, onRenderTriggered } from &#x27;vue&#x27; </span></div><div class="token-line"><span class="token plain">      export default { </span></div><div class="token-line"><span class="token plain">        setup () { </span></div><div class="token-line"><span class="token plain">          const count = ref(0) </span></div><div class="token-line"><span class="token plain">          function increase () { </span></div><div class="token-line"><span class="token plain">            count.value++ </span></div><div class="token-line"><span class="token plain">          } </span></div><div class="token-line"><span class="token plain">          onRenderTracked((e) =&gt; { </span></div><div class="token-line"><span class="token plain">            console.log(e) </span></div><div class="token-line"><span class="token plain">            debugger </span></div><div class="token-line"><span class="token plain">          }) </span></div><div class="token-line"><span class="token plain">          onRenderTriggered((e) =&gt; { </span></div><div class="token-line"><span class="token plain">            console.log(e) </span></div><div class="token-line"><span class="token plain">            debugger </span></div><div class="token-line"><span class="token plain">          }) </span></div><div class="token-line"><span class="token plain">          return { </span></div><div class="token-line"><span class="token plain">            count, </span></div><div class="token-line"><span class="token plain">            increase </span></div><div class="token-line"><span class="token plain">          } </span></div><div class="token-line"><span class="token plain">        } </span></div><div class="token-line"><span class="token plain">      } </span></div><div class="token-line"><span class="token plain">    &lt;/script&gt;</span></div></pre></div><p><strong>像这样</strong>在开发阶段，我们可以通过注册这两个钩子函数，来追踪组件渲染的依赖来源以及触发组件重新渲染的数据更新来源。</p><h3 id="总结"><a aria-hidden="true" tabindex="-1" href="/blog/vue3源码分析/03.模块二学会新设计composition-api/08#总结"><span class="icon icon-link"></span></a>总结</h3><p>好的，到这里我们这一节的学习就结束啦，通过学习，你应该掌握 Vue.js 中生命周期注册的 API，了解各个生命周期的执行时机和应用场景。</p><p>最后，我们通过一张图再来直观地感受一下组件的各个生命周期：</p><p><img src="https://s0.lgstatic.com/i/image/M00/40/C1/Ciqc1F8zkvmAR_QpAAJxUtKU_4s942.png" alt="1.png"/></p><p>Vue.js 3.0 还有 2 个生命周期 API，分别是 onActivated 和 onDeactivated，我们将会在介绍 KeepAlive 组件时详细分析。</p><p>最后，给你留一道思考题目，如果你想在路由组件切换的时候，取消组件正在发送的异步 Ajax 请求，那你应该在哪个生命周期写这个逻辑呢？欢迎你在留言区与我分享。</p><blockquote><p><strong>本节课的相关代码在源代码中的位置如下：</strong><br/>packages/runtime-core/src/apiLifecycle.ts<br/>packages/runtime-core/src/renderer.ts<br/>packages/reactivity/src/effect.ts</p></blockquote></div><div class="__dumi-default-layout-footer-meta"><a target="_blank" rel="noopener noreferrer" href="https://github.com/GGwujun/blog/edit/master/docs/vue3源码分析/03.模块二学会新设计CompositionAPI/08.md">在 GitHub 上编辑此页<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a><span data-updated-text="最后更新时间：">5/2/2022 10:56:55</span></div></div></div></div>
	<script>
  window.g_useSSR = true;
  window.g_initialProps = {};
	</script>

    <script>
      (function () {
        if (!location.port) {
          (function (i, s, o, g, r, a, m) {
            i["GoogleAnalyticsObject"] = r;
            (i[r] =
              i[r] ||
              function () {
                (i[r].q = i[r].q || []).push(arguments);
              }),
              (i[r].l = 1 * new Date());
            (a = s.createElement(o)), (m = s.getElementsByTagName(o)[0]);
            a.async = 1;
            a.src = g;
            m.parentNode.insertBefore(a, m);
          })(
            window,
            document,
            "script",
            "//www.google-analytics.com/analytics.js",
            "ga"
          );
          ga("create", "UA-149864185-1", "auto");
          ga("send", "pageview");
        }
      })();
    </script>
    <script src="/blog/umi.js"></script>
  </body>
</html>
