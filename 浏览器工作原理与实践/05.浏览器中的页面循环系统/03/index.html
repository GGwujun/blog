<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no"
    />
    <link rel="shortcut icon" type="image/x-icon" href="/logo.png" />
    <link rel="stylesheet" href="/blog/umi.css" />
    <script>
      window.routerBase = "/blog";
    </script>
    <script>
      //! umi version: 3.5.17
    </script>
    <script>
      !(function () {
        var e = localStorage.getItem("dumi:prefers-color"),
          t = window.matchMedia("(prefers-color-scheme: dark)").matches,
          r = ["light", "dark", "auto"];
        document.documentElement.setAttribute(
          "data-prefers-color",
          e === r[2] ? (t ? r[1] : r[0]) : r.indexOf(e) > -1 ? e : r[0]
        );
      })();
    </script>
    <title>17 | WebAPI：XMLHttpRequest是怎么实现的？</title>
  </head>
  <body>
    <div id="root"><div class="__dumi-default-layout" data-route="/浏览器工作原理与实践/05.浏览器中的页面循环系统/03" data-show-sidemenu="true" data-show-slugs="true" data-site-mode="true" data-gapless="false"><div class="__dumi-default-navbar" data-mode="site"><button class="__dumi-default-navbar-toggle"></button><a class="__dumi-default-navbar-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog/">大师兄</a><nav><div class="__dumi-default-search"><input type="search" class="__dumi-default-search-input" value=""/><ul></ul></div><span>计算机基础<ul><li><a href="/blog/编译原理之美">编译原理之美</a></li><li><a href="/blog/编译原理实战">编译原理实战</a></li><li><a href="/blog/深入浅出计算机组成原理">深入浅出计算机组成原理</a></li><li><a href="/blog/详解http">详解http</a></li><li><a href="/blog/计算机网络通关29讲">计算机网络通关29讲</a></li><li><a href="/blog/网络排查案例课">网络排查案例课</a></li><li><a href="/blog/linux操作系统">linux操作系统</a></li><li><a href="/blog/linux性能优化实战">linux性能优化实战</a></li><li><a href="/blog/程序员数学基础">程序员数学基础</a></li><li><a href="/blog/趣谈网络协议">趣谈网络协议</a></li><li><a href="/blog/操作系统实战">操作系统实战</a></li><li><a href="/blog/软件工程之美">软件工程之美</a></li><li><a href="/blog/sql必知必会">sql必知必会</a></li><li><a href="/blog/操作系统实战45讲">操作系统实战45讲</a></li><li><a href="/blog/网络编程实战">网络编程实战</a></li></ul></span><span>算法<ul><li><a href="/blog/常用算法25讲">常用算法25讲</a></li><li><a href="/blog/数据结构与算法之美">数据结构与算法之美</a></li><li><a href="/blog/业务开发算法50讲">业务开发算法50讲</a></li><li><a href="/blog/动态规划面试宝典">动态规划面试宝典</a></li></ul></span><span>前端开发<ul><li><a aria-current="page" class="active" href="/blog/浏览器工作原理与实践">浏览器工作原理与实践</a></li><li><a href="/blog/新时代产品经理进阶之路">新时代产品经理进阶之路</a></li><li><a href="/blog/全栈工程师修炼指南">全栈工程师修炼指南</a></li><li><a href="/blog/flutter核心技术与实战">flutter核心技术与实战</a></li><li><a href="/blog/java-script核心原理解析">java-script核心原理解析</a></li><li><a href="/blog/说透低代码">说透低代码</a></li><li><a href="/blog/nodejs应用开发实战">nodejs应用开发实战</a></li><li><a href="/blog/反爬虫兵法演绎20讲">反爬虫兵法演绎20讲</a></li><li><a href="/blog/reactnative新架构实战课">reactnative新架构实战课</a></li><li><a href="/blog/正则表达式入门">正则表达式入门</a></li><li><a href="/blog/重学前端">重学前端</a></li><li><a href="/blog/serverless入门课">serverless入门课</a></li><li><a href="/blog/type-script入门实战笔记">type-script入门实战笔记</a></li><li><a href="/blog/图解googlev8">图解googlev8</a></li><li><a href="/blog/vue3源码分析">vue3源码分析</a></li><li><a href="/blog/玩转Vue3全家桶">玩转Vue3全家桶</a></li><li><a href="/blog/webassembly入门">webassembly入门</a></li><li><a href="/blog/手把手带你写一个Web框架">手把手带你写一个Web框架</a></li><li><a href="/blog/web漏洞挖掘实战">web漏洞挖掘实战</a></li><li><a href="/blog/跟月影学可视化">跟月影学可视化</a></li><li><a href="/blog/搞定音频技术">搞定音频技术</a></li><li><a href="/blog/攻克视频技术">攻克视频技术</a></li></ul></span><span>前端工程化<ul><li><a href="/blog/logger">logger</a></li><li><a href="/blog/webpack">webpack</a></li><li><a href="/blog/webpackChain">webpackChain</a></li></ul></span><span>前端性能优化<ul><li><a href="/blog/react性能调优">react性能调优</a></li></ul></span><span>软件测试<ul><li><a href="/blog/全链路压测实战30讲">全链路压测实战30讲</a></li><li><a href="/blog/性能测试实战30讲">性能测试实战30讲</a></li><li><a href="/blog/自动化测试高手课">自动化测试高手课</a></li><li><a href="/blog/软件测试52讲">软件测试52讲</a></li></ul></span><span>面试<ul><li><a href="/blog/面试现场">面试现场</a></li></ul></span><span>杂谈<ul><li><a href="/blog/超级访谈对话张雪峰">超级访谈对话张雪峰</a></li><li><a href="/blog/Git实战手册">Git实战手册</a></li><li><a href="/blog/NodeJS">NodeJS</a></li><li><a href="/blog/ReactJS">ReactJS</a></li><li><a href="/blog/UI设计">UI设计</a></li><li><a href="/blog/webpack4系列教程">webpack4系列教程</a></li><li><a href="/blog/前端知识体系">前端知识体系</a></li><li><a href="/blog/剑指offer刷题笔记">剑指offer刷题笔记</a></li><li><a href="/blog/思考与成长">思考与成长</a></li><li><a href="/blog/设计模式手册">设计模式手册</a></li></ul></span><div class="__dumi-default-navbar-tool"><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "></div></div></div></nav></div><div class="__dumi-default-menu" data-mode="site"><div class="__dumi-default-menu-inner"><div class="__dumi-default-menu-header"><a class="__dumi-default-menu-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog/"></a><h1>大师兄</h1><p></p></div><div class="__dumi-default-menu-mobile-area"><ul class="__dumi-default-menu-nav-list"><li>计算机基础<ul><li><a href="/blog/编译原理之美">编译原理之美</a></li><li><a href="/blog/编译原理实战">编译原理实战</a></li><li><a href="/blog/深入浅出计算机组成原理">深入浅出计算机组成原理</a></li><li><a href="/blog/详解http">详解http</a></li><li><a href="/blog/计算机网络通关29讲">计算机网络通关29讲</a></li><li><a href="/blog/网络排查案例课">网络排查案例课</a></li><li><a href="/blog/linux操作系统">linux操作系统</a></li><li><a href="/blog/linux性能优化实战">linux性能优化实战</a></li><li><a href="/blog/程序员数学基础">程序员数学基础</a></li><li><a href="/blog/趣谈网络协议">趣谈网络协议</a></li><li><a href="/blog/操作系统实战">操作系统实战</a></li><li><a href="/blog/软件工程之美">软件工程之美</a></li><li><a href="/blog/sql必知必会">sql必知必会</a></li><li><a href="/blog/操作系统实战45讲">操作系统实战45讲</a></li><li><a href="/blog/网络编程实战">网络编程实战</a></li></ul></li><li>算法<ul><li><a href="/blog/常用算法25讲">常用算法25讲</a></li><li><a href="/blog/数据结构与算法之美">数据结构与算法之美</a></li><li><a href="/blog/业务开发算法50讲">业务开发算法50讲</a></li><li><a href="/blog/动态规划面试宝典">动态规划面试宝典</a></li></ul></li><li>前端开发<ul><li><a aria-current="page" class="active" href="/blog/浏览器工作原理与实践">浏览器工作原理与实践</a></li><li><a href="/blog/新时代产品经理进阶之路">新时代产品经理进阶之路</a></li><li><a href="/blog/全栈工程师修炼指南">全栈工程师修炼指南</a></li><li><a href="/blog/flutter核心技术与实战">flutter核心技术与实战</a></li><li><a href="/blog/java-script核心原理解析">java-script核心原理解析</a></li><li><a href="/blog/说透低代码">说透低代码</a></li><li><a href="/blog/nodejs应用开发实战">nodejs应用开发实战</a></li><li><a href="/blog/反爬虫兵法演绎20讲">反爬虫兵法演绎20讲</a></li><li><a href="/blog/reactnative新架构实战课">reactnative新架构实战课</a></li><li><a href="/blog/正则表达式入门">正则表达式入门</a></li><li><a href="/blog/重学前端">重学前端</a></li><li><a href="/blog/serverless入门课">serverless入门课</a></li><li><a href="/blog/type-script入门实战笔记">type-script入门实战笔记</a></li><li><a href="/blog/图解googlev8">图解googlev8</a></li><li><a href="/blog/vue3源码分析">vue3源码分析</a></li><li><a href="/blog/玩转Vue3全家桶">玩转Vue3全家桶</a></li><li><a href="/blog/webassembly入门">webassembly入门</a></li><li><a href="/blog/手把手带你写一个Web框架">手把手带你写一个Web框架</a></li><li><a href="/blog/web漏洞挖掘实战">web漏洞挖掘实战</a></li><li><a href="/blog/跟月影学可视化">跟月影学可视化</a></li><li><a href="/blog/搞定音频技术">搞定音频技术</a></li><li><a href="/blog/攻克视频技术">攻克视频技术</a></li></ul></li><li>前端工程化<ul><li><a href="/blog/logger">logger</a></li><li><a href="/blog/webpack">webpack</a></li><li><a href="/blog/webpackChain">webpackChain</a></li></ul></li><li>前端性能优化<ul><li><a href="/blog/react性能调优">react性能调优</a></li></ul></li><li>软件测试<ul><li><a href="/blog/全链路压测实战30讲">全链路压测实战30讲</a></li><li><a href="/blog/性能测试实战30讲">性能测试实战30讲</a></li><li><a href="/blog/自动化测试高手课">自动化测试高手课</a></li><li><a href="/blog/软件测试52讲">软件测试52讲</a></li></ul></li><li>面试<ul><li><a href="/blog/面试现场">面试现场</a></li></ul></li><li>杂谈<ul><li><a href="/blog/超级访谈对话张雪峰">超级访谈对话张雪峰</a></li><li><a href="/blog/Git实战手册">Git实战手册</a></li><li><a href="/blog/NodeJS">NodeJS</a></li><li><a href="/blog/ReactJS">ReactJS</a></li><li><a href="/blog/UI设计">UI设计</a></li><li><a href="/blog/webpack4系列教程">webpack4系列教程</a></li><li><a href="/blog/前端知识体系">前端知识体系</a></li><li><a href="/blog/剑指offer刷题笔记">剑指offer刷题笔记</a></li><li><a href="/blog/思考与成长">思考与成长</a></li><li><a href="/blog/设计模式手册">设计模式手册</a></li></ul></li></ul><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "><button title="Dark theme" class="__dumi-default-dark-moon "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="3854" width="22" height="22"><path d="M991.816611 674.909091a69.166545 69.166545 0 0 0-51.665455-23.272727 70.795636 70.795636 0 0 0-27.438545 5.585454A415.674182 415.674182 0 0 1 754.993338 698.181818c-209.594182 0-393.472-184.785455-393.472-395.636363 0-52.363636 38.539636-119.621818 69.515637-173.614546 4.887273-8.610909 9.634909-16.756364 14.103272-24.901818A69.818182 69.818182 0 0 0 384.631156 0a70.842182 70.842182 0 0 0-27.438545 5.585455C161.678429 90.298182 14.362065 307.898182 14.362065 512c0 282.298182 238.824727 512 532.38691 512a522.286545 522.286545 0 0 0 453.957818-268.334545A69.818182 69.818182 0 0 0 991.816611 674.909091zM546.679156 954.181818c-248.785455 0-462.941091-192-462.941091-442.181818 0-186.647273 140.637091-372.829091 300.939637-442.181818-36.817455 65.629091-92.578909 151.970909-92.578909 232.727273 0 250.181818 214.109091 465.454545 462.917818 465.454545a488.331636 488.331636 0 0 0 185.181091-46.545455 453.003636 453.003636 0 0 1-393.565091 232.727273z m103.656728-669.323636l-14.266182 83.781818a34.909091 34.909091 0 0 0 50.362182 36.770909l74.775272-39.563636 74.752 39.563636a36.142545 36.142545 0 0 0 16.174546 3.956364 34.909091 34.909091 0 0 0 34.210909-40.727273l-14.289455-83.781818 60.509091-59.345455a35.025455 35.025455 0 0 0-19.223272-59.578182l-83.61891-12.101818-37.376-76.101818a34.56 34.56 0 0 0-62.254545 0l-37.376 76.101818-83.618909 12.101818a34.909091 34.909091 0 0 0-19.246546 59.578182z m70.423272-64.698182a34.280727 34.280727 0 0 0 26.135273-19.083636l14.312727-29.090909 14.336 29.090909a34.257455 34.257455 0 0 0 26.135273 19.083636l32.046546 4.887273-23.272728 22.574545a35.234909 35.234909 0 0 0-10.007272 30.952727l5.46909 32.116364-28.625454-15.127273a34.490182 34.490182 0 0 0-32.302546 0l-28.695272 15.127273 5.469091-32.116364a35.141818 35.141818 0 0 0-9.984-30.952727l-23.272728-22.574545z" p-id="3855"></path></svg></button><button title="Light theme" class="__dumi-default-dark-sun "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="4026" width="22" height="22"><path d="M915.2 476.16h-43.968c-24.704 0-44.736 16-44.736 35.84s20.032 35.904 44.736 35.904H915.2c24.768 0 44.8-16.064 44.8-35.904s-20.032-35.84-44.8-35.84zM512 265.6c-136.704 0-246.464 109.824-246.464 246.4 0 136.704 109.76 246.464 246.464 246.464S758.4 648.704 758.4 512c0-136.576-109.696-246.4-246.4-246.4z m0 425.6c-99.008 0-179.2-80.128-179.2-179.2 0-98.944 80.192-179.2 179.2-179.2S691.2 413.056 691.2 512c0 99.072-80.192 179.2-179.2 179.2zM197.44 512c0-19.84-19.136-35.84-43.904-35.84H108.8c-24.768 0-44.8 16-44.8 35.84s20.032 35.904 44.8 35.904h44.736c24.768 0 43.904-16.064 43.904-35.904zM512 198.464c19.776 0 35.84-20.032 35.84-44.8v-44.8C547.84 84.032 531.84 64 512 64s-35.904 20.032-35.904 44.8v44.8c0 24.768 16.128 44.864 35.904 44.864z m0 627.136c-19.776 0-35.904 20.032-35.904 44.8v44.736C476.096 940.032 492.16 960 512 960s35.84-20.032 35.84-44.8v-44.736c0-24.768-16.064-44.864-35.84-44.864z m329.92-592.832c17.472-17.536 20.288-43.072 6.4-57.024-14.016-14.016-39.488-11.2-57.024 6.336-4.736 4.864-26.496 26.496-31.36 31.36-17.472 17.472-20.288 43.008-6.336 57.024 13.952 14.016 39.488 11.2 57.024-6.336 4.8-4.864 26.496-26.56 31.296-31.36zM213.376 759.936c-4.864 4.8-26.56 26.624-31.36 31.36-17.472 17.472-20.288 42.944-6.4 56.96 14.016 13.952 39.552 11.2 57.024-6.336 4.8-4.736 26.56-26.496 31.36-31.36 17.472-17.472 20.288-43.008 6.336-56.96-14.016-13.952-39.552-11.072-56.96 6.336z m19.328-577.92c-17.536-17.536-43.008-20.352-57.024-6.336-14.08 14.016-11.136 39.488 6.336 57.024 4.864 4.864 26.496 26.56 31.36 31.424 17.536 17.408 43.008 20.288 56.96 6.336 14.016-14.016 11.264-39.488-6.336-57.024-4.736-4.864-26.496-26.56-31.296-31.424z m527.168 628.608c4.864 4.864 26.624 26.624 31.36 31.424 17.536 17.408 43.072 20.224 57.088 6.336 13.952-14.016 11.072-39.552-6.4-57.024-4.864-4.8-26.56-26.496-31.36-31.36-17.472-17.408-43.072-20.288-57.024-6.336-13.952 14.016-11.008 39.488 6.336 56.96z" p-id="4027"></path></svg></button><button title="Default to system" class="__dumi-default-dark-auto "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="11002" width="22" height="22"><path d="M127.658667 492.885333c0-51.882667 10.24-101.717333 30.378666-149.162666s47.786667-88.064 81.92-122.538667 75.093333-61.781333 122.538667-81.92 96.938667-30.378667 149.162667-30.378667 101.717333 10.24 149.162666 30.378667 88.405333 47.786667 122.88 81.92 61.781333 75.093333 81.92 122.538667 30.378667 96.938667 30.378667 149.162666-10.24 101.717333-30.378667 149.162667-47.786667 88.405333-81.92 122.88-75.093333 61.781333-122.88 81.92-97.28 30.378667-149.162666 30.378667-101.717333-10.24-149.162667-30.378667-88.064-47.786667-122.538667-81.92-61.781333-75.093333-81.92-122.88-30.378667-96.938667-30.378666-149.162667z m329.045333 0c0 130.048 13.994667 244.394667 41.984 343.381334h12.970667c46.762667 0 91.136-9.216 133.461333-27.306667s78.848-42.666667 109.568-73.386667 54.954667-67.242667 73.386667-109.568 27.306667-86.698667 27.306666-133.461333c0-46.421333-9.216-90.794667-27.306666-133.12s-42.666667-78.848-73.386667-109.568-67.242667-54.954667-109.568-73.386667-86.698667-27.306667-133.461333-27.306666h-11.605334c-28.672 123.562667-43.349333 237.909333-43.349333 343.722666z" p-id="11003"></path></svg></button></div></div></div><ul class="__dumi-default-menu-list"><li><a href="/blog/浏览器工作原理与实践">浏览器工作原理与实践</a></li><li><a href="/blog/浏览器工作原理与实践/01.开篇词">01.开篇词</a><ul><li><a href="/blog/浏览器工作原理与实践/01.开篇词/01"><span>开篇词 | 参透了浏览器的工作原理，你就能解决80%的前端难题</span></a></li></ul></li><li><a href="/blog/浏览器工作原理与实践/02.宏观视角下的浏览器">02.宏观视角下的浏览器</a><ul><li><a href="/blog/浏览器工作原理与实践/02.宏观视角下的浏览器/01"><span>01 | Chrome架构：仅仅打开了1个页面，为什么有4个进程？</span></a></li><li><a href="/blog/浏览器工作原理与实践/02.宏观视角下的浏览器/02"><span>02 | TCP协议：如何保证页面文件能被完整送达浏览器？</span></a></li><li><a href="/blog/浏览器工作原理与实践/02.宏观视角下的浏览器/03"><span>03 | HTTP请求流程：为什么很多站点第二次打开速度会很快？</span></a></li><li><a href="/blog/浏览器工作原理与实践/02.宏观视角下的浏览器/04"><span>04 | 导航流程：从输入URL到页面展示，这中间发生了什么？</span></a></li><li><a href="/blog/浏览器工作原理与实践/02.宏观视角下的浏览器/05"><span>05 | 渲染流程（上）：HTML、CSS和JavaScript，是如何变成页面的？</span></a></li><li><a href="/blog/浏览器工作原理与实践/02.宏观视角下的浏览器/06"><span>06 | 渲染流程（下）：HTML、CSS和JavaScript，是如何变成页面的？</span></a></li></ul></li><li><a href="/blog/浏览器工作原理与实践/03.浏览器中的java-script执行机制">03.浏览器中的JavaScript执行机制</a><ul><li><a href="/blog/浏览器工作原理与实践/03.浏览器中的java-script执行机制/01"><span>07 | 变量提升：JavaScript代码是按顺序执行的吗？</span></a></li><li><a href="/blog/浏览器工作原理与实践/03.浏览器中的java-script执行机制/02"><span>08 | 调用栈：为什么JavaScript代码会出现栈溢出？</span></a></li><li><a href="/blog/浏览器工作原理与实践/03.浏览器中的java-script执行机制/03"><span>09 | 块级作用域：var缺陷以及为什么要引入let和const？</span></a></li><li><a href="/blog/浏览器工作原理与实践/03.浏览器中的java-script执行机制/04"><span>10 | 作用域链和闭包 ：代码中出现相同的变量，JavaScript引擎是如何选择的？</span></a></li><li><a href="/blog/浏览器工作原理与实践/03.浏览器中的java-script执行机制/05"><span>11 | this：从JavaScript执行上下文的视角讲清楚this</span></a></li></ul></li><li><a href="/blog/浏览器工作原理与实践/04.v8工作原理">04.V8工作原理</a><ul><li><a href="/blog/浏览器工作原理与实践/04.v8工作原理/01"><span>12 | 栈空间和堆空间：数据是如何存储的？</span></a></li><li><a href="/blog/浏览器工作原理与实践/04.v8工作原理/02"><span>13 | 垃圾回收：垃圾数据是如何自动回收的？</span></a></li><li><a href="/blog/浏览器工作原理与实践/04.v8工作原理/03"><span>14 | 编译器和解释器：V8是如何执行一段JavaScript代码的？</span></a></li></ul></li><li><a aria-current="page" class="active" href="/blog/浏览器工作原理与实践/05.浏览器中的页面循环系统">05.浏览器中的页面循环系统</a><ul><li><a href="/blog/浏览器工作原理与实践/05.浏览器中的页面循环系统/01"><span>15 | 消息队列和事件循环：页面是怎么“活”起来的？</span></a></li><li><a href="/blog/浏览器工作原理与实践/05.浏览器中的页面循环系统/02"><span>16 | WebAPI：setTimeout是如何实现的？</span></a></li><li><a aria-current="page" class="active" href="/blog/浏览器工作原理与实践/05.浏览器中的页面循环系统/03"><span>17 | WebAPI：XMLHttpRequest是怎么实现的？</span></a></li><li><a href="/blog/浏览器工作原理与实践/05.浏览器中的页面循环系统/04"><span>18 | 宏任务和微任务：不是所有任务都是一个待遇</span></a></li><li><a href="/blog/浏览器工作原理与实践/05.浏览器中的页面循环系统/05"><span>19 | Promise：使用Promise，告别回调函数</span></a></li><li><a href="/blog/浏览器工作原理与实践/05.浏览器中的页面循环系统/06"><span>20 | async/await：使用同步的方式去写异步代码</span></a></li></ul></li><li><a href="/blog/浏览器工作原理与实践/06.浏览器中的页面">06.浏览器中的页面</a><ul><li><a href="/blog/浏览器工作原理与实践/06.浏览器中的页面/01"><span>21 | Chrome开发者工具：利用网络面板做性能分析</span></a></li><li><a href="/blog/浏览器工作原理与实践/06.浏览器中的页面/02"><span>22 | DOM树：JavaScript是如何影响DOM树构建的？</span></a></li><li><a href="/blog/浏览器工作原理与实践/06.浏览器中的页面/03"><span>23 | 渲染流水线：CSS如何影响首次加载时的白屏时间？</span></a></li><li><a href="/blog/浏览器工作原理与实践/06.浏览器中的页面/04"><span>24 | 分层和合成机制：为什么CSS动画比JavaScript高效？</span></a></li><li><a href="/blog/浏览器工作原理与实践/06.浏览器中的页面/05"><span>25 | 页面性能：如何系统地优化页面？</span></a></li><li><a href="/blog/浏览器工作原理与实践/06.浏览器中的页面/06"><span>26 | 虚拟DOM：虚拟DOM和实际的DOM有何不同？</span></a></li><li><a href="/blog/浏览器工作原理与实践/06.浏览器中的页面/07"><span>27 | 渐进式网页应用（PWA）：它究竟解决了Web应用的哪些问题？</span></a></li><li><a href="/blog/浏览器工作原理与实践/06.浏览器中的页面/08"><span>28 | WebComponent：像搭积木一样构建Web应用</span></a></li></ul></li><li><a href="/blog/浏览器工作原理与实践/07.浏览器中的网络">07.浏览器中的网络</a><ul><li><a href="/blog/浏览器工作原理与实践/07.浏览器中的网络/01"><span>29 | HTTP/1：HTTP性能优化</span></a></li><li><a href="/blog/浏览器工作原理与实践/07.浏览器中的网络/02"><span>30｜HTTP/2：如何提升网络速度？</span></a></li><li><a href="/blog/浏览器工作原理与实践/07.浏览器中的网络/03"><span>31｜HTTP/3：甩掉TCP、TLS 的包袱，构建高效网络</span></a></li></ul></li><li><a href="/blog/浏览器工作原理与实践/08.浏览器安全">08.浏览器安全</a><ul><li><a href="/blog/浏览器工作原理与实践/08.浏览器安全/01"><span>32 | 同源策略：为什么XMLHttpRequest不能跨域请求资源？</span></a></li><li><a href="/blog/浏览器工作原理与实践/08.浏览器安全/02"><span>33 | 跨站脚本攻击（XSS）：为什么Cookie中有HttpOnly属性？</span></a></li><li><a href="/blog/浏览器工作原理与实践/08.浏览器安全/03"><span>34 | CSRF攻击：陌生链接不要随便点</span></a></li><li><a href="/blog/浏览器工作原理与实践/08.浏览器安全/04"><span>35 | 安全沙箱：页面和系统之间的隔离墙</span></a></li><li><a href="/blog/浏览器工作原理与实践/08.浏览器安全/05"><span>36 | HTTPS：让数据传输更安全</span></a></li></ul></li><li><a href="/blog/浏览器工作原理与实践/09.结束语">09.结束语</a><ul><li><a href="/blog/浏览器工作原理与实践/09.结束语/01"><span>结束语 | 大道至简</span></a></li><li><a href="/blog/浏览器工作原理与实践/09.结束语/02"><span>第二季回归 | 这次我们来专门聊聊V8</span></a></li><li><a href="/blog/浏览器工作原理与实践/09.结束语/03"><span>结课测试 | 这些浏览器的知识你都掌握了吗？</span></a></li></ul></li><li><a href="/blog/浏览器工作原理与实践/10.课外加餐">10.课外加餐</a><ul><li><a href="/blog/浏览器工作原理与实践/10.课外加餐/01"><span>加餐一｜浏览上下文组：如何计算Chrome中渲染进程的个数？</span></a></li><li><a href="/blog/浏览器工作原理与实践/10.课外加餐/02"><span>加餐二｜任务调度：有了setTimeOut，为什么还要使用rAF？</span></a></li><li><a href="/blog/浏览器工作原理与实践/10.课外加餐/03"><span>加餐三｜加载阶段性能：使用Audits来优化Web性能</span></a></li><li><a href="/blog/浏览器工作原理与实践/10.课外加餐/04"><span>加餐四｜页面性能工具：如何使用Performance？</span></a></li><li><a href="/blog/浏览器工作原理与实践/10.课外加餐/05"><span>加餐五 | 性能分析工具：如何分析Performance中的Main指标？</span></a></li><li><a href="/blog/浏览器工作原理与实践/10.课外加餐/06"><span>加餐六｜HTTPS：浏览器如何验证数字证书？</span></a></li></ul></li><li><a href="/blog/浏览器工作原理与实践/summary">浏览器工作原理与实践</a></li></ul></div></div><ul role="slug-list" class="__dumi-default-layout-toc"><li title="回调函数 VS 系统调用栈" data-depth="2"><a href="/blog/浏览器工作原理与实践/05.浏览器中的页面循环系统/03#回调函数-vs-系统调用栈"><span>回调函数 VS 系统调用栈</span></a></li><li title="XMLHttpRequest运作机制" data-depth="2"><a href="/blog/浏览器工作原理与实践/05.浏览器中的页面循环系统/03#xmlhttprequest运作机制"><span>XMLHttpRequest运作机制</span></a></li><li title="XMLHttpRequest使用过程中的“坑”" data-depth="2"><a href="/blog/浏览器工作原理与实践/05.浏览器中的页面循环系统/03#xmlhttprequest使用过程中的坑"><span>XMLHttpRequest使用过程中的“坑”</span></a></li><li title="1. 跨域问题" data-depth="3"><a href="/blog/浏览器工作原理与实践/05.浏览器中的页面循环系统/03#1-跨域问题"><span>1. 跨域问题</span></a></li><li title="2. HTTPS混合内容的问题" data-depth="3"><a href="/blog/浏览器工作原理与实践/05.浏览器中的页面循环系统/03#2-https混合内容的问题"><span>2. HTTPS混合内容的问题</span></a></li><li title="总结" data-depth="2"><a href="/blog/浏览器工作原理与实践/05.浏览器中的页面循环系统/03#总结"><span>总结</span></a></li><li title="思考时间" data-depth="2"><a href="/blog/浏览器工作原理与实践/05.浏览器中的页面循环系统/03#思考时间"><span>思考时间</span></a></li></ul><div class="__dumi-default-layout-content"><div class="markdown"><h1 id="17--webapixmlhttprequest是怎么实现的"><a aria-hidden="true" tabindex="-1" href="/blog/浏览器工作原理与实践/05.浏览器中的页面循环系统/03#17--webapixmlhttprequest是怎么实现的"><span class="icon icon-link"></span></a>17 | WebAPI：XMLHttpRequest是怎么实现的？</h1><p>在<a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/134456">上一篇文章<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>中我们介绍了setTimeout是如何结合渲染进程的循环系统工作的，那本篇文章我们就继续介绍另外一种类型的WebAPI——XMLHttpRequest。</p><p>自从网页中引入了JavaScript，我们就可以操作DOM树中任意一个节点，例如隐藏/显示节点、改变颜色、获得或改变文本内容、为元素添加事件响应函数等等， 几乎可以“为所欲为”了。</p><p>不过在XMLHttpRequest出现之前，如果服务器数据有更新，依然需要重新刷新整个页面。而XMLHttpRequest提供了从Web服务器获取数据的能力，如果你想要更新某条数据，只需要通过XMLHttpRequest请求服务器提供的接口，就可以获取到服务器的数据，然后再操作DOM来更新页面内容，整个过程只需要更新网页的一部分就可以了，而不用像之前那样还得刷新整个页面，这样既有效率又不会打扰到用户。</p><p>关于XMLHttpRequest，本来我是想一带而过的，后来发现这个WebAPI用于教学非常好。首先前面讲了那么网络内容，现在可以通过它把HTTP协议实践一遍；其次，XMLHttpRequest是一个非常典型的WebAPI，通过它来讲解浏览器是如何实现WebAPI的很合适，这对于你理解其他WebAPI也有非常大的帮助，同时在这个过程中我们还可以把一些安全问题给串起来。</p><p>但在深入讲解XMLHttpRequest之前，我们得先介绍下<strong>同步回调</strong>和<strong>异步回调</strong>这两个概念，这会帮助你更加深刻地理解WebAPI是怎么工作的。</p><h2 id="回调函数-vs-系统调用栈"><a aria-hidden="true" tabindex="-1" href="/blog/浏览器工作原理与实践/05.浏览器中的页面循环系统/03#回调函数-vs-系统调用栈"><span class="icon icon-link"></span></a>回调函数 VS 系统调用栈</h2><p>那什么是回调函数呢（Callback Function）？</p><p>将一个函数作为参数传递给另外一个函数，那作为参数的这个函数就是<strong>回调函数</strong>。简化的代码如下所示：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">let callback = function(){</span></div><div class="token-line"><span class="token plain">        console.log(&#x27;i am do homework&#x27;)</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    function doWork(cb) {</span></div><div class="token-line"><span class="token plain">        console.log(&#x27;start do work&#x27;)</span></div><div class="token-line"><span class="token plain">        cb()</span></div><div class="token-line"><span class="token plain">        console.log(&#x27;end do work&#x27;)</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    doWork(callback)</span></div></pre></div><p>在上面示例代码中，我们将一个匿名函数赋值给变量callback，同时将callback作为参数传递给了doWork()函数，这时在函数doWork()中callback就是回调函数。</p><p>上面的回调方法有个特点，就是回调函数callback是在主函数doWork返回之前执行的，我们把这个回调过程称为<strong>同步回调</strong>。</p><p>既然有同步回调，那肯定也有异步回调。下面我们再来看看异步回调的例子：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">let callback = function(){</span></div><div class="token-line"><span class="token plain">        console.log(&#x27;i am do homework&#x27;)</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    function doWork(cb) {</span></div><div class="token-line"><span class="token plain">        console.log(&#x27;start do work&#x27;)</span></div><div class="token-line"><span class="token plain">        setTimeout(cb,1000)   </span></div><div class="token-line"><span class="token plain">        console.log(&#x27;end do work&#x27;)</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    doWork(callback)</span></div></pre></div><p>在这个例子中，我们使用了setTimeout函数让callback在doWork函数执行结束后，又延时了1秒再执行，这次callback并没有在主函数doWork内部被调用，我们把这种回调函数在主函数外部执行的过程称为<strong>异步回调</strong>。</p><p>现在你应该知道什么是同步回调和异步回调了，那下面我们再深入点，站在消息循环的视角来看看同步回调和异步回调的区别。理解了这些，可以让你从本质上理解什么是回调。</p><p>我们还是先来回顾下页面的事件循环系统，通过<a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/132931">《15 | 消息队列和事件循环：页面是怎么“活”起来的？》<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>的学习，你应该已经知道浏览器页面是通过事件循环机制来驱动的，每个渲染进程都有一个消息队列，页面主线程按照顺序来执行消息队列中的事件，如执行JavaScript事件、解析DOM事件、计算布局事件、用户输入事件等等，如果页面有新的事件产生，那新的事件将会追加到事件队列的尾部。所以可以说是<strong>消息队列和主线程循环机制保证了页面有条不紊地运行</strong>。</p><p>这里还需要补充一点，那就是当循环系统在执行一个任务的时候，都要为这个任务维护一个<strong>系统调用栈</strong>。这个<strong>系统调用栈</strong>类似于JavaScript的调用栈，只不过系统调用栈是Chromium的开发语言C++来维护的，其完整的调用栈信息你可以通过chrome://tracing/来抓取。当然，你也可以通过Performance来抓取它核心的调用信息，如下图所示：</p><p><img src="https://static001.geekbang.org/resource/image/d3/77/d3d66afb1a103103e5c3f86c823efb77.png" alt=""/></p><p>消息循环系统调用栈记录</p><p>这幅图记录了一个Parse HTML的任务执行过程，其中黄色的条目表示执行JavaScript的过程，其他颜色的条目表示浏览器内部系统的执行过程。</p><p>通过该图你可以看出来，Parse HTML任务在执行过程中会遇到一系列的子过程，比如在解析页面的过程中遇到了JavaScript脚本，那么就暂停解析过程去执行该脚本，等执行完成之后，再恢复解析过程。然后又遇到了样式表，这时候又开始解析样式表……直到整个任务执行完成。</p><p>需要说明的是，整个Parse HTML是一个完整的任务，在执行过程中的脚本解析、样式表解析都是该任务的子过程，其下拉的长条就是执行过程中调用栈的信息。</p><p>每个任务在执行过程中都有自己的调用栈，那么同步回调就是在当前主函数的上下文中执行回调函数，这个没有太多可讲的。下面我们主要来看看异步回调过程，异步回调是指回调函数在主函数之外执行，一般有两种方式：</p><ul><li>第一种是把异步函数做成一个任务，添加到信息队列尾部；</li><li>第二种是把异步函数添加到微任务队列中，这样就可以在当前任务的末尾处执行微任务了。</li></ul><h2 id="xmlhttprequest运作机制"><a aria-hidden="true" tabindex="-1" href="/blog/浏览器工作原理与实践/05.浏览器中的页面循环系统/03#xmlhttprequest运作机制"><span class="icon icon-link"></span></a>XMLHttpRequest运作机制</h2><p>理解了什么是同步回调和异步回调，接下来我们就来分析XMLHttpRequest背后的实现机制，具体工作过程你可以参考下图：</p><p><img src="https://static001.geekbang.org/resource/image/29/c6/2914a052f4f249a52077692a22ee5cc6.png" alt=""/></p><p>XMLHttpRequest工作流程图</p><p>这是XMLHttpRequest的总执行流程图，下面我们就来分析从发起请求到接收数据的完整流程。</p><p>我们先从XMLHttpRequest的用法开始，首先看下面这样一段请求代码：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">function GetWebData(URL){</span></div><div class="token-line"><span class="token plain">        /**</span></div><div class="token-line"><span class="token plain">         * 1:新建XMLHttpRequest请求对象</span></div><div class="token-line"><span class="token plain">         */</span></div><div class="token-line"><span class="token plain">        let xhr = new XMLHttpRequest()</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        /**</span></div><div class="token-line"><span class="token plain">         * 2:注册相关事件回调处理函数 </span></div><div class="token-line"><span class="token plain">         */</span></div><div class="token-line"><span class="token plain">        xhr.onreadystatechange = function () {</span></div><div class="token-line"><span class="token plain">            switch(xhr.readyState){</span></div><div class="token-line"><span class="token plain">              case 0: //请求未初始化</span></div><div class="token-line"><span class="token plain">                console.log(&quot;请求未初始化&quot;)</span></div><div class="token-line"><span class="token plain">                break;</span></div><div class="token-line"><span class="token plain">              case 1://OPENED</span></div><div class="token-line"><span class="token plain">                console.log(&quot;OPENED&quot;)</span></div><div class="token-line"><span class="token plain">                break;</span></div><div class="token-line"><span class="token plain">              case 2://HEADERS_RECEIVED</span></div><div class="token-line"><span class="token plain">                console.log(&quot;HEADERS_RECEIVED&quot;)</span></div><div class="token-line"><span class="token plain">                break;</span></div><div class="token-line"><span class="token plain">              case 3://LOADING  </span></div><div class="token-line"><span class="token plain">                console.log(&quot;LOADING&quot;)</span></div><div class="token-line"><span class="token plain">                break;</span></div><div class="token-line"><span class="token plain">              case 4://DONE</span></div><div class="token-line"><span class="token plain">                if(this.status == 200||this.status == 304){</span></div><div class="token-line"><span class="token plain">                    console.log(this.responseText);</span></div><div class="token-line"><span class="token plain">                    }</span></div><div class="token-line"><span class="token plain">                console.log(&quot;DONE&quot;)</span></div><div class="token-line"><span class="token plain">                break;</span></div><div class="token-line"><span class="token plain">            }</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        xhr.ontimeout = function(e) { console.log(&#x27;ontimeout&#x27;) }</span></div><div class="token-line"><span class="token plain">        xhr.onerror = function(e) { console.log(&#x27;onerror&#x27;) }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        /**</span></div><div class="token-line"><span class="token plain">         * 3:打开请求</span></div><div class="token-line"><span class="token plain">         */</span></div><div class="token-line"><span class="token plain">        xhr.open(&#x27;Get&#x27;, URL, true);//创建一个Get请求,采用异步</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        /**</span></div><div class="token-line"><span class="token plain">         * 4:配置参数</span></div><div class="token-line"><span class="token plain">         */</span></div><div class="token-line"><span class="token plain">        xhr.timeout = 3000 //设置xhr请求的超时时间</span></div><div class="token-line"><span class="token plain">        xhr.responseType = &quot;text&quot; //设置响应返回的数据格式</span></div><div class="token-line"><span class="token plain">        xhr.setRequestHeader(&quot;X_TEST&quot;,&quot;time.geekbang&quot;)</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        /**</span></div><div class="token-line"><span class="token plain">         * 5:发送请求</span></div><div class="token-line"><span class="token plain">         */</span></div><div class="token-line"><span class="token plain">        xhr.send();</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>上面是一段利用了XMLHttpRequest来请求数据的代码，再结合上面的流程图，我们可以分析下这段代码是怎么执行的。</p><p><strong>第一步：创建XMLHttpRequest对象。</strong></p><p>当执行到<code>let xhr = new XMLHttpRequest()</code>后，JavaScript会创建一个XMLHttpRequest对象<strong>xhr</strong>，用来执行实际的网络请求操作。</p><p><strong>第二步：为xhr对象注册回调函数。</strong></p><p>因为网络请求比较耗时，所以要注册回调函数，这样后台任务执行完成之后就会通过调用回调函数来告诉其执行结果。</p><p>XMLHttpRequest的回调函数主要有下面几种：</p><ul><li>ontimeout，用来监控超时请求，如果后台请求超时了，该函数会被调用；</li><li>onerror，用来监控出错信息，如果后台请求出错了，该函数会被调用；</li><li>onreadystatechange，用来监控后台请求过程中的状态，比如可以监控到HTTP头加载完成的消息、HTTP响应体消息以及数据加载完成的消息等。</li></ul><p><strong>第三步：配置基础的请求信息。</strong></p><p>注册好回调事件之后，接下来就需要配置基础的请求信息了，首先要通过open接口配置一些基础的请求信息，包括请求的地址、请求方法（是get还是post）和请求方式（同步还是异步请求）。</p><p>然后通过xhr内部属性类配置一些其他可选的请求信息，你可以参考文中示例代码，我们通过<code>xhr.timeout = 3000</code>来配置超时时间，也就是说如果请求超过3000毫秒还没有响应，那么这次请求就被判断为失败了。</p><p>我们还可以通过<code>xhr.responseType = &quot;text&quot;</code>来配置服务器返回的格式，将服务器返回的数据自动转换为自己想要的格式，如果将responseType的值设置为json，那么系统会自动将服务器返回的数据转换为JavaScript对象格式。下面的图表是我列出的一些返回类型的描述：</p><p><img src="https://static001.geekbang.org/resource/image/85/bf/856d1965676fafa46122e3ad1235dfbf.png" alt=""/></p><p>假如你还需要添加自己专用的请求头属性，可以通过xhr.setRequestHeader来添加。</p><p><strong>第四步：发起请求。</strong></p><p>一切准备就绪之后，就可以调用<code>xhr.send</code>来发起网络请求了。你可以对照上面那张请求流程图，可以看到：渲染进程会将请求发送给网络进程，然后网络进程负责资源的下载，等网络进程接收到数据之后，就会利用IPC来通知渲染进程；渲染进程接收到消息之后，会将xhr的回调函数封装成任务并添加到消息队列中，等主线程循环系统执行到该任务的时候，就会根据相关的状态来调用对应的回调函数。</p><ul><li>如果网络请求出错了，就会执行xhr.onerror；</li><li>如果超时了，就会执行xhr.ontimeout；</li><li>如果是正常的数据接收，就会执行onreadystatechange来反馈相应的状态。</li></ul><p>这就是一个完整的XMLHttpRequest请求流程，如果你感兴趣，可以参考下Chromium对XMLHttpRequest的实现，<a target="_blank" rel="noopener noreferrer" href="https://chromium.googlesource.com/chromium/src/+/refs/heads/master/third_party/blink/renderer/core/xmlhttprequest/">点击这里查看代码<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>。</p><h2 id="xmlhttprequest使用过程中的坑"><a aria-hidden="true" tabindex="-1" href="/blog/浏览器工作原理与实践/05.浏览器中的页面循环系统/03#xmlhttprequest使用过程中的坑"><span class="icon icon-link"></span></a>XMLHttpRequest使用过程中的“坑”</h2><p>上述过程看似简单，但由于浏览器很多安全策略的限制，所以会导致你在使用过程中踩到非常多的“坑”。</p><p>浏览器安全问题是前端工程师避不开的一道坎，通常在使用过程中遇到的“坑”，很大一部分都是由安全策略引起的，不管你喜不喜欢，它都在这里。本来很完美的一个方案，正是由于加了安全限制，导致使用起来非常麻烦。</p><p>而你要做的就是去正视这各种的安全问题。也就是说要想更加完美地使用XMLHttpRequest，你就要了解浏览器的安全策略。</p><p>下面我们就来看看在使用XMLHttpRequest的过程中所遇到的跨域问题和混合内容问题。</p><h3 id="1-跨域问题"><a aria-hidden="true" tabindex="-1" href="/blog/浏览器工作原理与实践/05.浏览器中的页面循环系统/03#1-跨域问题"><span class="icon icon-link"></span></a>1. 跨域问题</h3><p>比如在极客邦的官网使用XMLHttpRequest请求极客时间的页面内容，由于极客邦的官网是<a target="_blank" rel="noopener noreferrer" href="https://www.geekbang.org/">www.geekbang.org<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>，极客时间的官网是<a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/">time.geekbang.org<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>，它们不是同一个源，所以就涉及到了跨域（在A站点中去访问不同源的B站点的内容）。默认情况下，跨域请求是不被允许的，你可以看下面的示例代码：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">var xhr = new XMLHttpRequest()</span></div><div class="token-line"><span class="token plain">    var url = &#x27;https://time.geekbang.org/&#x27;</span></div><div class="token-line"><span class="token plain">    function handler() {</span></div><div class="token-line"><span class="token plain">        switch(xhr.readyState){</span></div><div class="token-line"><span class="token plain">            case 0: //请求未初始化</span></div><div class="token-line"><span class="token plain">            console.log(&quot;请求未初始化&quot;)</span></div><div class="token-line"><span class="token plain">            break;</span></div><div class="token-line"><span class="token plain">            case 1://OPENED</span></div><div class="token-line"><span class="token plain">            console.log(&quot;OPENED&quot;)</span></div><div class="token-line"><span class="token plain">            break;</span></div><div class="token-line"><span class="token plain">            case 2://HEADERS_RECEIVED</span></div><div class="token-line"><span class="token plain">            console.log(&quot;HEADERS_RECEIVED&quot;)</span></div><div class="token-line"><span class="token plain">            break;</span></div><div class="token-line"><span class="token plain">            case 3://LOADING  </span></div><div class="token-line"><span class="token plain">            console.log(&quot;LOADING&quot;)</span></div><div class="token-line"><span class="token plain">            break;</span></div><div class="token-line"><span class="token plain">            case 4://DONE</span></div><div class="token-line"><span class="token plain">            if(this.status == 200||this.status == 304){</span></div><div class="token-line"><span class="token plain">                console.log(this.responseText);</span></div><div class="token-line"><span class="token plain">                }</span></div><div class="token-line"><span class="token plain">            console.log(&quot;DONE&quot;)</span></div><div class="token-line"><span class="token plain">            break;</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">       </span></div><div class="token-line"><span class="token plain">    function callOtherDomain() {</span></div><div class="token-line"><span class="token plain">      if(xhr) {    </span></div><div class="token-line"><span class="token plain">        xhr.open(&#x27;GET&#x27;, url, true)</span></div><div class="token-line"><span class="token plain">        xhr.onreadystatechange = handler</span></div><div class="token-line"><span class="token plain">        xhr.send();</span></div><div class="token-line"><span class="token plain">      }</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    callOtherDomain()</span></div></pre></div><p>你可以在控制台测试下。首先通过浏览器打开<a target="_blank" rel="noopener noreferrer" href="https://www.geekbang.org/">www.geekbang.org<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>，然后打开控制台，在控制台输入以上示例代码，再执行，会看到请求被Block了。控制台的提示信息如下：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">Access to XMLHttpRequest at &#x27;https://time.geekbang.org/&#x27; from origin &#x27;https://www.geekbang.org&#x27; has been blocked by CORS policy: No &#x27;Access-Control-Allow-Origin&#x27; header is present on the requested resource.</span></div></pre></div><p>因为 <a target="_blank" rel="noopener noreferrer" href="http://www.geekbang.org/">www.geekbang.org<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 和 time.geekbang.com 不属于一个域，所以以上访问就属于跨域访问了，这次访问失败就是由于跨域问题导致的。</p><h3 id="2-https混合内容的问题"><a aria-hidden="true" tabindex="-1" href="/blog/浏览器工作原理与实践/05.浏览器中的页面循环系统/03#2-https混合内容的问题"><span class="icon icon-link"></span></a>2. HTTPS混合内容的问题</h3><p>了解完跨域问题后，我们再来看看HTTPS的混合内容。HTTPS混合内容是HTTPS页面中包含了不符合HTTPS安全要求的内容，比如包含了HTTP资源，通过HTTP加载的图像、视频、样式表、脚本等，都属于混合内容。</p><p>通常，如果HTTPS请求页面中使用混合内容，浏览器会针对HTTPS混合内容显示警告，用来向用户表明此HTTPS页面包含不安全的资源。比如打开站点 <a target="_blank" rel="noopener noreferrer" href="https://www.iteye.com/groups">https://www.iteye.com/groups<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> ，可以通过控制台看到混合内容的警告，参考下图：</p><p><img src="https://static001.geekbang.org/resource/image/4b/63/4b4a210a1e078d9a26fe31e6eab34963.png" alt=""/></p><p>HTTPS混合内容警告</p><p>从上图可以看出，通过HTML文件加载的混合资源，虽然给出警告，但大部分类型还是能加载的。而使用XMLHttpRequest请求时，浏览器认为这种请求可能是攻击者发起的，会阻止此类危险的请求。比如我通过浏览器打开地址 <a target="_blank" rel="noopener noreferrer" href="https://www.iteye.com/groups">https://www.iteye.com/groups<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> ，然后通过控制台，使用XMLHttpRequest来请求 <a target="_blank" rel="noopener noreferrer" href="http://img-ads.csdn.net/2018/201811150919211586.jpg">http://img-ads.csdn.net/2018/201811150919211586.jpg<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> ，这时候请求就会报错，出错信息如下图所示：</p><p><img src="https://static001.geekbang.org/resource/image/46/a1/46c22d4e54815942c1a86f11b14516a1.png" alt=""/></p><p>使用XMLHttpRequest混合资源失效</p><h2 id="总结"><a aria-hidden="true" tabindex="-1" href="/blog/浏览器工作原理与实践/05.浏览器中的页面循环系统/03#总结"><span class="icon icon-link"></span></a>总结</h2><p>好了，今天我们就讲到这里，下面我来总结下今天的内容。</p><p>首先我们介绍了回调函数和系统调用栈；接下来我们站在循环系统的视角，分析了XMLHttpRequest是怎么工作的；最后又说明了由于一些安全因素的限制，在使用XMLHttpRequest的过程中会遇到跨域问题和混合内容的问题。</p><p>本篇文章跨度比较大，不是单纯地讲一个问题，而是将回调类型、循环系统、网络请求和安全问题“串联”起来了。</p><p>对比<a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/134456">上一篇文章<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>，setTimeout是直接将延迟任务添加到延迟队列中，而XMLHttpRequest发起请求，是由浏览器的其他进程或者线程去执行，然后再将执行结果利用IPC的方式通知渲染进程，之后渲染进程再将对应的消息添加到消息队列中。如果你搞懂了setTimeout和XMLHttpRequest的工作机制后，再来理解其他WebAPI就会轻松很多了，因为大部分WebAPI的工作逻辑都是类似的。</p><h2 id="思考时间"><a aria-hidden="true" tabindex="-1" href="/blog/浏览器工作原理与实践/05.浏览器中的页面循环系统/03#思考时间"><span class="icon icon-link"></span></a>思考时间</h2><p>网络安全很重要，但是又很容易被忽视，因为项目需求很少涉及到基础的Web安全。如果忽视了这些基础安全策略，在开发过程中会处处遇到安全策略挖下的“大坑”，所以对于一名开发者来说，Web安全理论很重要，也必须要学好。</p><p>那么今天我留给你一道开放性的思考题：你认为作为一名开发工程师，要如何去高效地学习前端的Web安全理论呢？</p><p>欢迎在留言区与我分享你的想法，也欢迎你在留言区记录你的思考过程。感谢阅读，如果你觉得这篇文章对你有帮助的话，也欢迎把它分享给更多的朋友。</p></div><div class="__dumi-default-layout-footer-meta"><a target="_blank" rel="noopener noreferrer" href="https://github.com/GGwujun/blog/edit/master/docs/浏览器工作原理与实践/05.浏览器中的页面循环系统/03.md">在 GitHub 上编辑此页<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a><span data-updated-text="最后更新时间：">5/2/2022 10:56:26</span></div></div></div></div>
	<script>
  window.g_useSSR = true;
  window.g_initialProps = {};
	</script>

    <script>
      (function () {
        if (!location.port) {
          (function (i, s, o, g, r, a, m) {
            i["GoogleAnalyticsObject"] = r;
            (i[r] =
              i[r] ||
              function () {
                (i[r].q = i[r].q || []).push(arguments);
              }),
              (i[r].l = 1 * new Date());
            (a = s.createElement(o)), (m = s.getElementsByTagName(o)[0]);
            a.async = 1;
            a.src = g;
            m.parentNode.insertBefore(a, m);
          })(
            window,
            document,
            "script",
            "//www.google-analytics.com/analytics.js",
            "ga"
          );
          ga("create", "UA-149864185-1", "auto");
          ga("send", "pageview");
        }
      })();
    </script>
    <script src="/blog/umi.js"></script>
  </body>
</html>
