exports.category = "other";
exports.title = "从0开始学游戏开发";
exports.data = [
  {
    chapterTitle: "开篇词",
    children: [
      {
        title: "开篇词 | 跟我学，你也可以开发一款游戏！",
        id: 7729,
        content:
          '<p>你好，我是蔡能。从96年编写第一行代码开始，我在IT行业从业已经有22年的时间。</p>\n<p>从程序员到管理者，我参与过各式各样的项目，也主导过很多项目。当然，我经历的大部分项目都是游戏。20多年里，我目睹了从最初的像素游戏，到如今高清贴图的3D游戏的发展过程。游戏行业，乃至整个IT行业都发生了翻天覆地的变化。</p>\n<p>当然，我本人也非常喜欢玩游戏。我喜欢自由自在的游戏和需要脑力的游戏。比如，“GTA系列”“老滚系列”和“三国志系列”。在玩游戏的过程中，我体会到各种各样的乐趣，同时，作为开发者，我也会从专业的角度出发，思考这款游戏究竟是如何制作出来的。</p>\n<p>我发现，喜欢玩游戏的人，都很有兴趣自己做一款游戏。哪怕自己不懂编程，但是自己做做策划，懂美术的话自己做做图，能让自己的游戏跑起来，就是一件幸福的事情。</p>\n<p>还有一部分人，可能对游戏并不感兴趣，但是对赚钱感兴趣，那么我的专栏也可以让你知道游戏开发的基础流程和知识，避免走弯路，不花冤枉钱，不掉技术坑。</p>\n<p>我看过网上各式各样的“傻瓜式”游戏开发工具，比如RPG MAKER。任何不懂编程的人，只需要导入规定的模板，就能方便地开发出一款游戏。然而，这种方法只能开发某一类非常简单的游戏。<strong><span class="orange">如果想要开发出一款真正意义上的游戏，还是要借助编程基础和系统的开发知识。</span></strong></p>\n<p>我举几个简单的例子，你就明白了。</p>\n<ul>\n<li>\n<p>在《守望先锋》里，我们看到的子弹射击，对方被击伤，这些都是经过怎样不断地网络优化实现的呢？还有各种网络预判模型，你是否都了解呢？</p>\n</li>\n<li>\n<p>我们玩的《星际争霸》，究竟是每个线程控制一个兵种，还是一个线程刷新全部兵种画面？</p>\n</li>\n<li>\n<p>《魔兽世界》如此庞大，它是如何将海量逻辑写在游戏客户端里？将逻辑编写成硬代码显然不理性，写成配置文件又缺乏机动性，那它是怎么做到的呢？</p>\n</li>\n<li>\n<p>另外，我发现，很多公司在开发游戏的时候，选择引擎也是一个尴尬事。是自己研发一款引擎还是购买别家成熟的引擎呢？引擎的好坏，对开发的游戏来讲有什么影响？很多人也是不知道的。</p>\n</li>\n</ul>\n<p>这些问题，我都会在专栏文章中一一解答。但前提是你最好具备一定的编程知识和基础。</p>\n<ul>\n<li>\n<p><strong>我将会尽量选择简洁的Python语言来编写。</strong>我会从最上层的脚本语言Python的使用开始，剖析为什么游戏开发要从这里开始。在用到C/C++代码的地方，我将会尽可能地使用简单易懂的语法来示范，所以，其实你只需要懂点儿英文就可以了（笑）。</p>\n</li>\n<li>\n<p><strong>我会尽量选择简单的开发工具，而不是动辄几个G的开发工具。</strong>比如“VS系列”，比如各种复杂的IDE。简单的开发工具足够简单明了地让你了解开发的具体流程，快速进入状态，而不是在设置工具上浪费大量的时间和精力。</p>\n</li>\n<li>\n<p><strong>我会尽量避免特别复杂的底层知识，但是也不会一带而过。</strong>我会帮你一步步梳理开发的流程，并仔细剖析，在C/C++中如何控制计算机的各种设备，操作计算机的各种硬件。或许你还会在编译中遇到问题，我也会一步一步，由浅入深，教你如何解决编译问题。</p>\n</li>\n<li>\n<p><strong>我将用制作“打飞机”游戏demo的过程，来完成游戏开发内容的分解步骤讲解。</strong>之所以选择“打飞机”作为游戏demo，是因为它的开发过程几乎涵盖了我要讲述的所有开发流程，包括操作、画面的前后遮挡、图像的碰撞和切换、资源包、脚本语言等等。</p>\n</li>\n</ul>\n<p>对于专栏的具体内容，我将分以下几个方面来阐述。</p>\n<ol>\n<li>我会先带你熟悉游戏开发的基础概念。包括开发游戏需要涉及的基础知识和需要准备的工具：游戏引擎、底层图形接口和地图编辑器。</li>\n<li>然后从0开始搭建一个游戏窗体，往窗体里添加图形、界面和操作。</li>\n<li>我还会讲解如何嵌入脚本语言。毕竟使用硬代码编写游戏逻辑并不是一个很好的选择，而脚本语言的嵌入，可以让我们很方便地完成游戏的逻辑开发。我们只需要将底层图形图像的显示、函数等捆绑好，接下来交给脚本语言就好了。</li>\n<li>除此之外，我还会阐述各种平台上的游戏开发和实现，带你学习一些最近热点的游戏开发知识。比如HTML5游戏和手机移动平台游戏。我们已经有了游戏开发的基本知识，也掌握了游戏开发的流程，再来看这些游戏的开发，就会变得很轻松了。</li>\n<li>最后，我会与你谈谈，我对游戏行业未来发展的看法。游戏将会如何发展，往哪个方向走？开开脑洞，我们大胆畅想游戏领域的未来。</li>\n</ol>\n<p>我希望，学习完这个专栏，<strong>能让你对游戏开发有个实质性的掌握，让你对游戏的开发和理念有一个完整并且系统的了解，并且能很快地着手进行游戏的开发</strong>。万变不离其宗，希望我的分享不会辜负你为此投入的金钱和时间。</p>\n<p>让我们一起踏上游戏开发的旅程吧！</p>\n<!-- [[[read_end]]] -->\n<p><img src="https://static001.geekbang.org/resource/image/56/24/566a01f6857d4a0e42c5f2fb8db59624.jpg" alt="" /></p>\n',
        article_title: "开篇词 | 跟我学，你也可以开发一款游戏！",
      },
    ],
  },
  {
    chapterTitle: "第一章：游戏开发基础知识",
    children: [
      {
        title: "第1讲 | 游戏开发需要了解哪些背景知识？",
        id: 8104,
        content:
          '<p>这一节开始，我将带你进入游戏开发的世界。</p>\n<p>从最初的小霸王，到充满混混和烟味的街机厅，到PS、Xbox、DC、N64等次世代游戏主机，再到电脑游戏，再到如今，在手机上就能玩到各种各样的游戏。</p>\n<p>我会依次为你揭密，这些令人痴迷、沉浸的游戏，究竟是怎么发展的，常见的游戏种类有哪些，这些游戏在开发流程和细节上有什么不同，以及游戏开发究竟要从哪里开始学起。</p>\n<h2 id="-">浅述游戏的发展</h2>\n<p>我们现在公认的第一款电子游戏（也就是主机游戏），是1952年面世的。游戏玩的是井字棋，6年后才出现了简陋的<a href="https://www.bilibili.com/video/av1326850/">网球游戏</a>。</p>\n<p>下面这幅图就是井字棋游戏，尽管它与1952年的游戏画面还是有所出入，但是游戏内容是一样的。</p>\n<p><img src="https://static001.geekbang.org/resource/image/e6/74/e67d2a821df9f4c625ba2f78ee294974.jpg" alt=""></p>\n<p>此后，我们就进入了“雅达利”时期。随后的《太空侵略者》，是最经典的一款游戏。在这之后，我们耳熟能详的任天堂红白机，发布了《吃豆人》《大金刚》等游戏。再之后，就进入了各种游戏主机竞相绽放的阶段。</p>\n<p>在电脑游戏方面，第一款电脑游戏是1962年面世的《太空战争》。这是一个学生编写的。到1980年之后，随着电脑技术的日趋成熟，电脑游戏的画面才开始有了逐渐赶超电子游戏的态势。到2005年之后，随着电脑图形硬件的发展，电脑游戏的发展进入了加速期。</p>\n<p>电子游戏的优势是，它集合了当时高精尖的图形显卡技术，纯粹为游戏所设计。比如索尼的PS系列。据闻，PS使用的显卡技术来自军用科技（传闻的真实性有待考证，但每一代PS的图形显卡的确都是业内顶尖水平）。而电脑游戏的优势是，它能更换显卡和硬件。当显卡升级换代的时候，理论上，只要主板支持，你就可以更新；而电子游戏主机是固化的硬件，只能靠购买新的版本。</p>\n<h2 id="-">游戏有哪些种类？</h2>\n<p>当前全世界的游戏琳琅满目，从硬件来讲，大致可以分为四大类。</p>\n<p>第一类是我们前面提到的<strong>主机游戏</strong>，业界称为<strong>Console Game</strong>。比如微软的Xbox系列、索尼的PS系列、任天堂的Switch、N64、Wii等。这类游戏的硬件可以插在电视机或者显示屏上。以前，游戏的载体一般是光盘、卡带，现在也可以直接从网上下载。</p>\n<p>这些公司还相应推出了掌上游戏机，比如任天堂的3DS、NDS、GBA，索尼的PSP、PSV等。掌上游戏机的推出，让玩家随时随地可以玩上游戏。由于是专业的游戏机，比之手机上的游戏，有更好的操作感，同时也更能体验到游戏的乐趣。</p>\n<p>第二类是<strong>电脑游戏</strong>。电脑游戏品类繁多，有PC客户端游戏，比如《梦幻西游》《魔兽世界》《星际争霸》《GTA》等；还有HTML5网页游戏、Flash游戏等等。</p>\n<p>另外一类是<strong>移动游戏</strong>。包括Pad游戏、手机游戏。手机游戏目前品类繁多，包括App游戏、HTML5游戏，以及微信发布的小游戏。</p>\n<p>最后一类是目前并不是特别发达的<strong>电视机游戏</strong>。随着安卓系统的兴起，电视盒子的出现，出现了一种不需要游戏主机却能在电视屏幕上直接玩的游戏，这就是电视机游戏。但这类游戏一般需要用电视遥控器玩，而且由于电视盒子的机能限制，画面甚至可能比不上手机游戏，所以只适合闲暇的时候偶尔玩一下。</p>\n<h2 id="-">游戏开发使用什么编程语言？</h2>\n<p>在最早期的游戏开发中，比如任天堂的《FamiCom》（我们俗称《红白机FC》）、《Super FamiCom》（我们俗称《超任SFC》），都是使用<strong>汇编语言</strong>进行开发的。早期由于8位机能限制，程序员们为了优化游戏速度、提升游戏画面，无所不用其极，甚至到了奇技淫巧的地步。到了后期的游戏（比如《无赖战士》《足球小将》等），已经将机能挖掘到了极限。到了16位机后（任天堂《SFC》、世嘉的《MD》），才逐步使用<strong>C语言</strong>进行编程。到了32位机之后，基本都是使用<strong>C/C++语言</strong>进行编程。</p>\n<h2 id="-">游戏开发从哪里开始学起？</h2>\n<p>手游这么火，我为什么不直接讲手游呢？原因很简单，想要开发手机游戏，对技术人员要求很高。手游有两种，一种是传统意义上的原生开发手游，一种是微信小游戏和网页小游戏。后面这个就不用说了，我主要说原生手游。</p>\n<p>我在后面会讲到，游戏引擎可以购买也可以自己开发。原生手游的话，用购买的成熟引擎做的话，调试起来就会比较困难。毕竟要在手机跑，出问题再改，再跑，加上手机内存和硬件限制，不如电脑端可以随时调试。其次，手游的开发需要考量更多资源的分配和占比，发布的包就是一个考验，谁也不会下载一个三四百兆的安装包。</p>\n<p>我会以电脑游戏为主，进行开发流程的讲解。首先，<strong>电脑游戏开发便捷</strong>。事实上，只要开发游戏，就一定离不开电脑，不管是主机游戏，还是掌上游戏、移动游戏，开发一定是在电脑上（或者专用开发电脑）；其次，<strong>搞明白了电脑游戏的开发流程和知识之后，其他游戏的开发也一通百通</strong>。</p>\n<p>我会针对2D游戏（特指客户端游戏）进行剖析和讲解。为何专门选择2D游戏进行讲解呢？</p>\n<!-- [[[read_end]]] -->\n<p>主要有两方面的原因：</p>\n<ul>\n<li><p><strong>2D游戏涉及最基本的图形、图像知识。</strong>从画面方面考虑，开发2D游戏只需要你知道X和Y的位置即可，其他深层次的知识，引擎都可以替你完成。想要制作3D画面，你需要掌握更多的知识，特别是几何知识，这是毋庸置疑的。对于初学者来说，我们首先需要掌握核心的开发流程，至于过于细节的知识，可以在有了一定基础之后再进行拓展学习。</p>\n</li>\n<li><p><strong>2D游戏涉及最核心的网络呈现过程。</strong>网络数据在客户端和服务器端之间传输，经过服务器端计算的数据返回给客户端，客户端进行呈现。比如，从“一颗炸弹消灭几个敌人”，就能知道网络是否有延迟，服务器计算是否正确等等。</p>\n</li>\n</ul>\n<h2 id="2d-">2D游戏的类型</h2>\n<p><strong>1. 横版游戏</strong></p>\n<p>经典游戏《超级玛丽》就是一款横版过关游戏。横版游戏，是2D游戏可以实现的最基本的内容。横版游戏最主要的特点是它的画面，这种2D平面的画面只有左右两侧画面可以控制，玩家体验通常比较顺畅。还有前几年大火的《水管鸟》、耳熟能详的《魂斗罗》，以及Steam上的《返校》等等，都是横版2D游戏。</p>\n<p><strong>2.俯视视角游戏</strong></p>\n<p>其次就是俯视视角的游戏。比如FC上的《勇者斗恶龙》《大航海时代》等等。这类的游戏提供一个空中俯视的视角给玩家，能很清晰地看到游戏中呈现的所有地图和区域。在区域中，主角可以给玩家呈现四个、六个或者八个方向的旋转和移动。在横版游戏中，玩家只能左右或者上下进行移动，而俯视角的游戏则可以移动四个、六个或八个方向。比如，在《GTA2》中，可以朝各个方向移动，并且通过缩放实现了主角的上下跳跃的视觉呈现。</p>\n<p><strong>3.斜45度角的视角游戏（“伪3D”游戏）</strong></p>\n<p>另外，还有斜45度角的视角游戏。我们看到大量的网页游戏、Flash游戏、一些早期所谓的2.5D MMO游戏，都是这种类型的视角。这种视角下的游戏，也被俗称为“伪3D”游戏。我们可以通过八个或者六个方向进行操作。地图和建筑物都是斜45度角的，做得好的游戏可以进行缩放，所以看起来就像是3D的画面。</p>\n<p>事实上，到了2D斜45度角的后期，我们都使用3D建模，然后把它转成2D图形来进行制作。因为在2D角度下，有一个很细节的问题，那就是左右手脚的交换。也就是说，如果角色右手拿着武器，往左边走，当它在往右侧走的时候，为了节省资源和编程的方便，会对人物进行镜像绘制，这就变成了左手拿着武器了。</p>\n<p>所以，到了后期的2D MMO游戏中，我们会通过3D建模，制作大量的非镜像图片来契合左右手的限制。比如主角骑的坐骑中，左右脚被坐骑遮挡，我们可以通过3D建模将各种模型的脚和坐骑制作在一起，以解决左右脚或者装备被遮挡的问题。</p>\n<p>不管是开发2D游戏还是3D游戏，你首先需要理解什么是游戏引擎，这一点我会在第三节的时候着重介绍。以目前的技术手段，开发一款完整的游戏已经不是特别难的事情，只要你有一款强大的引擎，然后将焦点focus在你所要实现的逻辑上，只需要配置一些图片、关卡、音乐，就能很快地实现一款游戏。</p>\n<p>但是，<strong>如果你不明白游戏的总体开发逻辑和实现细节，在开发过程中出现了问题将会变得很棘手</strong>。如果你了解和明白了游戏开发的本质、网络传输的基础知识，那么对于其他游戏的开发，比如移动端，比如HTML5端，比如小游戏的开发，则会变得更容易。因为，<strong>知道了游戏开发的底层知识和开发逻辑之后，几乎所有的游戏都是以这样的结构和逻辑进行开发的</strong>。</p>\n<h2 id="-">小结</h2>\n<p>以上是我今天分享的全部内容，你只需要记住一个理念即可：</p>\n<p><span class="orange">不管何种类型、何种平台的游戏，其开发的顺序和手段几乎是一样的。而对于初学游戏开发的人来说，首先需要掌握的是开发流程，在有了一定基础之后，再学习细节的知识，就会如虎添翼。</span></p>\n<p>最后，给你留一个思考题吧。在游戏开发中，很多游戏公司都会先出一个游戏Demo，请问游戏Demo在游戏的开发流程中扮演一个怎样的角色？  </p>\n<p>欢迎留言说出你的看法，我在下一节的挑战中等你！</p>\n<p></p>\n',
        article_title: "第1讲 | 游戏开发需要了解哪些背景知识？",
      },
      {
        title: "第2讲 | 2D游戏和3D游戏有什么区别？",
        id: 8299,
        content:
          '<p>我们知道，游戏的体现形式最主要是2D和3D。最近比较流行的AR/VR等，都是属于3D类的体现形式。关于VR游戏，我会在之后的“热点剖析”模块详细介绍，这里就不多说了。  </p>\n<p>最初的游戏，2D是绝对的主流。虽然现如今3D游戏大行其道，但是2D游戏还是拥有一席之地。比如我们上一节提到的《返校》，日本光荣公司前几年仍然在推出2D版的《三国志》，以及最近暴雪又复刻的《星际争霸1》高清版。</p>\n<h2 id="2d-3d-">2D游戏和3D游戏的区别</h2>\n<p>我在前面已经讲过我为何选择2D游戏作为讲解的对象，也阐述过手机游戏开发的难点。至于3D游戏和2D游戏具体的区别，我还需要再和你讲一讲。</p>\n<ul>\n<li>呈现画面</li>\n</ul>\n<p>3D和2D游戏最大的区别就是，游戏呈现画面的方式有了质的改变。3D较之2D画面有更强大的冲击力和震撼力，就好像VR较之普通3D，对人们视觉的冲击力和震撼力也是质的飞升。</p>\n<p>所以，<strong>要做出一款好的2D游戏，要比3D游戏下更多的功夫，特别是在游戏的内涵、创意、音乐和细节上面。</strong>因为2D游戏先天只能呈现2D画面，所以玩家在入手游戏后，会很快对游戏有一个总体的评价，因此，开发者会想方设法留住用户。而一些3D游戏创意和游戏内容其实都不是非常优秀，只是由于画面突出，效果卓绝，也能吸引不少玩家战斗到最后一关。</p>\n<ul>\n<li>文件体积</li>\n</ul>\n<p>2D游戏的体积基本控制在1G以内。因为2D游戏本身的图片量并不是很大，图片体积也就不会很大。而3D游戏的体积基本都是2~4G，现在甚至会有30G、40G，甚至60、100多个G。那是因为3D模型、骨骼、动作、贴图等资源占用了大量的空间，高清贴图动辄几十甚至上百兆都是正常的体积，所以3D游戏比2D游戏体积大这是很重要的一个方面。</p>\n<h2 id="-3d-">“伪3D”游戏</h2>\n<p>我们熟知的3D游戏，有广义、狭义之分。狭义的3D游戏是指Polygon游戏，也就是多边形游戏，需要靠纯3D计算技术实现操作。而广义的3D游戏，则包括了“伪3D”游戏。所谓伪3D，其实就是2D+3D，也有人称之为2.5D。其实就是将2D和3D技术结合起来，实现3D游戏的体验。</p>\n<p>类似《暴力摩托》这样的早期3D游戏，其实就是“伪3D”，它基本上是通过<strong>模拟计算</strong>和<strong>光线跟踪</strong>（Raycasting）算法做出来的。因此，<strong>2D游戏引擎无法制作狭义的3D游戏，而3D游戏引擎则可以做2D游戏。</strong>  </p>\n<p>比如，《梦幻西游》可以称作“伪3D”，而《暴力摩托》、早期的赛车游戏、《DOOM》等，都可以归类为广义的3D游戏。</p>\n<p>我们继续拿《暴力摩托》，或者更早期的赛车游戏来举例。</p>\n<!-- [[[read_end]]] -->\n<p><img src="https://static001.geekbang.org/resource/image/87/da/87483c1fb12cbb8e7691f6d8843959da.jpg" alt=""></p>\n<p>这类游戏的内存中，存在两种甚至多种主角赛车的形态图像，比如近景摩托车、远景摩托车。在判断速度大小之后，我们可以对图像进行替换，以此让玩家感觉到远近；背景和地面则是按照线条来处理，也就是将一副背景图片分成N条线，而第N+1条线会比第N条放大一倍，以此达到给赛道设置不同远近的效果；根据玩家赛车的前后位置，来判断绘制每一行的“放大”。而玩家控制的赛车则是一个活动块。每个活动块都存放有不同远近大小的图像形态，来控制前后图像大小。</p>\n<p>国外有不少专门研究这类“伪3D”技术的网站，我在这里推荐几个，你有兴趣的话可以去看看。\n<a href="http://www.extentofthejam.com/pseudo/">http://www.extentofthejam.com/pseudo/</a>\n<a href="http://lodev.org/cgtutor/raycasting.html">http://lodev.org/cgtutor/raycasting.html</a>\n<a href="https://codeincomplete.com/posts/javascript-racer-v1-straight/">https://codeincomplete.com/posts/javascript-racer-v1-straight/</a></p>\n<p>那么，用3D游戏引擎制作2D游戏究竟是怎么回事呢？就是将3D游戏的视角和控制锁定在只有2D能呈现的范围内，让玩家误以为是2D游戏，但是这类游戏可以<strong>借助3D引擎来优化游戏的声光和绚丽的特效，让2D游戏更大放异彩。</strong> </p>\n<p>再者，在移动端的表现上，2D游戏其实和3D游戏不相上下。</p>\n<p>首先，利用小屏幕观看3D画面非常累。由于手机计算能力有限，所以目前移动端的3D游戏大部分都还是以低模为主。浅显地讲，高模就是相当精细的模型和贴图，由无数个面（看需求）组成的模型，而低模一般会为了计算效率考虑控制其3D面数，贴图也相对简单。</p>\n<p>其次，在移动设备上，因为移动平台的硬件限制，3D引擎的表现一定不如电脑或者主机游戏来得好。这样一来，2D游戏其实有非常大的施展空间。</p>\n<h2 id="2d-3d-">2D游戏和3D游戏在电子竞技中的区别</h2>\n<p>我们再来看看电子竞技这一块。</p>\n<p>我们都知道《星际争霸》在前几年一直是韩国的“国技”。《星际争霸1》的选手水平占据着全球巅峰位置。2015年之后，由于圈内丑闻加上《星际争霸2》的出现，《星际争霸1》的三大联赛几乎销声匿迹。然而《星际争霸2》却没有想象中那么火爆。虽然有《DOTA》《LOL》的泰山压顶之势，但总体原因除了《星际争霸2》的平衡性外，还有一个原因是，《星际2》的3D画面并不完全适合电视转播。</p>\n<p>我们拿《星际争霸1》的2D画面和《星际争霸2》的3D画面进行比较。这里，第一幅图是《星际1》的画面，第二幅图是《星际2》的画面。</p>\n<p><img src="https://static001.geekbang.org/resource/image/f6/74/f63c7cb07818dc0d0771139008ae4974.jpg" alt=""></p>\n<p><img src="https://static001.geekbang.org/resource/image/04/36/041b56fd0bb54443d32c083c237a7136.jpg" alt=""></p>\n<p>你可以看到，3D画面几乎要在高清画质的情况下才能看清楚单位兵种、战斗场面，而且很多时候都是一团黑漆漆、绿乎乎的3D画面堆在一起。《LOL》看似没有这种情况，是因为大家都熟悉每个英雄的形象，加上地图比较明亮，兵种没有《星际争霸》那么多。</p>\n<p>我们再来看《星际争霸1》的画面，层次分明，清晰可辨，哪怕在低画质的情况下仍然可以一眼看出究竟是什么兵种，有的时候，甚至连地雷都能看清楚。当然，<strong>这并不是说3D比不过2D，而是在某些特殊情况和场景下，3D图形会有一些缺陷。</strong></p>\n<p>由于表现方式不同，3D游戏最典型的就是比2D游戏的坐标多出一个Z值。<strong>所谓的Z值，就是除了X、Y的长宽之外，还多了一个高度值。</strong>这个值我们也可以用在2D游戏中。</p>\n<p>在PS时代，有不少2D和3D结合在一起的游戏。比如，《生化危机》系列的1、2、3部，都属于2D静态场景、3D模型。再比如，《最终幻想》系列的7、8。玩家在世界地图行动的时候，使用的是3D画面，但是在游戏主场景里面，使用的仍然是《生化危机》那种3D建模。2D渲染场景使用伪3D技术，一般是因为机能限制或者3D技术不成熟，但实际的实现难度不会比纯3D技术更简单。</p>\n<h2 id="3d-2d-">3D游戏和2D游戏在美术上的区别</h2>\n<p>从美术方面来说，3D游戏和2D游戏的区别也相当大。</p>\n<p>在3D建模和骨骼方面，一个熟练的美工，只需要在原有模型上添加或者修改某些物件。比如给某个生物加一个角，给它增加一个小小的动作。这样模型的修改，对于美工来说，是比2D美术要简单的。因为2D美术一般都是手绘，所以如果需求改动特别明显，那一系列跟该角色相关的图案都需要手工调整，这是非常大的工作量。</p>\n<p>准确地讲，2D游戏是2D图像图形进行线性的一些变换将之渲染至屏幕而成。而3D的游戏是将3D的图形图像进行3D线性变换然后投影（Projection）至显示器（显示器是2D的）而成。显示器在视觉上形成远近大小的效果，让我们看起来是立体的。事实上，我们眼睛的视网膜也是这么工作的。</p>\n<h2 id="-">游戏的本质</h2>\n<p>说了这么多2D游戏和3D游戏的区别，最后，我想跟你谈一点轻松的内容。游戏的本质究竟是什么？不管是作为开发者，还是策划、运营人员，或者是打游戏的玩家，我想请你思考一下这个问题。</p>\n<p>有人说，游戏的本质是人类的层次需求，并且还进行了细致的分析。其实不需要这么复杂，要我说，游戏的本质就是供人娱乐，给人各种开心的、刺激的、恐怖的感官刺激。</p>\n<p>有些人喜欢复杂策略类的游戏，那么繁琐复杂的《太空帝国》就能满足他们。有些人喜欢快节奏的游戏，那么赛车或者打一局就走的《FPS》可以满足你的胃口；像我就喜欢悠哉悠哉地不受任务限制，那么“GTA系列”和“老滚系列”就是我的选择。</p>\n<p>那如何定义一款成功的游戏呢？如何做出一个爆款游戏呢？我想说的是，一款游戏的成功离不开美术、音乐等等这些硬指标，然而这些指标却不能决定这款游戏是否能深得人心。每一个人心中的判断并不一样，大量的人玩《王者荣耀》，但这并不代表它是优秀的游戏，只能说是成功的游戏。毕竟，青菜萝卜各有所爱。</p>\n<h2 id="-">小结</h2>\n<p>这一节内容差不多了，总结一下，你需要记住这几点：</p>\n<ul>\n<li><p>3D和2D游戏的区别主要体现在呈现画面和文件体积上；</p>\n</li>\n<li><p>借助3D引擎可以提升2D游戏的声光和特效效果；</p>\n</li>\n<li><p>成功的游戏不一定是优秀的游戏。</p>\n</li>\n</ul>\n<p>最后，给你留个思考题吧。你觉得一款成功的游戏需要具备什么样的特点呢？</p>\n<p>欢迎留言说出你的看法，我在下一节的挑战中等你！</p>\n<p></p>\n',
        article_title: "第2讲 | 2D游戏和3D游戏有什么区别？",
      },
      {
        title: "第3讲 | 游戏的发动机：游戏引擎",
        id: 8440,
        content:
          '<p>估计长期玩游戏的玩家，都能脱口而出几款游戏引擎的名字，比如“虚幻”“寒霜”“狂怒”等等。那你能说说，游戏引擎究竟是什么吗？它在游戏开发中究竟起着什么样的作用呢？</p>\n<h2 id="-">游戏引擎是什么？</h2>\n<p>汽车没有发动机就无法跑起来，人类没有心脏就会死亡。而引擎就是发动机，就是心脏。</p>\n<p>我们先来看一下维基百科对于游戏引擎的定义：</p>\n<p><span class="reference">游戏引擎是指一些已编写好的可编辑电脑游戏系统或者一些交互式实时图像应用程序的核心组件。这些系统为游戏设计者提供各种编写游戏所需的各种工具，其目的在于让游戏设计者能容易和快速地做出游戏程序而不用由零开始。大部分都支持多种操作系统平台，如Linux、Mac OS X、Windows。大多数游戏引擎包含以下系统：渲染引擎、物理引擎、碰撞检测系统、音效、脚本引擎、电脑动画、人工智能、网络引擎以及场景管理。</span></p>\n<p>这个概念是不是看起来还是不太好理解？我来具体解释一下，游戏引擎到底是什么，以及它究竟能干什么。</p>\n<ol>\n<li><p><strong>游戏引擎就是图形引擎。</strong>准确地说，游戏引擎约等于图形引擎。玩家口中所说的“虚幻”“寒霜”等，这每一款引擎对于图形渲染的处理方式都不同，所以用某个引擎编写出来的游戏，具体的表现画面也会不同。比如，有的引擎编写出的光影效果特别绚丽，有的则粒子效果特别真实。</p>\n</li>\n<li><p><strong>游戏引擎是一整套游戏解决方案。</strong>其实，游戏引擎并不仅仅等同于图形引擎。图形引擎只是游戏引擎中一个占比极大的组成部分。一款好的游戏引擎，不仅要看它对于图形图像的处理能力，也要看它对于其他部分的处理能力，比如对音频、音效的播放、键盘鼠标的处理，以及UI界面的编辑和各种处理工具的提供。这里的处理工具包括地图编辑器、关卡编辑器、人物编辑器、资源编辑器、物理碰撞、碰撞检测等。所以，从专业的角度讲，游戏引擎是完成开发一套游戏的解决方案，而不仅涉及图形部分。</p>\n</li>\n<li><p><strong>游戏引擎是一整套编程接口。</strong>要写游戏就必须写程序，所以有游戏引擎就一定需要编程。不管你是直接面对引擎编写代码，还是在引擎提供的编辑器（比如关卡编辑器）基础上编写简单的逻辑代码，写代码都是必不可少的。在引擎提供的编程接口上，你能很容易地调用各种接口完成游戏的开发。</p>\n</li>\n</ol>\n<h2 id="-">游戏引擎是怎么工作的？</h2>\n<p>说完了游戏引擎是什么，我们来看游戏引擎具体是怎么工作的。 </p>\n<p>我先从代码层面来说。这里是一段伪代码：</p>\n<!-- [[[read_end]]] -->\n<pre><code>int DrawLine(const Surface&amp; s, int sx, int sy, int fx, int fy, int fit, const Color&amp; color);\n</code></pre><p>这段伪代码提供了一个在屏幕上画一个线条的函数。该函数提供了7个传入参数，分别是：</p>\n<ul>\n<li>目标图层</li>\n<li>线（在游戏窗口内）的起始x点</li>\n<li>线（在游戏窗口内）的起始y点</li>\n<li>线（在游戏窗口内）的终止x点</li>\n<li>线（在游戏窗口内）的终止y点</li>\n<li>线条粗细</li>\n<li>线条颜色</li>\n</ul>\n<p>在调用了这个函数之后，你就能很容易在屏幕上画出一个线条。同时，在这个函数背后，引擎做了一系列这样的动作：</p>\n<ul>\n<li>判断传入的Surface图层对象是否正确、是否存在；</li>\n<li>判断传入的起始点、终止点是不是存在负数；</li>\n<li>判断颜色是不是正确；</li>\n<li>拆分Color变量为RGB值，填入到SDL绘图接口，调用SDL绘图接口绘制一条线。</li>\n</ul>\n<p>关于绘图接口，我会在下一节的内容中详细讲解。这里，你只需要知道，画线的接口函数在背后分解、组合、计算，然后会将绘制工作交给底层绘图接口就可以了。</p>\n<p>之所以要拿这个画线函数举例，是因为它展示了引擎中函数的使用方式。如果我们用一般的画线函数画圆，那首先要知道圆的直径和计算方式；如果画矩形，那就要知道哪里是起始点和终结点。这一系列动作等于将引擎所做的工作包含在了画线函数里，你只需要关心画线的这一系列参数如何使用就可以了。</p>\n<p>说完了代码层面，我们来说说非代码层面的东西。</p>\n<p><strong>游戏引擎其实也包括游戏开发的一系列工具，也就是诸如地图编辑器、关卡编辑器、人物编辑器、资源编辑器等。</strong>美术、策划、制作人等，这些开发流程中的责任人，可以往工具内填入需要的东西，制作出需要的内容。</p>\n<p>我们拿人物编辑器来举例。如果我们使用通用编辑工具（比如3DMAX、Maya等）编辑出来内容，需要经过格式的转换才能应用到游戏中，但是这样不仅耗费转换时间，也耗费调试时间。因为通用工具可能并不适合引擎本身所定义的格式，需要不停修正和更改。如果引擎本身就提供了这样的制作工具，那么制作出的内容直接就能在游戏中使用，不需要转换，所见即所得。</p>\n<p>所以，游戏引擎背后的工作方式是：</p>\n<ul>\n<li><span class="orange">在代码层面，游戏引擎是对绘图接口、操作系统、音频等接口进行的代码层面的封装；</span></li>\n<li><span class="orange">在工具层面，游戏引擎是一整套游戏内容的制作工具，方便你制作针对这个引擎的游戏内容。</span></li>\n</ul>\n<h2 id="-">自己开发引擎还是直接购买？</h2>\n<p>了解了游戏引擎的概念和工作方式，那么开发者究竟是自己编写引擎还是购买商业引擎比较好呢？</p>\n<p>从一般意义上讲，如果有实力，当然是自己开发引擎更贴合公司的情况。然而，这样付出的代价就是，花费大量的人力和财力，而且，以一般小公司或者起步阶段的开发者的开发水平，编写出的引擎，很可能只是一个半成品或者问题多多的残次品。<strong>自研引擎并不是一个不可能完成的任务，但是要看公司的财力和程序员的实力。</strong></p>\n<p>购买商业引擎是现在大部分公司都会走的一条路。购买商业引擎只需要花费一笔钱就能拿到成熟的游戏引擎，直接可以开发游戏，然而付出的代价就是，你可能需要从头开始学习这套引擎的工作原理、工具套装。</p>\n<p>如果你非常熟悉3DMAX等通用工具，那要从头学习开发工具，就会产生许多问题，比如：</p>\n<ol>\n<li>引擎中包含的开发工具基本没有通用性可言。就算吃透了工具，对你今后的能力提升和职业规划也没有明显的帮助；</li>\n<li>如果引擎升级或者更换引擎，就需要从头再学一次工具，会耗费大量时间和精力。当然会有一些优秀的商业引擎支持通用工具制作的内容导出和转换，直接在引擎中可以使用，当然这种引擎的购买费用也会更高；</li>\n<li>另外，商业引擎本身也会存在一些隐藏得很深的bug。在游戏发布后，这些bug可能会影响到游戏本身的质量和口碑。引擎出问题，游戏一定出问题，这也是购买商业引擎需要考量的一个风险。</li>\n</ol>\n<p>但是，在实际的开发过程中，考虑到公司的经济实力和程序员的开发能力，一般来说，大多数开发者都会选择购买商业引擎，毕竟这在一定程度上，是个非常省时省力的事情。</p>\n<h2 id="-">游戏引擎是用什么编写的？</h2>\n<p>尽管如此，你还是需要掌握更多游戏引擎相关的知识。因为，不管你是购买游戏引擎还是自己开发游戏引擎，了解游戏引擎，会让你对游戏编程的总体脉络有一个了解。一旦在开发过程中出现问题，比如你发现屏幕贴图出问题了，那究竟是自己的代码出现问题，还是引擎本身出现问题呢？熟知游戏引擎的开发逻辑，你就能很快定位问题所在。</p>\n<p>事实上，<strong>游戏引擎并没有一种固定的开发语言，就看你所制作游戏的目标平台是什么。</strong></p>\n<h3 id="1-c-c-">1.C/C++</h3>\n<p>如果你在Windows或者Linux下开发游戏，游戏引擎99%都是使用C/C++或者汇编语言编写。由于C/C++和汇编运行效率高，所以在Windows下的执行效率也非常高。你看到的Python游戏引擎、Ruby游戏引擎等脚本语言引擎，都是在C/C++的基础上进行封装的。这样可以方便程序员将专注力放在游戏逻辑上，而不是在处理底层问题上。</p>\n<h3 id="2-javascript-typescript-">2.<strong>JavaScript/TypeScript</strong></h3>\n<p>如果是HTML5游戏，游戏引擎的编程接口99%是使用JavaScript完成的。比如耳熟能详的Cocos2d引擎、白鹭引擎等等。至于其他配套的开发工具，可以使用任意软件开发语言进行编写。</p>\n<h3 id="3-net">3..NET</h3>\n<p>经过微软的努力和版本迭代，在Windows下，.NET的运行效率和开发效率已经提高了好几个等级。由于和Windows紧密结合，现在的.NET的运行效率只比C/C++编写的代码低一点。在电脑配置比较高的情况下，用户基本不会有太多的感知。而.NET对于Windows底层的调用和控制，比C/C++更方便，编程也更容易，所以现在已经出现了一些引擎是使用.NET编写的。这对于.NET开发者来说是一件好事。</p>\n<h3 id="4-java">4.Java</h3>\n<p>和.NET一样，使用Java编写的游戏引擎并不多。虽然Java的运行效率已经有了质的提升，但是对于编写大型游戏来说还是有相当大的瓶颈。随着电脑硬件配置的提升，使用Java编写游戏也不再是一件不可能的事情。比如大火的《我的世界》，就是使用Java编写的。</p>\n<h2 id="-">小结</h2>\n<p>好了，这一节内容差不多了，总结一下，我主要给你分享了四个内容，分别是游戏引擎的定义、游戏引擎的工作方式、游戏引擎的选择和编写。</p>\n<p>你只需要记住以下这些内容即可：</p>\n<ul>\n<li>游戏引擎是一整套的游戏开发程序接口和开发组件，可以让你更方便、更专注于游戏的开发；</li>\n<li>游戏引擎控制着游戏的几乎所有内容，游戏的表现质量和游戏引擎直接相关；</li>\n<li>针对不同的平台，游戏引擎所使用的编程语言也不一样。而了解了游戏引擎的编写，在之后的开发过程中，会有非常多的便利。</li>\n</ul>\n<p>最后，给你留一个思考题：</p>\n<p>什么情况下，我们可以跳过游戏引擎，直接编写一款游戏呢？</p>\n<p>欢迎留言说出你的看法，我在下一节的挑战中等你！</p>\n<p></p>\n',
        article_title: "第3讲 | 游戏的发动机：游戏引擎",
      },
      {
        title: "第4讲 | 底层绘图接口的妙用",
        id: 8527,
        content:
          '<p>上一节，我给你介绍了游戏引擎的概念及其在游戏开发中所起的作用。同时，我也提到了游戏引擎背后的工作方式。在代码层面，游戏引擎是一套对底层绘图、音频、操作系统接口的封装实现。</p>\n<p>在此基础上，我还举了一个在游戏屏幕上画线条的例子。在这个例子中，<strong><span class="orange">画线的接口函数在背后分解、组合、计算，并将绘制工作交给底层绘图接口。</span></strong>这个绘图接口，就是今天要讲的内容。</p>\n<h2 id="-">几种常见的绘图接口</h2>\n<p>前面我已经说过，我会针对2D游戏来讲解游戏开发的流程和细节，所以，这里我先介绍几种2D<strong>绘图接口</strong>（即<strong>API，</strong>全称<strong>Application Programming Interface</strong>）。我选择了5种Windows下最流行的绘图接口，分别讲解。</p>\n<h3 id="1-opengl">1.OpenGL</h3>\n<p>OpenGL是老牌的图形图像接口。GL是Graphics Library的缩写。所以，顾名思义，OpenGL就是开放图形接口的意思。和接下来要讲的DirectX一样，OpenGL也可以创建和渲染2D、3D图形。但是，和DirectX不同的是，它可以在多种平台下运行，比如Windows、Linux、macOS和部分UNIX，而DirectX只能在Windows生态下运行。</p>\n<p>OpenGL本身只提供图形渲染接口，如果你需要别的功能，比如音频、鼠标、键盘的操作，甚至是创建一个窗体，都需要别的扩展库支持。</p>\n<h3 id="2-directx">2.DirectX</h3>\n<p>说起DirectX，这个名字已经如雷贯耳。DirectX的开发初衷，是为了让游戏开发者能像在DOS平台编写游戏一样，在当时新的Windows 95平台上，也能一样高效、快速地操纵各种硬件设备。</p>\n<p>其实，在DirectX发布之前，微软已经将OpenGL包含在Windows系统里面。随着时间的推移，OpenGL逐渐成为了行业标准，而DirectX自然免不了与其展开竞争。</p>\n<p>这里，我主要介绍一下DirectX中的两个核心组件。这两个核心组件的功能与2D游戏编程息息相关，你一定得了解一下。</p>\n<!-- [[[read_end]]] -->\n<p>第一个是<strong>DirectDraw</strong>。它是早期DirectX中掌管2D部分的组件。DirectDraw类似我之后要说的GDI，支持显存位图，而不是只能将位图存放在内存里，所以DirectDraw更贴近硬件。但是在DirectX 7版本之后，DirectDraw被合并到Direct Graphics组件中。虽然目前仍有很多人在使用DirectDraw的老版本开发包，然而DirectDraw已经被微软逐渐淘汰。</p>\n<p>第二个是<strong>Direct2D</strong>。它是微软推出的最新2D组件，它的出现是为了取代Windows下的GDI、GDI+和DirectDraw。Direct2D能通过硬件加速来绘制2D图形，也支持高质量2D图形渲染，比如支持ClearType呈现的方式、除锯齿、几何位图的绘制和填充等等。</p>\n<h3 id="3-sdl">3.SDL</h3>\n<p>SDL全称<strong>Simple DirectMedia Layer</strong>，直译就是<strong>简单的直接媒体层</strong>。从严格意义上来讲，SDL并不算是“独立的”图形渲染接口，因为它将各类操作系统的图形图像渲染接口进行了封装，包装成统一的函数，以此来方便调用。比如，在Windows下，它封装了DirectX和GDI+；在Linux下，它封装了Xlib等等。同时，它也提供了OpenGL的调用函数。</p>\n<p>SDL不仅仅可以对现有图形图像接口进行封装，它也提供SDL官方自己发布的编程接口。比如，SDL_image、图像接口、SDL_net、网络接口等等。后续我将介绍到的Pygame，其背后就是调用SDL编写的。</p>\n<p>Pygame是使用Python封装的游戏库，你可以很方便地利用Pygame进行2D游戏的编写，它的背后，调用的就是SDL的接口。所以我们将利用Pygame来对2D游戏开发流程做一个完整的梳理。虽然网上关于Pygame的代码和教材很多，但是我们要讲的，<strong><span class="orange">不仅仅是Pygame代码是如何编写的，而是要从Pygame的代码中，分析2D游戏的编写逻辑和编程思想</span></strong>。在这个过程中，Pygame只是一个载体。</p>\n<h3 id="4-gdi">4.GDI</h3>\n<p>GDI，全称<strong>Graphics Device Interface</strong>，也是Windows下的图形设备接口。它所做的就是处理Windows程序的图形输出，负责在Windows系统和绘图程序之间进行信息的交换。使用GDI的人已经越来越少，从编程的方便性和硬件加速等功能来看，GDI被GDI+取代是显而易见的。</p>\n<h3 id="5-gdi-">5.GDI+</h3>\n<p>在Windows下，大部分接触过图形编程的程序员都会用过GDI+。而GDI+其实就是GDI的进阶版本。</p>\n<p>GDI+是有<strong>硬件加速功能</strong>的，而GDI没有；GDI是以C语言接口的形式提供的，而GDI+则是C++和托管类的形式提供；从接口代码的层次上说，GDI+对程序员更友好，使用起来也更顺手。</p>\n<p>GDI+还提供了<strong>图像处理</strong>的接口，比如提供了Image、Bitmap等类，可以用于读取、保存、显示，操作各种类型的图像，比如BMP、JPG、GIF等。</p>\n<p>GDI和GDI+的<strong>绘图操作</strong>也存在差别。GDI中存在一个称为“当前坐标”（MoveTo）的位置。“当前坐标”的存在是为了提高绘画的效率。</p>\n<p>我还拿画线的过程来举例。有一条新的线连着一条老的线画，如果有了“当前坐标”的设置，逻辑上可以避免每次画线都要给出两个点的坐标（开始和结束）；如果每次都以该“当前坐标”做为起始点，线条绘制结束后，线的结束位置就成为“当前坐标”。</p>\n<p>事实上，这种方式的存在是有历史原因的。有一种说法来自很早的Logo语言。这种语言针对儿童进行寓教于乐的编程教育。它的绘画逻辑是，如果有“当前坐标”这个概念，只需要一个递归就可以不停地画线，最终组成一个图形。所以后期很多的绘画接口都沿用这种方式去做。但实际到了2000年左右，人们发现这种方式并不方便，因此GDI+取消了这个“当前坐标”。</p>\n<p>一个原因是不方便；另一个原因是，如果无法确定“当前坐标”，绘图就会出现差错。而用GDI+绘制线条，则可以直接在DrawLine函数中指定起始点和结束点的坐标位置。</p>\n<h2 id="-">如何直接使用绘图接口进行游戏开发？</h2>\n<p>通过上面的介绍，你是否对Windows下几大流行的绘图接口有了大致的了解呢？接下来你或许会问，那我了解这些图形接口的编程接口后，是不是就可以直接用这些接口进行游戏的开发呢？</p>\n<p>答案当然是可以的。由于SDL的开发便利性和通用性，所以我拿SDL编程接口作为例子，来阐述一下究竟怎样通过图形接口直接进行游戏的开发。</p>\n<p>从最基础的开始，我们先要从SDL的网站下载SDL的最新版本，下载网址是： <a href="http://www.libsdl.org/download-2.0.php">http://www.libsdl.org/download-2.0.php</a> （写作这篇文章的时候，最新的版本是2.0.8稳定版）。</p>\n<p><img style="margin: 0 auto" src="https://static001.geekbang.org/resource/image/1e/7c/1e5e2f488c67643776858f564214787c.jpg"></p>\n<p>在下载的网站页面，我们可以看到Source Code一栏，这是SDL的源代码。有一定编程基础的同学可以下载源代码，直接使用VC++、MinGW等编译器进行编译，编译完的头文件和库文件直接就可以使用。</p>\n<p>如果你对编译不熟悉，可以选择下载Development Libraries，也就是编译完成后的开发包。网站已经将Windows下的开发环境分为VC++32位版和64位版、MinGW32位版和64位版。为了教学方面和统一，也照顾各种平台的用户，我建议使用MinGW的32位版。因为64位Windows可以兼容32位的应用。至于MinGW编译器和IDE的下载安装细节，我将会在后续的专栏文章中介绍。</p>\n<p>下载完成后，将压缩包解压缩到任意目录，头文件和库文件使用解压缩出来的“i686-w64-mingw32”这个目录下的“include”和“lib”。</p>\n<p>接下来，我们在IDE中设置include路径和lib路径，链接程序的时候需要在IDE设置包含库文件libsdl.a、libsdlmain.a，就可以开始在IDE中编写代码了。</p>\n<p>在开始开发的时候，首先使用SDL_Init来进行初始化。用这个方法传入一个unsigned int类型的参数，参数列表就像这样：</p>\n<p><img style="margin: 0 auto" src="https://static001.geekbang.org/resource/image/7b/6d/7b0370e14ed1121d8c37c546888c9e6d.jpg"></p>\n<p>其中“初始化所有系统”这个选项，除了“忽略任意错误”外，包含了以上所有不同的初始化系统，一般使用SDL_INIT_EVERYTHING即可。</p>\n<p>随后，我们要使用SDL_CreateWindows来创建一个窗体。SDL_CreateWindows支持六个参数，分别是：窗体名称、在Windows屏幕显示的x坐标、在Windows屏幕显示的y坐标、宽、长、显示方式。</p>\n<p>然后将使用SDL_CreateRenderer创建一个SDL的渲染器（SDL_Renderer）。渲染器的参数是：</p>\n<p><img style="margin: 0 auto" src="https://static001.geekbang.org/resource/image/bb/6e/bbc37419239a0c9d32d5676acbc6b96e.jpg"></p>\n<p>随后可以使用SDL_RenderClear来清空SDL渲染器、使用SDL_RenderPresent方法将渲染的结果显示出来。然后我们需要建立一个大循环，在这个循环内，你可以把SDL支持的图形图像函数或者其他逻辑代码往里面填写，完成游戏的程序内容，具体的操作我会在之后的文章详细介绍。</p>\n<p>在这个大循环内，我们要用到SDL_Event事件系统。在循环内捕捉用户事件，比如要退出这个循环就必须点击右上角的X关闭按钮才行。如果你点击了X按钮，就会被while内的event事件捕捉到，并且匹配是不是退出事件，如果是退出事件就退出程序。</p>\n<p>最终退出程序的时候，使用SDL_Quit清除资源退出程序。</p>\n<p><img style="margin: 0 auto" src="https://static001.geekbang.org/resource/image/fd/b6/fd59a32a4b01a53581cee54a16f2f9b6.jpg"></p>\n<p>我们结合这张流程图来看一下将这些内容串联起来的代码：</p>\n<pre><code>#include  &lt;SDL.h&gt;\nint main(int argc,char *args[])\n{\n    SDL_Window* window;\n    SDL_Renderer* render;\n    SDL_Event e;\n    bool q = 0;\n    int sdl=SDL_Init(SDL_INIT_EVERYTHING);\n</code></pre><p>初始化完成后，我们要建立窗体，并编写后续的步骤：</p>\n<pre><code>if(0 &lt;= sdl ){\n        // 当SDL初始化完成后创建一个标题为&quot;SDL Window&quot;的窗口,窗口对齐方式为居中对齐，分辨率为640x480的窗口\n        g_pWindow=SDL_CreateWindow(&quot;SDL Window&quot;,\n            SDL_WINDOWPOS_CENTERED,SDL_WINDOWPOS_CENTERED,\n            640,480,SDL_WINDOW_SHOWN);\n        if(0 != window)\n            render=SDL_CreateRenderer(window,-1,0);  \n    }\n    SDL_SetRenderDrawColor(render,0,255,255,255);\n    SDL_RenderClear(render);\n    SDL_RenderPresent(render);\n</code></pre><p>接下来是游戏主循环的内容：</p>\n<pre><code>while( 0 == q )\n    {\n       while( 0 != SDL_PollEvent( &amp;e ) )\n                {\n                    //检测到用户需要退出\n                    if( e.type == SDL_QUIT )\n                        q = true;\n                }\n    }\n    SDL_Quit();\n    return 0;\n}\n</code></pre><p>这个简单的例子说明了如何直接利用SDL接口编写游戏。直接利用其他图形接口编写游戏，也基本是这样的步骤。</p>\n<h2 id="-">小结</h2>\n<p>我来给今天的内容做一个总结，你只需要记住这些内容即可：</p>\n<ul>\n<li>绘图接口绘图接口其实就是使用C/C++语言或汇编语言，通过操作系统的底层，调用诸如显卡、内存这些绘图设备，最后做成接口；</li>\n<li>SDL拥有统一封装的绘图接口，你可以在各个平台无缝编译和使用。</li>\n</ul>\n<p>现在，你是不是对游戏开发的一部分流程有点了然于胸了呢？</p>\n<p>给你留个小思考题吧。</p>\n<p>我们提到了直接利用绘图接口编写游戏，请问，如果这样，还需要“游戏引擎”吗？如果需要的话，这个“引擎”应该放在哪里呢？</p>\n<p>欢迎留言说出你的看法，我在下一节的挑战中等你！</p>\n<p></p>\n',
        article_title: "第4讲 | 底层绘图接口的妙用",
      },
      {
        title: "第5讲 | 构建游戏场景的武器：地图编辑器",
        id: 8670,
        content:
          '<p>今天，我想和你聊一聊基础知识模块的最后一部分，地图编辑器。为了给之后的内容铺垫，我还会顺带介绍一些游戏Demo的知识。</p>\n<p>我们先来看一幅图。这看起来是一款FPS射击游戏对不对？也对也不对。说对，因为这确实是一款FPS游戏；说不对，这其实只是一幅地图，但是这幅地图来自《魔兽争霸3》。更准确地说，这是使用《魔兽争霸3》的地图编辑器制作出来的一幅游戏地图。</p>\n<p><img style="margin: 0 auto" src="https://static001.geekbang.org/resource/image/21/28/2180e87327f796c9d69b2b2222399d28.jpeg"></p>\n<p>《魔兽争霸3》发布之初，没人能想到并且能做出这样“变态”且“不走寻常路”的地图。《魔兽争霸3》的地图编辑器之强大，直到它发布五、六年后，才有人开始制作出这样令人匪夷所思的地图。</p>\n<p><strong>地图编辑器在游戏开发的前期扮演着非常重要的角色，它的主要功能就是用来制作游戏地图。</strong> 因为我们现在是一个人来开发一款游戏，不涉及分工的问题。而常规的团队在进行游戏开发的过程中，用地图编辑器制作地图是由美术来负责的。</p>\n<p>地图编辑器本身一般会由专业的地图编辑器程序员来开发完成。地图编辑器可以使用原生引擎所支持的语言来编写，比如C/C++；也可以使用引擎加嵌入脚本语言的方式来进行编写，比如Lua等。但是现在，一些成熟的游戏引擎都会自带地图编辑器。所以，大多数时候地图编辑器不需要你自己开发。</p>\n<h2 id="-">地图编辑器有哪些种类？</h2>\n<p>地图编辑器并非千篇一律。由于游戏类型的不同，地图编辑器也不相同。比如我们做一个《大富翁》类的游戏，我们就需要做一个<strong>斜45度角的地图编辑器</strong>。</p>\n<p>如果是<strong>俯视角度的游戏</strong>，地图编辑器的视角呈现方式也类似斜45度角的游戏。这两种编辑器制作地图的方式极其类似，唯一不同的是，<strong>斜45度角是用菱形的地图块拼接而成，俯视视角是用矩形的地图块拼接而成的。</strong></p>\n<p><img style="margin: 0 auto" src="https://static001.geekbang.org/resource/image/e8/d1/e86acc386c52fd571b6e879630489bd1.jpg"></p>\n<p>我们做一个<strong>横版卷轴游戏</strong>，就需要在地图编辑器内摆放横版的地图。如果地图是重复地图，类似《管道鸟》，那就需要程序员重复贴图，而不需要在地图编辑器重复编辑相同的地图。</p>\n<p><img style="margin: 0 auto" src="https://static001.geekbang.org/resource/image/67/cc/679b41409741dfae9f7e28a18cd0aacc.jpg">  </p>\n<p>3D游戏就会有3D地图编辑器，就像前面的《魔兽争霸》编辑器，就是一个3D视角。地图编辑器的种类不同，保存的地图类型和文件结构也不一样。有些地图编辑器保存的是图片和位置，而有一些保存的却是一个脚本文件，方便直接载入游戏程序。</p>\n<h2 id="-">为什么要了解地图编辑器的编写过程？</h2>\n<p>我刚才说过，大多数时候地图编辑器不需要你自己开发。但是我们依然要了解地图编辑器是如何编写出来的，至于了解这些究竟有什么用呢？我继续来给你讲。</p>\n<!-- [[[read_end]]] -->\n<p>1.<strong>编写地图编辑器的过程，能让你更好地了解游戏引擎。</strong> 从编写地图编辑器开始，就是对游戏引擎的一次全面应用。为什么这么说呢，因为在编写地图编辑器的过程中，除了音乐模块或许暂时不会被用到外，利用引擎编写的地图编辑器、地图资源的载入代码、保存代码等等，都会被用在正式的游戏中。</p>\n<p>2.<strong>编写地图编辑器的过程，可以优化游戏开发流程。</strong> 程序员之间会讨论关于资源载入、游戏内容加载和读取这些基础问题，并将最基础的流程完整地梳理一遍。在游戏正式开始开发之前，把这些流程梳理一遍，能极大提升开发过程中的流畅性。</p>\n<p>3.<strong>编写地图编辑器的过程，涉及UI、按钮和键盘事件的使用。</strong>地图编辑器开发完毕后，主要是给美术人员使用，所以UI的点击、鼠标键盘事件是必不可少的。在地图编辑器中运用UI、按钮、键盘事件后，在正式游戏开发中，这些代码可以直接移植到游戏代码中使用。</p>\n<p>4.<strong>编写地图编辑器的过程，能起到团队磨合的作用。</strong> 在编写的过程中，你会接触到策划、美术等很多人的意见，程序员之间也会对引擎的应用有很多的讨论。</p>\n<h2 id="-">地图编辑器与关卡编辑器</h2>\n<p>说到地图编辑器，不得不提到关卡编辑器。<strong>关卡编辑器是一种主要给策划使用的编辑器，它涉及地图中的关卡内容。</strong> 一般情况下，关卡编辑器不涉及具体的地图细节，但是它涉及总体的游戏地图和游戏流程。</p>\n<p>简单来说，地图编辑器的功能就相当于房屋的结构朝向图。我们可以从这张图里，看到每个房间的俯视图。里面包括门的位置、阳台的位置，甚至厕所的位置。而装修公司设计家居，就相当于关卡编辑器的功能。设计师会在你已有房间的结构内，摆放各种桌子、椅子、床、柜子、灯泡等具体的家居用品。</p>\n<p>在实际开发过程中，很多时候，只有一些成体系的大游戏才会把关卡编辑器单独分出来。很多时候，对一些小游戏来说，关卡编辑器和地图编辑器经常是在一起的，你可以在地图编辑器里面直接来编写关卡。这张 《坦克大战》的地图编辑器中就包含了关卡编辑器的内容。</p>\n<p><img style="margin: 0 auto" src="https://static001.geekbang.org/resource/image/07/31/0751315e5a271167ebfc8f7253073831.jpg">  </p>\n<p>这里有一个3D游戏的关卡编辑器的界面。我们常见的关卡编辑器的界面一般都是这样的。这个界面最左侧的对话框，是物件的选择界面，具体包括关卡内物件的选择和摆放；界面右侧的对话框是属性选择界面，定义这个物件的属性，比如这个物件是否可以弹跳、爆炸等等；界面右下角是物件X、Y、Z轴的编辑，可以自定义物件的拉伸和缩放。</p>\n<p><img style="margin: 0 auto" src="https://static001.geekbang.org/resource/image/4f/95/4f55227b8c3e5abd0fc67d3224413895.jpg"></p>\n<p>我们拿FPS枪战游戏来举例。我们可以先在编辑器内画完所有俯视角的<strong>地图通路</strong>，然后在这个地方<strong>放上某种武器</strong>，在那个地方<strong>放上某种升级包</strong>。这就是一个关卡的总体架构。</p>\n<p>随后，你需要在编辑器里编写一些简单的脚本程序。这些脚本程序会涉及玩家在进入游戏后总体的游戏进程和逻辑。比如，你可能会写“分数达到多少之后，等级+1”“击杀敌人达到多少之后，分数+10”“失血达到多少出现什么情况”等等。</p>\n<p>总之，关卡编辑器和地图编辑器的功能，就好比家装设计图和房屋结构朝向图，一个是在地图内设置物件的摆放位置和具体的表现形式；一个是设计地图本身。</p>\n<h2 id="-demo-">为什么要做游戏Demo？</h2>\n<p>按照传统的标准游戏开发流程，在编写完地图编辑器之后，就要开发游戏了。事实上，开发游戏的初期，我们必须要制作这款游戏的Demo。很多商业游戏制作之前都是要先做游戏Demo的。你或许会问，为什么不立刻开发一个正式的游戏呢？我总结了一下，有以下几方面的原因：</p>\n<p>1.<strong>游戏Demo可以完成游戏核心框架。</strong> 绝大部分情况下，最终完成的游戏成品，都会和游戏Demo有较大的差异。这些差异体现在美术画面的优化细节、操作的优化细节、网络优化上等等。<strong><span class="orange">游戏Demo所肩负的任务，就是完成该游戏总体的核心内容框架。</span></strong> 在这个框架内，我们可以一窥游戏的总体逻辑、想呈现给玩家的是什么内容。</p>\n<p>比如，《三国志》题材的游戏，游戏Demo就会呈现在大地图上进行城市内政的管理、军队的管理，以及战斗画面这些游戏的核心内容；比如FPS射击游戏，游戏Demo呈现出的就是，主角在一个有限的空间内进行射击和击杀敌人的操作，因为这些就是游戏的核心。至于游戏是不是好玩，画面是不是炫酷，音乐是不是好听，并不在游戏Demo中呈现。</p>\n<p>2.<strong>游戏Demo可以测试bug。</strong> 在游戏开发中，地图编辑器做完之后，会载入经地图编辑器制作的地图，这些地图在游戏中是否有bug，是否需要调整，游戏体验好不好。这些内容在游戏Demo中将被测试出来，并且在正式开发中进行调整。</p>\n<p>3.<strong>游戏Demo可以磨合开发团队。</strong> 前面我们提到，有一些引擎自带地图编辑器，所以大多数情况下，地图编辑器不需要你自己编写。这个时候，你敲下的第一行代码就是游戏Demo的代码，所以游戏Demo就肩负另一个使命，就是团队人员的磨合。和地图编辑器一样，第一次编写游戏Demo，会有来自策划、美术、程序等各方面的意见和讨论，而制作游戏Demo的过程对磨合团队是非常有利的。</p>\n<p>4.<strong>游戏Demo最终会被舍弃。</strong> 在开发过程中，Demo版本是不稳定的，是有bug的。只要不是特别严重的，一般不会去进行特别的修正。但是一般来说，bug会在正式版本中被修正。所以，游戏Demo肩负的另一个任务，就是“试水”。程序代码在游戏中跑起来是不是有瓶颈，bug出现在哪里，哪些部分可以从Demo中提取出来，在正式开发中使用，哪些部分可以在正式版本中优化，这些都是游戏Demo所背负的“使命”。</p>\n<p>很多开发团队为了节省时间，很多公司老板为了节省成本，在地图编辑器完成之后，就跳过了游戏Demo开发这个步骤，或者有些开发leader根本就不知道要做Demo这个流程，所以一开始就去做正式版。这是个很危险的动作。</p>\n<p>因为按照流程，<strong>如果一上来就开始编写正式版本的游戏，很有可能会出现无法预估的bug和无法修正的问题。</strong> 比如，地图编辑器中保存的地图，在正式游戏中就出现极大的错误，连修正的时间都没有，最终修修补补急急忙忙地上线，玩家一片怨声载道。游戏死亡。</p>\n<p>当然，由于游戏类型不同，地图编辑器、关卡编辑器和游戏Demo，并非是必须要做的内容，就像我们要做的“打飞机”这样简单的游戏，甚至贪吃蛇、俄罗斯方块、象棋、围棋等等，这些都不需要任何编辑器，这些单一简单的游戏，开发流程简单，如果出现问题直接重新编写就可以了。</p>\n<h2 id="-">小结</h2>\n<p>这一节，我讲了地图编辑器、关卡编辑器和游戏Demo相关的内容，你只需要记住这些重点：</p>\n<ul>\n<li><p>开发地图编辑器的过程可以帮助开发人员了解引擎、优化开发流程、测试bug、磨合团队；</p>\n</li>\n<li><p>关卡编辑器之于地图编辑器，就好比装修设计图和房屋朝向图之间的关系；</p>\n</li>\n<li><p>游戏Demo的使命是完成游戏核心框架，测试地图编辑器等问题，Demo最终会被舍弃；</p>\n</li>\n<li><p>在游戏开发的正规流程中，我们要经历地图编辑器、关卡编辑器、游戏Demo、正式开发等几个流程，每一个流程都肩负不一样的任务。但简单如贪吃蛇类的游戏，我们可以直接上手编写代码。</p>\n</li>\n</ul>\n<p>最后，给你留一道小思考题吧。</p>\n<p>用地图编辑器制作出来的地图有没有取巧的保存方法，让游戏程序读取地图时更方便？</p>\n<p>欢迎留言说出你的看法，我在下一节的挑战中等你！</p>\n<p></p>\n',
        article_title: "第5讲 | 构建游戏场景的武器：地图编辑器",
      },
    ],
  },
  {
    chapterTitle: "第二章：客户端开发",
    children: [
      {
        title: "第6讲 | 从0开始整理开发流程",
        id: 8782,
        content:
          '<p>在第一模块的基础知识中，我已经讲过开发一款游戏需要的一些背景知识。对于2D游戏和3D游戏的区别、从程序到美术、从2D、伪3D到3D等方面，我都进行了逐一地阐述。除此之外，对于任何类型的游戏开发都非常重要的三个概念：游戏引擎、底层绘图接口、地图编辑器，我也进行了一些我个人的解读。</p>\n<p>有了这些背景知识，这一节，我来带你整理一下整个游戏开发流程以及流程中所需要的工具。</p>\n<h2 id="1-">1.选择开发环境</h2>\n<p>我们默认是在Windows环境下进行开发，至于是什么版本的Windows不需要做更多地阐述，你愿意用什么版本就用什么版本，因为几乎所有流行的Windows环境都能进行编程工作。至于我为什么选择Windows环境进行开发，那是因为：</p>\n<ul>\n<li><p>首先，在Windows环境下，拥有比较方便的<strong>调试工具</strong>。不管是Python脚本语言还是C/C++语言，都可以使用图形界面进行调试；</p>\n</li>\n<li><p>其次，Windows下的<strong>IDE开发环境</strong>也比其他平台更多，你拥有更多的工具可供选择。另外，在开发游戏的时候，你可以选择OpenGL、DirectX或者SDL等图形库进行编程。作为游戏开发，DirectX几乎是不可或缺的标准，而我在第四节讲述底层绘图接口的时候说过，它是由微软提供的游戏编程接口，在Windows下提供了更为方便的底层调用。</p>\n</li>\n<li><p>除了Windows外，Linux平台的<strong>图形显卡驱动</strong>几乎是不完善的，无法发挥显卡的最大优势。苹果平台又一家独大，开发人员只能为其定制专一的代码，开发难度比之Windows就大了不少。</p>\n</li>\n</ul>\n<h2 id="2-">2.下载脚本工具</h2>\n<p>在开发过程中，我们需要用到Python、Lua或者Ruby等脚本工具。我们可以直接用Python或者Ruby开发简单的游戏模块的Demo。<strong>由于脚本语言代码的简单和高可读性，所以由脚本语言入手，进行早期示例的代码剖析，是一个不错的选择。</strong></p>\n<p>Python我们可以从python.org下载，Lua我们可以从lua.org下载，相应地，Ruby也可以在ruby-lang.org下载。为了考虑兼容性，Python建议使用2.7.x版本。Lua下载最新的版本即可。Windows下Python的源代码编译并不方便，所以建议下载MSI安装包，直接安装即可。因为之后我要使用Pygame进行示范，所以建议你使用32位的Python版本。</p>\n<h2 id="3-">3.选择编程语言版本</h2>\n<p>在开发的过程中，一定会用到C/C++语言。</p>\n<p>如果你要使用VC++的话，会涉及购买、安装和配置等情况。为了使这个专栏的内容尽量简洁、可用，我建议使用Windows下，移植版本的GCC和G++进行编译（也就是MinGW移植版），GCC版本为4.2.x或者以上版本。有人说这些版本太老了，我认为，<strong><span class="orange">初学阶段，版本越新，意味着你需要知道的编译器内容和编译器开关就越多，</span></strong>因此建议你选择较为稳定的4.2.x或以上版本。</p>\n<p>对于C++而言，我们也不需要用到最新的C++标准，比如C++11等。对于C语言，我们默认使用C89或者C99都是可以的。简洁、高效、显而易见，是我一向遵从的原则。</p>\n<h2 id="4-">4.下载编译器</h2>\n<p>关于C/C++，你可以去MinGW官网下载4.2.x版本。当然如果你希望使用其他更新的版本也不是不行，你可以直接下载安装器，来获取编译器的版本。下载地址是这个：<a href="https://sourceforge.net/projects/mingw/files/Installer/">https://sourceforge.net/projects/mingw/files/Installer/</a></p>\n<p>你也可以按照你的需求定制下载。如果要成为完整的编译器，必须下载这些内容：</p>\n<!-- [[[read_end]]] -->\n<ul>\n<li><p>MinGW (C/C++) Compiler</p>\n</li>\n<li><p>Binutils</p>\n</li>\n<li><p>Windows32 API</p>\n</li>\n<li><p>MinGW Runtime Libraries</p>\n</li>\n<li><p>GNU Debugger (GDB)</p>\n</li>\n<li><p>GNU Make</p>\n</li>\n</ul>\n<p>一般来讲，使用安装器下载的编译器都是最新版本的，如果你需要下载特定的版本号，你可以在这个网址  <a href="https://sourceforge.net/projects/mingw/files">https://sourceforge.net/projects/mingw/files</a> 下，找到相应的编译工具目录和对应的版本号。</p>\n<p>这样，C/C++编译器就下载完成了。如果你是自己下载特定版本号的话，需要将所有包解压缩在一个指定的目录下，解压缩出来的目录结构一般有这几个常用子目录：bin、include、lib、share、 local、etc、var。</p>\n<h2 id="5-c-c-python-ide">5.选择C/C++和Python的IDE</h2>\n<p>接下来，我们需要一套IDE来帮助我们进行C/C++和Python的开发。</p>\n<p><strong>C/C++方面，我选择使用免费的MinGW Studio来完成。</strong>MinGW Studio的界面绝大部分模仿了经典的VC6的IDE界面。虽然相对于更时髦的收费编译器来说，MinGW Studio没有特别智能的代码提示，但是可以方便我们完成程序的调试。</p>\n<p>我们可以通过搜索引擎搜索到并且顺利地下载MinGW Studio。有一些IDE是自带C/C++编译器的，这种包也没有问题。如果你对C/C++这部分设置比较熟悉，你也可以自由选择其他IDE，比如DevCpp、CodeLite、CodeBlocks等等。</p>\n<p><strong>至于Python方面，我们可以使用Wing IDE。</strong>这是一个付费项目。也可以使用国内程序员编写的Ulipad，另一个付费软件Komodo，用来做Python、Ruby的IDE都很合适。至于Wing IDE，我们可以在wingware.com下载最新版本。</p>\n<h2 id="6-">6.带你一起测试编译器的运作</h2>\n<p>首先，我们需要先测试编译器是否运作顺利，所以我选择Lua来进行编译。在将来，需要使用Lua的时候，必须将之编译为<strong>静态库</strong>或者<strong>可执行文件</strong>。</p>\n<p>我们打开MinGW Studio，界面是这样的：</p>\n<p><img style="margin: 0 auto" src="https://static001.geekbang.org/resource/image/e9/13/e9ff8b431d455f4a03cef636dd838e13.jpg"></p>\n<p>我们可以在Edit-&gt;Options-&gt;Compiler选项里设置具体的编译器路径，以便让IDE找到编译器来开始工作。</p>\n<p><img style="margin: 0 auto" src="https://static001.geekbang.org/resource/image/d8/e0/d8affea68aed61a67f25a8bd04d766e0.jpg">  </p>\n<p>一般编译器的路径都会自带bin目录，所以设置的目录必须在bin目录的上级目录。比如我们设置的MinGW编译器路径为C:\\MinGW，那么bin目录就是C:\\MinGW\\bin，所以在IDE的设置下，只需要设置为C:\\MinGW就可以了。</p>\n<p>我们将下载到的Lua5.x.x.tar.gz解压缩到某个目录。在我写文章的时候，Lua的最新版本是5.3.4。在这个目录下，并没有我们所需要的MinGW Studio的项目文件，所以我们需要手工建立一个。我们在File-&gt;New-&gt;Projects选项下，建立一个Win32 Static Library，也就是Windows静态库，将名字设为lua。</p>\n<p><img style="margin: 0 auto" src="https://static001.geekbang.org/resource/image/01/84/016bd92e192c42b2b53aa076c6277f84.jpg">  </p>\n<p>然后我们将文件添加到项目里面，在项目虚拟目录里面，点击鼠标右键。</p>\n<p><img style="margin: 0 auto" src="https://static001.geekbang.org/resource/image/0b/29/0bf22ba55c20fd93198d335260842629.jpg">  </p>\n<p>在弹出的选择文件对话框里，选中刚才解压缩出来的Lua目录，选择src目录下的所有或椎为.c的文件，随后，我们将 lua.c 排除在外（选中，右键，选择移除出项目）。因为我们制作静态库的时候，可以不用这个文件。</p>\n<p><img style="margin: 0 auto" src="https://static001.geekbang.org/resource/image/90/d2/90a6974f6a57c8530f52dda064878ad2.jpg">  </p>\n<p>我们可以点击Build-&gt;Build选项来进行编译，编译完成后，如果编译成功的话，我们会在Debug目录下看到一个.a文件。如果你的项目名叫lua，那么制作出来的静态库就是liblua.a，所以个文件就是我们以后要用到<strong>Lua静态库</strong>。</p>\n<p>如果你有一定的编程经验的话，可能已经看到，我们现在编译出来的是Debug，是调试版本，我们暂且不去管它。这个在后面我们会进行详细地探讨，目前我们只需要知道这一系列的使用方式和方法就可以了。</p>\n<p>我们已经将Lua编译完毕了，后续的文章中我会教你使用Lua静态库。</p>\n<p>接下来，我们尝试使用Python语言。你可以使用任何一个上述推荐的专业IDE来编写Python代码。实际上，Python的IDE不需要过多的配置。因为安装在Windows机器上后，Python的路径会被注册到系统。通常IDE会自动找到Python执行文件，并且，IDE的Shell窗口将会正确地找到Python并看到其互动窗口，就像这张图的内容：</p>\n<p><img style="margin: 0 auto" src="https://static001.geekbang.org/resource/image/05/82/057511edf04d2d71904b44f1462c2182.jpg">  </p>\n<p>现在，我们尝试在IDE中编写一小段Python测试代码，然后跑一下。程序运行结果就是打印一个 test字符串。</p>\n<pre><code>import os, sys\nif __name__ == &#39;__main__&#39;:\n   print &#39;test&#39;\n</code></pre><p>最后，将该文件保存后缀为.py的文件，这就是Python源代码。</p>\n<h2 id="7-python-pygame">7.专为Python开发的游戏库Pygame</h2>\n<p>在这里，为你介绍一个专门为Python开发的游戏库Pygame。至于为什么选择Pygame，我在第四节讲底层绘图接口的时候已经解释了一些。这里再说一下。</p>\n<p>Pygame包装了SDL的实现。在编写2D游戏方面，它的表现可以用三个词来形容：<strong>成熟，稳定，简单</strong>。它把一些细枝末节隐藏在了Python语法背后，当然也有Ruby语言封装的RubyGame，但是很多人对于这种魔幻的语言并不是特别了解，所以选择简洁的Python语法+SDL库封装是最合适的选择。</p>\n<p>今后我们会编写游戏的示例Demo，一些轻量级的、游戏的某一部分的说明和介绍，我会使用Pygame进行简单的阐述。Windows版本我们点击这个网址下载这个版本的源代码。 <a href="http://www.pygame.org/ftp/pygame-1.9.1release.zip">http://www.pygame.org/ftp/pygame-1.9.1release.zip</a> 如果你不愿意下载源代码，也可以根据自己对应的Python版本号下载对应的二进制包，支持Python 2.4 到3.2的版本。</p>\n<pre><code>pygame-1.9.1.win32-py2.7.msi 3.1MB\npygame-1.9.1release.win32-py2.4.exe 3MB\npygame-1.9.1release.win32-py2.5.exe 3MB\npygame-1.9.1.win32-py2.5.msi 3MB\npygame-1.9.1.win32-py2.6.msi 3MB\npygame-1.9.2a0.win32-py2.7.msi 6.4MB\npygame-1.9.1.win32-py3.1.msi 3MB\npygame-1.9.2a0.win32-py3.2.msi 6.4MB\n</code></pre><p>如果你安装的是64位Windows和64位Python，注意Pygame版本和Python都需要是32位的，才能完美兼容和使用。</p>\n<h2 id="-">小结</h2>\n<p>好了，这节内容差不多了。我来总结一下。在这一节中：</p>\n<ul>\n<li><p>我先从各操作系统下的调试工具、IDE开发环境、显卡驱动等三个方面，分析了为什么选择在Windows环境下进行开发；</p>\n</li>\n<li><p>然后，我还带你梳理了一遍开发所需要的语言和工具，并且提供了下载的网址和安装的方法；</p>\n</li>\n<li><p>之后，我还带你测试了Lua脚本语言在编译器中的编译并且生成了静态库文件。</p>\n</li>\n<li><p>最后给你介绍了Pygame，今后将会用到这个Python下的2D游戏开发引擎。</p>\n</li>\n</ul>\n<p>最后，给你留一个思考题吧。</p>\n<p>你可以结合之前几节的内容，思考一下，Pygame绑定SDL绘图接口是如何实现的？</p>\n<p>欢迎留言说出你的看法，我在下一节的挑战中等你！</p>\n<p></p>\n',
        article_title: "第6讲 | 从0开始整理开发流程",
      },
      {
        title: "第7讲 | 如何建立一个Windows窗体？",
        id: 8957,
        content:
          '<p>今天，我要跟你分享开发Windows游戏的第一步，建立窗体。</p>\n<p>上一节，我讲解Python和C++的编译器，以及它们各自对应的IDE该如何选择，并且测试了C/C++的运行，编译了一个Lua静态库。准备工作基本上算是完成了。</p>\n<p>如果你有一些编程功底，应该知道建立Windows的窗体所需的一些基础知识。如果你经验稍丰富一些，还应该知道Delphi、C++Builder、C#等等。这些工具都可以帮助你非常方便地做出一个空白窗体，但是这些窗体并没有游戏的绘图系统，所以它们只是“建立了一个标准窗体”而已。因此，虽然建立窗体是我们这一节的内容，但<strong>我们要探讨的是，在窗体背后，Windows系统做了什么。</strong></p>\n<h2>Windows窗体由哪些部分构成？</h2>\n<p>我们常规意义上的Windows窗体，由下列几个部分组成。</p>\n<ul>\n<li>\n<p><strong>标题栏</strong>：窗口上方的鼠标拖动条区域。标题栏的左边有控制菜单的图标，中间显示的是程序的标题。</p>\n</li>\n<li>\n<p><strong>菜单栏</strong>：位于标题栏的下面，包含很多菜单，涉及的程序所负责的功能不一样，菜单的内容也不一样。比如有些有文件菜单，有些就没有，有一些窗体甚至根本就没有菜单栏。</p>\n</li>\n<li>\n<p><strong>工具栏</strong>：位于菜单栏的下方，工具栏会以图形按钮的形式给出用户最常使用的一些命令。比如，新建、复制、粘贴、另存为等。</p>\n</li>\n<li>\n<p><strong>工作区域</strong>：窗体的中间区域。一般窗体的输入输出都在这里面进行，如果你接触过Windows窗体编程，就知道在这个工作区域能做很多的事情，比如子窗体显示、层叠，在工作区域的子窗体内进行文字编辑等等。你可以理解成，游戏的图形图像就在此处显示。</p>\n</li>\n<li>\n<p><strong>状态栏</strong>：位于窗体的底部，显示运行程序的当前状态。通过它，用户可以了解到程序运行的情况。比如的，如果我们开发出的窗体程序是个编辑器的话，我按了一下Insert键，那么状态栏就会显示Ins缩写；或者点击到哪个编辑区域，会在状态栏出现第几行第几列这样的标注。</p>\n</li>\n<li>\n<p><strong>滚动条</strong>：如果窗体中显示的内容过多，不管横向还是纵向，当前可见的部分不够显示时，窗体就会出现滚动条，分为水平滚动条与垂直滚动条两种。</p>\n</li>\n<li>\n<p><strong>窗体缩放按钮</strong>：窗体的缩放按钮在右上角，在窗体编程中属于System类目。这些缩放按钮依次为最小化、最大化和关闭按钮。</p>\n</li>\n</ul>\n<p>我们来看一张标准的Windows窗体截图，这个软件名是Notepad++。</p>\n<img style="margin: 0 auto" src="https://static001.geekbang.org/resource/image/cc/af/cc1d248bd1c76405ad73792112c33faf.jpg?wh=735*700">\n<p>这是MSDN上对于窗体结构的说明：</p>\n<pre><code>typedef struct tagWNDCLASSEX {\n  UINT      cbSize; //结构体大小，等于 sizeof(WNDCLASSEX)\n  UINT      style;  //窗体的风格\n  WNDPROC   lpfnWndProc; //窗体函数指针\n  int       cbClsExtra;  //附加在窗体类后的字节数，初始化是零\n  int       cbWndExtra;  //附加在窗体实例化的附加字节数。系统初始化是零，如果一个应用程序使用WNDCLASSEX注册一个通过在资源中使用CLASS指令建立的对话框时，必须把这个成员设成DLGWINDOWEXTRA。\n  HINSTANCE hInstance; //该对象的实例句柄\n  HICON     hIcon;     //该对象的图标句柄\n  HCURSOR   hCursor;   //该对象的光标句柄\n  HBRUSH    hbrBackground; //该对象的背景刷子\n  LPCTSTR   lpszMenuName;  //菜单指针\n  LPCTSTR   lpszClassName;  //类名指针\n  HICON     hIconSm;       //与窗体关联的小图标，如果这个值为NULL，那么就把hIcon转换为大小比较合适的小图标\n} WNDCLASSEX, *PWNDCLASSEX;\n</code></pre>\n<h2>使用C/C++编写Windows窗体</h2>\n<p>接下来，我将使用C/C++IDE来编写代码，完成一个默认窗体的开发，并让它运行起来。</p>\n<!-- [[[read_end]]] -->\n<pre><code>#include &lt;windows.h&gt;\nLRESULT CALLBACK WindowProcedure(HWND, UINT, WPARAM, LPARAM);\nchar szClassName[ ] = &quot;WindowsApp&quot;;\nint WINAPI WinMain(HINSTANCE hThisInstance, HINSTANCE hPrevInstance, LPSTR lpszArgument, int nFunsterStil)\n\n {\n    HWND hwnd;               /* 指向我们窗体的句柄 */\n    MSG messages;            /* 保存发往应用的消息 */\n    WNDCLASSEX wincl;        /* 前面详细介绍过的WNDCLASSEX结构的对象 */\n    wincl.hInstance = hThisInstance;\n    wincl.lpszClassName = szClassName;\n    wincl.lpfnWndProc = WindowProcedure;      \n    wincl.style = CS_DBLCLKS;                \n    wincl.cbSize = sizeof(WNDCLASSEX);\n</code></pre>\n<p>上述代码开始给WNDCLASSEX结构对象赋值。</p>\n<pre><code> /* 使用默认图标以及鼠标指针 */\n    wincl.hIcon = LoadIcon(NULL, IDI_APPLICATION);\n    wincl.hIconSm = LoadIcon(NULL, IDI_APPLICATION);\n    wincl.hCursor = LoadCursor(NULL, IDC_ARROW);\n    wincl.lpszMenuName = NULL; /* 没有菜单栏 */\n    wincl.cbClsExtra = 0;                      /* 没有多余的字节跟在窗体类的后面 */\n    wincl.cbWndExtra = 0;                      \n    wincl.hbrBackground = (HBRUSH) GetStockObject(LTGRAY_BRUSH);\n    if(!RegisterClassEx(&amp;wincl)) return 0;\n</code></pre>\n<p>代码在窗口过程调用函数的时候，将地址赋值给lpfnWndProc，然后呼叫RegisterClassEx(&amp;wincl)注册窗口类，系统就拥有了窗口过程函数的地址。如果注册失败，则返回0。</p>\n<pre><code> hwnd = CreateWindowEx( 0,            /* 扩展风格为0*/                               \n           szClassName,         /* 类名 */\n           &quot;Windows App&quot;,         /* 窗体抬头标题 */\n           WS_OVERLAPPEDWINDOW, /* 默认窗体 */\n           CW_USEDEFAULT,       /* 让操作系统决定窗体对应Windows的X位置在哪里 */\n           CW_USEDEFAULT,       /* 让操作系统决定窗体对应Windows的Y位置在哪里 */\n           544,                 /* 程序宽度 */\n           375,                 /* 程序高度 */\n           HWND_DESKTOP,        /* 父窗体的句柄，父窗体定义为Windows桌面，HWND_DESKTOP 是系统定义的最顶层的托管的窗体 */\n           NULL,                /* 没有菜单 */\n           hThisInstance,       /* 程序实例化句柄 */\n           NULL                 /* 指向窗体的创建数据为空 */\n           );\n    ShowWindow(hwnd, nFunsterStil);\n    /* 要显示窗体，使用的是ShowWindow函数 */\n    while(GetMessage(&amp;messages, NULL, 0, 0))\n    {      \n           TranslateMessage(&amp;messages);\n           DispatchMessage(&amp;messages);    \n    }\n    return messages.wParam;\n}\n</code></pre>\n<p>建立并显示窗体，在循环内将虚拟键消息转换为字符串消息，随后调度一个消息给窗体程序。</p>\n<pre><code>LRESULT CALLBACK WindowProcedure(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)\n{\n    switch (message)                  /* 指向消息的句柄 */\n    {\n           case WM_DESTROY:\n           PostQuitMessage(0);        \n           break;\n           default:                   \n           return DefWindowProc(hwnd, message, wParam, lParam);\n                 \n    }\n    return 0;\n}\n</code></pre>\n<p>最后是消息处理。当窗体程序接收到某些操作的时候，比如键盘、鼠标等等，就会呼叫 DispatchMessage(&amp;messages)；函数将消息回调给系统，系统通过注册的窗口类得到函数指针并且通过函数指针调用函数对消息进行处理。</p>\n<p>还有一个经常用到的函数就是MoveWindow，就是移动已经建立的窗体。MoveWindow函数用来改变窗口的位置和尺寸，如果窗体本身就按照计算机的屏幕对齐左上角，对于窗体内的子窗体，就对齐父窗体的左上角。</p>\n<pre><code>BOOL MoveWindow( HWND hWnd,/* 窗体句柄 */\n         int x,  /* 窗体左上角起点x轴 */\n         int y,  /* 窗体左上角起点y轴 */\n         int nWidth, /* 窗体宽度 */\n         int nHeight, /* 窗体高度 */\n         BOOL bRepaint = TRUE /* 是否重新绘制，如果是true系统会发送WM_PAINT到窗体，然后呼叫UpdateWindow函数进行重新绘制，如果是false则不重新绘制*/\n        );\n</code></pre>\n<p>MoveWindow会给窗体发送WM_WINDOWPOSCHANGING，WM_WINDOWPOSCHANGED，WM_MOVE，WM_SIZE和WM_NCCALCSIZE消息。</p>\n<p>类似的功能还有SetWindowPos，SetWindowPos功能更强大，可以设置更多的参数。</p>\n<p>这是基本的使用C/C++绘制Windows窗体的流程，也是标准的Windows窗体的创建和显示。在后续的分享中，我也会使用GDI或者GDI+来绘制一些的内容。</p>\n<h2>使用Python编写Windows窗体</h2>\n<p>说完了C/C++系统编程编写的Windows窗体，接下来来看一下，如何使用Python来编写Windows窗体。</p>\n<p>Python的Windows窗体编程一般会使用默认的Tinker库。不过用别的窗体库也可一建立一个窗体，比如Python版本的QT库或者wxPython。</p>\n<p>现在来看一下，使用默认的Tinker来建立一个窗体。</p>\n<pre><code>import Tkinter\n\ndef my_window(w, h):\n  ws = root.winfo_screenwidth()\n  hs = root.winfo_screenheight()\n  x = (ws/2) - (w/2)\n  y = (hs/2) - (h/2)\n  root.geometry(&quot;%dx%d+%d+%d&quot; % (w, h, x, y))\n\nroot = Tkinter.Tk(className=\'python windows app\')\nmy_window(100, 100)\nroot.mainloop()\n</code></pre>\n<p>运行的结果是这样的。</p>\n<img style="margin: 0 auto" src="https://static001.geekbang.org/resource/image/65/b8/657a175b08898385f555f7613d1a55b8.jpg?wh=316*339">\n<p>我们可以看到左上角有一个Tk的标识，这是Tinker的默认图标。目前，我们只是建立了一个Windows的窗体，并不能直接编写游戏。除此之外，我们还必须要知道这些建立窗体的具体的细节。</p>\n<p>不过，就像前面的文章所说，OpenGL并不附带任何关联窗体的编程，所以如果你使用的是OpenGL的接口来编写代码，稍微修改一下，这些窗体就能成为游戏屏幕窗体。</p>\n<p><strong><span class="orange">游戏所有的内容都是在一个循环内完成的，即我们所有的绘图、线程、操作、刷新，都在一个大循环内完成</span></strong>，类似我们在前面看到的代码。</p>\n<pre><code>while(GetMessage(&amp;messages, NULL, 0, 0))\n  {\n      TranslateMessage(&amp;messages);\n      DispatchMessage(&amp;messages);\n  }\n</code></pre>\n<p>以及使用Python编写的代码的窗体中，也会看到一个循环函数：</p>\n<pre><code>root.mainloop()\n</code></pre>\n<p>在这个while循环中，消息的派发都在此完成。游戏也一样，我们所有游戏内的代码几乎都在循环内完成。你可以想象<strong>一个循环完成一个大的绘制过程，第二个循环刷新前一次绘制过程，最终类似电影一样，完成整个动画的绘制以及不间断的操作。</strong></p>\n<p>在建立Windows窗体的时候，程序会从入口函数WinMain开始运行，定义和初始化窗体类，然后将窗体类实例化，随后进行消息循环获取消息，然后将消息发送给消息处理函数，最后做出相应的操作。</p>\n<h2>小结</h2>\n<p>总结一下今天所说的内容，我们编写了一个标准的Windows窗体，在编写的过程中：</p>\n<ul>\n<li>\n<p>窗体的结构是在建立窗体之前就定义下来的；</p>\n</li>\n<li>\n<p>所有长时间运行的程序，包括游戏，包括Windows本身都是一个大循环。我们在这个循环里做我们想做的事情，直到循环结束；</p>\n</li>\n<li>\n<p>如果使用脚本语言的方式编写窗体，就不需要关心那么多的东西，只需要定义坐标、位置和窗体名称即可。</p>\n</li>\n</ul>\n<p>最后，给你留一道小思考题吧。</p>\n<p>你经常会看到有一些游戏是需要全屏才能进行的。既然我们在这里建立了一个窗体，那请问你，全屏是怎么做到的呢？</p>\n<p>欢迎留言说出你的看法，我在下一节的挑战中等你！</p>\n',
        article_title: "第7讲 | 如何建立一个Windows窗体？",
      },
      {
        title: "第8讲 | 如何区分图形和图像？",
        id: 8951,
        content:
          '<p>据我所知，很多人可能都分不清图形和图像这两个概念：一种情况是你可能会觉得区分图形和图像这两个概念并没有什么实质的用途，于是就没关心过；另一种情况是，你可能朦胧中对图形和图像的区别有一些了解，但是不够深入或者不够透彻，也说不出一个所以然。没关系，今天我就来深入浅出地给你讲一下，图形和图像背后的那些事儿。</p>\n<p>既然我们是做游戏开发，那首先我们得知道，从专业地角度讲，区分图形和图像对我们的开发工作有什么帮助。简单地说，<strong>搞清楚了游戏开发中绘制、载入、保存的究竟是图形还是图像，你会对接口函数的使用有一个更深入的认识。</strong></p>\n<p>比如，如果是图形接口，可能它的接口函数是：</p>\n<pre><code>Surface* DrawSomething(int start_x, int start_y, int finish_x, int finish_y);\n</code></pre><p>如果是图像接口，它的接口函数函数看起来可能是这个样子：</p>\n<pre><code>Surface* LoadFromFile(const string&amp; filename);\n</code></pre><h2 id="-">如何区分图形和图像？</h2>\n<p>从广义上说，所有我们人肉眼能看到的对象，都是图形。从狭义上说，图形是我们所看到的一种点、线、面的描述对象。</p>\n<p><strong>图像，是由数据组成的任意像素点的描述对象。</strong>比如我们所看到的照片。在电脑中，图形的显示过程是有一定顺序（比如从左往右）的，而图像则是按照像素点进行显示的。电脑对于图形的编辑、修改更为简单方便，因为单一的图形具有特殊的属性（比如圆圈的直径、颜色等等，因为这些在这个图形建立的时候就固定了下来）。</p>\n<p>对于图像进行编辑则非常困难，软件需要用一些特殊的算法来计算图像的色块、区域、描边等等，来安排图像该如何进行编辑，有一些甚至还需要用到深度学习的方法来辨别图像的显示区域、显示的内容等等，所以图像的修改比之图形的修改要困难。</p>\n<p>那么你可能就会问了，既然前面说，任何眼睛看到的对象，都是图形，那么我觉得图形也是一种图像，这么说对不对呢？如果按照载体来说，图形也是一种图像，这种说法是对的。因为一张JPG图片可能存储的是一幅照片，也可能存储一幅三角形的图形。虽然本质不一样，但是由于存储的形式是以图像的形式存储的，在电脑看来，这个三角形就是一幅图像。但是如果你在游戏中使用函数画出了一个三角形，那就是图形了。</p>\n<p>所以，严格来说，<strong>图形其实是图像的一种抽象表现形式</strong>。一般来讲，图形的轮廓并不复杂，比如一个圆圈、一个方块、一个三角形、一条线、某些几何图形、工程上面使用的图纸和CAD等，这些都属于图形。图形的色彩也并不是很丰富。而图像一般都有复杂的轮廓、非常多的细节和颜色（当然也有纯单一的颜色，比如黑白照片）。</p>\n<p><img style="margin: 0 auto" src="https://static001.geekbang.org/resource/image/fb/bc/fb2b9c4192fd7147c3346dc0da7423bc.jpg">  </p>\n<p><img style="margin: 0 auto" src="https://static001.geekbang.org/resource/image/7d/0b/7d00b8af46c9455a24f5a6a3f77e650b.jpg"></p>\n<p>所以，准确地说，图形和图像有不同的模式。当然，从计算机最底层的程序（显卡处理）来看，绘制图形和图像所经过的硬件处理几乎是一样的。一般显卡会经过这些流程进行图形、图像计算（2D）、显存，用来存取图形图像内容，GPU计算图像图像内容并渲染，最后输出到显示器。</p>\n<p>从<strong>图像的呈现方式</strong>讲，只有通过图像的方式去呈现“图形”这个对象，才能看到图形，而在开发游戏的过程中，图形和图像的编程方式是截然不同的。比如我们要画线，那么可能会使用到一个叫DrawLine的函数。该函数里面需要输入线条的起始坐标，这就是图形的绘制方式。而在接下来的过程中，我将教你如何绘制图形和图像，并呈现出来。</p>\n<h2 id="-">跟我一起绘制图形和图形</h2>\n<p>现在，我们先用Pygame游戏库来建立一个窗体，然后开始绘制图形、载入图像。</p>\n<p>在第五节的时候，我们已经讲过Pygame的安装和配置。在第六节的时候，我们讲过如何建立一个Windows窗体。现在从上到下，我们一起看一下这段代码。</p>\n<!-- [[[read_end]]] -->\n<pre><code>import pygame\npygame.init()\ncaption=pygame.display.set_caption(&#39;Python App&#39;)\nscreen=pygame.display.set_mode([320,200]) #窗口大小为320*200\nwhile True:\n    for event in pygame.event.get():\n        if event.type == pygame.QUIT:\n            pygame.quit()\n    pygame.display.update()\n    screen.fill([255,255,255]) #用白色填充窗体\nsys.exit()\n</code></pre><p>在这段代码中，首先，我们需要告诉Python我们要引入Pygame。然后Pygame进行初始化（init）。在这个初始化的函数里，Pygame会初始化屏幕、声音、事件、按钮等一系列需要初始化的东西。随后，我们利用Pygame的display对象的set_caption函数来设置窗体的文字，将这个设置后的对象返回给caption变量。随后，再使用set_mode函数设置窗口大小，将窗口大小设置为320x200分辨率，将返回对象赋值给screen变量，最后screen拿到窗口句柄后，使用fill函数设置填充窗体的颜色，在这里填充的颜色是白色。</p>\n<p>我们可以看到，使用Pygame游戏库来建立一个Windows窗体比前面我们提到的任何一种方式都快。那是因为<strong>Pygame封装了建立窗体的代码和图形显示模块</strong>。</p>\n<p>我们在前面提到，<strong>一个游戏是在一个大循环下形成的</strong>，所以这里我们要补上一个大循环以确保这个程序不会立刻退出。</p>\n<pre><code>while True:\n    for event in pygame.event.get():\n        if event.type == pygame.QUIT:\n            pygame.quit()\n    pygame.display.update()\n    screen.fill([255,255,255]) #用白色填充窗体\nsys.exit()\n</code></pre><p>这段代码的意思是，当条件为真（True）的时候（条件总是为真），进行一个循环。事实上这是个死循环，如果没有下面的退出代码的话。那么在这个循环里，从Pygame的event事件列表中取出event事件，然后进行判断，如果event的类型是退出类型（点击右上角的X关闭按钮），那么Pygame就退出，这个quit 函数就直接退出while大循环了。最终系统也退出sys.exit。</p>\n<p><img style="margin: 0 auto" src="https://static001.geekbang.org/resource/image/85/7c/85a8383c033ff7ec997e4e7ad9d1dd7c.jpg">  </p>\n<p>现在我们要在窗体上放上一个矩形和圆。我们先使用rect函数来画一个矩形：</p>\n<pre><code>  pygame.draw.rect(screen,[255,0,0],[150,10,0,40],0)\n</code></pre><p>其中，draw中rect的定义为：rect(目标画布,颜色,位置,宽度)。</p>\n<p>我们也可以用类似的方法来画一个圆：</p>\n<pre><code>  pygame.draw.circle(screen,[0,0,0],[top,left],20,1)\n</code></pre><p>然后我们使用pygame.draw.circle()用来画圆形。circle函数具有5个参数：</p>\n<ul>\n<li><p>目标画布，在这里是screen</p>\n</li>\n<li><p>颜色</p>\n</li>\n<li><p>由左侧点和顶部点组成的圆形初始位置</p>\n</li>\n<li><p>直径</p>\n</li>\n<li><p>宽度</p>\n</li>\n</ul>\n<p>现在我们将所有的代码合并起来看一下：</p>\n<pre><code>import pygame\npygame.init()\ncaption=pygame.display.set_caption(&#39;Python App&#39;)\nscreen=pygame.display.set_mode([320,200]) #窗口大小为640*480\nwhile True:\n    for event in pygame.event.get():\n        if event.type==pygame.QUIT:\n            pygame.quit()\npygame.draw.rect(screen,[255,0,0],[150,10,20,40],0)\npygame.draw.circle(screen,[0,0,0],[20,50],20,1)\npygame.display.update()\nscreen.fill([255,255,255])#用白色填充窗口\nsys.exit()\n</code></pre><p><img style="margin: 0 auto" src="https://static001.geekbang.org/resource/image/41/4a/41ed7da2761a57bf68d990a660f7014a.jpg">  </p>\n<p>所以我们很容易就能看出来，<strong><span class="orange">在Pygame游戏开发库里面，画一个图形是很容易的事情，你不需要知道太多的细节，只要将位置和颜色或者内容填充进去就可以了。</span></strong></p>\n<p>我们可以在Pygame中使用Pygame.image.load来加载图像文件，这个函数支持各种图片格式。我们使用这个方法来加载一副PNG图片：  </p>\n<pre><code>obj = pygame.image.load(&quot;test.png&quot;).convert_alpha()\n</code></pre><p>使用convert_alpha函数是因为这个函数会使用透明方法来绘制，所以我们在加载一个拥有alpha通道的图片的时候（比如TGA、PNG）的时候，可以使用这个方式。</p>\n<p>然后使用blit方法将图像绘制出来：</p>\n<pre><code>screen.blit(obj, (20,10))\n</code></pre><p>或许你会问，blit是什么函数，我在这里简单介绍一下，blit这个函数会以各种函数形式出现在图形引擎的函数里面，比如FastBlit等等。这个函数具体负责将图像从某一个平面复制到另一个平面，或者将图像从内存复制到屏幕。简而言之，这个函数的功能就是将图像“绘制”在游戏窗体的屏幕上。</p>\n<p>现在继续来看看blit函数。blit函数的第一个参数是加载完成的返回对象，第二个参数是绘制的坐标位置。最后我们需要update（更新）整个游戏窗体的绘制内容。</p>\n<p>我们把载入图像的代码整合到刚才的代码中一块儿看一下。</p>\n<pre><code>import pygame\npygame.init()\ncaption=pygame.display.set_caption(&#39;Python App&#39;)\nscreen=pygame.display.set_mode([320,200]) #窗口大小为640*480\n\nobj = pygame.image.load(&quot;test.png&quot;).convert_alpha()  \n\nwhile True:  \n\n    for event in pygame.event.get():\n        if event.type==pygame.QUIT:\n            pygame.quit()\n            sys.exit()\n    screen.blit(obj, (20,10))\n    pygame.display.update()\nscreen.fill([255,255,255])#用白色填充窗口\n</code></pre><p>最后呈现的效果是这样的：</p>\n<p><img style="margin: 0 auto" src="https://static001.geekbang.org/resource/image/9e/97/9e8f1747c6ddcdb3302de41d64a69c97.jpg"></p>\n<h2 id="-">小结</h2>\n<p>这一节，我带你学习了图形和图像的区别，使用Pygame绘制了最基础的图形，最后我们通过代码载入一副PNG图像并在屏幕上绘制出来。</p>\n<p>给你留一个小练习吧。</p>\n<p>请你结合上述代码，在游戏执行的大循环内，在游戏的窗体里面，绘制出一个从左到右移动的矩形、圆形或者图像。</p>\n<p>之后，针对一些实操性强的内容，我都会适时给你留一些必要的练习。希望你每次都能动手去练习一下。同时，也欢迎你留言，说出你在练习中的疑惑和成果。温故而知新，相信你会有更多的收获！</p>\n<p>我在下一节的挑战中等你！</p>\n<p></p>\n',
        article_title: "第8讲 | 如何区分图形和图像？",
      },
      {
        title: "第9讲 | 如何绘制游戏背景？",
        id: 8965,
        content:
          '<p>我在之前的文章中描述了各种基础知识，然后梳理了开发流程，并带你创建了一个窗体，现在我们要做的就是朝这个窗体里添加东西。</p>\n<p>我会随着进度逐渐提升难度。就现阶段来讲，我们涉及的只是一些基础知识，并且只<strong>需要将大部分的关注点放在我们要做的游戏内容上，并不需要关注过多的底层逻辑代码</strong>。</p>\n<p>做事情都有先后顺序，做游戏开发自然也是。为什么要学习先绘制游戏背景而不是别的什么，很简单，因为只有先绘制了游戏背景，才能进行后续的游戏图像遮挡、图形图像的显示等等操作。</p>\n<p>不管你有没有玩过《超级玛丽》《魂斗罗》《雷电》之类的游戏，但一定对其画面不陌生。和我们要开始做的打飞机游戏一样，这种类型的2D游戏，其背景不是左右卷轴，就是上下卷轴。<strong>所谓左右卷轴，就是游戏画面是横向的、左右运动的，而上下卷轴就是游戏画面是竖直对的、上下运动的。</strong></p>\n<p><img src="https://static001.geekbang.org/resource/image/2c/b1/2cd9958a20b5aca5650e9d6a99dec0b1.jpg" alt=""></p>\n<p>像《雷电》这样的经典飞机游戏，就是属于上下卷轴的。上下卷轴的飞机游戏有一个特点，就是它是在空中，从凌驾于飞机之上的视角，往地面俯瞰的。因为是俯视角，所以我们可以很方便地看到游戏的整体地图，包括地面上的敌人、空中的敌人等等，层次感会很强。</p>\n<p>因此，可以确定，我们要做的打飞机，也是一个上下卷轴的游戏。这样，我们就可以着手将需要的图片添加进去了。</p>\n<p>我们要使用Pygame，先读取一个图片，让该图片成为游戏背景并载入进去。当下阶段，我们的图片从哪儿获得并不重要，因为在一个完整的游戏开发团队里面，都有专业的美术团队负责作图，但是现在我们没有，所以我就自己贴一幅图来代替正式的游戏背景。所以你现在只需要知道背景是如何贴上去的就好了。</p>\n<p>和前面的文章说过的一样，我们需要先载入Pygame模块，并且定义一个变量background。我们将一幅名为lake,jpg的图片文件赋值给backgroud变量。</p>\n<!-- [[[read_end]]] -->\n<pre><code>import pygame\nbackground = &#39;lake.jpg&#39;\n</code></pre><p>然后，我们先把Pygame的所有组件都初始化。接下来，我们调用display类里的set_mode函数来对屏幕进行一个初始化。</p>\n<pre><code>pygame.init()\nscreen = pygame.display.set_mode((640, 480), 0, 32)\npygame.display.set_caption(&quot;pygame game&quot;)\n</code></pre><p>这里一共有三个参数，第一个参数是<strong>分辨率</strong>，比如我这里编写的是640x480的分辨率；第二个参数是<strong>flag</strong>，flag的参数我放在下面这个表里了；第三个参数是<strong>32</strong>，32代表的是颜色深度，这里是32位的意思。</p>\n<p><img src="https://static001.geekbang.org/resource/image/da/67/daecb1449c14d6f4c9b55922011bd667.jpg" alt="">  </p>\n<p>在设置完了窗体模式之后，后面的一段代码就是设置窗体的抬头文字，这里显示的是pygame game。</p>\n<p>随后，我们要载入背景的图片。</p>\n<pre><code>bg = pygame.image.load(background).convert()\n</code></pre><p>我在前面的文章中也说过，这句话的意义是，载入backgroud图片。但是pygame.image.load这个函数返回的是一个surface，而.convert函数是来自于surface对象。你可以参考下面的代码来理解。</p>\n<pre><code>surface_temp = pygame.image.load(background)\nbg = surface_temp.convert()\n</code></pre><p>其次，bg这个变量也是一个surface，而convert函数的作用是改变一副图片的像素格式。convert有四个相同名字的重载函数。如果就像我们的代码里所示，convert没有任何参数，则表示直接返回一个surface对象。</p>\n<p>好了，现在我们设置完了背景bg的surface，我们按照上面的文章，开始写一个大循环，并且在循环里面进行检测鼠标事件是不是退出操作，这是最基本的一项检测。</p>\n<pre><code>while True:\n    for event in pygame.event.get():\n        if event.type == QUIT:\n            pygame.quit()\n</code></pre><p>和前面的文章一样，我们从event里取出事件列表，然后把每一个event的类型进行对比，如果发现有QUIT事件（鼠标点击X关闭按钮后），就直接退出游戏。完成这一步之后，就可以开始使用blit函数进行绘制屏幕的操作。</p>\n<pre><code>screen.blit(bg, (0,0))\n</code></pre><p>这句话的意思是，使用blit将bg在以游戏屏幕x,y轴为（0,0）的坐标位置在screen对象上绘制背景图像。然后我们需要update刷新屏幕，添加下面这行代码。</p>\n<pre><code>pygame.display.update()\n</code></pre><p>upadate这个函数是 pygame.display.flip 函数的优化版。因为pygame,display.flip是更新整块屏幕，所以如果加载的资源多，效率并不是很高，而update如果传递一个矩形值得参数的话，它会只更新这块矩形的内容，所以效率会比较高，但是不传递参数的话，默认还是会更新整块屏幕，但是这个函数不能用在set_mode的时候设置为OpenGL的模式下。</p>\n<p>好了，我们该做的事情基本都做完了，现在我们来运行一下，看看效果。</p>\n<p><img src="https://static001.geekbang.org/resource/image/5c/95/5c96858d8059e1729ce1e14d1c93fc95.jpg" alt=""></p>\n<p>好了，背景是贴上去了。现在问题来了，要想让背景动起来该怎么做呢？如果在blit的时候，改变坐标是不是就可以移动背景图的位置了呢？你再开动脑筋想想，该怎么做才能让背景移动起来？</p>\n<p>对的，我们只需要写一个循环，就可以将背景移动起来。</p>\n<p>我们来修改一下大循环开始的代码。</p>\n<pre><code>y_move = 0\nwhile True:\n    for event in pygame.event.get():\n        if event.type == QUIT:\n            pygame.quit()\n    screen.blit(bg, (0,y_move))\n    y_move-=1\n</code></pre><p>我们在大循环开始之前，在这段代码里定义了一个y值移动的变量，而我们每循环一次，blit就绘制一次屏幕，y值都会被减去1，所以我们每次看到的图片，都会不停往上移动，我们来看一下效果。</p>\n<p><img src="https://static001.geekbang.org/resource/image/13/81/135f2931b3a3168192ec9a5cc0a1ba81.jpg" alt=""></p>\n<p>发现问题了没有，在移动的过程中，下方的图案居然没有被刷新，直接黏在了屏幕上，看起来是不是很恶心的样子？</p>\n<p>我们应该怎么做才能达到正常的效果呢？也就是说，请你思考一下，应该怎样做，我们才可以将这个令人头疼的图像在移动的时候变得正常呢？</p>\n<p>我们先来回顾一下，我们在循环里面做了哪些步骤：</p>\n<ol>\n<li><p>检测退出事件；</p>\n</li>\n<li><p>在屏幕上绘制bg对象，坐标初始为（0, y）；</p>\n</li>\n<li><p>飞机每移动一格，坐标y减1；</p>\n</li>\n<li><p>更新屏幕。</p>\n</li>\n</ol>\n<p>看起来似乎没有什么问题，我再来带你梳理一下。</p>\n<p>首先我们初始化的时候，屏幕是黑屏一块，没有任何图像，然后我们进入大循环，将bg对象绘制到屏幕上的时候，你觉得这时候我们的眼睛看到绘制的图像了吗？</p>\n<p>如果你说是的话，那就大错特错了，因为<strong>这个blit的动作，仅仅是绘制，而不是显示</strong>。请记住这个区别：<strong>绘制不等于显示</strong>。</p>\n<p>那你可能就要问了，既然绘制了，为什么不显示呢？要什么时候才能显示呢？答案是，要在update一次屏幕的时候，才会显示，这就是“更新”的作用。就像电影是一帧一帧的，如果没有下一帧更新，电影就会永远定格在某一秒。</p>\n<p>所以问题逐渐就暴露出来了，我们再来重新梳理一下流程：</p>\n<ol>\n<li><p>检测退出事件；</p>\n</li>\n<li><p>在屏幕上绘制bg对象，坐标初始为（0, y）（注意是绘制，不是显示）；</p>\n</li>\n<li><p>飞机每移动一格，坐标y就减1；</p>\n</li>\n<li><p>更新屏幕，将第二步绘制的bg对象呈现在屏幕上，严谨地说，应该是将在update函数之前所有的绘制操作都更新一次并呈现在屏幕上）。</p>\n</li>\n</ol>\n<p>好了，问题很清楚了，update函数只是将屏幕更新了一次，并未进行填充颜色或者“擦除”背景的操作，也就是<strong>我们在移动y值的时候，整个屏幕不停地更新，然而没有擦除</strong>。那么应该怎么将移动后的画面进行清理呢？</p>\n<p>我们在update代码之后填入下面的代码。</p>\n<pre><code>screen.fill([0,0,0])\n</code></pre><p>fill操作拥有三个参数，其中第一个参数是<strong>填充颜色；</strong>第二个参数是<strong>填充某一块区域</strong>（如果不填入第二个参数，就会填充整个屏幕）；第三个参数是<strong>blit操作的特殊参数</strong>，我们暂时可以不用管它。</p>\n<p>所以，我们在代码里填充了黑色到整个屏幕，这样一来我们的屏幕操作变成这样：</p>\n<ol>\n<li><p>检测退出事件；</p>\n</li>\n<li><p>在屏幕上绘制bg对象，坐标初始为（0, y）；</p>\n</li>\n<li><p>坐标的y减1；</p>\n</li>\n<li><p>更新屏幕；</p>\n</li>\n<li><p>填充屏幕区域为黑色。</p>\n</li>\n</ol>\n<p>我们再运行一下看一下效果。</p>\n<p><img src="https://static001.geekbang.org/resource/image/49/66/4982b8ea20800fba341143140eeb8a66.jpg" alt=""> </p>\n<p>嗯，这下看起来正常了，屏幕不断往上移，并且没有拖着尾巴一样的图案了。</p>\n<h2 id="-">小结</h2>\n<p>我们在写2D游戏的时候要注意一点，就是：</p>\n<p>我们要<strong><span class="orange">想象游戏的每一帧就像电影的每一帧。每一帧做的事情，如果下一帧不去做，那么永远不会更新屏幕内容</span></strong>。</p>\n<p>所以，update的功能是更新调用update之前的所有动作，这些动作可以有绘制图像操作，也可以有音乐播放，也可以有动画每一帧的操作等等。只要update一次，屏幕的画面就会往前行进一次。</p>\n<p>给你留个小思考题吧，我们在fill屏幕的时候，怎么做才能让填充的颜色不停变幻呢？</p>\n<p>欢迎留言说出你的看法。我在下一节的挑战中等你！</p>\n<p></p>\n',
        article_title: "第9讲 | 如何绘制游戏背景？",
      },
      {
        title: "第10讲 | 如何载入“飞机”和“敌人”？",
        id: 9421,
        content:
          '<p>上周，我向你解释了如何载入背景图片，以及如何使用坐标值的变换来移动背景图片。今天，我们要载入主角“飞机”和一些“敌人”。</p><h2>导入随机函数</h2><p>我们选择Python做为开发语言。在开始之前，需要用到一个随机函数，这个随机函数会在之后的代码中用到，具体用作什么，我会在后面揭晓。</p><p>首先，需要将随机函数导入Python的随机函数库random。代码可以这么写：</p><pre><code>import random\n</code></pre><p>然后，我们需要限定一个范围，来生成随机数，比如10到100的范围，代码可以这么写：</p><pre><code>random.randrange(10, 100)\n</code></pre><p>这个函数会接受三个参数：开始、结束、递增数字。</p><ul>\n<li>\n<p>开始：开始随机的指定范围数值，包含在范围内。比如(10，100)，就包含10。</p>\n</li>\n<li>\n<p>结束：开始随机的指定范围数值，不包含在范围内。比如(10，100)，不包含100，最多到99。</p>\n</li>\n<li>\n<p>递增：指定递增数字。</p>\n</li>\n</ul><p>如果不填写递增值，则按照开始、结束的值随机分配。比如 (10，100) ，那就会在10～99之间随机分配任何一个数字。</p><h2>载入主角飞机</h2><p>我们说完了随机函数的准备工作，就可以开始载入飞机了。</p><p>我们假设主角的飞机是从下往上飞，那它的飞机头应该是朝着电脑屏幕上方，而敌人的飞机是从上往下出现，所以它的飞机头应该朝着电脑屏幕的下方。主角的飞机暂时固定在屏幕下方，敌人的飞机则一直不停从上往下飞。</p><!-- [[[read_end]]] --><p>飞机的图片是我从共享的图片网站上抓取下来，让美术帮我处理和加工了一下。其实就是将飞机从一整块背景图片上抠除下来，让飞机看起来拥有飞机本身的轮廓，而不是一幅“方块”的飞机图片，然后将其图片保存成png的格式。</p><p>我们来看这里的代码。和载入背景一样，我们需要先定义主角飞机的图片名和敌人飞机的图片名。</p><pre><code>plane = \'plane.png\'\nenemy = \'enemy.png\' \n</code></pre><p>使用png格式的原因是，png格式包含alpha通道。我们可以将图片抠成透明图，这样将图片贴在背景上面就看不到任何黑色块。</p><p>我们先尝试贴一下主角的飞机。</p><pre><code>pln = pygame.image.load(plane).convert_alpha()\nscreen.blit(pln, (40, 350))\npygame.display.update()\n</code></pre><p>我们定义一个叫pln的变量，载入plane图片，并且将alpha通道进行处理，然后在屏幕中绘制pln，最后我们使用update函数更新屏幕。</p><p>我们来看一下贴图的效果。</p><p><img src="https://static001.geekbang.org/resource/image/3b/ca/3b13e0a3ff4b7006ee4a1ddbaf8309ca.jpg" alt=""></p><p>我们已经将这幅图片贴了上去。</p><p>在载入的过程中，如果我不使用convert_alpha函数会怎样呢？我们也来做一下实验。</p><pre><code>pln = pygame.image.load(plane).convert()\nscreen.blit(pln, (40, 350))\npygame.display.update()  \n\n</code></pre><p>我将 convert_alpha 改成了convert，来看一下效果。</p><p><img src="https://static001.geekbang.org/resource/image/4b/57/4ba2eb42b15c44056099e53489104d57.jpg" alt=""></p><p>看到了那个大大的黑色色块没有？这就是我们没有处理alpha通道导致的结果，导致了一个大大的抠图色块出现在屏幕，所以要记住：</p><ol>\n<li>\n<p>设计主角图的时候，要将图片抠下来；</p>\n</li>\n<li>\n<p>在贴图的时候，需要进行alpha混合的处理，否则贴上去的图会存在抠图黑块。</p>\n</li>\n</ol><h2>载入敌人飞机</h2><p>接下来，我们要从屏幕上方，贴一架敌人的飞机。</p><pre><code>enm = pygame.image.load(enemy).convert_alpha()\nscreen.blit(enm, (30, 10))\npygame.display.update()\n</code></pre><p>我们将两架飞机前后代码整合起来，再来看一下效果。</p><p><img src="https://static001.geekbang.org/resource/image/ee/31/ee3059e4cb999d4a5f532c634e88d331.jpg" alt=""></p><p>这样，我们将两架飞机都贴在了屏幕上了。看起来是不是有点像样了呢？</p><p>敌方肯定不止一个飞机，那我们就需要贴更多的敌方飞机。这里我们就需要用到最开始提到的随机函数了。为什么使用随机函数呢？因为我们需要让敌方飞机的排列看起来很随机（笑）。</p><p>我们现在要加载相同的敌方飞机图片，加载三次。也就是说，我们会在屏幕上方的一个固定区域范围贴上三次敌人的飞机。我们需要准备三个随机 (x，y) 位置的数字，并且赋值给 blit 函数。</p><pre><code>ex1 = random.randrange(20, 600)\ney1 = random.randrange(10, 50)\nex2 = random.randrange(20, 600)\ney2 = random.randrange(10, 50)\nex3 = random.randrange(20, 600)\ney3 = random.randrange(10, 50)\nscreen.blit(enm, (ex1, ey1))\nscreen.blit(enm, (ex2, ey2))\nscreen.blit(enm, (ex3, ey3)) \n</code></pre><p>这样，我们就贴上了三幅飞机的图片。</p><p>我们再来看一下效果。</p><p><img src="https://static001.geekbang.org/resource/image/b9/7d/b932a985b390ccf359a4a56f25796c7d.jpg" alt=""></p><p>是不是看起来很有意思？但是这样并不能让飞机动起来，我们需要用到上一节里，移动背景图片的知识，来让敌人的飞机动起来。我们只需要将这三个y值在循环中设置成递增，就可以做到三架飞机的移动了。代码就像这样：</p><pre><code>screen.blit(enm, (ex1, ey1))\nscreen.blit(enm, (ex2, ey2))\nscreen.blit(enm, (ex3, ey3))\ney1 +=1\ney2 +=1\ney3 +=1\n</code></pre><p>这样我们就完成了敌人飞机不停往下飞的效果了。</p><p>后面的内容，也会像现在这样，代码很多，我带你再梳理一下逻辑。</p><p><strong><span class="orange">首先，我们需要使用Python程序库的随机函数来制作随机数。</span></strong></p><ol>\n<li>\n<p>通过这个随机函数，来随机载入敌人飞机的位置。当然如果有游戏策划的话，游戏可能会由某种固定的起始点来刷出敌人飞机，这里我们只用到随机函数来刷敌人飞机。</p>\n</li>\n<li>\n<p>如果想要做得更漂亮的话，我们可以将随机函数的值从屏幕最上方刷出来，这样看起来敌人就是从屏幕最上方飞下来的。比如我们可以设置y值为-10左右。</p>\n</li>\n<li>\n<p>如果想要做得更精细的话，我们可以通过程序得到图片的长和宽。通过图片的长和宽来计算刷出飞机的位置，我们可以使用屏幕大小来减去飞机长宽的大小来计算，比如屏幕长是640，图片的长是8。那么，我们在设置 x 轴位置的时候，就应该最大只设置到640-8这样的位置。这样就不至于我们在编程的时候，只刷出半架飞机，或者根本就看不到飞机。</p>\n</li>\n</ol><p><strong><span class="orange">其次，我们在载入敌人飞机的时候，需要贴三幅图片。</span></strong></p><ol>\n<li>\n<p>当然，我们可以优化这一系列的代码，比如我们可以将一系列blit放在一个函数里面。上述的代码只是一个针对教学用的代码，为的是让你更直观、明了地能看明白如何载入三幅敌人飞机的图片。我们优化了代码后，可以直接使用一段代码和一系列数组就可以完成这个操作。</p>\n</li>\n<li>\n<p>如果做了一幅alpha通道抠图的图片，我们在载入的时候，需要处理alpha通道的数据，让其图片达到“透明”的效果，而不是直接贴一幅有黑框的图片。</p>\n</li>\n</ol><p><strong><span class="orange">最后，事实上，我们要将这些内容更加完善，还有许多的工作要做。</span></strong></p><ol>\n<li>\n<p>这些工作我将在后续的内容中展开讲解。比如我们需要移动背景。这个我们上次已经说明了。在敌人飞机往下飞的过程中，我们需要考虑敌人飞机往下飞的速度，是不是要比屏幕移动的速度更快或者更慢，这样才能体现敌人飞机的等级高低，体现出游戏的难度是随着关卡的变化越来越难的。</p>\n</li>\n<li>\n<p>我们将游戏背景的图片blit函数放在游戏循环的最开始，而载入飞机的代码则放在稍后的部分，那么如果我们将游戏背景的图片放到飞机之后载入会发生什么事情呢？如果你一直在练习我在文中提供的代码，你应该可以知道，这个时候飞机的图片都会不见了，只能看到游戏背景。这是因为Pygame是按照blit代码的顺序来载入图片的，这部分内容我在后面的内容中讲解。</p>\n</li>\n<li>\n<p>我们可以将载入的图片资源放到一个资源包中，或者放在一个目录中，这样游戏的目录就不至于看起来乱七八糟，而是非常有序的。比如我们可以将所有和主角飞机相关的内容就放在飞机的目录下，和敌人相关的就放在敌人的目录下，背景和关卡就放在关卡的目录下，这样就看起来就整整齐齐。在编写代码的时候，从目录的名字不同，可以知道载入的是什么内容，比如：‘enemy/plane.png’。</p>\n</li>\n</ol><h2>小结</h2><p>好了，这节内容差不多了。我主要和你讲了三个内容：</p><ol>\n<li>\n<p>随机函数使用random.randrange来做，输入开始和结束值，就能随机出这一个范围的数字;</p>\n</li>\n<li>\n<p>让飞机移动起来，需要将x或者y的值进行加减变化;</p>\n</li>\n<li>\n<p>处理alpha混合半透明图片，需要使用conver_alpha函数。</p>\n</li>\n</ol><p>最后，给你留一个小思考题吧。</p><pre><code>while True:\n     ......\nex1 = random.randrange(20, 600)\ney1 = random.randrange(10, 50)\nscreen.blit(enm, (ex1, ey1))\n     pygame.display.update()\n</code></pre><p>如果我们把这段代码的ex1, ey1变量放在游戏循环中（本来在循环外面），并且将ex1, ey1填入到敌人飞机的blit函数中，会出现什么样的结果呢？</p><p>欢迎留言说出你的看法。我在下一节的挑战中等你！</p>',
        article_title: "第10讲 | 如何载入“飞机”和“敌人”？",
      },
      {
        title: "第11讲 | 如何设置图像的前后遮挡？",
        id: 9423,
        content:
          '<p>我们人的肉眼所观察到的世界是属于3D世界，有远近大小之分。一个物件A被另一个物件B遮挡，物件A就会看不到，而在2D的世界里，都是平面的，没有实际的高度区分，就算做成了斜45度角，也是一种视觉呈现，并没有在计算机内形成高度差。</p><p>在一般的游戏引擎，或者像Pygame这样的游戏库中，基本都是“先绘制的图案先出来”，“后绘制的图案后出来”，而后绘制的图案一定遮挡前面绘制的图案。因为2D就是一个平面，从逻辑上讲，按照先后顺序绘制，没有任何问题。</p><p>但是如果我们现在做的游戏是斜45度角的游戏，类似《梦幻西游》视角的，那么人物和建筑物之间就存在遮挡的问题，如果处理不谨慎，就会出现人物浮在建筑物上，或者建筑物把人挡住了。</p><p>所以在一些2D引擎中，会有一个Z值的概念，Z值的概念就是在（X,Y）的基本2D位置上，加一个高度的概念。这个高度是一个伪概念，它模仿3D的Z值，只是作遮挡用。但是我们现在使用Pygame来编写游戏的话，并没有Z值的概念，所以我们需要想一些办法来解决遮挡的问题。</p><p>首先，我们从共享资源中抽取一段围墙的图片来进行摆放。</p><img></img><img></img><p>围墙分为两幅图片，都是往右上角延伸的。现在我们需要将这两段围墙连接起来。如果我们像以前的做法，一个图片一个blit的话，那是不行的。因为这样需要相当大的代码量，所以我们采取将围墙的代码放入一个list中的做法。</p><!-- [[[read_end]]] --><p>首先，我们要定义图片和载入图片。</p><pre><code>right_1 = \'right_1.png\'\nright_2 = \'right_2.png\'\nr_1 = pygame.image.load(right_1).convert_alpha()\nr_2 = pygame.image.load(right_2).convert_alpha()\n</code></pre><p>然后，我们写一个循环，将围墙放入一个list中。我们想要将这两段围墙每隔一个放置不同的样式，就需要做一些判断。我们将数字除以2，如果能除尽，就摆放其中一个，否则就摆放另一个。</p><pre><code>total = 10\nwall = []\nwhile total &gt; 0:\n    if total % 2 == 0:\n        wall.append(r_1)\n    else:\n        wall.append(r_2)\n    total-=1  \n\n</code></pre><p>这样，我们就将围墙的对象分割并且放入到了list里面，我们就可以在接下来的代码中使用这个list，来将围墙拼接出来。</p><p>在拼接之前，我们还要定义一系列的变量。现在我们已知这个图片的宽度是62，长度是195，所以我们需要增加的步长就是“每次拼接加62的宽度”。而围墙1和围墙2在拼接的过程中，是要往右上角倾斜的。经过测量，倾斜的高度是30，所以每增加一个围墙，就要往y轴减去30的高度，现在我们要定义初始化的x和y的起始位置，并且要定义增加步长的x值和y值，我们可以这么写：</p><pre><code>init_x = 0\n    init_y = 300\n    step_x = 62\n    step_y = -30\n</code></pre><p>我们要将这一系列变量放在循环中，因为每循环贴图一次，就需要重新初始化和计算步长，这样看上去就像把一系列墙一直贴在游戏中一样。</p><p>我们来看一下代码。</p><pre><code>for w in wall:\n        screen.blit(w, (init_x, init_y))\n        init_x += step_x\n        init_y += step_y\n</code></pre><p>这段代码的意思是，遍历wall这个list，取出下标并且赋值给w变量，每个w变量都是一个surface对象，这个对象通过screen.blit来贴上去，贴上去的位子使用初始x和初始y，然后初始x和初始y的位置又变化了，每次增加步长x和减去步长y，进行第二次的贴图，然后继续循环贴，这样我们的围墙就开始连贯了起来。</p><p>我们来看一下贴上去的效果。</p><p><img src="https://static001.geekbang.org/resource/image/5e/91/5e15bd7c6cff5c0ff0080090ae1cc391.jpg" alt=""></p><p>可以看到，每隔一段贴一幅图，另一段贴另一幅图，这样一整段的围墙就贴完了。一共有十幅图片，每一副图片的y值都向上减去30。</p><p>现在我们来总结一下贴这些连贯图片的重点：</p><ol>\n<li>\n<p>将内容放入列表或者数组中。为了编程方便，将需要连续贴图的内容放入列表或者数组中就能够减少编程工作量；</p>\n</li>\n<li>\n<p>计算好贴图的点，能让我们在连续贴图的过程中，只要控制位置变量就可以完成。</p>\n</li>\n</ol><p>如果我们编写的是地图编辑器，而地图编辑器生成的脚本代码，除非写得非常智能，一般来讲，就是一连串的贴图代码，这样就会有许许多多的blit的操作，并不会将相同的元素加入循环或者列表，那是因为脚本代码是电脑生成的，没有更多的优化代码。</p><p>接下来，我们要将一个人物放上去。这个人物只是摆设，我们只是为了测试图像遮挡的情况。</p><pre><code>player = \'human.png\'\nplr = pygame.image.load(player).convert_alpha()\n</code></pre><p>然后我们在循环的围墙贴图的代码之后，放入人物。</p><pre><code>screen.blit(plr, (62, 270))\n</code></pre><p>我们将人物故意放在围墙的某一个位置，效果看起来是这样的。</p><p><img src="https://static001.geekbang.org/resource/image/32/a4/32e01951e1b5d28ec1cd0a616b9019a4.jpg" alt=""></p><p>这样看上去，人物就站在围墙上面了。看起来他似乎有飞檐走壁的功夫，然而事实上，他应该几乎被围墙挡住，但是这个时候问题就来了。虽然我们可以把blit的代码放在显示围墙的blit代码之下，让围墙遮挡住人物，但是当游戏在进行的时候，人物要往下走，这时候就需要显示在围墙之外，我们不可能在游戏运行的时候改变代码，这是不可能做到的。所以我们还需要改变代码。</p><p>事实上，在正式的游戏开发中，我们需要将人物的控制、NPC的控制等放在不同的线程中去做，而地图则是直接载入地图数据文件。在地图的数据文件中会告诉你，哪些坐标是有物件挡住的，不能走；哪些坐标有哪些物件，你需要走过去的时候被遮挡。但是在我们今天的内容中，为了你能看得更明白，我们将地图和人物的代码都放在游戏的大循环中去做。</p><p>我们使用代码来模拟Z值的作用，虽然在代码中没有体现Z值，但是通过代码你可以理解Z值的意义。</p><p>首先我们来定义一个函数，这个函数将blit代码抽取出来，然后判断传入的参数是不是list类型，如果是的话，就连续贴图，否则就贴一张图。</p><pre><code>def blit_squences(data, x, y):\n    if isinstance(data, list):\n        for d in data:\n            screen.blit(d, (x, y))\n    else:\n        screen.blit(data, (x, y))  \n</code></pre><p>我们利用Python的isinstance函数，来判断传入的data是不是list类型。如果是的话，我们就遍历data，然后将data中的内容进行连续贴图。这是为了模拟我们除了贴人物，还要贴围墙。如果判断不是list类型的话，则直接贴上data。</p><p>然后，我们需要改变在游戏循环内的绘制图片代码。我们需要用blit_sequences函数来替代这块代码，然后我们在内部做一个判断，判断人物是不是和围墙的位置重叠了，如果是的话，就贴上人物和围墙。</p><pre><code>for w in wall:\n        if  init_y == 270:\n            blit_squences([plr, w], init_x, init_y)\n        else:\n            blit_squences(w, init_x, init_y)\n        init_x += step_x\n        init_y += step_y\n</code></pre><p>在这段代码中，我们看到，我们使用了blit_sequences这个函数，替代了原本的surface.blit代码。在这段代码中，我们需要判断一个位置，这个位置是围墙的y值，如果人物走到了这个位置，那么我们就将人物和围墙对象放入到blit_sequences中进行绘制。效果就是，人物被遮挡到了围墙外面。</p><p><img src="https://static001.geekbang.org/resource/image/5d/1f/5d4eb9552dce19be5a8b184fe347391f.jpg" alt=""></p><p>这段代码起作用的地方是在[plr, w]这部分。我告诉Pygame，要先绘制plr然后再绘制w，但是如果你换一个位置，就是先绘制w再绘制plr。</p><p>这一部分是示例代码，正式编写游戏的时候，其实是不太会这么写的。这是为了展示我们如何方便地切换绘制位置。其中，plr和w的list部分，事实上就是解释Z值所做的工作，如果plr的Z值高于w，那么就先绘制plr，否则就先绘制w。当然在正式编写类似的游戏的时候，我们需要考虑的是多线程，这些我们将在后续的内容中进行讲解。</p><p>一般的做法是，我们会在多线程中绘制人物，然后载入地图，我们会在人物走动的过程中，判断地图上的物件，然后进行Z值的调整，或许，Z值最高的是物件本身，比如围墙和建筑物的Z值是100，而人物的Z值一直保持在20，所以每次走到围墙和建筑物这里，总是先绘制人物，再绘制建筑物，这样就起到了遮挡的效果。</p><h2>小结</h2><p>这一节内容差不多了，我来总结一下。</p><p>我们其实就讲了一个内容。<span class="orange">在做遮挡的时候，要考虑绘制顺序，先绘制的一定会被后绘制的遮挡。</span></p><p>如果做得比较成熟的话，利用Python，我们需要在外面包裹一层字典。每个物件载入的时候，都告知其Z值，然后在绘制的时候，判断Z值，安排绘制顺序。</p><p>现在给你留一个小问题。</p><p>如果在绘制的过程中，两个人物的Z值相同的话，人物碰到一起，会出现什么结果呢？</p><p>欢迎留言说出你的看法。我在下一节的挑战中等你！</p>',
        article_title: "第11讲 | 如何设置图像的前后遮挡？",
      },
      {
        title: "第12讲 | 如何设置精灵的变形、放大和缩小？",
        id: 9847,
        content:
          '<p>上周四，我给你讲解了图片的遮挡问题。这一节我要和你讲精灵的变形、放大和缩小。如果之前没有做过游戏开发，你肯定会问，什么是精灵？</p><h2>什么是精灵？</h2><p>我先来解释一下什么是精灵。精灵当然不是我们传统意义上的什么树林里的精灵。精灵是一个游戏开发中的名词，英文叫Sprite。</p><blockquote>\n<p>它多用于游戏中的人物和可移动物品，也可以用于显示鼠标指针和输入的文字。如果屏幕上的可移动物体的尺寸比一个精灵图要大，可由若干个精灵图缩放或者拼接而成。</p>\n</blockquote><p>从<strong>宏观</strong>的概念讲，精灵就是一幅图片。比如我们之前中讲过的那些飞机图、背景图，这些都可以认为是精灵或者是从精灵中派生出来的。它就是一系列可以变化的图片。这些图片可以变形、放大、缩小，或者是一系列的动画帧等等。</p><p>从<strong>编程</strong>的角度讲，精灵是一种管理器。在一个精灵的管理器中，可能会有一系列的方法去操作精灵，比如添有加、删除操作，比如有图像的变形、放大、缩小操作，还有系列帧的显示操作等。</p><p>既然，精灵就是图片，那在“打飞机”中，飞机会随着画面的变化、操作的不同，而有变形、放大以及缩小的状态。我现在就来讲这些操作的实现，需要用到哪些函数，以及这背后都有什么技巧。</p><h2>设置变形、放大和缩小需要用到哪些函数？</h2><p>Pygame中的底层，使用的是SDL开发库，这个我们在之前的内容中已经讲过，因此，这些变形、放大缩小等操作，都有对应的SDL库。</p><!-- [[[read_end]]] --><p>我们要用到的还是之前的飞机图片，为了让你更明确的看清楚，我删除了背景，只呈现飞机的内容。</p><h3>翻转函数flip</h3><p>我们首先要用到的是<strong>函数flip</strong>。顾名思义，这个函数就是让你对图片进行翻转，你可以翻转成水平的或者垂直的。所以它拥有两个参数，一个是传入x，一个是传入y，并且都需要传入<strong>布尔值</strong>。如果传入x值为真，那就进行水平镜像翻转，如果y值为真，那就进行垂直镜像翻转，两个都为真，两方都进行翻转。这个函数会返回一个surface。</p><pre><code>pln_t = pygame.transform.flip(pln, 1, 1)\nscreen.blit(pln_t, (40, 350))\n</code></pre><p>我们看到的结果是这样：</p><p><img src="https://static001.geekbang.org/resource/image/96/2f/961af51b04e51d3ba802e44a1fd2382f.jpg" alt=""></p><p>原本飞机的头是朝上的，现在进行了水平和垂直的翻转。</p><h3>缩放函数scale</h3><p>我们再来看一下<strong>缩放的函数scale</strong>。scale的参数是这样：</p><pre><code>scale(Surface, (width, height), DestSurface =None)\n</code></pre><p>其中第一个参数是绘制对象，第二个参数是缩放大小，第三个参数一般不太使用，指的是目标对象。</p><pre><code>pln_t = pygame.transform.scale(pln, (220,220))\nscreen.blit(pln_t, (20, 150))\n</code></pre><p>我们在代码中，将pln这个对象放大到220×220（飞机原本大小为195×62），然后看一下效果。</p><p><img src="https://static001.geekbang.org/resource/image/78/66/78b91a5ea30d2eaa2c08fce1ca749b66.jpg" alt=""></p><p>你看，飞机变大了。我们再尝试修改一下代码。</p><pre><code>pln_t = pygame.transform.scale(pln, (20,20))  \n</code></pre><p><img src="https://static001.geekbang.org/resource/image/1b/58/1bd5885a91a0462e852ddcbc15132358.jpg" alt=""></p><p>飞机就变小了。所以，<strong>scale函数</strong>的作用是，<strong>只要你传入参数的width和height值大于原本精灵的长宽值，就变大，否则就变小。</strong></p><p>类似，我们还有一个<strong>函数scale2x</strong>，你只需要填入绘制对象即可，函数会帮你进行两倍扩大，不需要你计算原本的长宽值并且乘以2。</p><h3>旋转函数rotate</h3><p>我们再来看一下<strong>rotate旋转函数</strong>。它提供一个参数angle，也就是你需要旋转的角度，正负值都可以。</p><p>我们来看一下代码。</p><pre><code>pln_t = pygame.transform.rotate(pln, 20)\n</code></pre><p>我们看到的效果就像这样。</p><p><img src="https://static001.geekbang.org/resource/image/62/39/62704bbf6e240e17ade2a907a82d3939.jpg" alt=""></p><p>这样飞机就朝左侧旋转了20度。 相似的，也有整合的函数<strong>rotozoom</strong>。它该函数提供了旋转和扩大的功能。</p><p>如果代码这么写：</p><pre><code>pln_t = pygame.transform.rotozoom(pln, 20, 2)\n</code></pre><p>我们能看到的效果就是这样：</p><p><img src="https://static001.geekbang.org/resource/image/17/f0/1785173b9a5e6e4f149b1c3d9797dbf0.jpg" alt=""></p><h3>剪切函数chop</h3><p>接下来的是<strong>函数chop</strong>，这个函数提供了图像剪切的功能。我们需要传入一个绘制对象以及一个rect矩形，这样就可以将输入的矩形的内容剪切出来。</p><pre><code>pln_t = pygame.transform.chop(pln, [20,150,25,155])\n    screen.blit(pln_t, (20, 150))\n</code></pre><p>我们看一下代码的内容，我们在blit的时候，将pln_t放置在(20,150)的位置上，所以我们在chop的时候，将剪裁[20,150,25,155]这样一个矩形进行裁切。</p><p>然后我们来看一下效果。</p><p><img src="https://static001.geekbang.org/resource/image/d0/63/d06607b46aa22f6321edf7a76ee7ab63.jpg" alt=""><br>\n﻿﻿<br>\n这么多函数，是不是容易记不住？我来给这一部分做个总结：</p><p><strong><span class="orange">对于精灵的所有放大、缩小或者变换的函数，都在pygame.transform模块里。它提供了一系列2D精灵的变换操作，包括旋转角度、缩小放大、镜像、描边、切割等功能，让你很方便地能够在游戏中随心所欲地对处理2D精灵。</span></strong></p><h2>Pygame中的Sprite</h2><p>我们再来看一下Pygame本身，Pygame本身就提供有Sprite模块，Sprite模块提供了Sprite类，事实上，Pygame的精灵类最方便的功能就是将某些序列帧的图片，做成动画，并且保存在Sprite的组（group）里面。在Pygame里面，Sprite是一个轻量级的模块，我们需要做的是要将这个模块继承下来，并且重载某些方法。</p><h3>类explode</h3><p>我们现在有一副图片，效果是打击到某个点，开始爆开图案。</p><p><img src="https://static001.geekbang.org/resource/image/68/e5/68ee7fc3ef87a7fe6a471da3837626e5.jpg" alt=""></p><p>这幅图片一共三帧，是一个标准的精灵动画。那么我们需要做的，就是先将这幅图片导入到精灵类当中。我们做一个类explode：</p><pre><code>class explode(pygame.sprite.Sprite):    \n</code></pre><p>这个类继承自Sprite类，然后我们定义一个初始化函数，并且首先调用上层基类的初始化。</p><pre><code>  def __init__(self, target, frame, single_w, single_h, pos=(0,0)):\n        pygame.sprite.Sprite.__init__(self)\n</code></pre><p>在这个类当中，我们看到了函数的定义内容，第一个参数<strong>self</strong>，我就不过多解释了；<strong>target</strong>是我们需要载入的目标图片；<strong>frame</strong>是我们需要告诉这个类，我们这个动画有几帧；<strong>single_w, single_h</strong> 代表了我们每一帧动画的长宽。在这里，我们的每一格动画是262×262。<strong>pos</strong>是我们告诉屏幕，将这个动画放置在屏幕的什么位置。</p><p>接下来，这是我编写的初始化代码：</p><pre><code>def __init__(self, target, frame, single_w, single_h, pos=(0,0)):\n\n        pygame.sprite.Sprite.__init__(self)\n\n        self.image = pygame.image.load(target).convert_alpha()\n\n        self.main_image = self.image\n\n        self.frame = frame\n\n        self.rect = self.image.get_rect()\n\n        self.count = 0\n\n        self.single_w, self.single_h = single_w, single_h\n\n        self.rect.topleft = pos  \n</code></pre><p>大部分代码你应该都能理解，但是有几个点，我要特殊说明一下。</p><p>第一个是<strong>main_image</strong>。这个是保存主image图片。我们在后续的切换帧的时候，需要在main_image中切割后面几帧，并且呈现在屏幕上，这样就会在视觉效果中呈现动画效果。<strong>count</strong>是每一帧的当前计数。在这里我们一共拥有三帧，这三帧我们记录在self.frame里，是总的帧数。</p><h3>重载函数update</h3><p>接下来，我们来看一下update代码。</p><pre><code> def update(self):\n\n        if self.count &lt; self.frame-1:\n\n            self.count += 1\n\n        else:\n\n            self.count = 0\n\n        self.image = self.main_image.subsurface([self.count*self.single_w, 0, self.single_w,self.single_h])\n</code></pre><p><strong>Update</strong>是一个重载函数。事实上，在update函数里，需要判断帧数、当前循环的计数等等。但是，为了能让你能更直观容易地感受代码做了什么内容，所以我直接使用self.count来做帧数的计数。</p><p>进入函数后，我们使用self.count来和self.frame的总帧数进行对比。如果帧数不足以切换，那就加1，否则就置为0。判断结束后，我们就将image变成下一帧的内容。</p><p>其中，subsurface的意思是传入一个rect值，并且将这个值的surface对象复制给image对象，并且呈现出来。</p><p>这时候，我们需要将这些内容放入到group中。</p><pre><code>exp = explode(\'explode.png\', 3, 262,262, (100,100))\ngroup = pygame.sprite.Group()\ngroup.add(exp)\n</code></pre><p>首先，exp就是我们定义的explode类的对象，我们分别传入的内容是图片、帧数、单个帧的宽度、单个帧的高度，并且将这个精灵显示在屏幕的位置。</p><p>随后，我们定义一个叫作group的对象，并且将exp对象填入group中。随后，我们在大循环内，写一串代码。</p><pre><code>group.update()\n    group.draw(screen)\n</code></pre><p>这个update，调用的就是<strong>exp.update函数</strong>。draw就是在screen中绘制我们填入group中的内容。由于动画在文章中无法显示，所以我就不将图片放入到文章中来了。</p><p>在精灵类中，我们除了动画的呈现，还有碰撞效果的制作。这属于更为复杂的层面，后续的内容，我将会用简单的方式来呈现碰撞的实现。</p><p>当然，Sprite类还有更为高阶的用法，除了碰撞，还有Layer（层）的概念。group的添加精灵，事实上是没有次序概念的，所以哪个精灵在前，哪个在后是不清楚的，到了这个时候，你可以使用OrderUpdates、LayerUpdates这些类，其中LayerUpdates拥有众多方法可以调用，这样就会有分层的概念。</p><h2>小结</h2><p>这一节，你需要记住这几个重点。</p><ul>\n<li>\n<p>精灵的变形、缩放以及pygame中关于精灵类的一些简单的操作。</p>\n</li>\n<li>\n<p>你可以直观地感受到，精灵类和group类配合起来使用是一件很方便的事情，也就是说，我们忽略了blit的这些方法，直接在group中，进行update和draw就可以一次性做完很多的工作。</p>\n</li>\n<li>\n<p>如果我们单独编写精灵的序列帧动画函数，也不是不行，但是你可能需要编写相当多的代码来代替Sprite和group类的工作。</p>\n</li>\n</ul><p>现在留一个小问题给你。</p><p>结合精灵的变形、放大和缩小，再结合Pygame精灵类的内容，要在update重载函数里绘制动画帧效果，并且不停地放大、缩小，该怎么实现呢？</p><p>欢迎留言说出你的看法。我在下一节的挑战中等你！</p>',
        article_title: "第12讲 | 如何设置精灵的变形、放大和缩小？",
      },
      {
        title: "第13讲 | 如何设置淡入淡出和碰撞检测？",
        id: 9922,
        content:
          '<p>我们在前一节，学习了精灵的变形、放大和缩小，并且学习了如何使用精灵类和组的概念来管理精灵，制成动画。今天，我将带你学习淡入淡出和碰撞热点的判断。</p><p>所谓的<strong>淡入淡出</strong>，就是英文的<strong>fade-in</strong>和<strong>fade-out</strong>。淡入淡出在电影、游戏、CG、操作系统、手机UI、应用等等各种地方随处可见。那究竟什么是淡入淡出呢？它在游戏中究竟如何实现呢？在我们的打飞机游戏中，什么时候会用到这个操作呢？</p><h2>什么是淡入淡出？</h2><p>不知道你有没有注意，在我们玩过的打飞机游戏中，当每一关游戏开始的时候，都会有个游戏画面逐渐出现的过程。短短几秒，从无到有，整个画面就呈现在你眼前了。同样，每一关结束的时候，也会有个画面逐渐消失的过程。</p><p>从<strong>画面效果</strong>讲，这个画面从有到逐渐屏幕变暗，直到消失，或者反过来，由暗逐渐变亮，到完全进入画面的过程，就叫做淡入淡出。从<strong>声音</strong>角度讲，也存在淡入淡出，比如音乐从无声到逐渐有声，或者从有声到逐渐无声。</p><p><strong>在Pygame中并不存在“画面的淡入淡出”这样的函数，需要我们自己去实现这样的功能。</strong></p><p>首先，如果我们想给这张图片进行淡入淡出的处理的话，就需要对它进行alpha混合处理。我们在前面谈到过alpha混合，你可以理解成半透明，但是alpha混合究竟是什么呢？</p><!-- [[[read_end]]] --><p><strong>alpha混合</strong>就是将一部分被遮盖的图像进行半透明处理。在游戏引擎或者游戏库中，图像的alpha值是可以被修改的。每动态修改一次alpha值，就会让图像更透明或者更不透明。通过制作出alpha效果，我们可以在游戏中实现各种绚丽的效果。</p><p>一般来讲，底层图形接口的颜色为32位的值，包含RGB以及A（alpha），其中红色R、绿色G和蓝色B各为8位，alpha也为8位，所以合起来是32位的颜色值。</p><p>但是如果不存在A通道，那么就是24位的颜色值。每个颜色值都有256个级别的值，从程序角度是从0到255，而支持alpha通道的图片格式有png、tiff等。但是如果没有带alpha透明通道的图，我们也可以在程序中设置它的alpha值来做透明。</p><p>如果是Pygame，在load image函数的时候，不要处理alpha，也就是不要调用convert_alpha函数。具体为什么呢？我后面给你揭晓。</p><h2>如何做出淡入淡出效果？</h2><p>我们在没有背景图片载入的时候，做淡入淡出效果，就不是使用alpha通道了，而是需要用<strong>fill函数</strong>来填充背景色。</p><p>如果背景色是（0,0,0），也就是纯黑的话，那么就需要将（0,0,0）逐渐变成（255,255,255）来变成纯白，或者你自己定义一个RGB值来完成最终淡出后的背景色。</p><p>我们现在来看一下这段代码。</p><pre><code>pln = pygame.image.load(plane).convert()\na=0\nwhile True：\npln.set_alpha(a)\nscreen.blit(pln, (20, 150))\nif a &gt; 255:\n    a=0\nscreen.fill([a,a,a])\na += 1\n</code></pre><p>这段代码中，我们开始载入飞机图片。注意一下，我们没有用convert_alpha。如果我们用了convert_alpha，就会出现设置的alpha值没有任何作用。因为，在载入的时候，已经处理了alpha值了。</p><p>随后，我们定义一个变量a，这个a既作用在screen.fill上，将fill的RGB值进行变换，也作用在set_alpha这个函数里，这个函数将图片的surface进行alpha值的设置，最后blit出来，呈现在屏幕上。</p><p>我们呈现的效果就是这样。</p><p><img src="https://static001.geekbang.org/resource/image/2b/1c/2b6bc9023c281fa5ae7f44bbe51ef01c.jpg" alt=""></p><p>其他图片也可以做alpha混合，我们将最早的背景jpg图片传入，进行alpha半透明调整，效果是这样的。</p><p><img src="https://static001.geekbang.org/resource/image/9c/ac/9c71cf0a87d6ebb9c2fd6e7f323d09ac.jpg" alt=""></p><h2>如何设置碰撞检测？</h2><p>说完了alpha混合，我们现在要来学习一下碰撞相关的内容。这个很好理解，飞机相撞了，就要用到碰撞。</p><p>事实上，在游戏中，碰撞属于物理引擎的一部分。特别是在3D游戏当中，物理引擎是独立于图形引擎的一个模块。程序员需要将图形引擎的对象填入到物理引擎中，计算出碰撞的结果，然后再返回给图形引擎，给出画面效果。做得精致的2D游戏也有独立的物理引擎，专门检测碰撞、计算重力等等。</p><p>但是在今天我们的课程中，我将使用浅显易懂，用你最能看懂的代码来解释碰撞是怎么回事。</p><p><strong>事实上，我们今天要讲到的碰撞是两个图片相交之间的碰撞检测，这并不算物理检测，而是图片检测。</strong></p><p>既然我们要检测的是图片，那么哪些前置信息是我们需要知道的呢？</p><p>首先，我们肯定要知道这两张需要碰撞图片的长宽，才能计算图片是否相交。在计算图片相交的时候，我们首先要知道它<strong>所在位置的x轴的起点</strong>，然后要知道它的<strong>图片宽度</strong>，然后我们要知道<strong>图片位置的y起点</strong>，以及它的<strong>图片长度</strong>，这样我们就得到了图片的长宽。</p><p>我们用上面的主角飞机图片和敌人飞机图片来做演示。</p><p><img src="https://static001.geekbang.org/resource/image/86/68/861154a6a7403ef7113c259f65425d68.jpg" alt=""></p><p>让两架飞机面对面，敌人的飞机从上往下飞，主角飞机从下往上飞。如果两架飞机碰到，我将在后台的命令行窗口显示一些字符串。</p><h3>定义碰撞函数</h3><p>接下来，我们来看一下，如何定义这个碰撞函数。</p><pre><code>def collide(a, axy,  b, bxy):\n    a_x1, a_x2 = axy[0], axy[0]+a.get_width()\n    a_y1, a_y2 = axy[1], axy[1]+a.get_height()\n    b_x1, b_x2 = bxy[0], bxy[0]+b.get_width()\n    b_y1, b_y2 = bxy[1], bxy[1]+b.get_height()\n    a1, a2 = range(a_x1, a_x2) , range(a_y1, a_y2)\n    b1, b2 = range(b_x1, b_x2) , range(b_y1, b_y2) \n\n    ct = 0\n    for a in a1:\n        if a in b1:\n            ct = 1\n            break\n    for a in a2:\n        if a in b2:\n            if ct == 1:\n                return True\n    return False\n</code></pre><p>我们来仔细地看一下这段函数。</p><p>首先，<strong>collide函数</strong>拥有四个参数。第一个参数是第一幅图片的对象，第二个参数接收一个元组，接收第一幅图片所在的x轴和y轴，第三个参数是第二幅图片的对象，第四个参数接收一个元组，接收第二幅图片所在的x轴和y轴。</p><p>随后，代码进入一个<strong>得到长宽</strong>的过程。</p><p>a_x1获取a图片对象所在屏幕的x点的起始位置，这个位置由第二个参数的元组下标0提供，a_x2获取a图片对象所在屏幕的x点的终止位置（事实上是它的宽度），由于有x轴的起始坐标的关系，所以需要起始坐标加上图片宽度，才是它真实的x坐标结束点。</p><p>a_y2获取a图片对象所在屏幕的y点的起始位置，这个由第二个参数的元组下标1提供，a_y2获取a图片对象所在屏幕y点的终止位置，其实是它的长度，和前面的x轴一样，需要加上y轴所在屏幕的位置，才是真正的y轴的结束点。</p><p>和a图片是一个道理，b图片我就不作具体阐述了。</p><p>接下来，我们需要知道整个图片所在的屏幕点，那么我们就需要用到<strong>range函数</strong>。</p><p>Python的range函数，是自动形成的一串整数列表。它的函数原型是这样的。</p><pre><code>range(start, stop, [step])\n</code></pre><p>其中步长step可以省略。因为默认是1，所以如果在range中输入了开始和结束，就会形成一个列表。如果省略了stop，就会从0开始计数，形成一串列表。比如range(5)，那就会形成0，1，2，3，4。</p><p>我们在range中形成了一串列表，其中a1对应的是，a图片x值的起始点到终止点的列表，a2对应的是a图片y值的起始点到终止点的列表。接下来的b1和b2就不做阐述了，和a1是相同的代码逻辑。</p><h3>碰撞的检测</h3><p>随后，我们就需要进行碰撞的检测了。</p><p>首先，我们先要判断a图片x轴的列表数字里面，是不是存在b图片的x轴的数字。如果存在，那么就把计数加1，跳出循环。</p><p>接下来，我们再判断a图片的y轴的列表数字里面，是不是存在b图片的y轴的数字。如果存在，那么就返回为真（True），就说明碰撞检测成功了。如果计数等于0或者计数等于1但是并没有通过y轴的列表检测，那么就返回假（False）。</p><p>我们来看一下传入参数的代码。</p><pre><code>y1, y2 = 1, 1\n  screen.blit(pln, (100, 300 + y1))\n  screen.blit(enm, (100, 20 + y2))\n  print collide(pln, (100,300+y1), enm, (100,20+y2))\n  y1-=1\n  y2+=1 \n</code></pre><p>我们在blit绘制的时候，y轴加入了一个变量，就是y1和y2。其中主角的飞机pln对象，y轴始终减1，敌人的飞机enm，始终加1，为的就是让两架飞机对向飞过来并且检测碰撞。</p><p>我们将pln和 enm以及它们所在的位置，分别传入collide函数，进行检测。我们将在命令行后台打印True或者False。如果是False就是没有碰撞，如果是True就是碰撞了。</p><p><img src="https://static001.geekbang.org/resource/image/bb/35/bbc8171fa91b1cc49bede8ba38f2ea35.jpg" alt=""></p><p>当两架飞机碰到的时候，True就出现了，那是因为x轴和y轴都有不同程度的重叠。所以在collide函数里面，就返回了True。</p><p>另外，在Pygame里，精灵类当中也有碰撞检测的类可以提供使用，但是，<strong>使用碰撞检测类可以用来进行球形的判断，而不能用于矩形图片之间的判断</strong>。 这是更为高级和复杂的用法，在这里不做更深的阐述了。</p><h2>小结</h2><p><span class="orange">今天，我和你讲解了淡入淡出以及碰撞的热点检测。我们需要设置Alpha混合和背景填充，来实现淡入淡出，而普通图像碰撞的检测，则是通过判断图像x轴和y轴是否重叠来实现。</span></p><p>给你留个小问题吧。</p><p>如果给你一张图片，需要判断精准的碰撞，比如碰到机翼，或者碰到某一个非矩形的位置，你该如何判断碰撞结果？</p><p>欢迎留言说出你的看法。我在下一节的挑战中等你！</p>',
        article_title: "第13讲 | 如何设置淡入淡出和碰撞检测？",
      },
      {
        title: "第14讲 | 如何制作游戏资源包和保存机制？",
        id: 10106,
        content:
          "<p>我们要做一款打飞机游戏，里面有飞机图片、背景图片、飞机音效、碰撞音效等等非常多的素材。如果将这些资源都放置在一个目录下，将会变得非常混乱。如果按照素材内容来划分目录，程序读取的效率就不高，所以我们需要将这些素材打包在一个资源包内，然后将每个素材都放置在一个虚拟目录内。</p><p>因此，今天我们就来如何制作讲解资源包。简单来说，所谓的资源包，就是将游戏的所有资源和素材，进行打包分类，并且进行资源整合，亦或将资源和素材进行压缩，减少游戏体积。</p><h2>什么是资源包？</h2><p>我总结了一下，可以从这三个角度来理解什么是资源包。</p><ul>\n<li>\n<p>资源包是一种将游戏的资源和素材进行分类、梳理，并且打包的一种包裹。</p>\n</li>\n<li>\n<p>资源包可以用来压缩游戏资源和素材，减少游戏体积。</p>\n</li>\n<li>\n<p>资源包里存在任何可能性，比如它可以包含图片文件、模型文件、音频文件、脚本文件等等，具体要看游戏开发人员的配置需求，来决定资源包里的内容。</p>\n</li>\n</ul><p>现在很多游戏公司都不会编写特殊的资源包格式。因为设计一种资源包格式，需要经过一系列复杂的动作，包括包头、包身和包尾。</p><p>关于这个格式的设计，一会儿我会给你仔细分析。因为，和我们自定义网络协议包一样，一个好的资源包，能够很方便进行解包、打包、删除文件、插入文件的操作，以及游戏的在线更新、补丁更新、资源包的解包、打包、删除、插入、更新文件等操作。</p><!-- [[[read_end]]] --><p>而一个好的资源包格式，不会占用主程序大量的时间。因为在游戏中，需要直接读取包文件里面的内容。</p><p>比如我们之前在Pygame中读取的图片文件，在包裹格式中，可能会这么写伪代码：</p><pre><code>load.image(‘package.pack/plane.png’)    \n</code></pre><p>其中package.pack就是包裹，plane.png是存在在包裹里面的其中一幅图片文件。这样，打了包裹后的文件，就不会污染目录。一般一个包裹文件中存在大量资源，而我们只要按照包裹路径读取就可以了。</p><p>如果不编写特殊的资源包格式，那应该怎么制作资源包呢？答案是，<strong>使用现成的压缩软件库，进行打包压缩，直接在程序内使用</strong>。比如我们最常用的zip文件、rar文件，都是可以拿来做资源包文件的。在Python中有内置zip模块，可以直接读取zip文件。我们可以直接在Pygame中结合zip模块进行编程。</p><h2>资源包的格式</h2><p>我们要讲解的是资源包的制作，我将会用一种较为通用和简单易懂的方法，解释资源包都包含哪些内容，同时让你理解资源包是怎么制作的。</p><p>首先，从编程的格式来理解资源包，你需要了解下列这些内容。</p><ul>\n<li>\n<p><strong>资源包头</strong>，是一种标记，存放在包裹里最开始的几个字节，一般是2～4个字节。资源包头可以用来辨别这个资源包是哪个公司出品的。例如我后面准备举的一个例子，这里面就有INFO这样的标记，INFO可能是这家游戏公司的名字或者是缩写等等。</p>\n</li>\n<li>\n<p><strong>资源包版本</strong>，这个不是必须的。如果考虑到一款游戏各个版本之间变化很大，未来可能会修改资源包的格式，那么这个时候就需要版本号。版本号一般会使用2个字节的short类型来存储，或者直接用十六进制编辑器能看明白的字符串，来代表版本号，比如用10表示1.0。所以，结合资源包头，我们现在所看到的结构是INFO10。</p>\n</li>\n<li>\n<p><strong>资源包是否进行压缩</strong>，这个也不是必需的，但是有一些资源包会说明白，究竟是不是压缩资源包。如果是压缩就是1，不是压缩就是0。至于压缩格式，一般在编程的时候，就会指定清楚，不需要特别说明在资源包内。</p>\n</li>\n<li>\n<p><strong>资源包的目录结构以及素材名文件名偏移量</strong>，资源包内的目录结构都是虚拟的，所以你可以定义在资源包内类似于/game/res这样的目录结构。但是事实上，这只是方便程序调用，事实上目录是不存在的，这是一种只存在在包裹内的虚拟目录。</p>\n</li>\n</ul><p>然后，我们需要规定素材的<strong>文件名</strong>和<strong>偏移量</strong>。比如/game/res/background.jpg。这是告诉我们在/game/res虚拟目录下，拥有background.jpg这个文件。随后需要告诉程序偏移量是多少，一般是存储4个字节的整型数字。</p><p>到目前为止，资源包的格式看起来可能是这样的：</p><pre><code>INFO100/game/res/background.jpg,[四个字节的偏移量]\n</code></pre><p>在这里，我们看到，偏移量之前多加了一个逗号“,”。这是一个<strong>分隔符</strong>，也就是告诉程序，这一段在哪里结束。</p><p>随后是四个字节的偏移量。所谓的<strong>偏移量</strong>，就是告诉程序，你要到这个包裹的第几个字节去寻找这个文件的具体内容。</p><ul>\n<li>\n<p><strong>资源包的素材本体</strong>。每个本体都可能是一个二进制文件、文本文件或其他任何文件。这些文件的文件名在资源包的素材文件名中都被定义好了。在资源包的素材本体中，我们可能会碰到各种各样的二进制字符，那么我们怎么知道这些素材是从哪里开始哪里结束的呢？</p>\n</li>\n<li>\n<p><strong>资源包的素材长度</strong>，规定素材的长度有两种方法，<strong>一种方法</strong>是在定义资源包的目录结构以及素材偏移量的时候，再加上一个素材长度，也是四个字节的整型数字。这种方法的好处是，不需要添加某个分隔符告诉程序，这个素材的本体到这里结束。<strong>第二种方法</strong>是在本体结束的位置添加分隔符，比如一个逗号或者分隔符号|。这种方法的好处是，不需要知道文件长度是多少。但是坏处是，分割符号可能会和素材本体重叠。</p>\n</li>\n</ul><p>比如素材的本体是个二进制文件，分隔符比如是!@#$，素材的本体里面也存在!@#$这样的内容，这样的情况下，就会出现读取中断，因为程序以为素材内的!@#$就是结束符号，事实上这只是素材本身的内容而已。</p><ul>\n<li><strong>资源包结束符</strong>，这个也不是必须的。我们要结束资源包，必须在资源包的结尾添加结束符，这个结束符是告诉程序，资源包已经结束了。</li>\n</ul><p>我们来看一个完整的资源包，大概是什么样子的。</p><pre><code>[资源包头][版本号][是否压缩][资源包目录/素材文件名A][文件A偏移量][文件A长度]…[资源包目录/素材文件名N][文件N偏移量][文件N长度][素材A本体]….[素材N本体][结束符]\n</code></pre><p>了解了资源包的格式内容，我们可以很方便地利用Python或者C语言等来编写相应格式的资源包。</p><p>我来给这部分做一个总结：</p><p>资源包的存在，有两个目的，一是让游戏目录干净整洁，不然看上去都是乱七八糟的图片和各种配置，二是让游戏程序能更快地从内存中读取游戏资源制作的包裹文件，加速游戏的运行效率。这个包裹文件中含有虚拟目录、资源、资源位置、资源名字等等信息。我们不需要从文件目录中去读取单一文件，只需要从内存中载入的资源包中取出某个文件即可。</p><h2>如何制作游戏的保存机制？</h2><p>每一个游戏几乎都有保存和载入的机制。首先你需要知道，只有保存了数据，我们才能载入数据。那么游戏的保存机制是怎么做的呢？</p><p>事实上，游戏的保存和游戏的地图编辑器中保存地图的原理，可以说是异曲同工。如果一个游戏中，有地图、坐标、人物、装备、分数，这些都需要被记录下来，那么我们不可能将地图、坐标、人物、装备、分数等全部转换成二进制文件记录下来。那应该怎么做呢？</p><p>首先，如果是记录地图，有地图1或者地图2，我们只需要记录地图的ID就好了。假如是地图2，坐标是（x，y）。人物只需要记录人物的ID，再关联到人物。一个游戏中，玩家建立了一个人物角色，就会将这个人物角色进行保存，不至于丢失人物角色。所以，在读取游戏的时候，需要先读取人物角色，再读取保存的游戏内容。</p><p>至于分数就很好记录了，记录分数其实就是记录数字，所以记录起来会很方便。</p><p>那么装备呢？如果是装备，一般会将装备的所有内容记录下来，如果做得精致的游戏，还会将地图中那些掉落的装备和死去的NPC进行记录。</p><p>还有一种做法是，将游戏保存的文件直接导出成一个脚本文件，以后每次读取数据就只需要使用程序读取脚本就可以了。</p><h2>小结</h2><p>今天我讲解了资源包的制作以及游戏进度的保存，你需要你记住这些内容。</p><ul>\n<li>制作资源包的目的是为了厘清游戏素材以及游戏素材的存放结构。资源包的结构与压缩包的结构比较相似，但是为了更贴合游戏程序读取，会对虚拟目录和素材文件名等，做一些修改。</li>\n<li>另外，为了方便保存游戏进度，我们可以做成游戏脚本，第二次打开游戏直接载入保存的脚本即可。</li>\n</ul><p>给你留一个小思考题吧。</p><p>在《GTA》中，汽车会有不同程度的损毁，当你保存完游戏重新进入的时候，汽车又复原了，请问这是为什么呢？</p><p>欢迎留言说出你的看法。我在下一节的挑战中等你！</p>",
        article_title: "第14讲 | 如何制作游戏资源包和保存机制？",
      },
      {
        title: "第15讲 | 如何载入背景音乐和音效？",
        id: 10112,
        content:
          '<p>好的音乐总是伴随着游戏一起，一直被玩家所记忆。在游戏中播放音乐和音效并不是什么困难的事情，但是究竟什么时候播放什么音效，具体怎么实现，这恐怕就需要一些技巧了。比如，我今天要讲的，我们可以和某些函数捆绑在一起实现。</p><p>Pygame支持mp3、ogg、wav音频和音效的播放。音乐的模块都在pygame.mixer中，这里面包括音乐和音效。</p><p>我们在使用音频部分模块的时候，需要先初始化一次。</p><pre><code>pygame.mixer.init()\n</code></pre><p>这个初始化应该在pygame.init()的初始化之后。</p><p>我们来看一下具体的函数，这些函数，存在在pygame.mixer.Sound模块下。</p><p><img src="https://static001.geekbang.org/resource/image/29/4d/299c0650d736f939189c49b32eb2b54d.jpg" alt=""></p><p>我们再来看一下Pygame.mixer.music音乐模块。我们可以尝试一下载入音频并且播放。</p><pre><code>pygame.mixer.music.load(\'bgm.mp3\')\npygame.mixer.music.set_volume(0.5)\npygame.mixer.music.play()\ns1 = pygame.mixer.Sound(\'a.wav\') \ns1.set_volume(0.5)\ns2 = pygame.mixer.Sound(\'b.wav\')\ns2.set_volume(0.5)\n</code></pre><p>我来解释一下这段代码。</p><p>刚开始，我们载入了一个名叫bgm的mp3文件，告诉程序需要载入这个文件，然后调整音量到0.5，随后就是play，也就是播放，播放是在程序的后台播放，然后程序会接着跑到下面的代码行。</p><p>随后，我们使用Sound模块，Sound模块初始化会载入a.wav，然后返回一个对象，这个对象设置音量为0.5，随后再初始化一次，载入b.wav，然后设置音量为0.5。</p><!-- [[[read_end]]] --><p>到这里为止，我们已经将所有的初始化、设置都在游戏的循环外做好了。</p><p>随后，我们需要结合前几节的内容，在循环里面，对飞机碰撞进行声音的操作，比如出现爆炸声的时候，播放什么声音；碰撞结束，播放另一种的声音。</p><pre><code>if True == collide(pln, (100,300+y1), enm, (100,20+y2)):\ns1.play()\nelse:\n  s2.play()\nfor event in pygame.event.get():\n   if event.type == QUIT:\n     pygame.quit()\n   if event.type == KEYDOWN:\n     if event.key == K_p:\n       pygame.mixer.music.pause()\n     if event.key == K_r:\n       pygame.mixer.music.unpause()\n</code></pre><p>首先，我们使用<strong>collide函数</strong>。这在前面几章有过详细的说明。</p><p>这是一段检测飞机碰撞的代码，如果飞机碰撞了的话，就会返回True，如果返回True的话，我们就播放s1音频，否则就播放s2音频。当然，这个s2音频可能会一直在播放（因为一直没有碰撞）。</p><p>随后就是<strong>事件监测</strong>，如果检测到K_p，就是按下键盘p，就让音乐停止，使用pause函数；如果按下r键，就恢复播放。</p><p>我们在Pygame上的操作已经基本结束了，但是，音频和音效的内容并没有结束。</p><p>在游戏编程中，我们需要嵌入音频和音效，特别是在没有Pygame的时候，如果有一些游戏引擎没有提供音频库的话，我们就需要自己使用第三方的音频库。虽然可以使用耳熟能详的ffmpeg，但是感觉有点大材小用了，所以我们需要一个专门的音频库。</p><p>在这里，我推荐<strong>BASS音频库</strong>。你可以去 <a href="http://www.un4seen.com">http://www.un4seen.com</a> 下载开发库。这个音频库是不开源的，如果你只是自己开发游戏玩玩，非商业目的，就可以使用。如果是商业使用，那就需要购买证书。</p><p><img src="https://static001.geekbang.org/resource/image/90/e2/9022635f73854d8b464a188c585ee6e2.jpg" alt=""></p><p>在这个页面上，我们点击download按钮，就会下载最新版本的开发库。解压缩下来，会出现对应几个语言的开发目录。</p><p>其中bass.dll文件是动态链接库，要使用的话，可以在c文件夹下，使用lib库和bass.h进行头文件包含进行编程。</p><p>我们来看一下，如何使用C/C++语言加入Bass引擎的代码。</p><pre><code>BASS_Init(-1, 44100, 0, hwnd, NULL);\nHSTREAM s = BASS_StreamCreateFile(false, &quot;a.mp3&quot;, 0, 0, 0);\nBASS_ChannelPlay(s, false);\nBASS_StreamFree(s)\n</code></pre><p>首先，我们将 BASS 库初始化，初始化的参数是：设备、输出比率、标志位（比如8位音质、立体声、3D等等）、Windows句柄。你也可以输入0。最后一个是clsid，就是用于初始化DirectSound的类的ID，一般会使用NULL。</p><p>随后，开始从文件建立一个流，BASS_StreamCreateFile函数，返回一个HSTREAM。HSTREAM其实是一个DWORD类型。</p><p>这个函数里的参数，我也解释一下。</p><ul>\n<li>\n<p>第一个参数是内存。如果传入true的话，就将这个流保存在内存中；否则的话，就不保存在内存中。</p>\n</li>\n<li>\n<p>第二个参数是音频文件名。这个参数和第一个参数会联动。当第一个参数保存在内存中的时候，就填入内存地址，否则就填入文件名。</p>\n</li>\n<li>\n<p>第三个参数是偏移量，也就是文件从哪里开始播放。当然这个参数只在第一个参数为false，不保存在内存的情况下起作用。</p>\n</li>\n<li>\n<p>第四个参数是长度，如果填入0，就是所有长度。</p>\n</li>\n<li>\n<p>最后一个是标志位，填入的是创建模式，比如是循环播放方式，还是软件解码模式等等。</p>\n</li>\n</ul><p>接下来就是开始播放，第一个填入的是刚才返回的流的句柄，第二个参数是是否重新开始播放。最后一个就是播放完后进行回收资源，删除句柄。</p><pre><code>float v; DWORD r;\nBASS_SetConfig(BASS_CONFIG_GVOL_STREAM, 100);\nv = BASS_GetVolume();\nv = 200;\nBASS_SetVolume(v);\nr = BASS_ChannelIsActive(s);\nif(r == BASS_ACTIVE_PAUSED)\n...\nelse if(r == BASS_ACTIVE_PLAYING)\n...\nelse if(r == BASS_ACTIVE_STOPPED)\n...\nelse if (r == BASS_ACTIVE_STALLED)\n  ..\n</code></pre><p>接下来就是调整音量以及获取播放的状态功能。</p><p>其中BASS_SetConfig中，第一个参数是选项，第二个参数是调整音量的值，BASS_CONFIG_GVOL_STREAM的意义是全局的流的音量。</p><p>随后我们就开始取得音量，BASS_GetVolume是获取系统的音量，并不是流的音量，第五行代码就是设置系统音量。</p><p>接下来，我们就要获取播放的状态。在BASS_ChannelIsActive的函数内填入流的句柄，随后获取返回值，然后使用返回值进行比较，其中BASS_ACTIVE_PAUSED，就是播放状态暂停，BASS_ACTIVE_PLAYING是正在播放中或者录音状态，BASS_ACTIVE_STOPPED是停止状态，或者流句柄并不是有效的，BASS_ACTIVE_STALLED是停滞状态。</p><p>一般的原因是，播放的状态缺少样本数据，流的播放停滞了，如果数据足够播放的话，就会自动恢复。</p><p>BASS库还有许许多多的函数和功能，就不在这里过多阐述了。</p><h2>小结</h2><p>我来总结一下。今天我们讲解了Pygame中音频和音效的播放。你应该记住这些东西。</p><ul>\n<li>\n<p>在Pygame中，播放音乐是不需要进行多线程控制的。它本身就会在后台进行播放。</p>\n</li>\n<li>\n<p>所有的音乐和音效都在pygame.mixer模块中，如果载入的是音乐，就使用music模块；如果载入的是音效，就使用Sound模块。</p>\n</li>\n<li>\n<p>随后我们介绍了BASS音频库。这几乎是最专业的音频库了。由于是C接口，所以通用多种语言，你可以使用.NET或者VB等语言来应用。当然如果要进行后台播放、多个频道播放等功能，你需要编写多线程的代码，并没有Pygame那么轻松，这里面很多事情需要自己去做。</p>\n</li>\n</ul><p>现在给你留一个小问题。</p><p>在pygame.mixer.music模块中，如何播放一首音乐后立刻播放另外一首音乐？</p><p>欢迎留言说出你的看法。我在下一节的挑战中等你！</p>',
        article_title: "第15讲 | 如何载入背景音乐和音效？",
      },
    ],
  },
  {
    chapterTitle: "第三章：UI和键盘鼠标",
    children: [
      {
        title: "第16讲 | 如何在游戏中载入UI和菜单？",
        id: 10436,
        content:
          '<p>今天我们要在游戏中载入UI和菜单，在开始之前，我们先调整一下，我们之前讲过的游戏代码部分的内容。</p><p>首先我们需要更改游戏的背景图片，使之看起来更像是一款打飞机的游戏，而不是最早之前我们随便用的一幅山水图。我们先将游戏背景修改为正常的游戏背景，并且贴上飞机图像。</p><p><img src="https://static001.geekbang.org/resource/image/3c/2c/3cbd72b8968c23eaeb57737a9393072c.jpg" alt=""></p><p>这里，我想到一个问题，之前有人留言问我，程序员需不需要有美术功底。我在这里说一下我的看法。如果你只是要做一个程序员，那我可以告诉你，不需要。但是，如果你不是只想做一个“码农”，你想有更多的发展，那各方面的知识，比如策划、美术，你都需要去了解。</p><h2>UI的两种呈现形式</h2><p>言归正传，我们需要在这个游戏画面上面，加一系列的内容来代表UI的呈现。UI的呈现有两种形式：</p><ul>\n<li>第一种就是美术画好UI图片，然后直接贴图，用鼠标控制一系列的点击和按下操作；</li>\n<li>另外一种是自己画UI界面，比如画一个框，并且在框里面写上文字。</li>\n</ul><p>这两种方式各有利弊。</p><p>如果使用美术UI图贴图的方式，<strong>优点</strong>就是可以减少程序员的工作量。这样在版本迭代的时候，美术改一幅图就可以修改界面，方便快捷，你就不需要做多余的工作。但是这样的<strong>缺点</strong>就是，增加了游戏安装包的大小，毕竟UI是一幅图，只要是图就会有一定的体积，就会增加安装包的大小。</p><!-- [[[read_end]]] --><p>如果是程序员自己绘制的UI界面，<strong>好处</strong>就是主程序体积变得稍大一点，而游戏安装包不会变大。但是这样的<strong>缺点</strong>也很明显，就是程序员的工作量会增加很多。而且当游戏需要迭代的时候，或者界面需要更新的时候，程序员需要重新绘制或者重新编写UI源代码，大大增加了工作量。</p><p>我们现在是自己来开发，那我就讲一讲程序员绘制UI的方法。</p><p>我们通过模拟按钮的方式来摆放UI界面。<span class="orange">首先，我们要在UI界面上摆放一系列字符，我们要实现的效果是，只要使用鼠标点击到这个字符，就会变换字符的内容。</span>这个过程，我们会用到鼠标操作、绘制矩形、字体和字符绘制相关的知识，下面我就来具体给你讲。</p><h2>鼠标操作</h2><p>我们先来看一下鼠标操作的知识。在Pygame中，鼠标操作用到的模块是pygame.mouse。在这个模块里面，点击事件的函数是get_pressed.假如有返回按钮1、按钮2和按钮3等等很多按钮,我们随便选一个点，假如说选了按钮1，那代码可以这么写：</p><pre><code>pygame.mouse.get_pressed()[0]\n</code></pre><p>这条语句不需要在事件语句里面操作，写在别的地方也可以，而且鼠标的操作在循环里一直是实时监测的。</p><h2>绘制矩形</h2><p>随后，我们要绘制矩形。 <strong>绘制矩形的目的是为了模拟一个按钮。</strong> 矩形绘制的代码是Rect，但是我们需要绘制在一个surface上，这个surface需要新建，然而在pygame中，如果使用pygame.surface.surface初始化一个surface的话，不能指定位置，x值是从0开始的。</p><p>所以在屏幕上看到的新建的surface是一个长条状的图层，所以我们需要将生成一个图层的子图层，并且，如果使用这个子图层的话，在blit的时候将会提示被锁定，所以，我们还需要将这个子图层进行拷贝。所以，我们的代码看起来是这个样子的。</p><pre><code>the_rect = Rect(200, 100, 150, 40)\nblock_surface = screen.subsurface(the_rect).copy()\n</code></pre><p>首先第一行代码是建立一个矩形，分别是左侧起始值是200，顶部从100开始，宽度150，长度40。随后，使用screen这个图层来建立一个子图层，子图层的大小按照the_rect这个矩形大小来建立。随后的一个copy函数，是将子图层进行拷贝，在后续的使用中，不会出现锁定图层的情况。</p><h2>绘制字体和字符</h2><p>之后我们要开始编写文字处理的代码，字体我们要用到pygame.font模块，我们先初始化一个字体，这个字体在安装pygame游戏库的时候就包含在了pygame里面，我们直接就可以拿来使用。现在我们初始化字体，并且将字体大小调整到25：</p><pre><code>fnt = pygame.font.Font(\'freesansbold.ttf\',25)\n</code></pre><p>其中，freesansbold.ttf是pygame安装的时候默认存在的ttf字体文件，随后，我们在第二个参数设置为大小25。</p><p>我们拿到了fnt对象，然后使用这个对象调用render函数。这其实就是渲染，将文字渲染在屏幕，并且形成一个文字图层，函数原型是这样的：</p><pre><code>Font.render(text, antialias, color, background=None)\n</code></pre><p>其中第一个参数text是文字内容，第二个参数antialias是抗锯齿，第三个内容color是文字颜色，最后一个是背景颜色，默认可以忽略。</p><pre><code>tsurf = fnt.render(text, True, (255,255,255))\n</code></pre><p>我们将颜色设置为白色，所以是（255，255，255）。</p><p>tsurf是render返回的一个文字的图层（surface），我们之后要按照这个图层，来确定它的矩形框。</p><pre><code>trect = tsurf.get_rect()\n</code></pre><p>随后我们需要将文字摆在这个trect矩形框的中央，所以我们要进一步将trect确定在中央的位置，计算完中央的坐标值并且赋值过去。</p><pre><code>trect.center = ((block_surface.get_width()/2),(block_surface.get_height()/2))\n</code></pre><p>我们将最开始的复制的子图层的宽度和高度除以2，就得到了中心点的位置。</p><p>最后我们要做的就是在封装的函数内将blit部分包含进去，现在我们来看一下完整的包装函数代码。</p><pre><code>def text_out(text):\n    fnt = pygame.font.Font(\'freesansbold.ttf\',25)\n    tsurf = fnt.render(text, True, (255,255,255))\n    trect = tsurf.get_rect()\n    trect.center = ((block_surface.get_width()/2),(block_surface.get_height()/2))\n    block_surface.blit(tsurf, trect)\n</code></pre><p>我们看到，在函数最后，我们blit了block_surface这个被拷贝的图层。</p><p>随后我们在游戏的大循环里面，需要判断鼠标的点击事件，我们之前所定义的矩形，代码是这样：</p><pre><code>the_rect = Rect(200, 100, 150, 40)\n</code></pre><p>所以这x的起始位置和结束位置是200和350，y轴的起始位置和结束位置是200和240，为什么y轴也是200开始呢？因为起始点 200既是x轴开始的点也是y轴开始的点。我们在代码里面这么判断鼠标的点：</p><pre><code>txt = &quot;Pause&quot;\nx, y = pygame.mouse.get_pos()\n    if pygame.mouse.get_pressed()[0]:\n        if x &gt;=200 and x &lt;= 350 and y &gt;= 200 and y &lt;= 240:\n            txt = &quot;Clicked\n</code></pre><p>我们将txt定义为Pause字符串，并且判断是不是鼠标左键点击的。如果是的话，判断是不是在 x 轴和y轴进行点击，如果不是的话，就将txt改为Clicked。</p><p>随后我们绘制按钮框，并且将按钮框背景设置为绿色，然后输出文字，并且绘制。</p><pre><code>screen.blit(block_surface, (200, 200))\n    block_surface.fill([0,20,0])\n    text_out(txt)\n</code></pre><p>将block_surface这个图层绘制在（200,200）的坐标点，并且将之涂为绿色，最后调用text_out函数，由于text_out里面已经编写了blit函数，所以不需要再次blit了。</p><p>我们来看一下效果图：</p><p><img src="https://static001.geekbang.org/resource/image/fb/a4/fb4e358092d3ad315e54f61cb984fca4.jpg" alt=""></p><p>我们看到了一个绿色的按钮放置在屏幕上，并且有一个白色的Pause字样放在按钮上，如果是鼠标左键点击在这个按钮上，就会变成Clicked字样。</p><p>到这里，你可能会问了，为什么没有解释怎么输出中文呢？</p><p>在这种情况下，输出中文有两种解决方案。</p><ul>\n<li>\n<p>第一种是比较底层的方案，就是<strong>根据中文进行点阵绘制</strong>，这需要很底层的代码操作，效率也不太高，所以这种方案我们不作讨论。</p>\n</li>\n<li>\n<p>第二种就是<strong>改变字体</strong>，我们可以在初始化字体的时候，下载一些网上的中文字体先进行尝试，或者我们可以使用系统字体。在使用系统字体的时候，我们可以使用SysFont来初始化字体。</p>\n</li>\n</ul><pre><code>fnt = pygame.font.SysFont(\'微软雅黑\',32)\n</code></pre><p>另外，还需要修改一个地方。我们需要在Python代码最开始的地方添加编码方式，并且将中文文字前面添加u字样来告诉解释器是Unicode的。</p><pre><code># encoding: utf-8\ntxt = u&quot;暂停&quot; \n</code></pre><p>我们来看一下效果：</p><p><img src="https://static001.geekbang.org/resource/image/bb/d2/bba42a0cb409eedaab6a78f02cc456d2.jpg" alt=""></p><p>至此，中文的输出也已经完成了。</p><p>到现在为止，我们编写完了UI的按钮部分。至于菜单部分，我们也可以通过相同的方式来编写菜单效果。</p><p>作为菜单这些高级操作，比如点击出现下级菜单、隐藏菜单这些动态效果，可以使用图片的方式来制作菜单，并且进行载入。如果使用程序来编写菜单的效果，工作量就太大了。而如果是图片形式的话，只需要载入并且控制鼠标点击和绘制子菜单就可以了。</p><h2>小结</h2><p>今天我们学习了UI部分的编写以及文字的输出、鼠标的移动和抓取鼠标按键的实现，我来总结一下今天的内容。</p><ol>\n<li>\n<p>不管何种类型的游戏引擎，鼠标的操作基本有3个值需要控制，左键、中键和右键。</p>\n</li>\n<li>\n<p>按钮可以用常规的方法来绘制。如果想做出更好的效果，比如画框，可以在框里面再画一个小框，看起来像是有凸出感觉的样子。这就需要你平时多注意观察一些细节，然后去分析如何用我们讲过的简单的操作来实现这些内容。</p>\n</li>\n<li>\n<p>在2D游戏中，很多游戏引擎都不支持中文的输出。如果要输出中文，假如你的引擎支持，那你可以使用系统字体或者其他中文字体；如果引擎不支持，可以使用一个一个点阵绘制的方式在屏幕上绘制中文。最后一种方式，也就是比较极端的方式，那就是使用图片来直接贴上中文字符，这种方式直接粗暴，但是图片资源量太大，而且如果你要在游戏中进行网络聊天，这里面其实还是没有从根本上解决中文输出的问题。</p>\n</li>\n</ol><p>现在给你留一个小问题。</p><p>如果让你在上述的代码中，将按钮变成菜单，也就是点击按钮，就在下方出下一个下拉框，你会如何实现？</p><p>欢迎留言说出你的看法。我在下一节的挑战中等你！</p>',
        article_title: "第16讲 | 如何在游戏中载入UI和菜单？",
      },
      {
        title: "第17讲 | 如何用鼠标和键盘来操作游戏？",
        id: 10437,
        content:
          '<p><strong>如果一款游戏不能用鼠标和键盘操作，那我们只能当动画来看。</strong></p><p>所以在一款游戏中，鼠标和键盘的操作是必不可少的，有时候甚至鼠标和键盘都要同时操作，比如FPS游戏，比如即时战略等等。鼠标和键盘的操作在Pygame中需要进行实时检测，这个上一节我有提到过，然后我们就可以对游戏画面进行操作。</p><p>我们在Pygame中有两种方式可以检测和编写键盘事件，一种是使用<strong>event事件</strong>操作，一种是使用<strong>keypressed函数</strong>来进行键盘的判断操作。</p><p>我们先来尝试一下使用事件进行操作的键盘事件。我们在之前的代码中，已经使用事件来判断是不是退出，我们来看如下代码：</p><pre><code>for event in pygame.event.get():\n        if event.type == QUIT:\n            pygame.quit()  \n</code></pre><p>在这段代码里面，event.type的类型如果是QUIT的话，就让pygame退出，那么举一反三，我们也可以在里面写上如下代码：</p><pre><code>if event.type == KEYDOWN:\n    if event.key == pygame.K_w:\n        .....\n</code></pre><p>在这里，我们判断事件的类型是KEYDOWN，也就是键盘按下的事件，随后我们再在下面的代码里,判断event所返回键盘key值，是pygame.K_w，这个K_w是pygame里面定义的虚拟键盘的按键，代表的是Key值为键盘w的按键，所以你只要按下w键，就会出现对应的操作。</p><p>我们来写下一系列的操作代码，在编写代码之前，我们首先要来定义一下规则。</p><!-- [[[read_end]]] --><p>我们的目的，是要让主角的飞机移动起来，所谓的飞机的移动，我们在前面几篇课程里面都有阐述。如果我们要让飞机在画面上移动起来，就需要修正飞机的x轴和y轴。</p><p>相应的，如果飞机往左侧飞，就需要减少飞机的x轴；如果飞机往右侧飞，就要增加飞机的x轴；如果往上面飞，就要减少飞机的y轴；如果往底下飞，就要增加飞机的y轴。我们先理清楚了这些内容之后，就可以编写键盘操作代码了。</p><p>我们先来修正飞机的x轴和y轴。我们要在游戏的循环之外，定义两个变量xx和yy，以修正键盘操作后的飞机坐标。</p><pre><code>xx = 0\nyy = 0  \n</code></pre><p>在定义完了这些内容后，我们再来看看按键的定义。</p><pre><code>if event.type == KEYDOWN:\n            if event.key == pygame.K_w:\n                yy -= 1\n            if event.key == pygame.K_s:\n                yy += 1\n            if event.key == pygame.K_a:\n                xx -= 1\n            if event.key == pygame.K_d:\n                xx += 1\n</code></pre><p>首先，和普通的游戏一样，我们将电脑键盘上的WSAD按键用作上下左右的操作按键，所以我们判断了一系列的按键值，比如K_w，K_s等等，然后我们看到，xx, yy 的一系列操作，然后我们进行飞机的贴图和操作：</p><pre><code>screen.blit(pln, (100+xx, 300+yy))\n</code></pre><p>我们看到，基础坐标值是（100，300）。我们经过键盘操作，对xx和yy进行位置的修正。到这里为止，我们可以看到，只要我们按下WSAD中的任意一个按键，飞机就会往指定的位置移动。</p><p>所以如果你认为到这里按键的内容就结束了，那就错了，就像我们今天开头所说的，Pygame下的键盘类，还有另外一种方式可以检测，你可以考虑下面的代码。</p><pre><code>key = pygame.key.get_pressed()\n    if key[pygame.K_w]:\n        yy -= 1\n    if key[pygame.K_s]:\n        yy += 1\n    if key[pygame.K_a]:\n        xx -= 1\n    if key[pygame.K_d]:\n        xx += \n</code></pre><p>是的，我们看到了pygame.key.get_pressed(); 函数。这个函数返回一个Key值。和event事件不同的是，我们直接可以在每一次循环内进行判断。返回的Key是一个tuple类型，在里面存放了各种按键对应的值。如果没有按键，所有值都是0；如果有按键，其中一个值是1。</p><p>再来看接下来的代码，如果key值的tuple里正好是pygame.K_w的话，那么判断结果就是真，我们来将这个内容打印出来看一下。</p><pre><code>print key\n</code></pre><p>我们打印了key，并且按下w按键，随后，我们可以在游戏界面命令行看到如下内容输出：</p><p><img src="https://static001.geekbang.org/resource/image/48/4a/480b8b53350ddb06e6a70e6987c84a4a.jpg" alt=""><br>\n﻿找到那个1没有？那个1，就是对应的K_w值，在key[pygame.K_w]判断的时候，返回一个1，也就是True，那么就产生yy-=1的操作。接下来就是类似的代码了，我就不再作重复的阐述了。</p><p>看到这里，或许你就要问了，那有很多的游戏都有组合键，比如我按下Ctrl键，再按下w键，就会出现对应的操作，这又该怎么实现呢？</p><p>你思考一下，我们是不是可以把两个按键写在同一个判断语句下？是的，你没有猜错，确实可以这么写，这就是<strong>组合键</strong>的效果。</p><pre><code>if key[pygame.K_w] and key[pygame.K_LCTRL]:\n    yy -= 2 \n</code></pre><p>在这里我们看到，只要同时按下了w和左侧CTRL，（LCTRL的意思是Left Control，就是左侧Control的意思），那么yy的坐标值就减去2，我们操作一下就知道结果了。所以，组合键可以在同一个判断里面，使用and连接起来。</p><p>然后，事情并没有到这里结束，请你将这些代码写在自己的电脑里，并做一下实验，第一种方式是事件判断，第二种方式是按键判断。这两种方式的区别是什么？</p><p>看到区别了吗？如果你按照我说的去做，你会发现，第一种方式，只要按下一个键，飞机就会往指定方向移动一格，然而如果你一直按着这个键，飞机是不会移动的，要等你再按下键盘才行。而第二种方式，只要你一直按着这个键，飞机就会一直不停往指定位置移动。</p><p>问题究竟出在哪里呢？</p><p>问题在于，事件判断首先判断了KEYDOWN，当你按下按键的时候，KEYDOWN已经被判断了，随后我们再进入event的按键类型的判断，但是如果你这时候一直按着键盘，KEYDOWN事件并没有被唤起，所以一直按着按键并没有起到作用，所以你要按下键盘，松开，再按下一次，飞机才会移动。</p><p>而第二种方式，在循环里面，只要键盘按下去，就会一直返回一个tuple给key，然后在继续做判断，所以，我们只要一直按着键盘，一直会做判断，直到按下的键盘是WSAD为止。</p><p>接下来，我们要做一下鼠标的操作。鼠标的操作我们在前几次的课程中也进行了介绍，我们再来温习一遍，并且添加一些新的内容进去。</p><p>我们今天要把一幅图片贴在鼠标的位置，并且随着鼠标的移动而移动，我们先来看下列代码：</p><pre><code>mouse = \'mouse.png\'\nmouse_cursor = pygame.image.load(mouse).convert_alpha()\nmouse_scale = pygame.transform.scale(mouse_cursor, (40, 40))\n \nWhile True:\n    #获取 x, y 值\n    x-= mouse_scale.get_width() / 2\n    y-= mouse_scale.get_height() / 2\n    screen.blit(mouse_scale, (x, y))\n    ...\n</code></pre><p>首先我们要定义的一幅图片名叫 mouse.png，随后载入图片并且处理alpha混合，这在我们先前的课程中都有过阐述。</p><p>随后我们看到了一个叫pygame.transform.scale的函数。这个函数的意思是，我们要重新将mouse这个surface进行缩放，其中缩放的大小长宽是（40，40），并且返回一个新的 surface。</p><p>随后在循环里，我们获取到这个surface的中心点，也就是计算需要绘制鼠标的x，y值，我们需要得到图片的长宽，并且除以2，最后blit开始贴图，我们看到的效果是这样的。</p><p><img src="https://static001.geekbang.org/resource/image/28/a1/2840dec856ac2ed69eb6d3c8956926a1.jpg" alt=""></p><p>那么我们如果要判断鼠标的按键怎么办呢？我们来温习一下上一次所讲的内容，鼠标的按键，也是类似的判断方式：</p><pre><code>x, y = pygame.mouse.get_pos()\n  if pygame.mouse.get_pressed()[0]:\n      .... \n</code></pre><p>前面那段代码用到的 x，y的值，在这里进行代码获取。</p><p>我们看到，pygame.mouse.get_pos() 函数，获取两个值，x和y坐标，后面一段代码就是获取鼠标点击的内容，其中 get_pressed函数下标0返回是不是左键点击，下标1返回是不是中键点击，下标2返回是不是右键点击，最后再做出判断。</p><h2>小结</h2><p>今天的内容基本到这里了，我带你将内容梳理并总结一下。</p><ol>\n<li>\n<p>首先是键盘事件判断，这里会出现按一下键盘做一下操作的情况，问题出在KEYDOWN事件判断上。但是如果你需要一直按键的判断，可以使用get_pressed函数。</p>\n</li>\n<li>\n<p>组合键可以写在同一个判断下，使用and连起来做判断。</p>\n</li>\n<li>\n<p>get_pressed会返回一个tuple，里面存放了所有的key值，只要判断key值是不是为True就是判断了有没有按键。</p>\n</li>\n<li>\n<p>鼠标操作也可以使用get_pressed函数，也是返回tuple，其中下标0、1、2分别代表了左、中、右三个按键。</p>\n</li>\n</ol><p>最后，给你留一个小问题。</p><p>如果将组合键写在第一个按键的判断下，会出现什么情况？</p><pre><code>if key[pygame.K_LCTRL]:\n    if key[pygame.K_w]:\n        ...\n</code></pre><p>欢迎留言说出你的看法，我在下一节的挑战中等你！</p>',
        article_title: "第17讲 | 如何用鼠标和键盘来操作游戏？",
      },
      {
        title: "第18讲 | 如何判断客户端的网络连接？",
        id: 10544,
        content:
          "<p>由于涉及到网络、脚本语言等等，这一节起，我要开始讲一些基础的、看起来比较枯燥的知识。我会尽力写得有趣生动，但是，知识的获取并不容易，即便我已经在努力去讲解，还是需要你用更多的时间去摸索和学习。</p><p>我们在前面说了Pygame的一些客户端知识，如果你想让这款游戏能够在网络上传输数据，接下来，那就需要编写服务器端，并且在客户端做客户端连接的准备。</p><p>前面我们已经用Pygame讲解了很多内容，那我们客户端的网络连接，我也继续使用Python来编写，当然这已经和Pygame没有关系了。因为网络连接是独立的代码，所以只需要直接写在游戏里就可以了。</p><p>在开始编写网络部分之前，我们需要整理一下网络的基础知识。如果我们一上来就编写网络代码，对于你来说，可能会有一些概念上的模糊。</p><p>对于网络编程，或许你已经接触到了，或许你只是有点概念，或许你一点都没接触过。但是你或许听说过Socket套接字、TCP/IP协议、UDP协议、HTTP、HTTPS协议等等，那么这些协议是不是都属于网络编程范畴？还是这里面哪些部分是属于网络编程范畴呢？</p><p>网络，从模型上讲，一共分为七层，从底层到最上层，分别是：物理层、数据链路层、网络层、传输层、会话层、表示层、应用层。</p><!-- [[[read_end]]] --><p>我来分别解释一下。</p><ul>\n<li>\n<p><strong>物理层</strong>：所谓的物理层，你可以理解为我们看到的各种网络线，也就是人肉眼能看到的物理线路，包括光纤、以前连接调制解调器的电话线等等。这些线路就是物理层。物理层有物理层的规范，比如电流、编码、帧、连接头等等。你只需要知道物理层也是存在规范的，就可以了。<strong>物理层最主要的功能就是网络的物理连接</strong>。</p>\n</li>\n<li>\n<p><strong>数据链路层</strong>：所谓的数据链路层，就是建立逻辑连接，然后进行硬件上的寻址操作、差错的校验，然后将二进制的字节进行组合，通过MAC地址进行访问，比如网卡、交换机等等。你需要记住的是，<strong>在这一层，要通过MAC地址来进行访问，进行硬件寻址操作。</strong></p>\n</li>\n<li>\n<p><strong>网络层</strong>：网络层进行逻辑地址的寻址操作和数据链路层不同。数据链路是使用硬件寻址操作，而网络层是使用逻辑地址寻址，比如路由器、防火墙、多层交换机等等。我们最熟悉的IPv4（202.101.253.233）、IPv6、ARP等等都属于这一层。你在这里需要记住的是，<strong>网络层是逻辑寻址操作，会用到ARP、IPv4等等协议。</strong></p>\n</li>\n<li>\n<p><strong>传输层</strong>：在编程中最常用到的TCP、UDP等等协议，都在这一层进行操作，它首先定义了数据传输的协议端口号以及一些错误的检测。</p>\n</li>\n<li>\n<p><strong>会话层</strong>：会话层在传输层之上，它就在客户端和服务器端。严谨地说，就是本地机器和远端机器之间的会话，比如要进行断点续传这些操作，就属于会话层的范畴。</p>\n</li>\n<li>\n<p><strong>表示层</strong>：表示层很容易理解，就是数据的传输，然后展现在电脑上。比如图片的传输和显示、网络地址的加密等等。</p>\n</li>\n<li>\n<p><strong>应用层</strong>：应用层就是提供给电脑用户的各种网络应用，比如你自己编写的网络软件、FTP软件、Telnet、浏览器等等。</p>\n</li>\n</ul><p>以上这些点你要硬性记住的话，会比较困难。我教给你一个方法。</p><p>首先，我们想象一段从网线过来一段数据，网线就是“物理层”，那么数据需要找到一个门牌号，这个门牌号是一个硬件地址，可能是你的电脑网卡，也可能是你公司的交换机。这些数据需要把这些门牌地址连接起来，这就是“数据链路层”。</p><p>随后，这些数据找到门牌号后，就需要分发到逻辑地址，比如路由器或者你的IP地址，这些逻辑地址就是网络地址，这就是“网络层”。</p><p>经过网络层后，就要看这是什么数据，是TCP协议的，还是UDP协议的。知道了协议后，才可以传输数据，所以这个是“传输层”。</p><p>那么在传输的过程中，可能会中断，所以我们需要登录服务器，断点续传进行重新传输，这些属于机器和机器之间的会话，所以是“会话层”。</p><p>传输完数据后，我们就会在电脑里显示这个内容，是一幅图片呢，还是一段电影？这个需要表示出来，所以是“表示层”。</p><p>最后，我们将这个一整套的东西，写成了一个应用，这就是“应用层”。</p><p>虽然这么表述起来，有许多不精确不严谨的地方，但是通过这段话能让你很快记住这个七层网络模型，对你将来的编程有很大的帮助。</p><p>Python支持Socket编程，也就是支持TCP、UDP等协议的编程，也支持更上层的编程，比如HTTP协议等等。在今天的内容中，我们要用到TCP编程。至于为什么要使用TCP，有这样几个原因：</p><ol>\n<li>\n<p>TCP保证连接的<strong>正确性</strong>。在建立TCP连接的时候，需要经过三次握手，连接这一方发送SYN协议，被连接方返回SYN+ACK协议，最后连接方再返回ACK协议；</p>\n</li>\n<li>\n<p>TCP保证如果在一定时间内没有收到对方的信息，就重发消息，保证消息传输的<strong>可靠性</strong>；</p>\n</li>\n<li>\n<p>TCP可以进行<strong>流量控制</strong>。它拥有固定大小的缓冲池，TCP的接收方只允许另一方发送缓冲池内所接纳的数据大小。</p>\n</li>\n</ol><p>TCP还有其他更多的保证传输可靠性的内容和标准，我在这里不做更多的阐述。另外，使用TCP可以进行长时间的连接，在客户端和服务器端之间进行不停地交互。在交互过程中，服务器端发送数据给客户端，客户端就能做出相应的回应。</p><p>在Python中编写TCP协议的代码比之使用C/C++更为方便。因为C/C++需要初始化一系列的内容，然后进行顺序的流程化绑定，设置网络参数，最后进行发送和接收操作，在结束的时候进行资源的回收。而在Python这里，只需要设置协议和IP地址就可以实现TCP协议编程。我们来看一段代码。</p><pre><code>import socket\nclass go_sock(object):\n    ip = &quot;&quot;\n    port = 0\n    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    def __init__(self):\n        object.__init__(self)\n    def connect(self, ip, port): \n        self.ip = ip\n        self.port = port\n        self.sock.connect_ex((ip, port))\n    def close(self):\n        self.sock.close()\n</code></pre><p>我在这里编写了一个类，这个类将TCP的内容封装在了类中，这样，我们的网络代码能在游戏中方便地初始化，使用起来就很方便。</p><p>首先，我们看到在类里面定义了ip、port、sock这三个变量，这三个变量分别是对应IP地址、端口号以及socket句柄。在类里，我们直接将sock初始化为socket类，其中socket类填写的内容中，参数1是服务器之间的网络通信，参数2是流Socket，这里指的是TCP协议。</p><p>在初始化完成了之后，我们看到connect函数。在函数里面，我们看到参数对变量的初始化，其中sock句柄调用了标准socket函数sock.connect_ex，这个函数负责与对方进行一个连接。</p><p>最后的函数是close关闭操作，在任务完成之后，你可以调用close函数进行socket句柄的关闭。</p><p>我们可以这样使用这个类。</p><pre><code>_inet = go_sock()\n_inet.connect(&quot;115.231.74.62&quot;, 21)\n_inet.sock.recv(100)\n</code></pre><p>在这里，我们可以简单测试一下某些应用服务器，然后接收返回内容。这个类的封装工作到此就告一个段落，更多的网络服务和交互的编写，我将在下一节阐述。</p><h2>小结</h2><p>今天我们学习了网络的七层模型结构，以及我们将要在游戏中使用的TCP协议的编程。</p><ul>\n<li>\n<p>我用了一个传输过程介绍了七层每一层做的事情，这个你一定要牢记。</p>\n</li>\n<li>\n<p>我们使用Python封装了Socket库的细节内容，只需要直接编写connect代码就可以进行数据的接收和发送操作了。</p>\n</li>\n<li>\n<p>选择TCP协议是因为它安全可靠，能保证游戏传输的过程中不出错。</p>\n</li>\n</ul><p>现在，我给你留一个小问题吧。</p><p>如果我们要使用UDP来编写这个网络服务，该如何保证数据的准确性呢？选择UDP协议的优势在哪里？</p><p>欢迎留言说出你的看法。我在下一节的挑战中等你！</p>",
        article_title: "第18讲 | 如何判断客户端的网络连接？",
      },
    ],
  },
  {
    chapterTitle: "第四章：脚本语言",
    children: [
      {
        title: "第19讲 | 如何嵌入脚本语言？",
        id: 10998,
        content:
          '<p>从2005年开始，逐渐流行使用C/C++语言结合脚本语言（Lua、Python、Ruby等等）编写游戏。这是因为用C/C++编写游戏的传统方式，硬代码太多，而使用硬代码编写的游戏，更新难度很大，除非重新编译一次程序。</p><p>于是，就有人开始使用配置文件来做活动逻辑。比如填写好配置表、玩家等级多少、攻击力如何、等于多少的伤害力等等，一开始就将这些内容都读取进代码，在游戏中实时计算出来。</p><p>但是这种方法其实也并不方便。很久以前的游戏，由于硬件资源限制，所以一般都加载WAV格式。而加载MP3则需要机器对音乐文件进行解压缩再播放，如果机器硬件计算能力不好的话，会由于解压缩而导致整个游戏的运行效率下降。</p><p>脚本语言也是如此，如果机器硬件能力不好的话，会由于脚本语言的虚拟机要解释程序，导致游戏运行效率下降。随着电脑硬件的提升，我们在游戏中加载MP3音乐文件成为可能，而在游戏中加载脚本语言进行逻辑编写当然也是可以的。</p><p>《魔兽世界》就是使用Lua脚本语言编写的。类似《GTA》等大型游戏，都拥有一套自己的脚本语言和体系。 <strong>使用脚本语言，是为了能够在编写硬代码的同时，也能很方便地、不需要重新编译地编写逻辑代码。</strong> 事实上，现在很多大型游戏都使用这种方式来编写代码，甚至一些游戏引擎本身，也支持脚本语言和引擎本身所提供的语言分离编写。比如引擎用C++语言编写，脚本语言用Lua编写。</p><!-- [[[read_end]]] --><h2>为什么使用Lua脚本嵌入C/C++硬代码？</h2><p>今天我就来教你使用Lua脚本来嵌入C/C++硬代码。为什么我要选择Lua脚本语言来编写代码呢？</p><p>因为<strong>Lua脚本足够轻量级，几乎没有冗余的代码。Lua虚拟机的执行效率几乎可以媲美C/C++的执行效率</strong>。如果选择Python、Ruby等常用脚本语言来嵌入，并不是不行，而是要付出执行效率作为代价。因为Python、Ruby的执行效率远逊于Lua。</p><p>如果没有非常多的编码经验，你可能会问，为什么Python、Ruby的执行效率远逊于Lua呢？这个问题，用一本书的篇幅恐怕才能彻底讲明白。我这里只简要说一下原因。</p><p>Lua的虚拟机很简单，指令设计得也精简，Lua本身是基于寄存器的虚拟机实现，而Python等其他脚本语言是基于堆栈的虚拟机，而基于寄存器的虚拟机字节码更简单、高效。因为字节码，一般会同时包含指令、操作数、操作目标等内容。</p><p>另一方面，Python、Ruby之所以应用范围广，是因为它们拥有大量的成熟库和框架，而Lua只是一种很纯粹的脚本语言。因为Lua没有过多的第三方库，只提供最基础的I/O处理、数学运算处理、字符串处理等，别的与操作系统相关度密切的，例如网络、多线程、音频视频处理等等都不提供。</p><p>我在<a href="https://time.geekbang.org/column/article/8782">第6讲</a>里，已经非常详细地讲过，如何将Lua脚本编译成为静态库，如果不记得的话，可以回去复习一下。编译好静态库liblua.a之后，我们就可以在编程中使用它了。</p><p>你也可以选择在解压缩出来的目录内，使用make命令来直接编译，编译会生成Lua虚拟机的执行文件lua.exe、luac.exe，当然这需要一整套MinGW的环境支持。</p><p>开始，我们还是使用MinGW Development Studio来创建一个工程。由于只是示例，所以名字可以任意取。我取一个叫作lua_test的工程名，并且将工程设置为Win32 Console Application。你可以看这个示例图。<br>\n<img style="margin: 0 auto" src="https://static001.geekbang.org/resource/image/c2/51/c214aaccf9b6cd231d73304beea8ba51.jpg"></p><p>建立好了工程之后，我们新建一个test.c文件。这个文件位于lua源代码路径下。我们将liblua.a 文件也放到同一个目录下，以方便后续链接时候调用。</p><p>在包含Lua头文件之前，我们需要将头文件写在某一个.hpp文件下，以便一次性包含进去，我们的代码可以这么写。</p><pre><code>#ifdef __CPLUSPLUS\nextern &quot;C&quot; {\n#endif\n#include &quot;src/lua.h&quot;\n#include &quot;src/lualib.h&quot;\n#include &quot;src/lauxlib.h&quot;\n#ifdef __CPLUSPLUS\n}\n#endi\n</code></pre><p>你可以看到，这里面包含了三个代码。这三个代码来自src目录下，其中最后一个lauxlib.h包含了大量的C语言形式的接口以及扩展接口。而定义extern "C"的意思是，使用C的方式进行链接，前置条件是，你的语言是C++语言（ifdef __CPLUSPLUS）。</p><p>定义好了这个hpp文件后，我们可以在C或者C++语言中进行包含。</p><pre><code>#include “lua.hpp”\n</code></pre><h2>你需要了解三个Lua语言的细节问题</h2><p>写完定义之后，我们就可以开始对Lua进行一系列的绑定操作了。在编程之前，我先用一些你能看得懂的语言，对Lua语言的细节进行一些描述。有三个点，需要你着重记一下。</p><p>首先，<strong>Lua的下标都是以1为最初始的值</strong>（当然反向可以使用-1为下标），而不是我们所熟悉的0。有个传言说，是因为作者当时编写最初版本的Lua时，计算错误才导致的，所以就这么一直沿用下来了，这个说法虽然不可考，但也算是一种解释。</p><p>其次，在C/C++内嵌Lua的做法中，<strong>Lua有两种读取脚本的方法。</strong></p><ul>\n<li>\n<p>一种方式是<strong>读取后直接运行，调用的函数是luaL_dofile</strong>。使用这个函数，脚本会在读取完毕后直接运行。当然如果出现错误，你也不知道错误的具体位置在哪里，调试起来不是很方便。</p>\n</li>\n<li>\n<p>第二种方式是<strong>将脚本代码压到栈顶，然后使用pcall操作运行脚本，这个函数叫luaL_loadfile</strong>。事实上第一种方式也是使用这种方式并且将pcall操作直接调用起来，第一种方式的代码一看你就能明了。</p>\n</li>\n</ul><pre><code>#define luaL_dofile(L, fn) \\\n      (luaL_loadfile(L, fn) || lua_pcall(L, 0, LUA_MULTRET, 0))\n</code></pre><p>这行代码在lauxlib.h中能找到。这段代码写得非常精妙，它的意思是，如果loadfile成功，那么就运行pcall函数，中间这个 || （或者）已经直接判断了loadfile是否成功。因为loadfile函数操作成功就返回0，否则就返回1。</p><p>而在“或者”这个逻辑判断下，只要是0，就继续往下判断；只要是1，就直接返回条件为真。所以，在这行代码下，只要是1，就中断dofile这个宏的操作；只要是0，就进行pcall操作。</p><p>最后，我要说一下<strong>Lua的堆栈</strong>。理解了堆栈的计数方式，就能很容易地理解我后续要讲解的代码中的计数方式。Lua的堆栈可以从这个图里看出来，从栈底往上表示可以用1、2、3、4、5，而从栈顶往下表示是-1、-2、-3、-4、-5。<br>\n<img style="margin: 0 auto" src="https://static001.geekbang.org/resource/image/af/ad/af00612d1f227cac1900b5c9e153c6ad.jpg"></p><h2>如何使用Lua以及liblua.a来进行与C语言的绑定操作？</h2><p>我们现在开始使用Lua以及liblua.a来进行与C语言的绑定操作。</p><p>首先，我们需要包含之前我们所定义的lua.hpp头文件，随后我们开始在main入口函数处，定义一些变量。</p><pre><code>#include &quot;lua.hpp&quot;\nint main(int argc, char ** argv)\n{\n      int r;\n      const char* err;\n      lua_State* ls;\n       ….\n}\n</code></pre><p>在这里，我们定义了三个变量，其中r是用来接收返回值的；err是一个常量字符串，用来接收错误字符串并打印出来；而lua_State* ls就是Lua虚拟机的指针了。</p><p>我们再来看接下来的代码。</p><pre><code>ls = luaL_newstate();\nluaL_openlibs(ls);   \n</code></pre><p>在这两行代码中，首先初始化一个虚拟机（在Lua 5.1中，使用的函数是 lua_open来新建虚拟机），并且将虚拟机地址赋值给ls指针。随后，我们拿到这个指针之后，就在之后的代码中“打开”Lua所需要用到的各种库。我们用到luaL_openlibs。我现在只是给你示范，你可以一个一个库单独打开。</p><p>我们新建了虚拟机，并且打开了Lua类库。我们继续看下面的代码。</p><pre><code>r = luaL_loadfile(ls, argv[1]);\nif(r)\n{\nerr = lua_tostring(ls, -1);\nif(err)\nprintf(&quot;err1: %s\\n&quot;, err);\nreturn 1;\n}\nr = lua_pcall(ls, 0, 0, 0);\nif(r)\n{\nerr = lua_tostring(ls, -1);\nif(err)\n     printf(&quot;err2: %s\\n&quot;, err);\nreturn 1;\n}\nlua_close(ls); \n</code></pre><p>我来具体解释一下。这段代码中，argv[1]的是命令行输入的第一个内容。比如我们的程序叫lua_test，那么我们在Windows命令行中，输入lua_test a.lua，那么其中a.lua 就是argv[1] 这个内容。</p><p>luaL_loadfile我们在前面介绍过，就是载入文件并不运行。当然在这个期间，它会检查基础的语法。如果你少一个括号或者多一个引号，就会在这个时候给你一个错误信息，这个错误信息就是利用r这个变量判断的。如果r的返回值不等于0的话，那就是出错了。出错的时候，Lua会将出错信息压栈顶，而栈顶是从-1开始表示，所以我们要取出栈顶的错误信息lua_tostring(ls, -1);，并且将它赋值给err，最后由err打印出来。</p><p>认为没有错误之后，就是过了这一关。第二关我们需要使用lua_pcall函数，来调用Lua脚本文件，其中第一个参数是虚拟机指针，第二个参数是传递多少参数给Lua，第三个参数是这个脚本返回多少值，第四个是错误处理函数，可以是0，那就是无处理函数。</p><p>pcall的返回值也是一样，如果不是0的话，就说明出错了。和之前的luaL_loadfile不同，这时候一般是运行时错误，比如运行时类型错误等等。同样的，pcall也会把错误信息压到栈顶，我们直接去将栈顶的内容转成string就可以打印出来了。最后，我们将Lua虚拟机通过lua_close关闭。</p><p>按常理来说，我们现在可以来运行一下效果了，你可以先等等，我们先写一段错误的Lua代码，来看看执行起来会发生什么情况。</p><pre><code>print &quot;test running&quot;)\n</code></pre><p>我们故意少写一个括号，然后将源代码命名为 a.lua，我们来运行看看。会出现一个这样的错误信息：<br>\n<img style="margin: 0 auto" src="https://static001.geekbang.org/resource/image/cf/2a/cfad6d423a3c95bacba12b5e8dc3782a.jpg"></p><p>在发现语法错误后，程序就会报错，另外，如果你输入了一个根本不存在的文件，比如我们这么运行，test_lua xxx.lua，也会在loadfile的时候出错。</p><h2>小结</h2><p>我们今天的内容就到这里。下次我会进一步把Lua的脚本嵌入的细节呈现在你面前。我们来总结一下今天的内容。</p><ol>\n<li>\n<p>因为Lua脚本足够轻量级，几乎没有冗余的代码。Lua虚拟机的执行效率几乎可以媲美C/C++的执行效率。所以我们选择使用Lua脚本来嵌入C/C++硬代码。</p>\n</li>\n<li>\n<p>Lua脚本在C/C++语言里面嵌入，需要先声明一个虚拟机并且赋值给指针。</p>\n</li>\n<li>\n<p>Lua脚本需要先loadfile再pcall调用脚本文件，loadfile会检查最基本的脚本文件内容，比如文件是否存在，比如脚本代码是否出错，而pcall会在运行时出错的时候将错误压至栈顶。</p>\n</li>\n<li>\n<p>Lua错误会将错误压制栈顶，我们要取出来，需要使用-1下标取出栈顶的内容，并转成string打印。</p>\n</li>\n</ol><p>给你留一个小问题吧。</p><p>如果直接使用luaL_dofile，相对于把loadfile和pcall分开写，这样有什么优劣呢？</p><p>欢迎留言说出你的看法。我在下一节的挑战中等你！</p>',
        article_title: "第19讲 | 如何嵌入脚本语言？",
      },
      {
        title: "第20讲 | 脚本语言在游戏开发中有哪些应用？",
        id: 11785,
        content:
          '<p>上一次，我们谈到了如何在游戏中嵌入脚本语言，我们用的语言是Lua。Lua语言具有轻量级、速度快的特点，而且API的调用也非常方便和直观。现在，我们仍然拿Lua脚本，试着把它应用在我们开发的游戏中。</p><p>我们使用C语言来对Lua脚本的绑定做一次深入的剖析，然后来看一下，在游戏开发中绑定了脚本语言后，脚本语言能做些什么事情。</p><p>首先，我们要明白一点，事实上<strong>任何模块都可以使用脚本语言编写</strong>。当然在游戏开发的过程中，需要分工明确，如果不分工的话，效率可能会比较低。</p><p>在需要某些效率要求非常高的情况下，一般是用C、C++或ASM语言，将底层模块搭建好，然后将一些逻辑部分分出来，给脚本语言处理。比如我们熟知的服务器端，可以使用C/C++来编写服务器端的IOCP或者epoll处理；而接收、发送、逻辑处理等等，都可以使用绑定脚本的方式编写。</p><p>我们在编写的过程中，需要对C/C++的语言和代码有个了解，我们需要先考虑这个函数。</p><pre><code>int test_func(lua_State *L)    \n{    \n     return 0;    \n}\n</code></pre><p>这只是一个空的C函数，在这个函数里面，我们看到它的传入参数是lua_State，接受一个指针L。随后，这个函数返回一个0。</p><p>lua_State是Lua虚拟机的对象指针，也就是我们需要把前面new出来的一个虚拟机传进去，才可以保证在这个函数里面，使用的是一致的虚拟机。</p><!-- [[[read_end]]] --><p>这个函数的作用是，<strong>只要注册到了Lua虚拟机里面，它就是lua的一个函数，其中在lua函数中，传入的参数由函数内部决定</strong>。</p><p>比如我可以这么写：</p><pre><code>int test_func(lua_State *L)    \n{    \n     const char *p1 = lua_tostring(L, 1);    \n     const char *p2 = lua_tostring(L, 2);    \n     // .... do something    \n     lua_pushstring(L, &quot;something&quot;);    \n     return 1;    \n}\n</code></pre><p>这里面，lua_tosting 就是这个函数的传入参数，传入的是一个字符串的参数；第二个参数也是字符串参数，其中 lua_tosting 的第二个参数1或者2，表明的是在Lua虚拟机的堆栈中从栈底到栈顶开始计数，一般先压入的参数在第一个，后压入的在第二个，以此类推。返回1的意思是，这个函数会返回一个参数，这个参数就是我们前面 lua_pushstring 后压入的这个内容something，这就是返回的参数。</p><p>那么这个函数究竟怎么注册成为Lua函数呢？我们来看这段代码。</p><pre><code>lua_register(L, &quot;test&quot;, &amp;test_func); \n</code></pre><p>lua_register函数的功能是，注册C函数到Lua虚拟机。其中L是虚拟机指针。这个在前面的代码都有说到，而第二个参数test就是注册在Lua虚拟机中的函数名，所以这个函数名叫test。第三个参数是函数指针，我们把test_func这个函数传入到lua_register函数中。这样，一个函数就注册好了。</p><p>那么，如果我们在游戏中有许多许多的函数需要注册到Lua中，那么这种写法是不是太慢了，有没有一种快捷的写法来支持注册等操作呢？</p><p>如果你没有C/C++的语言基础，或者C/C++语言基础比较薄弱，下面的内容可能需要花一点时间消化，我也会竭尽所能解释清楚代码的意思，但如果你已经是个C/C++程序员，那么下面的代码对你来说应该不会太难。</p><p>我们需要使用lua_register，我们先看它里面有什么参数。第一个是<strong>字符串</strong>，也就是<strong>char*；<strong>第二个是</strong>函数指针</strong>，也就是<strong>int (<em>)(lua_State</em>)</strong> 这种形式的。</p><p>那么，我们需要定义一个struct结构，这个结构可以这么写：</p><pre><code>   #define _max 256    \n    typedef struct _ph_func    \n    {    \n          char ph_name[_max];    \n          int (*ph_p_func)(lua_State*);    \n    } ph_func;\n\n</code></pre><p>我们定义了一个struct结构，这个结构的名字叫_ph_func，名字叫什么并没有关系，但是最开始有一个typedef，这说明在这个结构声明完后，接下来最后一行ph_func就是替代最初定义的那个_ph_func的名字，替代的结果是，<strong>ph_func 等同于struct _ph_func</strong>，这在很多C语言的代码里面经常能见到。</p><p>接下来，我们看到char ph_name[_max]。其中_max的值为256。我相信你应该能理解这句话。第二个变量就是我们所看到的函数指针，其中ph_p_func是函数指针，其中函数指针指向的内容目前暂时还没有确定，我们将在后续初始化这个结构变量的时候进行赋值。</p><p>我们来仔细看一下这两段宏的内容。</p><pre><code>#define func_reg(fname) #fname, &amp;ph_##fname\n#define func_lua(fname) int ph_##fname(lua_State* L)\n</code></pre><p>其中func_reg是在给前面那个结构体初始化赋值的时候使用的，因为我们知道，如果我们需要给这个结构体赋值，看起来的代码是这样：</p><pre><code>ph_func pobj =  {&quot;test&quot;, &amp;test_func};\n</code></pre><p>那么由于我们有大量的函数需要注册，所以我们将之拆分为宏，其中#fname的意思是，将fname变为字符串，而ph_##fname的意思是使用##字符，将前后内容连接起来。</p><p>通过这个宏，比如我们输入一个a赋值给 fname，那么#fname就变成字符串"a"，通过 ph_##fname，结果就是ph_a。</p><p>接下来的代码，是方便在代码中编写一个一个lua注册函数用的，所以很明显，和上述的宏一样，我们只需要输入a，那么这个函数就变成了 int ph_a(lua_State* L)；</p><p>定义好了这两个宏，我们怎么来应用呢？</p><pre><code>func_lua(test_func);\n          \nph_func p_funcs[] =    \n{    \n      { func_reg(test_func) },    \n};    \nfunc_lua(test_func)    \n{    \n     const char *p1 = lua_tostring(L, 1);    \n     const char *p2 = lua_tostring(L, 2);    \n     // .... do something    \n     lua_pushstring(L, &quot;something&quot;);    \n     return 1;    \n}    \nvoid register_func(lua_State* L)    \n{    \n      int i;    \n      for(i=0; i&lt;sizeof(p_funcs)/sizeof(p_funcs[0]); i++)    \n      lua_register(L, p_funcs[i].ph_name,  p_funcs[i].ph_p_func);    \n}\n</code></pre><p>首先，联系上面的宏，第一行代码是使用func_lua，所以func_lua输入的宏参数是test_func。于是，通过这个宏，我们最终得到的函数名字是int ph_test_func(lua_State* L); 。</p><pre><code>ph_func p_funcs[] =  \n{    \n      { func_reg(test_func) },    \n};\n</code></pre><p>这段代码，使用的是func_reg的宏。test_func最终在宏里面，变成了 “test_func”，以及&amp;ph_test_func函数指针。</p><p>最后我们来看一个重要的函数，<strong>register_func</strong>，这个函数在后续将会输入一个Lua虚拟机指针，但是我们要知道它在函数内部它做了什么东西。</p><pre><code>int i;    \nfor(i=0; i&lt;sizeof(p_funcs)/sizeof(p_funcs[0]); i++)    \n      lua_register(L, p_funcs[i].ph_name,  p_funcs[i].ph_p_func)\n</code></pre><p>在循环里面，我们计算p_funcs的结构数组的长度，怎么计算的呢？</p><p>首先，我们使用sizeof编译器内置函数，来取得p_funcs整个数组的长度，这整个长度等于sizeof(ph_func)的值乘以数组长度。而ph_func结构体拥有一个字符串数组，每个数组长度是256，加上一个函数指针为4字节长，所以长度是260。而如果有两个数组元素，那就是520的长度。</p><p>以此类推，/sizeof(p_funcs[0]的意思是，我们取出第一个数组的长度作为被除数。事实上就是结构体本身的长度，所以就是结构体数组总长度除以结构体长度，就是一共有多少数组元素，随后进行循环。</p><p>在循环的过程中，我们看到，我们填入了结构体里面的两个变量ph_name以及ph_p_func，这样一来，我们只需要通过宏加上一些小技巧，就可以把Lua的函数都注册到C程序里面，我们假设这个C程序就是游戏的话，那么我们很容易就可以和Lua进行互通了。</p><h2>小结</h2><p>我总结一下今天所讲的内容。</p><ul>\n<li>\n<p>在Lua与C的结合过程中，C语言需要新建一个Lua虚拟机，然后使用虚拟机的指针来操作Lua函数。</p>\n</li>\n<li>\n<p>在程序的应用中，使用C语言中的一些宏的技巧，可以使代码能够便利地应用在程序里。</p>\n</li>\n</ul><p>最后，给你留一个小问题。</p><p>如果使用Lua往C语言传递一些内容，比如从C语言获取Lua脚本中某个变量的值，应该怎么做？</p><p>欢迎留言说出你的看法。我在下一节的挑战中等你！</p>',
        article_title: "第20讲 | 脚本语言在游戏开发中有哪些应用？",
      },
      {
        title: "第21讲 | 如何使用脚本语言编写周边工具？",
        id: 11801,
        content:
          "<p>上一节，我们讲了脚本语言在游戏开发中的应用，我列举了很多C语言代码，这些代码做了这样一些事情：</p><ol>\n<li>\n<p>使用C语言和Lua语言进行沟通；</p>\n</li>\n<li>\n<p>在C语言代码里，使用了宏和结构，方便批量注册和导入C语言函数；</p>\n</li>\n<li>\n<p>Lua代码如何传输内容给C语言；</p>\n</li>\n<li>\n<p>Lua虚拟机堆栈的使用。</p>\n</li>\n</ol><p>这一节，我们要用Lua脚本来编写一个游戏周边工具Makefile。游戏周边工具有很多种，并没有一个统一的说法，比如在线更新工具、补丁打包工具、人物模型编辑工具、游戏环境设置工具等等。</p><p>你或许就会问了，那我为什么选择Makefile工具来编写，而不选择别的周边工具来编写呢？</p><p>因为这个工具简单、小巧，我们可以将Lua脚本语句直接拿来用作Makefile语句，而在这个过程中，我们同时还可以通过Lua语句来了解Lua的工作机理。 而且这个编写过程我们一篇文章差不多就可以说清楚。</p><p>而别的周边工具编写起来可能会比较复杂，比如如果要编写类似Awk的工具的话，就要编写文本解析和文件查找功能；如果编写游戏更新工具的话，就必须涉及网络基础以及压缩解压缩的功能。</p><p>简单直白地说，Makefile是一种编译器的配置脚本文件。这个文件被GNU Make命令读取，并且解析其中的意义，调用C/C++（绝大部分时候）或者别的编译器（小部分）来将源代码编译成为执行文件或者动态、静态链接库。</p><!-- [[[read_end]]] --><p>我们可以自己定义一系列的规则，然后通过顺利地运行gcc、cl 等命令来进行源代码编译。</p><p>我们先定义一系列函数，来固定我们在Lua中所使用的函数。</p><pre><code>int compiler(lua_State*);\nint linker(lua_State*);\nint target(lua_State*);\nint source_code(lua_State*);\nint source_object(lua_State*);\nint shell_command(lua_State*);\nint compile_param(lua_State*);\nint link_param(lua_State*);\nint make(lua_State*);   \n</code></pre><p>这些都是注册到Lua内部的C/C++函数。我们现在要将这些函数封装给Lua使用，但是在这之前，我们要将大部分的功能都在C/C++里编写好。</p><p>随后，我们来看一下，在Lua脚本里面，具体是怎么实现Make命令操作的。</p><pre><code>target(&quot;test.exe&quot;);\nlinker(&quot;c:\\\\develop\\\\dm\\\\bin\\\\dmc.exe&quot;);\ncompiler(&quot;c:\\\\develop\\\\dm\\\\bin\\\\dmc.exe&quot;);\n\nsource_code(&quot;c.cpp&quot;, &quot;fun.cpp&quot;, &quot;x.cpp&quot;);\nsource_object(&quot;c.obj&quot;, &quot;fun.obj&quot;, &quot;x.obj&quot;);\n\ncompile_param( &quot;$SRC&quot;, &quot;-c&quot;,\n                      &quot;-Ic:/develop/dm/stlport/stlport&quot;,\n                    &quot;c:/develop/dm/lib/stlp45dm_static.lib&quot;);\n\nlink_param(&quot;$TARGET&quot;, &quot;$OBJ&quot;);\nmake();\nshell_command(&quot;del *.obj&quot;);\n</code></pre><p>首先，第一行对应的就是目标文件target函数，后续的每一个Lua函数都能在最初的函数定义里找到。</p><p>在这个例子当中，我们使用的是DigitalMars的C/C++编译器，执行文件叫dmc.exe。我们可以看到，在linker和compiler函数里都填写了dmc.exe，说明编译器和链接器都是dmc.exe文件。</p><p>现在来看一下在C/C++里面是如何定义这个类的。</p><pre><code>struct my_make\n{\n      string target;\n      string compiler;\n      string linker;\n      vector&lt;string&gt; source_code;\n      vector&lt;string&gt; source_object;\n      vector&lt;string&gt; c_param;\n      vector&lt;string&gt; l_param;\n};\n</code></pre><p>为了便于理解，我将C++类声明改成了struct，也就是把成员变量改为公有变量，你可以通过一个对象直接访问到。</p><p>随后，我们来看一下如何将target、compiler和linker传入到C函数里面。</p><pre><code>int compiler(lua_State* L)\n{\n      string c = lua_tostring(L, 1);\n      get_my_make().compiler = c;\n      return 0;\n}\nint linker(lua_State* L)\n{\n      string l = lua_tostring(L, 1);\n      get_my_make().linker = l;\n      return 0;       \n}\nint target(lua_State* L)\n{\n      string t = lua_tostring(L, 1);\n      get_my_make().target = t;\n      return 0;\n}\n\n</code></pre><p>在这三个函数里面，我们看到，get_my_make函数就是返回一个my_make类的对象。这个具体就不进行说明了，因为返回对象有多种方式，比如new一个对象并且return，或者直接返回一个静态对象。</p><p>随后，我们直接使用了Lua函数lua_tostring，来得到Lua传入的参数，比如如果是target的话，我们就会得到”test.exe”，并且将这个字符串传给my_make对象的 string target 变量。后续的compiler、linker也是一样的道理。</p><p>我们接着看下面两行。</p><pre><code>source_code(&quot;c.cpp&quot;, &quot;fun.cpp&quot;, &quot;x.cpp&quot;);\nsource_object(&quot;c.obj&quot;, &quot;fun.obj&quot;, &quot;x.obj&quot;);\n</code></pre><p>这两行填入了cpp源文件以及obj中间文件，这些填入的参数并没有一个固定值，可能是1个，也可能是100个，那在C/C++和Lua的结合里面，我们应该怎么做呢？</p><p>我们看到一个函数lua_gettop。这个函数是取得在当前函数中，虚拟机中堆栈的大小，所以返回的值，就是堆栈的大小值，比如我们传入3个参数，那么返回的就是3。</p><p>接下来可以看到，使用Lua的计数方式，从1开始计数，并且循环结束的条件是和堆栈大小一样大，然后就在循环内，将传入的参数字符串，压入到C++的vector中。</p><p>随后的source_object、compile_param和link_param都是相同的方法，将传入的参数压入到vector中。</p><p>你可能要问了，我在Lua的代码中看到了$TARGET、$OBJ、$SRC等字样的字符串，这些字符串的处理在哪里，这些字符串又是做什么的呢？</p><p>这些字符串是替代符号，你可以理解为C语言中printf函数的格式化符号，例如 “%d %s”等等，虽然在这里，这些符号都是自己定义的，但是我们仍然需要解析它们。</p><p>其实解析的步骤并不难，我们只需要将vector内的内容提取出来，对比是不是字符串$TARGET等，如果是的话，就被替代为前面我们在target函数或者source_code函数中所定义的内容。</p><p>我们拿source_code部分来举例，来看一下部分代码。</p><pre><code>void run()\n      {\n               string command_line;\n               string src = &quot;$SRC&quot;;\n               string tar = &quot;$TARGET&quot;;\n               string obj = &quot;$OBJ&quot;;\n        for(int i = 0; i &lt; source_code.size(); i++)\n         {\n         ..............\n        for(int j=0; j&lt;c_param.size(); j++)\n                        {\n                                 if(c_param[j] == src)\n                                 {\n                                 command_line += source_code[i];\n                                        .....\n                                         }\n                       }\n          }\n</code></pre><p>在这部分的代码里面可以看到，我们将压入的source_code内容进行循环。在循环之后，必须对c_param（compile_param），也就是编译参数进行循环。当我们发现编译参数里面出现了$SRC这个替代字符串的时候，就将source_code的内容（其实就是源代码文件）合并到command_line（命令行）里面去，然后整合成为一个完整的、可以运行的命令行。</p><p>随后我再贴一部分代码，可以看到别的可替代字符串是怎么做的。</p><pre><code>else if(c_param[j] == obj)\n{\n      command_line += source_object[i];\n}\nelse if(c_param[j] == tar)\n{\n      command_line += target;\n}\n</code></pre><p>我们对替代字符串做了相同的比较，如果是一致的话，就将被替代内容添加到command_line变量里面，组成一个完整的可运行命令行。</p><p>这个run函数其实就是在make的时候调用的函数。至于如何调用这一串command命令，在C里面最简单的方式就是调用system函数，或者使用execl函数系列。注意，这个execl并不是来自微软的excel表格，而是C语言的函数。</p><p>我们封装完了Lua部分的代码之后，就需要将Lua的函数注册到Lua虚拟机里面，这个我上一节已经具体说过了。</p><p>最后，由于我们的Lua源代码本身就是一个Makefile文件，所以我们不需要做过多的解析，直接将这个源代码输入给Lua虚拟机即可。</p><pre><code>string makefile;\nifstream in(&quot;my_makefile&quot;);\nmakefile = &quot;my_makefile&quot;;\nif(!in.is_open())\n{\nin.close();\n}\nelse luaL_dofile(L, makefile.c_str());\n</code></pre><p>在这段代码里面，我们首先使用C++的fstream库中的ifstream来尝试读取是不是有这个my_makefile文件，如果没有的话，就跳过，并且关闭文件句柄，如果存在的话，就把这个文件填入到Lua虚拟机中，让Lua虚拟机直接运行这个源文件。所以这种方式是最简单快捷的。</p><p>代码有点多，不要担心，我带你梳理一下今天的内容。</p><ol>\n<li>\n<p><strong>利用C/C++语言和Lua源代码进行交互，从Lua代码中获取数据并且在C语言里面进行算法的封装和计算，最后将结果返回给Lua。</strong> 我们在C/C++语言里面进行大量的封装和算法提取，并且也利用C/C++进行调用和结果的呈现，这是一种常用的方式，也就是C语言占比60%～70%，Lua代码占比30%～40%。</p>\n</li>\n<li>\n<p>另一种比较好的方式是，<strong>使用C/C++编写底层实现逻辑，随后将数据传输给Lua，让Lua来做逻辑运算，最终将结果返回给C语言并且呈现出来</strong>。这是很多人在游戏开发中都会做的事情，比如我们编写地图编辑器，先在Lua中编写好逻辑，用C语言在界面中呈现出来即可。如果反过来做的话，那就会出现大量的硬代码，是很不合适的。所以这种情况下，C语言占比30%～40%，Lua代码占比60%～70%。</p>\n</li>\n<li>\n<p><strong>Lua可以是一种胶水语言。严谨地说，像Python、Ruby等脚本语言，都是合格的胶水语言。</strong> 在这种情况下，胶水语言起到的作用就是粘合系统语言（C/C++）和上层脚本逻辑。所以，使用胶水语言，就像是一种动态的配置文件。<br>\n按照普通的配置文件来讲，你需要手工解析比如类似INI、XML、JSON等配置文件，随后按照这些文件的内容来做出一系列的配置，但是胶水语言不需要，它本身就是一种动态的语言。<br>\n你也可以把它当作一种配置的文件，就像今天讲的Makefile，它可以不需要你检测语法问题，这些问题在Lua虚拟机本身就已经做掉了，你需要做的就是将我们脑海里想让它做的事情，通过C和Lua的库代码进行整合，直接使用就可以了。所以，<strong>胶水语言的本身就是一个配置文件，同时它也是一个脚本语言源代码。</strong></p>\n</li>\n</ol><h2>小结</h2><p>在使用C/C++结合脚本语言的时候，需要梳理这些内容，比如哪些是放在C/C++硬代码里写的，那些可以放到脚本语言里写，梳理完后，就可以将脚本语言和C/C++结合起来，编写出易于修改脚本逻辑（如果有不同需求，可以很方便地改写脚本而不需要动C/C++硬代码）、易于使用的工具。</p><p>现在给你留一个小问题吧。</p><p>在Lua当中有table表的存在，如何在C语言中，给Lua源代码生成一个table表，并且可以在Lua中正常使用呢？</p><p>欢迎留言说出你的看法。我在下一节的挑战中等你！</p>",
        article_title: "第21讲 | 如何使用脚本语言编写周边工具？",
      },
    ],
  },
  {
    chapterTitle: "第五章：服务器端开发",
    children: [
      {
        title: "第22讲 | 如何选择合适的开发语言？",
        id: 12324,
        content:
          '<p>有许多编程语言可以用来开发服务器端。一些语言对于网络开发有先天优势，一些语言没有先天优势，但是能完成任务，而有一些语言，则不太适合。今天，我就来具体讲一讲这些语言来开发网络服务的优劣势。</p><h2>你了解这些编程语言吗？</h2><p><strong>C/C++</strong> 是最标准的开发语言，速度快，并发性能高，能最大程度利用机器资源完成任务。现在C/C++层面拥有无数网络开发库和SDK，知名的有ACE、Boost/Asio、ICE等等。但是缺点是，开发效率不比别的语言来得高，出错后常常只有熟练的程序员才能定位问题并且作出修复。</p><p><strong>Go</strong>是2009年新出现的语言。Go天生适合编写网络程序。它也是一种系统级的语言，可以直接编译为执行文件，当然由于封装了大量的语法糖，所以编译出来的文件会更大，它天生支持并发操作，所以很多时候你不需要像C/C++一样手工去处理。缺点是，Go语言仍然存在许多语法方面的坑，你可以去 <a href="https://studygolang.com/">https://studygolang.com/</a> 学习最新的资料。</p><p><strong>Java</strong>是公认的编写网络服务的第一大语言。在运行性能和开发效率上，有很好的折中效果。Java拥有众多的中间件和开发库，调试方便，一般的运维人员也有极为广泛可用的第三方维护工具可以使用。缺点是，Java的运行效率虽然有了质的飞跃，但因为中间隔了一层虚拟机，所以仍然比不上系统开发语言编写的软件。另外，Java的发布和部署需要众多的依赖包和库，软件体积庞大也是其重要弊病。</p><!-- [[[read_end]]] --><p>如果深入理解，<strong>Python、Ruby</strong>这两种语言的相似程度以及对系统的支持程度，可以用C和C++的相似程度来相比。你或许会很疑惑，毕竟Python和Ruby的语法几乎不一样，Python需要格式化源代码，而Ruby并不需要；Python更严谨，Ruby更开放；Python用户更多，Ruby用户更少。</p><p>不可否认的是，两种语言编写网络程序都非常方便，也非常高效。两种语言都可以在100行内编写出一个简单的、完全可以直接使用的网络服务器程序。但是这两种语言的弊病也很明显，那就是速度不够快。</p><p>比之Java，或许运行效率更慢一点，但由于目前机器硬件水平的提升，软件效率不足的缺点一部分已经被硬件所弥补，但是仍然不能否认，Python、Ruby语言适合IO密集型开发，而不适合计算密集型的开发。</p><p>Python的书籍比Ruby多好几倍，然而你如果仔细去看的话就会发现，Ruby的书籍质量明显比Python高几个等级，所以如果要看好的脚本语言的书籍，Ruby相关的书籍是首选，我这里推荐一本<a href="https://book.douban.com/subject/2032343/">Programming in Ruby</a>，有兴趣的话可以找来看看。</p><p><strong>Node.js</strong>从前端语言变成后端语言，让编程界眼前为之一亮。随后的发展大家也有目共睹，Node.js由于使用JavaScript语言语法，所以我们一般采用事件驱动的形式，以及非阻塞的模型来进行网络开发。因为这些特点，它非常适合做分布式的、数据密集型的工作。但是缺点也很明显，Node.js是单线程，无法很好地使用多核CPU，这个问题在Python、Ruby语言中也很明显。</p><p>或许你没有听说过<strong>Erlang</strong>这种语言，这种语言最初是由爱立信开发的。它的初衷是让程序员应对大规模并发、分布式、软件实时并行系统进行编程。最早期的版本在80年代就出现了，但是一直到1998年才开源。</p><p>Erlang也不是系统语言，它有自己的虚拟机和解释器。当然和Java一样，Erlang也支持将代码编译为Native Code来运行。Erlang的缺点就是类型问题，它并非强类型语言。由于是事件编程，所以导致会在运行时无法匹配类型而出错，不过这些问题可以使用规范的编程方法来规避。</p><p>这么多种编程语言，整合起来看，大致可以把他们分为三类。</p><p><strong>系统级编程语言</strong>，诸如汇编、C、C++。这种编程语言执行效率快，并发量也比较高，作为编写网络服务的第一语言，一台服务器就能支撑许多人。缺点是开发效率不够高，需要几年以上经验的程序员才能搞定。</p><p><strong>专门为网络服务器开发的语言</strong>，诸如Go、Erlang。这种语言编写高并发和开发效率都不是问题，有很好的折中效果。缺点就是语言比较新，有许多的坑等着后来的程序员去填，而且语言、语法等系统机制要随着进一步的发展才能稳定下来。</p><p><strong>解释型脚本语言</strong>，诸如Python、Ruby。 这类语言的开发效率非常高效，在现在的服务器硬件上，也能支撑不少用户，但是唯一的缺点是，运行效率低下。虽然也有解决方案，但仍然不能对抗高性能的系统编程语言和专业网络开发的语言。</p><h2>如何选择一种合适的语言来编写网络服务？</h2><h3>Web服务</h3><p>现在有一种流行的说法叫前后端分离。对于编写C/S结构的程序员，听到这种说法应该会比较蒙，客户端和服务器端难道不是本来就分离的吗？</p><p>很长的一段时间里，在Web的世界中，前后端都是混合在一起编写的，比如PHP的方式，只有用到Ajax交互的时候，才需要用到后端的代码。但是前后端一分离，后台就需要做更多的工作了，当然前端的工作也不会变少。</p><p>编写Web服务，需要HTTP和HTTPS的服务体系，那么在这种情况下，使用nginx、Apache作为静态页面路由，Java、Tomcat、Python、Ruby等脚本语言就有了用武之地。因为页面只需要使用JSON交互即可。</p><p>所以，编写Web服务，我们可以选择Java、Python、Ruby。但是如果公司财力物力有限，再考虑到招人成本的问题，次选也可以是Java语言，第一是写Java的人够多，第二是Java成熟的类库够多，因此，一旦出问题，有解决经验的人也比较多。</p><h3>Socket服务</h3><p>传统TCP/IP和UDP服务，或者最近的WebSocket等，都需要快速响应和并发操作，在这种情况下，系统级编程语言和网络编程语言就可以派上用场了。</p><p>如果公司的项目需要更快更高效，并且财力也允许，那么选择C、C++、Go、Erlang等编程语言未尝不是一种选择。当然Java也能很好地提供服务，但是从业务上来讲，既然选择了Socket服务模式，那么就必然是对并发量有一定的要求，所以选择上述这些语言更合适。</p><h3>混合模式</h3><p>这类业务，既有HTTP/HTTPS的服务，也有Socket服务，那么如何平衡两者之间的语言成本？如何平衡程序员之间技术栈的问题呢？</p><p>如果要做一款短期内必须上线的产品，我建议选择成熟的、有大量解决方案的，开发人员不短缺的语言，比如Java；或者能快速做出原型的语言，比如服务器专有语言Go。如果是长期发展的产品，并不那么着急成型，那么选择稳定成熟的，人员素质高的语言，比如Python、Java等。</p><p>至于平衡技术栈的问题，首先要选择网上有众多解决方案的语言，其次是找成熟的语言，比如Python、Java、Ruby。如果针对某种特殊的产品，比如并发要求特别高的，那么只有选择系统语言或者专门的语言，比如Go、C++等。</p><p>看到这里，你是不是觉得Java语言是一种万能药，或者是银弹？错了，这个世界上没有银弹。Java虽然有其独特的优势，但是其被人诟病的地方，也是有不少的。</p><p>第一点莫过于速度。就算拥有JIT编译，总体速度仍然比不上C/C++，但是事实上这些因素综合考虑并不算特别大的弊病，因为硬件资源提升后，速度这些问题已经可以“得过且过”了。</p><p>那么从语言本身来看，如果说C/C++语言本身的弊病是因为系统平台导致的，那么Java语言的弊病就是因为继承自C++，却没有做更彻底的改革而导致的。</p><p>我随便举一个例子，比如说switch case判断语句，硬生生地从C/C++处直接继承了下来，因为C/C++只允许使用int、enum（其实是int）、char（提升为int）作为判断类型，而Java也是直接将这套规范继承了下来。</p><p>再比如，在Java里面，异常检查也是一个痛苦的根源，程序员不得不写下无数try catch语句以使得将捕获的异常，转变为运行时的异常，然后再将之抛出去，这样一来，使用Java编写的API将缺少灵活和扩展性。</p><p>那如果选择了Python或者Ruby等脚本语言进行开发，却需要大量高并发的操作该怎么办呢？我们可以选择多进程（不是多线程）编程的方式进行开发，代码尽量简洁、高效，一个进程兼顾一个任务，进程之间的通信方式要尽量高效、简洁，比如可以使用自定义的队列等方式。</p><h2>小结</h2><p>学完这一节，你应该对使用各种编程语言来编写网络服务有了一个更深的了解。我主要讲了以下几个内容。</p><ul>\n<li>\n<p>编程语言可以大致分为三类，系统级编程语言、专为网络服务器开发的编程语言和解释型脚本语言。</p>\n</li>\n<li>\n<p>在编写网络服务的时候，可以根据要编写的是Web服务、Socket服务，还是混合模式，来选择合适的编程语言。</p>\n</li>\n</ul><p>给你留一个小问题吧。</p><p>如果让你来使用C/C++粘合Lua脚本来编写网络服务器，你会怎么设计这个程序框架？</p><p>欢迎留言说出你的看法。我在下一节的挑战中等你！</p>',
        article_title: "第22讲 | 如何选择合适的开发语言？",
      },
      {
        title: "第23讲 | 如何定制合适的开发协议？",
        id: 12451,
        content:
          "<p>什么是开发协议？说得简单一点，就是一种客户端和服务器端的网络沟通协议（Protocol）。</p><p>广义上说，协议是计算机各种设备之间沟通的桥梁。比如网络之间需要协议，ping一个网站是否通顺也需要协议，广播地址也需要协议。我们甚至可以说键盘鼠标操作事件也需要协议，Dubbo架构也需要协议沟通等等。</p><p>从狭义上说，协议指的就是网络协议。比如在网络游戏中，客户端和服务器端之间的内容交互，就需要网络协议；在Web网站中，前端和后端的交互，也需要协议；再比如，邮件服务的网络交互也需要协议的交互等等。可以说，任何与网络相关的服务都少不了协议的支撑。</p><p>在游戏开发中，我们可以自定义一套自己的开发协议，也可以把现成的开发协议拿来使用。具体怎么做呢？我们先来看现在网上用得比较多的几种协议。</p><h2>三种最流行的开发协议</h2><h3>XML</h3><p>XML几乎是网络上最早出现的传输协议之一。在最早的Web开发中，XML可以作为网络协议，也可以用作配置文件。比如某些游戏或者某些应用的配置文件，都可以使用XML来编写。</p><p>从人类的角度讲，它的可读性比较强，解析也比较方便。我们先来看几种解析方式。</p><p>解析方式是这些协议被程序理解的一种方式，按照这种方式解析，和我后面要说的自定义协议的解析和剖析结合起来，乃前后呼应之奇效。</p><!-- [[[read_end]]] --><ol>\n<li>\n<p>PULL方式：PULL解析是一种专门为安卓设备解析XML文件设计的解析方式。这种解析方式更适用于移动设备。PULL解析和我们下面要说的SAX解析比较类似，不一样的地方是PULL读取XML文件后，触发相应的事件调用方法返回的是number。另外，PULL方式可以控制程序的解析停止位置，不需要全部解析，可以随时停止。</p>\n</li>\n<li>\n<p>SAX方式：SAX（Simple API for XML）采用事件驱动型方式。语法解析从发现元素开始、元素结束、文本、文档的开始或结束等，就开始事件的发送，程序员编写响应这些事件的代码，就可以直接将数据保存下来。所以优点是，不需要载入整个文档，资源占用比较少。<br>\nSAX解析器的代码比DOM解析器的代码更精简，一般应用于Applet技术。缺点就是，这种解析方式并不持久，等事件消息过去后，如果你没有保存数据，那么数据就丢失了；从事件的消息中我们只能得到文本数据，但不知道这个文本属于哪个元素。但是，我们只需XML文档的少量内容就可以解析出我们所需的数据，所以耗费的内存更少。</p>\n</li>\n<li>\n<p>DOM方式：DOM（Document Object Model）是最传统的解析方式。解析器读入整个文档，然后在内容中构建一个XML的树结构，使用代码就可以操作这个树结构。优点是整个文档树在内存中，便于操作；而且支持删除、修改、重排等多种功能。缺点是将整个文档调入内存比较浪费计算机的时间和空间，但是如果一旦解析了文档，还需多次访问这些数据的话，这种方式就可以起到作用了。</p>\n</li>\n</ol><h3>JSON</h3><p>其实，目前XML已经不太流行，取而代之的是JSON。JSON是一种轻量级的数据交换格式。它用完全独立于编程语言的文本格式来存储和表示数据。</p><p>比之XML，它看起来更加简洁和清晰，层次结构分明；JSON易于阅读和编写，在程序方面，也易于机器解析和生成，同时也提升了网络传输效率。这些优点使得JSON很快在程序员中流行起来，成为理想的数据交换语言。</p><p>它也是移动端比较常见的网络传输协议。相对于前面所说的XML格式，它更为简单，体积更小，加之对网络流量和内存的需求更小，所以JSON比XML更适合移动端的使用。</p><p>我们来看一下JSON的几种流行的解析程序库。</p><ol>\n<li>\n<p>Gson是谷歌开源的一种解析方法，使用Java编写，你可以通过提供的JAR文件包，使用静态方法直接将JSON字符串解析成Java对象，这样使用起来简单方便。</p>\n</li>\n<li>\n<p>FastJSON是阿里开源的一个解析JSON数据的类库。</p>\n</li>\n<li>\n<p>JSONObject也是一个解析JSON字符串的Java类。第二、第三这两种用的人都比较少，我就不多介绍了。</p>\n</li>\n</ol><p>当然，支持别的语言的库也有很多，由于JSON比较流行，所以各种语言都有其支持的类库版本，比如Python、C++、Ruby等等。</p><h3>ProtoBuf</h3><p>ProtoBuf全称Google Protocol Buffer， 是谷歌公司开发的内部混合语言数据标准。目前正在使用的有接近五万种报文格式定义和超过一万两千多个.proto文件。它们都用于RPC系统和持续数据存储的系统。</p><p>这是一种轻便、高效的结构化数据存储格式，可以用于结构化数据的序列化操作。它很适合用作数据存储或RPC数据交换格式。可以用于通讯协议、数据存储等领域。由于是独立的协议系统，所以它和开发语言、运行平台都没有关系，可以用在扩展的序列化结构数据格式。目前提供了 C++、Java、Python 、Ruby、Go等语言的开发接口API。</p><p>ProtoBuf方便的地方在于，它有一款编译器可以将.proto后缀的协议文件，编译成C++、Java、Python等语言的源代码。你可以直接看到和利用这些源代码，且不需要自己去做解析，所以不同语言之间使用ProtoBuf的协议规范都是一样的，但是有一个问题是，ProtoBuf存储的文件格式是二进制的，由于是二进制的，所以程序员需要调试其保存的内容就有点麻烦，当然这可能只是对于某些人来说的瑕疵吧，对于大部分人来讲，方便性还是大于瑕疵的。</p><p>ProtoBuf的编码风格是这样的，花括号的使用类似C/C++、Java。数据类型的命名方式使用驼峰命名，比如DataType、NewObject。字段的变量小写并使用下划线连接，类似GNU规范，比如proto_buf、user_name。枚举类型使用大写，并使用下划线连接，比如MY_HOME，BEST_FRIEND。</p><p>Protobuf并不是针对大型数据设计的，Protobuf对于1M以下的message有很高的效率，但是当message大于1M的时候，Protobuf的效率会逐步降低。</p><h2>如何自己定义协议包？</h2><p>我们讲完了三种目前最流行的开发协议，接下来我们要讲讲如何自己定义协议包。</p><p>我们所说的<strong>协议包</strong>，是<strong>在TCP和UDP传输之上的协议包，也就是通过字符串的形式发送的协议包</strong>。这些协议包在客户端和服务器之间做了约定，也就是说，客户端和服务器都能通过拿到协议包来进行解包操作，并且进行一系列的逻辑运算并返回结果，当然结果也是协议包的形式发送出去。</p><p>一个好的协议不仅能节约网络带宽，也能让接收端快速拿到和解析需要的内容。设计协议包，必须保证<strong>安全性</strong>和<strong>完整性</strong>。</p><p>为了保证完整性，接收方需要知道协议的长度，或者知道协议的尾部在哪里。</p><p>我们可以给协议最末尾添加分隔符，该分隔符需要特殊字符。不能被传输的内容所混淆，又要能达到方便接收方辨认，因此，该特殊字符需要具有唯一性。比如我们可以将“!@#$”这四个字符做为分隔符，那么协议看起来可能是这样：</p><pre><code>[协议头][协议体][协议结尾分隔符]\n</code></pre><p>你可能要问了，在传输的过程中，我知道了协议长度，不需要协议头，只需要协议长度就可以？是的。因为有了协议长度，协议尾部有没有分隔符就不重要了。如果我们固定好输出协议长度的字节数，就可以忽略协议头。在这种情况下，协议看起来像是这样：</p><pre><code>[协议长度2字节][协议体]\n</code></pre><p>这样简单地就能定义整个协议的内容。</p><p>在读取的时候，我们只需要读取开头的两个字节，转换为一个short的长度，或者四个字节一个int的长度，在第三个字节开始就是协议体。让程序开始计算长度，如果长度少于协议长度所定义的长度，那就继续接收，如果接收长度超过协议所定义的长度，切割协议体，并将下一段开始的协议存储到内存中留待下一次取出。这种方式是最方便的。</p><p>我们在保证协议完整性的同时，也要保证协议不被破坏和篡改，也就是所说的安全性。在这种情况下，最直接的方式，就可以将协议内容进行加密。比如SHA-256或者AES等等加密方式将内容加密，随后传输过去，最简单的做法就是将密码在客户端和服务器端协商好就可以了。</p><p>看起来可能是这个样子：</p><pre><code>[协议长度2字节][加密协议体]\n</code></pre><h2>小结</h2><p>这节内容差不多了，我们总结一下。我和你介绍了这几个内容。</p><ul>\n<li>\n<p>我介绍了三种的开发协议XML、JSON和ProtoBuf，以及它们对应的解析方式。XML是网络上最早出现的传输协议之一。</p>\n</li>\n<li>\n<p>游戏或应用的配置文件，都可以使用XML来编写，但是目前XML已经不太流行，取而代之的是JSON。</p>\n</li>\n<li>\n<p>ProtoBuf适合用作数据存储或RPC数据交换格式，缺点是保存比较麻烦，但是总体来讲还是比较方便的。</p>\n</li>\n<li>\n<p>自己定义协议包需要考虑完整性和安全性。接收方需要知道协议的长度，或者知道协议的尾部在哪里，就可以保证协议包的完整性。而最直接的给协议包加密，就可以保证安全性。</p>\n</li>\n</ul><p>最后，给你留一个小问题吧。</p><p>在自定义协议中，如果使用添加协议结尾的方式来做协议，如何才能保证协议结尾分割字符串不和协议本身的二进制内容重复？</p><p>欢迎留言说出你的看法。我在下一节的挑战中等你！</p>",
        article_title: "第23讲 | 如何定制合适的开发协议？",
      },
      {
        title: "第24讲  | 不可忽视的多线程及并发问题",
        id: 12755,
        content:
          "<p>既然我们说到了服务器端的开发，我们就不得不提起多线程和并发的问题，因为如果没有多线程和并发，是不可能做网络服务器端的，除非你的项目是base在Nginx或者Apache之上的。</p><h2>多线程和并发究竟有什么区别和联系？</h2><p>提到并发，不得不提到并行，所以我就讲这三个概念：并发、并行，以及多线程。作为初学者，你或许不太明白，多线程和并发究竟有什么区别和联系？下面我们就分别来看看。</p><p><strong>并发</strong>出现在电脑只有一个CPU的情况下，那如果有多个线程需要操作，该怎么办呢？CPU不可能一次只运行一个程序，运行完一个再运行第二个，这个效率任谁都忍受不了啊！所以，就想了个办法。</p><p>CPU将运行的线程分成若干个CPU时间片来运行。不运行的那个线程就挂起，运行的时候，那个线程就活过来，切换地特别快，就好像是在同时运行一样。</p><p>你可以想象这个场景，有一个象棋大师，一个人对十个对手下棋，那十个人轮流和他下。大师从1号棋手这里开始下，下完1号走到2号的棋手面前，下2号棋手的棋，一直轮流走下去，直到再走回1号棋手这里再下一步。只要象棋大师下象棋下得足够快，然后他移动到下一位棋手这里又移动得足够快，大家都会觉得好像有十位象棋大师在和十个对手下棋。事实上只有一位象棋大师在下棋，只是他移动得很快而已。</p><!-- [[[read_end]]] --><p><strong>并行</strong>和并发不同，并行是出现在多个物理CPU的情况下。在这种情况下，并行是真正的并发状态，是在物理状态下的并发运行。所以，并行是真的有几位象棋大师在应对几个对手。当然在并行的同时，CPU也会进行并发运算。</p><p>而<strong>多线程</strong>是单个进程的切片，单个进程中的线程中的内存和资源都是共享的，所以线程之间进行沟通是很方便的。</p><p>多线程的意义，就好比一个厨师，他掌管了三个锅，一个锅在煮排骨，一个锅在烧鱼，另一个锅在煮面，这三个锅内容不同，火候不同，但是所有的调料和资源，包括菜、油、水、盐、味精、糖、酱油等等，都来自同一个地方（也就是资源共享），而厨师自己是一个进程，他分配了三个线程（也就是三个锅），这三个锅烧着不同的东西，三个食物或许不是同时出锅的，但是厨师心里有数，什么时候这个菜可以出锅，什么时候这个菜还需要煮。这就是多线程的一个比喻。</p><p>我们在编写网络服务器的时候，多线程和并发的问题是一定会考虑的。我们说的网络并发和CPU的并发可以说是异曲同工，也就是说，<strong>网络并发的意义是，这个网络服务器可以同时支撑多少个用户同时登陆，或者同时在线操作</strong>。</p><h2>为什么Python用多个CPU的时候会出现问题？</h2><p>那么我们又回头来看，为什么Python、Ruby或者Node.js，在利用多个CPU的时候会出现问题呢？这是因为，它们是使用C/C++语言编写的。是的，问题就在这里。</p><p>我们后续的内容还是会用Python来写，所以我们先来看看Python的多线程问题。Python有个<strong>GIL</strong>（Global Interpreter Lock，全局解释锁），问题就出在GIL上。</p><p>使用C语言编写的Python版本（后面简写为C-Python）的线程是操作系统的原生线程。在Linux上为pthread，在Windows上为Win thread，完全由操作系统调度线程的执行。</p><p>一个Python解释器进程内有一条主线程，以及多条用户程序的执行线程。即使在多核CPU平台上。由于GIL的存在，所以会禁止多线程的并行执行。这是为什么呢?</p><p>因为Python解释器进程内的多线程是合作多任务方式执行的。当一个线程遇到I/O（输入输出）任务时，将释放GIL锁。计算密集型（以计算为主的逻辑代码）的线程在执行大约100次解释器的计步时，将释放GIL锁。你可以将计步看作是Python虚拟机的指令。计步实际上与CPU的时间片长度无关。我们可以通过Python的库sys.setcheckinterval()设置计步长度来控制GIL的释放事件。</p><p>在单核的CPU上，数百次间隔检查才会导致一次线程切换。在多核CPU上，就做不到这些了。从Python 3.2开始就使用新的GIL锁了。在新的GIL实现中，用一个固定的超时时间来指示当前的线程放弃全局锁。在当前线程保持这个锁，且其他线程请求这个锁的时候，当前线程就会在五毫秒后被强制释放掉这个锁。</p><p>我们如果要实现并行，利用Python的多线程效果不好，所以我们可以创建独立的进程来实现并行化。Python 2.6（含）以上版本引进了multiprocessing这个多进程包。</p><p>我们也可以把多线程的关键部分用C/C++写成Python扩展，通过ctypes使Python程序直接调用C语言编译的动态库的导出函数来使用。</p><p>C-Python的GIL的问题存在于C-Python的编写语言，原生语言C语言中，由于GIL为了保证Python解释器的顺利运行，所以事实上，多线程只是模拟了切换线程而已。这么做的话，如果你使用的是IO密集型任务的时候，就会提高速度。为什么这么说？</p><p>因为写文件读文件的时间完全可以将GIL锁给释放出来，而如果是计算密集型的任务，或许将会得到比单线程更慢的速度。为什么呢？事实上GIL是一个全局的排他锁，它并不能很好地利用CPU的多核，相反地，它会将多线程模拟成单线程进行上下文切换的形式进行运行。</p><p>我们来看一下，在计算密集型的代码中，单线程和多线程的比较。</p><p>单线程版本：</p><pre><code>from threading import Thread\n  import time\n  def my_counter():\n      i = 0\n      for x in range(10000):\n          i = i + 1\n      return True\n  def run():\n      thread_array = {}\n      start_time = time.time()\n      for tt in range(2):\n          t = Thread(target=my_counter)\n          t.start()\n          t.join()\n      end_time = time.time()\n      print(&quot;count time: {}&quot;.format(end_time - start_time))\n  if __name__ == '__main__':\n      run()\n</code></pre><p>多线程版本：</p><pre><code>from threading import Thread\n  import time\n  def my_counter():\n      i = 0\n      for x in range(10000):\n          i = i + 1\n      return True\n  def run():\n      thread_array = {}\n      start_time = time.time()\n      for tt in range(2):\n          t = Thread(target=my_counter)\n          t.start()\n          thread_array[tid] = t\n      for i in range(2):\n          thread_array[i].join()\n      end_time = time.time()\n      print(&quot;count time: {}&quot;.format(end_time - start_time))\n  if __name__ == '__main__':\n      run()\n</code></pre><p>当然，我们还可以把这个ranger的数字改得更大，看到更大的差异。</p><p>当计步完成后，将会达到一个释放锁的阀值，释放完后立刻又取得锁，然而这在单CPU环境下毫无问题，但是多CPU的时候，第二块CPU正要被唤醒线程的时候，第一块CPU的主线程又直接取得了主线程锁，这时候，就出现了第二块CPU不停地被唤醒，第一块CPU拿到了主线程锁继续执行内容，第二块继续等待锁，唤醒、等待，唤醒、等待。这样，事实上只有一块CPU在执行指令，浪费了其他CPU的时间。这就是问题所在。</p><p>这也就是C语言开发的Python语言的问题。当然如果是使用Java写成的Python（Jython）和.NET下的Python（Iron Python），并没有GIL的问题。事实上，它们其实连GIL锁都不存在。我们也可以使用新的Python实作项目PyPy。所以，这些问题事实上是由于实现语言的差异造成的。</p><h2>如何尽可能利用多线程和并发的优势？</h2><p>我们来尝试另一种解决思路，我们仍然用的是C-Python，但是我们要尽可能使之能利用多线程和并发的优势，这该怎么做呢？</p><p>multiprocess是在Python 2.6（含）以上版本的提供是为了弥补GIL的效率问题而出现的，不同的是它使用了多进程而不是多线程。每个进程有自己的独立的GIL锁，因此也不会出现进程之间，CPU进行GIL锁的争抢问题，因为都是独立的进程。</p><p>当然multiprocessing也有不少问题。首先它会增加程序实现时线程间数据通信和同步的困难。</p><p>就拿计数器来举例子。如果我们要多个线程累加同一个变量，对于thread来说，申明一个global变量，用thread.Lock的context就可以了。而multiprocessing由于进程之间无法看到对方的数据，只能通过在主线程申明一个Queue，put再get或者用共享内存、共享文件、管道等等方法。</p><p>我们可以来看一下multiprocess的共享内容数据的方案。</p><pre><code>from multiprocessing import Process, Queue\n  def f(q):\n      q.put([4031, 1024, 'my data'])\n  if __name__ == '__main__':\n      q = Queue()\n      p = Process(target=f, args=(q,))\n      p.start()\n      print q.get()\n      p.join()\n</code></pre><p>这样的方案虽说可行，但是编码效率变得比较低下，但是也是一种权宜之计吧。</p><h2>小结</h2><p>我们来总结一下今天的内容。</p><ul>\n<li>\n<p>我首先介绍了几个概念。并发是单个CPU之间切换多线程任务的操作。并行是多个CPU同时分配和运行多线程任务的操作。线程是进程内的独立任务单元，但是共享这个进程的所有资源。网络的并发指的是服务器同时可以承载多少数量的人数和任务。</p>\n</li>\n<li>\n<p>而C语言编写的Python有GIL锁的问题，会让其多线程计算密集型的任务效率更低，解决方案有，利用多进程解决问题 或者 更换Python语言的实现版本，比如PyPy或者JPython等等。</p>\n</li>\n</ul><p>给你留一个小问题，如果Python以多进程方式进行操作，那么如果我们网络服务器是用Python编写的，其中一个Python进程崩溃或者报错了，有什么办法可以让其复活？</p><p>欢迎留言说出你的看法。我在下一节的挑战中等你！</p>",
        article_title: "第24讲  | 不可忽视的多线程及并发问题",
      },
      {
        title: "第25讲 | 如何判断心跳包是否离线？",
        id: 12757,
        content:
          "<p>在初学网络，编写过阻塞和非阻塞网络代码的时候，有一个问题，那就是在非阻塞的情况下，不知道对方的网络何时断开。</p><p>因为在非阻塞的情况下，如果没有接收到消息，recv的数值一直会是0。如果以这个来判断，显然是错误的。而在阻塞情况下，只要对方一断开，接收到0就说明断开了，那么我们怎么才能在非阻塞的情况下确定连接是断开还是没断开呢？</p><p>我们可以采用离线超时的方案来判断对方连接是否断开。那什么是离线超时呢？</p><p>我们都知道，人累了就要休息。你在休息的时候，有没有注意过这么一个现象，那就是你在快要睡着的时候，忽然脚会蹬一下，或者人会抽一下，这是为什么呢？</p><p>有一种说法流传很广，说，其实大脑是在不停地检测人有没有“死”，所以发送神经信号给手和腿。抽动一下，检验其是否死亡。这个就有点儿像我们检测超时，看看有没有反应。</p><p>现在我们先看一段Python代码，让它运行起来。</p><pre><code>import socket\nimport time\n\ndef server_run():\n   clients = []\n   my_server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n   my_server.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\n   my_server.bind((&quot;&quot;, 1024))\n   my_server.listen(256)\n   my_server.setblocking(False)   \n</code></pre><p>这是我节选的一部分代码。其中，在函数server_run里面，我们先定义了一个clients，这是一个列表，用于后面保存客户端连接用。my_server获得socket句柄，并且将之设置为TCP模式，随后我们绑定地址为本地（bind函数），端口号为1024，并且开始侦听，随后我们看到 setblocking函数，将之设置为非阻塞模式。</p><!-- [[[read_end]]] --><pre><code>while True:\n      time.sleep(1)\n      try:\n         client, addr = my_server.accept()\n         print client\n         client.setblocking(False)\n         clients.append(client)\n      except Exception as e:\n         print &quot;no client incoming&quot;\n      for cli in clients:\n         try:\n            data = cli.recv(1024)\n            if data:\n               print data\n            else:\n               cli.close()\n               clients.remove(cli ) \n         except Exception as e:\n            print &quot;no data from &quot;, cli\n   my_server.close()\n</code></pre><p>在一个大循环内，我们做了如下几件事情：第一个是accept，只要有客户端进来，我们就accept，如果没有客户端进来，一直等待状态下，就打印 no client incoming字符串，如果有客户端进入的话，就直接将新客户端放入列表。</p><p>我们在启动函数的时候，如果没有客户端连接，就会出现这样的字样：</p><img></img><p>然后我们使用Windows下的telnet命令来模拟客户端。输入telnet 127.0.0.1 1024，服务器端代码会出现这样的字符串：</p><img></img><p>我们打印新的客户端连接的对象地址，并且将新的客户端连接句柄放入列表里面。随后，循环进入到了取出新客户端列表，并且做出判断，每次接收1024字节。如果没有，则显示 no data from &lt;xxxx地址&gt;；如果有，那就显示输入的字符串。</p><p>好了，现在我们打开Windows任务管理器，找到拥有telnet的程序，并且“杀死”它。</p><img></img><p>随后，我们会发现，命令行提示符出现了如下内容的字符串：</p><img></img><p>按照道理，服务器不是应该断开连接了吗？它应该能知道客户端断开了不是吗？</p><p>错，服务器端根本不知道对方已经被“杀死”了，所以它的状态仍然在接收中。由于是TCP握手，除非你正常将telnet程序关闭，才会让服务器端正常接收到客户端关闭的消息，否则，你永远不知道对方已经退出连接了。</p><p>所以<strong>心跳包的作用</strong>就在这里，心跳包<strong>允许你每隔多少毫秒发送数据给服务器端，告诉服务器我还活着，否则服务器就当它已经死了，确认超时，并且退出</strong>。</p><p>事实上，在TCP/IP的协议层中，本身是存在心跳包的设计的，就是TCP协议中的SO_KEEPALIVE。</p><p>系统默认是设置2小时的心跳频率。需要用setsockopt选项将SOL_SOCKET.SO_KEEPALIVE设置为1，打开，并且可以设置三个参数tcp_keepalive_time，tcp_keepalive_probes，tcp_keepalive_intvl，分别表示连接闲置多久开始发keepalive的ACK包、发几个ACK包不回复就当连接端“死”了。</p><p>这种心跳检测包是属于TCP协议底层的检测机制，上层软件只是解析显示网口的有用数据包，收到心跳包报文属于TCP协议层的数据，一般软件不会将它直接在应用层显示出来，所以用户是看不到的。以太网中的心跳包可以通过以太网抓包软件分析TCP/IP协议层的数据流看到。报文名称是TCP Keep-Alive。</p><p>当然，我们也可以做应用层的心跳包检测，我们在编写游戏服务器的时候，就可以自定义心跳服务，TCP层的心跳服务是为了保持存活的，但是应用层的心跳，则是拥有更明确或者其他的目的（比如对方是否还活着）。</p><p>我们专门独立一台服务器做心跳服务器，连接客户端和真正的游戏逻辑服务器，那么我们希望逻辑服务器的同步率和心跳服务器统一，也就是说，<strong>心跳服务器负责的就是发送心跳包和客户端数据给逻辑服务器</strong>，逻辑服务器每一次获取数据，也是从心跳服务器获得的，那么心跳服务器能做的事情就会变得很多。</p><p>为了调试方便，我们可以利用心跳服务器，将客户端传送过去的数据包存储在本地磁盘上。如果应用或者游戏在测试的时候，就可以看到那些发送的内容，甚至可以回滚任意时段的数据内容，这样调试起来就相对方便，而不需要客户端大费周章地不停演练重现出现的错误。代码看起来是这样：</p><pre><code> def SendToServer(is_save = 0):\n      package = socket.recv(recv_len)\n      ticktock()\n      if is_save:\n          SaveToDisk(package)\n      server_socket.send(package)\n</code></pre><p>在逻辑服务器内部，每一次接收数据，都根据心跳服务包的心跳来接收，这样做的好处就是，可以随时调整心跳的频率，而不需要调整逻辑服务器的代码。</p><p>在应用层的心跳模式下，我们会有两种策略需要进行选择。</p><p>我们假定把逻辑运算设为A，心跳时间（比如代码的Sleep或者挂起）设为B。</p><p>第一种是运算时间A和心跳时间B相对固定。也就是说，不管A运算多久，B一定是固定挂起多久。</p><p>第二种策略是运算时间A和心跳时间B是实时调整。A运算时间长，挂起时间就短，如果A运算时间加上B挂起时间超过约定心跳总时间，那B就不挂起，直接进行另一个A运算。这两种策略究竟哪种好呢？</p><p>在CPU负载并不是那么严重的情况下，策略二是比较好的选择。</p><p>假设心跳Sleep时间是1000ms，运行时间规定为2000ms。如果运行时间小于等于2000ms的话，Sleep时间不变；如果运行时间超过2000ms的话，那么Sleep时间就等于Sleep时间 - (运行时间 - 2000ms)。</p><p>这样一来，平均心跳有了保障，但是在运算量加大的时候，Sleep时间已经完全被运行时间所占据，那么心跳Sleep时间就会减少到最少甚至不存在，CPU的负载就会变得很高，这种时候就需要用到策略一。</p><p>你可以这么理解。策略一是说，不管我们的运行时间多久，Sleep时间始终是一致的1000ms，这种方式保证了服务器一定会进行心跳，而不会导致负载过高等情况。</p><p>当然这只是一种简单的模型，在进行大规模运算，或者有多台服务器的时候，我们可以将两种方式合并起来进行策略交互。任务不繁重的时候采用策略二，当服务器发现任务一直很多且超过Sleep时间几次，就切换到策略一，这样可以保证心跳时间基本一致。</p><p>我们可以将心跳服务和逻辑服务分开运行，而是否放在同一台物理机并不是首要的问题，这样心跳服务器只提供心跳包，而逻辑服务通过心跳包自动判断并且调整运行频率。</p><h2>小结</h2><p>好了，我给今天的内容做一个总结。</p><ul>\n<li>\n<p>判断非阻塞模型的网络是否断开，可以使用心跳包和计算超时的方式进行断开操作，比如30秒没收到心跳包，则可以强制关闭Socket句柄断开。</p>\n</li>\n<li>\n<p>心跳包是一种服务器之间交互的方法，也可以用作服务器数据调试和回滚的策略方案。心跳包有两种策略，第一种就是运算时间A和心跳时间B相对固定，第二种策略是运算时间A和心跳时间B是实时调整。CPU的负载很高的时候用策略一，CPU负载并不是那么严重的情况下，策略二是比较好的选择。</p>\n</li>\n</ul><p>最后，给你留一个思考题吧。</p><p>如果编写的是阻塞方式的服务器代码，心跳包还有存在的意义吗？</p><p>欢迎留言说出你的看法。我在下一节的挑战中等你！</p>",
        article_title: "第25讲 | 如何判断心跳包是否离线？",
      },
      {
        title: "第26讲 | 如何用网关服务器进行负载均衡？",
        id: 13077,
        content:
          "<p>我们费劲心思做了一款游戏，那肯定希望有很多人来玩。一旦玩家数量开始多起来，服务器需要承担的压力就会变大，我们就需要做负载均衡了。</p><p>所谓的负载均衡，就是对外有一个公共地址，在请求过来的时候，通过轮询、随机分配等方式，定点到不同的服务器，以分摊服务器的压力。</p><h2>两种常用的负载均衡技术</h2><p>常用的负载均衡技术有<strong>软件模式</strong>和<strong>硬件模式。</strong></p><p>其中，硬件模式用得比较多的是F5。F5是F5 Networks公司提供的一个负载均衡器专用设备， F5 BIG-IP LTM 的官方名称叫本地流量管理器，可以做4～7层负载均衡，具有负载均衡、应用交换、会话交换、状态监控等等全备的强大网络功能。</p><p>F5硬件负载均衡的优点是，负载均衡能直接通过智能交换机实现,处理能力更强，与操作系统无关，负载性能强，适用于一大堆设备、大访问量，其缺点也是很明显的，那就是购买成本高，设备的配置冗余，有些用不上的都给默认配置了。另外，由于设备只有单个，所以单个负载均衡配置无法有效掌握所有服务器及应用状态。</p><p>硬件的负载均衡，是从网络层来判断负载规则，所以有时候软件的系统处理能力出现问题，网络硬件还可以作出负载的动作。</p><p>软件模式的话，比较常用的软件的有LVS、Nginx、HAProxy。</p><!-- [[[read_end]]] --><p>LVS是四层负载均衡，根据目标地址和端口选择内部服务器。Nginx这种负载均衡工具是七层负载均衡。而HAProxy同时支持四层、七层负载均衡，还可以根据报文内容选择内部服务器。</p><p>因此，LVS分发路径优于Nginx和HAProxy，性能上也要高些。但Nginx和HAProxy则更具配置性，比如说可以用来做动静分离。所谓动静分离，就是根据请求协议的特征，去选择静态资源服务器还是应用服务器。</p><p>很久以前，游戏服务器只是简单的对应客户端的服务，就像使用编程语言写了一个多线程的程序，每个线程接收一个客户端，然后把该存储的数据放到数据库去保存。到了后期，大量的网游开始兴起，玩的人越来越多，所以一些老式游戏服务器框架已经无法满足更大更现代化的网络游戏的需求了。</p><p>到了2005年左右，这种情况愈演愈烈，不改变现状不行了。于是，程序员和游戏开发厂商设计出了新的一种服务器的框架模型。这种模型几乎是延用到今天，这种模型甚至延伸到各行各业的服务框架。</p><p>我们甚至可以说Nginx反向代理的想法也是类似这种模型的一种表现形式。尽管我们不能说Nginx学的就是这种模型，但是与这种反向代理的模型的做法实在太类似了。</p><p>这种服务器模型的最大改变，就是加了一个gateway，可以称作网关。这当然不是传统意义上的网关路由器，只是在服务器的应用层面，做的事情类似网关路由器，所以我们仍然把它称为网关。</p><p>我们可以在Web端称它为<strong>会话</strong>（<strong>Session</strong>），也可以称它为<strong>Link Server</strong>，总之道理是一样的。</p><p>这个网关服务器所做的工作可以分为两种，对应网关服务器实现不同功能的服务。每一种功能不同，后台逻辑服务器的传输数据内容也会不同，不能相互混合使用。</p><h2>网关服务器有哪些功能？</h2><h3>1.中转功能</h3><p>网关服务器作为一种代理，所有玩家从客户端传输到真正的游戏逻辑服务器的内容，都需要通过网关服务器，用该服务器作为中转。也就是说，假设有A客户端到B服务器，网关为G的话，就是A到G到B，然后B服务器完成逻辑计算后，返回给G网关，网关再一次返回给A、B到G到A。</p><p>这样做的好处是，网关可以随时询问它底下的真实逻辑服务器到底哪一台趋于饱和，可以将玩家移动到不饱和的游戏服务器，但是缺点也是很明显的，那就是玩家和服务器之间隔了一层网关，需要消耗更长的时间，传输速率相对低。</p><h3>2.负载均衡</h3><p>网关服务器作为查询网关，也就是说，网关服务器会和底下所有服务器做一个长连接，或者随时询问的连接，这个连接所询问的内容，可以放到一个缓存里面，所查询的内容就是它底下所有服务器哪一台有空，在这种功能模式下，网关服务器只做了负载均衡的工作。</p><p>那么当客户端A要连接到游戏服务器的时候，需要先询问网关服务器G，模型看起来会是这样：</p><p>A-询问G，G通过查询缓存表，告知A客户端，C服务器有空，于是通知A，你去连C服务器，IP地址和端口号是多少多少，于是A从网关G关闭连接，去连接C服务器。如果连接失败（因为是缓存查询，从逻辑上讲有可能滞后），那么再次询问网关，直到成功连接某一台服务器为止。</p><p>这个模型，网关服务器只做了负载均衡的动作，客户端和网关之间不会保持一个长连接，在这个基础上，一台网关服务器支撑同时七千人以上都不是什么太大的问题。但是它的缺点也很明显，那就是一台游戏逻辑服务器只能负责一个游戏世界，不能进行分块。如果要进行分块，则需要其他模型的服务器模块，这个我一会儿会说。</p><p>Nginx的反向代理也是类似这种负载均衡的网关模型，这种模型大量运用在很多应用服务器、HTTP连接的网络服务器上。但是，这项技术到了上升时期开始遇到了瓶颈，人们发现就算加上网关，也无法负担体量更大的游戏地图。于是，我们需要对这样的模型进行修改。</p><h2>如何优化负载均衡的网关模型？</h2><p>首先，需要将网关服务器增加为几个网关服务器。每个网关服务器都做相同的工作，也就是管理它所下属的所有逻辑服务器。客户端在启动的时候，随机抽取某一个网关服务器，进行询问，使用网关服务器做代理进行中转。</p><p>如果游戏地图特别大，这样的模型可以将游戏地图分割成几块，分割好的地图放到下属的各个逻辑服务器中，网关做中转服务，比如服务器A负责浙江省，服务器B负责安徽省等等。</p><p>客户端在连接到网关服务器后，随着游戏进度的走向，网关服务器可以选择连接负责哪一块地图的逻辑服务器，这样在玩家看来就像是连接了一台服务器，而客户端并不用考虑切换服务器的工作。</p><p>当然为了减轻服务器的压力，增加更多的人流量，后期这样的模型被逐步细分。比如可以将聊天服务放到一台独立的服务器进行存放，把用户数据独立到一台数据服务器存放，把商品交易放到另一个独立的服务器，或者把私信等等这些和主游戏逻辑无关的内容都放到一个独立的服务器上。</p><p>这样一来，主游戏逻辑的服务器的负载就会减轻，然而客户端就不得不多连接几台服务器，要不停获取用户数据或者聊天信息等等，某些负载就转嫁到客户端上了。</p><p>这样的游戏逻辑服务器的模型一直沿用到现在。某一些稍微轻量级的，只是使用网关当成负载均衡使用，有一些重量级的，加上地图分割，就会增加网关服务器，但是付出的代价就是，如果要加一台新的游戏逻辑服务器的话，势必会增加部署难度。</p><p>不仅网关服务器的配置文件要重新部署，每个游戏节点服务器和被分割的诸如聊天等服务都需要进行重新配置，这样付出的代价也是巨大的，当然很多游戏公司靠着这样的服务器框架使用了好多年，其思想也被延伸到各个行业领域的服务器架构中。</p><h2>小结</h2><p>这节内容差不多了，我来总结一下。</p><ul>\n<li>\n<p>我首先讲了两种常用的负载均衡技术，软件模式和硬件模式。硬件模式用得比较多的是F5。软件模式的话，比较常用的软件的有LVS、Nginx、HAProxy。</p>\n</li>\n<li>\n<p>网关服务器有中转功能和负载功能。Nginx的反向代理用的是负载均衡的网关模型，但是这种模型无法负担更大体量的内容。为了减轻服务器的压力，也为了增加更多的人流量，可以通过增加网关，分割业务逻辑到独立的服务器，分摊服务器压力，这种经典类型的服务器模型被大量沿用并使用至今。</p>\n</li>\n</ul><p>现在给你留一个小问题吧。</p><p>我们使用网关服务器这样的模型，如果网关服务器宕机了，或者网关服务器很久没有响应的情况下，有什么办法让客户端能顺利连上网关服务器之下的逻辑服务器呢？</p><p>欢迎留言说出你的看法。我在下一节的挑战中等你！</p>",
        article_title: "第26讲 | 如何用网关服务器进行负载均衡？",
      },
      {
        title: "第27讲 | 如何制作游戏内容保存和缓存处理？",
        id: 13080,
        content:
          "<p>我们在打完游戏的关卡之后，需要保存游戏进度。单机游戏的进度都保存在本地磁盘上，如果是网络游戏的话该怎么办呢？这一节，我就来讲这个内容。</p><p>首先，我们要了解游戏内容的保存，需要先了解缓存处理。</p><p>为什么要了解缓存的处理呢？那是因为在大量用户的情况下，我们所保存的内容都是为了下次读取，如果每一次都从硬盘或者数据库读取，会导致用户量巨大数据库死锁，或者造成读取速度变慢，所以在服务器端，缓存的功能是一定要加上的。</p><h2>Redis不仅是内存缓存</h2><p>缓存机制里有个叫Redis的软件。它是一种内存数据库，很多开发者把Redis当作单纯的内存缓存来使用，事实上，这种说法并不准确，Redis完全可以当作一般数据库来使用。</p><p>Redis是一种key-value型的存储系统。它支持存储的value类型很多，包括字符串、链表、集合、有序集合和哈希类型。这些数据类型都支持push/pop、add/remove及取交集并集和差集及更丰富的操作，而且这些操作都具有原子性。</p><p>Redis还支持各种不同方式的排序。为了保证效率，数据一般都会缓存在内存中，而Redis会周期性地把更新的数据写入磁盘或者把修改操作写入追加的记录文件，并且在此基础上实现master-slave（主从）的同步。</p><!-- [[[read_end]]] --><p>说到Redis，就不得不说缓存机制的老前辈Memcached。同样是缓存机制，Memcached的做法是多线程，非阻塞的IO复用的网络模型。</p><p>多线程分监听线程和工作子线程。监听线程监听网络连接，接受请求了之后，将连接描述字使用管道传递给工作线程，进行读写。网络层的事件使用libevent封装。多线程模型可以发挥多核的作用。Memcached所有操作都要对全局变量加锁，进行计数等工作，所以会有性能损耗。</p><p>而Redis使用单线程IO复用模型，自己封装了一个简单的事件处理框架，对于单纯只有IO操作的模型来说，单线程可以将速度优势发挥到最大，但是Redis也提供了一些简单的计算功能，比如排序、聚合等。</p><p>Redis还可以在某些场景下对关系数据库（比如MySQL）起到较好的补充作用。它提供了多种编程语言的接口，开发人员调用起来也很方便。</p><p>Redis支持主从同步。通过配置文件，可以将主服务器上的数据往任意数量的从服务器上同步，从服务器A1也是主服务器B（B是关联到其他从服务器B1，B2的主服务器，同时又是主服务器A的从服务器A1）。</p><p>这种做法就使得Redis可以执行单层的树结构的复制。Redis实现了发布/订阅（publisher/subscriber）的机制。所谓发布和订阅，就是订阅者接收发布者的消息的时候，发布者和订阅者都不用去管对方是什么状态，只管各司其职就好了，在这种状态下，可以订阅一个频道并接收主服务器完整的消息发布记录。</p><h2>编写Redis接口代码</h2><p>我们尝试使用Python编写Redis接口的代码。</p><p>要使Python支持Redis编程，必须安装一个包“redis”，在使用的时候import一下。</p><pre><code>import redis\n</code></pre><p>然后我们开启Redis服务，在Windows下可以运行redis-server.exe，使用默认配置即可。</p><p>现在，我们尝试使用代码连接一下数据库服务，并且往数据库存放并取出、删除内容。</p><pre><code>       r = redis.Redis(host='127.0.0.1', port=6379, db=0)\n       r.set('foo', 'my_redis')\n       print r.get('foo')\n       r.delete('foo')\n       print r.dbsize(   \n</code></pre><p>运行结果为输出 my_redis 和 0。</p><p>当然，如果我们没有运行Redis，则会抛出一个异常：</p><p><img src=\"https://static001.geekbang.org/resource/image/44/a3/44d41a80ab192dfa5514a25bb66c80a3.jpg\" alt=\"\"></p><p>r对象为连接Redis服务器的对象，其中db=0表示使用 redis 的0号数据库，可以随你喜欢切换为1号、2号等等。如果Redis设置了密码，还可以在初始化的时候输入密码。</p><p>Redis的初始函数是这样定义的：</p><pre><code>__init__(self, host='localhost', port=6379, db=0, password=None, socket_timeout=None, connection_pool=None, charset='utf-8', errors='strict', decode_responses=False, unix_socket_path=None)\n</code></pre><p>在之后的代码中，r.set 表明将 key 为 foo，value为 my_redis的内容写入数据库。</p><p>最后输出 0 号数据库的内容长度。</p><p>值得一提的是，Redis对于存储的内容是来者不拒，有什么扔什么，所以你如果往Redis里插入二进制、UTF-8编码、图片等等，任何东西都可以。理论上只要不超过内存大小的数据都可以往里面扔。</p><p>最后，我们可以这么写：</p><pre><code> r.save()\n</code></pre><p>强制Redis往硬盘里写入数据，这样我们就能保证数据不会因为电脑发生异常而丢失。这样就将内存的数据同步了下来。</p><p>我们常说的木桶理论其实在这里也适用。比如电脑的速度取决于电脑设备中最慢的那个设备，就像水在桶中的高度始终取决于水桶里面最下方的那个漏水处。而磁盘I/O始终是拖慢电脑速度的重要力量。</p><p>前面我们介绍了Redis，所以我们可以使用Redis对文件进行缓存。Redis可以当作普通缓存也可以当作文件缓存，在Redis中放入任何东西，当然也包括放入二进制文件，Redis也不会有任何异常出现，从Redis缓存中取出二进制文件的速度也非常快，因为是直接从内存中取出数据。</p><p>我们假设网络游戏保存下来的数据很大，因为有人物属性、人物装备、地图NPC位置和怪兽等等。这些玩家退出后，游戏保存的数据文件，被保存在关系型数据库中，或者保存在服务器硬盘的文件中。我们不可能每次都去读取关系数据库中的游戏内容或者硬盘文件内容，所以，可以用一种方案来存放游戏保存的文件和缓存。</p><h2>如何存放文件和缓存？</h2><p>这套机制并不局限于读取保存文件，某些大文件，或者数据文件的读取和缓存上，都可以使用这种思路去做。</p><p>首先我们假定文件存放在某一个目录，所有的负载均衡服务器都存放有这个目录的副本，其他分布式服务器存放其他文件和目录，我们先暂定A服务器存放文件A1、A2、A3。</p><p>这些都是游戏的保存文件，在服务器初始启动的时候，Redis并不读取任何文件，当有请求过来的时候，服务器程序通知Redis读取某个文件。</p><p>这时，我们需要一个机制，为了保证服务器的内存开销，也为了保证缓存速度，我们必须保证被读取量最大的文件被缓存，而不是所有文件，这时候，Python程序可以另开一个线程或者进程，暂且命名为 T 线程，记录某文件被缓存。</p><p>服务器程序每次得到请求的时候，都会将需要递交的被读取文件告诉Python线程T，说文件 A1 被缓存了 N 次，文件 A2 被缓存了 N 次，在这种策略下，T线程通过几个小时或者几天的计数，就能明确知道 ，比如A2 文件被递交次数最多，于是它始终通知Redis将A2文件进行缓存，而A1由于到了某一天递交次数下降，在某一个时间节点上，线程T就告知Redis A1文件可以从缓存文件中撤出来，节省内存开销，让位给读取频次更高更高的文件。</p><p>这样，一套完整的缓存计数和缓存的解决方案就出现了。</p><p>当然，并不是说MySQL等关系型数据库不能做这些工作，但从效率和开发成本来讲，Redis（缓存）的开发成本和效率显然更胜一筹。因为在几十万几百万甚至上亿等级用户量的时候，就算是Redis，在这种量级的情况下也是吃不消的，所以如果不在上层做更多层的缓存，底层数据库一定是会死锁或者出现各种各样的问题。</p><p>那么你可能会说，我可以做索引啊，要知道在连接数足够多的时候，做索引、读写分离，主从数据库等方案，也只是救急只用，无法真正实现稳固的架构体系。</p><h2>小结</h2><p>我来总结一下今天的内容。</p><ul>\n<li>\n<p>Redis不仅仅可以用作普通的缓存机制使用，也可以当作正常的数据库使用，Redis也支持主从同步，要按照应用场景不同来配置不同的Redis使用场景。</p>\n</li>\n<li>\n<p>缓存机制不仅仅针对读取游戏保存文件这么一种方案，也可以用作各种数据文件的读取和写入操作。</p>\n</li>\n<li>\n<p>使用现成的Redis等缓存数据软件，是一个好的方案。而设计好的框架、好的缓存机制、好的网络模型，是一款好网游必不可少的条件。</p>\n</li>\n</ul><p>现在给你留一个小问题吧。</p><p>有没有可能将网络游戏的内容保存在客户端本地的电脑上，如果可以的话，请问如果玩家换了一台电脑，怎么同步内容呢？保存在客户端本地的意义是什么？</p><p>欢迎留言说出你的看法。</p>",
        article_title: "第27讲 | 如何制作游戏内容保存和缓存处理？",
      },
    ],
  },
  {
    chapterTitle: "第六章：热点剖析",
    children: [
      {
        title: "第28讲 | 热点剖析（一）：HTML5技术是如何取代Flash的？",
        id: 9298,
        content:
          '<p>本周开始，我将会在<strong>每周六</strong>更新一篇“热点剖析”，阐述我对2D游戏开发之外的热点，比如HTML5游戏、移动端游戏、AR和人工智能在游戏领域的应用，以及我对微信小游戏、移动游戏、独立游戏开发者的一些观点和看法。</p><p>我已经为你讲解了核心的开发知识，对于这些相对热门领域的知识，你可以根据兴趣进行选择学习。</p><p>本周及接下来两周的周六，我会依次为你介绍HTML5游戏，以及<a href="https://time.geekbang.org/column/article/9702">如何选择HTML5的游戏引擎</a>，并带你编写一款H5小游戏。</p><p>从前几年开始，H5这个技术就开始蓬勃发展。不管是懂行的还是不懂行的，都开始以“H5”这个字眼来描述产品。比如老板会说“我们就做个H5的页面吧”，或者“这个游戏是H5的吗”。很多人已经把H5等价于“手机端页面”了，这样的理解显然是错误的。</p><p>那么H5究竟是什么？它的优点在哪里？为什么现在大家都在谈论H5？你真的知道H5是什么，并真的深入理解了它吗？</p><h2>Flash是什么？</h2><p>首先，在说H5之前，我想先介绍一下Flash技术。</p><p><strong>Flash是由Adobe公司开发的一种富媒体技术，起初是一种放置在浏览器中的插件，填补了当时HTML页面平淡的空白，增强了网页交互的能力。</strong>你可以在Flash中做出任何东西，也可以访问本地电脑中的东西。后来，Adobe公司推出了播放器，在电脑上不打开浏览器，也可以观看或者游戏Flash程序员编写出来的产品。乃至今日，依然有大量应用于Flash的富媒体应用，比如视频的播放，比如独立的小游戏，比如网页游戏，甚至桌面应用，都是使用Flash开发的。</p><!-- [[[read_end]]] --><p>虽然Flash拥有大量优点，并在当时弥补了网页端的很多不足，但是Flash的缺点也是很明显的。</p><p>首先，<strong>它的浏览器插件的运行效率并不高，而且访问电脑资源也很不方便，导致很多程序员在开发的过程中出现许多的问题</strong>，就算成功发布了一款Flash应用，浏览器也会被Flash插件拖得很慢，电脑会因此变得很卡，所以H5技术出现后，很多人就开始转投到H5的门下。</p><p>另一方面，由于Flash技术掌握在Adobe公司下，一家独大，所以从商业角度讲，很多大公司并不会坐视不管，就开始从Flash中抽取内容并制定公有的Flash规范，到了后面就添加到了H5规范下，成为大家都能掌握的规范。</p><p>谷歌苹果等大公司都不支持Flash应用，所以在大公司的压力下以及现在H5的流行，Adobe公司决定在2020年终止Flash技术的提供。</p><h2>H5技术究竟是什么？</h2><p>有了这个铺垫，我们再来看看H5技术究竟是什么，它为什么会取代Flash。</p><p>首先，<span class="orange">H5大量应用在手机端的网页上面，但这并不等于“H5等于手机网页”</span>，因为普通的HTML页面也可以适配手机端屏幕。</p><p>H5全称是HTML5，HTML是超文本标记语言的首字母缩写。而HTML4.01的标准在1999年年底发布。HTML5的草案，前身是网络应用1.0（Web Application），而HTML5的第一份草案于2008年1月月份公布，定稿是在2012年的年底。</p><p>在H5标准出现后，各大浏览器纷纷开始支持H5，比如火狐、谷歌的Chrome、IE9、苹果的Safari，Opera等等。事实上，<strong>H5技术很大程度上是为了移动平台所设计，能在移动平台支持多媒体，当然取代Flash这是顺理成章的事情</strong>，但是，H5技术并不等同于移动平台网页，我们在很多的PC端的网页也能看到HTML5的技术。</p><h2>H5技术有什么新特性？</h2><p>H5技术拥有很多最新的特性。</p><p>在<strong>语法</strong>方面，HTML5的语法给了网页编写程序员拥有更好的语法结构以及更加丰富的标签。比如，video标签就可以直接在H5页面中嵌入播放器。H5也支持更多的<strong>设备兼容</strong>，比如可以支持摄像头，支持麦克风（移动端的或者电脑端的都可以）。</p><p>H5也支持<strong>本地存储</strong>的功能，我们可以使用H5技术来开发网页app，这些都来自本地存储的缓存技术，所以H5网页的<strong>载入速度</strong>会比传统网页更加迅速和便捷，连接也变得更快。H5支持多媒体这是必然的，包括音频、视频、摄像头等功能，事实上使用H5技术的多媒体技术已经完全可以取代Flash技术了。</p><p>在<strong>编程</strong>方面，以前我们需要跨域的技术，在H5中，可以使用XMLHttpRequest来解决跨域问题。而且H5页面一经修改就能直接更新上去，基本上刷新页面就能看到效果，而如果使用Flash来做，需要进行编译和发布，并且替换Flash页面，才可以看到Flash应用的更新，从时间效率讲，H5技术又是技高一筹。</p><p>另外，如果有专业的SEO人员，也可以很方便地通过H5来做SEO优化，做网站的索引和搜索引擎的抓取优化工作，这在Flash来说几乎是不可能做到的工作。</p><h2>用H5编写游戏有什么优点？</h2><p>使用H5技术编写的应用和游戏，可以很方便地嵌入到苹果或者安桌的App中。这种方式可以免去原生开发两套App的麻烦，只需要编写一套类似App的H5页面，然后使用类似WebView的方式来嵌入到原生应用中。</p><p>由于<strong>H5页面可以随时更改</strong>，所以现在苹果商店对于H5内嵌应用的审核比较严格，所以H5页面必须做得好，而且逻辑流程都不能有问题。所以在H5发展的阶段，有很多声音说，H5除了取代Flash，还会取代App，事实上这是不可能的。虽然H5取代Flash已经毋庸置疑，但是H5取代原生App还是有很多的掣肘，比如H5只能编写轻量级的App，如果需要那种画面效果特别好的App，或者对设备进行深层次的操控，那就只有原生可以办到了，所以现在有许多的App开发，都选择H5和原生混合开发，这样会减轻一定的工作量，并且在实现其他深层次的功能的时候也能使用原生代码。</p><p><strong>用H5比Flash编写游戏更快速，占用资源也更少</strong>，所以以前利用Flash技术编写的游戏，现在都改成H5技术编写，当然H5编写的游戏仍然比不上原生编写的游戏。毕竟原生有对底层的操控能力，直接而且快速，而H5毕竟需要通过浏览器的解释和渲染，所以它的速度基本取决于浏览器，代码优化地再好，也无法直接穿过浏览器这一层去做事情。</p><p>所以，用H5编写的游戏，如果是在电脑端，我们可以编写大一点的网络游戏，因为电脑的资源能随心所欲地利用；而如果在手机端，H5技术适合编写小型游戏，比如电商领域、推广平台等营销类的小游戏，再比如玩家操作不是特别复杂的游戏，比如战棋类的、益智类的、策略类的，或者静态画面比较多的游戏（比如选择一个正确答案，猜一个成语那样的等等）。这样的游戏，占用的资源不大，动态资源载入不多，移动平台也不会有太多的卡顿感，各种手机都可以适配和游戏，这样小型的H5游戏是比较适合移动平台的。</p><p><strong>H5游戏的传播能力比Flash更好。</strong>首先Flash技术需要安装一个插件才可以使用，然而H5游戏只需要浏览器支持即可，所以从这方面讲，只需要你通过浏览器分享一个H5游戏到微信、QQ等社交软件，就可以直接进行传播，而不像Flash那样需要安装额外的东西。所以利用H5技术编写的营销工具现在占领了绝对的主流，所以才会有本篇文章最初所说，很多人认为“H5等价于移动平台网页”这样的误解。</p><h2>小结</h2><p>总结一下今天的内容：</p><ul>\n<li>\n<p>H5游戏拥有比Flash更好用更开放的规范，开发和发布也更方便，修改代码后放到网上，只需要刷新一下页面就可以看到修改的内容；</p>\n</li>\n<li>\n<p>另外，Flash技术需要安装一个插件，而H5技术直接在浏览器就可以呈现。所以H5技术完全替代Flash只是时间问题。</p>\n</li>\n</ul><p>现在留一个小问题给你。</p><p>我们都知道浏览器渲染出来的网页都是2D的页面和游戏，但是H5技术也可以编写3D视觉效果的内容。你知道H5技术所拥有的3D效果是用什么技术实现的吗？</p><p>欢迎留言说出你的看法。我在下一节的挑战中等你！</p>',
        article_title: "第28讲 | 热点剖析（一）：HTML5技术是如何取代Flash的？",
      },
      {
        title: "第29讲 | 热点剖析（二）：如何选择一款HTML5引擎？",
        id: 9702,
        content:
          '<p>上周六，我详细介绍了<a href="https://time.geekbang.org/column/article/9298">HTML5技术相比Flash技术的优势</a>，相信你已经对HTML5技术有一个大致的了解。下周六，我会带你编写一个HTML5游戏，在这之前，我们需要先了解几种常见的HTML5游戏引擎。</p><p>一些比较成熟的引擎，比如Cocos2d-JS、白鹭等，它们都提供有系列化的工具，比如编辑器、IDE等周边。但是其实<strong>大部分HTML5游戏引擎都只有图形引擎</strong>而已，比如legend.js。而且很多HTML5引擎只是个人编写的开源引擎，所以漏洞还是比较多的。</p><p>HTML5游戏引擎在编写的时候，除非用DOM（Document Object Model）纯原生编写，绝大部分都是使用JavaScript编写的。但是为了考虑各种程序员的需求，现在也有使用TypeScript、CoffeeScript、LiveScript等语言编写的HTML5引擎。</p><h2>几款常见的HTML5游戏引擎</h2><p>我们现在来看一下几款常见的HTML5游戏引擎。</p><h3>Construct 2</h3><p>这是一款收费的引擎，当然也有免费的版本，但是免费的版本不可用于商业用途。那么既然是商用引擎，那它一定会比免费开源的产品更加完善和易用。这里有一幅Construct 2的截图，你可以看一下它的界面。</p><!-- [[[read_end]]] --><p><img src="https://static001.geekbang.org/resource/image/a7/8b/a725e6389a0636f8f0539a626de2f18b.jpg" alt=""></p><p>我们可以清晰地看到，这个界面类似Office的操作界面。左侧是物件的<strong>属性</strong>，比如长宽高等；右侧上方是物件的<strong>层</strong>，包括背景、物件；右侧下方是<strong>物件选择器</strong>，你可以选择各种物件摆放到编辑器内。这种类型的编辑器，在成熟的商业引擎中比较常见，但是由于编写编辑器的人力物力成本，所以免费的引擎一般不提供这种成熟的编辑器。</p><p>从<strong>使用</strong>角度，我总结了一下它的特点，大概有这几条，供你自己制作HTML5游戏的时候选择：</p><ul>\n<li>\n<p>可以设计任何类型的2D游戏，而且不需要编程的技能（可以由事件系统控制）；</p>\n</li>\n<li>\n<p>使用简单的拖拽和事件系统就可以设计游戏逻辑；</p>\n</li>\n<li>\n<p>拥有一个物理引擎，可以用来计算运动、旋转和碰撞反映；</p>\n</li>\n<li>\n<p>可以在iOS、Android、Windows Store等多个平台上发布游戏；</p>\n</li>\n<li>\n<p>拥有很完备的文档和教程案例。</p>\n</li>\n</ul><p>在<strong>软件</strong>方面，它拥有一个非常直观的编辑器，可以开发高级的视觉效果，可以支持视差滚动的游戏，并且在编辑器中集成了调试器和profiler。做出来的游戏支持多人游戏，也支持2D的阴影，还支持JS SDK的插件。</p><p>Construct 2的不同版本，对应的功能也不相同。</p><p>第一个是<strong>免费版本</strong>的，它的使用没有时间限制，你可以使用100个事件、4个图层和2个着色器，随意导出成HTML5网页游戏，但是这些编写出来的游戏不可以用作商业用途。</p><p>第二个是<strong>个人版</strong>或者<strong>教育版</strong>：这个版本移除了免费版本的限制，甚至可以将项目导出至iOS、Android或者其他平台。如果你用作商业用途，可以允许你在商业用途中获得最高5000美元的收入。它可以使用调试器观察tab、profiler和事件断点，还可以制作多人游戏，在应用程序内可以嵌入内购功能。</p><p>最后一个是<strong>商业版本。</strong>所有特点与个人版本相同，但是没有上面说的那些限制。</p><p><strong>Construct 2的缺点就是相关的中文教程不是很多，需要你自己去摸索。但是它支持多平台，简单易用，还提供了很强悍的事件系统，可以不通过代码来控制逻辑，所以不需要编程知识就可以使用。</strong></p><h3>白鹭引擎</h3><p>白鹭引擎是我们国内自己研发的HTML5引擎。最初，它也是一套图形引擎，后来资本化之后，白鹭引擎就开始着手将引擎变成一套解决方案。</p><p>它不仅提供HTML5游戏引擎，也提供了各种周边工具和产品。除了图形引擎之外，它还提供了可视化编辑工具（Egret Wing）、动画制作工具（Dragon Bones）、HTML5游戏加速器（Egret Runtime）。</p><p><strong>可视化编辑工具</strong>提供了代码调试功能。可以在文件中打断点、单步调试、跳入和跳出、查看局部变量、添加观察表达式等。当然你也可以自己编写扩展程序，可以对任何语言进行调试。可以让开发者用 Node.js + HTML 来开发IDE的扩展插件，然后实现各种提升效率的工具。</p><p>你还可以自定义语法高亮、智能提示和调试。它还内置了版本控制系统Git，集成命令行工具，可以同时打开多个命令行标签，执行需要的命令。</p><p>它甚至可以在Wing中直接运行Vim。它还内置多种主流的代码配色方案，满足大部分开发者配色习惯。开发者还可以自己编写配色扩展，你可以根据自己习惯，定制你的IDE。</p><p>白鹭的<strong>动画制作工具</strong>提供了动画和动漫的解决方案，打通了动画设计和游戏开发的工作流，也支持导出各种动画格式，提供了可交互动态漫画编辑器模式。你甚至不需要动画基础，轻松实现丰富特效。DragonBones可以输出多种格式，视频、网页、动画数据，可以用于几乎目前所有的主流游戏引擎和编程语言，提供了各个平台的运行库。</p><p>另外，还有一个<strong>HTML5加速器</strong>，这是一款支持3D的HTML5游戏加速器，解决低端机对HTML5标准支持不佳、体验差的弊端，加速器可以适配不同的系统让HTML5游戏效果媲美原生游戏，解决设备不统一，移动应用市场的设备、操作系统和屏幕的不统一的问题很严重， 已成为HTML5游戏开发者面临的难题，适配也成为美工最头痛的问题。</p><p>另外，越来越多的游戏和应用使用移动QQ、微信、微博等客户端作为入口。 不同客户端软件所携带的浏览器内核不同， 也直接影响HTML5游戏在平台上的表现。</p><p>而HTML5加速器直接支持HTML5游戏运行所需的底层功能，解决了屏幕适配和性能问题，并且也从渠道角度解决了HTML5游戏接入流程复杂， 定制化功能多的问题，实现一次接入，随时上线。</p><p>我们再来讲讲白鹭引擎本身。白鹭引擎支持2D、3D游戏，引擎本身采用模块化设计，egret也实现了脏矩阵方法，可以很大提升渲染性能。<strong>脏矩阵</strong>，简单描述就是，系统只渲染动画变化的部分，不变化的部分并不进行渲染更新。</p><p><strong>白鹭引擎本身的功能和周边工具都很强大，中文教程和论坛也比较成熟，且支持2D、3D游戏的制作，现在也支持直接编写最流行的微信小游戏。</strong>在商业化方面，白鹭是做的比较成功的，所以现在的用户也非常多。</p><h3>Cocos2d-JS</h3><p>最后，我们来说一下Cocos2d-JS。</p><p>Cocos2d-JS是Cocos2d-x的一个分支，只要对HTML5游戏有所了解的话，基本都听说过Cocos2d-JS，很多开发人员也会选择Cocos2d-JS来进行开发HTML5游戏。</p><p>根据官方说法，它跨全平台，采用JavaScript语言，可发布到包括Web、iOS、Android、Windows Phone8、Mac、Windows等平台，引擎基于MIT开源协议，完全开源、免费、易学易用，拥有活跃的社区支持。</p><p><strong>Cocos2d-JS让2D的游戏编程门槛更低，使用更加容易和高效。和其他类似游戏引擎相比，它定义了更加清晰的2D游戏编程的基本组件、易学易用的API，并且具备原生性能的脚本绑定技术，实现游戏的跨原生平台发布，开发效率更高，使用简单。</strong></p><p>它本身融合了Cocos2d-HTML5和Cocos2d-x JavaScript Bindings（JSB），支持Cocos2d-x的所有核心特性并提供更简单易用的JavaScript风格API，基于Cocos2d-JS的框架，可以方便地使用JavaScript语言进行游戏开发，快速构建原型进行测试和验证。</p><p>由于Cocos2d-html5的API和Cocos2d-x JSB的API高度一致，开发出来的游戏不用修改代码或者修改少量代码就可打包为原生性能表现的混合游戏，发布到原生应用市场，这就是一次编码全平台部署的效果。</p><h2>小结</h2><p>这一节，我给你介绍了最流行的三款HTML5游戏引擎。</p><p>其中一款是商业引擎，另外两款可以自由使用。从难易角度讲，Construct 2拥有更方便的开发体验；从流行度讲，Cocos2d-JS和白鹭都属于国内最流行的HTML5游戏引擎。</p><p>你可以根据自己的需求来选择，<strong><span class="orange">如果美术熟悉Cocos2d-JS，或者想要快速上手2D游戏，可以选择Cocos2d-JS；如果对编程不太熟练，可以选择Construct 2；如果是拥有完整流程的开发公司，Cocos2d-JS和白鹭都可以选择</span></strong>。</p><p>最后，给你留一个小问题吧。</p><p>现在流行的微信小游戏，目前只支持3M左右的大小，否则就审核不过，那么如果在游戏资源大的情况下，有什么方案可以让游戏维持在3M大小呢？</p><p>欢迎留言说出你的看法。我在下一节的挑战中等你！</p>',
        article_title: "第29讲 | 热点剖析（二）：如何选择一款HTML5引擎？",
      },
      {
        title: "第30讲 | 热点剖析（三）：试试看，你也可以编写一款HTML5小游戏！",
        id: 9926,
        content:
          '<p>前两周，我分析了<a href="https://time.geekbang.org/column/article/9298">HTML5的核心竞争力</a>以及<a href="https://time.geekbang.org/column/article/9702">HTML5游戏的引擎</a>。选择好了HTML5引擎，我们就可以开始制作游戏了。</p><p>对于编写HTML5小游戏，你或许会很有兴趣，因为HTML5现在已然是一个潮流，而且利用引擎编写HTML5游戏已经变得相当方便。</p><h2>如何选择一款引擎？</h2><p>我选择的是比较容易上手的lufylengend引擎。为什么要选择这款引擎呢？因为它只需要下载一个压缩包，并且不需要特别繁琐的说明和设置就能直接上手，用作我们的教学示例是最合适的。</p><p>如果使用白鹭引擎或者Cocos-2d引擎这些比较有名的引擎，可能会有这些问题。</p><ol>\n<li>\n<p>这些引擎从工具到套件都非常成熟，你直接下载一个引擎启动器或者组件管理器，就可以一应俱全地在启动器里面下载，配置到默认路径。但是，这些工具拥有纷繁复杂的界面，你连上手都要费一段时间，更别说短时间内熟练使用并制作出一款游戏。</p>\n</li>\n<li>\n<p>这些引擎需要引入的库或者使用的方式极为系统，所以你需要系统地引入库文件，才可以使用。事实上我要做的示例，并不需要很多复杂的东西，你只需要跟我从头到尾走一遍，就能明白编写HTML5游戏是怎么回事。</p>\n</li>\n<li>\n<p>这些引擎需要别的工具支持，比如node.js。作为新手来说，光配置node.js就是一项比较麻烦的工作。所以我选择了lufylengend引擎这一个比较“单纯的”引擎来作为教学引擎。</p>\n</li>\n</ol><!-- [[[read_end]]] --><h2>几个简单的说明</h2><p>你可以从这个地址下载最新版本：<a href="https://github.com/lufylegend/lufylegend.js/archive/lufylegend-1.10.1.zip">https://github.com/lufylegend/lufylegend.js/archive/lufylegend-1.10.1.zip</a> 。下载下来的安装包大约有30M大，解压缩后有36M左右。解压缩后，我们会看到一系列的js文件。</p><p>我先对这些文件做一些说明，并且对最基础的编程流程做一个简单的梳理。</p><p>压缩包内包含lufylegend-版本号.js和lufylegend-版本号.min.js这两个<strong>完整版本</strong>，还有lufylegend-版本号.simple.js和lufylegend-版本号.simple.min.js这两个<strong>缩减版本</strong>，其中带min字样的是去除了回车和空格的压缩版本。如果你使用JavaScript编程，缩减版本对于你来说再熟悉不过的了。</p><p>其中，simple缩减版本与完整版本的区别在于，它将LBox2d、LQuadTree、LTransitionManager、LoadingSample1、LoadingSample2、LoadingSample3、LoadingSample4、LoadingSample5等几个类与HTML5引擎的常用部分分离，缩减了引擎的体积。如果需要用到被分离的部分功能的话，可以手动进行加载。</p><p>随后，可以在HTML代码中将legend引擎的库件引入。调用LInit函数，初始化库件。然后开始游戏代码的编写。剩下，你只需要有一款合适的IDE就可以开始编程了。</p><p>对制作HTML5游戏来说，你首先要做的是，将游戏场景在浏览器中呈现出来。把Windows的窗体，从系统客户端程序搬到浏览器上，呈现的窗体从可执行文件变成了浏览器。从这个角度讲，<strong>浏览器担负了应用层的工作，浏览器本身担负了解释程序，并且渲染的过程，</strong>所以，从理论上讲，<strong>相同的游戏类型和游戏内容，HTML5游戏的渲染速度是比不上客户端游戏的渲染速度的。</strong></p><h2>一起动手制作吧！</h2><p>很凑巧的是，lufylengend引擎也拥有一款打飞机demo。我们只需要在lufylegend引擎目录的examples/demo下，找到barrage目录。</p><p>这一款打飞机的游戏，打开后是这个样子。</p><p><img src="https://static001.geekbang.org/resource/image/bb/b5/bb3765557be1728cbd606fa54cc4a8b5.jpg" alt=""></p><p>这和我们之前讲述的内容非常类似。那我就借解释一下这款游戏的代码，来教你制作。</p><p>在目录下，有一个index.html，这就是游戏的开始页面。在这个页面下，我们先来看一下部分代码。</p><pre><code>&lt;script type=&quot;text/javascript&quot; src=&quot;../load_lufylegend.js&quot;&gt;&lt;/script&gt;\n&lt;script type=&quot;text/javascript&quot;&gt;\nif(LGlobal.canTouch){\n      LGlobal.stageScale = LStageScaleMode.EXACT_FIT;\n      LSystem.screen(LStage.FULL_SCREEN);\n}\n&lt;/script&gt;\n&lt;script type=&quot;text/javascript&quot; src=&quot;./js/Main.js&quot;&gt;&lt;/script&gt; \n</code></pre><p>如果你熟悉web编程，对于这些代码肯定非常熟悉。在开始的地方，我们看到载入的JavaScript代码是load_lufylegend.js，这个js文件包含在打飞机游戏的上一层目录，内部就只有一行代码。</p><pre><code>document.write(\'&lt;script type=&quot;text/javascript&quot; src=&quot;../../../lufylegend-1.10.1.min.js&quot;&gt;&lt;/script&gt; \');\n</code></pre><p>我们看到，在这个js文件内，包含了lufylegend的原始引擎文件。至于为什么要这么做，为什么要使用两个文件包含引擎，是因为这样可以保持游戏代码的干净。如果你要修改引擎的包含路径，不需要修改游戏本体文件，只需要修改load_lufylegend.js包含路径即可。</p><p>而LGlobal.canTouch这段话的意思是，如果是移动版本的话，设置缩放模式为适应屏幕，并且为全屏，代码是：</p><pre><code>LSystem.screen(LStage.FULL_SCREEN)\n</code></pre><p>最后，导入游戏脚本Main.js文件。</p><p>在Main.js里面，我们看到，它还包含了三个别的js文件，代码是这样。</p><pre><code>imgData.push({type:&quot;js&quot;,path:&quot;./js/Global.js&quot;});\n      imgData.push({type:&quot;js&quot;,path:&quot;./js/Bullet.js&quot;});\n      imgData.push({type:&quot;js&quot;,path:&quot;./js/Plain.js&quot;});\n</code></pre><p>它包含了一个共有类Global.js、子弹类Bullet.js以及飞机类Plain.js。之后的代码是这样的。</p><pre><code>loadingLayer = new LoadingSample1();\naddChild(loadingLayer);\n</code></pre><p>其中LoadingSample1是“载入进度条”类，我们可以在下面的代码看到载入的实现。</p><pre><code>LLoadManage.load(\nimgData,\nfunction(progress){\nloadingLayer.setProgress(progress);\n},\nfunction(result){\nimglist = result;\nremoveChild(loadingLayer);\nloadingLayer = null;\ngameInit();\n}\n);\n</code></pre><p>在载入结束后，就开始gameInit函数的调用，也就是游戏初始化。</p><pre><code>function gameInit(event){\n//游戏底层实例化\nbackLayer = new LSprite();\naddChild(backLayer);\nctrlLayer = new LSprite();\naddChild(ctrlLayer);\n</code></pre><p>LSprite是引擎的基本显示列表构造，里面包含了显示内容的列表节点，addChild就是将显示内容添加到节点列表。</p><pre><code>//添加游戏背景\nbitmapdata = new LBitmapData(imglist[&quot;back&quot;]);\nbitmap = new LBitmap(bitmapdata);\nbackLayer.addChild(bitmap);  \n</code></pre><p>这几段代码就是将背景图片也添加到显示节点列表。</p><pre><code>//得分显示\npointText = new LTextField();\npointText.color = &quot;#ffffff&quot;;\npointText.size = 20;\npointText.text = point;\nbackLayer.addChild(pointText)\n</code></pre><p>这是一个得分的显示，所以需要新建一个文本类，并设置颜色和大小，并将之放到显示节点的列表。</p><pre><code>//加入玩家\nplayer = new Plain(&quot;player&quot;,0,200,600,[5]);\nbackLayer.addChild(player);\n</code></pre><p>我们需要新建一个玩家类。新建玩家，其实就是新建一个飞机类型，所以我们在这里看到一个plain类的创建。</p><p>这个创建函数的实现原型是这样的。</p><pre><code>function Plain(name,belong,x,y,bullets)\n</code></pre><p>你可能会觉得奇怪，Plain是什么意思，在它的demo里面，Plain是飞机的意思，然而可能是作者的一时疏忽或者是英文“捉急”，所以就把Plane写成了Plain。以下所有和飞机相关的代码都是Plain，虽然并不影响代码的运行，但是出于严谨考虑，我在这里更正一下，Plain等于Plane。</p><p>第一个参数是名字，第二个参数是飞机所属，表明是属于敌人还是玩家，随后两个参数（x,y）是飞机在2D画布上所显示的位置，最后一个bullets是子弹的数组。</p><pre><code>//添加帧事件，开始游戏循环\nbackLayer.addEventListener(LEvent.ENTER_FRAME,onframe);\n//添加控制事件\nbackLayer.addEventListener(LMouseEvent.MOUSE_DOWN,ondown);\nbackLayer.addEventListener(LMouseEvent.MOUSE_UP,onup);\n}\n</code></pre><p>在初始化的最后，我们需要添加鼠标事件，将鼠标事件LMouseEvent的鼠标上下操作事件都放入到事件侦听函数内：addEventListener。</p><p>看到这里，你不禁会问，按照我们所教学的，游戏应该会有一个大循环来完成游戏的显示、操作等内容。那这个循环在哪里呢？</p><p>事实上这个循环，就在上面这串代码中。</p><pre><code>backLayer.addEventListener(LEvent.ENTER_FRAME,onframe); \n</code></pre><p>其中，LEvent为事件类。<strong>和传统客户端游戏不同，在HTML5游戏引擎中，循环采用了事件代码来完成，只要你在侦听器函数中注册了事件，都会一帧一帧不停地调度这个事件，以此达到循环的效果。</strong></p><p>在这里，注册的侦听事件函数就是onframe函数。查看它的源代码你可以看到onframe函数的实现细节，我就不在这里进行阐述了。</p><h2>小结</h2><p>今天，我们使用lufylegend引擎剖析了HTML5游戏的编写方式。我来总结一下。</p><ul>\n<li>\n<p><span class="orange">HTML5游戏的启动页是一个HTML文件。</span>这个文件包含引擎的js文件。在其他别的引擎中，也是使用类似的方式来加载引擎。包含了引擎，就可以针对引擎所封装的接口进行游戏的开发。</p>\n</li>\n<li>\n<p><span class="orange">HTML5游戏的循环方式和传统游戏的循环方式不同。</span>由于HTML5游戏引擎绝大部分是使用JavaScript脚本编写的，而JS本身就是以事件驱动的方式来工作的，所以<strong>使用事件驱动是HTML5游戏引擎的一个很大特点</strong>。我们在事件侦听函数中注册一个事件函数，在这个函数内编写“游戏循环”内的代码，就能起到传统游戏循环的作用。</p>\n</li>\n<li>\n<p><span class="orange">在HTML5游戏中，我们几乎不需要关心图片的刷新或者清空操作。</span>这些操作比之传统客户端游戏更为简洁，我们只需要关心游戏的图片呈现以及操作即可。</p>\n</li>\n</ul><p>简单来说，<strong><span class="orange">HTML5游戏就是一种使用事件驱动模式并渲染在网页上的一种技术，省却了传统游戏的底层操控。</span></strong>你在制作的时候，可以把更多的关注点放在游戏逻辑和可玩性上。</p><p>最后，留一个小问题给你。</p><p>在类似这样的HTML5打飞机游戏中，碰撞检测是怎么做的呢？请结合我以前的讲过的内容给出一个答案。</p><p>欢迎留言说出你的看法。我在下一节的挑战中等你！</p>',
        article_title:
          "第30讲 | 热点剖析（三）：试试看，你也可以编写一款HTML5小游戏！",
      },
      {
        title: "第31讲 | 热点剖析（四）：安卓端和苹果端游戏开发有什么区别？",
        id: 10423,
        content:
          "<p>所谓的移动端，指的是可以随时拿在手上游戏和工作的，自带直流电源的设备，所以从游戏角度讲，手机、掌上游戏机、iPad都属于移动端设备。</p><p>我们今天的侧重点在安卓和苹果端的手机游戏，在开始说手机游戏之前，我们先简单了解一下掌上游戏机，因为这毕竟是移动端游戏的鼻祖。</p><p>在游戏发展的历史中，游戏机从8位发展到32位、64位；游戏存储的媒体，从芯片到卡带到光盘再到网络下载。从电视游戏机到掌上游戏机，游戏存储的容量也越做越大，游戏机也变得越来越小巧、轻薄。</p><p>在如今的手机游戏流行之前，各种掌上游戏机在游戏界的竞争可谓硝烟弥漫。GB、GBA、GBASP、NDS、3DS、PSP、PSV，这是很多人都耳熟能详的掌上游戏主机。当然在这之中也有一些只是昙花一现。加上智能手机的出现，能在手机上玩到如此多种多样的游戏，在此之前，这些东西人们从来没有想过。</p><p>因为在当时的条件下，GameBoy系列、NDS系列、3DS系列，每一款都是惊艳世界的产品。然而到了智能机时代，这些产品的优势逐渐被削弱，一大部分掌机玩家被分流去了手机和平板的市场。</p><p>而自从2007年第一代iPhone发布到今天，智能机经历了多次的变革。随着硬件的提升，移动端的游戏画面逐渐超越了2000年左右次世代32位机，比如PS2以及同时期的次世代游戏机。所以今天我们可以在智能机上玩到相当多的2D、3D游戏，<strong>尽管移动端都是小屏幕，但呈现结果其实已经不输给几年前的高端电脑。</strong></p><!-- [[[read_end]]] --><p>智能机发展到现在，操作系统从苹果、安卓、塞班、黑莓、Windows等，大战最终剩下两大操作系统阵营，苹果和安卓。而苹果和安卓两大生态系统，一个是<strong>封闭式</strong>的系统，一个是<strong>开放式</strong>的系统，有相同点，也有不同点，所以在这两大系统下编写游戏，有很多内容可以讲。</p><p>首先，从<strong>编程语言</strong>这方面说，苹果系统大量使用Objective-C、Swift来开发游戏，而安卓大量使用的是Java。</p><p>而苹果公司选择Objective-C的原因是因为苹果收购了NEXTSTEP。NEXTSTEP是由NeXT.公司所开发的操作系统。这套系统以Mach和BSD为基础，Objective-C作为原生语言，拥有先进的GUI界面。后来苹果公司将NeXT买下，成为Mac OS X的基础，抛开语言特性不说，Objective-C比C++出现年代更早，更为动态），使用Objective-C也有很大因素是这一历史原因。</p><p>而安卓刚诞生的时候，要与苹果展开竞争，目的肯定是要降低开发门槛，吸引更多开发者加入，才能带动安卓的普及。所以选择Java入门比C++来得快，在跨平台的能力上也比C++来得容易，庞大活跃的Java社区可以提供足够的第三方资源库。所以Java成为了安卓平台的首选开发语言，选择Java是一个在执行效率和开发效率之间均衡的选择。</p><p>在安卓和苹果端开发游戏，除了语言区别之外，还有审核区别。如果我们说的是中国开发者，那苹果开发者的开发工作就复杂多了，不仅要申请开发者帐号，递交开发者年费，还要申请游戏运营资质等等。在安卓端，你就省却了申请开发帐号，开发年费的问题，但是其他资质一样是需要申请的。</p><p>不管两者平台的开发语言如何，在安卓和苹果端，使用游戏引擎编写游戏的话，除了使用的语言不同之外，编程接口、引擎的周边工具、美术资源以及最终构建完成后的游戏效果都是一样的。</p><p>在iOS的环境下，我们同样也可以使用游戏引擎来编写游戏。在苹果的体系下，2D游戏比较流行的引擎是SpriteKit。</p><p>SpriteKit是苹果公司在iOS 7的SDK中新加入的一个2D游戏框架，包括物理引擎、视频、滤镜、遮罩等等。IDE中对SpriteKit也有比较好的集成，因为减少了开发者的工作。</p><p>SpriteKit里面有几个比较常用的类：</p><ul>\n<li>\n<p>SKSpriteNode，用来绘制精灵的纹理；</p>\n</li>\n<li>\n<p>SKLabelNode ，文本渲染类；</p>\n</li>\n<li>\n<p>SKVideoNode，视频播放的类；</p>\n</li>\n<li>\n<p>SKEmitterNode，粒子系统的创建和渲染；</p>\n</li>\n<li>\n<p>SKShapeNode，基于Core Graphics 路径形状的渲染；</p>\n</li>\n<li>\n<p>SKEffectNode，使用遮罩来裁剪子节点的类。</p>\n</li>\n</ul><p>因为是苹果公司推出的2D游戏引擎，所以你可以在苹果的机器上编写和调试代码，并且在iPhone上进行预览和测试。</p><p>在编写游戏的过程中，安卓使用工具是Android Studio，而苹果使用的是XCode等编程工具。除了苹果特有的游戏库之外，有不少通用的游戏引擎也可供选择，比如Cocos2d-x之类的，在这两个平台都能编写，比如Unity，比如libGDX游戏库，也是目前在安卓、苹果上编写游戏适合选择的一个游戏库。</p><p>所以如果使用跨平台的游戏引擎，<strong>在两大平台下开发，除了开发语言的区别之外，底层的内容并没有什么区别</strong>，比如Cocos2d-x、libGDX等等，都是跨平台生成不同目标代码的引擎。</p><p>我们继续拿libGDX来做说明。libGDX兼容多种平台系统，自然也包括安卓和苹果。</p><p>这款引擎兼容性强，为调试和开发提供了便利。为什么这么说呢？你可以在电脑上编写测试和调试游戏，但是不需要打开安卓模拟器。开发应用的同学应该知道，安卓应用一般是在电脑上编写、测试、调试，并且到模拟器或者安卓硬件上进行预览运行，但是libGDX解决了这个问题，你可以直接在桌面上进行开发测试和调试。</p><p>libGDX引擎是由audio（音频操作）、files（文件读取）、graphics（2D/3D图像）、math（数学绘图运算）、physics（Box2D物理引擎封装）、scenes（2D/3D场景组件）、utils（内置工具）这些主要模块所组成。</p><p>libGDX主要是用Java编写的，还用了少部分的C/C++代码。至于这部分C/C++代码，是为了针对一些性能做出优化而编写的，比如音频、物理引擎等等。在Java层面，它已经封装了所有的本地代码，相比别的安卓游戏引擎，libGDX的执行效率也比较突出。</p><p>libGDX使用jni封装了Box2D物理引擎的C++版本，所以比之JBox2D速度更快，目前比较流行的几个包含物理引擎安卓游戏引擎（如Andengine、Rokon等）都在用libGDX的封装版本。</p><p>libGDX的开发工具也是非常地丰富，比如粒子编辑器、文字生成工具、贴图合并工具，一些UI库等。</p><p>另外，在网络部分，libGDX最早的版本提供了单机游戏的编写或者一些联网程度不是特别高的游戏。</p><p>在后续的版本里面，由于市场和竞争的原因，现在新版本的libGDX也提供了专门的网络模块。在一款将虚拟环境与现实地理位置信息结合在一起的手机游戏《Ingress》推出之后，也有部分国内公司基于libGDX网络模块编写的手机网络游戏。</p><p>另外，libGDX拥有很强大的第三发工具，比如第三方物理引擎的属性编辑器PhysicsEditor、贴图资源打包工具TexturePacker以及Spine。Spine是制作2D骨骼游戏的动画制作软件，功能非常强大，它的作者也是libGDX的核心代码编写者之一。</p><p>从文档看，libGDX的文档数量已经比较完善了，但是大部分都是英文，对于部分开发者来说学习难度较大。虽然libGDX拥有非常活跃的官方讨论社区，但是大部分还是英文的。</p><p>你可以通过libGDX来编写苹果和安卓的游戏，当然如果你编写的是网络游戏，那么服务器端就需要你自己来编写。</p><h2>小结</h2><p>我来总结一下今天的内容。</p><ul>\n<li>\n<p>从游戏角度讲，手机、掌上游戏机、iPad都属于移动端设备。而进入智能机时代之后，掌上游戏机逐渐退居幕后，成为少部分游戏发烧友的选择。</p>\n</li>\n<li>\n<p>安卓端和苹果端在开发游戏中的区别，主要体现在开发语言上。苹果系统大量使用Objective-C、Swift，而安卓大量使用的是Java。</p>\n</li>\n<li>\n<p>之后，我介绍了苹果端的比较流行的引擎SpriteKit以及适用于各种平台的libGDX。使用libGDX在各个平台编写出的游戏，表现几乎是一样的，除了执行效率或者耗电水平会有细微的差别，但这和引擎其实关系不大。</p>\n</li>\n</ul><p>最后，给你留一个小问题。你知道什么是2D骨骼游戏吗？能否举个例子？</p><p>欢迎留言说出你的看法。我在下一节的挑战中等你！</p>",
        article_title:
          "第31讲 | 热点剖析（四）：安卓端和苹果端游戏开发有什么区别？",
      },
      {
        title: "第32讲 | 热点剖析（五）：如何选择移动端的游戏引擎？",
        id: 10961,
        content:
          '<p>上一次，我和你探讨了<a href="https://time.geekbang.org/column/article/10423">移动端游戏的一些区别和特点</a>，我特别介绍了libGDX这款游戏引擎。因为这款游戏引擎是多平台的，且各种第三方工具都很完备，比如物理引擎、特效、2D骨骼动画工具等等，所以libGDX目前已经被越来越多的公司和个人接受和使用。</p><p>在苹果端，我们也讲到了，苹果公司推出的SpriteKit游戏开发框架，在苹果体系下，使用XCode就可以很方便地使用SK工具开发出好玩的2D移动游戏。</p><p>从目前最新的游戏引擎的趋势看，一次编码、到处兼容已经成为了市场的主流，多种语言、一次打包（多种语言都可以编写相同的代码，然后配合打包成目标平台的游戏），也是程序员喜闻乐见的一种编程方式。</p><p>如果你准备编写移动端的游戏，或者你已经是app程序员，有编码经验但是想要转型游戏程序员，那么你要对移动端的游戏引擎有一定的了解，才能开始你的游戏编程之旅。</p><h2>五种常见的移动端引擎</h2><p>我今天介绍五种常见的移动端引擎，分别是Unity、虚幻、App Game Kit、Corona SDK、Cocos2d-x。</p><h3>Unity</h3><p>和虚幻之类有名的游戏引擎一样，Unity最初是从3D网页引擎的样子进化成现在这样的。Unity普通版是400美元，但是Pro版本要1500多美元，但是如果你购买Pro版的话会得到更强大的功能和编辑器等等。Unity不仅支持电脑和移动端多平台，还支持游戏机甚至掌上游戏机，比如我们熟知的PS系列和PSV之类的，比如《杀出重围》《神庙逃亡》等，都是使用Unity引擎制作的。</p><!-- [[[read_end]]] --><p>Unity的<strong>编程</strong>可以使用C#、JavaScript、Java、Boo等脚本语言。对于Flash，Unity已经放弃支持这个平台了。事实上，Unity在版本4.0之前是可以支持将游戏转换为Flash平台的，4.0后已经不支持转成Flash游戏了。至于Flash被各家放弃的原因我在之前的文章已经讲过，这里就不多说了。</p><p>Unity拥有大量的所见即所得的编程<strong>界面开发工具</strong>。比如支持3D骨骼和动画的导入、贴图的材质可以转换为自身的U3D格式等等。</p><p>在<strong>底层</strong>方面，它支持OpenGL以及DX系列。它自带的物理引擎、粒子系统，性能也极其高效，还支持网络系统，所以你可以使用Unity来编写单机或者网络游戏。</p><h3>虚幻</h3><p>这个大佬级别的引擎，你一定不陌生。它现在已经支持在移动平台使用了。虚幻有免费版本和付费版本，但是只有付费版本你可以获取引擎全部的C++源代码。最为可贵的是，出品虚幻的Epic公司有发布<a href="http://study.163.com/course/introduction/185001.htm">完整</a><a href="http://study.163.com/course/introduction/185001.htm">的</a><a href="http://study.163.com/course/introduction/185001.htm">教学视频</a>，而开发人员也能从网络社区获取大量的学习资源。</p><p>这款引擎不仅仅在游戏引擎技术方面比较优秀，运营方面、市场方面，在行业内都是属于前列。耳熟能详的《蝙蝠侠》《阿卡姆之城》等等用的都是虚幻引擎。</p><p>虚幻引擎有完整的<strong>数据属性编辑功能</strong>。关卡设计人员可以自由地对游戏中的物件进行设置，也可以通过脚本编写的形式进行优化设置。关于关卡编辑器的功能，我在<a href="https://time.geekbang.org/column/article/8670">之前的文章</a>中有详细介绍。</p><p>虚幻的<strong>资源管理器</strong>可以进行快速准确地查找、观看，并对游戏开发中的各种资源进行整理组织。地图编辑器可以让美术开发人员自由地对地形进行升降调节。更强大的是，它可以通过带有alpha通道的笔刷对地图的层进行融合修饰，可以在地图编辑中生成碰撞数据和位移贴图，你看到的可以说是游戏场景的一种演示版也不为过。</p><p>它的编辑器还为美术制作人员提供了完整的模型、骨骼和动画数据导出工具，并可以编辑游戏事件所需要的声音文件、剧情脚本。</p><h3>App Game Kit</h3><p>我个人认为，App Game Kit 比较适合刚进阶的游戏开发者。这款引擎使用非常容易上手，你可以去它的<a href="https://www.appgamekit.com/">官网</a>看最新发布的消息。有一款Driving Test Success的应用就是使用AGK编写的，当然这是一个商业化的付费引擎。这款游戏引擎也支持树莓派上编程，可谓是各个平台都兼容。</p><h3>Corona SDK</h3><p>如果你深入学习过或者接触过移动端游戏开发的话，你一定知道这款游戏引擎。这款引擎不仅仅是跨平台支持，甚至还支持Kindle电子书这类的平台。</p><p>它的编程语言为Lua，我们在之后的文章会介绍Lua和C语言的绑定，我在这里只是简单说一下。相对于别的语言来说，Lua更加轻量级，对初学者来说也更容易上手。</p><p>Corona SDK的客户除了个人，也有很多知名的大厂，比如日本的南梦宫等等。当然收费也并不便宜，专业版就接近600美元，企业版接近1000美元，当然如果是企业用户的话，这点投入比之自己编写引擎来说，划算得多。</p><h3></h3><p>Cocos2d-x</p><p>国内的朋友对这款引擎非常熟悉，与此同时，它的同胞兄弟Cocos2d系列，我也在<a href="https://time.geekbang.org/column/article/9702">前面</a>做过一些介绍。</p><p>很多人以为Cocos2d-x是中国人编写的。事实上Cocos2d的作者是一个叫Richardo的阿根廷人。Cocos是在阿根廷的一个叫Los Cocos的地方诞生的。由于Richardo的学习曲线是汇编、C/C++、Python，所以这个时候Cocos版本是Python的。他们将研究成果在PyCon 2008和EuroPython 2008上都做了展示。</p><p>2008年的时候，他们抓住iPhone发布的机遇，在2008年6月宣布支持iPhone，然后沿用了Python版本的Cocos2d相同的设计思维，用Object-C重新编写了iPhone版的Cocos2d并且发布了0.1版。智能手机刚起步的时候，iPhone用户数量明显多过安卓，所以Cocos2d刚开始就笼络了大批iPhone开发者，随后又有了安卓版。所以，现在用Cocos2d引擎编写的游戏，几乎随处可见。</p><p>在2009年的时候，Cocos团队编写了Cocos2d的World Editor，Cocos2d-Python。这个编辑器用起来非常方便，随后Cocos2d的各种平台和各种语言的移植版本也逐渐被各类程序员拿去开发并且出现在开源社区。</p><p>我们可以看到几个主流语言的绑定版本：</p><ul>\n<li>\n<p>Ruby版本：ShinyCocos</p>\n</li>\n<li>\n<p>安卓版本：Cocos2d-Android</p>\n</li>\n<li>\n<p>.NET 版本：CocosNet（Mono based）</p>\n</li>\n<li>\n<p>Windows版本</p>\n</li>\n</ul><p>这里有一幅来自它的官网的产品分支图，你可以比较清晰地了解Cocos2d的各个分支。</p><p><img src="https://static001.geekbang.org/resource/image/18/1c/183105d6284d501f3337c192ffebe11c.jpg" alt=""><br>\n同时经过几年的努力，Cocos系列也拥有了非常优秀的编辑器，例如SpriteSheet Editors（精灵序列图编辑器）、Particle Editors（粒子编辑器）、Font Editors（字体编辑器）、Tilemap Editors（瓦片地图编辑器）。</p><p>CocosStudio这款工具集套件于2012年发布，它是Cocos2d-x团队官方推出的游戏开发工具。CocoStudio根据开发团队自己在游戏开发中的经验，为移动游戏开发者和团队定做了这么一套集成工具，用意在降低游戏开发的门槛，提高开发效率；当然最主要还是为了Cocos2d-x占领游戏引擎市场。</p><h2>如何选择引擎？</h2><p>今天我介绍了这五款引擎，在开发的过程中，究竟该如何选择呢？如果接触游戏开发不久的话，你肯定还是会有点懵。 <strong>其实只要有选择，就有取舍，你只要明确自己的需求，然后结合自己的需求和引擎自身的特性，来对比选择就可以了。</strong> 这里我把这五种引擎的一些特点，总结了一下，列了一个表格。你在选择的时候，可以作为参考。</p><p><img src="https://static001.geekbang.org/resource/image/52/b5/5207890afc60df1fef5d8ce01edda6b5.jpg" alt=""></p><p>首先，如果我们只是编写2D游戏，那么Cocos系列一定符合你的预期，而且能方便地制作出跨平台的游戏。</p><p>如果我们编写的是3D游戏，如果是商业购买多话，那么Unity和虚幻一定是不错的选择。在财力足够的情况下，选择这两个大厂级别的游戏引擎，一定会让你满意。</p><p>但是如果你需要编写休闲的、规模不大的游戏，那么Corona、App Game Kit就可以用。</p><h2>小结</h2><p>我们总结一下今天的内容。</p><ul>\n<li>\n<p>首先，移动平台的游戏引擎有一个最大的特点，游戏引擎已经逐渐演变成跨平台能力的游戏引擎，如果不这么做，很块就会被别的竞争对手所淘汰，我们先前讲到的HTML5游戏引擎，都可以编译出不同的跨平台的目标代码。</p>\n</li>\n<li>\n<p>其次，移动游戏引擎，要挑选适合自己的才行，引擎规模有大有小，做出来的游戏质量也都不同。游戏开发大厂，可以选择虚幻引擎；中等公司可以选择Unity；个人团队可以选择Cocos2d或者App Game Kit；个人开发者或者轻量级开发可以选择Corona SDK。</p>\n</li>\n</ul><p>最后，给你留一个小思考题吧。</p><p>如果用移动平台的游戏引擎编写移动应用，是否可以实现呢？</p><p>欢迎留言说出你的看法。我在下一节的挑战中等你！</p>',
        article_title: "第32讲 | 热点剖析（五）：如何选择移动端的游戏引擎？",
      },
      {
        title: "第33讲 | 热点剖析（六）：AR和人工智能在游戏领域有哪些应用？",
        id: 11632,
        content:
          '<p>在2014年左右，VR、AR、人工智能开始逐渐火热起来，我也曾在它最火的时候深入接触过这几项技术。</p><p>如果你不是在这个领域从业的话，除了VR之外，有很多名词你可能都没有听说过，那我们就先来看一下这些名词是什么意思。通过这几个名词，我们来看一下它们究竟是如何在游戏领域应用的。</p><h2>VR是什么？</h2><p><strong>VR</strong>本身是<strong>Virual Reality</strong>的缩写，意思就是<strong>虚拟现实</strong>。VR相对于AR、MR等技术来说，在技术上是最为简单的。简单地说，它只需要将3D画面做成可以通过3D眼镜呈现的内容即可，那么VR眼镜是怎么播放VR画面的呢？</p><p>VR基于不同视觉场，在局部空间中营造出对不同画面的深度感知，在用户的大脑视觉系统中形成一个虚拟现实视场，而决定虚拟现实视场的主要因素是透镜，而非我们人眼的瞳孔。因此，为了得到更宽广的视场，制作者需要缩短用户眼球与透镜间的距离，或增加透镜的大小。</p><img></img><p>VR眼镜的结构一般都是透镜加上屏幕成像的方式，透镜放置在眼前2～3厘米的地方，屏幕距离透镜3～6厘米，成像在眼前25～50厘米左右。</p><p>除此之外，在VR中，两个眼睛的立体视觉起的作用很大。用户双眼看到的不同图像是分别产生的，显示在不同的镜面上。用户带上VR眼镜后，一只眼睛只能看到奇数帧图像，另一只眼睛只能看到偶数帧图像，奇、偶帧之间的不同，也就因为视差产生了立体感。</p><!-- [[[read_end]]] --><p>人的眼睛有两方面用途，一个是判断左右距离，一个是判断前后深度距离。VR眼镜相当于通过透镜，欺骗了你的眼睛，让你的眼睛认为自己是在真实的场景下工作，而有些人对于距离和景深比较敏感，就会有眩晕的副作用出现，毕竟是模拟真实的效果，而非完全真实的场景。</p><h2>如何区分AR和MR？</h2><p>随着VR的兴起，AR也逐渐进入了人们的视野。<strong>AR</strong>（<strong>Augmented Reality</strong>）<strong>就是增强现实</strong>。简单地描述，所谓增强现实，就是利用摄像头或者头盔，将现实世界外部影像结合内部3D计算的影像，将内容混合。</p><p>比如我们走在一个空旷的屋子里面，忽然在AR视觉效果里面，出现一个怪兽，向你扑过来，你需要拿起手柄，将手柄变成武器，将怪兽杀死，这里面就涉及AR，<strong>它将现实中不存在的东西模拟出来，变成增强了效果的现实场景。</strong></p><p>至于<strong>MR</strong>，它是<strong>混合现实</strong>（<strong>Mixed Reality</strong>）。混合现实的意义和AR非常相似，比如将现实混合在视觉效果中，这是两者都在做的事情。同时，AR和MR中比较重要的一个技术是定位技术。</p><p>基于2D定位的是AR最成熟的技术。2D定位是基于平面的识别和定位，比如利用手机App拍摄图书中的某个图片，然后虚拟物件就会出现在手机中的对应位置。这种App可以识别一幅图片或者图形，作为定位点，随后手机生成的虚拟物体会围绕这个点，融入到被拍摄的现实环境中。</p><p>3D环境的动态实时解析是当前AR在技术中最活跃的功能，这其中不得不说的就是SLAM定位。所谓SLAM就是“同时定位与映射”（Simultaneously Localization And Mapping）。</p><p>AR中的SLAM比其他别的领域中的难度大很多，因为移动端的硬件计算能力和资源比起其他硬件平台来说弱很多，所以难度比资源充足的硬件平台更大，所以有一些做法是利用网络交互，到主服务器去计算SLAM场景，但是网络交互又有实时性无法保证的问题。计算SLAM最好是本地计算，这样才能保证随时随地都能计算，而如果通过网络交互的话，你可能需要等好久才会拿到计算结果。</p><p>SLAM的问题可以这么理解：打开摄像头，你要知道“我（摄像头）在哪”。然后进行定位，定位完后需要对周围的环境进行映射和虚拟环境的构建。然后一边走，一边对周边环境进行虚拟模型的构建，确定本身在所建地图中的定位。所以AR SLAM需要在走的过程中，一方面把所见到的地方连起来成模型图，另一方面找到自己在地图上的定位， 这就是SLAM的原理。</p><p>AR和MR的原理大致一致，不一样的是，MR是在AR的基础上将3D物件更精确地展现出来。那究竟该怎么区分AR和MR呢？有一个方法就是，看虚拟物件是否会跟着真实场景一起动。如果是的话，就是MR；如果不是的话，就是AR。</p><p>所以，MR比AR更“先进”的地方就是，它看起来更像现实，所以是“混合现实”。当然MR还有更多事情可以做，比如它可以让你听到、感受到来自虚拟世界的感受，这是混合现实的另一层含义。</p><h2>AR在游戏开发中的应用</h2><p>说完了这些名词，我们来看一下实际使用AR技术制作的游戏吧。</p><p>AR最出名的就是前些年的《PokeMon》和LBS结合版本的AR游戏，这款游戏风靡一时，可以说是AR领域一次比较成功的尝试。它利用SLAM技术，结合相机拍摄的真实场景，让虚拟小宠物出现在真实场景下，然后进行App端的操作。</p><p>VR就不用说了，现在Steam上拥有大量的VR游戏，比如前阵子非常火爆的《Beat Saber》，就是一款非常成功的VR音乐游戏。还有《刀剑神域》也是成功的VR游戏。</p><p>但是所谓的VR游戏，用到的VR头戴式设备，用的其实还是“MR”设备。因为所谓的混合现实头戴设备，就是将手中的手柄，眼里看到的内容进行混合，比如手柄变成剑或者手枪，这就是混合现实的一部分，所以使用MR设备也无可厚非。</p><p>所以在视觉效果的增强下，目前VR在游戏中的使用范围是最广的，其次是AR和MR。</p><h2>人工智能在游戏开发中的应用</h2><p>至于人工智能，那也是最近比较火爆的一个行业风口。但是从理论讲，我觉得人工智能、AR、VR并不会像HTML5技术、Flash技术等一样变成全面颠覆产业的技术，而是会成为各个行业的辅助。</p><p>人工智能涉及的领域很多，每一个分支进行细分，都是一个研究课题和研究方向，比如导航当中的语音识别、手机的人脸识别、专家系统、大数据分析、机器学习等等。在游戏领域，能使用到人工智能的地方，或者说最能体现人工智能的地方，就是游戏中的NPC。</p><p><strong>NPC是最简单，但也是最难做好的</strong>。如果做得简单，你随便写几行脚本语言，就可以完成一段NPC，或者一整个城市NPC的编写。但是如果要写得好，利用简易的人工智能，就能将NPC做的很真实。</p><p>比如《老滚》中的NPC，你可以看到他走向某个地方去和某人说话，或者你跟踪他一段时间会发现他会和森林里某些野兽战斗。在脚本语言里面，就是大量的事件绑定机制来实现人工智能的功能，比如A事件和B事件组合出现就可以决定某些NPC的行为，比如你可以利用类似代码来作为NPC的行为准则。</p><pre><code>def foo():\n\n    if npc.action == eat and player.action == talk:\n\n        npc.action = talk\n</code></pre><p>早几年，我曾经想做一款只有NPC，没有玩家的游戏。你可以观察它们的生活起居，也就是所谓的“上帝模式”。这样的游戏要求游戏中的NPC足够智能，以至于这里面的人工智能需要做一些最基础的判断，类似“自动”的“模拟人生”。然而当我开始编写逻辑代码的时候，就发现事情并非想象得那么简单。</p><p>我们先抛开人工智能本身不说。我们首先从NPC入手，从编程角度讲，每个NPC一定有一个统一的身体和大脑的类，就像“模拟人生”一样。我们先要塑造这个NPC的躯壳，有了躯壳，才能填写数据进去，比如他累了要睡觉，饿了要吃饭，渴了要喝水，到达一定阀值就要去做某件事情。</p><p>单从一个NPC入手的框架都很难实现，就算真的完成了一个NPC的人工智能的框架，一个游戏中有这么多NPC需要交互和计算，一台普通的个人电脑估计很难运算过来，所以从这点来讲，这个游戏的编写计划就已经很难实现。</p><p>我们最常见的就是还有地图生成、人物运动控制等。</p><p>我们可以通过学习算法进行地图的随机生成，比如哪些是河流，河流旁边一定有树木，河流旁边不可能有飞机场等等；另一个领域是利用神经网络实现人物运动控制，你如果有兴趣也可以去这个网站看。</p><p><a href="http://theorangeduck.com/page/phase-functioned-neural-networks-character-control">http://theorangeduck.com/page/phase-functioned-neural-networks-character-control</a></p><p>除此之外，也可以用在一些2D讲故事类的游戏中，开放式结局的游戏中，有了人工智能，我们就可以把开放式解决做得更生动和有趣，每个人物的结局都可以是不同的，也没有任何死的套路可言，但是从某方面讲，这个要实现起来也有一定的难度。</p><h2>小结</h2><p>今天我们讲了VR、AR的知识以及人工智能在游戏中的应用。</p><p>AR和VR是对于人们在现实世界的一种增强技术，将现实和虚拟结合起来，做出更多优秀和好玩的游戏，而人工智能则能让人们在游戏中的体验能更好，比如智能的NPC行为，漂亮的随机地图的生成等等，这些技术的应用能使我们的游戏体验能变得更加丰富。</p><p>给你留个小问题，任天堂出的3DS，是最早的一款裸眼3D设备，这种技术是怎么实现的呢？</p><p>欢迎留言说出你的看法。我在下一节的挑战中等你！</p>',
        article_title:
          "第33讲 | 热点剖析（六）：AR和人工智能在游戏领域有哪些应用？",
      },
      {
        title: "第34讲 | 热点剖析（七）：谈谈微信小游戏的成功点",
        id: 12179,
        content:
          "<p>在定下这个专栏目录的时候，微信小游戏仅仅出现了唯一一款《跳一跳》。在写下这篇文章的时候，微信小游戏已经在小程序领域占据了绝大部分的江山。大量开发者涌入微信小游戏，为微信生态、为微信小程序的生态增添了无数可能性。作为游戏开发者，免不了要被挤入这场战斗。今天我们就来了解一下微信小程序和小游戏背后的技术，来看看它们成功的背后，有哪些技术上的支持和创新。</p><h2>微信小游戏的技术创新</h2><p>最早以前，微信小游戏有3M程序大小的限制，而到了现在，这个大小限制已经上升到了8M，这使得微信小游戏从轻量级的休闲游戏，逐渐往中级、重量级的方向发展。游戏的品质和操作性也有了质的提升。</p><p>小游戏的体积为什么会有限制呢？因为体积较小的话，我们可以从服务器快速拉取资源数据来开启游戏。现在，微信平台本身已经可以做到20M的体积限制，只是微信并不愿意开放地太快，因为开发者有一个循序渐进的过程，微信平台本身的战略规划也有一个循序渐进的过程。</p><p>我在之前的热点剖析部分，分析过HTML5技术发展以及HTML5游戏引擎，<strong>其实微信小游戏、小程序，甚至微信本身都是基于HTML5技术的，而微信小游戏用的其实就是HTML5技术，只是在小游戏中运用的是Canvas 2D的API和WebGL 1.0的API。</strong></p><!-- [[[read_end]]] --><p>毕竟微信小游戏也属于小程序的范畴，所以我们先来看一下微信小程序。</p><p>微信小程序用的是基于WebView的技术。所谓的WebView，你可以理解为在手机中内置一款高性能WebKit内核的浏览器，然后将这个浏览器核心封装成SDK，供接口方调用。这个浏览器核心没有地址栏和导航栏，只是单纯的在软件需要的地方展示一个网页界面。</p><p>微信小程序本身分为页面的视图层和逻辑层。页面的视图层运用的是WXML和WXSS，它们是两种腾讯修改过的HTML和CSS技术；而逻辑层则分为Manager和API。视图层和逻辑层都呼叫了JSBridge技术，更下层则是一些网络服务、离线存储，再下层则是系统层。具体的结构，你可以看我画的这幅图。</p><img></img><p>微信小游戏脱胎于微信小程序。小游戏兼顾传统HTML5技术和小程序技术，但是小游戏却没有用到WebView技术，而是修改了HTML5规范的一些接口内容，成为腾讯自己的内容。也就是说，同一款游戏，如果要在微信小游戏和普通网站都能运行，需要编写两套代码。</p><p>那么你或许就要问了，为什么微信要自己开发一套Web体系而不用Web本身的标准体系呢，这样不是增加了前端程序员的工作量吗？如果说都是一套Web体系的话，大家不就可以皆大欢喜，到这里可以用，移植到那儿也可以用。</p><p>同样的问题，我们是不是可以这么问，为什么苹果公司要自己研发iOS系统，用最早最成熟的塞班系统不是挺好，诺基亚用得也挺不错。为什么谷歌要开发一套Go语言，现成的Java、Python不也挺好，都挺成熟，为什么一定要开发新的东西，让工程师入坑呢？</p><p>有很多人说，自己开发一套体系是因为微信下的棋很大，野心很大，你可以这么理解，我们今天从技术本身来看看，事情是什么样的。</p><p>我们从以下几个方面来看为什么微信要自己定义一套体系。</p><ol>\n<li>\n<p><strong>可以自定义Web标准</strong>。为什么要自定义Web标准呢？我们从结果来看，自然是为了提升用户体验。而从技术层面讲，这和Web兼容性有关。Web标准本身是个庞大的体系。所以如果既要全部兼容Web体系又要按照自己的意愿去实现功能，这是很难做到的事情。比如，如果微信本身的小程序浏览器会重塑一套渲染规则，比如播放视频的时候自动屏蔽广告、按钮默认变成椭圆形等等，因此，自定义Web标准，可以去做更多的事情。</p>\n</li>\n<li>\n<p><strong>可以自定义开发标准</strong>。微信扔掉了Web兼容性以及标准HTML5的内容之后，就开始自定义开发标准了，所以微信强制要求开发者按照某种编码规则来编写代码，从而解决了在普通Web编程中“如果不用某种规则来编码，就会出现兼容性问题”的难题，这样，就从源头上解决了这个问题。事实上，这也是“强制约束开发者写出素质较高的代码”。</p>\n</li>\n<li>\n<p><strong>可以有比HTML5更强的功能</strong>。完全兼容标准HTML5的话，并非不可能，如果你熟悉前端开发的话，就会知道这个坑会有多大。因为首先HTML5不具备很多功能，比如获取手机设备信息、获取手机罗盘、地图定位等等。但如果用自定义的体系，加上从微信作为App本身具有的底层获取功能，就完全可以做到了。</p>\n</li>\n<li>\n<p><strong>防止刷流量、刷广告</strong>。在防止垃圾HTML5页面出现的这件事情上，微信做了大量的工作，比如你应该经常可以看到的，如果出现单纯的IP地址的页面，微信就给出提示，询问你是否跳转，或者提示你可以举报诱导分享等等，当然这都不能完全避免垃圾HTML5页面出现在微信生态下，所以在小程序自定义规则的情况下，你只能按照定义规则来开发，如果想钻空子，最后小程序和小游戏的上线还有一道人工审核的关卡，所以想要出现垃圾HTML5页面的情况几乎是不可能出现的。</p>\n</li>\n<li>\n<p><strong>方便后续优化</strong>。由于微信自己那一套体系是高层次抽象层，所以微信小程序团队可以在用户完全没有感知的情况下进行底层优化，而上层不用修改任何代码就可以了。</p>\n</li>\n</ol><p>所以说，微信小游戏其实是基于HTM5技术，并在此之上，充分结合自己的需求和产品特性，添加了自己的创新。</p><h2>微信小游戏成功的原因</h2><p>微信小游戏建立在微信本体上，因此微信能获取到的移动端的<strong>底层功能</strong>小游戏基本都能一并获取，比如网络连接、内部存储等等，而HTML5做不到这点。微信可以获取底层平台的接口且并不需要授权，因为微信安装上去后已经获取了手机的权限，小游戏想要或者一部分权限是很容易的事情，相比HTML5游戏要从浏览器获取权限那就是很麻烦的一件事情。</p><p>其次，因为微信本身作为<strong>流量入口</strong>，对于小游戏的传播是一个极大的便利，独立开发者或者中小游戏开发公司，如果前期没有推广资源和推广渠道，那么通过微信本身这个巨大的流量入口，就可以获取相比传统HTML5游戏更好的效果。</p><p>除此之外，传统HTML5小游戏可以包装成App的外壳做成App的形式供人下载，因此又多了一个获客途径。到了后期，苹果公司加大了对于HTML5应用和游戏包装成App这种形式的审核力度，加上网页机制的运行效率限制，HTML5套壳程序比原生应用的体验感也更差。</p><p>传统HTML5游戏发布之后，如果需要更新，则需要重新上传一次网页代码。如果用户端还需要重新刷新网页，甚至清除浏览器缓存等复杂的操作，如果做成App套壳，那就更需要在各个渠道市场上传一遍程序，这在效率上就慢了一截。而微信作为平台本身，更新游戏后，你重新获取只需要上传到微信平台就可以了，获取新游戏，刷新网页缓存，微信一并帮你做了。</p><p>传统HTML5游戏的<strong>广告接入</strong>，是非常麻烦的一件事情，你需要去和广告商去做分成机制、对接广告接口等等。如果是微信小游戏，你只需要对接微信自己的广告渠道就可以，可以说是一键就能对接几种广告机制，广告分成也是透明的、公开的。</p><p>微信平台本身拥有<strong>打击拷贝游戏</strong>的能力，如果有一款游戏被抄袭了，你可以投诉，如果发现属实，微信就会将抄袭的游戏下架，这样一来，就保护了原创游戏，激发广大开发者创作出更好的游戏，给微信带来更好的游戏生态。当然这里所谓的原创机制，是指的微信小游戏本身生态下的原创，因为作为成熟的游戏生态来讲，已经基本不存在狭义上的“原创”这两个字了。</p><h2>小结</h2><p>这节内容差不多了，我们来总结一下。我和你讲了这样几个内容。</p><ul>\n<li>\n<p>微信小游戏、小程序都是基于HTML5技术的，而微信小游戏的技术就是HTML5技术，只是在小游戏中运用的框架并不是普通的HTML5的框架。</p>\n</li>\n<li>\n<p>微信小程序用的是基于WebView的技术；小游戏却没有用到WebView技术，而是修改了HTML5规范的一些接口内容，成为腾讯自己的内容。</p>\n</li>\n<li>\n<p>微信平台之所以要自定义自己的一套体系，比如Web标准、开发标准等等，是因为可以结合微信本身的特性，在此基础上制作出更契合腾讯生态的产品，一句话就是，为了方便自己开发、优化和管理。</p>\n</li>\n<li>\n<p>微信小游戏基于微信的底层获取功能、广告接入优势和打击拷贝的能力，塑造了一个更好的微信小程序生态。</p>\n</li>\n</ul><p>迄今为止，你最喜欢玩的一款微信小游戏是什么？它吸引你的点是什么？</p><p>欢迎留言说出你的看法。我在下一节的挑战中等你！</p>",
        article_title: "第34讲 | 热点剖析（七）：谈谈微信小游戏的成功点",
      },
      {
        title: "第35讲 | 热点剖析（八）：谈谈移动游戏的未来发展",
        id: 12460,
        content:
          "<p>随着芯片纳米工艺技术不断提升，我们的电子设备变得越来越小，而随着移动设备的普及，移动游戏一定是未来游戏行业发展的重头，未来游戏玩家将会花更多的时间在移动端的游戏上，所以我们今天就来探讨一下移动游戏的未来发展。</p><h2>现阶段移动游戏是什么样？</h2><p>在展望未来之前，我们先来看看现阶段的移动游戏是什么样的。</p><p>首先，移动游戏比较轻量级，一局游戏时间快，能很快出结果。像竞技类游戏的一局时间一般不会超过30分钟。由于手机屏幕和操作限制，没有游戏机手柄或者电脑鼠标键盘之类的方便操作，所以移动端的游戏操作手法极尽简化，所以需要尽量突出让人第一眼就能耳目一新的画面效果。</p><p>各大平台级的App都推出了不同的“小程序”技术，只是名称叫法各有不同，除了叫“小程序”，还有“快应用”“轻应用”的说法等等。在这样的聚合平台下，重量级原生游戏已经逐渐减少，转而都去了聚合平台下，比如微信小游戏。</p><p>而HTML5游戏依然有人在做，只是变成了大中型电脑网页游戏的形式，以及营销推广渠道的一种方法。这其实和以前Flash的路径一样。如果现在有人做HTML5游戏的话，更多的可能会往微信端、支付宝端等平台级应用上的小程序方向走。</p><p>原生移动端游戏往高操控性、高画质、高可玩性这几个方向走，人群更接近核心玩家，更多碎片时间的游戏内容将往HTML5、微信小游戏等方向走。</p><!-- [[[read_end]]] --><h2>什么是移动游戏发展的最大掣肘？</h2><p>要思考移动端游戏的发展，不得不提硬件的发展。没有硬件的发展，移动游戏始终是这样几种形式。而在硬件问题还不能解决的情况下，移动游戏有哪些路可以走呢？</p><p>首先，往更大型的方向发展，逐步取代电脑上一些中等、小型的游戏。手游的硬件发展带动质量的发展，变得更像电脑上的游戏，3D、2D的精美的游戏将更多出现在市场上。而重度游戏的发展，将会有迎合重度硬核玩家的游戏加入，包括周边设备的联动推出，比如手柄、键盘等等。</p><p>AR、VR等功能游戏的推出，就算是在现在，这几种类型也是一直在市场上推出，在不久的将来，手机硬件的提升会让这类游戏变得越来也多，裸眼3D游戏也会变得越来越多。</p><p>而更多利用手机硬件特性的游戏将会出现，比如随着苹果前置感应头的出现，前置感应的人体体感游戏，或者脸部感应游戏也会出现，这些其实都是以前Wii时代体感游戏的缩小版本。</p><p>手机游戏与电视或者电脑游戏联合互动。随着任天堂Switch的发布，多屏互动，小屏和大屏游戏联合也会是将来移动游戏的一个方向。如果有新的巨头加入手机竞争，比如微软，那么手机和电视机连接玩耍，或者安卓系统的电视盒子和手机端联动，也将会是一个发展的趋势。</p><p>其次，人工智能将出现更好的发展，泛游戏类型和应用，以及游戏内的人工智能，结合AR、VR等的游戏也将出现，游戏将会给玩家一个更好的体验。</p><p>移动端的硬件发展，除了平板市场之外，手机市场的硬件发展并不是特别快，而平板市场则是下一个移动端硬件发展的风口，比如安卓的拥有独立显卡的平板，这就给深度学习、人工智能提供了良好的运算平台以及商业接口。毕竟高质量的移动游戏需要在更高级的硬件设备上才能呈现。</p><h2>移动设备未来会有什么样的变化？</h2><p>在这个基础上，我们的移动设备会有什么变化呢？</p><p>移动设备会随着硬件的发展变得越来也小。虽然越来也小，但是计算能力已经遇到了摩尔定律的瓶颈，所以，虽然硬件可以越做越小，但是CPU的计算能力却并不见得能变得更为强大。而可能是，今年的普通移动设备A，在明年会缩小，变成B。B的计算能力和A一样，只是变小了，而明年做成普通移动设备的C，计算能力会比B更强大一点，然后后年C也会缩小，变成D，D变成和C一样的计算能力，这样一代一代往下发展。</p><p>由于移动设备变得越来越小，那么小型移动设备上的游戏也会变得可观，比如智能手表上裸眼3D的小游戏，甚至就像科幻片里面，手表上的游戏投影在手臂上方，这种模式不再变得不可能。</p><p>我们之前说过，谷歌眼镜并不成功，并不是应用少的问题，而是场景的问题。试问谁会戴着眼镜到处跑，为了利用眼镜识别各种物件，而非常不自然地盯着某个物体看半天？其次，技术也不是特别成熟，上传数据到分辨并且得到信息是有时间差的，无法做到完美实时。</p><p>我们不妨做一个实验，打开手机摄像头，拍摄视频，你会看到视频中的影像比现实中大致慢半秒左右，这是由于视频抓取后呈现，流的压缩等各种手机端的计算占据了一定的时间，所以哪怕本地都无法做到完美实时，又如何将网络端交互变成实时的呢？</p><p>所以未来移动设备变得小的同时，做的应用和游戏也应该考虑到<strong>互动效果</strong>和<strong>硬件</strong>的制约因素。</p><p>移动设备并不只是指手机和PAD，眼镜、手表、车载导航之类的，也可以算是移动设备，这样很多游戏都可以放在不同的移动平台下，比如车载导航内的小游戏，比如手环上的简单游戏，都是发展的方向。</p><p>而AR和VR，体感游戏依然是移动端游戏的一个卖点，因为可以随时随地玩游戏，所以结合现实世界和虚拟世界类型的游戏将会越来越多，再结合地图定位，能玩转的游戏类型也会越来越多，如果能结合现实中的头戴式设备，比如类似谷歌眼镜的成熟产品，那么结合AR VR等的应用，将会变得非常生动和有意思。</p><p>前些年就有PokeMon之类的AR游戏风靡了一阵子，但是这类游戏，最主要是是结合了一个强大的IP之上，其次是新鲜感，当时去新鲜感后，如何让玩家保持继续玩下去的动力，就是游戏公司需要做的事情了。</p><p><strong>制约移动设备发展的，并不是技术本身，或者将芯片做小的能力，具体来说就是电池，</strong> 不仅仅是移动设备，事实上各种设备上的制约因素都是电池，包括笔记本、电动汽车、无人飞机等等，只有解决了电源问题，科技才可能有质的飞跃。</p><p>如果我们有了大容量的电池且不增加额外电池尺寸开销的情况下，移动端游戏会有怎样的发展呢？</p><p>如果电池得到了发展，移动端游戏将会出现和PC端游戏一样的效果，比如玩3D游戏再也不需要半小时一个小时充一次电了，玩再久的游戏都只要两天或者更多天，才充一次电，这在现在是无法想象的，比如智能手表上的游戏，不可能一只手表玩了游戏后，一天充一次电，这实在是非常尴尬的事情。</p><h2>小结</h2><p>我们来总结一下今天的内容。</p><ul>\n<li>\n<p>移动端游戏将往更加精品、高画质、高品位的游戏转型。3D、VR、AR等游戏也会层出不穷，移动端和大屏幕之间的阻隔也会逐渐模糊，两边都可以互相游戏。</p>\n</li>\n<li>\n<p>另外，如果摆脱了电池的掣肘，那么移动端游戏将往PC端游戏的方向发展，更高质量的3D游戏也不用担心电池耗尽而半途无法玩了。</p>\n</li>\n</ul><p>给你留个小问题吧。</p><p>如果让你来开开脑洞，思考下移动游戏的未来发展方向，你认为移动游戏会怎么走下去呢？移动游戏的未来是往高品质高画质走下去，还是往真实与虚拟结合走下去呢？还是有其他的方向？</p><p>欢迎留言说出你的看法。我在下一节的挑战中等你！</p>",
        article_title: "第35讲 | 热点剖析（八）：谈谈移动游戏的未来发展",
      },
      {
        title: "第36讲 | 热点剖析（九）：谈谈独立开发者的未来发展",
        id: 13074,
        content:
          "<p>我曾经看过这么一句话，<strong>游戏开发是一门异常复杂的综合性艺术创作</strong>。作为个人独立开发者，一个人常常需要包揽所有职责，策划、美工、原画，甚至推广。</p><p>说到推广，不得不提的就是发布平台。比如，我第一时间想到的就是Steam，这个由专门开发电子游戏的美国Valve公司开发的PC游戏界最大的发行平台。对于Steam，我想你应该非常熟悉了，我这里就不多介绍了。</p><p>但是，现在Steam的日子也并“不好过”，更别说独立开发者本身了。</p><p>以前，一个人在DOS下就可以编写出一款小游戏，一支三五人的小团队就可以做出一款游戏，现在来说几乎是不可能的。现代游戏需要大量人力物力去做一系列的基础工作，美术、关卡、引擎等等都是必不可少，甚至可能成为影响一款游戏成功与否的必要因素。即便你有特别优秀的创意，有非常突出的画面和故事情节，但是依旧很容易就被淹没在游戏海洋中。</p><p>为什么现在的游戏制作的难度越来越大？请注意是制作，不是开发，制作游戏不仅仅包含开发，还包含创意、资源调配、产品规划等等。不少人跟我讨论过这个问题，我自己从业的这么多年也一直在思考这个问题。</p><p>其实，并不是因为游戏开发的难度比先前更难，相反，现在开发游戏的难度，比DOS时代小多了。但是，游戏的制作却没有变得更简单。这是为什么呢？</p><!-- [[[read_end]]] --><p>DOS时代开发游戏，有一个好的idea后，最先要考虑的是DOS 16位的内存限制，因为很可能一不小心就崩溃了。到了DOS游戏后期时代，有了DOS4GW这种突破内存限制的“32位保护模式”的方式开发游戏。虽然可以几乎不用考虑内存限制，但是难度依然很高，要从头绘制鼠标箭头、点击事件。所有玩家在界面上能看到的和不能看到的，都要手工一行一行敲出来。</p><p>现在不同了，有了游戏引擎，只需要往引擎里填写需要的内容就可以了。很多情况下，鼠标箭头、UI点击事件，甚至图像载入，绘制这些底层操作都不需要你关心，游戏引擎一揽子都包装好了。</p><p>我曾经看过Steam游戏Descenders的创意总监Mike Rose的一篇采访，大致是说，现在在Steam上上架的游戏，利润大部分都被头部游戏赚取。</p><p>一个重要的原因是，Steam上的游戏越来越多，就像苹果商店，如果用户不搜索，基本不可能会有新游戏的展示和宣传位置。即便Mike Rose提议最好能整理游戏列表，能下架一系列没人买的僵尸游戏，这样一来就能给更多的新游戏以展示自己的机会，但是，Steam没有这么做或者说已经大势已去来不及挽回。所以，越来越多的开发者开始转向了主机游戏。</p><p>所以以目前的形式看，对于独立开发，我其实更看好主机游戏。</p><p>加上Switch、XBOX等主机游戏相继都推出了自己的独立游戏计划，吸引了很多Steam平台的独立开发者进入。尽管主机游戏并非是独立游戏开发者的第一选择，然而XBOX等的开放态度以及Steam平台的利益不平等，还是导致很多开发者流向了主机游戏。</p><p>我们开发的游戏，最常开发的分别为PC游戏、原生App游戏、HTML5游戏（不含PC的MMO游戏）、微信小游戏。</p><p>在微信小游戏的生态中，你只需要注册账号，并且使用游戏引擎导出到微信，并且申请游戏资质就可以上线运营了。</p><p>关于PC游戏，Steam依旧是最大的PC游戏商店平台。原生App游戏，苹果端就不说了，没有别的选择。而安卓端，国内有至少30个应用市场可以上架，所以走一圈上架流程、接入到平台API就是一个相当麻烦的过程。</p><p>如果要做原生安卓游戏，把主要精力放在几个大平台上就行了。HTML5游戏，也有可以选择的平台，比如比较出名的4399、4177等。</p><p>从收入情况看，苹果App的收费情况比安卓端更好，一个是用户付费习惯早已经在苹果端养成。另一个是苹果端游戏有审核（谷歌市场也有审核，但是没有苹果那么严格），所以游戏质量都能得到保证。</p><p>PC端的Steam市场也有较好的收费机制。而微信小游戏则是统一的广告、支付等渠道，用起来也比较方便。所以独立开发者可以选择对自己较为有利的方案进行针对性开发和推广，比如选择微信小游戏，或者苹果端游戏，如果自己的开发成本不是特别充裕，这是一个相对稳妥的选择。</p><p>不管是独立游戏开发还是别的，我个人觉得现在的游戏一定要有这样几个特点：轻、快、多。</p><p>首先，游戏体量要够轻，够小，打开手机，打开电脑翻开一个网页就能玩，玩完就走。</p><p>其次，游戏体验要快速。一盘游戏不能时间太久，一局超过十分钟就会逐渐变成重度游戏，除非有很强的吸引力，否则时间太久的游戏大多数人都不愿意尝试。</p><p>游戏版本一定要不停迭代。从玩法、画面，到平衡性，这样才会让玩家保持新鲜感，不停地被游戏粘滞住。</p><h2>小结</h2><p>这节我和你聊了独立开发者的未来发展。</p><ul>\n<li>\n<p>DOS时代的时候，一个人或者一个小团队就可以做出一款游戏，但是这种时代已经过去了。游戏开发难度变小了，但是游戏制作难度变得越来越大了。</p>\n</li>\n<li>\n<p>尽管Steam依旧是目前最大的发布平台，但是由于它本身没有对上架的游戏进行分类、整理，有选择的展示。对独立开发者其实是不利的。加上Switch、XBOX等主机游戏相继都推出了自己的独立游戏计划，我其实更看好主机游戏的发展。</p>\n</li>\n<li>\n<p>其实不管基于什么平台，把游戏本身做好，才是最重要的。</p>\n</li>\n</ul><p>你想成为一个独立游戏开发者吗？你想做出一款什么样的游戏？</p><p>欢迎留言说出你的看法。我在下一节的挑战中等你！</p>",
        article_title: "第36讲 | 热点剖析（九）：谈谈独立开发者的未来发展",
      },
    ],
  },
  {
    chapterTitle: "加餐",
    children: [
      {
        title: "复习课 | 带你梳理客户端开发的三个重点",
        id: 10551,
        content:
          '<p>我们用了将近两个月的时间，讲述了游戏客户端的开发流程和代码编写，今天我来带你总结并且回顾一下。</p>\n<p>我这里列了一些编写游戏客户端<strong>你必须要掌握的知识和注意的事项</strong>。希望通过梳理这些知识，能让你对学过的内容有一个全盘的认识和更加深入的理解。</p>\n<h2>重点一：客户端开发中4个重要方法</h2>\n<p><strong>首先，我们来看，设置前后遮挡效果时要用到的一个虚拟概念，Z值。</strong> 2D游戏中其实是不存在这个概念的，因为Z值是高度概念，一般只存在于3D游戏当中。2D游戏的坐标轴，拥有X和Y两种位置。X轴是横向坐标，Y轴是纵向坐标。在斜45度角的游戏，或者需要经常改变前后遮挡位置游戏中，往往才需要加入这个概念。在2D开发中，用好了Z值，能够帮你计算2D游戏中图片的前后位置，在游戏中设置前后遮挡效果的时候就会更加方便。</p>\n<p><strong>其次，在2D游戏中制作碰撞检测的时候，可以使用图片相交检测的方法，来替代物理引擎</strong>。像打飞机游戏这样非常简单的2D游戏，是完全不需要使用物理引擎的，我们使用<strong>图片相交检测</strong>的方法，直接写对应的代码就可以。</p>\n<p><strong>什么时候才要使用物理引擎呢？这取决于你的代码量和程序编写的复杂程度。</strong></p>\n<p>如果碰撞代码非常复杂，占据整个工程量的1/5~1/4，那就可以直接使用物理引擎；如果仅仅用一两个函数就可以搞定，那就可以自己模拟物理碰撞效果来写相应的代码。毕竟2D游戏不比3D游戏，对“拟真”的要求没有那么高。而图片相交检测这样的方法易于编写，且效果也可以满足需求。当然，3D游戏中，往往需要高精度地模拟真实世界的碰撞，这个时候就直接使用物理引擎就好了。</p><!-- [[[read_end]]] -->\n<p><strong>再次，在游戏开发中，保持低耦合度，能够提高你的开发效率，减少你的工作量。</strong> 如果一款游戏引擎没有提供UI模块的话，那需要你编写一套UI模块或者UI库。所谓单独的UI模块，指的是仍然使用游戏引擎作为基础编写代码，但是却独立于游戏本身的逻辑之外，将之抽象出UI模块和UI库。如果UI模块直接融合在游戏里，虽然玩家看起来是一样的效果，但是在代码层面，耦合度却更高，可复用性和可修改性就变得更低，代码质量就更差。</p>\n<p>同样，在游戏开发中，很多模块都可以提取出来。比如鼠标和键盘的检测，单独提取出来做，变成相应的模块和库；很多的内容都可以进行抽象和独立，有了抽象和独立的模块，这样可以保证游戏版本的迭代不出现问题，你甚至可以拿这一套独立的抽象模块（比如UI模块、鼠标键盘模块等等），继续来做第二款游戏，因为里面很多代码都可以复用。</p>\n<p><strong>低耦合度，是游戏开发，甚至编程中都非常重要的思想</strong>。我这里推荐一本书<a href="https://book.douban.com/subject/1052241/">《设计模式》</a>。这里面对于耦合度的几种模式有详细的讲解。比如工厂模式、代理模式等等，但是不管用什么模式，<strong>低耦合度始终是编程中追求的一种代码方式</strong>。</p>\n<p>所谓低耦合度，简单理解，就是将功能抽象出来，并且写成一组函数或者类（我们简称为接口）。这些接口有传入传出的参数或者返回值，可以通过外界代码传给接口，接口通过计算，将计算后的结果返回给外部代码。这些接口和别的功能关联性不大，替换了接口，就仅仅替换了算法或者内部实现而已，但是核心功能是一样的。</p>\n<p><strong>最后，我想来说一下游戏逻辑。将游戏逻辑放在脚本语言里去写，迭代版本的时候可以不更新主程序，只更新脚本。</strong>（如果不放在脚本语言里，就直接写在硬代码里面。）我们在使用引擎和原生语言开发游戏的时候，只保持核心内容，其他游戏逻辑、游戏配置，特别是在游戏中可活动、可配置、可调节的部分，都提取出来，放到脚本语言里去编写。</p>\n<p>所谓的主程序，在Windows下就是EXE文件，一般情况下，更新EXE执行文件会导致一系列的更新，比如DLL动态链接库或者某些资源也会更新，所以更新资源包会变得很大。如果纯粹更新脚本文件，那就是几个脚本程序而已。当然这个也要看具体的需求，并不是说一定不更新主程序，如果有迫切需求更新主程序，也是必须要更新的。</p>\n<p>除此之外，关于客户端其他部分的流程和要注意的细节，我放在一起梳理一下。如果有哪些还不是很清楚，你可以回到对应的文章去复习一下。</p>\n<ul>\n<li>\n<p>首先，一款成熟的引擎会包含各种编辑器和工具。如果游戏引擎没有提供相应工具，你就必须根据要做的游戏项目，编写方便策划和美术使用的编辑器，包括地图编辑器、关卡编辑器、场景编辑器等等。</p>\n</li>\n<li>\n<p>游戏的网络部分，要尽量保持网络连接和数据传输的安全性，游戏的网络协议可以迭代更新，网络传输的内容和逻辑也可以放在游戏脚本里面去做。</p>\n</li>\n<li>\n<p>游戏的音乐部分，如果引擎不提供，建议使用成熟的音乐库。游戏要合理使用多线程技术，才能保证流畅性。游戏资源打包的包裹格式，如果没有现成的方案，可以使用压缩包的开发库编写，成熟稳定可靠。</p>\n</li>\n<li>\n<p>每个平台的游戏机制都不相同，比如在HTML5游戏里面，它使用的是事件机制，并非普通的循环。</p>\n</li>\n</ul>\n<h2>重点二：游戏开发的3大模块</h2>\n<p>这里我按照游戏开发中的三大模块策划、程序、美术，画了一个图。</p>\n<p><img src="https://static001.geekbang.org/resource/image/63/25/63c518012e92fb2dea46ffc58c1df125.jpg" alt="" /></p>\n<p>开发游戏的时候，策划要先行，先出策划稿、UI图、页面迁徙图等等，然后美术开始跟上，紧接着根据策划案开始制作UI、原画、人物、场景等等。程序员开始制作各种编辑器和周边工具（如果引擎没有提供的话），随后美术开始制作地图和各种关卡，程序员开始编写demo。随后就开始内部测试和运行，总结问题和经验，修正和补缺。最后，开始第一个正式版本的开发。正式版本的开发流程和demo版本是一样的，我在<a href="https://time.geekbang.org/column/article/8670">第5讲</a>的时候已经详细说过demo的作用。</p>\n<p>在专栏中，我用Pygame来做教学示例，有很多人在留言里问，我想用别的语言编写游戏难道不可以吗？当然是可以的，Pygame只是利用Python+SDL封装的游戏库，而我只是以Pygame为载体，告诉你编写2D游戏引擎的一些核心知识是怎样的。有了核心知识，了解了流程，语言层面就简单地多了。举一反三，换作任何语言、任何引擎都不会有问题了。</p>\n<p>在这之后，如果你想要进一步学习，或者从事相关的开发工作，你要自己多练习、多思考。如果是在公司里，那就多上手去做项目。游戏的开发流程就是这么回事，要做的东西也就那么多，但是不同的项目，不同种类的游戏，就会有不同的问题出现。每次遇到问题，<strong>多换几种思路去思考，多去了解策划、运营的想法</strong>，而不要只是在“不断填坑”。</p>\n<h2>重点三：如何写出过硬的代码？</h2>\n<p>其实，说了这么多，我现在要说我认为最重要的一点。 <strong>无论你是做游戏开发或者别的开发，你都要有过硬的代码基础。</strong> 一款游戏，有再好的引擎，再好的策划，如果代码写得不好，也会影响游戏体验，毕竟引擎只是在底层带动游戏的运行，在上层业务上，还是要依赖代码的牢靠和稳固。</p>\n<p>我从96年写下第一行代码开始，走过许多的弯路，也经历过许多挫折。<strong>在写代码方面，我或许可以带给你一些直接的经验和警示之谈</strong>。</p>\n<p>十几年前，当我刚还是个入门级程序员的时候，经历过一个项目，我负责做一个共享内存的接口。事实上写这个接口很简单，用不了多少代码就能完成，但当时我正在学习C++最新的Loki库（后来加入了Boost），觉得里面的模板技巧简直是无敌，所以我在共享内存接口之上又封装了类似Loki模板的方法，最终导致代码过于复杂，很难控制和管理，项目失败。</p>\n<p>因此，<strong>如果代码不是特别复杂，你大可以直接写功能，不需要从类、框架开始写起，因为这会造成我所犯的那个错误，就是“过度设计”</strong>。举个简单的例子，如果一个“hello word”，却有500行代码，这很明显就是“过度设计”。</p>\n<p>所以，我的多年的习惯是，<strong>如果一个正常的软件、游戏，或者模块、接口，我都会将普通的功能、重复性高的功能，抽象出来，做成一个模块，特殊的功能、无法重复的，再做成一个模块。代码尽可能不要长，长的代码分割成几部分，放在几个文件里，阅读起来也会很清晰。能写简洁的绝对不要花里胡哨，能用正常技巧的绝对不用小聪明，实在没办法才用小聪明。</strong></p>\n<p>对外提供接口要清晰、易于阅读，逻辑要一条一条理顺。有异常，就写异常处理代码；有错误，就处理错误代码；没有问题，再运行下一条。</p>\n<p>好记性不如烂笔头，写之前先想明白思路，将自己即将要写的代码在脑子里跑一遍，然后将思路记录下来，记在笔记本、电脑、手机哪里都可以。这样写出的代码比直接上手写，速度上会慢很多，但是出错概率极低。直接写你可能一下子就写完，但还要修修补补，调试一整天，事实上，这比思考虑好了再写还要慢。</p>\n<p>最后，还是那句话，不管是编写大型游戏还是一款小游戏，还是做任何项目，都离不开踏踏实实把代码写好。毕竟这是基础。如果你总想着什么多少天速成法，快速入门、快速编写出一款脍炙人口的游戏，用户上几百万，这是不存在的。游戏开发，应该说任何程序开发，都不适合任何想要走捷径的人。真正聪明的人，都应该知道学习本来也没有什么捷径。</p>\n<p>经过这两个月的学习，不知道你对游戏开发有没有更深入的认识？关于游戏开发或者编程，你还有什么想要了解的，你可以继续在留言区写下想法。</p>\n<p>我在后面的挑战中继续等待你的到来！</p>\n<p></p>\n',
        article_title: "复习课 | 带你梳理客户端开发的三个重点",
      },
      {
        title: "课后阅读 | 游戏开发工程师学习路径（上）",
        id: 13561,
        content:
          '<p>整个开发流程和内容我已经讲完了。你现在已经不是一个完全零基础的小白了。作为一个满心想要进入游戏开发行业的人，或者想要在游戏行业深耕，你可能要问了，后续的路，该怎么走呢？今天，我就来和你聊一聊这个内容。</p>\n<p>我会通过这份看似很长的必读书单，先给你搭建一个学习路径，然后从底层知识和游戏开发这两方面分别讲讲，想成为游戏开发工程师，应该掌握哪些知识。</p>\n<p>我在专栏里讲了很多具体的操作，作为初学者，把这些彻底掌握，其实已经差不多了。但是想要进阶，成为一名真正的游戏开发工程师，你还有很长的路要走。从业二十余年，我见过不少的年轻人，抱着对游戏的一腔热血，一头扎进游戏开发，想着自己有一天也能开发出一款爆款游戏，从此“走上人生巅峰”。</p>\n<p>然而走着走着，发现要学的东西太多，无从下手，直接放弃；或者学了之后，因为一直写不出什么项目，也放弃了。就好像去少林寺学武功的人，方丈让他先捆着沙包登山、挑水，他以为这并不是学武术，因此就放弃了。</p>\n<p>事实上游戏开发，甚至编程都是这样，你首先要学好基础知识，有了扎实的基础，才可能去做更多的事。道理我想你都懂，我就不多啰嗦啦。我们进入正题。</p>\n<p>还记得，在专栏最开始的时候，我专门写过<a href="https://time.geekbang.org/column/article/8104">游戏的分类</a>，按呈现效果，我们可以粗略分为2D游戏和3D游戏；按硬件，我们可以分为主机游戏、电脑游戏、移动游戏和电视机游戏。但是，如果从真正的开发角度，我会把游戏开发分为<strong>原生游戏开发</strong>和<strong>网页游戏开发</strong>。</p><!-- [[[read_end]]] -->\n<p>为什么这么分呢？首先，我这个分类中，并没有把网络服务器端的内容放进来，而只是针对游戏客户端部分。我将它分为原生客户端（PC、手机非HTML5原生App）和网页客户端（PC端页游、HTML5游戏、手机端HTML5游戏、微信小游戏）。</p>\n<p></p>\n<p>我们先从原生客户端讲起。</p>\n<p>在专栏里，我通过Pygame做了示例，但是碍于你可能不仅是个游戏开发新手，还可能是个编程新手，而我们专栏的侧重点在于帮你认识、了解游戏开发流程，知道游戏开发是怎么一回事，对于底层的知识，我其实没有过多的去介绍。</p>\n<p>我本身是写服务器端的，对于底层知识研究了很多，所以，我深知底层知识对于一个真正想要在游戏开发之路走得长远的人的重要性。学习的过程，我没有办法替你做，但是我想应该有那么一些经验还可以跟你讲一讲，不至于你在一些可以避免走弯路的地方，浪费掉许多时间。</p>\n<p>开发原生客户端游戏需要非常系统的底层知识。这里的底层知识指的是计算机（移动设备）的硬件底层知识，比如内存、CPU、图形显卡等等。当然如果要学得全面，你还可以学习物理引擎、音频等等。</p>\n<h2>想走捷径，去学C++吧！</h2>\n<p><strong>如果你的学习时间并不充裕，或者非常迫切地想知道“底层是什么，底层做了点什么”，想相对快速地能学习到底层知识，那么我推荐你直接学习C++。</strong></p>\n<p>首先从执行效率看，C++的执行效率仅次于汇编，约等于C。如果要编写更底层的操作系统，因为语法糖太多，你不知道编译器在背后做了什么事情，C++语言将无法“直接”掌控底层设备。所以要写操作系统，需要对C++编译器进行针对性改造。</p>\n<p>我们再往上看，如果要编写更上层的应用，比如桌面应用、动态网页应用，这些是C++经历过的“银弹”时代。90年代到2007年左右，几乎电脑上所有应用都有C++的身影，但是现在，桌面应用完全可以使用C#来编写。</p>\n<p>网页端就更不用说了，PHP、JavaScript、Python每一个都能比C++做得更快、更完美。但是在游戏开发中，既需要执行速度，相对地，又需要开发速度，综合下来，只有C++最适合。</p>\n<p>所以，学习C++，会让你对底层知识有了一个大致的了解，但是如果你没有更进阶地学习C或者汇编，那么你的知识面就停留在类、内存分配、对象等层面。</p>\n<p>作为二十多年的C++程序员，我这里有几个学习C++的心得想跟你分享。</p>\n<p>首先，C++和C语言并不是一门语言。它们之间的语法结构看起来虽然“相似”，但C++相对于C更像是瑞士军刀和匕首之间的关系。它们都有刀的功能，而C++除了刀的功能，还有更多的功能。</p>\n<p>其次，C++是做减法而非加法。把C++所有特性学完会耗费你极大的精力，注意是极大，不是大量。每一种特性背后都包裹着无数语法糖衣和编译器的“自动化”动作，使用C++的人当中，有一部分人经常会“走火入魔”，专门研究一些奇技淫巧的技巧。</p>\n<p>所以最好的方法是，<strong>不要执着于语言特性</strong>，因为两个不同的编译器，可能编译结果都会不同，比如一个会出错，一个会通过，但只要略作修改，就能运行。只要不影响具体最终软件的执行，就可以了。C++特性太多，选择一种或者两种特性来编写整个软件，才是发挥C++最大功效的方法。</p>\n<p>最后，大道至简，这对于整个产品、架构、编码，都是一句适用的箴言。当然对C++也是如此，只有用最简略的方法来编写代码，才会让代码快速成型。C++比C多了太多快速搭建的语法功能。尽量利用它的优点（比如面向对象、模板等等），就能发挥出语言最大的特长。</p>\n<h2>走这个路径，基础更扎实！</h2>\n<p>如果你有较宽裕的时间学习编程，也希望学习到更多的底层知识，对计算机有一个全面的掌握和了解，那么我推荐你用以下的这个更全面的路径来学习。</p>\n<p>以我的经验，我建议你先去学习一下C语言。为什么呢？因为C语言是汇编的封装，C语言的一句语句，可以是汇编的几条指令，虽然每个C编译器最终生成的汇编指令可能不同，但大致方向是一致的。</p>\n<p>其次，学习C语言能让你从基础的语言语法了解计算机编程是怎么回事。C语言是99.9%的电子设备的基础语言（剩下的0.01是汇编）。</p>\n<p>学习C语言有太多的入门书。在这里我推荐<a href="https://book.douban.com/subject/1240002/">《C Prime Plus》</a>，绝对的C语言入门经典教材。<a href="https://book.douban.com/subject/1139336/">《C Programming Language》</a>，读完 《C Prime Plus》之后再去读这本书，绝对会让你了解什么是高手所写的书。</p>\n<p>看完了《C Programming Language》之后，你除了是C程序员之外，俨然是一个不错的Linux用户了。</p>\n<p>学习完C语言后，你可以学习汇编语言。有了C语言的基础，对编程、地址操作、位操作这些基础，学习汇编就会相对容易。</p>\n<p>估计看到汇编语言这几个字，很多人就望而却步了。但是，我想说，<strong>没有比汇编更适合学习底层知识的语言了</strong>。</p>\n<p>毕竟在现实中，除非你编写的是芯片或者操作系统（现在编写芯片或者操作系统也大量使用C语言），只有占那1%的启动部分代码会使用汇编。这么看，使用汇编编程的人真的非常少，而且它本身也不适合编写大型项目。</p>\n<p>你可能要问了，为什么你还推荐我从汇编开始学呢？学习汇编的意义在哪里？</p>\n<p>我们先来看一段指令。</p>\n<pre><code> pushl %ebp\n\n movl %esp,%ebp\n\n subl $8,%esp\n</code></pre>\n<p>在汇编里，这些指令就代表着CPU的指令操作。在编写中级、高级语言，需要调试代码的时候，如果没有调试信息，最终都会落到汇编语言这里。这时候，汇编语言就是你的最后一道防线，学习了汇编，你就能快速、深入地定位程序的问题所在。</p>\n<p>所以，<strong>学习汇编的意义就是，你能在脑中完全掌握电脑的运行规律和运作逻辑</strong>，比如内存寻址操作、寄存器操作、加减操作、CPU指令等等。</p>\n<p>学习汇编有一本书，是绝对的入门级好书，能够把深奥枯燥的机器知识讲得生动活泼，那就是王爽的<a href="https://book.douban.com/subject/3037562/">《汇编语言》</a>。</p>\n<p>学习了汇编语言，也会对你的C语言知识有一个本质上的巩固。所以结合C和汇编，指针不再是头疼的问题，因为你已经知道在汇编中的地址是如何操作的。</p>\n<p>C语言看起来就好像把汇编进行了一次朴素的包装，你不再需要强制记忆寄存器和指令，定义一个变量就知道汇编语言是怎么做的，这对于你的C语言来说，是有绝对帮助意义的。</p>\n<p><strong>一般人提倡的学习路径是由浅入深，如果你想一直在技术领域深耕下去，我建议你走一条由难到易的学习路径。</strong></p>\n<p>因为，越高级的编程语言越接近人类的思维方式，这种思维会固化你的编程思维，让你在之后的学习过程中，无法更深层次地理解底层机器语言的沟通方式，学习起来就会比较困难。先学习底层知识，这样你在后续的高级语言的学习中，就属于“降维打击”，学习起来就相对轻松和快速。</p>\n<p>除此之外，如果你已经是一名程序员，你应该很能体会，你的工作将会越来越忙，几乎没有时间学习新的知识，而学习能力是一名程序员必备的基本能力。</p>\n<p>接下来，你还是需要学C++语言了。具体原因其实我刚才也说了，游戏引擎绝大部分使用C++编写，也有一小部分是使用C语言或者汇编编写的，比如Allegro。</p>\n<p>如果你要学习C++语言，学苑出版社出版的HerbertSchildt写的《C++从入门到精通》，这本书一定不能错过，它是我的C++启蒙书。唯一可惜的是，这本书年头有些久了，我的书还没有找到，但是我至今对书的内容都记忆犹新。这本书后面的小习题，绝对能让你在学完这本书之后，对C++了解的非常透彻和深刻。</p>\n<p>另外，<a href="https://book.douban.com/subject/1091086/">《深</a><a href="https://book.douban.com/subject/1091086/">度探索</a><a href="https://book.douban.com/subject/1091086/">C++对象模型》</a><a href="https://book.douban.com/subject/1099889/">《C++ Programming Language》</a><a href="https://book.douban.com/subject/1096216/">《C++语言的设计与演化》</a>也是必看书籍。前一本能让你了解C++对象模型，从底层了解C++的机制。后两本出自C++之父Bjarne Stroustrup之手。</p>\n<p>从C++开始设计到现在，为何会如此演化和设计，语言的背后又是怎样的故事，除了语言的基础知识，也会有一些小小的故事。另外，如果你的知识面和时间允许，我建议你最好去看《C++ Programming Language》的原版，因为只有原版是原汁原味，不会有被翻译偏差影响的。</p>\n<p>现在，我们已经将一幢大楼的“地基”都搭建好了。</p>\n<h2>学完这些，要多久啊？</h2>\n<p>你可能会问了，从开始学习底层知识，到对知识有了解并且能顺利写出软件需要多久呢？因人而异，有人是计算机系的，有人是野路子，有人对计算机特别有天赋，有人虽然不聪明但是非常勤奋，每个人的学习曲线和学习路径以及最终学会的时间都是不一样的。</p>\n<p>但是一般来说，要从C到汇编再到C++，一直到能编写成熟的代码，平均下来需要5～7年的时间。我没有做过精细地统计，但是我想，按照大学四年的学习时间，从学习到实践，再加上毕业1～3年的实践深入，5～7年的时间基本是差不多的。你觉得呢？</p>\n<p>今天这些内容主要涉及游戏开发的底层知识。说起来很容易，做起来却一点都不容易。有了这些基本功，下一节，我会推荐一些游戏原理和机制相关的书籍。希望我的分享对你有帮助。</p>\n<p></p>\n',
        article_title: "课后阅读 | 游戏开发工程师学习路径（上）",
      },
      {
        title: "课后阅读 | 游戏开发工程师学习路径（下）",
        id: 13701,
        content:
          '<p>上一节，我讲了一些底层知识和编程语言。搭好了底子，接下来，你需要掌握一些游戏的常规原理和机制。这里我也为你准备了一份学习书单。</p>\n<h2>游戏设计</h2>\n<p><a href="https://book.douban.com/subject/25859579/">《游戏机制》</a>，这是一本策划和程序员都可以看的书。在游戏设计中，游戏机制的设计，决定着游戏中的呈现效果，直接影响着玩家体验。而这本书就是教你如何打造出挑战丰富、乐趣十足、平衡良好的可玩性的游戏机制。它结合了很多实用案例，从不同角度介绍和阐述了游戏机制，介绍了用于构建和模拟游戏机制的Machinations工具。</p>\n<p><a href="https://book.douban.com/subject/26318335/">《游戏设计的100个原理》</a>做游戏开发的人，基本上自己都是非常喜欢游戏的，肯定玩过不少游戏。但是估计你对游戏设计背后的原理性的东西，了解的不会很多。这本书就是讲很多原理性的东西，让你从更专业的角度来看你以前玩过的游戏，毕竟游戏设计其实更像是一门哲学。</p>\n<p><a href="https://book.douban.com/subject/1230286/">《Windows游戏编程大师技巧》</a>，这是一本经典书籍，属于游戏开发启蒙教材，它涉及了开发的基础知识和理论、开发技巧这些问题。有一点点汇编、C/C++语言基础，看这些就不会觉得特别难了。</p>\n<h2>2D和3D编程</h2>\n<p>接下来，关于2D编程，我们可以看<a href="https://book.douban.com/subject/24733748/">《Cocos2dX游戏开发技术精解》</a>，这是一本让你一下子就能学习2D引擎且直接上手的书籍，几乎是学习2D游戏必备。</p><!-- [[[read_end]]] -->\n<p>《Unity 4.x 2D游戏开发基础教程》是一本利用Unity编写2D游戏的教程书籍。另外有一本非常难买到的书<a href="https://book.douban.com/subject/20116832/">《2D Graphics Programming for Games》</a>，目前只有英文版，如果你能找到电子书也可以阅读一下。</p>\n<p>毕竟3D游戏大行其道，但是它和2D游戏的路数又是非常不一样的。加上很多人上来就想做3D游戏，那关于3D开发，这几本书必看不可。</p>\n<p><a href="https://book.douban.com/subject/1321769/">《3D游戏编程大师技巧》</a><a href="https://book.douban.com/subject/25916788/">《Unity 3.x游戏开发实例》</a><a href="https://book.douban.com/subject/1488758/">《3D游戏开发大全》</a>。第一本书可以让你很轻松地就了解3D游戏的编程基础知识，第二、三本书都是属于利用引擎来编写实例的，你可以在这些例子中获取更多的实战经验。</p>\n<p>而《3D游戏开发大全》以Torque引擎来作为切入点，让你看到更多的技术。比如，游戏建模技术、人工智能技术、玩家控制技术等等游戏开发的细节。看完这三本书你就会对3D游戏编程有一个本质的了解。</p>\n<p>做为3D游戏开发，还要知道3D模型、贴图、骨骼等一些3D美术知识。从基础开始学起的话，我推荐<a href="https://book.douban.com/subject/2111771/">《DirectX 9.0 3D游戏开发编程基础》</a>。这本书介绍了一些必备的数学工具，涵盖了Direct 3D中几乎所有基本运算，以及如何使用Direct 3D来实现3D游戏。</p>\n<h2>网页游戏开发</h2>\n<p>原生游戏客户端开发的学习重点在编程语言上，所以，其实你学了什么编程语言，几乎可以决定你会从事什么样的开发工作。而网页游戏相对来说就简单得多。</p>\n<p>想要学习网页游戏制作，其实就是学习CSS3、HTML5以及JavaScript的知识。这方面的学习资料非常之多，网上一搜就能出来一大堆。其实你只要把每个方面专心学完一本书，把基本知识和核心知识搞懂了，结合一些项目实战有针对性的去练习就可以了，入门还是非常容易的。</p>\n<p>比如，看些大家都推荐的经典书籍<a href="https://book.douban.com/subject/20390374/">《响应式Web设计》</a><a href="https://book.douban.com/subject/10608238/">《HTML5程序设计》</a>等等。</p>\n<p>最初，你需要学习最基础的HTML语言语法。HTML5本身对初学者就非常友好。</p>\n<p><a href="https://book.douban.com/subject/3590768/">《JavaScript语言精粹》</a>也是必读的书籍。JavaScript语言的书籍非常非常多。这本书的内容就像它的书名，真是是精粹，从语法、函数、对象、数组、正则等等特性来介绍JavaScript语言的精髓，让你能真正掌握并高效地使用JavaScript，非常推荐。</p>\n<p>到这里，按照原生游戏开发和网页游戏开发的分类，我们的游戏学习路径和书籍介绍已经写得差不多了，在这里再向你介绍两本与游戏无关却与编程有关的书籍<a href="https://book.douban.com/subject/1052241/">《设计模式》</a><a href="https://book.douban.com/subject/1477390/">《代码大全》</a>。</p>\n<p>这两本书能让你编写代码的水平提升一个层次，提高编程水平是让自己的职业化道路越走越好的一条唯一途径。世上没有捷径，勤学苦练，多看多写才是根本。游戏开发的基础是编程基础，有了扎实的底子，往后走提升得才会比较快。</p>\n<p>一百多年前，福楼拜曾在一封信里写到：“谁要能熟读五六本书，就可成为大学问家了。”所以，我列的这些书，你能读完最好。但我知道，对大多数人来说，肯定是读不完的。你可以根据自己的情况做个筛选，有针对、有选择的去学习。</p>\n<p>如果你想从事H5游戏开发的，你可以着重学习HTML和CSS；如果想学习服务器端开发的话，可以着重学习Socket开发和TCP/IP相关的书籍；如果想学习客户端知识，比如3D客户端的话，可以注重学习Unity或者虚幻引擎为载体的书籍。</p>\n<p>希望今天的分享对你有帮助。</p>\n<p></p>\n',
        article_title: "课后阅读 | 游戏开发工程师学习路径（下）",
      },
    ],
  },
  {
    chapterTitle: "结束语",
    children: [
      {
        title: "结束语 | 做游戏的过程就像是在雕琢一件艺术品",
        id: 13883,
        content:
          '<p>我们用三个月的时间，一起创作了《从0开始学游戏开发》这个专栏。转眼间，到了说再见的时候，回想起来，只觉得时间过得真快。</p><p>说实话，这三个月我是“痛并快乐”着的，接下来就和你“诉诉苦”，也聊一聊我的收获和成长。</p><p>“苦”在哪里呢？坦白说，写专栏真是一件费时费力的事。每周三篇稿子，既要保证不断更，又要保证质量，而我平时的工作非常忙，几乎都是在夜晚赶稿。每次都是先构思，然后写代码、验证代码的正确性，才开始写文章，和编辑反反复复修改，还要再去录音。</p><p>录音又是一个“苦差”，夏天蝉鸣声非常大，为了找到一个安静的录音环境，我经常在地下车库录，一个人关在车里，一录就是个把小时，一会儿就汗流浃背。</p><p>但是，我把这件事坚持做下来了，因为这个过程中我也非常开心，成长了不少。</p><p>写专栏前，我刚写完一本书。写这本书用了我将近两年的时间，所以在一开始创作专栏的时候，我一直用写书的感觉来写专栏文章。我想的是以PC游戏为突破口，包含客户端和服务器端，按照完整的开发路径和开发顺序，讲解开发一款PC游戏最最基本的流程和细节。</p><p>但是，专栏开始后，我立刻就收到了很多反馈。我了解到很多同学的编码经验可能不是非常丰富，于是在后续的文章中，我做了一些调整。在写的过程中，我假想面对的是初入coding世界的自己，除了之前构思的内容，还对代码环境给出更详细的说明，对为什么要这么做，也写了更多我自己的思考和总结。</p><!-- [[[read_end]]] --><p>这是一个转变，从一开始不知道以什么姿势写专栏，到后期能够不断地梳理和提炼自己的想法和经验，不得不说，写专栏这件事，对我本身的改变是非常大的。</p><p>而给我带来这个转变的，是你的反馈。你的每一个留言我都会认真看，感谢这些留言，使我不断想起自己最初做开发的样子，想起那些激情澎湃的日子。</p><p>我在博客里写过一个系列的文章叫“代码十年”，记录了我十多年的代码生活。</p><p>那时我刚开始学C++，对这门语言非常感兴趣，每天都发愤看书，看完之后把习题抄下来，然后模拟，自己再写一份。那时候对编程的入迷程度，几乎可以用痴迷来形容。 那时我和一起工作的程序员，对一种算法几乎都可以研究半天。</p><p>后来，我开始自己创业，遇到的问题变得越来越多，也越来越复杂。这让我慢慢抛开编程本身，去思考更多的事情。</p><p>游戏开发是个复杂的过程，我们时时刻刻都需要学习、更新和积累知识，比如，编码基础知识、编程结构性知识，软件架构、业务架构知识，以及产品设计、市场、推广，乃至整个行业的动态信息。</p><p>现如今，十多年过去了，游戏这个行业依然风起云涌。虽然大公司几乎垄断了70%以上的游戏资源，但是每年依然有不少中小游戏公司借助小游戏、HTML5突出重围，而且独立开发者的未来更是可期。</p><p>我自己觉得，<strong>开发游戏就是在雕琢一件艺术品，从哪里下刀，怎么切入，怎么设计，人物的表情、仪态、动作如何，完全取决于手握刻刀的你。而现在你刻下的每一刀，都决定了这件艺术品以后的生命周期</strong>。</p><p>专栏虽然已经结束，但这对你我来说，还只是一个开始。我会继续在游戏行业深耕下去，并试着输出更多的内容。我希望，这对你来说，也是一个开始。毕竟这次我们只做了一个小游戏，在游戏世界里，只是戳开了一个小口子，我们还要朝着游戏开发世界的大门，不断前进。</p><p>路漫漫其修远兮，吾将上下而求索。希望我们可以一起努力，给游戏领域注入自己的力量。</p><p><a href="http://cn.mikecrm.com/WM3BaeU"><img src="https://static001.geekbang.org/resource/image/e4/ad/e43e1d08d65b9c3b3dc21e379afb91ad.jpg" alt=""></a></p>',
        article_title: "结束语 | 做游戏的过程就像是在雕琢一件艺术品",
      },
      {
        title: "结课测试｜“从0开始学游戏开发”100分试卷等你来挑战？",
        id: 248805,
        content:
          '<p>你好，我是蔡能。</p><p>到这里，《从0开始学游戏开发》这门课程已经全部结束了。我给你准备了一个结课小测试，来帮助你检验自己的学习效果。</p><p>这套测试题共有 20 道题目，包括16道单选题和4道多选题，满分 100 分，系统自动评分。</p><p>还等什么，点击下面按钮开始测试吧！</p><p><a href="http://time.geekbang.org/quiz/intro?act_id=187&exam_id=436"><img src="https://static001.geekbang.org/resource/image/28/a4/28d1be62669b4f3cc01c36466bf811a4.png?wh=1142*201" alt=""></a></p><!-- [[[read_end]]] -->',
        article_title: "结课测试｜“从0开始学游戏开发”100分试卷等你来挑战？",
      },
    ],
  },
];
