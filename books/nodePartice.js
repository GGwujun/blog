exports.category = "frontend";
exports.title = "nodejs应用开发实战";
exports.data = [
  {
    chapterTitle: "开篇词",
    children: [
      {
        content:
          '<p data-nodeid="769" class="">你好，欢迎来到 Node.js 课程，我是清弦。</p>\n<p data-nodeid="770">近 10 年来，我一直在一线大厂从事前端研发工作，负责前端、中台业务，以及跨端平台的研发和管理，曾经负责研发过亿级用户社交项目、千万级用户海外音视频应用平台等大型项目，同时我还自研了 Node.js 框架，为公司内部 10 多个系统项目提供支持。</p>\n<p data-nodeid="771">现在我和我的团队，不仅用 Node.js 来做前端的工程化（即将其作为辅助工具，利用 webpack 提升前端开发效率以及保证开发质量），还用来做一部分后端开发，来发挥 Node.js 更大的价值。</p>\n<p data-nodeid="772" class="te-preview-highlight">在 Node.js 的应用过程中，有些问题曾经一度困扰着我：</p>\n<ul data-nodeid="773">\n<li data-nodeid="774">\n<p data-nodeid="775">在前端，Node.js 难道只能做工程化应用吗？</p>\n</li>\n<li data-nodeid="776">\n<p data-nodeid="777">既然要学习后端开发，为什么我不学习其他应用更广的 Java 或者 Go？</p>\n</li>\n</ul>\n<h3 data-nodeid="778">前端为什么要选择 Node.js 来做后端开发？</h3>\n<p data-nodeid="779">作为一个前端工程师，掌握一门后端语言是很有必要的。</p>\n<p data-nodeid="780">在小公司，通常希望你“十八般武艺，样样都懂”，甚至要求你可以独立开发一个项目。当你掌握一门后端语言后，无论是独立开发还是在前端团队需要做部分后台服务的时候，你都可以主动承担这部分工作，从而在团队中凸显个人优势。</p>\n<p data-nodeid="781">在大公司，前后端虽然分工很明确，但是团队间的协作是常态，需要跟后端人员频繁地沟通，如果你不懂后端，不考虑后台，写出来的一些代码可能是无效的，在与后台进行数据交互的时候用不了。如果你掌握了一门后端语言，不仅可以和后端同事更好地交流合作，还可以提升自己的编程能力，使自己的前端开发更合理、更有效，甚至可以写 API 调试自己的前端代码。</p>\n<p data-nodeid="782">另外，<strong data-nodeid="845">技术栈是统一的，有时候可以前后互转，掌握一门后端语言，无可厚非可以使你的职业生涯更广阔一些</strong>。</p>\n<p data-nodeid="783">我相信每个程序员，都不会仅仅满足于当下，可能希望成为一个全栈工程师，再到技术负责人，最终能够在一家企业成为 CTO 或者实现更大的目标。而如果你仅仅掌握前端技术，那么无论如何是无法实现这些目标的。</p>\n<p data-nodeid="784">还有一方面就是从招聘信息可以得知，掌握一门后端语言，特别是 Node.js，已经成为一个加分项。在前端竞争如此激烈的今天，甚至可以说是一个必备技能。</p>\n<p data-nodeid="785"><img src="https://s0.lgstatic.com/i/image6/M01/12/F9/CioPOWBBqTKAW_1kAACq0w1s3oU424.png" alt="Drawing 0.png" data-nodeid="850"><br>\n<img src="https://s0.lgstatic.com/i/image6/M01/12/F9/CioPOWBBqTaAQhNtAAB4YN0SxUw334.png" alt="Drawing 1.png" data-nodeid="854"></p>\n<p data-nodeid="786"><strong data-nodeid="858">这时你肯定会问，我可以学习其他应用更广的 Java 或者 Go，为什么要学 Node.js 呢？</strong></p>\n<p data-nodeid="787">因为前端同学对 JavaScript 甚是了解，而 Node.js 是运行在服务端的 JavaScript。因此从 Node.js 去学习服务端研发技术，是最合适的选择。</p>\n<p data-nodeid="788">从自身经历来讲，我虽然也使用过其他后端语言，比如将 PHP 或者 C++ 作为服务端渲染以及后台服务，然而在这一过程中发现了一些问题。</p>\n<ul data-nodeid="789">\n<li data-nodeid="790">\n<p data-nodeid="791">PHP 处理高并发的能力比较一般，因为多进程非常损耗服务器资源；其次 PHP 作为服务端渲染在研发方面非常低效，前端代码需要融合 PHP 代码，而现在前端也淘汰了这类技术方案。</p>\n</li>\n<li data-nodeid="792">\n<p data-nodeid="793">C++ 作为后台服务性能虽高，但是在研发效率上是比较低的，要不断进行编译调试，根本无法跟上运营与项目需求的进度。</p>\n</li>\n</ul>\n<p data-nodeid="794"><strong data-nodeid="867">而基于我对 Node.js 的了解，它的一些优点，比如高并发特性以及研发高效能正好可以解决这些问题，所以最终还是回归到 Node.js</strong>。</p>\n<h3 data-nodeid="795">是什么阻碍了前端对于 Node.js 的进阶？</h3>\n<p data-nodeid="796">就目前来说，Node.js 应用较多的是前端工程化的部分，作为后台系统应用较少，而 Node.js 本就是后端的语言，如果只做工程化应用，会“大材小用”，没能应用到它的核心特性，没能真正发挥它的最大价值。</p>\n<p data-nodeid="797">特别是在应对一些高并发系统上，因为比较缺乏这方面的实践知识，在出现各类问题后缺少专业人才来解决这些核心问题，团队领导层方面往往基于这层考虑，并不会将 Node.js 应用在核心业务上。</p>\n<p data-nodeid="798">在一些实际场景中，有一部分前端人员也希望应用 Node.js 来做一些后端服务应用，但在应用过程中碰到了各种问题，并且苦于没有一些专业性的文章和指导方法，他们也就浅尝辄止了。</p>\n<p data-nodeid="799">前端在学习 Node.js 后端服务应用的过程中，存在很多技术层面的空缺，这些都阻碍了 Node.js 在工程化应用到后端服务应用的转变。</p>\n<p data-nodeid="800"><strong data-nodeid="878">1. 核心技术点的掌握不足</strong></p>\n<p data-nodeid="801">关于一些技术知识，我们一般会通过官网来进行学习，但是 Node.js 官网文档提供的是核心的 API ，并没有介绍在系统设计中的核心的技术点，特别是对于前端同学来说，<strong data-nodeid="884">官网的技术文档并不能满足 Node.js 应用开发的技术能力要求</strong>。</p>\n<p data-nodeid="802"><strong data-nodeid="890">2. 关注点及流程、方法的不同</strong></p>\n<p data-nodeid="803">由于前端工程化和后端服务开发在关注点和流程上的差异，前端同学在学习后端服务应用的过程中，思维还是停留在原来的层面，不能一下子转变。</p>\n<p data-nodeid="804">比如，作为后台服务的核心就是能够安全、稳定地提供服务，避免出现服务异常导致无法提供服务的问题。一旦出现这些问题，必然会影响大部分用户，恢复周期也比较长。而对于前端同学来说这点感知不深。</p>\n<p data-nodeid="805">对于任何一端而言，性能分析和优化都是非常重要的环节，但是对于不同端性能的要求以及性能分析的方法都不同，那么如何从前端性能分析转化到 Node.js 服务端性能分析，这就是非常重要的一个技术点。</p>\n<p data-nodeid="806">服务端研发的流程和方法与前端有着非常大的区别，前端主要基于 UI 和交互，而服务端则基于数据和数据流转。前端可以不绘制 UML 类图或者时序图，但是对于服务端研发流程来说是必需的。在这点上，前端更需要进行一些项目实践，重拾学过的知识点，才能掌握这部分技术能力的实际应用。</p>\n<h3 data-nodeid="807">课程设计</h3>\n<p data-nodeid="808">鉴于以上情况，我希望通过一个系统化的课程来帮你快速掌握 Node.js 的后端服务开发，真正地应用 Node.js 来实现核心的后台业务系统。也因此，我会遵循这样几个设计思路：</p>\n<ul data-nodeid="809">\n<li data-nodeid="810">\n<p data-nodeid="811"><strong data-nodeid="901">紧抓核心技术点</strong>：Node.js 基础知识在官网文档中比较详细，我不会赘述，而是针对性介绍服务端开发实践中重点关注的性能、安全和稳定性等方面的知识点及解决方案。当然，这也是 Node.js 相应岗位面试着重关注的点，希望能帮你积累一些面试经验。</p>\n</li>\n<li data-nodeid="812">\n<p data-nodeid="813"><strong data-nodeid="906">贴近项目应用场景</strong>：分别从系统的设计、研发到维护，进一步通过项目实践（通用的抢票系统和通用的投票系统），来强化你对 Node.js 服务端研发技术点和核心设计思想的掌握。</p>\n</li>\n</ul>\n<p data-nodeid="814">具体来讲，专栏分为<strong data-nodeid="912">核心知识点 + 技术应用分析 + 研发实战</strong>三大模块，合计 19 讲。</p>\n<ul data-nodeid="815">\n<li data-nodeid="816">\n<p data-nodeid="817"><strong data-nodeid="921">模块一</strong>，<strong data-nodeid="922">核心知识点篇</strong>：带你掌握 Node.js 服务端技术的核心知识，包括 Node.js 原理、 Node.js RESTful 服务实践、当前 3 大流行架构的对比、多进程方案、性能影响因素、CPU 过载保护方案、密集 I/O 设计思想，以及缓存的介绍和应用。</p>\n</li>\n<li data-nodeid="818">\n<p data-nodeid="819"><strong data-nodeid="931">模块二</strong>，<strong data-nodeid="932">技术应用分析篇</strong>：在模块一的基础上，讲解和实践 Node.js 服务中最关键的几个要素，系统稳定、内存安全、网络安全和性能分析的解决方法。其次，本模块最后还会介绍一个开源工具，告诉你如何应用该工具来实现服务上线前自动化的系统安全检查。</p>\n</li>\n<li data-nodeid="820">\n<p data-nodeid="821"><strong data-nodeid="941">模块三</strong>，<strong data-nodeid="942">系统研发实战篇</strong>：为了将本专栏的理论转化为实践，这部分则带你去实践开发一些 Node.js 服务端项目，进一步提升你对 Node.js 服务端技术的理解。本模块包含的实践项目有：RPC 服务实践、通用抢票系统、通用投票系统及当前最为流行的 Serverless。</p>\n</li>\n</ul>\n<h3 data-nodeid="822">讲师寄语</h3>\n<p data-nodeid="823">世界都在进步，为什么我在止步不前？</p>\n<p data-nodeid="824">虽然这句话说得有点大了，但是想想，科技与技术都在不断推陈出新，那么作为程序员的我们，更不该停滞不前，未来注定会对我们要求更高。安于现状，不如持续更新自身知识结构，每次选择便是一次机会。</p>\n<p data-nodeid="825">希望这门课，能够让你对 Node.js 的后端服务应用有一个全面的认识，从 Node.js 入门服务端研发，往全栈的方向更靠近一些，成为一名优秀的 Node.js 开发工程师。</p>\n<hr data-nodeid="826">\n<p data-nodeid="827"><a href="https://shenceyun.lagou.com/t/mka" data-nodeid="951"><img src="https://s0.lgstatic.com/i/image6/M00/12/FA/CioPOWBBrAKAAod-AASyC72ZqWw233.png" alt="Drawing 2.png" data-nodeid="950"></a></p>\n<p data-nodeid="828"><strong data-nodeid="955">《大前端高薪训练营》</strong></p>\n<p data-nodeid="829" class="">对标阿里 P7 技术需求 + 每月大厂内推，6 个月助你斩获名企高薪 Offer。<a href="https://shenceyun.lagou.com/t/mka" data-nodeid="959">点击链接</a>，快来领取！</p>',
        article_title: "开篇词 | Node.js 从工程化工具到后端服务应用的转变",
        title: "开篇词 | Node.js 从工程化工具到后端服务应用的转变",
        id: 6781,
      },
      {
        content:
          '<p data-nodeid="4591">在前端工程师眼里，工程化最重要的就是 Webpack 工具，而 Webpack 核心是基于 Node.js 来运行的，当然还有其他场景比如说 SSR 的实现以及前端的一些工具化场景。这些应用最终目标都是为了<strong data-nodeid="4692">提升前端研发效率</strong>或者<strong data-nodeid="4693">保证研发质量</strong>，其实并没有真正地应用到 Node.js 核心特点，而后端服务应用才是真正地应用 Node.js 异步事件驱动的特性，那么本讲就着重来介绍两者存在的差异，并指导你进行一些转型思考。</p>\n<p data-nodeid="4592">由于 Node.js 的编程语言就是 JavaScript，因此很多前端同学用起来也是非常顺手，但是顺手和熟练应用区别可太大了。这有段小插曲，有一次我看到一份非常好的简历，精通 React、熟练应用 Node.js，看到这种简历着实让我心情很愉悦，心想终于找到一个对口的人才了。当小伙进来面试后，我问了一个问题，我说：“你主要用 Node.js 做了哪些事情，这些应用中，你觉得哪些场景真正发挥出了 Node.js 的特性”。他最终没有通过我的面试，其主要原因是只用了 Node.js 做一些工具或者简单的服务端应用，并没有真实地了解 Node.js 的特点以及所适用的场景，因此谈不上熟练应用 Node.js。如果你想在简历中带上，熟练应用 Node.js，那你可以带着这些问题来学习下本讲的知识点。</p>\n<p data-nodeid="4593">本讲将会从表格 1 的这几个方面来讲解这两者之间的区别。</p>\n\n<p data-nodeid="5964" class=""><img src="https://s0.lgstatic.com/i/image6/M00/13/1D/CioPOWBB0TyASaasAABtZvrLaXk828.png" alt="image.png" data-nodeid="5967"></p>\n\n\n<h3 data-nodeid="4630">运行环境</h3>\n<ul data-nodeid="4631">\n<li data-nodeid="4632">\n<p data-nodeid="4633">工程化的大部分情况都是基于当前开发环境，运行在本地开发机器上。</p>\n</li>\n<li data-nodeid="4634">\n<p data-nodeid="4635">而后端服务应用一般运行在远程服务器上。</p>\n</li>\n</ul>\n<p data-nodeid="4636">为什么这两者的差异会导致我们理解或者编程方面的区别呢？</p>\n<p data-nodeid="4637">这就好比，你是老板，你需要两个人来帮你分别做一件事情，一个就在你旁边，一个需要出差去其他地方。</p>\n<p data-nodeid="4638">在你旁边的，可以关注到他的效率、进展、是否情绪有问题、是否可能会离职，甚至知道他到底为你做了什么贡献价值。</p>\n<p data-nodeid="4639">那出差的就没有这么清晰了，所以你需要有一些方法和工具来分析这些问题，因此需要知道出差的地方办公环境或者团队协助是怎么样的，是否能够符合该员工的办公要求；有人反馈员工有问题时，我们还需要远程取证，判断这个举报或者反馈是否真实存在；其次你需要使用一些目标和策略来考证出差的员工是否按照你既定目标在办公，他的工作状态和工作效率是否达到了要求，或者是否超出了你的预期范围等等。</p>\n<p data-nodeid="4640">讲了上面的这个例子以后，我们再回过头来思考，Node.js 的服务其实也是一样的：</p>\n<ul data-nodeid="4641">\n<li data-nodeid="4642">\n<p data-nodeid="4643">运行在本地的服务，你可以快速地判断定位、分析、解决问题；</p>\n</li>\n<li data-nodeid="4644">\n<p data-nodeid="4645">但是在远程的服务，你需要利用一些工具来分析判断或者监控其运行情况。</p>\n</li>\n</ul>\n<p data-nodeid="4646">那因为环境上的差异，会引发什么不同点呢：</p>\n<ul data-nodeid="4647">\n<li data-nodeid="4648">\n<p data-nodeid="4649">首先我们需要应用工具将服务发布到远程机器上，这里就涉及<strong data-nodeid="4748">devops 工具</strong>；</p>\n</li>\n<li data-nodeid="4650">\n<p data-nodeid="4651">我们需要保证远程服务的安全与稳定，这就涉及一些进程管理工具，例如我们<strong data-nodeid="4754">常见的 PM2</strong>；</p>\n</li>\n<li data-nodeid="4652">\n<p data-nodeid="4653">我们需要判断远程服务运行是否正常，这就涉及远程服务的<strong data-nodeid="4760">监控和告警机制</strong>；</p>\n</li>\n<li data-nodeid="4654">\n<p data-nodeid="4655">遇到运行问题时，我们需要通过远程日志来定位分析问题，这就涉及<strong data-nodeid="4770">日志打印</strong>和<strong data-nodeid="4771">跟踪染色</strong>。</p>\n</li>\n</ul>\n<h3 data-nodeid="4656">受众群体</h3>\n<ul data-nodeid="4657">\n<li data-nodeid="4658">\n<p data-nodeid="4659">前端工程化一般都是服务于开发者，比如我自己在本地应用 Webpack 打包或者将 ES6、ES7 转为 ES5 语法等，都是基于开发者工具，而这部分用户则是我们开发者自己。</p>\n</li>\n<li data-nodeid="4660">\n<p data-nodeid="4661">而后端服务应用则服务于真实的用户群体，为用户提供各种交互体验方面的数据处理等。</p>\n</li>\n</ul>\n<p data-nodeid="4662">因为两者的差异，工程化侧重于为开发者提升<strong data-nodeid="4784">研发效率</strong>或者<strong data-nodeid="4785">研发质量</strong>。</p>\n<p data-nodeid="4663">后端服务应用则必须关注服务的<strong data-nodeid="4803">稳定与安全</strong>。因为都是基于用户发送的内容，用户有时候发送一些非法或者违法的内容。其次需要关注<strong data-nodeid="4804">并发性能</strong>，因此必须充分考量服务器所能承载的最大用户并发数，在并发即将达到阈值时，又需要考量平行<strong data-nodeid="4805">扩容方案</strong>。还有就是为了用户体验，需要充分做好服务的<strong data-nodeid="4806">性能优化</strong>，做到极致的接口响应时间。</p>\n<h3 data-nodeid="4664">问题调试</h3>\n<ul data-nodeid="4665">\n<li data-nodeid="4666">\n<p data-nodeid="4667">因为前端工程化在本地运行，你可以随意地 console.log 打印日志进行调试，因为这些影响的也只是个人，或者说即使变成通用的工具，打印一些 console.log 也对工具的影响不大。</p>\n</li>\n<li data-nodeid="4668">\n<p data-nodeid="4669">但是在后端服务应用时，你就需要考虑一些方法来进行问题调试和定位策略了。</p>\n</li>\n</ul>\n<p data-nodeid="4670">你需要在每个业务场景中，思考在哪里进行一些关键逻辑或者数据打印日志信息，这里就需要 Node.js 日志服务模块，而这类日志服务又不能影响性能，因此需要考虑一些<strong data-nodeid="4827">高性能日志打印工具</strong>。其次在服务端运行，你可能会遇到诸如<strong data-nodeid="4828">内存泄漏</strong>、<strong data-nodeid="4829">句柄泄漏</strong>或者<strong data-nodeid="4830">进程异常退出</strong>等问题，因此这里就需要这类工具和方法来分析定位现网问题。</p>\n<h3 data-nodeid="4671">关注点</h3>\n<p data-nodeid="4672">经过上面的各种对比，最后这点已经非常明确了，即两者的关注点不同，从而导致了两者的差异性。这也是需要你在学习 Node.js 的时候进行一些<strong data-nodeid="4837">思维转变</strong>，切莫停留在前端工程化应用的角度去学习了，而应该全面地学习上面总结的知识点。只有上面的知识点掌握了，我们才能在简历上说，掌握 Node.js 的应用。</p>\n<p data-nodeid="4673">其次我们也来回答下上面的面试题，如果是我，我就会从本讲的两个方面去回答，一个是前端工程化的应用，另外一个是后端服务应用。前者着重于开发效率的提升和研发质量的保证，后者则是真正发挥出了 Node.js 的异步驱动特性。因为异步驱动特性，在主线程不被 CPU 密集型所影响时，可以真正发挥出 Node.js 高并发特性，可以作为大部分网络 I/O 较高的后端服务。</p>\n<h3 data-nodeid="4674">总结</h3>\n<p data-nodeid="4675">上面讨论的这些差异点，是我们本专栏所需要重点介绍的知识，也是你从 Node.js 前端工程化应用扩展到系统化应用，所必须要掌握的技能点。学完本讲后，希望你能够从思维中有所转变，认识差异重新出发。</p>\n<p data-nodeid="4676">那除了我提到的关于两者的差异点，你觉得它们还有什么差异呢，欢迎在评论区与我分享。</p>\n<p data-nodeid="4677">下一讲我们就正式进入专栏内容了，第 01 讲我将为你讲解 Node.js 中最基础也是最核心的部分：事件循环的原理。</p>\n<hr data-nodeid="4678">\n\n\n\n\n<p data-nodeid="4572"><a href="https://shenceyun.lagou.com/t/mka" data-nodeid="4580"><img src="https://s0.lgstatic.com/i/image6/M00/12/FA/CioPOWBBrAKAAod-AASyC72ZqWw233.png" alt="Drawing 2.png" data-nodeid="4579"></a></p>\n<p data-nodeid="4573"><strong data-nodeid="4584">《大前端高薪训练营》</strong></p>\n<p data-nodeid="4574" class="">对标阿里 P7 技术需求 + 每月大厂内推，6 个月助你斩获名企高薪 Offer。<a href="https://shenceyun.lagou.com/t/mka" data-nodeid="4588">点击链接</a>，快来领取！</p>',
        article_title: "课前导读 | Node.js 在前端工程化和后端服务应用的区别",
        title: "课前导读 | Node.js 在前端工程化和后端服务应用的区别",
        id: 6782,
      },
    ],
  },
  {
    chapterTitle: "模块一：核心知识点篇",
    children: [
      {
        content:
          '<p data-nodeid="1453" class="">在介绍 Node.js 的应用之前，我们先来讲解下 Node.js 中最基础也是最核心的部分：事件循环的原理。这一部分在面试过程中是必考的点，然而大家在网络上查找到的知识或多或少有些出入，会被误导。</p>\n<p data-nodeid="1814" class="te-preview-highlight">所以本讲就基于 Node.js 10+ 版本，为你讲解事件循环的原理，不过要注意这个<strong data-nodeid="1824">事件循环原理</strong>和<strong data-nodeid="1825">浏览器的原理</strong>是不同的，Node.js 10+ 版本后虽然在运行结果上与浏览器一致，但是两者在原理上一个是基于浏览器，一个是基于 libuv 库。浏览器核心的是宏任务和微任务，而在 Node.js 还有阶段性任务执行阶段。</p>\n\n<h3 data-nodeid="1455">Node.js 事件循环</h3>\n<p data-nodeid="1456"><strong data-nodeid="1625">事件循环通俗来说就是一个无限的 while 循环</strong>。现在假设你对这个 while 循环什么都不了解，你一定会有以下疑问。</p>\n<ol data-nodeid="1457">\n<li data-nodeid="1458">\n<p data-nodeid="1459">谁来启动这个循环过程，循环条件是什么？</p>\n</li>\n<li data-nodeid="1460">\n<p data-nodeid="1461">循环的是什么任务呢？</p>\n</li>\n<li data-nodeid="1462">\n<p data-nodeid="1463">循环的任务是否存在优先级概念？</p>\n</li>\n<li data-nodeid="1464">\n<p data-nodeid="1465">什么进程或者线程来执行这个循环？</p>\n</li>\n<li data-nodeid="1466">\n<p data-nodeid="1467">无限循环有没有终点？</p>\n</li>\n</ol>\n<p data-nodeid="1468">带着这些问题，我们先来看看 Node.js 官网提供的事件循环原理图。</p>\n<h4 data-nodeid="1469">Node.js 循环原理</h4>\n<p data-nodeid="1470">图 1 为 Node.js 官网的事件循环原理的核心流程图。</p>\n<p data-nodeid="1471"><img src="https://s0.lgstatic.com/i/image6/M00/13/1F/CioPOWBB0_iAYF-EAACboqFVHbQ092.png" alt="image (1).png" data-nodeid="1636"></p>\n<div data-nodeid="1472"><p style="text-align:center">图 1 事件循环原理流程图</p></div>\n<p data-nodeid="1473">可以看到，这一流程包含 6 个阶段，每个阶段代表的含义如下所示。</p>\n<p data-nodeid="1474">（1）<strong data-nodeid="1643">timers</strong>：本阶段执行已经被 setTimeout() 和 setInterval() 调度的回调函数，简单理解就是由这两个函数启动的回调函数。</p>\n<p data-nodeid="1475">（2）<strong data-nodeid="1649">pending callbacks</strong>：本阶段执行某些系统操作（如 TCP 错误类型）的回调函数。</p>\n<p data-nodeid="1476">（3）<strong data-nodeid="1655">idle、prepare</strong>：仅系统内部使用，你只需要知道有这 2 个阶段就可以。</p>\n<p data-nodeid="1477">（4）<strong data-nodeid="1661">poll</strong>：检索新的 I/O 事件，执行与 I/O 相关的回调，其他情况 Node.js 将在适当的时候在此阻塞。这也是最复杂的一个阶段，所有的事件循环以及回调处理都在这个阶段执行，接下来会详细分析这个过程。</p>\n<p data-nodeid="1478">（5）<strong data-nodeid="1667">check</strong>：setImmediate() 回调函数在这里执行，setImmediate 并不是立马执行，而是当事件循环 poll 中没有新的事件处理时就执行该部分，如下代码所示：</p>\n<pre class="lang-javascript" data-nodeid="1479"><code data-language="javascript"><span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">\'fs\'</span>);\nsetTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> { <span class="hljs-comment">// 新的事件循环的起点</span>\n    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">\'1\'</span>); \n}, <span class="hljs-number">0</span>);\nsetImmediate( <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {\n    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">\'setImmediate 1\'</span>);\n});\n<span class="hljs-comment">/// 将会在 poll 阶段执行</span>\nfs.readFile(<span class="hljs-string">\'./test.conf\'</span>, {<span class="hljs-attr">encoding</span>: <span class="hljs-string">\'utf-8\'</span>}, (err, data) =&gt; {\n    <span class="hljs-keyword">if</span> (err) <span class="hljs-keyword">throw</span> err;\n    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">\'read file success\'</span>);\n});\n<span class="hljs-comment">/// 该部分将会在首次事件循环中执行</span>\n<span class="hljs-built_in">Promise</span>.resolve().then(<span class="hljs-function"><span class="hljs-params">()</span>=&gt;</span>{\n    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">\'poll callback\'</span>);\n});\n<span class="hljs-comment">// 首次事件循环执行</span>\n<span class="hljs-built_in">console</span>.log(<span class="hljs-string">\'2\'</span>);\n</code></pre>\n<p data-nodeid="1480">在这一代码中有一个非常奇特的地方，就是 setImmediate 会在 setTimeout 之后输出。有以下几点原因：</p>\n<ul data-nodeid="1481">\n<li data-nodeid="1482">\n<p data-nodeid="1483">setTimeout 如果不设置时间或者设置时间为 0，则会默认为 1ms；</p>\n</li>\n<li data-nodeid="1484">\n<p data-nodeid="1485">主流程执行完成后，超过 1ms 时，会将 setTimeout 回调函数逻辑插入到待执行回调函数poll 队列中；</p>\n</li>\n<li data-nodeid="1486">\n<p data-nodeid="1487">由于当前 poll 队列中存在可执行回调函数，因此需要先执行完，待完全执行完成后，才会执行<strong data-nodeid="1676">check</strong>：setImmediate。</p>\n</li>\n</ul>\n<p data-nodeid="1488">因此这也验证了这句话，<strong data-nodeid="1682">先执行回调函数，再执行 setImmediate</strong>。</p>\n<p data-nodeid="1489">（6）<strong data-nodeid="1692">close callbacks</strong>：执行一些关闭的回调函数，如 socket.on(\'close\', ...)。</p>\n<p data-nodeid="1490">以上就是循环原理的 6 个过程，针对上面的点，我们再来解答上面提出的 5 个疑问。</p>\n<h4 data-nodeid="1491">运行起点</h4>\n<p data-nodeid="1492">从图 1 中我们可以看出事件循环的起点是 timers，如下代码所示：</p>\n<pre class="lang-javascript" data-nodeid="1493"><code data-language="javascript">setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {\n    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">\'1\'</span>);\n}, <span class="hljs-number">0</span>);\n<span class="hljs-built_in">console</span>.log(<span class="hljs-string">\'2\'</span>)\n</code></pre>\n<p data-nodeid="1494">在代码 setTimeout 中的回调函数就是新一轮事件循环的起点，看到这里有很多同学会提出非常合理的疑问：“为什么会先输出 2 然后输出 1，不是说 timer 的回调函数是运行起点吗？”</p>\n<p data-nodeid="1495">这里有一个非常关键点，当 Node.js 启动后，会初始化事件循环，处理已提供的输入脚本，它可能会先调用一些异步的 API、调度定时器，或者 process.nextTick()，然后再开始处理事件循环。因此可以这样理解，Node.js 进程启动后，就发起了一个新的事件循环，也就是事件循环的起点。</p>\n<p data-nodeid="1496">总结来说，Node.js 事件循环的发起点有 4 个：</p>\n<ul data-nodeid="1497">\n<li data-nodeid="1498">\n<p data-nodeid="1499">Node.js 启动后；</p>\n</li>\n<li data-nodeid="1500">\n<p data-nodeid="1501">setTimeout 回调函数；</p>\n</li>\n<li data-nodeid="1502">\n<p data-nodeid="1503">setInterval 回调函数；</p>\n</li>\n<li data-nodeid="1504">\n<p data-nodeid="1505">也可能是一次 I/O 后的回调函数。</p>\n</li>\n</ul>\n<p data-nodeid="1506">以上就解释了我们上面提到的第 1 个问题。</p>\n<h4 data-nodeid="1507">Node.js 事件循环</h4>\n<p data-nodeid="1508">在了解谁发起的事件循环后，我们再来回答第 2 个问题，即循环的是什么任务。在上面的核心流程中真正需要关注循环执行的就是 <strong data-nodeid="1714">poll 这个过程</strong>。在 poll 过程中，主要处理的是异步 I/O 的回调函数，以及其他几乎所有的回调函数，<strong data-nodeid="1715">异步 I/O 又分为网络 I/O 和文件 I/O</strong>。这是我们常见的代码逻辑部分的异步回调逻辑。</p>\n<p data-nodeid="1509">事件循环的主要包含微任务和宏任务。具体是怎么进行循环的呢？如图 2 所示。</p>\n<p data-nodeid="1510"><img src="https://s0.lgstatic.com/i/image6/M00/13/20/CioPOWBB1rCAM7NxAAFF-n4jMtY220.png" alt="image (2).png" data-nodeid="1719"></p>\n<div data-nodeid="1511"><p style="text-align:center">图 2 事件循环过程</p></div>\n<p data-nodeid="1512">在解释上图之前，我们先来解释下两个概念，微任务和宏任务。</p>\n<p data-nodeid="1513"><strong data-nodeid="1725">微任务</strong>：在 Node.js 中微任务包含 2 种——process.nextTick 和 Promise。微任务在事件循环中优先级是最高的，因此在同一个事件循环中有其他任务存在时，优先执行微任务队列。并且process.nextTick 和 Promise 也存在优先级，process.nextTick 高于 Promise。</p>\n<p data-nodeid="1514"><strong data-nodeid="1734">宏任务</strong>：在 Node.js 中宏任务包含 4 种——setTimeout、setInterval、setImmediate 和 I/O。宏任务在微任务执行之后执行，因此在同一个事件循环周期内，如果既存在微任务队列又存在宏任务队列，那么<strong data-nodeid="1735">优先将微任务队列清空，再执行宏任务队列</strong>。这也解释了我们前面提到的第 3 个问题，事件循环中的事件类型是存在优先级。</p>\n<p data-nodeid="1515">在图 2 的左侧，我们可以看到有一个核心的主线程，它的执行阶段主要处理三个核心逻辑。</p>\n<ul data-nodeid="1516">\n<li data-nodeid="1517">\n<p data-nodeid="1518">同步代码。</p>\n</li>\n<li data-nodeid="1519">\n<p data-nodeid="1520">将异步任务插入到微任务队列或者宏任务队列中。</p>\n</li>\n<li data-nodeid="1521">\n<p data-nodeid="1522">执行微任务或者宏任务的回调函数。在主线程处理回调函数的同时，也需要判断是否插入微任务和宏任务。根据优先级，先判断微任务队列是否存在任务，存在则先执行微任务，不存在则判断在宏任务队列是否有任务，有则执行。</p>\n</li>\n</ul>\n<p data-nodeid="1523">如果微任务和宏任务都只有一层时，那么看起来是比较简单的，比如下面的例子：</p>\n<pre class="lang-javascript" data-nodeid="1524"><code data-language="javascript"><span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">\'fs\'</span>);\n<span class="hljs-comment">// 首次事件循环执行</span>\n<span class="hljs-built_in">console</span>.log(<span class="hljs-string">\'start\'</span>);\n<span class="hljs-comment">/// 将会在新的事件循环中的阶段执行</span>\nfs.readFile(<span class="hljs-string">\'./test.conf\'</span>, {<span class="hljs-attr">encoding</span>: <span class="hljs-string">\'utf-8\'</span>}, (err, data) =&gt; {\n    <span class="hljs-keyword">if</span> (err) <span class="hljs-keyword">throw</span> err;\n    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">\'read file success\'</span>);\n});\nsetTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> { <span class="hljs-comment">// 新的事件循环的起点</span>\n    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">\'setTimeout\'</span>); \n}, <span class="hljs-number">0</span>);\n<span class="hljs-comment">/// 该部分将会在首次事件循环中执行</span>\n<span class="hljs-built_in">Promise</span>.resolve().then(<span class="hljs-function"><span class="hljs-params">()</span>=&gt;</span>{\n    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">\'Promise callback\'</span>);\n});\n<span class="hljs-comment">/// 执行 process.nextTick</span>\nprocess.nextTick(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {\n    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">\'nextTick callback\'</span>);\n});\n<span class="hljs-comment">// 首次事件循环执行</span>\n<span class="hljs-built_in">console</span>.log(<span class="hljs-string">\'end\'</span>);\n</code></pre>\n<p data-nodeid="1525">根据上面介绍的执行过程，我们来分析下上面代码的执行过程：</p>\n<ol data-nodeid="1526">\n<li data-nodeid="1527">\n<p data-nodeid="1528">第一个事件循环主线程发起，因此先执行同步代码，所以先输出 start，然后输出 end；</p>\n</li>\n<li data-nodeid="1529">\n<p data-nodeid="1530">再从上往下分析，遇到微任务，插入微任务队列，遇到宏任务，插入宏任务队列，分析完成后，微任务队列包含：Promise.resolve 和 process.nextTick，宏任务队列包含：fs.readFile 和 setTimeout；</p>\n</li>\n<li data-nodeid="1531">\n<p data-nodeid="1532">先执行微任务队列，但是根据优先级，先执行 process.nextTick 再执行 Promise.resolve，所以先输出 nextTick callback 再输出 Promise callback；</p>\n</li>\n<li data-nodeid="1533">\n<p data-nodeid="1534">再执行宏任务队列，根据宏任务插入先后顺序执行 setTimeout 再执行 fs.readFile，这里需要注意，先执行 setTimeout 由于其回调时间较短，因此回调也先执行，并非是 setTimeout 先执行所以才先执行回调函数，但是它执行需要时间肯定大于 1ms，所以虽然 fs.readFile 先于 setTimeout 执行，但是 setTimeout 执行更快，所以先输出 setTimeout ，最后输出 read file success。</p>\n</li>\n</ol>\n<p data-nodeid="1535">根据上面的分析，我们可以得到如下的执行结果：</p>\n<pre class="lang-java" data-nodeid="1536"><code data-language="java">start\nend\nnextTick callback\nPromise callback\nsetTimeout\nread file success\n</code></pre>\n<p data-nodeid="1537">但是当微任务和宏任务又产生新的微任务和宏任务时，又应该如何处理呢？如下代码所示：</p>\n<pre class="lang-javascript" data-nodeid="1538"><code data-language="javascript"><span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">\'fs\'</span>);\nsetTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> { <span class="hljs-comment">// 新的事件循环的起点</span>\n    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">\'1\'</span>); \n    fs.readFile(<span class="hljs-string">\'./config/test.conf\'</span>, {<span class="hljs-attr">encoding</span>: <span class="hljs-string">\'utf-8\'</span>}, (err, data) =&gt; {\n        <span class="hljs-keyword">if</span> (err) <span class="hljs-keyword">throw</span> err;\n        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">\'read file sync success\'</span>);\n    });\n}, <span class="hljs-number">0</span>);\n<span class="hljs-comment">/// 回调将会在新的事件循环之前</span>\nfs.readFile(<span class="hljs-string">\'./config/test.conf\'</span>, {<span class="hljs-attr">encoding</span>: <span class="hljs-string">\'utf-8\'</span>}, (err, data) =&gt; {\n    <span class="hljs-keyword">if</span> (err) <span class="hljs-keyword">throw</span> err;\n    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">\'read file success\'</span>);\n});\n<span class="hljs-comment">/// 该部分将会在首次事件循环中执行</span>\n<span class="hljs-built_in">Promise</span>.resolve().then(<span class="hljs-function"><span class="hljs-params">()</span>=&gt;</span>{\n    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">\'poll callback\'</span>);\n});\n<span class="hljs-comment">// 首次事件循环执行</span>\n<span class="hljs-built_in">console</span>.log(<span class="hljs-string">\'2\'</span>);\n</code></pre>\n<p data-nodeid="1539">在上面代码中，有 2 个宏任务和 1 个微任务，宏任务是 setTimeout 和 fs.readFile，微任务是 Promise.resolve。</p>\n<ol data-nodeid="1540">\n<li data-nodeid="1541">\n<p data-nodeid="1542">整个过程优先执行主线程的第一个事件循环过程，所以先执行同步逻辑，先输出 2。</p>\n</li>\n<li data-nodeid="1543">\n<p data-nodeid="1544">接下来执行微任务，输出 poll callback。</p>\n</li>\n<li data-nodeid="1545">\n<p data-nodeid="1546">再执行宏任务中的 fs.readFile 和 setTimeout，由于 fs.readFile 优先级高，先执行 fs.readFile。但是处理时间长于 1ms，因此会先执行 setTimeout 的回调函数，输出 1。这个阶段在执行过程中又会产生新的宏任务 fs.readFile，因此又将该 fs.readFile 插入宏任务队列。</p>\n</li>\n<li data-nodeid="1547">\n<p data-nodeid="1548">最后由于只剩下宏任务了 fs.readFile，因此执行该宏任务，并等待处理完成后的回调，输出 read file sync success。</p>\n</li>\n</ol>\n<p data-nodeid="1549">根据上面的分析，我们可以得出最后的执行结果，如下所示：</p>\n<pre class="lang-java" data-nodeid="1550"><code data-language="java"><span class="hljs-number">2</span>\npoll callback\n<span class="hljs-number">1</span>\nread file success\nread file sync success\n</code></pre>\n<p data-nodeid="1551">在上面的例子中，我们来思考一个问题，主线程是否会被阻塞，具体我们来看一个代码例子：</p>\n<pre class="lang-javascript" data-nodeid="1552"><code data-language="javascript"><span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">\'fs\'</span>);\nsetTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> { <span class="hljs-comment">// 新的事件循环的起点</span>\n    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">\'1\'</span>); \n    sleep(<span class="hljs-number">10000</span>)\n    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">\'sleep 10s\'</span>);\n}, <span class="hljs-number">0</span>);\n<span class="hljs-comment">/// 将会在 poll 阶段执行</span>\nfs.readFile(<span class="hljs-string">\'./test.conf\'</span>, {<span class="hljs-attr">encoding</span>: <span class="hljs-string">\'utf-8\'</span>}, (err, data) =&gt; {\n    <span class="hljs-keyword">if</span> (err) <span class="hljs-keyword">throw</span> err;\n    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">\'read file success\'</span>);\n});\n<span class="hljs-built_in">console</span>.log(<span class="hljs-string">\'2\'</span>);\n<span class="hljs-comment">/// 函数实现，参数 n 单位 毫秒 ；</span>\n<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sleep</span> (<span class="hljs-params"> n </span>) </span>{ \n    <span class="hljs-keyword">var</span> start = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>().getTime() ;\n    <span class="hljs-keyword">while</span> ( <span class="hljs-literal">true</span> ) {\n        <span class="hljs-keyword">if</span> ( <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>().getTime() - start &gt; n ) {\n            <span class="hljs-comment">// 使用  break  实现；</span>\n            <span class="hljs-keyword">break</span>;\n        }\n    }\n}\n</code></pre>\n<p data-nodeid="1553">我们在 setTimeout 中增加了一个阻塞逻辑，这个阻塞逻辑的现象是，只有等待当次事件循环结束后，才会执行 fs.readFile 回调函数。这里会发现 fs.readFile 其实已经处理完了，并且通知回调到了主线程，但是由于主线程在处理回调时被阻塞了，导致无法处理 fs.readFile 的回调。因此可以得出一个结论，主线程会因为回调函数的执行而被阻塞，这也符合图 2 中的执行流程图。</p>\n<p data-nodeid="1554">如果把上面代码中 setTimeout 的时间修改为 10 ms，你将会优先看到 fs.readFile 的回调函数，因为 fs.readFile 执行完成了，并且还未启动下一个事件循环，修改的代码如下：</p>\n<pre class="lang-javascript" data-nodeid="1555"><code data-language="javascript">setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> { <span class="hljs-comment">// 新的事件循环的起点</span>\n    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">\'1\'</span>); \n    sleep(<span class="hljs-number">10000</span>)\n    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">\'sleep 10s\'</span>);\n}, <span class="hljs-number">10</span>);\n</code></pre>\n<p data-nodeid="1556">最后我们再来回答第 5 个问题，当所有的微任务和宏任务都清空的时候，虽然当前没有任务可执行了，但是也并不能代表循环结束了。因为可能存在当前还未回调的异步 I/O，所以这个循环是没有终点的，只要进程在，并且有新的任务存在，就会去执行。</p>\n<h3 data-nodeid="1557">实践分析</h3>\n<p data-nodeid="1558">了解了整个原理流程，我们再来实践验证下 Node.js 的事件驱动，以及 I/O 到底有什么效果和为什么能提高并发处理能力。我们的实验分别从同步和异步的代码性能分析对比，从而得出两者的差异。</p>\n<p data-nodeid="1559"><strong data-nodeid="1764">Node.js 不善于处理 CPU 密集型的业务</strong>，就会导致性能问题，如果要实现一个耗时 CPU 的计算逻辑，处理方法有 2 种：</p>\n<ul data-nodeid="1560">\n<li data-nodeid="1561">\n<p data-nodeid="1562">直接在主业务流程中处理；</p>\n</li>\n<li data-nodeid="1563">\n<p data-nodeid="1564">通过网络异步 I/O 给其他进程处理。</p>\n</li>\n</ul>\n<p data-nodeid="1565">接下来，我们用 2 种方法分别计算从 0 到 1000000000 之间的和，然后对比下各自的效果。</p>\n<h4 data-nodeid="1566">主流程执行</h4>\n<p data-nodeid="1567">为了效果，我们把两部分计算分开，这样能更好地形成对比，没有异步驱动计算的话，只能同步的去执行两个函数 startCount 和 nextCount，然后将两部分计算结果相加。</p>\n<pre class="lang-javascript" data-nodeid="1568"><code data-language="javascript"><span class="hljs-keyword">const</span> http = <span class="hljs-built_in">require</span>(<span class="hljs-string">\'http\'</span>);\n<span class="hljs-comment">/**\n * \n * 创建 http 服务，简单返回\n */</span>\n<span class="hljs-keyword">const</span> server = http.createServer(<span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> {\n    res.write(<span class="hljs-string">`<span class="hljs-subst">${startCount() + nextCount()}</span>`</span>);\n    res.end();\n});\n<span class="hljs-comment">/**\n * 从 0 计算到 500000000 的和\n */</span>\n<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">startCount</span>(<span class="hljs-params"></span>) </span>{\n    <span class="hljs-keyword">let</span> sum = <span class="hljs-number">0</span>;\n    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">500000000</span>; i++){\n        sum = sum + i;\n    }\n    <span class="hljs-keyword">return</span> sum;\n}\n<span class="hljs-comment">/**\n * 从 500000000 计算到 1000000000 之间的和\n */</span>\n<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">nextCount</span>(<span class="hljs-params"></span>) </span>{\n    <span class="hljs-keyword">let</span> sum = <span class="hljs-number">0</span>;\n    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i=<span class="hljs-number">500000000</span>; i&lt;<span class="hljs-number">1000000000</span>; i++){\n        sum = sum + i;\n    }\n    <span class="hljs-keyword">return</span> sum;\n}\n<span class="hljs-comment">/**\n * \n * 启动服务\n */</span>\nserver.listen(<span class="hljs-number">4000</span>, () =&gt; {\n    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">\'server start http://127.0.0.1:4000\'</span>);\n});\n</code></pre>\n<p data-nodeid="1569">接下来使用下面命令启动该服务：</p>\n<pre class="lang-java" data-nodeid="1570"><code data-language="java">node sync.js\n</code></pre>\n<p data-nodeid="1571">启动成功后，再在另外一个命令行窗口执行如下命令，查看响应时间，运行命令如下：</p>\n<pre class="lang-java" data-nodeid="1572"><code data-language="java">time curl http:<span class="hljs-comment">//127.0.0.1:4000</span>\n</code></pre>\n<p data-nodeid="1573">运行完成以后可以看到如下的结果：</p>\n<pre class="lang-java" data-nodeid="1574"><code data-language="java"><span class="hljs-number">499999999075959400</span>\nreal&nbsp; &nbsp; <span class="hljs-number">0</span>m1<span class="hljs-number">.100</span>s\nuser&nbsp; &nbsp; <span class="hljs-number">0</span>m0<span class="hljs-number">.004</span>s\nsys&nbsp; &nbsp; &nbsp;<span class="hljs-number">0</span>m0<span class="hljs-number">.005</span>s\n</code></pre>\n<p data-nodeid="1575">启动第一行是计算结果，第二行是执行时长。经过多次运行，其结果基本相近，都在 1.1s 左右。接下来我们利用 Node.js 异步事件循环的方式来优化这部分计算方式。</p>\n<h4 data-nodeid="1576">异步网络 I/O</h4>\n<p data-nodeid="1577">异步网络 I/O 对比主流程执行，优化的思想是将上面的两个计算函数 startCount 和 nextCount 分别交给其他两个进程来处理，然后主进程应用异步网络 I/O 的方式来调用执行。</p>\n<p data-nodeid="1578">我们先看下主流程逻辑，如下代码所示：</p>\n<pre class="lang-javascript" data-nodeid="1579"><code data-language="javascript"><span class="hljs-keyword">const</span> http = <span class="hljs-built_in">require</span>(<span class="hljs-string">\'http\'</span>);\n<span class="hljs-keyword">const</span> rp = <span class="hljs-built_in">require</span>(<span class="hljs-string">\'request-promise\'</span>);\n<span class="hljs-comment">/**\n * \n * 创建 http 服务，简单返回\n */</span>\n<span class="hljs-keyword">const</span> server = http.createServer(<span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> {\n    <span class="hljs-built_in">Promise</span>.all([startCount(), nextCount()]).then(<span class="hljs-function">(<span class="hljs-params">values</span>) =&gt;</span> {\n        <span class="hljs-keyword">let</span> sum = values.reduce(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">prev, curr, idx, arr</span>)</span>{\n            <span class="hljs-keyword">return</span> <span class="hljs-built_in">parseInt</span>(prev) + <span class="hljs-built_in">parseInt</span>(curr);\n        })\n        res.write(<span class="hljs-string">`<span class="hljs-subst">${sum}</span>`</span>);\n        res.end(); \n    })\n});\n<span class="hljs-comment">/**\n * 从 0 计算到 500000000 的和\n */</span>\n<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">startCount</span>(<span class="hljs-params"></span>) </span>{\n    <span class="hljs-keyword">return</span> <span class="hljs-keyword">await</span> rp.get(<span class="hljs-string">\'http://127.0.0.1:5000\'</span>);\n}\n<span class="hljs-comment">/**\n * 从 500000000 计算到 1000000000 之间的和\n */</span>\n<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">nextCount</span>(<span class="hljs-params"></span>) </span>{\n    <span class="hljs-keyword">return</span> <span class="hljs-keyword">await</span> rp.get(<span class="hljs-string">\'http://127.0.0.1:6000\'</span>);\n}\n<span class="hljs-comment">/**\n * \n * 启动服务\n */</span>\nserver.listen(<span class="hljs-number">4000</span>, () =&gt; {\n    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">\'server start http://127.0.0.1:4000\'</span>);\n});\n</code></pre>\n<p data-nodeid="1580">代码中使用到了 Promise.all 来异步执行两个函数 startCount 和 nextCount，待 2 个异步执行结果返回后再计算求和。其中两个函数 startCount 和 nextCount 中的 rp.get 地址分别是：</p>\n<pre class="lang-java" data-nodeid="1581"><code data-language="java">http:<span class="hljs-comment">//127.0.0.1:5000</span>\nhttp:<span class="hljs-comment">//127.0.0.1:6000</span>\n</code></pre>\n<p data-nodeid="1582">其实是两个新的进程分别计算两个求和的逻辑，具体以 5000 端口的逻辑为例看下，代码如下：</p>\n<pre class="lang-javascript" data-nodeid="1583"><code data-language="javascript"><span class="hljs-keyword">const</span> http = <span class="hljs-built_in">require</span>(<span class="hljs-string">\'http\'</span>);\n<span class="hljs-comment">/**\n * \n * 创建 http 服务，简单返回\n */</span>\n<span class="hljs-keyword">const</span> server = http.createServer(<span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> {\n    <span class="hljs-keyword">let</span> sum = <span class="hljs-number">0</span>;\n    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">500000000</span>; i++){\n        sum = sum + i;\n    }\n    res.write(<span class="hljs-string">`<span class="hljs-subst">${sum}</span>`</span>);\n    res.end();\n});\n<span class="hljs-comment">/**\n * \n * 启动服务\n */</span>\nserver.listen(<span class="hljs-number">5000</span>, () =&gt; {\n    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">\'server start http://127.0.0.1:5000\'</span>);\n});\n</code></pre>\n<p data-nodeid="1584">接下来我们分别打开三个命令行窗口，使用以下命令分别启动三个服务：</p>\n<pre class="lang-java" data-nodeid="1585"><code data-language="java">node startServer.js\nnode nextServer.js&nbsp;\nnode async.js\n</code></pre>\n<p data-nodeid="1586">启动成功后，再运行如下命令，查看执行时间：</p>\n<pre class="lang-java" data-nodeid="1587"><code data-language="java">time curl http:<span class="hljs-comment">//127.0.0.1:4000</span>\n</code></pre>\n<p data-nodeid="1588">运行成功后，你可以看到如下结果：</p>\n<pre class="lang-java" data-nodeid="1589"><code data-language="java"><span class="hljs-number">499999999075959400</span>\nreal&nbsp; &nbsp; <span class="hljs-number">0</span>m0<span class="hljs-number">.575</span>s\nuser&nbsp; &nbsp; <span class="hljs-number">0</span>m0<span class="hljs-number">.004</span>s\nsys&nbsp; &nbsp; &nbsp;<span class="hljs-number">0</span>m0<span class="hljs-number">.005</span>s\n</code></pre>\n<p data-nodeid="1590">结果还是一致的，但是运行时间缩减了一半，大大地提升了执行效率。</p>\n<h4 data-nodeid="1591">响应分析</h4>\n<p data-nodeid="1592">两个服务的执行时间相差一半，因为异步网络 I/O 充分利用了 Node.js 的异步事件驱动能力，将耗时 CPU 计算逻辑给到其他进程来处理，而无须等待耗时 CPU 计算，可以直接处理其他请求或者其他部分逻辑。第一种同步执行的方式就无法去处理其逻辑，导致性能受到影响。</p>\n<p data-nodeid="1593">如果使用压测还可以使对比效果更加明显，我将在第 12 讲为你详细介绍关于压测使用以及分析过程。</p>\n<h3 data-nodeid="1594">单线程/多线程</h3>\n<p data-nodeid="1595">我相信在面试过程中，面试官经常会问这个问题“Node.js 是单线程的还是多线程的”。</p>\n<p data-nodeid="1596">学完上面的内容后，你就可以回答了。</p>\n<blockquote data-nodeid="1597">\n<p data-nodeid="1598">主线程是单线程执行的，但是 Node.js 存在多线程执行，多线程包括 setTimeout 和异步 I/O 事件。其实 Node.js 还存在其他的线程，包括垃圾回收、内存优化等。</p>\n</blockquote>\n<p data-nodeid="1599">这里也可以解释我们前面提到的第 4 个问题，<strong data-nodeid="1795">主要还是主线程来循环遍历当前事件</strong>。</p>\n<h3 data-nodeid="1600">总结</h3>\n<p data-nodeid="1601">本讲主要介绍了 Node.js 事件循环机制和原理，然后通过实践对比了两种情况下的性能耗时，并且说明了异步事件循环驱动的好处。学完本讲以后，你就可以掌握 Node.js 的事件循环原理，也可以掌握如何充分利用 Node.js 的事件循环原理的优势。</p>\n<p data-nodeid="1602">你可以自行思考下这个问题：浏览器的事件循环原理和 Node.js 事件循环原理的区别以及联系有哪些点，欢迎你把答案写在评论区。</p>\n<p data-nodeid="1603">本讲就到这了，下一讲我会为你介绍服务端研发的 RPC 服务的知识点。</p>\n<hr data-nodeid="1604">\n<p data-nodeid="1605"><a href="https://shenceyun.lagou.com/t/mka" data-nodeid="1804"><img src="https://s0.lgstatic.com/i/image6/M00/12/FA/CioPOWBBrAKAAod-AASyC72ZqWw233.png" alt="Drawing 2.png" data-nodeid="1803"></a></p>\n<p data-nodeid="1606"><strong data-nodeid="1808">《大前端高薪训练营》</strong></p>\n<p data-nodeid="1607" class="">对标阿里 P7 技术需求 + 每月大厂内推，6 个月助你斩获名企高薪 Offer。<a href="https://shenceyun.lagou.com/t/mka" data-nodeid="1812">点击链接</a>，快来领取！</p>',
        article_title: "01 | 事件循环：高性能到底是如何做到的？",
        title: "01 | 事件循环：高性能到底是如何做到的？",
        id: 6783,
      },
      {
        content:
          '<p data-nodeid="18522" class="">目前 Node.js 最常被用作前端工程化，导致大家误解为 Node.js 只适合作前端工程化工具，而忽视了其作为后端服务的特性。导致很少在后端研发中考虑使用 Node.js，认为没有任何优势，比如适用场景较少、性能较差等。为了消除这种误解，本讲将介绍 Node.js 的特性，以及适合哪些后端应用场景。</p>\n<h3 data-nodeid="18523">服务分类</h3>\n<p data-nodeid="18524">我们常听说的服务有 RESTful 和 RPC，但这都是架构设计规范。我们也可以从另外一个角度来分析后台服务，如图 1 所示。</p>\n<p data-nodeid="18525"><img src="https://s0.lgstatic.com/i/image6/M01/13/29/Cgp9HWBB2I2ALxWGAAC4luceI5c251.png" alt="Drawing 0.png" data-nodeid="18617"></p>\n<div data-nodeid="18526"><p style="text-align:center">图1 后台服务分类</p></div>\n<p data-nodeid="18527">以上分类并不能代表所有的服务，但是各个系统都或多或少包含这些服务。有些大型系统可能会比这复杂；有些小型系统可能没有这么多模块系统。</p>\n<p data-nodeid="18528">下面我们看下每个模块主要的工作是什么：</p>\n<ul data-nodeid="18529">\n<li data-nodeid="18530">\n<p data-nodeid="18531"><strong data-nodeid="18624">网关</strong>，处理请求转发和一些通用的逻辑，例如我们常见的 Nginx；</p>\n</li>\n<li data-nodeid="18532">\n<p data-nodeid="18533"><strong data-nodeid="18629">业务网关</strong>，处理业务相关的逻辑，比如一些通用的协议转化、通用的鉴权处理，以及其他统一的业务安全处理等；</p>\n</li>\n<li data-nodeid="18534">\n<p data-nodeid="18535"><strong data-nodeid="18634">运营系统</strong>，负责我们日常的运营活动或者运营系统；</p>\n</li>\n<li data-nodeid="18536">\n<p data-nodeid="18537"><strong data-nodeid="18639">业务系统</strong>，负责我们核心的业务功能的系统；</p>\n</li>\n<li data-nodeid="18538">\n<p data-nodeid="18539"><strong data-nodeid="18644">中台服务</strong>，负责一些通用 App 类的服务，比如配置下发、消息系统及用户反馈系统等；</p>\n</li>\n<li data-nodeid="18540">\n<p data-nodeid="18541"><strong data-nodeid="18649">各类基础层</strong>，这些就是比较单一的核心后台服务，例如用户模块，这就需要根据不同业务设计不同的核心底层服务；</p>\n</li>\n<li data-nodeid="18542">\n<p data-nodeid="18543">左侧的<strong data-nodeid="18655">数据缓存和数据存储</strong>，则是相应的数据类的服务。</p>\n</li>\n</ul>\n<p data-nodeid="18544">在这些分层中，我们需要寻找网络 I/O 较多，但是 CPU 计算较少、业务复杂度高的服务，基于这点我们可以分析出 Node.js 应用在业务网关、中台服务及运营系统几个方面。接下来我们就分别从系统的业务场景及系统特性来分析为什么 Node.js 更合适。</p>\n<h3 data-nodeid="18545">业务网关</h3>\n<p data-nodeid="18546">我们都了解 Nginx 作为负载均衡转发层，负责负载分发，那么业务网关又是什么呢？</p>\n<p data-nodeid="18547">可以这样考虑，比如我们后台管理系统有鉴权模块，以往都是在管理后台服务中增加一个鉴权的类，然后在统一路由处增加鉴权判断。而现在不仅仅是这个管理系统需要使用这个鉴权类，多个管理系统都需要这个鉴权类，这时你会考虑复制这个类到其他项目，又或者设计一个专门的服务来做鉴权，图 2 是一个转变的过程效果图。</p>\n<p data-nodeid="18548"><img src="https://s0.lgstatic.com/i/image6/M00/13/2A/CioPOWBB3lmASJg-AAHV0vpcYas739.png" alt="Drawing 1.png" data-nodeid="18662"></p>\n<div data-nodeid="18549"><p style="text-align:center">图 2 业务网关的作用对比效果图</p></div>\n<p data-nodeid="18550">从上图我们可以看到，其实每个项目的鉴权都是相似的，没有必要在每个项目中维护一份通用的鉴权服务。因此可以提炼一层叫作业务网关，专门处理业务相关的通用逻辑，包括鉴权模块。</p>\n<p data-nodeid="18551">接下来我们就从一个实际的例子 OPEN API 的业务网关来介绍下这类服务场景。</p>\n<h4 data-nodeid="18552">业务场景</h4>\n<p data-nodeid="18553">OPEN API 一般会有一个统一的 token 鉴权，通过 token 鉴权后还需要判断第三方的 appid 是否有接口权限，其次判断接口是否到达了请求频率上限。为了服务安全，我们也可以做一些降级处理，在服务过载时，可以根据优先级抛弃一些请求，具体可以查看图 3。</p>\n<p data-nodeid="18554"><img src="https://s0.lgstatic.com/i/image6/M00/13/2A/CioPOWBB3nOAWYquAABKfQ7r_hc648.png" alt="Drawing 3.png" data-nodeid="18669"></p>\n<p data-nodeid="18555">接下来我们从技术层面来看为什么 Node.js 更适合此类应用场景。</p>\n<h4 data-nodeid="18556">服务特性</h4>\n<p data-nodeid="18557">根据图 2 的场景应用，我们专注看下 Nginx 后面的业务网关处理层，它的业务场景如图 4 所示。</p>\n<p data-nodeid="18558"><img src="https://s0.lgstatic.com/i/image6/M00/13/2D/Cgp9HWBB3nyAcYKlAABG_EYz4Lo055.png" alt="Drawing 5.png" data-nodeid="18675"></p>\n<p data-nodeid="18559">这 3 个功能都是基于缓存来处理业务逻辑的，大部分都是网络 I/O ，并未涉及 CPU 密集型逻辑，这也是 Node.js 的优势，其次异步驱动的方案能够处理更高的并发。根据第 01 讲的内容，Node.js 的代码核心是不阻塞主线程处理，而这类业务网关都是轻 CPU 运算服务。因此在这类场景的技术选型中，可以考虑使用 Node.js 作为服务端语言。</p>\n<h3 data-nodeid="18560">中台服务</h3>\n<p data-nodeid="18561">在 Web 或者 App 应用中都存在一些<strong data-nodeid="18683">通用服务</strong>，以往都是独立接口、独立开发。随着公司应用越来越多，需要将一些通用的业务服务进行集中，这也是中台的概念。而这部分业务场景往往也是网络 I/O 高、并发较大、业务关联性高、数据库读写压力相对较小。下面我们就来分析下这种业务场景。</p>\n<h4 data-nodeid="18562">业务场景</h4>\n<p data-nodeid="18563">为了避免资源浪费、人力浪费，我们可以使用如图 5 所示的中台服务系统：</p>\n<p data-nodeid="18564"><img src="https://s0.lgstatic.com/i/image6/M00/13/2E/Cgp9HWBB3oaAV4SxAAA1KV5k6KE492.png" alt="Drawing 7.png" data-nodeid="18688"></p>\n<ul data-nodeid="18565">\n<li data-nodeid="18566">\n<p data-nodeid="18567"><strong data-nodeid="18693">前端配置系统</strong>是在服务端根据客户端的版本、设备、地区和语言，下发不同的配置（JSON或者文件包）；</p>\n</li>\n<li data-nodeid="18568">\n<p data-nodeid="18569"><strong data-nodeid="18698">反馈系统</strong>，即用户可以在任何平台，调用反馈接口，并将反馈内容写入队列，并落地到系统中进行综合分析；</p>\n</li>\n<li data-nodeid="18570">\n<p data-nodeid="18571"><strong data-nodeid="18703">推送系统</strong>用于管理消息的推送、用户红点和消息数的拉取，以及消息列表的管理；</p>\n</li>\n<li data-nodeid="18572">\n<p data-nodeid="18573"><strong data-nodeid="18708">系统工具</strong>用于处理用户端日志捞取、用户端信息调试上报、性能定位问题分析提取等。</p>\n</li>\n</ul>\n<p data-nodeid="18574">以上是多个中台系统的业务说明，我们再来具体看看每个系统的特性，从特性来分析为什么 Node.js 适合作为服务端语言。</p>\n<h4 data-nodeid="18575">服务特性</h4>\n<p data-nodeid="18576">在中台系统的设计中，系统着重关注：<strong data-nodeid="18728">网络 I/O</strong>、<strong data-nodeid="18729">并发</strong>、<strong data-nodeid="18730">通用性</strong>及<strong data-nodeid="18731">业务复杂度</strong>，一般情况下不涉及复杂的 CPU 运算。这里我们以上面列举的系统来做分析，如表 1 所示。</p>\n<p data-nodeid="18577"><img src="https://s0.lgstatic.com/i/image6/M00/13/2B/CioPOWBB3p-AQBVzAABL9J_mTls495.png" alt="Drawing 8.png" data-nodeid="18734"></p>\n<p data-nodeid="18578">在上述系统对比中，可以分析出 Node.js 作为中台服务，要求是：</p>\n<ul data-nodeid="18579">\n<li data-nodeid="18580">\n<p data-nodeid="18581">通用性必须好；</p>\n</li>\n<li data-nodeid="18582">\n<p data-nodeid="18583">低 CPU 计算；</p>\n</li>\n<li data-nodeid="18584">\n<p data-nodeid="18585">网络 I/O 高或者低都行；</p>\n</li>\n<li data-nodeid="18586">\n<p data-nodeid="18587">并发高或者低都行。</p>\n</li>\n</ul>\n<p data-nodeid="18588">因为这样的服务在 Node.js 主线程中，可以快速处理各类业务场景，不会存在阻塞的情况，因此这类场景也适合使用 Node.js 作为服务端语言。</p>\n<h3 data-nodeid="18589">其他相关</h3>\n<h4 data-nodeid="18590">运营系统</h4>\n<p data-nodeid="18591">在各类互联网项目中，经常用运营活动来做项目推广，而这类运营系统往往逻辑复杂，同时需要根据业务场景进行多次迭代、不断优化。往往这些活动并发很高，但是可以不涉及底层数据库的读写，而更多的是缓存数据的处理。比如我们常见的一些投票活动、排行榜活动等，如图 6 所示。</p>\n<p data-nodeid="18592"><img src="https://s0.lgstatic.com/i/image6/M00/13/2B/CioPOWBB3qyAB_uYAAA0AUisml4262.png" alt="Drawing 10.png" data-nodeid="18746"></p>\n<p data-nodeid="18593">运营系统这块我们会在《18 | 系统的实践设计（下）：完成一个通用投票系统》中详细介绍，并且进行这类系统的实践开发。</p>\n<h4 data-nodeid="18594">不适合场景</h4>\n<p data-nodeid="18595">前一讲介绍了事件循环原理，在原理中突出的是不能阻塞主线程，而一些密集型 CPU 运算的服务则非常不适合使用 Node.js 来处理。比如：</p>\n<ul data-nodeid="18596">\n<li data-nodeid="18597">\n<p data-nodeid="18598"><strong data-nodeid="18756">图片处理</strong>，比如图片的裁剪、图片的缩放，这些非常损耗 CPU 计算，应该用其他进程来处理；</p>\n</li>\n<li data-nodeid="18599">\n<p data-nodeid="18600"><strong data-nodeid="18761">大字符串、大数组类处理</strong>，当涉及这些数据时，应该考虑如何通过切割来处理，或者在其他进程异步处理；</p>\n</li>\n<li data-nodeid="18601">\n<p data-nodeid="18602"><strong data-nodeid="18766">大文件读写处理</strong>，有时会使用 Node.js 服务来处理 Excel，但是遇到 Excel 过大时，会导致 Node.js 内存溢出，因为 V8 内存上限是 1.4 G。</p>\n</li>\n</ul>\n<p data-nodeid="18603">可能还有更多场景，这里只是列举了很小的一部分，总之两个关键因素：<strong data-nodeid="18776">大内存</strong>和<strong data-nodeid="18777">CPU 密集</strong>，这样的场景都不适合使用 Node.js 来提供服务。</p>\n<h3 data-nodeid="18604">总结</h3>\n<p data-nodeid="19644" class="te-preview-highlight">本讲中介绍的各类系统，都遵循了我们<a href="https://kaiwu.lagou.com/course/courseInfo.htm?courseId=694#/detail/pc?id=6783" data-nodeid="19650">《01 | 事件循环：高性能到底是如何做到的？》</a>所介绍的 Node.js 事件循环原理，减少或者避免在 Node.js 主线程中被阻塞，或者进行一些 CPU 密集型计算。遵循了这个原理后，就可以拓展出一些业务复杂度高、业务迭代快的功能，或者一些通用性服务。</p>\n\n\n\n<p data-nodeid="18606">在学完本讲后，你可以了解 Node.js 适合哪些应用场景，并在实际工作中可以尝试使用或者推荐团队来尝试，有任何心得或者问题，都欢迎在评论区与我交流。</p>\n<p data-nodeid="18607">下一讲，我们将介绍一个 Node.js 作为后端服务的例子，到时见。</p>\n<hr data-nodeid="18608">\n<p data-nodeid="18609"><a href="https://shenceyun.lagou.com/t/mka" data-nodeid="18792"><img src="https://s0.lgstatic.com/i/image6/M00/12/FA/CioPOWBBrAKAAod-AASyC72ZqWw233.png" alt="Drawing 2.png" data-nodeid="18791"></a></p>\n<p data-nodeid="18610"><strong data-nodeid="18796">《大前端高薪训练营》</strong></p>\n<p data-nodeid="18611" class="">对标阿里 P7 技术需求 + 每月大厂内推，6 个月助你斩获名企高薪 Offer。<a href="https://shenceyun.lagou.com/t/mka" data-nodeid="18800">点击链接</a>，快来领取！</p>',
        article_title: "02 | 应用场景：Node.js 作为后台可以提供哪些服务？",
        title: "02 | 应用场景：Node.js 作为后台可以提供哪些服务？",
        id: 6784,
      },
      {
        content:
          '<p data-nodeid="22200" class="">前面几讲都是一些知识点的阐述，本讲将应用前面讲到的知识点，来实现一个简单版本的 RESTful 系统架构，并在此架构上实现一些简单的应用。</p>\n<h3 data-nodeid="22201">基础技术点</h3>\n<p data-nodeid="22202">在学习本讲时会涉及一些技术知识点：</p>\n<ul data-nodeid="22203">\n<li data-nodeid="22204">\n<p data-nodeid="22205">什么是 RESTful 规范；</p>\n</li>\n<li data-nodeid="22206">\n<p data-nodeid="22207">数据库的读写处理过程；</p>\n</li>\n<li data-nodeid="22208">\n<p data-nodeid="22209">目前常用的 MVC 架构模式，以及后续本专栏所应用的一套新的、独创的架构模式——MSVC 架构模式。</p>\n</li>\n</ul>\n<h4 data-nodeid="22210">RESTful</h4>\n<p data-nodeid="22211">RESTful（Representational State Transfer）是一种架构的<strong data-nodeid="22416">约束条件</strong>和<strong data-nodeid="22417">规则</strong>。在倡导前后端分离后，该架构规范的应用愈加广泛。具体知识点，<a href="https://github.com/aisuhua/restful-api-design-references" data-nodeid="22414">你可以参考这里进行学习</a>。</p>\n<h4 data-nodeid="22212">MongoDB</h4>\n<p data-nodeid="22213">由于本讲涉及数据库的操作，本专栏主要使用<strong data-nodeid="22436">非关系型数据库</strong>——MongoDB，因此这里需要先了解下 MongoDB 的相关操作，以及安装配置方法，你可以参考<a href="https://www.runoob.com/mongodb/mongodb-osx-install.html" data-nodeid="22426">官网的文档来安装</a>，这里就不细讲。为了使用便利，我们可以直接在官网创建 MongoDB 云服务远程连接，具体请参照<a href="https://cloud.mongodb.com/" data-nodeid="22430">官网</a>，以及 <a href="https://mongodb.github.io/node-mongodb-native/2.0/api/index.html" data-nodeid="22434">API 文档请参考这里</a>。</p>\n<h4 data-nodeid="22214">MVC→MSVC</h4>\n<p data-nodeid="22215">我们应该都比较熟知 MVC 架构，它在前后端分离中起到了非常重要的作用，我们先来看下传统的 MVC 架构的模式，如图 1 所示。</p>\n<p data-nodeid="22216"><img src="https://s0.lgstatic.com/i/image6/M00/17/08/CioPOWBHMl-ASR4aAAAg3opNISU640.png" alt="图片 2.png" data-nodeid="22441"></p>\n<p data-nodeid="22217">此模式中：</p>\n<ul data-nodeid="22218">\n<li data-nodeid="22219">\n<p data-nodeid="22220">M（Model）层处理数据库相关的操作（只有数据库操作时）；</p>\n</li>\n<li data-nodeid="22221">\n<p data-nodeid="22222">C（Controller）层处理业务逻辑；</p>\n</li>\n<li data-nodeid="22223">\n<p data-nodeid="22224">V（View）层则是页面显示和交互（本讲不涉及）。</p>\n</li>\n</ul>\n<p data-nodeid="22225">但是在目前服务划分较细的情况下，M 层不仅仅是数据库操作，因此这种架构模式显得有些力不从心，导致开发的数据以及业务逻辑有时候在 M 层，有时候却在 C 层。出现这类情况的核心原因是 C 与 C 之间无法进行复用，如果需要复用则需要放到 M 层，那么业务逻辑就会冗余在 M，代码会显得非常繁杂，如图 2 所示。</p>\n<p data-nodeid="22226"><img src="https://s0.lgstatic.com/i/image6/M00/17/0C/Cgp9HWBHMnaAG42WAAA3-AZ5WeM867.png" alt="图片 4.png" data-nodeid="22449"></p>\n<div data-nodeid="22227"><p style="text-align:center">图 2 MVC 模式问题</p></div>\n<p data-nodeid="22228">为了解决以上问题，在经过一些实践后，我在研发过程中提出了一套新的架构模式，当然也有他人提到过（比如 Eggjs 框架中的模式）。这种模式也会应用在本专栏的整个架构体系中，我们暂且叫作 MSVC（Model、Service、View、Controller）。</p>\n<p data-nodeid="22229">我们先来看下 MSVC 的架构模式，如图 3 所示。</p>\n<p data-nodeid="22230"><img src="https://s0.lgstatic.com/i/image6/M00/17/09/CioPOWBHMomAfpfmAABDDmUKgC4829.png" alt="图片 6.png" data-nodeid="22454"></p>\n<p data-nodeid="22231">将所有数据相关的操作都集中于 M 层，而 M 层复用的业务逻辑则转到新的 S 层，C 层则负责核心业务处理，可以调用 M 和 S 层。以上是相关知识点，接下来我们进行架构的实践设计。</p>\n<h3 data-nodeid="22232">系统实践</h3>\n<p data-nodeid="22233">我们先实现一个简单版本的 RESTful 服务，其次为了能够更清晰地了解 MVC 架构和 MSVC 架构的优缺点，我们也会分别实现两个版本的 RESTful 服务。</p>\n<p data-nodeid="22234">我们要实现的是一个<strong data-nodeid="22463">获取用户发帖的列表信息 API</strong>，该 API 列表的内容包含两部分，一部分是从数据库获取的发帖内容，但是这部分只包含用户 ID，另外一部分则是需要通过 ID 批量拉取用户信息。</p>\n<p data-nodeid="22235">我们先来设计 RESTful API，由于是拉取列表内容接口，因此这里设计为一个 GET 接口，根据 RESTful 约束规则设计为：GET /v1/contents；另外还需要设计一个独立的服务用来获取用户信息，将接口设计为：GET /v1/userinfos。</p>\n<p data-nodeid="22236">为了更清晰些，我绘制了一个时序图来表示，如图 4 所示。</p>\n<p data-nodeid="22237"><img src="https://s0.lgstatic.com/i/image6/M00/17/0C/Cgp9HWBHMpOASLZ7AACJ0Un2XOA103.png" alt="图片 7.png" data-nodeid="22468"></p>\n<div data-nodeid="22238"><p style="text-align:center">图 4 例子系统时序图</p></div>\n<p data-nodeid="22239">在图 4 中详细的过程是：</p>\n<ul data-nodeid="22240">\n<li data-nodeid="22241">\n<p data-nodeid="22242">用户先调用 /v1/contents API 拉取 restful server 的内容；</p>\n</li>\n<li data-nodeid="22243">\n<p data-nodeid="22244">restful server 会首先去 MongoDB 中获取 contents；</p>\n</li>\n<li data-nodeid="22245">\n<p data-nodeid="22246">拿到 contents 后解析出其中的 userIds；</p>\n</li>\n<li data-nodeid="22247">\n<p data-nodeid="22248">然后再通过 /v1/userinfos API 调用 API server 的服务获取用户信息列表；</p>\n</li>\n<li data-nodeid="22249">\n<p data-nodeid="22250">API server 同样需要和 MongoDB 交互查询到所需要的 userinfos；</p>\n</li>\n<li data-nodeid="22251">\n<p data-nodeid="22252">拿到 userinfos 后通过 addUserinfo 将用户信息整合到 contents 中去；</p>\n</li>\n<li data-nodeid="22253">\n<p data-nodeid="22254">最后将 contents 返回给到调用方。</p>\n</li>\n</ul>\n<p data-nodeid="22255">在不考虑任何架构模式的情况下，我们来实现一个简单版本的 restful 服务，上面分析了需要实现 2 个 server，这里分别叫作 <strong data-nodeid="22486">API server</strong> 和 <strong data-nodeid="22487">restful server</strong>。</p>\n<h4 data-nodeid="22256">API server</h4>\n<p data-nodeid="22257">server 包含 2 个部分：<strong data-nodeid="22498">解析请求路径</strong>和<strong data-nodeid="22499">解析请求参数</strong>，在 Node.js 中我们可以用以下代码来解析：</p>\n<pre class="lang-javascript" data-nodeid="22258"><code data-language="javascript"><span class="hljs-comment">/**\n * \n * 创建 http 服务，简单返回\n */</span>\n<span class="hljs-keyword">const</span> server = http.createServer(<span class="hljs-keyword">async</span> (req, res) =&gt; {\n    <span class="hljs-comment">// 获取 get 参数</span>\n    <span class="hljs-keyword">const</span> pathname = url.parse(req.url).pathname;\n    paramStr = url.parse(req.url).query,\n    param = querystring.parse(paramStr);\n    <span class="hljs-comment">// 过滤非拉取用户信息请求</span>\n    <span class="hljs-keyword">if</span>(<span class="hljs-string">\'/v1/userinfos\'</span> != pathname) {\n      <span class="hljs-keyword">return</span> setResInfo(res, <span class="hljs-literal">false</span>, <span class="hljs-string">\'path not found\'</span>);\n    }\n    <span class="hljs-comment">// 参数校验，没有包含参数时返回错误</span>\n    <span class="hljs-keyword">if</span>(!param || !param[<span class="hljs-string">\'user_ids\'</span>]) {\n      <span class="hljs-keyword">return</span> setResInfo(res, <span class="hljs-literal">false</span>, <span class="hljs-string">\'params error\'</span>);\n    }\n});\n</code></pre>\n<p data-nodeid="22259">上面代码中使用 Node.js 的 url 模块来获取请求路径和 GET 字符串，拿到 GET 的字符串后还需要使用 Node.js 的 querystring 将字符串解析为参数的 JSON 对象。</p>\n<p data-nodeid="22260">参数和请求路径解析成功后，再进行路径的判断和校验，如果不满足我们当前的要求，调用 setResInfo 报错返回相应的数据给到前端。setResInfo 这个函数实现比较简单，使用 res 对象来设置返回的数据，具体你可以前往 <a href="https://github.com/love-flutter/nodejs-column" data-nodeid="22504">GitHub 源码</a>中查看。</p>\n<p data-nodeid="22261">路径和参数解析成功后，我们再根据当前参数查询 MongoDB 中的 userinfo 数据，具体代码如下：</p>\n<pre class="lang-javascript" data-nodeid="22262"><code data-language="javascript"><span class="hljs-keyword">const</span> baseMongo = <span class="hljs-built_in">require</span>(<span class="hljs-string">\'./lib/baseMongodb\'</span>)();\n<span class="hljs-keyword">const</span> server = http.createServer(<span class="hljs-keyword">async</span> (req, res) =&gt; {\n    <span class="hljs-comment">// ...省略上面部分代码</span>\n    <span class="hljs-comment">// 从 db 查询数据，并获取，有可能返回空数据</span>\n    <span class="hljs-keyword">const</span> userInfo = <span class="hljs-keyword">await</span> queryData({<span class="hljs-string">\'id\'</span> : { <span class="hljs-attr">$in</span> : param[<span class="hljs-string">\'user_ids\'</span>].split(<span class="hljs-string">\',\'</span>)}});\n    <span class="hljs-keyword">return</span> setResInfo(res, <span class="hljs-literal">true</span>, <span class="hljs-string">\'success\'</span>, userInfo);\n});\n<span class="hljs-comment">/**\n * \n * @description db 数据查询\n * @param object queryOption \n */</span>\n<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">queryData</span>(<span class="hljs-params">queryOption</span>) </span>{\n  <span class="hljs-keyword">const</span> client = <span class="hljs-keyword">await</span> baseMongo.getClient();\n  <span class="hljs-keyword">const</span> collection = client.db(<span class="hljs-string">"nodejs_cloumn"</span>).collection(<span class="hljs-string">"user"</span>);\n  <span class="hljs-keyword">const</span> queryArr = <span class="hljs-keyword">await</span> collection.find(queryOption).toArray();\n  <span class="hljs-keyword">return</span> queryArr;\n}\n</code></pre>\n<p data-nodeid="22263">这一代码中使用了 baseMongodb 这个自己封装的库，该库主要基于 mongo 的基础库进行了本地封装处理。在 queryData 中通过 mongo 来查询 nodejs_cloumn 库中的 user 表，并带上查询条件，查询语法你可以参考 <a href="https://mongodb.github.io/node-mongodb-native/2.0/api/index.html" data-nodeid="22512">API 文档</a>。</p>\n<blockquote data-nodeid="22264">\n<p data-nodeid="22265">注意上面代码中，find 查询返回的数据需要使用 toArray 进行转化处理。拿到 MongoDB 查询结果后，再调用 setResInfo 返回查询结果给到前端。</p>\n</blockquote>\n<p data-nodeid="22266">接下来我们继续实现 restful server。</p>\n<h4 data-nodeid="22267">restful server</h4>\n<p data-nodeid="22268">和 API server 相似，前面 2 个过程是解析请求路径和请求参数，解析成功后，根据时序图先从 MongoDB 中拉取 10 条 content 数据，代码如下：</p>\n<pre class="lang-javascript" data-nodeid="22269"><code data-language="javascript"><span class="hljs-keyword">const</span> server = http.createServer(<span class="hljs-keyword">async</span> (req, res) =&gt; {\n    <span class="hljs-comment">// 获取 get 参数</span>\n    <span class="hljs-keyword">const</span> pathname = url.parse(req.url).pathname;\n    paramStr = url.parse(req.url).query,\n    param = querystring.parse(paramStr);\n    <span class="hljs-comment">// 过滤非拉取用户信息请求</span>\n    <span class="hljs-keyword">if</span>(<span class="hljs-string">\'/v1/contents\'</span> != pathname) {\n      <span class="hljs-keyword">return</span> setResInfo(res, <span class="hljs-literal">false</span>, <span class="hljs-string">\'path not found\'</span>, <span class="hljs-literal">null</span>, <span class="hljs-string">\'404\'</span>);\n    }\n    <span class="hljs-comment">// 从 db 查询数据，并获取，有可能返回空数据</span>\n    <span class="hljs-keyword">let</span> contents = <span class="hljs-keyword">await</span> queryData({}, {<span class="hljs-attr">limit</span>: <span class="hljs-number">10</span>});\n\n    contents = <span class="hljs-keyword">await</span> filterUserinfo(contents);\n    <span class="hljs-keyword">return</span> setResInfo(res, <span class="hljs-literal">true</span>, <span class="hljs-string">\'success\'</span>, contents);\n});\n</code></pre>\n<p data-nodeid="22270">在 MongoDB 中查询到具体的 contents 后，再调用 filterUserinfo 这个函数将 contents 中的 user_id 转化为 userinfo，具体代码如图 5 所示（为了代码简洁，我使用了截图，源代码请参考 <a href="https://github.com/love-flutter/nodejs-column" data-nodeid="22523">GitHub</a> 上的）：</p>\n<p data-nodeid="22271"><img src="https://s0.lgstatic.com/i/image6/M01/17/09/CioPOWBHMqSAeQfTAAF5ba4WuFA603.png" alt="图片 8.png" data-nodeid="22527"></p>\n<div data-nodeid="22272"><p style="text-align:center">图 5 filterUserinfo 代码实现</p></div>\n<p data-nodeid="22273">在上面代码中的第 52 行是调用 API server 将用户的 userIds 转化为 userinfos，最后在 64 行，将获取的 userinfos 添加到 contents 中。</p>\n<p data-nodeid="22274">最后我们打开两个命令行窗口，分别进入到两个 server 下，运行如下命令启动服务。</p>\n<pre class="lang-java" data-nodeid="22275"><code data-language="java">node index\n</code></pre>\n<p data-nodeid="22276">运行成功后，我们在浏览器中打开如下地址：</p>\n<pre class="lang-java" data-nodeid="22277"><code data-language="java">http:<span class="hljs-comment">//127.0.0.1:5000/v1/userinfos?user_ids=1001,1002</span>\n</code></pre>\n<p data-nodeid="22278">你将会看到一个 JSON 的返回结构，如图 6 所示。</p>\n<p data-nodeid="22279"><img src="https://s0.lgstatic.com/i/image6/M00/17/0D/Cgp9HWBHMqyAFEfxAACiD747m4U810.png" alt="图片 9.png" data-nodeid="22534"></p>\n<div data-nodeid="22280"><p style="text-align:center">图 6 API server 返回信息</p></div>\n<p data-nodeid="22281">接下来我们访问如下地址，并且打开 chrome 的控制台的 network 状态栏。</p>\n<pre class="lang-java" data-nodeid="22282"><code data-language="java">http:<span class="hljs-comment">//127.0.0.1:5000/v1/test</span>\n</code></pre>\n<p data-nodeid="22283">你将会看到返回的状态码是 404，如图 7 所示，这也是 restful 的规范之一，即正确地使用 http 状态码。</p>\n<p data-nodeid="22284"><img src="https://s0.lgstatic.com/i/image6/M01/17/0D/Cgp9HWBHMrWAHu5_AAFIdt9MME4795.png" alt="图片 10.png" data-nodeid="22539"></p>\n<div data-nodeid="22285"><p style="text-align:center">图 7 异常响应返回</p></div>\n<p data-nodeid="22286">接下来我们请求 restful server 的 API，同样使用浏览器打开如下接口地址：</p>\n<pre class="lang-java" data-nodeid="22287"><code data-language="java">http:<span class="hljs-comment">//127.0.0.1:4000/v1/contents</span>\n</code></pre>\n<p data-nodeid="22288">你将会看到如图 8 所示的响应结果。</p>\n<p data-nodeid="22289"><img src="https://s0.lgstatic.com/i/image6/M01/17/0D/Cgp9HWBHMr-AKdSMAAFW1ay8vPI075.png" alt="图片 11.png" data-nodeid="22544"></p>\n<div data-nodeid="22290"><p style="text-align:center">图 8 contents 响应结果</p></div>\n<p data-nodeid="22291">以上就实现了一个简单 restful 服务的功能，你可以看到代码都堆积在 index.js 中，并且代码逻辑还比较简单，如果稍微复杂一些，这种架构模式根本没法进行团队合作，或者后期维护，因此就需要 MVC 和 MVCS 架构模式来优化这种场景。</p>\n<p data-nodeid="22292">接下来我们先来看看使用 MVC 来优化。</p>\n<h3 data-nodeid="22293">进阶实现</h3>\n<p data-nodeid="22294">没有架构模式虽然也能按照需求满足接口要求，但是代码是<strong data-nodeid="22553">不可维护</strong>的。而 MVC 已经被实践证明是非常好的架构模式，但是在现阶段也存在一些问题，接下来我们就逐步进行优化，让我们的架构和代码更加优秀。</p>\n<h4 data-nodeid="22295">MVC</h4>\n<p data-nodeid="22296">既然是 M 和 C，我们就先思考下，上面的 restful server 中哪些是 M 层的逻辑，哪些是 C 层的逻辑。</p>\n<p data-nodeid="22297"><img src="https://s0.lgstatic.com/i/image6/M01/17/0D/Cgp9HWBHMsyAF-PaAAB-xAx-32s648.png" alt="图片 12.png" data-nodeid="22558"></p>\n<p data-nodeid="22298">以上是所有的逻辑，根据表格，我们首先创建两个目录分别是 <strong data-nodeid="22568">model</strong> 和 <strong data-nodeid="22569">Controller</strong>：</p>\n<ul data-nodeid="22299">\n<li data-nodeid="22300">\n<p data-nodeid="22301">在 model 中创建一个 content.js 用来处理 content model 逻辑；</p>\n</li>\n<li data-nodeid="22302">\n<p data-nodeid="22303">在 Controller 中也创建一个 content.js 用来处理 content 的 Controller 逻辑。</p>\n</li>\n</ul>\n<p data-nodeid="22304">在源代码中有一个 index.js 文件，在没有架构模式时，基本上处理了所有的业务，但是根据当前架构模式，如表 1 所示，只适合处理 url 路径解析、路由判断及转发，因此需要简化原来的逻辑，和第一部分代码一样，我们就不再列举了，主要看路由判断。首先需要根据 restful url 路由配置一份路由转发逻辑，配置如下：</p>\n<pre class="lang-javascript" data-nodeid="22305"><code data-language="javascript"><span class="hljs-keyword">const</span> routerMapping = {\n    <span class="hljs-string">\'/v1/contents\'</span> : {\n        <span class="hljs-string">\'Controller\'</span> : <span class="hljs-string">\'content\'</span>,\n        <span class="hljs-string">\'method\'</span> : <span class="hljs-string">\'list\'</span>\n    },\n    <span class="hljs-string">\'/v1/test\'</span> : {\n        <span class="hljs-string">\'Controller\'</span> : <span class="hljs-string">\'content\'</span>,\n        <span class="hljs-string">\'method\'</span> : <span class="hljs-string">\'test\'</span>\n    }\n};\n</code></pre>\n<p data-nodeid="22306">上面代码的意思是：</p>\n<ul data-nodeid="22307">\n<li data-nodeid="22308">\n<p data-nodeid="22309">如果请求路径是 /v1/contents 就转发到 content.js 这个 Controller，并且调用其 list 方法；</p>\n</li>\n<li data-nodeid="22310">\n<p data-nodeid="22311">如果是 /v1/test 则也转发到 content.js 这个 Controller，但调用的是 test 方法。</p>\n</li>\n</ul>\n<blockquote data-nodeid="22312">\n<p data-nodeid="22313">注意：其中 test 是一个同步方法，list 是一个异步方法。</p>\n</blockquote>\n<p data-nodeid="22314">路由配置完成以后，就需要根据路由配置，将请求路径、转发到处理相应功能的模块或者类、函数中去，代码如图 9 所示。</p>\n<p data-nodeid="22315"><img src="https://s0.lgstatic.com/i/image6/M01/17/0D/Cgp9HWBHMtiAAs7YAAJNxih_ssE949.png" alt="图片 13.png" data-nodeid="22580"></p>\n<div data-nodeid="22316"><p style="text-align:center">图 9 index 核心逻辑</p></div>\n<ul data-nodeid="22317">\n<li data-nodeid="22318">\n<p data-nodeid="22319">第一个红色框内的部分，判断的是路由是否在配置内，不存在则返回 404；</p>\n</li>\n<li data-nodeid="22320">\n<p data-nodeid="22321">第二个红色框内的部分，加载对应的 Controller 模块；</p>\n</li>\n<li data-nodeid="22322">\n<p data-nodeid="22323">第三个红色框内的部分，表示判断所调用的方法类型是异步还是同步，如果是异步使用 await 来获取执行结果，如果是同步则直接调用获取返回结果。</p>\n</li>\n</ul>\n<blockquote data-nodeid="22324">\n<p data-nodeid="22325">注意：这里使用 try catch 的目的是确保调用安全，避免 crash 问题。</p>\n</blockquote>\n<p data-nodeid="22326">接下来我们实现一个 Controller，为了合理性，我们先实现一个基类，然后让每个 Controller 继承这个基类：</p>\n<ul data-nodeid="22327">\n<li data-nodeid="22328">\n<p data-nodeid="22329">在项目根目录下我们创建一个 core 文件夹，并创建一个 Controller.js 作为基类；</p>\n</li>\n<li data-nodeid="22330">\n<p data-nodeid="22331">然后我们把一些相同的功能放入这个基类，比如 res 和 req 的赋值，以及通用返回处理，还有 url 参数解析等。</p>\n</li>\n</ul>\n<p data-nodeid="22332">我们来看下这部分代码，如图 10 所示。</p>\n<p data-nodeid="22333"><img src="https://s0.lgstatic.com/i/image6/M01/17/0B/CioPOWBHMxSAAxc8AAF_MvEbU10031.png" alt="图片 14.png" data-nodeid="22591"></p>\n<div data-nodeid="22334"><p style="text-align:center">图 10 Controller 基类</p></div>\n<p data-nodeid="22335">功能还是比较简单的，只是提炼了一些 Controller 共同的部分。接下来我们再来实现 content.js 这个 Controller，代码如图 11 所示：</p>\n<p data-nodeid="22336"><img src="https://s0.lgstatic.com/i/image6/M01/17/0E/Cgp9HWBHMwaAMQK8AAD-onTOdVQ611.png" alt="图片 15.png" data-nodeid="22595"></p>\n<div data-nodeid="22337"><p style="text-align:center">图 11 content.js Controller</p></div>\n<p data-nodeid="22338">我们在初次实现时，可以不关注图 11 中的第 2 和 3 行，实现红色框内的代码即可。可以将 list 暂时设置为空，实现完成后，我们在根目录运行以下命令，启动服务。</p>\n<pre class="lang-java" data-nodeid="22339"><code data-language="java">node index\n</code></pre>\n<p data-nodeid="22340">接下来打开浏览器访问：</p>\n<pre class="lang-java" data-nodeid="22341"><code data-language="java">http:<span class="hljs-comment">//127.0.0.1:3000/v1/test</span>\n</code></pre>\n<p data-nodeid="22342">你就可以看到响应了一个 JSON 数据，这样就实现了 Controller 部分了。如下代码所示：</p>\n<pre class="lang-json" data-nodeid="22343"><code data-language="json">{\n  ret:&nbsp;0,\n  message:&nbsp;"good",\n  data: { }\n}\n</code></pre>\n<p data-nodeid="22344">接下来我们再来实现 Model 层部分，和 Controller 类似，我们也需要一个基类来处理 Model 层相似的逻辑，然后其他 Model 来继承这个基类，这部分如图 12 所示。</p>\n<p data-nodeid="22345"><img src="https://s0.lgstatic.com/i/image6/M00/17/0B/CioPOWBHMx2AHsKzAAEYhjLBhO4974.png" alt="图片 16.png" data-nodeid="22602"></p>\n<div data-nodeid="22346"><p style="text-align:center">图 12 Model 基类</p></div>\n<p data-nodeid="22347">这个基类首先设置了 db 名称，其次定义了一个 GET 方法来获取表的操作句柄，这部分代码与上面简单 restful 服务的类似。完成基类后，我们再来完善 model 中的 content.js 逻辑。</p>\n<p data-nodeid="22348"><img src="https://s0.lgstatic.com/i/image6/M01/17/0E/Cgp9HWBHMyeAPElfAAEk45BmKsI006.png" alt="图片 17.png" data-nodeid="22606"></p>\n<div data-nodeid="22349"><p style="text-align:center">图 13 model content.js 代码实现</p></div>\n<p data-nodeid="22684" class="te-preview-highlight">这部分代码主要方法是 <strong data-nodeid="22690">getList</strong>，原理和简单 restful server 中的查询类似，在第 11 行通过父类的 GET 方法获取表 content 的操作句柄，再调用 MongoDB 的 find 方法查询 contents。有了 model content 后，我们再回去完善 content.js Controller 中的 list 函数部分逻辑，代码封装的比较简洁，如下所示：</p>\n\n<pre class="lang-javascript" data-nodeid="22351"><code data-language="javascript">    <span class="hljs-keyword">async</span> list() {\n        <span class="hljs-keyword">let</span> contentList = <span class="hljs-keyword">await</span> <span class="hljs-keyword">new</span> ContentModel().getList();\n        contentList = <span class="hljs-keyword">await</span> <span class="hljs-keyword">this</span>._filterUserinfo(contentList);\n\n        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.resAPI(<span class="hljs-literal">true</span>, <span class="hljs-string">\'success\'</span>, contentList);\n    }\n</code></pre>\n<p data-nodeid="22352">上面代码中的第 4 行，只能在当前 Controller 下实现一个私有方法 _filterUserinfo 来处理用户信息部分，这部分逻辑也和简单 restful 服务的一样。</p>\n<p data-nodeid="22353">这样就实现了一个 MVC 的架构，将原来的复杂不可扩展性的代码，转化为<strong data-nodeid="22629">可扩展</strong>、<strong data-nodeid="22630">易维护</strong>的代码，这部分核心代码可以参考 <a href="https://github.com/love-flutter/nodejs-column" data-nodeid="22627">GitHub 源码</a>。</p>\n<h4 data-nodeid="22354">MVCS</h4>\n<p data-nodeid="22355">在上面的代码中存在一个问题，就是 _filterUserinfo 是放在 Controller 来处理，这个方法又会涉及调用 API server 的逻辑，看起来也是数据处理部分，从原理上说这部分不适合放在 Controller。其次在其他 Controller 也需要 _filterUserinfo 时，这时候就比较懵逼了，比如我们现在有另外一个 Controller 叫作 recommend.js，这里面也是拉取推荐的 content，也需要这个 _filterUserinfo 方法，如图 14 所示。</p>\n<p data-nodeid="22356"><img src="https://s0.lgstatic.com/i/image6/M00/17/0B/CioPOWBHMzCANv2nAAFcFfow9m4167.png" alt="图片 18.png" data-nodeid="22641"></p>\n<div data-nodeid="22357"><p style="text-align:center">图 14 MVC 复用性问题例子</p></div>\n<p data-nodeid="22358">其中左边是存在的矛盾，因为 _filterUserinfo 在 Controller 是私有方法，recommend Controller 调用不到，那么为了复用，我们只能将该方法封装到 content-model 中，并且将数据也集中在 Model 层去。</p>\n<p data-nodeid="22359">虽然解决了问题，但是你会发现：</p>\n<ul data-nodeid="22360">\n<li data-nodeid="22361">\n<p data-nodeid="22362">Model 层不干净了，它现在既要负责数据处理，又要负责业务逻辑；</p>\n</li>\n<li data-nodeid="22363">\n<p data-nodeid="22364">Controller 层的业务减少了，但是分层不明确了，有些业务放在 Model，有些又在 Controller 层，对于后期代码的维护或者扩展都非常困难了。</p>\n</li>\n</ul>\n<p data-nodeid="22365">为了解决这个问题，有一个新的概念——Service 层，具体如图 15 所示。</p>\n<p data-nodeid="22366"><img src="https://s0.lgstatic.com/i/image6/M00/17/0E/Cgp9HWBHMzqAc1JJAAFspSJGcu8417.png" alt="图片 19.png" data-nodeid="22651"></p>\n<div data-nodeid="22367"><p style="text-align:center">图 15 MSVC 优化效果</p></div>\n<ul data-nodeid="22368">\n<li data-nodeid="22369">\n<p data-nodeid="22370">图中的浅红色框内，就是新架构模式的 M 层；</p>\n</li>\n<li data-nodeid="22371">\n<p data-nodeid="22372">两个绿色框内为 C 层；</p>\n</li>\n<li data-nodeid="22373">\n<p data-nodeid="22374">最上面的浅蓝色框则为 Service 层。</p>\n</li>\n</ul>\n<p data-nodeid="22375">这样就可以复用 _filterUserinfo，并解决 M 与 C 层不明确的问题。接下来我们来实践这部分代码：</p>\n<ul data-nodeid="22376">\n<li data-nodeid="22377">\n<p data-nodeid="22378">首先我们需要创建一个文件夹 service 来存放相应的 Service 层代码；</p>\n</li>\n<li data-nodeid="22379">\n<p data-nodeid="22380">然后创建一个 content.js 来表示 content-service 这个模块；</p>\n</li>\n<li data-nodeid="22381">\n<p data-nodeid="22382">再将原来代码中的 _filterUserinfo 逻辑转到 content-service 中去；</p>\n</li>\n<li data-nodeid="22383">\n<p data-nodeid="22384">最后修改 Controller 代码。</p>\n</li>\n</ul>\n<p data-nodeid="22385">如下代码所示：</p>\n<pre class="lang-javascript" data-nodeid="22386"><code data-language="javascript"> <span class="hljs-keyword">async</span> list() {\n        <span class="hljs-keyword">let</span> contentList = <span class="hljs-keyword">await</span> <span class="hljs-keyword">new</span> ContentModel().getList();\n        contentList = <span class="hljs-keyword">await</span> contentService.filterUserinfo(contentList);\n\n        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.resAPI(<span class="hljs-literal">true</span>, <span class="hljs-string">\'success\'</span>, contentList);\n    }\n</code></pre>\n<p data-nodeid="22387">注意代码中的第 4 行，从原来调用本类的方法，修改为调用 contentService 的 filterUserinfo。</p>\n<h3 data-nodeid="22388">总结</h3>\n<p data-nodeid="22389">本讲最开始介绍了一些技术知识点，这些是你开始学习本专栏必需巩固的技术，接下来根据实践开发了一个微型的 restful 服务，由于代码的不可维护性以及不可扩展性，我们接下来就应用了 MVC 架构设计模式进行了优化，最后由于 MVC 的缺陷，进而提出了使用 MSVC 来解决 MVC 中 M 和 C 业务界定不清晰的问题。</p>\n<p data-nodeid="22390">学完本讲后，你就能自己写一个 restful API 了，并且能够掌握 MVC 和 MSVC 的架构原理，同时能够开发出轻量版本的框架。在实践过程中有任何问题或者心得，都可以在留言区留言。</p>\n<p data-nodeid="22391">讲解完我们自身设计的简版框架后，在下一讲要介绍 Node.js 目前业界使用最广的三个框架，并且进行深入对比分析其优缺点。</p>\n<hr data-nodeid="22392">\n<p data-nodeid="22393"><a href="https://shenceyun.lagou.com/t/mka" data-nodeid="22674"><img src="https://s0.lgstatic.com/i/image6/M00/12/FA/CioPOWBBrAKAAod-AASyC72ZqWw233.png" alt="Drawing 2.png" data-nodeid="22673"></a></p>\n<p data-nodeid="22394"><strong data-nodeid="22678">《大前端高薪训练营》</strong></p>\n<p data-nodeid="22395" class="">对标阿里 P7 技术需求 + 每月大厂内推，6 个月助你斩获名企高薪 Offer。<a href="https://shenceyun.lagou.com/t/mka" data-nodeid="22682">点击链接</a>，快来领取！</p>',
        article_title: "03 | 如何构建一个简单的 RESTful 服务？",
        title: "03 | 如何构建一个简单的 RESTful 服务？",
        id: 6785,
      },
      {
        content:
          '<p data-nodeid="1849" class="">上一讲我们没有应用任何框架实现了一个简单后台服务，以及一个简单版本的 MSVC 框架。本讲将介绍一些目前主流框架的设计思想，同时介绍其核心代码部分的实现，为后续使用框架优化我们上一讲实现的 MSVC 框架做一定的准备。</p>\n<h3 data-nodeid="1850">主流框架介绍</h3>\n<p data-nodeid="3234" class="">目前比较流行的 Node.js 框架有<strong data-nodeid="3248">Express</strong>、<strong data-nodeid="3249">KOA</strong> 和 <strong data-nodeid="3250">Egg.js</strong>，其次是另外一个正在兴起的与 TypeScript 相关的框架——Nest.js，接下来我们分析三个主流框架之间的关系。</p>\n\n\n<p data-nodeid="1852">在介绍框架之前，我们先了解一个非常重要的概念——<strong data-nodeid="2033">洋葱模型</strong>，这是一个在 Node.js 中比较重要的面试考点，掌握这个概念，当前各种框架的原理学习都会驾轻就熟。无论是哪个 Node.js 框架，都是基于中间件来实现的，而中间件（可以理解为一个类或者函数模块）的执行方式就需要依据洋葱模型来介绍。Express 和 KOA 之间的区别也在于洋葱模型的执行方式上。</p>\n<h4 data-nodeid="1853">洋葱模型</h4>\n<p data-nodeid="1854">洋葱我们都知道，一层包裹着一层，层层递进，但是现在不是看其立体的结构，而是需要将洋葱切开来，从切开的平面来看，如图 1 所示。</p>\n<p data-nodeid="1855"><img src="https://s0.lgstatic.com/i/image6/M00/17/0C/CioPOWBHM5qAFpsgAA9oKfFNTFM895.png" alt="Drawing 0.png" data-nodeid="2038"></p>\n<div data-nodeid="1856"><p style="text-align:center">图 1 洋葱切面图</p></div>\n<p data-nodeid="1857">可以看到要从洋葱中心点穿过去，就必须先一层层向内穿入洋葱表皮进入中心点，然后再从中心点一层层向外穿出表皮，这里有个特点：进入时穿入了多少层表皮，出去时就必须穿出多少层表皮。先穿入表皮，后穿出表皮，符合我们所说的栈列表，<strong data-nodeid="2044">先进后出</strong>的原则。</p>\n<p data-nodeid="1858">然后再回到 Node.js 框架，洋葱的表皮我们可以思考为<strong data-nodeid="2050">中间件</strong>：</p>\n<ul data-nodeid="1859">\n<li data-nodeid="1860">\n<p data-nodeid="1861">从外向内的过程是一个关键词 next()；</p>\n</li>\n<li data-nodeid="1862">\n<p data-nodeid="1863">而从内向外则是每个中间件执行完毕后，进入下一层中间件，一直到最后一层。</p>\n</li>\n</ul>\n<h4 data-nodeid="1864">中间件执行</h4>\n<p data-nodeid="1865">为了理解上面的洋葱模型以及其执行过程，我们用 Express 作为框架例子，来实现一个后台服务。在应用 Express 前，需要做一些准备工作，你按照如下步骤初始化项目即可。</p>\n<pre class="lang-java" data-nodeid="1866"><code data-language="java">mkdir myapp\ncd myapp\nnpm init\nnpm install express --save\ntouch app.js\n</code></pre>\n<p data-nodeid="1867">然后输入以下代码，其中的 app.use 部分的就是 3 个中间件，从上到下代表的是洋葱的从外向内的各个层：<strong data-nodeid="2068">1 是最外层</strong>，<strong data-nodeid="2069">2 是中间层</strong>，<strong data-nodeid="2070">3 是最内层</strong>。</p>\n<p data-nodeid="1868"><img src="https://s0.lgstatic.com/i/image6/M00/17/10/Cgp9HWBHM6eAF1p7AAG-YifWNQg212.png" alt="Drawing 1.png" data-nodeid="2073"></p>\n<p data-nodeid="1869">接下来我们运行如下命令，启动项目。</p>\n<pre class="lang-java" data-nodeid="1870"><code data-language="java">node app.js\n</code></pre>\n<p data-nodeid="1871">启动成功后，打开浏览器，输入如下浏览地址：</p>\n<pre class="lang-java" data-nodeid="1872"><code data-language="java">http:<span class="hljs-comment">//127.0.0.1:3000/</span>\n</code></pre>\n<p data-nodeid="1873">然后在命令行窗口，你可以看到打印的信息如下：</p>\n<pre class="lang-java" data-nodeid="1874"><code data-language="java">Example app listening on port <span class="hljs-number">3000</span>!\nfirst\nsecond\nthird\nthird end\nsecond end\nfirst end\n</code></pre>\n<p data-nodeid="1875">这就可以很清晰地验证了我们中间件的执行过程：</p>\n<ul data-nodeid="1876">\n<li data-nodeid="1877">\n<p data-nodeid="1878">先执行第一个中间件，输出 first；</p>\n</li>\n<li data-nodeid="1879">\n<p data-nodeid="1880">遇到 next() 执行第二个中间件，输出 second；</p>\n</li>\n<li data-nodeid="1881">\n<p data-nodeid="1882">再遇到 next() 执行第三个中间件，输出 third；</p>\n</li>\n<li data-nodeid="1883">\n<p data-nodeid="1884">中间件都执行完毕后，往外一层层剥离，先输出 third end；</p>\n</li>\n<li data-nodeid="1885">\n<p data-nodeid="1886">再输出 second；</p>\n</li>\n<li data-nodeid="1887">\n<p data-nodeid="1888">最后输出 first end。</p>\n</li>\n</ul>\n<p data-nodeid="1889">以上就是中间件的执行过程，不过 Express 和 KOA 在中间件执行过程中还是存在一些差异的。</p>\n<h4 data-nodeid="1890">Express &amp; KOA</h4>\n<p data-nodeid="1891">Express 框架出来比较久了，它在 Node.js 初期就是一个<strong data-nodeid="2101">热度较高</strong>、<strong data-nodeid="2102">成熟</strong>的 Web 框架，并且包括的<strong data-nodeid="2103">应用场景非常齐全</strong>。同时基于 Express，也诞生了一些场景型的框架，常见的就如上面我们提到的 Nest.js 框架。</p>\n<p data-nodeid="4163" class="">随着 Node.js 的不断迭代，出现了以 await/async 为核心的语法糖，Express 原班人马为了实现一个高可用、高性能、更健壮，并且符合当前 Node.js 版本的框架，开发出了 <strong data-nodeid="4169">KOA 框架</strong>。</p>\n\n<p data-nodeid="1893">那么两者存在哪些方面的差异呢：</p>\n<ul data-nodeid="1894">\n<li data-nodeid="1895">\n<p data-nodeid="1896">Express 封装、内置了很多中间件，比如 connect 和 router ，而 KOA 则比较轻量，开发者可以根据自身需求<strong data-nodeid="2116">定制框架</strong>；</p>\n</li>\n<li data-nodeid="1897">\n<p data-nodeid="1898">Express 是基于 callback 来处理中间件的，而 KOA 则是基于 await/async；</p>\n</li>\n<li data-nodeid="1899">\n<p data-nodeid="1900">在异步执行中间件时，Express 并非严格按照洋葱模型执行中间件，而 KOA 则是严格遵循的。</p>\n</li>\n</ul>\n<p data-nodeid="1901" class="">为了更清晰地对比两者在中间件上的差异，我们对上面那段代码进行修改，其次用 KOA 来重新实现，看下两者的运行差异。</p>\n<p data-nodeid="1902">因为两者在中间件为<strong data-nodeid="2129">异步函数</strong>的时候处理会有不同，因此我们保留原来三个中间件，同时在 2 和 3 之间插入一个新的<strong data-nodeid="2130">异步中间件</strong>，代码如下：</p>\n<pre class="lang-javascript" data-nodeid="1903"><code data-language="javascript"><span class="hljs-comment">/**\n * 异步中间件\n */</span>\napp.use(<span class="hljs-keyword">async</span> (req, res, next) =&gt; {\n    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">\'async\'</span>);\n    <span class="hljs-keyword">await</span> next();\n    <span class="hljs-keyword">await</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(\n        <span class="hljs-function">(<span class="hljs-params">resolve</span>) =&gt;</span> \n            setTimeout(\n                <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {\n                    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`wait 1000 ms end`</span>);\n                    resolve()\n                }, \n            <span class="hljs-number">1000</span>\n        )\n    );\n    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">\'async end\'</span>);\n});\n</code></pre>\n<p data-nodeid="1904">然后将其他中间件修改为 await next() 方式，如下中间件 1 的方式：</p>\n<pre class="lang-javascript" data-nodeid="1905"><code data-language="javascript"><span class="hljs-comment">/**\n * 中间件 1\n */</span>\napp.use(<span class="hljs-keyword">async</span> (req, res, next) =&gt; {\n    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">\'first\'</span>);\n    <span class="hljs-keyword">await</span> next();\n    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">\'first end\'</span>);\n});\n</code></pre>\n<p data-nodeid="1906">接下来，我们启动服务：</p>\n<pre class="lang-java" data-nodeid="1907"><code data-language="java">node app\n</code></pre>\n<p data-nodeid="1908">并打开浏览器访问如下地址：</p>\n<pre class="lang-java" data-nodeid="1909"><code data-language="java">http:<span class="hljs-comment">//127.0.0.1:3000/</span>\n</code></pre>\n<p data-nodeid="1910">然后再回到打印窗口，你会发现输出如下数据：</p>\n<pre class="lang-java" data-nodeid="1911"><code data-language="java">Example app listening on port <span class="hljs-number">3000</span>!\nfirst\nsecond\nasync\nthird\nthird end\nsecond end\nfirst end\nwait <span class="hljs-number">1000</span> ms end\nasync end\n</code></pre>\n<p data-nodeid="1912">可以看出，<strong data-nodeid="2144">从内向外的是正常的</strong>，一层层往里进行调用，<strong data-nodeid="2145">从外向内时则发生了一些变化</strong>，最主要的原因是异步中间件并没有按照顺序输出执行结果。</p>\n<p data-nodeid="1913">接下来我们看看 KOA 的效果。在应用 KOA 之前，我们需要参照如下命令进行初始化。</p>\n<pre class="lang-java" data-nodeid="1914"><code data-language="java">mkdir -p koa/myapp-async\ncd koa/myapp-async\nnpm init\nnpm i koa --save\ntouch app.js\n</code></pre>\n<p data-nodeid="5082" class="">然后我们打开 app.js 添加如下代码，这部分我们只看<strong data-nodeid="5092">中间件 1</strong> 和<strong data-nodeid="5093">异步中间件</strong>即可，其他在 GitHub 源码中，你可以自行查看。</p>\n\n<pre class="lang-javascript" data-nodeid="1916"><code data-language="javascript"><span class="hljs-keyword">const</span> Koa = <span class="hljs-built_in">require</span>(<span class="hljs-string">\'koa\'</span>);\n<span class="hljs-keyword">const</span> app = <span class="hljs-keyword">new</span> Koa();\n<span class="hljs-comment">/**\n * 中间件 1\n */</span>\napp.use(<span class="hljs-keyword">async</span> (ctx, next) =&gt; {\n    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">\'first\'</span>);\n    <span class="hljs-keyword">await</span> next();\n    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">\'first end\'</span>);\n});\n<span class="hljs-comment">/**\n * 异步中间件\n */</span>\napp.use(<span class="hljs-keyword">async</span> (ctx, next) =&gt; {\n    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">\'async\'</span>);\n    <span class="hljs-keyword">await</span> next();\n    <span class="hljs-keyword">await</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(\n        <span class="hljs-function">(<span class="hljs-params">resolve</span>) =&gt;</span> \n            setTimeout(\n                <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {\n                    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`wait 1000 ms end`</span>);\n                    resolve()\n                }, \n            <span class="hljs-number">1000</span>\n        )\n    );\n    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">\'async end\'</span>);\n});\napp.use(<span class="hljs-keyword">async</span> ctx =&gt; {\n    ctx.body = <span class="hljs-string">\'Hello World\'</span>;\n  });\n\napp.listen(<span class="hljs-number">3000</span>, () =&gt; <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`Example app listening on port 3000!`</span>));\n</code></pre>\n<p data-nodeid="1917">和 express 代码基本没有什么差异，只是将中间件中的 res、req 参数替换为 ctx ，如上面代码的第 6 和 14 行，修改完成以后，我们需要启动服务：</p>\n<pre class="lang-java" data-nodeid="1918"><code data-language="java">node app\n</code></pre>\n<p data-nodeid="1919">并打开浏览器访问如下地址：</p>\n<pre class="lang-java" data-nodeid="1920"><code data-language="java">http:<span class="hljs-comment">//127.0.0.1:3000/</span>\n</code></pre>\n<p data-nodeid="1921">然后打开命令行窗口，可以看到如下输出：</p>\n<pre class="lang-java" data-nodeid="1922"><code data-language="java">Example app listening on port <span class="hljs-number">3000</span>!\nfirst\nsecond\nasync\nthird\nthird end\nwait <span class="hljs-number">1000</span> ms end\nasync end\nsecond end\nfirst end\n</code></pre>\n<p data-nodeid="1923">你会发现，KOA 严格按照了洋葱模型的执行，从上到下，也就是从洋葱的内部向外部，输出 first、second、async、third；接下来从内向外输出 third end、async end、second end、first end。</p>\n<p data-nodeid="1924">因为两者基于的 Node.js 版本不同，所以只是出现的时间点不同而已，并没有孰优孰劣之分。Express 功能较全，发展时间比较长，也经受了不同程度的历练，因此在一些项目上是一个不错的选择。当然你也可以选择 KOA，虽然刚诞生不久，但它是未来的一个趋势。</p>\n<h4 data-nodeid="1925">KOA &amp; Egg.js</h4>\n<p data-nodeid="1926">上面我们说了 KOA 是一个可定制的框架，开发者可以根据自己的需要，定制各种机制，比如多进程处理、路由处理、上下文 context 的处理、异常处理等，非常灵活。而 Egg.js 就是在 KOA 基础上，做了各种比较成熟的中间件和模块，可以说是在 KOA 框架基础上的最佳实践，用以满足开发者开箱即用的特性。</p>\n<p data-nodeid="1927">我们说到 KOA 是未来的一个趋势，然后 Egg.js 是目前 KOA 的最佳实践，因此在一些企业级应用后台服务时，可以使用 Egg.js 框架，如果你需要做一些高性能、高定制化的框架也可以在 KOA 基础上扩展出新的框架。本专栏为了实践教学，我们会在 KOA 基础上将上一讲的框架进行优化和扩展。</p>\n<h3 data-nodeid="1928">原理实现</h3>\n<p data-nodeid="1929">以上简单介绍了几个框架的知识点，接下来我们再来看下其核心实现原理，这里只介绍底层的两个框架<strong data-nodeid="2178">Express</strong>和<strong data-nodeid="2179">KOA</strong>，如果你对 Egg.js 有兴趣的话，可以参照我们的方法进行学习。</p>\n<h4 data-nodeid="1930">Express</h4>\n<p data-nodeid="1931">Express 涉及 app 函数、中间件、Router 和视图四个核心部分，这里我们只介绍 app 函数、中间件和 Router 原理，因为视图在后台服务中不是特别关键的部分。</p>\n<p data-nodeid="1932">我们先来看一个图，图 2 是 Express 核心代码结构部分：</p>\n<p data-nodeid="1933"><img src="https://s0.lgstatic.com/i/image6/M01/17/0D/CioPOWBHM7-AN7gmAABaG7HpWG8493.png" alt="Drawing 2.png" data-nodeid="2185"></p>\n<div data-nodeid="1934"><p style="text-align:center">图 2 Express 核心代码</p></div>\n<p data-nodeid="1935">它涉及的源码不多，其中：</p>\n<ul data-nodeid="1936">\n<li data-nodeid="1937">\n<p data-nodeid="1938">middleware 是部分中间件模块；</p>\n</li>\n<li data-nodeid="1939">\n<p data-nodeid="1940">router 是 Router 核心代码；</p>\n</li>\n<li data-nodeid="1941">\n<p data-nodeid="1942">appliaction.js 就是我们所说的 app 函数核心处理部分；</p>\n</li>\n<li data-nodeid="1943">\n<p data-nodeid="1944">express.js 是我们 express() 函数的执行模块，实现比较简单，主要是创建 application 对象，将 application 对象返回；</p>\n</li>\n<li data-nodeid="1945">\n<p data-nodeid="1946">request.js 是对 HTTP 请求处理部分；</p>\n</li>\n<li data-nodeid="1947">\n<p data-nodeid="1948">response.js 是对 HTTP 响应处理部分；</p>\n</li>\n<li data-nodeid="1949">\n<p data-nodeid="1950">utils.js 是一些工具函数；</p>\n</li>\n<li data-nodeid="1951">\n<p data-nodeid="1952">view.js 是视图处理部分。</p>\n</li>\n</ul>\n<p data-nodeid="1953"><strong data-nodeid="2198">express.js</strong></p>\n<p data-nodeid="1954">在 express 整个代码架构中核心是创建 application 对象，那么我们先来看看这部分的核心实现部分。在 Express 中的例子都是下面这样的：</p>\n<pre class="lang-javascript" data-nodeid="1955"><code data-language="javascript"><span class="hljs-keyword">const</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">\'express\'</span>)\n<span class="hljs-keyword">const</span> app = express()\n<span class="hljs-keyword">const</span> port = <span class="hljs-number">3000</span>\napp.listen(port, () =&gt; <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`Example app listening on port <span class="hljs-subst">${port}</span>!`</span>))\napp.get(<span class="hljs-string">\'/\'</span>, (req, res) =&gt; res.send(<span class="hljs-string">\'Hello World!\'</span>))\n</code></pre>\n<p data-nodeid="1956">其中我们所说的 app ，就是 express() 函数执行的返回，该 express.js 模块中核心代码是一个叫作 createApplication 函数，代码如下：</p>\n<pre class="lang-javascript" data-nodeid="1957"><code data-language="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createApplication</span>(<span class="hljs-params"></span>) </span>{\n\t  <span class="hljs-keyword">var</span> app = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">req, res, next</span>) </span>{\n\t    app.handle(req, res, next);\n\t  };\n\t\n\t  mixin(app, EventEmitter.prototype, <span class="hljs-literal">false</span>);\n\t  mixin(app, proto, <span class="hljs-literal">false</span>);\n\t\n\t  <span class="hljs-comment">// expose the prototype that will get set on requests</span>\n\t  app.request = <span class="hljs-built_in">Object</span>.create(req, {\n\t    <span class="hljs-attr">app</span>: { <span class="hljs-attr">configurable</span>: <span class="hljs-literal">true</span>, <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">true</span>, <span class="hljs-attr">writable</span>: <span class="hljs-literal">true</span>, <span class="hljs-attr">value</span>: app }\n\t  })\n\t\n\t  <span class="hljs-comment">// expose the prototype that will get set on responses</span>\n\t  app.response = <span class="hljs-built_in">Object</span>.create(res, {\n\t    <span class="hljs-attr">app</span>: { <span class="hljs-attr">configurable</span>: <span class="hljs-literal">true</span>, <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">true</span>, <span class="hljs-attr">writable</span>: <span class="hljs-literal">true</span>, <span class="hljs-attr">value</span>: app }\n\t  })\n\t\n\t  app.init();\n\t  <span class="hljs-keyword">return</span> app;\n\t}\n</code></pre>\n<p data-nodeid="1958">代码中最主要的部分是创建了一个 app 函数，并将 application 中的函数继承给 app 。因此 app 包含了 application 中所有的属性和方法，而其中的 app.init() 也是调用了 application.js 中的 app.init 函数。在 application.js 核心代码逻辑中，我们最常用到 app.use 、app.get 以及 app.post 方法，这三个原理都是一样的，我们主要看下 app.use 的代码实现。</p>\n<p data-nodeid="1959"><strong data-nodeid="2205">application.js</strong></p>\n<p data-nodeid="1960"><strong data-nodeid="2214">app.use</strong>，用于<strong data-nodeid="2215">中间件以及路由的处理</strong>，是我们常用的一个核心函数。</p>\n<ul data-nodeid="1961">\n<li data-nodeid="1962">\n<p data-nodeid="1963">在只传入一个函数参数时，将会匹配所有的请求路径。</p>\n</li>\n<li data-nodeid="1964">\n<p data-nodeid="1965">当传递的是具体的路径时，只有匹配到具体路径才会执行该函数。</p>\n</li>\n</ul>\n<p data-nodeid="1966">如下代码所示：</p>\n<pre class="lang-javascript" data-nodeid="1967"><code data-language="javascript"><span class="hljs-keyword">const</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">\'express\'</span>)\n<span class="hljs-keyword">const</span> app = express()\n<span class="hljs-keyword">const</span> port = <span class="hljs-number">3000</span>\napp.listen(port, () =&gt; <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`Example app listening on port <span class="hljs-subst">${port}</span>!`</span>))\napp.use(<span class="hljs-function">(<span class="hljs-params">req, res, next</span>) =&gt;</span> {\n    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">\'first\'</span>);\n    next();\n    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">\'first end\'</span>);\n});\napp.use(<span class="hljs-string">\'/a\'</span>, (req, res, next) =&gt; {\n    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">\'a\'</span>);\n    next();\n    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">\'a end\'</span>);\n});\napp.get(<span class="hljs-string">\'/\'</span>, (req, res) =&gt; res.send(<span class="hljs-string">\'Hello World!\'</span>))\napp.get(<span class="hljs-string">\'/a\'</span>, (req, res) =&gt; res.send(<span class="hljs-string">\'Hello World! a\'</span>))\n</code></pre>\n<p data-nodeid="1968">当我们只请求如下端口时，只执行第 6 ~ 10 行的 app.use。</p>\n<pre class="lang-java" data-nodeid="1969"><code data-language="java">http:<span class="hljs-comment">//127.0.0.1:3000/</span>\n</code></pre>\n<p data-nodeid="1970">而当请求如下端口时，两个中间件都会执行。</p>\n<pre class="lang-java" data-nodeid="1971"><code data-language="java">http:<span class="hljs-comment">//127.0.0.1:3000/a</span>\n</code></pre>\n<p data-nodeid="1972">再来看下 Express 代码实现，如图 3 所示：</p>\n<p data-nodeid="1973"><img src="https://s0.lgstatic.com/i/image6/M01/17/10/Cgp9HWBHM-CAYcukAAFHHQytNag202.png" alt="Drawing 3.png" data-nodeid="2226"></p>\n<div data-nodeid="1974"><p style="text-align:center">图 3 Express app.use 代码实现</p></div>\n<p data-nodeid="1975">当没有传入 path 时，会默认设置 path 为 / ，而 / 则是<strong data-nodeid="2232">匹配任何路径</strong>，最终都是调用 router.use 将 fn 中间件函数传入到 router 中。</p>\n<p data-nodeid="1976">接下来我们看下 router.use 的代码实现。</p>\n<p data-nodeid="1977"><strong data-nodeid="2237">router/index.js</strong></p>\n<p data-nodeid="1978">这个文件在当前目录 router 下的 index.js 中，有一个方法叫作 proto.use，即 application.js 中调用的 router.use 。</p>\n<p data-nodeid="1979"><img src="https://s0.lgstatic.com/i/image6/M01/17/0D/CioPOWBHM-eAT835AAFGYW1HaL0653.png" alt="Drawing 4.png" data-nodeid="2241"></p>\n<div data-nodeid="1980"><p style="text-align:center">图 4 中间件 push 实现</p></div>\n<p data-nodeid="1981">图 4 中的代码经过一系列处理，最终将中间件函数通过 Layer 封装后放到栈列表中。就完成了中间件的处理，最后我们再来看下用户请求时，是如何在栈列表执行的。</p>\n<p data-nodeid="8793" class="">所有请求进来后都会调用 application.js 中的 <strong data-nodeid="8807">app.handle</strong> 方法，该方法最终调用的是 router/index.js 中的 <strong data-nodeid="8808">proto.handle</strong> 方法，所以我们主要看下 router.handle 的实现。在这个函数中有一个 next 方法非常关键，用于判断执行<strong data-nodeid="8809">下一层中间件的逻辑</strong>，它的原理是从栈列表中取出一个 layer 对象，判断是否满足当前匹配，如果满足则执行该中间件函数，如图 5 所示。</p>\n\n\n\n\n<p data-nodeid="1983"><img src="https://s0.lgstatic.com/i/image6/M01/17/0D/CioPOWBHM_CAGrfhAAEAXbjYjVU402.png" alt="Drawing 5.png" data-nodeid="2261"></p>\n<div data-nodeid="1984"><p style="text-align:center">图 5 中间件执行逻辑</p></div>\n<p data-nodeid="1985">接下来我们再看看 layer.handle_request 的代码逻辑，如图 6 所示。</p>\n<p data-nodeid="1986"><img src="https://s0.lgstatic.com/i/image6/M01/17/10/Cgp9HWBHM_iAAdIdAACdFAXr7Tg707.png" alt="Drawing 6.png" data-nodeid="2267"></p>\n<div data-nodeid="1987"><p style="text-align:center">图 6 handle_request 代码实现</p></div>\n<p data-nodeid="1988">图 6 中的代码释放了一个很重要的逻辑，就是在代码 try 部分，会执行 fn 函数，而 fn 中的 next 为下一个中间件，因此中间件栈执行代码，过程如下所示：</p>\n<pre class="lang-javascript" data-nodeid="1989"><code data-language="javascript">(<span class="hljs-function"><span class="hljs-params">()</span>=&gt;</span>{ \n    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">\'a\'</span>); \n    <span class="hljs-function">(<span class="hljs-params">(</span>)=&gt;</span>{ \n        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">\'b\'</span>); \n        <span class="hljs-function">(<span class="hljs-params">(</span>)=&gt;</span>{ \n            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">\'c\'</span>); \n            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">\'d\'</span>); \n        })();\n        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">\'e\'</span>); \n    })();\n    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">\'f\'</span>); \n})();\n</code></pre>\n<p data-nodeid="1990">如果没有异步逻辑，那肯定是 a → b → c → d → e → f 的执行流程，如果这时我们在第二层增加一些异步处理函数时，情况如下代码所示：</p>\n<pre class="lang-javascript" data-nodeid="1991"><code data-language="javascript">(<span class="hljs-keyword">async</span> ()=&gt;{ \n    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">\'a\'</span>); \n    <span class="hljs-function">(<span class="hljs-params"><span class="hljs-keyword">async</span> (</span>)=&gt;</span>{ \n        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">\'b\'</span>); \n        <span class="hljs-function">(<span class="hljs-params"><span class="hljs-keyword">async</span> (</span>)=&gt;</span>{ \n            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">\'c\'</span>); \n            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">\'d\'</span>); \n        })();\n        <span class="hljs-keyword">await</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve</span>) =&gt;</span> setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {<span class="hljs-built_in">console</span>.log(<span class="hljs-string">`async end`</span>);resolve()}, <span class="hljs-number">1000</span>));\n        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">\'e\'</span>); \n    })();\n    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">\'f\'</span>); \n})();\n</code></pre>\n<p data-nodeid="1992">再执行这部分代码时，你会发现整个输出流程就不是原来的模式了，这也印证了 Express 的中间件执行方式并不是完全的洋葱模型。</p>\n<p data-nodeid="1993">Express 源码当然不止这些，这里只是介绍了部分核心代码，其他部分建议你按照这种方式自我学习。</p>\n<h4 data-nodeid="1994">KOA</h4>\n<p data-nodeid="1995">和 Express 相似，我们只看 app 函数、中间件和 Router 三个部分的核心代码实现。在 app.use 中的逻辑非常相似，唯一的区别是，在 KOA 中使用的是 await/async 语法，因此需要判断中间件<strong data-nodeid="2278">是否为异步方法</strong>，如果是则使用 koa-convert 将其转化为 Promise 方法，代码如下：</p>\n<pre class="lang-javascript" data-nodeid="1996"><code data-language="javascript">  use(fn) {\n    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> fn !== <span class="hljs-string">\'function\'</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(<span class="hljs-string">\'middleware must be a function!\'</span>);\n    <span class="hljs-keyword">if</span> (isGeneratorFunction(fn)) {\n      deprecate(<span class="hljs-string">\'Support for generators will be removed in v3. \'</span> +\n                <span class="hljs-string">\'See the documentation for examples of how to convert old middleware \'</span> +\n                <span class="hljs-string">\'https://github.com/koajs/koa/blob/master/docs/migration.md\'</span>);\n      fn = convert(fn);\n    }\n    debug(<span class="hljs-string">\'use %s\'</span>, fn._name || fn.name || <span class="hljs-string">\'-\'</span>);\n    <span class="hljs-keyword">this</span>.middleware.push(fn);\n    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;\n  }\n</code></pre>\n<p data-nodeid="1997">最终都是将中间件函数放入中间件的一个数组中。接下来我们再看下 KOA 是如何执行中间件的代码逻辑的，其核心是 koa-compose 模块中的这部分代码：</p>\n<pre class="lang-javascript" data-nodeid="1998"><code data-language="javascript"><span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">context, next</span>) </span>{\n    <span class="hljs-comment">// last called middleware #</span>\n    <span class="hljs-keyword">let</span> index = <span class="hljs-number">-1</span>\n    <span class="hljs-keyword">return</span> dispatch(<span class="hljs-number">0</span>)\n    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">dispatch</span> (<span class="hljs-params">i</span>) </span>{\n      <span class="hljs-keyword">if</span> (i &lt;= index) <span class="hljs-keyword">return</span> <span class="hljs-built_in">Promise</span>.reject(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">\'next() called multiple times\'</span>))\n      index = i\n      <span class="hljs-keyword">let</span> fn = middleware[i]\n      <span class="hljs-keyword">if</span> (i === middleware.length) fn = next\n      <span class="hljs-keyword">if</span> (!fn) <span class="hljs-keyword">return</span> <span class="hljs-built_in">Promise</span>.resolve()\n      <span class="hljs-keyword">try</span> {\n        <span class="hljs-keyword">return</span> <span class="hljs-built_in">Promise</span>.resolve(fn(context, dispatch.bind(<span class="hljs-literal">null</span>, i + <span class="hljs-number">1</span>)));\n      } <span class="hljs-keyword">catch</span> (err) {\n        <span class="hljs-keyword">return</span> <span class="hljs-built_in">Promise</span>.reject(err)\n      }\n    }\n  }\n</code></pre>\n<p data-nodeid="1999">在代码中首先获取第一层级的中间件，也就是数组 middleware 的第一个元素，这里不同点在于使用了 Promise.resolve 来执行中间件，根据上面的代码我们可以假设 KOA 代码逻辑是这样的：</p>\n<pre class="lang-javascript" data-nodeid="2000"><code data-language="javascript"><span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-keyword">async</span> (resolve, reject) =&gt; {\n        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">\'a\'</span>)\n        <span class="hljs-keyword">await</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-keyword">async</span> (resolve, reject) =&gt; {\n            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">\'b\'</span>);\n            <span class="hljs-keyword">await</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {\n                <span class="hljs-built_in">console</span>.log(<span class="hljs-string">\'c\'</span>);\n                resolve();\n            }).then(<span class="hljs-keyword">async</span> () =&gt; {\n                <span class="hljs-keyword">await</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve</span>) =&gt;</span> setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {<span class="hljs-built_in">console</span>.log(<span class="hljs-string">`async end`</span>);resolve()}, <span class="hljs-number">1000</span>));\n                <span class="hljs-built_in">console</span>.log(<span class="hljs-string">\'d\'</span>);\n            });\n            resolve();\n        }).then(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {\n          <span class="hljs-built_in">console</span>.log(<span class="hljs-string">\'e\'</span>)\n        })\n        resolve();\n    }).then(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {\n        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">\'f\'</span>)\n    })\n</code></pre>\n<p data-nodeid="9722" class="te-preview-highlight">可以看到所有 next() 后面的代码逻辑都包裹在 next() 中间件的 then 逻辑中，这样就可以确保上一个异步函数执行完成后才会执行到 then 的逻辑，也就保证了洋葱模型的先进后出原则，这点是 KOA 和 Express 的本质区别。这里要注意，如果需要确保中间件的执行顺序，必须使用 <strong data-nodeid="9728">await next()</strong>。</p>\n\n<p data-nodeid="2002">Express 和 KOA 的源代码还有很多，这里就不一一分析了，其他的部分你可以自行学习，在学习中，可以进一步提升自己的编码能力，同时改变部分编码陋习。在此过程中有任何问题，都欢迎留言与我交流。</p>\n<h3 data-nodeid="2003">总结</h3>\n<p data-nodeid="2004">本讲先介绍了洋葱模型，其次根据洋葱模型详细分析了 Express 和 KOA 框架的区别和联系，最后介绍了两个核心框架的 app 函数、中间件和 Router 三个部分的核心代码实现。学完本讲，你需要掌握洋葱模型，特别是在面试环节中要着重介绍；能够讲解清楚在 Express 与 KOA 中的洋葱模型差异；以及掌握 Express 和 KOA 中的核心代码实现部分原理；其次了解 Egg.js 框架。</p>\n<p data-nodeid="2005">下一讲，我们将会介绍 Node.js 多进程方案，在介绍该方案时，我们还会应用 KOA 框架来优化我们第 03 讲的基础框架，使其成为一个比较通用的框架。</p>\n<hr data-nodeid="2006">\n<p data-nodeid="2007"><a href="https://shenceyun.lagou.com/t/mka" data-nodeid="2295"><img src="https://s0.lgstatic.com/i/image6/M00/12/FA/CioPOWBBrAKAAod-AASyC72ZqWw233.png" alt="Drawing 2.png" data-nodeid="2294"></a></p>\n<p data-nodeid="2008"><strong data-nodeid="2299">《大前端高薪训练营》</strong></p>\n<p data-nodeid="2009" class="">对标阿里 P7 技术需求 + 每月大厂内推，6 个月助你斩获名企高薪 Offer。<a href="https://shenceyun.lagou.com/t/mka" data-nodeid="2303">点击链接</a>，快来领取！</p>',
        article_title:
          "04 | 3 大主流系统框架：由浅入深分析 Express、Koa 和 Egg.js",
        title: "04 | 3 大主流系统框架：由浅入深分析 Express、Koa 和 Egg.js",
        id: 6786,
      },
      {
        content:
          '<p data-nodeid="1613" class="">前几讲我们都使用了一种非常简单暴力的方式（node app.js）启动 Node.js 服务器，而在线上我们要考虑使用多核 CPU，充分利用服务器资源，这里就用到多进程解决方案，所以本讲介绍 PM2 的原理以及如何应用一个 cluster 模式启动 Node.js 服务。</p>\n<h3 data-nodeid="1614">单线程问题</h3>\n<p data-nodeid="1615">在<a href="https://kaiwu.lagou.com/course/courseInfo.htm?courseId=694#/detail/pc?id=6783" data-nodeid="1750">《01 | 事件循环：高性能到底是如何做到的？》</a>中我们分析了 Node.js 主线程是单线程的，如果我们使用 node app.js 方式运行，就启动了一个进程，只能在<strong data-nodeid="1764">一个 CPU 中进行运算</strong>，无法应用服务器的多核 CPU，因此我们需要寻求一些解决方案。你能想到的解决方案肯定是<strong data-nodeid="1765">多进程分发策略</strong>，即主进程接收所有请求，然后通过一定的<strong data-nodeid="1766">负载均衡策略</strong>分发到不同的 Node.js 子进程中。如图 1 的方案所示：</p>\n<p data-nodeid="1616"><img src="https://s0.lgstatic.com/i/image6/M01/1D/E0/CioPOWBQKV2ABtnsAAAuF7ZUkEQ818.png" alt="Drawing 1.png" data-nodeid="1769"></p>\n<p data-nodeid="1617">这一方案有 2 个不同的实现：</p>\n<ul data-nodeid="1618">\n<li data-nodeid="1619">\n<p data-nodeid="1620">主进程监听一个端口，子进程不监听端口，通过主进程分发请求到子进程；</p>\n</li>\n<li data-nodeid="1621">\n<p data-nodeid="1622">主进程和子进程分别监听不同端口，通过主进程分发请求到子进程。</p>\n</li>\n</ul>\n<p data-nodeid="1623">在 Node.js 中的 cluster 模式使用的是第一个实现。</p>\n<h3 data-nodeid="1624">cluster 模式</h3>\n<p data-nodeid="1625">cluster 模式其实就是我们上面图 1 所介绍的模式，<strong data-nodeid="1784">一个主进程</strong>和<strong data-nodeid="1785">多个子进程</strong>，从而形成一个集群的概念。我们先来看看 cluster 模式的应用例子。</p>\n<h4 data-nodeid="1626">应用</h4>\n<p data-nodeid="1627">我们先实现一个简单的 app.js，代码如下：</p>\n<pre class="lang-javascript" data-nodeid="1628"><code data-language="javascript"><span class="hljs-keyword">const</span> http = <span class="hljs-built_in">require</span>(<span class="hljs-string">\'http\'</span>);\n<span class="hljs-comment">/**\n * \n * 创建 http 服务，简单返回\n */</span>\n<span class="hljs-keyword">const</span> server = http.createServer(<span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> {\n    res.write(<span class="hljs-string">`hello world, start with cluster <span class="hljs-subst">${process.pid}</span>`</span>);\n    res.end();\n});\n<span class="hljs-comment">/**\n * \n * 启动服务\n */</span>\nserver.listen(<span class="hljs-number">3000</span>, () =&gt; {\n    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">\'server start http://127.0.0.1:3000\'</span>);\n});\n<span class="hljs-built_in">console</span>.log(<span class="hljs-string">`Worker <span class="hljs-subst">${process.pid}</span> started`</span>);\n</code></pre>\n<p data-nodeid="1629">这是最简单的一个 Node.js 服务，接下来我们应用 cluster 模式来包装这个服务，代码如下：</p>\n<pre class="lang-javascript" data-nodeid="1630"><code data-language="javascript"><span class="hljs-keyword">const</span> cluster = <span class="hljs-built_in">require</span>(<span class="hljs-string">\'cluster\'</span>);\n<span class="hljs-keyword">const</span> instances = <span class="hljs-number">2</span>; <span class="hljs-comment">// 启动进程数量</span>\n<span class="hljs-keyword">if</span> (cluster.isMaster) {\n    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>;i&lt;instances;i++) { <span class="hljs-comment">// 使用 cluster.fork 创建子进程</span>\n        cluster.fork();\n    }\n} <span class="hljs-keyword">else</span> {\n    <span class="hljs-built_in">require</span>(<span class="hljs-string">\'./app.js\'</span>);\n}\n</code></pre>\n<p data-nodeid="1631">首先判断是否为主进程：</p>\n<ul data-nodeid="1632">\n<li data-nodeid="1633">\n<p data-nodeid="1634">如果是则使用 cluster.fork 创建子进程；</p>\n</li>\n<li data-nodeid="1635">\n<p data-nodeid="1636">如果不是则为子进程 require 具体的 app.js。</p>\n</li>\n</ul>\n<p data-nodeid="1637">然后运行下面命令启动服务。</p>\n<pre class="lang-java" data-nodeid="1638"><code data-language="java">$ node cluster.js\n</code></pre>\n<p data-nodeid="1639">启动成功后，再打开另外一个命令行窗口，多次运行以下命令：</p>\n<pre class="lang-java" data-nodeid="1640"><code data-language="java">curl <span class="hljs-string">"http://127.0.0.1:3000/"</span>\n</code></pre>\n<p data-nodeid="1641">你可以看到如下输出：</p>\n<pre class="lang-java" data-nodeid="1642"><code data-language="java">hello world, start with cluster <span class="hljs-number">4543</span>\nhello world, start with cluster <span class="hljs-number">4542</span>\nhello world, start with cluster <span class="hljs-number">4543</span>\nhello world, start with cluster <span class="hljs-number">4542</span>\n</code></pre>\n<p data-nodeid="1643">后面的进程 ID 是比较有规律的随机数，有时候输出 4543，有时候输出 4542，4543 和 4542 就是我们 <strong data-nodeid="1800">fork 出来的两个子进程</strong>，接下来我们看下为什么是这样的。</p>\n<h4 data-nodeid="1644">原理</h4>\n<p data-nodeid="1645">首先我们需要搞清楚两个问题：</p>\n<ul data-nodeid="1646">\n<li data-nodeid="1647">\n<p data-nodeid="1648">Node.js 的 cluster 是如何做到多个进程监听一个端口的；</p>\n</li>\n<li data-nodeid="1649">\n<p data-nodeid="1650">Node.js 是如何进行负载均衡请求分发的。</p>\n</li>\n</ul>\n<p data-nodeid="1651"><strong data-nodeid="1808">多进程端口问题</strong></p>\n<p data-nodeid="1652">在 cluster 模式中存在 master 和 worker 的概念，<strong data-nodeid="1818">master 就是主进程</strong>，<strong data-nodeid="1819">worker 则是子进程</strong>，因此这里我们需要看下 master 进程和 worker 进程的创建方式。如下代码所示：</p>\n<pre class="lang-javascript" data-nodeid="1653"><code data-language="javascript"><span class="hljs-keyword">const</span> cluster = <span class="hljs-built_in">require</span>(<span class="hljs-string">\'cluster\'</span>);\n<span class="hljs-keyword">const</span> instances = <span class="hljs-number">2</span>; <span class="hljs-comment">// 启动进程数量</span>\n<span class="hljs-keyword">if</span> (cluster.isMaster) {\n    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>;i&lt;instances;i++) { <span class="hljs-comment">// 使用 cluster.fork 创建子进程</span>\n        cluster.fork();\n    }\n} <span class="hljs-keyword">else</span> {\n    <span class="hljs-built_in">require</span>(<span class="hljs-string">\'./app.js\'</span>);\n}\n</code></pre>\n<p data-nodeid="1654">这段代码中，第一次 require 的 cluster 对象就默认是一个 master，这里的判断逻辑在<a href="https://github.com/nodejs/node/blob/master/lib/cluster.js" data-nodeid="1823">源码</a>中，如下代码所示：</p>\n<pre class="lang-javascript" data-nodeid="1655"><code data-language="javascript"><span class="hljs-meta">\'use strict\'</span>;\n\t\n\t<span class="hljs-keyword">const</span> childOrPrimary = <span class="hljs-string">\'NODE_UNIQUE_ID\'</span> <span class="hljs-keyword">in</span> process.env ? <span class="hljs-string">\'child\'</span> : <span class="hljs-string">\'primary\'</span>;\n\t<span class="hljs-built_in">module</span>.exports = <span class="hljs-built_in">require</span>(<span class="hljs-string">`internal/cluster/<span class="hljs-subst">${childOrPrimary}</span>`</span>);\n</code></pre>\n<p data-nodeid="1656">通过<strong data-nodeid="1830">进程环境变量设置</strong>来判断：</p>\n<ul data-nodeid="1657">\n<li data-nodeid="1658">\n<p data-nodeid="1659">如果没有设置则为 master 进程；</p>\n</li>\n<li data-nodeid="1660">\n<p data-nodeid="1661">如果有设置则为子进程。</p>\n</li>\n</ul>\n<p data-nodeid="1662">因此第一次调用 cluster 模块是 master 进程，而后都是子进程。</p>\n<p data-nodeid="1663">主进程和子进程 require 文件不同：</p>\n<ul data-nodeid="1664">\n<li data-nodeid="1665">\n<p data-nodeid="1666">前者是 internal/cluster/primary；</p>\n</li>\n<li data-nodeid="1667">\n<p data-nodeid="1668">后者是 internal/cluster/child。</p>\n</li>\n</ul>\n<p data-nodeid="1669">我们先来看下 master 进程的创建过程，这部分<a href="https://github.com/nodejs/node/blob/7397c7e4a303b1ebad84892872717c0092852921/lib/internal/cluster/primary.js#L60" data-nodeid="1840">代码在这里</a>。</p>\n<p data-nodeid="1670">可以看到 cluster.fork，一开始就会调用 setupPrimary 方法，创建主进程，由于该方法是通过 cluster.fork 调用，因此会调用多次，但是该模块有个全局变量 initialized 用来区分是否为首次，如果是首次则创建，否则则跳过，如下代码：</p>\n<pre class="lang-javascript" data-nodeid="1671"><code data-language="javascript">  <span class="hljs-keyword">if</span> (initialized === <span class="hljs-literal">true</span>)\n\t    <span class="hljs-keyword">return</span> process.nextTick(setupSettingsNT, settings);\n\t\n\t  initialized = <span class="hljs-literal">true</span>;\n</code></pre>\n<p data-nodeid="1672">接下来继续看 cluster.fork 方法，源码如下：</p>\n<pre class="lang-javascript" data-nodeid="1673"><code data-language="javascript">cluster.fork = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">env</span>) </span>{\n\t  cluster.setupPrimary();\n\t  <span class="hljs-keyword">const</span> id = ++ids;\n\t  <span class="hljs-keyword">const</span> workerProcess = createWorkerProcess(id, env);\n\t  <span class="hljs-keyword">const</span> worker = <span class="hljs-keyword">new</span> Worker({\n\t    <span class="hljs-attr">id</span>: id,\n\t    <span class="hljs-attr">process</span>: workerProcess\n\t  });\n\t\n\t  worker.on(<span class="hljs-string">\'message\'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">message, handle</span>) </span>{\n\t    cluster.emit(<span class="hljs-string">\'message\'</span>, <span class="hljs-keyword">this</span>, message, handle);\n\t  });\n</code></pre>\n<p data-nodeid="1674">在上面代码中第 2 行就是<strong data-nodeid="1855">创建主进程</strong>，第 4 行就是<strong data-nodeid="1856">创建 worker 子进程</strong>，在这个 createWorkerProcess 方法中，最终是使用 child_process 来创建子进程的。在初始化代码中，我们调用了两次 cluster.fork 方法，因此会创建 2 个子进程，在创建后又会调用我们项目根目录下的 cluster.js 启动一个新实例，这时候由于 cluster.isMaster 是 false，因此会 require 到 internal/cluster/child 这个方法。</p>\n<p data-nodeid="1675">由于是 worker 进程，因此代码会 require (\'./app.js\') 模块，在该模块中会监听具体的端口，代码如下：</p>\n<pre class="lang-javascript" data-nodeid="1676"><code data-language="javascript"><span class="hljs-comment">/**\n * \n * 启动服务\n */</span>\nserver.listen(<span class="hljs-number">3000</span>, () =&gt; {\n    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">\'server start http://127.0.0.1:3000\'</span>);\n});\n<span class="hljs-built_in">console</span>.log(<span class="hljs-string">`Worker <span class="hljs-subst">${process.pid}</span> started`</span>);\n</code></pre>\n<p data-nodeid="1677">这里的 server.listen 方法很重要，这部分<a href="https://github.com/nodejs/node/blob/15164cebcebfcad9822d3f065234a8c1511776a4/lib/net.js" data-nodeid="1865">源代码在这里</a>，其中的 server.listen 会调用该模块中的 listenInCluster 方法，该方法中有一个关键信息，如下代码所示：</p>\n<pre class="lang-javascript" data-nodeid="1678"><code data-language="javascript"><span class="hljs-keyword">if</span> (cluster.isPrimary || exclusive) {\n\t    <span class="hljs-comment">// Will create a new handle</span>\n\t    <span class="hljs-comment">// _listen2 sets up the listened handle, it is still named like this</span>\n\t    <span class="hljs-comment">// to avoid breaking code that wraps this method</span>\n\t    server._listen2(address, port, addressType, backlog, fd, flags);\n\t    <span class="hljs-keyword">return</span>;\n\t  }\n\t\n\t  <span class="hljs-keyword">const</span> serverQuery = {\n\t    <span class="hljs-attr">address</span>: address,\n\t    <span class="hljs-attr">port</span>: port,\n\t    <span class="hljs-attr">addressType</span>: addressType,\n\t    <span class="hljs-attr">fd</span>: fd,\n\t    flags,\n\t  };\n\t\n\t  <span class="hljs-comment">// Get the primary\'s server handle, and listen on it</span>\n\t  cluster._getServer(server, serverQuery, listenOnPrimaryHandle);\n</code></pre>\n<p data-nodeid="1679">上面代码中的第 6 行，判断为<strong data-nodeid="1880">主进程</strong>，就是<strong data-nodeid="1881">真实的监听端口启动服务</strong>，而如果非主进程则调用 cluster._getServer 方法，也就是 internal/cluster/child 中的 cluster._getServer 方法。</p>\n<p data-nodeid="1680">接下来我们看下这部分代码：</p>\n<pre class="lang-javascript" data-nodeid="1681"><code data-language="javascript">obj.once(<span class="hljs-string">\'listening\'</span>, () =&gt; {\n\t    cluster.worker.state = <span class="hljs-string">\'listening\'</span>;\n\t    <span class="hljs-keyword">const</span> address = obj.address();\n\t    message.act = <span class="hljs-string">\'listening\'</span>;\n\t    message.port = (address &amp;&amp; address.port) || options.port;\n\t    send(message);\n\t  });\n</code></pre>\n<p data-nodeid="1682">这一代码通过 send 方法，如果监听到 listening 发送一个消息给到主进程，主进程也有一个同样的 listening 事件，监听到该事件后将子进程通过 EventEmitter 绑定在主进程上，这样就完成了主子进程之间的<strong data-nodeid="1892">关联绑定</strong>，并且只监听了一个端口。而主子进程之间的通信方式，就是我们常听到的 <strong data-nodeid="1893">IPC 通信方式</strong>。</p>\n<p data-nodeid="1683"><strong data-nodeid="1897">负载均衡原理</strong></p>\n<p data-nodeid="1684">既然 Node.js cluster 模块使用的是主子进程方式，那么它是如何进行负载均衡处理的呢，这里就会涉及 Node.js cluster 模块中的两个模块。</p>\n<ul data-nodeid="1685">\n<li data-nodeid="1686">\n<p data-nodeid="1687"><a href="https://github.com/nodejs/node/blob/7397c7e4a303b1ebad84892872717c0092852921/lib/internal/cluster/round_robin_handle.js" data-nodeid="1905">round_robin_handle.js</a>（非 Windows 平台应用模式），这是一个<strong data-nodeid="1911">轮询处理模式</strong>，也就是轮询调度分发给空闲的子进程，处理完成后回到 worker 空闲池子中，这里要注意的就是如果绑定过就会复用该子进程，如果没有则会重新判断，这里可以通过上面的 app.js 代码来测试，用浏览器去访问，你会发现每次调用的子进程 ID 都会不变。</p>\n</li>\n<li data-nodeid="1688">\n<p data-nodeid="1689"><a href="https://github.com/nodejs/node/blob/7397c7e4a303b1ebad84892872717c0092852921/lib/internal/cluster/shared_handle.js" data-nodeid="1916">shared_handle.js</a>（ Windows 平台应用模式），通过将文件描述符、端口等信息传递给子进程，子进程通过信息创建相应的 SocketHandle / ServerHandle，然后进行相应的端口绑定和监听、处理请求。</p>\n</li>\n</ul>\n<p data-nodeid="1690">以上就是 cluster 的原理，总结一下就是 cluster 模块应用 child_process 来创建子进程，子进程通过复写掉 cluster._getServer 方法，从而在 server.listen 来保证只有主进程监听端口，主子进程通过 IPC 进行通信，其次主进程根据平台或者协议不同，应用两种不同模块（round_robin_handle.js 和 shared_handle.js）进行请求分发给子进程处理。接下来我们看一下 cluster 的成熟的应用工具 PM2 的应用和原理。</p>\n<h3 data-nodeid="1691">PM2 原理</h3>\n<p data-nodeid="1692">PM2 是<strong data-nodeid="1935">守护进程管理器</strong>，可以帮助你管理和保持应用程序在线。PM2 入门非常简单，它是一个简单直观的 CLI 工具，可以通过 NPM 安装，接下来我们看下一些简单的用法。</p>\n<h4 data-nodeid="1693">应用</h4>\n<p data-nodeid="1694">你可以使用如下命令进行 NPM 或者 Yarn 的安装：</p>\n<pre class="lang-java" data-nodeid="1695"><code data-language="java">$ npm install pm2@latest -g\n# or\n$ yarn global add pm2\n</code></pre>\n<p data-nodeid="1696">安装成功后，可以使用如下命令查看是否安装成功以及当前的版本：</p>\n<pre class="lang-java" data-nodeid="1697"><code data-language="java">$&nbsp;pm2 --version\n</code></pre>\n<p data-nodeid="1698">接下来我们使用 PM2 启动一个简单的 Node.js 项目，进入本讲代码的项目根目录，然后运行下面命令：</p>\n<pre class="lang-java" data-nodeid="1699"><code data-language="java">$&nbsp;pm2 start app.js\n</code></pre>\n<p data-nodeid="1700">运行后，再执行如下命令：</p>\n<pre class="lang-java" data-nodeid="1701"><code data-language="java">$&nbsp;pm2&nbsp;list\n</code></pre>\n<p data-nodeid="1702">可以看到如图 2 所示的结果，代表运行成功了。</p>\n<p data-nodeid="1703"><img src="https://s0.lgstatic.com/i/image6/M01/1D/E3/Cgp9HWBQKZeAM-MIAAB0_RHaw1E022.png" alt="Drawing 2.png" data-nodeid="1944"></p>\n<div data-nodeid="1704"><p style="text-align:center">图 2 pm2 list 运行结果</p></div>\n<p data-nodeid="1705">PM2 启动时可以带一些配置化参数，具体参数列表你可以参考<a href="https://pm2.keymetrics.io/docs/usage/pm2-doc-single-page/" data-nodeid="1948">官方文档</a>。在开发中我总结出了一套最佳的实践，如以下配置所示：</p>\n<pre class="lang-javascript" data-nodeid="1706"><code data-language="javascript"><span class="hljs-built_in">module</span>.exports = {\n    <span class="hljs-attr">apps</span> : [{\n      <span class="hljs-attr">name</span>: <span class="hljs-string">"nodejs-column"</span>, <span class="hljs-comment">// 启动进程名</span>\n      <span class="hljs-attr">script</span>: <span class="hljs-string">"./app.js"</span>, <span class="hljs-comment">// 启动文件</span>\n      <span class="hljs-attr">instances</span>: <span class="hljs-number">2</span>, <span class="hljs-comment">// 启动进程数</span>\n      <span class="hljs-attr">exec_mode</span>: <span class="hljs-string">\'cluster\'</span>, <span class="hljs-comment">// 多进程多实例</span>\n      <span class="hljs-attr">env_development</span>: {\n        <span class="hljs-attr">NODE_ENV</span>: <span class="hljs-string">"development"</span>,\n        <span class="hljs-attr">watch</span>: <span class="hljs-literal">true</span>, <span class="hljs-comment">// 开发环境使用 true，其他必须设置为 false</span>\n      },\n      <span class="hljs-attr">env_testing</span>: {\n        <span class="hljs-attr">NODE_ENV</span>: <span class="hljs-string">"testing"</span>,\n        <span class="hljs-attr">watch</span>: <span class="hljs-literal">false</span>, <span class="hljs-comment">// 开发环境使用 true，其他必须设置为 false</span>\n      },\n      <span class="hljs-attr">env_production</span>: {\n        <span class="hljs-attr">NODE_ENV</span>: <span class="hljs-string">"production"</span>,\n        <span class="hljs-attr">watch</span>: <span class="hljs-literal">false</span>, <span class="hljs-comment">// 开发环境使用 true，其他必须设置为 false</span>\n      },\n      <span class="hljs-attr">log_date_format</span>: <span class="hljs-string">\'YYYY-MM-DD HH:mm Z\'</span>,\n      <span class="hljs-attr">error_file</span>: <span class="hljs-string">\'~/data/err.log\'</span>, <span class="hljs-comment">// 错误日志文件，必须设置在项目外的目录，这里为了测试</span>\n      <span class="hljs-attr">out_file</span>: <span class="hljs-string">\'~/data/info.log\'</span>, <span class="hljs-comment">//  流水日志，包括 console.log 日志，必须设置在项目外的目录，这里为了测试</span>\n      <span class="hljs-attr">max_restarts</span>: <span class="hljs-number">10</span>,\n    }]\n  }\n</code></pre>\n<p data-nodeid="3650" class="te-preview-highlight">在上面的配置中要特别注意 <strong data-nodeid="3664">error_file</strong> 和 <strong data-nodeid="3665">out_file</strong>，这里的日志目录在项目初始化时要创建好，如果不提前创建好会导致线上运行失败，特别是无权限创建目录时。其次如果存在环境差异的配置时，可以放置在不同的环境下，最终可以使用下面三种方式来启动项目，分别对应不同环境。</p>\n\n\n\n<pre class="lang-shell" data-nodeid="1708"><code data-language="shell"><span class="hljs-meta">$</span><span class="bash"> pm2 start pm2.config.js --env development</span>\n<span class="hljs-meta">$</span><span class="bash"> pm2 start pm2.config.js --env testing</span>\n<span class="hljs-meta">$</span><span class="bash"> pm2 start pm2.config.js --env production</span>\n</code></pre>\n<h4 data-nodeid="1709">原理</h4>\n<p data-nodeid="1710">接下来我们来看下是如何实现的，由于整个项目是比较复杂庞大的，这里我们主要关注<strong data-nodeid="1971">进程创建管理的原理</strong>。</p>\n<p data-nodeid="1711">首先我们来看下进程创建的方式，整体的流程如图 3 所示。</p>\n<p data-nodeid="1712"><img src="https://s0.lgstatic.com/i/image6/M01/1D/E0/CioPOWBQKaWAHrR1AAKhg2CW1Z0319.png" alt="Drawing 3.png" data-nodeid="1975"></p>\n<div data-nodeid="1713"><p style="text-align:center">图 3 PM2 源码多进程创建方式</p></div>\n<p data-nodeid="1714">这一方式涉及五个模块文件。</p>\n<ul data-nodeid="1715">\n<li data-nodeid="1716">\n<p data-nodeid="1717">CLI（lib/binaries/CLI.js）处理命令行输入，如我们运行的命令：</p>\n</li>\n</ul>\n<pre class="lang-java" data-nodeid="1718"><code data-language="java">pm2 start pm2.config.js --env development\n</code></pre>\n<ul data-nodeid="1719">\n<li data-nodeid="1720">\n<p data-nodeid="1721">API（lib/API.js）对外暴露的各种命令行调用方法，比如上面的 start 命令对应的 API-&gt;start 方法。</p>\n</li>\n<li data-nodeid="1722">\n<p data-nodeid="1723">Client （lib/Client.js）可以理解为命令行接收端，负责创建守护进程 Daemon，并与 Daemon（lib/Daemon.js）保持 RPC 连接。</p>\n</li>\n<li data-nodeid="1724">\n<p data-nodeid="1725">God （lib/God.js）主要负责进程的创建和管理，主要是通过 Daemon 调用，Client 所有调用都是通过 RPC 调用 Daemon，然后 Daemon 调用 God 中的方法。</p>\n</li>\n<li data-nodeid="1726">\n<p data-nodeid="1727">最终在 God 中调用 ClusterMode（lib/God/ClusterMode.js）模块，在 ClusterMode 中调用 Node.js 的 cluster.fork 创建子进程。</p>\n</li>\n</ul>\n<p data-nodeid="1728">图 3 中首先通过命令行解析调用 API，API 中的方法基本上是与 CLI 中的命令行一一对应的，API 中的 start 方法会根据传入参数判断是否是调用的方法，一般情况下使用的都是一个 JSON 配置文件，因此调用 API 中的私有方法 _startJson。</p>\n<p data-nodeid="1729">接下来就开始在 Client 模块中流转了，在 _startJson 中会调用 executeRemote 方法，该方法会先判断 PM2 的守护进程 Daemon 是否启动，如果没有启动会先调用 Daemon 模块中的方法启动守护进程 RPC 服务，启动成功后再通知 Client 并建立 RPC 通信连接。</p>\n<p data-nodeid="1730">成功建立连接后，Client 会发送启动 Node.js 子进程的命令 prepare，该命令传递 Daemon，Daemon 中有一份对应的命令的执行方法，该命令最终会调用 God 中的 prepare 方法。</p>\n<p data-nodeid="1731">在 God 中最终会调用 God 文件夹下的 ClusterMode 模块，应用 Node.js 的 cluster.fork 创建子进程，这样就完成了整个启动过程。</p>\n<p data-nodeid="1732">综上所述，PM2 通过命令行，使用 RPC 建立 Client 与 Daemon 进程之间的通信，通过 RPC 通信方式，调用 God，从而应用 Node.js 的 cluster.fork 创建子进程的。以上是启动的流程，对于其他命令指令，比如 stop、restart 等，也是一样的通信流转过程，你参照上面的流程分析就可以了，如果遇到任何问题，都可以在留言区与我交流。</p>\n<blockquote data-nodeid="1733">\n<p data-nodeid="1734">以上的分析你需要参考<a href="https://github.com/Unitech/pm2/tree/64f8ea0f2c31c7d70a415eccc6222547b3664e65" data-nodeid="1994">PM2 的 GitHub 源码</a>。</p>\n</blockquote>\n<h3 data-nodeid="1735">总结</h3>\n<p data-nodeid="1736">本讲主要介绍了 Node.js 中的 cluster 模块，并深入介绍了其核心原理，其次介绍了目前比较常用的多进程管理工具 PM2 的应用和原理。学完本讲后，需要掌握 Node.js cluster 原理，并且掌握 PM2 的实现原理。</p>\n<p data-nodeid="1737">接下来我们将开始讲解一些关于 Node.js 性能相关的知识，为后续的高性能服务做一定的准备，其次也在为后续性能优化打下一定的技术基础。</p>\n<p data-nodeid="1738">下一讲会讲解，目前我们在使用的 Node.js cluster 模式存在的性能问题。</p>\n<hr data-nodeid="1739">\n<p data-nodeid="1740"><a href="https://shenceyun.lagou.com/t/mka" data-nodeid="2004"><img src="https://s0.lgstatic.com/i/image6/M00/12/FA/CioPOWBBrAKAAod-AASyC72ZqWw233.png" alt="Drawing 2.png" data-nodeid="2003"></a></p>\n<p data-nodeid="1741"><strong data-nodeid="2008">《大前端高薪训练营》</strong></p>\n<p data-nodeid="1742" class="">对标阿里 P7 技术需求 + 每月大厂内推，6 个月助你斩获名企高薪 Offer。<a href="https://shenceyun.lagou.com/t/mka" data-nodeid="2012">点击链接</a>，快来领取！</p>',
        article_title:
          "05 | 多进程解决方案：cluster 模式以及 PM2 工具的原理介绍",
        title: "05 | 多进程解决方案：cluster 模式以及 PM2 工具的原理介绍",
        id: 6787,
      },
      {
        content:
          '<p data-nodeid="1197" class="">Node.js 作为后台服务性能是非常关键的一点，而影响 Node.js 的性能不仅仅要考虑其本身的因素，还应该考虑所在服务器的一些因素。前面我们介绍的 Node.js 的事件循环机制和 cluster 模式就是一种 Node.js 潜在的内在因素，而网络 I/O 、磁盘 I/O 以及其他内存、句柄的一些问题则是因为服务器的资源因素导致的性能问题。本讲就详细地分析影响其性能的因素原因，以及部分的优化解决方案。</p>\n<h3 data-nodeid="1198">代码逻辑</h3>\n<p data-nodeid="1199">影响性能的一个最大的原因就是在写 Node.js 代码时，没有注重性能影响问题，接下来我们就从三个方面来分析下到底哪些代码会出现性能影响。</p>\n<h4 data-nodeid="1200">1.CPU 密集型计算</h4>\n<p data-nodeid="1496" class="">CPU 负责了程序的运行和业务逻辑的处理，而 CPU 密集型表示的主要是 <strong data-nodeid="1502">CPU 承载了比较复杂的运算</strong>。</p>\n\n<p data-nodeid="1202">在 Node.js 中由于主线程是单线程的（这部分知识点，在<a href="https://kaiwu.lagou.com/course/courseInfo.htm?courseId=694#/detail/pc?id=6783" data-nodeid="1306">《01 | 事件循环：高性能到底是如何做到的？》</a>中已经非常详细地讲解了），无论是主线程逻辑，还是回调处理逻辑，最终都是在主线程处理，那么如果该线程一直在处理复杂的计算，其他请求就无法再次进来，也就是单个用户就可以阻塞所有用户的请求。因此保持主线程的通畅是非常关键的。</p>\n<p data-nodeid="1203">在 Node.js 中有以下几种情况，会影响到主线程的运行，应该主动避免：</p>\n<ul data-nodeid="1204">\n<li data-nodeid="1205">\n<p data-nodeid="1206"><strong data-nodeid="1313">大的数据循环</strong>，比如没有利用好数据流，一次性处理非常大的数组；</p>\n</li>\n<li data-nodeid="1207">\n<p data-nodeid="1208"><strong data-nodeid="1318">字符串处理转化</strong>，比如加解密、字符串序列化等；</p>\n</li>\n<li data-nodeid="1209">\n<p data-nodeid="1210"><strong data-nodeid="1327">图片</strong>、<strong data-nodeid="1328">视频的计算处理</strong>，比如对图片进行裁剪、缩放或者切割等。</p>\n</li>\n</ul>\n<p data-nodeid="1211">接下来举个实际例子，假设我们现在有 2 个功能：</p>\n<ul data-nodeid="1212">\n<li data-nodeid="1213">\n<p data-nodeid="1214">大数组的循环；</p>\n</li>\n<li data-nodeid="1215">\n<p data-nodeid="1216">一个非常简单的 Hello World 输出。</p>\n</li>\n</ul>\n<p data-nodeid="1217">再来看下因为大计算的逻辑如何影响了其他逻辑的处理，代码如下（请注意这里会应用 MSVC 框架来实现，因此我们只看 Controller 部分逻辑）：</p>\n<pre class="lang-javascript" data-nodeid="1218"><code data-language="javascript"><span class="hljs-keyword">const</span> Controller = <span class="hljs-built_in">require</span>(<span class="hljs-string">\'../core/controller\'</span>);\n<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Controller</span> </span>{\n    <span class="hljs-keyword">constructor</span>(res, req) {\n        <span class="hljs-keyword">super</span>(res, req);\n    }\n    <span class="hljs-comment">/**\n     * 复杂运算\n     */</span>\n    bad() {\n        <span class="hljs-keyword">let</span> sum = <span class="hljs-number">0</span>;\n        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">10000000000</span>; i++){\n            sum = sum + i;\n        }\n\n        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.resApi(<span class="hljs-literal">true</span>, <span class="hljs-string">\'success\'</span>, {<span class="hljs-string">\'sum\'</span> : sum});\n    }\n    <span class="hljs-comment">/**\n     * 正常请求\n     */</span>\n    normal() {\n        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.resApi(<span class="hljs-literal">true</span>, <span class="hljs-string">\'good\'</span>, <span class="hljs-string">\'hello world\'</span>);\n    }\n}\n<span class="hljs-built_in">module</span>.exports = Test;\n</code></pre>\n<p data-nodeid="1219">这段代码中 bad 是一个复杂的 CPU 计算，而 normal 是一个正常的请求。</p>\n<p data-nodeid="1220">接下来我们使用 PM2 将服务运行，也可以直接运行（作为后台进程服务，建议后续都使用 PM2 来运行）。</p>\n<pre class="lang-java" data-nodeid="1221"><code data-language="java">$ pm2 start pm2.config.js --env=development\n或者\n$ node index\n</code></pre>\n<p data-nodeid="1222">运行成功后，我们在浏览器可以多次访问该地址：</p>\n<pre class="lang-java" data-nodeid="1223"><code data-language="java">http:<span class="hljs-comment">//127.0.0.1:3000/v1/normal</span>\n或者在命令行运行\n$ time curl http:<span class="hljs-comment">//127.0.0.1:3000/v1/normal</span>\n</code></pre>\n<p data-nodeid="1224">不管如何访问，响应速度都是非常快的，那么接下来我们打开浏览器的另外一个窗口，访问如下地址：</p>\n<pre class="lang-java" data-nodeid="1225"><code data-language="java">http:<span class="hljs-comment">//127.0.0.1:3000/v1/cpu</span>\n或者运行 \n$ time curl http:<span class="hljs-comment">//127.0.0.1:3000/v1/cpu</span>\n</code></pre>\n<p data-nodeid="1226">你再切换到 normal 的请求链接，会发现响应时间变得非常慢了。</p>\n<p data-nodeid="1227">这样就会因为某些用户的复杂运算，而影响到整个系统的请求处理，如果这种复杂运算占用的 CPU 时间越久，那么就会导致请求堆积，而这就会进一步导致系统处于崩溃状态无法恢复。</p>\n<h4 data-nodeid="1228">2.网络 I/O</h4>\n<p data-nodeid="1229">网络 I/O 中有 2 种相关的类型，同步阻塞 I/O 和 异步非阻塞 I/O：</p>\n<ul data-nodeid="1230">\n<li data-nodeid="1231">\n<p data-nodeid="1232"><strong data-nodeid="1345">同步阻塞 I/O</strong>的字面意思是发出网络请求后需要等待返回后，再处理其他计算；</p>\n</li>\n<li data-nodeid="1233">\n<p data-nodeid="1234"><strong data-nodeid="1350">异步非阻塞 I/O</strong>就是发起网络 I/O 后，还可以处理其他的计算，这也是为什么 Node.js 在处理网络 I/O 性能较高的原因。</p>\n</li>\n</ul>\n<p data-nodeid="1235">举个例子，假设我们有个功能需要访问一个 API 的数据，Node.js 调用 API 就是一种网络 I/O：</p>\n<ul data-nodeid="1236">\n<li data-nodeid="1237">\n<p data-nodeid="1238">如果该 API 处理慢，那么则所有用户请求都被阻塞了；</p>\n</li>\n<li data-nodeid="1239">\n<p data-nodeid="1240">而如果异步的话，则无须等待处理，可以继续其他的运行。</p>\n</li>\n</ul>\n<p data-nodeid="2101" class="">在 CPU 例子中，我们有一种办法就是将 CPU 密集型计算使用其他进程来处理，那么这里我们可以来做一个简单的测试，启用 2 个服务，一个是使用 <strong data-nodeid="2107">CPU 密集型计算</strong>（保留上面 CPU 的服务、代码不变）、另外一个则是正常请求的，这部分 Controller 代码如下：</p>\n\n<pre class="lang-javascript" data-nodeid="1242"><code data-language="javascript"><span class="hljs-keyword">const</span> rp = <span class="hljs-built_in">require</span>(<span class="hljs-string">\'request-promise\'</span>);\n<span class="hljs-keyword">const</span> Controller = <span class="hljs-built_in">require</span>(<span class="hljs-string">\'../core/controller\'</span>);\n<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Controller</span> </span>{\n    <span class="hljs-keyword">constructor</span>(res, req) {\n        <span class="hljs-keyword">super</span>(res, req);\n    }\n    <span class="hljs-comment">/**\n     * 复杂运算，使用网络 I/O 调用\n     */</span>\n    <span class="hljs-keyword">async</span> bad() {\n        <span class="hljs-keyword">let</span> result = <span class="hljs-keyword">await</span> rp.get(<span class="hljs-string">\'http://127.0.0.1:3000/v1/cpu\'</span>);\n\n        <span class="hljs-keyword">let</span> sumData = <span class="hljs-built_in">JSON</span>.parse(result);\n        <span class="hljs-keyword">let</span> sum = sumData &amp;&amp; sumData.data ? sumData.data.sum : <span class="hljs-literal">false</span>;\n        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.resApi(<span class="hljs-literal">true</span>, <span class="hljs-string">\'success\'</span>, {<span class="hljs-string">\'sum\'</span> : sum});\n    }\n    <span class="hljs-comment">/**\n     * 正常请求\n     */</span>\n    normal() {\n        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.resApi(<span class="hljs-literal">true</span>, <span class="hljs-string">\'good\'</span>, <span class="hljs-string">\'hello world io\'</span>);\n    }\n}\n<span class="hljs-built_in">module</span>.exports = Test;\n</code></pre>\n<p data-nodeid="1243">这部分代码和上面 CPU 代码例子唯一不同在于<strong data-nodeid="1365">bad 函数中复杂的运算使用了网络 I/O</strong>，这样就不会影响 normal 的请求了。</p>\n<p data-nodeid="1244">接下来我们将 CPU 部分的服务启动，然后在浏览器再次访问。</p>\n<pre class="lang-java" data-nodeid="1245"><code data-language="java">http:<span class="hljs-comment">//127.0.0.1:4000/v1/cpu</span>\nhttp:<span class="hljs-comment">//127.0.0.1:4000/v1/normal</span>\n</code></pre>\n<p data-nodeid="1246">你会发现虽然 /v1/cpu 很慢，但是并不影响 /v1/normal 的请求，这就是我们上面介绍到的为什么 Node.js 适合网络 I/O 密集型的服务的原因了。</p>\n<p data-nodeid="4518" class="">从上面的例子中，看到了网络 I/O 其实是 Node.js 的优势，虽然不影响主线程的处理，但是对于 <a href="http://127.0.0.1:4000/v1/cpu" data-nodeid="4522">http://127.0.0.1:4000/v1/cpu</a> 这个请求，如果要提升性能，我们应该关注什么呢？</p>\n\n\n\n\n<ul data-nodeid="1248">\n<li data-nodeid="1249">\n<p data-nodeid="1250"><strong data-nodeid="1377">通道复用</strong>，比如我们现在每次访问 :4000/v1/cpu 时都会发起一个 TCP 到 :3000/v1/cpu，如果能够通道复用，减少 TCP 握手，那么就可以提升该接口的性能，或者将某些内部服务使用 UDP 来实现。</p>\n</li>\n<li data-nodeid="1251">\n<p data-nodeid="1252"><strong data-nodeid="1382">增加缓存</strong>，对于相同响应的返回数据，增加缓存处理，避免不必要的计算，对于上面的计算，我们完全可以缓存计算结果，这样来减少网络 I/O。</p>\n</li>\n<li data-nodeid="1253">\n<p data-nodeid="1254"><strong data-nodeid="1387">长链接链接池</strong>，有一些网络 I/O 是长链接的形式，比如 MySQL、Mamcached 或者 Redis，为了避免排队使用长链接的问题，可以使用链接池，而由于 Redis 和 Node.js 是单线程非阻塞处理，因此可以不用链接池。</p>\n</li>\n</ul>\n<p data-nodeid="1255">网络 I/O 一般不影响主线程逻辑，往往<strong data-nodeid="1393">网络 I/O 请求的服务反而是瓶颈端</strong>，从而影响 Node.js 中涉及该网络服务的请求。其次网络 I/O 堆积较多会侧面影响：</p>\n<ul data-nodeid="1256">\n<li data-nodeid="1257">\n<p data-nodeid="1258">服务器本身的网络模块问题；</p>\n</li>\n<li data-nodeid="1259">\n<p data-nodeid="1260">Node.js 性能，导致其他服务接口受影响。</p>\n</li>\n</ul>\n<p data-nodeid="1261">因此在网络 I/O 瓶颈时需要考虑修改服务器网络相关的配置。</p>\n<h4 data-nodeid="1262">3.磁盘 I/O</h4>\n<p data-nodeid="1263">和网络 I/O 相似，在一般情况下磁盘 I/O 是不会影响到主线程性能的，这里就不举例子了，因为磁盘 I/O 也是异步其他线程处理。这里所说的也不是主线程的问题，而是涉及磁盘 I/O 的服务请求。因为服务器的<strong data-nodeid="1403">磁盘性能</strong>是一定的，如果在高并发情况下，磁盘 I/O 压力较大，从而导致磁盘 I/O 的服务性能下降。</p>\n<p data-nodeid="1264">在实际开发过程中，最常见的磁盘 I/O 场景，那就是<strong data-nodeid="1409">日志模块</strong>，因为日志是需要写文件，从而会有频繁的日志写入。和网络 I/O 相似，磁盘 I/O 也会从侧面的影响机器性能，导致 Node.js 服务性能受影响。</p>\n<p data-nodeid="1265">在上面 3 种情况中，只有<strong data-nodeid="1425">CPU 密集计算会真正影响到 Node.js 服务性能</strong>，<strong data-nodeid="1426">而网络 I/O 和磁盘 I/O 都是直接影响服务器性能</strong>，<strong data-nodeid="1427">从而侧面影响到 Node.js 服务性能</strong>，一般这时候就需要调整服务器配置或者做一些队列优化方式来提升服务器性能，这点我们在《12 | 性能分析：性能影响的关键路径以及优化策略》将会介绍。</p>\n<h3 data-nodeid="1266">集群服务</h3>\n<p data-nodeid="1267"><strong data-nodeid="1433">后台服务一般都有集群的概念</strong>，无论是多机器部署，还是单机器（Node.js cluster 模式），具体我们画一个集群的架构例子，如图 1 所示。在进程分发的主节点 Nginx 和 Master 都可能会存在性能影响因素点，本讲核心是介绍 Node.js，因此我们主要看 cluster 模式的性能影响问题。</p>\n<p data-nodeid="1268"><img src="https://s0.lgstatic.com/i/image6/M00/1D/E1/CioPOWBQK0GAZFfaAABsROVQ92Y096.png" alt="Drawing 1.png" data-nodeid="1436"></p>\n<h4 data-nodeid="1269">1.多进程 cluster 模式</h4>\n<p data-nodeid="1270">在上一讲中我们详细地介绍了 cluster 模式，在实际应用过程中这种模式也是存在性能瓶颈问题的。我们在上一讲中讲到的 cluster 模式，如图 2 所示。</p>\n<p data-nodeid="1271"><img src="https://s0.lgstatic.com/i/image6/M00/1D/E1/CioPOWBQK0mAAVVQAAB3dogpY-k967.png" alt="Drawing 3.png" data-nodeid="1441"></p>\n<p data-nodeid="1272">你会发现这种模式的主进程也就是上一讲中的<strong data-nodeid="1447">master 进程</strong>会存在瓶颈，因为所有的请求都必须经过 master 进程进行分发，同时接收处理 worker 进程的返回。</p>\n<p data-nodeid="1273">在实际开发过程中，遇到一个问题，由于我们所用机器是一个 96 核以上的服务器，因此启用了比较多的 worker 进程，而主进程只有一个，从而在单机高并发时（2 万以上的每秒并发请求）会导致 master 进程处理瓶颈，这样就影响到了服务性能，并且这时候你会发现 worker 进程的 CPU 并没有任何压力。</p>\n<p data-nodeid="1274">以上这点非常重要，在生产环境下一般很难发现这类问题，不过你应该有一个这样的概念：大概在 2 万以上的并发时，master 进程会存在性能瓶颈。</p>\n<h3 data-nodeid="1275">其他相关</h3>\n<p data-nodeid="1276">对于 Node.js 后台服务，我们不仅仅要考虑其本身的性能影响，更应该考虑它对服务器资源竞争产生的性能影响。比如<strong data-nodeid="1456">无节制地使用服务器的内存或者句柄</strong>，都会导致服务器的异常，而服务器的异常则从侧面影响到 Node.js 本身的性能。</p>\n<h4 data-nodeid="1277">1.内存限制</h4>\n<p data-nodeid="1278">在 32 位服务器上 Node.js 的内存限制是 0.7 G，而在 64 位服务器上则是 1.4 G，而这个限制主要是因为 Node.js 的垃圾回收线程在超过限制内存时，回收时长循环会大于 1s，从而会影响性能问题。</p>\n<p data-nodeid="1279">现网我们一般会<strong data-nodeid="1464">启用多个进程</strong>，如果每个进程损耗 1.4 G，那么加起来可能超出了服务器内存上限，从而导致服务器瘫痪。其次如果内存不会超出服务器上限，而是在达到一定上限时，也就是我们上面说的 0.7 G和 1.4 G，会导致服务器重启，从而会导致接口请求失败的问题。</p>\n<h4 data-nodeid="1280">2.句柄限制</h4>\n<p data-nodeid="5122" class="te-preview-highlight">句柄可以简单理解为一个 <strong data-nodeid="5128">ID 索引</strong>，通过这个索引可以访问到其他的资源，比如说文件句柄、网络 I/O 操作句柄等等，而一般服务器句柄都有上限。当 Node.js 没有控制好句柄，比如说无限的打开文件并未关闭，就会出现句柄泄漏问题，而这样会导致服务器异常，从而影响 Node.js 服务。</p>\n\n<p data-nodeid="1282">以上这两点我们都需要有一定的工具检测方法，<strong data-nodeid="1477">在服务上限之前进行检测</strong>，其次也需要有一定的定位的方法，在出现现网异常时，能够定位出具体的问题，这也就是我们接下来会涉及的知识点。</p>\n<h3 data-nodeid="1283">总结</h3>\n<p data-nodeid="1284">本讲介绍了影响 Node.js 后台服务的代码因素、cluster 模式因素以及其他服务器资源相关的因素。学完本讲后，要了解哪些直接影响性能，哪些是从侧面也就是因为服务器资源问题导致的性能下降原因。本讲中的几个知识点，也是面试中常见的面试题，希望你能牢记这些知识点，这些也是我们后续章节中经常会被提及的一些知识。</p>\n<p data-nodeid="1285">那这一讲学完，你有什么心得或者问题吗？欢迎在评论区与我讨论。</p>\n<p data-nodeid="1286">下一讲将会为你讲解“CPU 过载保护设计：如何在服务层面确保系统稳定”。</p>\n<hr data-nodeid="1287">\n<p data-nodeid="1288"><a href="https://shenceyun.lagou.com/t/mka" data-nodeid="1486"><img src="https://s0.lgstatic.com/i/image6/M00/12/FA/CioPOWBBrAKAAod-AASyC72ZqWw233.png" alt="Drawing 2.png" data-nodeid="1485"></a></p>\n<p data-nodeid="1289"><strong data-nodeid="1490">《大前端高薪训练营》</strong></p>\n<p data-nodeid="1290" class="">对标阿里 P7 技术需求 + 每月大厂内推，6 个月助你斩获名企高薪 Offer。<a href="https://shenceyun.lagou.com/t/mka" data-nodeid="1494">点击链接</a>，快来领取！</p>',
        article_title: "06 | 哪些因素会影响 Node.js 性能？",
        title: "06 | 哪些因素会影响 Node.js 性能？",
        id: 6788,
      },
      {
        content:
          '<p data-nodeid="4735" class="">上一讲我们介绍了影响 Node.js 服务性能的一个关键点，也就是 <strong data-nodeid="4871">CPU 的密集型计算</strong>，通过例子，你可以看到只要出现这类请求，基本就会导致服务器瘫痪。那么是否有办法来保护我们的服务呢？比如说我们是否可以丢弃部分 /v1/cpu 的请求，但是可以正常响应 /v1/normal 的用户请求，这就是我们这一讲要介绍的知识点，也就是 CPU 过载保护机制。</p>\n<h3 data-nodeid="4736">过载保护</h3>\n<p data-nodeid="4737">假设一种场景，我们去银行办事，大家都知道需要拿号排队，银行每 10 分钟处理 1 个人的业务，而每 10 分钟会进来 2 个人，这样每 10 分钟就会积压一个用户，然后偶数进来的用户还需要多等 10 分钟，从而就会导致每个人的等待时长是 ((n + 1) / 2 - 1 + (n + 1) % 2) * 10。</p>\n<p data-nodeid="4738">其中变量 n 为第几个进来的用户。随着 n 越大，等待的时间就越长，如果没有及时制止，银行将永远都是饱和状态。长时间饱和工作状态，银行人员将会很辛苦，从而无法更好服务用户。一般情况下，在银行都会有一定的取号上限或者保安会提示无法再服务了，这就是一个<strong data-nodeid="4881">过载的保护</strong>，避免因事务积压，导致系统无法提供更好的服务。</p>\n<p data-nodeid="4739">以上是一个简单的例子，接下来我们从技术层面介绍过载保护概念，而由于 Node.js 最大的性能损耗又在于 CPU，因此又需要进一步了解什么是 CPU 的过载保护。</p>\n<h4 data-nodeid="4740">1.什么是过载保护</h4>\n<p data-nodeid="4741"><strong data-nodeid="4888">这个词最早出现是在电路方面</strong>，在出现短路或者电压承载过大时，会触发电源的过载保护设备，该设备要不熔断、要不跳闸切断电源。</p>\n<p data-nodeid="4742">在服务端也是相似的原理，首先我们需要设计一个过载保护的服务，在过载触发时，切断用户服务直接返回报错，在压力恢复时，正常响应用户请求。</p>\n<h4 data-nodeid="4743">2.CPU 过载保护</h4>\n<p data-nodeid="4744">在 Node.js 中最大的瓶颈在于 CPU，因此我们需要针对 CPU 的过载进行保护。当 CPU 使用率超出一定范围时，进行请求熔断处理，直接报错返回，接下来我们来看下具体的实现原理。</p>\n<h3 data-nodeid="4745">实现方案</h3>\n<p data-nodeid="4746">在实现方案前，我们需要思考几个关键的问题：</p>\n<ul data-nodeid="4747">\n<li data-nodeid="4748">\n<p data-nodeid="4749">获取当前进程所在的 CPU 使用率的方法；</p>\n</li>\n<li data-nodeid="4750">\n<p data-nodeid="4751">应尽量避免影响服务性能；</p>\n</li>\n<li data-nodeid="4752">\n<p data-nodeid="4753">什么时候触发过载，能否减少误处理情况；</p>\n</li>\n<li data-nodeid="4754">\n<p data-nodeid="4755">请求丢弃方法和优先级；</p>\n</li>\n</ul>\n<p data-nodeid="4756">接下来我们看下这几个部分的实现方法。</p>\n<h4 data-nodeid="4757">1.获取 CPU 使用率</h4>\n<p data-nodeid="4758">Node.js 进程启动后，都会绑定在单核 CPU 上。假设机器有 2 个 CPU 内核，我们只启动了一个进程，那么在没有其他外在因素影响的情况下，Node.js 即使跑满 CPU，也最多只占用了 50% 的总机器的 CPU 利用率。因此这里我需要获取该进程 CPU 使用率。</p>\n<p data-nodeid="4759"><strong data-nodeid="4913">我们需要获取当前进程下的 CPU 使用情况，而不是整体机器的 CPU</strong>，<strong data-nodeid="4914">因此需要使用 PS 这个命令，而不是利用 Node.js 本身的 OS 模块</strong>。这里我们以 Mac 为例子，其他部分你可以参考 <a href="https://github.com/love-flutter/nodejs-column" data-nodeid="4911">GitHub 源码</a>。</p>\n<p data-nodeid="4760">首先我们需要使用一个命令：</p>\n<pre class="lang-java" data-nodeid="4761"><code data-language="java">$ ps -p ${process.pid} -o pid,rss,vsz,pcpu,comm\n</code></pre>\n<p data-nodeid="4762">这一命令是<strong data-nodeid="4921">获取当前 Node.js 进程下的进程信息</strong>：</p>\n<ul data-nodeid="4763">\n<li data-nodeid="4764">\n<p data-nodeid="4765"><strong data-nodeid="4926">pid 是进程 ID</strong>；</p>\n</li>\n<li data-nodeid="4766">\n<p data-nodeid="4767"><strong data-nodeid="4931">rss 是实际内存占用</strong>；</p>\n</li>\n<li data-nodeid="4768">\n<p data-nodeid="4769"><strong data-nodeid="4936">vsz 是虚拟内存占用</strong>；</p>\n</li>\n<li data-nodeid="4770">\n<p data-nodeid="4771"><strong data-nodeid="4941">pcpu 是 CPU 使用率</strong>；</p>\n</li>\n<li data-nodeid="4772">\n<p data-nodeid="4773"><strong data-nodeid="4946">comm 是进程执行的指令</strong>。</p>\n</li>\n</ul>\n<p data-nodeid="4774">在 Linux 或者 Mac 系统中可以直接运行以上命令，查看某些进程的信息。</p>\n<p data-nodeid="4775">有了命令后，我们需要在 Node.js 中执行修改命令，并获取执行结果，以下代码就是在 Node.js 执行修改命令的方法。</p>\n<pre class="lang-javascript" data-nodeid="4776"><code data-language="javascript"><span class="hljs-comment">/**\n * <span class="hljs-doctag">@description </span>使用 ps 命令获取进程信息\n */</span>\n<span class="hljs-keyword">async</span> _getPs() {\n    <span class="hljs-comment">// 命令行</span>\n    <span class="hljs-keyword">const</span> cmd = <span class="hljs-string">`ps -p <span class="hljs-subst">${process.pid}</span> -o pid,rss,vsz,pcpu,comm`</span>;\n    <span class="hljs-comment">// 获取执行结果</span>\n    <span class="hljs-keyword">const</span> { stdout, stderr } = <span class="hljs-keyword">await</span> exec(cmd);\n    <span class="hljs-keyword">if</span>(stderr) { <span class="hljs-comment">// 异常情况</span>\n      <span class="hljs-built_in">console</span>.log(stderr);\n      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;\n    }\n    <span class="hljs-keyword">return</span> stdout;\n}\n</code></pre>\n<p data-nodeid="4777"><strong data-nodeid="4953">在上面代码中 exec 是一个经过 util.promisify 处理的方法，而不是 Node.js 原生模块的 exec 方法</strong>，处理逻辑如下：</p>\n<pre class="lang-javascript" data-nodeid="4778"><code data-language="javascript"><span class="hljs-keyword">const</span> util = <span class="hljs-built_in">require</span>(<span class="hljs-string">\'util\'</span>);\n<span class="hljs-keyword">const</span> exec = util.promisify(<span class="hljs-built_in">require</span>(<span class="hljs-string">\'child_process\'</span>).exec);\n</code></pre>\n<p data-nodeid="4779">获取到进程信息后，我们需要将进程信息转化为相应的数据对象，具体方法如下：</p>\n<pre class="lang-javascript te-preview-highlight" data-nodeid="5143"><code data-language="javascript"><span class="hljs-comment">/**\n * <span class="hljs-doctag">@description </span>获取进程信息\n */</span>\n<span class="hljs-keyword">async</span> _getProcessInfo() {\n    <span class="hljs-keyword">let</span> pidInfo, cpuInfo;\n\n    <span class="hljs-keyword">if</span> (platform === <span class="hljs-string">\'win32\'</span>) { <span class="hljs-comment">// windows 平台</span>\n      pidInfo = <span class="hljs-keyword">await</span> <span class="hljs-keyword">this</span>._getWmic();\n    } <span class="hljs-keyword">else</span> { <span class="hljs-comment">// 其他平台 linux &amp; mac</span>\n      pidInfo = <span class="hljs-keyword">await</span> <span class="hljs-keyword">this</span>._getPs();\n    }\n    cpuInfo = <span class="hljs-keyword">await</span> <span class="hljs-keyword">this</span>._parseInOs(pidInfo);\n\n    <span class="hljs-keyword">if</span>(!cpuInfo) { <span class="hljs-comment">// 异常处理</span>\n      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;\n    }\n    <span class="hljs-comment">/// 命令行数据，字段解析处理</span>\n    <span class="hljs-keyword">const</span> pid = <span class="hljs-built_in">parseInt</span>(cpuInfo.pid, <span class="hljs-number">10</span>);\n    <span class="hljs-keyword">const</span> name = cpuInfo.name.substr(cpuInfo.name.lastIndexOf(<span class="hljs-string">\'/\'</span>) + <span class="hljs-number">1</span>);\n    <span class="hljs-keyword">const</span> cpu = <span class="hljs-built_in">parseFloat</span>(cpuInfo.cpu);\n    <span class="hljs-keyword">const</span> mem = {\n    <span class="hljs-attr">private</span>: <span class="hljs-built_in">parseInt</span>(cpuInfo.pmem, <span class="hljs-number">10</span>),\n      <span class="hljs-attr">virtual</span>: <span class="hljs-built_in">parseInt</span>(cpuInfo.vmem, <span class="hljs-number">10</span>),\n      <span class="hljs-attr">usage</span>: cpuInfo.pmem / totalmem * <span class="hljs-number">100</span>\n    };\n\n    <span class="hljs-keyword">return</span> {\n      pid, name, cpu, mem\n    }\n}\n</code></pre>\n\n<p data-nodeid="4781">在上面代码中，一开始需要根据平台的不同，<strong data-nodeid="4960">调用不同的命令来获取进程信息</strong>。其他基本上都是一些字符串的处理，没有什么特殊的逻辑。</p>\n<p data-nodeid="4782">以上就是一个获取当前进程的相关信息的方法，其中的 usage 就是 CPU 相关的信息，由于还是涉及非常多的逻辑处理和计算，因此我们需要思考如何简化方式，减少对主线程 CPU 性能损耗。</p>\n<h4 data-nodeid="4783">2.性能影响</h4>\n<p data-nodeid="4784">由于在 Node.js 就只有一个主线程，因此<strong data-nodeid="4968">必须严格减少框架在主线程的占用时间，控制框架基础模块的性能损耗，从而将主线程资源更多服务于业务，增强业务并发处理能力</strong>。为了满足这点，我们需要做两件事情：</p>\n<ul data-nodeid="4785">\n<li data-nodeid="4786">\n<p data-nodeid="4787"><strong data-nodeid="4973">只处理需要的数据</strong>，因此在第一步获取 CPU 使用率的基础上，我们需要缩减一些字段，只获取 CPU 信息即可；</p>\n</li>\n<li data-nodeid="4788">\n<p data-nodeid="4789"><strong data-nodeid="4978">定时落地 CPU 信息到内存中</strong>，而非根据用户访问来实时计算。</p>\n</li>\n</ul>\n<p data-nodeid="4790">在第一点上，我们把原来获取的 pid、rss、vsz、comm 全部去掉，只留下 pcpu，然后将逻辑优化。第二点则需要定时设置内存中的 CPU 使用率，这部分代码如下：</p>\n<pre class="lang-javascript" data-nodeid="4791"><code data-language="javascript"><span class="hljs-keyword">async</span> check(maxOverloadNum =<span class="hljs-number">30</span>, maxCpuPercentage=<span class="hljs-number">80</span>) {\n     <span class="hljs-comment">/// 定时处理逻辑</span>\n     setInterval(<span class="hljs-keyword">async</span> () =&gt; {\n        <span class="hljs-keyword">try</span> {\n            <span class="hljs-keyword">const</span> cpuInfo = <span class="hljs-keyword">await</span> <span class="hljs-keyword">this</span>._getProcessInfo();\n            <span class="hljs-keyword">if</span>(!cpuInfo) { <span class="hljs-comment">// 异常不处理</span>\n                <span class="hljs-keyword">return</span>;\n            }\n            <span class="hljs-keyword">if</span>(cpuInfo &gt; maxCpuPercentage) {\n                overloadTimes++;\n            } <span class="hljs-keyword">else</span> {\n                overloadTimes = <span class="hljs-number">0</span>;\n                <span class="hljs-keyword">return</span> isOverload = <span class="hljs-literal">false</span>;\n            }\n            <span class="hljs-keyword">if</span>(overloadTimes &gt; maxOverloadNum){\n                isOverload = <span class="hljs-literal">true</span>;\n            }\n        } <span class="hljs-keyword">catch</span>(err){\n            <span class="hljs-built_in">console</span>.log(err);\n            <span class="hljs-keyword">return</span>;\n        }\n    }, <span class="hljs-number">2000</span>);\n}\n</code></pre>\n<p data-nodeid="4792">上面代码中使用了 <strong data-nodeid="4985">setInterval</strong> 来实现，每秒执行一次。在代码中的两个参数 maxOverloadNum 和 maxCpuPercentage：</p>\n<ul data-nodeid="4793">\n<li data-nodeid="4794">\n<p data-nodeid="4795">maxOverloadNum 表示最大持续超出负载次数，当大于该值时才会判断为超出负载了；</p>\n</li>\n<li data-nodeid="4796">\n<p data-nodeid="4797">maxCpuPercentage 表示单次 CPU 使用率是否大于该分位值，大于则记录一次超载次数。</p>\n</li>\n</ul>\n<p data-nodeid="4798">最后我们再看下应用的地方，如下所示，整个代码在 <a href="https://github.com/love-flutter/nodejs-column" data-nodeid="4991">GitHub 项目</a>的 index.js 文件中。</p>\n<pre class="lang-javascript" data-nodeid="4799"><code data-language="javascript">cpuOverload.check().then().catch(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> {\n<span class="hljs-built_in">console</span>.log(err)\n});\n</code></pre>\n<p data-nodeid="4800">上面代码主要是调用 <strong data-nodeid="4998">check 方法</strong>，并且用来捕获异常，避免引起服务器崩溃。</p>\n<h4 data-nodeid="4801">3.概率丢弃</h4>\n<p data-nodeid="4802">在获取 CPU 值以后，我们可以根据当前 CPU 的情况进行一些丢弃处理，但是应尽量避免出现<strong data-nodeid="5009">误处理</strong>的情况。比如当前 CPU 某个时刻出现了过高，但是立马恢复了，这种情况下我们是不能进行丢弃请求的，<strong data-nodeid="5010">只有当 CPU 长期处于一个高负载情况下才能进行请求丢弃</strong>。</p>\n<p data-nodeid="4803">即使要丢请求，也需要根据概率来丢弃，而不是每个请求都丢弃，我们需要根据三个变量：</p>\n<ul data-nodeid="4804">\n<li data-nodeid="4805">\n<p data-nodeid="4806"><strong data-nodeid="5018">overloadTimes</strong>，用 o 表示，指 CPU 过载持续次数，该值越高则丢弃概率越大，设定取值范围为 0 ~ 10；</p>\n</li>\n<li data-nodeid="4807">\n<p data-nodeid="4808"><strong data-nodeid="5025">currentCpuPercentage</strong>，用 c 表示，指 CPU 当前负载越高，占用率越大则丢弃概率越大，这里设定范围为 0 ~ 10，10 代表是最大值 100% ；</p>\n</li>\n<li data-nodeid="4809">\n<p data-nodeid="4810"><strong data-nodeid="5032">baseProbability</strong>，用 b 表示，是负载最大时的丢弃概率，取值范围为 0 ~ 1。</p>\n</li>\n</ul>\n<p data-nodeid="4811">虽然都是<strong data-nodeid="5038">正向反馈</strong>，但是三者对结果影响是不同的：</p>\n<ul data-nodeid="4812">\n<li data-nodeid="4813">\n<p data-nodeid="4814"><strong data-nodeid="5043">overloadTimes 可以看作是直线型</strong>，但是影响系数为 0.1；</p>\n</li>\n<li data-nodeid="4815">\n<p data-nodeid="4816"><strong data-nodeid="5048">baseProbability 我们也可以看作是直线型</strong>；</p>\n</li>\n<li data-nodeid="4817">\n<p data-nodeid="4818">而 <strong data-nodeid="5054">currentCpuPercentage 则是一个指数型增长模型</strong>。</p>\n</li>\n</ul>\n<p data-nodeid="4819">可以得出一个简单的算法公式，如下所示：</p>\n<pre class="lang-java" data-nodeid="4820"><code data-language="java">P = (<span class="hljs-number">0.1</span> * o) * Math.exp(c) / (<span class="hljs-number">10</span> * Math.exp(<span class="hljs-number">10</span>)) * b\n</code></pre>\n<p data-nodeid="4821">其中 o 取最大值 100，c 取最大值 10，b 为固定值，这里假设为 0.7，那么求出来的最大概率是 0.7 ；那么在 o 为 30，c 为 90 的概率则是 0.19 ，因此会丢弃 19% 的用户请求。</p>\n<p data-nodeid="4822">接下来我们先实现该 P 概率公式，代码如下：</p>\n<pre class="lang-javascript" data-nodeid="4823"><code data-language="javascript"><span class="hljs-comment">/**\n * <span class="hljs-doctag">@description </span>获取丢弃概率\n */</span>\n_setProbability() {\n     <span class="hljs-keyword">let</span> o = overloadTimes &gt;= <span class="hljs-number">100</span> ? <span class="hljs-number">100</span> : overloadTimes;\n     <span class="hljs-keyword">let</span> c = currentCpuPercentage &gt;= <span class="hljs-number">100</span> ? <span class="hljs-number">10</span> : currentCpuPercentage/<span class="hljs-number">10</span>;\n     currentProbability = ((<span class="hljs-number">0.1</span> * o) * <span class="hljs-built_in">Math</span>.exp(c) / maxValue * <span class="hljs-keyword">this</span>.baseProbability).toFixed(<span class="hljs-number">4</span>);\n}\n</code></pre>\n<p data-nodeid="4824">为了性能考虑，我们会将上面的 10 * Math.exp(10) 作为一个 const 值，避免重复计算，其次这个方法是在 check 函数中调用，2 秒处理一次，避免过多计算影响 CPU 性能。然后我们再来实现一个<strong data-nodeid="5065">获取随机数</strong>的方法，代码如下：</p>\n<pre class="lang-javascript" data-nodeid="4825"><code data-language="javascript"><span class="hljs-comment">/**\n * <span class="hljs-doctag">@description </span>获取一个概率值\n */</span>\n_getRandomNum(){\n    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Math</span>.random();\n}\n</code></pre>\n<p data-nodeid="4826">最后我们在 isAvailable 函数中判断当前的随机数是否大于等于概率值，如果小于概率值则丢弃该请求，大于则认为允许请求继续访问，如下代码所示：</p>\n<pre class="lang-javascript" data-nodeid="4827"><code data-language="javascript">isAvailable(path, uuid) {\n    <span class="hljs-keyword">if</span>(isOverload) {\n      <span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span>._getRandomNum() &lt;= <span class="hljs-keyword">this</span>._getProbability()) {\n          <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;\n      }\n      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;\n    }\n    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;\n}\n</code></pre>\n<p data-nodeid="4828">以上就是判断是否需要丢弃的逻辑。在某些情况下，我们需要做一定的优化，避免一些重要的请求无法触达用户，因此还需要做一些优化级和同一个 uuid 进行优化的策略。</p>\n<h4 data-nodeid="4829">4.优先级处理</h4>\n<p data-nodeid="4830">这里我们需要考虑 2 个点：</p>\n<ul data-nodeid="4831">\n<li data-nodeid="4832">\n<p data-nodeid="4833"><strong data-nodeid="5074">优先级问题</strong>，因为有些核心的请求我们不希望用户在访问时出现丢弃的情况，比如支付或者其他核心重要的流程；</p>\n</li>\n<li data-nodeid="4834">\n<p data-nodeid="4835">其次对于一个用户，我们允许了该用户访问其中一个接口，那么其他接口在短时间内应该也允许请求，不然会导致有些接口响应成功，有些失败，那么用户还是无法正常使用。</p>\n</li>\n</ul>\n<p data-nodeid="4836"><strong data-nodeid="5079">优先级的实现</strong></p>\n<p data-nodeid="4837">优先级实现最简单的方式，就是接受一个<strong data-nodeid="5085">白名单参数</strong>，如果设置了则会在白名单中的请求通过处理，无须校验，如果不在才会进行检查，代码实现如下：</p>\n<pre class="lang-javascript" data-nodeid="4838"><code data-language="javascript">isAvailable(path, uuid) {\n    <span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span>.whiteList.includes(path)) {\n        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;\n    }\n    <span class="hljs-keyword">if</span>(isOverload) {\n        <span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span>._getRandomNum() &lt;= currentProbability) {\n            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;\n        }\n        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;\n    }\n    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;\n}\n</code></pre>\n<p data-nodeid="4839"><strong data-nodeid="5089">uuid 处理</strong></p>\n<p data-nodeid="4840">这部分稍微复杂一些，首先我们需要考虑<strong data-nodeid="5099">时效性</strong>，如果存储没有时效会导致存储数据过大，从而引起内存异常问题，其次应该考虑使用<strong data-nodeid="5100">共享内存 Redis 方式</strong>，因为有可能是多机器部署。这里为了简单化，会使用本地内存的方式，但是也需要考虑上限，超过上限剔除第一个元素，代码实现如下：</p>\n<pre class="lang-javascript" data-nodeid="4841"><code data-language="javascript">isAvailable(path, uuid) {\n    <span class="hljs-keyword">if</span>(path &amp;&amp; <span class="hljs-keyword">this</span>.whiteList.includes(path)) { <span class="hljs-comment">// 判断是否在白名单内</span>\n        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;\n    }\n    <span class="hljs-keyword">if</span>(uuid &amp;&amp; canAccessList.includes(uuid)){ <span class="hljs-comment">// 判断是否已经放行过</span>\n        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;\n    }\n    <span class="hljs-keyword">if</span>(isOverload) {\n         <span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span>._getRandomNum() &lt;= currentProbability) {\n            removeCount++;\n            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;\n          }\n    }\n    <span class="hljs-keyword">if</span>(uuid) { <span class="hljs-comment">// 需要将 uuid 加入放行数组</span>\n        <span class="hljs-keyword">if</span>(canAccessList.length &gt; maxUser){\n            canAccessList.shift()\n        }\n        canAccessList.push(uuid);\n    }\n    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;\n}\n</code></pre>\n<p data-nodeid="4842">以上就实现这个过载模块了，重点要注意的是获取 CPU 使用率的方法、减少性能影响、概率丢弃和优先级处理。接下来我们就实践应用一下，首先我们可以对比下性能影响，在没有应用和应用之后两者的空转性能对比。</p>\n<h3 data-nodeid="4843">实践应用</h3>\n<p data-nodeid="4844">在下一讲中我们会将 MSVC 框架转化为 Koa 框架接入，这里我们还是以最原始的框架为基础来接入 MSVC。</p>\n<h4 data-nodeid="4845">1.接入 MSVC</h4>\n<p data-nodeid="4846">首先我们需要在入口文件初始化过载保护模块，并且调用 check 方法，定时获取 CPU 信息，代码如下:</p>\n<pre class="lang-javascript" data-nodeid="4847"><code data-language="javascript"><span class="hljs-keyword">const</span> cpuOverload = <span class="hljs-keyword">new</span> (<span class="hljs-built_in">require</span>(<span class="hljs-string">\'./util/cpuOverload\'</span>))();\n<span class="hljs-comment">/**\n * 处理 cpu 信息采集\n */</span>\ncpuOverload.check().then().catch(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> {\n    <span class="hljs-built_in">console</span>.log(err)\n});\n</code></pre>\n<p data-nodeid="4848">接下来在请求转发处，先进行判断，在进入业务之前就进行拦截处理，代码如下图 1 所示：</p>\n<p data-nodeid="4849"><img src="https://s0.lgstatic.com/i/image6/M00/1D/E4/Cgp9HWBQK5GADhMxAAHtP-9awms474.png" alt="Drawing 0.png" data-nodeid="5109"></p>\n<div data-nodeid="4850"><p style="text-align:center">图 1 增加 CPU 过载处理代码图</p></div>\n<p data-nodeid="4851">使用起来比较简单，接下来我们就来看看实际性能对比。</p>\n<h4 data-nodeid="4852">2.性能分析对比</h4>\n<p data-nodeid="4853">我们对移除 CPU 过载保护代码和加上过载保护逻辑后的压测数据，使用压测工具进行压测，这里你只需要了解 WRK 即可，具体压测工具我们还会在《12 | 性能分析：性能影响的关键路径以及优化策略》中详细介绍。最后我们可以得到如下表格 1 所示的结果。</p>\n<p data-nodeid="4854"><img src="https://s0.lgstatic.com/i/image6/M01/1D/E1/CioPOWBQK6KACYDqAACIqA12oSE255.png" alt="Drawing 1.png" data-nodeid="5117"></p>\n<p data-nodeid="4855">上面的测试数据是在持续时长为 20 秒、CPU 占用大于 98、丢弃概率为 80% 时的测试数据，可以看出，整体上两者并没有多大差距（由于是本机器测试，会有部分误差），那么如果我们将 CPU 占用修改为 80 时，我们可以看下 1000 并发时压测数据，如下所示：</p>\n<pre class="lang-java" data-nodeid="4856"><code data-language="java">&nbsp;<span class="hljs-number">10</span> threads and <span class="hljs-number">1000</span> connections\n&nbsp; Thread Stats&nbsp; &nbsp;Avg&nbsp; &nbsp; &nbsp; Stdev&nbsp; &nbsp; &nbsp;Max&nbsp; &nbsp;+/- Stdev\n&nbsp; &nbsp; Latency&nbsp; &nbsp; <span class="hljs-number">71.31</span>ms&nbsp; &nbsp; <span class="hljs-number">4.95</span>ms <span class="hljs-number">189.60</span>ms&nbsp; &nbsp;<span class="hljs-number">90.88</span>%\n&nbsp; &nbsp; Req/Sec&nbsp; &nbsp; &nbsp;<span class="hljs-number">1.40</span>k&nbsp; &nbsp;<span class="hljs-number">171.05</span>&nbsp; &nbsp; &nbsp;<span class="hljs-number">2.25</span>k&nbsp; &nbsp; <span class="hljs-number">80.83</span>%\n&nbsp; <span class="hljs-number">416766</span> requests in <span class="hljs-number">30.04</span>s, <span class="hljs-number">72.26</span>MB read\n&nbsp; Socket errors: connect <span class="hljs-number">0</span>, read <span class="hljs-number">3990</span>, write <span class="hljs-number">0</span>, timeout <span class="hljs-number">0</span>\n&nbsp; Non-<span class="hljs-number">2</span>xx or <span class="hljs-number">3</span>xx responses: <span class="hljs-number">12779</span>\nRequests/sec:&nbsp; <span class="hljs-number">13874.51</span>\n</code></pre>\n<p data-nodeid="4857">你可以看到结果中平均耗时减少了，从原来的 76.96 变成了 71.31，其次增加了 503 的返回量，原来是 0 现在是 12779，在 scoket 超时方面还是基本一致的。因此在实际情况，我们需要根据业务以及机器的配置来选择这几个参数的配置，具体的关系就是我上面所提到的。<strong data-nodeid="5124">随着并发越来越高，如果没有负载保护用户的处理时长会越来越长，但是有了负载保护就可以避免雪崩现象，从而保护服务器可以正常地提供服务</strong>。</p>\n<h3 data-nodeid="4858">总结</h3>\n<p data-nodeid="4859">本讲首先介绍了什么是过载保护和什么是 CPU 过载保护，接下来实践教学了如何去实现一个 CPU 过载保护模块，最后实践接入 MSVC 框架，并且与基础框架进行了对比分析。学完本讲后，要掌握 CPU 过载保护的设计，同时从这个过程中，掌握在 Node.js 中应注重的代码设计原则。</p>\n<p data-nodeid="4860">学完本讲后，你可以再思考下，setInterval 中的 2000 ms 是否可以进行调整，这个值的调整会有哪些影响，这部分希望你可以动手验证下效果，有任何问题，都可以在留言区与我交流。</p>\n<p data-nodeid="4861">下一讲我们将会讲解在 I/O 方面应该注意哪些要点，到时见！</p>\n<hr data-nodeid="4862">\n<p data-nodeid="4863"><a href="https://shenceyun.lagou.com/t/mka" data-nodeid="5133"><img src="https://s0.lgstatic.com/i/image6/M00/12/FA/CioPOWBBrAKAAod-AASyC72ZqWw233.png" alt="Drawing 2.png" data-nodeid="5132"></a></p>\n<p data-nodeid="4864"><strong data-nodeid="5137">《大前端高薪训练营》</strong></p>\n<p data-nodeid="4865" class="">对标阿里 P7 技术需求 + 每月大厂内推，6 个月助你斩获名企高薪 Offer。<a href="https://shenceyun.lagou.com/t/mka" data-nodeid="5141">点击链接</a>，快来领取！</p>',
        article_title: "07 | CPU 过载保护设计：如何在服务层面确保系统稳定？",
        title: "07 | CPU 过载保护设计：如何在服务层面确保系统稳定？",
        id: 6789,
      },
      {
        content:
          '<p data-nodeid="29390" class="">在<a href="https://kaiwu.lagou.com/course/courseInfo.htm?courseId=694#/detail/pc?id=6788&amp;fileGuid=X6R6kCycxy33VKCQ" data-nodeid="29542">《06 | 哪些因素会影响 Node.js 性能？》</a>中我们有提到 I/O 不会影响整体 Node.js 服务的性能，但是会因为 I/O 影响服务器系统，从而侧面影响到 Node.js 性能。本讲就着重介绍磁盘 I/O 和网络 I/O 两个方面在研发过程中注意的要点。</p>\n<h3 data-nodeid="29391">I/O 基础介绍</h3>\n<p data-nodeid="29392">I/O（Input/Output）意思是<strong data-nodeid="29554">输入输出</strong>，其实就是<strong data-nodeid="29555">数据传递的一个过程</strong>，作为后台服务需要更多地与外部进行数据交互，那么就免不了 I/O 操作。I/O 的类型也是非常多的，我们应该掌握常用的一些 I/O 模型分类。</p>\n<p data-nodeid="29393">I/O 分为以下 5 种模型，在介绍分类之前，我们先了解 I/O 在系统层面会有 2 个阶段（以读为例子）：</p>\n<ul data-nodeid="29394">\n<li data-nodeid="29395">\n<p data-nodeid="29396">第一个阶段是<strong data-nodeid="29566">读取文件</strong>，将<strong data-nodeid="29567">文件放入操作系统内核缓冲区</strong>；</p>\n</li>\n<li data-nodeid="29397">\n<p data-nodeid="29398">第二阶段是将<strong data-nodeid="29573">内核缓冲区拷贝到应用程序地址空间</strong>。</p>\n</li>\n</ul>\n<h4 data-nodeid="29399">1.阻塞 I/O</h4>\n<p data-nodeid="29400">例如读取一个文件，我们必须要<strong data-nodeid="29580">等待文件读取完成后</strong>，也就是完成上面所说的两个阶段，才能执行其他逻辑，而当前是无法释放 CPU 的，因此无法去处理其他逻辑。</p>\n<h4 data-nodeid="29401">2.非阻塞 I/O</h4>\n<p data-nodeid="29402">非阻塞的意思是，我们发起了一个读取文件的指令，系统会返回正在处理中，然后这时候如果要释放进程中的 CPU 去处理其他逻辑，你就必须间隔一段时间，然后不停地去询问操作系统，使用轮询的判断方法看是否读取完成了。</p>\n<h4 data-nodeid="29403">3.多路复用 I/O</h4>\n<p data-nodeid="29404">这一模型主要是为了解决<strong data-nodeid="29589">轮询调度的问题</strong>，我们可以将这些 I/O Socket 处理的结果统一交给一个独立线程来处理，当 I/O Socket 处理完成后，就主动告诉业务，处理完成了，这样不需要每个业务都来进行轮询查询了。</p>\n<p data-nodeid="29405"><strong data-nodeid="29598">它包括目前常见的三种类型：select 、poll 和 epoll</strong>。首先 <strong data-nodeid="29599">select 是比较旧的</strong>，它和 poll 的区别在于 poll 使用的是链表来保存 I/O Socket 数据，而 select 是数组，因此 select 会有上限 1024，而 poll 则没有。select、poll 与 epoll 的区别在于，前两者不会告诉你是哪个 I/O Socket 完成了，而 epoll 会通知具体哪个 I/O Socket 完成了哪个阶段的操作，这样就不需要去遍历查询了。</p>\n<p data-nodeid="29406">当然这里有一个重点是这三者<strong data-nodeid="29605">只会告知文件读取进入了操作系统内核缓冲区</strong>，也就是上面我们所说的第一阶段，但是第二阶段从内核拷贝到应用程序地址空间还是同步等待的。</p>\n<h4 data-nodeid="29407">4.信号驱动 I/O</h4>\n<p data-nodeid="29408">这种模式和多路复用的区别在于<strong data-nodeid="29612">不需要有其他线程来处理</strong>，而是在完成了读取进入操作系统内核缓冲区后，立马通知，也就是第一阶段可以由系统层面来处理，不需要独立线程来管理，但是第二阶段还是和多路复用一样。</p>\n<h4 data-nodeid="29409">5.异步 I/O</h4>\n<p data-nodeid="29410">和信号驱动不同的是，异步 I/O 是<strong data-nodeid="29623">两个阶段都完成了以后</strong>，<strong data-nodeid="29624">才会通知</strong>，并不是第一阶段完成。</p>\n<p data-nodeid="29411">我们常说的Node.js 是一个异步 I/O 这个是没有错的。具体来说 Node.js 是其 libv 库自行实现的一种类似异步 I/O 的模型，对于 Node.js 应用来说是一个异步 I/O，因此无须处理两个过程，而在 libv 内部实现，则是多线程的一个 epoll 模型。这点是非常重要的，希望你可以牢记。</p>\n<p data-nodeid="29412">在了解了以上基础知识后，我们再来分析在 Node.js 中如何进行代码优化才能达到极致的性能。我们从两个方面来介绍：</p>\n<ul data-nodeid="29413">\n<li data-nodeid="29414">\n<p data-nodeid="29415">本地磁盘 I/O；</p>\n</li>\n<li data-nodeid="29416">\n<p data-nodeid="29417">远程网络 I/O。</p>\n</li>\n</ul>\n<h3 data-nodeid="29418">本地磁盘 I/O</h3>\n<p data-nodeid="29419">根据以上结论，我们可以思考以下六点：</p>\n<ol data-nodeid="29420">\n<li data-nodeid="29421">\n<p data-nodeid="29422">如果是<strong data-nodeid="29640">写 I/O</strong>，并且不需要获取写入结果时，则<strong data-nodeid="29641">不需要进行回调处理</strong>，减少主线程压力，比如最常见的例子就是写日志；</p>\n</li>\n<li data-nodeid="29423">\n<p data-nodeid="29424">如果是<strong data-nodeid="29651">写 I/O</strong>，可以<strong data-nodeid="29652">使用文件流的方式</strong>，避免重复的打开同一个文件，损耗不必要的打开和关闭文件的过程；</p>\n</li>\n<li data-nodeid="29425">\n<p data-nodeid="29426">如果是<strong data-nodeid="29662">写 I/O</strong>，为了缓解写并发对系统的压力，可以将需要写入的日志放入一个<strong data-nodeid="29663">临时内存</strong>中，从而降低系统并发处理压力，从而降低系统负载；</p>\n</li>\n<li data-nodeid="29427">\n<p data-nodeid="29428">如果是<strong data-nodeid="29669">读 I/O</strong>，并且需要获取读取结果时，能够使用缓存尽量使用缓存，因为读 I/O 是需要时间，虽然不影响主线程性能，但是会影响用户响应时间，当读 I/O 过大，则系统压力较大，从而影响整体读接口的性能，因此需要使用缓存，减少并发对系统的 I/O 压力；</p>\n</li>\n<li data-nodeid="29429">\n<p data-nodeid="29430">如果是<strong data-nodeid="29675">读 I/O</strong>，并且无法进行缓存的，则尽量考虑不使用本地磁盘 I/O 操作；</p>\n</li>\n<li data-nodeid="29431">\n<p data-nodeid="29432">如果是<strong data-nodeid="29681">读 I/O</strong>，涉及大文件读取操作时，则应使用数据流的方式，而不是一次性读取内存中进行处理。</p>\n</li>\n</ol>\n<p data-nodeid="29433">接下来我们看下几个实际场景，并且介绍如何去实现上面几点。</p>\n<h4 data-nodeid="29434">文件读取</h4>\n<p data-nodeid="29435">后台服务会涉及较多的配置文件，而读取配置文件是与第 4 个场景相似的，因此这类情况处理比较简单，只需要在程序启动时，将配置文件读取到内存中即可。</p>\n<p data-nodeid="29436">另外一种就是读取大文件，这点和第 6 个大文件场景相似，比如说一次性读取一个 Excel 的大文件，然后对每一行进行处理，这时候如果使用 Node.js 的 fs 会导致性能问题，并且处理时间也会非常长，这部分应该尽量使用<strong data-nodeid="29690">文件流方式</strong>。</p>\n<h4 data-nodeid="29437">日志模块</h4>\n<p data-nodeid="29438">日志存在很大的写情况，和我们上面说的 1、2 、3 场景是一致的，因此我们需要从这 3 个方面去提升性能。</p>\n<p data-nodeid="29439">接下来我们就来实现一个<strong data-nodeid="29698">简单版本</strong>，包含这 3 个性能提升的点的模块：</p>\n<ul data-nodeid="29440">\n<li data-nodeid="29441">\n<p data-nodeid="29442"><strong data-nodeid="29703">保存待写入的日志信息</strong>，当超出最大保存日志条数时，则直接写入，不保存在日志信息中，主要是避免内存过大，引起垃圾回收性能问题；</p>\n</li>\n<li data-nodeid="29443">\n<p data-nodeid="29444"><strong data-nodeid="29708">定时从临时缓存中，取出数据写入文件中</strong>；</p>\n</li>\n<li data-nodeid="29445">\n<p data-nodeid="29446"><strong data-nodeid="29713">写入文件后，无须处理回调</strong>。</p>\n</li>\n</ul>\n<p data-nodeid="29447">为了避免内存占用过大，我们设置最大的文件句柄保存数为 1000 个，每个文件最大的日志临时保存数为 100000 ，因此最大可能占用的内存为 1000*100000/1024/1024，约等于 100 M。将这些默认参数作为日志的变量，可供外部传入配置，如下所示：</p>\n<pre class="lang-javascript" data-nodeid="29448"><code data-language="javascript"><span class="hljs-comment">/**\n     * \n     * <span class="hljs-doctag">@param <span class="hljs-type">{boolean}</span> </span>cacheEnable 是否打开日志缓存模式，默认打开\n     * <span class="hljs-doctag">@param <span class="hljs-type">{int}</span> </span>cacheTime 缓存处理时间，默认 2 秒，会定时入文件\n     * <span class="hljs-doctag">@param <span class="hljs-type">{int}</span> </span>maxLen 单个日志文件最大缓存长度，默认100000\n     * <span class="hljs-doctag">@param <span class="hljs-type">{int}</span> </span>maxFileStream 最大缓存文件句柄数，默认是 1000\n     */</span>\n    <span class="hljs-keyword">constructor</span>(cacheEnable=true, cacheTime=2000, maxLen=100000, maxFileStream=1000) {\n        <span class="hljs-keyword">this</span>.cacheTime = cacheTime;\n        <span class="hljs-keyword">this</span>.cacheEnable = cacheEnable;\n        <span class="hljs-keyword">this</span>.maxLen = maxLen;\n        <span class="hljs-keyword">this</span>.maxFileStream = maxFileStream;\n        <span class="hljs-keyword">this</span>.currentFileStreamNum = <span class="hljs-number">0</span>;\n    }\n</code></pre>\n<p data-nodeid="29449">接下来我们看下整体日志逻辑的设计流转，如图 1 所示。</p>\n<p data-nodeid="29450"><img src="https://s0.lgstatic.com/i/image6/M00/27/7A/Cgp9HWBccvaAVgUCAAAwlAOAoRg862.png" alt="Drawing 0.png" data-nodeid="29720"></p>\n<div data-nodeid="29451"><p style="text-align:center">图 1 日志模块逻辑</p></div>\n<p data-nodeid="29452">在上面逻辑中日志写入有 2 个入口：</p>\n<ul data-nodeid="29453">\n<li data-nodeid="29454">\n<p data-nodeid="29455">info（假设只有一种 info 日志）</p>\n</li>\n<li data-nodeid="29456">\n<p data-nodeid="29457">start</p>\n</li>\n</ul>\n<p data-nodeid="29458"><strong data-nodeid="29732">info</strong> 会调用 _flush 判断当前缓存是否已满，或者是否开启了缓存，如果没有开启或者缓存已满，则直接调用 _addLog 写入日志，其他情况都写入缓存中。</p>\n<p data-nodeid="29459"><strong data-nodeid="29741">start</strong> 会定时从临时缓存中获取待写入的日志内容，如果有则调用 _addLog 写入日志，写入完成后会调用 _clean 清理已经写入的内容，其次会清理未使用的空文件流句柄，避免空文件夹、 句柄流占用缓存。</p>\n<p data-nodeid="29460"><strong data-nodeid="29749">_addLog</strong> 根据类型获取需要写入的文件路径，并调用 _getFileStream 来获取文件流句柄，这里就会用到文件流缓存，当缓存有则返回，没有则创建一个文件流句柄。</p>\n<p data-nodeid="29461">我们主要看下 _flush 和 _intervalWrite 两个代码，_flush 的代码实现逻辑如图 2 所示：</p>\n<p data-nodeid="29462"><img src="https://s0.lgstatic.com/i/image6/M00/27/77/CioPOWBccwWAbxV9AAIgXwovZRI835.png" alt="Drawing 1.png" data-nodeid="29759"></p>\n<div data-nodeid="29463"><p style="text-align:center">图 2 _flush 代码实现逻辑</p></div>\n<p data-nodeid="29464">这块代码最主要就是判断<strong data-nodeid="29765">是否开启了缓存以及当前文件流是否超出了最大缓存</strong>，如果这两个条件任意一个满足，则直接写日志，不经过临时缓存。</p>\n<p data-nodeid="29465">_intervalWrite 的代码实现逻辑如图 3 所示：</p>\n<p data-nodeid="29466"><img src="https://s0.lgstatic.com/i/image6/M00/27/7A/Cgp9HWBccw6AN65NAAGA3qjte14745.png" alt="Drawing 2.png" data-nodeid="29770"></p>\n<div data-nodeid="29467"><p style="text-align:center">图 3 _intervalWrite 代码实现</p></div>\n<p data-nodeid="29468">在上面代码中使用了 <strong data-nodeid="29776">setInterval 定时获取临时缓存数据</strong>，并写入文件。</p>\n<p data-nodeid="29469">在代码 57 行中，对<strong data-nodeid="29782">空缓存的文件流句柄进行清理</strong>，避免一些没用的句柄缓存一直占用缓存数据。</p>\n<p data-nodeid="29470">其次在代码 61 行中可能会丢失日志，主要是在写入日志完成后，还没清理，又有数据写入了临时缓存中，导致部分丢失的现象，默认情况下允许这种情况，因为这种丢失的现象概率比较低。</p>\n<p data-nodeid="29471">在 <a href="https://github.com/love-flutter/nodejs-column?fileGuid=X6R6kCycxy33VKCQ" data-nodeid="29787">GitHub 源码</a>中，我们可以打开本讲的代码，并且在项目根目录运行以下命令，启动调试。</p>\n<pre class="lang-java" data-nodeid="29472"><code data-language="java">node app\n</code></pre>\n<p data-nodeid="29473">运行成功后，访问如下地址：</p>\n<pre class="lang-java" data-nodeid="29474"><code data-language="java">http:<span class="hljs-comment">//127.0.0.1:3000/v1/log</span>\n</code></pre>\n<p data-nodeid="29475">然后打开根目录下的 log 文件夹，就可以看到具体的日志信息了，具体信息如下所示：</p>\n<pre class="lang-java" data-nodeid="29476"><code data-language="java">good success <span class="hljs-number">0.4400041351511781</span>\ngood success <span class="hljs-number">0.8533540410020264</span>\ngood success <span class="hljs-number">0.05602191887030328</span>\ngood success <span class="hljs-number">0.9211995961759676</span>\ngood success <span class="hljs-number">0.18125957486134014</span>\n</code></pre>\n<p data-nodeid="29477">以上就是一个性能较好的日志服务，具体的性能数据我们后续再通过《12 | 性能分析：性能影响的关键路径以及优化策略》中的压测来进行对比分析。</p>\n<h3 data-nodeid="29478">网络 I/O</h3>\n<p data-nodeid="29479">在后台服务中常见的网络 I/O 有如下几种类型：</p>\n<ul data-nodeid="29480">\n<li data-nodeid="29481">\n<p data-nodeid="29482"><strong data-nodeid="29800">缓存型</strong>，如 MemCache、Redis；</p>\n</li>\n<li data-nodeid="29483">\n<p data-nodeid="29484"><strong data-nodeid="29805">数据存储型</strong>，如 MySQL、MongoDB；</p>\n</li>\n<li data-nodeid="29485">\n<p data-nodeid="29486"><strong data-nodeid="29810">服务型</strong>，如内网 API 服务或者第三方 API。</p>\n</li>\n</ul>\n<p data-nodeid="29487">网络 I/O 的成本是最高的，因为会涉及两个最重要的点：</p>\n<ul data-nodeid="29488">\n<li data-nodeid="29489">\n<p data-nodeid="29490">依赖其他服务的性能；</p>\n</li>\n<li data-nodeid="29491">\n<p data-nodeid="29492">依赖服务器之间的延时。</p>\n</li>\n</ul>\n<p data-nodeid="29493">针对上面的两个最重要的点，我们可以从以下几个方面来考虑优化的策略：</p>\n<ul data-nodeid="29494">\n<li data-nodeid="29495">\n<p data-nodeid="29496"><strong data-nodeid="29819">减少与网络 I/O 的交互</strong>，比如缓存已获取的内容；</p>\n</li>\n<li data-nodeid="29497">\n<p data-nodeid="29498">使用<strong data-nodeid="29825">更高性能的网络 I/O</strong> 替代其他性能较差的、成本更高的网络 I/O 类型，比如数据库读写的 I/O 成本是明显高于缓存型的，因此可以使用缓存型网络 I/O 替换存储型；</p>\n</li>\n<li data-nodeid="29499">\n<p data-nodeid="29500">降低目标网络 I/O 服务的<strong data-nodeid="29831">并发压力</strong>，可以采用异步队列方式。</p>\n</li>\n</ul>\n<p data-nodeid="29501">下面我们就来看下以上三种方式的实现方案。</p>\n<h4 data-nodeid="29502">减少网络 I/O</h4>\n<p data-nodeid="29503">对于一些与用户维度不相关的数据，或者批次用户数据类似的情况，我们可以通过网络 I/O 获取数据后，缓存在本地服务器上，后面只需要从本地内存中读取即可。</p>\n<p data-nodeid="29504">这部分我们还是来看一个计算的逻辑，在 Controller 新增了一个叫作 locaCache.js 的文件，然后创建 yes 和 no 两个方法，分别对应接口路由为：</p>\n<pre class="lang-java" data-nodeid="29505"><code data-language="java">http:<span class="hljs-comment">//127.0.0.1:3000/v1/cache</span>\nhttp:<span class="hljs-comment">//127.0.0.1:3000/v1/no-cache</span>\n</code></pre>\n<p data-nodeid="29506">代码实现如图 4 所示：</p>\n<p data-nodeid="29507"><img src="https://s0.lgstatic.com/i/image6/M00/27/77/CioPOWBccx2AJxvJAAFS6_8BrgA672.png" alt="Drawing 3.png" data-nodeid="29839"></p>\n<div data-nodeid="29508"><p style="text-align:center">图 4 本地缓存代码例子</p></div>\n<p data-nodeid="29509">其中 yes 函数中就是增加了本地内存缓存，而 no 则没有。</p>\n<p data-nodeid="29510">接下来启动服务，我们使用如下两条命令（或者使用浏览器，打开 Chrome 的 Network 查看耗时）多次运行查看耗时情况。</p>\n<pre class="lang-java" data-nodeid="29511"><code data-language="java">time curl http:<span class="hljs-comment">//127.0.0.1:3000/v1/no-cache</span>\ntime curl http:<span class="hljs-comment">//127.0.0.1:3000/v1/cache</span>\n</code></pre>\n<p data-nodeid="29512">你会发现 /v1/cache 只有第一次耗时比较久，后面都非常快，而 /v1/no-cache 则每次耗时都比较久。</p>\n<p data-nodeid="29513">因此本地缓存对于这种<strong data-nodeid="29852">固定化</strong>，并且<strong data-nodeid="29853">无用户差别的数据</strong>是可以进行缓存的，而且非常有必要。比如说，我们常见的一些客户端配置化信息。</p>\n<p data-nodeid="29514">不过本地内存缓存有一个最大的问题点在于，<strong data-nodeid="29859">每台机器可能缓存了不同的数据</strong>，比如每台机器缓存了运营配置，这时候运营修改了配置，不同机器过期时间不一致，导致用户每次刷新可能出现不同的首页配置。那么这个问题就需要高性能替换方案（共享内存方案）来解决了。</p>\n<h4 data-nodeid="29515">高性能替换</h4>\n<p data-nodeid="29516">本地缓存是直接本地内存，性能高过共享内存，也就是网络 I/O 中的共享内存方式，但是网络 I/O 共享内存的性能高于网络 I/O 中的磁盘 I/O 性能。比如 Redis 的性能是远高于 MySQL 的，主要有一点是前两者是<strong data-nodeid="29866">共享内存的方式</strong>，内存的操作是快于磁盘 I/O。因此可以通过 MySQL 获取数据后保存在高性能网络 I/O 的 Redis 上，这样可以大大提升性能。其次共享内存方案也可以解决本地缓存中数据不一致的问题。</p>\n<p data-nodeid="29517"><img src="https://s0.lgstatic.com/i/image6/M00/27/77/CioPOWBcczWAdNqNAABJ2ImrHUY990.png" alt="Drawing 5.png" data-nodeid="29869"></p>\n<p data-nodeid="29518">在图 5 中我们访问 API 服务，在 API 中判断获取的数据是否有缓存，有缓存则直接从共享内存服务中读取，如果没有则先前往 MySQL 获取具体的数据，返回到 API 服务以后，再设置共享内存，这样下次用户来访问该数据时，就有相应的数据了。从而实现了高性能网络 I/O 替换低性能网络 I/O 的方案。</p>\n<p data-nodeid="29519">共享内存适合那些可以延迟更新的数据服务，并且与用户维度无关，每个用户（或者有限用户分类）拉取的内容都是一致的。如果每个用户内容不一致，会导致缓存命中较低，同时浪费大量的内存空间。</p>\n<h4 data-nodeid="29520">异步队列</h4>\n<p data-nodeid="29521">举一个用户抢票的例子，如果每个用户抢票，我们都执行一次查询并且购票，那么对于目标机器则压力非常大，特别像 12306 这种几亿人同时抢的情况，那么这里就可以采用异步队列的方式，也就是用户发送请求后只告知用户，你已经进入队列，但是真正情况是<strong data-nodeid="29878">用户的请求会缓存在一个队列中</strong>，再一个个前往具体的网络 I/O 服务中，独立去处理，这时候并发压力就可控，因此也不会出现性能问题。</p>\n<p data-nodeid="29522">具体方案如图 6 所示：</p>\n<p data-nodeid="29523"><img src="https://s0.lgstatic.com/i/image6/M01/27/77/CioPOWBcc0OAc-o2AABrosw8lrA094.png" alt="Drawing 7.png" data-nodeid="29882"></p>\n<p data-nodeid="29524">如图所示，假设我们现在有 3 个（实际情况可能几千万甚至几亿）用户同时向服务器请求，这时候服务器肯定是处理不过来的，只能告诉用户，你的请求我们已经收到了，并且在处理中了，请耐心等待通知。这时候将用户的请求放到一个队列中，然后通过另外一个服务，定时从队列中获取待处理的消息，根据实际情况处理完成后，将处理后的结果通知给具体的每个用户。</p>\n<p data-nodeid="29525">异步队列一个比较高性能的网络 I/O ，通过一个高性能网络 I/O 将其他的业务逻辑封装，让用户无感知，只是<strong data-nodeid="29889">延迟了用户收到结果的时间</strong>。</p>\n<p data-nodeid="29526">以上就是网络 I/O 常见的三种优化策略，在实际应用过程中需要更巧妙和灵活的使用，我们在实战部分会详细介绍这部分代码的应用实践。</p>\n<h3 data-nodeid="29527">总结</h3>\n<p data-nodeid="29528">本讲介绍了 I/O 的基础模型分类，需要了解 Node.js 应用层是一个异步 I/O 模型，但是其底层 libv 库是一个基于 epoll 的 I/O 模型，这点希望你可以牢记，后续面试说不定也会被问及。并介绍了在 Node.js 中常见的两种 I/O：磁盘和网络，对于这两者都存在非常多的性能问题点，本讲详细介绍了如何处理这些会导致性能问题的场景。希望学完本讲后，你能够解决 Node.js 开发过程中各种 I/O 性能问题，并且能够给出一定的性能调优方案。</p>\n<p data-nodeid="29529">那在日常开发中你遇到过哪些 I/O 性能问题，以及你是如何解决的呢，欢迎在交流区留下你的回答。</p>\n<p data-nodeid="29530">本讲中有提及用缓存来解决一部分 I/O 场景的问题，但是没有系统性地介绍，在接下来的一讲我们将详细介绍缓存的分类以及缓存的应用方案。</p>\n<hr data-nodeid="29531">\n<p data-nodeid="29532"><a href="https://shenceyun.lagou.com/t/mka" data-nodeid="29899"><img src="https://s0.lgstatic.com/i/image6/M00/12/FA/CioPOWBBrAKAAod-AASyC72ZqWw233.png" alt="Drawing 2.png" data-nodeid="29898"></a></p>\n<p data-nodeid="29533"><strong data-nodeid="29903">《大前端高薪训练营》</strong></p>\n<p data-nodeid="29534" class="te-preview-highlight">对标阿里 P7 技术需求 + 每月大厂内推，6 个月助你斩获名企高薪 Offer。<a href="https://shenceyun.lagou.com/t/mka" data-nodeid="29907">点击链接</a>，快来领取！</p>',
        article_title: "08 | 优化设计：在 I/O 方面应该注意哪些要点？",
        title: "08 | 优化设计：在 I/O 方面应该注意哪些要点？",
        id: 6790,
      },
      {
        content:
          '<p data-nodeid="7696" class="">在上一讲中我们介绍了网络 I/O 的优化方案，也就是应用缓存来减少网络 I/O 或者用高性能网络 I/O 替换性能较低的网络 I/O。将缓存应用好，也并非一件简单的事情，需要详细地学习和掌握缓存的基础知识。其次在本讲中我会应用 Node.js 来实践开发一个多级缓存的库，让你进一步掌握缓存的应用要点。</p>\n<h3 data-nodeid="7697">缓存概念</h3>\n<p data-nodeid="7698">从我的理解上来介绍，<strong data-nodeid="7799">缓存是临时的一块存储空间</strong>，用于存放<strong data-nodeid="7800">访问频次较高的数据</strong>，用空间换响应速度，核心是减少用户对<strong data-nodeid="7801">数据库的查询压力</strong>。</p>\n<p data-nodeid="7699">从以上概念介绍中，我们需要整理出以下几个关键词：</p>\n<ul data-nodeid="7700">\n<li data-nodeid="7701">\n<p data-nodeid="7702"><strong data-nodeid="7807">临时</strong>，为了避免存储空间的浪费，我们应该尽量设置数据缓存的时间，当过期时自动销毁；</p>\n</li>\n<li data-nodeid="7703">\n<p data-nodeid="7704"><strong data-nodeid="7812">存储空间</strong>，一般选择读写性能较高的内存（本地内存或者共享内存），有些会应用 SSD 进一步提升性能；</p>\n</li>\n<li data-nodeid="7705">\n<p data-nodeid="7706"><strong data-nodeid="7817">访问频次较高的数据</strong>，为了避免存储空间的浪费，应该尽量选择访问频次较高的数据，切莫将任何数据放入缓存；</p>\n</li>\n<li data-nodeid="7707">\n<p data-nodeid="7708"><strong data-nodeid="7822">数据库的查询压力</strong>，我们需要将一些复杂的数据库查询进行缓存，减少数据库访问压力，从而提升用户的响应速度。</p>\n</li>\n</ul>\n<p data-nodeid="7709">在了解了基础概念后，我们再来看下缓存中常见的几个问题，这也是面试过程中常被问及的问题。</p>\n<h3 data-nodeid="7710">缓存问题</h3>\n<p data-nodeid="7711">如果没有应用好缓存，将会<strong data-nodeid="7830">导致一些不可见或者说很难定位的现网事故</strong>，主要是三点：缓存雪崩、缓存击穿和缓存穿透。</p>\n<h4 data-nodeid="7712">1.缓存雪崩</h4>\n<p data-nodeid="7713">在上面概念中，提到了一个关键词叫作临时，因此大部分数据都有一个过期时间的概念，假设我们有一批数据是通过定时服务从数据库写入缓存中，然后我们统一设置了过期时间。当这个时间节点到了，但是由于某种原因数据又没有从数据库写入缓存，导致这时候所有的数据都会前往数据库查询数据，从而引起数据库查询压力，导致数据库并发过大而瘫痪无法正常服务。</p>\n<p data-nodeid="7714">那么应该如何应对呢？</p>\n<p data-nodeid="7715">（1）<strong data-nodeid="7839">避免所有数据都设置同一个过期时间节点</strong>，应该按数据类型、数据更新时效性来设置。</p>\n<p data-nodeid="7716">（2）<strong data-nodeid="7845">数据过期时间应大于数据更新节点时间</strong>，并考虑更新时长，同时增加更新失败异常告警提示。</p>\n<p data-nodeid="7717">（3）对于一些相对较高频次或者数据库查询压力较大的数据，<strong data-nodeid="7851">可不设置过期时间</strong>，主动从程序上来控制该数据的移除或者更替。</p>\n<h4 data-nodeid="7718">2.缓存穿透</h4>\n<p data-nodeid="7719">在上面概念中，提到了一个关键句叫作访问频繁较高的数据，这里就会出现一种情况，比如说查询信息一直是<strong data-nodeid="7858">空数据</strong>，空数据按理不属于访问频繁较高的数据，所以经过了缓存，但是并没有缓存该空数据，而是直接穿透进入了数据库，虽然数据库查询也是空数据，但是还是需要经过数据库的查询，这种现象就是击穿了缓存直接前往了数据库查询。</p>\n<p data-nodeid="7720">那么应该如何应对呢？</p>\n<p data-nodeid="7721">（1）<strong data-nodeid="7865">过滤非正常请求数据</strong>，比如一些从参数就可以知道为空的数据，可以直接从程序上处理。</p>\n<p data-nodeid="7722">（2）<strong data-nodeid="7871">缓存空的结果</strong>，为了提升性能，可以将一些查询为空的结果也缓存起来，这样下次用户再进行访问时，可以直接从缓存中判断返回。</p>\n<p data-nodeid="7723">（3）由于第 2 种方案在空数据较多时会浪费内存空间，我们可以将这些空数据的键名，使用<strong data-nodeid="7877">布隆过滤器</strong>来缓存到缓存，这样可以尽可能地减少内存占用，并且更加高效。</p>\n<h4 data-nodeid="7724">3.缓存击穿</h4>\n<p data-nodeid="7725">这个概念和缓存雪崩有点类似，但不是大面积的缓存过期失效，而是某个访问频次较高的数据失效了，从而导致这一刻高并发的请求全部穿透到了数据库，从而数据库并发压力较高，响应较慢，也进一步导致数据库异常，影响其他业务。</p>\n<p data-nodeid="7726">那么应该如何应对呢？</p>\n<p data-nodeid="7727">（1）高频数据、查询较为复杂的数据，可以不设置过期时间，但是需要程序去维护数据的更替删除。</p>\n<p data-nodeid="7728">（2）如果需要缓存过期时间，要大于缓存更新时间，避免过期无法找到键。</p>\n<p data-nodeid="7729">（3）使用原子操作方案，当多个数据都需要前往数据库查询同一个数据时，告知程序缓存正在生成中，并且告知其他程序可以读取上一次缓存数据，避免同时读取同一份数据。</p>\n<h3 data-nodeid="7730">实现多级缓存</h3>\n<p data-nodeid="7731">在上一讲中我们已经介绍了两种缓存方案：</p>\n<ul data-nodeid="7732">\n<li data-nodeid="7733">\n<p data-nodeid="7734"><strong data-nodeid="7889">本地缓存</strong></p>\n</li>\n<li data-nodeid="7735">\n<p data-nodeid="7736"><strong data-nodeid="7893">共享内存</strong></p>\n</li>\n</ul>\n<p data-nodeid="7737">接下来我们主要基于这两个缓存来实现一个 Node.js 缓存库，以方便后续在项目中应用。</p>\n<h4 data-nodeid="7738">1.代码实现</h4>\n<p data-nodeid="7739">关于本地缓存，我们可以借助一个第三方库 <a href="https://github.com/node-cache/node-cache?fileGuid=3HCRkDrgCrR8h6rY" data-nodeid="7899">node-cache</a>，redis 的话则使用 <a href="https://github.com/NodeRedis/node-redis?fileGuid=3HCRkDrgCrR8h6rY" data-nodeid="7903">node-redis</a> 第三方库，为了实现方便，这里就不详细地介绍 redis 安装和配置了，而是借助 <a href="https://app.redislabs.com/?fileGuid=3HCRkDrgCrR8h6rY" data-nodeid="7907">redis 云服务</a>。这里我已经申请了一个，具体信息如下，你可以使用以下云服务配置，由于是免费的，也可以自行去申请试用。</p>\n<pre class="lang-java" data-nodeid="7740"><code data-language="java">host: <span class="hljs-string">\'redis-17353.c245.us-east-1-3.ec2.cloud.redislabs.com\'</span>,\nport: <span class="hljs-number">17353</span>,\npassword: <span class="hljs-string">\'nodejs@2021\'</span>,\ndb: <span class="hljs-number">0</span>\n</code></pre>\n<p data-nodeid="7741">接下来我们在项目的 lib 中新增一个 cache.js ，在 cache.js 中来实现多级缓存的代码。</p>\n<p data-nodeid="7742">还需要提供三种方案，一种是直接<strong data-nodeid="7923">使用本地缓存</strong>，一种是<strong data-nodeid="7924">使用 redis 缓存</strong>，还有一种就是<strong data-nodeid="7925">都使用</strong>，因此我们需要为 Cache 这个类设置 2 个参数，构造函数实现如下：</p>\n<pre class="lang-javascript" data-nodeid="7743"><code data-language="javascript">  <span class="hljs-keyword">constructor</span>(localCacheEnable=true, redisEnable=true) {\n        <span class="hljs-keyword">this</span>.localCacheEnable = localCacheEnable;\n        <span class="hljs-keyword">this</span>.redisEnable = redisEnable;\n        <span class="hljs-keyword">if</span>(localCacheEnable){\n            <span class="hljs-keyword">this</span>.myCache = <span class="hljs-keyword">new</span> NodeCache();\n        }\n        <span class="hljs-keyword">if</span>(redisEnable) {\n            <span class="hljs-keyword">this</span>.client = redis.createClient({\n                <span class="hljs-attr">host</span>: <span class="hljs-string">\'redis-17353.c245.us-east-1-3.ec2.cloud.redislabs.com\'</span>,\n                <span class="hljs-attr">port</span>: <span class="hljs-number">17353</span>,\n                <span class="hljs-attr">password</span>: <span class="hljs-string">\'nodejs@2021\'</span>,\n                <span class="hljs-attr">db</span>: <span class="hljs-number">0</span>\n            });\n        }\n    }\n</code></pre>\n<p data-nodeid="7744">在本地缓存 localCacheEnable 为 true 时，才会本地缓存初始化；在 redis 缓存 redisEnable 为 true 的时候，我们才会初始化 redis 缓存。</p>\n<p data-nodeid="7745">接下来我们主要看 2 个核心方法的实现，一个是 get 获取缓存内容，一个是 set 设置缓存内容。</p>\n<p data-nodeid="7746">get 获取缓存内容的实现代码如下：</p>\n<pre class="lang-javascript" data-nodeid="7747"><code data-language="javascript">    <span class="hljs-comment">/**\n     * \n     * <span class="hljs-doctag">@description </span>获取缓存信息\n     * <span class="hljs-doctag">@param <span class="hljs-type">{string}</span> </span>key \n     */</span>\n    <span class="hljs-keyword">async</span> get(key) {\n        <span class="hljs-keyword">let</span> value;\n        <span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span>.localCacheEnable) {\n            value = <span class="hljs-keyword">this</span>.myCache.get(key);\n            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`local value is <span class="hljs-subst">${value}</span>`</span>);\n        }\n        <span class="hljs-keyword">if</span>(!value &amp;&amp; <span class="hljs-keyword">this</span>.redisEnable) {\n            <span class="hljs-keyword">try</span> {\n                value = <span class="hljs-keyword">await</span> promisify(<span class="hljs-keyword">this</span>.client.get).bind(<span class="hljs-keyword">this</span>.client)(key);\n                <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`redis value is <span class="hljs-subst">${value}</span>`</span>)\n            } <span class="hljs-keyword">catch</span> (err){\n                <span class="hljs-built_in">console</span>.log(err);\n            }\n        }\n        <span class="hljs-keyword">return</span> value;\n    }\n</code></pre>\n<p data-nodeid="7748">代码逻辑比较清晰，首先判断是否打开了本地缓存，如果有则先从本地缓存中获取，如果没有则查看 redis 缓存是否打开，并且是否存在缓存数据。上面这段代码中，需要将 redis 的 get 方法转化为 promise，所以应用到了 util 工具中的 promisify。</p>\n<p data-nodeid="7749">set 方法的实现代码如下：</p>\n<pre class="lang-javascript" data-nodeid="7750"><code data-language="javascript">   <span class="hljs-comment">/**\n     * \n     * <span class="hljs-doctag">@description </span>保存缓存信息\n     * <span class="hljs-doctag">@param <span class="hljs-type">{string}</span> </span>key 缓存key\n     * <span class="hljs-doctag">@param <span class="hljs-type">{string}</span> </span>value 缓存值\n     * <span class="hljs-doctag">@param <span class="hljs-type">{int}</span> </span>expire 过期时间/秒\n     * <span class="hljs-doctag">@param <span class="hljs-type">{boolean}</span> </span>cacheLocal 是否本地缓存\n     */</span>\n    <span class="hljs-keyword">async</span> set(key, value, expire=<span class="hljs-number">10</span>, cacheLocal=<span class="hljs-literal">false</span>) {\n        <span class="hljs-keyword">let</span> localCacheRet, redisRet;\n        <span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span>.localCacheEnable &amp;&amp; cacheLocal) {\n            localCacheRet = <span class="hljs-keyword">this</span>.myCache.set(key, value, expire);\n        }\n        <span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span>.redisEnable) { \n            <span class="hljs-keyword">try</span> {\n                redisRet = <span class="hljs-keyword">await</span> promisify(<span class="hljs-keyword">this</span>.client.set).bind(<span class="hljs-keyword">this</span>.client)(key, value, <span class="hljs-string">\'EX\'</span>, expire);\n            } <span class="hljs-keyword">catch</span> (err){\n                <span class="hljs-built_in">console</span>.log(err);\n            }\n        }\n        <span class="hljs-keyword">return</span> localCacheRet || redisRet;\n    }\n</code></pre>\n<p data-nodeid="7751">首先还是判断是否启用了本地缓存，同时判断该数据参数是否需要进行本地数据缓存操作，如果都需要则会调用 node-cache 的 set 方法缓存到本地内存中。接下来就判断是否需要进行 redis 缓存，如果需要则调用 node-redis 的 set 方法进行缓存。</p>\n<p data-nodeid="7752">以上就是 2 个核心方法的实现，其他方法比如说 delete 方法可以参照去实现。接下来我们主要看下业务侧的应用以及演示效果。</p>\n<h4 data-nodeid="7753">2.效果演示</h4>\n<p data-nodeid="7754">我们在 controller 中新增一个 cache.js，并且新增 3 个方法，分别是 local、 redis 和 both，然后在中间件 router 中新增相应的路由配置。</p>\n<p data-nodeid="7755">在 cache.js 中，我们首先需要创建 3 个类型的缓存对象，如下所示：</p>\n<pre class="lang-javascript" data-nodeid="7756"><code data-language="javascript"><span class="hljs-keyword">const</span> cache = <span class="hljs-built_in">require</span>(<span class="hljs-string">\'../lib/cache\'</span>)(<span class="hljs-literal">true</span>, <span class="hljs-literal">false</span>); <span class="hljs-comment">// 本地缓存</span>\n<span class="hljs-keyword">const</span> redisCache = <span class="hljs-built_in">require</span>(<span class="hljs-string">\'../lib/cache\'</span>)(<span class="hljs-literal">false</span>, <span class="hljs-literal">true</span>); <span class="hljs-comment">// redis 缓存</span>\n<span class="hljs-keyword">const</span> bothCache = <span class="hljs-built_in">require</span>(<span class="hljs-string">\'../lib/cache\'</span>)(<span class="hljs-literal">true</span>, <span class="hljs-literal">true</span>); <span class="hljs-comment">// 本地+redis</span>\n</code></pre>\n<p data-nodeid="7757">我们先来看下本地缓存的应用实现，如下所示：</p>\n<pre class="lang-javascript" data-nodeid="7758"><code data-language="javascript"><span class="hljs-keyword">async</span> local() {\n        <span class="hljs-keyword">const</span> cacheKey = <span class="hljs-string">\'sum_result\'</span>;\n        <span class="hljs-keyword">let</span> result = <span class="hljs-keyword">await</span> cache.get(cacheKey);\n        <span class="hljs-keyword">if</span>(!result){\n            result = <span class="hljs-number">0</span>;\n            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">1000000000</span>; i++){\n                result = result + i;\n            }\n            cache.set(cacheKey, result, <span class="hljs-number">10</span>, <span class="hljs-literal">true</span>).then();\n        }\n        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.resApi(<span class="hljs-literal">true</span>, <span class="hljs-string">\'success\'</span>, <span class="hljs-string">`sum 0 - 1000000000 is <span class="hljs-subst">${result}</span>`</span>);\n    }\n</code></pre>\n<p data-nodeid="7759">这块代码的逻辑还是与<a href="https://kaiwu.lagou.com/course/courseInfo.htm?courseId=694#/detail/pc?id=6790&amp;fileGuid=3HCRkDrgCrR8h6rY" data-nodeid="7942">《08 | 优化设计：在 I/O 方面应该注意哪些要点？》</a>的类似，都是一个耗 CPU 的计算，首先我们获取缓存内容，如果没有则去计算，计算完成后再缓存到本地内存中。与上一讲不同的是，我们将本地缓存的操作交给了 cache 库。</p>\n<p data-nodeid="7760">redis 和 both 两个方法的实现基本是一样的，只是应用的 cache 实例不一样，不过在 both 中缓存时间也设置得不一样，为了更容易演示，我们只看 both 就可以了，如下所示：</p>\n<pre class="lang-javascript" data-nodeid="7761"><code data-language="javascript"> <span class="hljs-keyword">async</span> both() {\n        <span class="hljs-keyword">const</span> cacheKey = <span class="hljs-string">\'sum_result\'</span>;\n        <span class="hljs-keyword">let</span> result = <span class="hljs-keyword">await</span> bothCache.get(cacheKey);\n        <span class="hljs-keyword">if</span>(!result){ <span class="hljs-comment">// result 为函数本地内存缓存</span>\n            result = <span class="hljs-number">0</span>;\n            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">1000000000</span>; i++){\n                result = result + i;\n            }\n            bothCache.set(cacheKey, result, <span class="hljs-number">600</span>, <span class="hljs-literal">true</span>).then();\n        }\n        <span class="hljs-comment">//bothCache.set(cacheKey, result, 600, true).then();</span>\n        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.resApi(<span class="hljs-literal">true</span>, <span class="hljs-string">\'success\'</span>, <span class="hljs-string">`sum 0 - 1000000000 is <span class="hljs-subst">${result}</span>`</span>);\n    }\n</code></pre>\n<p data-nodeid="7762">接下来我们用以下命令启动该服务：</p>\n<pre class="lang-java" data-nodeid="7763"><code data-language="java">pm2 start pm2.config.js --env development\n</code></pre>\n<p data-nodeid="7764">启动成功后，我们先访问如下地址：</p>\n<pre class="lang-java" data-nodeid="7765"><code data-language="java">http:<span class="hljs-comment">//127.0.0.1:3000/v1/local-cache</span>\n</code></pre>\n<p data-nodeid="7766">你会发现第一次访问较慢，而接下来的 10 秒内访问响应都非常快，这就是本地缓存的作用。同样的方式，我们去访问以下地址：</p>\n<pre class="lang-java" data-nodeid="7767"><code data-language="java">http:<span class="hljs-comment">//127.0.0.1:3000/v1/redis-cache</span>\n</code></pre>\n<p data-nodeid="7768">也是得出一样的结论。虽然两者效果上是一致的，但是在性能上是有一定差距的，这点在之前的<a href="https://kaiwu.lagou.com/course/courseInfo.htm?courseId=694#/detail/pc?id=6790&amp;fileGuid=3HCRkDrgCrR8h6rY" data-nodeid="7953">《08 | 优化设计：在 I/O 方面应该注意哪些要点？》</a>中已经详细说明过。</p>\n<p data-nodeid="7769">接下来我们访问如下地址：</p>\n<pre class="lang-java" data-nodeid="7770"><code data-language="java">http:<span class="hljs-comment">//127.0.0.1:3000/v1/both-cache</span>\n</code></pre>\n<p data-nodeid="7982" class="te-preview-highlight">然后打开 PM2 中的日志路径，由于 <a href="https://github.com/love-flutter/nodejs-column" data-nodeid="7986">GitHub 代码</a>中默认的是 /data/nodejs-column-io/info.log 路径（注意如果没有该路径 PM2 会启动失败，需要先创建路径，也可以放在其他路径下），我们打开日志文件目录。</p>\n\n<p data-nodeid="7772">在访问 both-cache 地址后，你会看到缓存会优先从本地缓存中获取，接下来我们重启下服务，使用如下命令：</p>\n<pre class="lang-java" data-nodeid="7773"><code data-language="java">pm2 restart&nbsp;nodejs-column-io\n</code></pre>\n<p data-nodeid="7774">然后我们再次访问时，你会发现缓存信息只能从 redis 中获取了，<strong data-nodeid="7963">因为本地重启，内存被释放，所以没有数据了</strong>，因此在应用过程中，建议本地和 redis 缓存同时使用，避免因为现网版本发版或者异常重启导致的缓存穿透击穿现象，从而可能引发服务异常问题。</p>\n<pre class="lang-java" data-nodeid="7775"><code data-language="java"><span class="hljs-number">2021</span>-<span class="hljs-number">02</span>-<span class="hljs-number">27</span> <span class="hljs-number">11</span>:<span class="hljs-number">25</span> +<span class="hljs-number">08</span>:<span class="hljs-number">00</span>: local value is undefined\n<span class="hljs-number">2021</span>-<span class="hljs-number">02</span>-<span class="hljs-number">27</span> <span class="hljs-number">11</span>:<span class="hljs-number">25</span> +<span class="hljs-number">08</span>:<span class="hljs-number">00</span>: redis value is <span class="hljs-number">499999999067109000</span>\n</code></pre>\n<p data-nodeid="7776">以上就是多级缓存的实现方案，该库的其他方法你可以自行去补充实现，作为一个小作业，原理基本上是一致的，有任何问题都欢迎在评论区留言。</p>\n<h3 data-nodeid="7777">总结</h3>\n<p data-nodeid="7778">本讲主要介绍了缓存的一些基础知识，着重要掌握的是缓存的三个问题：雪崩、穿透和击穿，这也是面试中常考的点，接下来就是应用 Node.js 实践开发了一个多级缓存的库，可以简单快速地应用本地缓存和 redis 缓存，需要掌握其实现以及后续扩展的实现方法。</p>\n<p data-nodeid="7779">接下来我们要进入第二个部分，系统相关的实践案例分析，下一讲我们先来讲解如何监控和保护进程安全。</p>\n<hr data-nodeid="7780">\n<p data-nodeid="7781"><a href="https://shenceyun.lagou.com/t/mka" data-nodeid="7972"><img src="https://s0.lgstatic.com/i/image6/M00/12/FA/CioPOWBBrAKAAod-AASyC72ZqWw233.png" alt="Drawing 2.png" data-nodeid="7971"></a></p>\n<p data-nodeid="7782"><strong data-nodeid="7976">《大前端高薪训练营》</strong></p>\n<p data-nodeid="7783" class="">对标阿里 P7 技术需求 + 每月大厂内推，6 个月助你斩获名企高薪 Offer。<a href="https://shenceyun.lagou.com/t/mka" data-nodeid="7980">点击链接</a>，快来领取！</p>',
        article_title: "09 | 缓存与应用：多级缓存策略介绍与应用要点",
        title: "09 | 缓存与应用：多级缓存策略介绍与应用要点",
        id: 6791,
      },
    ],
  },
  {
    chapterTitle: "模块二：技术应用分析篇",
    children: [
      {
        content:
          '<p data-nodeid="184402" class="">在开始本讲之前，我们先了解一个特点，<strong data-nodeid="184547">在前端因为某些用户的特殊性，导致的逻辑 Bug 会造成这个用户服务异常，但是在服务端如果没有做好异常保护，因为某个用户的特殊操作可能会导致整个进程退出，从而无法提供服务</strong>，因此如何做好监控和进程安全保护就显得尤为重要。</p>\n<p data-nodeid="184403">本讲我将介绍在 Node.js 代码层面应该如何降低异常出现的概率，其次会介绍当出现现网问题时，如何及时发现并通知相应的开发去处理。</p>\n<h3 data-nodeid="184404">Node.js 进程安全</h3>\n<p data-nodeid="184405">这里我们主要讲解为什么 Node.js 的进程安全和健康状况很重要。</p>\n<h4 data-nodeid="184406">进程安全很重要</h4>\n<p data-nodeid="184407">这里举一个例子，想象一下我们家庭电网的安全保护策略，一般情况下家庭都会有<strong data-nodeid="184557">短路跳闸设施</strong>，其次插座或者电器也设有短路保护功能。</p>\n<p data-nodeid="184408">如果电器没有安全保护措施，就会直接导致家庭电网跳闸整体不可用，但是由于有了跳闸保护，至少我们可以重启，从而服务正常，但是这期间一家人由于一个人的原因，导致了比如说弟弟无法继续看书了、爸爸无法继续洗热水澡了、妈妈无法继续做饭了。</p>\n<p data-nodeid="184409">再说 Node.js，<strong data-nodeid="184564">由于一个用户的异常访问或者数据异常，加上没有做好异常处理和安全保护，直接导致了整个 Node.js 服务重启了，从而中断了所有人的请求，用户体验非常差</strong>。</p>\n<p data-nodeid="184410">接下来我们再往上升级，如果家庭电网没有跳闸短路保护措施，将直接导致上一层电网异常重启，从而影响到其他居民，这样影响面又更大了，从而导致的问题也更严重了。</p>\n<p data-nodeid="184411">这就是和 Node.js 一样的原理，因此我们<strong data-nodeid="184571">要尽可能地在最小处进行安全保护</strong>，也就是我们所说的在每个插电设备上尽量装有短路保护设备一样，这样就最小地影响用户，比如这个用户的异常数据只影响了该用户，而不会因为这个用户影响到整个服务的用户。</p>\n<h4 data-nodeid="184412">哪些场景会导致 Node.js 异常？</h4>\n<ul data-nodeid="184413">\n<li data-nodeid="184414">\n<p data-nodeid="184415">由于 Node.js 使用的是 JavaScript，而<strong data-nodeid="184582">JavaScript 是一个弱类型语言</strong>，因此<strong data-nodeid="184583">在现网经常会引发一些由代码逻辑的异常导致的进程异常退出</strong>。</p>\n</li>\n<li data-nodeid="184416">\n<p data-nodeid="184417">其次在 Node.js 中也经常会因为内存的使用不当，导致内存泄漏，当在 64 位系统中达到 1.4 G（32 位系统 0.7 G）时，Node.js 就会异常崩溃。</p>\n</li>\n<li data-nodeid="184418">\n<p data-nodeid="184419">再而由于<strong data-nodeid="184590">Node.js 的 I/O 较多也较为频繁</strong>，当启用较多 I/O 句柄，但是没有及时释放，同样会引发进程问题。</p>\n</li>\n</ul>\n<p data-nodeid="184420">这些都会导致服务器异常退出，就没办法正常提供服务了，从而引发现网问题。</p>\n<p data-nodeid="184421">接下来我们就从<strong data-nodeid="184601">代码逻辑</strong>和<strong data-nodeid="184602">服务器异常</strong>两个方面来介绍哪些场景会导致这些问题，并且我们应该如何去杜绝这类问题，其次还将演示一个搭建 Node.js 性能告警平台，来解决告警通知机制。</p>\n<h3 data-nodeid="184422">代码逻辑异常汇总</h3>\n<p data-nodeid="184423"><img src="https://s0.lgstatic.com/i/image6/M01/2D/97/Cgp9HWBmwJGAJi8vAAFeHpxgYKQ954.png" alt="Drawing 0.png" data-nodeid="184606"></p>\n<div data-nodeid="184424"><p style="text-align:center">图 1 Node.js 异常问题</p></div>\n<p data-nodeid="184425">以上是一个异常问题的部分汇总，前端同学都应该掌握这些基本问题的解决方案，不过我们也来详细地看看每个问题出现的场景。</p>\n<h4 data-nodeid="184426">null.property</h4>\n<p data-nodeid="184427">由于 JavaScript 是一个弱类型语言，因此<strong data-nodeid="184614">如果对数据没有严格的判断就进行逻辑处理的话，会导致代码服务异常退出，从而影响用户体验</strong>。这里我们统一看 null.property 这种问题。</p>\n<p data-nodeid="184428">首先第一种就是<strong data-nodeid="184620">多层数据嵌套时 (data.str?.str)</strong>，需要逐层地进行数据判断，如下代码所示：</p>\n<pre class="lang-javascript" data-nodeid="184429"><code data-language="javascript"><span class="hljs-keyword">const</span> Controller = <span class="hljs-built_in">require</span>(<span class="hljs-string">\'../core/controller\'</span>);\n<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Error</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Controller</span> </span>{\n    obj() {\n        <span class="hljs-keyword">let</span> data = {\n            <span class="hljs-string">\'userinfo\'</span> : {\n                <span class="hljs-string">\'nick\'</span> : <span class="hljs-string">\'node\'</span>,\n                <span class="hljs-string">\'name\'</span> : <span class="hljs-string">\'nodejs\'</span>,\n                <span class="hljs-string">\'age\'</span>  : <span class="hljs-number">10</span>\n            }\n        };\n        <span class="hljs-keyword">let</span> nick = data.userinfo.nick;\n        data.userinfo = <span class="hljs-literal">null</span>; <span class="hljs-comment">// 中间经过一系列处理，userinfo 被设置为了 null</span>\n        <span class="hljs-keyword">let</span> name = data.userinfo.name; <span class="hljs-comment">// 此时再去访问 userinfo 的信息就无法处理了</span>\n        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.resApi(<span class="hljs-literal">true</span>, <span class="hljs-string">\'good\'</span>, {nick, name});\n    }\n}\n<span class="hljs-built_in">module</span>.exports = <span class="hljs-built_in">Error</span>;\n</code></pre>\n<p data-nodeid="184430"><strong data-nodeid="184625">你可以看到由于 userinfo 是一个 null，使用 null.name 是一定会报错的，而这个报错就会直接导致进程退出</strong>，在我们源码的框架中由于做了保护，是不会退出，而是给出一个如下的提示信息：</p>\n<pre class="lang-java" data-nodeid="184431"><code data-language="java">TypeError: Cannot read property <span class="hljs-string">\'name\'</span> of <span class="hljs-keyword">null</span>\nat Error.obj (/Users/XXX/Desktop/专栏技术/nodejs/nodejs-column/<span class="hljs-number">10</span>/src/controller/error.js:<span class="hljs-number">18</span>:<span class="hljs-number">34</span>)\n</code></pre>\n<p data-nodeid="184432">data.str?.str 和 data[$str]?[$str] 是类似的，但是<strong data-nodeid="184647">data[$str]?[$str] 这种问题在现网出现会更多</strong>，由于 $str 是一个变量，因此这个变量都有可能为 null，如下代码所示：</p>\n<pre class="lang-javascript" data-nodeid="184433"><code data-language="javascript">    arrObj() {\n        <span class="hljs-keyword">let</span> data = {\n            <span class="hljs-string">\'userinfo\'</span> : {\n                <span class="hljs-string">\'nick\'</span> : <span class="hljs-string">\'node\'</span>,\n                <span class="hljs-string">\'name\'</span> : <span class="hljs-string">\'nodejs\'</span>,\n                <span class="hljs-string">\'lastName\'</span> : <span class="hljs-string">\'js\'</span>,\n                <span class="hljs-string">\'age\'</span>  : <span class="hljs-number">10</span>\n            },\n            <span class="hljs-string">\'js-nodejs\'</span> : {\n                <span class="hljs-string">\'Chinese\'</span> : <span class="hljs-string">\'90\'</span>,\n                <span class="hljs-string">\'English\'</span> : <span class="hljs-string">\'80\'</span>,\n                <span class="hljs-string">\'Mathematics\'</span> : <span class="hljs-string">\'99\'</span>\n            }\n        };\n        <span class="hljs-keyword">let</span> lastName = data.userinfo.lastName;\n        <span class="hljs-keyword">let</span> name = data.userinfo.name;\n        <span class="hljs-keyword">let</span> fullName =  <span class="hljs-string">`<span class="hljs-subst">${lastName}</span> <span class="hljs-subst">${name}</span>`</span>; <span class="hljs-comment">// 获取用户真实姓名，由于数据中使用的是 - 连接，这里使用的是空格，导致了异常 </span>\n        <span class="hljs-keyword">let</span> chineseFraction = data[fullName][<span class="hljs-string">\'Chinese\'</span>]; <span class="hljs-comment">// 由于 fullName 不存在，所以会导致异常</span>\n        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.resApi(<span class="hljs-literal">true</span>, <span class="hljs-string">\'good\'</span>, {chineseFraction});\n    }\n</code></pre>\n<p data-nodeid="184434">以上问题在实际开发过程中更常见，由于 fullName 是一个变量，而变量往往是不同的值，因此出现问题的概率性更高。</p>\n<p data-nodeid="184435">避免上面两个问题的方式也非常简单，就是对数据进行一些必要的检查就可以了，下面就是修复后的逻辑：</p>\n<pre class="lang-javascript" data-nodeid="184436"><code data-language="javascript"><span class="hljs-keyword">let</span> nick = data.userinfo.nick;\ndata.userinfo = <span class="hljs-literal">null</span>; <span class="hljs-comment">// 中间经过一系列处理，userinfo 被设置为了 null</span>\n<span class="hljs-keyword">if</span>(!data || !data.userinfo){ <span class="hljs-comment">// 注意既需要判断 data 也需要判断 userinfo</span>\n  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.resApi(<span class="hljs-literal">true</span>, <span class="hljs-string">\'data error\'</span>);\n}\n<span class="hljs-keyword">let</span> name = data.userinfo.name; <span class="hljs-comment">// 此时再去访问 userinfo 的信息就无法处理</span>\n</code></pre>\n<p data-nodeid="184437"><strong data-nodeid="184654">主要是对每一层数据都进行校验</strong>，从 data 到 data.userinfo，而如果有四层，那么就需要前三层逐层去判断，代码可读性以及后期可维护性都比较低。</p>\n<p data-nodeid="184438">这样会发现一个问题，<strong data-nodeid="184660">当数据结构非常复杂时，你的判断逻辑也会非常复杂，从而影响了开发效率，为了解决这个问题我们可以使用 lodash 这个库的 get 方法</strong>，代码修改如下：</p>\n<pre class="lang-javascript" data-nodeid="184439"><code data-language="javascript"><span class="hljs-keyword">let</span> lastName = data.userinfo.lastName;\n<span class="hljs-keyword">let</span> name = data.userinfo.name;\n<span class="hljs-keyword">let</span> fullName =  <span class="hljs-string">`<span class="hljs-subst">${lastName}</span> <span class="hljs-subst">${name}</span>`</span>; <span class="hljs-comment">// 获取用户真实姓名，由于数据中使用的是 - 连接，这里使用的是空格，导致了异常 </span>\n<span class="hljs-keyword">let</span> chineseFraction = _.get(data, <span class="hljs-string">`<span class="hljs-subst">${fullName}</span>.Chinese`</span>, <span class="hljs-number">0</span>); <span class="hljs-comment">// 使用 lodash 来简化</span>\n</code></pre>\n<p data-nodeid="184440">在上面代码中的第 5 行，就简化了这部分判断逻辑，可以直接去获取属性，如果未获取到则设置默认 0 这个值，避免异常情况。</p>\n<p data-nodeid="184441">这样以后在系统层面就不会报错了，建议后续我们都使用这种方法来尽量避免以上的异常问题。</p>\n<p data-nodeid="184442"><strong data-nodeid="184677">object?.forEach</strong>和<strong data-nodeid="184678">for(let i=0;i&lt;arr?.length:i++){}</strong> 这类问题和上面基本相似。不过这里是<strong data-nodeid="184679">类型的判断</strong>，应用这些方法之前都需要进行类型的检测，不然也会引发现网异常，例如下面这种处理方式才是正确的。</p>\n<p data-nodeid="184443"><img src="https://s0.lgstatic.com/i/image6/M01/2D/97/Cgp9HWBmwOiAAUQHAACrzbEZSFM047.png" alt="Drawing 1.png" data-nodeid="184682"><br>\n<img src="https://s0.lgstatic.com/i/image6/M00/2D/9F/CioPOWBmwO6AFikrAADYDnDm-Ts197.png" alt="Drawing 2.png" data-nodeid="184686"></p>\n<div data-nodeid="184444"><p style="text-align:center">图 2 for 类型检测方法</p></div>\n<p data-nodeid="184445">我们对比下左右两边的逻辑，<strong data-nodeid="184692">只需要判断是否为 null 就行了，因为我们需要使用数组的 length 属性，如果是一个 null.length 则会引发报错</strong>。</p>\n<h4 data-nodeid="184446">parameters error</h4>\n<p data-nodeid="184447">接下来我们看下<strong data-nodeid="184703">内部参数导致的一些问题</strong>，主要来看下常用的<strong data-nodeid="184704">JSON.parse</strong>。</p>\n<p data-nodeid="184448"><strong data-nodeid="184709">关于 JSON.parse 很多时候我们都比较自然地将其他接口或者第三方的数据拿来解析，但是这里往往会忽略其非 JSON 字符串的问题</strong>，比如下面这段代码就会引发异常：</p>\n<pre class="lang-javascript" data-nodeid="184449"><code data-language="javascript">jsonParse() {\n  <span class="hljs-keyword">let</span> str = <span class="hljs-string">\'nodejs\'</span>;\n  <span class="hljs-keyword">let</span> obj = <span class="hljs-built_in">JSON</span>.parse(str);\n\n  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.resApi(<span class="hljs-literal">true</span>, <span class="hljs-string">\'good\'</span>, obj);\n}\n</code></pre>\n<p data-nodeid="184450">为了解决这个问题，我们需要进行<strong data-nodeid="184715">try catch 异常判断</strong>，如下代码所示：</p>\n<pre class="lang-javascript" data-nodeid="184451"><code data-language="javascript">jsonParse() {\n  <span class="hljs-keyword">let</span> str = <span class="hljs-string">\'nodejs\'</span>;\n  <span class="hljs-keyword">let</span> obj = {};\n  <span class="hljs-keyword">try</span> {\n    obj = <span class="hljs-built_in">JSON</span>.parse(str);\n  } <span class="hljs-keyword">catch</span> (err) {\n    <span class="hljs-built_in">console</span>.log(err);\n  }\n\n  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.resApi(<span class="hljs-literal">true</span>, <span class="hljs-string">\'good\'</span>, obj);\n}\n</code></pre>\n<p data-nodeid="184452">在我们框架中也存在一个问题，就是<strong data-nodeid="184725">require</strong>的时候未进行异常判断，这部分你可以去<a href="https://github.com/love-flutter/nodejs-column?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="184723">第 09 讲源码中</a>查看，并与本讲的代码进行对比，看看哪部份进行了修改。</p>\n<p data-nodeid="184453"><strong data-nodeid="184730">其次 Node.js 的 fs 这个模块应用是非常多的，在应用 fs 的方法时，最好是使用 try catch 进行异常处理</strong>，因为很多时候可能存在权限不足或者文件不存在等问题。</p>\n<h4 data-nodeid="184454">other errors</h4>\n<p data-nodeid="184455">JavaScript 也存在一些语法问题，由于 Node.js 是运行时报错，因此语法问题也只会在运行期间被发现，比如我们常发现的同变量重新申明的问题，<strong data-nodeid="184737">特别是 let 和 var 声明同一个变量</strong>。</p>\n<p data-nodeid="184456"><strong data-nodeid="184742">当前 Node.js 的 Promise 应用越来越广泛了，因此对于 Promise 的 catch 也应该多进行重视</strong>，对于每个 Promise 都应该要处理其异常 catch 逻辑，不然系统会提示 warning 信息。</p>\n<p data-nodeid="184457">还有一些常见的长连接的服务，比如 Socket、Redis、Memcache 等等，我们需要在连接异常时进行处理，如果没有处理同样会导致异常，<strong data-nodeid="184748">比如 Socket 提供了 Socket.on(‘error’) 的监听</strong>。</p>\n<p data-nodeid="184458">还有其他的常见问题，希望各位同学在下面补充，我们一起来完善这份报错指引。</p>\n<h3 data-nodeid="184459">常见服务异常解析</h3>\n<p data-nodeid="184460">服务器异常在 Node.js 中最常见的问题主要是<strong data-nodeid="184764">内存泄漏</strong>、<strong data-nodeid="184765">句柄泄漏</strong>以及<strong data-nodeid="184766">网络模块调用</strong>。</p>\n<p data-nodeid="184461">接下来我们看看一些更深层次的关于 Node.js 的问题，我们先来回顾下在《08 | 优化设计：在 I/O 方面应该注意哪些要点？》所介绍的高性能日志模块的设计：</p>\n<ul data-nodeid="184462">\n<li data-nodeid="184463">\n<p data-nodeid="184464"><strong data-nodeid="184776">设置最大临时缓存数，超出则不使用缓存</strong>；</p>\n</li>\n<li data-nodeid="184465">\n<p data-nodeid="184466"><strong data-nodeid="184781">设置最大缓存句柄数，超出则不使用缓存</strong>；</p>\n</li>\n<li data-nodeid="184467">\n<p data-nodeid="184468"><strong data-nodeid="184786">定时清理当前的临时缓存和句柄缓存</strong>。</p>\n</li>\n</ul>\n<p data-nodeid="184469">这三个设计的目的主要是<strong data-nodeid="184792">为了避免内存泄漏、句柄泄漏问题</strong>。可以思考下，如果不进行定时清理或者上限限制，随着时间的增长，其中文件句柄会越来越多，其次在并发较高时，临时缓存的日志内容可能超出 1.4 G，从而引发重启。</p>\n<p data-nodeid="184470">具体实际开发中还有哪些场景我们也来详细分析下。</p>\n<h4 data-nodeid="184471">全局变量</h4>\n<p data-nodeid="184472"><strong data-nodeid="184799">一般情况下不建议使用全局变量</strong>，因为全局变量是最容易引发内存泄漏问题的，举个简单的例子，比如我们需要将用户的 session 保存在一个全局变量中，随着用户越来越多，这个 session 变量保存的数据也会越来越大，而且没有清理的规则，即使有清理规则，清理时间的长短影响用户体验，其次也影响内存的大小。</p>\n<p data-nodeid="184473">包括我们上面所说的日志模块就是一个全局变量，这个全局变量必须要<strong data-nodeid="184805">有一定的上限和清理规则才能保证服务的安全</strong>。</p>\n<h4 data-nodeid="184474">单例模块中的变量</h4>\n<p data-nodeid="184475">要注意一个点，有些模块我们使用单例的模式，就是在每次 require 后都返回这个对象，这种情况也比较容易引发内存泄漏的问题。</p>\n<p data-nodeid="184476">因为<strong data-nodeid="184813">单例模式会引发每个用户访问的数据的叠加</strong>，比如下面这个模块的代码：</p>\n<pre class="lang-javascript" data-nodeid="184477"><code data-language="javascript"><span class="hljs-keyword">let</span> singleton;\n<span class="hljs-keyword">const</span> userList = [];\n<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span> </span>{\n    add(uid) {\n        userList.push(uid);\n    }\n    getLength() {\n        <span class="hljs-keyword">return</span> userList.length;\n    }\n}\n<span class="hljs-built_in">module</span>.exports = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {\n    <span class="hljs-keyword">if</span>(singleton){\n        <span class="hljs-keyword">return</span> singleton;\n    }\n    singleton = <span class="hljs-keyword">new</span> Singleton();\n    <span class="hljs-keyword">return</span> singleton;\n}\n</code></pre>\n<p data-nodeid="184478">以上代码就是一个单例模式，其中会无限地往 userList push 数据，每调用一次 add 插入一条数据，这样会导致内存泄漏的问题，我们在 GitHub 源码的 error.js 中的 controller 有一个 singletonTest 方法，你会发现每调用一次数组长度就 +1，并且永远不会减少，除非重启。</p>\n<p data-nodeid="184479">对于这种单例的代码，<strong data-nodeid="184820">我们要严格地进行 CR</strong>，因为这种问题真的很容易被忽视。</p>\n<h4 data-nodeid="184480">打开文件后，未主动关闭</h4>\n<p data-nodeid="184481">这个是最容易理解的，一般打开文件句柄后，我们都应该主动关闭，<strong data-nodeid="184827">如果未主动关闭，就会导致文件句柄越来越多，从而引发句柄泄漏问题</strong>。</p>\n<p data-nodeid="184482">在 Node.js 里 fs 的模块中都提供了打开文件句柄关闭的方法，比如 fs.open 提供了 fs.close 的方法，其次比如 fs.createWriteStream 提供了 fileStream.end 的方法。</p>\n<h4 data-nodeid="184483">网络句柄</h4>\n<p data-nodeid="184484">网络句柄超出的情况一般还好，因为目标服务器会主动拒绝了你的请求，但是作为调用方，应该也要复用句柄，主动避免这类问题。其次还要注意连接超时控制，特别是在使用 Node.js 第三方库 request 以及 Socket 模块时。</p>\n<h3 data-nodeid="184485">监控告警介绍</h3>\n<p data-nodeid="184486">图 3 是一个最简单的层级结构图，具体每个层级设计其实是非常复杂的。</p>\n<p data-nodeid="184487"><img src="https://s0.lgstatic.com/i/image6/M00/2D/98/Cgp9HWBmwY2AXDslAABuqH1Pwi0559.png" alt="Drawing 3.png" data-nodeid="184835"></p>\n<div data-nodeid="184488"><p style="text-align:center">图 3 监控告警平台简单流程图</p></div>\n<p data-nodeid="184489">我们可以看到在 Node.js 服务器中，会包含两部分：</p>\n<ul data-nodeid="184490">\n<li data-nodeid="184491">\n<p data-nodeid="184492"><strong data-nodeid="184841">自动定时采集进程的指标数据</strong>；</p>\n</li>\n<li data-nodeid="184493">\n<p data-nodeid="184494"><strong data-nodeid="184846">接口被调用或者访问后主动上报的信息</strong>。</p>\n</li>\n</ul>\n<p data-nodeid="184495">以上的两部分信息都会异步地发送给本地一个采集服务，落地到本地临时缓存中，然后定时地将本地临时缓存的上报信息发送给监控数据处理服务。</p>\n<p data-nodeid="184496">监控数据处理经过一系列的复杂计算，按照一定的数据要求落入监控平台的数据存储中，告警平台则使用特定 QL 语法查询数据库，主要服务于三种类型：</p>\n<ul data-nodeid="184497">\n<li data-nodeid="184498">\n<p data-nodeid="184499"><strong data-nodeid="184853">触发告警</strong>，根据告警平台的设置，当数据落入后判断是否满足告警机制，满足则调用告警模块触发告警；</p>\n</li>\n<li data-nodeid="184500">\n<p data-nodeid="184501"><strong data-nodeid="184858">查询视图</strong>，这部分就是一个前端可交互的界面，用户可以在这个平台查询监控信息；</p>\n</li>\n<li data-nodeid="184502">\n<p data-nodeid="184503"><strong data-nodeid="184863">API 接口</strong>，有些情况需要针对告警进行一些研发操作，因此也支持 API 来查询监控告警信息。</p>\n</li>\n</ul>\n<p data-nodeid="184504">接下来我们再来看看 Node.js 到底有哪些监控告警平台，以及监控的指标会有哪些。</p>\n<h4 data-nodeid="184505">平台介绍</h4>\n<p data-nodeid="184506">在系统监控告警方面，<strong data-nodeid="184871">Node.js 的 PM2 提供了付费服务</strong>，你可以直接用 PM2 来构建一个专门的监控告警机制，其中覆盖的进程管理功能也是比较齐全的。</p>\n<p data-nodeid="184507">不过还有另外一个方式就是<strong data-nodeid="184881">自己构建一套开源免费的 prometheus 服务</strong>，如果是公司级别应用的话，可以参考 prometheus 官网自己搭建一套这种服务，其对 Node.js 的支持也是非常到位的，扩展请参考<a href="https://github.com/siimon/prom-client?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="184879">GitHub prom-client 库</a>。</p>\n<p data-nodeid="184508">而在业务告警方面你可以直接<strong data-nodeid="184895">复用当前后台侧的业务告警系统</strong>，或者<strong data-nodeid="184896">prometheus</strong>也是可以的，又或者目前常用的一套组合系统<strong data-nodeid="184897">Grafana（主要是监控系统界面操作平台）+InfluxDB（数据存储）+telegraf（数据采集）</strong> 也可以。</p>\n<p data-nodeid="184509">以上工具，具体如何安装、配置、使用，你可以去官网按照指引进行即可，我们接下来看下到底会监控哪些指标以及各个指标的含义。</p>\n<h4 data-nodeid="184510">监控指标</h4>\n<p data-nodeid="184511">在进程监控告警层面，我们要了解到底应该监控 Node.js 的哪些指标属性，其次在业务层面我们又应该主动上报哪些信息来作为监控指标。</p>\n<p data-nodeid="184512">在 Node.js 进程方面我们要监控以下几个指标。</p>\n<ul data-nodeid="184513">\n<li data-nodeid="184514">\n<p data-nodeid="184515"><strong data-nodeid="184914">事件延迟</strong>，因为 Node.js 主要是事件循环，如果主线程被长时间占用，就会导致事件执行有延迟，而最简单的办法就是<strong data-nodeid="184915">使用 setTimeout 来判断</strong>。当我们设定 1000ms 执行某个事件，但是真正开始执行的时间大于 1000ms，那么我们就可能存在事件延迟了，而如果这个延迟越来越长，那么就必须进行<strong data-nodeid="184916">告警</strong>提示开发者需要查看是否有异常事件被卡住，或者服务压力过大。</p>\n</li>\n<li data-nodeid="184516">\n<p data-nodeid="184517"><strong data-nodeid="184925">CPU 使用率</strong>，这是一个非常重要的指标，当发现 CPU 使用率长期维持在 70% 以上，我们就要<strong data-nodeid="184926">考虑是否需要扩容，或者是增加进程的方式来解决这个问题</strong>，如果长期在 100% 那么肯定是需要扩容，或者检查内部代码逻辑是否存在问题。</p>\n</li>\n<li data-nodeid="184518">\n<p data-nodeid="184519"><strong data-nodeid="184935">内存变化</strong>，Node.js 的内存泄漏还是比较常见的，其<strong data-nodeid="184936">最大的问题就是导致垃圾回收时间变长，从而影响 Node.js 的服务性能，最大的影响就是内存达到上限后进行重启，从而中断用户请求，引发在重启过程中的用户请求</strong>。</p>\n</li>\n<li data-nodeid="184520">\n<p data-nodeid="184521"><strong data-nodeid="184941">句柄变化</strong>，由于服务器的句柄是有上限的，如果无节制地开启句柄，将会导致系统性能损耗，从而影响进程的性能，因此我们必须在未使用句柄时进行释放，而如果长期不释放就会在达到上限时，导致新的请求无法开启新的句柄，从而无法正常提供服务。</p>\n</li>\n<li data-nodeid="184522">\n<p data-nodeid="184523"><strong data-nodeid="184946">进程异常重启次数</strong>，也是用来判断我们代码逻辑是否足够健壮的一个点，如果存在异常重启次数，那么一定是我们代码中存在未 catch 住的异常，或者说上面提到的内存泄漏上限问题。</p>\n</li>\n</ul>\n<p data-nodeid="184524">以上指标在达到一定限度的时候，就应该进行告警提示开发者。</p>\n<p data-nodeid="184525">在业务层面，我们主要是关心服务提供的<strong data-nodeid="184953">业务响应速度</strong>，我们需要把所有的接口按照以下指标进行上报（这点和其他后台服务差异不大）。</p>\n<ul data-nodeid="184526">\n<li data-nodeid="184527">\n<p data-nodeid="184528"><strong data-nodeid="184958">接口名称</strong>，主要是用来区分接口的唯一性。</p>\n</li>\n<li data-nodeid="184529">\n<p data-nodeid="184530"><strong data-nodeid="184963">接口请求时服务器时间</strong>，用来保留用户请求的时间节点。</p>\n</li>\n<li data-nodeid="184531">\n<p data-nodeid="184532"><strong data-nodeid="184968">接口的请求用户分类标识</strong>，有些需要根据设备、地区、网络运营商、版本信息等进行不同纬度的数据统计，因此这部分需要根据自身业务进行上报。</p>\n</li>\n<li data-nodeid="184533">\n<p data-nodeid="184534"><strong data-nodeid="184973">接口请求耗时</strong>，尽量细分，比如 Node.js 内部逻辑耗时、第三方接口耗时以及一些存储服务的请求耗时，例如 Redis、MySQL、MongoDB 等。</p>\n</li>\n<li data-nodeid="184535">\n<p data-nodeid="184536"><strong data-nodeid="184978">当前服务器 IP</strong>，有些可能和服务器有关，比如如果负载均衡未做好，导致部分机器分发的请求过大，从而引发部分机器过载的问题，因此上报当前服务器的 IP 也是非常关键的点。</p>\n</li>\n</ul>\n<p data-nodeid="184537">拿到上面这些指标数据后，我们就可以在类似 Grafana 平台中进行数据配置和监控告警设置，当接口耗时对比昨天同时刻出现较大波动时，或者超出用户可接受的响应时间时则进行告警。</p>\n<h3 data-nodeid="184538">总结</h3>\n<p data-nodeid="184539">学完本讲后，你首先应该明白为什么进程的安全是一个比较重要的原因，其次要掌握一些基础的会导致进程异常的问题以及如何优化的方案，最后就是要了解目前 Node.js 监控指标以及当前适合 Node.js 的告警监控平台。</p>\n<p data-nodeid="184540">别忘了上文提到的，让我们在留言区一起完善报错指引。</p>\n<p data-nodeid="186150">下一讲我们将针对本讲中所提到的内存泄漏问题进行详细阐述，教你如何一步步定位到内存泄漏的问题，其次在 GitHub 源码中会发现 router 的路由对象越来越大了，我们也需要进一步去优化，在下一讲中，我们会直接使用优化后的路由文件，也会顺便介绍优化的方法。</p>\n<hr data-nodeid="186151">\n<p data-nodeid="186152"><a href="https://shenceyun.lagou.com/t/mka" data-nodeid="186160"><img src="https://s0.lgstatic.com/i/image6/M00/12/FA/CioPOWBBrAKAAod-AASyC72ZqWw233.png" alt="Drawing 2.png" data-nodeid="186159"></a></p>\n<p data-nodeid="186153"><strong data-nodeid="186164">《大前端高薪训练营》</strong></p>\n<p data-nodeid="186154" class="te-preview-highlight">对标阿里 P7 技术需求 + 每月大厂内推，6 个月助你斩获名企高薪 Offer。<a href="https://shenceyun.lagou.com/t/mka" data-nodeid="186168">点击链接</a>，快来领取！</p>',
        article_title: "10 | 系统稳定：如何监控和保护进程安全？",
        title: "10 | 系统稳定：如何监控和保护进程安全？",
        id: 6792,
      },
      {
        content:
          '<p data-nodeid="188830" class="">前面一讲我们主要介绍了进程的安全，而内存的泄漏异常是进程安全的其中一种场景，那么本讲我们就来详细介绍一下，什么是内存泄漏以及当出现内存异常时，我们应该如何去分析并定位具体的问题。其次在上一讲中，我们提到了需要优化 router 这个中间件，我们将在本讲末说明下。</p>\n<h3 data-nodeid="188831">内存泄漏</h3>\n<blockquote data-nodeid="188832">\n<p data-nodeid="188833">内存泄漏（Memory Leak）是指程序中已动态分配的堆内存，由于某种原因程序未释放或无法释放，造成系统内存的浪费，导致程序运行速度减慢甚至系统崩溃等严重后果。</p>\n</blockquote>\n<p data-nodeid="188834">这是来自百度百科的一段解释，下面我们先来看下 Node.js 中的内存回收策略。</p>\n<h4 data-nodeid="188835">Node.js GC 的策略</h4>\n<p data-nodeid="188836">首先我们要理解在 Node.js 存储中分为堆和栈：</p>\n<ul data-nodeid="188837">\n<li data-nodeid="188838">\n<p data-nodeid="188839"><strong data-nodeid="188961">栈中主要存储的是一些原始类型</strong>，比如 Boolean、Null、Undefined、Number、BigInt、String 以及 Symbol；</p>\n</li>\n<li data-nodeid="188840">\n<p data-nodeid="188841"><strong data-nodeid="188966">堆中主要存储引用类型的数据</strong>，比如对象、全局变量等。</p>\n</li>\n</ul>\n<p data-nodeid="188842"><strong data-nodeid="188971">由于栈是系统存储的临时数据，因此系统会进行释放，不会引发内存泄漏问题；而堆中的数据是需要程序自己进行清理，因此存在内存泄漏风险，在 JavaScript 中进行垃圾回收的有引用计数和标记清除法</strong>。</p>\n<p data-nodeid="188843">而<strong data-nodeid="188977">在 Node.js V8 引擎中使用了多种方法的融合</strong>：</p>\n<ul data-nodeid="188844">\n<li data-nodeid="188845">\n<p data-nodeid="188846">对于存活较短的存储对象会使用<strong data-nodeid="188983">Scavenge 算法</strong>；</p>\n</li>\n<li data-nodeid="188847">\n<p data-nodeid="188848">而对于存活较长的对象或者说在 Scavenge 算法中存储的对象数据超过一定比例时，则会使用<strong data-nodeid="188989">标记清除法与标记整理法相结合的方式</strong>。</p>\n</li>\n</ul>\n<p data-nodeid="188849">具体这三种算法的细节，你需要自行去了解下，本讲核心还是内存泄漏的类型以及分析方法，下面我们先来了解下内存泄漏的分类。</p>\n<h3 data-nodeid="188850">内存泄漏分类</h3>\n<p data-nodeid="188851"><strong data-nodeid="188996">内存泄漏可以分为 4 种类型，分别是常发性、偶发性、一次性和隐性</strong>。</p>\n<h4 data-nodeid="188852">1.常发性</h4>\n<p data-nodeid="188853"><strong data-nodeid="189002">发生内存泄漏的代码会被多次执行，每次被执行的时候都会导致一块内存泄漏</strong>。这种是比较好理解的，比如说我们有一个全局变量，在每次调用该部分业务逻辑时，都会导致该变量的数据增加，这就是常发性。这种问题一般比较好定位，只要在开发或者测试阶段就可以快速定位到。</p>\n<h4 data-nodeid="188854">2.偶发性</h4>\n<p data-nodeid="188855"><strong data-nodeid="189012">发生内存泄漏的代码只有在某些特定环境或操作过程下才会发生</strong>。<strong data-nodeid="189013">常发性和偶发性是相对的</strong>。对于特定的环境，偶发性也许就变成了常发性。比如虽然都是全局变量，A 逻辑只要调用就会增加，而 B 逻辑需要满足各种复杂条件后才会增加，那么 B 就是偶发性，而 A 就是上面的常发性。</p>\n<h4 data-nodeid="188856">3.一次性</h4>\n<p data-nodeid="188857"><strong data-nodeid="189019">发生内存泄漏的代码只会被执行一次，或者由于算法上的缺陷，导致总会有一块且仅一块内存发生泄漏</strong>。这种情况如果出现的次数不多，那么影响相对较小，比如说我们在启动 Node.js 服务后，require 并初始化了一个对象，但是并没有在程序中使用这个对象，我们知道在 Node.js require 的模块是会被缓存起来的，因此这也算是一种内存泄漏场景，只是这类场景影响非常有限。</p>\n<h4 data-nodeid="188858">4.隐性</h4>\n<p data-nodeid="188859"><strong data-nodeid="189025">在调用函数或者模块时，当参数或者输入没有达到界定值时，是不会发生泄漏，当参数或者输入值达到一定时，才会发现内存泄漏，我们称这种为隐性</strong>。举个简单的例子，比如我们要读取一个文件，当文件很小时，我们内存可以处理，但是当读取的文件非常大，则会导致内存异常问题，严格来说隐性的情况并不是内存泄漏，因为当程序调用结束后，还是会最终释放。</p>\n<h3 data-nodeid="188860">Node.js 内存泄漏分析方法</h3>\n<p data-nodeid="188861">一般情况下内存的增长是不会立即出现的，而是缓慢地增长，特别是偶发性和隐性的情况，因此<strong data-nodeid="189032">我们需要选择相应的时间来进行一些内存快照分析</strong>。</p>\n<p data-nodeid="188862"><strong data-nodeid="189041">如果内存泄漏是常发性的，这就不需要到生产环境（现网环境）复现了，可以直接在开发或者测试环境进行内存快照即可</strong>。<strong data-nodeid="189042">而如果是偶发性的或者隐性的情况，你才需要在生产环境进行内存快照</strong>。</p>\n<p data-nodeid="188863">接下来我们先来看看，这其中会应用到哪些工具。</p>\n<h4 data-nodeid="188864">1.工具介绍</h4>\n<p data-nodeid="188865">只需要 2 个工具就可以分析出内存泄漏的问题：</p>\n<ul data-nodeid="188866">\n<li data-nodeid="188867">\n<p data-nodeid="188868">heapdump 内存快照的工具</p>\n</li>\n<li data-nodeid="188869">\n<p data-nodeid="188870">chrome dev tools 中的 Memory Profiles</p>\n</li>\n</ul>\n<p data-nodeid="188871"><strong data-nodeid="189051">heapdump</strong></p>\n<p data-nodeid="188872">该工具主要是生成一个内存快照文件，在我们框架项目中，你可以直接 require lib 下的 heapdump 这个库即可，比如我们的 app.js 这段代码：</p>\n<pre class="lang-javascript" data-nodeid="188873"><code data-language="javascript"><span class="hljs-keyword">const</span> Koa = <span class="hljs-built_in">require</span>(<span class="hljs-string">\'koa\'</span>);\n<span class="hljs-keyword">const</span> app = <span class="hljs-keyword">new</span> Koa();\n<span class="hljs-keyword">const</span> routerMiddleware = <span class="hljs-built_in">require</span>(<span class="hljs-string">\'./src/middleware/router\'</span>);\n<span class="hljs-keyword">const</span> logCenter = <span class="hljs-built_in">require</span>(<span class="hljs-string">\'./src/middleware/logCenter\'</span>);\n<span class="hljs-keyword">const</span> dumpFun = <span class="hljs-built_in">require</span>(<span class="hljs-string">\'./src/lib/heapdump\'</span>); \napp.use(logCenter());\napp.use(routerMiddleware());\napp.listen(<span class="hljs-number">3000</span>, () =&gt; <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`Example app listening on port 3000!`</span>));\ndumpFun(<span class="hljs-string">\'nodejs-cloumn\'</span>, <span class="hljs-string">\'10:53\'</span>, <span class="hljs-number">60</span>);\n</code></pre>\n<p data-nodeid="188874">在代码中的第 5 行引用了这个库，然后调用 dumpFun 从 10 点 53 分开始，每隔 60 秒打印一次内存快照。这个库如何实现的细节，你可以自己去 <a href="https://github.com/love-flutter/nodejs-column?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="189056">GitHub 源码</a>中的 lib 目录下查看，主要是<strong data-nodeid="189062">做了一层封装，能够更好地适用我们的应用场景</strong>。</p>\n<p data-nodeid="188875"><strong data-nodeid="189066">chrome dev tools</strong></p>\n<p data-nodeid="188876">打开 Chrome 浏览器的控制台，在图 1 界面可以找到该工具。</p>\n<p data-nodeid="188877"><img src="https://s0.lgstatic.com/i/image6/M00/2D/A4/CioPOWBmwqqAQM50AAD9oysXX_E217.png" alt="Drawing 0.png" data-nodeid="189070"></p>\n<div data-nodeid="188878"><p style="text-align:center">图 1 chrome dev tools 的 Memory 工具</p></div>\n<p data-nodeid="188879">把生成的内存快照文件，点击 Load 按钮加载进来。</p>\n<p data-nodeid="188880">接下来我们做一些实践的例子分析，来介绍下具体的使用方法。</p>\n<h4 data-nodeid="188881">2.实践分析</h4>\n<p data-nodeid="188882">在介绍之前，我们先来看一个常发性的内存泄漏场景，假设我们有一个 session 处理的模块，每次用户请求时需要判断用户是否有登录态，因此需要将 session 保存在一个地方，这里我们保存在内存中。为了效果，我们在请求登录的接口时，进行一个比较大的循环处理，代码如下：</p>\n<pre class="lang-javascript" data-nodeid="188883"><code data-language="javascript"><span class="hljs-keyword">const</span> Controller = <span class="hljs-built_in">require</span>(<span class="hljs-string">\'../core/controller\'</span>);\n<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MemLeak</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Controller</span> </span>{\n    login() {\n        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">10000000</span>; i++){\n            <span class="hljs-keyword">this</span>.ctx.session.set(i);\n        }\n        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.resApi(<span class="hljs-literal">true</span>, <span class="hljs-string">\'set success\'</span>);\n    }\n}\n<span class="hljs-built_in">module</span>.exports = MemLeak;\n</code></pre>\n<p data-nodeid="188884">这个文件在源码的 controller/memLeak.js 中，上面代码就是在调用这个接口时，往 session 中 set 了一个 10000000 的数据。</p>\n<p data-nodeid="188885">接下来我们修改 app.js，在其中<strong data-nodeid="189085">增加 session 功能模块</strong>，<strong data-nodeid="189086">并且启动内存快照的打印时间节点</strong>，如下代码所示：</p>\n<pre class="lang-javascript" data-nodeid="188886"><code data-language="javascript"><span class="hljs-keyword">const</span> Koa = <span class="hljs-built_in">require</span>(<span class="hljs-string">\'koa\'</span>);\n<span class="hljs-keyword">const</span> app = <span class="hljs-keyword">new</span> Koa();\n<span class="hljs-keyword">const</span> routerMiddleware = <span class="hljs-built_in">require</span>(<span class="hljs-string">\'./src/middleware/router\'</span>);\n<span class="hljs-keyword">const</span> logCenter = <span class="hljs-built_in">require</span>(<span class="hljs-string">\'./src/middleware/logCenter\'</span>);\n<span class="hljs-keyword">const</span> session = <span class="hljs-built_in">require</span>(<span class="hljs-string">\'./src/middleware/session\'</span>);\n<span class="hljs-keyword">const</span> dumpFun = <span class="hljs-built_in">require</span>(<span class="hljs-string">\'./src/lib/heapdump\'</span>); \napp.use(logCenter());\napp.use(session());\napp.use(routerMiddleware());\napp.listen(<span class="hljs-number">3000</span>, () =&gt; <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`Example app listening on port 3000!`</span>));\n<span class="hljs-comment">/// 为了方便，可以打开如下代码自动获取</span>\n<span class="hljs-keyword">const</span> currentDate = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>();\ndumpFun(<span class="hljs-string">\'nodejs-cloumn\'</span>, <span class="hljs-string">`<span class="hljs-subst">${currentDate.getHours()}</span>:<span class="hljs-subst">${currentDate.getMinutes()+<span class="hljs-number">1</span>}</span>`</span>, <span class="hljs-number">60</span>);\n</code></pre>\n<p data-nodeid="188887">在上面代码中的第 5 行就是加载我们的 session 中间件，并且在第 10 行，也就是路由转发处理之前调用，这样就可以在 controller 中处理 session。最后在代码 15 行增加内存快照，这里的时间点，你需要根据自己的当前时间进行调整，最好大于当前时间 1 分钟就行了，比如我现在的时间是 14 点 43 分，因此可以设置成 14 点 44 分，为了方便，我这里将上面的时间设置为了自动获取。</p>\n<p data-nodeid="188888">session 这个中间件是比较简单的，代码如下：</p>\n<pre class="lang-javascript" data-nodeid="188889"><code data-language="javascript"><span class="hljs-keyword">const</span> loginUsers = {};\n<span class="hljs-built_in">module</span>.exports = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{\n    <span class="hljs-keyword">return</span> <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"> ctx, next </span>) </span>{\n       ctx.session = session;\n       <span class="hljs-keyword">await</span> next();\n    }\n}\n<span class="hljs-keyword">const</span> session = {\n    <span class="hljs-attr">set</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">username</span>) </span>{\n        loginUsers[username] = <span class="hljs-literal">true</span>;\n    },\n\n    <span class="hljs-attr">check</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">username</span>)</span>{\n        <span class="hljs-keyword">return</span> loginUsers[username] ? <span class="hljs-literal">true</span> : <span class="hljs-literal">false</span>;\n    }\n};\n</code></pre>\n<p data-nodeid="188890">在上面代码中存在一个内存泄漏的点，就是<strong data-nodeid="189094">loginUsers 会随着用户请求越来越大，</strong> 导致存储的空间占用越来越大，而这个 loginUsers 在进程运行期间，又不会进行释放，从而导致内存泄漏的问题。</p>\n<p data-nodeid="188891">接下来我们就启动服务，启动成功后会看到如下提示：</p>\n<pre class="lang-java" data-nodeid="188892"><code data-language="java">系统将在 <span class="hljs-number">38</span> 秒后打印首次内存快照，请在首次快照后请求内存泄漏接口\nExample app listening on port <span class="hljs-number">3000</span>!\n</code></pre>\n<p data-nodeid="188893">等待 38 秒后，同样会提示：</p>\n<pre class="lang-java" data-nodeid="188894"><code data-language="java">打印首次内存快照成功，请开始请求内存泄漏接口\n</code></pre>\n<p data-nodeid="188895">接下来我们打开内存异常的接口：</p>\n<pre class="lang-java" data-nodeid="188896"><code data-language="java">http:<span class="hljs-comment">//127.0.0.1:3000/v1/mem-leak</span>\n</code></pre>\n<p data-nodeid="188897">请求成功后，由于我们内存快照间隔 1 分钟，再耐心等待 1 分钟，你会在项目的 log 目录下看到两个 heapsnapshot 文件。</p>\n<p data-nodeid="188898">接下来我们打开 Chrome 浏览器 Memory 分析工具，分别 Load 这两个问题，如图 2 所示，先选择较大内存的文件，然后再选择 comparsion 对比最新的文件。</p>\n<p data-nodeid="188899"><img src="https://s0.lgstatic.com/i/image6/M00/2D/9B/Cgp9HWBmwryAJxI1AAKJIYG0_JU009.png" alt="Drawing 1.png" data-nodeid="189102"></p>\n<div data-nodeid="188900"><p style="text-align:center">图 2 内存快照对比图</p></div>\n<p data-nodeid="188901">在对比后，你可以选择右侧的单独每一列进行排序，其中右侧的每一项表示的是：</p>\n<ul data-nodeid="188902">\n<li data-nodeid="188903">\n<p data-nodeid="188904"><strong data-nodeid="189107">New，对比文件新创建的对象；</strong></p>\n</li>\n<li data-nodeid="188905">\n<p data-nodeid="188906"><strong data-nodeid="189111">Deleted，对比文件删除的对象；</strong></p>\n</li>\n<li data-nodeid="188907">\n<p data-nodeid="188908"><strong data-nodeid="189115">Delta，对比文件净新增的对象；</strong></p>\n</li>\n<li data-nodeid="188909">\n<p data-nodeid="188910"><strong data-nodeid="189119">Alloc Size，已分配使用中的内存空间；</strong></p>\n</li>\n<li data-nodeid="188911">\n<p data-nodeid="188912"><strong data-nodeid="189123">Freed Size，对比文件释放的内存空间；</strong></p>\n</li>\n<li data-nodeid="188913">\n<p data-nodeid="188914"><strong data-nodeid="189128">Size Delta，对比文件净占用内存空间</strong>。</p>\n</li>\n</ul>\n<p data-nodeid="188915">以上我们主要对比净新增的 Delta 和 Size Delta，分别用两者排序，你会发现 Size Delta 中 (array) 占用空间非常大，如图 3 所示。</p>\n<p data-nodeid="188916"><img src="https://s0.lgstatic.com/i/image6/M00/2D/9B/Cgp9HWBmwsSAd_jVAAKOBgdlSSQ463.png" alt="Drawing 2.png" data-nodeid="189132"></p>\n<div data-nodeid="188917"><p style="text-align:center">图 3 Size Delta 排序后的结果</p></div>\n<p data-nodeid="188918">你展开 (array) 这一列，然后在 (array) 的第一行，如图 4 所示，会看到一个未描述的对象占用了非常大的空间，这个对象几乎占用了 99% 的空间，在这个对象中有一个关键信息是 @108135 这个值，你可以先对这个值有个印象。</p>\n<p data-nodeid="188919"><img src="https://s0.lgstatic.com/i/image6/M00/2D/A4/CioPOWBmws2ALJfrAAF6K_LTAvs088.png" alt="Drawing 3.png" data-nodeid="189136"></p>\n<div data-nodeid="188920"><p style="text-align:center">图 4 (array) 空间占比排序结果</p></div>\n<p data-nodeid="188921">我们右键这个数据，然后选择 Reveal in Summary view，你将会看到图 5 的结果：</p>\n<p data-nodeid="188922"><img src="https://s0.lgstatic.com/i/image6/M00/2D/A4/CioPOWBmwtSARfZXAAELN9G896Q666.png" alt="Drawing 4.png" data-nodeid="189140"></p>\n<div data-nodeid="188923"><p style="text-align:center">图 5 Reveal in Summary view 结果</p></div>\n<p data-nodeid="188924">但是这里因为 (array) 是一个引用对象，因此我们要看下整体的占用情况，我们把 (array) 收缩起来，然后选择右侧的 Retained Size，可以看到图 6 所示的结果。</p>\n<p data-nodeid="188925"><img src="https://s0.lgstatic.com/i/image6/M00/2D/9B/Cgp9HWBmwuCAAi-LAAFhD2HwhQo398.png" alt="Drawing 5.png" data-nodeid="189144"></p>\n<div data-nodeid="188926"><p style="text-align:center">图 6 Retained Size 排序后的结果</p></div>\n<p data-nodeid="188927">现在你可以看到了，占用最大的就是前 3 个，因此我们着重看这 3 个，我们展开 Object 看看，你会发现一个如图 7 所示的结果，注意 @108135 就是我们之前看到的 (array) 中的数组对象。</p>\n<p data-nodeid="188928"><img src="https://s0.lgstatic.com/i/image6/M00/2D/A4/CioPOWBmwuiAP3CDAAG2Cu236LA987.png" alt="Drawing 6.png" data-nodeid="189148"></p>\n<div data-nodeid="188929"><p style="text-align:center">图 7 展开 Object 后的结果</p></div>\n<p data-nodeid="188930">在图 7 中你发现很多以 0、1、10 、... 这种为键的对象，里面存储了比较简单的值 true，这里我们还没有找到具体的原因，但是至少发现了数据问题，那么接下来我们继续看 system/Context，其实第一眼就能发现其是 Koa 框架中的 ctx，我们展开就可以看到图 8 结果。</p>\n<p data-nodeid="188931"><img src="https://s0.lgstatic.com/i/image6/M00/2D/A4/CioPOWBmwvCAC9V1AAH1y5NvYrw937.png" alt="Drawing 7.png" data-nodeid="189152"></p>\n<div data-nodeid="188932"><p style="text-align:center">图 8 展开 system/Context 结果</p></div>\n<p data-nodeid="188933">你从图 8 发现异常了吗，loginUsers 占用了 95% 空间，好了这下真相大白了，我们再去 ctx 中寻找在哪里进行 loginUsers 的设置，经过代码检查，那肯定能找到泄漏的具体位置了。</p>\n<p data-nodeid="188934">以上就是一个分析过程，主要还是 comparsion 结合 summary 来进行分析。<strong data-nodeid="189159">对于非常发性的内存泄漏，比如偶发性，就需要在生产环境定时打印内存快照</strong>。请注意要选择用户访问较少的时间节点，比如说当地的凌晨 3-4 点，同时两个快照的打印时间点必须一致，这样用户访问的数据对内存影响较小。</p>\n<h3 data-nodeid="188935">Router 中间件优化</h3>\n<p data-nodeid="188936">在前一讲中，我们说了 Router 存在的问题，这里顺便将这块进行一些优化，减少对 router 模块的频繁修改。</p>\n<p data-nodeid="188937">我们在中间件 middleware 文件夹中新增了一个 newRouter.js 文件，主要介绍几个关键的实现点。</p>\n<p data-nodeid="188938">第一个就是需要<strong data-nodeid="189168">将横杠转化为大写首字母</strong>，因此这里需要使用到这样的正则替换：</p>\n<pre class="lang-javascript" data-nodeid="188939"><code data-language="javascript"><span class="hljs-comment">// 去除非常规请求路径，将-转化为大写</span>\npathname = pathname.replace(<span class="hljs-string">\'..\'</span>, <span class="hljs-string">\'\'</span>).replace(<span class="hljs-regexp">/\\-(\\w)/g</span>, <span class="hljs-function">(<span class="hljs-params">all,letter</span>)=&gt;</span>letter.toUpperCase());\n</code></pre>\n<p data-nodeid="188940">上面代码中需要去除 .. 的访问，防止用户利用非法请求路径，请求根目录的文件信息。</p>\n<p data-nodeid="188941">第二就是我们<strong data-nodeid="189175">默认请求路径的最后一个是方法名</strong>，因此使用 / 切割后，获取最后一个元素为请求的方法名，如下代码所示：</p>\n<pre class="lang-javascript" data-nodeid="188942"><code data-language="javascript">pathnameArr = pathname.split(<span class="hljs-string">\'/\'</span>);\npathnameArr.shift();\n\n<span class="hljs-keyword">if</span>(pathnameArr.length &lt; <span class="hljs-number">2</span>){\n  baseFun.setResInfo(ctx, <span class="hljs-literal">false</span>, <span class="hljs-string">\'path not found\'</span>, <span class="hljs-literal">null</span>, <span class="hljs-number">404</span>);\n  <span class="hljs-keyword">return</span> <span class="hljs-keyword">await</span> next();\n}\n<span class="hljs-keyword">let</span> method = pathnameArr.pop();\n</code></pre>\n<p data-nodeid="188943">其他部分的代码基本相似，你要使用这个新的路由的话，直接在 app.js 中打开这段注释即可。</p>\n<pre class="lang-javascript" data-nodeid="188944"><code data-language="javascript"><span class="hljs-keyword">const</span> routerMiddleware = <span class="hljs-built_in">require</span>(<span class="hljs-string">\'./src/middleware/router\'</span>);\n<span class="hljs-comment">//const routerMiddleware = require(\'./src/middleware/newRouter\');</span>\n<span class="hljs-keyword">const</span> logCenter = <span class="hljs-built_in">require</span>(<span class="hljs-string">\'./src/middleware/logCenter\'</span>);\n<span class="hljs-keyword">const</span> session = <span class="hljs-built_in">require</span>(<span class="hljs-string">\'./src/middleware/session\'</span>);\n</code></pre>\n<p data-nodeid="188945">打开以后，你就可以按照如下方式来请求了：</p>\n<pre class="lang-java" data-nodeid="188946"><code data-language="java">http:<span class="hljs-comment">//127.0.0.1:3000/v1/test/index</span>\nhttp:<span class="hljs-comment">//127.0.0.1:3000/content/test</span>\nhttp:<span class="hljs-comment">//127.0.0.1:3000/v1/test/index-test</span>\n</code></pre>\n<p data-nodeid="188947">这样都可以返回正常的数据。</p>\n<h3 data-nodeid="188948">总结</h3>\n<p data-nodeid="188949">本讲先介绍了内存泄漏的概念，以及 Node.js 的内存回收机制，其次介绍了一些内存泄漏分类，着重介绍了内存泄漏的分析方法，其中如何<strong data-nodeid="189185">一步步定位到泄漏的代码</strong>是本讲核心知识点，希望你可以多尝试一些内存泄漏的案例来自我分析，比如闭包会导致内存泄漏，那么应该如何进行分析和定位呢？可以将你的答案写在评论区。</p>\n<p data-nodeid="190262">下一讲我们将进行一些压测工具的应用介绍，以及如何在压测过程中一步步进行性能分析优化，并且介绍一些常见性能优化方案。</p>\n<hr data-nodeid="190263">\n<p data-nodeid="190264"><a href="https://shenceyun.lagou.com/t/mka" data-nodeid="190272"><img src="https://s0.lgstatic.com/i/image6/M00/12/FA/CioPOWBBrAKAAod-AASyC72ZqWw233.png" alt="Drawing 2.png" data-nodeid="190271"></a></p>\n<p data-nodeid="190265"><strong data-nodeid="190276">《大前端高薪训练营》</strong></p>\n<p data-nodeid="190266" class="te-preview-highlight">对标阿里 P7 技术需求 + 每月大厂内推，6 个月助你斩获名企高薪 Offer。<a href="https://shenceyun.lagou.com/t/mka" data-nodeid="190280">点击链接</a>，快来领取！</p>',
        article_title: "11 | 内存检查：多种类型的内存泄漏分析方案",
        title: "11 | 内存检查：多种类型的内存泄漏分析方案",
        id: 6793,
      },
      {
        content:
          '<p data-nodeid="191125">模块一的<a href="https://kaiwu.lagou.com/course/courseInfo.htm?courseId=694#/detail/pc?id=6788&amp;fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="191666">《06 | 哪些因素会影响 Node.js 性能？》</a>，我们详细讲解了影响到 Node.js 性能的一些因素，但是在实际开发过程中，我们应该如何去定位影响性能的关键因素呢？定位到性能问题后，又该如何去优化这部分功能呢？以上就是本讲要介绍的核心知识点。</p>\n<h3 data-nodeid="191126">工具介绍</h3>\n<p data-nodeid="191127">在讲解性能分析实践之前，我们先来看看性能分析所应用的两个比较关键的工具：</p>\n<ul data-nodeid="191128">\n<li data-nodeid="191129">\n<p data-nodeid="191130">压测所使用到的 WRK（Windows Research Kernel）；</p>\n</li>\n<li data-nodeid="191131">\n<p data-nodeid="191132">性能分析所使用到的 Chrome 分析工具 JavaScript Profile。</p>\n</li>\n</ul>\n<h4 data-nodeid="191133">WRK 的安装及参数</h4>\n<p data-nodeid="191134">在压测工具上可选择的比较多，比如 Apache-ab 压测工具、Siege 及本讲所应用的 WRK。<strong data-nodeid="191678">为了能够更好地利用多核的多线程并发测试，这里我们选择使用 WRK 来作为压测工具</strong>。我们看下该工具的安装以及一些常用参数。</p>\n<ul data-nodeid="191135">\n<li data-nodeid="191136">\n<p data-nodeid="191137">在<strong data-nodeid="191684">Mac</strong>上使用软件包管理工具 Homebrew 来安装，使用如下命令即可：</p>\n</li>\n</ul>\n<pre class="lang-powershell" data-nodeid="191138"><code data-language="powershell">brew install wrk\n</code></pre>\n<ul data-nodeid="191139">\n<li data-nodeid="191140">\n<p data-nodeid="191141">在<strong data-nodeid="191690">Linux</strong>上依次执行……的命令安装就可以（如果 Linux 上没有安装 GCC、Make 或者 Git，就需要先安装这几个工具）。</p>\n</li>\n</ul>\n<pre class="lang-powershell" data-nodeid="191142"><code data-language="powershell"><span class="hljs-comment">#下载命令</span>\ngit clone https://github.com/wg/wrk.git \n<span class="hljs-comment">#切换路径到wrk目录下</span>\n<span class="hljs-built_in">cd</span> wrk  \n<span class="hljs-comment">#使用make命令编译环境</span>\n \nmake \n</code></pre>\n<ul data-nodeid="191143">\n<li data-nodeid="191144">\n<p data-nodeid="191145">在<strong data-nodeid="191696">Windows</strong>上就非常遗憾了，因为这个工具不支持 Windows。但如果你是 Windows 10，可以切换到 Ubuntu 子系统的方式来安装，或者在 Windows 上安装 Linux 虚拟机也是可以的。</p>\n</li>\n</ul>\n<p data-nodeid="191146">成功安装后，你可以在命令行使用……命令查看具体的参数说明和介绍：</p>\n<pre class="lang-powershell" data-nodeid="191147"><code data-language="powershell">wrk\n</code></pre>\n<p data-nodeid="191148">这一讲因为需要进行并发请求的验证，所以我们会使用下面的压测命令：</p>\n<pre class="lang-powershell" data-nodeid="191149"><code data-language="powershell">wrk <span class="hljs-literal">-t4</span> <span class="hljs-literal">-c300</span> <span class="hljs-literal">-d20s</span> https://www.baidu.com/\n</code></pre>\n<p data-nodeid="191150">其参数说明如下：</p>\n<ul data-nodeid="191151">\n<li data-nodeid="191152">\n<p data-nodeid="191153">-t 代表的是启动 4 个线程；</p>\n</li>\n<li data-nodeid="191154">\n<p data-nodeid="191155">-c 代表的是并发数，300 个并发请求；</p>\n</li>\n<li data-nodeid="191156">\n<p data-nodeid="191157">-d 代表的是持续时长，20s 就是 20 秒。</p>\n</li>\n</ul>\n<p data-nodeid="191158">我们运行上面的命令后，会有相应的压测结果，如下所示：</p>\n<pre class="lang-powershell" data-nodeid="191159"><code data-language="powershell">Running <span class="hljs-number">20</span>s test <span class="hljs-selector-tag">@</span> https://www.baidu.com/\n&nbsp; <span class="hljs-number">10</span> threads and <span class="hljs-number">300</span> connections\n&nbsp; Thread Stats &nbsp; Avg&nbsp; &nbsp; &nbsp; Stdev &nbsp; &nbsp; Max &nbsp; +/- Stdev\n&nbsp; &nbsp; Latency &nbsp; <span class="hljs-number">789.93</span>ms&nbsp; <span class="hljs-number">393.84</span>ms &nbsp; <span class="hljs-number">2.00</span>s&nbsp; &nbsp; <span class="hljs-number">76.57</span>%\n&nbsp; &nbsp; Req/Sec&nbsp; &nbsp; <span class="hljs-number">14.33</span> &nbsp; &nbsp; <span class="hljs-number">10.17</span>&nbsp; &nbsp; <span class="hljs-number">59.00</span> &nbsp; &nbsp; <span class="hljs-number">72.31</span>%\n&nbsp; <span class="hljs-number">2252</span> requests <span class="hljs-keyword">in</span> <span class="hljs-number">20.10</span>s, <span class="hljs-number">34.49</span>MB read\n&nbsp; Socket errors: connect <span class="hljs-number">60</span>, read <span class="hljs-number">0</span>, <span class="hljs-built_in">write</span> <span class="hljs-number">0</span>, timeout <span class="hljs-number">481</span>\nRequests/sec:&nbsp; &nbsp; <span class="hljs-number">112.05</span>\nTransfer/sec:&nbsp; &nbsp; &nbsp; <span class="hljs-number">1.72</span>MB\n</code></pre>\n<p data-nodeid="191160">上面的结果，我们核心应该关注的是 Requests/sec 为 QPS，其次也需要了解平均耗时的情况，也就是上面的 Avg 789.93ms，以及失败超时的情况，即上面 socket errors 的 timeout 481。</p>\n<h4 data-nodeid="191161">Chrome 分析工具 JavaScript Profiler</h4>\n<p data-nodeid="191162">在压测下，如果发现请求 QPS 非常低、平均耗时非常长，或者失败率非常高的话，这时就需要将 CPU 信息进行保存，然后用 Chrome 的 JavaScript Profiler 工具来进行分析。</p>\n<p data-nodeid="191163">方法也很简单，用 Chrome 的开发者工具 More-tools → JavaScript Profiler → Load，读取 CPU Profile，查看火焰图（如图 1 所示）。</p>\n<p data-nodeid="199540" class=""><img src="https://s0.lgstatic.com/i/image6/M00/34/08/CioPOWBwD02Ab_ffAAK5Evk7rNM190.png" alt="Drawing 0.png" data-nodeid="199544"></p>\n<div data-nodeid="199541"><p style="text-align:center">图 1 Chrome 打开 JavaScript Profiler 指引图</p></div>\n\n\n\n<p data-nodeid="191166">要使用这个功能，需要在 Node.js 中对 CPU 进行采集，采集的方式需要使用 v8-profiler 这个库（如果你的 Node.js 版本大于 10，则需要使用 v8-profiler-next 这个库），在上一讲中已经应用过该工具分析过内存泄漏问题。</p>\n<h4 data-nodeid="191167">简单 Demo 演示</h4>\n<p data-nodeid="191168">为了演示这个分析方式，我们写一个最简单的测试代码，如下所示：</p>\n<pre class="lang-javascript" data-nodeid="191169"><code data-language="javascript"><span class="hljs-keyword">const</span> http = <span class="hljs-built_in">require</span>(<span class="hljs-string">\'http\'</span>);\n<span class="hljs-comment">// 引入 v8-profiler 库，可以作为一个中间件来实现</span>\n<span class="hljs-keyword">const</span> v8Profiler = <span class="hljs-built_in">require</span>(<span class="hljs-string">\'./lib/v8_profiler\'</span>);\n<span class="hljs-comment">/**\n * \n * 创建 http 服务，简单返回\n */</span>\n<span class="hljs-keyword">const</span> server = http.createServer(<span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> {\n    res.write(<span class="hljs-string">\'hello world\'</span>);\n    res.end();\n});\n<span class="hljs-comment">/**\n * \n * 启动服务，并开始执行 v8 profiler 的采集工作\n */</span>\nserver.listen(<span class="hljs-number">3000</span>, () =&gt; {\n    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">\'server start http://127.0.0.1:3000\'</span>);\n    v8Profiler.start();\n});\n</code></pre>\n<p data-nodeid="191170">在上面代码中的第二行，我们引入了一个自身写的 v8-profiler 库，接下来看看这个库的逻辑。</p>\n<pre class="lang-javascript" data-nodeid="191171"><code data-language="javascript"><span class="hljs-meta">\'use strict\'</span>;\n<span class="hljs-keyword">const</span> v8Profiler = <span class="hljs-built_in">require</span>(<span class="hljs-string">\'v8-profiler-next\'</span>);\n<span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">\'fs\'</span>);\n<span class="hljs-comment">// 设置采集数据保存的文件名</span>\n<span class="hljs-keyword">const</span> title = <span class="hljs-string">\'example\'</span>;\n<span class="hljs-built_in">module</span>.exports = {\n    <span class="hljs-string">\'start\'</span> : <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {\n        <span class="hljs-comment">// 启动采集，如果需要定时采集，可以将 title 设置为一个动态的根据时间变化的值</span>\n        v8Profiler.startProfiling(title, <span class="hljs-literal">true</span>);\n        setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> { <span class="hljs-comment">// 30 秒后采集并导出</span>\n          <span class="hljs-keyword">const</span> profile = v8Profiler.stopProfiling(title);\n          profile.export(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">error, result</span>) </span>{ <span class="hljs-comment">// 将内容写入指定文件</span>\n            fs.writeFileSync(<span class="hljs-string">`./cpu_profiler/<span class="hljs-subst">${title}</span>.cpuprofile`</span>, result);\n            profile.delete();\n          });\n        }, <span class="hljs-number">30</span> * <span class="hljs-number">1000</span>);\n    }\n};\n</code></pre>\n<p data-nodeid="191172"><strong data-nodeid="191720">上面代码中的 start 方法，就是核心的采集代码</strong>。v8-Profiler 开始采集，使用 title 作为唯一标示，在 30 秒后，停止这个 title 的采集，并获取数据保存在文件中。</p>\n<p data-nodeid="191173">为了验证效果，你可以根据我们下面的步骤来进行分析（代码源码保存在<a href="https://github.com/love-flutter/nodejs-column?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="191724">GitHub</a>中，自行下载后，可按照下面步骤执行）。</p>\n<p data-nodeid="191174">（1）打开项目，进入项目根目录，执行命令启动服务。</p>\n<pre class="lang-java" data-nodeid="191175"><code data-language="java">npm run test\n</code></pre>\n<p data-nodeid="191176">（2）打开另外一个命令窗口，开始执行压测程序。</p>\n<pre class="lang-java" data-nodeid="191177"><code data-language="java">wrk -t2 -c300 -d20s http:<span class="hljs-comment">//127.0.0.1:3000/</span>\n</code></pre>\n<p data-nodeid="191178">（3）大概 30 秒后，项目目录下的 cpu_profiler 文件夹下会生成 example.cpuprofile 文件。</p>\n<p data-nodeid="191179">（4）打开 Chrome 工具中的 JavaScript Profiler，然后 load 刚才项目目录下的 cpu_profiler/example.cpuprofile 文件，就可以看到如图 2 所示的结果。</p>\n<p data-nodeid="204356" class=""><img src="https://s0.lgstatic.com/i/image6/M01/33/FF/Cgp9HWBwD1yAaayGAAO16nRrzQQ497.png" alt="Drawing 1.png" data-nodeid="204360"></p>\n<div data-nodeid="204357"><p style="text-align:center">图 2 cpuprofile 演示结果</p></div>\n\n\n\n<p data-nodeid="191182">从上面的结果可以看到相应的单个执行时间和总的耗时。如果性能较慢，你可以参照标准的结果来进行分析，或者对比一个性能较好、一个性能较差的执行结果。为了让你更清晰地了解这些，下面我将从实践来进行分析。</p>\n<h3 data-nodeid="191183">实践分析</h3>\n<p data-nodeid="191184">在分析任何数据之前，首先必须有一个标准的数据进行比较，如果你用的是 Express、Eggjs 等框架，需要做一个完全空转的数据作为标准分析数据。在本讲，由于我们没有用任何框架，所以需要设计一个完全空转的 HTTP 服务来作为标准的分析数据。</p>\n<h4 data-nodeid="191185">标准数据</h4>\n<p data-nodeid="191186">这里我们还是用上面“简单 Demo 演示”中的代码，然后通过 WRK 下面的压测命令来压测，看下具体的数据情况。</p>\n<pre class="lang-java" data-nodeid="191187"><code data-language="java">wrk -t2 -c300 -d20s http:<span class="hljs-comment">//127.0.0.1:3000/</span>\n</code></pre>\n<p data-nodeid="191188">压测得到的结果如表 1 所示。</p>\n<p data-nodeid="209047"><img src="https://s0.lgstatic.com/i/image6/M00/34/08/CioPOWBwD2aAAtjKAABBXwAaJE8675.png" alt="Drawing 2.png" data-nodeid="209050"></p>\n\n\n\n\n<p data-nodeid="191219">有了这份数据后，我们再来逐个分析以下问题。</p>\n<h4 data-nodeid="191220">CPU 计算耗时</h4>\n<p data-nodeid="191221">为了验证效果，这里我们写一个 CPU 计算耗时的逻辑，然后继续压测。这点在模块一的<a href="https://kaiwu.lagou.com/course/courseInfo.htm?courseId=694#/detail/pc?id=6788&amp;fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="191788">《06 | 哪些因素会影响 Node.js 性能？》</a>已经有一些例子，我们拿一个出来尝试一下，比如 MD5 计算的逻辑，代码如下：</p>\n<pre class="lang-javascript" data-nodeid="191222"><code data-language="javascript">crypto = <span class="hljs-built_in">require</span>(<span class="hljs-string">\'crypto\'</span>);\n<span class="hljs-built_in">module</span>.exports = <span class="hljs-function">(<span class="hljs-params">content</span>) =&gt;</span> {\n    <span class="hljs-keyword">return</span> crypto.createHash(<span class="hljs-string">\'md5\'</span>).update(content).digest(<span class="hljs-string">"hex"</span>)\n}\n</code></pre>\n<p data-nodeid="191223">核心逻辑就是应用 crypto 来生成 MD5 加密数据，为了效果更好，我们在入口文件 index.js 中多调用几次，这里只修改 server 中的代码逻辑，代码如下：</p>\n<pre class="lang-javascript" data-nodeid="191224"><code data-language="javascript"><span class="hljs-keyword">const</span> server = http.createServer(<span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> {\n    <span class="hljs-comment">// 设置返回的字符串</span>\n    <span class="hljs-keyword">let</span> ret;\n    <span class="hljs-comment">// 加密一组数据</span>\n    <span class="hljs-keyword">const</span> md5List = [<span class="hljs-string">\'hello\'</span>, <span class="hljs-string">\'Node.js\'</span>, <span class="hljs-string">\'lagou\'</span>, <span class="hljs-string">\'is\'</span>, <span class="hljs-string">\'great\'</span>];\n    md5List.forEach( <span class="hljs-function">(<span class="hljs-params">str</span>)=&gt;</span> {\n        <span class="hljs-keyword">if</span>(ret){\n            ret = <span class="hljs-string">`<span class="hljs-subst">${ret}</span> <span class="hljs-subst">${getMd5(str)}</span>`</span>;\n        } <span class="hljs-keyword">else</span> {\n            ret = getMd5(str)\n        }\n    });\n    res.write(ret);\n    res.end();\n});\n</code></pre>\n<p data-nodeid="191225">修改完成后，我们再按照简单 Demo 中的四个步骤压测数据即可：</p>\n<ul data-nodeid="191226">\n<li data-nodeid="191227">\n<p data-nodeid="191228">启动服务</p>\n</li>\n<li data-nodeid="191229">\n<p data-nodeid="191230">开始压测</p>\n</li>\n<li data-nodeid="191231">\n<p data-nodeid="191232">等待 CPU 采集</p>\n</li>\n<li data-nodeid="191233">\n<p data-nodeid="191234">分析压测数据</p>\n</li>\n</ul>\n<p data-nodeid="191235">接下来我们看下压测后的数据，如表 2 所示。</p>\n<p data-nodeid="211325" class=""><img src="https://s0.lgstatic.com/i/image6/M00/34/08/CioPOWBwD3SAIEtvAABS4dW-YPo314.png" alt="Drawing 3.png" data-nodeid="211328"></p>\n\n\n\n<p data-nodeid="191274">这一对比可以非常清晰地看到，相对于标准服务，CPU 耗时服务在各方面（平均耗时、最低耗时、最大耗时以及失败率）都差很多，在性能上两者是有比较大的落差的，如果我们不知道是因为 MD5 影响到 CPU 计算导致的，那么就需要分析 CPU 耗时的情况了。</p>\n<p data-nodeid="191275">接下来我们打开 Chrome JavaScript Profiler 工具，可以看到如图 3 所示的结果。</p>\n<p data-nodeid="215563"><img src="https://s0.lgstatic.com/i/image6/M00/34/08/CioPOWBwD3uADtMhAAMNNH1bIOY973.png" alt="Drawing 4.png" data-nodeid="215567"></p>\n<div data-nodeid="215564" class=""><p style="text-align:center">图 3 CPU 压测 CPU 耗时分析</p></div>\n\n\n\n<p data-nodeid="191278">几个耗时较长的函数，例如 digest、Hash 以及 update 等，都是在 MD5 计算中的逻辑，因此可以非常清晰地了解到，在 MD5 计算方面会对 Node.js 的服务有一个比较大的性能影响，因此在开发时尽量减少或者避免这种类似的计算服务。</p>\n<h4 data-nodeid="191279">网络 I/O</h4>\n<p data-nodeid="191280">为了演示效果，我们<strong data-nodeid="191858">先创建一个新的服务</strong>，这个服务在原来的“简单 Demo 演示”基础上增加了一个延迟返回的效果，具体代码在 api_server 文件项目中，核心代码如下：</p>\n<pre class="lang-javascript" data-nodeid="191281"><code data-language="javascript"><span class="hljs-keyword">const</span> http = <span class="hljs-built_in">require</span>(<span class="hljs-string">\'http\'</span>);\n<span class="hljs-comment">/**\n * \n * 创建 http 服务，简单返回\n */</span>\n<span class="hljs-keyword">const</span> server = http.createServer(<span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> {\n    setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> { <span class="hljs-comment">// 延迟 1 秒返回</span>\n        res.write(<span class="hljs-string">\'this is api result\'</span>);\n        res.end();\n    }, <span class="hljs-number">1</span> * <span class="hljs-number">1000</span>);\n});\n<span class="hljs-comment">/**\n * \n * 启动服务，并开始执行 v8 profiler 的采集工作\n */</span>\nserver.listen(<span class="hljs-number">4000</span>, () =&gt; {\n    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">\'server start http://127.0.0.1:4000\'</span>);\n});\n</code></pre>\n<p data-nodeid="191282">核心代码是在 setTimeout 延迟返回，其次修改了以下监听端口，从 3000 修改为 4000。</p>\n<p data-nodeid="191283"><strong data-nodeid="191868">接下来我们创建一个 network_io</strong>，实现调用 http://127.0.0.1:4000 这个服务，从而实现网络 I/O 操作。首先还是实现一个 call_api 的服务，该服务会应用到 request 这个 npm 库（后续这个库不会维护了，暂时还没有替代方案，除非自己手动实现），代码如下：</p>\n<pre class="lang-javascript" data-nodeid="191284"><code data-language="javascript"><span class="hljs-comment">// 引入 request 库，需要在 package.json 中申明，并且 npm install</span>\n<span class="hljs-keyword">const</span> request = <span class="hljs-built_in">require</span>(<span class="hljs-string">\'request\'</span>);\n<span class="hljs-comment">/**\n * \n * request 调用外部 api\n * @param {*} apiLink string\n * @param {*} callback funtion\n * \n */</span>\n<span class="hljs-built_in">module</span>.exports = <span class="hljs-function">(<span class="hljs-params">apiLink, callback</span>) =&gt;</span> {\n    request(apiLink, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">error, response, body</span>) </span>{\n        <span class="hljs-keyword">if</span>(error) {\n            callback(<span class="hljs-literal">false</span>);\n        } <span class="hljs-keyword">else</span> {\n            callback(body);\n        }\n    });\n}\n</code></pre>\n<p data-nodeid="191285">这部分代码主要是应用 request 模块调用 apiLink 服务，并获取执行结果。通过回调的方式返回具体的数据，也就是上面的参数 callback。</p>\n<p data-nodeid="191286">最后我们再来看下 index.js 中的核心部分 server 的修改，代码如下：</p>\n<pre class="lang-javascript" data-nodeid="191287"><code data-language="javascript"><span class="hljs-comment">/**\n * \n * 创建 http 服务，简单返回\n */</span>\n<span class="hljs-keyword">const</span> server = http.createServer(<span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> {\n    callApi(<span class="hljs-string">\'http://127.0.0.1:4000\'</span>, (ret) =&gt; { <span class="hljs-comment">// 调用 4000 服务，并显示返回结果</span>\n        <span class="hljs-keyword">if</span>(ret) {\n            res.write(ret);\n        } <span class="hljs-keyword">else</span> {\n            res.write(<span class="hljs-string">\'call api server error\'</span>);\n        }\n        res.end();\n    });\n});\n</code></pre>\n<p data-nodeid="191288">接下来就启动两个服务，分别打开地址：</p>\n<ul data-nodeid="191289">\n<li data-nodeid="191290">\n<p data-nodeid="191291"><a href="http://127.0.0.1:4000?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="191874">http://127.0.0.1:4000</a></p>\n</li>\n<li data-nodeid="191292">\n<p data-nodeid="191293"><a href="http://127.0.0.1:3000?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="191877">http://127.0.0.1:3000</a></p>\n</li>\n</ul>\n<p data-nodeid="191294">看下是否正常响应，正常返回数据后，我们再启动对 3000 服务的压测，运行如下命令：</p>\n<pre class="lang-java" data-nodeid="191295"><code data-language="java">wrk -t2 -c300 -d20s http:<span class="hljs-comment">//127.0.0.1:3000/</span>\n</code></pre>\n<p data-nodeid="191296">接下来我们看下压测后的数据，如表 3 所示：</p>\n<p data-nodeid="217680" class=""><img src="https://s0.lgstatic.com/i/image6/M00/34/00/Cgp9HWBwD4-AFJLoAABlk46DdAs957.png" alt="Drawing 5.png" data-nodeid="217683"></p>\n\n\n\n<p data-nodeid="191343">拿到压测数据后，同样按照 CPU 分析方法，可以看到如图 4 所示的性能分析结果。</p>\n<p data-nodeid="221527" class=""><img src="https://s0.lgstatic.com/i/image6/M01/34/00/Cgp9HWBwD5mAFR0WAAHjSmqkmd0847.png" alt="Drawing 6.png" data-nodeid="221531"></p>\n<div data-nodeid="221528"><p style="text-align:center">图 4 网络 I/O 性能分析数据</p></div>\n\n\n\n<p data-nodeid="191346">其中有一个 connect，该模块在 net.js 中，这里就可以得到是网络 I/O 引起的问题。</p>\n<p data-nodeid="191347">最后我们再来看下 磁盘 I/O 的问题。</p>\n<h4 data-nodeid="191348">磁盘 I/O</h4>\n<p data-nodeid="191349">这里主要使用 Node.js 的 fs 模块来读取本地的文件，并显示返回文件的内容，核心代码是 server 回调部分，代码如下：</p>\n<pre class="lang-javascript" data-nodeid="191350"><code data-language="javascript"><span class="hljs-keyword">const</span> server = http.createServer(<span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> {\n    <span class="hljs-keyword">let</span> ret = fs.readFileSync(<span class="hljs-string">\'./test_file.conf\'</span>);\n    res.write(ret);\n    res.end();\n});\n</code></pre>\n<p data-nodeid="191351">接下来，我们同样用如下命令来启动压测服务：</p>\n<pre class="lang-java" data-nodeid="191352"><code data-language="java">wrk -t2 -c300 -d20s http:<span class="hljs-comment">//127.0.0.1:3000/</span>\n</code></pre>\n<p data-nodeid="191353">压测后将得到如表格 4 所示的结果。</p>\n<p data-nodeid="223452" class=""><img src="https://s0.lgstatic.com/i/image6/M00/34/08/CioPOWBwD6SAOvwRAAB4GHKuanE270.png" alt="Drawing 7.png" data-nodeid="223455"></p>\n\n\n\n<p data-nodeid="191408">从结果看也是存在一定损耗的，具体在哪方面影响到性能，同样用 Chrome 工具载入该服务采集的 CPU 信息，如图 5 所示。</p>\n<p data-nodeid="226862"><img src="https://s0.lgstatic.com/i/image6/M00/34/00/Cgp9HWBwD6yATYtxAAHRgb9iz4o952.png" alt="Drawing 8.png" data-nodeid="226866"></p>\n<div data-nodeid="226863" class=""><p style="text-align:center">图 5 磁盘 I/O CPU 采集信息</p></div>\n\n\n\n<p data-nodeid="191411">从图 5 中可以非常清晰地看到前面几个耗时较长的都是关于文件读写相关的模块，如上面红色圈里面的信息。</p>\n<h3 data-nodeid="191412">优化以及效果</h3>\n<p data-nodeid="191413">上面已经介绍到了那么多性能影响的部分，那么接下来看看如何进行一些优化，来提升性能。</p>\n<h4 data-nodeid="191414">CPU 计算耗时</h4>\n<p data-nodeid="191415">这部分只能说减少操作，或者减少运算。像我们上面的例子，如果都是一样的 MD5 计算，那么增加一个短时间的缓存就可以了。当然这里我们可以直接用内存来缓存（实际开发过程中，不能使用内存的方式，因为会造成内存使用越来越大，一般使用共享内存，并短时间保存即可），代码如下（代码保存在 cpu_opt 中）：</p>\n<pre class="lang-javascript" data-nodeid="191416"><code data-language="javascript">crypto = <span class="hljs-built_in">require</span>(<span class="hljs-string">\'crypto\'</span>);\n<span class="hljs-comment">// 保存缓存信息</span>\n<span class="hljs-keyword">const</span> md5Cache = {};\n<span class="hljs-built_in">module</span>.exports = <span class="hljs-function">(<span class="hljs-params">content</span>) =&gt;</span> { \n    <span class="hljs-keyword">if</span>(md5Cache[content]) { <span class="hljs-comment">// 判断是否存在缓存信息，存在则直接返回</span>\n        <span class="hljs-keyword">return</span> md5Cache[content]\n    }\n    <span class="hljs-comment">/** 不存在则计算并返回 */</span>\n    md5Cache[content] = crypto.createHash(<span class="hljs-string">\'md5\'</span>).update(content).digest(<span class="hljs-string">"hex"</span>);\n    <span class="hljs-keyword">return</span> md5Cache[content];\n}\n</code></pre>\n<p data-nodeid="191417"><strong data-nodeid="192020">核心就是在原来的基础上，增加计算的缓存，避免多次相同的计算</strong>，接下来我们压测后看看实际的效果数据，并与之前的进行对比，得到的结果如表 5 所示。</p>\n<p data-nodeid="228565" class=""><img src="https://s0.lgstatic.com/i/image6/M01/34/00/Cgp9HWBwD7aAKWHYAABelIOMBeE096.png" alt="Drawing 9.png" data-nodeid="228568"></p>\n\n\n\n<p data-nodeid="191464">对比数据后，可以看到已经非常好了，已经和标准数据相差无几，QPS 和 标准服务也基本一致（这里比标准服务高，是因为本机测试，会有一定的起伏，是正常情况）。也就代表本次优化是达到了效果的。</p>\n<h4 data-nodeid="191465">网络 I/O</h4>\n<p data-nodeid="191466">网络 I/O 同样的办法也是增加缓存，避免重复的请求导致的问题。这里我们同样<strong data-nodeid="192085">用缓存的方式来保存请求结果</strong>，优化的代码如下（代码保存在 network_io_opt 中）：</p>\n<pre class="lang-javascript" data-nodeid="191467"><code data-language="javascript"><span class="hljs-comment">// 引入 request 库，需要在 package.json 中申明，并且 npm install</span>\n<span class="hljs-keyword">const</span> request = <span class="hljs-built_in">require</span>(<span class="hljs-string">\'request\'</span>);\n<span class="hljs-comment">// 缓存 api 请求结果数据</span>\n<span class="hljs-keyword">const</span> apiCacheData = {};\n<span class="hljs-comment">/**\n * \n * request 调用外部 api\n * @param {*} apiLink string\n * @param {*} callback funtion\n * \n */</span>\n<span class="hljs-built_in">module</span>.exports = <span class="hljs-function">(<span class="hljs-params">apiLink, callback</span>) =&gt;</span> {\n    <span class="hljs-keyword">if</span>(apiCacheData[apiLink]) {\n        <span class="hljs-keyword">return</span> callback(apiCacheData[apiLink]);\n    }\n    request(apiLink, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">error, response, body</span>) </span>{\n        <span class="hljs-keyword">if</span>(error) {\n            callback(<span class="hljs-literal">false</span>);\n        } <span class="hljs-keyword">else</span> {\n            apiCacheData[apiLink] = body;\n            callback(body);\n        }\n    });\n}\n</code></pre>\n<p data-nodeid="191468"><strong data-nodeid="192090">其次为了服务性能考虑，我们可以考虑放弃部分超时请求，从而提升服务性能</strong>。避免因为部分请求返回慢，导致整体服务被 block 住，修改 request 部分增加超时处理，代码如下：</p>\n<pre class="lang-javascript" data-nodeid="191469"><code data-language="javascript"><span class="hljs-built_in">module</span>.exports = <span class="hljs-function">(<span class="hljs-params">apiLink, callback</span>) =&gt;</span> {\n    <span class="hljs-keyword">if</span>(apiCacheData[apiLink]) {\n        <span class="hljs-keyword">return</span> callback(apiCacheData[apiLink]);\n    }\n    request(apiLink, {<span class="hljs-attr">timeout</span>: <span class="hljs-number">3000</span>}, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">error, response, body</span>) </span>{\n        <span class="hljs-keyword">if</span>(error) {\n            callback(<span class="hljs-literal">false</span>);\n        } <span class="hljs-keyword">else</span> {\n            apiCacheData[apiLink] = body;\n            callback(body);\n        }\n    });\n}\n</code></pre>\n<p data-nodeid="191470">实际情况需要根据具体的接口性能来设置这个超时时间，避免超时时间过度影响服务，也避免时间过长无法达到效果。</p>\n<p data-nodeid="191471">优化完成后，同样我们再跑一遍测试数据：</p>\n<ul data-nodeid="191472">\n<li data-nodeid="191473">\n<p data-nodeid="191474">首先还是先去 api_server 中启动 api 服务；</p>\n</li>\n<li data-nodeid="191475">\n<p data-nodeid="191476">接下来再启动本文件夹 network_io_opt 的服务；</p>\n</li>\n<li data-nodeid="191477">\n<p data-nodeid="191478">启动完成后，再进行压测。</p>\n</li>\n</ul>\n<p data-nodeid="191479" class="">可以得到表 6 的压测对比数据。</p>\n<p data-nodeid="230077" class=""><img src="https://s0.lgstatic.com/i/image6/M00/34/00/Cgp9HWBwD8GACAFLAABqJCdynds886.png" alt="Drawing 10.png" data-nodeid="230080"></p>\n\n\n\n<p data-nodeid="191526">从结果中可以看出优化效果非常明显，一个简单的优化就可以将原来 272.96 的 QPS 提升到 31503.58。</p>\n<p data-nodeid="191527">最后我们再来看看磁盘 I/O 的优化。</p>\n<h4 data-nodeid="191528">磁盘 I/O</h4>\n<p data-nodeid="191529"><strong data-nodeid="192163">磁盘 I/O 的优化分为读优化和写优化</strong>，优化的策略有：</p>\n<ul data-nodeid="191530">\n<li data-nodeid="191531">\n<p data-nodeid="191532">为了提升性能需要将同步修改异步，避免影响主线程的性能；</p>\n</li>\n<li data-nodeid="191533">\n<p data-nodeid="191534">读优化，必须增加必要的缓存，减少相同文件的重复读取；</p>\n</li>\n<li data-nodeid="191535">\n<p data-nodeid="191536">写优化，可以使用异步写文件的方式，先将写内容缓存到队列（如我们第一部分的第 08 讲的方案）；</p>\n</li>\n<li data-nodeid="191537">\n<p data-nodeid="191538">合并多次写操作，避免频繁打开文件，读写文件内容。</p>\n</li>\n</ul>\n<p data-nodeid="191539">当然对于本讲，我们着重优化 2 点：</p>\n<ul data-nodeid="191540">\n<li data-nodeid="191541">\n<p data-nodeid="191542">修改为异步</p>\n</li>\n<li data-nodeid="191543">\n<p data-nodeid="191544">增加缓存</p>\n</li>\n</ul>\n<p data-nodeid="191545">优化代码如下（代码在 disk_io_opt 中）：</p>\n<pre class="lang-javascript" data-nodeid="191546"><code data-language="javascript"><span class="hljs-keyword">const</span> server = http.createServer(<span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> {\n    fs.readFile(<span class="hljs-string">\'./test_file.conf\'</span>, (err, data) =&gt; {\n        <span class="hljs-keyword">if</span> (err) {\n            res.write(<span class="hljs-string">\'error read file\'</span>);\n            res.end();\n        } <span class="hljs-keyword">else</span> {\n            res.write(data);\n            res.end();\n        }\n    });\n});\n</code></pre>\n<p data-nodeid="191547">接下来继续压测看下效果，如表 7 所示：</p>\n<p data-nodeid="231399" class=""><img src="https://s0.lgstatic.com/i/image6/M00/34/00/Cgp9HWBwD8qATRwGAABrIJLpIKs046.png" alt="Drawing 11.png" data-nodeid="231402"></p>\n\n\n\n<p data-nodeid="191594">从上面看得出异步 I/O 对服务性能提升还是比较突出，也是比较关键的。如果文件大会更突出，因此在平时代码中要非常注重这点，减少同步读写的操作。</p>\n<p data-nodeid="191595">那么如果我们继续优化，增加缓存呢？我们来看下效果，修改下面代码：</p>\n<pre class="lang-javascript" data-nodeid="191596"><code data-language="javascript"><span class="hljs-comment">// 文件缓存</span>\n<span class="hljs-keyword">let</span> fileCache;\n<span class="hljs-comment">/**\n * \n * 创建 http 服务，简单返回\n */</span>\n<span class="hljs-keyword">const</span> server = http.createServer(<span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> {\n    <span class="hljs-keyword">if</span>(fileCache) {\n        res.write(fileCache);\n        res.end();\n        <span class="hljs-keyword">return</span>;\n    }\n    fs.readFile(<span class="hljs-string">\'./test_file.conf\'</span>, (err, data) =&gt; {\n        <span class="hljs-keyword">if</span> (err) {\n            res.write(<span class="hljs-string">\'error read file\'</span>);\n            res.end();\n        } <span class="hljs-keyword">else</span> {\n            fileCache = data;\n            res.write(data);\n            res.end();\n        }\n    });\n});\n</code></pre>\n<p data-nodeid="191597">并且重新压测看下数据，如表格 8 所示。</p>\n<p data-nodeid="232531" class=""><img src="https://s0.lgstatic.com/i/image6/M00/34/08/CioPOWBwD9KAICB5AAB9TVaRLF4498.png" alt="Drawing 12.png" data-nodeid="232534"></p>\n\n\n\n<p data-nodeid="191652">从结果看已经和标准的数据非常接近，因此<strong data-nodeid="192298">在 Node.js 开发过程中，要特别注意文件读取，避免相同文件的重复读取</strong>。从表格 8 中的异步和缓存数据对比来看，通过缓存的处理优化，就可以在 QPS 上从 18353.39 提升至 35058.79，有 91% 以上的性能提升。</p>\n<h3 data-nodeid="191653">总结</h3>\n<p data-nodeid="191654">学完本讲，你应该要掌握两个工具的应用，对于服务端研发来说这些工具是非常重要的，我希望你能深入去实践应用这两个工具。其次了解 3 种影响性能因素的优化策略，同时在日常开发中，应尽量避免影响性能的代码逻辑。</p>\n<p data-nodeid="191655">那你在实际的工作中，是如何提升性能的呢，欢迎在评论区分享你的经验。</p>\n<p data-nodeid="233443">这一讲就讲完了，下一讲将讲解“常见网络攻击以及防护策略”，到时见~</p>\n\n\n\n\n\n<hr data-nodeid="191661">\n\n\n\n<p data-nodeid="191033"><a href="https://shenceyun.lagou.com/t/mka" data-nodeid="191040"><img src="https://s0.lgstatic.com/i/image6/M00/12/FA/CioPOWBBrAKAAod-AASyC72ZqWw233.png" alt="Drawing 2.png" data-nodeid="191039"></a></p>\n<p data-nodeid="191034"><strong data-nodeid="191044">《大前端高薪训练营》</strong></p>\n<p data-nodeid="191035" class="">对标阿里 P7 技术需求 + 每月大厂内推，6 个月助你斩获名企高薪 Offer。<a href="https://shenceyun.lagou.com/t/mka" data-nodeid="191048">点击链接</a>，快来领取！</p>',
        article_title: "12 | 性能分析：性能影响的关键路径以及优化策略",
        title: "12 | 性能分析：性能影响的关键路径以及优化策略",
        id: 6794,
      },
      {
        content:
          '<p data-nodeid="12942" class="">Node.js 作为后台服务，网络相关的安全措施也非常重要，<strong data-nodeid="13019">互联网一些常见的网络攻击策略，我们都应该在框架层面去杜绝</strong>。本讲就介绍一些常见的网络攻击方式，并介绍如何在框架中增加这类问题的防护措施。我会着重介绍 Node.js 作为后台服务，自身所需要注意的安全问题，为后续我们在线上的应用提供一个参考。</p>\n<h3 data-nodeid="12943">常见的网络攻击</h3>\n<p data-nodeid="12944">这些网络攻击有<strong data-nodeid="13026">XSS、CSRF、SQL 注入以及 Dos</strong>，在 Node.js 作为后台服务时，同样存在这些问题，这里简单演示下可能出现问题的场景，以及如何去防御。</p>\n<h4 data-nodeid="12945">XSS</h4>\n<p data-nodeid="12946">这里就不对概念进行阐述，我们看下下面这段代码。这里尽量不要直接吐出数据，而是统一经过处理层进行转化。</p>\n<pre class="lang-javascript" data-nodeid="12947"><code data-language="javascript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Xss</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Controller</span> </span>{\n    index() {\n        <span class="hljs-keyword">const</span> params = querystring.parse(<span class="hljs-keyword">this</span>.ctx.request.querystring);\n        <span class="hljs-keyword">let</span> name = <span class="hljs-built_in">decodeURI</span>(params[<span class="hljs-string">\'name\'</span>]);\n\n        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.ctx.response.body = name;\n        <span class="hljs-comment">//return this.resApi(true, \'good\', a);</span>\n    }\n}\n<span class="hljs-built_in">module</span>.exports = Xss;\n</code></pre>\n<p data-nodeid="12948">在上面代码中，<strong data-nodeid="13038">没有对 name 进行任何处理，就直接返回给接口，并且没有经过我们的 resApi 服务，而是使用 body 直接设置返回</strong>。这样就会导致，<strong data-nodeid="13039">当 name 为一个 HTML 或者 JS 都会被浏览器执行</strong>。当我们启动服务后，访问以下地址，都会出现一些异常问题。</p>\n<pre class="lang-java" data-nodeid="12949"><code data-language="java">http:<span class="hljs-comment">//127.0.0.1:3000/v1/xss/index?name=%3Cscript%3Ealert(%27nodejs%27)%3C/script%3E</span>\nhttp:<span class="hljs-comment">//127.0.0.1:3000/v1/xss/index?name=%3Chtml%3E%3Ch1%3E%E6%88%91%E6%83%B3%E6%89%93%E5%8D%B0%E4%BB%80%E4%B9%88%EF%BC%8C%E5%B0%B1%E6%89%93%E5%8D%B0%E4%BB%80%E4%B9%88%EF%BC%8C%E4%BD%A0%E7%BD%91%E7%AB%99%E8%A2%AB%E6%94%BB%E5%87%BB%E4%BA%86%3C/h1%3E%3C/html%3E</span>\n</code></pre>\n<p data-nodeid="12950">这里<strong data-nodeid="13045">最简单的防御方式就是使用我们统一的 resApi 处理响应数据</strong>，因为在 resApi 中固定了返回结果，进行了 JSON.stringify 处理，所有的返回都会封装为一个 json 字符串，因此不会存在 XSS 的问题。</p>\n<h4 data-nodeid="12951">CSRF</h4>\n<p data-nodeid="12952"><strong data-nodeid="13051">跨站攻击</strong>，举个简单的例子，在前端一般会将登录态相关的信息保存在 Cookie 中，假设我们已经在 A 站点登录了，接下来我在 B 域名站点，诱骗在 A 站登录的用户，发起一个 A 站点的接口请求，而这时候 A 站请求会携带 Cookie 给到服务端，服务端会正常的响应，从而我在 B 站可以诱骗各种支付或者扣款请求。</p>\n<p data-nodeid="12953">这种安全问题对后台服务的影响还是非常大的，而 Node.js 作为后台服务也需要做一定的安全校验，其中一个是<strong data-nodeid="13061">对 referer 的校验通用做法</strong>，也就是只允许我们制定的域名发送的请求，其他站点则认为是非法请求，比如下面我们的中间件，只要存在 referer，并且 referer 不在我们的域名白名单下，那么则<strong data-nodeid="13062">直接返回 403 拒绝访问</strong>。</p>\n<pre class="lang-javascript" data-nodeid="12954"><code data-language="javascript"><span class="hljs-keyword">const</span> baseFun = <span class="hljs-built_in">require</span>(<span class="hljs-string">\'../lib/baseFun\'</span>);\n<span class="hljs-keyword">const</span> whiteList = [\n    <span class="hljs-string">\'127.0.0.1:3000\'</span>\n];\n<span class="hljs-built_in">module</span>.exports = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{\n    <span class="hljs-keyword">return</span> <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"> ctx, next </span>) </span>{\n       <span class="hljs-keyword">if</span>(ctx.request.headers.referer &amp;&amp; !whiteList.includes(ctx.request.headers.referer)){\n            baseFun.setResInfo(ctx, <span class="hljs-literal">false</span>, <span class="hljs-string">\'access have been forbidden\'</span>, <span class="hljs-literal">null</span>, <span class="hljs-number">403</span>);\n            <span class="hljs-keyword">return</span>;\n       }\n       <span class="hljs-keyword">return</span> <span class="hljs-keyword">await</span> next();\n    }\n}\n</code></pre>\n<p data-nodeid="12955">另外一个是<strong data-nodeid="13068">后台服务在写操作时，使用 token 校验方式</strong>，这里我们应用的是 JWT，也就是在用户打开页面时，将 token 写入页面的隐藏元素中，当请求接口时从页面元素中获取 token，再传递到接口参数中，这样第三方站点因为没有打开页面是无法获取到这个 token 的。</p>\n<h4 data-nodeid="12956">SQL 注入</h4>\n<p data-nodeid="12957">在 Node.js 中应用 MySQL 时要特别注意这点，<strong data-nodeid="13075">因为 SQL 语句中包含了外部的参数，如果参数没有做任何处理，将导致用户可以根据自己的意愿拼装 SQL 语句在数据库中执行，从而影响业务服务的正常运行</strong>。</p>\n<p data-nodeid="12958">假设我们需要查询一个名字为 \'Node.js\' 的学生，在 Node.js 中，假设我们这样去拼装并执行语句。</p>\n<pre class="lang-javascript" data-nodeid="12959"><code data-language="javascript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Sql</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Controller</span> </span>{\n    index() {\n        <span class="hljs-keyword">const</span> params = querystring.parse(<span class="hljs-keyword">this</span>.ctx.request.querystring);\n        <span class="hljs-keyword">let</span> name = <span class="hljs-built_in">decodeURI</span>(params[<span class="hljs-string">\'name\'</span>]);\n        <span class="hljs-comment">/// connection 是 mysql 的链接句柄</span>\n        <span class="hljs-keyword">let</span> queryStr    = <span class="hljs-string">\'SELECT * FROM student WHERE name = "\'</span> + name + <span class="hljs-string">\'"\'</span>; \n        <span class="hljs-comment">//connection.query(queryStr, function(err, results) {});</span>\n        <span class="hljs-built_in">console</span>.log(queryStr);\n        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.resApi(<span class="hljs-literal">true</span>, <span class="hljs-string">\'good\'</span>, queryStr);\n    }\n}\n<span class="hljs-built_in">module</span>.exports = Sql;\n</code></pre>\n<p data-nodeid="12960">在上面代码例子中，获取参数 name 的值，然后拼接到 queryStr 中，组装成一个 SQL 语句，这里如果 name 传递正常的值当然是没有问题的，比如下面这样：</p>\n<pre class="lang-java" data-nodeid="12961"><code data-language="java">http:<span class="hljs-comment">//127.0.0.1:3000/v1/sql/index?name=Node.js</span>\n</code></pre>\n<p data-nodeid="12962">但是如果我们传递的是下面这样的 name：</p>\n<pre class="lang-java" data-nodeid="12963"><code data-language="java">http:<span class="hljs-comment">//127.0.0.1:3000/v1/sql/index?name=自定义";DELETE FROM student;"</span>\n</code></pre>\n<p data-nodeid="12964">你就会发现其实<strong data-nodeid="13088">SQL 语句不仅仅是执行了一条 SELECT 语句，还执行了一个 DELETE student 表的操作</strong>。</p>\n<p data-nodeid="12965">以上是非常危险的行为，<strong data-nodeid="13098">通过这个漏洞可以直接对 SQL 的数据库进行攻击</strong>。那么如何去防御呢？在 Node.js 中有最常见的方法是<strong data-nodeid="13099">使用占位符的方式</strong>，也就是使用下面的方式替代拼装 SQL 语法的方法：</p>\n<pre class="lang-java" data-nodeid="12966"><code data-language="java">connection.query(<span class="hljs-string">\'SELECT * FROM student WHERE name = ?\'</span>, [name], function(err, results) {})\n</code></pre>\n<p data-nodeid="12967"><strong data-nodeid="13104">使用这种方式会自动将 name 进行转译，以防止其他 SQL 语法的混入</strong>。</p>\n<h4 data-nodeid="12968">Dos</h4>\n<p data-nodeid="12969"><strong data-nodeid="13114">这种网络攻击的主要原理就是通过模拟无效的海量用户请求，来导致后台服务的崩溃现象</strong>。一般这种在后台服务中不需要考虑，可以直接在网关层进行处理，如果真的没有网关层的话，可以考虑使用 NPM 中的一个<a href="https://www.npmjs.com/package/ddos?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="13112">ddos 库</a>。</p>\n<p data-nodeid="12970">以上就是常见的互联网的攻击方式，但是在 Node.js 中还存在一些特别的情况，下面我们就来看下这些特殊情况的例子，以及如何去应对。</p>\n<h3 data-nodeid="12971">Node.js 中特有的一些问题</h3>\n<p data-nodeid="12972">在应用 Node.js 作为后台服务时，以下 3 种情况是非常要注意的，不注意的话会严重导致线上安全问题，从而导致公司、企业的严重损失。</p>\n<h4 data-nodeid="12973">eval 函数</h4>\n<p data-nodeid="12974"><strong data-nodeid="13123">在任何情况下，都应杜绝使用该函数，因为该函数存在非常不可控的因素，这点和 SQL 注入相似，相当于 JS 代码注入</strong>，比如下面这段代码：</p>\n<pre class="lang-javascript" data-nodeid="12975"><code data-language="javascript"><span class="hljs-keyword">const</span> querystring = <span class="hljs-built_in">require</span>(<span class="hljs-string">\'querystring\'</span>);\n<span class="hljs-keyword">const</span> Controller = <span class="hljs-built_in">require</span>(<span class="hljs-string">\'../../core/controller\'</span>);\n<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Eval</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Controller</span> </span>{\n    index() {\n        <span class="hljs-keyword">const</span> params = querystring.parse(<span class="hljs-keyword">this</span>.ctx.request.querystring);\n        <span class="hljs-comment">// 获取参数 r</span>\n        <span class="hljs-keyword">let</span> r = <span class="hljs-built_in">decodeURI</span>(params[<span class="hljs-string">\'r\'</span>]);\n        <span class="hljs-comment">// 根据参数 r 动态调用 this._p() 获取执行结果</span>\n        <span class="hljs-keyword">let</span> ret = <span class="hljs-built_in">eval</span>(<span class="hljs-string">`this._q() + <span class="hljs-subst">${r}</span>`</span>);\n        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.resApi(<span class="hljs-literal">true</span>, <span class="hljs-string">\'good\'</span>, ret);\n    }\n    _q () {\n        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;\n    }\n    _p () {\n        <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;\n    }\n}\n<span class="hljs-built_in">module</span>.exports = Eval;\n</code></pre>\n<p data-nodeid="12976">代码比较简单，假设我们希望用 eval 来动态调用内部的一些函数，因此我们使用了 r 这个参数，正常情况下是可以调用，但是如果我们调用下面的地址：</p>\n<pre class="lang-java" data-nodeid="12977"><code data-language="java">http:<span class="hljs-comment">//127.0.0.1:3000/v1/eval/index?r=this._p();console.log(\'d\');const fs=require(\'fs\');fs.readFileSync(__filename, \'utf8\')</span>\n</code></pre>\n<p data-nodeid="12978">访问后，你会发现很恐怖的一幕，源代码直接被返回了，如图 1 所示。</p>\n<p data-nodeid="12979"><img src="https://s0.lgstatic.com/i/image6/M00/37/20/CioPOWB1u9iAa6CoAAEyQ6iErU8829.png" alt="Drawing 0.png" data-nodeid="13128"></p>\n<div data-nodeid="12980"><p style="text-align:center">图 1 eval 泄漏源代码例子</p></div>\n<p data-nodeid="12981">因此<strong data-nodeid="13134">无论任何情况下，代码中都不允许 eval 的使用，因为不可控因素太大</strong>。</p>\n<h4 data-nodeid="12982">文件读写</h4>\n<p data-nodeid="12983">在我们之前设计路由的时候，有讲解过这个路径的问题，就像下面这段代码：</p>\n<pre class="lang-javascript" data-nodeid="12984"><code data-language="javascript"> <span class="hljs-comment">// 去除非常规请求路径，将-转化为大写</span>\npathname = pathname.replace(<span class="hljs-string">\'..\'</span>, <span class="hljs-string">\'\'</span>).replace(<span class="hljs-regexp">/\\-(\\w)/g</span>, <span class="hljs-function">(<span class="hljs-params">all,letter</span>)=&gt;</span>letter.toUpperCase());\n</code></pre>\n<p data-nodeid="12985">第一个 replace 的两个点是非常重要的，这样我们才能控制 require 的文件仅仅只在 controller 文件夹下。</p>\n<p data-nodeid="12986">接下来我们看一个没有控制好目录路径导致的问题，比如下面这段代码：</p>\n<pre class="lang-javascript" data-nodeid="12987"><code data-language="javascript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Fs</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Controller</span> </span>{\n    index() {\n        <span class="hljs-keyword">const</span> params = querystring.parse(<span class="hljs-keyword">this</span>.ctx.request.querystring);\n        <span class="hljs-comment">// 根据产品名称获取产品的配置信息</span>\n        <span class="hljs-keyword">let</span> product = <span class="hljs-built_in">decodeURI</span>(params[<span class="hljs-string">\'product\'</span>]);\n        <span class="hljs-keyword">try</span> {\n            <span class="hljs-keyword">let</span> productInfo = fs.readFileSync(<span class="hljs-string">`<span class="hljs-subst">${__dirname}</span>/../../config/products/<span class="hljs-subst">${product}</span>.json`</span>, <span class="hljs-string">\'utf8\'</span>);\n            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.resApi(<span class="hljs-literal">true</span>, <span class="hljs-string">\'good\'</span>, productInfo);\n        } <span class="hljs-keyword">catch</span>(err){\n            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.resApi(<span class="hljs-literal">false</span>, <span class="hljs-string">\'can not find the product\'</span>);\n        }\n    }\n}\n</code></pre>\n<p data-nodeid="12988">正常访问以下两个链接都可以拿到我们具体需要的正常逻辑。</p>\n<pre class="lang-java" data-nodeid="12989"><code data-language="java">http:<span class="hljs-comment">//127.0.0.1:3000/v1/fs/index?product=c</span>\nhttp:<span class="hljs-comment">//127.0.0.1:3000/v1/fs/index?product=d</span>\n</code></pre>\n<p data-nodeid="12990">如图 2 所示的是一个正常的响应结果。</p>\n<p data-nodeid="12991"><img src="https://s0.lgstatic.com/i/image6/M01/37/18/Cgp9HWB1u-eAICCOAAAyzg3koIs578.png" alt="Drawing 1.png" data-nodeid="13143"></p>\n<div data-nodeid="12992"><p style="text-align:center">图 2 fs 正常响应</p></div>\n<p data-nodeid="12993">但是<strong data-nodeid="13149">如果我们访问了以下地址，就直接导致了配置文件泄漏，从而引发了数据库账号和密码被泄漏的安全问题</strong>。</p>\n<pre class="lang-java" data-nodeid="12994"><code data-language="java">http:<span class="hljs-comment">//127.0.0.1:3000/v1/fs/index?product=../b</span>\n</code></pre>\n<p data-nodeid="12995">访问以后，你就可以通过上面代码访问到我们项目中的所有配置文件了，而配置文件中包含了非常多敏感信息，如图 3 所示。</p>\n<p data-nodeid="12996"><img src="https://s0.lgstatic.com/i/image6/M00/37/20/CioPOWB1u--ARC0iAABHYTevEBU886.png" alt="Drawing 2.png" data-nodeid="13153"></p>\n<div data-nodeid="12997"><p style="text-align:center">图 3 泄漏配置文件响应</p></div>\n<p data-nodeid="12998">解决方案的话，就是将访问的配置文件，<strong data-nodeid="13159">控制在当前配置文件目录下</strong>，因此你需要将这种 .. 路径进行替换，比如使用下面代码修复后，就解决了该问题。你再次启动服务，访问上面路径后，将会提示访问路径异常的信息。</p>\n<pre class="lang-javascript" data-nodeid="12999"><code data-language="javascript"><span class="hljs-comment">// 去掉上层目录访问</span>\nproduct = product.replace(<span class="hljs-string">\'..\'</span>, <span class="hljs-string">\'\'</span>)\n</code></pre>\n<p data-nodeid="13000">但是这里要注意，这样还是可以访问同目录下的文件的，因此最好的方式是，<strong data-nodeid="13165">将配置文件归类，并且做好校验，非范围内的配置文件不允许读取</strong>。</p>\n<p data-nodeid="13001">其次在写文件时，更加要注意风险问题，一般情况下，<strong data-nodeid="13175">分开写目录和源代码目录</strong>，例如可以将上传的文件或者日志文件放到另外一个单独目录，并控制权限即可。<strong data-nodeid="13176">以防代码写漏洞，导致本地文件被篡改，或者写入一些脚本文件从而控制服务器</strong>。</p>\n<p data-nodeid="13002">为了更清晰了解写带来的风险，我们同样写了一个测试代码，你可以看下 Fs 类中的 writeTest 方法，也可以自行地去测试一下，这部分就交给你去实践了。测试时，你需要使用 Postman 来发送数据，例如图 4 所示。</p>\n<p data-nodeid="13003"><img src="https://s0.lgstatic.com/i/image6/M01/37/18/Cgp9HWB1u_eAPII6AAEJsYGMP54262.png" alt="Drawing 3.png" data-nodeid="13180"></p>\n<div data-nodeid="13004"><p style="text-align:center">图 4 测试文件写风险</p></div>\n<h4 data-nodeid="13005">非 root 用户权限</h4>\n<p data-nodeid="14254" class="te-preview-highlight"><strong data-nodeid="14259">在大部分情况下 Node.js 的进程是无须太多权限的，只需要一些固定目录的读写权限，因此我们只需要赋予 Node.js 服务最低的用户权限，一定不要设置为 root 权限</strong>。比如上面我们的 eval 函数导致的问题，如果你是使用 root 权限，那么就可以通过 Node.js fs 获取主机的登录密码，从而直接控制这台机器。而在大部分公司，主机和主机都是内网互通，如果单台内网机器被攻克后，就相当于整个公司的内网系统沦陷了。</p>\n\n\n\n<p data-nodeid="13007">为了解决这个问题，<strong data-nodeid="13192">我们可以新建一个独立的用户，然后创建 Node.js 所需要读写的日志以及其他目录权限赋予读写权限</strong>，如下所示：</p>\n<pre class="lang-shell" data-nodeid="13008"><code data-language="shell">adduser username\nchown -R /path\n</code></pre>\n<p data-nodeid="13009"><strong data-nodeid="13197">第一步创建用户，第二步为用户归属权限</strong>，一般情况下只需要归属当前源代码路径和需要写日志的目录。</p>\n<h3 data-nodeid="13010">总结</h3>\n<p data-nodeid="13011">本讲介绍了常见的一些网络攻击方案，其次着重介绍了在 Node.js 中要注意的安全风险问题。网络攻击一般是面试中常被问及的题目，因此我们需要着重学习其原理，其次针对 Node.js 的安全问题则是你在编码过程中非常要注重的，避免在应用 Node.js 的过程中导致企业受到损失。</p>\n<p data-nodeid="13012">如果你还有其他的一些安全性问题，也可以在本讲下面进行留言，我将和你一起探讨如何解决这些线上安全问题。</p>\n<p data-nodeid="13013" class="">下一讲我们将介绍一个可以轻松地协助我们来做各种性能提前校验的工具，其次会实践应用该工具融合到我们的框架中。</p>',
        article_title: "13 | 网络安全：常见网络攻击以及防护策略",
        title: "13 | 网络安全：常见网络攻击以及防护策略",
        id: 6795,
      },
      {
        content:
          '<p data-nodeid="47644">在该模块的几讲中，我们都是先有问题，然后再定位分析解决问题，那么是否有方法能够在出现问题之前检测问题呢？那就需要用到本讲要介绍的 clinicjs 工具，在上线之前通过自动化的方式来发现问题。</p>\n<h3 data-nodeid="47645">clinicjs 是什么</h3>\n<h4 data-nodeid="47646">介绍</h4>\n<p data-nodeid="47647">clinicjs 是一个 Node.js 的第三方工具，<a href="https://clinicjs.org/?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="47754">clinicjs 官网</a>介绍了其核心的目的是，<strong data-nodeid="47760">帮助诊断和查明 Node.js 性能问题的工具</strong>。那么它具体能帮助我们定位查询哪些性能问题呢？</p>\n<ul data-nodeid="47648">\n<li data-nodeid="47649">\n<p data-nodeid="47650"><strong data-nodeid="47765">CPU 异常问题</strong>，当 CPU 存在密集计算占用时可以检测出来。</p>\n</li>\n<li data-nodeid="47651">\n<p data-nodeid="47652"><strong data-nodeid="47770">事件循环延迟问题</strong>，当主线程存在过载时，事件循环的执行时间存在延迟，可以检测出来。</p>\n</li>\n<li data-nodeid="47653">\n<p data-nodeid="47654"><strong data-nodeid="47775">内存泄漏问题</strong>。</p>\n</li>\n<li data-nodeid="47655">\n<p data-nodeid="47656"><strong data-nodeid="47780">句柄泄漏问题</strong>。</p>\n</li>\n</ul>\n<p data-nodeid="47657">以上几个问题也是我们非常关注的几个点。</p>\n<p data-nodeid="47658">我们先使用 npm 来安装该工具，如下所示：</p>\n<pre class="lang-java" data-nodeid="47659"><code data-language="java">npm install -g clinic\nclinic --help\n</code></pre>\n<p data-nodeid="47660">安装完成后，我们需要把《12 | 性能分析：性能影响的关键路径以及优化策略》中的 wrk 也安装了，因为其需要 wrk 来进行压测，都安装完成后，需要着重掌握以下三个命令。</p>\n<p data-nodeid="47661">你可以先把我们的服务器启动起来，然后尝试在我们项目根目录去运行下面的命令 1 。</p>\n<pre class="lang-java" data-nodeid="47662"><code data-language="java">clinic doctor --on-port <span class="hljs-string">"wrk http://127.0.0.1:3000/local-cache/no"</span> -- node app.js\n</code></pre>\n<p data-nodeid="47663"><strong data-nodeid="47789">这个命令 1 是指对服务的 local-cache/no 进行性能全局分析</strong>。</p>\n<p data-nodeid="47664">我们再来看下命令 2，如下所示：</p>\n<pre class="lang-java" data-nodeid="47665"><code data-language="java">clinic flame --on-port <span class="hljs-string">"wrk http://127.0.0.1:3000/local-cache/no"</span> -- node app.js\n</code></pre>\n<p data-nodeid="47666"><strong data-nodeid="47799">命令 2 是当全局分析出现事件延迟或者高 CPU 占用时，就需要使用该工具进行具体深入分析</strong>，关于如何应用，你可以参考<a href="https://clinicjs.org/documentation/flame/?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="47797">clinic flame 官网</a>说明。</p>\n<p data-nodeid="47667">以下是命令 3：</p>\n<pre class="lang-java" data-nodeid="47668"><code data-language="java">clinic bubbleprof --on-port <span class="hljs-string">"wrk http://127.0.0.1:3000/local-cache/no"</span> -- node app.js\n</code></pre>\n<p data-nodeid="47669"><strong data-nodeid="47809">命令 3 是当全局分析出现 I/O 问题时，我们就需要使用该工具进一步分析</strong>，关于如何应用，你可以参考<a href="https://clinicjs.org/documentation/doctor/06-fixing-io-problem/?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="47807"> clinic bubbleprof 官网</a>说明。</p>\n<h4 data-nodeid="47670">示例分析</h4>\n<p data-nodeid="47671">我们来看几个例子，以下例子都是来自 clinicjs 测试的结果。</p>\n<p data-nodeid="47672">我们先来看图 1 所示的结果。</p>\n<p data-nodeid="49622" class=""><img src="https://s0.lgstatic.com/i/image6/M00/37/90/Cgp9HWB37a2AKhPmAAJeXJvA1Tg457.png" alt="Drawing 0.png" data-nodeid="49626"></p>\n<div data-nodeid="49623"><p style="text-align:center">图 1 clinicjs 无异常检测结果</p></div>\n\n\n\n<p data-nodeid="47675">从图 1 可以看到一个总结性的话，正如第一行 Detected no issue 表明，本次测试没有任何问题，具体可以再看下四个结果：<strong data-nodeid="47822">CPU 占用、内存占用、事件延迟和句柄</strong>。</p>\n<p data-nodeid="47676">我们再来看一种异常的情况，如图 2 所示的结果。</p>\n<p data-nodeid="50750" class=""><img src="https://s0.lgstatic.com/i/image6/M00/37/98/CioPOWB37bmAOY3WAAKiAW23OY4348.png" alt="Drawing 1.png" data-nodeid="50754"></p>\n<div data-nodeid="50751"><p style="text-align:center">图 2 clinicjs 异常检测结果</p></div>\n\n\n\n<p data-nodeid="47679">上图的第一行很清晰地告诉我们，<strong data-nodeid="47833">存在 CPU 问题、内存问题和事件延迟的情况</strong>，看到以上问题后，我们接下来怎么处理呢？</p>\n<p data-nodeid="47680">在 clinicjs 中如果分析出存在 CPU 和事件延迟，可以使用上面我们所介绍的 clinic flame 工具。而 I/O 问题则使用 clinic bubbleprof 来进一步定位。</p>\n<h3 data-nodeid="47681">框架中接入自动化</h3>\n<p data-nodeid="47682">以上是一个工具的应用，并不是我们本讲的重点，<strong data-nodeid="47841">我们本讲的核心是将该工具作为一个自动化模块接入我们的框架中</strong>。</p>\n<h4 data-nodeid="47683">框架中测试的思考</h4>\n<p data-nodeid="47684">clinicjs 接入后，使用方法非常简单，我们只需要使用以下命令就可以进行测试检测。</p>\n<pre class="lang-java" data-nodeid="47685"><code data-language="java">clinic doctor --on-port <span class="hljs-string">"wrk http://127.0.0.1:3000/local-cache/no"</span> -- node app.js\n</code></pre>\n<p data-nodeid="47686">但是需要思考一下，如果每次新接口上线我们都需要一个个跑一遍，那么岂不是很花费人力，这时就需要思考下有没有办法可以自动化地做接口测试，而我们只需要深入分析有问题的接口就可以了。</p>\n<p data-nodeid="47687">有了以上思考后，我们就开始来规划下，如何进行自动化测试。</p>\n<h4 data-nodeid="47688">自动化</h4>\n<p data-nodeid="47689">首先来整理一个流程图，来分析下我们应该如何实现这个功能。</p>\n<p data-nodeid="51874" class=""><img src="https://s0.lgstatic.com/i/image6/M00/37/98/CioPOWB37cOAdvHkAAJjWOy1L2Y825.png" alt="Drawing 2.png" data-nodeid="51878"></p>\n<div data-nodeid="51875"><p style="text-align:center">图 3 自动化方案流程图</p></div>\n\n\n\n<p data-nodeid="47692">我们分析一下以上流程的每个过程：</p>\n<ol data-nodeid="47693">\n<li data-nodeid="47694">\n<p data-nodeid="47695">我们<strong data-nodeid="47858">将需要测试的接口组装成一个配置信息</strong>，其中包含了待测试的请求路径、请求方式以及请求的参数；</p>\n</li>\n<li data-nodeid="47696">\n<p data-nodeid="47697">因为 clinicjs 生成的是一个 html 文件，并且这个 html 文件是一个 JavaScript 执行生成的结果文件，因此需要启动一个本地服务来读取 html 并解析生成具体的 DOM 结构；</p>\n</li>\n<li data-nodeid="47698">\n<p data-nodeid="47699">从数组取出一个待测试的接口数据，来开始测试，根据 clinicjs 的命令，生成具体的执行命令行，然后借助 child process 的 exec 来执行，并获取其执行结果；</p>\n</li>\n<li data-nodeid="47700">\n<p data-nodeid="47701">最终会生成一个运行期间的结果，在输出的最后一行会提供一个生成后的 html 文件路径地址，一般这个文件都会生成在当前目录下的 .clinic 文件夹中；</p>\n</li>\n<li data-nodeid="47702">\n<p data-nodeid="47703">使用一个 html 的解析工具 puppeteer 从本地服务中读取 html 文件，并解析获取其中的测试结果的 DOM 信息；</p>\n</li>\n<li data-nodeid="47704">\n<p data-nodeid="47705">判断 DOM 信息中是否有异常结果，有异常显示异常并记录测试数据，没有则跳过；</p>\n</li>\n<li data-nodeid="47706">\n<p data-nodeid="47707">最终测试完成以后，显示所有测试异常的接口，并把测试信息给到开发者。</p>\n</li>\n</ol>\n<p data-nodeid="47708">根据以上的流程，我们画一个逻辑执行过程来更清晰描述下这个过程。</p>\n<p data-nodeid="52994" class=""><img src="https://s0.lgstatic.com/i/image6/M00/37/90/Cgp9HWB37cyAPGhrAAEXls5qfQY168.png" alt="Drawing 3.png" data-nodeid="52998"></p>\n<div data-nodeid="52995"><p style="text-align:center">图 4 自动化方案逻辑执行图</p></div>\n\n\n\n<p data-nodeid="47711">上面的逻辑和流程图基本上是一个过程，<strong data-nodeid="47881">只是这里用函数和模块来表示了</strong>，具体我们可以看下部分代码的实现，如图 5 所示，源码在<a href="https://github.com/love-flutter/nodejs-column?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="47877">GitHub </a>中的 bin/clinic_test.js 文件中。</p>\n<p data-nodeid="54110" class=""><img src="https://s0.lgstatic.com/i/image6/M00/37/98/CioPOWB37dKAaCSYAALhCgAFm2U761.png" alt="Drawing 4.png" data-nodeid="54114"></p>\n<div data-nodeid="54111"><p style="text-align:center">图 5 startTestLink 代码实现</p></div>\n\n\n\n<p data-nodeid="47714">在图 5 中的第 57-63 行逻辑中，主要是在组装 clinicjs 的测试命令，最终的命令会变成以下的命令行。</p>\n<pre class="lang-java" data-nodeid="47715"><code data-language="java">cd ..\nclinic doctor --on-port <span class="hljs-string">"wrk http://127.0.0.1:3000/xxxx"</span> -- node app.js\nexit\n</code></pre>\n<p data-nodeid="47716">以上是 GET 方法，<strong data-nodeid="47892">如果是 POST 方法则需要写入 POST 数据，并且需要在命令行中加上 POST 参数</strong>，如下命令示例结果：</p>\n<pre class="lang-java" data-nodeid="47717"><code data-language="java">cd ..\nclinic doctor --on-port <span class="hljs-string">"wrk http://127.0.0.1:3000/xxxx -s ./bin/post_tmp.lua"</span> -- node app.js\nexit\n</code></pre>\n<p data-nodeid="47718">拿到命令以后，再使用 Node.js 的 execSync 方法获取执行结果，请注意这里的执行结果是非常长的日志，但是在最后一行会提示 html 生成的文件地址，在图 5 中的 64 到 67 行就是获取到相应的 html 文件，拿到 html 文件后再向本地服务读取到 html 的内容，最后 parseResult 来分析是否存在性能问题。</p>\n<p data-nodeid="47719">接下来我们看下 parseResult 的方法实现，代码如图 6 所示。</p>\n<p data-nodeid="55779" class=""><img src="https://s0.lgstatic.com/i/image6/M00/37/98/CioPOWB37eWAX1KsAAFcIAG2wp8914.png" alt="Drawing 5.png" data-nodeid="55783"></p>\n<div data-nodeid="55780"><p style="text-align:center">图 6 parseResult 代码实现</p></div>\n\n\n\n\n\n<p data-nodeid="47722"><strong data-nodeid="47903">这里有个小技巧，就是在 Node.js 中可以模拟浏览器去读取一个 html 文件，如果 html 文件不是通过 Javascript 动态生成的，那么你可以直接 fs.readFile 去获取，如果是动态生成的则必须用 puppeteer 模拟浏览器解析 html DOM 结构了</strong>。</p>\n<p data-nodeid="47723">拿到 DOM 结构后，就可以进行分析判断是否存在异常了，后面的逻辑就比较简单，都是一些判断方法了。通过以上方式，我们就可以在配置文件中增加一些接口，从而实现自动化的方式，每次我们在线上发布之前，在测试环境或者预发布环境中跑一遍测试就可以提前发现问题了。接下来我们来演示一下这个功能。</p>\n<h3 data-nodeid="47724">实践测试</h3>\n<p data-nodeid="47725">之前我们的项目中有几个存在 CPU 密集计算的问题，这里我们用这个工具来检测下，看下是否能帮我们定位到问题。我们把配置文件修改为如下内容：</p>\n<pre class="lang-javascript" data-nodeid="47726"><code data-language="javascript"><span class="hljs-keyword">const</span> testMapping = [\n    {\n        <span class="hljs-string">\'urlPath\'</span> : <span class="hljs-string">\'cache/local\'</span>,\n        <span class="hljs-string">\'method\'</span> : <span class="hljs-string">\'get\'</span>,\n        <span class="hljs-string">\'getParams\'</span> : {\n        },\n        <span class="hljs-string">\'postParams\'</span> : {\n        }\n    },\n    {\n      <span class="hljs-string">\'urlPath\'</span> : <span class="hljs-string">\'local-cache/no\'</span>,\n      <span class="hljs-string">\'method\'</span> : <span class="hljs-string">\'get\'</span>,\n      <span class="hljs-string">\'getParams\'</span> : {\n      },\n      <span class="hljs-string">\'postParams\'</span> : {\n      }\n    },\n    {\n      <span class="hljs-string">\'urlPath\'</span> : <span class="hljs-string">\'local-cache/yes\'</span>,\n      <span class="hljs-string">\'method\'</span> : <span class="hljs-string">\'get\'</span>,\n      <span class="hljs-string">\'getParams\'</span> : {\n      },\n      <span class="hljs-string">\'postParams\'</span> : {\n      }\n    }\n];\n</code></pre>\n<p data-nodeid="47727">接下来我们在项目根目录执行下面两个命令：</p>\n<pre class="lang-java" data-nodeid="47728"><code data-language="java">cd bin\nnode clinic_test.js&nbsp;\n</code></pre>\n<p data-nodeid="47729">运行完成后，你将会看到如下结果：</p>\n<pre class="lang-java" data-nodeid="47730"><code data-language="java">启动服务开始测试...\n开始检测 cache/local 的接口性能问题\n该接口无任何异常问题\n开始检测 local-cache/no 的接口性能问题\n该接口存在异常\n具体详情请查看项目根目录下的\n./.clinic/<span class="hljs-number">21097</span>.clinic-doctor.html\n开始检测 local-cache/yes 的接口性能问题\n该接口无任何异常问题\n你需要处理以下问题汇总，具体请查看下面详细信息\n[{<span class="hljs-string">"resultLink"</span>:<span class="hljs-string">"21097.clinic-doctor.html"</span>,<span class="hljs-string">"url"</span>:<span class="hljs-string">"http://127.0.0.1:3000/local-cache/no"</span>,<span class="hljs-string">"command"</span>:<span class="hljs-string">"clinic doctor --on-port \\"wrk http://127.0.0.1:3000/local-cache/no\\" -- node app.js"</span>,<span class="hljs-string">"problem"</span>:<span class="hljs-string">"Detected data analysis issue"</span>}]\n</code></pre>\n<p data-nodeid="47731">从原来的分析来看也是这样的结果，因为我们对 cache/local 和 local-cache/yes 做了缓存优化，所以无任何异常问题，而 local-cache/no 存在性能问题，然后我们打开  .clinic/21097.clinic-doctor.html 这个文件，可以看到如图 7 所示的结果。</p>\n<p data-nodeid="56887" class=""><img src="https://s0.lgstatic.com/i/image6/M00/37/90/Cgp9HWB37e-APupPAAJ0RW3kNww550.png" alt="Drawing 6.png" data-nodeid="56891"></p>\n<div data-nodeid="56888"><p style="text-align:center">图 7  local-cache/no 检测结果</p></div>\n\n\n\n<p data-nodeid="47734">如果遇到了 CPU 占用和事件延迟这类问题就使用 clinic flame 来进一步分析，我们从刚才的运行结果中，取出测试方法，把 doctor 修改为 flame 即可，如下命令所示（请注意要回到项目根目录去运行，不要在当前 bin 目录）。</p>\n<pre class="lang-java" data-nodeid="47735"><code data-language="java">clinic flame --on-port <span class="hljs-string">"wrk http://127.0.0.1:3000/local-cache/no"</span> -- node app.js\n</code></pre>\n<p data-nodeid="47736">成功运行后，打开相应的 html 文件，可以看到如图 8 所示的结果。</p>\n<p data-nodeid="57991" class="te-preview-highlight"><img src="https://s0.lgstatic.com/i/image6/M00/37/90/Cgp9HWB37fiAX8tvAAJ_iWJXzkU653.png" alt="Drawing 7.png" data-nodeid="57995"></p>\n<div data-nodeid="57992"><p style="text-align:center">图 8  clinic flame 运行结果</p></div>\n\n\n\n<p data-nodeid="47739">在图 8 中我们可以非常清晰地看到提示，具体在 localCache.js 中的第 20 行占用的问题，你都不用去详细分析就可以轻松得到结论。</p>\n<p data-nodeid="47740">为了使用方便，我们将此工具集成到了 package 中，只需要运行下面命令就可以了。</p>\n<pre class="lang-java" data-nodeid="47741"><code data-language="java">npm run clinic-test\n</code></pre>\n<p data-nodeid="47742">以上就完成了该工具的自动化方法。</p>\n<h3 data-nodeid="47743">总结</h3>\n<p data-nodeid="47744">你可以想象一下如果没有该工具，我们每次开发完的功能都像是一次冒险，心里很忐忑，但是有了 clinicjs 工具以后，我们再也不需要担心这个事情了，在发布之前就可以预先发现这些问题，我希望如果应用 Node.js 做后台开发时，它都应该作为一个必备的工具。</p>\n<p data-nodeid="47745">我们本讲实现的自动化工具，还可以继续抽离细化，希望你可以根据自己的想法生成一个比较通用的工具，如果有人抽离出来后，请给出 GitHub 地址，让大家可以一起来使用，一起来维护。</p>\n<p data-nodeid="47746">下一讲我们将进入实战模块，基本把当前 Node.js 的相关知识都介绍完了，我们也开始进行一些项目尝试。</p>',
        article_title: "14 | 工具应用：使用 clinicjs 工具实现通用性安全检查",
        title: "14 | 工具应用：使用 clinicjs 工具实现通用性安全检查",
        id: 6796,
      },
    ],
  },
  {
    chapterTitle: "模块三：系统服务研发实战",
    children: [
      {
        content:
          '<p data-nodeid="1421" class="">前面几讲我们学习的性能相关的知识点，都是基于单个接口或者单个服务，从这一讲开始，我们将从系统层面设计高并发的系统，所以掌握单个接口技术性能相关的知识远远不够，你还要拓展更多的知识点，比如服务器内核配置、单机单服务部署和多机多服务部署、多机器负载均衡策略以及如何做并行压测等。</p>\n<p data-nodeid="1422">那么今天，我就先带你回顾一下前面第 1、6、7、8 和 9 讲的设计要点，然后在此基础上，带你学习一些需要进一步实践的相关知识。</p>\n<h3 data-nodeid="1423">知识回顾</h3>\n<p data-nodeid="1424">对于单个服务或者单个接口，我们学习了在 Node.js 中要着重注意的 5 个高性能点。</p>\n<ol data-nodeid="1425">\n<li data-nodeid="1426">\n<p data-nodeid="1427">主线程避阻塞，特别是一些复杂 CPU 密集计算型，最好的方式是交由其他进程处理，减少当前服务进程的阻塞；</p>\n</li>\n<li data-nodeid="1428">\n<p data-nodeid="1429">多进程 cluster 模式的应用，充分利用多核服务器，能够在单台机器启用多个进程进行负载均衡，提升服务的稳定性；</p>\n</li>\n<li data-nodeid="1430">\n<p data-nodeid="1431">在 I/O 方面要注重缓存的应用，本地缓存优先、其次共享内存、最后再是数据库（能用本地缓存的尽量用，不能用本地缓存的考虑共享内存，如果共享内存也不行，那么就需要使用数据库，而数据库可以优先考虑 MongoDB 内存查询效率更高的数据库，最后再考虑 MySQL，如果遇到必须查询或者写 MySQL 时，可以用延迟队列方式）；</p>\n</li>\n<li data-nodeid="1432">\n<p data-nodeid="1433">过载保护策略，提升服务的稳定性，在服务过载时，保住部分用户的请求链路，以免影响所有用户；</p>\n</li>\n<li data-nodeid="1434">\n<p data-nodeid="1435">工具自动化，单接口单服务性能保证，在上线前至少保证代码没有性能异常问题。</p>\n</li>\n</ol>\n<p data-nodeid="1436">以上是我们之前学习的一部分知识，其中会涉及应用细节，比如在缓存方面我们不仅仅要考虑缓存数据，还应该考虑存储过期的问题；又比如过载保护，什么样的过载参数适合我们当前服务，这些都需要你进行实践应用，去沉淀和总结。</p>\n<h3 data-nodeid="1437">高并发知识</h3>\n<p data-nodeid="1438">除了上述知识点，我认为你还需要掌握以下 5 个关键的知识点：</p>\n<ol data-nodeid="1439">\n<li data-nodeid="1440">\n<p data-nodeid="1441">微服务拆分、独立系统、可扩展、可分流；</p>\n</li>\n<li data-nodeid="1442">\n<p data-nodeid="1443">机器内核网络配置；</p>\n</li>\n<li data-nodeid="1444">\n<p data-nodeid="1445">单机单服务和单机多服务；</p>\n</li>\n<li data-nodeid="1446">\n<p data-nodeid="1447">多机器部署负载均衡；</p>\n</li>\n<li data-nodeid="1448">\n<p data-nodeid="1449">并行压测。</p>\n</li>\n</ol>\n<p data-nodeid="1450">接下来我带你学习每个技术点的核心部分。</p>\n<h4 data-nodeid="1451">微服务拆分</h4>\n<p data-nodeid="1452">微服务拆分要分阶段来进行，在项目初期，微服务拆分建议在项目中去进行，其核心是 Controller 、 Model 以及 Service 的代码按项目区分，比如可以按照下面这种方式。</p>\n<p data-nodeid="1453"><img src="https://s0.lgstatic.com/i/image6/M01/39/F2/Cgp9HWB9TpyAJjg1AABwcxUmgzs211.png" alt="Drawing 0.png" data-nodeid="1599"></p>\n<div data-nodeid="1454"><p style="text-align:center">图 1 项目拆分方式</p></div>\n<p data-nodeid="1455">在项目初期，流量并发并不高，该方式比较好维护，但随着项目流量以及功能越来越多，就应该考虑微服务拆分。主要是按照业务功能进行拆分（这里你要注意，基础服务模块在 Node.js 中最好不要拆分为服务，而应该拆分为模块，模块调用的方式肯定比网路性能更高）。</p>\n<p data-nodeid="1456">在业务功能较复杂时，拆分出独立的项目有这样几个好处：</p>\n<ol data-nodeid="1457">\n<li data-nodeid="1458">\n<p data-nodeid="1459">便于扩展和后期维护；</p>\n</li>\n<li data-nodeid="1460">\n<p data-nodeid="1461">能够独立部署，针对流量不同的业务，独立安排部署；</p>\n</li>\n<li data-nodeid="1462">\n<p data-nodeid="1463">功能解藕、服务安全、减少相互影响，避免一个业务承载压力过大，导致所有服务异常；</p>\n</li>\n<li data-nodeid="1464">\n<p data-nodeid="1465">多人协作开发模式清晰，可以按照功能模块进行团队人力划分，这样既清晰又便于团队合作管理；</p>\n</li>\n</ol>\n<p data-nodeid="1466">既然有这些优点，那么我们应该如何去做微服务拆分呢？</p>\n<p data-nodeid="1467">最简单的方式，就是将图 1 中的模块按照文件模块进行拆分，其他保持不变。假设 user 模块流量较大，那么我们就需要单独拆分这个模块到一个项目，其他的部分我们复制一份。</p>\n<p data-nodeid="1468">上面这种方式固然是比较简单的，但是问题来了，我们很多基础模块都复制了一份，以后怎么去维护，项目越多发现维护成本会越来越高，那么有没有更好的方式来处理呢？</p>\n<p data-nodeid="1469">我们需要将通用的部分进行整合，然后不同的部分进行拆分，比如上面的项目结构，可以拆分出这样的结构。</p>\n<p data-nodeid="1470"><img src="https://s0.lgstatic.com/i/image6/M01/39/F2/Cgp9HWB9TqSALKcMAACWOU_LikA525.png" alt="Drawing 1.png" data-nodeid="1612"></p>\n<div data-nodeid="1471"><p style="text-align:center">图 2 拆分方式</p></div>\n<p data-nodeid="1472">图 2 中 common 为我们公共部分，main 为流量较小项目，user 则为一个独立的比较大流量的模块，这样就可以做到单独拆分并且公用。现网发布时，如果发布的是 user 服务，则只发布 common 和 user，如果发布 main 服务，则只发布 common 和 main。这样就可以做到既复用又独立的方式。</p>\n<p data-nodeid="1473">当然微服务拆分也会让开发者的开发模式更为复杂，团队协作沟通成本更高。</p>\n<h4 data-nodeid="1474">机器内核网络配置</h4>\n<p data-nodeid="1475">微服务拆分是基于一种框架的解决方案，能降低耦合提升单个服务的处理能力，但不能实质性的提升整体服务的并发处理能力，而服务器内核的网络配置却在一定程度上可以提升并发处理能力。关于机器内核网络配置，这里会涉及几个比较关键的内核配置（请注意，一般情况下请勿修改内核配置，要修改也请运维比较专业的人员进行配置）。</p>\n<p data-nodeid="1476">我们来看下调优 TCP 相关的一些参数。具体配置在 /etc/sysctl.conf 文件中，或者也可以创建新配置文件，比如 /etc/sysctl.d/99-tuning.conf ，然后运行sysctl -p，让内核装载这个配置。</p>\n<pre class="lang-haskell" data-nodeid="1477"><code data-language="haskell"><span class="hljs-title">net</span>.ipv4.ip_local_port_range=\'<span class="hljs-number">1024</span> <span class="hljs-number">65000</span>\'\n<span class="hljs-title">net</span>.ipv4.tcp_tw_reuse=\'<span class="hljs-number">1</span>\'\n<span class="hljs-title">net</span>.ipv4.tcp_fin_timeout=\'<span class="hljs-number">15</span>\'\n<span class="hljs-title">net</span>.core.netdev_max_backlog=\'<span class="hljs-number">4096</span>\'\n<span class="hljs-title">net</span>.core.rmem_max=\'<span class="hljs-number">16777216</span>\'\n<span class="hljs-title">net</span>.core.somaxconn=\'<span class="hljs-number">4096</span>\'\n<span class="hljs-title">net</span>.core.wmem_max=\'<span class="hljs-number">16777216</span>\'\n<span class="hljs-title">net</span>.ipv4.tcp_max_syn_backlog=\'<span class="hljs-number">20480</span>\'\n<span class="hljs-title">net</span>.ipv4.tcp_max_tw_buckets=\'<span class="hljs-number">400000</span>\'\n<span class="hljs-title">net</span>.ipv4.tcp_no_metrics_save=\'<span class="hljs-number">1</span>\'\n<span class="hljs-title">net</span>.ipv4.tcp_rmem=\'<span class="hljs-number">4096</span> <span class="hljs-number">87380</span> <span class="hljs-number">16777216</span>\'\n<span class="hljs-title">net</span>.ipv4.tcp_syn_retries=\'<span class="hljs-number">2</span>\'\n<span class="hljs-title">net</span>.ipv4.tcp_synack_retries=\'<span class="hljs-number">2</span>\'\n<span class="hljs-title">net</span>.ipv4.tcp_wmem=\'<span class="hljs-number">4096</span> <span class="hljs-number">65536</span> <span class="hljs-number">16777216</span>\'\n<span class="hljs-title">vm</span>.min_free_kbytes=\'<span class="hljs-number">65536</span>\'\n</code></pre>\n<p data-nodeid="1478">这里重点说下几个配置。</p>\n<ul data-nodeid="1479">\n<li data-nodeid="1480">\n<p data-nodeid="1481"><strong data-nodeid="1629">ip_local_port_range：</strong> 如果在请求高并发时，会导致端口不够用，因此需要调整范围，但是你要注意，范围并不是越小越好，如果从 1024 开始，也可能会与系统相关的进程服务端口冲突，从而导致请求失败。</p>\n</li>\n<li data-nodeid="1482">\n<p data-nodeid="1483"><strong data-nodeid="1650">net.ipv4.tcp_tw_reuse：</strong> 当服务器要在大量 TCP 连接之间切换时，会产生大量处于TIME_WAIT 状态的连接。TIME_WAIT意味着连接本身是关闭的，但资源没有释放，将net_ipv4_tcp_tw_reuse 设置为 1 是让内核在安全时尽量回收连接，这比重新建立新连接便宜得多。</p>\n</li>\n<li data-nodeid="1484">\n<p data-nodeid="1485"><strong data-nodeid="1661">net.ipv4.tcp_fin_timeout：</strong> 这是处于 TIME_WAIT状态的连接在回收前必须等待的最小时间，改小它可以加快回收，当然也不是越小越好，如果太小比如设置5，可能会导致 TCP 连接异常。</p>\n</li>\n</ul>\n<p data-nodeid="1486">如果需要对其他的配置进行改动，希望大家在改动前大家先深入去了解 Linux 内核参数的作用，它的改动范围以及所带来的影响面，这部分改动如果出现问题，可能会出现一些难以定位的现网问题。</p>\n<h4 data-nodeid="1487">单机单服务和单机多服务</h4>\n<p data-nodeid="1488">Node.js 服务在部署时，需要分 2 种情况：</p>\n<ul data-nodeid="1489">\n<li data-nodeid="1490">\n<p data-nodeid="1491">单机只部署一个 Node.js 服务；</p>\n</li>\n<li data-nodeid="1492">\n<p data-nodeid="1493">单机上部署多个 Node.js 服务。</p>\n</li>\n</ul>\n<p data-nodeid="1494">我们分别看一下这两者需要注意的细节。</p>\n<p data-nodeid="1495"><strong data-nodeid="1671">单机单服务</strong></p>\n<p data-nodeid="1496">单机单服务适合并发较大、功能底层的服务，比如Node.js 做业务网关时，就适合单机单服务。因为网关并发一般较大，需要非常严谨地了解当前承担的并发和性能。而单机单服务则可以非常精准的了解性能数据，不会被外界因素干扰。</p>\n<p data-nodeid="1497">在应用这种服务时，你要按照机器核数来启用进程数，等于或者小于核数（最好是小于核数），避免在并发较高时，占满 CPU ，从而影响机器性能，系统资源无法调度，那样就非常危险。</p>\n<p data-nodeid="1498"><strong data-nodeid="1677">单机多服务</strong></p>\n<p data-nodeid="1499">单机多服务适合于多个业务服务，但这多个业务并发相对不高，比如应用 Node.js 做一些活动或者通用中台服务时。该情况不利于判断当前服务启用的进程数，需要根据具体的业务判断。</p>\n<p data-nodeid="1500">假设我们在一台 16 核机器上部署 2 个服务，一个并发较高，一个并发较低，但是两者经过分析，并发高的 10 核就可以满足到要求，而并发低的只需要 4 核就足够。这种情况就不会有太大的风险，因为加起来 14 核，也不会影响到性能问题。但两者加起来如果超出 16 核，比如并发低的需要 8 核才能满足业务，就要考虑两者在什么场景下是否存在同时并发的压力，如果存在并发压力就应该考虑将两者分到不同机器上，而不是同一台机器上，或者增加机器来满足当前业务场景。</p>\n<p data-nodeid="1501">如果一台机器上有 4 个服务呢？分析方法还是和上面相似，按照以下几个步骤来评判。</p>\n<ol data-nodeid="1502">\n<li data-nodeid="1503">\n<p data-nodeid="1504">判断 4 个服务加起来是否超出当前 CPU 总核数；</p>\n</li>\n<li data-nodeid="1505">\n<p data-nodeid="1506">不超出不会有影响，超出时则判断多个服务是否会在同时最大并发数，或者最大并发的服务加起来是否会超出当前 CPU 核数；</p>\n</li>\n<li data-nodeid="1507">\n<p data-nodeid="1508">多个服务最大并发不会超出 CPU 核数时，则可以合并部署；</p>\n</li>\n<li data-nodeid="1509">\n<p data-nodeid="1510">多个服务最大并发会超出 CPU 核数时，就需要考虑拆分服务出去，或者增加机器，减少 CPU 核数占用，比如原来是 6 核 2 台机器，现在增加了 2 台机器，可以 3 核 4 台机器，虽然这种方法计算不够准确，但是可以这样参考。</p>\n</li>\n</ol>\n<p data-nodeid="1511">实际开发过程中监控和性能告警是非常重要的，当 CPU 长期处于高负荷时，一定是需要告警的，我们才能知道是否需要进一步扩容或者性能优化提升。</p>\n<h4 data-nodeid="1512">多机器部署负载均衡</h4>\n<p data-nodeid="1513">上面我介绍的是单机注意的细节，接下来我们再来看一下多机器的负载均衡方案。后台服务一般都有个独立 IP:PORT ，如果有域名，一般会选择用 Nginx 作为负载均衡的服务，没有域名的话，多个服务之间调用。多服务之间调用，就需要使用到一个叫作名字服务的功能，该功能主要是使用方可以通过一个字符串名字，随机获取一个可用的 IP:PORT 配置；</p>\n<p data-nodeid="1514"><img src="https://s0.lgstatic.com/i/image6/M01/39/F2/Cgp9HWB9Tx6AUefLAADCvjmrv30935.png" alt="Drawing 2.png" data-nodeid="1690"></p>\n<div data-nodeid="1515"><p style="text-align:center">图 3 负载均衡方法</p></div>\n<p data-nodeid="1516">图 3 就是一个负载均衡的方案，对于域名访问按照刚才所说可以使用 Nginx，而对于服务间调用则使用名字服务。这种方案，可以适配我们现在的绝大不多数后台多服务的负载均衡方案，因此对于 Node.js 来说，我们实际开发中负载均衡也是使用这套方案。</p>\n<h4 data-nodeid="1517">并行压测</h4>\n<p data-nodeid="1518">如果我们服务使用了刚才上面所介绍的多服务负载均衡的方案，那么我们就需要去学习一种新的方案来评估服务承载能力。接下来我们就来学习一下，怎么有效地评估服务承载的情况。</p>\n<p data-nodeid="1519"><strong data-nodeid="1698">1</strong>. 首先应用 clinicjs 压测工具，检测单个接口是否存在性能问题；</p>\n<p data-nodeid="1520"><strong data-nodeid="1703">2</strong>. 计算当前服务所应该承担的最大并发情况，我们用一个渐进性的表格来分析，如表格 1。</p>\n<p data-nodeid="1771" class=""><img src="https://s0.lgstatic.com/i/image6/M00/3A/65/CioPOWB_g7eAJW_sAABOZsdm58g189.png" alt="image.png" data-nodeid="1774"></p>\n\n<div data-nodeid="1543"><p style="text-align:center">表格 1 预测并发压力方式</p></div>\n<p data-nodeid="1544">比如我们当前 DAU 1000 万，最高在线人数 12% ，因此最高的在线人数 120 万，而按照秒来计算的话，我们用当前数除以 60 就是每秒，但是由于不是严格除以 60 ，我们需要乘以 5 来确保安全，最后 10% 的在线用户会使用到该服务，所以该服务最大并发数是 1万 QPS。</p>\n<p data-nodeid="1545">假设我们有 4 台服务器，按照平均分配的话，那么每台机器处理并发数大概是 2500 的 QPS 。</p>\n<p data-nodeid="1546">得到 1 万的结论后，我们再细分接口的并发数，得到一个像表格 2 的结论。</p>\n<p data-nodeid="2381" class="te-preview-highlight"><img src="https://s0.lgstatic.com/i/image6/M00/3A/65/CioPOWB_g8CAIJSsAABEY3NwObM047.png" alt="image (1).png" data-nodeid="2388"></p>\n\n<div data-nodeid="1569"><p style="text-align:center">表格 2 并发结论</p></div>\n<p data-nodeid="1570"><strong data-nodeid="1756">3</strong>. 拿到表格 2 结论后，就可以联合的压测以上 4 个接口了，分别按照 1000 、200 、1000 和 300 的并发去压测；</p>\n<p data-nodeid="1571"><strong data-nodeid="1761">4</strong>. 压测后就可以得出当前服务的情况，接下来就需要进行多台机器联合压测，在现网一般情况下是无法 4 台同时摘除压测的，可以考虑在现网比较空闲的时段，使用 2 台进行压测进一步分析是否满足要求；</p>\n<p data-nodeid="1572"><strong data-nodeid="1766">5</strong>. 如果单台机器涉及多服务，那么则需要将多个服务进行联合压测，才能真实的得到现网的负载承受能力。</p>\n<p data-nodeid="1573">这里就不详细的实践压测细节了，压测这部分还需要你自己多进行学习和深入掌握。</p>\n<h3 data-nodeid="1574">总结</h3>\n<p data-nodeid="1575">总的来说，这一讲也是我之前使用 Node.js 开发沉淀下来的一些经验，你在学习本讲时，着重了解这些知识点即可，在实际应用过程中再来逐个参考，我这里所介绍的也是一个参考项，真正实际应用过程中还需要你和项目组的同事一起讨论。</p>\n<p data-nodeid="1576" class="">这一讲，我提到了并行压测，今天的作业就是：希望你应用 wrk 来实现一个联合压测工具，可行的话可以在评论区分享给后面的同学。下一讲我们将实现一个通用的透传类的 Node.js 服务，也就是一个简单版本的业务网关服务。</p>',
        article_title: "15 | 理论先行：高并发设计必须学的知识点有哪些？",
        title: "15 | 理论先行：高并发设计必须学的知识点有哪些？",
        id: 6797,
      },
      {
        content:
          '<p data-nodeid="159080">在学习了 Node.js 相关的知识以后，我们怎么才能在实际工作中将这些知识应用起来呢？在这之前，我们应该思考，是完全应用 Node.js 改造原来的后台，还是与现有后台技术，进行兼容。</p>\n<p data-nodeid="159081">这一讲，我就带你掌握如何快速地在项目中尝试应用 Node.js ，构建一个介入前后台之间的服务，逐步替换部分线上后台服务。</p>\n<h3 data-nodeid="159082">架构设计</h3>\n<p data-nodeid="159083">以当时的团队情况为例，当时，我们的团队有 30 多人，具备后台服务，但为了尝试 Node.js 的应用，以便可以更高效地进行应用服务，我们需要尝试 Node.js 接入方案，当时有几种选择，比如：</p>\n<ul data-nodeid="159084">\n<li data-nodeid="159085">\n<p data-nodeid="159086">重新将原来后台改造为 Node.js 的方式（不过该方式在项目已经进行很长时间，或者代码结构很大的情况下并不适合）。</p>\n</li>\n<li data-nodeid="159087">\n<p data-nodeid="159088">兼容原来的后台，部分请求转发到 Node.js 服务和后台服务，另外一些请求则可以经过 Node.js 处理后再透传到后台服务。</p>\n</li>\n</ul>\n<h4 data-nodeid="159089">兼容方案设计</h4>\n<p data-nodeid="159090">现实情况下，大部分是第二种方案，在此基础上我们绘制了一个简单的架构图：</p>\n<p data-nodeid="160657" class=""><img src="https://s0.lgstatic.com/i/image6/M00/39/F3/Cgp9HWB9T6WALOD3AAESrBDsph0977.png" alt="Drawing 0.png" data-nodeid="160661"></p>\n<div data-nodeid="160658"><p style="text-align:center">图 1 Node.js 与后台兼容方案</p></div>\n\n\n\n<p data-nodeid="159093">由于我在该课程测试过程中没有非 Node.js 的后台服务，所以我们需要模拟使用 Node.js 来模拟一个后台服务。</p>\n<p data-nodeid="159094">图 1 中，我假设 15 课时的代码为后台服务，15 课时分别有 2 个启动文件：</p>\n<ul data-nodeid="159095">\n<li data-nodeid="159096">\n<p data-nodeid="159097">app.js 会以 3002 端口启动 Node.js 服务；</p>\n</li>\n<li data-nodeid="159098">\n<p data-nodeid="159099">app-3003.js 会以 3003 端口启动 Node.js 服务。</p>\n</li>\n</ul>\n<p data-nodeid="159100">接着，我们假设 16 课时的代码为 Node.js 服务，16 课时同样有 2 个启动文件：</p>\n<ul data-nodeid="159101">\n<li data-nodeid="159102">\n<p data-nodeid="159103">app.js 会以 3000 端口启动 Node.js 服务；</p>\n</li>\n<li data-nodeid="159104">\n<p data-nodeid="159105">app-3001.js 会以 3001 端口启动 Node.js 服务。</p>\n</li>\n</ul>\n<p data-nodeid="159106">假设我们服务的域名是 lagou-nodejs.com ，从该域名的请求会经过 Nginx 作为负载均衡的处理模块，然后根据请求路径进行转发。</p>\n<p data-nodeid="159107">/music/info/index 为一个透传服务，因为该路径请求时会经过 Node.js 服务，经过部分处理后，再透传给后台服务；/test/index 为一个 Node.js 服务，该路径请求时会直接在 Node.js 服务中处理完成。其他的路径都是请求到后台服务中，也就是 3002 端口和 3003 端口。</p>\n<p data-nodeid="159108">接下来我就带你看一看怎么搭建图 15 所示的前后台服务。</p>\n<h3 data-nodeid="159109">实现方案</h3>\n<p data-nodeid="159110">实现该系统需要做这样几个工作：</p>\n<ol data-nodeid="159111">\n<li data-nodeid="159112">\n<p data-nodeid="159113">Nginx 搭建，并配置路由转发；</p>\n</li>\n<li data-nodeid="159114">\n<p data-nodeid="159115">16 课时实现接口透传方式，将未能处理的接口转发到后台服务；</p>\n</li>\n<li data-nodeid="159116">\n<p data-nodeid="159117">转发时需要根据名字服务，随机地将请求转发到后台的多个服务中，进行负载均衡；</p>\n</li>\n<li data-nodeid="159118">\n<p data-nodeid="159119">Node.js 16 课时实现 /test/index 方法；</p>\n</li>\n<li data-nodeid="159120">\n<p data-nodeid="159121">Node.js 16 课时多端口启动服务，并设置 2 个子进程；</p>\n</li>\n<li data-nodeid="159122">\n<p data-nodeid="159123">Node.js 15 课时（后台服务），实现 /music/info/index 和 /activity/info/index 两个方法；</p>\n</li>\n<li data-nodeid="159124">\n<p data-nodeid="159125">Node.js 15 课时口启动服务，分别启动 1 个子进程；</p>\n</li>\n<li data-nodeid="159126">\n<p data-nodeid="159127">配置本地 host 并测试；</p>\n</li>\n</ol>\n<p data-nodeid="159128">接下来我们将上面的 8 个步骤融合为 5 个过程来实践讲解，分别是： Nginx 搭建和配置、透传转发和名字服务、实现 Node.js 服务、实现后台服务和配置本地 host 测试。</p>\n<h4 data-nodeid="159129">Nginx 搭建和配置</h4>\n<p data-nodeid="159130">作为后台开发，搭建和掌握 Nginx 配置非常基础，安装和配置方法你完全可以去参考<a href="https://www.nginx.cn/doc/?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="159227">官网中文文档</a>教学。这里我已经配置好了 Nginx ，重点强调一下其中的配置方法：在 Nginx 安装目录下会有一个 nginx.conf 配置文件，在最下面一行一般都会有一个下面的配置，如果没有则在 http 中最后一行，增加下面这段代码：</p>\n<pre class="lang-java" data-nodeid="159131"><code data-language="java">include servers<span class="hljs-comment">/*;\n</span></code></pre>\n<p data-nodeid="159132">接下来，在 Nginx 根目录创建 servers 文件夹，并在 servers 中创建 lagou-nodejs.conf 配置文件（文件在<a href="https://github.com/love-flutter/nodejs-column?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="159232">GitHub</a>中项目根目录下的 src/config 文件夹中），首先配置两个 upstream 用来随机转发，其中 lagou-nodejs 为 Node.js 服务，lagou-backend 为后台服务。</p>\n<pre class="lang-java" data-nodeid="159133"><code data-language="java">upstream lagou-nodejs {\n        server <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">3000</span>;\n        server <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">3001</span>;\n}\nupstream lagou-backend {\n    server <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">3002</span>;\n    server <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">3003</span>;\n}\n</code></pre>\n<p data-nodeid="161992">接下来就是在 Nginx 中配置不同路径的转发规则，我们先看下 /test/index 和 /music/info/index 的配置：</p>\n<p data-nodeid="161993" class=""><img src="https://s0.lgstatic.com/i/image6/M00/39/F3/Cgp9HWB9T7aAdPm4AAGL6gtb52U583.png" alt="Drawing 1.png" data-nodeid="161998"></p>\n<div data-nodeid="161994"><p style="text-align:center">图 2 lagou-nodejs Nginx 配置</p></div>\n\n\n\n\n\n<p data-nodeid="159136">图 2 中 /test/index 转发到<a href="http://lagou-nodejs?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="159243">http://lagou-nodejs</a>虚拟 host 下（以 music 开头的也是一样的配置），而其他的都是转发到<a href="http://lagou-backend?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="159247">http://lagou-backend</a>下。注意所有 Nginx 配置修改，都需要使用 nginx -s reload 进行重启。</p>\n<p data-nodeid="159137">这样一来，我们就完成了 Nginx 的配置，第二步就是透传转发和名字服务。</p>\n<h4 data-nodeid="159138">透传转发和名字服务</h4>\n<p data-nodeid="159139">透传转发和名字服务要结合使用，所以我们把二者放在一起来学习。</p>\n<p data-nodeid="159140">首先你肯定要知道在 Node.js 服务中是否有相应的路径处理服务，所以要修改 router.js 中的代码，在匹配到具体的 Controller 逻辑时，在 ctx 中标记已匹配服务，而如果没有匹配到相应的 Controller 时则不做任何标记，如图 3 中红色框部分逻辑：</p>\n<p data-nodeid="162886" class=""><img src="https://s0.lgstatic.com/i/image6/M00/39/FB/CioPOWB9T8CARhfuAAJXX2CAbd0870.png" alt="Drawing 2.png" data-nodeid="162890"></p>\n<div data-nodeid="162887"><p style="text-align:center">图 3 router.js 标记匹配到服务</p></div>\n\n\n\n<p data-nodeid="159143">接下来我们在 routerMiddleware 中间件下增加一个新的中间件 backendRouter，用来处理转发到后台服务的功能：</p>\n<pre class="lang-javascript" data-nodeid="159144"><code data-language="javascript"><span class="hljs-keyword">const</span> proxy = <span class="hljs-built_in">require</span>(<span class="hljs-string">\'koa-better-http-proxy\'</span>);\n<span class="hljs-keyword">const</span> nameService = <span class="hljs-built_in">require</span>(<span class="hljs-string">\'../lib/nameService\'</span>);\n<span class="hljs-built_in">module</span>.exports = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{\n    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"> ctx, next </span>) </span>{\n        <span class="hljs-keyword">if</span>(ctx.currentExist){\n            <span class="hljs-keyword">return</span>;\n        }\n        <span class="hljs-comment">/// 转发相应的数据到指定服务，并且记录下系统日志</span>\n        <span class="hljs-keyword">const</span> newService = nameService.get(<span class="hljs-string">\'poxyBackendServer\'</span>);\n        ctx.log.add(<span class="hljs-string">\'info\'</span>, <span class="hljs-string">\'system\'</span>, <span class="hljs-string">`current server do not find the <span class="hljs-subst">${ctx.pathname}</span> path, forward the request to <span class="hljs-subst">${newService}</span>`</span>);\n        \n        <span class="hljs-keyword">return</span> proxy(newService)(ctx, next);\n    }\n}\n</code></pre>\n<p data-nodeid="159145">代码中应用了 2 个比较重要的模块：</p>\n<ul data-nodeid="159146">\n<li data-nodeid="159147">\n<p data-nodeid="159148"><a href="https://github.com/nsimmons/koa-better-http-proxy#readme?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="159261">koa-better-http-proxy</a>，它是一个第三方 koa 的 http-proxy 服务；</p>\n</li>\n<li data-nodeid="159149">\n<p data-nodeid="159150">我们内部实现的 nameService ，用来做负载均衡转发后台服务。来看第 6 行代码，首先我们要判断路由是否在 Node.js 业务中处理，如果已经处理则直接跳出，如果没有处理，则需要获取到一个待转发的后台服务地址，通过 proxy 将当前请求转发到相应的后台服务中。</p>\n</li>\n</ul>\n<p data-nodeid="159151">nameService 相关的代码如下：</p>\n<pre class="lang-javascript" data-nodeid="159152"><code data-language="javascript"><span class="hljs-keyword">const</span> serviceMapping = {\n    <span class="hljs-string">\'poxyBackendServer\'</span> : [\n        <span class="hljs-string">\'127.0.0.1:3002\'</span>,\n        <span class="hljs-string">\'127.0.0.1:3003\'</span>,\n    ]\n};\n<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NameService</span> </span>{\n    <span class="hljs-keyword">static</span> get(name) {\n        <span class="hljs-keyword">if</span>(!serviceMapping[name] || serviceMapping[name].length &lt; <span class="hljs-number">1</span>){\n            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;\n        }\n        <span class="hljs-keyword">const</span> serviceList = serviceMapping[name];\n        <span class="hljs-keyword">return</span> serviceList[<span class="hljs-built_in">Math</span>.floor(<span class="hljs-built_in">Math</span>.random()*serviceList.length)];\n    }\n}\n<span class="hljs-built_in">module</span>.exports = NameService;\n</code></pre>\n<p data-nodeid="159153">这里是一个简版的路径，在实际开发中你可以单独实现一个本地服务来做名字服务，如果没有这类服务也可以参考这种方法来实现。</p>\n<h4 data-nodeid="163333">实现 Node.js 服务</h4>\n\n\n<p data-nodeid="159156">上面我们已经为 Node.js 服务做了一些基础工作，接下来我们就来实现这个 Node.js 相关的业务功能。在 Controller 中增加一个 test.js 类，并在类中增加 index 方法，这部分比较简单，和原来的 Controller 相比也没太大区别。为了让大家了解如何在单个服务中启用多个端口，我主要说一下怎么在一个项目中启动多个端口服务。</p>\n<p data-nodeid="159157">复制一个 app.js 为 app-3001.js 文件，然后将其中的 3000 端口修改为 3001 （包括里面的 console.log 中的 3000，避免误解），其次修改 pm2.config.js 在配置文件中的 apps 数组中增加一项启动配置，两个数组元素的配置差异就是启动文件和进程名，改动如下图 4 所示：</p>\n<p data-nodeid="164214" class=""><img src="https://s0.lgstatic.com/i/image6/M00/39/F3/Cgp9HWB9T8yAUpkWAAHVHZ00FDk139.png" alt="Drawing 3.png" data-nodeid="164218"></p>\n<div data-nodeid="164215"><p style="text-align:center">图 4 pm2.config.js 文件配置</p></div>\n\n\n\n<p data-nodeid="159160">以上修改完成后，我们使用下面的命令来启动服务：</p>\n<pre class="lang-java" data-nodeid="159161"><code data-language="java">pm2 start pm2.config.js\n</code></pre>\n<p data-nodeid="159162">启动以后，可以看到有 4 个进程，分别对应 3000 和 3001 端口的服务，这时候我们访问如下地址：</p>\n<pre class="lang-java" data-nodeid="159163"><code data-language="java">http:<span class="hljs-comment">//127.0.0.1:3000/test/index</span>\nhttp:<span class="hljs-comment">//127.0.0.1:3001/test/index</span>\nhttp:<span class="hljs-comment">//127.0.0.1:3000/music/info/index</span>\nhttp:<span class="hljs-comment">//127.0.0.1:3001/activity/info/index</span>\n</code></pre>\n<p data-nodeid="159164">你可以看到，前 2 个都是正常响应的，但是后面 2 个都会提示服务器内部错误的信息，主要是我们透传给 3002 和 3003 了，但是无响应，接下来我们就需要去实现 15 课时的 3002 和 3003 的响应处理。</p>\n<h4 data-nodeid="159165">实现后台服务</h4>\n<p data-nodeid="159166">15 课时的 3002 和 3003 服务与 16 课时的核心业务逻辑实现逻辑相似，先复制 app.js 为 app-3003.js ，然后修改 pm2.config.js 文件增加一项，主要是修改其中的 name 和 script ，修改完成后，在 15 课时的根目录，使用下面命令启动服务：</p>\n<pre class="lang-java" data-nodeid="159167"><code data-language="java">pm2 start pm2.config.js\n</code></pre>\n<p data-nodeid="159168">启动成功后，我们使用下面命令查看当前所有进程：</p>\n<pre class="lang-java" data-nodeid="159169"><code data-language="java">pm2 list\n</code></pre>\n<p data-nodeid="165546">可以看到图 5 所示。</p>\n<p data-nodeid="165547"><img src="https://s0.lgstatic.com/i/image6/M00/39/FB/CioPOWB9T9WAPFx3AAFhIzbGogw453.png" alt="Drawing 4.png" data-nodeid="165551"></p>\n\n<div data-nodeid="165104" class=""><p style="text-align:center">图 5 当前 PM2 进程列表</p></div>\n\n\n\n<p data-nodeid="159172">接下来我们再次访问下面 4 个连接：</p>\n<pre class="lang-java" data-nodeid="159173"><code data-language="java">http:<span class="hljs-comment">//127.0.0.1:3000/test/index</span>\nhttp:<span class="hljs-comment">//127.0.0.1:3001/test/index</span>\nhttp:<span class="hljs-comment">//127.0.0.1:3000/music/info/index</span>\nhttp:<span class="hljs-comment">//127.0.0.1:3001/activity/info/index</span>\n</code></pre>\n<p data-nodeid="159174">你会发现都可以正常响应了，并且在 16 课时的根目录 log/system.log 文件中，可以看到如下的日志信息：</p>\n<pre class="lang-prolog" data-nodeid="159175"><code data-language="prolog"><span class="hljs-number">2021</span><span class="hljs-number">-04</span><span class="hljs-number">-05</span> <span class="hljs-number">10</span>:<span class="hljs-number">46</span>:<span class="hljs-number">01</span> info    current server do not find the /activity/info/index path, forward the request to <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">3002</span>\n<span class="hljs-number">2021</span><span class="hljs-number">-04</span><span class="hljs-number">-05</span> <span class="hljs-number">10</span>:<span class="hljs-number">46</span>:<span class="hljs-number">04</span> info    current server do not find the /activity/info/index path, forward the request to <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">3002</span>\n<span class="hljs-number">2021</span><span class="hljs-number">-04</span><span class="hljs-number">-05</span> <span class="hljs-number">10</span>:<span class="hljs-number">46</span>:<span class="hljs-number">58</span> info    current server do not find the /activity/info/index path, forward the request to <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">3002</span>\n<span class="hljs-number">2021</span><span class="hljs-number">-04</span><span class="hljs-number">-05</span> <span class="hljs-number">10</span>:<span class="hljs-number">47</span>:<span class="hljs-number">18</span> info    current server do not find the /music/info/index path, forward the request to <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">3002</span>\n<span class="hljs-number">2021</span><span class="hljs-number">-04</span><span class="hljs-number">-05</span> <span class="hljs-number">10</span>:<span class="hljs-number">47</span>:<span class="hljs-number">54</span> info    current server do not find the /music/info/index path, forward the request to <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">3003</span>\n</code></pre>\n<p data-nodeid="159176">这样一来，就实现了透传请求，接下来我们使用域名来访问。</p>\n<h4 data-nodeid="165988">配置 host 测试</h4>\n\n\n<p data-nodeid="159179">因为我们做的是一个测试虚拟域名，所以在本地配置一个 host ，如果你是在 Mac 或者 Linux 可以直接修改 /etc/hosts 文件，增加下面一行：</p>\n<pre class="lang-java" data-nodeid="159180"><code data-language="java"><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span> lagou-nodejs.com\n</code></pre>\n<p data-nodeid="159181">如果你是在 Windows 下则需要去 C:\\Windows\\System32\\drivers\\etc 这个路径下修改 host 文件。修改以后，我们再将上面的 IP 访问方式修改为域名访问方式：</p>\n<pre class="lang-java" data-nodeid="159182"><code data-language="java">http:<span class="hljs-comment">//lagou-nodejs.com/test/index</span>\nhttp:<span class="hljs-comment">//lagou-nodejs.com/music/info/index</span>\nhttp:<span class="hljs-comment">//lagou-nodejs.com/activity/info/index</span>\n</code></pre>\n<p data-nodeid="166424">再次访问以上地址时，还是正常响应，只是唯一的区别在于 /activity/info/index 不会再经过 Node.js 服务，而 /music/info/index 则还是会在 log/system.log 中打印转发信息。</p>\n<p data-nodeid="166425">以上就完成了一个比较通用的介于前后台的 Node.js 服务，这样可以前期进行一些尝试，慢慢地接入后台的服务。同时也满足我们后台的基本高性能特性，比如负载均衡和多机器快速扩容方案。</p>\n\n<h3 data-nodeid="159184">总结</h3>\n<p data-nodeid="159185">这一讲，我主要带你实践学习了实现一套引入 Node.js 兼容后台的方案，在尝试应用 Node.js 作为后台服务的过程中肯定会存在一些细节问题，比如业务了解不清晰导致的业务问题，或者由于原来服务并发较大，没有充分考虑并发问题，也可能导致现网事故。因此希望你可以在后台服务中拆分出部分非核心模块，依照我们本讲的实践知识进行接入，比较成熟后可以考虑透传的方式，最后再慢慢将所有服务接入，特殊部分则转发到后台服务即可。</p>\n<p data-nodeid="159186">除此之外，学完这一讲内容之后，希望你可以在自己项目中进行一些简单尝试，比如一些新的后台服务类的需求，可以主动的要求，使用 Node.js 来实现一个技术方案，并做一些 demo 演示给你们团队，在应用 Node.js 来实现技术方案时，多从高效开发、可扩展性、后期维护性以及高性能方面来体现其优势。</p>\n<p data-nodeid="159187">接下来，我们将实现一个通用抢票系统，下一讲见。</p>',
        article_title: "16 | RESTful 应用实践：构建一个介于前后台之间的服务",
        title: "16 | RESTful 应用实践：构建一个介于前后台之间的服务",
        id: 6798,
      },
      {
        content:
          '<p data-nodeid="113072" class="">互联网公司经常举办福利活动，比如“ 9.9 元电影票活动”，并以回帖的方式进行（前 500 名回复者获得奖励）。为了参加活动，你需要报名然后快速回帖，如果几万个人同时回帖，并发肯定极大，很可能导致回帖直接卡住，这时候先报名的同学根本无法回帖，只能不断进行重试，那有没有更公平有效的方式保证先来先得呢？</p>\n<p data-nodeid="113073">Node.js 适合做这种通用的高并发服务，正好可以解决这类并发抢票的问题，所以接下来我就用两讲的时间和你一起实现一个通用的抢票系统，这样一来，你可以自己配置票种，然后导入系统中，在自己公司内部和同事一起来玩这个抢票游戏了。</p>\n<p data-nodeid="113074">一般来讲，一个后台系统的设计首先需要了解产品的需求（核心就是该服务应该解决什么问题），从问题出发，分析系统的一些核心特点，在此基础上去设计系统架构、数据库、接口、开发代码以及联调，提测上线。今天这一讲，我们也按照这个流程来学习。</p>\n<h3 data-nodeid="113075">系统的核心特点</h3>\n<p data-nodeid="113076">根据抢票的例子，我们可以提炼出这个系统的核心特点：</p>\n<ol data-nodeid="113077">\n<li data-nodeid="113078">\n<p data-nodeid="113079">抢票活动可配制化；</p>\n</li>\n<li data-nodeid="113080">\n<p data-nodeid="113081">抢票并发较大；</p>\n</li>\n<li data-nodeid="113082">\n<p data-nodeid="113083">物品有限，一定不能超出；</p>\n</li>\n<li data-nodeid="113084">\n<p data-nodeid="113085">安全性重要，避免一些非法获利；</p>\n</li>\n<li data-nodeid="113086">\n<p data-nodeid="113087">抢票结果可导出分析。</p>\n</li>\n</ol>\n<p data-nodeid="113088">分析这 5 个特点，我们先设计出整体的架构，看一下需要哪些技术来支撑这个系统。</p>\n<h3 data-nodeid="113089">架构说明</h3>\n<p data-nodeid="113090"><img src="https://s0.lgstatic.com/i/image6/M01/3B/EF/Cgp9HWCHs9uASQd_AAEmJyLM3ZA530.png" alt="Drawing 0.png" data-nodeid="113368"></p>\n<div data-nodeid="113091"><p style="text-align:center">通用抢票系统架构</p></div>\n<p data-nodeid="113092">从图中我们可以看到，需要以下 5 点技术来支撑上述系统：</p>\n<ol data-nodeid="113093">\n<li data-nodeid="113094">\n<p data-nodeid="113095">Nginx 作为负载均衡，其次作为域名的一个接入点；</p>\n</li>\n<li data-nodeid="113096">\n<p data-nodeid="113097">Node.js 核心服务，这里我会把课程中涉及的各种功能应用上，比如 PM2、压测、监控、日志、安全以及过载保护机制；</p>\n</li>\n<li data-nodeid="113098">\n<p data-nodeid="113099">考虑到高性能，在 Node.js 核心服务中，部分信息还会直接缓存在本地，减少与 Redis 交互次数；</p>\n</li>\n<li data-nodeid="113100">\n<p data-nodeid="113101">Node.js 核心服务交互都只会和 Redis 进行，包括获取活动、票信息以及抢票等，Redis 的数据来源主要是配置文件、异步更新等，由于涉及抢票，所以要用到 Redis 一些原子操作来进行处理（下一讲代码实现中会详细说明）；</p>\n</li>\n<li data-nodeid="113102">\n<p data-nodeid="113103">MongoDB 会作为部分数据的落地处理，只是简单的异步方式，不影响核心主线程，比如存储某个人的抢票结果；</p>\n</li>\n</ol>\n<p data-nodeid="113104">考虑到高性能，我们不会在任何一个接口中，去等待 MongoDB 操作结束后再响应用户请求（08 讲中我提到要用高性能的网络 I/O 替换低性能网络 I/O），在本系统的接口实现中都是与高性能 I/O Redis 缓存服务来交互。</p>\n<p data-nodeid="113105">当整体架构设计完成后，因为后台服务的核心是数据交互，所以你要继续要思考数据库结构的设计方案，接下来我们就来看一下 MongoDB 需要存储哪些信息、Redis 需要存储哪些信息。</p>\n<h3 data-nodeid="113106">数据库设计</h3>\n<p data-nodeid="113107">根据抢票系统的架构设计图，我们需要用到3 种数据存储的服务：本地服务器缓存；Redis 缓存；MongoDB 存储。咱们先分析一下底层的 MongoDB。</p>\n<h4 data-nodeid="113108">MongoDB 存储</h4>\n<p data-nodeid="115498">上述场景需求中，涉及了用户、活动、票以及抢票结果，与这些场景属性对应的是：用户表、活动表、票表、票的券码表和用户票列表（也就是抢票结果） 5 个表，我们先来看下用户表。</p>\n<p data-nodeid="115499" class=""><img src="https://s0.lgstatic.com/i/image6/M01/3B/F6/Cgp9HWCHxM2AVJF9AAEESFYZzXQ742.png" alt="2021427-16051.png" data-nodeid="115504"></p>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n<p data-nodeid="113267" class="">以上就是 MongoDB 中要保存的原始数据（无论是接口响应数据还是各种缓存存储数据，都是来自原始数据表）。接下来你需要将一部分原始数据落入本地缓存和 Redis 缓存中，特别是一些高频访问的数据，使用高性能的网络 I/O 替换低性能的网络 I/O 。</p>\n<p data-nodeid="113268">那什么数据需要缓存到 Redis 中，什么数据需要本地服务器缓存呢？我们一个一个分析。</p>\n<h4 data-nodeid="113269">Redis 存储</h4>\n<p data-nodeid="113270">因为要拉取进行中的<strong data-nodeid="113552">活动列表</strong>，所以你要把活动列表缓存到 Redis 中，防止数据量过多。比如只缓存前 100 个进行中的活动（100 是个例子，你需要了解自己系统中用户的习惯，一般情况下前 100 个就可以囊括了 99% 的用户了）在这里你可以按照分页来缓存，比如 20 个一页，那么可以用 activity_list_page_1 、activity_list_page_2 ... activity_list_page_5 这种键名来保存。对于我们这个系统的场景超出 5 页的数据，由于访问极少，我们可以直接读取数据库。</p>\n<p data-nodeid="113271"><strong data-nodeid="113569">而活动详情是访问最大量的请求，</strong> 所以你要把在线的活动列表的详情缓存在 Redis 中（可以使用 activity_info_id_001 、 activity_info_id_002 这样的键名）。</p>\n<p data-nodeid="113272"><strong data-nodeid="113578">票详情基本都是一致的，</strong> 但是它的访问频次也较高，所以可以把票详情存储在 Redis 中，以 ticket_id_001 的方式保存。</p>\n<p data-nodeid="113273"><strong data-nodeid="113589">针对券码列表，</strong> 因为票券码需要存储在一个 Redis 队列中，所以你要设计一个 activity_ticket_codes_001 以活动 id 为标识。</p>\n<p data-nodeid="113274"><strong data-nodeid="113594">针对获取票结果，</strong> 因为用户参与活动后会获得券码，或者没有获得券码，但是要标记用户是否参与了本次活动的结果，由于这种访问频次非常高，因此需要将该数据保存在缓存中。</p>\n<p data-nodeid="113275">最后，<strong data-nodeid="113600">个人的票列表</strong>一般访问并发较少，其次缓存意义也不大，因为每个人的票列表不一样。</p>\n<h4 data-nodeid="113276">本地服务器缓存</h4>\n<p data-nodeid="113277">根据 09 讲涉及的知识，我们只能缓存基本不变化以及数据量较少的数据。而 Redis 中的数据，<strong data-nodeid="113607">活动详情、票详情基本不变，</strong> 可以缓存在本地服务器上；但是活动列表因为有时间概念，最好不要直接缓存在本地服务，避免更新不及时，多个服务器返回的列表不一致的情况。</p>\n<p data-nodeid="113278">明确数据库以及缓存数据的设计后，接下来就要了解数据的流转以及变化，而数据的流转变化都在接口中进行处理，所以要继续分析 Node.js 核心服务中包含的接口，以及每个接口的时序图。</p>\n<h3 data-nodeid="113279">接口设计</h3>\n<p data-nodeid="113280">我们先来看一下抢票活动的应用场景：用户先进入活动列表页面，选择相应的活动，进入活动详情，然后点击抢票，最终在抢票列表结果页面查看票证的详情。</p>\n<p data-nodeid="113281">根据该抢票场景，涉及的接口有 5 个。</p>\n<ol data-nodeid="113282">\n<li data-nodeid="113283">\n<p data-nodeid="113284">活动列表：显示当前可以参与的抢票活动列表；</p>\n</li>\n<li data-nodeid="113285">\n<p data-nodeid="113286">活动详情：获取抢票活动信息，根据用户是否登录，获取用户是否已经参与过活动；</p>\n</li>\n<li data-nodeid="113287">\n<p data-nodeid="113288">抢票接口：携带活动 ID ，需要判断用户是否有登录权限，活动是否已经结束，用户是否已经参与过；</p>\n</li>\n<li data-nodeid="113289">\n<p data-nodeid="113290">票列表：需要显示用户抢到的票列表；</p>\n</li>\n<li data-nodeid="113291">\n<p data-nodeid="113292">票详情：显示具体的票证详情，为后续提供一些认证信息。</p>\n</li>\n</ol>\n<p data-nodeid="113293">根据以上接口，我们来分析其所对应的时序图。</p>\n<h4 data-nodeid="113294">活动列表</h4>\n<p data-nodeid="113295">我们先来设计一下活动列表的接口参数以及返回结构：由于是活动列表，所以需要携带翻页数据（这里我们简单用 pageSize 来翻页，默认每页 20 条数据）。</p>\n<div data-nodeid="113296"><p style="text-align:center">表格 6 活动列表接口参数</p></div>\n<p data-nodeid="113297"><img src="https://s0.lgstatic.com/i/image6/M01/3B/F7/CioPOWCHtCOAQdDiAABbA8HTaXk689.png" alt="Drawing 1.png" data-nodeid="113622"></p>\n<p data-nodeid="113298">接下来，我们看下返回的数据：</p>\n<pre class="lang-json" data-nodeid="113299"><code data-language="json">{\n  <span class="hljs-attr">"ret"</span>:<span class="hljs-number">0</span>,\n  <span class="hljs-attr">"message"</span>:<span class="hljs-string">"success"</span>,\n  <span class="hljs-attr">"data"</span>:{\n    <span class="hljs-attr">"pageNum"</span> : <span class="hljs-number">1</span>,\n    <span class="hljs-attr">"hasMore"</span>: <span class="hljs-literal">true</span>,\n    <span class="hljs-attr">"pageSize"</span>: <span class="hljs-number">20</span>,\n    <span class="hljs-attr">"lastId"</span>: <span class="hljs-string">"0022"</span>,\n    <span class="hljs-attr">"list"</span>: [\n      {\n        <span class="hljs-attr">"id"</span>:<span class="hljs-string">"111"</span>,\n        <span class="hljs-attr">"name"</span>:<span class="hljs-string">"抢洗头券"</span>,\n        <span class="hljs-attr">"desc"</span>:<span class="hljs-string">"周六日前往，可免费体验"</span>,\n        <span class="hljs-attr">"image"</span>:<span class="hljs-string">"xxxx"</span>,\n        <span class="hljs-attr">"start_time"</span>:<span class="hljs-number">1422222333</span>,\n        <span class="hljs-attr">"end_time"</span>:<span class="hljs-number">1444444444</span>\n      }\n    ]\n  }\n}\n</code></pre>\n<p data-nodeid="113300">在上面数据结构中，最外层是我们框架的基本结构，而在 data 中第一层是翻页配置，list 中则是具体的活动数据结构。而整个接口的时序图就如图 2 所示：</p>\n<p data-nodeid="113301"><img src="https://s0.lgstatic.com/i/image6/M01/3B/EF/Cgp9HWCHtDmADmj3AAB9ykWJBzM920.png" alt="Drawing 2.png" data-nodeid="113627"></p>\n<div data-nodeid="113302"><p style="text-align:center">图 2 活动列表时序图</p></div>\n<p data-nodeid="113303">图 2 中的 Activity-C 是活动 Controller 类，S 则为 Service，M 则是 Model ，Redis 是我们的 Cache 类。</p>\n<p data-nodeid="113304">首先，接口请求到 Controller 中，然后去 Service 中拉取在线的活动列表，这时候需要通过 Redis 数据层来获取缓存数据，如果成功获取直接返回，如果获取失败则需要从 Model 层去重新获取，获取成功则再次缓存到数据层中，最后再返回到接口调用方。</p>\n<p data-nodeid="113305">在图 2 中，我们发现活动列表的大部分逻辑都经过 Service 层来处理，这其中的主要原因在于：我们希望将业务逻辑处理部分都转移到 Service 来处理，而在 Model 层保存比较单一的数据获取的逻辑。</p>\n<p data-nodeid="113306">其他的票列表、票详情和活动详情比较相似，我们看一下这三者的接口参数设置和返回接口就可以了，没必要每个都进行时序图设计。</p>\n<h4 data-nodeid="113307">活动详情</h4>\n<p data-nodeid="113308">首先还是来设计接口参数和返回结构，如表格 7。</p>\n<div data-nodeid="113309"><p style="text-align:center">表格 7 活动详情接口参数</p></div>\n<p data-nodeid="113310"><img src="https://s0.lgstatic.com/i/image6/M01/3B/F7/CioPOWCHtFCAUZ2yAAA5HVIwidg206.png" alt="Drawing 3.png" data-nodeid="113636"></p>\n<p data-nodeid="113311">返回的数据结构也比较简单，只需要返回一条活动详情数据即可：</p>\n<pre class="lang-json" data-nodeid="113312"><code data-language="json">{\n  <span class="hljs-attr">"ret"</span>:<span class="hljs-number">0</span>,\n  <span class="hljs-attr">"message"</span>:<span class="hljs-string">"success"</span>,\n  <span class="hljs-attr">"data"</span>:{\n    <span class="hljs-attr">"id"</span>:<span class="hljs-string">"111"</span>,\n    <span class="hljs-attr">"name"</span>:<span class="hljs-string">"抢洗头券"</span>,\n    <span class="hljs-attr">"desc"</span>:<span class="hljs-string">"周六日前往，可免费体验"</span>,\n    <span class="hljs-attr">"image"</span>:<span class="hljs-string">"xxxx"</span>,\n    <span class="hljs-attr">"start_time"</span>:<span class="hljs-number">1422222333</span>,\n    <span class="hljs-attr">"end_time"</span>:<span class="hljs-number">1444444444</span>\n  }\n}\n</code></pre>\n<h4 data-nodeid="113313">票列表</h4>\n<p data-nodeid="113314">接口参数和返回结构，如表格 8。</p>\n<div data-nodeid="113315"><p style="text-align:center">表格 8 票列表接口参数</p></div>\n<p data-nodeid="113316"><img src="https://s0.lgstatic.com/i/image6/M00/3B/F7/CioPOWCHtGCAUraVAABWk6QkP0g384.png" alt="Drawing 4.png" data-nodeid="113642"></p>\n<p data-nodeid="113317">返回的数据结构是一个列表的通用结构，包括 pageNum 是当前页数，hasMore 代表的是是否存在下一页，pageSize 代表的是一页所包含的票数量，lastId 是本页的最后一条数据的 ID ，主要用于辅助翻页，list 则是当前的票列表数据。</p>\n<pre data-nodeid="113318"><code>{\n  "ret":0,\n  "message":"success",\n  "data":{\n    "pageNum" : 1,\n    "hasMore": true,\n    "pageSize": 20,\n    "lastId": "0022",\n    "list": [\n        "id":"111",\n        "name":"洗头券",\n        "desc":"周六日前往，可免费体验",\n        "code":"xxxx11",\n        "act_id":"1110",\n        "is_effective": true,\n        "start_time":1422222333,\n        "end_time":1444444444\n    ]\n}\n</code></pre>\n<h4 data-nodeid="113319">票详情</h4>\n<p data-nodeid="113320">接口参数和返回结构，如表格 9。</p>\n<div data-nodeid="113321"><p style="text-align:center">表格 9 活动详情接口参数</p></div>\n<p data-nodeid="113322"><img src="https://s0.lgstatic.com/i/image6/M00/3B/F7/CioPOWCHtGyAJsHYAAA01aveJSg751.png" alt="Drawing 5.png" data-nodeid="113648"></p>\n<p data-nodeid="113323">返回的数据结构也比较简单，只需要返回一条活动详情数据即可。</p>\n<pre class="lang-json" data-nodeid="113324"><code data-language="json">{\n  <span class="hljs-attr">"ret"</span>:<span class="hljs-number">0</span>,\n  <span class="hljs-attr">"message"</span>:<span class="hljs-string">"success"</span>,\n  <span class="hljs-attr">"data"</span>:{\n    <span class="hljs-attr">"id"</span>:<span class="hljs-string">"111"</span>,\n    <span class="hljs-attr">"name"</span>:<span class="hljs-string">"洗头券"</span>,\n    <span class="hljs-attr">"code"</span>:<span class="hljs-string">"xxxx11"</span>,\n    <span class="hljs-attr">"desc"</span>:<span class="hljs-string">"周六日前往，可免费体验"</span>,\n    <span class="hljs-attr">"act_id"</span>:<span class="hljs-string">"1110"</span>,\n    <span class="hljs-attr">"is_effective"</span>: <span class="hljs-literal">true</span>,\n    <span class="hljs-attr">"image"</span>:<span class="hljs-string">"xxxx"</span>,\n    <span class="hljs-attr">"start_time"</span>:<span class="hljs-number">1422222333</span>,\n    <span class="hljs-attr">"end_time"</span>:<span class="hljs-number">1444444444</span>\n  }\n}\n</code></pre>\n<h4 data-nodeid="113325">抢票接口</h4>\n<p data-nodeid="113326">最后我们再来看下抢票的接口，这个稍微复杂并且核心，因此这部分会设计时序图，我们首先还是来看下参数设计，如表格 10 所示。</p>\n<div data-nodeid="113327"><p style="text-align:center">表格 10 抢票接口参数</p></div>\n<p data-nodeid="113328"><img src="https://s0.lgstatic.com/i/image6/M00/3B/F8/CioPOWCHtHiAETgTAAA1-H9aNLI698.png" alt="Drawing 6.png" data-nodeid="113654"></p>\n<p data-nodeid="113329">返回结构如下所示：</p>\n<pre class="lang-json" data-nodeid="113330"><code data-language="json">{\n  <span class="hljs-attr">"ret"</span>:<span class="hljs-number">0</span>,\n  <span class="hljs-attr">"message"</span>:<span class="hljs-string">"success"</span>,\n  <span class="hljs-attr">"data"</span>:{\n    <span class="hljs-attr">"id"</span>:<span class="hljs-string">"111"</span>,\n    <span class="hljs-attr">"name"</span>:<span class="hljs-string">"洗头券"</span>,\n    <span class="hljs-attr">"desc"</span>:<span class="hljs-string">"周六日前往，可免费体验"</span>,\n    <span class="hljs-attr">"code"</span>:<span class="hljs-string">"xxx1222"</span>,\n    <span class="hljs-attr">"actId"</span>:<span class="hljs-string">"1110"</span>,\n    <span class="hljs-attr">"isEffective"</span>: <span class="hljs-literal">true</span>,\n    <span class="hljs-attr">"image"</span>:<span class="hljs-string">"xxxx"</span>,\n    <span class="hljs-attr">"start_time"</span>:<span class="hljs-number">1422222333</span>,\n    <span class="hljs-attr">"end_time"</span>:<span class="hljs-number">1444444444</span>\n  }\n}\n</code></pre>\n<p data-nodeid="113331">这里抢票会可能失败，比如 -1 活动结束了，-2 票不足，未抢到，-3 则是系统错误。如果抢到票则在 data 中返回具体的票信息，用于前端展示。<br>\n时序图如图 3 所示。</p>\n<p data-nodeid="113332"><img src="https://s0.lgstatic.com/i/image6/M00/3B/EF/Cgp9HWCHtIOAPyT9AADhIF3eWWE014.png" alt="Drawing 7.png" data-nodeid="113661"></p>\n<div data-nodeid="113333"><p style="text-align:center">图 3 抢票接口时序图</p></div>\n<p data-nodeid="113334">我来详细带你了解各模块间的函数交互的 6 过程：</p>\n<ol data-nodeid="113335">\n<li data-nodeid="113336">\n<p data-nodeid="113337">用户调用 ticket/get 前往抢票；</p>\n</li>\n<li data-nodeid="113338">\n<p data-nodeid="113339">进行活动校验，主要是检查活动时间是否生效过程中，如果已经失效或者未开始，则直接返回相应的错误码；</p>\n</li>\n<li data-nodeid="113340">\n<p data-nodeid="113341">检查用户是否有权限参加活动，判断用户是否已经参加过，或者该活动是否仅针对某些用户，如果参加过返回相应的状态，如果不能参加则返回其他信息；</p>\n</li>\n<li data-nodeid="113342">\n<p data-nodeid="113343">校验都通过后，调用 Model 层的 getOneTicket 方法获取一张票，这时候需要利用 Redis 的队列，原子操作获取一张票，拿到票以后返回相应的 code 信息；</p>\n</li>\n<li data-nodeid="113344">\n<p data-nodeid="113345">拿到 code 以后需要将 code 换成票详情信息，因此又需要反查 Service 层获取票详情；</p>\n</li>\n<li data-nodeid="113346">\n<p data-nodeid="113347">最终再将票详情返回给到接口调用方。</p>\n</li>\n</ol>\n<p data-nodeid="113348">完成接口设计以后，我们就可以做一定的 Mock 数据返回了，你可以打开<a href="https://github.com/love-flutter/nodejs-column?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="113672">17 讲的 GitHub</a>的源代码，然后运行服务，访问以下 5 个接口，你将可以得到一组测试的假数据，这样和你合作的前端同学也可以进行一些界面的开发了：</p>\n<pre class="lang-java" data-nodeid="113349"><code data-language="java">http:<span class="hljs-comment">//127.0.0.1:3000/act/list</span>\nhttp:<span class="hljs-comment">//127.0.0.1:3000/act/detail?actId=111</span>\nhttp:<span class="hljs-comment">//127.0.0.1:3000/ticket/get</span>\nhttp:<span class="hljs-comment">//127.0.0.1:3000/ticket/detail?ticketId=111</span>\nhttp:<span class="hljs-comment">//127.0.0.1:3000/ticket/list</span>\n</code></pre>\n<p data-nodeid="113350">以上就是抢票逻辑的几个过程，这一讲我只带你做完了前期的准备工作，主要是让你了解后台服务的开发流程，而 18 讲则侧重在代码实现细节，核心是介绍系统的开发实践以及核心抢票逻辑的原理。</p>\n<h3 data-nodeid="113351">总结</h3>\n<p data-nodeid="113352">总的来说，前后端开发在思路上是完全不同的，前端注重交互，后端则要考虑架构的设计以及数据结构的设计。学完这一讲之后，我希望你能更了解后台服务的开发思维，从需求拆解分析到架构设计、数据结构的设计，最终到接口的协议的设计。在整个流程中，你要非常注意核心接口的设计以及技术细节的实现，在前期考虑好所有的设计后，再进行下一讲的代码实现。</p>\n<p data-nodeid="113353" class="">今天我给你留的作业是：在本讲中只是绘制了活动列表和抢票的时序图，你可以尝试去绘制活动详情、票列表和票详情的时序图，感谢你的阅读，我们下一讲见。</p>',
        article_title: "17 | 系统的实践设计（上）：完成一个通用抢票系统",
        title: "17 | 系统的实践设计（上）：完成一个通用抢票系统",
        id: 6799,
      },
      {
        content:
          '<p data-nodeid="71844">上一讲，我们完成了准备工作，包括架构设计、数据库设计、接口设计以及接口时序图绘制，这一讲就着重实现活动相关接口、票相关接口和抢票接口，为的是让你熟悉使用 Node.js 来开发后台服务。</p>\n<p data-nodeid="71845">这三个部分的实现都有一定的代表性，活动相关接口因为访问量较大，要完全走缓存的设计方式；与个人相关的票接口，访问量较少并且缓存意义不大，所以走数据库的设计方式；而抢票是我们核心接口，也是最大的并发接口，则涉及应用 Redis 的链表技术点。</p>\n<p data-nodeid="71846">明确上述需要开发的接口，以及要掌握的技术点之后，接下来我们就正式进入今天的内容，看一下你在开发时需要注意的细节。</p>\n<h3 data-nodeid="73409">开发流程</h3>\n\n\n<p data-nodeid="71849">在开发之前，我们做这样 4 个准备。</p>\n<ul data-nodeid="71850">\n<li data-nodeid="71851">\n<p data-nodeid="71852">安装本地的 Redis 服务，如果你是 Mac 可以直接使用 brew install redis，如果是 Linux 或者 Windows 可以前往<a href="https://redis.io/?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="71981">redis 官网</a>下载配置，完成后需要修改项目代码 src/cache.js 中的 redis 配置。</p>\n</li>\n<li data-nodeid="71853">\n<p data-nodeid="71854">重新配置 pm2.config.js 文件，在 env_development 中增加以下配置，主要是为了在开发阶段，自动重启不需要监听下面目录的变化。</p>\n</li>\n</ul>\n<pre class="lang-java" data-nodeid="71855"><code data-language="java">ignore_watch: [<span class="hljs-string">"log"</span>, <span class="hljs-string">"node_modules"</span>, <span class="hljs-string">"bin"</span>, <span class="hljs-string">"config"</span>]\n</code></pre>\n<ul data-nodeid="71856">\n<li data-nodeid="71857">\n<p data-nodeid="71858">创建好 PM2 的系统日志路径（可以自行在 pm2.config.js 中修改你自己希望的地址）。</p>\n</li>\n</ul>\n<pre class="lang-java" data-nodeid="71859"><code data-language="java">mkdir -p ~/data/nodejs-column-io/\n</code></pre>\n<ul data-nodeid="71860">\n<li data-nodeid="71861">\n<p data-nodeid="71862">由于 Mongodb 使用的是云服务，所以也需要你自行去申请一个<a href="https://cloud.mongodb.com/?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="71990">Mongodb 云服务</a>。当然，你也可以自行在<a href="https://www.mongodb.com/try/download/community?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="71994">官网下载</a>本地安装一个，安装完成后，需要修改 src/lib/baseMongodb.js 中第一行的配置，并且要在 Mongodb 中创建 nodejs_cloumn 数据库。</p>\n</li>\n</ul>\n<p data-nodeid="71863">完成上述 4 点准备之后，要在项目根目录使用下面的命令启动服务：</p>\n<pre class="lang-java" data-nodeid="71864"><code data-language="java">pm2 start pm2.config.js --env development\n</code></pre>\n<p data-nodeid="71865">启动成功后，访问以下路径来检测 Mongodb 和 Redis 配置是否正确。</p>\n<pre class="lang-java" data-nodeid="71866"><code data-language="java">http:<span class="hljs-comment">//127.0.0.1:3000/tools/test?token=piu12naern9023izcx</span>\n</code></pre>\n<p data-nodeid="75269">如果返回图 1 的信息则表示正常，如果出现异常，就要检查一下具体的配置是不是正确，或者 Redis 以及 Mongodb 是否正常启动。</p>\n<p data-nodeid="75270" class=""><img src="https://s0.lgstatic.com/i/image6/M00/3B/FE/CioPOWCHwuCASYE8AAA3Jdxt9po231.png" alt="Drawing 0.png" data-nodeid="75275"></p>\n<div data-nodeid="75271"><p style="text-align:center">图 1 正常检测结果</p></div>\n\n\n\n\n\n<p data-nodeid="71869">前期检查正常后，接下来我们就来实现 17讲中的那 5 个接口。为了方便你开发调试，你可以直接调用以下链接，初始化我们的数据库：</p>\n<pre class="lang-java" data-nodeid="71870"><code data-language="java">http:<span class="hljs-comment">//127.0.0.1:3000/tools/init?token=piu12naern9023izcx</span>\n</code></pre>\n<p data-nodeid="71871">成功会提示正常的结果，如果失败就要前往项目根目录的 log/_tools_init.log 中查看具体的报错信息。</p>\n<h3 data-nodeid="71872">活动相关接口</h3>\n<p data-nodeid="71873">活动相关的接口包含活动列表接口、活动详情接口，下面我们先来看下活动列表接口的实现。</p>\n<h4 data-nodeid="71874">活动列表接口</h4>\n<p data-nodeid="71875">在 src/controller 路径下创建 act.js 作为活动的类，其中的 list 方法为活动列表，我们看一下该方法的代码，如图 2 所示。</p>\n<p data-nodeid="76515" class=""><img src="https://s0.lgstatic.com/i/image6/M00/3B/F5/Cgp9HWCHwuqAOGpKAAFix4u8UOA791.png" alt="Drawing 1.png" data-nodeid="76519"></p>\n<div data-nodeid="76516"><p style="text-align:center">图 2 活动列表接口</p></div>\n\n\n\n<p data-nodeid="71878">在图 2 中的红色框部分，就是应用框架的 loadService 加载 actService 这个类，然后调用该类的 getList 获取数据，那么我们继续来看 actService.getList 的逻辑，如图 3 所示。</p>\n<p data-nodeid="77755" class=""><img src="https://s0.lgstatic.com/i/image6/M00/3B/FE/CioPOWCHwvOAHPXsAAFObmPiKdI776.png" alt="Drawing 2.png" data-nodeid="77759"></p>\n<div data-nodeid="77756"><p style="text-align:center">图 3 actService getList 逻辑</p></div>\n\n\n\n<p data-nodeid="71881">在图 3 ，我们首先在第一个红色框中获取缓存数据，如果没有获取到则从数据库中获取，也就是第二个红框逻辑。</p>\n<p data-nodeid="71882">为了性能考虑以及实时性考虑，我们只能将活动列表的缓存设置为 120 秒，但是我们可以定时地每 60 秒去生成这个缓存。为了定时缓存，我们特意在 actService 中实现了一个 cacheList 方法，你可以前往<a href="https://github.com/love-flutter/nodejs-column?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="72029">GitHub</a>查看详细实现。</p>\n<p data-nodeid="71883">这里你可以思考一下：为什么一个设置为 120 秒和另外一个为 60 秒？这在课程的某一讲提及过，你知道是哪一讲以及原因吗？欢迎在评论区分享你的答案。</p>\n<h4 data-nodeid="78376">活动详情</h4>\n\n\n<p data-nodeid="71886">活动详情和活动列表的实现基本是一样的，核心都是从缓存中获取，代码如图 4 所示。</p>\n<p data-nodeid="79605" class=""><img src="https://s0.lgstatic.com/i/image6/M00/3B/FE/CioPOWCHwv6AdGZaAADbxFIfj50739.png" alt="Drawing 3.png" data-nodeid="79609"></p>\n<div data-nodeid="79606"><p style="text-align:center">图 4 活动详情接口</p></div>\n\n\n\n<p data-nodeid="71889">在完成两个接口开发以后，你可以直接访问下面两个地址，就可以看到正常的响应结果了。</p>\n<pre class="lang-java" data-nodeid="71890"><code data-language="java">http:<span class="hljs-comment">//127.0.0.1:3000/act/list?page=0&amp;token=piu12naern9023izcx</span>\nhttp:<span class="hljs-comment">//127.0.0.1:3000/act/detail?id=607bc870647e4cc06f7f3df7&amp;token=piu12naern9023izcx</span>\n</code></pre>\n<p data-nodeid="71891">如果这个过程中出现失败异常情况，你要分别打开 PM2 的日志路径文件，项目根目录下的 log/_act_list.log 和 log/_act_detail.log 日志信息查看具体的错误原因。</p>\n<h3 data-nodeid="80222">票相关接口</h3>\n\n\n<p data-nodeid="71894">由于个人的票券码列表访问比较少，并且每个人访问的列表内容不一样，因此缓存设置的意义不太大，直接从数据库读取就行，没有必要单独为这部分进行缓存了。在项目 src/controller 中创建 ticket.js 用来实现 ticket 类。</p>\n<h4 data-nodeid="71895">个人票券码列表</h4>\n<p data-nodeid="71896">在 ticket.js 中实现 list 方法，代码实现如图 5 所示。</p>\n<p data-nodeid="81443" class=""><img src="https://s0.lgstatic.com/i/image6/M00/3B/FE/CioPOWCHwwqAP5GuAAD3ZbKdwSU388.png" alt="Drawing 4.png" data-nodeid="81447"></p>\n<div data-nodeid="81444"><p style="text-align:center">图 5 个人票券码列表</p></div>\n\n\n\n<p data-nodeid="71899">从图 5 中可以看到，其实现逻辑和上面的活动列表实现非常相似，都是调用 Service 方法逻辑，只是区别在 ticketService 中的实现不同，代码如图 6 所示。</p>\n<p data-nodeid="82663" class=""><img src="https://s0.lgstatic.com/i/image6/M00/3B/F6/Cgp9HWCHwxKAVi9pAAE57SHwWPE688.png" alt="Drawing 5.png" data-nodeid="82667"></p>\n<div data-nodeid="82664"><p style="text-align:center">图 6 ticketService.getUserTickList 实现</p></div>\n\n\n\n<p data-nodeid="71902">在图 6 中两个红色框中都是直接 load 了数据库模块来获取数据，没有从缓存中获取。</p>\n<h4 data-nodeid="83274">票券码详情</h4>\n\n\n<p data-nodeid="71905">票券码详情也是一样，这部分我们也是使用的数据库读取的方式来实现，在我们项目源码中已经实现。但是这里我希望你进行改进，在原有的基础上改造为从缓存中读取，这部分留作你自己实现。</p>\n<p data-nodeid="71906">在完成以上两个接口以后，我们可以访问以下两个请求来查看接口是否正常。</p>\n<pre class="lang-java" data-nodeid="71907"><code data-language="java">http:<span class="hljs-comment">//127.0.0.1:3000/ticket/list?token=piu12naern9023izcx</span>\nhttp:<span class="hljs-comment">//127.0.0.1:3000/ticket/detail?token=piu12naern9023izcx&amp;code=OPIADCV23</span>\n</code></pre>\n<p data-nodeid="71908">由于我们还没有券码，因此返回都是空的数据，接下来我们来实现抢票，抢票完成后再回过来看两个接口的响应数据。</p>\n<h3 data-nodeid="71909">抢票接口</h3>\n<p data-nodeid="71910">这部分是核心的实现，我们需要使用到 Redis 的原子操作 lpush lrem lpop 三个指令。</p>\n<ul data-nodeid="88854">\n<li data-nodeid="88855">\n<p data-nodeid="88856"><strong data-nodeid="88866">lpush</strong>：向一个双向链表插入一个数据元素，在我们应用中插入的是一个券码；</p>\n</li>\n<li data-nodeid="88857">\n<p data-nodeid="88858"><strong data-nodeid="88871">lrem</strong>：在链表中删除指定的元素，在我们应用中需要在插入之前先进行删除，避免重复；</p>\n</li>\n<li data-nodeid="88859">\n<p data-nodeid="88860"><strong data-nodeid="88876">lpop</strong>：弹出一个数据元素，在我们应用中从链表中获取一个券码。</p>\n</li>\n</ul>\n<p data-nodeid="88861" class=""><strong data-nodeid="88881">这三个命令就帮我们实现了一个简单的抢票逻辑：</strong> 首先在初始化时，将我们的券码插入 Redis 中，这部分逻辑在 codeService 中的 import 方法中实现，具体代码如图 7 所示。</p>\n\n\n\n\n\n\n\n\n<p data-nodeid="88243" class=""><img src="https://s0.lgstatic.com/i/image6/M00/3B/F6/Cgp9HWCHwy6AJs7aAAGuUnYHXbA462.png" alt="Drawing 6.png" data-nodeid="88247"></p>\n<div data-nodeid="88244"><p style="text-align:center">图 7 import 券码逻辑</p></div>\n\n\n\n<p data-nodeid="71921">在图 7 中的红色框部分，就是调用 codeModel 中的 lpush 将券码插入 Redis 中，而这部分逻辑就是在调用 /tools/init 时完成。在 lpush 中有一个比较取巧的技巧，如图 8 所示。</p>\n<p data-nodeid="90097" class=""><img src="https://s0.lgstatic.com/i/image6/M00/3B/F6/Cgp9HWCHwziAJmT9AAFXUG0RFAo437.png" alt="Drawing 7.png" data-nodeid="90101"></p>\n<div data-nodeid="90098"><p style="text-align:center">图 8 lpush 逻辑实现</p></div>\n\n\n\n<p data-nodeid="90708" class="">在图 8 的红色框内，我们需要先删除该项，删除完成后再插入，<strong data-nodeid="90714">为什么这么复杂呢？</strong> 主要是为了避免插入重复项，如果删除成功代表原来就有该数据，因此不算新插入，如果删除为 0 则表示新插入，这样就可以方便后续的逻辑，比如需要落地数据库，那么重复的就没有必要再次落数据库了。</p>\n\n<p data-nodeid="71925">数据初始化完以后，我们再来看下抢票逻辑是如何实现的，该逻辑实现在 ticket controller 中的 get 方法。</p>\n<p data-nodeid="91930" class=""><img src="https://s0.lgstatic.com/i/image6/M00/3B/F6/Cgp9HWCHw0OAAnrLAAGblxCYBsA727.png" alt="Drawing 8.png" data-nodeid="91934"></p>\n<div data-nodeid="91931"><p style="text-align:center">图 9 抢票接口校验实现</p></div>\n\n\n\n<p data-nodeid="71928">图 9 主要是我们的抢票的资格校验，判断该用户是否参与过该项目，或者提交的一个活动是否是非法的（其次还可以根据需求校验该活动是否在生效期内）。校验通过后，就调用 codeService.getOneCode 方法，来抢一张票，如图 10 所示。</p>\n<p data-nodeid="93146" class=""><img src="https://s0.lgstatic.com/i/image6/M00/3B/F6/Cgp9HWCHw0qAcn7NAAG9Pxo2yvQ405.png" alt="Drawing 9.png" data-nodeid="93150"></p>\n<div data-nodeid="93147"><p style="text-align:center">图 10 抢票逻辑</p></div>\n\n\n\n<p data-nodeid="71931">图 10 中的红色框部分就是调用 lpop 来实现抢票。抢票完成后，我们需要设置缓存，以方便后续用户再次进入活动时，主动提示用户已经参与过该活动。抢票实现完成后，我们再回过来看抢票后的逻辑。</p>\n<p data-nodeid="94358" class=""><img src="https://s0.lgstatic.com/i/image6/M00/3B/FE/CioPOWCHw1KANkPlAAHBsH7y-v8488.png" alt="Drawing 10.png" data-nodeid="94362"></p>\n<div data-nodeid="94359"><p style="text-align:center">图 11 抢票数据落地</p></div>\n\n\n\n<p data-nodeid="71934">在上一讲的时序图中我们说明过，只要抢票成功，就代表成功了，后续的一些逻辑数据都使用异步的方式去存储，存储失败则需要记录日志，并定时回写失败数据，比如图 11 中的 historyService.insertHistory 是一个异步执行逻辑，不会阻塞用户成功响应。</p>\n<p data-nodeid="71935">以上就完成了抢票部分逻辑，开发完成以后，你只需要调用以下接口就可以测试。</p>\n<pre class="lang-java" data-nodeid="71936"><code data-language="java">http:<span class="hljs-comment">//127.0.0.1:3000/ticket/get?token=piu12naern9023izcx&amp;actId=607bc99b7e96f0c1e8057f3c</span>\n</code></pre>\n<p data-nodeid="96161">响应如图 12 所示。</p>\n<p data-nodeid="96162" class=""><img src="https://s0.lgstatic.com/i/image6/M00/3B/FE/CioPOWCHw1uABdDNAADOAVf-s_g172.png" alt="Drawing 11.png" data-nodeid="96167"></p>\n<div data-nodeid="96163"><p style="text-align:center">图 12 抢票结果信息</p></div>\n\n\n\n\n\n<p data-nodeid="71939">当你再次调用上面的接口时，就会提醒你已经参与过该活动了。</p>\n<h3 data-nodeid="96768">clinic 检测</h3>\n\n\n<p data-nodeid="71942">在完成了所有接口以后，我们就需要使用 clinic 工具来检测是否存在一些性能问题，我们在 bin/clinic_test.js 中增加需要测试的接口列表，这部分也需要大家自行修改，因为其中的参数可能会不同。</p>\n<p data-nodeid="71943">比如我们修改以下配置。</p>\n<p data-nodeid="97965" class=""><img src="https://s0.lgstatic.com/i/image6/M00/3B/FE/CioPOWCHw2aANAAzAAEShovGyQg910.png" alt="Drawing 12.png" data-nodeid="97969"></p>\n<div data-nodeid="97966"><p style="text-align:center">图 13 clinic 测试配置</p></div>\n\n\n\n<p data-nodeid="71946">配置修改完成以后，我们就回到项目根目录，首先需要将 PM2 中的该服务进程关闭，使用下面命令即可关闭（如果你修改过 PM2 中的配置，则需要根据配置中的进程名来进行关闭）。</p>\n<pre class="lang-java" data-nodeid="71947"><code data-language="java">pm2 delete nodejs-main-server-<span class="hljs-number">3000</span>\n</code></pre>\n<p data-nodeid="71948">接下来我们运行下面命令启动测试。</p>\n<pre class="lang-java" data-nodeid="71949"><code data-language="java">npm run clinic-test\n</code></pre>\n<p data-nodeid="71950">接下来你会看到如下的结果。</p>\n<pre class="lang-java" data-nodeid="71951"><code data-language="java">启动服务开始测试...\n开始检测 act/list 的接口性能问题\n该接口无任何异常问题\n开始检测 act/detail 的接口性能问题\n该接口无任何异常问题\n开始检测 ticket/list 的接口性能问题\n该接口存在异常\n具体详情请查看项目根目录下的\n./.clinic/<span class="hljs-number">56983</span>.clinic-doctor.html\n开始检测 ticket/detail 的接口性能问题\n该接口存在异常\n具体详情请查看项目根目录下的\n./.clinic/<span class="hljs-number">57041</span>.clinic-doctor.html\n开始检测 ticket/get 的接口性能问题\n该接口无任何异常问题\n你需要处理以下问题汇总，具体请查看下面详细信息\n</code></pre>\n<p data-nodeid="98566">上面结论很清晰告诉了我们 ticket/list 和 ticket/detail 存在性能问题，我们打开测试结果的 html 文件以后发现主要是 I/O 问题，然后再思考我们没有使用任何的缓存，并且 Mongodb 使用的还是一个远程云服务，因此这部分是的确存在问题的。</p>\n<p data-nodeid="98567">其他的几个接口都没有任何问题，因此对于我们来说是否就完事了呢？</p>\n\n<p data-nodeid="71953">虽然 ticket/get 没有问题，但是是基于已经完成抢票的逻辑，只是一个简单的判断，并不能说明可以支持批量用户同时来抢票，那么接下来我们就使用压测的方法，来查看该接口是否能满足高并发的情况。</p>\n<h3 data-nodeid="71954">抢票接口压测</h3>\n<p data-nodeid="71955">我们需要模拟批量用户，在我们项目中没有用户登录，但是在中间件 checkToken 中做了一个假的用户校验操作，那么我们在该模块中去写一个脚本来随机生成用户 ID（源码中这部分为注释代码，大家尝试时需要主动打开，如图 14 所示）。</p>\n<p data-nodeid="99166" class=""><img src="https://s0.lgstatic.com/i/image6/M00/3B/F6/Cgp9HWCHw3OAbeHJAAEBbgNTKdg378.png" alt="Drawing 13.png" data-nodeid="99169"></p>\n\n<p data-nodeid="71957">我们先请求活动列表，拿到一个可用的活动 ID ，我们获取图 15 中的最后一个活动 ID。</p>\n<p data-nodeid="100361" class=""><img src="https://s0.lgstatic.com/i/image6/M00/3B/FE/CioPOWCHw32ADMtjAAGXiGES6HI969.png" alt="Drawing 14.png" data-nodeid="100365"></p>\n<div data-nodeid="100362"><p style="text-align:center">图 15 活动列表</p></div>\n\n\n\n<p data-nodeid="71960">接下来我们多次请求以下链接。</p>\n<pre class="lang-java" data-nodeid="71961"><code data-language="java">http:<span class="hljs-comment">//127.0.0.1:3000/ticket/get?actId=607be8b34bf4efe9f8d04baa</span>\n</code></pre>\n<p data-nodeid="71962">你会发现，每次请求都可以获取新的券码，这样我们每次就可以走不同的逻辑了，为了测试性能，我们使用 wrk 来进行验证，使用下面命令来进行压测。</p>\n<pre class="lang-java" data-nodeid="71963"><code data-language="java">wrk -t2 -c300 -d20s <span class="hljs-string">"http://127.0.0.1:3000/ticket/get?actId=607be8b34bf4efe9f8d04baa"</span>\n</code></pre>\n<p data-nodeid="71964">压测完成后，你可以看到数据如下</p>\n<pre class="lang-java" data-nodeid="71965"><code data-language="java">Running <span class="hljs-number">20</span>s test @ http:<span class="hljs-comment">//127.0.0.1:3000/ticket/get?actId=607bc99b7e96f0c1e8057f3c</span>\n&nbsp; <span class="hljs-number">2</span> threads and <span class="hljs-number">300</span> connections\n&nbsp; Thread Stats&nbsp; &nbsp;Avg&nbsp; &nbsp; &nbsp; Stdev&nbsp; &nbsp; &nbsp;Max&nbsp; &nbsp;+/- Stdev\n&nbsp; &nbsp; Latency&nbsp; &nbsp; <span class="hljs-number">45.99</span>ms&nbsp; &nbsp;<span class="hljs-number">69.01</span>ms&nbsp; &nbsp;<span class="hljs-number">1.99</span>s&nbsp; &nbsp; <span class="hljs-number">98.47</span>%\n&nbsp; &nbsp; Req/Sec&nbsp; &nbsp; &nbsp;<span class="hljs-number">2.82</span>k&nbsp; &nbsp;<span class="hljs-number">655.32</span>&nbsp; &nbsp; &nbsp;<span class="hljs-number">4.71</span>k&nbsp; &nbsp; <span class="hljs-number">78.55</span>%\n&nbsp; <span class="hljs-number">106002</span> requests in <span class="hljs-number">20.07</span>s, <span class="hljs-number">21.53</span>MB read\n&nbsp; Socket errors: connect <span class="hljs-number">0</span>, read <span class="hljs-number">132</span>, write <span class="hljs-number">0</span>, timeout <span class="hljs-number">283</span>\nRequests/sec:&nbsp; &nbsp;<span class="hljs-number">5282.13</span>\nTransfer/sec:&nbsp; &nbsp; &nbsp; <span class="hljs-number">1.07</span>MB\n</code></pre>\n<p data-nodeid="71966">这个数据和我们第 12 讲的数据进行对比，QPS 在 5282.13 （我们当前启用 1 个进程），平均耗时 45.99 ms 因此整体上我们的抢票接口性能还是非常好的，这里唯一有问题的可能是我们的 Mongodb ，你测试的时候最好在本地搭建环境，避免这类影响。</p>\n<h3 data-nodeid="100960">总结</h3>\n\n\n<p data-nodeid="71969">本讲核心是实践开发活动相关接口、票相关接口以及主要的抢票接口，并利用我们所学的一些知识 clinic 检测和 wrk 压测工具来分析接口的性能问题。</p>\n<p data-nodeid="71970">总的来说，Node.js 开发效率还是非常高的，整个系统我大概花费了 1 天半的时间完成这部分演示代码，代码还会存在一些缺陷，你可以尝试应用项目，然后共同来解决这个项目中存在的问题。</p>\n<p data-nodeid="71971">实际开发过程中的需求大部分离不开我们通用抢票系统的流程，最核心的是要了解哪些是高并发需要使用缓存处理，哪些是低访问可以直接读取数据库的方式。在实际应用过程中，我们还需要动态的根据现网的访问情况进行扩容，但是每次都需要手动扩容非常的不方便，那有没有弹性的服务机制，在我请求较大时分配更多服务资源，在请求少时减少服务资源呢？那么这就是我们下一讲的内容 serverless 的知识点。</p>',
        article_title: "18 | 系统的实践设计（下）：完成一个通用投票系统",
        title: "18 | 系统的实践设计（下）：完成一个通用投票系统",
        id: 6800,
      },
      {
        content:
          '<p data-nodeid="101986">上一讲我们学习了机器部署的一些方案和策略，比如当你要将一个服务部署到多台（2台以上）机时，你会发现为了尽可能地利用资源、避免浪费，更不能在高并发时引起现网问题，每次都要精细地分析每台机器的部署方案，那有没有可以弹性地根据当前负载情况进行自动化的方案呢？</p>\n\n\n\n<p data-nodeid="101557">当然有，就是我们这一讲要学习的 Serverless 技术，目前市面上 Serverless 技术的资料非常多（拉勾教育也有一门课 《 玩转 Serverless 架构》，感兴趣可以看一下）。而我们这一讲主要学习的是，Serverless 是怎么帮我们解决 Node.js 的问题点的；以及怎么将课程中的 KOA 框架应用接入到 Serverless 服务中去。</p>\n<p data-nodeid="101558">作为 Node.js 后台开发人员，因为一定会涉及服务器资源、服务器的部署分配或者自动化扩容等问题，所以你有必要去仔细学习今天的内容，希望学完这一讲之后，你能从 Serverless 的角度去解决这些问题，为你的企业节省一大笔费用。</p>\n<h3 data-nodeid="101559">什么是 Serverless</h3>\n<p data-nodeid="101560">Serverless 的英文转换过来就是无服务器，简单理解是“摒弃服务器”。但是无服务器不是说真的没有服务器，而是说云服务厂商来帮你动态地规划服务器资源，你只提供源代码给云厂商，云厂商就按照你服务所调度的资源来计费，而不是最原始的租借服务器的方式。</p>\n<h4 data-nodeid="101561">实际场景</h4>\n<p data-nodeid="101562">按照 18 讲中的多服务部署经验，你要严格地根据服务并发情况分配服务器，并且要按照服务的并发上限来分配服务器。</p>\n<p data-nodeid="101563">比如你经过压测分析后，得到结论是需要 4 台 16 核的服务器，那么你在每台服务器上还只能启动 14 或者 15 个进程（避免内核占满，服务器异常无法使用的情况）。我们来计算成本，假设 1 台机器 1 万元/年， 那么 4 台就是 4 万元/年。</p>\n<p data-nodeid="101564">也就说不管你用多或者用少，服务器已经分配给你了，这 4 万元/年没法避免，但其实你是无法充分利用服务器资源的，因为我们都是按照最大并发来配置的，所以一定存在服务资源的浪费（极端地说，如果今年的业绩没有达到预期，并没有用到多出来的 4 台机器，就全浪费了）。</p>\n<h4 data-nodeid="101565">解决的问题</h4>\n<p data-nodeid="101566">在上面的例子中，如果没有 Serverless ，会一直存在这样的问题，没有一个很好的解决方案，所以多少存在资源浪费的问题，那么 Serverless 解决了 Node.js 服务的哪些问题呢？</p>\n<ul data-nodeid="103201">\n<li data-nodeid="103202">\n<p data-nodeid="103203"><strong data-nodeid="103214">费用问题：</strong> 假设我还是给你 4 台最大并发的服务器，但是不让你按月缴费，而是根据你调用的次数和流量来计费，这种计费方式下，可以在没有服务调用时不计费，所以大部分情况下都是 Serverless 价格优势更大。</p>\n</li>\n<li data-nodeid="103204">\n<p data-nodeid="103205"><strong data-nodeid="103219">扩容更加简单：</strong> 如果你遇到公司大促，只用临时扩容当前的内存占用即可，不用再一步步地去部署服务器环境，再部署 Node.js 服务，最后经过测试验证后才可使用。</p>\n</li>\n<li data-nodeid="103206">\n<p data-nodeid="103207"><strong data-nodeid="103224">减少了并发校验的问题：</strong> 根据课程的内容，我们每次都要预估上线后的服务承载能力，并且需要非常细致地规划服务器部署情况，但有了 Serverless 以后，可以不用关心这种情况，专注避免性能问题就行。</p>\n</li>\n<li data-nodeid="103208">\n<p data-nodeid="103209" class=""><strong data-nodeid="103229">环境依赖兼容问题更少：</strong> Node.js 对各种库版本都是有要求的，而如果服务器共用，就务必会导致各种 so 库版本不兼容问题，但是 Serverless 是独立的环境运行空间，所以不用担心这类问题，这些都由云服务厂商帮你解决。</p>\n</li>\n</ul>\n\n\n\n\n<p data-nodeid="101576">既然 Severless 可以帮你解决上述问题，那么我们就来尝试将 KOA 框架应用接入到 Serverless 云服务上。</p>\n<h3 data-nodeid="101577">如何应用</h3>\n<p data-nodeid="101578">因为 Serverless 是从线下转到线上的云计算的技术应用，所以我们要依托一家云计算服务来分析演示，比如 AWS 、腾讯云或者阿里云都有一定的免费调用次数。在选择一家免费云测试服务以后，接下来就将现有的业务进行改造，以满足接入要求。</p>\n<h4 data-nodeid="103518">KOA 接入</h4>\n\n\n<p data-nodeid="104098" class="">目前各大云计算服务都支持 Node.js 的各种框架接入，比如我们所使用的 KOA ，这里我们选了一家免费的云计算服务来演示接入过程，其中有一个接入指引，你可以去 <a href="https://github.com/serverless-components/tencent-koa/tree/master?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="104102">GitHub</a> 上了解其接入方案（这里不涉及任何推荐云平台，在测试阶段根据自己的喜好接入，接入方法比较简单）。</p>\n\n\n<p data-nodeid="101582"><strong data-nodeid="101652">设置配置文件</strong></p>\n<p data-nodeid="101583">无论是哪家云计算服务，一般都会包含一个 Serverless 配置文件，用于保存当前服务的相关启动配置，比如下面我们的一个 Serverless 配置。</p>\n<pre class="lang-yaml" data-nodeid="101584"><code data-language="yaml"><span class="hljs-attr">component:</span> <span class="hljs-string">koa</span> <span class="hljs-comment"># (required) name of the component. In that case, it\'s koa.</span>\n<span class="hljs-attr">app:</span> <span class="hljs-string">koa-tst-4</span> <span class="hljs-comment"># (optional) Serverless dashboard app. default is the same as the name property.</span>\n<span class="hljs-attr">name:</span> <span class="hljs-string">koa-tst-4</span> <span class="hljs-comment"># (required) name of your koa component instance.</span>\n<span class="hljs-attr">inputs:</span>\n  <span class="hljs-attr">src:</span>\n    <span class="hljs-attr">src:</span> <span class="hljs-string">./</span> <span class="hljs-comment"># (optional) path to the source folder. default is a hello world app.</span>\n    <span class="hljs-attr">exclude:</span>\n      <span class="hljs-bullet">-</span> <span class="hljs-string">.env</span>\n  <span class="hljs-attr">region:</span> <span class="hljs-string">ap-guangzhou</span>\n  <span class="hljs-attr">runtime:</span> <span class="hljs-string">Nodejs10.15</span>\n  <span class="hljs-attr">apigatewayConf:</span>\n    <span class="hljs-attr">protocols:</span>\n      <span class="hljs-bullet">-</span> <span class="hljs-string">http</span>\n      <span class="hljs-bullet">-</span> <span class="hljs-string">https</span>\n    <span class="hljs-attr">environment:</span> <span class="hljs-string">test</span>\n</code></pre>\n<p data-nodeid="104390">首先在 component 中申明了框架类型，其次 app 说明了项目名称，name 则为启动的项目实例名称。inputs 就是项目相关的配置，比如 src 表明项目所处的根目录位置，详细的字段说明n你可以参考<a href="https://github.com/serverless-components/tencent-koa/blob/master/docs/configure.md?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="104395">GitHub 这个项目</a>说明。</p>\n<p data-nodeid="104391"><strong data-nodeid="104400">修改 APP 入口文件</strong></p>\n\n<p data-nodeid="101586">默认情况下 Serverless 的入口文件名为 sls.js ，因此我们将项目中的 app.js 修改为 sls.js ，同时将 sls.js 中的最后一行代码进行修改如下。</p>\n<pre class="lang-javascript" data-nodeid="101587"><code data-language="javascript"><span class="hljs-keyword">if</span>(process.env.Serverless) {\n    <span class="hljs-built_in">module</span>.exports = app \n} <span class="hljs-keyword">else</span> {\n    app.listen(<span class="hljs-number">3000</span>) \n}\n<span class="hljs-comment">//app.listen(3000, () =&gt; console.log(`Example app listening on port 3000!`));</span>\n</code></pre>\n<p data-nodeid="104687">首先判断环境类型，如果是 Serverless 的运行环境，就使用 module.exports 导出相应的 app 对象，如果非 Serverless 环境，也就是我们自身环境就使用 listen 来启动服务。</p>\n<p data-nodeid="104688">以上就完成了接入，接下来只需要将代码上传到平台即可，上传平台有多种方式，比如命令行的方式。还可以使用代码文件夹上传的方式，或者 GitHub 地址授权引入的方式。</p>\n\n<h4 data-nodeid="104977">实践测试</h4>\n\n\n<p data-nodeid="101591">在代码上传完成以后，我们可以看到类似图 1 所示的结果。</p>\n<p data-nodeid="105546" class=""><img src="https://s0.lgstatic.com/i/image6/M01/3B/F6/Cgp9HWCHw--AIb5jAAEa4Dzd7Bs282.png" alt="Drawing 0.png" data-nodeid="105550"></p>\n<div data-nodeid="105547"><p style="text-align:center">图 1 Serverless 服务</p></div>\n\n\n\n<p data-nodeid="101594">接下来我们只需要访问图 1 的 API 网关的 URL 。</p>\n<p data-nodeid="101595">打开地址后，我们就可以看到我们熟悉的框架响应数据了，如下图 2 所示。</p>\n<p data-nodeid="106114" class=""><img src="https://s0.lgstatic.com/i/image6/M01/3B/F6/Cgp9HWCHw_aAEDyzAAAmkVZjuso799.png" alt="Drawing 1.png" data-nodeid="106118"></p>\n<div data-nodeid="106115"><p style="text-align:center">图 2 KOA 框架响应</p></div>\n\n\n\n<p data-nodeid="101598">接下来我们访问一个我们正确的路径地址，如下 URL：</p>\n<pre class="lang-java" data-nodeid="101599"><code data-language="java">https:<span class="hljs-comment">//service-bnike5yc-1251046496.gz.apigw.tencentcs.com/release/page/index?name=lagou-nodejs</span>\n</code></pre>\n<p data-nodeid="101600">这个 URL 访问的就是我们 GitHub 源码中 Page 类的 index 方法，代码如下：</p>\n<pre class="lang-javascript" data-nodeid="101601"><code data-language="javascript"><span class="hljs-keyword">const</span> Controller = <span class="hljs-built_in">require</span>(<span class="hljs-string">\'../core/controller\'</span>);\n<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Page</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Controller</span> </span>{\n    <span class="hljs-keyword">async</span> index() {\n        <span class="hljs-keyword">let</span> name = <span class="hljs-keyword">this</span>.getParams(<span class="hljs-string">\'name\'</span>);\n        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.resApi(<span class="hljs-literal">true</span>, <span class="hljs-string">\'success\'</span>, {name} );\n    }\n}\n<span class="hljs-built_in">module</span>.exports = Page; \n</code></pre>\n<p data-nodeid="106951">代码逻辑比较简单，获取 name 字段，然后将 name 返回给到 API 调用方。因此当访问 page/index?name=lagou-nodejs 后，会响应如下数据，如图 3 示。</p>\n<p data-nodeid="106952" class=""><img src="https://s0.lgstatic.com/i/image6/M00/3B/F6/Cgp9HWCHw_6AX42UAAAzwZkU7Fc325.png" alt="Drawing 2.png" data-nodeid="106957"></p>\n<div data-nodeid="106953"><p style="text-align:center">图 3 KOA 正常响应数据</p></div>\n\n\n\n\n\n<p data-nodeid="101604">由于需要独立部署项目，所以我们本讲的<a href="https://github.com/love-flutter/serverless?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="101691">GitHub 源码</a>做了一定的调整，单独启用了一个新项目，你在实践时，可以直接 fork 该项目，然后去尝试接。</p>\n<p data-nodeid="101605">以上就完成了接入，后续只需要正常开发提交到自己的 GitHub 项目中，然后在应用平台的自动化工具从 GitHub 直接部署到 Serverless 服务上，部署应用都将非常快捷。</p>\n<h3 data-nodeid="107236">总结</h3>\n\n\n<p data-nodeid="101608">本讲核心是介绍了什么是 Serverless 、解决了我们当前 Node.js 服务的问题以及如何接入应用，学完本讲后能够了解 Serverless 的优势，并且可以进行一些简单云服务接入尝试。</p>\n<p data-nodeid="101609">由于项目迁移成本不大，因此主要是在项目应用前可以先和团队进行价格分析，从价格入手让团队尝试 Serverless 的应用，帮助团队/老板减少费用占用问题。Serverless 在多方面是可以减少我们项目的维护成本，我们只需要关注服务开发即可，因此是能够大大的节省人力和资源，在小型公司更建议你尝试应用。</p>\n<p data-nodeid="101610">到此为止，本专栏的知识点部分已经全部介绍完了，今天给你留的作业是：应用本框架开发一个新的接口，并按照本课时的内容部署到 Serverless 云服务上。</p>',
        article_title: "19 | Serverless 的实践：进一步提升系统的稳定性",
        title: "19 | Serverless 的实践：进一步提升系统的稳定性",
        id: 6801,
      },
    ],
  },
  {
    chapterTitle: "结束语",
    children: [
      {
        content:
          '<p data-nodeid="881" class="">到今天为止，你已经学完了本专栏的全部内容，最后我想和你分享一个稍微轻松的话题：如何最小路径学习一门新技术？希望你能有所收获。</p>\n<p data-nodeid="882">首先我们要了解清楚什么是“最小路径”，我自己理解是能够从本质出发，剖析出这门技术的所有需要掌握的知识点，然后提炼出核心的技术实现，只针对这部分核心的知识进行深入学习，并扩充自己基础技术框架的技能点，从而达到掌握这门技术的目的的学习路径。</p>\n<p data-nodeid="883">我在面试候选人时，经常会问这样一个问题：“<strong data-nodeid="991">如果你要学习一门新的技术，比如 Node.js，你该怎么学？</strong>”</p>\n<p data-nodeid="884">大部分的候选人给出的答案都很雷同：</p>\n<ol data-nodeid="885">\n<li data-nodeid="886">\n<p data-nodeid="887">首先了解这是什么技术（查看一些技术类文章博客）；</p>\n</li>\n<li data-nodeid="888">\n<p data-nodeid="889">查看官方文档，走一下简单的 demo ，以及文档中的部分 API ；</p>\n</li>\n<li data-nodeid="890">\n<p data-nodeid="891">接着去实践一个测试项目（也称为踩坑记），熟悉这门技术；</p>\n</li>\n<li data-nodeid="892">\n<p data-nodeid="893">最后去了解深层的源码实现。</p>\n</li>\n</ol>\n<p data-nodeid="894">以上也是我一开始学习 Node.js 的路径，而当我学习了 PHP、Java、React、Flutter 以及 Swift 后，我发现技术都有共通的地方。我希望你意识到这一点，并在面试时，能向面试官展现你的学习技巧。</p>\n<p data-nodeid="895">你要先把技术分为三类。</p>\n<ul data-nodeid="896">\n<li data-nodeid="897">\n<p data-nodeid="898">编程语言类： PHP、Java、Go、Kotlin、JavaScript、Dart、Object-C、Swift……</p>\n</li>\n<li data-nodeid="899">\n<p data-nodeid="900">技术框架类：React、Node.js……</p>\n</li>\n<li data-nodeid="901">\n<p data-nodeid="902">技术服务类：Redis、Kafka、MQ……</p>\n</li>\n</ul>\n<p data-nodeid="903">接下来，我会带你了解前两类的学习方法，前两者需要学习的成本和时间都比较多，而技术服务类的一般掌握应用起来周期比较短。</p>\n<h3 data-nodeid="904">学习路径</h3>\n<p data-nodeid="905">对于语言和技术框架，你要了解这样几个本质的知识点：</p>\n<ul data-nodeid="906">\n<li data-nodeid="907">\n<p data-nodeid="908">编程语言的本质；</p>\n</li>\n<li data-nodeid="909">\n<p data-nodeid="910">前端/后台的本质；</p>\n</li>\n<li data-nodeid="911">\n<p data-nodeid="912">程序员的本质。</p>\n</li>\n</ul>\n<h4 data-nodeid="913">编程语言的本质</h4>\n<p data-nodeid="914">你应该知道，编程语言的本质就是把可描述的自然语言转为机器可运算解读的二进制，那么在这个过程中你要对编程语言有足够的认识：</p>\n<ul data-nodeid="915">\n<li data-nodeid="916">\n<p data-nodeid="917">语言转化为可运算的二进制应该掌握哪些基础；</p>\n</li>\n<li data-nodeid="918">\n<p data-nodeid="919">编程语言是如何去执行的；</p>\n</li>\n<li data-nodeid="920">\n<p data-nodeid="921">这门语言的特点和规范是什么；</p>\n</li>\n</ul>\n<p data-nodeid="922">我所提及的基础，就是编程语言的数据类型、流程控制、运算方式、异常处理、并行串行、面向对象以及面向函数等。</p>\n<p data-nodeid="923">举个例子，假如你想学 Dart 语言，那么你就要先了解它包含的基础数据类型，基础数据类型的申明，基础类型的应用场景。接下来就是流程控制，流程控制对于各种编程语言来说，都是非常相似的，比如说 if...else 、for...in 、switch……对于这类的知识点尽量学习其与众不同的部分，不用面面俱到，只需要了解其差异点即可。运算方式的话，每种语言也都比较相同；而并行串行，每种语言的处理方式都会不同，你需要深入了解，最后的面向对象、面向函数，每门语言也基本相似。</p>\n<p data-nodeid="924">所以，关于“基础”每门语言都是相通的，只要你有编程基础，就可以去学习并且掌握。</p>\n<p data-nodeid="925">关于“如何执行”，主要考虑是解释型语言还是脚本类语言？多进程还是单进程？多线程还是单线程、底层的代码机制是如何执行的？</p>\n<p data-nodeid="926">举个例子，如果你想学习 Go 语言，那么你应该了解它是多线程，并且其包含了一个协程（ goroutine ），所谓的一个 M 比 N 的模型（GMP模型），那么 M 比 N 应该如何去调度执行呢？通过探究“如何执行”的问题，你就会去深入了解和学习这门技术的深层次知识，而不是掌握其命令行运行方式。</p>\n<p data-nodeid="927">关于“语言特点和规范”，每一门语言都不同，比如你熟悉的 JavaScript，它是弱类型的语言，知道这一点后，你就要注意弱类型使用时要对其进行严格的校验，避免异常。语言的规范就是我们的根基，每一种语言的规范都有所不同，不管是变量、常量、函数、类命名还是使用上都存在不同，而这也是学习一门语言必须要掌握的知识。</p>\n<p data-nodeid="928">相信你只要掌握了这三个方面，就可以掌握编程语言的技术了。</p>\n<h4 data-nodeid="929">前端的本质</h4>\n<p data-nodeid="930">我自己经过了长时间的分析和提炼，总结了前端的本质：</p>\n<ol data-nodeid="931">\n<li data-nodeid="932">\n<p data-nodeid="933">视图布局；</p>\n</li>\n<li data-nodeid="934">\n<p data-nodeid="935">视图交互；</p>\n</li>\n<li data-nodeid="936">\n<p data-nodeid="937">数据流转；</p>\n</li>\n<li data-nodeid="938">\n<p data-nodeid="939">用户体验；</p>\n</li>\n</ol>\n<p data-nodeid="940">关于视觉布局，你应该去学习这门技术视图包含哪些基础组件，比如说列表、Form 表单、图片、动画等；另外，布局是用什么方式进行的，比如静态、流式、响应式以及弹性等。以上是前端比较通用的技术，只要你掌握了这些内容，学习其他语言是非常轻松的。</p>\n<p data-nodeid="941">而对前端来说，视图交互无非是事件类型（事件生成者）、事件响应（事件消费者）以及事件流（事件传递者）三个事件对象。</p>\n<ul data-nodeid="942">\n<li data-nodeid="943">\n<p data-nodeid="944"><strong data-nodeid="1032">事件类型包含：</strong> 点击事件、滑动事件、拖拽事件、输入事件……而前端这类事件都是共通的，因为人机交互的方式也就这些。</p>\n</li>\n<li data-nodeid="945">\n<p data-nodeid="946"><strong data-nodeid="1037">事件响应包含：</strong> 路由跳转、数据处理转化、数据提交、事件转发……路由跳转对于前端来说是比较核心的部分，但是原理相似，主要是 URL 、Deep link 、Scheme 、Universal link 、 内部的 Action 机制……</p>\n</li>\n<li data-nodeid="947">\n<p data-nodeid="948"><strong data-nodeid="1042">事件转发包含：</strong> 冒泡机制、事件捕获和事件委托，对前端来说都是非常相似的技术点。</p>\n</li>\n</ul>\n<p data-nodeid="949">关于数据流转，会涉及数据的网络模块、传输协议、存储和管理、本地存储技术、数据的动态响应等。</p>\n<ul data-nodeid="950">\n<li data-nodeid="951">\n<p data-nodeid="952"><strong data-nodeid="1048">网络模块：</strong> 每个技术都有该模块，并且都会有一些不同的处理原则，比如说同步返回还是异步获取。</p>\n</li>\n<li data-nodeid="953">\n<p data-nodeid="954"><strong data-nodeid="1053">传输协议：</strong> 无非就是 JSON、XML 和 Protobuff ，当然也存在自定义的消息二进制数据。</p>\n</li>\n<li data-nodeid="955">\n<p data-nodeid="956"><strong data-nodeid="1058">本地存储技术：</strong> 前端的各类技术中都有所不同，也分为私密的和公开的，那么在应用时也应该区分开来。</p>\n</li>\n<li data-nodeid="957">\n<p data-nodeid="958"><strong data-nodeid="1063">数据响应：</strong> 目前就包含我们比较熟悉的 MVVM 的 VM 模块。</p>\n</li>\n</ul>\n<p data-nodeid="959">而前端最重要的目标就是用户体验，所以用户体验是任何前端技术的核心部分，你要考虑“用户体验的指标怎么去衡量？”不过每一种技术衡量的指标都相似，比如首屏渲染时长、FPS、事件响应延时……</p>\n<p data-nodeid="960">那怎么去获取这些用户体验的性能指标，并且上报监控呢？这是你需要了解的，比如 Web 有 performance 对象。其次，使用什么工具化方式来调试以及优化用户体验指标的数据，也是你需要了解和掌握的部分，比如前端有 Chrome 、Flutter 有 DevTools 。</p>\n<p data-nodeid="961">以上就是前端的本质，掌握这些本质的知识以后，你学习一门新的技术往往是比较容易的，比如说现在都是人操作交互，假设以后靠神经传输交互，那么视图交互还是没有变，变的主要是交互方式。</p>\n<h4 data-nodeid="962">程序员的本质</h4>\n<p data-nodeid="963">程序员的本质我认为是高质量、高效率、高扩展。我认为，如果你没有追求这三个方面，你还是不够努力。那么为了做好这三方面，你要掌握哪些技术点呢？</p>\n<ul data-nodeid="964">\n<li data-nodeid="965">\n<p data-nodeid="966"><strong data-nodeid="1073">高质量：</strong> 包括单元测试、自动化测试、性能压测工具、性能检测工具、异常检测上报、异常告警、安全扫描、安全保护策略……</p>\n</li>\n</ul>\n<p data-nodeid="967">有了以上知识，你再套用一下新的技术，假设你要学习 iOS 技术开发，那么就应该去学习其单元测试的方法（XCTest）、UI 自动化测试工具（Appium）、性能压测工具（instrument）、性能检测工具（instrument）、异常检测上报和告警（firebase 平台）、安全扫描和安全保护策略（passionfruit 和其他云平台服务）。你也可以把它套用在 Web 技术和 Flutter 上……</p>\n<ul data-nodeid="968">\n<li data-nodeid="969">\n<p data-nodeid="970"><strong data-nodeid="1079">高效率：</strong> 包括工程化（指工程化工具比如 webpack ，包体积优化、打包时间优化方案）；和工具化（比如前端技术中的多国家地区多语言、埋点自动化、IDE……）。</p>\n</li>\n<li data-nodeid="971">\n<p data-nodeid="972"><strong data-nodeid="1084">高扩展：</strong> 包括组件化、框架（生命周期、分层结构、原理实现）、设计模式、架构模式（MVC、MVVM、KVO、MVP）、库包管理……相信你应该熟悉这些基础。</p>\n</li>\n</ul>\n<p data-nodeid="1531">当你学习新技术时，只需要扩充这部分的知识体系就足够了。为了帮助你梳理内容，建立整个框架，我整理了一张思维导图，如图 1 所示。</p>\n<p data-nodeid="1532" class="te-preview-highlight"><img src="https://s0.lgstatic.com/i/image6/M00/3E/52/CioPOWCY3O2AfqpLAAQW5ovFSIo859.png" alt="图片2.png" data-nodeid="1537"></p>\n<div data-nodeid="1533"><p style="text-align:center">图 1 最小路径学习新技术思维导图</p></div>\n\n\n\n\n<h3 data-nodeid="976">专栏体会</h3>\n<p data-nodeid="977">之所以分享我的学习路径，是希望你在学习课程时，掌握学习后台编程的本质，在课程设计中，我都是在根据学习路径和你一起学习。以我们本专栏学习的 Node.js 为例，我们首先学习了 Node.js 单线程的事件循环原理，这部分就是编程语言的本质中所需要掌握的部分，然后在后台的本质中，用户体验以及性能是非常关键的点，所以我们用了大量的时间在讲性能的问题和优化策略。</p>\n<p data-nodeid="978">再比如程序员的本质，我们学习了框架以及原理，介绍了安全、安全检测和防护方法以及工具化、自动化方案……</p>\n<h3 data-nodeid="979">直击本质</h3>\n<p data-nodeid="980">上面的学习路径是我近期的一个思考，也是我学习 Flutter 这门技术的一个缩影，而灵感来源于《直击本质》这本书。你在学习一门新的前端或者后台技术时，首先要去探索该技术方向的本质特征，在此基础上思考要掌握哪些基础要素。只要把这些基础技术要点掌握后，我相信当遇到一门新的技术或者新的方向时，只需要在原来的技术面之上，拓展基础技术点就可以了，那样学习速度会比别人快很多。</p>\n<p data-nodeid="981">那么假设让你学习 Flutter 这个新的前端技术时，你应该如何去学习掌握好这门技术呢？相信看到这里以后你心中一定有答案了，欢迎分享你的想法。</p>\n<p data-nodeid="982">最后，我为你准备了一份结课问卷，希望你对本课程的内容进行评价，以便我及时优化课程内容。</p>\n<p data-nodeid="983" class=""><a href="https://wj.qq.com/s2/8431305/6925" data-nodeid="1098">点击链接，即可参与课程评价</a>。</p>',
        article_title: "结束语 | 如何规划自己的 Node.js 学习之路？",
        title: "结束语 | 如何规划自己的 Node.js 学习之路？",
        id: 6802,
      },
    ],
  },
];
