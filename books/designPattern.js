exports.category = 'architect'
exports.title = '设计模式之美'
exports.data = [
    {
        "chapterTitle": "开篇词 (1讲)",
        "children": [
            {
                "title": "开篇词 | 一对一的设计与编码集训，让你告别没有成长的烂代码！",
                "herf": "https://time.geekbang.org/column/article/160463",
                "id": "160463",
                "content": "<p>你好，我是王争，是“<a href=\"https://time.geekbang.org/column/intro/126?utm_term=zeusNGLWQ&amp;utm_source=xiangqingye&amp;utm_medium=geektime&amp;utm_campaign=end&amp;utm_content=xiangqingyelink1104\">数据结构与算法之美</a>”专栏的作者。“数据结构与算法之美”专栏在今年2月底全部更新完毕。时隔8个月，我又给你带来了一个新的专栏“设计模式之美”。<strong>如果说“数据结构与算法之美”是教你写出高效的代码，那这个设计模式专栏就是教你写出高质量的代码</strong>。</p><h2>程序员的看家本领你得练好</h2><p>研究生毕业后我就加入了Google，至今我还清晰地记得，我第一次提交代码的时候，短短的100多行代码，被同事review出了n多问题，来来回回改了不下十几个版本才提交上去。我当时有很大的逆反心理，觉得有必要浪费这么多时间在如此细节的编码上吗？只要代码能用、能解决问题不就够了吗？</p><p>工作一段时间之后，我才发现自己当时的想法有多幼稚。</p><p>写代码可以说是程序员天天要干的事情，要是代码都写不好，最基本的看家本领都练不好，成天堆砌烂代码，写代码还有啥意思呢？那还干啥程序员啊！写出“能用”代码的人比比皆是，但是，并不是每个人都能写出“好用”的代码。只会写能用的代码，我们永远成长不成大牛，成长不成最优秀的那批人。</p><p>后来我熟练掌握了各种编写高质量代码的技巧、方法和理论，我发现，实际上，写烂代码和好代码花费的时间是差不多的。当你把写高质量代码培养成一种开发习惯之后，在你在编写代码的时候，自然就有一种代码质量意识，自然而然就可以写出不错的代码。即便在我离开Google加入其他公司之后，项目的代码质量因为各种原因有所妥协，但我起码知道什么样的代码是高质量代码，丝毫不影响我具备写出高质量代码的能力。</p><!-- [[[read_end]]] --><p>我相信，很多工程师都很重视代码质量，毕竟谁也不想写被人吐槽的烂代码。但是，就我的了解来看，毫不夸张地讲，很多工程师，甚至一些BAT的员工，代码都写得惨不忍睹。一方面，在目前这种快糙猛的开发环境下，很多工程师并没有太多时间去思考如何写高质量代码；另一方面，在烂代码的熏陶下，在没有人指导的环境里，很多工程师也搞不大清楚高质量代码到底长什么样。</p><p>这就导致很多工程师写了多年代码，代码功力一点都没长进，编写的代码仍然只是能用即可，能运行就好。平日的工作就是修修补补、抄抄改改，一直在做重复劳动，能力也一直停留在“会干活”的层面，就像高速路上的收银员，只能算是一个“熟练工”。</p><h2>一个人闷头看书效果并不好</h2><p>当然，也有一些比较上进的工程师，会去找设计模式、编码规范、重构等类型的书籍去看，学习如何编写高质量的代码。实际上，我也买了很多这类的书籍来看，从这些经典的书籍中，我也学到了很多编程技巧和提高代码质量的方法。</p><p>不过，这些书籍都有一个特点，那就是比较偏重理论讲解，喜欢拿猫、狗之类生活中的例子来举例。当然，这样的例子也有优点，那就是能在简短的时间和篇幅内，很好地帮你理解原理。但同时也存在一个严重的问题，那就是过于脱离真实的软件开发。而且例子本身没有难度，你一看就觉得懂了，但是看完之后，可能还是不清楚如何将理论落地到实际的项目编码中。</p><p>比如，我们都知道著名的KISS原则（Keep It Simple and Stupid）。这个原则理解起来很简单，一看貌似就懂了，那我问你，怎样的代码才算是足够简单呢？怎样才算不够简单需要优化呢？估计很多人都回答不上来，因为大部分书籍都没有讲清楚。</p><p>除此之外，一个人自己闷头看书，在很多时候效果并不好。一方面，每个人的理解能力是不一样的。对于同一本书，不同理解能力的人看完之后收获也是不一样的。跟着有经验的老师学比闷头自己看书要更高效、收获更多、成长更快。另一方面，编码本身就是一门实践课，光闷头看书本理论肯定是不够的，更重要的是在实践中学习如何应用这些理论。</p><h2>一对一手把手指导才最有效</h2><p>从我的经验来看，我觉得最有效、最快速提高编码能力的方法就是，找一个比你资深的工程师，一对一、手把手地指导你写代码。你提交代码，他来指出你的问题，你再优化，这样一来一往，要不了多久，你就会发现，自己的代码能力突飞猛进。</p><p>但是，理想很丰满，现实很骨感。且不说能不能找到这样有资格指导你的人，即便能找到，他愿不愿意、有没有时间来手把手指导你，还是另外一回事。而我比较幸运，在毕业之后就加入了Google，得到了顶尖工程师的指导，一对一地给我review代码，手把手地指导我如何优化代码。正因如此，在Google的那段时间也成为了我编码能力提高最快的一段时间。</p><p>所以，在设计专栏的初期，我就在想，如果我能模拟这样一个一对一、手把手、就真实项目代码讲解的场景，是不是就能让专栏有别于千篇一律的书籍，从而能真正提高你的代码能力呢？基于这样一个想法，我们接下来就来看，我是如何设计整个专栏内容的。</p><h2>我是如何设计这个专栏的？</h2><h3>100多篇文章、50万字、2万多行代码</h3><p>整个专栏的文章总共有100多篇，每篇平均下来在5000字左右，所以你总共需要学习50万字。为什么篇幅会这么多？这是因为，<strong>我想一次性把跟编写高质量代码相关的所有知识，都系统、全面地讲清楚，一次性给你讲透彻。你看完我这一个专栏，就能搞清楚所有跟写高质量代码相关的知识点。</strong></p><p>除此之外，为了避免脱离代码，空洞地讲理论，专栏每篇文章平均大约有200多行代码，整个专栏累计有2万多行代码。而且，这些代码都来自我这十几年积累的真实项目，而非编造出来的阿猫阿狗、停车场、餐厅之类的没有太多实际意义的代码。</p><p>我个人写Java代码比较多，所以，专栏中的代码我是用Java语言实现的。不过，在设计专栏的时候，我已经考虑到其他不熟悉Java语言的小伙伴了。我力争做到，实际上我觉得也已经做到，一方面，专栏内容的讲解并不与具体的编程语言挂勾；另一方面，我只用最基本、最简单的Java语法，只要你有一些编程基础，不管你熟悉的是哪种编程语言，都可以看懂我写的代码，理解代码背后的设计思想。</p><p>所以，如果你熟悉的不是Java，而是C++、C#、PHP、Python、Go、Ruby、JavaScript等其他编程语言，不要担心，这完全不会影响你学习这个专栏。</p><h3>200多个真实的项目实战代码案例剖析</h3><p>实际上，大部分设计原则、设计思想、设计模式理解起来都不难，难的是如何将这些理论灵活恰当地应用到实际的开发中，而不是教条主义和盲目滥用。而要想正确、得当地应用理论知识，光看书是不够的，我们要在实战中去亲身感受、体会这些理论该如何应用。但是，我们平时的开发更多的是基于已有的框架，照着别人的流程，扩展新的功能模块。所以，在工作中就可能没有那么多足够复杂、足够有难度的开发场景，让我们有机会去实践这些理论。</p><p>基于这种考虑，我结合自己过去工作中积累的项目经验，为整个专栏精心设计了200多个真实的项目实战代码案例。几乎每节课、每个知识点都会结合一个完整的开发案例来讲解。我们知道，刷算法最出名的就属LeetCode了。类比一下的话，我这200多个开发案例足以称得上是一个锻炼编写高质量代码的“LeetCode”了。跟着我一起把这200多个开发案例练下来，不愁代码能力提高不了！</p><h3>8个月、240天一对一手把手编程指导</h3><p>前面我有提到，提高自己编码能力，最有效的手段就是让有经验的前辈一对一、手把手地指导。我经历过Google最严格的Code Review，也被最顶尖的工程师指导过，也见识过最优秀的代码长什么样子，而且自己平时也比较重视代码质量，所以，我觉得我还是有挺多写代码方面的心得体会可以分享给你的。</p><p>而且，看过“数据结构与算法之美”专栏的小伙伴都知道，我这个人最大的特点就是逻辑清晰，能抓住要点把问题讲透彻。所以，对于专栏中的理论解读，我并不会照搬那些经典的大部头书籍，而是更多地融入我自己的思考和理解。或许我的解读会跟大师的不完全一样，但我都可以自成一体，并且告诉你如何落地指导具体的开发、编码，而不是很鸡汤地浮在表面来讲，让你听的时候感觉好像都懂了，感觉思想好像得到了升华，而合上书就又忘得一干二净，更别提应用到项目中了。</p><p>当然，除了理论解读之外，对于每一种设计原则、思想或者模式，我还会讲一些更深入、更本质、更有用的东西，比如，“为什么要有这种设计原则、思想或者模式？它能解决什么编程问题？有哪些应用场景？又该如何权衡、恰当地在项目中应用？”等等。</p><p>在讲解每个实战案例的时候，我会从最原始的问题代码讲起，然后告诉你缺陷在哪里，如何通过设计原则、思想、模式来优化，让你知其然知其所以然，了解背后设计的来龙去脉。我觉得，这比单纯只告诉最终的设计结果要重要得多。我也希望，你不光是被动地听我讲，而是能跟着我的节奏主动地去思考，这对你的逻辑思维训练也会很有帮助。毕竟，对于成天跟程序逻辑打交道的程序员来说，逻辑思维能力是一项非常重要的能力。我们平时要多多加强这方面的锻炼。</p><p>除此之外，专栏内容的讲解，我也刻意模拟这种一对一指导的感觉。虽然我没法真正坐在你的面前，跟你一块讨论原理、分析如何优化代码，但我力争让你在看或者听专栏的时候，就好像我在你的面前，跟你一块讨论问题一样。 整个专栏有100多篇文章，一周更新3篇，需要持续更新8个多月、240多天。这就相当于我手把手指导你8个月写代码。我希望通过这8个月的指导，能把我十几年的积累统统传授给你。</p><h3>100多个有深度的课堂讨论、头脑风暴</h3><p>我们知道，设计问题本来就没有标准答案。 所以，不要轻信一家之言，更不要迷信我的专栏，也不要盲目追从任何一位专家、大师的说法。主动思考，积极讨论，比单纯地被动接受，学习效果要好十倍、百倍。</p><p>所以，在每节课的最后，我都设计了1～2道课堂讨论题，这些题目有些是代码设计相关的开放性问题，有些是具体的代码优化问题。看过我“数据结构与算法之美”专栏的小伙伴们都知道，专栏的思考题和同学们的留言，有的时候比专栏文章本身还要精彩。所以，对于这个专栏，我也希望你能积极参与，发表自己的观点。</p><p>如果你在学习完每节课程之后，都能花5分钟、10分钟的时间去思考一下课堂讨论问题。这不仅对课程知识的学习很有帮助，还能锻炼你的思考能力。你要知道，独立思考能力对一个人来说是多么重要啊！</p><h2>让我们一起见证成长</h2><p>我个人觉得，“数据结构与算法之美”和“设计模式之美”是两门跟我们每天的编程开发，直接关系非常大的课程，是两门奠定一个工程师最基本的代码能力的课程。它们一个教你如何写高效代码，一个教你如何写高质量代码。弄懂了这两门课的内容，在今后的开发中，你就不需要担心写出被人吐槽的烂代码了，甚至还能让你的代码成为职场发展的一个加分项和闪光点。</p><p>前面讲到，专栏要持续更新8个月的时间，你可能会觉得时间好长。实际上，只要跟着专栏更新的节奏，每周认真学好3节课，稳扎稳打，8个月一眨眼就过去了。而经过这8个月的刻意编码训练，我相信，你会发现自己因为这样的坚持学习成长了很多，不仅代码能力会提高几个档次，或许还能养成一种好的学习习惯。</p><p>最后，今天是开篇，你可以做个自我介绍，立个学习flag。当然，你也可以留下你对专栏的期待和建议。</p><p>说起来连续8个月坚持学习，不是件容易事，而和志同道合的小伙伴一起，更容易找到学习的乐趣。为此，我在“极客时间小程序”发起了“8个月，攻克设计模式”的学习打卡活动。我可以向你保证，这8个月只要你跟着我的节奏，踏踏实实走下来，你的代码能力一定能有一个质的飞跃。</p><p>欢迎加入，让我们一起见证成长！</p>",
                "article_title": "开篇词 | 一对一的设计与编码集训，让你告别没有成长的烂代码！"
            }
        ]
    },
    {
        "chapterTitle": "设计模式学习导读 (3讲)",
        "children": [
            {
                "title": "01 | 为什么说每个程序员都要尽早地学习并掌握设计模式相关知识？",
                "herf": "https://time.geekbang.org/column/article/160981",
                "id": "160981",
                "content": "<p>我相信，很多程序员都已经意识到基础知识的重要性，觉得要夯实基础，才能走得更远，但同时对于如何将基础知识转化成开发“生产力”仍然有些疑惑。所以，你可能看了很多基础的书籍，比如操作系统、组成原理、编译原理等，但还是觉得很迷茫，觉得在开发中用不上，起码在平时的CRUD业务开发中用不上。实际上，这些基础的知识确实很难直接转化成开发“生产力”。但是，它能潜移默化地、间接地提高你对技术的理解。</p><p>不过，我觉得，设计模式和操作系统、组成原理、编译原理等这些基础学科是不一样的。它虽然也算是一门基础知识，但是它和数据结构、算法更像是一道儿的，相比那些更加基础的学科，设计模式能更直接地提高你的开发能力。我在开篇词里也说了，如果说数据结构和算法是教你如何写出高效代码，那设计模式讲的是如何写出可扩展、可读、可维护的高质量代码，所以，它们跟平时的编码会有直接的关系，也会直接影响到你的开发能力。</p><p>不过，你可能还是会觉得设计模式是把屠龙刀，看起来很厉害，但平时的开发根本用不上。基于这种观点，接下来，我们就具体地聊一聊，我们为什么要学习设计模式？</p><h2>1. 应对面试中的设计模式相关问题</h2><p>学习设计模式和算法一样，最功利、最直接的目的，可能就是应对面试了。</p><!-- [[[read_end]]] --><p>不管你是前端工程师、后端工程师，还是全栈工程师，在求职面试中，设计模式问题是被问得频率比较高的一类问题。特别是一些像BAT、TMD这样的大公司，比较重视候选人的基本功，经常会拿算法、设计模式之类的问题来考察候选人。</p><p>所以，我在求职面试的时候，都会提前准备、温习一遍设计模式。尽管并不是每次面试都会被问到，但一旦被问到，如果回答得不好，就是一个败笔，这场面试基本上也就凉凉了。所以，为了保证万无一失，摆脱一旦被问到答不出来的窘境，对于设计模式这种大概率被问到的问题，我都会未雨绸缪，提前准备一下。</p><p>当然，我并不是临时抱佛脚。我平时就比较重视设计模式相关知识的积累，所以底子比较好，只需要在每次面试前花很短的时间，重新温习一下，便可以自信满满地去面试，而不是心里老是担心被问到，影响正常的面试发挥。</p><p>所以，如果你也不想让设计模式相关问题成为你面试中的短板，那跟着我把专栏中的知识点都搞清楚，以后面试再遇到设计模式相关的问题，就不会惧怕了，甚至还会成为你面试中的亮点。</p><h2>2. 告别写被人吐槽的烂代码</h2><p>我们经常说，“Talk is cheap，show me the code。”实际上，代码能力是一个程序员最基础的能力，是基本功，是展示一个程序员基础素养的最直接的衡量标准。你写的代码，实际上就是你名片。</p><p>尽管我已经工作近十年，但我一直没有脱离编码一线，现在每天也都在坚持写代码、review指导同事写代码、重构遗留系统的烂代码。这些年的工作经历中，我见过太多的烂代码，比如命名不规范、类设计不合理、分层不清晰、没有模块化概念、代码结构混乱、高度耦合等等。这样的代码维护起来非常费劲，添加或者修改一个功能，常常会牵一发而动全身，让你无从下手，恨不得将全部的代码删掉重写！</p><p>当然，在这些年的工作经历中，我也看到过很多让我眼前一亮的代码。每当我看到这样的好代码，都会立刻对作者产生无比的好感和认可。且不管这个人处在公司的何种级别，从代码就能看出，他是一个基础扎实的高潜员工，值得培养，前途无量！因此，代码写得好，能让你在团队中脱颖而出。</p><p>所以，我的专栏，不仅仅只是讲解设计模式，更加重要的是，我会通过实战例子，手把手教你如何避免刚刚提到的代码问题，告别被人诟病的烂代码，写出令人称道的好代码，成为团队中的代码标杆！而且，写出一份漂亮的代码，你自己也会很有成就感。</p><h2>3. 提高复杂代码的设计和开发能力</h2><p>大部分工程师比较熟悉的都是编程语言、工具、框架这些东西，因为每天的工作就是在框架里根据业务需求，填充代码。实际上，我刚工作的时候，也是做这类事情。相对来说，这样的工作并不需要你具备很强的代码设计能力，只要单纯地能理解业务，翻译成代码就可以了。</p><p>但是，有一天，我的leader让我开发一个跟业务无关的比较通用的功能模块，面对这样稍微复杂的代码设计和开发，我就发现我有点力不从心，不知从何下手了。因为我知道只是完成功能、代码能用，可能并不复杂，但是要想写出易扩展、易用、易维护的代码，并不容易。</p><p>如何分层、分模块？应该怎么划分类？每个类应该具有哪些属性、方法？怎么设计类之间的交互？该用继承还是组合？该使用接口还是抽象类？怎样做到解耦、高内聚低耦合？该用单例模式还是静态方法？用工厂模式创建对象还是直接new出来？如何避免引入设计模式提高扩展性的同时带来的降低可读性问题？……各种问题，一下子挤到了我面前。</p><p>而我当时并没有对设计模式相关的知识（包括设计模式、设计原则、面向对象设计思想等）有太多的了解和积累，所以一时间搞得我手足无措。好在因此我意识到了这方面知识的重要性，所以在之后很多年的开发中，我都一直刻意锻炼、积累这方面的能力。面对复杂代码、功能、系统的设计和开发，我也越来越得心应手，游刃有余。写出高质量代码已经成为了我的习惯，不经意间写出来的代码，都能作为同事学习、临摹的范例，这也成为了我职场中最引以为豪的亮点之一。</p><h2>4. 让读源码、学框架事半功倍</h2><p>对于一个有追求的程序员来说，对技术的积累，既要有广度，也要有深度。很多技术人早早就意识到了这一点，所以在学习框架、中间件的时候，都会抽空去研究研究原理，读一读源码，希望能在深度上有所积累，而不只是略知皮毛，会用而已。</p><p>从我的经验和同事的反馈来看，有些人看源码的时候，经常会遇到看不懂、看不下去的问题。不知道你有没有遇到过这种情况？实际上，这个问题的原因很简单，那就是你积累的基本功还不够，你的能力还不足以看懂这些代码。为什么我会这么说呢？</p><p>优秀的开源项目、框架、中间件，代码量、类的个数都会比较多，类结构、类之间的关系极其复杂，常常调用来调用去。所以，为了保证代码的扩展性、灵活性、可维护性等，代码中会使用到很多设计模式、设计原则或者设计思想。如果你不懂这些设计模式、原则、思想，在看代码的时候，你可能就会琢磨不透作者的设计思路，对于一些很明显的设计思路，你可能要花费很多时间才能参悟。相反，如果你对设计模式、原则、思想非常了解，一眼就能参透作者的设计思路、设计初衷，很快就可以把脑容量释放出来，重点思考其他问题，代码读起来就会变得轻松了。</p><p>实际上，除了看不懂、看不下去的问题，还有一个隐藏的问题，你可能自己都发现不了，那就是你自己觉得看懂了，实际上，里面的精髓你并没有get到多少！因为优秀的开源项目、框架、中间件，就像一个集各种高精尖技术在一起的战斗机。如果你想剖析它的原理、学习它的技术，而你没有积累深厚的基本功，就算把这台战斗机摆在你面前，你也不能完全参透它的精髓，只是了解个皮毛，看个热闹而已。</p><p>因此，学好设计模式相关的知识，不仅能让你更轻松地读懂开源项目，还能更深入地参透里面的技术精髓，做到事半功倍。</p><h2>5. 为你的职场发展做铺垫</h2><p>普通的、低级别的开发工程师，只需要把框架、开发工具、编程语言用熟练，再做几个项目练练手，基本上就能应付平时的开发工作了。但是，如果你不想一辈子做一个低级的码农，想成长为技术专家、大牛、技术leader，希望在职场有更高的成就、更好的发展，那就要重视基本功的训练、基础知识的积累。</p><p>你去看大牛写的代码，或者优秀的开源项目，代码写得都非常的优美，质量都很高。如果你只是框架用得很溜，架构聊得头头是道，但写出来的代码很烂，让人一眼就能看出很多不合理的、可以改进的地方，那你永远都成不了别人心目中的“技术大牛”。</p><p>再者，在技术这条职场道路上，当成长到一定阶段之后，你势必要承担一些指导培养初级员工、新人，以及code review的工作。这个时候，如果你自己都对“什么是好的代码？如何写出好的代码？”不了解，那又该如何指导别人，如何让人家信服呢？</p><p>还有，如果你是一个技术leader，负责一个项目整体的开发工作，你就需要为开发进度、开发效率和项目质量负责。你也不希望团队堆砌垃圾代码，让整个项目无法维护，添加、修改一个功能都要费老大劲，最终拉低整个团队的开发效率吧？</p><p>除此之外，代码质量低还会导致线上bug频发，排查困难。整个团队都陷在成天修改无意义的低级bug、在烂代码中添补丁的事情中。而一个设计良好、易维护的系统，可以解放我们的时间，让我们做些更加有意义、更能提高自己和团队能力的事情。</p><p>最后，当你成为leader、或者团队中的资深工程师、技术专家之后，你势必要负责一部分团队的招聘工作。这个时候，如果你要考察候选人的设计能力、代码能力，那设计模式相关的问题便是一个很好的考察点。</p><p>不过，我也了解到，很多面试官实际上对设计模式也并不是很了解，只能拿一些简单的单例模式、工厂模式来考察候选人，而且所出的题目往往都脱离实践，比如，如何设计一个餐厅系统、停车场系统、售票系统等。这些题目都是网上万年不变的老题目，几乎考察不出候选人的能力。在我的专栏中，有200多个真实项目开发中的设计模式相关问题，你跟着看下来，足以让你成为设计模式方面的大牛，再来面试候选人的时候，就不用因为题目老套、脱离实践而尴尬了！</p><h2>重点回顾</h2><p>今天，我们讲了为什么要学习设计模式相关的知识，总结一下的话，主要有这样五点：应对面试中的设计模式相关问题；告别写被人吐槽的烂代码；提高复杂代码的设计和开发能力；让读源码、学框架事半功倍；为你的职场发展做铺垫。</p><p>投资要趁早，这样我们才能尽早享受复利。同样，有些能力，要早点锻炼；有些东西，要早点知道；有些书，要早点读。这样在你后面的生活、工作、学习中，才能一直都发挥作用。不要等到好多年后，看到了，才恍然大悟，后悔没有早点去学、去看。</p><p>设计模式作为一门与编码、开发有着直接关系的基础知识，是你现在就要开始学习的。早点去学习，以后的项目就都可以拿来锻炼，每写一行代码都是对内功的利用和加深，是可以受益一整个职业生涯的事情。</p><h2>课堂讨论</h2><p>今天课堂讨论的话题有两个：</p><ol>\n<li>聊一聊你对设计模式相关知识的重要性的看法；</li>\n<li>在你过往的项目开发中，有没有用过某种设计模式？是在什么场景下应用的？解决了什么问题？</li>\n</ol><p>欢迎在留言区发表你的观点，积极参与讨论。你也可以把这篇文章分享给你的朋友，邀请他一起学习。</p>",
                "article_title": "01 | 为什么说每个程序员都要尽早地学习并掌握设计模式相关知识？"
            },
            {
                "title": "02 | 从哪些维度评判代码质量的好坏？如何具备写出高质量代码的能力？",
                "herf": "https://time.geekbang.org/column/article/160985",
                "id": "160985",
                "content": "<p>在我的工作经历中，每当同事评论起项目代码质量的时候，听到的最多的评语就是：“代码写得很烂”或者“代码写得很好”。用“好”“烂”这样的字眼来描述，非常地笼统。当我具体问到底如何烂、如何好的时候，尽管大部分同事都能简单地罗列上几个点，但往往都不够全面、非常零碎，也切不中要害。</p><p>当然，也有一些工程师对如何评价代码质量有所认识，比如，好代码是易扩展、易读、简单、易维护的等等，但他们对于这些评价的理解往往只停留在表面概念上，对于诸多更深入的问题，比如，“怎么才算可读性好？什么样的代码才算易扩展、易维护？可读、可扩展与可维护之间有什么关系？可维护中‘维护’两字该如何理解？”等等，并没有太清晰的认识。</p><p>对于程序员来说，辨别代码写得“好”还是“烂”，是一个非常重要的能力。这也是我们写出好代码的前提。毕竟，如果我们连什么是好代码、什么是烂代码，都分辨不清，又谈何写出好代码呢？</p><p>所以，今天我们就聊一聊关于代码质量评判的相关问题，希望你在学完今天的内容之后，对代码质量的评判有个更加清晰、更加透彻的认识和理解。</p><h2>如何评价代码质量的高低？</h2><p>实际上，咱们平时嘴中常说的“好”和“烂”，是对代码质量的一种描述。“好”笼统地表示代码质量高，“烂”笼统地表示代码质量低。对于代码质量的描述，除了“好”“烂”这样比较简单粗暴的描述方式之外，我们也经常会听到很多其他的描述方式。这些描述方法语义更丰富、更专业、更细化。我搜集整理了一下，罗列在了下面。这些几乎涵盖我们所能听到的描述代码质量的所有常用词汇，你可以看一看。</p><!-- [[[read_end]]] --><blockquote>\n<p>灵活性（flexibility）、可扩展性（extensibility）、可维护性（maintainability）、可读性（readability）、可理解性（understandability）、易修改性（changeability）、可复用（reusability）、可测试性（testability）、模块化（modularity）、高内聚低耦合（high cohesion loose coupling）、高效（high effciency）、高性能（high performance）、安全性（security）、兼容性（compatibility）、易用性（usability）、整洁（clean）、清晰（clarity）、简单（simple）、直接（straightforward）、少即是多（less code is more）、文档详尽（well-documented）、分层清晰（well-layered）、正确性（correctness、bug free）、健壮性（robustness）、鲁棒性（robustness）、可用性（reliability）、可伸缩性（scalability）、稳定性（stability）、优雅（elegant）、好（good）、坏（bad）……</p>\n</blockquote><p>看到如此多的描述词，你可能要问了，我们到底该用哪些词来描述一段代码的质量呢？</p><p>实际上，我们很难通过其中的某个或者某几个词汇来全面地评价代码质量。因为这些词汇都是从不同维度来说的。这就好比，对于一个人的评价，我们需要综合各个方面来给出，比如性格、相貌、能力、财富等等。代码质量高低也是一个综合各种因素得到的结论。我们并不能通过单一的维度去评价一段代码写的好坏。比如，即使一段代码的可扩展性很好，但可读性很差，那我们也不能说这段代码质量高。</p><p>除此之外，不同的评价维度也并不是完全独立的，有些是具有包含关系、重叠关系或者可以互相影响的。比如，代码的可读性好、可扩展性好，就意味着代码的可维护性好。而且，各种评价维度也不是非黑即白的。比如，我们不能简单地将代码分为可读与不可读。如果用数字来量化代码的可读性的话，它应该是一个连续的区间值，而非0、1这样的离散值。</p><p>不过，我们真的可以客观地量化一段代码质量的高低吗？答案是否定的。对一段代码的质量评价，常常有很强的主观性。比如，怎么样的代码才算可读性好，每个人的评判标准都不大一样。这就好比我们去评价一本小说写得是否精彩，本身就是一个很难量化的、非常主观的事情。</p><p>正是因为代码质量评价的主观性，使得这种主观评价的准确度，跟工程师自身经验有极大的关系。越是有经验的工程师，给出的评价也就越准确。相反，资历比较浅的工程师就常常会觉得，没有一个可执行的客观的评价标准作为参考，很难准确地判断一段代码写得好与坏。有的时候，自己觉得代码写得已经够好了，但实际上并不是。所以，这也导致如果没有人指导的话，自己一个人闷头写代码，即便写再多的代码，代码能力也可能一直没有太大提高。</p><h2>最常用的评价标准有哪几个？</h2><p>仔细看前面罗列的所有代码质量评价标准，你会发现，有些词语过于笼统、抽象，比较偏向对于整体的描述，比如优雅、好、坏、整洁、清晰等；有些过于细节、偏重方法论，比如模块化、高内聚低耦合、文档详尽、分层清晰等；有些可能并不仅仅局限于编码，跟架构设计等也有关系，比如可伸缩性、可用性、稳定性等。</p><p>为了做到有的放矢、有重点地学习，我挑选了其中几个最常用的、最重要的评价标准，来详细讲解，其中就包括：可维护性、可读性、可扩展性、灵活性、简洁性（简单、复杂）、可复用性、可测试性。接下来，我们逐一讲解一下。</p><h3>1.可维护性（maintainability）</h3><p>我们首先来看，什么是代码的“可维护性”？所谓的“维护代码”到底包含哪些具体工作？</p><p>落实到编码开发，所谓的“维护”无外乎就是修改bug、修改老的代码、添加新的代码之类的工作。所谓“代码易维护”就是指，在不破坏原有代码设计、不引入新的bug的情况下，能够快速地修改或者添加代码。所谓“代码不易维护”就是指，修改或者添加代码需要冒着极大的引入新bug的风险，并且需要花费很长的时间才能完成。</p><p>我们知道，对于一个项目来说，维护代码的时间远远大于编写代码的时间。工程师大部分的时间可能都是花在修修bug、改改老的功能逻辑、添加一些新的功能逻辑之类的工作上。所以，代码的可维护性就显得格外重要。</p><p>维护、易维护、不易维护这三个概念不难理解。不过，对于实际的软件开发来说，更重要的是搞清楚，如何来判断代码可维护性的好坏。</p><p>实际上，可维护性也是一个很难量化、偏向对代码整体的评价标准，它有点类似之前提到的“好”“坏”“优雅”之类的笼统评价。代码的可维护性是由很多因素协同作用的结果。代码的可读性好、简洁、可扩展性好，就会使得代码易维护；相反，就会使得代码不易维护。更细化地讲，如果代码分层清晰、模块化好、高内聚低耦合、遵从基于接口而非实现编程的设计原则等等，那就可能意味着代码易维护。除此之外，代码的易维护性还跟项目代码量的多少、业务的复杂程度、利用到的技术的复杂程度、文档是否全面、团队成员的开发水平等诸多因素有关。</p><p>所以，从正面去分析一个代码是否易维护稍微有点难度。不过，我们可以从侧面上给出一个比较主观但又比较准确的感受。如果bug容易修复，修改、添加功能能够轻松完成，那我们就可以主观地认为代码对我们来说易维护。相反，如果修改一个bug，修改、添加一个功能，需要花费很长的时间，那我们就可以主观地认为代码对我们来说不易维护。</p><p>你可能会说，这样的评价方式也太主观了吧？没错，是否易维护本来就是针对维护的人来说的。不同水平的人对于同一份代码的维护能力并不是相同的。对于同样一个系统，熟悉它的资深工程师会觉得代码的可维护性还不错，而一些新人因为不熟悉代码，修改bug、修改添加代码要花费很长的时间，就有可能会觉得代码的可维护性不那么好。这实际上也印证了我们之前的观点：代码质量的评价有很强的主观性。</p><h3>2.可读性（readability）</h3><p>软件设计大师Martin Fowler曾经说过：“Any fool can write code that a computer can understand. Good programmers write code that humans can understand.”翻译成中文就是：“任何傻瓜都会编写计算机能理解的代码。好的程序员能够编写人能够理解的代码。”Google内部甚至专门有个认证就叫作Readability。只有拿到这个认证的工程师，才有资格在code review的时候，批准别人提交代码。可见代码的可读性有多重要，毕竟，代码被阅读的次数远远超过被编写和执行的次数。</p><p>我个人认为，代码的可读性应该是评价代码质量最重要的指标之一。我们在编写代码的时候，时刻要考虑到代码是否易读、易理解。除此之外，代码的可读性在非常大程度上会影响代码的可维护性。毕竟，不管是修改bug，还是修改添加功能代码，我们首先要做的事情就是读懂代码。代码读不大懂，就很有可能因为考虑不周全，而引入新的bug。</p><p>既然可读性如此重要，那我们又该如何评价一段代码的可读性呢？</p><p>我们需要看代码是否符合编码规范、命名是否达意、注释是否详尽、函数是否长短合适、模块划分是否清晰、是否符合高内聚低耦合等等。你应该也能感觉到，从正面上，我们很难给出一个覆盖所有评价指标的列表。这也是我们无法量化可读性的原因。</p><p>实际上，code review是一个很好的测验代码可读性的手段。如果你的同事可以轻松地读懂你写的代码，那说明你的代码可读性很好；如果同事在读你的代码时，有很多疑问，那就说明你的代码可读性有待提高了。</p><h3>3.可扩展性（extensibility）</h3><p>可扩展性也是一个评价代码质量非常重要的标准。它表示我们的代码应对未来需求变化的能力。跟可读性一样，代码是否易扩展也很大程度上决定代码是否易维护。那到底什么是代码的可扩展性呢？</p><p>代码的可扩展性表示，我们在不修改或少量修改原有代码的情况下，通过扩展的方式添加新的功能代码。说直白点就是，代码预留了一些功能扩展点，你可以把新功能代码，直接插到扩展点上，而不需要因为要添加一个功能而大动干戈，改动大量的原始代码。</p><p>关于代码的扩展性，在后面讲到“对修改关闭，对扩展开放”这条设计原则的时候，我会来详细讲解，今天我们只需要知道，代码的可扩展性是评价代码质量非常重要的标准就可以了。</p><h3>4.灵活性（flexibility）</h3><p>灵活性也是描述代码质量的一个常用词汇。比如我们经常会听到这样的描述：“代码写得很灵活”。那这里的“灵活”该如何理解呢？</p><p>尽管有很多人用这个词汇来描述代码的质量。但实际上，灵活性是一个挺抽象的评价标准，要给灵活性下个定义也是挺难的。不过，我们可以想一下，什么情况下我们才会说代码写得好灵活呢？我这里罗列了几个场景，希望能引发你自己对什么是灵活性的思考。</p><ul>\n<li>当我们添加一个新的功能代码的时候，原有的代码已经预留好了扩展点，我们不需要修改原有的代码，只要在扩展点上添加新的代码即可。这个时候，我们除了可以说代码易扩展，还可以说代码写得好灵活。</li>\n<li>当我们要实现一个功能的时候，发现原有代码中，已经抽象出了很多底层可以复用的模块、类等代码，我们可以拿来直接使用。这个时候，我们除了可以说代码易复用之外，还可以说代码写得好灵活。</li>\n<li>当我们使用某组接口的时候，如果这组接口可以应对各种使用场景，满足各种不同的需求，我们除了可以说接口易用之外，还可以说这个接口设计得好灵活或者代码写得好灵活。</li>\n</ul><p>从刚刚举的场景来看，如果一段代码易扩展、易复用或者易用，我们都可以称这段代码写得比较灵活。所以，灵活这个词的含义非常宽泛，很多场景下都可以使用。</p><h3>5.简洁性（simplicity）</h3><p>有一条非常著名的设计原则，你一定听过，那就是KISS原则：“Keep It Simple，Stupid”。这个原则说的意思就是，尽量保持代码简单。代码简单、逻辑清晰，也就意味着易读、易维护。我们在编写代码的时候，往往也会把简单、清晰放到首位。</p><p>不过，很多编程经验不足的程序员会觉得，简单的代码没有技术含量，喜欢在项目中引入一些复杂的设计模式，觉得这样才能体现自己的技术水平。实际上，<strong>思从深而行从简，真正的高手能云淡风轻地用最简单的方法解决最复杂的问题。这也是一个编程老手跟编程新手的本质区别之一。</strong></p><p>除此之外，虽然我们都能认识到，代码要尽量写得简洁，符合KISS原则，但怎么样的代码才算足够简洁？不是每个人都能很准确地判断出来这一点。所以，在后面的章节中，当我们讲到KISS原则的时候，我会通过具体的代码实例，详细给你解释，“为什么KISS原则看似非常简单、好理解，但实际上用好并不容易”。今天，我们就暂且不展开详细讲解了。</p><h3>6.可复用性（reusability）</h3><p>代码的可复用性可以简单地理解为，尽量减少重复代码的编写，复用已有的代码。在后面的很多章节中，我们都会经常提到“可复用性”这一代码评价标准。</p><p>比如，当讲到面向对象特性的时候，我们会讲到继承、多态存在的目的之一，就是为了提高代码的可复用性；当讲到设计原则的时候，我们会讲到单一职责原则也跟代码的可复用性相关；当讲到重构技巧的时候，我们会讲到解耦、高内聚、模块化等都能提高代码的可复用性。可见，可复用性也是一个非常重要的代码评价标准，是很多设计原则、思想、模式等所要达到的最终效果。</p><p>实际上，代码可复用性跟DRY（Don’t Repeat Yourself）这条设计原则的关系挺紧密的，所以，在后面的章节中，当我们讲到DRY设计原则的时候，我还会讲更多代码复用相关的知识，比如，“有哪些编程方法可以提高代码的复用性”等。</p><h3>7.可测试性（testability）</h3><p>相对于前面六个评价标准，代码的可测试性是一个相对较少被提及，但又非常重要的代码质量评价标准。代码可测试性的好坏，能从侧面上非常准确地反应代码质量的好坏。代码的可测试性差，比较难写单元测试，那基本上就能说明代码设计得有问题。关于代码的可测试性，我们在重构那一部分，会花两节课的时间来详细讲解。现在，你暂时只需要知道，代码的可测试性非常重要就可以了。</p><h2>如何才能写出高质量的代码？</h2><p>我相信每个工程师都想写出高质量的代码，不想一直写没有成长、被人吐槽的烂代码。那如何才能写出高质量的代码呢？针对什么是高质量的代码，我们刚刚讲到了七个最常用、最重要的评价指标。所以，问如何写出高质量的代码，也就等同于在问，如何写出易维护、易读、易扩展、灵活、简洁、可复用、可测试的代码。</p><p>要写出满足这些评价标准的高质量代码，我们需要掌握一些更加细化、更加能落地的编程方法论，包括面向对象设计思想、设计原则、设计模式、编码规范、重构技巧等。而所有这些编程方法论的最终目的都是为了编写出高质量的代码。</p><p>比如，面向对象中的继承、多态能让我们写出可复用的代码；编码规范能让我们写出可读性好的代码；设计原则中的单一职责、DRY、基于接口而非实现、里式替换原则等，可以让我们写出可复用、灵活、可读性好、易扩展、易维护的代码；设计模式可以让我们写出易扩展的代码；持续重构可以时刻保持代码的可维护性等等。具体这些编程方法论是如何提高代码的可维护性、可读性、可扩展性等等的呢？我们在后面的课程中慢慢来学习。</p><h2>重点回顾</h2><p>今天的内容到此就讲完了。我们来一起回顾一下，你需要重点掌握的几个知识点。</p><p><strong>1.如何评价代码质量的高低？</strong></p><p>代码质量的评价有很强的主观性，描述代码质量的词汇也有很多，比如可读性、可维护性、灵活、优雅、简洁等，这些词汇是从不同的维度去评价代码质量的。它们之间有互相作用，并不是独立的，比如，代码的可读性好、可扩展性好就意味着代码的可维护性好。代码质量高低是一个综合各种因素得到的结论。我们并不能通过单一的维度去评价一段代码的好坏。</p><p><strong>2.最常用的评价标准有哪几个？</strong></p><p>最常用到几个评判代码质量的标准是：可维护性、可读性、可扩展性、灵活性、简洁性、可复用性、可测试性。其中，可维护性、可读性、可扩展性又是提到最多的、最重要的三个评价标准。</p><p><strong>3.如何才能写出高质量的代码？</strong></p><p>要写出高质量代码，我们就需要掌握一些更加细化、更加能落地的编程方法论，这就包含面向对象设计思想、设计原则、设计模式、编码规范、重构技巧等等，这也是我们后面课程学习的重点。</p><h2>课堂讨论</h2><p>除了我今天提到的这些，你觉得还有哪些其他的代码评价标准非常重要？聊一聊你心目中的好代码是什么样子的？</p><p>欢迎在留言区发表你的观点，积极参与讨论。你也可以把这篇文章分享给你的朋友，邀请他一起学习。</p>",
                "article_title": "02 | 从哪些维度评判代码质量的好坏？如何具备写出高质量代码的能力？"
            },
            {
                "title": "03 | 面向对象、设计原则、设计模式、编程规范、重构，这五者有何关系？",
                "herf": "https://time.geekbang.org/column/article/160991",
                "id": "160991",
                "content": "<p>在上一节课中，我们讲到，要具备编写高质量代码的能力，你需要学习一些编程方法论，其中就包含面向对象（我们可以把它看成一种设计思想）、设计原则、设计模式、编程规范、重构技巧等。而我们整个专栏的内容也是围绕着这几块展开讲解的。所以，今天我就先来简单介绍一下这几个概念，并且说一说它们之间的联系。</p><p>今天的内容相当于专栏的一个教学大纲，或者说学习框架。它能让你对整个专栏所涉及的知识点，有一个全局性的了解，能帮你将后面零散的知识更系统地组织在大脑里。</p><p>话不多说，我们就一块来看一下，接下来的这8个月我们到底要学习哪些内容吧！</p><h2>面向对象</h2><p>现在，主流的编程范式或者是编程风格有三种，它们分别是面向过程、面向对象和函数式编程。面向对象这种编程风格又是这其中最主流的。现在比较流行的编程语言大部分都是面向对象编程语言。大部分项目也都是基于面向对象编程风格开发的。面向对象编程因为其具有丰富的特性（封装、抽象、继承、多态），可以实现很多复杂的设计思路，是很多设计原则、设计模式编码实现的基础。</p><p>所以，在专栏的最开始，我们会详细地讲解面向对象编程的相关的知识，为学习后面的内容做铺垫。对于这部分内容，你需要掌握下面这7个大的知识点。</p><!-- [[[read_end]]] --><ul>\n<li>面向对象的四大特性：封装、抽象、继承、多态</li>\n<li>面向对象编程与面向过程编程的区别和联系</li>\n<li>面向对象分析、面向对象设计、面向对象编程</li>\n<li>接口和抽象类的区别以及各自的应用场景</li>\n<li>基于接口而非实现编程的设计思想</li>\n<li>多用组合少用继承的设计思想</li>\n<li>面向过程的贫血模型和面向对象的充血模型</li>\n</ul><h2>设计原则</h2><p>设计原则是指导我们代码设计的一些经验总结。设计原则这块儿的知识有一个非常大的特点，那就是这些原则听起来都比较抽象，定义描述都比较模糊，不同的人会有不同的解读。所以，如果单纯地去记忆定义，对于编程、设计能力的提高，意义并不大。对于每一种设计原则，我们需要掌握它的设计初衷，能解决哪些编程问题，有哪些应用场景。只有这样，我们才能在项目中灵活恰当地应用这些原则。</p><p>对于这一部分内容，你需要透彻理解并且掌握，如何应用下面这样几个常用的设计原则。</p><ul>\n<li>SOLID原则-SRP单一职责原则</li>\n<li>SOLID原则-OCP开闭原则</li>\n<li>SOLID原则-LSP里式替换原则</li>\n<li>SOLID原则-ISP接口隔离原则</li>\n<li>SOLID原则-DIP依赖倒置原则</li>\n<li>DRY原则、KISS原则、YAGNI原则、LOD法则</li>\n</ul><h2>设计模式</h2><p>设计模式是针对软件开发中经常遇到的一些设计问题，总结出来的一套解决方案或者设计思路。大部分设计模式要解决的都是代码的可扩展性问题。设计模式相对于设计原则来说，没有那么抽象，而且大部分都不难理解，代码实现也并不复杂。这一块的学习难点是了解它们都能解决哪些问题，掌握典型的应用场景，并且懂得不过度应用。</p><p>经典的设计模式有23种。随着编程语言的演进，一些设计模式（比如Singleton）也随之过时，甚至成了反模式，一些则被内置在编程语言中（比如Iterator），另外还有一些新的模式诞生（比如Monostate）。</p><p>在专栏中，我们会重点讲解23种经典的设计模式。它们又可以分为三大类：创建型、结构型、行为型。对于这23种设计模式的学习，我们要有侧重点，因为有些模式是比较常用的，有些模式是很少被用到的。对于常用的设计模式，我们要花多点时间理解掌握。对于不常用的设计模式，我们只需要稍微了解即可。</p><p>我按照类型和是否常用，对专栏中讲到的这些设计模式，进行了简单的分类，具体如下所示。</p><h3>1.创建型</h3><p>常用的有：单例模式、工厂模式（工厂方法和抽象工厂）、建造者模式。</p><p>不常用的有：原型模式。</p><h3>2.结构型</h3><p>常用的有：代理模式、桥接模式、装饰者模式、适配器模式。</p><p>不常用的有：门面模式、组合模式、享元模式。</p><h3>3.行为型</h3><p>常用的有：观察者模式、模板模式、策略模式、职责链模式、迭代器模式、状态模式。</p><p>不常用的有：访问者模式、备忘录模式、命令模式、解释器模式、中介模式。</p><h2>编程规范</h2><p>编程规范主要解决的是代码的可读性问题。编码规范相对于设计原则、设计模式，更加具体、更加偏重代码细节。即便你可能对设计原则不熟悉、对设计模式不了解，但你最起码要掌握基本的编码规范，比如，如何给变量、类、函数命名，如何写代码注释，函数不宜过长、参数不能过多等等。</p><p>对于编码规范，考虑到很多书籍已经讲得很好了（比如《重构》《代码大全》《代码整洁之道》等）。而且，每条编码规范都非常简单、非常明确，比较偏向于记忆，你只要照着来做可以。它不像设计原则，需要融入很多个人的理解和思考。所以，在这个专栏中，我并没有花太多的篇幅来讲解所有的编码规范，而是总结了我认为的最能改善代码质量的20条规范。如果你暂时没有时间去看那些经典的书籍，看我这些就够了。</p><p>除此之外，专栏并没有将编码规范单独作为一个模块来讲解，而是跟重构放到了一起。之所以这样做，那是因为我把重构分为大重构和小重构两种类型，而小重构利用的知识基本上就是编码规范。</p><p>除了编码规范，我们还会介绍一些代码的坏味道，让你知道什么样的代码是不符合规范的，应该如何优化。参照编码规范，你可以写出可读性好的代码；参照代码的坏味道，你可以找出代码存在的可读性问题。</p><h2>代码重构</h2><p>在软件开发中，只要软件在不停地迭代，就没有一劳永逸的设计。随着需求的变化，代码的不停堆砌，原有的设计必定会存在这样那样的问题。针对这些问题，我们就需要进行代码重构。重构是软件开发中非常重要的一个环节。持续重构是保持代码质量不下降的有效手段，能有效避免代码腐化到无可救药的地步。</p><p>而重构的工具就是我们前面罗列的那些面向对象设计思想、设计原则、设计模式、编码规范。实际上，设计思想、设计原则、设计模式一个最重要的应用场景就是在重构的时候。我们前面讲过，虽然使用设计模式可以提高代码的可扩展性，但过度不恰当地使用，也会增加代码的复杂度，影响代码的可读性。在开发初期，除非特别必须，我们一定不要过度设计，应用复杂的设计模式。而是当代码出现问题的时候，我们再针对问题，应用原则和模式进行重构。这样就能有效避免前期的过度设计。</p><p>对于重构这部分内容，你需要掌握以下几个知识点：</p><ul>\n<li>重构的目的（why）、对象（what）、时机（when）、方法（how）；</li>\n<li>保证重构不出错的技术手段：单元测试和代码的可测试性；</li>\n<li>两种不同规模的重构：大重构（大规模高层次）和小重构（小规模低层次）。</li>\n</ul><p>希望你学完这部分内容之后，不仅仅是掌握一些重构技巧、套路，更重要的是建立持续重构意识，把重构当作开发的一部分，融入到日常的开发中。</p><h2>五者之间的联系</h2><p>关于面向对象、设计原则、设计模式、编程规范和代码重构，这五者的关系我们前面稍微提到了一些，我这里再总结梳理一下。</p><ul>\n<li>面向对象编程因为其具有丰富的特性（封装、抽象、继承、多态），可以实现很多复杂的设计思路，是很多设计原则、设计模式等编码实现的基础。</li>\n<li>设计原则是指导我们代码设计的一些经验总结，对于某些场景下，是否应该应用某种设计模式，具有指导意义。比如，“开闭原则”是很多设计模式（策略、模板等）的指导原则。</li>\n<li>设计模式是针对软件开发中经常遇到的一些设计问题，总结出来的一套解决方案或者设计思路。应用设计模式的主要目的是提高代码的可扩展性。从抽象程度上来讲，设计原则比设计模式更抽象。设计模式更加具体、更加可执行。</li>\n<li>编程规范主要解决的是代码的可读性问题。编码规范相对于设计原则、设计模式，更加具体、更加偏重代码细节、更加能落地。持续的小重构依赖的理论基础主要就是编程规范。</li>\n<li>重构作为保持代码质量不下降的有效手段，利用的就是面向对象、设计原则、设计模式、编码规范这些理论。</li>\n</ul><p>实际上，面向对象、设计原则、设计模式、编程规范、代码重构，这五者都是保持或者提高代码质量的方法论，本质上都是服务于编写高质量代码这一件事的。当我们追本逐源，看清这个本质之后，很多事情怎么做就清楚了，很多选择怎么选也清楚了。比如，在某个场景下，该不该用这个设计模式，那就看能不能提高代码的可扩展性；要不要重构，那就看重代码是否存在可读、可维护问题等。</p><h2>重点回顾</h2><p>今天的内容到此就讲完了。我画了一张图，总结了专栏中所涉及的知识点。在学习后面的课程的时候，你可以经常翻出来看一下，建立全局意识，不至于迷失在零碎的知识点中。</p><p><img src=\"https://static001.geekbang.org/resource/image/f3/d3/f3262ef8152517d3b11bfc3f2d2b12d3.png\" alt=\"\"></p><h2>课堂讨论</h2><p>今天课堂讨论的话题有两个。</p><ol>\n<li>在今天讲到的内容中，你觉得哪一部分内容对提高代码质量最有效？为什么？除了我罗列的这些内容之外，你还知道哪些可以提高代码质量的方法？</li>\n<li>我们知道，最经典的设计模式书籍是GoF的《设计模式》，它的中文全称是《设计模式：可复用面向对象软件的基础》，英文全称是“Design Patterns: Elements of Reusable Object-Oriented Software”。为什么它在标题中会特意提到“面向对象”呢？</li>\n</ol><p>欢迎在留言区写下你的想法，和同学一起交流和分享。如果有收获，也欢迎你把这篇文章分享给你的朋友。</p>",
                "article_title": "03 | 面向对象、设计原则、设计模式、编程规范、重构，这五者有何关系？"
            }
        ]
    },
    {
        "chapterTitle": "设计原则与思想：面向对象 (11讲)",
        "children": [
            {
                "title": "04 | 理论一：当谈论面向对象的时候，我们到底在谈论什么？",
                "herf": "https://time.geekbang.org/column/article/161575",
                "id": "161575",
                "content": "<p>考虑到各个水平层次的同学，并且保证专栏内容的系统性、全面性，我会循序渐进地讲解跟设计模式相关的所有内容。所以，专栏正文的第一个模块，我会讲一些设计原则、设计思想，比如，面向对象设计思想、经典设计原则以及重构相关的知识，为之后学习设计模式做铺垫。</p><p>在第一个模块中，我们又首先会讲到面向对象相关的理论知识。提到面向对象，我相信很多人都不陌生，随口都可以说出面向对象的四大特性：封装、抽象、继承、多态。实际上，面向对象这个概念包含的内容还不止这些。所以，今天我打算花一节课的时间，先大概跟你聊一下，当我们谈论面向对象的时候，经常会谈到的一些概念和知识点，为学习后面的几节更加细化的内容做一个铺垫。</p><p>特别说明一下，对于今天讲到的概念和知识点，大部分我都是点到为止，并没有展开详细讲解。如果你看了之后，对某个概念和知识点还不是很清楚，那也没有关系。在后面的几节课中，我会花更多的篇幅，对今天讲到的每个概念和知识点，结合具体的例子，一一做详细的讲解。</p><h2>什么是面向对象编程和面向对象编程语言？</h2><p>面向对象编程的英文缩写是OOP，全称是Object Oriented Programming。对应地，面向对象编程语言的英文缩写是OOPL，全称是Object Oriented Programming Language。</p><!-- [[[read_end]]] --><p>面向对象编程中有两个非常重要、非常基础的概念，那就是类（class）和对象（object）。这两个概念最早出现在1960年，在Simula这种编程语言中第一次使用。而面向对象编程这个概念第一次被使用是在Smalltalk这种编程语言中。Smalltalk被认为是第一个真正意义上的面向对象编程语言。</p><p>1980年左右，C++的出现，带动了面向对象编程的流行，也使得面向对象编程被越来越多的人认可。直到今天，如果不按照严格的定义来说，大部分编程语言都是面向对象编程语言，比如Java、C++、Go、Python、C#、Ruby、JavaScript、Objective-C、Scala、PHP、Perl等等。除此之外，大部分程序员在开发项目的时候，都是基于面向对象编程语言进行的面向对象编程。</p><p>以上是面向对象编程的大概发展历史。在刚刚的描述中，我着重提到了两个概念，面向对象编程和面向对象编程语言。那究竟什么是面向对象编程？什么语言才算是面向对象编程语言呢？如果非得给出一个定义的话，我觉得可以用下面两句话来概括。</p><ul>\n<li>面向对象编程是一种编程范式或编程风格。它以类或对象作为组织代码的基本单元，并将封装、抽象、继承、多态四个特性，作为代码设计和实现的基石 。</li>\n<li>面向对象编程语言是支持类或对象的语法机制，并有现成的语法机制，能方便地实现面向对象编程四大特性（封装、抽象、继承、多态）的编程语言。</li>\n</ul><p>一般来讲， 面向对象编程都是通过使用面向对象编程语言来进行的，但是，不用面向对象编程语言，我们照样可以进行面向对象编程。反过来讲，即便我们使用面向对象编程语言，写出来的代码也不一定是面向对象编程风格的，也有可能是面向过程编程风格的。这里听起来是不是有点绕？不过没关系，我们在后面的第7节课中，会详细讲解这个问题。</p><p>除此之外，从定义中，我们还可以发现，理解面向对象编程及面向对象编程语言两个概念，其中最关键的一点就是理解面向对象编程的四大特性。这四大特性分别是：封装、抽象、继承、多态。不过，关于面向对象编程的特性，也有另外一种说法，那就是只包含三大特性：封装、继承、多态，不包含抽象。为什么会有这种分歧呢？抽象为什么可以排除在面向对象编程特性之外呢？关于这个问题，在下一节课详细讲解这四大特性的时候，我还会再拿出来说一下。不过，话说回来，实际上，我们没必要纠结到底是四大特性还是三大特性，关键还是理解每种特性讲的是什么内容、存在的意义以及能解决什么问题。</p><p>而且，在技术圈里，封装、抽象、继承、多态也并不是固定地被叫作“四大特性”（features），也有人称它们为面向对象编程的四大概念（concepts）、四大基石（cornerstones）、四大基础（fundamentals）、四大支柱（pillars）等等。你也发现了吧，叫法挺混乱的。不过，叫什么并不重要。我们只需要知道，这是前人进行面向对象编程过程中总结出来的、能让我们更容易地实现各种设计思路的几个编程套路，这就够了。在之后的课程讲解中，我统一把它们叫作“四大特性”。</p><h2>如何判定某编程语言是否是面向对象编程语言？</h2><p>如果你足够细心，你可能已经留意到，在我刚刚的讲解中，我提到，“如果不按照严格的定义来说，大部分编程语言都是面向对象编程语言”。为什么要加上“如果不按照严格的定义”这个前提呢？那是因为，如果按照刚刚我们给出的严格的面向对象编程语言的定义，前面提到的有些编程语言，并不是严格意义上的面向对象编程语言，比如JavaScript，它不支持封装和继承特性，按照严格的定义，它不算是面向对象编程语言，但在某种意义上，它又可以算得上是一种面向对象编程语言。我为什么这么说呢？到底该如何判断一个编程语言是否是面向对象编程语言呢？</p><p>还记得我们前面给出的面向对象编程及面向对象编程语言的定义吗？如果忘记了，你可以先翻到上面回顾一下。不过，我必须坦诚告诉你，那个定义是我自己给出的。实际上，对于什么是面向对象编程、什么是面向对象编程语言，并没有一个官方的、统一的定义。而且，从1960年，也就是60年前面向对象编程诞生开始，这两个概念就在不停地演化，所以，也无法给出一个明确的定义，也没有必要给出一个明确定义。</p><p>实际上，面向对象编程从字面上，按照最简单、最原始的方式来理解，就是将对象或类作为代码组织的基本单元，来进行编程的一种编程范式或者编程风格，并不一定需要封装、抽象、继承、多态这四大特性的支持。但是，在进行面向对象编程的过程中，人们不停地总结发现，有了这四大特性，我们就能更容易地实现各种面向对象的代码设计思路。</p><p>比如，我们在面向对象编程的过程中，经常会遇到is-a这种类关系（比如狗是一种动物），而继承这个特性就能很好地支持这种is-a的代码设计思路，并且解决代码复用的问题，所以，继承就成了面向对象编程的四大特性之一。但是随着编程语言的不断迭代、演化，人们发现继承这种特性容易造成层次不清、代码混乱，所以，很多编程语言在设计的时候就开始摒弃继承特性，比如Go语言。但是，我们并不能因为它摒弃了继承特性，就一刀切地认为它不是面向对象编程语言了。</p><p>实际上，我个人觉得，只要某种编程语言支持类或对象的语法概念，并且以此作为组织代码的基本单元，那就可以被粗略地认为它就是面向对象编程语言了。至于是否有现成的语法机制，完全地支持了面向对象编程的四大特性、是否对四大特性有所取舍和优化，可以不作为判定的标准。基于此，我们才有了前面的说法，<strong>按照严格的定义，很多语言都不能算得上面向对象编程语言，但按照不严格的定义来讲，现在流行的大部分编程语言都是面向对象编程语言。</strong></p><p>所以，多说一句，关于这个问题，我们一定不要过于学院派，非要给面向对象编程、面向对象编程语言下个死定义，非得对某种语言是否是面向对象编程语言争个一清二白，这样做意义不大。</p><h2>什么是面向对象分析和面向对象设计？</h2><p>前面我们讲了面向对象编程（OOP），实际上，跟面向对象编程经常放到一块儿来讲的还有另外两个概念，那就是面向对象分析（OOA）和面向对象设计（OOD）。面向对象分析英文缩写是OOA，全称是Object Oriented Analysis；面向对象设计的英文缩写是OOD，全称是Object Oriented Design。OOA、OOD、OOP三个连在一起就是面向对象分析、设计、编程（实现），正好是面向对象软件开发要经历的三个阶段。</p><p>关于什么是面向对象编程，我们前面已经讲过了。我们现在再来讲一下，什么是面向对象分析和设计。这两个概念相对来说要简单一些。面向对象分析与设计中的“分析”和“设计”这两个词，我们完全可以从字面上去理解，不需要过度解读，简单类比软件开发中的需求分析、系统设计即可。不过，你可能会说，那为啥前面还加了个修饰词“面向对象”呢？有什么特殊的意义吗？</p><p>之所以在前面加“面向对象”这几个字，是因为我们是围绕着对象或类来做需求分析和设计的。分析和设计两个阶段最终的产出是类的设计，包括程序被拆解为哪些类，每个类有哪些属性方法，类与类之间如何交互等等。它们比其他的分析和设计更加具体、更加落地、更加贴近编码，更能够顺利地过渡到面向对象编程环节。这也是面向对象分析和设计，与其他分析和设计最大的不同点。</p><p>看到这里，你可能会问，那面向对象分析、设计、编程到底都负责做哪些工作呢？简单点讲，面向对象分析就是要搞清楚做什么，面向对象设计就是要搞清楚怎么做，面向对象编程就是将分析和设计的的结果翻译成代码的过程。今天，我们只是简单介绍一下概念，不展开详细讲解。在后面的面向对象实战环节中，我会用两节课的时间，通过一个实际例子，详细讲解如何进行面向对象分析、设计和编程。</p><h2>什么是UML？我们是否需要UML？</h2><p>讲到面向对象分析、设计、编程，我们就不得不提到另外一个概念，那就是UML（Unified Model Language），统一建模语言。很多讲解面向对象或设计模式的书籍，常用它来画图表达面向对象或设计模式的设计思路。</p><p>实际上，UML是一种非常复杂的东西。它不仅仅包含我们常提到类图，还有用例图、顺序图、活动图、状态图、组件图等。在我看来，即便仅仅使用类图，学习成本也是很高的。就单说类之间的关系，UML就定义了很多种，比如泛化、实现、关联、聚合、组合、依赖等。</p><p>要想完全掌握，并且熟练运用这些类之间的关系，来画UML类图，肯定要花很多的学习精力。而且，UML作为一种沟通工具，即便你能完全按照UML规范来画类图，可对于不熟悉的人来说，看懂的成本也还是很高的。</p><p>所以，从我的开发经验来说，UML在互联网公司的项目开发中，用处可能并不大。为了文档化软件设计或者方便讨论软件设计，大部分情况下，我们随手画个不那么规范的草图，能够达意，方便沟通就够了，而完全按照UML规范来将草图标准化，所付出的代价是不值得的。</p><p>所以，我这里特别说明一下，专栏中的很多类图我并没有完全遵守UML的规范标准。为了兼顾图的表达能力和你的学习成本，我对UML类图规范做了简化，并配上了详细的文字解释，力图让你一眼就能看懂，而非适得其反，让图加重你的学习成本。毕竟，我们的专栏并不是一个讲方法论的教程，专栏中的所有类图，本质是让你更清晰地理解设计。</p><h2>重点回顾</h2><p>今天的内容讲完了，我们来一起总结回顾一下，你需要重点掌握的几个概念和知识点。</p><p><strong>1.什么是面向对象编程？</strong></p><p>面向对象编程是一种编程范式或编程风格。它以类或对象作为组织代码的基本单元，并将封装、抽象、继承、多态四个特性，作为代码设计和实现的基石 。</p><p><strong>2.什么是面向对象编程语言？</strong></p><p>面向对象编程语言是支持类或对象的语法机制，并有现成的语法机制，能方便地实现面向对象编程四大特性（封装、抽象、继承、多态）的编程语言。</p><p><strong>3.如何判定一个编程语言是否是面向对象编程语言？</strong></p><p>如果按照严格的的定义，需要有现成的语法支持类、对象、四大特性才能叫作面向对象编程语言。如果放宽要求的话，只要某种编程语言支持类、对象语法机制，那基本上就可以说这种编程语言是面向对象编程语言了，不一定非得要求具有所有的四大特性。</p><p><strong>4.面向对象编程和面向对象编程语言之间有何关系？</strong></p><p>面向对象编程一般使用面向对象编程语言来进行，但是，不用面向对象编程语言，我们照样可以进行面向对象编程。反过来讲，即便我们使用面向对象编程语言，写出来的代码也不一定是面向对象编程风格的，也有可能是面向过程编程风格的。</p><p><strong>5.什么是面向对象分析和面向对象设计？</strong></p><p>简单点讲，面向对象分析就是要搞清楚做什么，面向对象设计就是要搞清楚怎么做。两个阶段最终的产出是类的设计，包括程序被拆解为哪些类，每个类有哪些属性方法、类与类之间如何交互等等。</p><h2>课堂讨论</h2><p>今天我们要讨论的话题有两个：</p><ol>\n<li>在文章中，我讲到UML的学习成本很高，沟通成本也不低，不推荐在面向对象分析、设计的过程中使用，对此你有何看法？</li>\n<li>有关面向对象的概念和知识点，除了我们今天讲到的，你还能想到其他哪些吗？</li>\n</ol><p>欢迎在留言区发表你的观点，积极参与讨论。你也可以把这篇文章分享给你的朋友，邀请他一起学习。</p>",
                "article_title": "04 | 理论一：当谈论面向对象的时候，我们到底在谈论什么？"
            },
            {
                "title": "05 | 理论二：封装、抽象、继承、多态分别可以解决哪些编程问题？",
                "herf": "https://time.geekbang.org/column/article/161114",
                "id": "161114",
                "content": "<p>上一节课，我简单介绍了面向对象的一些基本概念和知识点，比如，什么是面向对象编程，什么是面向对象编程语言等等。其中，我们还提到，理解面向对象编程及面向对象编程语言的关键就是理解其四大特性：封装、抽象、继承、多态。不过，对于这四大特性，光知道它们的定义是不够的，我们还要知道每个特性存在的意义和目的，以及它们能解决哪些编程问题。所以，今天我就花一节课的时间，针对每种特性，结合实际的代码，带你将这些问题搞清楚。</p><p>这里我要强调一下，对于这四大特性，尽管大部分面向对象编程语言都提供了相应的语法机制来支持，但不同的编程语言实现这四大特性的语法机制可能会有所不同。所以，今天，我们在讲解四大特性的时候，并不与具体某种编程语言的特定语法相挂钩，同时，也希望你不要局限在你自己熟悉的编程语言的语法思维框架里。</p><h2>封装（Encapsulation）</h2><p>首先，我们来看封装特性。封装也叫作信息隐藏或者数据访问保护。类通过暴露有限的访问接口，授权外部仅能通过类提供的方式（或者叫函数）来访问内部信息或者数据。这句话怎么理解呢？我们通过一个简单的例子来解释一下。</p><p>下面这段代码是金融系统中一个简化版的虚拟钱包的代码实现。在金融系统中，我们会给每个用户创建一个虚拟钱包，用来记录用户在我们的系统中的虚拟货币量。对于虚拟钱包的业务背景，这里你只需要简单了解一下即可。在面向对象的实战篇中，我们会有单独两节课，利用OOP的设计思想来详细介绍虚拟钱包的设计实现。</p><!-- [[[read_end]]] --><pre><code>public class Wallet {\n  private String id;\n  private long createTime;\n  private BigDecimal balance;\n  private long balanceLastModifiedTime;\n  // ...省略其他属性...\n\n  public Wallet() {\n     this.id = IdGenerator.getInstance().generate();\n     this.createTime = System.currentTimeMillis();\n     this.balance = BigDecimal.ZERO;\n     this.balanceLastModifiedTime = System.currentTimeMillis();\n  }\n\n  // 注意：下面对get方法做了代码折叠，是为了减少代码所占文章的篇幅\n  public String getId() { return this.id; }\n  public long getCreateTime() { return this.createTime; }\n  public BigDecimal getBalance() { return this.balance; }\n  public long getBalanceLastModifiedTime() { return this.balanceLastModifiedTime;  }\n\n  public void increaseBalance(BigDecimal increasedAmount) {\n    if (increasedAmount.compareTo(BigDecimal.ZERO) &lt; 0) {\n      throw new InvalidAmountException(&quot;...&quot;);\n    }\n    this.balance.add(increasedAmount);\n    this.balanceLastModifiedTime = System.currentTimeMillis();\n  }\n\n  public void decreaseBalance(BigDecimal decreasedAmount) {\n    if (decreasedAmount.compareTo(BigDecimal.ZERO) &lt; 0) {\n      throw new InvalidAmountException(&quot;...&quot;);\n    }\n    if (decreasedAmount.compareTo(this.balance) &gt; 0) {\n      throw new InsufficientAmountException(&quot;...&quot;);\n    }\n    this.balance.subtract(decreasedAmount);\n    this.balanceLastModifiedTime = System.currentTimeMillis();\n  }\n}\n</code></pre><p>从代码中，我们可以发现，Wallet类主要有四个属性（也可以叫作成员变量），也就是我们前面定义中提到的信息或者数据。其中，id表示钱包的唯一编号，createTime表示钱包创建的时间，balance表示钱包中的余额，balanceLastModifiedTime表示上次钱包余额变更的时间。</p><p>我们参照封装特性，对钱包的这四个属性的访问方式进行了限制。调用者只允许通过下面这六个方法来访问或者修改钱包里的数据。</p><ul>\n<li>String getId()</li>\n<li>long getCreateTime()</li>\n<li>BigDecimal getBalance()</li>\n<li>long getBalanceLastModifiedTime()</li>\n<li>void increaseBalance(BigDecimal increasedAmount)</li>\n<li>void decreaseBalance(BigDecimal decreasedAmount)</li>\n</ul><p>之所以这样设计，是因为从业务的角度来说，id、createTime在创建钱包的时候就确定好了，之后不应该再被改动，所以，我们并没有在Wallet类中，暴露id、createTime这两个属性的任何修改方法，比如set方法。而且，这两个属性的初始化设置，对于Wallet类的调用者来说，也应该是透明的，所以，我们在Wallet类的构造函数内部将其初始化设置好，而不是通过构造函数的参数来外部赋值。</p><p>对于钱包余额balance这个属性，从业务的角度来说，只能增或者减，不会被重新设置。所以，我们在Wallet类中，只暴露了increaseBalance()和decreaseBalance()方法，并没有暴露set方法。对于balanceLastModifiedTime这个属性，它完全是跟balance这个属性的修改操作绑定在一起的。只有在balance修改的时候，这个属性才会被修改。所以，我们把balanceLastModifiedTime这个属性的修改操作完全封装在了increaseBalance()和decreaseBalance()两个方法中，不对外暴露任何修改这个属性的方法和业务细节。这样也可以保证balance和balanceLastModifiedTime两个数据的一致性。</p><p>对于封装这个特性，我们需要编程语言本身提供一定的语法机制来支持。这个语法机制就是<strong>访问权限控制。</strong>例子中的private、public等关键字就是Java语言中的访问权限控制语法。private关键字修饰的属性只能类本身访问，可以保护其不被类之外的代码直接访问。如果Java语言没有提供访问权限控制语法，所有的属性默认都是public的，那任意外部代码都可以通过类似wallet.id=123;这样的方式直接访问、修改属性，也就没办法达到隐藏信息和保护数据的目的了，也就无法支持封装特性了。</p><p><strong>封装特性的定义讲完了，我们再来看一下，封装的意义是什么？它能解决什么编程问题？</strong></p><p>如果我们对类中属性的访问不做限制，那任何代码都可以访问、修改类中的属性，虽然这样看起来更加灵活，但从另一方面来说，过度灵活也意味着不可控，属性可以随意被以各种奇葩的方式修改，而且修改逻辑可能散落在代码中的各个角落，势必影响代码的可读性、可维护性。比如某个同事在不了解业务逻辑的情况下，在某段代码中“偷偷地”重设了wallet中的balanceLastModifiedTime属性，这就会导致balance和balanceLastModifiedTime两个数据不一致。</p><p>除此之外，类仅仅通过有限的方法暴露必要的操作，也能提高类的易用性。如果我们把类属性都暴露给类的调用者，调用者想要正确地操作这些属性，就势必要对业务细节有足够的了解。而这对于调用者来说也是一种负担。相反，如果我们将属性封装起来，暴露少许的几个必要的方法给调用者使用，调用者就不需要了解太多背后的业务细节，用错的概率就减少很多。这就好比，如果一个冰箱有很多按钮，你就要研究很长时间，还不一定能操作正确。相反，如果只有几个必要的按钮，比如开、停、调节温度，你一眼就能知道该如何来操作，而且操作出错的概率也会降低很多。</p><h2>抽象（Abstraction）</h2><p>讲完了封装特性，我们再来看抽象特性。 封装主要讲的是如何隐藏信息、保护数据，而抽象讲的是如何隐藏方法的具体实现，让调用者只需要关心方法提供了哪些功能，并不需要知道这些功能是如何实现的。</p><p>在面向对象编程中，我们常借助编程语言提供的接口类（比如Java中的interface关键字语法）或者抽象类（比如Java中的abstract关键字语法）这两种语法机制，来实现抽象这一特性。</p><p>这里我稍微说明一下，在专栏中，我们把编程语言提供的接口语法叫作“接口类”而不是“接口”。之所以这么做，是因为“接口”这个词太泛化，可以指好多概念，比如API接口等，所以，我们用“接口类”特指编程语言提供的接口语法。</p><p>对于抽象这个特性，我举一个例子来进一步解释一下。</p><pre><code>public interface IPictureStorage {\n  void savePicture(Picture picture);\n  Image getPicture(String pictureId);\n  void deletePicture(String pictureId);\n  void modifyMetaInfo(String pictureId, PictureMetaInfo metaInfo);\n}\n\npublic class PictureStorage implements IPictureStorage {\n  // ...省略其他属性...\n  @Override\n  public void savePicture(Picture picture) { ... }\n  @Override\n  public Image getPicture(String pictureId) { ... }\n  @Override\n  public void deletePicture(String pictureId) { ... }\n  @Override\n  public void modifyMetaInfo(String pictureId, PictureMetaInfo metaInfo) { ... }\n}\n</code></pre><p>在上面的这段代码中，我们利用Java中的interface接口语法来实现抽象特性。调用者在使用图片存储功能的时候，只需要了解IPictureStorage这个接口类暴露了哪些方法就可以了，不需要去查看PictureStorage类里的具体实现逻辑。</p><p>实际上，抽象这个特性是非常容易实现的，并不需要非得依靠接口类或者抽象类这些特殊语法机制来支持。换句话说，并不是说一定要为实现类（PictureStorage）抽象出接口类（IPictureStorage），才叫作抽象。即便不编写IPictureStorage接口类，单纯的PictureStorage类本身就满足抽象特性。</p><p>之所以这么说，那是因为，类的方法是通过编程语言中的“函数”这一语法机制来实现的。通过函数包裹具体的实现逻辑，这本身就是一种抽象。调用者在使用函数的时候，并不需要去研究函数内部的实现逻辑，只需要通过函数的命名、注释或者文档，了解其提供了什么功能，就可以直接使用了。比如，我们在使用C语言的malloc()函数的时候，并不需要了解它的底层代码是怎么实现的。</p><p>除此之外，在上一节课中，我们还提到，抽象有时候会被排除在面向对象的四大特性之外，当时我卖了一个关子，现在我就来解释一下为什么。</p><p>抽象这个概念是一个非常通用的设计思想，并不单单用在面向对象编程中，也可以用来指导架构设计等。而且这个特性也并不需要编程语言提供特殊的语法机制来支持，只需要提供“函数”这一非常基础的语法机制，就可以实现抽象特性、所以，它没有很强的“特异性”，有时候并不被看作面向对象编程的特性之一。</p><p><strong>抽象特性的定义讲完了，我们再来看一下，抽象的意义是什么？它能解决什么编程问题？</strong></p><p>实际上，如果上升一个思考层面的话，抽象及其前面讲到的封装都是人类处理复杂性的有效手段。在面对复杂系统的时候，人脑能承受的信息复杂程度是有限的，所以我们必须忽略掉一些非关键性的实现细节。而抽象作为一种只关注功能点不关注实现的设计思路，正好帮我们的大脑过滤掉许多非必要的信息。</p><p>除此之外，抽象作为一个非常宽泛的设计思想，在代码设计中，起到非常重要的指导作用。很多设计原则都体现了抽象这种设计思想，比如基于接口而非实现编程、开闭原则（对扩展开放、对修改关闭）、代码解耦（降低代码的耦合性）等。我们在讲到后面的内容的时候，会具体来解释。</p><p>换一个角度来考虑，我们在定义（或者叫命名）类的方法的时候，也要有抽象思维，不要在方法定义中，暴露太多的实现细节，以保证在某个时间点需要改变方法的实现逻辑的时候，不用去修改其定义。举个简单例子，比如getAliyunPictureUrl()就不是一个具有抽象思维的命名，因为某一天如果我们不再把图片存储在阿里云上，而是存储在私有云上，那这个命名也要随之被修改。相反，如果我们定义一个比较抽象的函数，比如叫作getPictureUrl()，那即便内部存储方式修改了，我们也不需要修改命名。</p><h2>继承（Inheritance）</h2><p>学习完了封装和抽象两个特性，我们再来看继承特性。如果你熟悉的是类似Java、C++这样的面向对象的编程语言，那你对继承这一特性，应该不陌生了。继承是用来表示类之间的is-a关系，比如猫是一种哺乳动物。从继承关系上来讲，继承可以分为两种模式，单继承和多继承。单继承表示一个子类只继承一个父类，多继承表示一个子类可以继承多个父类，比如猫既是哺乳动物，又是爬行动物。</p><p>为了实现继承这个特性，编程语言需要提供特殊的语法机制来支持，比如Java使用extends关键字来实现继承，C++使用冒号（class B : public A），Python使用parentheses ()，Ruby使用&lt;。不过，有些编程语言只支持单继承，不支持多重继承，比如Java、PHP、C#、Ruby等，而有些编程语言既支持单重继承，也支持多重继承，比如C++、Python、Perl等。</p><p>为什么有些语言支持多重继承，有些语言不支持呢？这个问题留给你自己去研究，你可以针对你熟悉的编程语言，在留言区写一写具体的原因。</p><p><strong>继承特性的定义讲完了，我们再来看，继承存在的意义是什么？它能解决什么编程问题？</strong></p><p>继承最大的一个好处就是代码复用。假如两个类有一些相同的属性和方法，我们就可以将这些相同的部分，抽取到父类中，让两个子类继承父类。这样，两个子类就可以重用父类中的代码，避免代码重复写多遍。不过，这一点也并不是继承所独有的，我们也可以通过其他方式来解决这个代码复用的问题，比如利用组合关系而不是继承关系。</p><p>如果我们再上升一个思维层面，去思考继承这一特性，可以这么理解：我们代码中有一个猫类，有一个哺乳动物类。猫属于哺乳动物，从人类认知的角度上来说，是一种is-a关系。我们通过继承来关联两个类，反应真实世界中的这种关系，非常符合人类的认知，而且，从设计的角度来说，也有一种结构美感。</p><p>继承的概念很好理解，也很容易使用。不过，过度使用继承，继承层次过深过复杂，就会导致代码可读性、可维护性变差。为了了解一个类的功能，我们不仅需要查看这个类的代码，还需要按照继承关系一层一层地往上查看“父类、父类的父类……”的代码。还有，子类和父类高度耦合，修改父类的代码，会直接影响到子类。</p><p>所以，继承这个特性也是一个非常有争议的特性。很多人觉得继承是一种反模式。我们应该尽量少用，甚至不用。关于这个问题，在后面讲到“多用组合少用继承”这种设计思想的时候，我会非常详细地再讲解，这里暂时就不展开讲解了。</p><h2>多态（Polymorphism）</h2><p>学习完了封装、抽象、继承之后，我们再来看面向对象编程的最后一个特性，多态。多态是指，子类可以替换父类，在实际的代码运行过程中，调用子类的方法实现。对于多态这种特性，纯文字解释不好理解，我们还是看一个具体的例子。</p><pre><code>public class DynamicArray {\n  private static final int DEFAULT_CAPACITY = 10;\n  protected int size = 0;\n  protected int capacity = DEFAULT_CAPACITY;\n  protected Integer[] elements = new Integer[DEFAULT_CAPACITY];\n  \n  public int size() { return this.size; }\n  public Integer get(int index) { return elements[index];}\n  //...省略n多方法...\n  \n  public void add(Integer e) {\n    ensureCapacity();\n    elements[size++] = e;\n  }\n  \n  protected void ensureCapacity() {\n    //...如果数组满了就扩容...代码省略...\n  }\n}\n\npublic class SortedDynamicArray extends DynamicArray {\n  @Override\n  public void add(Integer e) {\n    ensureCapacity();\n    int i;\n    for (i = size-1; i&gt;=0; --i) { //保证数组中的数据有序\n      if (elements[i] &gt; e) {\n        elements[i+1] = elements[i];\n      } else {\n        break;\n      }\n    }\n    elements[i+1] = e;\n    ++size;\n  }\n}\n\npublic class Example {\n  public static void test(DynamicArray dynamicArray) {\n    dynamicArray.add(5);\n    dynamicArray.add(1);\n    dynamicArray.add(3);\n    for (int i = 0; i &lt; dynamicArray.size(); ++i) {\n      System.out.println(dynamicArray.get(i));\n    }\n  }\n  \n  public static void main(String args[]) {\n    DynamicArray dynamicArray = new SortedDynamicArray();\n    test(dynamicArray); // 打印结果：1、3、5\n  }\n}\n</code></pre><p>多态这种特性也需要编程语言提供特殊的语法机制来实现。在上面的例子中，我们用到了三个语法机制来实现多态。</p><ul>\n<li>第一个语法机制是编程语言要支持父类对象可以引用子类对象，也就是可以将SortedDynamicArray传递给DynamicArray。</li>\n<li>第二个语法机制是编程语言要支持继承，也就是SortedDynamicArray继承了DynamicArray，才能将SortedDyamicArray传递给DynamicArray。</li>\n<li>第三个语法机制是编程语言要支持子类可以重写（override）父类中的方法，也就是SortedDyamicArray重写了DynamicArray中的add()方法。</li>\n</ul><p>通过这三种语法机制配合在一起，我们就实现了在test()方法中，子类SortedDyamicArray替换父类DynamicArray，执行子类SortedDyamicArray的add()方法，也就是实现了多态特性。</p><p>对于多态特性的实现方式，除了利用“继承加方法重写”这种实现方式之外，我们还有其他两种比较常见的的实现方式，一个是利用接口类语法，另一个是利用duck-typing语法。不过，并不是每种编程语言都支持接口类或者duck-typing这两种语法机制，比如C++就不支持接口类语法，而duck-typing只有一些动态语言才支持，比如Python、JavaScript等。</p><p><strong>接下来，我们先来看如何利用接口类来实现多态特性。</strong>我们还是先来看一段代码。</p><pre><code>public interface Iterator {\n  boolean hasNext();\n  String next();\n  String remove();\n}\n\npublic class Array implements Iterator {\n  private String[] data;\n  \n  public boolean hasNext() { ... }\n  public String next() { ... }\n  public String remove() { ... }\n  //...省略其他方法...\n}\n\npublic class LinkedList implements Iterator {\n  private LinkedListNode head;\n  \n  public boolean hasNext() { ... }\n  public String next() { ... }\n  public String remove() { ... }\n  //...省略其他方法... \n}\n\npublic class Demo {\n  private static void print(Iterator iterator) {\n    while (iterator.hasNext()) {\n      System.out.println(iterator.next());\n    }\n  }\n  \n  public static void main(String[] args) {\n    Iterator arrayIterator = new Array();\n    print(arrayIterator);\n    \n    Iterator linkedListIterator = new LinkedList();\n    print(linkedListIterator);\n  }\n}\n</code></pre><p>在这段代码中，Iterator是一个接口类，定义了一个可以遍历集合数据的迭代器。Array和LinkedList都实现了接口类Iterator。我们通过传递不同类型的实现类（Array、LinkedList）到print(Iterator iterator)函数中，支持动态的调用不同的next()、hasNext()实现。</p><p>具体点讲就是，当我们往print(Iterator iterator)函数传递Array类型的对象的时候，print(Iterator iterator)函数就会调用Array的next()、hasNext()的实现逻辑；当我们往print(Iterator iterator)函数传递LinkedList类型的对象的时候，print(Iterator iterator)函数就会调用LinkedList的next()、hasNext()的实现逻辑。</p><p><strong>刚刚讲的是用接口类来实现多态特性。现在，我们再来看下，如何用duck-typing来实现多态特性。</strong>我们还是先来看一段代码。这是一段Python代码。</p><pre><code>class Logger:\n    def record(self):\n        print(“I write a log into file.”)\n        \nclass DB:\n    def record(self):\n        print(“I insert data into db. ”)\n        \ndef test(recorder):\n    recorder.record()\n\ndef demo():\n    logger = Logger()\n    db = DB()\n    test(logger)\n    test(db)\n</code></pre><p>从这段代码中，我们发现，duck-typing实现多态的方式非常灵活。Logger和DB两个类没有任何关系，既不是继承关系，也不是接口和实现的关系，但是只要它们都有定义了record()方法，就可以被传递到test()方法中，在实际运行的时候，执行对应的record()方法。</p><p>也就是说，只要两个类具有相同的方法，就可以实现多态，并不要求两个类之间有任何关系，这就是所谓的duck-typing，是一些动态语言所特有的语法机制。而像Java这样的静态语言，通过继承实现多态特性，必须要求两个类之间有继承关系，通过接口实现多态特性，类必须实现对应的接口。</p><p><strong>多态特性讲完了，我们再来看，多态特性存在的意义是什么？它能解决什么编程问题？</strong></p><p>多态特性能提高代码的可扩展性和复用性。为什么这么说呢？我们回过头去看讲解多态特性的时候，举的第二个代码实例（Iterator的例子）。</p><p>在那个例子中，我们利用多态的特性，仅用一个print()函数就可以实现遍历打印不同类型（Array、LinkedList）集合的数据。当再增加一种要遍历打印的类型的时候，比如HashMap，我们只需让HashMap实现Iterator接口，重新实现自己的hasNext()、next()等方法就可以了，完全不需要改动print()函数的代码。所以说，多态提高了代码的可扩展性。</p><p>如果我们不使用多态特性，我们就无法将不同的集合类型（Array、LinkedList）传递给相同的函数（print(Iterator iterator)函数）。我们需要针对每种要遍历打印的集合，分别实现不同的print()函数，比如针对Array，我们要实现print(Array array)函数，针对LinkedList，我们要实现print(LinkedList linkedList)函数。而利用多态特性，我们只需要实现一个print()函数的打印逻辑，就能应对各种集合数据的打印操作，这显然提高了代码的复用性。</p><p>除此之外，多态也是很多设计模式、设计原则、编程技巧的代码实现基础，比如策略模式、基于接口而非实现编程、依赖倒置原则、里式替换原则、利用多态去掉冗长的if-else语句等等。关于这点，在学习后面的章节中，你慢慢会有更深的体会。</p><h2>重点回顾</h2><p>今天的内容就讲完了，我们来一起总结回顾一下，你需要重点掌握的几个知识点。</p><p><strong>1.关于封装特性</strong></p><p>封装也叫作信息隐藏或者数据访问保护。类通过暴露有限的访问接口，授权外部仅能通过类提供的方式来访问内部信息或者数据。它需要编程语言提供权限访问控制语法来支持，例如Java中的private、protected、public关键字。封装特性存在的意义，一方面是保护数据不被随意修改，提高代码的可维护性；另一方面是仅暴露有限的必要接口，提高类的易用性。</p><p><strong>2.关于抽象特性</strong></p><p>封装主要讲如何隐藏信息、保护数据，那抽象就是讲如何隐藏方法的具体实现，让使用者只需要关心方法提供了哪些功能，不需要知道这些功能是如何实现的。抽象可以通过接口类或者抽象类来实现，但也并不需要特殊的语法机制来支持。抽象存在的意义，一方面是提高代码的可扩展性、维护性，修改实现不需要改变定义，减少代码的改动范围；另一方面，它也是处理复杂系统的有效手段，能有效地过滤掉不必要关注的信息。</p><p><strong>3.关于继承特性</strong></p><p>继承是用来表示类之间的is-a关系，分为两种模式：单继承和多继承。单继承表示一个子类只继承一个父类，多继承表示一个子类可以继承多个父类。为了实现继承这个特性，编程语言需要提供特殊的语法机制来支持。继承主要是用来解决代码复用的问题。</p><p><strong>4.关于多态特性</strong></p><p>多态是指子类可以替换父类，在实际的代码运行过程中，调用子类的方法实现。多态这种特性也需要编程语言提供特殊的语法机制来实现，比如继承、接口类、duck-typing。多态可以提高代码的扩展性和复用性，是很多设计模式、设计原则、编程技巧的代码实现基础。</p><h2>课堂讨论</h2><p>今天我们要讨论的话题有如下两个。</p><ol>\n<li>你熟悉的编程语言是否支持多重继承？如果不支持，请说一下为什么不支持。如果支持，请说一下它是如何避免多重继承的副作用的。</li>\n<li>你熟悉的编程语言对于四大特性是否都有现成的语法支持？对于支持的特性，是通过什么语法机制实现的？对于不支持的特性，又是基于什么原因做的取舍？</li>\n</ol><p>欢迎在留言区写下你的答案，和同学一起交流和分享。如果有收获，也欢迎你把这篇文章分享给你的朋友。</p>",
                "article_title": "05 | 理论二：封装、抽象、继承、多态分别可以解决哪些编程问题？"
            },
            {
                "title": "06 | 理论三：面向对象相比面向过程有哪些优势？面向过程真的过时了吗？",
                "herf": "https://time.geekbang.org/column/article/161587",
                "id": "161587",
                "content": "<p>在上两节课中，我们讲了面向对象这种现在非常流行的编程范式，或者说编程风格。实际上，除了面向对象之外，被大家熟知的编程范式还有另外两种，面向过程编程和函数式编程。面向过程这种编程范式随着面向对象的出现，已经慢慢退出了舞台，而函数式编程目前还没有被广泛接受。</p><p>在专栏中，我不会对函数式编程做讲解，但我会花两节课的时间，讲一下面向过程这种编程范式。你可能会问，既然面向对象已经成为主流的编程范式，而面向过程已经不那么推荐使用，那为什么又要浪费时间讲它呢？</p><p>那是因为在过往的工作中，我发现很多人搞不清楚面向对象和面向过程的区别，总以为使用面向对象编程语言来做开发，就是在进行面向对象编程了。而实际上，他们只是在用面向对象编程语言，编写面向过程风格的代码而已，并没有发挥面向对象编程的优势。这就相当于手握一把屠龙刀，却只是把它当作一把普通的刀剑来用，相当可惜。</p><p>所以，我打算详细对比一下面向过程和面向对象这两种编程范式，带你一块搞清楚下面这几个问题（前三个问题我今天讲解，后三个问题我放到下一节课中讲解）：</p><ol>\n<li>什么是面向过程编程与面向过程编程语言？</li>\n<li>面向对象编程相比面向过程编程有哪些优势？</li>\n<li>为什么说面向对象编程语言比面向过程编程语言更高级？</li>\n<li>有哪些看似是面向对象实际是面向过程风格的代码？</li>\n<li>在面向对象编程中，为什么容易写出面向过程风格的代码？</li>\n<li>面向过程编程和面向过程编程语言就真的无用武之地了吗？</li>\n</ol><!-- [[[read_end]]] --><p>话不多说，带着这几个问题，我们就正式开始今天的学习吧！</p><h2>什么是面向过程编程与面向过程编程语言？</h2><p>如果你是一名比较资深的程序员，最开始学习编程的时候，接触的是Basic、Pascal、C等面向过程的编程语言，那你对这两个概念肯定不陌生。但如果你是新生代的程序员，一开始学编程的时候，接触的就是面向对象编程语言，那你对这两个概念可能会比较不熟悉。所以，在对比面向对象与面向过程优劣之前，我们先把面向过程编程和面向过程编程语言这两个概念搞清楚。</p><p>实际上，我们可以对比着面向对象编程和面向对象编程语言这两个概念，来理解面向过程编程和面向过程编程语言。还记得我们之前是如何定义面向对象编程和面向对象编程语言的吗？让我们一块再来回顾一下。</p><ul>\n<li>面向对象编程是一种编程范式或编程风格。它以类或对象作为组织代码的基本单元，并将封装、抽象、继承、多态四个特性，作为代码设计和实现的基石 。</li>\n<li>面向对象编程语言是支持类或对象的语法机制，并有现成的语法机制，能方便地实现面向对象编程四大特性（封装、抽象、继承、多态）的编程语言。</li>\n</ul><p>类比面向对象编程与面向对象编程语言的定义，对于面向过程编程和面向过程编程语言这两个概念，我给出下面这样的定义。</p><ul>\n<li>面向过程编程也是一种编程范式或编程风格。它以过程（可以理解为方法、函数、操作）作为组织代码的基本单元，以数据（可以理解为成员变量、属性）与方法相分离为最主要的特点。面向过程风格是一种流程化的编程风格，通过拼接一组顺序执行的方法来操作数据完成一项功能。</li>\n<li>面向过程编程语言首先是一种编程语言。它最大的特点是不支持类和对象两个语法概念，不支持丰富的面向对象编程特性（比如继承、多态、封装），仅支持面向过程编程。</li>\n</ul><p>不过，这里我必须声明一下，就像我们在之前讲到的，面向对象编程和面向对象编程语言并没有官方的定义一样，这里我给出的面向过程编程和面向过程编程语言的定义，也并不是严格的官方定义。之所以要给出这样的定义，只是为了跟面向对象编程及面向对象编程语言做个对比，以方便你理解它们的区别。</p><p>定义不是很严格，也比较抽象，所以，我再用一个例子进一步解释一下。假设我们有一个记录了用户信息的文本文件users.txt，每行文本的格式是name&amp;age&amp;gender（比如，小王&amp;28&amp;男）。我们希望写一个程序，从users.txt文件中逐行读取用户信息，然后格式化成name\\tage\\tgender（其中，\\t是分隔符）这种文本格式，并且按照age从小到大排序之后，重新写入到另一个文本文件formatted_users.txt中。针对这样一个小程序的开发，我们一块来看看，用面向过程和面向对象两种编程风格，编写出来的代码有什么不同。</p><p>首先，我们先来看，用面向过程这种编程风格写出来的代码是什么样子的。注意，下面的代码是用C语言这种面向过程的编程语言来编写的。</p><pre><code>struct User {\n  char name[64];\n  int age;\n  char gender[16];\n};\n\nstruct User parse_to_user(char* text) {\n  // 将text(“小王&amp;28&amp;男”)解析成结构体struct User\n}\n\nchar* format_to_text(struct User user) {\n  // 将结构体struct User格式化成文本（&quot;小王\\t28\\t男&quot;）\n}\n\nvoid sort_users_by_age(struct User users[]) {\n  // 按照年龄从小到大排序users\n}\n\nvoid format_user_file(char* origin_file_path, char* new_file_path) {\n  // open files...\n  struct User users[1024]; // 假设最大1024个用户\n  int count = 0;\n  while(1) { // read until the file is empty\n    struct User user = parse_to_user(line);\n    users[count++] = user;\n  }\n  \n  sort_users_by_age(users);\n  \n  for (int i = 0; i &lt; count; ++i) {\n    char* formatted_user_text = format_to_text(users[i]);\n    // write to new file...\n  }\n  // close files...\n}\n\nint main(char** args, int argv) {\n  format_user_file(&quot;/home/zheng/user.txt&quot;, &quot;/home/zheng/formatted_users.txt&quot;);\n}\n</code></pre><p>然后，我们再来看，用面向对象这种编程风格写出来的代码是什么样子的。注意，下面的代码是用Java这种面向对象的编程语言来编写的。</p><pre><code> public class User {\n  private String name;\n  private int age;\n  private String gender;\n  \n  public User(String name, int age, String gender) {\n    this.name = name;\n    this.age = age;\n    this.gender = gender;\n  }\n  \n  public static User praseFrom(String userInfoText) {\n    // 将text(“小王&amp;28&amp;男”)解析成类User\n  }\n  \n  public String formatToText() {\n    // 将类User格式化成文本（&quot;小王\\t28\\t男&quot;）\n  }\n}\n\npublic class UserFileFormatter {\n  public void format(String userFile, String formattedUserFile) {\n    // Open files...\n    List users = new ArrayList&lt;&gt;();\n    while (1) { // read until file is empty \n      // read from file into userText...\n      User user = User.parseFrom(userText);\n      users.add(user);\n    }\n    // sort users by age...\n    for (int i = 0; i &lt; users.size(); ++i) {\n      String formattedUserText = user.formatToText();\n      // write to new file...\n    }\n    // close files...\n  }\n}\n\npublic class MainApplication {\n  public static void main(String[] args) {\n    UserFileFormatter userFileFormatter = new UserFileFormatter();\n    userFileFormatter.format(&quot;/home/zheng/users.txt&quot;, &quot;/home/zheng/formatted_users.txt&quot;);\n  }\n}\n</code></pre><p>从上面的代码中，我们可以看出，面向过程和面向对象最基本的区别就是，代码的组织方式不同。面向过程风格的代码被组织成了一组方法集合及其数据结构（struct User），方法和数据结构的定义是分开的。面向对象风格的代码被组织成一组类，方法和数据结构被绑定一起，定义在类中。</p><p>看完这个例子之后，你可能会说，面向对象编程和面向过程编程，两种风格的区别就这么一点吗？当然不是，对于这两种编程风格的更多区别，我们继续往下看。</p><h2>面向对象编程相比面向过程编程有哪些优势？</h2><p>刚刚我们介绍了面向过程编程及面向过程编程语言的定义，并跟面向对象编程及面向对象编程语言做了一个简单对比。接下来，我们再来看一下，为什么面向对象编程晚于面向过程编程出现，却能取而代之，成为现在主流的编程范式？面向对象编程跟面向过程编程比起来，到底有哪些优势？</p><h3>1.OOP更加能够应对大规模复杂程序的开发</h3><p>看了刚刚举的那个格式化文本文件的例子，你可能会有这样的疑问，两种编程风格实现的代码貌似差不多啊，顶多就是代码的组织方式有点区别，没有感觉到面向对象编程有什么明显的优势呀！你的感觉没错。之所以有这种感觉，主要原因是这个例子程序比较简单、不够复杂。</p><p>对于简单程序的开发来说，不管是用面向过程编程风格，还是用面向对象编程风格，差别确实不会很大，甚至有的时候，面向过程的编程风格反倒更有优势。因为需求足够简单，整个程序的处理流程只有一条主线，很容易被划分成顺序执行的几个步骤，然后逐句翻译成代码，这就非常适合采用面向过程这种面条式的编程风格来实现。</p><p>但对于大规模复杂程序的开发来说，整个程序的处理流程错综复杂，并非只有一条主线。如果把整个程序的处理流程画出来的话，会是一个网状结构。如果我们再用面向过程编程这种流程化、线性的思维方式，去翻译这个网状结构，去思考如何把程序拆解为一组顺序执行的方法，就会比较吃力。这个时候，面向对象的编程风格的优势就比较明显了。</p><p>面向对象编程是以类为思考对象。在进行面向对象编程的时候，我们并不是一上来就去思考，如何将复杂的流程拆解为一个一个方法，而是采用曲线救国的策略，先去思考如何给业务建模，如何将需求翻译为类，如何给类之间建立交互关系，而完成这些工作完全不需要考虑错综复杂的处理流程。当我们有了类的设计之后，然后再像搭积木一样，按照处理流程，将类组装起来形成整个程序。这种开发模式、思考问题的方式，能让我们在应对复杂程序开发的时候，思路更加清晰。</p><p>除此之外，面向对象编程还提供了一种更加清晰的、更加模块化的代码组织方式。比如，我们开发一个电商交易系统，业务逻辑复杂，代码量很大，可能要定义数百个函数、数百个数据结构，那如何分门别类地组织这些函数和数据结构，才能不至于看起来比较凌乱呢？类就是一种非常好的组织这些函数和数据结构的方式，是一种将代码模块化的有效手段。</p><p>你可能会说，像C语言这种面向过程的编程语言，我们也可以按照功能的不同，把函数和数据结构放到不同的文件里，以达到给函数和数据结构分类的目的，照样可以实现代码的模块化。你说得没错。只不过面向对象编程本身提供了类的概念，强制你做这件事情，而面向过程编程并不强求。这也算是面向对象编程相对于面向过程编程的一个微创新吧。</p><p>实际上，利用面向过程的编程语言照样可以写出面向对象风格的代码，只不过可能会比用面向对象编程语言来写面向对象风格的代码，付出的代价要高一些。而且，面向过程编程和面向对象编程并非完全对立的。很多软件开发中，尽管利用的是面向过程的编程语言，也都有借鉴面向对象编程的一些优点。</p><h3>2.OOP风格的代码更易复用、易扩展、易维护</h3><p>在刚刚的那个例子中，因为代码比较简单，所以只用到到了类、对象这两个最基本的面向对象概念，并没有用到更加高级的四大特性，封装、抽象、继承、多态。因此，面向对象编程的优势其实并没有发挥出来。</p><p>面向过程编程是一种非常简单的编程风格，并没有像面向对象编程那样提供丰富的特性。而面向对象编程提供的封装、抽象、继承、多态这些特性，能极大地满足复杂的编程需求，能方便我们写出更易复用、易扩展、易维护的代码。为什么这么说呢？还记得我们在上一节课中讲到的封装、抽象、继承、多态存在的意义吗？我们再来简单回顾一下。</p><p>首先，我们先来看下封装特性。封装特性是面向对象编程相比于面向过程编程的一个最基本的区别，因为它基于的是面向对象编程中最基本的类的概念。面向对象编程通过类这种组织代码的方式，将数据和方法绑定在一起，通过访问权限控制，只允许外部调用者通过类暴露的有限方法访问数据，而不会像面向过程编程那样，数据可以被任意方法随意修改。因此，面向对象编程提供的封装特性更有利于提高代码的易维护性。</p><p>其次，我们再来看下抽象特性。我们知道，函数本身就是一种抽象，它隐藏了具体的实现。我们在使用函数的时候，只需要了解函数具有什么功能，而不需要了解它是怎么实现的。从这一点上，不管面向过程编程还是是面向对象编程，都支持抽象特性。不过，面向对象编程还提供了其他抽象特性的实现方式。这些实现方式是面向过程编程所不具备的，比如基于接口实现的抽象。基于接口的抽象，可以让我们在不改变原有实现的情况下，轻松替换新的实现逻辑，提高了代码的可扩展性。</p><p>再次，我们来看下继承特性。继承特性是面向对象编程相比于面向过程编程所特有的两个特性之一（另一个是多态）。如果两个类有一些相同的属性和方法，我们就可以将这些相同的代码，抽取到父类中，让两个子类继承父类。这样两个子类也就可以重用父类中的代码，避免了代码重复写多遍，提高了代码的复用性。</p><p>最后，我们来看下多态特性。基于这个特性，我们在需要修改一个功能实现的时候，可以通过实现一个新的子类的方式，在子类中重写原来的功能逻辑，用子类替换父类。在实际的代码运行过程中，调用子类新的功能逻辑，而不是在原有代码上做修改。这就遵从了“对修改关闭、对扩展开放”的设计原则，提高代码的扩展性。除此之外，利用多态特性，不同的类对象可以传递给相同的方法，执行不同的代码逻辑，提高了代码的复用性。</p><p>所以说，基于这四大特性，利用面向对象编程，我们可以更轻松地写出易复用、易扩展、易维护的代码。当然，我们不能说，利用面向过程风格就不可以写出易复用、易扩展、易维护的代码，但没有四大特性的帮助，付出的代价可能就要高一些。</p><h3>3.OOP语言更加人性化、更加高级、更加智能</h3><p>人类最开始跟机器打交道是通过0、1这样的二进制指令，然后是汇编语言，再之后才出现了高级编程语言。在高级编程语言中，面向过程编程语言又早于面向对象编程语言出现。之所以先出现面向过程编程语言，那是因为跟机器交互的方式，从二进制指令、汇编语言到面向过程编程语言，是一个非常自然的过渡，都是一种流程化的、面条式的编程风格，用一组指令顺序操作数据，来完成一项任务。</p><p>从指令到汇编再到面向过程编程语言，跟机器打交道的方式在不停地演进，从中我们很容易发现这样一条规律，那就是编程语言越来越人性化，让人跟机器打交道越来越容易。笼统点讲，就是编程语言越来越高级。实际上，在面向过程编程语言之后，面向对象编程语言的出现，也顺应了这样的发展规律，也就是说，面向对象编程语言比面向过程编程语言更加高级！</p><p>跟二进制指令、汇编语言、面向过程编程语言相比，面向对象编程语言的编程套路、思考问题的方式，是完全不一样的。前三者是一种计算机思维方式，而面向对象是一种人类的思维方式。我们在用前面三种语言编程的时候，我们是在思考，如何设计一组指令，告诉机器去执行这组指令，操作某些数据，帮我们完成某个任务。而在进行面向对象编程时候，我们是在思考，如何给业务建模，如何将真实的世界映射为类或者对象，这让我们更加能聚焦到业务本身，而不是思考如何跟机器打交道。可以这么说，越高级的编程语言离机器越“远”，离我们人类越“近”，越“智能”。</p><p>这里多聊几句，顺着刚刚这个编程语言的发展规律来想，如果一种新的突破性的编程语言出现，那它肯定是更加“智能”的。大胆想象一下，使用这种编程语言，我们可以无需对计算机知识有任何了解，无需像现在这样一行一行地敲很多代码，只需要把需求文档写清楚，就能自动生成我们想要的软件了。</p><h2>重点回顾</h2><p>今天的内容就讲完了，我们来一起总结回顾一下，你需要重点掌握的几个知识点。</p><p><strong>1.什么是面向过程编程？什么是面向过程编程语言？</strong></p><p>实际上，面向过程编程和面向过程编程语言并没有严格的官方定义。理解这两个概念最好的方式是跟面向对象编程和面向对象编程语言进行对比。相较于面向对象编程以类为组织代码的基本单元，面向过程编程则是以过程（或方法）作为组织代码的基本单元。它最主要的特点就是数据和方法相分离。相较于面向对象编程语言，面向过程编程语言最大的特点就是不支持丰富的面向对象编程特性，比如继承、多态、封装。</p><p><strong>2.面向对象编程相比面向过程编程有哪些优势？</strong></p><p>面向对象编程相比起面向过程编程的优势主要有三个。</p><ul>\n<li>对于大规模复杂程序的开发，程序的处理流程并非单一的一条主线，而是错综复杂的网状结构。面向对象编程比起面向过程编程，更能应对这种复杂类型的程序开发。</li>\n<li>面向对象编程相比面向过程编程，具有更加丰富的特性（封装、抽象、继承、多态）。利用这些特性编写出来的代码，更加易扩展、易复用、易维护。</li>\n<li>从编程语言跟机器打交道的方式的演进规律中，我们可以总结出：面向对象编程语言比起面向过程编程语言，更加人性化、更加高级、更加智能。</li>\n</ul><h2>课堂讨论</h2><p>在文章中我讲到，面向对象编程比面向过程编程，更加容易应对大规模复杂程序的开发。但像Unix、Linux这些复杂的系统，也都是基于C语言这种面向过程的编程语言开发的，你怎么看待这个现象？这跟我之前的讲解相矛盾吗？</p><p>欢迎在留言区写下你的答案，和同学一起交流和分享。如果有收获，也欢迎你把这篇文章分享给你的朋友。</p>",
                "article_title": "06 | 理论三：面向对象相比面向过程有哪些优势？面向过程真的过时了吗？"
            },
            {
                "title": "07 | 理论四：哪些代码设计看似是面向对象，实际是面向过程的？",
                "herf": "https://time.geekbang.org/column/article/164907",
                "id": "164907",
                "content": "<p>上一节课，我们提到，常见的编程范式或者说编程风格有三种，面向过程编程、面向对象编程、函数式编程，而面向对象编程又是这其中最主流的编程范式。现如今，大部分编程语言都是面向对象编程语言，大部分软件都是基于面向对象编程这种编程范式来开发的。</p><p>不过，在实际的开发工作中，很多同学对面向对象编程都有误解，总以为把所有代码都塞到类里，自然就是在进行面向对象编程了。实际上，这样的认识是不正确的。有时候，从表面上看似是面向对象编程风格的代码，从本质上看却是面向过程编程风格的。</p><p>所以，今天，我结合具体的代码实例来讲一讲，有哪些看似是面向对象，实际上是面向过程编程风格的代码，并且分析一下，为什么我们很容易写出这样的代码。最后，我们再一起辩证思考一下，面向过程编程是否就真的无用武之地了呢？是否有必要杜绝在面向对象编程中写面向过程风格的代码呢？</p><p>好了，现在，让我们正式开始今天的学习吧！</p><h2>哪些代码设计看似是面向对象，实际是面向过程的？</h2><p>在用面向对象编程语言进行软件开发的时候，我们有时候会写出面向过程风格的代码。有些是有意为之，并无不妥；而有些是无意为之，会影响到代码的质量。下面我就通过三个典型的代码案例，给你展示一下，什么样的代码看似是面向对象风格，实际上是面向过程风格的。我也希望你通过对这三个典型例子的学习，能够做到举一反三，在平时的开发中，多留心一下自己编写的代码是否满足面向对象风格。</p><!-- [[[read_end]]] --><h3>1.滥用getter、setter方法</h3><p>在之前参与的项目开发中，我经常看到，有同事定义完类的属性之后，就顺手把这些属性的getter、setter方法都定义上。有些同事更加省事，直接用IDE或者Lombok插件（如果是Java项目的话）自动生成所有属性的getter、setter方法。</p><p>当我问起，为什么要给每个属性都定义getter、setter方法的时候，他们的理由一般是，为了以后可能会用到，现在事先定义好，类用起来就更加方便，而且即便用不到这些getter、setter方法，定义上它们也无伤大雅。</p><p>实际上，这样的做法我是非常不推荐的。它违反了面向对象编程的封装特性，相当于将面向对象编程风格退化成了面向过程编程风格。我通过下面这个例子来给你解释一下这句话。</p><pre><code>public class ShoppingCart {\n  private int itemsCount;\n  private double totalPrice;\n  private List&lt;ShoppingCartItem&gt; items = new ArrayList&lt;&gt;();\n  \n  public int getItemsCount() {\n    return this.itemsCount;\n  }\n  \n  public void setItemsCount(int itemsCount) {\n    this.itemsCount = itemsCount;\n  }\n  \n  public double getTotalPrice() {\n    return this.totalPrice;\n  }\n  \n  public void setTotalPrice(double totalPrice) {\n    this.totalPrice = totalPrice;\n  }\n\n  public List&lt;ShoppingCartItem&gt; getItems() {\n    return this.items;\n  }\n  \n  public void addItem(ShoppingCartItem item) {\n    items.add(item);\n    itemsCount++;\n    totalPrice += item.getPrice();\n  }\n  // ...省略其他方法...\n}\n</code></pre><p>在这段代码中，ShoppingCart是一个简化后的购物车类，有三个私有（private）属性：itemsCount、totalPrice、items。对于itemsCount、totalPrice两个属性，我们定义了它们的getter、setter方法。对于items属性，我们定义了它的getter方法和addItem()方法。代码很简单，理解起来不难。那你有没有发现，这段代码有什么问题呢？</p><p>我们先来看前两个属性，itemsCount和totalPrice。虽然我们将它们定义成private私有属性，但是提供了public的getter、setter方法，这就跟将这两个属性定义为public公有属性，没有什么两样了。外部可以通过setter方法随意地修改这两个属性的值。除此之外，任何代码都可以随意调用setter方法，来重新设置itemsCount、totalPrice属性的值，这也会导致其跟items属性的值不一致。</p><p>而面向对象封装的定义是：通过访问权限控制，隐藏内部数据，外部仅能通过类提供的有限的接口访问、修改内部数据。所以，暴露不应该暴露的setter方法，明显违反了面向对象的封装特性。数据没有访问权限控制，任何代码都可以随意修改它，代码就退化成了面向过程编程风格的了。</p><p>看完了前两个属性，我们再来看items这个属性。对于items这个属性，我们定义了它的getter方法和addItem()方法，并没有定义它的setter方法。这样的设计貌似看起来没有什么问题，但实际上并不是。</p><p>对于itemsCount和totalPrice这两个属性来说，定义一个public的getter方法，确实无伤大雅，毕竟getter方法不会修改数据。但是，对于items属性就不一样了，这是因为items属性的getter方法，返回的是一个List<shoppingcartitem>集合容器。外部调用者在拿到这个容器之后，是可以操作容器内部数据的，也就是说，外部代码还是能修改items中的数据。比如像下面这样：</shoppingcartitem></p><pre><code>ShoppingCart cart = new ShoppCart();\n...\ncart.getItems().clear(); // 清空购物车\n</code></pre><p>你可能会说，清空购物车这样的功能需求看起来合情合理啊，上面的代码没有什么不妥啊。你说得没错，需求是合理的，但是这样的代码写法，会导致itemsCount、totalPrice、items三者数据不一致。我们不应该将清空购物车的业务逻辑暴露给上层代码。正确的做法应该是，在ShoppingCart类中定义一个clear()方法，将清空购物车的业务逻辑封装在里面，透明地给调用者使用。ShoppingCart类的clear()方法的具体代码实现如下：</p><pre><code>public class ShoppingCart {\n  // ...省略其他代码...\n  public void clear() {\n    items.clear();\n    itemsCount = 0;\n    totalPrice = 0.0;\n  }\n}\n</code></pre><p>你可能还会说，我有一个需求，需要查看购物车中都买了啥，那这个时候，ShoppingCart类不得不提供items属性的getter方法了，那又该怎么办才好呢？</p><p>如果你熟悉Java语言，那解决这个问题的方法还是挺简单的。我们可以通过Java提供的Collections.unmodifiableList()方法，让getter方法返回一个不可被修改的UnmodifiableList集合容器，而这个容器类重写了List容器中跟修改数据相关的方法，比如add()、clear()等方法。一旦我们调用这些修改数据的方法，代码就会抛出UnsupportedOperationException异常，这样就避免了容器中的数据被修改。具体的代码实现如下所示。</p><pre><code>public class ShoppingCart {\n  // ...省略其他代码...\n  public List&lt;ShoppingCartItem&gt; getItems() {\n    return Collections.unmodifiableList(this.items);\n  }\n}\n\npublic class UnmodifiableList&lt;E&gt; extends UnmodifiableCollection&lt;E&gt;\n                          implements List&lt;E&gt; {\n  public boolean add(E e) {\n    throw new UnsupportedOperationException();\n  }\n  public void clear() {\n    throw new UnsupportedOperationException();\n  }\n  // ...省略其他代码...\n}\n\nShoppingCart cart = new ShoppingCart();\nList&lt;ShoppingCartItem&gt; items = cart.getItems();\nitems.clear();//抛出UnsupportedOperationException异常\n</code></pre><p>不过，这样的实现思路还是有点问题。因为当调用者通过ShoppingCart的getItems()获取到items之后，虽然我们没法修改容器中的数据，但我们仍然可以修改容器中每个对象（ShoppingCartItem）的数据。听起来有点绕，看看下面这几行代码你就明白了。</p><pre><code>ShoppingCart cart = new ShoppingCart();\ncart.add(new ShoppingCartItem(...));\nList&lt;ShoppingCartItem&gt; items = cart.getItems();\nShoppingCartItem item = items.get(0);\nitem.setPrice(19.0); // 这里修改了item的价格属性\n</code></pre><p>这个问题该如何解决呢？我今天就不展开来讲了。在后面讲到设计模式的时候，我还会详细地讲到。当然，你也可以在留言区留言或者把问题分享给你的朋友，和他一起讨论解决方案。</p><p>getter、setter问题我们就讲完了，我稍微总结一下，在设计实现类的时候，除非真的需要，否则，尽量不要给属性定义setter方法。除此之外，尽管getter方法相对setter方法要安全些，但是如果返回的是集合容器（比如例子中的List容器），也要防范集合内部数据被修改的危险。</p><h3>2.滥用全局变量和全局方法</h3><p>我们再来看，另外一个违反面向对象编程风格的例子，那就是滥用全局变量和全局方法。首先，我们先来看，什么是全局变量和全局方法？</p><p>如果你是用类似C语言这样的面向过程的编程语言来做开发，那对全局变量、全局方法肯定不陌生，甚至可以说，在代码中到处可见。但如果你是用类似Java这样的面向对象的编程语言来做开发，全局变量和全局方法就不是很多见了。</p><p>在面向对象编程中，常见的全局变量有单例类对象、静态成员变量、常量等，常见的全局方法有静态方法。单例类对象在全局代码中只有一份，所以，它相当于一个全局变量。静态成员变量归属于类上的数据，被所有的实例化对象所共享，也相当于一定程度上的全局变量。而常量是一种非常常见的全局变量，比如一些代码中的配置参数，一般都设置为常量，放到一个Constants类中。静态方法一般用来操作静态变量或者外部数据。你可以联想一下我们常用的各种Utils类，里面的方法一般都会定义成静态方法，可以在不用创建对象的情况下，直接拿来使用。静态方法将方法与数据分离，破坏了封装特性，是典型的面向过程风格。</p><p>在刚刚介绍的这些全局变量和全局方法中，Constants类和Utils类最常用到。现在，我们就结合这两个几乎在每个软件开发中都会用到的类，来深入探讨一下全局变量和全局方法的利与弊。</p><p><strong>我们先来看一下，在我过去参与的项目中，一种常见的Constants类的定义方法</strong>。</p><pre><code>public class Constants {\n  public static final String MYSQL_ADDR_KEY = &quot;mysql_addr&quot;;\n  public static final String MYSQL_DB_NAME_KEY = &quot;db_name&quot;;\n  public static final String MYSQL_USERNAME_KEY = &quot;mysql_username&quot;;\n  public static final String MYSQL_PASSWORD_KEY = &quot;mysql_password&quot;;\n  \n  public static final String REDIS_DEFAULT_ADDR = &quot;192.168.7.2:7234&quot;;\n  public static final int REDIS_DEFAULT_MAX_TOTAL = 50;\n  public static final int REDIS_DEFAULT_MAX_IDLE = 50;\n  public static final int REDIS_DEFAULT_MIN_IDLE = 20;\n  public static final String REDIS_DEFAULT_KEY_PREFIX = &quot;rt:&quot;;\n  \n  // ...省略更多的常量定义...\n}\n</code></pre><p>在这段代码中，我们把程序中所有用到的常量，都集中地放到这个Constants类中。不过，定义一个如此大而全的Constants类，并不是一种很好的设计思路。为什么这么说呢？原因主要有以下几点。</p><p>首先，这样的设计会影响代码的可维护性。</p><p>如果参与开发同一个项目的工程师有很多，在开发过程中，可能都要涉及修改这个类，比如往这个类里添加常量，那这个类就会变得越来越大，成百上千行都有可能，查找修改某个常量也会变得比较费时，而且还会增加提交代码冲突的概率。</p><p>其次，这样的设计还会增加代码的编译时间。</p><p>当Constants类中包含很多常量定义的时候，依赖这个类的代码就会很多。那每次修改Constants类，都会导致依赖它的类文件重新编译，因此会浪费很多不必要的编译时间。不要小看编译花费的时间，对于一个非常大的工程项目来说，编译一次项目花费的时间可能是几分钟，甚至几十分钟。而我们在开发过程中，每次运行单元测试，都会触发一次编译的过程，这个编译时间就有可能会影响到我们的开发效率。</p><p>最后，这样的设计还会影响代码的复用性。</p><p>如果我们要在另一个项目中，复用本项目开发的某个类，而这个类又依赖Constants类。即便这个类只依赖Constants类中的一小部分常量，我们仍然需要把整个Constants类也一并引入，也就引入了很多无关的常量到新的项目中。</p><p>那如何改进Constants类的设计呢？我这里有两种思路可以借鉴。</p><p>第一种是将Constants类拆解为功能更加单一的多个类，比如跟MySQL配置相关的常量，我们放到MysqlConstants类中；跟Redis配置相关的常量，我们放到RedisConstants类中。当然，还有一种我个人觉得更好的设计思路，那就是并不单独地设计Constants常量类，而是哪个类用到了某个常量，我们就把这个常量定义到这个类中。比如，RedisConfig类用到了Redis配置相关的常量，那我们就直接将这些常量定义在RedisConfig中，这样也提高了类设计的内聚性和代码的复用性。</p><p><strong>讲完了Constants类，我们再来讨论一下Utils类。</strong>首先，我想问你这样一个问题，我们为什么需要Utils类？Utils类存在的意义是什么？希望你先思考一下，然后再来看我下面的讲解。</p><p>实际上，Utils类的出现是基于这样一个问题背景：如果我们有两个类A和B，它们要用到一块相同的功能逻辑，为了避免代码重复，我们不应该在两个类中，将这个相同的功能逻辑，重复地实现两遍。这个时候我们该怎么办呢？</p><p>我们在讲面向对象特性的时候，讲过继承可以实现代码复用。利用继承特性，我们把相同的属性和方法，抽取出来，定义到父类中。子类复用父类中的属性和方法，达到代码复用的目的。但是，有的时候，从业务含义上，A类和B类并不一定具有继承关系，比如Crawler类和PageAnalyzer类，它们都用到了URL拼接和分割的功能，但并不具有继承关系（既不是父子关系，也不是兄弟关系）。仅仅为了代码复用，生硬地抽象出一个父类出来，会影响到代码的可读性。如果不熟悉背后设计思路的同事，发现Crawler类和PageAnalyzer类继承同一个父类，而父类中定义的却是URL相关的操作，会觉得这个代码写得莫名其妙，理解不了。</p><p>既然继承不能解决这个问题，我们可以定义一个新的类，实现URL拼接和分割的方法。而拼接和分割两个方法，不需要共享任何数据，所以新的类不需要定义任何属性，这个时候，我们就可以把它定义为只包含静态方法的Utils类了。</p><p>实际上，只包含静态方法不包含任何属性的Utils类，是彻彻底底的面向过程的编程风格。但这并不是说，我们就要杜绝使用Utils类了。实际上，从刚刚讲的Utils类存在的目的来看，它在软件开发中还是挺有用的，能解决代码复用问题。所以，这里并不是说完全不能用Utils类，而是说，要尽量避免滥用，不要不加思考地随意去定义Utils类。</p><p>在定义Utils类之前，你要问一下自己，你真的需要单独定义这样一个Utils类吗？是否可以把Utils类中的某些方法定义到其他类中呢？如果在回答完这些问题之后，你还是觉得确实有必要去定义这样一个Utils类，那就大胆地去定义它吧。因为即便在面向对象编程中，我们也并不是完全排斥面向过程风格的代码。只要它能为我们写出好的代码贡献力量，我们就可以适度地去使用。</p><p>除此之外，类比Constants类的设计，我们设计Utils类的时候，最好也能细化一下，针对不同的功能，设计不同的Utils类，比如FileUtils、IOUtils、StringUtils、UrlUtils等，不要设计一个过于大而全的Utils类。</p><h3>3.定义数据和方法分离的类</h3><p>我们再来看最后一种面向对象编程过程中，常见的面向过程风格的代码。那就是，数据定义在一个类中，方法定义在另一个类中。你可能会觉得，这么明显的面向过程风格的代码，谁会这么写呢？实际上，如果你是基于MVC三层结构做Web方面的后端开发，这样的代码你可能天天都在写。</p><p>传统的MVC结构分为Model层、Controller层、View层这三层。不过，在做前后端分离之后，三层结构在后端开发中，会稍微有些调整，被分为Controller层、Service层、Repository层。Controller层负责暴露接口给前端调用，Service层负责核心业务逻辑，Repository层负责数据读写。而在每一层中，我们又会定义相应的VO（View Object）、BO（Business Object）、Entity。一般情况下，VO、BO、Entity中只会定义数据，不会定义方法，所有操作这些数据的业务逻辑都定义在对应的Controller类、Service类、Repository类中。这就是典型的面向过程的编程风格。</p><p>实际上，这种开发模式叫作基于贫血模型的开发模式，也是我们现在非常常用的一种Web项目的开发模式。看到这里，你内心里应该有很多疑惑吧？既然这种开发模式明显违背面向对象的编程风格，为什么大部分Web项目都是基于这种开发模式来开发呢？</p><p>关于这个问题，我今天不打算展开讲解。因为它跟我们平时的项目开发结合得非常紧密，所以，更加细致、全面的讲解，我把它安排在面向对象实战环节里了，希望用两节课的时间，把这个问题给你讲透彻。</p><h2>在面向对象编程中，为什么容易写出面向过程风格的代码？</h2><p>我们在进行面向对象编程的时候，很容易不由自主地就写出面向过程风格的代码，或者说感觉面向过程风格的代码更容易写。这是为什么呢？</p><p>你可以联想一下，在生活中，你去完成一个任务，你一般都会思考，应该先做什么、后做什么，如何一步一步地顺序执行一系列操作，最后完成整个任务。面向过程编程风格恰恰符合人的这种流程化思维方式。而面向对象编程风格正好相反。它是一种自底向上的思考方式。它不是先去按照执行流程来分解任务，而是将任务翻译成一个一个的小的模块（也就是类），设计类之间的交互，最后按照流程将类组装起来，完成整个任务。我们在上一节课讲到了，这样的思考路径比较适合复杂程序的开发，但并不是特别符合人类的思考习惯。</p><p>除此之外，面向对象编程要比面向过程编程难一些。在面向对象编程中，类的设计还是挺需要技巧，挺需要一定设计经验的。你要去思考如何封装合适的数据和方法到一个类里，如何设计类之间的关系，如何设计类之间的交互等等诸多设计问题。</p><p>所以，基于这两点原因，很多工程师在开发的过程，更倾向于用不太需要动脑子的方式去实现需求，也就不由自主地就将代码写成面向过程风格的了。</p><h2>面向过程编程及面向过程编程语言就真的无用武之地了吗？</h2><p>前面我们讲了面向对象编程相比面向过程编程的各种优势，又讲了哪些代码看起来像面向对象风格，而实际上是面向过程编程风格的。那是不是面向过程编程风格就过时了被淘汰了呢？是不是在面向对象编程开发中，我们就要杜绝写面向过程风格的代码呢？</p><p>前面我们有讲到，如果我们开发的是微小程序，或者是一个数据处理相关的代码，以算法为主，数据为辅，那脚本式的面向过程的编程风格就更适合一些。当然，面向过程编程的用武之地还不止这些。实际上，面向过程编程是面向对象编程的基础，面向对象编程离不开基础的面向过程编程。为什么这么说？我们仔细想想，类中每个方法的实现逻辑，不就是面向过程风格的代码吗？</p><p>除此之外，面向对象和面向过程两种编程风格，也并不是非黑即白、完全对立的。在用面向对象编程语言开发的软件中，面向过程风格的代码并不少见，甚至在一些标准的开发库（比如JDK、Apache Commons、Google Guava）中，也有很多面向过程风格的代码。</p><p>不管使用面向过程还是面向对象哪种风格来写代码，我们最终的目的还是写出易维护、易读、易复用、易扩展的高质量代码。只要我们能避免面向过程编程风格的一些弊端，控制好它的副作用，在掌控范围内为我们所用，我们就大可不用避讳在面向对象编程中写面向过程风格的代码。</p><h2>重点回顾</h2><p>今天的内容讲完了。让我们一块回顾一下，你应该掌握的重点内容。今天你要掌握的重点内容是三种违反面向对象编程风格的典型代码设计。</p><p><strong>1.滥用getter、setter方法</strong></p><p>在设计实现类的时候，除非真的需要，否则尽量不要给属性定义setter方法。除此之外，尽管getter方法相对setter方法要安全些，但是如果返回的是集合容器，那也要防范集合内部数据被修改的风险。</p><p><strong>2.Constants类、Utils类的设计问题</strong></p><p>对于这两种类的设计，我们尽量能做到职责单一，定义一些细化的小类，比如RedisConstants、FileUtils，而不是定义一个大而全的Constants类、Utils类。除此之外，如果能将这些类中的属性和方法，划分归并到其他业务类中，那是最好不过的了，能极大地提高类的内聚性和代码的可复用性。</p><p><strong>3.基于贫血模型的开发模式</strong></p><p>关于这一部分，我们只讲了为什么这种开发模式是彻彻底底的面向过程编程风格的。这是因为数据和操作是分开定义在VO/BO/Entity和Controler/Service/Repository中的。今天，你只需要掌握这一点就可以了。为什么这种开发模式如此流行？如何规避面向过程编程的弊端？有没有更好的可替代的开发模式？相关的更多问题，我们在面向对象实战篇中会一一讲解。</p><h2>课堂讨论</h2><p>今天课堂讨论的话题有两个，你可以选择一个熟悉的来发表观点。</p><p>1.今天我们讲到，用面向对象编程语言写出来的代码，不一定是面向对象编程风格的，有可能是面向过程编程风格的。相反，用面向过程编程语言照样也可以写出面向对象编程风格的代码。尽管面向过程编程语言可能没有现成的语法来支持面向对象的四大特性，但可以通过其他方式来模拟，比如在C语言中，我们可以利用函数指针来模拟多态。如果你熟悉一门面向过程的编程语言，你能聊一聊如何用它来模拟面向对象的四大特性吗？</p><p>2.看似是面向对象实际上是面向过程编程风格的代码有很多，除了今天我讲到的这三个，在你工作中，你还遇到过哪些其他情况吗？</p><p>欢迎在留言区写下你的答案，和同学一起交流和分享。如果有收获，也欢迎你把这篇文章分享给你的朋友。</p>",
                "article_title": "07 | 理论四：哪些代码设计看似是面向对象，实际是面向过程的？"
            },
            {
                "title": "08 | 理论五：接口vs抽象类的区别？如何用普通的类模拟抽象类和接口？",
                "herf": "https://time.geekbang.org/column/article/165103",
                "id": "165103",
                "content": "<p>在面向对象编程中，抽象类和接口是两个经常被用到的语法概念，是面向对象四大特性，以及很多设计模式、设计思想、设计原则编程实现的基础。比如，我们可以使用接口来实现面向对象的抽象特性、多态特性和基于接口而非实现的设计原则，使用抽象类来实现面向对象的继承特性和模板设计模式等等。</p><p>不过，并不是所有的面向对象编程语言都支持这两个语法概念，比如，C++这种编程语言只支持抽象类，不支持接口；而像Python这样的动态编程语言，既不支持抽象类，也不支持接口。尽管有些编程语言没有提供现成的语法来支持接口和抽象类，我们仍然可以通过一些手段来模拟实现这两个语法概念。</p><p>这两个语法概念不仅在工作中经常会被用到，在面试中也经常被提及。比如，“接口和抽象类的区别是什么？什么时候用接口？什么时候用抽象类？抽象类和接口存在的意义是什么？能解决哪些编程问题？”等等。</p><p>你可以先试着回答一下，刚刚我提出的几个问题。如果你对某些问题还有些模糊不清，那也没关系，今天，我会带你把这几个问题彻底搞清楚。下面我们就一起来看！</p><h2>什么是抽象类和接口？区别在哪里？</h2><p>不同的编程语言对接口和抽象类的定义方式可能有些差别，但差别并不会很大。Java这种编程语言，既支持抽象类，也支持接口，所以，为了让你对这两个语法概念有比较直观的认识，我们拿Java这种编程语言来举例讲解。</p><!-- [[[read_end]]] --><p><strong>首先，我们来看一下，在Java这种编程语言中，我们是如何定义抽象类的。</strong></p><p>下面这段代码是一个比较典型的抽象类的使用场景（模板设计模式）。Logger是一个记录日志的抽象类，FileLogger和MessageQueueLogger继承Logger，分别实现两种不同的日志记录方式：记录日志到文件中和记录日志到消息队列中。FileLogger和MessageQueueLogger两个子类复用了父类Logger中的name、enabled、minPermittedLevel属性和log()方法，但因为这两个子类写日志的方式不同，它们又各自重写了父类中的doLog()方法。</p><pre><code>// 抽象类\npublic abstract class Logger {\n  private String name;\n  private boolean enabled;\n  private Level minPermittedLevel;\n\n  public Logger(String name, boolean enabled, Level minPermittedLevel) {\n    this.name = name;\n    this.enabled = enabled;\n    this.minPermittedLevel = minPermittedLevel;\n  }\n  \n  public void log(Level level, String message) {\n    boolean loggable = enabled &amp;&amp; (minPermittedLevel.intValue() &lt;= level.intValue());\n    if (!loggable) return;\n    doLog(level, message);\n  }\n  \n  protected abstract void doLog(Level level, String message);\n}\n// 抽象类的子类：输出日志到文件\npublic class FileLogger extends Logger {\n  private Writer fileWriter;\n\n  public FileLogger(String name, boolean enabled,\n    Level minPermittedLevel, String filepath) {\n    super(name, enabled, minPermittedLevel);\n    this.fileWriter = new FileWriter(filepath); \n  }\n  \n  @Override\n  public void doLog(Level level, String mesage) {\n    // 格式化level和message,输出到日志文件\n    fileWriter.write(...);\n  }\n}\n// 抽象类的子类: 输出日志到消息中间件(比如kafka)\npublic class MessageQueueLogger extends Logger {\n  private MessageQueueClient msgQueueClient;\n  \n  public MessageQueueLogger(String name, boolean enabled,\n    Level minPermittedLevel, MessageQueueClient msgQueueClient) {\n    super(name, enabled, minPermittedLevel);\n    this.msgQueueClient = msgQueueClient;\n  }\n  \n  @Override\n  protected void doLog(Level level, String mesage) {\n    // 格式化level和message,输出到消息中间件\n    msgQueueClient.send(...);\n  }\n}\n</code></pre><p>通过上面的这个例子，我们来看一下，抽象类具有哪些特性。我总结了下面三点。</p><ul>\n<li>抽象类不允许被实例化，只能被继承。也就是说，你不能new一个抽象类的对象出来（Logger logger = new Logger(...);会报编译错误）。</li>\n<li>抽象类可以包含属性和方法。方法既可以包含代码实现（比如Logger中的log()方法），也可以不包含代码实现（比如Logger中的doLog()方法）。不包含代码实现的方法叫作抽象方法。</li>\n<li>子类继承抽象类，必须实现抽象类中的所有抽象方法。对应到例子代码中就是，所有继承Logger抽象类的子类，都必须重写doLog()方法。</li>\n</ul><p><strong>刚刚我们讲了如何定义抽象类，现在我们再来看一下，在Java这种编程语言中，我们如何定义接口。</strong></p><pre><code>// 接口\npublic interface Filter {\n  void doFilter(RpcRequest req) throws RpcException;\n}\n// 接口实现类：鉴权过滤器\npublic class AuthencationFilter implements Filter {\n  @Override\n  public void doFilter(RpcRequest req) throws RpcException {\n    //...鉴权逻辑..\n  }\n}\n// 接口实现类：限流过滤器\npublic class RateLimitFilter implements Filter {\n  @Override\n  public void doFilter(RpcRequest req) throws RpcException {\n    //...限流逻辑...\n  }\n}\n// 过滤器使用Demo\npublic class Application {\n  // filters.add(new AuthencationFilter());\n  // filters.add(new RateLimitFilter());\n  private List&lt;Filter&gt; filters = new ArrayList&lt;&gt;();\n  \n  public void handleRpcRequest(RpcRequest req) {\n    try {\n      for (Filter filter : filters) {\n        filter.doFilter(req);\n      }\n    } catch(RpcException e) {\n      // ...处理过滤结果...\n    }\n    // ...省略其他处理逻辑...\n  }\n}\n</code></pre><p>上面这段代码是一个比较典型的接口的使用场景。我们通过Java中的interface关键字定义了一个Filter接口。AuthencationFilter和RateLimitFilter是接口的两个实现类，分别实现了对RPC请求鉴权和限流的过滤功能。</p><p>代码非常简洁。结合代码，我们再来看一下，接口都有哪些特性。我也总结了三点。</p><ul>\n<li>接口不能包含属性（也就是成员变量）。</li>\n<li>接口只能声明方法，方法不能包含代码实现。</li>\n<li>类实现接口的时候，必须实现接口中声明的所有方法。</li>\n</ul><p>前面我们讲了抽象类和接口的定义，以及各自的语法特性。从语法特性上对比，这两者有比较大的区别，比如抽象类中可以定义属性、方法的实现，而接口中不能定义属性，方法也不能包含代码实现等等。除了语法特性，从设计的角度，两者也有比较大的区别。</p><p>抽象类实际上就是类，只不过是一种特殊的类，这种类不能被实例化为对象，只能被子类继承。我们知道，继承关系是一种is-a的关系，那抽象类既然属于类，也表示一种is-a的关系。相对于抽象类的is-a关系来说，接口表示一种has-a关系，表示具有某些功能。对于接口，有一个更加形象的叫法，那就是协议（contract）。</p><h2>抽象类和接口能解决什么编程问题？</h2><p>刚刚我们学习了抽象类和接口的定义和区别，现在我们再来学习一下，抽象类和接口存在的意义，让你知其然知其所以然。</p><p><strong>首先，我们来看一下，我们为什么需要抽象类？它能够解决什么编程问题？</strong></p><p>刚刚我们讲到，抽象类不能实例化，只能被继承。而前面的章节中，我们还讲到，继承能解决代码复用的问题。所以，抽象类也是为代码复用而生的。多个子类可以继承抽象类中定义的属性和方法，避免在子类中，重复编写相同的代码。</p><p>不过，既然继承本身就能达到代码复用的目的，\b而继承也并不要求父类一定是抽象类，那我们不使用抽象类，照样也可以实现继承和复用。从这个角度上来讲，我们貌似并不需要抽象类这种语法呀。那抽象类除了解决代码复用的问题，还有什么其他存在的意义吗？</p><p>我们还是拿之前那个打印日志的例子来讲解。我们先对上面的代码做下改造。在改造之后的代码中，Logger不再是抽象类，只是一个普通的父类，删除了Logger中log()、doLog()方法，新增了isLoggable()方法。FileLogger和MessageQueueLogger还是继承Logger父类，以达到代码复用的目的。具体的代码如下：</p><pre><code>// 父类：非抽象类，就是普通的类. 删除了log(),doLog()，新增了isLoggable().\npublic class Logger {\n  private String name;\n  private boolean enabled;\n  private Level minPermittedLevel;\n\n  public Logger(String name, boolean enabled, Level minPermittedLevel) {\n    //...构造函数不变，代码省略...\n  }\n\n  protected boolean isLoggable() {\n    boolean loggable = enabled &amp;&amp; (minPermittedLevel.intValue() &lt;= level.intValue());\n    return loggable;\n  }\n}\n// 子类：输出日志到文件\npublic class FileLogger extends Logger {\n  private Writer fileWriter;\n\n  public FileLogger(String name, boolean enabled,\n    Level minPermittedLevel, String filepath) {\n    //...构造函数不变，代码省略...\n  }\n  \n  public void log(Level level, String mesage) {\n    if (!isLoggable()) return;\n    // 格式化level和message,输出到日志文件\n    fileWriter.write(...);\n  }\n}\n// 子类: 输出日志到消息中间件(比如kafka)\npublic class MessageQueueLogger extends Logger {\n  private MessageQueueClient msgQueueClient;\n  \n  public MessageQueueLogger(String name, boolean enabled,\n    Level minPermittedLevel, MessageQueueClient msgQueueClient) {\n    //...构造函数不变，代码省略...\n  }\n  \n  public void log(Level level, String mesage) {\n    if (!isLoggable()) return;\n    // 格式化level和message,输出到消息中间件\n    msgQueueClient.send(...);\n  }\n}\n</code></pre><p>这个设计思路虽然达到了代码复用的目的，但是无法使用多态特性了。像下面这样编写代码，就会出现编译错误，因为Logger中并没有定义log()方法。</p><pre><code>Logger logger = new FileLogger(&quot;access-log&quot;, true, Level.WARN, &quot;/users/wangzheng/access.log&quot;);\nlogger.log(Level.ERROR, &quot;This is a test log message.&quot;);\n</code></pre><p>你可能会说，这个问题解决起来很简单啊。我们在Logger父类中，定义一个空的log()方法，让子类重写父类的log()方法，实现自己的记录日志的逻辑，不就可以了吗？</p><pre><code>public class Logger {\n  // ...省略部分代码...\n  public void log(Level level, String mesage) { // do nothing... }\n}\npublic class FileLogger extends Logger {\n  // ...省略部分代码...\n  @Override\n  public void log(Level level, String mesage) {\n    if (!isLoggable()) return;\n    // 格式化level和message,输出到日志文件\n    fileWriter.write(...);\n  }\n}\npublic class MessageQueueLogger extends Logger {\n  // ...省略部分代码...\n  @Override\n  public void log(Level level, String mesage) {\n    if (!isLoggable()) return;\n    // 格式化level和message,输出到消息中间件\n    msgQueueClient.send(...);\n  }\n}\n</code></pre><p>这个设计思路能用，但是，它显然没有之前通过抽象类的实现思路优雅。我为什么这么说呢？主要有以下几点原因。</p><ul>\n<li>在Logger中定义一个空的方法，会影响代码的可读性。如果我们不熟悉Logger背后的设计思想，代码注释又不怎么给力，我们在阅读Logger代码的时候，就可能对为什么定义一个空的log()方法而感到疑惑，需要查看Logger、FileLogger、MessageQueueLogger之间的继承关系，才能弄明白其设计意图。</li>\n<li>当创建一个新的子类继承Logger父类的时候，我们有可能会忘记重新实现log()方法。之前基于抽象类的设计思路，编译器会强制要求子类重写log()方法，否则会报编译错误。你可能会说，我既然要定义一个新的Logger子类，怎么会忘记重新实现log()方法呢？我们举的例子比较简单，Logger中的方法不多，代码行数也很少。但是，如果Logger有几百行，有n多方法，除非你对Logger的设计非常熟悉，否则忘记重新实现log()方法，也不是不可能的。</li>\n<li>Logger可以被实例化，换句话说，我们可以new一个Logger出来，并且调用空的log()方法。这也增加了类被误用的风险。当然，这个问题可以通过设置私有的构造函数的方式来解决。不过，显然没有通过抽象类来的优雅。</li>\n</ul><p><strong>其次，我们再来看一下，我们为什么需要接口？它能够解决什么编程问题？</strong></p><p>抽象类更多的是为了代码复用，而接口就更侧重于解耦。接口是对行为的一种抽象，相当于一组协议或者契约，你可以联想类比一下API接口。调用者只需要关注抽象的接口，不需要了解具体的实现，具体的实现代码对调用者透明。接口实现了约定和实现相分离，可以降低代码间的耦合性，提高代码的可扩展性。</p><p>实际上，接口是一个比抽象类应用更加广泛、更加重要的知识点。比如，我们经常提到的“基于接口而非实现编程”，就是一条几乎天天会用到，并且能极大地提高代码的灵活性、扩展性的设计思想。关于接口这个知识点，我会单独再用一节课的时间，更加详细全面的讲解，这里就不展开了。</p><h2>如何模拟抽象类和接口两个语法概念？</h2><p>在前面举的例子中，我们使用Java的接口语法实现了一个Filter过滤器。不过，如果你熟悉的是C++这种编程语言，你可能会说，C++只有抽象类，并没有接口，那从代码实现的角度上来说，是不是就无法实现Filter的设计思路了呢？</p><p>实际上，我们可以通过抽象类来模拟接口。怎么来模拟呢？这是一个不错的面试题，你可以先思考一下，然后再来看我的讲解。</p><p>我们先来回忆一下接口的定义：接口中没有成员变量，只有方法声明，没有方法实现，实现接口的类必须实现接口中的所有方法。只要满足这样几点，从设计的角度上来说，我们就可以把它叫作接口。实际上，要满足接口的这些语法特性并不难。在下面这段C++代码中，我们就用抽象类模拟了一个接口（下面这段代码实际上是策略模式中的一段代码）。</p><pre><code>class Strategy { // 用抽象类模拟接口\n  public:\n    ~Strategy();\n    virtual void algorithm()=0;\n  protected:\n    Strategy();\n};\n</code></pre><p>抽象类Strategy没有定义任何属性，并且所有的方法都声明为virtual类型（等同于Java中的abstract关键字），这样，所有的方法都不能有代码实现，并且所有继承这个抽象类的子类，都要实现这些方法。从语法特性上来看，这个抽象类就相当于一个接口。</p><p>不过，如果你熟悉的既不是Java，也不是C++，而是现在比较流行的动态编程语言，比如Python、Ruby等，你可能还会有疑问：在这些动态语言中，不仅没有接口的概念，也没有类似abstract、virtual这样的关键字来定义抽象类，那该如何实现上面的讲到的Filter、Logger的设计思路呢？实际上，除了用抽象类来模拟接口之外，我们还可以用普通类来模拟接口。具体的Java代码实现如下所示。</p><pre><code>public class MockInteface {\n  protected MockInteface() {}\n  public void funcA() {\n    throw new MethodUnSupportedException();\n  }\n}\n</code></pre><p>我们知道类中的方法必须包含实现，这个不符合接口的定义。但是，我们可以让类中的方法抛出MethodUnSupportedException异常，来模拟不包含实现的接口，并且能强迫子类在继承这个父类的时候，都去主动实现父类的方法，否则就会在运行时抛出异常。我们将构造函数设置成protected属性的，这样就能避免非同包下的类去实例化MockInterface。不过，这样还是无法避免同包中的类去实例化MockInterface。为了解决这个问题，我们可以学习Google Guava中@VisibleForTesting注解的做法，自定义一个注解，人为表明不可实例化。</p><p>刚刚我们讲了如何用抽象类来模拟接口，以及如何用普通类来模拟接口，那如何用普通类来模拟抽象类呢？这个问题留给你自己思考，你可以留言说说你的实现方法。</p><p>实际上，对于动态编程语言来说，还有一种对接口支持的策略，那就是duck-typing。我们在上一节课中讲到多态的时候也有讲过，你可以再回忆一下。</p><h2>如何决定该用抽象类还是接口？</h2><p>刚刚的讲解可能有些偏理论，现在，我们就从真实项目开发的角度来看一下，在代码设计、编程开发的时候，什么时候该用抽象类？什么时候该用接口？</p><p>实际上，判断的标准很简单。如果我们要表示一种is-a的关系，并且是为了解决代码复用的问题，我们就用抽象类；如果我们要表示\b一种has-a关系，并且是为了解决抽象而非代码复用的问题，那我们就可以使用接口。</p><p>从类的继承层次上来看，抽象类是一种自下而上的设计思路，先有子类的代码重复，然后再抽象成上层的父类（也就是抽象类）。而接口正好相反，它是一种自上而下的设计思路。我们在编程的时候，一般都是先设计接口，再去考虑具体的实现。</p><h2>重点回顾</h2><p>好了，今天内容就讲完了，我们一块来总结回顾一下，你需要掌握的重点内容。</p><p><strong>1.抽象类和接口的语法特性</strong></p><p>抽象类不允许被实例化，只能被继承。它可以包含属性和方法。方法既可以包含代码实现，也可以不包含代码实现。不包含代码实现的方法叫作抽象方法。子类继承抽象类，必须实现抽象类中的所有抽象方法。接口不能包含属性，只能声明方法，方法不能包含代码实现。类实现接口的时候，必须实现接口中声明的所有方法。</p><p><strong>2.抽象类和接口存在的意义</strong></p><p>抽象类是对成员变量和方法的抽象，是一种is-a关系，是为了解决代码复用问题。接口仅仅是对方法的抽象，是一种has-a关系，表示具有某一组行为特性，是为了解决解耦问题，隔离接口和具体的实现，提高代码的扩展性。</p><p><strong>3.抽象类和接口的应用场景区别</strong></p><p>什么时候该用抽象类？什么时候该用接口？实际上，判断的标准很简单。如果要表示一种is-a的关系，并且是为了解决代码复用问题，我们就用抽象类；如果要表示\b一种has-a关系，并且是为了解决抽象而非代码复用问题，那我们就用接口。</p><h2>课堂讨论</h2><ol>\n<li>你熟悉的编程语言，是否有现成的语法支持接口和抽象类呢？具体是如何定义的呢？</li>\n<li>前面我们提到，接口和抽象类是两个经常在面试中被问到的概念。学习完今天的内容之后，你是否对抽象类和接口有一个新的认识呢？如果面试官再让你聊聊接口和抽象类，你会如何回答呢？</li>\n</ol><p>欢迎在留言区写下你的答案，和同学一起交流和分享。如果有收获，也欢迎你把这篇文章分享给你的朋友。</p>",
                "article_title": "08 | 理论五：接口vs抽象类的区别？如何用普通的类模拟抽象类和接口？"
            },
            {
                "title": "09 | 理论六：为什么基于接口而非实现编程？有必要为每个类都定义接口吗？",
                "herf": "https://time.geekbang.org/column/article/165114",
                "id": "165114",
                "content": "<p>在上一节课中，我们讲了接口和抽象类，以及各种编程语言是如何支持、实现这两个语法概念的。今天，我们继续讲一个跟“接口”相关的知识点：基于接口而非实现编程。这个原则非常重要，是一种非常有效的提高代码质量的手段，在平时的开发中特别经常被用到。</p><p>为了让你理解透彻，并真正掌握这条原则如何应用，今天，我会结合一个有关图片存储的实战案例来讲解。除此之外，这条原则还很容易被过度应用，比如为每一个实现类都定义对应的接口。针对这类问题，在今天的讲解中，我也会告诉你如何来做权衡，怎样恰到好处地应用这条原则。</p><p>话不多说，让我们正式开始今天的学习吧！</p><h2>如何解读原则中的“接口”二字？</h2><p>“基于接口而非实现编程”这条原则的英文描述是：“Program to an interface, not an implementation”。我们理解这条原则的时候，千万不要一开始就与具体的编程语言挂钩，局限在编程语言的“接口”语法中（比如Java中的interface接口语法）。这条原则最早出现于1994年GoF的《设计模式》这本书，它先于很多编程语言而诞生（比如Java语言），是一条比较抽象、泛化的设计思想。</p><p>实际上，理解这条原则的关键，就是理解其中的“接口”两个字。还记得我们上一节课讲的“接口”的定义吗？从本质上来看，“接口”就是一组“协议”或者“约定”，是功能提供者提供给使用者的一个“功能列表”。“接口”在不同的应用场景下会有不同的解读，比如服务端与客户端之间的“接口”，类库提供的“接口”，甚至是一组通信的协议都可以叫作“接口”。刚刚对“接口”的理解，都比较偏上层、偏抽象，与实际的写代码离得有点远。如果落实到具体的编码，“基于接口而非实现编程”这条原则中的“接口”，可以理解为编程语言中的接口或者抽象类。</p><!-- [[[read_end]]] --><p>前面我们提到，这条原则能非常有效地提高代码质量，之所以这么说，那是因为，应用这条原则，可以将接口和实现相分离，封装不稳定的实现，暴露稳定的接口。上游系统面向接口而非实现编程，不依赖不稳定的实现细节，这样当实现发生变化的时候，上游系统的代码基本上不需要做改动，以此来降低耦合性，提高扩展性。</p><p>实际上，“基于接口而非实现编程”这条原则的另一个表述方式，是“基于抽象而非实现编程”。后者的表述方式其实更能体现这条原则的设计初衷。在软件开发中，最大的挑战之一就是需求的不断变化，这也是考验代码设计好坏的一个标准。<strong>越抽象、越顶层、越脱离具体某一实现的设计，越能提高代码的灵活性，越能应对未来的需求变化。好的代码设计，不仅能应对当下的需求，而且在将来需求发生变化的时候，仍然能够在不破坏原有代码设计的情况下灵活应对。</strong>而抽象就是提高代码扩展性、灵活性、可维护性最有效的手段之一。</p><h2>如何将这条原则应用到实战中？</h2><p>对于这条原则，我们结合一个具体的实战案例来进一步讲解一下。</p><p>假设我们的系统中有很多涉及图片处理和存储的业务逻辑。图片经过处理之后被上传到阿里云上。为了代码复用，我们封装了图片存储相关的代码逻辑，提供了一个统一的AliyunImageStore类，供整个系统来使用。具体的代码实现如下所示：</p><pre><code>public class AliyunImageStore {\n  //...省略属性、构造函数等...\n  \n  public void createBucketIfNotExisting(String bucketName) {\n    // ...创建bucket代码逻辑...\n    // ...失败会抛出异常..\n  }\n  \n  public String generateAccessToken() {\n    // ...根据accesskey/secrectkey等生成access token\n  }\n  \n  public String uploadToAliyun(Image image, String bucketName, String accessToken) {\n    //...上传图片到阿里云...\n    //...返回图片存储在阿里云上的地址(url）...\n  }\n  \n  public Image downloadFromAliyun(String url, String accessToken) {\n    //...从阿里云下载图片...\n  }\n}\n\n// AliyunImageStore类的使用举例\npublic class ImageProcessingJob {\n  private static final String BUCKET_NAME = &quot;ai_images_bucket&quot;;\n  //...省略其他无关代码...\n  \n  public void process() {\n    Image image = ...; //处理图片，并封装为Image对象\n    AliyunImageStore imageStore = new AliyunImageStore(/*省略参数*/);\n    imageStore.createBucketIfNotExisting(BUCKET_NAME);\n    String accessToken = imageStore.generateAccessToken();\n    imagestore.uploadToAliyun(image, BUCKET_NAME, accessToken);\n  }\n  \n}\n</code></pre><p>整个上传流程包含三个步骤：创建bucket（你可以简单理解为存储目录）、生成access token访问凭证、携带access token上传图片到指定的bucket中。代码实现非常简单，类中的几个方法定义得都很干净，用起来也很清晰，乍看起来没有太大问题，完全能满足我们将图片存储在阿里云的业务需求。</p><p>不过，软件开发中唯一不变的就是变化。过了一段时间后，我们自建了私有云，不再将图片存储到阿里云了，而是将图片存储到自建私有云上。为了满足这样一个需求的变化，我们该如何修改代码呢？</p><p>我们需要重新设计实现一个存储图片到私有云的PrivateImageStore类，并用它替换掉项目中所有的AliyunImageStore类对象。这样的修改听起来并不复杂，只是简单替换而已，对整个代码的改动并不大。不过，我们经常说，“细节是魔鬼”。这句话在软件开发中特别适用。实际上，刚刚的设计实现方式，就隐藏了很多容易出问题的“魔鬼细节”，我们一块来看看都有哪些。</p><p>新的PrivateImageStore类需要设计实现哪些方法，才能在尽量最小化代码修改的情况下，替换掉AliyunImageStore类呢？这就要求我们必须将AliyunImageStore类中所定义的所有public方法，在PrivateImageStore类中都逐一定义并重新实现一遍。而这样做就会存在一些问题，我总结了下面两点。</p><p>首先，AliyunImageStore类中有些函数命名暴露了实现细节，比如，uploadToAliyun()和downloadFromAliyun()。如果开发这个功能的同事没有接口意识、抽象思维，那这种暴露实现细节的命名方式就不足为奇了，毕竟最初我们只考虑将图片存储在阿里云上。而我们把这种包含“aliyun”字眼的方法，照抄到PrivateImageStore类中，显然是不合适的。如果我们在新类中重新命名uploadToAliyun()、downloadFromAliyun()这些方法，那就意味着，我们要修改项目中所有使用到这两个方法的代码，代码修改量可能就会很大。</p><p>其次，将图片存储到阿里云的流程，跟存储到私有云的流程，可能并不是完全一致的。比如，阿里云的图片上传和下载的过程中，需要生产access token，而私有云不需要access token。一方面，AliyunImageStore中定义的generateAccessToken()方法不能照抄到PrivateImageStore中；另一方面，我们在使用AliyunImageStore上传、下载图片的时候，代码中用到了generateAccessToken()方法，如果要改为私有云的上传下载流程，这些代码都需要做调整。</p><p>那这两个问题该如何解决呢？解决这个问题的根本方法就是，在编写代码的时候，要遵从“基于接口而非实现编程”的原则，具体来讲，我们需要做到下面这3点。</p><ol>\n<li>函数的命名不能暴露任何实现细节。比如，前面提到的uploadToAliyun()就不符合要求，应该改为去掉aliyun这样的字眼，改为更加抽象的命名方式，比如：upload()。</li>\n<li>封装具体的实现细节。比如，跟阿里云相关的特殊上传（或下载）流程不应该暴露给调用者。我们对上传（或下载）流程进行封装，对外提供一个包裹所有上传（或下载）细节的方法，给调用者使用。</li>\n<li>为实现类定义抽象的接口。具体的实现类都依赖统一的接口定义，遵从一致的上传功能协议。使用者依赖接口，而不是具体的实现类来编程。</li>\n</ol><p>我们按照这个思路，把代码重构一下。重构后的代码如下所示：</p><pre><code>public interface ImageStore {\n  String upload(Image image, String bucketName);\n  Image download(String url);\n}\n\npublic class AliyunImageStore implements ImageStore {\n  //...省略属性、构造函数等...\n\n  public String upload(Image image, String bucketName) {\n    createBucketIfNotExisting(bucketName);\n    String accessToken = generateAccessToken();\n    //...上传图片到阿里云...\n    //...返回图片在阿里云上的地址(url)...\n  }\n\n  public Image download(String url) {\n    String accessToken = generateAccessToken();\n    //...从阿里云下载图片...\n  }\n\n  private void createBucketIfNotExisting(String bucketName) {\n    // ...创建bucket...\n    // ...失败会抛出异常..\n  }\n\n  private String generateAccessToken() {\n    // ...根据accesskey/secrectkey等生成access token\n  }\n}\n\n// 上传下载流程改变：私有云不需要支持access token\npublic class PrivateImageStore implements ImageStore  {\n  public String upload(Image image, String bucketName) {\n    createBucketIfNotExisting(bucketName);\n    //...上传图片到私有云...\n    //...返回图片的url...\n  }\n\n  public Image download(String url) {\n    //...从私有云下载图片...\n  }\n\n  private void createBucketIfNotExisting(String bucketName) {\n    // ...创建bucket...\n    // ...失败会抛出异常..\n  }\n}\n\n// ImageStore的使用举例\npublic class ImageProcessingJob {\n  private static final String BUCKET_NAME = &quot;ai_images_bucket&quot;;\n  //...省略其他无关代码...\n  \n  public void process() {\n    Image image = ...;//处理图片，并封装为Image对象\n    ImageStore imageStore = new PrivateImageStore(...);\n    imagestore.upload(image, BUCKET_NAME);\n  }\n}\n</code></pre><p>除此之外，很多人在定义接口的时候，希望通过实现类来反推接口的定义。先把实现类写好，然后看实现类中有哪些方法，照抄到接口定义中。如果按照这种思考方式，就有可能导致接口定义不够抽象，依赖具体的实现。这样的接口设计就没有意义了。不过，如果你觉得这种思考方式更加顺畅，那也没问题，只是将实现类的方法搬移到接口定义中的时候，要有选择性的搬移，不要将跟具体实现相关的方法搬移到接口中，比如AliyunImageStore中的generateAccessToken()方法。</p><p>总结一下，我们在做软件开发的时候，一定要有抽象意识、封装意识、接口意识。在定义接口的时候，不要暴露任何实现细节。接口的定义只表明做什么，而不是怎么做。而且，在设计接口的时候，我们要多思考一下，这样的接口设计是否足够通用，是否能够做到在替换具体的接口实现的时候，不需要任何接口定义的改动。</p><h2>是否需要为每个类定义接口？</h2><p>看了刚刚的讲解，你可能会有这样的疑问：为了满足这条原则，我是不是需要给每个实现类都定义对应的接口呢？在开发的时候，是不是任何代码都要只依赖接口，完全不依赖实现编程呢？</p><p>做任何事情都要讲求一个“度”，过度使用这条原则，非得给每个类都定义接口，接口满天飞，也会导致不必要的开发负担。至于什么时候，该为某个类定义接口，实现基于接口的编程，什么时候不需要定义接口，直接使用实现类编程，我们做权衡的根本依据，还是要回归到设计原则诞生的初衷上来。只要搞清楚了这条原则是为了解决什么样的问题而产生的，你就会发现，很多之前模棱两可的问题，都会变得豁然开朗。</p><p>前面我们也提到，这条原则的设计初衷是，将接口和实现相分离，封装不稳定的实现，暴露稳定的接口。上游系统面向接口而非实现编程，不依赖不稳定的实现细节，这样当实现发生变化的时候，上游系统的代码基本上不需要做改动，以此来降低代码间的耦合性，提高代码的扩展性。</p><p>从这个设计初衷上来看，如果在我们的业务场景中，某个功能只有一种实现方式，未来也不可能被其他实现方式替换，那我们就没有必要为其设计接口，也没有必要基于接口编程，直接使用实现类就可以了。</p><p>除此之外，越是不稳定的系统，我们越是要在代码的扩展性、维护性上下功夫。相反，如果某个系统特别稳定，在开发完之后，基本上不需要做维护，那我们就没有必要为其扩展性，投入不必要的开发时间。</p><h2>重点回顾</h2><p>今天的内容到此就讲完了。我们来一块总结回顾一下，你需要掌握的重点内容。</p><p>1.“基于接口而非实现编程”，这条原则的另一个表述方式，是“基于抽象而非实现编程”。后者的表述方式其实更能体现这条原则的设计初衷。我们在做软件开发的时候，一定要有抽象意识、封装意识、接口意识。越抽象、越顶层、越脱离具体某一实现的设计，越能提高代码的灵活性、扩展性、可维护性。</p><p>2.我们在定义接口的时候，一方面，命名要足够通用，不能包含跟具体实现相关的字眼；另一方面，与特定实现有关的方法不要定义在接口中。</p><p>3.“基于接口而非实现编程”这条原则，不仅仅可以指导非常细节的编程开发，还能指导更加上层的架构设计、系统设计等。比如，服务端与客户端之间的“接口”设计、类库的“接口”设计。</p><h2>课堂讨论</h2><p>在今天举的代码例子中，尽管我们通过接口来隔离了两个具体的实现。但是，在项目中很多地方，我们都是通过下面第8行的方式来使用接口的。这就会产生一个问题，那就是，如果我们要替换图片存储方式，还是需要修改很多类似第8行那样的代码。这样的设计还是不够完美，对此，你有更好的实现思路吗？</p><pre><code>// ImageStore的使用举例\npublic class ImageProcessingJob {\n  private static final String BUCKET_NAME = &quot;ai_images_bucket&quot;;\n  //...省略其他无关代码...\n  \n  public void process() {\n    Image image = ...;//处理图片，并封装为Image对象\n    ImageStore imageStore = new PrivateImageStore(/*省略构造函数*/);\n    imagestore.upload(image, BUCKET_NAME);\n  }\n</code></pre><p>欢迎在留言区写下你的答案，和同学一起交流和分享。如果有收获，也欢迎你把这篇文章分享给你的朋友。</p>",
                "article_title": "09 | 理论六：为什么基于接口而非实现编程？有必要为每个类都定义接口吗？"
            },
            {
                "title": "10 | 理论七：为何说要多用组合少用继承？如何决定该用组合还是继承？",
                "herf": "https://time.geekbang.org/column/article/169593",
                "id": "169593",
                "content": "<p>在面向对象编程中，有一条非常经典的设计原则，那就是：组合优于继承，多用组合少用继承。为什么不推荐使用继承？组合相比继承有哪些优势？如何判断该用组合还是继承？今天，我们就围绕着这三个问题，来详细讲解一下这条设计原则。</p><p>话不多说，让我们正式开始今天的学习吧！</p><h2>为什么不推荐使用继承？</h2><p>继承是面向对象的四大特性之一，用来表示类之间的is-a关系，可以解决代码复用的问题。虽然继承有诸多作用，但继承层次过深、过复杂，也会影响到代码的可维护性。所以，对于是否应该在项目中使用继承，网上有很多争议。很多人觉得继承是一种反模式，应该尽量少用，甚至不用。为什么会有这样的争议？我们通过一个例子来解释一下。</p><p>假设我们要设计一个关于鸟的类。我们将“鸟类”这样一个抽象的事物概念，定义为一个抽象类AbstractBird。所有更细分的鸟，比如麻雀、鸽子、乌鸦等，都继承这个抽象类。</p><p>我们知道，大部分鸟都会飞，那我们可不可以在AbstractBird抽象类中，定义一个fly()方法呢？答案是否定的。尽管大部分鸟都会飞，但也有特例，比如鸵鸟就不会飞。鸵鸟继承具有fly()方法的父类，那鸵鸟就具有“飞”这样的行为，这显然不符合我们对现实世界中事物的认识。当然，你可能会说，我在鸵鸟这个子类中重写（override）fly()方法，让它抛出UnSupportedMethodException异常不就可以了吗？具体的代码实现如下所示：</p><!-- [[[read_end]]] --><pre><code>public class AbstractBird {\n  //...省略其他属性和方法...\n  public void fly() { //... }\n}\n\npublic class Ostrich extends AbstractBird { //鸵鸟\n  //...省略其他属性和方法...\n  public void fly() {\n    throw new UnSupportedMethodException(&quot;I can't fly.'&quot;);\n  }\n}\n</code></pre><p>这种设计思路虽然可以解决问题，但不够优美。因为除了鸵鸟之外，不会飞的鸟还有很多，比如企鹅。对于这些不会飞的鸟来说，我们都需要重写fly()方法，抛出异常。这样的设计，一方面，徒增了编码的工作量；另一方面，也违背了我们之后要讲的最小知识原则（Least Knowledge Principle，也叫最少知识原则或者迪米特法则），暴露不该暴露的接口给外部，增加了类使用过程中被误用的概率。</p><p>你可能又会说，那我们再通过AbstractBird类派生出两个更加细分的抽象类：会飞的鸟类AbstractFlyableBird和不会飞的鸟类AbstractUnFlyableBird，让麻雀、乌鸦这些会飞的鸟都继承AbstractFlyableBird，让鸵鸟、企鹅这些不会飞的鸟，都继承AbstractUnFlyableBird类，不就可以了吗？具体的继承关系如下图所示：</p><p><img src=\"https://static001.geekbang.org/resource/image/1e/b7/1e27919f63ef615dba98bc00673914b7.jpg\" alt=\"\"></p><p>从图中我们可以看出，继承关系变成了三层。不过，整体上来讲，目前的继承关系还比较简单，层次比较浅，也算是一种可以接受的设计思路。我们再继续加点难度。在刚刚这个场景中，我们只关注“鸟会不会飞”，但如果我们还关注“鸟会不会叫”，那这个时候，我们又该如何设计类之间的继承关系呢？</p><p>是否会飞？是否会叫？两个行为搭配起来会产生四种情况：会飞会叫、不会飞会叫、会飞不会叫、不会飞不会叫。如果我们继续沿用刚才的设计思路，那就需要再定义四个抽象类（AbstractFlyableTweetableBird、AbstractFlyableUnTweetableBird、AbstractUnFlyableTweetableBird、AbstractUnFlyableUnTweetableBird）。</p><p><img src=\"https://static001.geekbang.org/resource/image/3f/c6/3f99fa541e7ec7656a1dd35cc4f28bc6.jpg\" alt=\"\"></p><p>如果我们还需要考虑“是否会下蛋”这样一个行为，那估计就要组合爆炸了。类的继承层次会越来越深、继承关系会越来越复杂。而这种层次很深、很复杂的继承关系，一方面，会导致代码的可读性变差。因为我们要搞清楚某个类具有哪些方法、属性，必须阅读父类的代码、父类的父类的代码……一直追溯到最顶层父类的代码。另一方面，这也破坏了类的封装特性，将父类的实现细节暴露给了子类。子类的实现依赖父类的实现，两者高度耦合，一旦父类代码修改，就会影响所有子类的逻辑。</p><p>总之，继承最大的问题就在于：继承层次过深、继承关系过于复杂会影响到代码的可读性和可维护性。这也是为什么我们不推荐使用继承。那刚刚例子中继承存在的问题，我们又该如何来解决呢？你可以先自己思考一下，再听我下面的讲解。</p><h2>组合相比继承有哪些优势？</h2><p>实际上，我们可以利用组合（composition）、接口、委托（delegation）三个技术手段，一块儿来解决刚刚继承存在的问题。</p><p>我们前面讲到接口的时候说过，接口表示具有某种行为特性。针对“会飞”这样一个行为特性，我们可以定义一个Flyable接口，只让会飞的鸟去实现这个接口。对于会叫、会下蛋这些行为特性，我们可以类似地定义Tweetable接口、EggLayable接口。我们将这个设计思路翻译成Java代码的话，就是下面这个样子：</p><pre><code>public interface Flyable {\n  void fly();\n}\npublic interface Tweetable {\n  void tweet();\n}\npublic interface EggLayable {\n  void layEgg();\n}\npublic class Ostrich implements Tweetable, EggLayable {//鸵鸟\n  //... 省略其他属性和方法...\n  @Override\n  public void tweet() { //... }\n  @Override\n  public void layEgg() { //... }\n}\npublic class Sparrow impelents Flyable, Tweetable, EggLayable {//麻雀\n  //... 省略其他属性和方法...\n  @Override\n  public void fly() { //... }\n  @Override\n  public void tweet() { //... }\n  @Override\n  public void layEgg() { //... }\n}\n</code></pre><p>不过，我们知道，接口只声明方法，不定义实现。也就是说，每个会下蛋的鸟都要实现一遍layEgg()方法，并且实现逻辑是一样的，这就会导致代码重复的问题。那这个问题又该如何解决呢？</p><p>我们可以针对三个接口再定义三个实现类，它们分别是：实现了fly()方法的FlyAbility类、实现了tweet()方法的TweetAbility类、实现了layEgg()方法的EggLayAbility类。然后，通过组合和委托技术来消除代码重复。具体的代码实现如下所示：</p><pre><code>public interface Flyable {\n  void fly()；\n}\npublic class FlyAbility implements Flyable {\n  @Override\n  public void fly() { //... }\n}\n//省略Tweetable/TweetAbility/EggLayable/EggLayAbility\n\npublic class Ostrich implements Tweetable, EggLayable {//鸵鸟\n  private TweetAbility tweetAbility = new TweetAbility(); //组合\n  private EggLayAbility eggLayAbility = new EggLayAbility(); //组合\n  //... 省略其他属性和方法...\n  @Override\n  public void tweet() {\n    tweetAbility.tweet(); // 委托\n  }\n  @Override\n  public void layEgg() {\n    eggLayAbility.layEgg(); // 委托\n  }\n}\n</code></pre><p>我们知道继承主要有三个作用：表示is-a关系，支持多态特性，代码复用。而这三个作用都可以通过其他技术手段来达成。比如is-a关系，我们可以通过组合和接口的has-a关系来替代；多态特性我们可以利用接口来实现；代码复用我们可以通过组合和委托来实现。所以，从理论上讲，通过组合、接口、委托三个技术手段，我们完全可以替换掉继承，在项目中不用或者少用继承关系，特别是一些复杂的继承关系。</p><h2>如何判断该用组合还是继承？</h2><p>尽管我们鼓励多用组合少用继承，但组合也并不是完美的，继承也并非一无是处。从上面的例子来看，继承改写成组合意味着要做更细粒度的类的拆分。这也就意味着，我们要定义更多的类和接口。类和接口的增多也就或多或少地增加代码的复杂程度和维护成本。所以，在实际的项目开发中，我们还是要根据具体的情况，来具体选择该用继承还是组合。</p><p>如果类之间的继承结构稳定（不会轻易改变），继承层次比较浅（比如，最多有两层继承关系），继承关系不复杂，我们就可以大胆地使用继承。反之，系统越不稳定，继承层次很深，继承关系复杂，我们就尽量使用组合来替代继承。</p><p>除此之外，还有一些设计模式会固定使用继承或者组合。比如，装饰者模式（decorator pattern）、策略模式（strategy pattern）、组合模式（composite pattern）等都使用了组合关系，而模板模式（template pattern）使用了继承关系。</p><p>前面我们讲到继承可以实现代码复用。利用继承特性，我们把相同的属性和方法，抽取出来，定义到父类中。子类复用父类中的属性和方法，达到代码复用的目的。但是，有的时候，从业务含义上，A类和B类并不一定具有继承关系。比如，Crawler类和PageAnalyzer类，它们都用到了URL拼接和分割的功能，但并不具有继承关系（既不是父子关系，也不是兄弟关系）。仅仅为了代码复用，生硬地抽象出一个父类出来，会影响到代码的可读性。如果不熟悉背后设计思路的同事，发现Crawler类和PageAnalyzer类继承同一个父类，而父类中定义的却只是URL相关的操作，会觉得这个代码写得莫名其妙，理解不了。这个时候，使用组合就更加合理、更加灵活。具体的代码实现如下所示：</p><pre><code>public class Url {\n  //...省略属性和方法\n}\n\npublic class Crawler {\n  private Url url; // 组合\n  public Crawler() {\n    this.url = new Url();\n  }\n  //...\n}\n\npublic class PageAnalyzer {\n  private Url url; // 组合\n  public PageAnalyzer() {\n    this.url = new Url();\n  }\n  //..\n}\n</code></pre><p>还有一些特殊的场景要求我们必须使用继承。如果你不能改变一个函数的入参类型，而入参又非接口，为了支持多态，只能采用继承来实现。比如下面这样一段代码，其中FeignClient是一个外部类，我们没有权限去修改这部分代码，但是我们希望能重写这个类在运行时执行的encode()函数。这个时候，我们只能采用继承来实现了。</p><pre><code>public class FeignClient { // Feign Client框架代码\n  //...省略其他代码...\n  public void encode(String url) { //... }\n}\n\npublic void demofunction(FeignClient feignClient) {\n  //...\n  feignClient.encode(url);\n  //...\n}\n\npublic class CustomizedFeignClient extends FeignClient {\n  @Override\n  public void encode(String url) { //...重写encode的实现...}\n}\n\n// 调用\nFeignClient client = new CustomizedFeignClient();\ndemofunction(client);\n</code></pre><p>尽管有些人说，要杜绝继承，100%用组合代替继承，但是我的观点没那么极端！之所以“多用组合少用继承”这个口号喊得这么响，只是因为，长期以来，我们过度使用继承。还是那句话，组合并不完美，继承也不是一无是处。只要我们控制好它们的副作用、发挥它们各自的优势，在不同的场合下，恰当地选择使用继承还是组合，这才是我们所追求的境界。</p><h2>重点回顾</h2><p>到此，今天的内容就讲完了。我们一块儿来回顾一下，你需要重点掌握的知识点。</p><p><strong>1.为什么不推荐使用继承？</strong></p><p>继承是面向对象的四大特性之一，用来表示类之间的is-a关系，可以解决代码复用的问题。虽然继承有诸多作用，但继承层次过深、过复杂，也会影响到代码的可维护性。在这种情况下，我们应该尽量少用，甚至不用继承。</p><p><strong>2.组合相比继承有哪些优势？</strong></p><p>继承主要有三个作用：表示is-a关系，支持多态特性，代码复用。而这三个作用都可以通过组合、接口、委托三个技术手段来达成。除此之外，利用组合还能解决层次过深、过复杂的继承关系影响代码可维护性的问题。</p><p><strong>3.如何判断该用组合还是继承？</strong></p><p>尽管我们鼓励多用组合少用继承，但组合也并不是完美的，继承也并非一无是处。在实际的项目开发中，我们还是要根据具体的情况，来选择该用继承还是组合。如果类之间的继承结构稳定，层次比较浅，关系不复杂，我们就可以大胆地使用继承。反之，我们就尽量使用组合来替代继承。除此之外，还有一些设计模式、特殊的应用场景，会固定使用继承或者组合。</p><h2>课堂讨论</h2><p>我们在基于MVC架构开发Web应用的时候，经常会在数据库层定义Entity，在Service业务层定义BO（Business Object），在Controller接口层定义VO（View Object）。大部分情况下，Entity、BO、VO三者之间的代码有很大重复，但又不完全相同。我们该如何处理Entity、BO、VO代码重复的问题呢？</p><p>欢迎在留言区写下你的答案，和同学一起交流和分享。如果有收获，也欢迎你把这篇文章分享给你的朋友。</p>",
                "article_title": "10 | 理论七：为何说要多用组合少用继承？如何决定该用组合还是继承？"
            },
            {
                "title": "11 | 实战一（上）：业务开发常用的基于贫血模型的MVC架构违背OOP吗？",
                "herf": "https://time.geekbang.org/column/article/169600",
                "id": "169600",
                "content": "<p>在前面几节课中，我们学习了面向对象的一些理论知识，比如，面向对象四大特性、接口和抽象类、面向对象和面向过程编程风格、基于接口而非实现编程和多用组合少用继承设计思想等等。接下来，我们再用四节课的时间，通过两个更加贴近实战的项目来进一步学习，如何将这些理论应用到实际的软件开发中。</p><p>据我了解，大部分工程师都是做业务开发的，所以，今天我们讲的这个实战项目也是一个典型的业务系统开发案例。我们都知道，很多业务系统都是基于MVC三层架构来开发的。实际上，更确切点讲，这是一种基于贫血模型的MVC三层架构开发模式。</p><p>虽然这种开发模式已经成为标准的Web项目的开发模式，但它却违反了面向对象编程风格，是一种彻彻底底的面向过程的编程风格，因此而被有些人称为<a href=\"https://zh.wikipedia.org/wiki/%E5%8F%8D%E9%9D%A2%E6%A8%A1%E5%BC%8F\">反模式（anti-pattern）</a>。特别是<strong>领域驱动设计</strong>（Domain Driven Design，简称DDD）盛行之后，这种基于贫血模型的传统的开发模式就更加被人诟病。而基于充血模型的DDD开发模式越来越被人提倡。所以，我打算用两节课的时间，结合一个虚拟钱包系统的开发案例，带你彻底弄清楚这两种开发模式。</p><p>考虑到你有可能不太了解我刚刚提到的这几个概念，所以，在正式进入实战项目的讲解之前，我先带你搞清楚下面几个问题：</p><!-- [[[read_end]]] --><ul>\n<li>什么是贫血模型？什么是充血模型？</li>\n<li>为什么说基于贫血模型的传统开发模式违反OOP?</li>\n<li>基于贫血模型的传统开发模式既然违反OOP，那又为什么如此流行？</li>\n<li>什么情况下我们应该考虑使用基于充血模型的DDD开发模式？</li>\n</ul><p>好了，让我们带着这些问题，正式开始今天的学习吧！</p><h2>什么是基于贫血模型的传统开发模式？</h2><p>我相信，对于大部分的后端开发工程师来说，MVC三层架构都不会陌生。不过，为了统一我们之间对MVC的认识，我还是带你一块来回顾一下，什么是MVC三层架构。</p><p>MVC三层架构中的M表示Model，V表示View，C表示Controller。它将整个项目分为三层：展示层、逻辑层、数据层。MVC三层开发架构是一个比较笼统的分层方式，落实到具体的开发层面，很多项目也并不会100%遵从MVC固定的分层方式，而是会根据具体的项目需求，做适当的调整。</p><p>比如，现在很多Web或者App项目都是前后端分离的，后端负责暴露接口给前端调用。这种情况下，我们一般就将后端项目分为Repository层、Service层、Controller层。其中，Repository层负责数据访问，Service层负责业务逻辑，Controller层负责暴露接口。当然，这只是其中一种分层和命名方式。不同的项目、不同的团队，可能会对此有所调整。不过，万变不离其宗，只要是依赖数据库开发的Web项目，基本的分层思路都大差不差。</p><p>刚刚我们回顾了MVC三层开发架构。现在，我们再来看一下，什么是贫血模型？</p><p>实际上，你可能一直都在用贫血模型做开发，只是自己不知道而已。不夸张地讲，据我了解，目前几乎所有的业务后端系统，都是基于贫血模型的。我举一个简单的例子来给你解释一下。</p><pre><code>////////// Controller+VO(View Object) //////////\npublic class UserController {\n  private UserService userService; //通过构造函数或者IOC框架注入\n  \n  public UserVo getUserById(Long userId) {\n    UserBo userBo = userService.getUserById(userId);\n    UserVo userVo = [...convert userBo to userVo...];\n    return userVo;\n  }\n}\n\npublic class UserVo {//省略其他属性、get/set/construct方法\n  private Long id;\n  private String name;\n  private String cellphone;\n}\n\n////////// Service+BO(Business Object) //////////\npublic class UserService {\n  private UserRepository userRepository; //通过构造函数或者IOC框架注入\n  \n  public UserBo getUserById(Long userId) {\n    UserEntity userEntity = userRepository.getUserById(userId);\n    UserBo userBo = [...convert userEntity to userBo...];\n    return userBo;\n  }\n}\n\npublic class UserBo {//省略其他属性、get/set/construct方法\n  private Long id;\n  private String name;\n  private String cellphone;\n}\n\n////////// Repository+Entity //////////\npublic class UserRepository {\n  public UserEntity getUserById(Long userId) { //... }\n}\n\npublic class UserEntity {//省略其他属性、get/set/construct方法\n  private Long id;\n  private String name;\n  private String cellphone;\n}\n</code></pre><p>我们平时开发Web后端项目的时候，基本上都是这么组织代码的。其中，UserEntity和UserRepository组成了数据访问层，UserBo和UserService组成了业务逻辑层，UserVo和UserController在这里属于接口层。</p><p>从代码中，我们可以发现，UserBo是一个纯粹的数据结构，只包含数据，不包含任何业务逻辑。业务逻辑集中在UserService中。我们通过UserService来操作UserBo。换句话说，Service层的数据和业务逻辑，被分割为BO和Service两个类中。像UserBo这样，只包含数据，不包含业务逻辑的类，就叫作<strong>贫血模型</strong>（Anemic Domain Model）。同理，UserEntity、UserVo都是基于贫血模型设计的。这种贫血模型将数据与操作分离，破坏了面向对象的封装特性，是一种典型的面向过程的编程风格。</p><h2>什么是基于充血模型的DDD开发模式？</h2><p>刚刚我们讲了基于贫血模型的传统的开发模式。现在我们再讲一下，另外一种最近更加被推崇的开发模式：基于充血模型的DDD开发模式。</p><p><strong>首先，我们先来看一下，什么是充血模型？</strong></p><p>在贫血模型中，数据和业务逻辑被分割到不同的类中。<strong>充血模型</strong>（Rich Domain Model）正好相反，数据和对应的业务逻辑被封装到同一个类中。因此，这种充血模型满足面向对象的封装特性，是典型的面向对象编程风格。</p><p><strong>接下来，我们再来看一下，什么是领域驱动设计？</strong></p><p>领域驱动设计，即DDD，主要是用来指导如何解耦业务系统，划分业务模块，定义业务领域模型及其交互。领域驱动设计这个概念并不新颖，早在2004年就被提出了，到现在已经有十几年的历史了。不过，它被大众熟知，还是基于另一个概念的兴起，那就是微服务。</p><p>我们知道，除了监控、调用链追踪、API网关等服务治理系统的开发之外，微服务还有另外一个更加重要的工作，那就是针对公司的业务，合理地做微服务拆分。而领域驱动设计恰好就是用来指导划分服务的。所以，微服务加速了领域驱动设计的盛行。</p><p>不过，我个人觉得，领域驱动设计有点儿类似敏捷开发、SOA、PAAS等概念，听起来很高大上，但实际上只值“五分钱”。即便你没有听说过领域驱动设计，对这个概念一无所知，只要你是在开发业务系统，也或多或少都在使用它。做好领域驱动设计的关键是，看你对自己所做业务的熟悉程度，而并不是对领域驱动设计这个概念本身的掌握程度。即便你对领域驱动搞得再清楚，但是对业务不熟悉，也并不一定能做出合理的领域设计。所以，不要把领域驱动设计当银弹，不要花太多的时间去过度地研究它。</p><p>实际上，基于充血模型的DDD开发模式实现的代码，也是按照MVC三层架构分层的。Controller层还是负责暴露接口，Repository层还是负责数据存取，Service层负责核心业务逻辑。它跟基于贫血模型的传统开发模式的区别主要在Service层。</p><p>在基于贫血模型的传统开发模式中，Service层包含Service类和BO类两部分，BO是贫血模型，只包含数据，不包含具体的业务逻辑。业务逻辑集中在Service类中。在基于充血模型的DDD开发模式中，Service层包含Service类和Domain类两部分。Domain就相当于贫血模型中的BO。不过，Domain与BO的区别在于它是基于充血模型开发的，既包含数据，也包含业务逻辑。而Service类变得非常单薄。总结一下的话就是，基于贫血模型的传统的开发模式，重Service轻BO；基于充血模型的DDD开发模式，轻Service重Domain。</p><p>基于充血模型的DDD设计模式的概念，今天我们只是简单地介绍了一下。在下一节课中，我会结合具体的项目，通过代码来给你展示，如何基于这种开发模式来开发一个系统。</p><h2>为什么基于贫血模型的传统开发模式如此受欢迎？</h2><p>前面我们讲过，基于贫血模型的传统开发模式，将数据与业务逻辑分离，违反了OOP的封装特性，实际上是一种面向过程的编程风格。但是，现在几乎所有的Web项目，都是基于这种贫血模型的开发模式，甚至连Java Spring框架的官方demo，都是按照这种开发模式来编写的。</p><p>我们前面也讲过，面向过程编程风格有种种弊端，比如，数据和操作分离之后，数据本身的操作就不受限制了。任何代码都可以随意修改数据。既然基于贫血模型的这种传统开发模式是面向过程编程风格的，那它又为什么会被广大程序员所接受呢？关于这个问题，我总结了下面三点原因。</p><p>第一点原因是，大部分情况下，我们开发的系统业务可能都比较简单，简单到就是基于SQL的CRUD操作，所以，我们根本不需要动脑子精心设计充血模型，贫血模型就足以应付这种简单业务的开发工作。除此之外，因为业务比较简单，即便我们使用充血模型，那模型本身包含的业务逻辑也并不会很多，设计出来的领域模型也会比较单薄，跟贫血模型差不多，没有太大意义。</p><p>第二点原因是，充血模型的设计要比贫血模型更加有难度。因为充血模型是一种面向对象的编程风格。我们从一开始就要设计好针对数据要暴露哪些操作，定义哪些业务逻辑。而不是像贫血模型那样，我们只需要定义数据，之后有什么功能开发需求，我们就在Service层定义什么操作，不需要事先做太多设计。</p><p>第三点原因是，思维已固化，转型有成本。基于贫血模型的传统开发模式经历了这么多年，已经深得人心、习以为常。你随便问一个旁边的大龄同事，基本上他过往参与的所有Web项目应该都是基于这个开发模式的，而且也没有出过啥大问题。如果转向用充血模型、领域驱动设计，那势必有一定的学习成本、转型成本。很多人在没有遇到开发痛点的情况下，是不愿意做这件事情的。</p><h2>什么项目应该考虑使用基于充血模型的DDD开发模式？</h2><p>既然基于贫血模型的开发模式已经成为了一种约定俗成的开发习惯，那什么样的项目应该考虑使用基于充血模型的DDD开发模式呢？</p><p>刚刚我们讲到，基于贫血模型的传统的开发模式，比较适合业务比较简单的系统开发。相对应的，基于充血模型的DDD开发模式，更适合业务复杂的系统开发。比如，包含各种利息计算模型、还款模型等复杂业务的金融系统。</p><p>你可能会有一些疑问，这两种开发模式，落实到代码层面，区别不就是一个将业务逻辑放到Service类中，一个将业务逻辑放到Domain领域模型中吗？为什么基于贫血模型的传统开发模式，就不能应对复杂业务系统的开发？而基于充血模型的DDD开发模式就可以呢？</p><p>实际上，除了我们能看到的代码层面的区别之外（一个业务逻辑放到Service层，一个放到领域模型中），还有一个非常重要的区别，那就是两种不同的开发模式会导致不同的开发流程。基于充血模型的DDD开发模式的开发流程，在应对复杂业务系统的开发的时候更加有优势。为什么这么说呢？我们先来回忆一下，我们平时基于贫血模型的传统的开发模式，都是怎么实现一个功能需求的。</p><p>不夸张地讲，我们平时的开发，大部分都是SQL驱动（SQL-Driven）的开发模式。我们接到一个后端接口的开发需求的时候，就去看接口需要的数据对应到数据库中，需要哪张表或者哪几张表，然后思考如何编写SQL语句来获取数据。之后就是定义Entity、BO、VO，然后模板式地往对应的Repository、Service、Controller类中添加代码。</p><p>业务逻辑包裹在一个大的SQL语句中，而Service层可以做的事情很少。SQL都是针对特定的业务功能编写的，复用性差。当我要开发另一个业务功能的时候，只能重新写个满足新需求的SQL语句，这就可能导致各种长得差不多、区别很小的SQL语句满天飞。</p><p>所以，在这个过程中，很少有人会应用领域模型、OOP的概念，也很少有代码复用意识。对于简单业务系统来说，这种开发方式问题不大。但对于复杂业务系统的开发来说，这样的开发方式会让代码越来越混乱，最终导致无法维护。</p><p>如果我们在项目中，应用基于充血模型的DDD的开发模式，那对应的开发流程就完全不一样了。在这种开发模式下，我们需要事先理清楚所有的业务，定义领域模型所包含的属性和方法。领域模型相当于可复用的业务中间层。新功能需求的开发，都基于之前定义好的这些领域模型来完成。</p><p>我们知道，越复杂的系统，对代码的复用性、易维护性要求就越高，我们就越应该花更多的时间和精力在前期设计上。而基于充血模型的DDD开发模式，正好需要我们前期做大量的业务调研、领域模型设计，所以它更加适合这种复杂系统的开发。</p><h2>重点回顾</h2><p>今天的内容到此就讲完了，我们来一起回顾一下，你应该掌握的重点内容。</p><p>我们平时做Web项目的业务开发，大部分都是基于贫血模型的MVC三层架构，在专栏中我把它称为传统的开发模式。之所以称之为“传统”，是相对于新兴的基于充血模型的DDD开发模式来说的。基于贫血模型的传统开发模式，是典型的面向过程的编程风格。相反，基于充血模型的DDD开发模式，是典型的面向对象的编程风格。</p><p>不过，DDD也并非银弹。对于业务不复杂的系统开发来说，基于贫血模型的传统开发模式简单够用，基于充血模型的DDD开发模式有点大材小用，无法发挥作用。相反，对于业务复杂的系统开发来说，基于充血模型的DDD开发模式，因为前期需要在设计上投入更多时间和精力，来提高代码的复用性和可维护性，所以相比基于贫血模型的开发模式，更加有优势。</p><h2>课堂讨论</h2><p>今天课堂讨论的话题有两个。</p><ol>\n<li>你做经历的项目中，有哪些是基于贫血模型的传统的开发模式？有哪些是基于充血模型的DDD开发模式呢？请简单对比一下两者的优劣。</li>\n<li>对于我们举的例子中，UserEntity、UserBo、UserVo包含的字段都差不多，是否可以合并为一个类呢？</li>\n</ol><p>欢迎在留言区写下你的答案，和同学一起交流和分享。如果有收获，也欢迎你把这篇文章分享给你的朋友。</p>",
                "article_title": "11 | 实战一（上）：业务开发常用的基于贫血模型的MVC架构违背OOP吗？"
            },
            {
                "title": "12 | 实战一（下）：如何利用基于充血模型的DDD开发一个虚拟钱包系统？",
                "herf": "https://time.geekbang.org/column/article/169631",
                "id": "169631",
                "content": "<p>上一节课，我们做了一些理论知识的铺垫性讲解，讲到了两种开发模式，基于贫血模型的传统开发模式，以及基于充血模型的DDD开发模式。今天，我们正式进入实战环节，看如何分别用这两种开发模式，设计实现一个钱包系统。</p><p>话不多说，让我们正式开始今天的学习吧！</p><h2>钱包业务背景介绍</h2><p>很多具有支付、购买功能的应用（比如淘宝、滴滴出行、极客时间等）都支持钱包的功能。应用为每个用户开设一个系统内的虚拟钱包账户，支持用户充值、提现、支付、冻结、透支、转赠、查询账户余额、查询交易流水等操作。下图是一张典型的钱包功能界面，你可以直观地感受一下。</p><p><img src=\"https://static001.geekbang.org/resource/image/9e/4a/9e91377602ef154eaf866c7e9263a64a.jpg\" alt=\"\"></p><p>一般来讲，每个虚拟钱包账户都会对应用户的一个真实的支付账户，有可能是银行卡账户，也有可能是三方支付账户（比如支付宝、微信钱包）。为了方便后续的讲解，我们限定钱包暂时只支持充值、提现、支付、查询余额、查询交易流水这五个核心的功能，其他比如冻结、透支、转赠等不常用的功能，我们暂不考虑。为了让你理解这五个核心功能是如何工作的，接下来，我们来一块儿看下它们的业务实现流程。</p><h3>1.充值</h3><p>用户通过三方支付渠道，把自己银行卡账户内的钱，充值到虚拟钱包账号中。这整个过程，我们可以分解为三个主要的操作流程：第一个操作是从用户的银行卡账户转账到应用的公共银行卡账户；第二个操作是将用户的充值金额加到虚拟钱包余额上；第三个操作是记录刚刚这笔交易流水。</p><!-- [[[read_end]]] --><p><img src=\"https://static001.geekbang.org/resource/image/39/14/3915a6544403854d35678c81fe65f014.jpg\" alt=\"\"></p><h3>2.支付</h3><p>用户用钱包内的余额，支付购买应用内的商品。实际上，支付的过程就是一个转账的过程，从用户的虚拟钱包账户划钱到商家的虚拟钱包账户上。除此之外，我们也需要记录这笔支付的交易流水信息。</p><p><img src=\"https://static001.geekbang.org/resource/image/7e/5e/7eb44e2f8661d1c3debde85f79fb2c5e.jpg\" alt=\"\"></p><h3>3.提现</h3><p>除了充值、支付之外，用户还可以将虚拟钱包中的余额，提现到自己的银行卡中。这个过程实际上就是扣减用户虚拟钱包中的余额，并且触发真正的银行转账操作，从应用的公共银行账户转钱到用户的银行账户。同样，我们也需要记录这笔提现的交易流水信息。</p><p><img src=\"https://static001.geekbang.org/resource/image/66/43/66ede1de93d29b86a9194ea0f80d1e43.jpg\" alt=\"\"></p><h3>4.查询余额</h3><p>查询余额功能比较简单，我们看一下虚拟钱包中的余额数字即可。</p><h3>5.查询交易流水</h3><p>查询交易流水也比较简单。我们只支持三种类型的交易流水：充值、支付、提现。在用户充值、支付、提现的时候，我们会记录相应的交易信息。在需要查询的时候，我们只需要将之前记录的交易流水，按照时间、类型等条件过滤之后，显示出来即可。</p><h2>钱包系统的设计思路</h2><p>根据刚刚讲的业务实现流程和数据流转图，我们可以把整个钱包系统的业务划分为两部分，其中一部分单纯跟应用内的虚拟钱包账户打交道，另一部分单纯跟银行账户打交道。我们基于这样一个业务划分，给系统解耦，将整个钱包系统拆分为两个子系统：虚拟钱包系统和三方支付系统。</p><p><img src=\"https://static001.geekbang.org/resource/image/60/62/60d3cfec73986b52e3a6ef4fe147e562.jpg\" alt=\"\"></p><p>为了能在有限的篇幅内，将今天的内容讲透彻，我们接来下只聚焦于虚拟钱包系统的设计与实现。对于三方支付系统以及整个钱包系统的设计与实现，我们不做讲解。你可以自己思考下。</p><p><strong>现在我们来看下，如果要支持钱包的这五个核心功能，虚拟钱包系统需要对应实现哪些操作。</strong>我画了一张图，列出了这五个功能都会对应虚拟钱包的哪些操作。注意，交易流水的记录和查询，我暂时在图中打了个问号，那是因为这块比较特殊，我们待会再讲。</p><p><img src=\"https://static001.geekbang.org/resource/image/d1/30/d1a9aeb6642404f80a62293ab2e45630.jpg\" alt=\"\"></p><p>从图中我们可以看出，虚拟钱包系统要支持的操作非常简单，就是余额的加加减减。其中，充值、提现、查询余额三个功能，只涉及一个账户余额的加减操作，而支付功能涉及两个账户的余额加减操作：一个账户减余额，另一个账户加余额。</p><p><strong>现在，我们再来看一下图中问号的那部分，也就是交易流水该如何记录和查询？</strong>我们先来看一下，交易流水都需要包含哪些信息。我觉得下面这几个信息是必须包含的。</p><p><img src=\"https://static001.geekbang.org/resource/image/38/68/38b56bd1981d8b40ececa4d638e4a968.jpg\" alt=\"\"></p><p>从图中我们可以发现，交易流水的数据格式包含两个钱包账号，一个是入账钱包账号，一个是出账钱包账号。为什么要有两个账号信息呢？这主要是为了兼容支付这种涉及两个账户的交易类型。不过，对于充值、提现这两种交易类型来说，我们只需要记录一个钱包账户信息就够了。</p><p>整个虚拟钱包的设计思路到此讲完了。接下来，我们来看一下，如何分别用基于贫血模型的传统开发模式和基于充血模型的DDD开发模式，来实现这样一个虚拟钱包系统？</p><h2>基于贫血模型的传统开发模式</h2><p>实际上，如果你有一定Web项目的开发经验，并且听明白了我刚刚讲的设计思路，那对你来说，利用基于贫血模型的传统开发模式来实现这样一个系统，应该是一件挺简单的事情。不过，为了对比两种开发模式，我还是带你一块儿来实现一遍。</p><p>这是一个典型的Web后端项目的三层结构。其中，Controller和VO负责暴露接口，具体的代码实现如下所示。注意，Controller中，接口实现比较简单，主要就是调用Service的方法，所以，我省略了具体的代码实现。</p><pre><code>public class VirtualWalletController {\n  // 通过构造函数或者IOC框架注入\n  private VirtualWalletService virtualWalletService;\n  \n  public BigDecimal getBalance(Long walletId) { ... } //查询余额\n  public void debit(Long walletId, BigDecimal amount) { ... } //出账\n  public void credit(Long walletId, BigDecimal amount) { ... } //入账\n  public void transfer(Long fromWalletId, Long toWalletId, BigDecimal amount) { ...} //转账\n  //省略查询transaction的接口\n}\n</code></pre><p>Service和BO负责核心业务逻辑，Repository和Entity负责数据存取。Repository这一层的代码实现比较简单，不是我们讲解的重点，所以我也省略掉了。Service层的代码如下所示。注意，这里我省略了一些不重要的校验代码，比如，对amount是否小于0、钱包是否存在的校验等等。</p><pre><code>public class VirtualWalletBo {//省略getter/setter/constructor方法\n  private Long id;\n  private Long createTime;\n  private BigDecimal balance;\n}\n\npublic Enum TransactionType {\n  DEBIT,\n  CREDIT,\n  TRANSFER;\n}\n\npublic class VirtualWalletService {\n  // 通过构造函数或者IOC框架注入\n  private VirtualWalletRepository walletRepo;\n  private VirtualWalletTransactionRepository transactionRepo;\n  \n  public VirtualWalletBo getVirtualWallet(Long walletId) {\n    VirtualWalletEntity walletEntity = walletRepo.getWalletEntity(walletId);\n    VirtualWalletBo walletBo = convert(walletEntity);\n    return walletBo;\n  }\n  \n  public BigDecimal getBalance(Long walletId) {\n    return walletRepo.getBalance(walletId);\n  }\n\n  @Transactional\n  public void debit(Long walletId, BigDecimal amount) {\n    VirtualWalletEntity walletEntity = walletRepo.getWalletEntity(walletId);\n    BigDecimal balance = walletEntity.getBalance();\n    if (balance.compareTo(amount) &lt; 0) {\n      throw new NoSufficientBalanceException(...);\n    }\n    VirtualWalletTransactionEntity transactionEntity = new VirtualWalletTransactionEntity();\n    transactionEntity.setAmount(amount);\n    transactionEntity.setCreateTime(System.currentTimeMillis());\n    transactionEntity.setType(TransactionType.DEBIT);\n    transactionEntity.setFromWalletId(walletId);\n    transactionRepo.saveTransaction(transactionEntity);\n    walletRepo.updateBalance(walletId, balance.subtract(amount));\n  }\n\n  @Transactional\n  public void credit(Long walletId, BigDecimal amount) {\n    VirtualWalletTransactionEntity transactionEntity = new VirtualWalletTransactionEntity();\n    transactionEntity.setAmount(amount);\n    transactionEntity.setCreateTime(System.currentTimeMillis());\n    transactionEntity.setType(TransactionType.CREDIT);\n    transactionEntity.setFromWalletId(walletId);\n    transactionRepo.saveTransaction(transactionEntity);\n    VirtualWalletEntity walletEntity = walletRepo.getWalletEntity(walletId);\n    BigDecimal balance = walletEntity.getBalance();\n    walletRepo.updateBalance(walletId, balance.add(amount));\n  }\n\n  @Transactional\n  public void transfer(Long fromWalletId, Long toWalletId, BigDecimal amount) {\n    VirtualWalletTransactionEntity transactionEntity = new VirtualWalletTransactionEntity();\n    transactionEntity.setAmount(amount);\n    transactionEntity.setCreateTime(System.currentTimeMillis());\n    transactionEntity.setType(TransactionType.TRANSFER);\n    transactionEntity.setFromWalletId(fromWalletId);\n    transactionEntity.setToWalletId(toWalletId);\n    transactionRepo.saveTransaction(transactionEntity);\n    debit(fromWalletId, amount);\n    credit(toWalletId, amount);\n  }\n}\n</code></pre><h2>基于充血模型的DDD开发模式</h2><p>刚刚讲了如何利用基于贫血模型的传统开发模式来实现虚拟钱包系统，现在，我们再来看一下，如何利用基于充血模型的DDD开发模式来实现这个系统？</p><p>在上一节课中，我们讲到，基于充血模型的DDD开发模式，跟基于贫血模型的传统开发模式的主要区别就在Service层，Controller层和Repository层的代码基本上相同。所以，我们重点看一下，Service层按照基于充血模型的DDD开发模式该如何来实现。</p><p>在这种开发模式下，我们把虚拟钱包VirtualWallet类设计成一个充血的Domain领域模型，并且将原来在Service类中的部分业务逻辑移动到VirtualWallet类中，让Service类的实现依赖VirtualWallet类。具体的代码实现如下所示：</p><pre><code>public class VirtualWallet { // Domain领域模型(充血模型)\n  private Long id;\n  private Long createTime = System.currentTimeMillis();;\n  private BigDecimal balance = BigDecimal.ZERO;\n  \n  public VirtualWallet(Long preAllocatedId) {\n    this.id = preAllocatedId;\n  }\n  \n  public BigDecimal balance() {\n    return this.balance;\n  }\n  \n  public void debit(BigDecimal amount) {\n    if (this.balance.compareTo(amount) &lt; 0) {\n      throw new InsufficientBalanceException(...);\n    }\n    this.balance = this.balance.subtract(amount);\n  }\n  \n  public void credit(BigDecimal amount) {\n    if (amount.compareTo(BigDecimal.ZERO) &lt; 0) {\n      throw new InvalidAmountException(...);\n    }\n    this.balance = this.balance.add(amount);\n  }\n}\n\npublic class VirtualWalletService {\n  // 通过构造函数或者IOC框架注入\n  private VirtualWalletRepository walletRepo;\n  private VirtualWalletTransactionRepository transactionRepo;\n  \n  public VirtualWallet getVirtualWallet(Long walletId) {\n    VirtualWalletEntity walletEntity = walletRepo.getWalletEntity(walletId);\n    VirtualWallet wallet = convert(walletEntity);\n    return wallet;\n  }\n  \n  public BigDecimal getBalance(Long walletId) {\n    return walletRepo.getBalance(walletId);\n  }\n  \n  @Transactional\n  public void debit(Long walletId, BigDecimal amount) {\n    VirtualWalletEntity walletEntity = walletRepo.getWalletEntity(walletId);\n    VirtualWallet wallet = convert(walletEntity);\n    wallet.debit(amount);\n    VirtualWalletTransactionEntity transactionEntity = new VirtualWalletTransactionEntity();\n    transactionEntity.setAmount(amount);\n    transactionEntity.setCreateTime(System.currentTimeMillis());\n    transactionEntity.setType(TransactionType.DEBIT);\n    transactionEntity.setFromWalletId(walletId);\n    transactionRepo.saveTransaction(transactionEntity);\n    walletRepo.updateBalance(walletId, wallet.balance());\n  }\n  \n  @Transactional\n  public void credit(Long walletId, BigDecimal amount) {\n    VirtualWalletEntity walletEntity = walletRepo.getWalletEntity(walletId);\n    VirtualWallet wallet = convert(walletEntity);\n    wallet.credit(amount);\n    VirtualWalletTransactionEntity transactionEntity = new VirtualWalletTransactionEntity();\n    transactionEntity.setAmount(amount);\n    transactionEntity.setCreateTime(System.currentTimeMillis());\n    transactionEntity.setType(TransactionType.CREDIT);\n    transactionEntity.setFromWalletId(walletId);\n    transactionRepo.saveTransaction(transactionEntity);\n    walletRepo.updateBalance(walletId, wallet.balance());\n  }\n\n  @Transactional\n  public void transfer(Long fromWalletId, Long toWalletId, BigDecimal amount) {\n    //...跟基于贫血模型的传统开发模式的代码一样...\n  }\n}\n\n</code></pre><p>看了上面的代码，你可能会说，领域模型VirtualWallet类很单薄，包含的业务逻辑很简单。相对于原来的贫血模型的设计思路，这种充血模型的设计思路，貌似并没有太大优势。你说得没错！这也是大部分业务系统都使用基于贫血模型开发的原因。不过，如果虚拟钱包系统需要支持更复杂的业务逻辑，那充血模型的优势就显现出来了。比如，我们要支持透支一定额度和冻结部分余额的功能。这个时候，我们重新来看一下VirtualWallet类的实现代码。</p><pre><code>public class VirtualWallet {\n  private Long id;\n  private Long createTime = System.currentTimeMillis();;\n  private BigDecimal balance = BigDecimal.ZERO;\n  private boolean isAllowedOverdraft = true;\n  private BigDecimal overdraftAmount = BigDecimal.ZERO;\n  private BigDecimal frozenAmount = BigDecimal.ZERO;\n  \n  public VirtualWallet(Long preAllocatedId) {\n    this.id = preAllocatedId;\n  }\n  \n  public void freeze(BigDecimal amount) { ... }\n  public void unfreeze(BigDecimal amount) { ...}\n  public void increaseOverdraftAmount(BigDecimal amount) { ... }\n  public void decreaseOverdraftAmount(BigDecimal amount) { ... }\n  public void closeOverdraft() { ... }\n  public void openOverdraft() { ... }\n  \n  public BigDecimal balance() {\n    return this.balance;\n  }\n  \n  public BigDecimal getAvaliableBalance() {\n    BigDecimal totalAvaliableBalance = this.balance.subtract(this.frozenAmount);\n    if (isAllowedOverdraft) {\n      totalAvaliableBalance += this.overdraftAmount;\n    }\n    return totalAvaliableBalance;\n  }\n  \n  public void debit(BigDecimal amount) {\n    BigDecimal totalAvaliableBalance = getAvaliableBalance();\n    if (totoalAvaliableBalance.compareTo(amount) &lt; 0) {\n      throw new InsufficientBalanceException(...);\n    }\n    this.balance = this.balance.subtract(amount);\n  }\n  \n  public void credit(BigDecimal amount) {\n    if (amount.compareTo(BigDecimal.ZERO) &lt; 0) {\n      throw new InvalidAmountException(...);\n    }\n    this.balance = this.balance.add(amount);\n  }\n}\n\n</code></pre><p>领域模型VirtualWallet类添加了简单的冻结和透支逻辑之后，功能看起来就丰富了很多，代码也没那么单薄了。如果功能继续演进，我们可以增加更加细化的冻结策略、透支策略、支持钱包账号（VirtualWallet id字段）自动生成的逻辑（不是通过构造函数经外部传入ID，而是通过分布式ID生成算法来自动生成ID）等等。VirtualWallet类的业务逻辑会变得越来越复杂，也就很值得设计成充血模型了。</p><h2>辩证思考与灵活应用</h2><p>对于虚拟钱包系统的设计与两种开发模式的代码实现，我想你应该有个比较清晰的了解了。不过，我觉得还有两个问题值得讨论一下。</p><p><strong>第一个要讨论的问题是：在基于充血模型的DDD开发模式中，将业务逻辑移动到Domain中，Service类变得很薄，但在我们的代码设计与实现中，并没有完全将Service类去掉，这是为什么？或者说，Service类在这种情况下担当的职责是什么？哪些功能逻辑会放到Service类中？</strong></p><p>区别于Domain的职责，Service类主要有下面这样几个职责。</p><p>1.Service类负责与Repository交流。在我的设计与代码实现中，VirtualWalletService类负责与Repository层打交道，调用Respository类的方法，获取数据库中的数据，转化成领域模型VirtualWallet，然后由领域模型VirtualWallet来完成业务逻辑，最后调用Repository类的方法，将数据存回数据库。</p><p>这里我再稍微解释一下，之所以让VirtualWalletService类与Repository打交道，而不是让领域模型VirtualWallet与Repository打交道，那是因为我们想保持领域模型的独立性，不与任何其他层的代码（Repository层的代码）或开发框架（比如Spring、MyBatis）耦合在一起，将流程性的代码逻辑（比如从DB中取数据、映射数据）与领域模型的业务逻辑解耦，让领域模型更加可复用。</p><p>2.Service类负责跨领域模型的业务聚合功能。VirtualWalletService类中的transfer()转账函数会涉及两个钱包的操作，因此这部分业务逻辑无法放到VirtualWallet类中，所以，我们暂且把转账业务放到VirtualWalletService类中了。当然，虽然功能演进，使得转账业务变得复杂起来之后，我们也可以将转账业务抽取出来，设计成一个独立的领域模型。</p><p>3.Service类负责一些非功能性及与三方系统交互的工作。比如幂等、事务、发邮件、发消息、记录日志、调用其他系统的RPC接口等，都可以放到Service类中。</p><p><strong>第二个要讨论问题是：在基于充血模型的DDD开发模式中，尽管Service层被改造成了充血模型，但是Controller层和Repository层还是贫血模型，是否有必要也进行充血领域建模呢？</strong></p><p>答案是没有必要。Controller层主要负责接口的暴露，Repository层主要负责与数据库打交道，这两层包含的业务逻辑并不多，前面我们也提到了，如果业务逻辑比较简单，就没必要做充血建模，即便设计成充血模型，类也非常单薄，看起来也很奇怪。</p><p>尽管这样的设计是一种面向过程的编程风格，但我们只要控制好面向过程编程风格的副作用，照样可以开发出优秀的软件。那这里的副作用怎么控制呢？</p><p>就拿Repository的Entity来说，即便它被设计成贫血模型，违反面向对象编程的封装特性，有被任意代码修改数据的风险，但Entity的生命周期是有限的。一般来讲，我们把它传递到Service层之后，就会转化成BO或者Domain来继续后面的业务逻辑。Entity的生命周期到此就结束了，所以也并不会被到处任意修改。</p><p>我们再来说说Controller层的VO。实际上VO是一种DTO（Data Transfer Object，数据传输对象）。它主要是作为接口的数据传输承载体，将数据发送给其他系统。从功能上来讲，它理应不包含业务逻辑、只包含数据。所以，我们将它设计成贫血模型也是比较合理的。</p><h2>重点回顾</h2><p>今天的内容到此就讲完了。我们一块来总结回顾一下，你应该重点掌握的知识点。</p><p>基于充血模型的DDD开发模式跟基于贫血模型的传统开发模式相比，主要区别在Service层。在基于充血模型的开发模式下，我们将部分原来在Service类中的业务逻辑移动到了一个充血的Domain领域模型中，让Service类的实现依赖这个Domain类。</p><p>在基于充血模型的DDD开发模式下，Service类并不会完全移除，而是负责一些不适合放在Domain类中的功能。比如，负责与Repository层打交道、跨领域模型的业务聚合功能、幂等事务等非功能性的工作。</p><p>基于充血模型的DDD开发模式跟基于贫血模型的传统开发模式相比，Controller层和Repository层的代码基本上相同。这是因为，Repository层的Entity生命周期有限，Controller层的VO只是单纯作为一种DTO。两部分的业务逻辑都不会太复杂。业务逻辑主要集中在Service层。所以，Repository层和Controller层继续沿用贫血模型的设计思路是没有问题的。</p><h2>课堂讨论</h2><p>这两节课中对于DDD的讲解，都是我的个人主观看法，你可能会有不同看法。</p><p>欢迎在留言区说一说你对DDD的看法。如果觉得有帮助，你也可以把这篇文章分享给你的朋友。</p>",
                "article_title": "12 | 实战一（下）：如何利用基于充血模型的DDD开发一个虚拟钱包系统？"
            },
            {
                "title": "13 | 实战二（上）：如何对接口鉴权这样一个功能开发做面向对象分析？",
                "herf": "https://time.geekbang.org/column/article/171760",
                "id": "171760",
                "content": "<p>面向对象分析（OOA）、面向对象设计（OOD）、面向对象编程（OOP），是面向对象开发的三个主要环节。在前面的章节中，我对三者的讲解比较偏理论、偏概括性，目的是让你先有一个宏观的了解，知道什么是OOA、OOD、OOP。不过，光知道“是什么”是不够的，我们更重要的还是要知道“如何做”，也就是，如何进行面向对象分析、设计与编程。</p><p>在过往的工作中，我发现，很多工程师，特别是初级工程师，本身没有太多的项目经验，或者参与的项目都是基于开发框架填写CRUD模板似的代码，导致分析、设计能力比较欠缺。当他们拿到一个比较笼统的开发需求的时候，往往不知道从何入手。</p><p>对于“如何做需求分析，如何做职责划分？需要定义哪些类？每个类应该具有哪些属性、方法？类与类之间该如何交互？如何组装类成一个可执行的程序？”等等诸多问题，都没有清晰的思路，更别提利用成熟的设计原则、思想或者设计模式，开发出具有高内聚低耦合、易扩展、易读等优秀特性的代码了。</p><p>所以，我打算用两节课的时间，结合一个真实的开发案例，从基础的需求分析、职责划分、类的定义、交互、组装运行讲起，将最基础的面向对象分析、设计、编程的套路给你讲清楚，为后面学习设计原则、设计模式打好基础。</p><!-- [[[read_end]]] --><p>话不多说，让我们正式开始今天的学习吧！</p><h2>案例介绍和难点剖析</h2><p>假设，你正在参与开发一个微服务。微服务通过HTTP协议暴露接口给其他系统调用，说直白点就是，其他系统通过URL来调用微服务的接口。有一天，你的leader找到你说，“为了保证接口调用的安全性，我们希望设计实现一个接口调用鉴权功能，只有经过认证之后的系统才能调用我们的接口，没有认证过的系统调用我们的接口会被拒绝。我希望由你来负责这个任务的开发，争取尽快上线。”</p><p>leader丢下这些话就走了。这个时候，你该如何来做呢？有没有脑子里一团浆糊，一时间无从下手的感觉呢？为什么会有这种感觉呢？我个人觉得主要有下面两点原因。</p><h3>1.需求不明确</h3><p>leader给到的需求过于模糊、笼统，不够具体、细化，离落地到设计、编码还有一定的距离。而人的大脑不擅长思考这种过于抽象的问题。这也是真实的软件开发区别于应试教育的地方。应试教育中的考试题目，一般都是一个非常具体的问题，我们去解答就好了。而真实的软件开发中，需求几乎都不是很明确。</p><p>我们前面讲过，面向对象分析主要的分析对象是“需求”，因此，面向对象分析可以粗略地看成“需求分析”。实际上，不管是需求分析还是面向对象分析，我们首先要做的都是将笼统的需求细化到足够清晰、可执行。我们需要通过沟通、挖掘、分析、假设、梳理，搞清楚具体的需求有哪些，哪些是现在要做的，哪些是未来可能要做的，哪些是不用考虑做的。</p><h3>2.缺少锻炼</h3><p>相比单纯的业务CRUD开发，鉴权这个开发任务，要更有难度。鉴权作为一个跟具体业务无关的功能，我们完全可以把它开发成一个独立的框架，集成到很多业务系统中。而作为被很多系统复用的通用框架，比起普通的业务代码，我们对框架的代码质量要求要更高。</p><p>开发这样通用的框架，对工程师的需求分析能力、设计能力、编码能力，甚至逻辑思维能力的要求，都是比较高的。如果你平时做的都是简单的CRUD业务开发，那这方面的锻炼肯定不会很多，所以，一旦遇到这种开发需求，很容易因为缺少锻炼，脑子放空，不知道从何入手，完全没有思路。</p><h2>对案例进行需求分析</h2><p>实际上，需求分析的工作很琐碎，也没有太多固定的章法可寻，所以，我不打算很牵强地罗列那些听着有用、实际没用的方法论，而是希望通过鉴权这个例子，来给你展示一下，面对需求分析的时候，我的完整的思考路径是什么样的。希望你能自己去体会，举一反三地类比应用到其他项目的需求分析中。</p><p>尽管针对框架、组件、类库等非业务系统的开发，我们一定要有组件化意识、框架意识、抽象意识，开发出来的东西要足够通用，不能局限于单一的某个业务需求，但这并不代表我们就可以脱离具体的应用场景，闷头拍脑袋做需求分析。多跟业务团队聊聊天，甚至自己去参与几个业务系统的开发，只有这样，我们才能真正知道业务系统的痛点，才能分析出最有价值的需求。不过，针对鉴权这一功能的开发，最大的需求方还是我们自己，所以，我们也可以先从满足我们自己系统的需求开始，然后再迭代优化。</p><p>现在，我们来看一下，针对鉴权这个功能的开发，我们该如何做需求分析？</p><p>实际上，这跟做算法题类似，先从最简单的方案想起，然后再优化。所以，我把整个的分析过程分为了循序渐进的四轮。每一轮都是对上一轮的迭代优化，最后形成一个可执行、可落地的需求列表。</p><h3>1.第一轮基础分析</h3><p>对于如何做鉴权这样一个问题，最简单的解决方案就是，通过用户名加密码来做认证。我们给每个允许访问我们服务的调用方，派发一个应用名（或者叫应用ID、AppID）和一个对应的密码（或者叫秘钥）。调用方每次进行接口请求的时候，都携带自己的AppID和密码。微服务在接收到接口调用请求之后，会解析出AppID和密码，跟存储在微服务端的AppID和密码进行比对。如果一致，说明认证成功，则允许接口调用请求；否则，就拒绝接口调用请求。</p><h3>2.第二轮分析优化</h3><p>不过，这样的验证方式，每次都要明文传输密码。密码很容易被截获，是不安全的。那如果我们借助加密算法（比如SHA），对密码进行加密之后，再传递到微服务端验证，是不是就可以了呢？实际上，这样也是不安全的，因为加密之后的密码及AppID，照样可以被未认证系统（或者说黑客）截获，未认证系统可以携带这个加密之后的密码以及对应的AppID，伪装成已认证系统来访问我们的接口。这就是典型的“<a href=\"https://zh.wikipedia.org/wiki/%E9%87%8D%E6%94%BE%E6%94%BB%E5%87%BB\">重放攻击</a>”。</p><p>提出问题，然后再解决问题，是一个非常好的迭代优化方法。对于刚刚这个问题，我们可以借助OAuth的验证思路来解决。调用方将请求接口的URL跟AppID、密码拼接在一起，然后进行加密，生成一个token。调用方在进行接口请求的的时候，将这个token及AppID，随URL一块传递给微服务端。微服务端接收到这些数据之后，根据AppID从数据库中取出对应的密码，并通过同样的token生成算法，生成另外一个token。用这个新生成的token跟调用方传递过来的token对比。如果一致，则允许接口调用请求；否则，就拒绝接口调用请求。</p><p>这个方案稍微有点复杂，我画了一张示例图，来帮你理解整个流程。</p><p><img src=\"https://static001.geekbang.org/resource/image/07/d7/0704c4806f9d6c01bb20884d05ee54d7.jpg\" alt=\"\"></p><h3>3.第三轮分析优化</h3><p>不过，这样的设计仍然存在重放攻击的风险，还是不够安全。每个URL拼接上AppID、密码生成的token都是固定的。未认证系统截获URL、token和AppID之后，还是可以通过重放攻击的方式，伪装成认证系统，调用这个URL对应的接口。</p><p>为了解决这个问题，我们可以进一步优化token生成算法，引入一个随机变量，让每次接口请求生成的token都不一样。我们可以选择时间戳作为随机变量。原来的token是对URL、AppID、密码三者进行加密生成的，现在我们将URL、AppID、密码、时间戳四者进行加密来生成token。调用方在进行接口请求的时候，将token、AppID、时间戳，随URL一并传递给微服务端。</p><p>微服务端在收到这些数据之后，会验证当前时间戳跟传递过来的时间戳，是否在一定的时间窗口内（比如一分钟）。如果超过一分钟，则判定token过期，拒绝接口请求。如果没有超过一分钟，则说明token没有过期，就再通过同样的token生成算法，在服务端生成新的token，与调用方传递过来的token比对，看是否一致。如果一致，则允许接口调用请求；否则，就拒绝接口调用请求。</p><p>优化之后的认证流程如下图所示。</p><p><img src=\"https://static001.geekbang.org/resource/image/bd/60/bde932c73c6636ad85380e4801dbfb60.jpg\" alt=\"\"></p><h3>4.第四轮分析优化</h3><p>不过，你可能会说，这样还是不够安全啊。未认证系统还是可以在这一分钟的token失效窗口内，通过截获请求、重放请求，来调用我们的接口啊！</p><p>你说得没错。不过，攻与防之间，本来就没有绝对的安全。我们能做的就是，尽量提高攻击的成本。这个方案虽然还有漏洞，但是实现起来足够简单，而且不会过度影响接口本身的性能（比如响应时间）。所以，权衡安全性、开发成本、对系统性能的影响，这个方案算是比较折中、比较合理的了。</p><p>实际上，还有一个细节我们没有考虑到，那就是，如何在微服务端存储每个授权调用方的AppID和密码。当然，这个问题并不难。最容易想到的方案就是存储到数据库里，比如MySQL。不过，开发像鉴权这样的非业务功能，最好不要与具体的第三方系统有过度的耦合。</p><p>针对AppID和密码的存储，我们最好能灵活地支持各种不同的存储方式，比如ZooKeeper、本地配置文件、自研配置中心、MySQL、Redis等。我们不一定针对每种存储方式都去做代码实现，但起码要留有扩展点，保证系统有足够的灵活性和扩展性，能够在我们切换存储方式的时候，尽可能地减少代码的改动。</p><h3>5.最终确定需求</h3><p>到此，需求已经足够细化和具体了。现在，我们按照鉴权的流程，对需求再重新描述一下。如果你熟悉UML，也可以用时序图、流程图来描述。不过，用什么描述不是重点，描述清楚才是最重要的。考虑到在接下来的面向对象设计环节中，我会基于文字版本的需求描述，来进行类、属性、方法、交互等的设计，所以，这里我给出的最终需求描述是文字版本的。</p><ul>\n<li>调用方进行接口请求的时候，将URL、AppID、密码、时间戳拼接在一起，通过加密算法生成token，并且将token、AppID、时间戳拼接在URL中，一并发送到微服务端。</li>\n<li>微服务端在接收到调用方的接口请求之后，从请求中拆解出token、AppID、时间戳。</li>\n<li>微服务端首先检查传递过来的时间戳跟当前时间，是否在token失效时间窗口内。如果已经超过失效时间，那就算接口调用鉴权失败，拒绝接口调用请求。</li>\n<li>如果token验证没有过期失效，微服务端再从自己的存储中，取出AppID对应的密码，通过同样的token生成算法，生成另外一个token，与调用方传递过来的token进行匹配；如果一致，则鉴权成功，允许接口调用，否则就拒绝接口调用。</li>\n</ul><p>这就是我们需求分析的整个思考过程，从最粗糙、最模糊的需求开始，通过“提出问题-解决问题”的方式，循序渐进地进行优化，最后得到一个足够清晰、可落地的需求描述。</p><h2>重点回顾</h2><p>今天的内容到此就讲完了。我们一块来总结回顾一下，你需要掌握的一些重点内容。</p><p>针对框架、类库、组件等非业务系统的开发，其中一个比较大的难点就是，需求一般都比较抽象、模糊，需要你自己去挖掘，做合理取舍、权衡、假设，把抽象的问题具象化，最终产生清晰的、可落地的需求定义。需求定义是否清晰、合理，直接影响了后续的设计、编码实现是否顺畅。所以，作为程序员，你一定不要只关心设计与实现，前期的需求分析同等重要。</p><p>需求分析的过程实际上是一个不断迭代优化的过程。我们不要试图一下就能给出一个完美的解决方案，而是先给出一个粗糙的、基础的方案，有一个迭代的基础，然后再慢慢优化，这样一个思考过程能让我们摆脱无从下手的窘境。</p><h2>课堂讨论</h2><p>除了工作中我们会遇到需求不明确的开发任务，实际上，在面试中，我们也经常遇到一些开放性的设计问题，对于这类问题，你是如何解答的？有哪些好的经验可以分享给大家呢？</p><p>欢迎在留言区写下你的答案，和同学一起交流和分享。如果有收获，也欢迎你把这篇文章分享给你的朋友。</p>",
                "article_title": "13 | 实战二（上）：如何对接口鉴权这样一个功能开发做面向对象分析？"
            },
            {
                "title": "14 | 实战二（下）：如何利用面向对象设计和编程开发接口鉴权功能？",
                "herf": "https://time.geekbang.org/column/article/171767",
                "id": "171767",
                "content": "<p>在上一节课中，针对接口鉴权功能的开发，我们讲了如何进行面向对象分析（OOA），也就是需求分析。实际上，需求定义清楚之后，这个问题就已经解决了一大半，这也是为什么我花了那么多篇幅来讲解需求分析。今天，我们再来看一下，针对面向对象分析产出的需求，如何来进行面向对象设计（OOD）和面向对象编程（OOP）。</p><h2>如何进行面向对象设计？</h2><p>我们知道，面向对象分析的产出是详细的需求描述，那面向对象设计的产出就是类。在面向对象设计环节，我们将需求描述转化为具体的类的设计。我们把这一设计环节拆解细化一下，主要包含以下几个部分：</p><ul>\n<li>划分职责进而识别出有哪些类；</li>\n<li>定义类及其属性和方法；</li>\n<li>定义类与类之间的交互关系；</li>\n<li>将类组装起来并提供执行入口。</li>\n</ul><p>实话讲，不管是面向对象分析还是面向对象设计，理论的东西都不多，所以我们还是结合鉴权这个例子，在实战中体会如何做面向对象设计。</p><h3>1.划分职责进而识别出有哪些类</h3><p>在面向对象有关书籍中经常讲到，类是现实世界中事物的一个建模。但是，并不是每个需求都能映射到现实世界，也并不是每个类都与现实世界中的事物一一对应。对于一些抽象的概念，我们是无法通过映射现实世界中的事物的方式来定义类的。</p><p>所以，大多数讲面向对象的书籍中，还会讲到另外一种识别类的方法，那就是把需求描述中的名词罗列出来，作为可能的候选类，然后再进行筛选。对于没有经验的初学者来说，这个方法比较简单、明确，可以直接照着做。</p><!-- [[[read_end]]] --><p>不过，我个人更喜欢另外一种方法，那就是根据需求描述，把其中涉及的功能点，一个一个罗列出来，然后再去看哪些功能点职责相近，操作同样的属性，是否应该归为同一个类。我们来看一下，针对鉴权这个例子，具体该如何来做。</p><p>在上一节课中，我们已经给出了详细的需求描述，为了方便你查看，我把它重新贴在了下面。</p><ul>\n<li>调用方进行接口请求的时候，将URL、AppID、密码、时间戳拼接在一起，通过加密算法生成token，并且将token、AppID、时间戳拼接在URL中，一并发送到微服务端。</li>\n<li>微服务端在接收到调用方的接口请求之后，从请求中拆解出token、AppID、时间戳。</li>\n<li>微服务端首先检查传递过来的时间戳跟当前时间，是否在token失效时间窗口内。如果已经超过失效时间，那就算接口调用鉴权失败，拒绝接口调用请求。</li>\n<li>如果token验证没有过期失效，微服务端再从自己的存储中，取出AppID对应的密码，通过同样的token生成算法，生成另外一个token，与调用方传递过来的token进行匹配。如果一致，则鉴权成功，允许接口调用；否则就拒绝接口调用。</li>\n</ul><p>首先，我们要做的是逐句阅读上面的需求描述，拆解成小的功能点，一条一条罗列下来。注意，拆解出来的每个功能点要尽可能的小。每个功能点只负责做一件很小的事情（专业叫法是“单一职责”，后面章节中我们会讲到）。下面是我逐句拆解上述需求描述之后，得到的功能点列表：</p><ol>\n<li>把URL、AppID、密码、时间戳拼接为一个字符串；</li>\n<li>对字符串通过加密算法加密生成token；</li>\n<li>将token、AppID、时间戳拼接到URL中，形成新的URL；</li>\n<li>解析URL，得到token、AppID、时间戳等信息；</li>\n<li>从存储中取出AppID和对应的密码；</li>\n<li>根据时间戳判断token是否过期失效；</li>\n<li>验证两个token是否匹配；</li>\n</ol><p>从上面的功能列表中，我们发现，1、2、6、7都是跟token有关，负责token的生成、验证；3、4都是在处理URL，负责URL的拼接、解析；5是操作AppID和密码，负责从存储中读取AppID和密码。所以，我们可以粗略地得到三个核心的类：AuthToken、Url、CredentialStorage。AuthToken负责实现1、2、6、7这四个操作；Url负责3、4两个操作；CredentialStorage负责5这个操作。</p><p>当然，这是一个初步的类的划分，其他一些不重要的、边边角角的类，我们可能暂时没法一下子想全，但这也没关系，面向对象分析、设计、编程本来就是一个循环迭代、不断优化的过程。根据需求，我们先给出一个粗糙版本的设计方案，然后基于这样一个基础，再去迭代优化，会更加容易一些，思路也会更加清晰一些。</p><p>不过，我还要再强调一点，接口调用鉴权这个开发需求比较简单，所以，需求对应的面向对象设计并不复杂，识别出来的类也并不多。但如果我们面对的是更加大型的软件开发、更加复杂的需求开发，涉及的功能点可能会很多，对应的类也会比较多，像刚刚那样根据需求逐句罗列功能点的方法，最后会得到一个长长的列表，就会有点凌乱、没有规律。针对这种复杂的需求开发，我们首先要做的是进行模块划分，将需求先简单划分成几个小的、独立的功能模块，然后再在模块内部，应用我们刚刚讲的方法，进行面向对象设计。而模块的划分和识别，跟类的划分和识别，是类似的套路。</p><h3>2.定义类及其属性和方法</h3><p>刚刚我们通过分析需求描述，识别出了三个核心的类，它们分别是AuthToken、Url和CredentialStorage。现在我们来看下，每个类都有哪些属性和方法。我们还是从功能点列表中挖掘。</p><p><strong>AuthToken类相关的功能点有四个：</strong></p><ul>\n<li>把URL、AppID、密码、时间戳拼接为一个字符串；</li>\n<li>对字符串通过加密算法加密生成token；</li>\n<li>根据时间戳判断token是否过期失效；</li>\n<li>验证两个token是否匹配。</li>\n</ul><p>对于方法的识别，很多面向对象相关的书籍，一般都是这么讲的，识别出需求描述中的动词，作为候选的方法，再进一步过滤筛选。类比一下方法的识别，我们可以把功能点中涉及的名词，作为候选属性，然后同样进行过滤筛选。</p><p>我们可以借用这个思路，根据功能点描述，识别出来AuthToken类的属性和方法，如下所示：</p><p><img src=\"https://static001.geekbang.org/resource/image/69/9b/69c8954e0db1a4db99a6094ee359fc9b.jpg\" alt=\"\"></p><p>从上面的类图中，我们可以发现这样三个小细节。</p><ul>\n<li>第一个细节：并不是所有出现的名词都被定义为类的属性，比如URL、AppID、密码、时间戳这几个名词，我们把它作为了方法的参数。</li>\n<li>第二个细节：我们还需要挖掘一些没有出现在功能点描述中属性，比如createTime，expireTimeInterval，它们用在isExpired()函数中，用来判定token是否过期。</li>\n<li>第三个细节：我们还给AuthToken类添加了一个功能点描述中没有提到的方法getToken()。</li>\n</ul><p>第一个细节告诉我们，从业务模型上来说，不应该属于这个类的属性和方法，不应该被放到这个类里。比如URL、AppID这些信息，从业务模型上来说，不应该属于AuthToken，所以我们不应该放到这个类中。</p><p>第二、第三个细节告诉我们，在设计类具有哪些属性和方法的时候，不能单纯地依赖当下的需求，还要分析这个类从业务模型上来讲，理应具有哪些属性和方法。这样可以一方面保证类定义的完整性，另一方面不仅为当下的需求还为未来的需求做些准备。</p><p><strong>Url类相关的功能点有两个：</strong></p><ul>\n<li>将token、AppID、时间戳拼接到URL中，形成新的URL；</li>\n<li>解析URL，得到token、AppID、时间戳等信息。</li>\n</ul><p>虽然需求描述中，我们都是以URL来代指接口请求，但是，接口请求并不一定是以URL的形式来表达，还有可能是Dubbo、RPC等其他形式。为了让这个类更加通用，命名更加贴切，我们接下来把它命名为ApiRequest。下面是我根据功能点描述设计的ApiRequest类。</p><p><img src=\"https://static001.geekbang.org/resource/image/1c/d6/1cc9b95e511bd49fbc23c00ac5c0fed6.jpg\" alt=\"\"></p><p><strong>CredentialStorage类相关的功能点有一个：</strong></p><ul>\n<li>从存储中取出AppID和对应的密码。</li>\n</ul><p>CredentialStorage类非常简单，类图如下所示。为了做到抽象封装具体的存储方式，我们将CredentialStorage设计成了接口，基于接口而非具体的实现编程。</p><p><img src=\"https://static001.geekbang.org/resource/image/3b/85/3b6d2c0cadafa723e26cc032c29c8785.jpg\" alt=\"\"></p><h3>3.定义类与类之间的交互关系</h3><p>类与类之间都有哪些交互关系呢？UML统一建模语言中定义了六种类之间的关系。它们分别是：泛化、实现、关联、聚合、组合、依赖。关系比较多，而且有些还比较相近，比如聚合和组合，接下来我就逐一讲解一下。</p><p><strong>泛化</strong>（Generalization）可以简单理解为继承关系。具体到Java代码就是下面这样：</p><pre><code>public class A { ... }\npublic class B extends A { ... }\n</code></pre><p><strong>实现</strong>（Realization）一般是指接口和实现类之间的关系。具体到Java代码就是下面这样：</p><pre><code>public interface A {...}\npublic class B implements A { ... }\n</code></pre><p><strong>聚合</strong>（Aggregation）是一种包含关系，A类对象包含B类对象，B类对象的生命周期可以不依赖A类对象的生命周期，也就是说可以单独销毁A类对象而不影响B对象，比如课程与学生之间的关系。具体到Java代码就是下面这样：</p><pre><code>public class A {\n  private B b;\n  public A(B b) {\n    this.b = b;\n  }\n}\n</code></pre><p><strong>组合</strong>（Composition）也是一种包含关系。A类对象包含B类对象，B类对象的生命周期依赖A类对象的生命周期，B类对象不可单独存在，比如鸟与翅膀之间的关系。具体到Java代码就是下面这样：</p><pre><code>public class A {\n  private B b;\n  public A() {\n    this.b = new B();\n  }\n}\n</code></pre><p><strong>关联</strong>（Association）是一种非常弱的关系，包含聚合、组合两种关系。具体到代码层面，如果B类对象是A类的成员变量，那B类和A类就是关联关系。具体到Java代码就是下面这样：</p><pre><code>public class A {\n  private B b;\n  public A(B b) {\n    this.b = b;\n  }\n}\n或者\npublic class A {\n  private B b;\n  public A() {\n    this.b = new B();\n  }\n}\n</code></pre><p><strong>依赖</strong>（Dependency）是一种比关联关系更加弱的关系，包含关联关系。不管是B类对象是A类对象的成员变量，还是A类的方法使用B类对象作为参数或者返回值、局部变量，只要B类对象和A类对象有任何使用关系，我们都称它们有依赖关系。具体到Java代码就是下面这样：</p><pre><code>public class A {\n  private B b;\n  public A(B b) {\n    this.b = b;\n  }\n}\n或者\npublic class A {\n  private B b;\n  public A() {\n    this.b = new B();\n  }\n}\n或者\npublic class A {\n  public void func(B b) { ... }\n}\n</code></pre><p>看完了UML六种类关系的详细介绍，不知道你有何感受？我个人觉得这样拆分有点太细，增加了学习成本，对于指导编程开发没有太大意义。所以，我从更加贴近编程的角度，对类与类之间的关系做了调整，只保留了四个关系：泛化、实现、组合、依赖，这样你掌握起来会更加容易。</p><p>其中，泛化、实现、依赖的定义不变，组合关系替代UML中组合、聚合、关联三个概念，也就相当于重新命名关联关系为组合关系，并且不再区分UML中的组合和聚合两个概念。之所以这样重新命名，是为了跟我们前面讲的“多用组合少用继承”设计原则中的“组合”统一含义。只要B类对象是A类对象的成员变量，那我们就称，A类跟B类是组合关系。</p><p>理论的东西讲完了，让我们来看一下，刚刚我们定义的类之间都有哪些关系呢？因为目前只有三个核心的类，所以只用到了实现关系，也即CredentialStorage和MysqlCredentialStorage之间的关系。接下来讲到组装类的时候，我们还会用到依赖关系、组合关系，但是泛化关系暂时没有用到。</p><h3>4.将类组装起来并提供执行入口</h3><p>类定义好了，类之间必要的交互关系也设计好了，接下来我们要将所有的类组装在一起，提供一个执行入口。这个入口可能是一个main()函数，也可能是一组给外部用的API接口。通过这个入口，我们能触发整个代码跑起来。</p><p>接口鉴权并不是一个独立运行的系统，而是一个集成在系统上运行的组件，所以，我们封装所有的实现细节，设计了一个最顶层的ApiAuthenticator接口类，暴露一组给外部调用者使用的API接口，作为触发执行鉴权逻辑的入口。具体的类的设计如下所示：</p><p><img src=\"https://static001.geekbang.org/resource/image/f4/ca/f408ac59caffde117716d11148d010ca.jpg\" alt=\"\"></p><h2>如何进行面向对象编程？</h2><p>面向对象设计完成之后，我们已经定义清晰了类、属性、方法、类之间的交互，并且将所有的类组装起来，提供了统一的执行入口。接下来，面向对象编程的工作，就是将这些设计思路翻译成代码实现。有了前面的类图，这部分工作相对来说就比较简单了。所以，这里我只给出比较复杂的ApiAuthenticator的实现。</p><p>对于AuthToken、ApiRequest、CredentialStorage这三个类，在这里我就不给出具体的代码实现了。给你留一个课后作业，你可以试着把整个鉴权框架自己去实现一遍。</p><pre><code>public interface ApiAuthenticator {\n  void auth(String url);\n  void auth(ApiRequest apiRequest);\n}\n\npublic class DefaultApiAuthenticatorImpl implements ApiAuthenticator {\n  private CredentialStorage credentialStorage;\n  \n  public DefaultApiAuthenticatorImpl() {\n    this.credentialStorage = new MysqlCredentialStorage();\n  }\n  \n  public DefaultApiAuthenticatorImpl(CredentialStorage credentialStorage) {\n    this.credentialStorage = credentialStorage;\n  }\n\n  @Override\n  public void auth(String url) {\n    ApiRequest apiRequest = ApiRequest.buildFromUrl(url);\n    auth(apiRequest);\n  }\n\n  @Override\n  public void auth(ApiRequest apiRequest) {\n    String appId = apiRequest.getAppId();\n    String token = apiRequest.getToken();\n    long timestamp = apiRequest.getTimestamp();\n    String originalUrl = apiRequest.getOriginalUrl();\n\n    AuthToken clientAuthToken = new AuthToken(token, timestamp);\n    if (clientAuthToken.isExpired()) {\n      throw new RuntimeException(&quot;Token is expired.&quot;);\n    }\n\n    String password = credentialStorage.getPasswordByAppId(appId);\n    AuthToken serverAuthToken = AuthToken.generate(originalUrl, appId, password, timestamp);\n    if (!serverAuthToken.match(clientAuthToken)) {\n      throw new RuntimeException(&quot;Token verfication failed.&quot;);\n    }\n  }\n}\n</code></pre><h2>辩证思考与灵活应用</h2><p>在之前的讲解中，面向对象分析、设计、实现，每个环节的界限划分都比较清楚。而且，设计和实现基本上是按照功能点的描述，逐句照着翻译过来的。这样做的好处是先做什么、后做什么，非常清晰、明确，有章可循，即便是没有太多设计经验的初级工程师，都可以按部就班地参照着这个流程来做分析、设计和实现。</p><p>不过，在平时的工作中，大部分程序员往往都是在脑子里或者草纸上完成面向对象分析和设计，然后就开始写代码了，边写边思考边重构，并不会严格地按照刚刚的流程来执行。而且，说实话，即便我们在写代码之前，花很多时间做分析和设计，绘制出完美的类图、UML图，也不可能把每个细节、交互都想得很清楚。在落实到代码的时候，我们还是要反复迭代、重构、打破重写。</p><p>毕竟，整个软件开发本来就是一个迭代、修修补补、遇到问题解决问题的过程，是一个不断重构的过程。我们没法严格地按照顺序执行各个步骤。这就类似你去学驾照，驾校教的都是比较正规的流程，先做什么，后做什么，你只要照着做就能顺利倒车入库，但实际上，等你开熟练了，倒车入库很多时候靠的都是经验和感觉。</p><h2>重点回顾</h2><p>今天的内容到此就讲完了。我们来一块总结回顾一下，你需要掌握的重点内容。</p><p>面向对象分析的产出是详细的需求描述。面向对象设计的产出是类。在面向对象设计这一环节中，我们将需求描述转化为具体的类的设计。这个环节的工作可以拆分为下面四个部分。</p><p><strong>1.划分职责进而识别出有哪些类</strong></p><p>根据需求描述，我们把其中涉及的功能点，一个一个罗列出来，然后再去看哪些功能点职责相近，操作同样的属性，可否归为同一个类。</p><p><strong>2.定义类及其属性和方法</strong></p><p>我们识别出需求描述中的动词，作为候选的方法，再进一步过滤筛选出真正的方法，把功能点中涉及的名词，作为候选属性，然后同样再进行过滤筛选。</p><p><strong>3.定义类与类之间的交互关系</strong></p><p>UML统一建模语言中定义了六种类之间的关系。它们分别是：泛化、实现、关联、聚合、组合、依赖。我们从更加贴近编程的角度，对类与类之间的关系做了调整，保留四个关系：泛化、实现、组合、依赖。</p><p><strong>4.将类组装起来并提供执行入口</strong></p><p>我们要将所有的类组装在一起，提供一个执行入口。这个入口可能是一个main()函数，也可能是一组给外部用的API接口。通过这个入口，我们能触发整个代码跑起来。</p><h2>课堂讨论</h2><p>软件设计的自由度很大，这也是软件的复杂之处。不同的人对类的划分、定义、类之间交互的设计，可能都不大一样。那除了我今天给出的设计思路，你还有没有其他设计思路呢？</p><p>欢迎在留言区写下你的答案，和同学一起交流和分享。如果有收获，也欢迎你把这篇文章分享给你的朋友。</p>",
                "article_title": "14 | 实战二（下）：如何利用面向对象设计和编程开发接口鉴权功能？"
            }
        ]
    },
    {
        "chapterTitle": "设计原则与思想：设计原则 (12讲)",
        "children": [
            {
                "title": "15 | 理论一：对于单一职责原则，如何判定某个类的职责是否够“单一”？",
                "herf": "https://time.geekbang.org/column/article/171771",
                "id": "171771",
                "content": "<p>上几节课中，我们介绍了面向对象相关的知识。从今天起，我们开始学习一些经典的设计原则，其中包括，SOLID、KISS、YAGNI、DRY、LOD等。</p><p>这些设计原则，从字面上理解，都不难。你一看就感觉懂了，一看就感觉掌握了，但真的用到项目中的时候，你会发现，“看懂”和“会用”是两回事，而“用好”更是难上加难。从我之前的工作经历来看，很多同事因为对这些原则理解得不够透彻，导致在使用的时候过于教条主义，拿原则当真理，生搬硬套，适得其反。</p><p>所以，在接下来的讲解中，我不仅会讲解这些原则的定义，还会解释这些原则设计的初衷，能解决哪些问题，有哪些应用场景等，让你知其然知其所以然。在学习的时候，希望你能跟上我的思路，把握住重点，真正做到活学活用。</p><h2>如何理解单一职责原则（SRP）？</h2><p>文章的开头我们提到了SOLID原则，实际上，SOLID原则并非单纯的1个原则，而是由5个设计原则组成的，它们分别是：单一职责原则、开闭原则、里式替换原则、接口隔离原则和依赖反转原则，依次对应SOLID中的S、O、L、I、D这5个英文字母。我们今天要学习的是SOLID原则中的第一个原则：单一职责原则。</p><p>单一职责原则的英文是Single Responsibility Principle，缩写为SRP。这个原则的英文描述是这样的：A class or module should have a single responsibility。如果我们把它翻译成中文，那就是：一个类或者模块只负责完成一个职责（或者功能）。</p><!-- [[[read_end]]] --><p>注意，这个原则描述的对象包含两个，一个是类（class），一个是模块（module）。关于这两个概念，在专栏中，有两种理解方式。一种理解是：把模块看作比类更加抽象的概念，类也可以看作模块。另一种理解是：把模块看作比类更加粗粒度的代码块，模块中包含多个类，多个类组成一个模块。</p><p>不管哪种理解方式，单一职责原则在应用到这两个描述对象的时候，道理都是相通的。为了方便你理解，接下来我只从“类”设计的角度，来讲解如何应用这个设计原则。对于“模块”来说，你可以自行引申。</p><p>单一职责原则的定义描述非常简单，也不难理解。一个类只负责完成一个职责或者功能。也就是说，不要设计大而全的类，要设计粒度小、功能单一的类。换个角度来讲就是，一个类包含了两个或者两个以上业务不相干的功能，那我们就说它职责不够单一，应该将它拆分成多个功能更加单一、粒度更细的类。</p><p>我举一个例子来解释一下。比如，一个类里既包含订单的一些操作，又包含用户的一些操作。而订单和用户是两个独立的业务领域模型，我们将两个不相干的功能放到同一个类中，那就违反了单一职责原则。为了满足单一职责原则，我们需要将这个类拆分成两个粒度更细、功能更加单一的两个类：订单类和用户类。</p><h2>如何判断类的职责是否足够单一？</h2><p>从刚刚这个例子来看，单一职责原则看似不难应用。那是因为我举的这个例子比较极端，一眼就能看出订单和用户毫不相干。但大部分情况下，类里的方法是归为同一类功能，还是归为不相关的两类功能，并不是那么容易判定的。在真实的软件开发中，对于一个类是否职责单一的判定，是很难拿捏的。我举一个更加贴近实际的例子来给你解释一下。</p><p>在一个社交产品中，我们用下面的UserInfo类来记录用户的信息。你觉得，UserInfo类的设计是否满足单一职责原则呢？</p><pre><code>public class UserInfo {\n  private long userId;\n  private String username;\n  private String email;\n  private String telephone;\n  private long createTime;\n  private long lastLoginTime;\n  private String avatarUrl;\n  private String provinceOfAddress; // 省\n  private String cityOfAddress; // 市\n  private String regionOfAddress; // 区 \n  private String detailedAddress; // 详细地址\n  // ...省略其他属性和方法...\n}\n</code></pre><p>对于这个问题，有两种不同的观点。一种观点是，UserInfo类包含的都是跟用户相关的信息，所有的属性和方法都隶属于用户这样一个业务模型，满足单一职责原则；另一种观点是，地址信息在UserInfo类中，所占的比重比较高，可以继续拆分成独立的UserAddress类，UserInfo只保留除Address之外的其他信息，拆分之后的两个类的职责更加单一。</p><p>哪种观点更对呢？实际上，要从中做出选择，我们不能脱离具体的应用场景。如果在这个社交产品中，用户的地址信息跟其他信息一样，只是单纯地用来展示，那UserInfo现在的设计就是合理的。但是，如果这个社交产品发展得比较好，之后又在产品中添加了电商的模块，用户的地址信息还会用在电商物流中，那我们最好将地址信息从UserInfo中拆分出来，独立成用户物流信息（或者叫地址信息、收货信息等）。</p><p>我们再进一步延伸一下。如果做这个社交产品的公司发展得越来越好，公司内部又开发出了很多其他产品（可以理解为其他App）。公司希望支持统一账号系统，也就是用户一个账号可以在公司内部的所有产品中登录。这个时候，我们就需要继续对UserInfo进行拆分，将跟身份认证相关的信息（比如，email、telephone等）抽取成独立的类。</p><p>从刚刚这个例子，我们可以总结出，不同的应用场景、不同阶段的需求背景下，对同一个类的职责是否单一的判定，可能都是不一样的。在某种应用场景或者当下的需求背景下，一个类的设计可能已经满足单一职责原则了，但如果换个应用场景或着在未来的某个需求背景下，可能就不满足了，需要继续拆分成粒度更细的类。</p><p>除此之外，从不同的业务层面去看待同一个类的设计，对类是否职责单一，也会有不同的认识。比如，例子中的UserInfo类。如果我们从“用户”这个业务层面来看，UserInfo包含的信息都属于用户，满足职责单一原则。如果我们从更加细分的“用户展示信息”“地址信息”“登录认证信息”等等这些更细粒度的业务层面来看，那UserInfo就应该继续拆分。</p><p>综上所述，评价一个类的职责是否足够单一，我们并没有一个非常明确的、可以量化的标准，可以说，这是件非常主观、仁者见仁智者见智的事情。实际上，在真正的软件开发中，我们也没必要过于未雨绸缪，过度设计。所以，<strong>我们可以先写一个粗粒度的类，满足业务需求。随着业务的发展，如果粗粒度的类越来越庞大，代码越来越多，这个时候，我们就可以将这个粗粒度的类，拆分成几个更细粒度的类。这就是所谓的持续重构</strong>（后面的章节中我们会讲到）。</p><p>听到这里，你可能会说，这个原则如此含糊不清、模棱两可，到底该如何拿捏才好啊？我这里还有一些小技巧，能够很好地帮你，从侧面上判定一个类的职责是否够单一。而且，我个人觉得，下面这几条判断原则，比起很主观地去思考类是否职责单一，要更有指导意义、更具有可执行性：</p><ul>\n<li>类中的代码行数、函数或属性过多，会影响代码的可读性和可维护性，我们就需要考虑对类进行拆分；</li>\n<li>类依赖的其他类过多，或者依赖类的其他类过多，不符合高内聚、低耦合的设计思想，我们就需要考虑对类进行拆分；</li>\n<li>私有方法过多，我们就要考虑能否将私有方法独立到新的类中，设置为public方法，供更多的类使用，从而提高代码的复用性；</li>\n<li>比较难给类起一个合适名字，很难用一个业务名词概括，或者只能用一些笼统的Manager、Context之类的词语来命名，这就说明类的职责定义得可能不够清晰；</li>\n<li>类中大量的方法都是集中操作类中的某几个属性，比如，在UserInfo例子中，如果一半的方法都是在操作address信息，那就可以考虑将这几个属性和对应的方法拆分出来。</li>\n</ul><p>不过，你可能还会有这样的疑问：在上面的判定原则中，我提到类中的代码行数、函数或者属性过多，就有可能不满足单一职责原则。那多少行代码才算是行数过多呢？多少个函数、属性才称得上过多呢？</p><p>比较初级的工程师经常会问这类问题。实际上，这个问题并不好定量地回答，就像你问大厨“放盐少许”中的“少许”是多少，大厨也很难告诉你一个特别具体的量值。</p><p>如果继续深究一下的话，你可能还会说，一些菜谱确实给出了，做某某菜需要放多少克盐，放多少克油的具体量值啊。我想说的是，那是给家庭主妇用的，那不是给专业的大厨看的。类比一下做饭，如果你是没有太多项目经验的编程初学者，实际上，我也可以给你一个凑活能用、比较宽泛的、可量化的标准，那就是一个类的代码行数最好不能超过200行，函数个数及属性个数都最好不要超过10个。</p><p>实际上， 从另一个角度来看，当一个类的代码，读起来让你头大了，实现某个功能时不知道该用哪个函数了，想用哪个函数翻半天都找不到了，只用到一个小功能要引入整个类（类中包含很多无关此功能实现的函数）的时候，这就说明类的行数、函数、属性过多了。实际上，等你做多项目了，代码写多了，在开发中慢慢“品尝”，自然就知道什么是“放盐少许”了，这就是所谓的“专业第六感”。</p><h2>类的职责是否设计得越单一越好？</h2><p>为了满足单一职责原则，是不是把类拆得越细就越好呢？答案是否定的。我们还是通过一个例子来解释一下。Serialization类实现了一个简单协议的序列化和反序列功能，具体代码如下：</p><pre><code>/**\n * Protocol format: identifier-string;{gson string}\n * For example: UEUEUE;{&quot;a&quot;:&quot;A&quot;,&quot;b&quot;:&quot;B&quot;}\n */\npublic class Serialization {\n  private static final String IDENTIFIER_STRING = &quot;UEUEUE;&quot;;\n  private Gson gson;\n  \n  public Serialization() {\n    this.gson = new Gson();\n  }\n  \n  public String serialize(Map&lt;String, String&gt; object) {\n    StringBuilder textBuilder = new StringBuilder();\n    textBuilder.append(IDENTIFIER_STRING);\n    textBuilder.append(gson.toJson(object));\n    return textBuilder.toString();\n  }\n  \n  public Map&lt;String, String&gt; deserialize(String text) {\n    if (!text.startsWith(IDENTIFIER_STRING)) {\n        return Collections.emptyMap();\n    }\n    String gsonStr = text.substring(IDENTIFIER_STRING.length());\n    return gson.fromJson(gsonStr, Map.class);\n  }\n}\n</code></pre><p>如果我们想让类的职责更加单一，我们对Serialization类进一步拆分，拆分成一个只负责序列化工作的Serializer类和另一个只负责反序列化工作的Deserializer类。拆分后的具体代码如下所示：</p><pre><code>public class Serializer {\n  private static final String IDENTIFIER_STRING = &quot;UEUEUE;&quot;;\n  private Gson gson;\n  \n  public Serializer() {\n    this.gson = new Gson();\n  }\n  \n  public String serialize(Map&lt;String, String&gt; object) {\n    StringBuilder textBuilder = new StringBuilder();\n    textBuilder.append(IDENTIFIER_STRING);\n    textBuilder.append(gson.toJson(object));\n    return textBuilder.toString();\n  }\n}\n\npublic class Deserializer {\n  private static final String IDENTIFIER_STRING = &quot;UEUEUE;&quot;;\n  private Gson gson;\n  \n  public Deserializer() {\n    this.gson = new Gson();\n  }\n  \n  public Map&lt;String, String&gt; deserialize(String text) {\n    if (!text.startsWith(IDENTIFIER_STRING)) {\n        return Collections.emptyMap();\n    }\n    String gsonStr = text.substring(IDENTIFIER_STRING.length());\n    return gson.fromJson(gsonStr, Map.class);\n  }\n}\n</code></pre><p>虽然经过拆分之后，Serializer类和Deserializer类的职责更加单一了，但也随之带来了新的问题。如果我们修改了协议的格式，数据标识从“UEUEUE”改为“DFDFDF”，或者序列化方式从JSON改为了XML，那Serializer类和Deserializer类都需要做相应的修改，代码的内聚性显然没有原来Serialization高了。而且，如果我们仅仅对Serializer类做了协议修改，而忘记了修改Deserializer类的代码，那就会导致序列化、反序列化不匹配，程序运行出错，也就是说，拆分之后，代码的可维护性变差了。</p><p>实际上，不管是应用设计原则还是设计模式，最终的目的还是提高代码的可读性、可扩展性、复用性、可维护性等。我们在考虑应用某一个设计原则是否合理的时候，也可以以此作为最终的考量标准。</p><h2>重点回顾</h2><p>今天的内容到此就讲完了。我们来一块总结回顾一下，你应该掌握的重点内容。</p><p><strong>1.如何理解单一职责原则（SRP）？</strong></p><p>一个类只负责完成一个职责或者功能。不要设计大而全的类，要设计粒度小、功能单一的类。单一职责原则是为了实现代码高内聚、低耦合，提高代码的复用性、可读性、可维护性。</p><p><strong>2.如何判断类的职责是否足够单一？</strong></p><p>不同的应用场景、不同阶段的需求背景、不同的业务层面，对同一个类的职责是否单一，可能会有不同的判定结果。实际上，一些侧面的判断指标更具有指导意义和可执行性，比如，出现下面这些情况就有可能说明这类的设计不满足单一职责原则：</p><ul>\n<li>类中的代码行数、函数或者属性过多；</li>\n<li>类依赖的其他类过多，或者依赖类的其他类过多；</li>\n<li>私有方法过多；</li>\n<li>比较难给类起一个合适的名字；</li>\n<li>类中大量的方法都是集中操作类中的某几个属性。</li>\n</ul><p><strong>3.类的职责是否设计得越单一越好？</strong></p><p>单一职责原则通过避免设计大而全的类，避免将不相关的功能耦合在一起，来提高类的内聚性。同时，类职责单一，类依赖的和被依赖的其他类也会变少，减少了代码的耦合性，以此来实现代码的高内聚、低耦合。但是，如果拆分得过细，实际上会适得其反，反倒会降低内聚性，也会影响代码的可维护性。</p><h2>课堂讨论</h2><p>今天课堂讨论的话题有两个：</p><ol>\n<li>对于如何判断一个类是否职责单一，如何判断代码行数过多，你还有哪些其他的方法吗？</li>\n<li>单一职责原则，除了应用到类的设计上，还能延伸到哪些其他设计方面吗？</li>\n</ol><p>欢迎在留言区写下你的答案，和同学一起交流和分享。如果有收获，也欢迎你把这篇文章分享给你的朋友。</p>",
                "article_title": "15 | 理论一：对于单一职责原则，如何判定某个类的职责是否够“单一”？"
            },
            {
                "title": "16 | 理论二：如何做到“对扩展开放、修改关闭”？扩展和修改各指什么？",
                "herf": "https://time.geekbang.org/column/article/176075",
                "id": "176075",
                "content": "<p>在上一节课中，我们学习了单一职责原则。今天，我们来学习SOLID中的第二个原则：开闭原则。我个人觉得，开闭原则是SOLID中最难理解、最难掌握，同时也是最有用的一条原则。</p><p>之所以说这条原则难理解，那是因为，“怎样的代码改动才被定义为‘扩展’？怎样的代码改动才被定义为‘修改’？怎么才算满足或违反‘开闭原则’？修改代码就一定意味着违反‘开闭原则’吗？”等等这些问题，都比较难理解。</p><p>之所以说这条原则难掌握，那是因为，“如何做到‘对扩展开放、修改关闭’？如何在项目中灵活地应用‘开闭原则’，以避免在追求扩展性的同时影响到代码的可读性？”等等这些问题，都比较难掌握。</p><p>之所以说这条原则最有用，那是因为，扩展性是代码质量最重要的衡量标准之一。在23种经典设计模式中，大部分设计模式都是为了解决代码的扩展性问题而存在的，主要遵从的设计原则就是开闭原则。</p><p>所以说，今天的内容非常重要，希望你能集中精力，跟上我的思路，将开闭原则理解透彻，这样才能更好地理解后面章节的内容。话不多说，让我们正式开始今天的学习吧！</p><h2>如何理解“对扩展开放、修改关闭”？</h2><p>开闭原则的英文全称是Open Closed Principle，简写为OCP。它的英文描述是：software entities (modules, classes, functions, etc.) should be open for extension , but closed for modification。我们把它翻译成中文就是：软件实体（模块、类、方法等）应该“对扩展开放、对修改关闭”。</p><!-- [[[read_end]]] --><p>这个描述比较简略，如果我们详细表述一下，那就是，添加一个新的功能应该是，在已有代码基础上扩展代码（新增模块、类、方法等），而非修改已有代码（修改模块、类、方法等）。</p><p>为了让你更好地理解这个原则，我举一个例子来进一步解释一下。这是一段API接口监控告警的代码。</p><p>其中，AlertRule存储告警规则，可以自由设置。Notification是告警通知类，支持邮件、短信、微信、手机等多种通知渠道。NotificationEmergencyLevel表示通知的紧急程度，包括SEVERE（严重）、URGENCY（紧急）、NORMAL（普通）、TRIVIAL（无关紧要），不同的紧急程度对应不同的发送渠道。关于API接口监控告警这部分，更加详细的业务需求分析和设计，我们会在后面的设计模式模块再拿出来进一步讲解，这里你只要简单知道这些，就够我们今天用了。</p><pre><code>public class Alert {\n  private AlertRule rule;\n  private Notification notification;\n\n  public Alert(AlertRule rule, Notification notification) {\n    this.rule = rule;\n    this.notification = notification;\n  }\n\n  public void check(String api, long requestCount, long errorCount, long durationOfSeconds) {\n    long tps = requestCount / durationOfSeconds;\n    if (tps &gt; rule.getMatchedRule(api).getMaxTps()) {\n      notification.notify(NotificationEmergencyLevel.URGENCY, &quot;...&quot;);\n    }\n    if (errorCount &gt; rule.getMatchedRule(api).getMaxErrorCount()) {\n      notification.notify(NotificationEmergencyLevel.SEVERE, &quot;...&quot;);\n    }\n  }\n}\n</code></pre><p>上面这段代码非常简单，业务逻辑主要集中在check()函数中。当接口的TPS超过某个预先设置的最大值时，以及当接口请求出错数大于某个最大允许值时，就会触发告警，通知接口的相关负责人或者团队。</p><p>现在，如果我们需要添加一个功能，当每秒钟接口超时请求个数，超过某个预先设置的最大阈值时，我们也要触发告警发送通知。这个时候，我们该如何改动代码呢？主要的改动有两处：第一处是修改check()函数的入参，添加一个新的统计数据timeoutCount，表示超时接口请求数；第二处是在check()函数中添加新的告警逻辑。具体的代码改动如下所示：</p><pre><code>public class Alert {\n  // ...省略AlertRule/Notification属性和构造函数...\n  \n  // 改动一：添加参数timeoutCount\n  public void check(String api, long requestCount, long errorCount, long timeoutCount, long durationOfSeconds) {\n    long tps = requestCount / durationOfSeconds;\n    if (tps &gt; rule.getMatchedRule(api).getMaxTps()) {\n      notification.notify(NotificationEmergencyLevel.URGENCY, &quot;...&quot;);\n    }\n    if (errorCount &gt; rule.getMatchedRule(api).getMaxErrorCount()) {\n      notification.notify(NotificationEmergencyLevel.SEVERE, &quot;...&quot;);\n    }\n    // 改动二：添加接口超时处理逻辑\n    long timeoutTps = timeoutCount / durationOfSeconds;\n    if (timeoutTps &gt; rule.getMatchedRule(api).getMaxTimeoutTps()) {\n      notification.notify(NotificationEmergencyLevel.URGENCY, &quot;...&quot;);\n    }\n  }\n}\n</code></pre><p>这样的代码修改实际上存在挺多问题的。一方面，我们对接口进行了修改，这就意味着调用这个接口的代码都要做相应的修改。另一方面，修改了check()函数，相应的单元测试都需要修改（关于单元测试的内容我们在重构那部分会详细介绍）。</p><p>上面的代码改动是基于“修改”的方式来实现新功能的。如果我们遵循开闭原则，也就是“对扩展开放、对修改关闭”。那如何通过“扩展”的方式，来实现同样的功能呢？</p><p>我们先重构一下之前的Alert代码，让它的扩展性更好一些。重构的内容主要包含两部分：</p><ul>\n<li>第一部分是将check()函数的多个入参封装成ApiStatInfo类；</li>\n<li>第二部分是引入handler的概念，将if判断逻辑分散在各个handler中。</li>\n</ul><p>具体的代码实现如下所示：</p><pre><code>public class Alert {\n  private List&lt;AlertHandler&gt; alertHandlers = new ArrayList&lt;&gt;();\n  \n  public void addAlertHandler(AlertHandler alertHandler) {\n    this.alertHandlers.add(alertHandler);\n  }\n\n  public void check(ApiStatInfo apiStatInfo) {\n    for (AlertHandler handler : alertHandlers) {\n      handler.check(apiStatInfo);\n    }\n  }\n}\n\npublic class ApiStatInfo {//省略constructor/getter/setter方法\n  private String api;\n  private long requestCount;\n  private long errorCount;\n  private long durationOfSeconds;\n}\n\npublic abstract class AlertHandler {\n  protected AlertRule rule;\n  protected Notification notification;\n  public AlertHandler(AlertRule rule, Notification notification) {\n    this.rule = rule;\n    this.notification = notification;\n  }\n  public abstract void check(ApiStatInfo apiStatInfo);\n}\n\npublic class TpsAlertHandler extends AlertHandler {\n  public TpsAlertHandler(AlertRule rule, Notification notification) {\n    super(rule, notification);\n  }\n\n  @Override\n  public void check(ApiStatInfo apiStatInfo) {\n    long tps = apiStatInfo.getRequestCount()/ apiStatInfo.getDurationOfSeconds();\n    if (tps &gt; rule.getMatchedRule(apiStatInfo.getApi()).getMaxTps()) {\n      notification.notify(NotificationEmergencyLevel.URGENCY, &quot;...&quot;);\n    }\n  }\n}\n\npublic class ErrorAlertHandler extends AlertHandler {\n  public ErrorAlertHandler(AlertRule rule, Notification notification){\n    super(rule, notification);\n  }\n\n  @Override\n  public void check(ApiStatInfo apiStatInfo) {\n    if (apiStatInfo.getErrorCount() &gt; rule.getMatchedRule(apiStatInfo.getApi()).getMaxErrorCount()) {\n      notification.notify(NotificationEmergencyLevel.SEVERE, &quot;...&quot;);\n    }\n  }\n}\n</code></pre><p>上面的代码是对Alert的重构，我们再来看下，重构之后的Alert该如何使用呢？具体的使用代码我也写在这里了。</p><p>其中，ApplicationContext是一个单例类，负责Alert的创建、组装（alertRule和notification的依赖注入）、初始化（添加handlers）工作。</p><pre><code>public class ApplicationContext {\n  private AlertRule alertRule;\n  private Notification notification;\n  private Alert alert;\n  \n  public void initializeBeans() {\n    alertRule = new AlertRule(/*.省略参数.*/); //省略一些初始化代码\n    notification = new Notification(/*.省略参数.*/); //省略一些初始化代码\n    alert = new Alert();\n    alert.addAlertHandler(new TpsAlertHandler(alertRule, notification));\n    alert.addAlertHandler(new ErrorAlertHandler(alertRule, notification));\n  }\n  public Alert getAlert() { return alert; }\n\n  // 饿汉式单例\n  private static final ApplicationContext instance = new ApplicationContext();\n  private ApplicationContext() {\n    initializeBeans();\n  }\n  public static ApplicationContext getInstance() {\n    return instance;\n  }\n}\n\npublic class Demo {\n  public static void main(String[] args) {\n    ApiStatInfo apiStatInfo = new ApiStatInfo();\n    // ...省略设置apiStatInfo数据值的代码\n    ApplicationContext.getInstance().getAlert().check(apiStatInfo);\n  }\n}\n</code></pre><p>现在，我们再来看下，基于重构之后的代码，如果再添加上面讲到的那个新功能，每秒钟接口超时请求个数超过某个最大阈值就告警，我们又该如何改动代码呢？主要的改动有\b下面四处。</p><ul>\n<li>第一处改动是：在ApiStatInfo类中添加新的属性timeoutCount。</li>\n<li>第二处改动是：添加新的TimeoutAlertHander类。</li>\n<li>第三处改动是：在ApplicationContext类的initializeBeans()方法中，往alert对象中注册新的timeoutAlertHandler。</li>\n<li>第四处改动是：在使用Alert类的时候，需要给check()函数的入参apiStatInfo对象设置timeoutCount的值。</li>\n</ul><p>改动之后的代码如下所示：</p><pre><code>public class Alert { // 代码未改动... }\npublic class ApiStatInfo {//省略constructor/getter/setter方法\n  private String api;\n  private long requestCount;\n  private long errorCount;\n  private long durationOfSeconds;\n  private long timeoutCount; // 改动一：添加新字段\n}\npublic abstract class AlertHandler { //代码未改动... }\npublic class TpsAlertHandler extends AlertHandler {//代码未改动...}\npublic class ErrorAlertHandler extends AlertHandler {//代码未改动...}\n// 改动二：添加新的handler\npublic class TimeoutAlertHandler extends AlertHandler {//省略代码...}\n\npublic class ApplicationContext {\n  private AlertRule alertRule;\n  private Notification notification;\n  private Alert alert;\n  \n  public void initializeBeans() {\n    alertRule = new AlertRule(/*.省略参数.*/); //省略一些初始化代码\n    notification = new Notification(/*.省略参数.*/); //省略一些初始化代码\n    alert = new Alert();\n    alert.addAlertHandler(new TpsAlertHandler(alertRule, notification));\n    alert.addAlertHandler(new ErrorAlertHandler(alertRule, notification));\n    // 改动三：注册handler\n    alert.addAlertHandler(new TimeoutAlertHandler(alertRule, notification));\n  }\n  //...省略其他未改动代码...\n}\n\npublic class Demo {\n  public static void main(String[] args) {\n    ApiStatInfo apiStatInfo = new ApiStatInfo();\n    // ...省略apiStatInfo的set字段代码\n    apiStatInfo.setTimeoutCount(289); // 改动四：设置tiemoutCount值\n    ApplicationContext.getInstance().getAlert().check(apiStatInfo);\n}\n</code></pre><p>重构之后的代码更加灵活和易扩展。如果我们要想添加新的告警逻辑，只需要基于扩展的方式创建新的handler类即可，不需要改动原来的check()函数的逻辑。而且，我们只需要为新的handler类添加单元测试，老的单元测试都不会失败，也不用修改。</p><h2>修改代码就意味着违背开闭原则吗？</h2><p>看了上面重构之后的代码，你可能还会有疑问：在添加新的告警逻辑的时候，尽管改动二（添加新的handler类）是基于扩展而非修改的方式来完成的，但改动一、三、四貌似不是基于扩展而是基于修改的方式来完成的，那改动一、三、四不就违背了开闭原则吗？</p><p><strong>我们先来分析一下改动一：往ApiStatInfo类中添加新的属性timeoutCount。</strong></p><p>实际上，我们不仅往ApiStatInfo类中添加了属性，还添加了对应的getter/setter方法。那这个问题就转化为：给类中添加新的属性和方法，算作“修改”还是“扩展”？</p><p>我们再一块回忆一下开闭原则的定义：软件实体（模块、类、方法等）应该“对扩展开放、对修改关闭”。从定义中，我们可以看出，开闭原则可以应用在不同粒度的代码中，可以是模块，也可以类，还可以是方法（及其属性）。同样一个代码改动，在粗代码粒度下，被认定为“修改”，在细代码粒度下，又可以被认定为“扩展”。比如，改动一，添加属性和方法相当于修改类，在类这个层面，这个代码改动可以被认定为“修改”；但这个代码改动并没有修改已有的属性和方法，在方法（及其属性）这一层面，它又可以被认定为“扩展”。</p><p>实际上，我们也没必要纠结某个代码改动是“修改”还是“扩展”，更没必要太纠结它是否违反“开闭原则”。我们回到这条原则的设计初衷：只要它没有破坏原有的代码的正常运行，没有破坏原有的单元测试，我们就可以说，这是一个合格的代码改动。</p><p><strong>我们再来分析一下改动三和改动四：在ApplicationContext类的initializeBeans()方法中，往alert对象中注册新的timeoutAlertHandler；在使用Alert类的时候，需要给check()函数的入参apiStatInfo对象设置timeoutCount的值。</strong></p><p>这两处改动都是在方法内部进行的，不管从哪个层面（模块、类、方法）来讲，都不能算是“扩展”，而是地地道道的“修改”。不过，有些修改是在所难免的，是可以被接受的。为什么这么说呢？我来解释一下。</p><p>在重构之后的Alert代码中，我们的核心逻辑集中在Alert类及其各个handler中，当我们在添加新的告警逻辑的时候，Alert类完全不需要修改，而只需要扩展一个新handler类。如果我们把Alert类及各个handler类合起来看作一个“模块”，那模块本身在添加新的功能的时候，完全满足开闭原则。</p><p>而且，我们要认识到，添加一个新功能，不可能任何模块、类、方法的代码都不“修改”，这个是做不到的。类需要创建、组装、并且做一些初始化操作，才能构建成可运行的的程序，这部分代码的修改是在所难免的。我们要做的是尽量让修改操作更集中、更少、更上层，尽量让最核心、最复杂的那部分逻辑代码满足开闭原则。</p><h2>如何做到“对扩展开放、修改关闭”？</h2><p>在刚刚的例子中，我们通过引入一组handler的方式来实现支持开闭原则。如果你没有太多复杂代码的设计和开发经验，你可能会有这样的疑问：这样的代码设计思路我\b怎么想不到呢？你是怎么想到的呢？</p><p>先给你个结论，\b之所以我能想到，靠的就是理论知识和实战经验，这些需要你慢慢学习和积累。对于如何做到“对扩展开放、修改关闭”，我们也有一些指导思想和具体的方法论，我们一块来看一下。</p><p>实际上，开闭原则讲的就是代码的扩展性问题，是判断一段代码是否易扩展的“金标准”。如果某段代码在应对未来需求变化的时候，能够做到“对扩展开放、对修改关闭”，那就说明这段代码的扩展性比较好。所以，问如何才能做到“对扩展开放、对修改关闭”，也就粗略地等同于在问，如何才能写出扩展性好的代码。</p><p><strong>在讲具体的方法论之前，我们先来看一些更加偏向顶层的指导思想。为了尽量写出扩展性好的代码，我们要时刻具备扩展意识、抽象意识、封装意识。这些“潜意识”可能比任何开发技巧都重要。</strong></p><p>在写代码的时候后，我们要多花点时间往前多思考一下，这段代码未来可能有哪些需求变更、如何设计代码结构，事先留好扩展点，以便在未来需求变更的时候，不需要改动代码整体结构、做到最小代码改动的情况下，新的代码能够很灵活地插入到扩展点上，做到“对扩展开放、对修改关闭”。</p><p>还有，在识别出代码可变部分和不可变部分之后，我们要将可变部分封装起来，隔离变化，提供抽象化的不可变接口，给上层系统使用。当具体的实现发生变化的时候，我们只需要基于相同的抽象接口，扩展一个新的实现，替换掉老的实现即可，上游系统的代码几乎不需要修改。</p><p><strong>刚刚我们讲了实现开闭原则的一些偏向顶层的指导思想，现在我们再来看下，支持开闭原则的一些更加具体的方法论。</strong></p><p>我们前面讲到，代码的扩展性是代码质量评判的最重要的标准之一。实际上，我们整个专栏的大部分知识点都是围绕扩展性问题来讲解的。专栏中讲到的很多设计原则、设计思想、设计模式，都是以提高代码的扩展性为最终目的的。特别是23种经典设计模式，大部分都是为了解决代码的扩展性问题而总结出来的，都是以开闭原则为指导原则的。</p><p>在众多的设计原则、思想、模式中，最常用来提高代码扩展性的方法有：多态、依赖注入、基于接口而非实现编程，以及大部分的设计模式（比如，装饰、策略、模板、职责链、状态等）。设计模式这一部分内容比较多，后面课程中我们能会详细讲到，这里就不展开了。今天我重点讲一下，如何利用多态、依赖注入、基于接口而非实现编程，来实现“对扩展开放、对修改关闭”。</p><p>实际上，多态、依赖注入、基于接口而非实现编程，以及前面提到的抽象意识，说的都是同一种设计思路，只是从不同的角度、不同的层面来阐述而已。这也体现了“很多设计原则、思想、模式都是相通的”这一思想。</p><p>接下来，我就通过一个例子来解释一下，如何利用这几个设计思想或原则来实现“对扩展开放、对修改关闭”。注意，依赖注入后面会讲到，如果你对这块不了解，可以暂时先忽略这个概念，只关注多态、基于接口而非实现编程以及抽象意识。</p><p>比如，我们代码中通过Kafka来发送异步消息。对于这样一个功能的开发，我们要学会将其抽象成一组跟具体消息队列（Kafka）无关的异步消息接口。\b所有上层系统都依赖这组抽象的接口编程，并且通过依赖注入的方式来调用。当我们要替换新的消息队列的时候，比如将Kafka替换成RocketMQ，可以很方便地拔掉老的消息队列实现，插入新的消息队列实现。具体代码如下所示：</p><pre><code>// 这一部分体现了抽象意识\npublic interface MessageQueue { //... }\npublic class KafkaMessageQueue implements MessageQueue { //... }\npublic class RocketMQMessageQueue implements MessageQueue {//...}\n\npublic interface MessageFromatter { //... }\npublic class JsonMessageFromatter implements MessageFromatter {//...}\npublic class ProtoBufMessageFromatter implements MessageFromatter {//...}\n\npublic class Demo {\n  private MessageQueue msgQueue; // 基于接口而非实现编程\n  public Demo(MessageQueue msgQueue) { // 依赖注入\n    this.msgQueue = msgQueue;\n  }\n  \n  // msgFormatter：多态、依赖注入\n  public void sendNotification(Notification notification, MessageFormatter msgFormatter) {\n    //...    \n  }\n}\n</code></pre><p>对于如何写出扩展性好的代码、如何实现“对扩展开放、对修改关闭”这个问题，我今天\b只是比较笼统地总结了一下，详细的知识我们在后面的章节中慢慢学习。</p><h2>如何在项目中灵活应用开闭原则？</h2><p>前面我们提到，写出支持“对扩展开放、对修改关闭”的代码的关键是预留扩展点。那问题是如何才能识别出所有可能的扩展点呢？</p><p>如果你开发的是一个业务导向的系统，比如金融系统、电商系统、物流系统等，要想识别出尽可能多的扩展点，就要对业务有足够的了解，能够知道当下以及未来可能要支持的业务需求。如果你开发的是跟业务无关的、通用的、偏底层的系统，比如，框架、组件、类库，你需要了解“它们会被如何使用？今后你打算添加哪些功能？使用者未来会有哪些更多的功能需求？”等问题。</p><p>不过，有一句话说得好，“唯一不变的只有变化本身”。即便我们对业务、对系统有足够的了解，那也不可能识别出所有的扩展点，即便你能识别出所有的扩展点，为这些地方都预留扩展点，这样做的成本也是不可接受的。我们没必要为一些遥远的、不一定发生的需求去提前买单，做过度设计。</p><p>最合理的做法是，对于一些比较确定的、短期内可能就会扩展，或者需求改动对代码结构影响比较大的情况，或者实现成本不高的扩展点，在编写代码的时候之后，我们就可以事先做些扩展性设计。但对于一些不确定未来是否要支持的需求，或者实现起来比较复杂的扩展点，我们可以等到有需求驱动的时候，再通过重构代码的方式来支持扩展的需求。</p><p>而且，开闭原则也并不是免费的。有些情况下，代码的扩展性会跟可读性相冲突。比如，我们之前举的Alert告警的例子。为了更好地支持扩展性，我们对代码进行了重构，重构之后的代码要比之前的代码复杂很多，理解起来也更加有难度。很多时候，我们都需要在扩展性和可读性之间做权衡。在某些场景下，代码的扩展性很重要，我们就可以适当地牺牲一些代码的可读性；在另一些场景下，代码的可读性更加重要，那我们就适当地牺牲一些代码的可扩展性。</p><p>在我们之前举的Alert告警的例子中，如果告警规则并不是很多、也不复杂，那check()函数中的if语句就不会很多，代码逻辑也不复杂，代码行数也不多，那最初的第一种代码实现思路简单易读，就是比较合理的选择。相反，如果告警规则很多、很复杂，check()函数的if语句、代码逻辑就会很多、很复杂，相应的代码行数也会很多，可读性、可维护性就会变差，那重构之后的第二种代码实现思路就是更加合理的选择了。总之，这里没有一个放之四海而皆准的参考标准，全凭实际的应用场景来决定。</p><h2>重点回顾</h2><p>今天的内容到此就讲完了。我们一块来总结回顾一下，你需要掌握的的重点内容。</p><p><strong>1.如何理解“对扩展开放、对修改关闭”？</strong></p><p>添加一个新的功能，应该是通过在已有代码基础上扩展代码（新增模块、类、方法、属性等），而非修改已有代码（修改模块、类、方法、属性等）的方式来完成。关于定义，我们有两点要注意。第一点是，开闭原则并不是说完全杜绝修改，而是以最小的修改代码的代价来完成新功能的开发。第二点是，同样的代码改动，在粗代码粒度下，可能被认定为“修改”；在细代码粒度下，可能又被认定为“扩展”。</p><p><strong>2.如何做到“对扩展开放、修改关闭”？</strong></p><p>我们要时刻具备扩展意识、抽象意识、封装意识。在写代码的时候，我们要多花点时间思考一下，这段代码未来可能有哪些需求变更，如何设计代码结构，事先留好扩展点，以便在未来需求变更的时候，在不改动代码整体结构、做到最小代码改动的情况下，将新的代码灵活地插入到扩展点上。</p><p>很多设计原则、设计思想、设计模式，都是以提高代码的扩展性为最终目的的。特别是23种经典设计模式，大部分都是为了解决代码的扩展性问题而总结出来的，都是以开闭原则为指导原则的。最常用来提高代码扩展性的方法有：多态、依赖注入、基于接口而非实现编程，以及大部分的设计模式（比如，装饰、策略、模板、职责链、状态）。</p><h2>课堂讨论</h2><p>学习设计原则，要多问个为什么。不能把设计原则当真理，而是要理解设计原则背后的思想。搞清楚这个，比单纯理解原则讲的是啥，更能让你灵活应用原则。所以，今天课堂讨论的话题是，为什么我们要“对扩展开放、对修改关闭”？</p><p>欢迎在留言区写下你的答案，和同学一起交流和分享。如果有收获，也欢迎你把这篇文章分享给你的朋友。</p>",
                "article_title": "16 | 理论二：如何做到“对扩展开放、修改关闭”？扩展和修改各指什么？"
            },
            {
                "title": "17 | 理论三：里式替换（LSP）跟多态有何区别？哪些代码违背了LSP？",
                "herf": "https://time.geekbang.org/column/article/177110",
                "id": "177110",
                "content": "<p>在上两节课中，我们学习了SOLID原则中的单一职责原则和开闭原则，这两个原则都比较重要，想要灵活应用也比较难，需要你在实践中多加练习、多加体会。今天，我们再来学习SOLID中的“L”对应的原则：里式替换原则。</p><p>整体上来讲，这个设计原则是比较简单、容易理解和掌握的。今天我主要通过几个反例，带你看看，哪些代码是违反里式替换原则的？我们该如何将它们改造成满足里式替换原则？除此之外，这条原则从定义上看起来，跟我们之前讲过的“多态”有点类似。所以，我今天也会讲一下，它跟多态的区别。</p><p>话不多说，让我们正式开始今天的学习吧！</p><h2>如何理解“里式替换原则”？</h2><p>里式替换原则的英文翻译是：Liskov Substitution Principle，缩写为LSP。这个原则最早是在1986年由Barbara Liskov提出，他是这么描述这条原则的：</p><blockquote>\n<p>If S is a subtype of T, then objects of type T may be replaced with objects of type S, without breaking the program。</p>\n</blockquote><p>在1996年，Robert Martin在他的SOLID原则中，重新描述了这个原则，英文原话是这样的：</p><!-- [[[read_end]]] --><blockquote>\n<p>Functions that use pointers of references to base classes must be able to use objects of derived classes without knowing it。</p>\n</blockquote><p>我们综合两者的描述，将这条原则用中文描述出来，是这样的：子类对象（object of subtype/derived class）能够替换程序（program）中父类对象（object of base/parent class）出现的任何地方，并且保证原来程序的逻辑行为（behavior）不变及正确性不被破坏。</p><p>这么说还是比较抽象，我们通过一个例子来解释一下。如下代码中，父类Transporter使用org.apache.http库中的HttpClient类来传输网络数据。子类SecurityTransporter继承父类Transporter，增加了额外的功能，支持传输appId和appToken安全认证信息。</p><pre><code>public class Transporter {\n  private HttpClient httpClient;\n  \n  public Transporter(HttpClient httpClient) {\n    this.httpClient = httpClient;\n  }\n\n  public Response sendRequest(Request request) {\n    // ...use httpClient to send request\n  }\n}\n\npublic class SecurityTransporter extends Transporter {\n  private String appId;\n  private String appToken;\n\n  public SecurityTransporter(HttpClient httpClient, String appId, String appToken) {\n    super(httpClient);\n    this.appId = appId;\n    this.appToken = appToken;\n  }\n\n  @Override\n  public Response sendRequest(Request request) {\n    if (StringUtils.isNotBlank(appId) &amp;&amp; StringUtils.isNotBlank(appToken)) {\n      request.addPayload(&quot;app-id&quot;, appId);\n      request.addPayload(&quot;app-token&quot;, appToken);\n    }\n    return super.sendRequest(request);\n  }\n}\n\npublic class Demo {    \n  public void demoFunction(Transporter transporter) {    \n    Reuqest request = new Request();\n    //...省略设置request中数据值的代码...\n    Response response = transporter.sendRequest(request);\n    //...省略其他逻辑...\n  }\n}\n\n// 里式替换原则\nDemo demo = new Demo();\ndemo.demofunction(new SecurityTransporter(/*省略参数*/););\n</code></pre><p>在上面的代码中，子类SecurityTransporter的设计完全符合里式替换原则，可以替换父类出现的任何位置，并且原来代码的逻辑行为不变且正确性也没有被破坏。</p><p>不过，你可能会有这样的疑问，刚刚的代码设计不就是简单利用了面向对象的多态特性吗？多态和里式替换原则说的是不是一回事呢？从刚刚的例子和定义描述来看，里式替换原则跟多态看起来确实有点类似，但实际上它们完全是两回事。为什么这么说呢？</p><p>我们还是通过刚才这个例子来解释一下。不过，我们需要对SecurityTransporter类中sendRequest()函数稍加改造一下。改造前，如果appId或者appToken没有设置，我们就不做校验；改造后，如果appId或者appToken没有设置，则直接抛出NoAuthorizationRuntimeException未授权异常。改造前后的代码对比如下所示：</p><pre><code>// 改造前：\npublic class SecurityTransporter extends Transporter {\n  //...省略其他代码..\n  @Override\n  public Response sendRequest(Request request) {\n    if (StringUtils.isNotBlank(appId) &amp;&amp; StringUtils.isNotBlank(appToken)) {\n      request.addPayload(&quot;app-id&quot;, appId);\n      request.addPayload(&quot;app-token&quot;, appToken);\n    }\n    return super.sendRequest(request);\n  }\n}\n\n// 改造后：\npublic class SecurityTransporter extends Transporter {\n  //...省略其他代码..\n  @Override\n  public Response sendRequest(Request request) {\n    if (StringUtils.isBlank(appId) || StringUtils.isBlank(appToken)) {\n      throw new NoAuthorizationRuntimeException(...);\n    }\n    request.addPayload(&quot;app-id&quot;, appId);\n    request.addPayload(&quot;app-token&quot;, appToken);\n    return super.sendRequest(request);\n  }\n}\n</code></pre><p>在改造之后的代码中，如果传递进demoFunction()函数的是父类Transporter对象，那demoFunction()函数并不会有异常抛出，但如果传递给demoFunction()函数的是子类SecurityTransporter对象，那demoFunction()有可能会有异常抛出。尽管代码中抛出的是运行时异常（Runtime Exception），我们可以不在代码中显式地捕获处理，但子类替换父类传递进demoFunction函数之后，整个程序的逻辑行为有了改变。</p><p>虽然改造之后的代码仍然可以通过Java的多态语法，动态地用子类SecurityTransporter来替换父类Transporter，也并不会导致程序编译或者运行报错。但是，从设计思路上来讲，SecurityTransporter的设计是不符合里式替换原则的。</p><p>好了，我们稍微总结一下。虽然从定义描述和代码实现上来看，多态和里式替换有点类似，但它们关注的角度是不一样的。多态是面向对象编程的一大特性，也是面向对象编程语言的一种语法。它是一种代码实现的思路。而里式替换是一种设计原则，是用来指导继承关系中子类该如何设计的，子类的设计要保证在替换父类的时候，不改变原有程序的逻辑以及不破坏原有程序的正确性。</p><h2>哪些代码明显违背了LSP？</h2><p>实际上，里式替换原则还有另外一个更加能落地、更有指导意义的描述，那就是“Design By Contract”，中文翻译就是“按照协议来设计”。</p><p>看起来比较抽象，我来进一步解读一下。子类在设计的时候，要遵守父类的行为约定（或者叫协议）。父类定义了函数的行为约定，那子类可以改变函数的内部实现逻辑，但不能改变函数原有的行为约定。这里的行为约定包括：函数声明要实现的功能；对输入、输出、异常的约定；甚至包括注释中所罗列的任何特殊说明。实际上，定义中父类和子类之间的关系，也可以替换成接口和实现类之间的关系。</p><p>为了更好地理解这句话，我举几个违反里式替换原则的例子来解释一下。</p><h3>1.子类违背父类声明要实现的功能</h3><p>父类中提供的sortOrdersByAmount()订单排序函数，是按照金额从小到大来给订单排序的，而子类重写这个sortOrdersByAmount()订单排序函数之后，是按照创建日期来给订单排序的。那子类的设计就违背里式替换原则。</p><h3>2.子类违背父类对输入、输出、异常的约定</h3><p>在父类中，某个函数约定：运行出错的时候返回null；获取数据为空的时候返回空集合（empty collection）。而子类重载函数之后，实现变了，运行出错返回异常（exception），获取不到数据返回null。那子类的设计就违背里式替换原则。</p><p>在父类中，某个函数约定，输入数据可以是任意整数，但子类实现的时候，只允许输入数据是正整数，负数就抛出，也就是说，子类对输入的数据的校验比父类更加严格，那子类的设计就违背了里式替换原则。</p><p>在父类中，某个函数约定，只会抛出ArgumentNullException异常，那子类的设计实现中只允许抛出ArgumentNullException异常，任何其他异常的抛出，都会导致子类违背里式替换原则。</p><h3>3.子类违背父类注释中所罗列的任何特殊说明</h3><p>父类中定义的withdraw()提现函数的注释是这么写的：“用户的提现金额不得超过账户余额……”，而子类重写withdraw()函数之后，针对VIP账号实现了透支提现的功能，也就是提现金额可以大于账户余额，那这个子类的设计也是不符合里式替换原则的。</p><p>以上便是三种典型的违背里式替换原则的情况。除此之外，判断子类的设计实现是否违背里式替换原则，还有一个小窍门，那就是拿父类的单元测试去验证子类的代码。如果某些单元测试运行失败，就有可能说明，子类的设计实现没有完全地遵守父类的约定，子类有可能违背了里式替换原则。</p><p>实际上，你有没有发现，里式替换这个原则是非常宽松的。一般情况下，我们写的代码都不怎么会违背它。所以，只要你能看懂我今天讲的这些，这个原则就不难掌握，也不难应用。</p><h2>重点回顾</h2><p>今天的内容到此就讲完了。我们来一块总结回顾一下，你需要掌握的重点内容。</p><p>里式替换原则是用来指导，继承关系中子类该如何设计的一个原则。理解里式替换原则，最核心的就是理解“design by contract，按照协议来设计”这几个字。父类定义了函数的“约定”（或者叫协议），那子类可以改变函数的内部实现逻辑，但不能改变函数原有的“约定”。这里的约定包括：函数声明要实现的功能；对输入、输出、异常的约定；甚至包括注释中所罗列的任何特殊说明。</p><p>理解这个原则，我们还要弄明白里式替换原则跟多态的区别。虽然从定义描述和代码实现上来看，多态和里式替换有点类似，但它们关注的角度是不一样的。多态是面向对象编程的一大特性，也是面向对象编程语言的一种语法。它是一种代码实现的思路。而里式替换是一种设计原则，用来指导继承关系中子类该如何设计，子类的设计要保证在替换父类的时候，不改变原有程序的逻辑及不破坏原有程序的正确性。</p><h2>课堂讨论</h2><p>把复杂的东西讲简单，把简单的东西讲深刻，都是比较难的事情。而里式替换原则存在的意义可以说不言自喻，非常简单明确，但是越是这种不言自喻的道理，越是难组织成文字或语言来描述，有点儿只可意会不可言传的意思，所以，今天的课堂讨论的话题是：请你有条理、有深度地讲一讲里式替换原则存在的意义。</p><p>欢迎在留言区写下你的想法，和同学一起交流和分享。如果有收获，也欢迎你把这篇文章分享给你的朋友。</p>",
                "article_title": "17 | 理论三：里式替换（LSP）跟多态有何区别？哪些代码违背了LSP？"
            },
            {
                "title": "18 | 理论四：接口隔离原则有哪三种应用？原则中的“接口”该如何理解？",
                "herf": "https://time.geekbang.org/column/article/177442",
                "id": "177442",
                "content": "<p>上几节课中，我们学习了SOLID原则中的单一职责原则、开闭原则和里式替换原则，今天我们学习第四个原则，接口隔离原则。它对应SOLID中的英文字母“I”。对于这个原则，最关键就是理解其中“接口”的含义。那针对“接口”，不同的理解方式，对应在原则上也有不同的解读方式。除此之外，接口隔离原则跟我们之前讲到的单一职责原则还有点儿类似，所以今天我也会具体讲一下它们之间的区别和联系。</p><p>话不多说，现在就让我们正式开始今天的学习吧！</p><h2>如何理解“接口隔离原则”？</h2><p>接口隔离原则的英文翻译是“ Interface Segregation Principle”，缩写为ISP。Robert Martin在SOLID原则中是这样定义它的：“Clients should not be forced to depend upon interfaces that they do not use。”直译成中文的话就是：客户端不应该被强迫依赖它不需要的接口。其中的“客户端”，可以理解为接口的调用者或者使用者。</p><p>实际上，“接口”这个名词可以用在很多场合中。生活中我们可以用它来指插座接口等。在软件开发中，我们既可以把它看作一组抽象的约定，也可以具体指系统与系统之间的API接口，还可以特指面向对象编程语言中的接口等。</p><!-- [[[read_end]]] --><p>前面我提到，理解接口隔离原则的关键，就是理解其中的“接口”二字。在这条原则中，我们可以把“接口”理解为下面三种东西：</p><ul>\n<li>一组API接口集合</li>\n<li>单个API接口或函数</li>\n<li>OOP中的接口概念</li>\n</ul><p>接下来，我就按照这三种理解方式来详细讲一下，在不同的场景下，这条原则具体是如何解读和应用的。</p><h2>把“接口”理解为一组API接口集合</h2><p>我们还是结合一个例子来讲解。微服务用户系统提供了一组跟用户相关的API给其他系统使用，比如：注册、登录、获取用户信息等。具体代码如下所示：</p><pre><code>public interface UserService {\n  boolean register(String cellphone, String password);\n  boolean login(String cellphone, String password);\n  UserInfo getUserInfoById(long id);\n  UserInfo getUserInfoByCellphone(String cellphone);\n}\n\npublic class UserServiceImpl implements UserService {\n  //...\n}\n</code></pre><p>现在，我们的后台管理系统要实现删除用户的功能，希望用户系统提供一个删除用户的接口。这个时候我们该如何来做呢？你可能会说，这不是很简单吗，我只需要在UserService中新添加一个deleteUserByCellphone()或deleteUserById()接口就可以了。这个方法可以解决问题，但是也隐藏了一些安全隐患。</p><p>删除用户是一个非常慎重的操作，我们只希望通过后台管理系统来执行，所以这个接口只限于给后台管理系统使用。如果我们把它放到UserService中，那所有使用到UserService的系统，都可以调用这个接口。不加限制地被其他业务系统调用，就有可能导致误删用户。</p><p>当然，最好的解决方案是从架构设计的层面，通过接口鉴权的方式来限制接口的调用。不过，如果暂时没有鉴权框架来支持，我们还可以从代码设计的层面，尽量避免接口被误用。我们参照接口隔离原则，调用者不应该强迫依赖它不需要的接口，将删除接口单独放到另外一个接口RestrictedUserService中，然后将RestrictedUserService只打包提供给后台管理系统来使用。具体的代码实现如下所示：</p><pre><code>public interface UserService {\n  boolean register(String cellphone, String password);\n  boolean login(String cellphone, String password);\n  UserInfo getUserInfoById(long id);\n  UserInfo getUserInfoByCellphone(String cellphone);\n}\n\npublic interface RestrictedUserService {\n  boolean deleteUserByCellphone(String cellphone);\n  boolean deleteUserById(long id);\n}\n\npublic class UserServiceImpl implements UserService, RestrictedUserService {\n  // ...省略实现代码...\n}\n</code></pre><p>在刚刚的这个例子中，我们把接口隔离原则中的接口，理解为一组接口集合，它可以是某个微服务的接口，也可以是某个类库的接口等等。在设计微服务或者类库接口的时候，如果部分接口只被部分调用者使用，那我们就需要将这部分接口隔离出来，单独给对应的调用者使用，而不是强迫其他调用者也依赖这部分不会被用到的接口。</p><h2>把“接口”理解为单个API接口或函数</h2><p>现在我们再换一种理解方式，把接口理解为单个接口或函数（以下为了方便讲解，我都简称为“函数”）。那接口隔离原则就可以理解为：函数的设计要功能单一，不要将多个不同的功能逻辑在一个函数中实现。接下来，我们还是通过一个例子来解释一下。</p><pre><code>public class Statistics {\n  private Long max;\n  private Long min;\n  private Long average;\n  private Long sum;\n  private Long percentile99;\n  private Long percentile999;\n  //...省略constructor/getter/setter等方法...\n}\n\npublic Statistics count(Collection&lt;Long&gt; dataSet) {\n  Statistics statistics = new Statistics();\n  //...省略计算逻辑...\n  return statistics;\n}\n</code></pre><p>在上面的代码中，count()函数的功能不够单一，包含很多不同的统计功能，比如，求最大值、最小值、平均值等等。按照接口隔离原则，我们应该把count()函数拆成几个更小粒度的函数，每个函数负责一个独立的统计功能。拆分之后的代码如下所示：</p><pre><code>public Long max(Collection&lt;Long&gt; dataSet) { //... }\npublic Long min(Collection&lt;Long&gt; dataSet) { //... } \npublic Long average(Colletion&lt;Long&gt; dataSet) { //... }\n// ...省略其他统计函数...\n</code></pre><p>不过，你可能会说，在某种意义上讲，count()函数也不能算是职责不够单一，毕竟它做的事情只跟统计相关。我们在讲单一职责原则的时候，也提到过类似的问题。实际上，判定功能是否单一，除了很强的主观性，还需要结合具体的场景。</p><p>如果在项目中，对每个统计需求，Statistics定义的那几个统计信息都有涉及，那count()函数的设计就是合理的。相反，如果每个统计需求只涉及Statistics罗列的统计信息中一部分，比如，有的只需要用到max、min、average这三类统计信息，有的只需要用到average、sum。而count()函数每次都会把所有的统计信息计算一遍，就会做很多无用功，势必影响代码的性能，特别是在需要统计的数据量很大的时候。所以，在这个应用场景下，count()函数的设计就有点不合理了，我们应该按照第二种设计思路，将其拆分成粒度更细的多个统计函数。</p><p>不过，你应该已经发现，接口隔离原则跟单一职责原则有点类似，不过稍微还是有点区别。单一职责原则针对的是模块、类、接口的设计。而接口隔离原则相对于单一职责原则，一方面它更侧重于接口的设计，另一方面它的思考的角度不同。它提供了一种判断接口是否职责单一的标准：通过调用者如何使用接口来间接地判定。如果调用者只使用部分接口或接口的部分功能，那接口的设计就不够职责单一。</p><h2>把“接口”理解为OOP中的接口概念</h2><p>除了刚讲过的两种理解方式，我们还可以把“接口”理解为OOP中的接口概念，比如Java中的interface。我还是通过一个例子来给你解释。</p><p>假设我们的项目中用到了三个外部系统：Redis、MySQL、Kafka。每个系统都对应一系列配置信息，比如地址、端口、访问超时时间等。为了在内存中存储这些配置信息，供项目中的其他模块来使用，我们分别设计实现了三个Configuration类：RedisConfig、MysqlConfig、KafkaConfig。具体的代码实现如下所示。注意，这里我只给出了RedisConfig的代码实现，另外两个都是类似的，我这里就不贴了。</p><pre><code>public class RedisConfig {\n    private ConfigSource configSource; //配置中心（比如zookeeper）\n    private String address;\n    private int timeout;\n    private int maxTotal;\n    //省略其他配置: maxWaitMillis,maxIdle,minIdle...\n\n    public RedisConfig(ConfigSource configSource) {\n        this.configSource = configSource;\n    }\n\n    public String getAddress() {\n        return this.address;\n    }\n    //...省略其他get()、init()方法...\n\n    public void update() {\n      //从configSource加载配置到address/timeout/maxTotal...\n    }\n}\n\npublic class KafkaConfig { //...省略... }\npublic class MysqlConfig { //...省略... }\n</code></pre><p>现在，我们有一个新的功能需求，希望支持Redis和Kafka配置信息的热更新。所谓“热更新（hot update）”就是，如果在配置中心中更改了配置信息，我们希望在不用重启系统的情况下，能将最新的配置信息加载到内存中（也就是RedisConfig、KafkaConfig类中）。但是，因为某些原因，我们并不希望对MySQL的配置信息进行热更新。</p><p>为了实现这样一个功能需求，我们设计实现了一个ScheduledUpdater类，以固定时间频率（periodInSeconds）来调用RedisConfig、KafkaConfig的update()方法更新配置信息。具体的代码实现如下所示：</p><pre><code>public interface Updater {\n  void update();\n}\n\npublic class RedisConfig implemets Updater {\n  //...省略其他属性和方法...\n  @Override\n  public void update() { //... }\n}\n\npublic class KafkaConfig implements Updater {\n  //...省略其他属性和方法...\n  @Override\n  public void update() { //... }\n}\n\npublic class MysqlConfig { //...省略其他属性和方法... }\n\npublic class ScheduledUpdater {\n    private final ScheduledExecutorService executor = Executors.newSingleThreadScheduledExecutor();;\n    private long initialDelayInSeconds;\n    private long periodInSeconds;\n    private Updater updater;\n\n    public ScheduleUpdater(Updater updater, long initialDelayInSeconds, long periodInSeconds) {\n        this.updater = updater;\n        this.initialDelayInSeconds = initialDelayInSeconds;\n        this.periodInSeconds = periodInSeconds;\n    }\n\n    public void run() {\n        executor.scheduleAtFixedRate(new Runnable() {\n            @Override\n            public void run() {\n                updater.update();\n            }\n        }, this.initialDelayInSeconds, this.periodInSeconds, TimeUnit.SECONDS);\n    }\n}\n\npublic class Application {\n  ConfigSource configSource = new ZookeeperConfigSource(/*省略参数*/);\n  public static final RedisConfig redisConfig = new RedisConfig(configSource);\n  public static final KafkaConfig kafkaConfig = new KakfaConfig(configSource);\n  public static final MySqlConfig mysqlConfig = new MysqlConfig(configSource);\n\n  public static void main(String[] args) {\n    ScheduledUpdater redisConfigUpdater = new ScheduledUpdater(redisConfig, 300, 300);\n    redisConfigUpdater.run();\n    \n    ScheduledUpdater kafkaConfigUpdater = new ScheduledUpdater(kafkaConfig, 60, 60);\n    kafkaConfigUpdater.run();\n  }\n}\n</code></pre><p>刚刚的热更新的需求我们已经搞定了。现在，我们又有了一个新的监控功能需求。通过命令行来查看Zookeeper中的配置信息是比较麻烦的。所以，我们希望能有一种更加方便的配置信息查看方式。</p><p>我们可以在项目中开发一个内嵌的SimpleHttpServer，输出项目的配置信息到一个固定的HTTP地址，比如：<a href=\"http://127.0.0.1:2389/config\">http://127.0.0.1:2389/config</a> 。我们只需要在浏览器中输入这个地址，就可以显示出系统的配置信息。不过，出于某些原因，我们只想暴露MySQL和Redis的配置信息，不想暴露Kafka的配置信息。</p><p>为了实现这样一个功能，我们还需要对上面的代码做进一步改造。改造之后的代码如下所示：</p><pre><code>public interface Updater {\n  void update();\n}\n\npublic interface Viewer {\n  String outputInPlainText();\n  Map&lt;String, String&gt; output();\n}\n\npublic class RedisConfig implemets Updater, Viewer {\n  //...省略其他属性和方法...\n  @Override\n  public void update() { //... }\n  @Override\n  public String outputInPlainText() { //... }\n  @Override\n  public Map&lt;String, String&gt; output() { //...}\n}\n\npublic class KafkaConfig implements Updater {\n  //...省略其他属性和方法...\n  @Override\n  public void update() { //... }\n}\n\npublic class MysqlConfig implements Viewer {\n  //...省略其他属性和方法...\n  @Override\n  public String outputInPlainText() { //... }\n  @Override\n  public Map&lt;String, String&gt; output() { //...}\n}\n\npublic class SimpleHttpServer {\n  private String host;\n  private int port;\n  private Map&lt;String, List&lt;Viewer&gt;&gt; viewers = new HashMap&lt;&gt;();\n  \n  public SimpleHttpServer(String host, int port) {//...}\n  \n  public void addViewers(String urlDirectory, Viewer viewer) {\n    if (!viewers.containsKey(urlDirectory)) {\n      viewers.put(urlDirectory, new ArrayList&lt;Viewer&gt;());\n    }\n    this.viewers.get(urlDirectory).add(viewer);\n  }\n  \n  public void run() { //... }\n}\n\npublic class Application {\n    ConfigSource configSource = new ZookeeperConfigSource();\n    public static final RedisConfig redisConfig = new RedisConfig(configSource);\n    public static final KafkaConfig kafkaConfig = new KakfaConfig(configSource);\n    public static final MySqlConfig mysqlConfig = new MySqlConfig(configSource);\n    \n    public static void main(String[] args) {\n        ScheduledUpdater redisConfigUpdater =\n            new ScheduledUpdater(redisConfig, 300, 300);\n        redisConfigUpdater.run();\n        \n        ScheduledUpdater kafkaConfigUpdater =\n            new ScheduledUpdater(kafkaConfig, 60, 60);\n        redisConfigUpdater.run();\n        \n        SimpleHttpServer simpleHttpServer = new SimpleHttpServer(“127.0.0.1”, 2389);\n        simpleHttpServer.addViewer(&quot;/config&quot;, redisConfig);\n        simpleHttpServer.addViewer(&quot;/config&quot;, mysqlConfig);\n        simpleHttpServer.run();\n    }\n}\n</code></pre><p>至此，热更新和监控的需求我们就都实现了。我们来回顾一下这个例子的设计思想。</p><p>我们设计了两个功能非常单一的接口：Updater和Viewer。ScheduledUpdater只依赖Updater这个跟热更新相关的接口，不需要被强迫去依赖不需要的Viewer接口，满足接口隔离原则。同理，SimpleHttpServer只依赖跟查看信息相关的Viewer接口，不依赖不需要的Updater接口，也满足接口隔离原则。</p><p>你可能会说，如果我们不遵守接口隔离原则，不设计Updater和Viewer两个小接口，而是设计一个大而全的Config接口，让RedisConfig、KafkaConfig、MysqlConfig都实现这个Config接口，并且将原来传递给ScheduledUpdater的Updater和传递给SimpleHttpServer的Viewer，都替换为Config，那会有什么问题呢？我们先来看一下，按照这个思路来实现的代码是什么样的。</p><pre><code>public interface Config {\n  void update();\n  String outputInPlainText();\n  Map&lt;String, String&gt; output();\n}\n\npublic class RedisConfig implements Config {\n  //...需要实现Config的三个接口update/outputIn.../output\n}\n\npublic class KafkaConfig implements Config {\n  //...需要实现Config的三个接口update/outputIn.../output\n}\n\npublic class MysqlConfig implements Config {\n  //...需要实现Config的三个接口update/outputIn.../output\n}\n\npublic class ScheduledUpdater {\n  //...省略其他属性和方法..\n  private Config config;\n\n  public ScheduleUpdater(Config config, long initialDelayInSeconds, long periodInSeconds) {\n      this.config = config;\n      //...\n  }\n  //...\n}\n\npublic class SimpleHttpServer {\n  private String host;\n  private int port;\n  private Map&lt;String, List&lt;Config&gt;&gt; viewers = new HashMap&lt;&gt;();\n \n  public SimpleHttpServer(String host, int port) {//...}\n  \n  public void addViewer(String urlDirectory, Config config) {\n    if (!viewers.containsKey(urlDirectory)) {\n      viewers.put(urlDirectory, new ArrayList&lt;Config&gt;());\n    }\n    viewers.get(urlDirectory).add(config);\n  }\n  \n  public void run() { //... }\n}\n</code></pre><p>这样的设计思路也是能工作的，但是对比前后两个设计思路，在同样的代码量、实现复杂度、同等可读性的情况下，第一种设计思路显然要比第二种好很多。为什么这么说呢？主要有两点原因。</p><p><strong>首先，第一种设计思路更加灵活、易扩展、易复用。</strong>因为Updater、Viewer职责更加单一，单一就意味了通用、复用性好。比如，我们现在又有一个新的需求，开发一个Metrics性能统计模块，并且希望将Metrics也通过SimpleHttpServer显示在网页上，以方便查看。这个时候，尽管Metrics跟RedisConfig等没有任何关系，但我们仍然可以让Metrics类实现非常通用的Viewer接口，复用SimpleHttpServer的代码实现。具体的代码如下所示：</p><pre><code>public class ApiMetrics implements Viewer {//...}\npublic class DbMetrics implements Viewer {//...}\n\npublic class Application {\n    ConfigSource configSource = new ZookeeperConfigSource();\n    public static final RedisConfig redisConfig = new RedisConfig(configSource);\n    public static final KafkaConfig kafkaConfig = new KakfaConfig(configSource);\n    public static final MySqlConfig mySqlConfig = new MySqlConfig(configSource);\n    public static final ApiMetrics apiMetrics = new ApiMetrics();\n    public static final DbMetrics dbMetrics = new DbMetrics();\n    \n    public static void main(String[] args) {\n        SimpleHttpServer simpleHttpServer = new SimpleHttpServer(“127.0.0.1”, 2389);\n        simpleHttpServer.addViewer(&quot;/config&quot;, redisConfig);\n        simpleHttpServer.addViewer(&quot;/config&quot;, mySqlConfig);\n        simpleHttpServer.addViewer(&quot;/metrics&quot;, apiMetrics);\n        simpleHttpServer.addViewer(&quot;/metrics&quot;, dbMetrics);\n        simpleHttpServer.run();\n    }\n}\n</code></pre><p><strong>其次，第二种设计思路在代码实现上做了一些无用功。</strong>因为Config接口中包含两类不相关的接口，一类是update()，一类是output()和outputInPlainText()。理论上，KafkaConfig只需要实现update()接口，并不需要实现output()相关的接口。同理，MysqlConfig只需要实现output()相关接口，并需要实现update()接口。但第二种设计思路要求RedisConfig、KafkaConfig、MySqlConfig必须同时实现Config的所有接口函数（update、output、outputInPlainText）。除此之外，如果我们要往Config中继续添加一个新的接口，那所有的实现类都要改动。相反，如果我们的接口粒度比较小，那涉及改动的类就比较少。</p><h2>重点回顾</h2><p>今天的内容到此就讲完了。我们一块来总结回顾一下，你需要掌握的重点内容。</p><p><strong>1.如何理解“接口隔离原则”？</strong></p><p>理解“接口隔离原则”的重点是理解其中的“接口”二字。这里有三种不同的理解。</p><p>如果把“接口”理解为一组接口集合，可以是某个微服务的接口，也可以是某个类库的接口等。如果部分接口只被部分调用者使用，我们就需要将这部分接口隔离出来，单独给这部分调用者使用，而不强迫其他调用者也依赖这部分不会被用到的接口。</p><p>如果把“接口”理解为单个API接口或函数，部分调用者只需要函数中的部分功能，那我们就需要把函数拆分成粒度更细的多个函数，让调用者只依赖它需要的那个细粒度函数。</p><p>如果把“接口”理解为OOP中的接口，也可以理解为面向对象编程语言中的接口语法。那接口的设计要尽量单一，不要让接口的实现类和调用者，依赖不需要的接口函数。</p><p><strong>2.接口隔离原则与单一职责原则的区别</strong></p><p>单一职责原则针对的是模块、类、接口的设计。接口隔离原则相对于单一职责原则，一方面更侧重于接口的设计，另一方面它的思考角度也是不同的。接口隔离原则提供了一种判断接口的职责是否单一的标准：通过调用者如何使用接口来间接地判定。如果调用者只使用部分接口或接口的部分功能，那接口的设计就不够职责单一。</p><h2>课堂讨论</h2><p>今天课堂讨论的话题是这样的：</p><p>java.util.concurrent并发包提供了AtomicInteger这样一个原子类，其中有一个函数getAndIncrement()是这样定义的：给整数增加一，并且返回未増之前的值。我的问题是，这个函数的设计是否符合单一职责原则和接口隔离原则？为什么？</p><pre><code>/**\n * Atomically increments by one the current value.\n * @return the previous value\n */\npublic final int getAndIncrement() {//...}\n</code></pre><p>欢迎在留言区写下你的答案，和同学一起交流和分享。如果有收获，也欢迎你把这篇文章分享给你的朋友。</p>",
                "article_title": "18 | 理论四：接口隔离原则有哪三种应用？原则中的“接口”该如何理解？"
            },
            {
                "title": "19 | 理论五：控制反转、依赖反转、依赖注入，这三者有何区别和联系？",
                "herf": "https://time.geekbang.org/column/article/177444",
                "id": "177444",
                "content": "<p>关于SOLID原则，我们已经学过单一职责、开闭、里式替换、接口隔离这四个原则。今天，我们再来学习最后一个原则：依赖反转原则。在前面几节课中，我们讲到，单一职责原则和开闭原则的原理比较简单，但是，想要在实践中用好却比较难。而今天我们要讲到的依赖反转原则正好相反。这个原则用起来比较简单，但概念理解起来比较难。比如，下面这几个问题，你看看能否清晰地回答出来：</p><ul>\n<li>“依赖反转”这个概念指的是“谁跟谁”的“什么依赖”被反转了？“反转”两个字该如何理解？</li>\n<li>我们还经常听到另外两个概念：“控制反转”和“依赖注入”。这两个概念跟“依赖反转”有什么区别和联系呢？它们说的是同一个事情吗？</li>\n<li>如果你熟悉Java语言，那Spring框架中的IOC跟这些概念又有什么关系呢？</li>\n</ul><p>看了刚刚这些问题，你是不是有点懵？别担心，今天我会带你将这些问题彻底搞个清楚。之后再有人问你，你就能轻松应对。话不多说，现在就让我们带着这些问题，正式开始今天的学习吧！</p><h2>控制反转（IOC）</h2><p>在讲“依赖反转原则”之前，我们先讲一讲“控制反转”。控制反转的英文翻译是Inversion Of Control，缩写为IOC。此处我要强调一下，如果你是Java工程师的话，暂时别把这个“IOC”跟Spring框架的IOC联系在一起。关于Spring的IOC，我们待会儿还会讲到。</p><!-- [[[read_end]]] --><p>我们先通过一个例子来看一下，什么是控制反转。</p><pre><code>public class UserServiceTest {\n  public static boolean doTest() {\n    // ... \n  }\n  \n  public static void main(String[] args) {//这部分逻辑可以放到框架中\n    if (doTest()) {\n      System.out.println(&quot;Test succeed.&quot;);\n    } else {\n      System.out.println(&quot;Test failed.&quot;);\n    }\n  }\n}\n</code></pre><p>在上面的代码中，所有的流程都由程序员来控制。如果我们抽象出一个下面这样一个框架，我们再来看，如何利用框架来实现同样的功能。具体的代码实现如下所示：</p><pre><code>public abstract class TestCase {\n  public void run() {\n    if (doTest()) {\n      System.out.println(&quot;Test succeed.&quot;);\n    } else {\n      System.out.println(&quot;Test failed.&quot;);\n    }\n  }\n  \n  public abstract boolean doTest();\n}\n\npublic class JunitApplication {\n  private static final List&lt;TestCase&gt; testCases = new ArrayList&lt;&gt;();\n  \n  public static void register(TestCase testCase) {\n    testCases.add(testCase);\n  }\n  \n  public static final void main(String[] args) {\n    for (TestCase case: testCases) {\n      case.run();\n    }\n  }\n</code></pre><p>把这个简化版本的测试框架引入到工程中之后，我们只需要在框架预留的扩展点，也就是TestCase类中的doTest()抽象函数中，填充具体的测试代码就可以实现之前的功能了，完全不需要写负责执行流程的main()函数了。 具体的代码如下所示：</p><pre><code>public class UserServiceTest extends TestCase {\n  @Override\n  public boolean doTest() {\n    // ... \n  }\n}\n\n// 注册操作还可以通过配置的方式来实现，不需要程序员显示调用register()\nJunitApplication.register(new UserServiceTest();\n</code></pre><p>刚刚举的这个例子，就是典型的通过框架来实现“控制反转”的例子。框架提供了一个可扩展的代码骨架，用来组装对象、管理整个执行流程。程序员利用框架进行开发的时候，只需要往预留的扩展点上，添加跟自己业务相关的代码，就可以利用框架来驱动整个程序流程的执行。</p><p>这里的“控制”指的是对程序执行流程的控制，而“反转”指的是在没有使用框架之前，程序员自己控制整个程序的执行。在使用框架之后，整个程序的执行流程可以通过框架来控制。流程的控制权从程序员“反转”到了框架。</p><p>实际上，实现控制反转的方法有很多，除了刚才例子中所示的类似于模板设计模式的方法之外，还有马上要讲到的依赖注入等方法，所以，控制反转并不是一种具体的实现技巧，而是一个比较笼统的设计思想，一般用来指导框架层面的设计。</p><h2>依赖注入（DI）</h2><p>接下来，我们再来看依赖注入。依赖注入跟控制反转恰恰相反，它是一种具体的编码技巧。依赖注入的英文翻译是Dependency Injection，缩写为DI。对于这个概念，有一个非常形象的说法，那就是：依赖注入是一个标价25美元，实际上只值5美分的概念。也就是说，这个概念听起来很“高大上”，实际上，理解、应用起来非常简单。</p><p>那到底什么是依赖注入呢？我们用一句话来概括就是：不通过new()的方式在类内部创建依赖类对象，而是将依赖的类对象在外部创建好之后，通过构造函数、函数参数等方式传递（或注入）给类使用。</p><p>我们还是通过一个例子来解释一下。在这个例子中，Notification类负责消息推送，依赖MessageSender类实现推送商品促销、验证码等消息给用户。我们分别用依赖注入和非依赖注入两种方式来实现一下。具体的实现代码如下所示：</p><pre><code>// 非依赖注入实现方式\npublic class Notification {\n  private MessageSender messageSender;\n  \n  public Notification() {\n    this.messageSender = new MessageSender(); //此处有点像hardcode\n  }\n  \n  public void sendMessage(String cellphone, String message) {\n    //...省略校验逻辑等...\n    this.messageSender.send(cellphone, message);\n  }\n}\n\npublic class MessageSender {\n  public void send(String cellphone, String message) {\n    //....\n  }\n}\n// 使用Notification\nNotification notification = new Notification();\n\n// 依赖注入的实现方式\npublic class Notification {\n  private MessageSender messageSender;\n  \n  // 通过构造函数将messageSender传递进来\n  public Notification(MessageSender messageSender) {\n    this.messageSender = messageSender;\n  }\n  \n  public void sendMessage(String cellphone, String message) {\n    //...省略校验逻辑等...\n    this.messageSender.send(cellphone, message);\n  }\n}\n//使用Notification\nMessageSender messageSender = new MessageSender();\nNotification notification = new Notification(messageSender);\n</code></pre><p>通过依赖注入的方式来将依赖的类对象传递进来，这样就提高了代码的扩展性，我们可以灵活地替换依赖的类。这一点在我们之前讲“开闭原则”的时候也提到过。当然，上面代码还有继续优化的空间，我们还可以把MessageSender定义成接口，基于接口而非实现编程。改造后的代码如下所示：</p><pre><code>public class Notification {\n  private MessageSender messageSender;\n  \n  public Notification(MessageSender messageSender) {\n    this.messageSender = messageSender;\n  }\n  \n  public void sendMessage(String cellphone, String message) {\n    this.messageSender.send(cellphone, message);\n  }\n}\n\npublic interface MessageSender {\n  void send(String cellphone, String message);\n}\n\n// 短信发送类\npublic class SmsSender implements MessageSender {\n  @Override\n  public void send(String cellphone, String message) {\n    //....\n  }\n}\n\n// 站内信发送类\npublic class InboxSender implements MessageSender {\n  @Override\n  public void send(String cellphone, String message) {\n    //....\n  }\n}\n\n//使用Notification\nMessageSender messageSender = new SmsSender();\nNotification notification = new Notification(messageSender);\n</code></pre><p>实际上，你只需要掌握刚刚举的这个例子，就等于完全掌握了依赖注入。尽管依赖注入非常简单，但却非常有用，在后面的章节中，我们会讲到，它是编写可测试性代码最有效的手段。</p><h2>依赖注入框架（DI Framework）</h2><p>弄懂了什么是“依赖注入”，我们再来看一下，什么是“依赖注入框架”。我们还是借用刚刚的例子来解释。</p><p>在采用依赖注入实现的Notification类中，虽然我们不需要用类似hard code的方式，在类内部通过new来创建MessageSender对象，但是，这个创建对象、组装（或注入）对象的工作仅仅是被移动到了更上层代码而已，还是需要我们程序员自己来实现。具体代码如下所示：</p><pre><code>public class Demo {\n  public static final void main(String args[]) {\n    MessageSender sender = new SmsSender(); //创建对象\n    Notification notification = new Notification(sender);//依赖注入\n    notification.sendMessage(&quot;13918942177&quot;, &quot;短信验证码：2346&quot;);\n  }\n}\n</code></pre><p>在实际的软件开发中，一些项目可能会涉及几十、上百、甚至几百个类，类对象的创建和依赖注入会变得非常复杂。如果这部分工作都是靠程序员自己写代码来完成，容易出错且开发成本也比较高。而对象创建和依赖注入的工作，本身跟具体的业务无关，我们完全可以抽象成框架来自动完成。</p><p>你可能已经猜到，这个框架就是“依赖注入框架”。我们只需要通过依赖注入框架提供的扩展点，简单配置一下所有需要创建的类对象、类与类之间的依赖关系，就可以实现由框架来自动创建对象、管理对象的生命周期、依赖注入等原本需要程序员来做的事情。</p><p>实际上，现成的依赖注入框架有很多，比如Google Guice、Java Spring、Pico Container、Butterfly Container等。不过，如果你熟悉Java Spring框架，你可能会说，Spring框架自己声称是<strong>控制反转容器</strong>（Inversion Of Control Container）。</p><p>实际上，这两种说法都没错。只是控制反转容器这种表述是一种非常宽泛的描述，DI依赖注入框架的表述更具体、更有针对性。因为我们前面讲到实现控制反转的方式有很多，除了依赖注入，还有模板模式等，而Spring框架的控制反转主要是通过依赖注入来实现的。不过这点区分并不是很明显，也不是很重要，你稍微了解一下就可以了。</p><h2>依赖反转原则（DIP）</h2><p>前面讲了控制反转、依赖注入、依赖注入框架，现在，我们来讲一讲今天的主角：依赖反转原则。依赖反转原则的英文翻译是Dependency Inversion Principle，缩写为DIP。中文翻译有时候也叫依赖倒置原则。</p><p>为了追本溯源，我先给出这条原则最原汁原味的英文描述：</p><blockquote>\n<p>High-level modules shouldn’t depend on low-level modules. Both modules should depend on abstractions. In addition, abstractions shouldn’t depend on details. Details depend on abstractions.</p>\n</blockquote><p>我们将它翻译成中文，大概意思就是：高层模块（high-level modules）不要依赖低层模块（low-level）。高层模块和低层模块应该通过抽象（abstractions）来互相依赖。除此之外，抽象（abstractions）不要依赖具体实现细节（details），具体实现细节（details）依赖抽象（abstractions）。</p><p>所谓高层模块和低层模块的划分，简单来说就是，在调用链上，调用者属于高层，被调用者属于低层。在平时的业务代码开发中，高层模块依赖底层模块是没有任何问题的。实际上，这条原则主要还是用来指导框架层面的设计，跟前面讲到的控制反转类似。我们拿Tomcat这个Servlet容器作为例子来解释一下。</p><p>Tomcat是运行Java Web应用程序的容器。我们编写的Web应用程序代码只需要部署在Tomcat容器下，便可以被Tomcat容器调用执行。按照之前的划分原则，Tomcat就是高层模块，我们编写的Web应用程序代码就是低层模块。Tomcat和应用程序代码之间并没有直接的依赖关系，两者都依赖同一个“抽象”，也就是Servlet规范。Servlet规范不依赖具体的Tomcat容器和应用程序的实现细节，而Tomcat容器和应用程序依赖Servlet规范。</p><h2>重点回顾</h2><p>好了，今天的内容到此就讲完了。我们一块来总结回顾一下，你需要掌握的重点内容。</p><p><strong>1.控制反转</strong></p><p>实际上，控制反转是一个比较笼统的设计思想，并不是一种具体的实现方法，一般用来指导框架层面的设计。这里所说的“控制”指的是对程序执行流程的控制，而“反转”指的是在没有使用框架之前，程序员自己控制整个程序的执行。在使用框架之后，整个程序的执行流程通过框架来控制。流程的控制权从程序员“反转”给了框架。</p><p><strong>2.依赖注入</strong></p><p>依赖注入和控制反转恰恰相反，它是一种具体的编码技巧。我们不通过new的方式在类内部创建依赖类的对象，而是将依赖的类对象在外部创建好之后，通过构造函数、函数参数等方式传递（或注入）给类来使用。</p><p><strong>3.依赖注入框架</strong></p><p>我们通过依赖注入框架提供的扩展点，简单配置一下所有需要的类及其类与类之间依赖关系，就可以实现由框架来自动创建对象、管理对象的生命周期、依赖注入等原本需要程序员来做的事情。</p><p><strong>4.依赖反转原则</strong></p><p>依赖反转原则也叫作依赖倒置原则。这条原则跟控制反转有点类似，主要用来指导框架层面的设计。高层模块不依赖低层模块，它们共同依赖同一个抽象。抽象不要依赖具体实现细节，具体实现细节依赖抽象。</p><h2>课堂讨论</h2><p>从Notification这个例子来看，“基于接口而非实现编程”跟“依赖注入”，看起来非常类似，那它俩有什么区别和联系呢？</p><p>欢迎在留言区写下你的答案，和同学一起交流和分享。如果有收获，也欢迎你把这篇文章分享给你的朋友。</p>",
                "article_title": "19 | 理论五：控制反转、依赖反转、依赖注入，这三者有何区别和联系？"
            },
            {
                "title": "20 | 理论六：我为何说KISS、YAGNI原则看似简单，却经常被用错？",
                "herf": "https://time.geekbang.org/column/article/177448",
                "id": "177448",
                "content": "<p>上几节课中，我们学习了经典的SOLID原则。今天，我们讲两个设计原则：KISS原则和YAGNI原则。其中，KISS原则比较经典，耳熟能详，但YAGNI你可能没怎么听过，不过它理解起来也不难。</p><p>理解这两个原则时候，经常会有一个共同的问题，那就是，看一眼就感觉懂了，但深究的话，又有很多细节问题不是很清楚。比如，怎么理解KISS原则中“简单”两个字？什么样的代码才算“简单”？怎样的代码才算“复杂”？如何才能写出“简单”的代码？YAGNI原则跟KISS原则说的是一回事吗？</p><p>如果你还不能非常清晰地回答出上面这几个问题，那恭喜你，又得到了一次进步提高的机会。等你听完这节课，我相信你很自然就能回答上来了。话不多说，让我们带着这些问题，正式开始今天的学习吧！</p><h2>如何理解“KISS原则”？</h2><p>KISS原则的英文描述有好几个版本，比如下面这几个。</p><ul>\n<li>Keep It Simple and Stupid.</li>\n<li>Keep It Short and Simple.</li>\n<li>Keep It Simple and Straightforward.</li>\n</ul><p>不过，仔细看你就会发现，它们要表达的意思其实差不多，翻译成中文就是：尽量保持简单。</p><p>KISS原则算是一个万金油类型的设计原则，可以应用在很多场景中。它不仅经常用来指导软件开发，还经常用来指导更加广泛的系统设计、产品设计等，比如，冰箱、建筑、iPhone手机的设计等等。不过，咱们的专栏是讲代码设计的，所以，接下来，我还是重点讲解如何在编码开发中应用这条原则。</p><!-- [[[read_end]]] --><p>我们知道，代码的可读性和可维护性是衡量代码质量非常重要的两个标准。而KISS原则就是保持代码可读和可维护的重要手段。代码足够简单，也就意味着很容易读懂，bug比较难隐藏。即便出现bug，修复起来也比较简单。</p><p>不过，这条原则只是告诉我们，要保持代码“Simple and Stupid”，但并没有讲到，什么样的代码才是“Simple and Stupid”的，更没有给出特别明确的方法论，来指导如何开发出“Simple and Stupid”的代码。所以，看着非常简单，但不能落地，这就有点像我们常说的“心灵鸡汤”。哦，咱们这里应该叫“技术鸡汤”。</p><p>所以，接下来，为了能让这条原则切实地落地，能够指导实际的项目开发，我就针对刚刚的这些问题来进一步讲讲我的理解。</p><h2>代码行数越少就越“简单”吗？</h2><p>我们先一起看一个例子。下面这三段代码可以实现同样一个功能：检查输入的字符串ipAddress是否是合法的IP地址。</p><p>一个合法的IP地址由四个数字组成，并且通过“.”来进行分割。每组数字的取值范围是0~255。第一组数字比较特殊，不允许为0。对比这三段代码，你觉得哪一段代码最符合KISS原则呢？如果让你来实现这个功能，你会选择用哪种实现方法呢？你可以先自己思考一下，然后再看我下面的讲解。</p><pre><code>// 第一种实现方式: 使用正则表达式\npublic boolean isValidIpAddressV1(String ipAddress) {\n  if (StringUtils.isBlank(ipAddress)) return false;\n  String regex = &quot;^(1\\\\d{2}|2[0-4]\\\\d|25[0-5]|[1-9]\\\\d|[1-9])\\\\.&quot;\n          + &quot;(1\\\\d{2}|2[0-4]\\\\d|25[0-5]|[1-9]\\\\d|\\\\d)\\\\.&quot;\n          + &quot;(1\\\\d{2}|2[0-4]\\\\d|25[0-5]|[1-9]\\\\d|\\\\d)\\\\.&quot;\n          + &quot;(1\\\\d{2}|2[0-4]\\\\d|25[0-5]|[1-9]\\\\d|\\\\d)$&quot;;\n  return ipAddress.matches(regex);\n}\n\n// 第二种实现方式: 使用现成的工具类\npublic boolean isValidIpAddressV2(String ipAddress) {\n  if (StringUtils.isBlank(ipAddress)) return false;\n  String[] ipUnits = StringUtils.split(ipAddress, '.');\n  if (ipUnits.length != 4) {\n    return false;\n  }\n  for (int i = 0; i &lt; 4; ++i) {\n    int ipUnitIntValue;\n    try {\n      ipUnitIntValue = Integer.parseInt(ipUnits[i]);\n    } catch (NumberFormatException e) {\n      return false;\n    }\n    if (ipUnitIntValue &lt; 0 || ipUnitIntValue &gt; 255) {\n      return false;\n    }\n    if (i == 0 &amp;&amp; ipUnitIntValue == 0) {\n      return false;\n    }\n  }\n  return true;\n}\n\n// 第三种实现方式: 不使用任何工具类\npublic boolean isValidIpAddressV3(String ipAddress) {\n  char[] ipChars = ipAddress.toCharArray();\n  int length = ipChars.length;\n  int ipUnitIntValue = -1;\n  boolean isFirstUnit = true;\n  int unitsCount = 0;\n  for (int i = 0; i &lt; length; ++i) {\n    char c = ipChars[i];\n    if (c == '.') {\n      if (ipUnitIntValue &lt; 0 || ipUnitIntValue &gt; 255) return false;\n      if (isFirstUnit &amp;&amp; ipUnitIntValue == 0) return false;\n      if (isFirstUnit) isFirstUnit = false;\n      ipUnitIntValue = -1;\n      unitsCount++;\n      continue;\n    }\n    if (c &lt; '0' || c &gt; '9') {\n      return false;\n    }\n    if (ipUnitIntValue == -1) ipUnitIntValue = 0;\n    ipUnitIntValue = ipUnitIntValue * 10 + (c - '0');\n  }\n  if (ipUnitIntValue &lt; 0 || ipUnitIntValue &gt; 255) return false;\n  if (unitsCount != 3) return false;\n  return true;\n}\n</code></pre><p>第一种实现方式利用的是正则表达式，只用三行代码就把这个问题搞定了。它的代码行数最少，那是不是就最符合KISS原则呢？答案是否定的。虽然代码行数最少，看似最简单，实际上却很复杂。这正是因为它使用了正则表达式。</p><p>一方面，正则表达式本身是比较复杂的，写出完全没有bug的正则表达本身就比较有挑战；另一方面，并不是每个程序员都精通正则表达式。对于不怎么懂正则表达式的同事来说，看懂并且维护这段正则表达式是比较困难的。这种实现方式会导致代码的可读性和可维护性变差，所以，从KISS原则的设计初衷上来讲，这种实现方式并不符合KISS原则。</p><p>讲完了第一种实现方式，我们再来看下其他两种实现方式。</p><p>第二种实现方式使用了StringUtils类、Integer类提供的一些现成的工具函数，来处理IP地址字符串。第三种实现方式，不使用任何工具函数，而是通过逐一处理IP地址中的字符，来判断是否合法。从代码行数上来说，这两种方式差不多。但是，第三种要比第二种更加有难度，更容易写出bug。从可读性上来说，第二种实现方式的代码逻辑更清晰、更好理解。所以，在这两种实现方式中，第二种实现方式更加“简单”，更加符合KISS原则。</p><p>不过，你可能会说，第三种实现方式虽然实现起来稍微有点复杂，但性能要比第二种实现方式高一些啊。从性能的角度来说，选择第三种实现方式是不是更好些呢？</p><p>在回答这个问题之前，我先解释一下，为什么说第三种实现方式性能会更高一些。一般来说，工具类的功能都比较通用和全面，所以，在代码实现上，需要考虑和处理更多的细节，执行效率就会有所影响。而第三种实现方式，完全是自己操作底层字符，只针对IP地址这一种格式的数据输入来做处理，没有太多多余的函数调用和其他不必要的处理逻辑，所以，在执行效率上，这种类似定制化的处理代码方式肯定比通用的工具类要高些。</p><p>不过，尽管第三种实现方式性能更高些，但我还是更倾向于选择第二种实现方法。那是因为第三种实现方式实际上是一种过度优化。除非isValidIpAddress()函数是影响系统性能的瓶颈代码，否则，这样优化的投入产出比并不高，增加了代码实现的难度、牺牲了代码的可读性，性能上的提升却并不明显。</p><h2>代码逻辑复杂就违背KISS原则吗？</h2><p>刚刚我们提到，并不是代码行数越少就越“简单”，还要考虑逻辑复杂度、实现难度、代码的可读性等。那如果一段代码的逻辑复杂、实现难度大、可读性也不太好，是不是就一定违背KISS原则呢？在回答这个问题之前，我们先来看下面这段代码：</p><pre><code>// KMP algorithm: a, b分别是主串和模式串；n, m分别是主串和模式串的长度。\npublic static int kmp(char[] a, int n, char[] b, int m) {\n  int[] next = getNexts(b, m);\n  int j = 0;\n  for (int i = 0; i &lt; n; ++i) {\n    while (j &gt; 0 &amp;&amp; a[i] != b[j]) { // 一直找到a[i]和b[j]\n      j = next[j - 1] + 1;\n    }\n    if (a[i] == b[j]) {\n      ++j;\n    }\n    if (j == m) { // 找到匹配模式串的了\n      return i - m + 1;\n    }\n  }\n  return -1;\n}\n\n// b表示模式串，m表示模式串的长度\nprivate static int[] getNexts(char[] b, int m) {\n  int[] next = new int[m];\n  next[0] = -1;\n  int k = -1;\n  for (int i = 1; i &lt; m; ++i) {\n    while (k != -1 &amp;&amp; b[k + 1] != b[i]) {\n      k = next[k];\n    }\n    if (b[k + 1] == b[i]) {\n      ++k;\n    }\n    next[i] = k;\n  }\n  return next;\n}\n</code></pre><p>这段代码来自我的另一个专栏《数据结构与算法之美》中<a href=\"https://time.geekbang.org/column/article/71845\">KMP字符串匹配算法</a>的代码实现。这段代码完全符合我们刚提到的逻辑复杂、实现难度大、可读性差的特点，但它并不违反KISS原则。为什么这么说呢？</p><p>KMP算法以快速高效著称。当我们需要处理长文本字符串匹配问题（几百MB大小文本内容的匹配），或者字符串匹配是某个产品的核心功能（比如Vim、Word等文本编辑器），又或者字符串匹配算法是系统性能瓶颈的时候，我们就应该选择尽可能高效的KMP算法。而KMP算法本身具有逻辑复杂、实现难度大、可读性差的特点。本身就复杂的问题，用复杂的方法解决，并不违背KISS原则。</p><p>不过，平时的项目开发中涉及的字符串匹配问题，大部分都是针对比较小的文本。在这种情况下，直接调用编程语言提供的现成的字符串匹配函数就足够了。如果非得用KMP算法、BM算法来实现字符串匹配，那就真的违背KISS原则了。也就是说，同样的代码，在某个业务场景下满足KISS原则，换一个应用场景可能就不满足了。</p><h2>如何写出满足KISS原则的代码？</h2><p>实际上，我们前面已经讲到了一些方法。这里我稍微总结一下。</p><ul>\n<li>不要使用同事可能不懂的技术来实现代码。比如前面例子中的正则表达式，还有一些编程语言中过于高级的语法等。</li>\n<li>不要重复造轮子，要善于使用已经有的工具类库。经验证明，自己去实现这些类库，出bug的概率会更高，维护的成本也比较高。</li>\n<li>不要过度优化。不要过度使用一些奇技淫巧（比如，位运算代替算术运算、复杂的条件语句代替if-else、使用一些过于底层的函数等）来优化代码，牺牲代码的可读性。</li>\n</ul><p>实际上，代码是否足够简单是一个挺主观的评判。同样的代码，有的人觉得简单，有的人觉得不够简单。而往往自己编写的代码，自己都会觉得够简单。所以，评判代码是否简单，还有一个很有效的间接方法，那就是code review。如果在code review的时候，同事对你的代码有很多疑问，那就说明你的代码有可能不够“简单”，需要优化啦。</p><p>这里我还想多说两句，我们在做开发的时候，一定不要过度设计，不要觉得简单的东西就没有技术含量。实际上，越是能用简单的方法解决复杂的问题，越能体现一个人的能力。</p><h2>YAGNI跟KISS说的是一回事吗？</h2><p>YAGNI原则的英文全称是：You Ain’t Gonna Need It。直译就是：你不会需要它。这条原则也算是万金油了。当用在软件开发中的时候，它的意思是：不要去设计当前用不到的功能；不要去编写当前用不到的代码。实际上，这条原则的核心思想就是：不要做过度设计。</p><p>比如，我们的系统暂时只用Redis存储配置信息，以后可能会用到ZooKeeper。根据YAGNI原则，在未用到ZooKeeper之前，我们没必要提前编写这部分代码。当然，这并不是说我们就不需要考虑代码的扩展性。我们还是要预留好扩展点，等到需要的时候，再去实现ZooKeeper存储配置信息这部分代码。</p><p>再比如，我们不要在项目中提前引入不需要依赖的开发包。对于Java程序员来说，我们经常使用Maven或者Gradle来管理依赖的类库（library）。我发现，有些同事为了避免开发中library包缺失而频繁地修改Maven或者Gradle配置文件，提前往项目里引入大量常用的library包。实际上，这样的做法也是违背YAGNI原则的。</p><p>从刚刚的分析我们可以看出，YAGNI原则跟KISS原则并非一回事儿。KISS原则讲的是“如何做”的问题（尽量保持简单），而YAGNI原则说的是“要不要做”的问题（当前不需要的就不要做）。</p><h2>重点回顾</h2><p>好了，今天的内容到此就讲完了。我们现在来总结回顾一下，你需要掌握的重点内容。</p><p>KISS原则是保持代码可读和可维护的重要手段。KISS原则中的“简单”并不是以代码行数来考量的。代码行数越少并不代表代码越简单，我们还要考虑逻辑复杂度、实现难度、代码的可读性等。而且，本身就复杂的问题，用复杂的方法解决，并不违背KISS原则。除此之外，同样的代码，在某个业务场景下满足KISS原则，换一个应用场景可能就不满足了。</p><p>对于如何写出满足KISS原则的代码，我还总结了下面几条指导原则：</p><ul>\n<li>不要使用同事可能不懂的技术来实现代码；</li>\n<li>不要重复造轮子，要善于使用已经有的工具类库；</li>\n<li>不要过度优化。</li>\n</ul><h2>课堂讨论</h2><p>你怎么看待在开发中重复造轮子这件事情？什么时候要重复造轮子？什么时候应该使用现成的工具类库、开源框架？</p><p>欢迎在留言区写下你的答案，和同学一起交流和分享。如果有收获，也欢迎你把这篇文章分享给你的朋友。</p>",
                "article_title": "20 | 理论六：我为何说KISS、YAGNI原则看似简单，却经常被用错？"
            },
            {
                "title": "21 | 理论七：重复的代码就一定违背DRY吗？如何提高代码的复用性？",
                "herf": "https://time.geekbang.org/column/article/179607",
                "id": "179607",
                "content": "<p>在上一节课中，我们讲了KISS原则和YAGNI原则，KISS原则可以说是人尽皆知。今天，我们再学习一个你肯定听过的原则，那就是DRY原则。它的英文描述为：Don’t Repeat Yourself。中文直译为：不要重复自己。将它应用在编程中，可以理解为：不要写重复的代码。</p><p>你可能会觉得，这条原则非常简单、非常容易应用。只要两段代码长得一样，那就是违反DRY原则了。真的是这样吗？答案是否定的。这是很多人对这条原则存在的误解。实际上，重复的代码不一定违反DRY原则，而且有些看似不重复的代码也有可能违反DRY原则。</p><p>听到这里，你可能会有很多疑问。没关系，今天我会结合具体的代码实例，来把这个问题讲清楚，纠正你对这个原则的错误认知。除此之外，DRY原则与代码的复用性也有一些联系，所以，今天，我还会讲一讲，如何写出可复用性好的代码。</p><p>话不多说，让我们正式开始今天的学习吧！</p><h2>DRY原则（Don’t Repeat Yourself）</h2><p>DRY原则的定义非常简单，我就不再过度解读。今天，我们主要讲三种典型的代码重复情况，它们分别是：实现逻辑重复、功能语义重复和代码执行重复。这三种代码重复，有的看似违反DRY，实际上并不违反；有的看似不违反，实际上却违反了。</p><!-- [[[read_end]]] --><h3>实现逻辑重复</h3><p>我们先来看下面这样一段代码是否违反了DRY原则。如果违反了，你觉得应该如何重构，才能让它满足DRY原则？如果没有违反，那又是为什么呢？</p><pre><code>public class UserAuthenticator {\n  public void authenticate(String username, String password) {\n    if (!isValidUsername(username)) {\n      // ...throw InvalidUsernameException...\n    }\n    if (!isValidPassword(password)) {\n      // ...throw InvalidPasswordException...\n    }\n    //...省略其他代码...\n  }\n\n  private boolean isValidUsername(String username) {\n    // check not null, not empty\n    if (StringUtils.isBlank(username)) {\n      return false;\n    }\n    // check length: 4~64\n    int length = username.length();\n    if (length &lt; 4 || length &gt; 64) {\n      return false;\n    }\n    // contains only lowcase characters\n    if (!StringUtils.isAllLowerCase(username)) {\n      return false;\n    }\n    // contains only a~z,0~9,dot\n    for (int i = 0; i &lt; length; ++i) {\n      char c = username.charAt(i);\n      if (!(c &gt;= 'a' &amp;&amp; c &lt;= 'z') || (c &gt;= '0' &amp;&amp; c &lt;= '9') || c == '.') {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  private boolean isValidPassword(String password) {\n    // check not null, not empty\n    if (StringUtils.isBlank(password)) {\n      return false;\n    }\n    // check length: 4~64\n    int length = password.length();\n    if (length &lt; 4 || length &gt; 64) {\n      return false;\n    }\n    // contains only lowcase characters\n    if (!StringUtils.isAllLowerCase(password)) {\n      return false;\n    }\n    // contains only a~z,0~9,dot\n    for (int i = 0; i &lt; length; ++i) {\n      char c = password.charAt(i);\n      if (!(c &gt;= 'a' &amp;&amp; c &lt;= 'z') || (c &gt;= '0' &amp;&amp; c &lt;= '9') || c == '.') {\n        return false;\n      }\n    }\n    return true;\n  }\n}\n</code></pre><p>代码很简单，我就不做过多解释了。在代码中，有两处非常明显的重复的代码片段：isValidUserName()函数和isValidPassword()函数。重复的代码被敲了两遍，或者简单copy-paste了一下，看起来明显违反DRY原则。为了移除重复的代码，我们对上面的代码做下重构，将isValidUserName()函数和isValidPassword()函数，合并为一个更通用的函数isValidUserNameOrPassword()。重构后的代码如下所示：</p><pre><code>public class UserAuthenticatorV2 {\n\n  public void authenticate(String userName, String password) {\n    if (!isValidUsernameOrPassword(userName)) {\n      // ...throw InvalidUsernameException...\n    }\n\n    if (!isValidUsernameOrPassword(password)) {\n      // ...throw InvalidPasswordException...\n    }\n  }\n\n  private boolean isValidUsernameOrPassword(String usernameOrPassword) {\n    //省略实现逻辑\n    //跟原来的isValidUsername()或isValidPassword()的实现逻辑一样...\n    return true;\n  }\n}\n</code></pre><p>经过重构之后，代码行数减少了，也没有重复的代码了，是不是更好了呢？答案是否定的，这可能跟你预期的不一样，我来解释一下为什么。</p><p>单从名字上看，我们就能发现，合并之后的isValidUserNameOrPassword()函数，负责两件事情：验证用户名和验证密码，违反了“单一职责原则”和“接口隔离原则”。实际上，即便将两个函数合并成isValidUserNameOrPassword()，代码仍然存在问题。</p><p>因为isValidUserName()和isValidPassword()两个函数，虽然从代码实现逻辑上看起来是重复的，但是从语义上并不重复。所谓“语义不重复”指的是：从功能上来看，这两个函数干的是完全不重复的两件事情，一个是校验用户名，另一个是校验密码。尽管在目前的设计中，两个校验逻辑是完全一样的，但如果按照第二种写法，将两个函数的合并，那就会存在潜在的问题。在未来的某一天，如果我们修改了密码的校验逻辑，比如，允许密码包含大写字符，允许密码的长度为8到64个字符，那这个时候，isValidUserName()和isValidPassword()的实现逻辑就会不相同。我们就要把合并后的函数，重新拆成合并前的那两个函数。</p><p>尽管代码的实现逻辑是相同的，但语义不同，我们判定它并不违反DRY原则。对于包含重复代码的问题，我们可以通过抽象成更细粒度函数的方式来解决。比如将校验只包含a~z、0~9、dot的逻辑封装成boolean onlyContains(String str, String charlist);函数。</p><h3>功能语义重复</h3><p>现在我们再来看另外一个例子。在同一个项目代码中有下面两个函数：isValidIp()和checkIfIpValid()。尽管两个函数的命名不同，实现逻辑不同，但功能是相同的，都是用来判定IP地址是否合法的。</p><p>之所以在同一个项目中会有两个功能相同的函数，那是因为这两个函数是由两个不同的同事开发的，其中一个同事在不知道已经有了isValidIp()的情况下，自己又定义并实现了同样用来校验IP地址是否合法的checkIfIpValid()函数。</p><p>那在同一项目代码中，存在如下两个函数，是否违反DRY原则呢？</p><pre><code>public boolean isValidIp(String ipAddress) {\n  if (StringUtils.isBlank(ipAddress)) return false;\n  String regex = &quot;^(1\\\\d{2}|2[0-4]\\\\d|25[0-5]|[1-9]\\\\d|[1-9])\\\\.&quot;\n          + &quot;(1\\\\d{2}|2[0-4]\\\\d|25[0-5]|[1-9]\\\\d|\\\\d)\\\\.&quot;\n          + &quot;(1\\\\d{2}|2[0-4]\\\\d|25[0-5]|[1-9]\\\\d|\\\\d)\\\\.&quot;\n          + &quot;(1\\\\d{2}|2[0-4]\\\\d|25[0-5]|[1-9]\\\\d|\\\\d)$&quot;;\n  return ipAddress.matches(regex);\n}\n\npublic boolean checkIfIpValid(String ipAddress) {\n  if (StringUtils.isBlank(ipAddress)) return false;\n  String[] ipUnits = StringUtils.split(ipAddress, '.');\n  if (ipUnits.length != 4) {\n    return false;\n  }\n  for (int i = 0; i &lt; 4; ++i) {\n    int ipUnitIntValue;\n    try {\n      ipUnitIntValue = Integer.parseInt(ipUnits[i]);\n    } catch (NumberFormatException e) {\n      return false;\n    }\n    if (ipUnitIntValue &lt; 0 || ipUnitIntValue &gt; 255) {\n      return false;\n    }\n    if (i == 0 &amp;&amp; ipUnitIntValue == 0) {\n      return false;\n    }\n  }\n  return true;\n}\n</code></pre><p>这个例子跟上个例子正好相反。上一个例子是代码实现逻辑重复，但语义不重复，我们并不认为它违反了DRY原则。而在这个例子中，尽管两段代码的实现逻辑不重复，但语义重复，也就是功能重复，我们认为它违反了DRY原则。我们应该在项目中，统一一种实现思路，所有用到判断IP地址是否合法的地方，都统一调用同一个函数。</p><p>假设我们不统一实现思路，那有些地方调用了isValidIp()函数，有些地方又调用了checkIfIpValid()函数，这就会导致代码看起来很奇怪，相当于给代码“埋坑”，给不熟悉这部分代码的同事增加了阅读的难度。同事有可能研究了半天，觉得功能是一样的，但又有点疑惑，觉得是不是有更高深的考量，才定义了两个功能类似的函数，最终发现居然是代码设计的问题。</p><p>除此之外，如果哪天项目中IP地址是否合法的判定规则改变了，比如：255.255.255.255不再被判定为合法的了，相应地，我们对isValidIp()的实现逻辑做了相应的修改，但却忘记了修改checkIfIpValid()函数。又或者，我们压根就不知道还存在一个功能相同的checkIfIpValid()函数，这样就会导致有些代码仍然使用老的IP地址判断逻辑，导致出现一些莫名其妙的bug。</p><h3>代码执行重复</h3><p>前两个例子一个是实现逻辑重复，一个是语义重复，我们再来看第三个例子。其中，UserService中login()函数用来校验用户登录是否成功。如果失败，就返回异常；如果成功，就返回用户信息。具体代码如下所示：</p><pre><code>public class UserService {\n  private UserRepo userRepo;//通过依赖注入或者IOC框架注入\n\n  public User login(String email, String password) {\n    boolean existed = userRepo.checkIfUserExisted(email, password);\n    if (!existed) {\n      // ... throw AuthenticationFailureException...\n    }\n    User user = userRepo.getUserByEmail(email);\n    return user;\n  }\n}\n\npublic class UserRepo {\n  public boolean checkIfUserExisted(String email, String password) {\n    if (!EmailValidation.validate(email)) {\n      // ... throw InvalidEmailException...\n    }\n\n    if (!PasswordValidation.validate(password)) {\n      // ... throw InvalidPasswordException...\n    }\n\n    //...query db to check if email&amp;password exists...\n  }\n\n  public User getUserByEmail(String email) {\n    if (!EmailValidation.validate(email)) {\n      // ... throw InvalidEmailException...\n    }\n    //...query db to get user by email...\n  }\n}\n</code></pre><p>上面这段代码，既没有逻辑重复，也没有语义重复，但仍然违反了DRY原则。这是因为代码中存在“执行重复”。我们一块儿来看下，到底哪些代码被重复执行了？</p><p>重复执行最明显的一个地方，就是在login()函数中，email的校验逻辑被执行了两次。一次是在调用checkIfUserExisted()函数的时候，另一次是调用getUserByEmail()函数的时候。这个问题解决起来比较简单，我们只需要将校验逻辑从UserRepo中移除，统一放到UserService中就可以了。</p><p>除此之外，代码中还有一处比较隐蔽的执行重复，不知道你发现了没有？实际上，login()函数并不需要调用checkIfUserExisted()函数，只需要调用一次getUserByEmail()函数，从数据库中获取到用户的email、password等信息，然后跟用户输入的email、password信息做对比，依次判断是否登录成功。</p><p>实际上，这样的优化是很有必要的。因为checkIfUserExisted()函数和getUserByEmail()函数都需要查询数据库，而数据库这类的I/O操作是比较耗时的。我们在写代码的时候，应当尽量减少这类I/O操作。</p><p>按照刚刚的修改思路，我们把代码重构一下，移除“重复执行”的代码，只校验一次email和password，并且只查询一次数据库。重构之后的代码如下所示：</p><pre><code>public class UserService {\n  private UserRepo userRepo;//通过依赖注入或者IOC框架注入\n\n  public User login(String email, String password) {\n    if (!EmailValidation.validate(email)) {\n      // ... throw InvalidEmailException...\n    }\n    if (!PasswordValidation.validate(password)) {\n      // ... throw InvalidPasswordException...\n    }\n    User user = userRepo.getUserByEmail(email);\n    if (user == null || !password.equals(user.getPassword()) {\n      // ... throw AuthenticationFailureException...\n    }\n    return user;\n  }\n}\n\npublic class UserRepo {\n  public boolean checkIfUserExisted(String email, String password) {\n    //...query db to check if email&amp;password exists\n  }\n\n  public User getUserByEmail(String email) {\n    //...query db to get user by email...\n  }\n}\n</code></pre><h2>代码复用性（Code Reusability）</h2><p>在专栏的最开始，我们有提到，代码的复用性是评判代码质量的一个非常重要的标准。当时只是点到为止，没有展开讲解，今天，我再带你深入地学习一下这个知识点。</p><h3>什么是代码的复用性？</h3><p>我们首先来区分三个概念：代码复用性（Code Reusability）、代码复用（Code Resue）和DRY原则。</p><p>代码复用表示一种行为：我们在开发新功能的时候，尽量复用已经存在的代码。代码的可复用性表示一段代码可被复用的特性或能力：我们在编写代码的时候，让代码尽量可复用。DRY原则是一条原则：不要写重复的代码。从定义描述上，它们好像有点类似，但深究起来，三者的区别还是蛮大的。</p><p><strong>首先，“不重复”并不代表“可复用”。</strong>在一个项目代码中，可能不存在任何重复的代码，但也并不表示里面有可复用的代码，不重复和可复用完全是两个概念。所以，从这个角度来说，DRY原则跟代码的可复用性讲的是两回事。</p><p><strong>其次，“复用”和“可复用性”关注角度不同。</strong>代码“可复用性”是从代码开发者的角度来讲的，“复用”是从代码使用者的角度来讲的。比如，A同事编写了一个UrlUtils类，代码的“可复用性”很好。B同事在开发新功能的时候，直接“复用”A同事编写的UrlUtils类。</p><p>尽管复用、可复用性、DRY原则这三者从理解上有所区别，但实际上要达到的目的都是类似的，都是为了减少代码量，提高代码的可读性、可维护性。除此之外，复用已经经过测试的老代码，bug会比从零重新开发要少。</p><p>“复用”这个概念不仅可以指导细粒度的模块、类、函数的设计开发，实际上，一些框架、类库、组件等的产生也都是为了达到复用的目的。比如，Spring框架、Google Guava类库、UI组件等等。</p><h3>怎么提高代码复用性？</h3><p>实际上，我们前面已经讲到过很多提高代码可复用性的手段，今天算是集中总结一下，我总结了7条，具体如下。</p><ul>\n<li>减少代码耦合</li>\n</ul><p>对于高度耦合的代码，当我们希望复用其中的一个功能，想把这个功能的代码抽取出来成为一个独立的模块、类或者函数的时候，往往会发现牵一发而动全身。移动一点代码，就要牵连到很多其他相关的代码。所以，高度耦合的代码会影响到代码的复用性，我们要尽量减少代码耦合。</p><ul>\n<li>满足单一职责原则</li>\n</ul><p>我们前面讲过，如果职责不够单一，模块、类设计得大而全，那依赖它的代码或者它依赖的代码就会比较多，进而增加了代码的耦合。根据上一点，也就会影响到代码的复用性。相反，越细粒度的代码，代码的通用性会越好，越容易被复用。</p><ul>\n<li>模块化</li>\n</ul><p>这里的“模块”，不单单指一组类构成的模块，还可以理解为单个类、函数。我们要善于将功能独立的代码，封装成模块。独立的模块就像一块一块的积木，更加容易复用，可以直接拿来搭建更加复杂的系统。</p><ul>\n<li>业务与非业务逻辑分离</li>\n</ul><p>越是跟业务无关的代码越是容易复用，越是针对特定业务的代码越难复用。所以，为了复用跟业务无关的代码，我们将业务和非业务逻辑代码分离，抽取成一些通用的框架、类库、组件等。</p><ul>\n<li>通用代码下沉</li>\n</ul><p>从分层的角度来看，越底层的代码越通用、会被越多的模块调用，越应该设计得足够可复用。一般情况下，在代码分层之后，为了避免交叉调用导致调用关系混乱，我们只允许上层代码调用下层代码及同层代码之间的调用，杜绝下层代码调用上层代码。所以，通用的代码我们尽量下沉到更下层。</p><ul>\n<li>继承、多态、抽象、封装</li>\n</ul><p>在讲面向对象特性的时候，我们讲到，利用继承，可以将公共的代码抽取到父类，子类复用父类的属性和方法。利用多态，我们可以动态地替换一段代码的部分逻辑，让这段代码可复用。除此之外，抽象和封装，从更加广义的层面、而非狭义的面向对象特性的层面来理解的话，越抽象、越不依赖具体的实现，越容易复用。代码封装成模块，隐藏可变的细节、暴露不变的接口，就越容易复用。</p><ul>\n<li>应用模板等设计模式</li>\n</ul><p>一些设计模式，也能提高代码的复用性。比如，模板模式利用了多态来实现，可以灵活地替换其中的部分代码，整个流程模板代码可复用。关于应用设计模式提高代码复用性这一部分，我们留在后面慢慢来讲解。</p><p>除了刚刚我们讲到的几点，还有一些跟编程语言相关的特性，也能提高代码的复用性，比如泛型编程等。实际上，除了上面讲到的这些方法之外，复用意识也非常重要。在写代码的时候，我们要多去思考一下，这个部分代码是否可以抽取出来，作为一个独立的模块、类或者函数供多处使用。在设计每个模块、类、函数的时候，要像设计一个外部API那样，去思考它的复用性。</p><h3>辩证思考和灵活应用</h3><p>实际上，编写可复用的代码并不简单。如果我们在编写代码的时候，已经有复用的需求场景，那根据复用的需求去开发可复用的代码，可能还不算难。但是，如果当下并没有复用的需求，我们只是希望现在编写的代码具有可复用的特点，能在未来某个同事开发某个新功能的时候复用得上。在这种没有具体复用需求的情况下，我们就需要去预测将来代码会如何复用，这就比较有挑战了。</p><p>实际上，除非有非常明确的复用需求，否则，为了暂时用不到的复用需求，花费太多的时间、精力，投入太多的开发成本，并不是一个值得推荐的做法。这也违反我们之前讲到的YAGNI原则。</p><p>除此之外，有一个著名的原则，叫作“Rule of Three”。这条原则可以用在很多行业和场景中，你可以自己去研究一下。如果把这个原则用在这里，那就是说，我们在第一次写代码的时候，如果当下没有复用的需求，而未来的复用需求也不是特别明确，并且开发可复用代码的成本比较高，那我们就不需要考虑代码的复用性。在之后我们开发新的功能的时候，发现可以复用之前写的这段代码，那我们就重构这段代码，让其变得更加可复用。</p><p>也就是说，第一次编写代码的时候，我们不考虑复用性；第二次遇到复用场景的时候，再进行重构使其复用。需要注意的是，“Rule of Three”中的“Three”并不是真的就指确切的“三”，这里就是指“二”。</p><h2>重点回顾</h2><p>今天的内容到此就讲完了。我们一块来回顾一下，你需要重点掌握的内容。</p><p><strong>1.DRY原则</strong></p><p>我们今天讲了三种代码重复的情况：实现逻辑重复、功能语义重复、代码执行重复。实现逻辑重复，但功能语义不重复的代码，并不违反DRY原则。实现逻辑不重复，但功能语义重复的代码，也算是违反DRY原则。除此之外，代码执行重复也算是违反DRY原则。</p><p><strong>2.代码复用性</strong></p><p>今天，我们讲到提高代码可复用性的一些方法，有以下7点。</p><ul>\n<li>减少代码耦合</li>\n<li>满足单一职责原则</li>\n<li>模块化</li>\n<li>业务与非业务逻辑分离</li>\n<li>通用代码下沉</li>\n<li>继承、多态、抽象、封装</li>\n<li>应用模板等设计模式</li>\n</ul><p>实际上，除了上面讲到的这些方法之外，复用意识也非常重要。在设计每个模块、类、函数的时候，要像设计一个外部API一样去思考它的复用性。</p><p>我们在第一次写代码的时候，如果当下没有复用的需求，而未来的复用需求也不是特别明确，并且开发可复用代码的成本比较高，那我们就不需要考虑代码的复用性。在之后开发新的功能的时候，发现可以复用之前写的这段代码，那我们就重构这段代码，让其变得更加可复用。</p><p>相比于代码的可复用性，DRY原则适用性更强一些。我们可以不写可复用的代码，但一定不能写重复的代码。</p><h2>课堂讨论</h2><p>除了实现逻辑重复、功能语义重复、代码执行重复，你还知道有哪些其他类型的代码重复？这些代码重复是否违反DRY原则？</p><p>欢迎在留言区写下你的想法，和同学一起交流和分享。如果有收获，也欢迎你把这篇文章分享给你的朋友。</p>",
                "article_title": "21 | 理论七：重复的代码就一定违背DRY吗？如何提高代码的复用性？"
            },
            {
                "title": "22 | 理论八：如何用迪米特法则（LOD）实现“高内聚、松耦合”？",
                "herf": "https://time.geekbang.org/column/article/179615",
                "id": "179615",
                "content": "<p>今天，我们讲最后一个设计原则：迪米特法则。尽管它不像SOLID、KISS、DRY原则那样，人尽皆知，但它却非常实用。利用这个原则，能够帮我们实现代码的“高内聚、松耦合”。今天，我们就围绕下面几个问题，并结合两个代码实战案例，来深入地学习这个法则。</p><ul>\n<li>什么是“高内聚、松耦合”？</li>\n<li>如何利用迪米特法则来实现“高内聚、松耦合”？</li>\n<li>有哪些代码设计是明显违背迪米特法则的？对此又该如何重构？</li>\n</ul><p>话不多说，让我们开始今天的学习吧！</p><h2>何为“高内聚、松耦合”？</h2><p>“高内聚、松耦合”是一个非常重要的设计思想，能够有效地提高代码的可读性和可维护性，缩小功能改动导致的代码改动范围。实际上，在前面的章节中，我们已经多次提到过这个设计思想。很多设计原则都以实现代码的“高内聚、松耦合”为目的，比如单一职责原则、基于接口而非实现编程等。</p><p>实际上，“高内聚、松耦合”是一个比较通用的设计思想，可以用来指导不同粒度代码的设计与开发，比如系统、模块、类，甚至是函数，也可以应用到不同的开发场景中，比如微服务、框架、组件、类库等。为了方便我讲解，接下来我以“类”作为这个设计思想的应用对象来展开讲解，其他应用场景你可以自行类比。</p><p>在这个设计思想中，“高内聚”用来指导类本身的设计，“松耦合”用来指导类与类之间依赖关系的设计。不过，这两者并非完全独立不相干。高内聚有助于松耦合，松耦合又需要高内聚的支持。</p><!-- [[[read_end]]] --><p><strong>那到底什么是“高内聚”呢？</strong></p><p>所谓高内聚，就是指相近的功能应该放到同一个类中，不相近的功能不要放到同一个类中。相近的功能往往会被同时修改，放到同一个类中，修改会比较集中，代码容易维护。实际上，我们前面讲过的单一职责原则是实现代码高内聚非常有效的设计原则。对于这一点，你可以回过头再去看下专栏的<a href=\"https://time.geekbang.org/column/article/171771?utm_source=PC&amp;utm_medium=geektime&amp;utm_term=pc_interstitial_5\">第15讲</a>。</p><p><strong>我们再来看一下，什么是“松耦合”？</strong></p><p>所谓松耦合是说，在代码中，类与类之间的依赖关系简单清晰。即使两个类有依赖关系，一个类的代码改动不会或者很少导致依赖类的代码改动。实际上，我们前面讲的依赖注入、接口隔离、基于接口而非实现编程，以及今天讲的迪米特法则，都是为了实现代码的松耦合。</p><p><strong>最后，我们来看一下，“内聚”和“耦合”之间的关系。</strong></p><p>前面也提到，“高内聚”有助于“松耦合”，同理，“低内聚”也会导致“紧耦合”。关于这一点，我画了一张对比图来解释。图中左边部分的代码结构是“高内聚、松耦合”；右边部分正好相反，是“低内聚、紧耦合”。</p><p><img src=\"https://static001.geekbang.org/resource/image/62/3c/62275095f1f5817cad8a9ca129a6ec3c.jpg\" alt=\"\"></p><p>图中左边部分的代码设计中，类的粒度比较小，每个类的职责都比较单一。相近的功能都放到了一个类中，不相近的功能被分割到了多个类中。这样类更加独立，代码的内聚性更好。因为职责单一，所以每个类被依赖的类就会比较少，代码低耦合。一个类的修改，只会影响到一个依赖类的代码改动。我们只需要测试这一个依赖类是否还能正常工作就行了。</p><p>图中右边部分的代码设计中，类粒度比较大，低内聚，功能大而全，不相近的功能放到了一个类中。这就导致很多其他类都依赖这个类。当我们修改这个类的某一个功能代码的时候，会影响依赖它的多个类。我们需要测试这三个依赖类，是否还能正常工作。这也就是所谓的“牵一发而动全身”。</p><p>除此之外，从图中我们也可以看出，高内聚、低耦合的代码结构更加简单、清晰，相应地，在可维护性和可读性上确实要好很多。</p><h2>“迪米特法则”理论描述</h2><p>迪米特法则的英文翻译是：Law of Demeter，缩写是LOD。单从这个名字上来看，我们完全猜不出这个原则讲的是什么。不过，它还有另外一个更加达意的名字，叫作最小知识原则，英文翻译为：The Least Knowledge Principle。</p><p>关于这个设计原则，我们先来看一下它最原汁原味的英文定义：</p><blockquote>\n<p>Each unit should have only limited knowledge about other units: only units “closely” related to the current unit. Or: Each unit should only talk to its friends; Don’t talk to strangers.</p>\n</blockquote><p>我们把它直译成中文，就是下面这个样子：</p><blockquote>\n<p>每个模块（unit）只应该了解那些与它关系密切的模块（units: only units “closely” related to the current unit）的有限知识（knowledge）。或者说，每个模块只和自己的朋友“说话”（talk），不和陌生人“说话”（talk）。</p>\n</blockquote><p>我们之前讲过，大部分设计原则和思想都非常抽象，有各种各样的解读，要想灵活地应用到实际的开发中，需要有实战经验的积累。迪米特法则也不例外。所以，我结合我自己的理解和经验，对刚刚的定义重新描述一下。注意，为了统一讲解，我把定义描述中的“模块”替换成了“类”。</p><blockquote>\n<p>不该有直接依赖关系的类之间，不要有依赖；有依赖关系的类之间，尽量只依赖必要的接口（也就是定义中的“有限知识”）。</p>\n</blockquote><p>从上面的描述中，我们可以看出，迪米特法则包含前后两部分，这两部分讲的是两件事情，我用两个实战案例分别来解读一下。</p><h2>理论解读与代码实战一</h2><p>我们先来看这条原则中的前半部分，<strong>“不该有直接依赖关系的类之间，不要有依赖”。</strong>我举个例子解释一下。</p><p>这个例子实现了简化版的搜索引擎爬取网页的功能。代码中包含三个主要的类。其中，NetworkTransporter类负责底层网络通信，根据请求获取数据；HtmlDownloader类用来通过URL获取网页；Document表示网页文档，后续的网页内容抽取、分词、索引都是以此为处理对象。具体的代码实现如下所示：</p><pre><code>public class NetworkTransporter {\n    // 省略属性和其他方法...\n    public Byte[] send(HtmlRequest htmlRequest) {\n      //...\n    }\n}\n\npublic class HtmlDownloader {\n  private NetworkTransporter transporter;//通过构造函数或IOC注入\n  \n  public Html downloadHtml(String url) {\n    Byte[] rawHtml = transporter.send(new HtmlRequest(url));\n    return new Html(rawHtml);\n  }\n}\n\npublic class Document {\n  private Html html;\n  private String url;\n  \n  public Document(String url) {\n    this.url = url;\n    HtmlDownloader downloader = new HtmlDownloader();\n    this.html = downloader.downloadHtml(url);\n  }\n  //...\n}\n</code></pre><p>这段代码虽然“能用”，能实现我们想要的功能，但是它不够“好用”，有比较多的设计缺陷。你可以先试着思考一下，看看都有哪些缺陷，然后再来看我下面的讲解。</p><p><strong>首先，我们来看NetworkTransporter类。</strong>作为一个底层网络通信类，我们希望它的功能尽可能通用，而不只是服务于下载HTML，所以，我们不应该直接依赖太具体的发送对象HtmlRequest。从这一点上讲，NetworkTransporter类的设计违背迪米特法则，依赖了不该有直接依赖关系的HtmlRequest类。</p><p>我们应该如何进行重构，让NetworkTransporter类满足迪米特法则呢？我这里有个形象的比喻。假如你现在要去商店买东西，你肯定不会直接把钱包给收银员，让收银员自己从里面拿钱，而是你从钱包里把钱拿出来交给收银员。这里的HtmlRequest对象就相当于钱包，HtmlRequest里的address和content对象就相当于钱。我们应该把address和content交给NetworkTransporter，而非是直接把HtmlRequest交给NetworkTransporter。根据这个思路，NetworkTransporter重构之后的代码如下所示：</p><pre><code>public class NetworkTransporter {\n    // 省略属性和其他方法...\n    public Byte[] send(String address, Byte[] data) {\n      //...\n    }\n}\n</code></pre><p><strong>我们再来看HtmlDownloader类。</strong>这个类的设计没有问题。不过，我们修改了NetworkTransporter的send()函数的定义，而这个类用到了send()函数，所以我们需要对它做相应的修改，修改后的代码如下所示：</p><pre><code>public class HtmlDownloader {\n  private NetworkTransporter transporter;//通过构造函数或IOC注入\n  \n  // HtmlDownloader这里也要有相应的修改\n  public Html downloadHtml(String url) {\n    HtmlRequest htmlRequest = new HtmlRequest(url);\n    Byte[] rawHtml = transporter.send(\n      htmlRequest.getAddress(), htmlRequest.getContent().getBytes());\n    return new Html(rawHtml);\n  }\n}\n</code></pre><p><strong>最后，我们来看下Document类。</strong>这个类的问题比较多，主要有三点。第一，构造函数中的downloader.downloadHtml()逻辑复杂，耗时长，不应该放到构造函数中，会影响代码的可测试性。代码的可测试性我们后面会讲到，这里你先知道有这回事就可以了。第二，HtmlDownloader对象在构造函数中通过new来创建，违反了基于接口而非实现编程的设计思想，也会影响到代码的可测试性。第三，从业务含义上来讲，Document网页文档没必要依赖HtmlDownloader类，违背了迪米特法则。</p><p>虽然Document类的问题很多，但修改起来比较简单，只要一处改动就可以解决所有问题。修改之后的代码如下所示：</p><pre><code>public class Document {\n  private Html html;\n  private String url;\n  \n  public Document(String url, Html html) {\n    this.html = html;\n    this.url = url;\n  }\n  //...\n}\n\n// 通过一个工厂方法来创建Document\npublic class DocumentFactory {\n  private HtmlDownloader downloader;\n  \n  public DocumentFactory(HtmlDownloader downloader) {\n    this.downloader = downloader;\n  }\n  \n  public Document createDocument(String url) {\n    Html html = downloader.downloadHtml(url);\n    return new Document(url, html);\n  }\n}\n</code></pre><h2>理论解读与代码实战二</h2><p>现在，我们再来看一下这条原则中的后半部分：“有依赖关系的类之间，尽量只依赖必要的接口”。我们还是结合一个例子来讲解。下面这段代码非常简单，Serialization类负责对象的序列化和反序列化。提醒你一下，有个类似的例子在之前的第15节课中讲过，你可以结合着一块儿看一下。</p><pre><code>public class Serialization {\n  public String serialize(Object object) {\n    String serializedResult = ...;\n    //...\n    return serializedResult;\n  }\n  \n  public Object deserialize(String str) {\n    Object deserializedResult = ...;\n    //...\n    return deserializedResult;\n  }\n}\n</code></pre><p>单看这个类的设计，没有一点问题。不过，如果我们把它放到一定的应用场景里，那就还有继续优化的空间。假设在我们的项目中，有些类只用到了序列化操作，而另一些类只用到反序列化操作。那基于迪米特法则后半部分“有依赖关系的类之间，尽量只依赖必要的接口”，只用到序列化操作的那部分类不应该依赖反序列化接口。同理，只用到反序列化操作的那部分类不应该依赖序列化接口。</p><p>根据这个思路，我们应该将Serialization类拆分为两个更小粒度的类，一个只负责序列化（Serializer类），一个只负责反序列化（Deserializer类）。拆分之后，使用序列化操作的类只需要依赖Serializer类，使用反序列化操作的类只需要依赖Deserializer类。拆分之后的代码如下所示：</p><pre><code>public class Serializer {\n  public String serialize(Object object) {\n    String serializedResult = ...;\n    ...\n    return serializedResult;\n  }\n}\n\npublic class Deserializer {\n  public Object deserialize(String str) {\n    Object deserializedResult = ...;\n    ...\n    return deserializedResult;\n  }\n}\n</code></pre><p>不知道你有没有看出来，尽管拆分之后的代码更能满足迪米特法则，但却违背了高内聚的设计思想。高内聚要求相近的功能要放到同一个类中，这样可以方便功能修改的时候，修改的地方不至于过于分散。对于刚刚这个例子来说，如果我们修改了序列化的实现方式，比如从JSON换成了XML，那反序列化的实现逻辑也需要一并修改。在未拆分的情况下，我们只需要修改一个类即可。在拆分之后，我们需要修改两个类。显然，这种设计思路的代码改动范围变大了。</p><p>如果我们既不想违背高内聚的设计思想，也不想违背迪米特法则，那我们该如何解决这个问题呢？实际上，通过引入两个接口就能轻松解决这个问题，具体的代码如下所示。实际上，我们在<a href=\"https://time.geekbang.org/column/article/177442\">第18节课</a>中讲到“接口隔离原则”的时候，第三个例子就使用了类似的实现思路，你可以结合着一块儿来看。</p><pre><code>public interface Serializable {\n  String serialize(Object object);\n}\n\npublic interface Deserializable {\n  Object deserialize(String text);\n}\n\npublic class Serialization implements Serializable, Deserializable {\n  @Override\n  public String serialize(Object object) {\n    String serializedResult = ...;\n    ...\n    return serializedResult;\n  }\n  \n  @Override\n  public Object deserialize(String str) {\n    Object deserializedResult = ...;\n    ...\n    return deserializedResult;\n  }\n}\n\npublic class DemoClass_1 {\n  private Serializable serializer;\n  \n  public Demo(Serializable serializer) {\n    this.serializer = serializer;\n  }\n  //...\n}\n\npublic class DemoClass_2 {\n  private Deserializable deserializer;\n  \n  public Demo(Deserializable deserializer) {\n    this.deserializer = deserializer;\n  }\n  //...\n}\n</code></pre><p>尽管我们还是要往DemoClass_1的构造函数中，传入包含序列化和反序列化的Serialization实现类，但是，我们依赖的Serializable接口只包含序列化操作，DemoClass_1无法使用Serialization类中的反序列化接口，对反序列化操作无感知，这也就符合了迪米特法则后半部分所说的“依赖有限接口”的要求。</p><p>实际上，上面的的代码实现思路，也体现了“基于接口而非实现编程”的设计原则，结合迪米特法则，我们可以总结出一条新的设计原则，那就是“基于最小接口而非最大实现编程”。有些同学之前问，新的设计模式和设计原则是怎么创造出来的，实际上，就是在大量的实践中，针对开发痛点总结归纳出来的套路。</p><h2>辩证思考与灵活应用</h2><p>对于实战二最终的设计思路，你有没有什么不同的观点呢？</p><p>整个类只包含序列化和反序列化两个操作，只用到序列化操作的使用者，即便能够感知到仅有的一个反序列化函数，问题也不大。那为了满足迪米特法则，我们将一个非常简单的类，拆分出两个接口，是否有点过度设计的意思呢？</p><p>设计原则本身没有对错，只有能否用对之说。不要为了应用设计原则而应用设计原则，我们在应用设计原则的时候，一定要具体问题具体分析。</p><p>对于刚刚这个Serialization类来说，只包含两个操作，确实没有太大必要拆分成两个接口。但是，如果我们对Serialization类添加更多的功能，实现更多更好用的序列化、反序列化函数，我们来重新考虑一下这个问题。修改之后的具体的代码如下：</p><pre><code>public class Serializer { // 参看JSON的接口定义\n  public String serialize(Object object) { //... }\n  public String serializeMap(Map map) { //... }\n  public String serializeList(List list) { //... }\n  \n  public Object deserialize(String objectString) { //... }\n  public Map deserializeMap(String mapString) { //... }\n  public List deserializeList(String listString) { //... }\n}\n</code></pre><p>在这种场景下，第二种设计思路要更好些。因为基于之前的应用场景来说，大部分代码只需要用到序列化的功能。对于这部分使用者，没必要了解反序列化的“知识”，而修改之后的Serialization类，反序列化的“知识”，从一个函数变成了三个。一旦任一反序列化操作有代码改动，我们都需要检查、测试所有依赖Serialization类的代码是否还能正常工作。为了减少耦合和测试工作量，我们应该按照迪米特法则，将反序列化和序列化的功能隔离开来。</p><h2>重点回顾</h2><p>好了，今天的内容到此就讲完了。我们一块来总结回顾一下，你需要掌握的重点内容。</p><p><strong>1.如何理解“高内聚、松耦合”？</strong></p><p>“高内聚、松耦合”是一个非常重要的设计思想，能够有效提高代码的可读性和可维护性，缩小功能改动导致的代码改动范围。“高内聚”用来指导类本身的设计，“松耦合”用来指导类与类之间依赖关系的设计。</p><p>所谓高内聚，就是指相近的功能应该放到同一个类中，不相近的功能不要放到同一类中。相近的功能往往会被同时修改，放到同一个类中，修改会比较集中。所谓松耦合指的是，在代码中，类与类之间的依赖关系简单清晰。即使两个类有依赖关系，一个类的代码改动也不会或者很少导致依赖类的代码改动。</p><p><strong>2.如何理解“迪米特法则”？</strong></p><p>不该有直接依赖关系的类之间，不要有依赖；有依赖关系的类之间，尽量只依赖必要的接口。迪米特法则是希望减少类之间的耦合，让类越独立越好。每个类都应该少了解系统的其他部分。一旦发生变化，需要了解这一变化的类就会比较少。</p><h2>课堂讨论</h2><p>在今天的讲解中，我们提到了“高内聚、松耦合”“单一职责原则”“接口隔离原则”“基于接口而非实现编程”“迪米特法则”，你能总结一下它们之间的区别和联系吗？</p><p>欢迎在留言区写下你的答案，和同学一起交流和分享。如果有收获，也欢迎你把这篇文章分享给你的朋友。</p>",
                "article_title": "22 | 理论八：如何用迪米特法则（LOD）实现“高内聚、松耦合”？"
            },
            {
                "title": "23 | 实战一（上）：针对业务系统的开发，如何做需求分析和设计？",
                "herf": "https://time.geekbang.org/column/article/182001",
                "id": "182001",
                "content": "<p>对于一个工程师来说，如果要追求长远发展，你就不能一直只把自己放在执行者的角色，不能只是一个代码实现者，你还要有独立负责一个系统的能力，能端到端（end to end）开发一个完整的系统。这其中的工作就包括：前期的需求沟通分析、中期的代码设计实现、后期的系统上线维护等。</p><p>前面我们还提到过，大部分工程师都是做业务开发的。很多工程师都觉得，做业务开发没啥技术含量，没有成长，就是简单的CRUD，翻译业务逻辑，根本用不上专栏中讲的设计原则、思想、模式。</p><p>所以，针对这两个普遍的现象，今天，我通过一个积分兑换系统的开发实战，一方面给你展示一个业务系统从需求分析到上线维护的整个开发套路，让你能举一反三地应用到所有其他系统的开发中，另一方面也给你展示在看似没有技术含量的业务开发中，实际上都蕴含了哪些设计原则、思想、模式。</p><p>话不多说，让我们正式开始今天的学习吧！</p><h2>需求分析</h2><p>积分是一种常见的营销手段，很多产品都会通过它来促进消费、增加用户粘性，比如淘宝积分、信用卡积分、商场消费积分等等。假设你是一家类似淘宝这样的电商平台的工程师，平台暂时还没有积分系统。Leader希望由你来负责开发这样一个系统，你会如何来做呢？</p><p>你可能会说，只要产品经理给我产品设计文档（PRD）、线框图，我照着实现就可以了。我觉得，这种想法有点狭隘。我认为，技术人员应该更多地参与到产品设计中。在Google工作的时候，我很明显能感受到，Google工程师跟其他公司工程师有一个很大区别，那就是大部分人都具备产品思维，并不是完全的“技术控”。所以，Google很多产品的初期设计都是工程师来完成的，在产品发展壮大到一定程度的时候，才会引入产品经理的角色。</p><!-- [[[read_end]]] --><p>那你可能要问了，作为技术人，我该怎么做产品设计呢？首先，一定不要自己一个人闷头想。一方面，这样做很难想全面。另一方面，从零开始设计也比较浪费时间。所以，我们要学会“借鉴”。爱因斯坦说过，“创造的一大秘诀是要懂得如何隐藏你的来源”。你看大师都含蓄地表达了“借鉴”的重要性，我们也没有必要因为“借鉴”而感到不好意思了。</p><p>我们可以找几个类似的产品，比如淘宝，看看它们是如何设计积分系统的，然后借鉴到我们的产品中。你可以自己亲自用用淘宝，看看积分是怎么使用的，也可以直接百度一下“淘宝积分规则”。基于这两个输入，我们基本上就大致能摸清楚积分系统该如何设计了。除此之外，我们还要充分了解自己公司的产品，将借鉴来的东西糅合在我们自己的产品中，并做适当的微创新。</p><p>笼统地来讲，积分系统无外乎就两个大的功能点，一个是赚取积分，另一个是消费积分。赚取积分功能包括积分赚取渠道，比如下订单、每日签到、评论等；还包括积分兑换规则，比如订单金额与积分的兑换比例，每日签到赠送多少积分等。消费积分功能包括积分消费渠道，比如抵扣订单金额、兑换优惠券、积分换购、参与活动扣积分等；还包括积分兑换规则，比如多少积分可以换算成抵扣订单的多少金额，一张优惠券需要多少积分来兑换等等。</p><p>我刚刚给出的只是非常笼统、粗糙的功能需求。在实际情况中，肯定还有一些业务细节需要考虑，比如积分的有效期问题。对于这些业务细节，还是那句话，闷头拍脑袋想是想不全面的。以防遗漏，我们还是要有方法可寻。那除了刚刚讲的“借鉴”的思路之外，我还喜欢通过产品的<strong>线框图</strong>、<strong>用户用例</strong>（user case ）或者叫用户故事（user story）来细化业务流程，挖掘一些比较细节的、不容易想到的功能点。</p><p>线框图对你来说应该不陌生，我就不赘述了，我这里重点说一下用户用例。用户用例有点儿类似我们后面要讲的单元测试用例。它侧重情景化，其实就是模拟用户如何使用我们的产品，描述用户在一个特定的应用场景里的一个完整的业务操作流程。所以，它包含更多的细节，且更加容易被人理解。比如，有关积分有效期的用户用例，我们可以进行如下的设计：</p><ul>\n<li>用户在获取积分的时候，会告知积分的有效期；</li>\n<li>用户在使用积分的时候，会优先使用快过期的积分；</li>\n<li>用户在查询积分明细的时候，会显示积分的有效期和状态（是否过期）；</li>\n<li>用户在查询总可用积分的时候，会排除掉过期的积分。</li>\n</ul><p>通过上面讲的方法，我们就可以将功能需求大致弄清楚了。积分系统的需求实际上并不复杂，我总结罗列了一下，如下所示。</p><h3>1.积分赚取和兑换规则</h3><p>积分的赚取渠道包括：下订单、每日签到、评论等。</p><p>积分兑换规则可以是比较通用的。比如，签到送10积分。再比如，按照订单总金额的10%兑换成积分，也就是100块钱的订单可以积累10积分。除此之外，积分兑换规则也可以是比较细化的。比如，不同的店铺、不同的商品，可以设置不同的积分兑换比例。</p><p>对于积分的有效期，我们可以根据不同渠道，设置不同的有效期。积分到期之后会作废；在消费积分的时候，优先使用快到期的积分。</p><h3>2.积分消费和兑换规则</h3><p>积分的消费渠道包括：抵扣订单金额、兑换优惠券、积分换购、参与活动扣积分等。</p><p>我们可以根据不同的消费渠道，设置不同的积分兑换规则。比如，积分换算成消费抵扣金额的比例是10%，也就是10积分可以抵扣1块钱；100积分可以兑换15块钱的优惠券等。</p><h3>3.积分及其明细查询</h3><p>查询用户的总积分，以及赚取积分和消费积分的历史记录。</p><h2>系统设计</h2><p>面向对象设计聚焦在代码层面（主要是针对类），那系统设计就是聚焦在架构层面（主要是针对模块），两者有很多相似之处。很多设计原则和思想不仅仅可以应用到代码设计中，还能用到架构设计中。还记得面向对象设计的四个步骤吗？实际上，我们也可以借鉴那个过程来做系统设计。</p><h3>1.合理地将功能划分到不同模块</h3><p>前面讲到面向对象设计的时候，我们提到，面向对象设计的本质就是把合适的代码放到合适的类中。合理地划分代码可以实现代码的高内聚、低耦合，类与类之间的交互简单清晰，代码整体结构一目了然，那代码的质量就不会差到哪里去。类比面向对象设计，系统设计实际上就是将合适的功能放到合适的模块中。合理地划分模块也可以做到模块层面的高内聚、低耦合，架构整洁清晰。</p><p>对于前面罗列的所有功能点，我们有下面三种模块划分方法。</p><p>第一种划分方式是：积分赚取渠道及兑换规则、消费渠道及兑换规则的管理和维护（增删改查），不划分到积分系统中，而是放到更上层的营销系统中。这样积分系统就会变得非常简单，只需要负责增加积分、减少积分、查询积分、查询积分明细等这几个工作。</p><p>我举个例子解释一下。比如，用户通过下订单赚取积分。订单系统通过异步发送消息或者同步调用接口的方式，告知营销系统订单交易成功。营销系统根据拿到的订单信息，查询订单对应的积分兑换规则（兑换比例、有效期等），计算得到订单可兑换的积分数量，然后调用积分系统的接口给用户增加积分。</p><p>第二种划分方式是：积分赚取渠道及兑换规则、消费渠道及兑换规则的管理和维护，分散在各个相关业务系统中，比如订单系统、评论系统、签到系统、换购商城、优惠券系统等。还是刚刚那个下订单赚取积分的例子，在这种情况下，用户下订单成功之后，订单系统根据商品对应的积分兑换比例，计算所能兑换的积分数量，然后直接调用积分系统给用户增加积分。</p><p>第三种划分方式是：所有的功能都划分到积分系统中，包括积分赚取渠道及兑换规则、消费渠道及兑换规则的管理和维护。还是同样的例子，用户下订单成功之后，订单系统直接告知积分系统订单交易成功，积分系统根据订单信息查询积分兑换规则，给用户增加积分。</p><p>怎么判断哪种模块划分合理呢？实际上，我们可以反过来通过看它是否符合高内聚、低耦合特性来判断。如果一个功能的修改或添加，经常要跨团队、跨项目、跨系统才能完成，那说明模块划分的不够合理，职责不够清晰，耦合过于严重。</p><p>除此之外，为了避免业务知识的耦合，让下层系统更加通用，一般来讲，我们不希望下层系统（也就是被调用的系统）包含太多上层系统（也就是调用系统）的业务信息，但是，可以接受上层系统包含下层系统的业务信息。比如，订单系统、优惠券系统、换购商城等作为调用积分系统的上层系统，可以包含一些积分相关的业务信息。但是，反过来，积分系统中最好不要包含太多跟订单、优惠券、换购等相关的信息。</p><p>所以，综合考虑，我们更倾向于第一种和第二种模块划分方式。但是，不管选择这两种中的哪一种，积分系统所负责的工作是一样的，只包含积分的增、减、查询，以及积分明细的记录和查询。</p><h3>2.设计模块与模块之间的交互关系</h3><p>在面向对象设计中，类设计好之后，我们需要设计类之间的交互关系。类比到系统设计，系统职责划分好之后，接下来就是设计系统之间的交互，也就是确定有哪些系统跟积分系统之间有交互以及如何进行交互。</p><p>比较常见的系统之间的交互方式有两种，一种是同步接口调用，另一种是利用消息中间件异步调用。第一种方式简单直接，第二种方式的解耦效果更好。</p><p>比如，用户下订单成功之后，订单系统推送一条消息到消息中间件，营销系统订阅订单成功消息，触发执行相应的积分兑换逻辑。这样订单系统就跟营销系统完全解耦，订单系统不需要知道任何跟积分相关的逻辑，而营销系统也不需要直接跟订单系统交互。</p><p>除此之外，上下层系统之间的调用倾向于通过同步接口，同层之间的调用倾向于异步消息调用。比如，营销系统和积分系统是上下层关系，它们之间就比较推荐使用同步接口调用。</p><h3>3.设计模块的接口、数据库、业务模型</h3><p>刚刚讲了模块的功能划分，模块之间的交互的设计，现在，我们再来看，模块本身如何来设计。实际上，业务系统本身的设计无外乎有这样三方面的工作要做：接口设计、数据库设计和业务模型设计。这部分的具体内容我们放到下一下节课中跟实现一块进行讲解。</p><h2>重点回顾</h2><p>今天的内容到此就讲完了。我们来一块总结回顾一下，你需要掌握的重点内容。</p><p>技术人也要有一些产品思维。对于产品设计、需求分析，我们要学会“借鉴”，一定不要自己闷头想。一方面这样做很难想全面，另一方面从零开始设计也比较浪费时间。除此之外，我们还可以通过线框图和用户用例来细化业务流程，挖掘一些比较细节的、不容易想到的功能点。</p><p>面向对象设计聚焦在代码层面（主要是针对类），那系统设计就是聚焦在架构层面（主要是针对模块），两者有很多相似之处。很多设计原则和思想不仅仅可以应用到代码设计中，还能用到架构设计中。实际上，我们可以借鉴面向对象设计的步骤，来做系统设计。</p><p>面向对象设计的本质就是把合适的代码放到合适的类中。合理地划分代码可以实现代码的高内聚、低耦合，类与类之间的交互简单清晰，代码整体结构一目了然。类比面向对象设计，系统设计实际上就是将合适的功能放到合适的模块中。合理地划分模块也可以做到模块层面的高内聚、低耦合，架构整洁清晰。在面向对象设计中，类设计好之后，我们需要设计类之间的交互关系。类比到系统设计，系统职责划分好之后，接下来就是设计系统之间的交互了。</p><h2>课堂讨论</h2><p>对公司业务及已有系统的熟悉程度，有时候甚至会超过个人的技术能力，更能决定一个人在公司内部的发展前途。但是，当我们出去面试的时候，面试官大部分情况下更加关注你的技术能力，而非特定的业务细节，特别是你做的业务并不是太复杂，或者跟要面试岗位无关的时候。</p><p>这两者听起来比较矛盾。作为一名技术人，为了谋求更好的发展，你觉得是应该多花点时间研究业务呢，还是要多花点心思在技术上呢？</p><p>欢迎在留言区写下你的答案，和同学一起交流和分享。如果有收获，也欢迎你把这篇文章分享给你的朋友。</p>",
                "article_title": "23 | 实战一（上）：针对业务系统的开发，如何做需求分析和设计？"
            },
            {
                "title": "24 | 实战一（下）：如何实现一个遵从设计原则的积分兑换系统？",
                "herf": "https://time.geekbang.org/column/article/183007",
                "id": "183007",
                "content": "<p>上一节课中，我们讲了积分系统的需求分析和系统设计。今天，我们来讲它的代码实现。</p><p>上一节课中，我们把积分赚取和消费的渠道和规则的管理维护工作，划分到了上层系统中，所以，积分系统的功能变得非常简单。相应地，代码实现也比较简单。如果你有一定的项目开发经验，那实现这样一个系统，对你来说并不是件难事。</p><p>所以，我们今天讲解的重点，并不是教你如何来实现积分系统的每个功能、每个接口，更不是教你如何编写SQL语句来增删改查数据，而是给你展示一些更普适的开发思想。比如，为什么要分MVC三层来开发？为什么要针对每层定义不同的数据对象？最后，我还会总结这其中都蕴含哪些设计原则和思想，让你知其然知其所以然，做到真正地透彻理解。</p><p>话不多说，让我们正式开始今天的学习吧！</p><h2>业务开发包括哪些工作？</h2><p>实际上，我们平时做业务系统的设计与开发，无外乎有这样三方面的工作要做：接口设计、数据库设计和业务模型设计（也就是业务逻辑）。</p><p>数据库和接口的设计非常重要，一旦设计好并投入使用之后，这两部分都不能轻易改动。改动数据库表结构，需要涉及数据的迁移和适配；改动接口，需要推动接口的使用者作相应的代码修改。这两种情况，即便是微小的改动，执行起来都会非常麻烦。因此，我们在设计接口和数据库的时候，一定要多花点心思和时间，切不可过于随意。相反，业务逻辑代码侧重内部实现，不涉及被外部依赖的接口，也不包含持久化的数据，所以对改动的容忍性更大。</p><!-- [[[read_end]]] --><p><strong>针对积分系统，我们先来看，如何设计数据库。</strong></p><p>数据库的设计比较简单。实际上，我们只需要一张记录积分流水明细的表就可以了。表中记录积分的赚取和消费流水。用户积分的各种统计数据，比如总积分、总可用积分等，都可以通过这张表来计算得到。</p><p><img src=\"https://static001.geekbang.org/resource/image/e9/c4/e9562c46bcb8fc45634f0d870c4778c4.jpg\" alt=\"\"></p><p><strong>接下来，我们再来看，如何设计积分系统的接口。</strong></p><p>接口设计要符合单一职责原则，粒度越小通用性就越好。但是，接口粒度太小也会带来一些问题。比如，一个功能的实现要调用多个小接口，一方面如果接口调用走网络（特别是公网），多次远程接口调用会影响性能；另一方面，本该在一个接口中完成的原子操作，现在分拆成多个小接口来完成，就可能会涉及分布式事务的数据一致性问题（一个接口执行成功了，但另一个接口执行失败了）。所以，为了兼顾易用性和性能，我们可以借鉴facade（外观）设计模式，在职责单一的细粒度接口之上，再封装一层粗粒度的接口给外部使用。</p><p>对于积分系统来说，我们需要设计如下这样几个接口。</p><p><img src=\"https://static001.geekbang.org/resource/image/7b/af/7b9008f6bc107add2b21d3dba901deaf.jpg\" alt=\"\"></p><p><strong>最后，我们来看业务模型的设计。</strong></p><p>前面我们讲到，从代码实现角度来说，大部分业务系统的开发都可以分为Controller、Service、Repository三层。Controller层负责接口暴露，Repository层负责数据读写，Service层负责核心业务逻辑，也就是这里说的业务模型。</p><p>除此之外，前面我们还提到两种开发模式，基于贫血模型的传统开发模式和基于充血模型的DDD开发模式。前者是一种面向过程的编程风格，后者是一种面向对象的编程风格。不管是DDD还是OOP，高级开发模式的存在一般都是为了应对复杂系统，应对系统的复杂性。对于我们要开发的积分系统来说，因为业务相对比较简单，所以，选择简单的基于贫血模型的传统开发模式就足够了。</p><p>从开发的角度来说，我们可以把积分系统作为一个独立的项目，来独立开发，也可以跟其他业务代码（比如营销系统）放到同一个项目中进行开发。从运维的角度来说，我们可以将它跟其他业务一块部署，也可以作为一个微服务独立部署。具体选择哪种开发和部署方式，我们可以参考公司当前的技术架构来决定。</p><p>实际上，积分系统业务比较简单，代码量也不多，我更倾向于将它跟营销系统放到一个项目中开发部署。只要我们做好代码的模块化和解耦，让积分相关的业务代码跟其他业务代码之间边界清晰，没有太多耦合，后期如果需要将它拆分成独立的项目来开发部署，那也并不困难。</p><p>相信这样一个简单的业务功能的开发，对你来说并没有太大难度。所以，具体的代码实现我就不在专栏中给出了。感兴趣的话，你可以自己实现一下。接下来的内容，才是我们这一节的重点。</p><h2>为什么要分MVC三层开发？</h2><p>我们刚刚提到，大部分业务系统的开发都可以分为三层：\bContoller层、Service层、Repository层。对于这种分层方式，我相信大部分人都很认同，甚至成为了一种开发习惯，但你有没有想过，为什么我们要分层开发？很多业务都比较简单，一层代码搞定所有的数据读取、业务逻辑、接口暴露不好吗？你可以把它作为一道面试题，试着自己思考下，然后再看我下面的讲解。</p><p>对于这个问题，我总结了以下几点原因。</p><h3>1.分层能起到代码复用的作用</h3><p>同一个Repository可能会被多个Service来调用，同一个Service可能会被多个Controller调用。比如，UserService中的getUserById()接口封装了通过ID获取用户信息的逻辑，这部分逻辑可能会被UserController和AdminController等多个Controller使用。如果没有Service层，每个Controller都要重复实现这部分逻辑，显然会违反DRY原则。</p><h3>2.分层能起到隔离变化的作用</h3><p>分层体现了一种抽象和封装的设计思想。比如，Repository层封装了对数据库访问的操作，提供了抽象的数据访问接口。基于接口而非实现编程的设计思想，Service层使用Repository层提供的接口，并不关心其底层依赖的是哪种具体的数据库。当我们需要替换数据库的时候，比如从MySQL到Oracle，从Oracle到Redis，只需要改动Repository层的代码，Service层的代码完全不需要修改。</p><p>除此之外，Controller、Service、Repository三层代码的稳定程度不同、引起变化的原因不同，所以分成三层来组织代码，能有效地隔离变化。比如，Repository层基于数据库表，而数据库表改动的可能性很小，所以Repository层的代码最稳定，而Controller层提供适配给外部使用的接口，代码经常会变动。分层之后，Controller层中代码的频繁改动并不会影响到稳定的Repository层。</p><h3>3.分层能起到隔离关注点的作用</h3><p>Repository层只关注数据的读写。Service层只关注业务逻辑，不关注数据的来源。Controller层只关注与外界打交道，数据校验、封装、格式转换，并不关心业务逻辑。三层之间的关注点不同，分层之后，职责分明，更加符合单一职责原则，代码的内聚性更好。</p><h3>4.分层能提高代码的可测试性</h3><p>后面讲单元测试的时候，我们会讲到，单元测试不依赖不可控的外部组件，比如数据库。分层之后，Repsitory层的代码通过依赖注入的方式供Service层使用，当要测试包含核心业务逻辑的Service层代码的时候，我们可以用mock的数据源替代真实的数据库，注入到Service层代码中。代码的可测试性和单元测试我们后面会讲到，这里你稍微了解即可。</p><h3>5.分层能应对系统的复杂性</h3><p>所有的代码都放到一个类中，那这个类的代码就会因为需求的迭代而无限膨胀。我们知道，当一个类或一个函数的代码过多之后，可读性、可维护性就会变差。那我们就要想办法拆分。拆分有垂直和水平两个方向。水平方向基于业务来做拆分，就是模块化；垂直方向基于流程来做拆分，就是这里说的分层。</p><p>还是那句话，不管是分层、模块化，还是OOP、DDD，以及各种设计模式、原则和思想，都是为了应对复杂系统，应对系统的复杂性。对于简单系统来说，其实是发挥不了作用的，就是俗话说的“杀鸡焉用牛刀”。</p><h2>BO、VO、Entity存在的意义是什么？</h2><p>在前面的章节中，我们提到，针对Controller、Service、Repository三层，每层都会定义相应的数据对象，它们分别是VO（View Object）、BO（Business Object）、Entity，例如UserVo、UserBo、UserEntity。在实际的开发中，VO、BO、Entity可能存在大量的重复字段，甚至三者包含的字段完全一样。在开发的过程中，我们经常需要重复定义三个几乎一样的类，显然是一种重复劳动。</p><p><strong>相对于每层定义各自的数据对象来说，是不是定义一个公共的数据对象更好些呢？</strong></p><p>实际上，我更加推荐每层都定义各自的数据对象这种设计思路，主要有以下3个方面的原因。</p><ul>\n<li>VO、BO、Entity并非完全一样。比如，我们可以在UserEntity、UserBo中定义Password字段，但显然不能在UserVo中定义Password字段，否则就会将用户的密码暴露出去。</li>\n<li>VO、BO、Entity三个类虽然代码重复，但功能语义不重复，从职责上讲是不一样的。所以，也并不能算违背DRY原则。在前面讲到DRY原则的时候，针对这种情况，如果合并为同一个类，那也会存在后期因为需求的变化而需要再拆分的问题。</li>\n<li>为了尽量减少每层之间的耦合，把职责边界划分明确，每层都会维护自己的数据对象，层与层之间通过接口交互。数据从下一层传递到上一层的时候，将下一层的数据对象转化成上一层的数据对象，再继续处理。虽然这样的设计稍微有些繁琐，每层都需要定义各自的数据对象，需要做数据对象之间的转化，但是分层清晰。对于非常大的项目来说，结构清晰是第一位的！</li>\n</ul><p><strong>既然VO、BO、Entity不能合并，那如何解决代码重复的问题呢？</strong></p><p>从设计的角度来说，VO、BO、Entity的设计思路并不违反DRY原则，为了分层清晰、减少耦合，多维护几个类的成本也并不是不能接受的。但是，如果你真的有代码洁癖，对于代码重复的问题，我们也有一些办法来解决。</p><p>我们前面讲到，继承可以解决代码重复问题。我们可以将公共的字段定义在父类中，让VO、BO、Entity都继承这个父类，各自只定义特有的字段。因为这里的继承层次很浅，也不复杂，所以使用继承并不会影响代码的可读性和可维护性。后期如果因为业务的需要，有些字段需要从父类移动到子类，或者从子类提取到父类，代码改起来也并不复杂。</p><p>前面在讲“多用组合，少用继承”设计思想的时候，我们提到，组合也可以解决代码重复的问题，所以，这里我们还可以将公共的字段抽取到公共的类中，VO、BO、Entity通过组合关系来复用这个类的代码。</p><p><strong>代码重复问题解决了，那不同分层之间的数据对象该如何互相转化呢？</strong></p><p>当下一层的数据通过接口调用传递到上一层之后，我们需要将它转化成上一层对应的数据对象类型。比如，Service层从Repository层获取的Entity之后，将其转化成BO，再继续业务逻辑的处理。所以，整个开发的过程会涉及“Entity到BO”和“BO到VO”这两种转化。</p><p>最简单的转化方式是手动复制。自己写代码在两个对象之间，一个字段一个字段的赋值。但这样的做法显然是没有技术含量的低级劳动。Java中提供了多种数据对象转化工具，比如BeanUtils、Dozer等，可以大大简化繁琐的对象转化工作。如果你是用其他编程语言来做开发，也可以借鉴Java这些工具类的设计思路，自己在项目中实现对象转化工具类。</p><p><strong>VO、BO、Entity都是基于贫血模型的，而且为了兼容框架或开发库（比如MyBatis、Dozer、BeanUtils），我们还需要定义每个字段的set方法。这些都违背OOP的封装特性，会导致数据被随意修改。那到底该怎么办好呢？</strong></p><p>前面我们也提到过，Entity和VO的生命周期是有限的，都仅限在本层范围内。而对应的Repository层和Controller层也都不包含太多业务逻辑，所以也不会有太多代码随意修改数据，即便设计成贫血、定义每个字段的set方法，相对来说也是安全的。</p><p>不过，Service层包含比较多的业务逻辑代码，所以BO就存在被任意修改的风险了。但是，设计的问题本身就没有最优解，只有权衡。为了使用方便，我们只能做一些妥协，放弃BO的封装特性，由程序员自己来负责这些数据对象的不被错误使用。</p><h2>总结用到的设计原则和思想</h2><p>前面我们提到，很多人做业务开发，总感觉就是CRUD，翻译代码，根本用不到设计原则、思想和模式。实际上，只是你没有发现而已。现在，我就给你罗列一下，今天讲解的内容中，都用到了哪些设计原则、思想和模式。</p><p><img src=\"https://static001.geekbang.org/resource/image/33/61/3332071c82182e72518143d05b8eaa61.jpg\" alt=\"\"></p><p>实际上，这两节课中还蕴含了很多其他的设计思想、原则、模式，你可以像我一样试着去总结一下，放在留言区说一说。</p><h2>重点回顾</h2><p>今天的内容到此就讲完了。我们一块来总结回顾一下，你需要掌握的重点内容。</p><p><strong>1.为什么要分MVC三层开发？</strong></p><p>对于这个问题，我总结了以下5点原因。</p><ul>\n<li>分层能起到代码复用的作用</li>\n<li>分层能起到隔离变化的作用</li>\n<li>分层能起到隔离关注点的作用</li>\n<li>分层能提高代码的可测试性</li>\n<li>分层能应对系统的复杂性</li>\n</ul><p><strong>2.BO、VO、Entity存在的意义是什么？</strong></p><p>从设计的角度来说，VO、BO、Entity的设计思路并不违反DRY原则，为了分层清晰、减少耦合，多维护几个类的成本也并不是不能接受的。但是，如果你真的有代码洁癖，对于代码重复的问题，我们可以通过继承或者组合来解决。</p><p>如何进行数据对象之间的转化？最简单的方式就是手动复制。当然，你也可以使用Java中提供了数据对象转化工具，比如BeanUtils、Dozer等，可以大大简化繁琐的对象转化工作。</p><p>尽管VO、BO、Entity的设计违背OOP的封装特性，有被随意修改的风险。但Entity和VO的生命周期是有限的，都仅限在本层范围内，相对来说是安全的。Service层包含比较多的业务逻辑代码，所以BO就存在被任意修改的风险了。为了使用方便，我们只能做一些妥协，放弃BO的封装特性，由程序员自己来负责这些数据对象的不被错误使用。</p><p><strong>3.总结用到的设计原则和思想</strong></p><p>从表面上看，做业务开发可能并不是特别有技术挑战，但是实际上，\b如果你要做到知其然知其所以然，做到透彻理解、真的懂，并不是件容易的事情。深挖一下，你会发现这其中还是蕴含了很多设计原则、思想和模式的。</p><h2>课堂讨论</h2><ol>\n<li>上节课中，我们讲到，下层系统不要包含太多上层系统的业务信息。但在今天的数据库设计中，积分明细表中credit_transaction中包含event_id，channel_id这些跟上层业务相关的字段，那这样的设计是否合理呢？</li>\n<li>我们经常说，修改和查询不要耦合在一个接口中，要分成两个接口来做。赚取积分和消费积分接口返回积分明细ID，这样的接口设计是否违背单一职责原则呢？是不是返回void或者boolean类型更合理呢？</li>\n</ol><p>欢迎在留言区写下你的答案，和同学一起交流和分享。如果有收获，也欢迎你把这篇文章分享给你的朋友。</p>",
                "article_title": "24 | 实战一（下）：如何实现一个遵从设计原则的积分兑换系统？"
            },
            {
                "title": "25 | 实战二（上）：针对非业务的通用框架开发，如何做需求分析和设计？",
                "herf": "https://time.geekbang.org/column/article/179644",
                "id": "179644",
                "content": "<p>上两节课中，我们讲了如何针对一个业务系统做需求分析、设计和实现，并且通过一个积分兑换系统的开发，实践了之前学过的一些设计原则。接下来的两节课，我们再结合一个支持各种统计规则的性能计数器项目，学习针对一个非业务的通用框架开发，如何来做需求分析、设计和实现，同时学习如何灵活应用各种设计原则。</p><p>话不多说，让我们正式开始今天的内容吧！</p><h2>项目背景</h2><p>我们希望设计开发一个小的框架，能够获取接口调用的各种统计信息，比如，响应时间的最大值（max）、最小值（min）、平均值（avg）、百分位值（percentile）、接口调用次数（count）、频率（tps） 等，并且支持将统计结果以各种显示格式（比如：JSON格式、网页格式、自定义显示格式等）输出到各种终端（Console命令行、HTTP网页、Email、日志文件、自定义输出终端等），以方便查看。</p><p>我们假设这是真实项目中的一个开发需求，如果让你来负责开发这样一个通用的框架，应用到各种业务系统中，支持实时计算、查看数据的统计信息，你会如何设计和实现呢？你可以先自己主动思考一下，然后再来看我的分析思路。</p><h2>需求分析</h2><p>性能计数器作为一个跟业务无关的功能，我们完全可以把它开发成一个独立的框架或者类库，集成到很多业务系统中。而作为可被复用的框架，除了功能性需求之外，非功能性需求也非常重要。所以，接下来，我们从这两个方面来做需求分析。</p><!-- [[[read_end]]] --><h3>1.功能性需求分析</h3><p>相对于一大长串的文字描述，人脑更容易理解短的、罗列的比较规整、分门别类的列表信息。显然，刚才那段需求描述不符合这个规律。我们需要把它拆解成一个一个的“干条条”。拆解之后我写在下面了，是不是看起来更加清晰、有条理？</p><ul>\n<li>接口统计信息：包括接口响应时间的统计信息，以及接口调用次数的统计信息等。</li>\n<li>统计信息的类型：max、min、avg、percentile、count、tps等。</li>\n<li>统计信息显示格式：Json、Html、自定义显示格式。</li>\n<li>统计信息显示终端：Console、Email、HTTP网页、日志、自定义显示终端。</li>\n</ul><p>除此之外，我们还可以借助设计产品的时候，经常用到的线框图，把最终数据的显示样式画出来，会更加一目了然。具体的线框图如下所示：</p><p><img src=\"https://static001.geekbang.org/resource/image/f0/e5/f04b341ad5fda418ae24f166d0a4dde5.jpg\" alt=\"\"></p><p>实际上，从线框图中，我们还能挖掘出了下面几个隐藏的需求。</p><ul>\n<li>统计触发方式：包括主动和被动两种。主动表示以一定的频率定时统计数据，并主动推送到显示终端，比如邮件推送。被动表示用户触发统计，比如用户在网页中选择要统计的时间区间，触发统计，并将结果显示给用户。</li>\n<li>统计时间区间：框架需要支持自定义统计时间区间，比如统计最近10分钟的某接口的tps、访问次数，或者统计12月11日00点到12月12日00点之间某接口响应时间的最大值、最小值、平均值等。</li>\n<li>统计时间间隔：对于主动触发统计，我们还要支持指定统计时间间隔，也就是多久触发一次统计显示。比如，每间隔10s统计一次接口信息并显示到命令行中，每间隔24小时发送一封统计信息邮件。</li>\n</ul><h3>2.非功能性需求分析</h3><p>对于这样一个通用的框架的开发，我们还需要考虑很多非功能性的需求。具体来讲，我总结了以下几个比较重要的方面。</p><ul>\n<li>易用性</li>\n</ul><p>易用性听起来更像是一个评判产品的标准。没错，我们在开发这样一个技术框架的时候，也要有产品意识。框架是否易集成、易插拔、跟业务代码是否松耦合、提供的接口是否够灵活等等，都是我们应该花心思去思考和设计的。有的时候，文档写得好坏甚至都有可能决定一个框架是否受欢迎。</p><ul>\n<li>性能</li>\n</ul><p>对于需要集成到业务系统的框架来说，我们不希望框架本身的代码执行效率，对业务系统有太多性能上的影响。对于性能计数器这个框架来说，一方面，我们希望它是低延迟的，也就是说，统计代码不影响或很少影响接口本身的响应时间；另一方面，我们希望框架本身对内存的消耗不能太大。</p><ul>\n<li>扩展性</li>\n</ul><p>这里说的扩展性跟之前讲到的代码的扩展性有点类似，都是指在不修改或尽量少修改代码的情况下添加新的功能。但是这两者也有区别。之前讲到的扩展是从框架代码开发者的角度来说的。这里所说的扩展是从框架使用者的角度来说的，特指使用者可以在不修改框架源码，甚至不拿到框架源码的情况下，为框架扩展新的功能。这就有点类似给框架开发插件。关于这一点，我举一个例子来解释一下。</p><p>feign是一个HTTP客户端框架，我们可以在不修改框架源码的情况下，用如下方式来扩展我们自己的编解码方式、日志、拦截器等。</p><pre><code>Feign feign = Feign.builder()\n        .logger(new CustomizedLogger())\n        .encoder(new FormEncoder(new JacksonEncoder()))\n        .decoder(new JacksonDecoder())\n        .errorDecoder(new ResponseErrorDecoder())\n        .requestInterceptor(new RequestHeadersInterceptor()).build();\n\npublic class RequestHeadersInterceptor implements RequestInterceptor {  \n  @Override\n  public void apply(RequestTemplate template) {\n    template.header(&quot;appId&quot;, &quot;...&quot;);\n    template.header(&quot;version&quot;, &quot;...&quot;);\n    template.header(&quot;timestamp&quot;, &quot;...&quot;);\n    template.header(&quot;token&quot;, &quot;...&quot;);\n    template.header(&quot;idempotent-token&quot;, &quot;...&quot;);\n    template.header(&quot;sequence-id&quot;, &quot;...&quot;);\n}\n\npublic class CustomizedLogger extends feign.Logger {\n  //...\n}\n\npublic class ResponseErrorDecoder implements ErrorDecoder {\n  @Override\n  public Exception decode(String methodKey, Response response) {\n    //...\n  }\n}\n</code></pre><ul>\n<li>容错性</li>\n</ul><p>容错性这一点也非常重要。对于性能计数器框架来说，不能因为框架本身的异常导致接口请求出错。所以，我们要对框架可能存在的各种异常情况都考虑全面，对外暴露的接口抛出的所有运行时、非运行时异常都进行捕获处理。</p><ul>\n<li>通用性</li>\n</ul><p>为了提高框架的复用性，能够灵活应用到各种场景中。框架在设计的时候，要尽可能通用。我们要多去思考一下，除了接口统计这样一个需求，还可以适用到其他哪些场景中，比如是否还可以处理其他事件的统计信息，比如SQL请求时间的统计信息、业务统计信息（比如支付成功率）等。</p><h2>框架设计</h2><p>前面讲了需求分析，现在我们来看如何针对需求做框架设计。</p><p>对于稍微复杂系统的开发，很多人觉得不知从何开始。我个人喜欢借鉴TDD（测试驱动开发）和Prototype（最小原型）的思想，先聚焦于一个简单的应用场景，基于此设计实现一个简单的原型。尽管这个最小原型系统在功能和非功能特性上都不完善，但它能够看得见、摸得着，比较具体、不抽象，能够很有效地帮助我缕清更复杂的设计思路，是迭代设计的基础。</p><p>这就好比做算法题目。当我们想要一下子就想出一个最优解法时，可以先写几组测试数据，找找规律，再先想一个最简单的算法去解决它。虽然这个最简单的算法在时间、空间复杂度上可能都不令人满意，但是我们可以基于此来做优化，这样思路就会更加顺畅。</p><p>对于性能计数器这个框架的开发来说，我们可以先聚焦于一个非常具体、简单的应用场景，比如统计用户注册、登录这两个接口的响应时间的最大值和平均值、接口调用次数，并且将统计结果以JSON的格式输出到命令行中。现在这个需求简单、具体、明确，设计实现起来难度降低了很多。</p><p>我们先给出应用场景的代码。具体如下所示：</p><pre><code>//应用场景：统计下面两个接口(注册和登录）的响应时间和访问次数\npublic class UserController {\n  public void register(UserVo user) {\n    //...\n  }\n  \n  public UserVo login(String telephone, String password) {\n    //...\n  }\n}\n</code></pre><p>要输出接口的响应时间的最大值、平均值和接口调用次数，我们首先要采集每次接口请求的响应时间，并且存储起来，然后按照某个时间间隔做聚合统计，最后才是将结果输出。在原型系统的代码实现中，我们可以把所有代码都塞到一个类中，暂时不用考虑任何代码质量、线程安全、性能、扩展性等等问题，怎么简单怎么来就行。</p><p>最小原型的代码实现如下所示。其中，recordResponseTime()和recordTimestamp()两个函数分别用来记录接口请求的响应时间和访问时间。startRepeatedReport()函数以指定的频率统计数据并输出结果。</p><pre><code>public class Metrics {\n  // Map的key是接口名称，value对应接口请求的响应时间或时间戳；\n  private Map&lt;String, List&lt;Double&gt;&gt; responseTimes = new HashMap&lt;&gt;();\n  private Map&lt;String, List&lt;Double&gt;&gt; timestamps = new HashMap&lt;&gt;();\n  private ScheduledExecutorService executor = Executors.newSingleThreadScheduledExecutor();\n\n  public void recordResponseTime(String apiName, double responseTime) {\n    responseTimes.putIfAbsent(apiName, new ArrayList&lt;&gt;());\n    responseTimes.get(apiName).add(responseTime);\n  }\n\n  public void recordTimestamp(String apiName, double timestamp) {\n    timestamps.putIfAbsent(apiName, new ArrayList&lt;&gt;());\n    timestamps.get(apiName).add(timestamp);\n  }\n\n  public void startRepeatedReport(long period, TimeUnit unit){\n    executor.scheduleAtFixedRate(new Runnable() {\n      @Override\n      public void run() {\n        Gson gson = new Gson();\n        Map&lt;String, Map&lt;String, Double&gt;&gt; stats = new HashMap&lt;&gt;();\n        for (Map.Entry&lt;String, List&lt;Double&gt;&gt; entry : responseTimes.entrySet()) {\n          String apiName = entry.getKey();\n          List&lt;Double&gt; apiRespTimes = entry.getValue();\n          stats.putIfAbsent(apiName, new HashMap&lt;&gt;());\n          stats.get(apiName).put(&quot;max&quot;, max(apiRespTimes));\n          stats.get(apiName).put(&quot;avg&quot;, avg(apiRespTimes));\n        }\n  \n        for (Map.Entry&lt;String, List&lt;Double&gt;&gt; entry : timestamps.entrySet()) {\n          String apiName = entry.getKey();\n          List&lt;Double&gt; apiTimestamps = entry.getValue();\n          stats.putIfAbsent(apiName, new HashMap&lt;&gt;());\n          stats.get(apiName).put(&quot;count&quot;, (double)apiTimestamps.size());\n        }\n        System.out.println(gson.toJson(stats));\n      }\n    }, 0, period, unit);\n  }\n\n  private double max(List&lt;Double&gt; dataset) {//省略代码实现}\n  private double avg(List&lt;Double&gt; dataset) {//省略代码实现}\n}\n</code></pre><p>我们通过不到50行代码就实现了最小原型。接下来，我们再来看，如何用它来统计注册、登录接口的响应时间和访问次数。具体的代码如下所示：</p><pre><code>//应用场景：统计下面两个接口(注册和登录）的响应时间和访问次数\npublic class UserController {\n  private Metrics metrics = new Metrics();\n  \n  public UserController() {\n    metrics.startRepeatedReport(60, TimeUnit.SECONDS);\n  }\n\n  public void register(UserVo user) {\n    long startTimestamp = System.currentTimeMillis();\n    metrics.recordTimestamp(&quot;regsiter&quot;, startTimestamp);\n    //...\n    long respTime = System.currentTimeMillis() - startTimestamp;\n    metrics.recordResponseTime(&quot;register&quot;, respTime);\n  }\n\n  public UserVo login(String telephone, String password) {\n    long startTimestamp = System.currentTimeMillis();\n    metrics.recordTimestamp(&quot;login&quot;, startTimestamp);\n    //...\n    long respTime = System.currentTimeMillis() - startTimestamp;\n    metrics.recordResponseTime(&quot;login&quot;, respTime);\n  }\n}\n</code></pre><p>最小原型的代码实现虽然简陋，但它却帮我们将思路理顺了很多，我们现在就基于它做最终的框架设计。下面是我针对性能计数器框架画的一个粗略的系统设计图。图可以非常直观地体现设计思想，并且能有效地帮助我们释放更多的脑空间，来思考其他细节问题。</p><p><img src=\"https://static001.geekbang.org/resource/image/92/16/926561b82b49c937dcf4a2b9e6b35c16.jpg\" alt=\"\"></p><p>如图所示，我们把整个框架分为四个模块：数据采集、存储、聚合统计、显示。每个模块负责的工作简单罗列如下。</p><ul>\n<li>数据采集：负责打点采集原始数据，包括记录每次接口请求的响应时间和请求时间。数据采集过程要高度容错，不能影响到接口本身的可用性。除此之外，因为这部分功能是暴露给框架的使用者的，所以在设计数据采集API的时候，我们也要尽量考虑其易用性。</li>\n<li>存储：负责将采集的原始数据保存下来，以便后面做聚合统计。数据的存储方式有多种，比如：Redis、MySQL、HBase、日志、文件、内存等。数据存储比较耗时，为了尽量地减少对接口性能（比如响应时间）的影响，采集和存储的过程异步完成。</li>\n<li>聚合统计：负责将原始数据聚合为统计数据，比如：max、min、avg、pencentile、count、tps等。为了支持更多的聚合统计规则，代码希望尽可能灵活、可扩展。</li>\n<li>显示：负责将统计数据以某种格式显示到终端，比如：输出到命令行、邮件、网页、自定义显示终端等。</li>\n</ul><p>前面讲到面向对象分析、设计和实现的时候，我们讲到设计阶段最终输出的是类的设计，同时也讲到，软件设计开发是一个迭代的过程，分析、设计和实现这三个阶段的界限划分并不明显。所以，今天我们只给出了比较粗略的模块划分，至于更加详细的设计，我们留在下一节课中跟实现一块来讲解。</p><h2>重点回顾</h2><p>今天的内容到此就讲完了。我们来一起总结回顾一下，你需要掌握的重点内容。</p><p>对于非业务通用框架的开发，我们在做需求分析的时候，除了功能性需求分析之外，还需要考虑框架的非功能性需求。比如，框架的易用性、性能、扩展性、容错性、通用性等。</p><p>对于复杂框架的设计，很多人往往觉得无从下手。今天我们分享了几个小技巧，其中包括：画产品线框图、聚焦简单应用场景、设计实现最小原型、画系统设计图等。这些方法的目的都是为了让问题简化、具体、明确，提供一个迭代设计开发的基础，逐步推进。</p><p>实际上，不仅仅是软件设计开发，不管做任何事情，如果我们总是等到所有的东西都想好了再开始，那这件事情可能永远都开始不了。有句老话讲：万事开头难，所以，先迈出第一步很重要。</p><h2>课堂讨论</h2><p>今天的课堂讨论题有下面两道。</p><ol>\n<li>应对复杂系统的设计实现，我今天讲到了聚焦简单场景、最小原型、画图等几个技巧，你还有什么经验可以分享给大家吗？</li>\n<li>今天提到的线框图、最小原型、易用性等，实际上都是产品设计方面的手段或者概念，应用到像框架这样的技术产品的设计上也非常有用。你觉得对于一个技术人来说，产品能力是否同样重要呢？技术人是否应该具备一些产品思维呢？</li>\n</ol><p>欢迎在留言区写下你的答案，和同学一起交流和分享。如果有收获，也欢迎你把这篇文章分享给你的朋友。</p>",
                "article_title": "25 | 实战二（上）：针对非业务的通用框架开发，如何做需求分析和设计？"
            },
            {
                "title": "26 | 实战二（下）：如何实现一个支持各种统计规则的性能计数器？",
                "herf": "https://time.geekbang.org/column/article/179673",
                "id": "179673",
                "content": "<p>在上一节课中，我们对计数器框架做了需求分析和粗略的模块划分。今天这节课，我们利用面向对象设计、实现方法，并结合之前学过的设计思想、设计原则来看一下，如何编写灵活、可扩展的、高质量的代码实现。</p><p>话不多说，现在就让我们正式开始今天的学习吧！</p><h2>小步快跑、逐步迭代</h2><p>在上一节课中，我们将整个框架分为数据采集、存储、聚合统计、显示这四个模块。除此之外，关于统计触发方式（主动推送、被动触发统计）、统计时间区间（统计哪一个时间段内的数据）、统计时间间隔（对于主动推送方法，多久统计推送一次）我们也做了简单的设计。这里我就不重新描述了，你可以打开上一节课回顾一下。</p><p>虽然上一节课的最小原型为我们奠定了迭代开发的基础，但离我们最终期望的框架的样子还有很大的距离。我自己在写这篇文章的时候，试图去实现上面罗列的所有功能需求，希望写出一个完美的框架，发现这是件挺烧脑的事情，在写代码的过程中，一直有种“脑子不够使”的感觉。我这个有十多年工作经验的人尚且如此，对于没有太多经验的开发者来说，想一下子把所有需求都实现出来，更是一件非常有挑战的事情。一旦无法顺利完成，你可能就会有很强的挫败感，就会陷入自我否定的情绪中。</p><p>不过，即便你有能力将所有需求都实现，可能也要花费很大的设计精力和开发时间，迟迟没有产出，你的leader会因此产生很强的不可控感。对于现在的互联网项目来说，小步快跑、逐步迭代是一种更好的开发模式。所以，我们应该分多个版本逐步完善这个框架。第一个版本可以先实现一些基本功能，对于更高级、更复杂的功能，以及非功能性需求不做过高的要求，在后续的v2.0、v3.0……版本中继续迭代优化。</p><!-- [[[read_end]]] --><p>针对这个框架的开发，我们在v1.0版本中，暂时只实现下面这些功能。剩下的功能留在v2.0、v3.0版本，也就是我们后面的第39节和第40节课中再来讲解。</p><ul>\n<li>数据采集：负责打点采集原始数据，包括记录每次接口请求的响应时间和请求时间。</li>\n<li>存储：负责将采集的原始数据保存下来，以便之后做聚合统计。数据的存储方式有很多种，我们暂时只支持Redis这一种存储方式，并且，采集与存储两个过程同步执行。</li>\n<li>聚合统计：负责将原始数据聚合为统计数据，包括响应时间的最大值、最小值、平均值、99.9百分位值、99百分位值，以及接口请求的次数和tps。</li>\n<li>显示：负责将统计数据以某种格式显示到终端，暂时只支持主动推送给命令行和邮件。命令行间隔n秒统计显示上m秒的数据（比如，间隔60s统计上60s的数据）。邮件每日统计上日的数据。</li>\n</ul><p>现在这个版本的需求比之前的要更加具体、简单了，实现起来也更加容易一些。实际上，学会结合具体的需求，做合理的预判、假设、取舍，规划版本的迭代设计开发，也是一个资深工程师必须要具备的能力。</p><h2>面向对象设计与实现</h2><p>在<a href=\"https://time.geekbang.org/column/article/171760\">第13节</a>和<a href=\"https://time.geekbang.org/column/article/171767\">第14节</a>课中，我们把面向对象设计与实现分开来讲解，界限划分比较明显。在实际的软件开发中，这两个过程往往是交叉进行的。一般是先有一个粗糙的设计，然后着手实现，实现的过程发现问题，再回过头来补充修改设计。所以，对于这个框架的开发来说，我们把设计和实现放到一块来讲解。</p><p>回顾上一节课中的最小原型的实现，所有的代码都耦合在一个类中，这显然是不合理的。接下来，我们就按照之前讲的面向对象设计的几个步骤，来重新划分、设计类。</p><h3>1.划分职责进而识别出有哪些类</h3><p>根据需求描述，我们先大致识别出下面几个接口或类。这一步不难，完全就是翻译需求。</p><ul>\n<li>MetricsCollector类负责提供API，来采集接口请求的原始数据。我们可以为MetricsCollector抽象出一个接口，但这并不是必须的，因为暂时我们只能想到一个MetricsCollector的实现方式。</li>\n<li>MetricsStorage接口负责原始数据存储，RedisMetricsStorage类实现MetricsStorage接口。这样做是为了今后灵活地扩展新的存储方法，比如用HBase来存储。</li>\n<li>Aggregator类负责根据原始数据计算统计数据。</li>\n<li>ConsoleReporter类、EmailReporter类分别负责以一定频率统计并发送统计数据到命令行和邮件。至于ConsoleReporter和EmailReporter是否可以抽象出可复用的抽象类，或者抽象出一个公共的接口，我们暂时还不能确定。</li>\n</ul><h3>2.定义类及类与类之间的关系</h3><p>接下来就是定义类及属性和方法，定义类与类之间的关系。这两步没法分得很开，所以，我们今天将它们合在一起来讲解。</p><p>大致地识别出几个核心的类之后，我的习惯性做法是，先在IDE中创建好这几个类，然后开始试着定义它们的属性和方法。在设计类、类与类之间交互的时候，我会不断地用之前学过的设计原则和思想来审视设计是否合理，比如，是否满足单一职责原则、开闭原则、依赖注入、KISS原则、DRY原则、迪米特法则，是否符合基于接口而非实现编程思想，代码是否高内聚、低耦合，是否可以抽象出可复用代码等等。</p><p>MetricsCollector类的定义非常简单，具体代码如下所示。对比上一节课中最小原型的代码，MetricsCollector通过引入RequestInfo类来封装原始数据信息，用一个采集函数代替了之前的两个函数。</p><pre><code>public class MetricsCollector {\n  private MetricsStorage metricsStorage;//基于接口而非实现编程\n\n  //依赖注入\n  public MetricsCollector(MetricsStorage metricsStorage) {\n    this.metricsStorage = metricsStorage;\n  }\n\n  //用一个函数代替了最小原型中的两个函数\n  public void recordRequest(RequestInfo requestInfo) {\n    if (requestInfo == null || StringUtils.isBlank(requestInfo.getApiName())) {\n      return;\n    }\n    metricsStorage.saveRequestInfo(requestInfo);\n  }\n}\n\npublic class RequestInfo {\n  private String apiName;\n  private double responseTime;\n  private long timestamp;\n  //...省略constructor/getter/setter方法...\n}\n</code></pre><p>MetricsStorage类和RedisMetricsStorage类的属性和方法也比较明确。具体的代码实现如下所示。注意，一次性取太长时间区间的数据，可能会导致拉取太多的数据到内存中，有可能会撑爆内存。对于Java来说，就有可能会触发OOM（Out Of Memory）。而且，即便不出现OOM，\b内存还够用，但也会因为内存吃紧，导致频繁的Full GC，进而导致系统接口请求处理变慢，甚至超时。这个问题解决起来并不难，先留给你自己思考一下。我会在第40节课中解答。</p><pre><code>public interface MetricsStorage {\n  void saveRequestInfo(RequestInfo requestInfo);\n\n  List&lt;RequestInfo&gt; getRequestInfos(String apiName, long startTimeInMillis, long endTimeInMillis);\n\n  Map&lt;String, List&lt;RequestInfo&gt;&gt; getRequestInfos(long startTimeInMillis, long endTimeInMillis);\n}\n\npublic class RedisMetricsStorage implements MetricsStorage {\n  //...省略属性和构造函数等...\n  @Override\n  public void saveRequestInfo(RequestInfo requestInfo) {\n    //...\n  }\n\n  @Override\n  public List&lt;RequestInfo&gt; getRequestInfos(String apiName, long startTimestamp, long endTimestamp) {\n    //...\n  }\n\n  @Override\n  public Map&lt;String, List&lt;RequestInfo&gt;&gt; getRequestInfos(long startTimestamp, long endTimestamp) {\n    //...\n  }\n}\n</code></pre><p>MetricsCollector类和MetricsStorage类的设计思路比较简单，不同的人给出的设计结果应该大差不差。但是，统计和显示这两个功能就不一样了，可以有多种设计思路。实际上，如果我们把统计显示所要完成的功能逻辑细分一下的话，主要包含下面4点：</p><ol>\n<li>根据给定的时间区间，从数据库中拉取数据；</li>\n<li>根据原始数据，计算得到统计数据；</li>\n<li>将统计数据显示到终端（命令行或邮件）；</li>\n<li>定时触发以上3个过程的执行。</li>\n</ol><p>实际上，如果用一句话总结一下的话，<strong>面向对象设计和实现要做的事情，就是把合适的代码放到合适的类中</strong>。所以，我们现在要做的工作就是，把以上的4个功能逻辑划分到几个类中。划分的方法有很多种，比如，我们可以把前两个逻辑放到一个类中，第3个逻辑放到另外一个类中，第4个逻辑作为上帝类（God Class）组合前面两个类来触发前3个逻辑的执行。当然，我们也可以把第2个逻辑单独放到一个类中，第1、3、4都放到另外一个类中。</p><p>至于到底选择哪种排列组合方式，判定的标准是，让代码尽量地满足低耦合、高内聚、单一职责、对扩展开放对修改关闭等之前讲到的各种设计原则和思想，尽量地让设计满足代码易复用、易读、易扩展、易维护。</p><p>我们暂时选择把第1、3、4逻辑放到ConsoleReporter或EmailReporter类中，把第2个逻辑放到Aggregator类中。其中，Aggregator类负责的逻辑比较简单，我们把它设计成只包含静态方法的工具类。具体的代码实现如下所示：</p><pre><code>public class Aggregator {\n  public static RequestStat aggregate(List&lt;RequestInfo&gt; requestInfos, long durationInMillis) {\n    double maxRespTime = Double.MIN_VALUE;\n    double minRespTime = Double.MAX_VALUE;\n    double avgRespTime = -1;\n    double p999RespTime = -1;\n    double p99RespTime = -1;\n    double sumRespTime = 0;\n    long count = 0;\n    for (RequestInfo requestInfo : requestInfos) {\n      ++count;\n      double respTime = requestInfo.getResponseTime();\n      if (maxRespTime &lt; respTime) {\n        maxRespTime = respTime;\n      }\n      if (minRespTime &gt; respTime) {\n        minRespTime = respTime;\n      }\n      sumRespTime += respTime;\n    }\n    if (count != 0) {\n      avgRespTime = sumRespTime / count;\n    }\n    long tps = (long)(count / durationInMillis * 1000);\n    Collections.sort(requestInfos, new Comparator&lt;RequestInfo&gt;() {\n      @Override\n      public int compare(RequestInfo o1, RequestInfo o2) {\n        double diff = o1.getResponseTime() - o2.getResponseTime();\n        if (diff &lt; 0.0) {\n          return -1;\n        } else if (diff &gt; 0.0) {\n          return 1;\n        } else {\n          return 0;\n        }\n      }\n    });\n    int idx999 = (int)(count * 0.999);\n    int idx99 = (int)(count * 0.99);\n    if (count != 0) {\n      p999RespTime = requestInfos.get(idx999).getResponseTime();\n      p99RespTime = requestInfos.get(idx99).getResponseTime();\n    }\n    RequestStat requestStat = new RequestStat();\n    requestStat.setMaxResponseTime(maxRespTime);\n    requestStat.setMinResponseTime(minRespTime);\n    requestStat.setAvgResponseTime(avgRespTime);\n    requestStat.setP999ResponseTime(p999RespTime);\n    requestStat.setP99ResponseTime(p99RespTime);\n    requestStat.setCount(count);\n    requestStat.setTps(tps);\n    return requestStat;\n  }\n}\n\npublic class RequestStat {\n  private double maxResponseTime;\n  private double minResponseTime;\n  private double avgResponseTime;\n  private double p999ResponseTime;\n  private double p99ResponseTime;\n  private long count;\n  private long tps;\n  //...省略getter/setter方法...\n}\n</code></pre><p>ConsoleReporter类相当于一个上帝类，定时根据给定的时间区间，从数据库中取出数据，借助Aggregator类完成统计工作，并将统计结果输出到命令行。具体的代码实现如下所示：</p><pre><code>public class ConsoleReporter {\n  private MetricsStorage metricsStorage;\n  private ScheduledExecutorService executor;\n\n  public ConsoleReporter(MetricsStorage metricsStorage) {\n    this.metricsStorage = metricsStorage;\n    this.executor = Executors.newSingleThreadScheduledExecutor();\n  }\n  \n  // 第4个代码逻辑：定时触发第1、2、3代码逻辑的执行；\n  public void startRepeatedReport(long periodInSeconds, long durationInSeconds) {\n    executor.scheduleAtFixedRate(new Runnable() {\n      @Override\n      public void run() {\n        // 第1个代码逻辑：根据给定的时间区间，从数据库中拉取数据；\n        long durationInMillis = durationInSeconds * 1000;\n        long endTimeInMillis = System.currentTimeMillis();\n        long startTimeInMillis = endTimeInMillis - durationInMillis;\n        Map&lt;String, List&lt;RequestInfo&gt;&gt; requestInfos =\n                metricsStorage.getRequestInfos(startTimeInMillis, endTimeInMillis);\n        Map&lt;String, RequestStat&gt; stats = new HashMap&lt;&gt;();\n        for (Map.Entry&lt;String, List&lt;RequestInfo&gt;&gt; entry : requestInfos.entrySet()) {\n          String apiName = entry.getKey();\n          List&lt;RequestInfo&gt; requestInfosPerApi = entry.getValue();\n          // 第2个代码逻辑：根据原始数据，计算得到统计数据；\n          RequestStat requestStat = Aggregator.aggregate(requestInfosPerApi, durationInMillis);\n          stats.put(apiName, requestStat);\n        }\n        // 第3个代码逻辑：将统计数据显示到终端（命令行或邮件）；\n        System.out.println(&quot;Time Span: [&quot; + startTimeInMillis + &quot;, &quot; + endTimeInMillis + &quot;]&quot;);\n        Gson gson = new Gson();\n        System.out.println(gson.toJson(stats));\n      }\n    }, 0, periodInSeconds, TimeUnit.SECONDS);\n  }\n}\n\npublic class EmailReporter {\n  private static final Long DAY_HOURS_IN_SECONDS = 86400L;\n\n  private MetricsStorage metricsStorage;\n  private EmailSender emailSender;\n  private List&lt;String&gt; toAddresses = new ArrayList&lt;&gt;();\n\n  public EmailReporter(MetricsStorage metricsStorage) {\n    this(metricsStorage, new EmailSender(/*省略参数*/));\n  }\n\n  public EmailReporter(MetricsStorage metricsStorage, EmailSender emailSender) {\n    this.metricsStorage = metricsStorage;\n    this.emailSender = emailSender;\n  }\n\n  public void addToAddress(String address) {\n    toAddresses.add(address);\n  }\n\n  public void startDailyReport() {\n    Calendar calendar = Calendar.getInstance();\n    calendar.add(Calendar.DATE, 1);\n    calendar.set(Calendar.HOUR_OF_DAY, 0);\n    calendar.set(Calendar.MINUTE, 0);\n    calendar.set(Calendar.SECOND, 0);\n    calendar.set(Calendar.MILLISECOND, 0);\n    Date firstTime = calendar.getTime();\n    Timer timer = new Timer();\n    timer.schedule(new TimerTask() {\n      @Override\n      public void run() {\n        long durationInMillis = DAY_HOURS_IN_SECONDS * 1000;\n        long endTimeInMillis = System.currentTimeMillis();\n        long startTimeInMillis = endTimeInMillis - durationInMillis;\n        Map&lt;String, List&lt;RequestInfo&gt;&gt; requestInfos =\n                metricsStorage.getRequestInfos(startTimeInMillis, endTimeInMillis);\n        Map&lt;String, RequestStat&gt; stats = new HashMap&lt;&gt;();\n        for (Map.Entry&lt;String, List&lt;RequestInfo&gt;&gt; entry : requestInfos.entrySet()) {\n          String apiName = entry.getKey();\n          List&lt;RequestInfo&gt; requestInfosPerApi = entry.getValue();\n          RequestStat requestStat = Aggregator.aggregate(requestInfosPerApi, durationInMillis);\n          stats.put(apiName, requestStat);\n        }\n        // TODO: 格式化为html格式，并且发送邮件\n      }\n    }, firstTime, DAY_HOURS_IN_SECONDS * 1000);\n  }\n}\n</code></pre><h3>3.将类组装起来并提供执行入口</h3><p>因为这个框架稍微有些特殊，有两个执行入口：一个是MetricsCollector类，提供了一组API来采集原始数据；另一个是ConsoleReporter类和EmailReporter类，用来触发统计显示。框架具体的使用方式如下所示：</p><pre><code>public class Demo {\n  public static void main(String[] args) {\n    MetricsStorage storage = new RedisMetricsStorage();\n    ConsoleReporter consoleReporter = new ConsoleReporter(storage);\n    consoleReporter.startRepeatedReport(60, 60);\n\n    EmailReporter emailReporter = new EmailReporter(storage);\n    emailReporter.addToAddress(&quot;wangzheng@xzg.com&quot;);\n    emailReporter.startDailyReport();\n\n    MetricsCollector collector = new MetricsCollector(storage);\n    collector.recordRequest(new RequestInfo(&quot;register&quot;, 123, 10234));\n    collector.recordRequest(new RequestInfo(&quot;register&quot;, 223, 11234));\n    collector.recordRequest(new RequestInfo(&quot;register&quot;, 323, 12334));\n    collector.recordRequest(new RequestInfo(&quot;login&quot;, 23, 12434));\n    collector.recordRequest(new RequestInfo(&quot;login&quot;, 1223, 14234));\n\n    try {\n      Thread.sleep(100000);\n    } catch (InterruptedException e) {\n      e.printStackTrace();\n    }\n  }\n}\n</code></pre><h2>Review设计与实现</h2><p>我们前面讲到了SOLID、KISS、DRY、YAGNI、LOD等设计原则，基于接口而非实现编程、多用组合少用继承、高内聚低耦合等设计思想。我们现在就来看下，上面的代码实现是否符合这些设计原则和思想。</p><ul>\n<li>MetricsCollector</li>\n</ul><p>MetricsCollector负责采集和存储数据，职责相对来说还算比较单一。它基于接口而非实现编程，通过依赖注入的方式来传递MetricsStorage对象，可以在不需要修改代码的情况下，灵活地替换不同的存储方式，满足开闭原则。</p><ul>\n<li>MetricsStorage、RedisMetricsStorage</li>\n</ul><p>MetricsStorage和RedisMetricsStorage的设计比较简单。当我们需要实现新的存储方式的时候，只需要实现MetricsStorage接口即可。因为所有用到MetricsStorage和RedisMetricsStorage的地方，都是基于相同的接口函数来编程的，所以，除了在组装类的地方有所改动（从RedisMetricsStorage改为新的存储实现类），其他接口函数调用的地方都不需要改动，满足开闭原则。</p><ul>\n<li>Aggregator</li>\n</ul><p>Aggregator类是一个工具类，里面只有一个静态函数，有50行左右的代码量，负责各种统计数据的计算。当需要扩展新的统计功能的时候，需要修改aggregate()函数代码，并且一旦越来越多的统计功能添加进来之后，这个函数的代码量会持续增加，可读性、可维护性就变差了。所以，从刚刚的分析来看，这个类的设计可能存在职责不够单一、不易扩展等问题，需要在之后的版本中，对其结构做优化。</p><ul>\n<li>ConsoleReporter、EmailReporter</li>\n</ul><p>ConsoleReporter和EmailReporter中存在代码重复问题。在这两个类中，从数据库中取数据、做统计的逻辑都是相同的，可以抽取出来复用，否则就违反了DRY原则。而且整个类负责的事情比较多，职责不是太单一。特别是显示部分的代码，可能会比较复杂（比如Email的展示方式），最好是将显示部分的代码逻辑拆分成独立的类。除此之外，因为代码中涉及线程操作，并且调用了Aggregator的静态函数，所以代码的可测试性不好。</p><p>今天我们给出的代码实现还是有诸多问题的，在后面的章节（第39、40讲）中，我们会慢慢优化，给你展示整个设计演进的过程，这比直接给你最终的最优方案要有意义得多！实际上，优秀的代码都是重构出来的，复杂的代码都是慢慢堆砌出来的 。所以，当你看到那些优秀而复杂的开源代码或者项目代码的时候，也不必自惭形秽，觉得自己写不出来。毕竟罗马不是一天建成的，这些优秀的代码也是靠几年的时间慢慢迭代优化出来的。</p><h2>重点回顾</h2><p>好了，今天的内容到此就讲完了。我们一块总结回顾一下，你需要掌握的重点内容。</p><p>写代码的过程本就是一个修修改改、不停调整的过程，肯定不是一气呵成的。你看到的那些大牛开源项目的设计和实现，也都是在不停优化、修改过程中产生的。比如，我们熟悉的Unix系统，第一版很简单、粗糙，代码不到1万行。所以，迭代思维很重要，不要刚开始就追求完美。</p><p>面向对象设计和实现要做的事情，就是把合适的代码放到合适的类中。至于到底选择哪种划分方法，判定的标准是让代码尽量地满足低耦合、高内聚、单一职责、对扩展开放对修改关闭等之前讲的各种设计原则和思想，尽量地做到代码可复用、易读、易扩展、易维护。</p><h2>课堂讨论</h2><p>今天课堂讨论题有下面两道。</p><ol>\n<li>对于今天的设计与代码实现，你有没有发现哪些不合理的地方？有哪些可以继续优化的地方呢？或者留言说说你的设计方案。</li>\n<li>说一个你觉得不错的开源框架或者项目，聊聊你为什么觉得它不错？</li>\n</ol><p>欢迎在留言区写下你的答案，和同学一起交流和分享。如果有收获，也欢迎你把这篇文章分享给你的朋友。</p>",
                "article_title": "26 | 实战二（下）：如何实现一个支持各种统计规则的性能计数器？"
            }
        ]
    },
    {
        "chapterTitle": "设计原则与思想：规范与重构 (11讲)",
        "children": [
            {
                "title": "27 | 理论一：什么情况下要重构？到底重构什么？又该如何重构？",
                "herf": "https://time.geekbang.org/column/article/179679",
                "id": "179679",
                "content": "<p>“重构”这个词对于大部分工程师来说都不陌生。不过，据我了解，大部分人都只是“听得多做得少”，真正进行过代码重构的人不多，而把持续重构作为开发的一部分的人，就更是少之又少了。</p><p>一方面，重构代码对一个工程师能力的要求，要比单纯写代码高得多。重构需要你能洞察出代码存在的坏味道或者设计上的不足，并且能合理、熟练地利用设计思想、原则、模式、编程规范等理论知识解决这些问题。</p><p>另一方面，很多工程师对为什么要重构、到底重构什么、什么时候重构、又该如何重构等相关问题理解不深，对重构没有系统性、全局性的认识，面对一堆烂代码，没有重构技巧的指导，只能想到哪改到哪，并不能全面地改善代码质量。</p><p>为了让你对重构有个清晰的认识，对于这部分知识的讲解，我安排了六节课的内容，主要包含以下几个方面：</p><ul>\n<li>对重构概括性的介绍，包括重构的目的（why）、对象（what）、时机（when）、方法（how）；</li>\n<li>保证重构不出错的手段，这里我会重点讲解单元测试和代码的可测试性；</li>\n<li>不同规模的重构，重点讲解大规模高层次重构（比如系统、模块、代码结构、类与类之间的交互等的重构）和小规模低层次重构（类、函数、变量等的重构）。</li>\n</ul><p>话不多说，现在就让我们来学习第一部分内容：重构的目的、对象、时机和方法。</p><!-- [[[read_end]]] --><h2>重构的目的：为什么要重构（why）？</h2><p>虽然对于你来说，重构这个词可能不需要过多解释，但我们还是简单来看一下，大师是怎么描述它的。软件设计大师Martin Fowler 是这样定义重构的：“重构是一种对软件内部结构的改善，目的是在不改变软件的可见行为的情况下，使其更易理解，修改成本更低。”</p><p>实际上，当讲到重构的时候，很多书籍都会引用这个定义。这个定义中有一个值得强调的点：“重构不改变外部的可见行为”。我们可以把重构理解为，在保持功能不变的前提下，利用设计思想、原则、模式、编程规范等理论来优化代码，修改设计上的不足，提高代码质量。</p><p><strong>简单了解重构的定义之后，我们重点来看一下，为什么要进行代码重构？</strong></p><p>首先，重构是时刻保证代码质量的一个极其有效的手段，不至于让代码腐化到无可救药的地步。项目在演进，代码不停地在堆砌。如果没有人为代码的质量负责任，代码总是会往越来越混乱的方向演进。当混乱到一定程度之后，量变引起质变，项目的维护成本已经高过重新开发一套新代码的成本，想要再去重构，已经没有人能做到了。</p><p>其次，优秀的代码或架构不是一开始就能完全设计好的，就像优秀的公司和产品也都是迭代出来的。我们无法100%遇见未来的需求，也没有足够的精力、时间、资源为遥远的未来买单，所以，随着系统的演进，重构代码也是不可避免的。</p><p>最后，重构是避免过度设计的有效手段。在我们维护代码的过程中，真正遇到问题的时候，再对代码进行重构，能有效避免前期投入太多时间做过度的设计，做到有的放矢。</p><p><strong>除此之外，重构对一个工程师本身技术的成长也有重要的意义。</strong></p><p>从前面我给出的重构的定义来看，重构实际上是对我们学习的经典设计思想、设计原则、设计模式、编程规范的一种应用。重构实际上就是将这些理论知识，应用到实践的一个很好的场景，能够锻炼我们熟练使用这些理论知识的能力。除此之外，平时堆砌业务逻辑，你可能总觉得没啥成长，而将一个比较烂的代码重构成一个比较好的代码，会让你很有成就感。</p><p>除此之外，重构能力也是衡量一个工程师代码能力的有效手段。所谓“初级工程师在维护代码，高级工程师在设计代码，资深工程师在重构代码”，这句话的意思是说，初级工程师在已有代码框架下修改bug、修改添加功能代码；高级工程师从零开始设计代码结构、搭建代码框架；而资深工程师为代码质量负责，需要发觉代码存在的问题，重构代码，时刻保证代码质量处于一个可控的状态（当然这里的初级、高级、资深只是一个相对概念，并不是一个确定的职级）。</p><h2>重构的对象：到底重构什么（what）？</h2><p>根据重构的规模，我们可以笼统地分为大规模高层次重构（以下简称为“大型重构”）和小规模低层次的重构（以下简称为“小型重构”）。</p><p>大型重构指的是对顶层代码设计的重构，包括：系统、模块、代码结构、类与类之间的关系等的重构，重构的手段有：分层、模块化、解耦、抽象可复用组件等等。这类重构的工具就是我们学习过的那些设计思想、原则和模式。这类重构涉及的代码改动会比较多，影响面会比较大，所以难度也较大，耗时会比较长，引入bug的风险也会相对比较大。</p><p>小型重构指的是对代码细节的重构，主要是针对类、函数、变量等代码级别的重构，比如规范命名、规范注释、消除超大类或函数、提取重复代码等等。小型重构更多的是利用我们能后面要讲到的编码规范。这类重构要修改的地方比较集中，比较简单，可操作性较强，耗时会比较短，引入bug的风险相对来说也会比较小。你只需要熟练掌握各种编码规范，就可以做到得心应手。</p><p>关于具体如何来做大型重构和小型重构，我会在后面的课程中详细讲解。</p><h2>重构的时机：什么时候重构（when）？</h2><p>搞清楚了为什么重构，到底重构什么，我们再来看一下，什么时候重构？是代码烂到一定程度之后才去重构吗？当然不是。因为当代码真的烂到出现“开发效率低，招了很多人，天天加班，出活却不多，线上bug频发，领导发飙，中层束手无策，工程师抱怨不断，查找bug困难”的时候，基本上重构也无法解决问题了。</p><p>我个人比较反对，平时不注重代码质量，堆砌烂代码，实在维护不了了就大刀阔斧地重构、甚至重写的行为。有时候项目代码太多了，重构很难做得彻底，最后又搞出来一个“四不像的怪物”，这就更麻烦了！所以，寄希望于在代码烂到一定程度之后，集中重构解决所有问题是不现实的，我们必须探索一条<strong>可持续、可演进</strong>的方式。</p><p>所以，我特别提倡的重构策略是持续重构。这也是我在工作中特别喜欢干的事情。平时没有事情的时候，你可以看看项目中有哪些写得不够好的、可以优化的代码，主动去重构一下。或者，在修改、添加某个功能代码的时候，你也可以顺手把不符合编码规范、不好的设计重构一下。总之，就像把单元测试、Code Review作为开发的一部分，我们如果能把持续重构也作为开发的一部分，成为一种开发习惯，对项目、对自己都会很有好处。</p><p>尽管我们说重构能力很重要，但持续重构意识更重要。我们要正确地看待代码质量和重构这件事情。技术在更新、需求在变化、人员在流动，代码质量总会在下降，代码总会存在不完美，重构就会持续在进行。时刻具有持续重构意识，才能避免开发初期就过度设计，避免代码维护的过程中质量的下降。而那些看到别人代码有点瑕疵就一顿乱骂，或者花尽心思去构思一个完美设计的人，往往都是因为没有树立正确的代码质量观，没有持续重构意识。</p><h2>重构的方法：又该如何重构（how）？</h2><p>前面我们讲到，按照重构的规模，重构可以笼统地分为大型重构和小型重构。对于这两种不同规模的重构，我们要区别对待。</p><p>对于大型重构来说，因为涉及的模块、代码会比较多，如果项目代码质量又比较差，耦合比较严重，往往会牵一发而动全身，本来觉得一天就能完成的重构，你会发现越改越多、越改越乱，没一两个礼拜都搞不定。而新的业务开发又与重构相冲突，最后只能半途而废，revert掉所有的改动，很失落地又去堆砌烂代码了。</p><p>在进行大型重构的时候，我们要提前做好完善的重构计划，有条不紊地分阶段来进行。每个阶段完成一小部分代码的重构，然后提交、测试、运行，发现没有问题之后，再继续进行下一阶段的重构，保证代码仓库中的代码一直处于可运行、逻辑正确的状态。每个阶段，我们都要控制好重构影响到的代码范围，考虑好如何兼容老的代码逻辑，必要的时候还需要写一些兼容过渡代码。只有这样，我们才能让每一阶段的重构都不至于耗时太长（最好一天就能完成），不至于与新的功能开发相冲突。</p><p>大规模高层次的重构一定是有组织、有计划，并且非常谨慎的，需要有经验、熟悉业务的资深同事来主导。而小规模低层次的重构，因为影响范围小，改动耗时短，所以，只要你愿意并且有时间，随时都可以去做。实际上，除了人工去发现低层次的质量问题，我们还可以借助很多成熟的静态代码分析工具（比如CheckStyle、FindBugs、PMD），来自动发现代码中的问题，然后针对性地进行重构优化。</p><p>对于重构这件事情，资深的工程师、项目leader要负起责任来，没事就重构一下代码，时刻保证代码质量处在一个良好的状态。否则，一旦出现“破窗效应”，一个人往里堆了一些烂代码，之后就会有更多的人往里堆更烂的代码。毕竟往项目里堆砌烂代码的成本太低了。不过，保持代码质量最好的方法还是打造一种好的技术氛围，以此来驱动大家主动去关注代码质量，持续重构代码。</p><h2>重点回顾</h2><p>今天的讲解比较偏理论、偏思想教育，主要还是让你对重构有个正确的、全局性的认知，建立持续重构意识。我觉得，这可能比教会你一些重构技巧更重要，因为很多技术问题本身就不是单纯靠技术来解决的，更重要的是要有这种认知和意识。</p><p>好了，下面我们还是来总结一下。对于今天的内容，你需要重点理解并且掌握如下知识点。</p><p><strong>1.重构的目的：为什么重构（why）？</strong></p><p>对于项目来言，重构可以保持代码质量持续处于一个可控状态，不至于腐化到无可救药的地步。对于个人而言，重构非常锻炼一个人的代码能力，并且是一件非常有成就感的事情。它是我们学习的经典设计思想、原则、模式、编程规范等理论知识的练兵场。</p><p><strong>2.重构的对象：重构什么（what）？</strong></p><p>按照重构的规模，我们可以将重构大致分为大规模高层次的重构和小规模低层次的重构。大规模高层次重构包括对代码分层、模块化、解耦、梳理类之间的交互关系、抽象复用组件等等。这部分工作利用的更多的是比较抽象、比较顶层的设计思想、原则、模式。小规模低层次的重构包括规范命名、注释、修正函数参数过多、消除超大类、提取重复代码等等编程细节问题，主要是针对类、函数级别的重构。小规模低层次的重构更多的是利用编码规范这一理论知识。</p><p><strong>3.重构的时机：什么时候重构（when）？</strong></p><p>我反复强调，我们一定要建立持续重构意识，把重构作为开发必不可少的部分，融入到日常开发中，而不是等到代码出现很大问题的时候，再大刀阔斧地重构。</p><p><strong>4.重构的方法：如何重构（how）？</strong></p><p>大规模高层次的重构难度比较大，需要组织、有计划地进行，分阶段地小步快跑，时刻让代码处于一个可运行的状态。而小规模低层次的重构，因为影响范围小，改动耗时短，所以，只要你愿意并且有时间，随时随地都可以去做。</p><h2>课堂讨论</h2><p>今天课堂讨论的话题是：关于代码重构，你有什么心得体会、经验教训？或者，你也可以说说，在重构过往项目的时候，你遇到过哪些问题？</p><p>欢迎在留言区写下你的答案，和同学一起交流和分享。如果有收获，也欢迎你把这篇文章分享给你的朋友。</p>",
                "article_title": "27 | 理论一：什么情况下要重构？到底重构什么？又该如何重构？"
            },
            {
                "title": "28 | 理论二：为了保证重构不出错，有哪些非常能落地的技术手段？",
                "herf": "https://time.geekbang.org/column/article/185684",
                "id": "185684",
                "content": "<p>上一节课中，我们对“为什么要重构、到底重构什么、什么时候重构、该如何重构”，做了概括性介绍，强调了重构的重要性，希望你建立持续重构意识，将重构作为开发的一部分来执行。</p><p>据我了解，很多程序员对重构这种做法还是非常认同的，面对项目中的烂代码，也想重构一下，但又担心重构之后出问题，出力不讨好。确实，如果你要重构的代码是别的同事开发的，你不是特别熟悉，在没有任何保障的情况下，重构引入bug的风险还是很大的。</p><p>那如何保证重构不出错呢？你需要熟练掌握各种设计原则、思想、模式，还需要对所重构的业务和代码有足够的了解。除了这些个人能力因素之外，最可落地执行、最有效的保证重构不出错的手段应该就是<strong>单元测试</strong>（Unit Testing）了。当重构完成之后，如果新的代码仍然能通过单元测试，那就说明代码原有逻辑的正确性未被破坏，原有的外部可见行为未变，符合上一节课中我们对重构的定义。</p><p>那今天我们就来学习一下单元测试。今天的内容主要包含这样几个内容：</p><ul>\n<li>什么是单元测试？</li>\n<li>为什么要写单元测试？</li>\n<li>如何编写单元测试？</li>\n<li>如何在团队中推行单元测试？</li>\n</ul><p>话不多说，让我们现在就开始今天的学习吧！</p><h2>什么是单元测试？</h2><p>单元测试由研发工程师自己来编写，用来测试自己写的代码的正确性。我们常常将它跟集成测试放到一块来对比。单元测试相对于集成测试（Integration Testing）来说，测试的粒度更小一些。集成测试的测试对象是整个系统或者某个功能模块，比如测试用户注册、登录功能是否正常，是一种端到端（end to end）的测试。而单元测试的测试对象是类或者函数，用来测试一个类和函数是否都按照预期的逻辑执行。这是代码层级的测试。</p><!-- [[[read_end]]] --><p>这么说比较理论，我举个例子来解释一下。</p><pre><code>public class Text {\n  private String content;\n\n  public Text(String content) {\n    this.content = content;\n  }\n\n  /**\n   * 将字符串转化成数字，忽略字符串中的首尾空格；\n   * 如果字符串中包含除首尾空格之外的非数字字符，则返回null。\n   */\n  public Integer toNumber() {\n    if (content == null || content.isEmpty()) {\n      return null;\n    }\n    //...省略代码实现...\n    return null;\n  }\n}\n</code></pre><p>如果我们要测试Text类中的toNumber()函数的正确性，应该如何编写单元测试呢？</p><p>实际上，写单元测试本身不需要什么高深技术。它更多的是考验程序员思维的缜密程度，看能否设计出覆盖各种正常及异常情况的测试用例，来保证代码在任何预期或非预期的情况下都能正确运行。</p><p>为了保证测试的全面性，针对toNumber()函数，我们需要设计下面这样几个测试用例。</p><ul>\n<li>如果字符串只包含数字：“123”，toNumber()函数输出对应的整数：123。</li>\n<li>如果字符串是空或者null，toNumber()函数返回：null。</li>\n<li>如果字符串包含首尾空格：“ 123”，“123 ”，“ 123 ”，toNumber()返回对应的整数：123。</li>\n<li>如果字符串包含多个首尾空格：“ 123 ”，toNumber()返回对应的整数：123；</li>\n<li>如果字符串包含非数字字符：“123a4”，“123 4”，toNumber()返回null；</li>\n</ul><p>当我们设计好测试用例之后，剩下的就是将其翻译成代码了。翻译成代码的过程非常简单，我把代码贴在下面了，你可以参考一下（注意，我们这里没有使用任何测试框架）。</p><pre><code>public class Assert {\n  public static void assertEquals(Integer expectedValue, Integer actualValue) {\n    if (actualValue != expectedValue) {\n      String message = String.format(\n              &quot;Test failed, expected: %d, actual: %d.&quot;, expectedValue, actualValue);\n      System.out.println(message);\n    } else {\n      System.out.println(&quot;Test succeeded.&quot;);\n    }\n  }\n\n  public static boolean assertNull(Integer actualValue) {\n    boolean isNull = actualValue == null;\n    if (isNull) {\n      System.out.println(&quot;Test succeeded.&quot;);\n    } else {\n      System.out.println(&quot;Test failed, the value is not null:&quot; + actualValue);\n    }\n    return isNull;\n  }\n}\n\npublic class TestCaseRunner {\n  public static void main(String[] args) {\n    System.out.println(&quot;Run testToNumber()&quot;);\n    new TextTest().testToNumber();\n\n    System.out.println(&quot;Run testToNumber_nullorEmpty()&quot;);\n    new TextTest().testToNumber_nullorEmpty();\n\n    System.out.println(&quot;Run testToNumber_containsLeadingAndTrailingSpaces()&quot;);\n    new TextTest().testToNumber_containsLeadingAndTrailingSpaces();\n\n    System.out.println(&quot;Run testToNumber_containsMultiLeadingAndTrailingSpaces()&quot;);\n    new TextTest().testToNumber_containsMultiLeadingAndTrailingSpaces();\n\n    System.out.println(&quot;Run testToNumber_containsInvalidCharaters()&quot;);\n    new TextTest().testToNumber_containsInvalidCharaters();\n  }\n}\n\npublic class TextTest {\n  public void testToNumber() {\n    Text text = new Text(&quot;123&quot;);\n    Assert.assertEquals(123, text.toNumber());\n  }\n\n  public void testToNumber_nullorEmpty() {\n    Text text1 = new Text(null);\n    Assert.assertNull(text1.toNumber());\n\n    Text text2 = new Text(&quot;&quot;);\n    Assert.assertNull(text2.toNumber());\n  }\n\n  public void testToNumber_containsLeadingAndTrailingSpaces() {\n    Text text1 = new Text(&quot; 123&quot;);\n    Assert.assertEquals(123, text1.toNumber());\n\n    Text text2 = new Text(&quot;123 &quot;);\n    Assert.assertEquals(123, text2.toNumber());\n\n    Text text3 = new Text(&quot; 123 &quot;);\n    Assert.assertEquals(123, text3.toNumber());\n  }\n\n  public void testToNumber_containsMultiLeadingAndTrailingSpaces() {\n    Text text1 = new Text(&quot;  123&quot;);\n    Assert.assertEquals(123, text1.toNumber());\n\n    Text text2 = new Text(&quot;123  &quot;);\n    Assert.assertEquals(123, text2.toNumber());\n\n    Text text3 = new Text(&quot;  123  &quot;);\n    Assert.assertEquals(123, text3.toNumber());\n  }\n\n  public void testToNumber_containsInvalidCharaters() {\n    Text text1 = new Text(&quot;123a4&quot;);\n    Assert.assertNull(text1.toNumber());\n\n    Text text2 = new Text(&quot;123 4&quot;);\n    Assert.assertNull(text2.toNumber());\n  }\n}\n</code></pre><h2>为什么要写单元测试？</h2><p>单元测试除了能有效地为重构保驾护航之外，也是保证代码质量最有效的两个手段之一（另一个是Code Review）。我在Google工作的时候，写了大量的单元测试代码，结合我的这些开发经验，我总结了以下几点单元测试的好处。尽管有些听起来有点“务虚”，但如果你认真写过一些单元测试的话，应该会很有共鸣。</p><h3>1.单元测试能有效地帮你发现代码中的bug</h3><p>能否写出bug free的代码，是判断工程师编码能力的重要标准之一，也是很多大厂面试考察的重点，特别是像FLAG这样的外企。即便像我这样代码写了十几年，逻辑还算缜密、清晰的人，通过单元测试也常常会发现代码中的很多考虑不全面的地方。</p><p>在离开Google之后，尽管我就职的很多公司，其开发模式都是“快、糙、猛”，对单元测试根本没有要求，但我还是坚持为自己提交的每一份代码，都编写完善的单元测试。得益于此，我写的代码几乎是bug free的。这也节省了我很多fix低级bug的时间，能够有时间去做其他更有意义的事情，我也因此在工作上赢得了很多人的认可。可以这么说，坚持写单元测试是保证我的代码质量的一个“杀手锏”，也是帮助我拉开与其他人差距的一个“小秘密”。</p><h3>2.写单元测试能帮你发现代码设计上的问题</h3><p>前面我们提到，代码的可测试性是评判代码质量的一个重要标准。对于一段代码，如果很难为其编写单元测试，或者单元测试写起来很吃力，需要依靠单元测试框架里很高级的特性才能完成，那往往就意味着代码设计得不够合理，比如，没有使用依赖注入、大量使用静态函数、全局变量、代码高度耦合等。</p><h3>3.单元测试是对集成测试的有力补充</h3><p>程序运行的bug往往出现在一些边界条件、异常情况下，比如，除数未判空、网络超时。而大部分异常情况都比较难在测试环境中模拟。而单元测试可以利用下一节课中讲到的mock的方式，控制mock的对象返回我们需要模拟的异常，来测试代码在这些异常情况的表现。</p><p>除此之外，对于一些复杂系统来说，集成测试也无法覆盖得很全面。复杂系统往往有很多模块。每个模块都有各种输入、输出、异常情况，组合起来，整个系统就有无数测试场景需要模拟，无数的测试用例需要设计，再强大的测试团队也无法穷举完备。</p><p>尽管单元测试无法完全替代集成测试，但如果我们能保证每个类、每个函数都能按照我们的预期来执行，底层bug少了，那组装起来的整个系统，出问题的概率也就相应减少了。</p><h3>4.写单元测试的过程本身就是代码重构的过程</h3><p>上一节课中，我们提到，要把持续重构作为开发的一部分来执行，那写单元测试实际上就是落地执行持续重构的一个有效途径。设计和实现代码的时候，我们很难把所有的问题都想清楚。而编写单元测试就相当于对代码的一次自我Code Review，在这个过程中，我们可以发现一些设计上的问题（比如代码设计的不可测试）以及代码编写方面的问题（比如一些边界条件处理不当）等，然后针对性的进行重构。</p><h3>5.阅读单元测试能帮助你快速熟悉代码</h3><p>阅读代码最有效的手段，就是先了解它的业务背景和设计思路，然后再去看代码，这样代码读起来就会轻松很多。但据我了解，程序员都不怎么喜欢写文档和注释，而大部分程序员写的代码又很难做到“不言自明”。在没有文档和注释的情况下，单元测试就起了替代性作用。单元测试用例实际上就是用户用例，反映了代码的功能和如何使用。借助单元测试，我们不需要深入的阅读代码，便能知道代码实现了什么功能，有哪些特殊情况需要考虑，有哪些边界条件需要处理。</p><h3>6.单元测试是TDD可落地执行的改进方案</h3><p>测试驱动开发（Test-Driven Development，简称TDD）是一个经常被提及但很少被执行的开发模式。它的核心指导思想就是测试用例先于代码编写。不过，要让程序员能彻底地接受和习惯这种开发模式还是挺难的，毕竟很多程序员连单元测试都懒得写，更何况在编写代码之前先写好测试用例了。</p><p>我个人觉得，单元测试正好是对TDD的一种改进方案，先写代码，紧接着写单元测试，最后根据单元测试反馈出来问题，再回过头去重构代码。这个开发流程更加容易被接受，更加容易落地执行，而且又兼顾了TDD的优点。</p><h2>如何编写单元测试？</h2><p>前面在讲什么是单元测试的时候，我们举了一个给toNumber()函数写单元测试的例子。根据那个例子，我们可以总结得出，写单元测试就是针对代码设计覆盖各种输入、异常、边界条件的测试用例，并将这些测试用例翻译成代码的过程。</p><p>在把测试用例翻译成代码的时候，我们可以利用单元测试框架，来简化测试代码的编写。比如，Java中比较出名的单元测试框架有Junit、TestNG、Spring Test等。这些框架提供了通用的执行流程（比如执行测试用例的TestCaseRunner）和工具类库（比如各种Assert判断函数）等。借助它们，我们在编写测试代码的时候，只需要关注测试用例本身的编写即可。</p><p>针对toNumber()函数的测试用例，我们利用Junit单元测试框架重新实现一下，具体代码如下所示。你可以拿它跟之前没有利用测试框架的实现方式对比一下，看是否简化了很多呢？</p><pre><code>import org.junit.Assert;\nimport org.junit.Test;\n\npublic class TextTest {\n  @Test\n  public void testToNumber() {\n    Text text = new Text(&quot;123&quot;);\n    Assert.assertEquals(new Integer(123), text.toNumber());\n  }\n\n  @Test\n  public void testToNumber_nullorEmpty() {\n    Text text1 = new Text(null);\n    Assert.assertNull(text1.toNumber());\n\n    Text text2 = new Text(&quot;&quot;);\n    Assert.assertNull(text2.toNumber());\n  }\n\n  @Test\n  public void testToNumber_containsLeadingAndTrailingSpaces() {\n    Text text1 = new Text(&quot; 123&quot;);\n    Assert.assertEquals(new Integer(123), text1.toNumber());\n\n    Text text2 = new Text(&quot;123 &quot;);\n    Assert.assertEquals(new Integer(123), text2.toNumber());\n\n    Text text3 = new Text(&quot; 123 &quot;);\n    Assert.assertEquals(new Integer(123), text3.toNumber());\n  }\n\n  @Test\n  public void testToNumber_containsMultiLeadingAndTrailingSpaces() {\n    Text text1 = new Text(&quot;  123&quot;);\n    Assert.assertEquals(new Integer(123), text1.toNumber());\n\n    Text text2 = new Text(&quot;123  &quot;);\n    Assert.assertEquals(new Integer(123), text2.toNumber());\n\n    Text text3 = new Text(&quot;  123  &quot;);\n    Assert.assertEquals(new Integer(123), text3.toNumber());\n  }\n\n  @Test\n  public void testToNumber_containsInvalidCharaters() {\n    Text text1 = new Text(&quot;123a4&quot;);\n    Assert.assertNull(text1.toNumber());\n\n    Text text2 = new Text(&quot;123 4&quot;);\n    Assert.assertNull(text2.toNumber());\n  }\n}\n</code></pre><p>对于如何使用这些单元测试框架，大部分框架都给出了非常详细的官方文档，你可以自行查阅。这些东西理解和掌握起来没有太大难度，所以这不是专栏要讲解的重点。关于如何编写单元测试，我更希望传达给你一些我的经验总结。具体包括以下几点。</p><h3>1.写单元测试真的是件很耗时的事情吗？</h3><p>尽管单元测试的代码量可能是被测代码本身的1～2倍，写的过程很繁琐，但并不是很耗时。毕竟我们不需要考虑太多代码设计上的问题，测试代码实现起来也比较简单。不同测试用例之间的代码差别可能并不是很大，简单copy-paste改改就行。</p><h3>2.对单元测试的代码质量有什么要求吗？</h3><p>单元测试毕竟不会在产线上运行，而且每个类的测试代码也比较独立，基本不互相依赖。所以，相对于被测代码，我们对单元测试代码的质量可以放低一些要求。命名稍微有些不规范，代码稍微有些重复，也都是没有问题的。</p><h3>3.单元测试只要覆盖率高就够了吗？</h3><p>单元测试覆盖率是比较容易量化的指标，常常作为单元测试写得好坏的评判标准。有很多现成的工具专门用来做覆盖率统计，比如，JaCoCo、Cobertura、Emma、Clover。覆盖率的计算方式有很多种，比较简单的是语句覆盖，稍微高级点的有：条件覆盖、判定覆盖、路径覆盖。</p><p>不管覆盖率的计算方式如何高级，将覆盖率作为衡量单元测试质量的唯一标准是不合理的。实际上，更重要的是要看测试用例是否覆盖了所有可能的情况，特别是一些corner case。我来举个简单的例子解释一下。</p><p>像下面这段代码，我们只需要一个测试用例就可以做到100%覆盖率，比如cal(10.0, 2.0)，但并不代表测试足够全面了，我们还需要考虑，当除数等于０的情况下，代码执行是否符合预期。</p><pre><code>public double cal(double a, double b) {\n  if (b != 0) {\n    return a / b;\n  }\n}\n</code></pre><p>实际上，过度关注单元测试的覆盖率会导致开发人员为了提高覆盖率，写很多没有必要的测试代码，比如get、set方法非常简单，没有必要测试。从过往的经验上来讲，一个项目的单元测试覆盖率在60～70%即可上线。如果项目对代码质量要求比较高，可以适当提高单元测试覆盖率的要求。</p><h3>4.写单元测试需要了解代码的实现逻辑吗？</h3><p>单元测试不要依赖被测试函数的具体实现逻辑，它只关心被测函数实现了什么功能。我们切不可为了追求覆盖率，逐行阅读代码，然后针对实现逻辑编写单元测试。否则，一旦对代码进行重构，在代码的外部行为不变的情况下，对代码的实现逻辑进行了修改，那原本的单元测试都会运行失败，也就起不到为重构保驾护航的作用了，也违背了我们写单元测试的初衷。</p><h3>5.如何选择单元测试框架？</h3><p>写单元测试本身不需要太复杂的技术，大部分单元测试框架都能满足。在公司内部，起码团队内部需要统一单元测试框架。如果自己写的代码用已经选定的单元测试框架无法测试，那多半是代码写得不够好，代码的可测试性不够好。这个时候，我们要重构自己的代码，让其更容易测试，而不是去找另一个更加高级的单元测试框架。</p><h2>单元测试为何难落地执行？</h2><p>虽然很多书籍中都会讲到，单元测试是保证重构不出错的有效手段；也有非常多人已经认识到单元测试的重要性。但是有多少项目有完善的、高质量的单元测试呢？据我了解，真的非常非常少，包括BAT这样级别公司的项目。如果不相信的话，你可以去看一下国内很多大厂开源的项目，有很多项目完全没有单元测试，还有很多项目的单元测试写得非常不完备，仅仅测试了逻辑是否运行正确而已。所以，100%落实执行单元测试是件“知易行难”的事。</p><p>写单元测试确实是一件考验耐心的活儿。一般情况下，单元测试的代码量要大于被测试代码量，甚至是要多出好几倍。很多人往往会觉得写单元测试比较繁琐，并且没有太多挑战，而不愿意去做。有很多团队和项目在刚开始推行单元测试的时候，还比较认真，执行得比较好。但当开发任务紧了之后，就开始放低对单元测试的要求，一旦出现<a href=\"https://wiki.mbalib.com/wiki/%E7%A0%B4%E7%AA%97%E6%95%88%E5%BA%94\">破窗效应</a>，慢慢的，大家就都不写了，这种情况很常见。</p><p>还有一种情况就是，由于历史遗留问题，原来的代码都没有写单元测试，代码已经堆砌了十几万行了，不可能再一个一个去补单元测试。这种情况下，我们首先要保证新写的代码都要有单元测试，其次，每次在改动到某个类时，如果没有单元测试就顺便补上，不过这要求工程师们有足够强的主人翁意识（ownership），毕竟光靠leader督促，很多事情是很难执行到位的。</p><p>除此之外，还有人觉得，有了测试团队，写单元测试就是浪费时间，没有必要。程序员这一行业本该是智力密集型的，但现在很多公司把它搞成劳动密集型的，包括一些大厂，在开发过程中，既没有单元测试，也没有Code Review流程。即便有，做的也是差强人意。写好代码直接提交，然后丢给黑盒测试狠命去测，测出问题就反馈给开发团队再修改，测不出的问题就留在线上出了问题再修复。</p><p>在这样的开发模式下，团队往往觉得没有必要写单元测试，但如果我们把单元测试写好、做好Code Review，重视起代码质量，其实可以很大程度上减少黑盒测试的投入。我在Google的时候，很多项目几乎没有测试团队参与，代码的正确性完全靠开发团队来保障，线上bug反倒非常少。</p><p>以上是我对单元测试的认知和实践心得。现在互联网信息如此的公开透明，网上有很多文章可以参考，对于程序员这个具有很强学习能力的群体来说，学会如何写单元测试并不是一件难事，难的是能够真正感受到它的作用，并且打心底认可、能100%落地执行。这也是我今天的课程特别想传达给你的一点。</p><h2>重点回顾</h2><p>好了，今天的内容到此就讲完了。我们来一块总结回顾一下，你需要掌握的重点内容。</p><p><strong>1.什么是单元测试？</strong></p><p>单元测试是代码层面的测试，由研发自己来编写，用于测试“自己”编写的代码的逻辑的正确性。单元测试顾名思义是测试一个“单元”，有别于集成测试，这个“单元”一般是类或函数，而不是模块或者系统。</p><p><strong>2.为什么要写单元测试？</strong></p><p>写单元测试的过程本身就是代码Code Review和重构的过程，能有效地发现代码中的bug和代码设计上的问题。除此之外，单元测试还是对集成测试的有力补充，还能帮助我们快速熟悉代码，是TDD可落地执行的改进方案。</p><p><strong>3.如何编写单元测试？</strong></p><p>写单元测试就是针对代码设计各种测试用例，以覆盖各种输入、异常、边界情况，并将其翻译成代码。我们可以利用一些测试框架来简化单元测试的编写。除此之外，对于单元测试，我们需要建立以下正确的认知：</p><ul>\n<li>编写单元测试尽管繁琐，但并不是太耗时；</li>\n<li>我们可以稍微放低对单元测试代码质量的要求；</li>\n<li>覆盖率作为衡量单元测试质量的唯一标准是不合理的；</li>\n<li>单元测试不要依赖被测代码的具体实现逻辑；</li>\n<li>单元测试框架无法测试，多半是因为代码的可测试性不好。</li>\n</ul><p><strong>4.单元测试为何难落地执行？</strong></p><p>一方面，写单元测试本身比较繁琐，技术挑战不大，很多程序员不愿意去写；另一方面，国内研发比较偏向“快、糙、猛”，容易因为开发进度紧，导致单元测试的执行虎头蛇尾。最后，关键问题还是团队没有建立对单元测试正确的认识，觉得可有可无，单靠督促很难执行得很好。</p><h2>课堂讨论</h2><p>今天的课堂讨论有以下两个：</p><ol>\n<li>你参与的项目有没有写单元测试？单元测试是否足够完备？贯彻执行写单元测试的过程中，遇到过哪些问题？又是如何解决的？</li>\n<li>在面试中，我经常会让候选人写完代码之后，列举几个测试用例，以此来考察候选人考虑问题是否全面，特别是针对一些边界条件的处理。所以，今天的另一个课堂讨论话题就是：写一个二分查找的变体算法，查找递增数组中第一个大于等于某个给定值的元素，并且为你的代码设计完备的单元测试用例。</li>\n</ol><p>欢迎在留言区写下你的答案，和同学一起交流和分享。如果有收获，也欢迎你把这篇文章分享给你的朋友。</p>",
                "article_title": "28 | 理论二：为了保证重构不出错，有哪些非常能落地的技术手段？"
            },
            {
                "title": "29 | 理论三：什么是代码的可测试性？如何写出可测试性好的代码？",
                "herf": "https://time.geekbang.org/column/article/186691",
                "id": "186691",
                "content": "<p>在上一节课中，我们对单元测试做了介绍，讲了“什么是单元测试？为什么要编写单元测试？如何编写单元测试？实践中单元测试为什么难贯彻执行？”这样几个问题。</p><p>实际上，写单元测试并不难，也不需要太多技巧，相反，写出可测试的代码反倒是件非常有挑战的事情。所以，今天，我们就再来聊一聊代码的可测试性，主要包括这样几个问题：</p><ul>\n<li>什么是代码的可测试性？</li>\n<li>如何写出可测试的代码？</li>\n<li>有哪些常见的不好测试的代码？</li>\n</ul><p>话不多说，让我们正式开始今天的学习吧！</p><h2>编写可测试代码案例实战</h2><p>刚刚提到的这几个关于代码可测试性的问题，我准备通过一个实战案例来讲解。具体的被测试代码如下所示。</p><p>其中，Transaction是经过我抽象简化之后的一个电商系统的交易类，用来记录每笔订单交易的情况。Transaction类中的execute()函数负责执行转账操作，将钱从买家的钱包转到卖家的钱包中。真正的转账操作是通过调用WalletRpcService RPC服务来完成的。除此之外，代码中还涉及一个分布式锁DistributedLock单例类，用来避免Transaction并发执行，导致用户的钱被重复转出。</p><pre><code>public class Transaction {\n  private String id;\n  private Long buyerId;\n  private Long sellerId;\n  private Long productId;\n  private String orderId;\n  private Long createTimestamp;\n  private Double amount;\n  private STATUS status;\n  private String walletTransactionId;\n  \n  // ...get() methods...\n  \n  public Transaction(String preAssignedId, Long buyerId, Long sellerId, Long productId, String orderId) {\n    if (preAssignedId != null &amp;&amp; !preAssignedId.isEmpty()) {\n      this.id = preAssignedId;\n    } else {\n      this.id = IdGenerator.generateTransactionId();\n    }\n    if (!this.id.startWith(&quot;t_&quot;)) {\n      this.id = &quot;t_&quot; + preAssignedId;\n    }\n    this.buyerId = buyerId;\n    this.sellerId = sellerId;\n    this.productId = productId;\n    this.orderId = orderId;\n    this.status = STATUS.TO_BE_EXECUTD;\n    this.createTimestamp = System.currentTimestamp();\n  }\n  \n  public boolean execute() throws InvalidTransactionException {\n    if ((buyerId == null || (sellerId == null || amount &lt; 0.0) {\n      throw new InvalidTransactionException(...);\n    }\n    if (status == STATUS.EXECUTED) return true;\n    boolean isLocked = false;\n    try {\n      isLocked = RedisDistributedLock.getSingletonIntance().lockTransction(id);\n      if (!isLocked) {\n        return false; // 锁定未成功，返回false，job兜底执行\n      }\n      if (status == STATUS.EXECUTED) return true; // double check\n      long executionInvokedTimestamp = System.currentTimestamp();\n      if (executionInvokedTimestamp - createdTimestap &gt; 14days) {\n        this.status = STATUS.EXPIRED;\n        return false;\n      }\n      WalletRpcService walletRpcService = new WalletRpcService();\n      String walletTransactionId = walletRpcService.moveMoney(id, buyerId, sellerId, amount);\n      if (walletTransactionId != null) {\n        this.walletTransactionId = walletTransactionId;\n        this.status = STATUS.EXECUTED;\n        return true;\n      } else {\n        this.status = STATUS.FAILED;\n        return false;\n      }\n    } finally {\n      if (isLocked) {\n       RedisDistributedLock.getSingletonIntance().unlockTransction(id);\n      }\n    }\n  }\n}\n</code></pre><p>对比上一节课中的Text类的代码，这段代码要复杂很多。如果让你给这段代码编写单元测试，你会如何来写呢？你可以先试着思考一下，然后再来看我下面的分析。</p><!-- [[[read_end]]] --><p>在Transaction类中，主要逻辑集中在execute()函数中，所以它是我们测试的重点对象。为了尽可能全面覆盖各种正常和异常情况，针对这个函数，我设计了下面6个测试用例。</p><ol>\n<li>正常情况下，交易执行成功，回填用于对账（交易与钱包的交易流水）用的walletTransactionId，交易状态设置为EXECUTED，函数返回true。</li>\n<li>buyerId、sellerId为null、amount小于0，返回InvalidTransactionException。</li>\n<li>交易已过期（createTimestamp超过14天），交易状态设置为EXPIRED，返回false。</li>\n<li>交易已经执行了（status==EXECUTED），不再重复执行转钱逻辑，返回true。</li>\n<li>钱包（WalletRpcService）转钱失败，交易状态设置为FAILED，函数返回false。</li>\n<li>交易正在执行着，不会被重复执行，函数直接返回false。</li>\n</ol><p>测试用例设计完了。现在看起来似乎一切进展顺利。但是，事实是，当我们将测试用例落实到具体的代码实现时，你就会发现有很多行不通的地方。对于上面的测试用例，第2个实现起来非常简单，我就不做介绍了。我们重点来看其中的1和3。测试用例4、5、6跟3类似，留给你自己来实现。</p><p>现在，我们就来看测试用例1的代码实现。具体如下所示：</p><pre><code>public void testExecute() {\n  Long buyerId = 123L;\n  Long sellerId = 234L;\n  Long productId = 345L;\n  Long orderId = 456L;\n  Transction transaction = new Transaction(null, buyerId, sellerId, productId, orderId);\n  boolean executedResult = transaction.execute();\n  assertTrue(executedResult);\n}\n</code></pre><p>execute()函数的执行依赖两个外部的服务，一个是RedisDistributedLock，一个WalletRpcService。这就导致上面的单元测试代码存在下面几个问题。</p><ul>\n<li>如果要让这个单元测试能够运行，我们需要搭建Redis服务和Wallet RPC服务。搭建和维护的成本比较高。</li>\n<li>我们还需要保证将伪造的transaction数据发送给Wallet RPC服务之后，能够正确返回我们期望的结果，然而Wallet RPC服务有可能是第三方（另一个团队开发维护的）的服务，并不是我们可控的。换句话说，并不是我们想让它返回什么数据就返回什么。</li>\n<li>Transaction的执行跟Redis、RPC服务通信，需要走网络，耗时可能会比较长，对单元测试本身的执行性能也会有影响。</li>\n<li>网络的中断、超时、Redis、RPC服务的不可用，都会影响单元测试的执行。</li>\n</ul><p>我们回到单元测试的定义上来看一下。单元测试主要是测试程序员自己编写的代码逻辑的正确性，并非是端到端的集成测试，它不需要测试所依赖的外部系统（分布式锁、Wallet RPC服务）的逻辑正确性。所以，如果代码中依赖了外部系统或者不可控组件，比如，需要依赖数据库、网络通信、文件系统等，那我们就需要将被测代码与外部系统解依赖，而这种解依赖的方法就叫作“mock”。所谓的mock就是用一个“假”的服务替换真正的服务。mock的服务完全在我们的控制之下，模拟输出我们想要的数据。</p><p>那如何来mock服务呢？mock的方式主要有两种，手动mock和利用框架mock。利用框架mock仅仅是为了简化代码编写，每个框架的mock方式都不大一样。我们这里只展示手动mock。</p><p>我们通过继承WalletRpcService类，并且重写其中的moveMoney()函数的方式来实现mock。具体的代码实现如下所示。通过mock的方式，我们可以让moveMoney()返回任意我们想要的数据，完全在我们的控制范围内，并且不需要真正进行网络通信。</p><pre><code>public class MockWalletRpcServiceOne extends WalletRpcService {\n  public String moveMoney(Long id, Long fromUserId, Long toUserId, Double amount) {\n    return &quot;123bac&quot;;\n  } \n}\n\npublic class MockWalletRpcServiceTwo extends WalletRpcService {\n  public String moveMoney(Long id, Long fromUserId, Long toUserId, Double amount) {\n    return null;\n  } \n}\n</code></pre><p>现在我们再来看，如何用MockWalletRpcServiceOne、MockWalletRpcServiceTwo来替换代码中的真正的WalletRpcService呢？</p><p>因为WalletRpcService是在execute()函数中通过new的方式创建的，我们无法动态地对其进行替换。也就是说，Transaction类中的execute()方法的可测试性很差，需要通过重构来让其变得更容易测试。该如何重构这段代码呢？</p><p>在<a href=\"https://time.geekbang.org/column/article/177444\">第19节</a>中，我们讲到，依赖注入是实现代码可测试性的最有效的手段。我们可以应用依赖注入，将WalletRpcService对象的创建反转给上层逻辑，在外部创建好之后，再注入到Transaction类中。重构之后的Transaction类的代码如下所示：</p><pre><code>public class Transaction {\n  //...\n  // 添加一个成员变量及其set方法\n  private WalletRpcService walletRpcService;\n  \n  public void setWalletRpcService(WalletRpcService walletRpcService) {\n    this.walletRpcService = walletRpcService;\n  }\n  // ...\n  public boolean execute() {\n    // ...\n    // 删除下面这一行代码\n    // WalletRpcService walletRpcService = new WalletRpcService();\n    // ...\n  }\n}\n</code></pre><p>现在，我们就可以在单元测试中，非常容易地将WalletRpcService替换成MockWalletRpcServiceOne或WalletRpcServiceTwo了。重构之后的代码对应的单元测试如下所示：</p><pre><code>public void testExecute() {\n  Long buyerId = 123L;\n  Long sellerId = 234L;\n  Long productId = 345L;\n  Long orderId = 456L;\n  Transction transaction = new Transaction(null, buyerId, sellerId, productId, orderId);\n  // 使用mock对象来替代真正的RPC服务\n  transaction.setWalletRpcService(new MockWalletRpcServiceOne()):\n  boolean executedResult = transaction.execute();\n  assertTrue(executedResult);\n  assertEquals(STATUS.EXECUTED, transaction.getStatus());\n}\n</code></pre><p>WalletRpcService的mock和替换问题解决了，我们再来看RedisDistributedLock。它的mock和替换要复杂一些，主要是因为RedisDistributedLock是一个单例类。单例相当于一个全局变量，我们无法mock（无法继承和重写方法），也无法通过依赖注入的方式来替换。</p><p>如果RedisDistributedLock是我们自己维护的，可以自由修改、重构，那我们可以将其改为非单例的模式，或者定义一个接口，比如IDistributedLock，让RedisDistributedLock实现这个接口。这样我们就可以像前面WalletRpcService的替换方式那样，替换RedisDistributedLock为MockRedisDistributedLock了。但如果RedisDistributedLock不是我们维护的，我们无权去修改这部分代码，这个时候该怎么办呢？</p><p>我们可以对transaction上锁这部分逻辑重新封装一下。具体代码实现如下所示：</p><pre><code>public class TransactionLock {\n  public boolean lock(String id) {\n    return RedisDistributedLock.getSingletonIntance().lockTransction(id);\n  }\n  \n  public void unlock() {\n    RedisDistributedLock.getSingletonIntance().unlockTransction(id);\n  }\n}\n\npublic class Transaction {\n  //...\n  private TransactionLock lock;\n  \n  public void setTransactionLock(TransactionLock lock) {\n    this.lock = lock;\n  }\n \n  public boolean execute() {\n    //...\n    try {\n      isLocked = lock.lock();\n      //...\n    } finally {\n      if (isLocked) {\n        lock.unlock();\n      }\n    }\n    //...\n  }\n}\n</code></pre><p>针对重构过的代码，我们的单元测试代码修改为下面这个样子。这样，我们就能在单元测试代码中隔离真正的RedisDistributedLock分布式锁这部分逻辑了。</p><pre><code>public void testExecute() {\n  Long buyerId = 123L;\n  Long sellerId = 234L;\n  Long productId = 345L;\n  Long orderId = 456L;\n  \n  TransactionLock mockLock = new TransactionLock() {\n    public boolean lock(String id) {\n      return true;\n    }\n  \n    public void unlock() {}\n  };\n  \n  Transction transaction = new Transaction(null, buyerId, sellerId, productId, orderId);\n  transaction.setWalletRpcService(new MockWalletRpcServiceOne());\n  transaction.setTransactionLock(mockLock);\n  boolean executedResult = transaction.execute();\n  assertTrue(executedResult);\n  assertEquals(STATUS.EXECUTED, transaction.getStatus());\n}\n</code></pre><p>至此，测试用例1就算写好了。我们通过依赖注入和mock，让单元测试代码不依赖任何不可控的外部服务。你可以照着这个思路，自己写一下测试用例4、5、6。</p><p>现在，我们再来看测试用例3：交易已过期（createTimestamp超过14天），交易状态设置为EXPIRED，返回false。针对这个单元测试用例，我们还是先把代码写出来，然后再来分析。</p><pre><code>public void testExecute_with_TransactionIsExpired() {\n  Long buyerId = 123L;\n  Long sellerId = 234L;\n  Long productId = 345L;\n  Long orderId = 456L;\n  Transction transaction = new Transaction(null, buyerId, sellerId, productId, orderId);\n  transaction.setCreatedTimestamp(System.currentTimestamp() - 14days);\n  boolean actualResult = transaction.execute();\n  assertFalse(actualResult);\n  assertEquals(STATUS.EXPIRED, transaction.getStatus());\n}\n</code></pre><p>上面的代码看似没有任何问题。我们将transaction的创建时间createdTimestamp设置为14天前，也就是说，当单元测试代码运行的时候，transaction一定是处于过期状态。但是，如果在Transaction类中，并没有暴露修改createdTimestamp成员变量的set方法（也就是没有定义setCreatedTimestamp()函数）呢？</p><p>你可能会说，如果没有createTimestamp的set方法，我就重新添加一个呗！实际上，这违反了类的封装特性。在Transaction类的设计中，createTimestamp是在交易生成时（也就是构造函数中）自动获取的系统时间，本来就不应该人为地轻易修改，所以，暴露createTimestamp的set方法，虽然带来了灵活性，但也带来了不可控性。因为，我们无法控制使用者是否会调用set方法重设createTimestamp，而重设createTimestamp并非我们的预期行为。</p><p>那如果没有针对createTimestamp的set方法，那测试用例3又该如何实现呢？实际上，这是一类比较常见的问题，就是代码中包含跟“时间”有关的“未决行为”逻辑。我们一般的处理方式是将这种未决行为逻辑重新封装。针对Transaction类，我们只需要将交易是否过期的逻辑，封装到isExpired()函数中即可，具体的代码实现如下所示：</p><pre><code>public class Transaction {\n\n  protected boolean isExpired() {\n    long executionInvokedTimestamp = System.currentTimestamp();\n    return executionInvokedTimestamp - createdTimestamp &gt; 14days;\n  }\n  \n  public boolean execute() throws InvalidTransactionException {\n    //...\n      if (isExpired()) {\n        this.status = STATUS.EXPIRED;\n        return false;\n      }\n    //...\n  }\n}\n</code></pre><p>针对重构之后的代码，测试用例3的代码实现如下所示：</p><pre><code>public void testExecute_with_TransactionIsExpired() {\n  Long buyerId = 123L;\n  Long sellerId = 234L;\n  Long productId = 345L;\n  Long orderId = 456L;\n  Transction transaction = new Transaction(null, buyerId, sellerId, productId, orderId) {\n    protected boolean isExpired() {\n      return true;\n    }\n  };\n  boolean actualResult = transaction.execute();\n  assertFalse(actualResult);\n  assertEquals(STATUS.EXPIRED, transaction.getStatus());\n}\n</code></pre><p>通过重构，Transaction代码的可测试性提高了。之前罗列的所有测试用例，现在我们都顺利实现了。不过，Transaction类的构造函数的设计还有点不妥。为了方便你查看，我把构造函数的代码重新copy了一份贴到这里。</p><pre><code>  public Transaction(String preAssignedId, Long buyerId, Long sellerId, Long productId, String orderId) {\n    if (preAssignedId != null &amp;&amp; !preAssignedId.isEmpty()) {\n      this.id = preAssignedId;\n    } else {\n      this.id = IdGenerator.generateTransactionId();\n    }\n    if (!this.id.startWith(&quot;t_&quot;)) {\n      this.id = &quot;t_&quot; + preAssignedId;\n    }\n    this.buyerId = buyerId;\n    this.sellerId = sellerId;\n    this.productId = productId;\n    this.orderId = orderId;\n    this.status = STATUS.TO_BE_EXECUTD;\n    this.createTimestamp = System.currentTimestamp();\n  }\n</code></pre><p>我们发现，构造函数中并非只包含简单赋值操作。交易id的赋值逻辑稍微复杂。我们最好也要测试一下，以保证这部分逻辑的正确性。为了方便测试，我们可以把id赋值这部分逻辑单独抽象到一个函数中，具体的代码实现如下所示：</p><pre><code>  public Transaction(String preAssignedId, Long buyerId, Long sellerId, Long productId, String orderId) {\n    //...\n    fillTransactionId(preAssignId);\n    //...\n  }\n  \n  protected void fillTransactionId(String preAssignedId) {\n    if (preAssignedId != null &amp;&amp; !preAssignedId.isEmpty()) {\n      this.id = preAssignedId;\n    } else {\n      this.id = IdGenerator.generateTransactionId();\n    }\n    if (!this.id.startWith(&quot;t_&quot;)) {\n      this.id = &quot;t_&quot; + preAssignedId;\n    }\n  }\n</code></pre><p>到此为止，我们一步一步将Transaction从不可测试代码重构成了测试性良好的代码。不过，你可能还会有疑问，Transaction类中isExpired()函数就不用测试了吗？对于isExpired()函数，逻辑非常简单，肉眼就能判定是否有bug，是可以不用写单元测试的。</p><p>实际上，可测试性差的代码，本身代码设计得也不够好，很多地方都没有遵守我们之前讲到的设计原则和思想，比如“基于接口而非实现编程”思想、依赖反转原则等。重构之后的代码，不仅可测试性更好，而且从代码设计的角度来说，也遵从了经典的设计原则和思想。这也印证了我们之前说过的，代码的可测试性可以从侧面上反应代码设计是否合理。除此之外，在平时的开发中，我们也要多思考一下，这样编写代码，是否容易编写单元测试，这也有利于我们设计出好的代码。</p><h2>其他常见的Anti-Patterns</h2><p>刚刚我们通过一个实战案例，讲解了如何利用依赖注入来提高代码的可测试性，以及编写单元测试中最复杂的一部分内容：如何通过mock、二次封装等方式解依赖外部服务。现在，我们再来总结一下，有哪些典型的、常见的测试性不好的代码，也就是我们常说的Anti-Patterns。</p><h3>1.未决行为</h3><p>所谓的未决行为逻辑就是，代码的输出是随机或者说不确定的，比如，跟时间、随机数有关的代码。对于这一点，在刚刚的实战案例中我们已经讲到，你可以利用刚才讲到的方法，试着重构一下下面的代码，并且为它编写单元测试。</p><pre><code>public class Demo {\n  public long caculateDelayDays(Date dueTime) {\n    long currentTimestamp = System.currentTimeMillis();\n    if (dueTime.getTime() &gt;= currentTimestamp) {\n      return 0;\n    }\n    long delayTime = currentTimestamp - dueTime.getTime();\n    long delayDays = delayTime / 86400;\n    return delayDays;\n  }\n}\n</code></pre><h3>2.全局变量</h3><p>前面我们讲过，全局变量是一种面向过程的编程风格，有种种弊端。实际上，滥用全局变量也让编写单元测试变得困难。我举个例子来解释一下。</p><p>RangeLimiter表示一个[-5, 5]的区间，position初始在0位置，move()函数负责移动position。其中，position是一个静态全局变量。RangeLimiterTest类是为其设计的单元测试，不过，这里面存在很大的问题，你可以先自己分析一下。</p><pre><code>public class RangeLimiter {\n  private static AtomicInteger position = new AtomicInteger(0);\n  public static final int MAX_LIMIT = 5;\n  public static final int MIN_LIMIT = -5;\n\n  public boolean move(int delta) {\n    int currentPos = position.addAndGet(delta);\n    boolean betweenRange = (currentPos &lt;= MAX_LIMIT) &amp;&amp; (currentPos &gt;= MIN_LIMIT);\n    return betweenRange;\n  }\n}\n\npublic class RangeLimiterTest {\n  public void testMove_betweenRange() {\n    RangeLimiter rangeLimiter = new RangeLimiter();\n    assertTrue(rangeLimiter.move(1));\n    assertTrue(rangeLimiter.move(3));\n    assertTrue(rangeLimiter.move(-5));\n  }\n\n  public void testMove_exceedRange() {\n    RangeLimiter rangeLimiter = new RangeLimiter();\n    assertFalse(rangeLimiter.move(6));\n  }\n}\n</code></pre><p>上面的单元测试有可能会运行失败。假设单元测试框架顺序依次执行testMove_betweenRange()和testMove_exceedRange()两个测试用例。在第一个测试用例执行完成之后，position的值变成了-1；再执行第二个测试用例的时候，position变成了5，move()函数返回true，assertFalse语句判定失败。所以，第二个测试用例运行失败。</p><p>当然，如果RangeLimiter类有暴露重设（reset）position值的函数，我们可以在每次执行单元测试用例之前，把position重设为0，这样就能解决刚刚的问题。</p><p>不过，每个单元测试框架执行单元测试用例的方式可能是不同的。有的是顺序执行，有的是并发执行。对于并发执行的情况，即便我们每次都把position重设为0，也并不奏效。如果两个测试用例并发执行，第16、17、18、23这四行代码可能会交叉执行，影响到move()函数的执行结果。</p><h3>3.静态方法</h3><p>前面我们也提到，静态方法跟全局变量一样，也是一种面向过程的编程思维。在代码中调用静态方法，有时候会导致代码不易测试。主要原因是静态方法也很难mock。但是，这个要分情况来看。只有在这个静态方法执行耗时太长、依赖外部资源、逻辑复杂、行为未决等情况下，我们才需要在单元测试中mock这个静态方法。除此之外，如果只是类似Math.abs()这样的简单静态方法，并不会影响代码的可测试性，因为本身并不需要mock。</p><h3>4.复杂继承</h3><p>我们前面提到，相比组合关系，继承关系的代码结构更加耦合、不灵活，更加不易扩展、不易维护。实际上，继承关系也更加难测试。这也印证了代码的可测试性跟代码质量的相关性。</p><p>如果父类需要mock某个依赖对象才能进行单元测试，那所有的子类、子类的子类……在编写单元测试的时候，都要mock这个依赖对象。对于层次很深（在继承关系类图中表现为纵向深度）、结构复杂（在继承关系类图中表现为横向广度）的继承关系，越底层的子类要mock的对象可能就会越多，这样就会导致，底层子类在写单元测试的时候，要一个一个mock很多依赖对象，而且还需要查看父类代码，去了解该如何mock这些依赖对象。</p><p>如果我们利用组合而非继承来组织类之间的关系，类之间的结构层次比较扁平，在编写单元测试的时候，只需要mock类所组合依赖的对象即可。</p><h3>5.高耦合代码</h3><p>如果一个类职责很重，需要依赖十几个外部对象才能完成工作，代码高度耦合，那我们在编写单元测试的时候，可能需要mock这十几个依赖的对象。不管是从代码设计的角度来说，还是从编写单元测试的角度来说，这都是不合理的。</p><h2>重点回顾</h2><p>好了，今天的内容到此就讲完了。我们一块来总结回顾一下，你需要重点掌握的内容。</p><p><strong>1.什么是代码的可测试性？</strong></p><p>粗略地讲，所谓代码的可测试性，就是针对代码编写单元测试的难易程度。对于一段代码，如果很难为其编写单元测试，或者单元测试写起来很费劲，需要依靠单元测试框架中很高级的特性，那往往就意味着代码设计得不够合理，代码的可测试性不好。</p><p><strong>2.编写可测试性代码的最有效手段</strong></p><p>依赖注入是编写可测试性代码的最有效手段。通过依赖注入，我们在编写单元测试的时候，可以通过mock的方法解依赖外部服务，这也是我们在编写单元测试的过程中最有技术挑战的地方。</p><p><strong>3.常见的Anti-Patterns</strong></p><p>常见的测试不友好的代码有下面这5种：</p><ul>\n<li>代码中包含未决行为逻辑</li>\n<li>滥用可变全局变量</li>\n<li>滥用静态方法</li>\n<li>使用复杂的继承关系</li>\n<li>高度耦合的代码</li>\n</ul><h2>课堂讨论</h2><ol>\n<li>实战案例中的void fillTransactionId(String preAssignedId)函数中包含一处静态函数调用：IdGenerator.generateTransactionId()，这是否会影响到代码的可测试性？在写单元测试的时候，我们是否需要mock这个函数？</li>\n<li>我们今天讲到，依赖注入是提高代码可测试性的最有效的手段。所以，依赖注入，就是不要在类内部通过new的方式创建对象，而是要通过外部创建好之后传递给类使用。那是不是所有的对象都不能在类内部创建呢？哪种类型的对象可以在类内部创建并且不影响代码的可测试性？你能举几个例子吗？</li>\n</ol><p>欢迎在留言区写下你的答案，和同学一起交流和分享。如果有收获，也欢迎你把这篇文章分享给你的朋友。</p>",
                "article_title": "29 | 理论三：什么是代码的可测试性？如何写出可测试性好的代码？"
            },
            {
                "title": "30 | 理论四：如何通过封装、抽象、模块化、中间层等解耦代码？",
                "herf": "https://time.geekbang.org/column/article/187761",
                "id": "187761",
                "content": "<p>前面我们讲到，重构可以分为大规模高层重构（简称“大型重构”）和小规模低层次重构（简称“小型重构”）。大型重构是对系统、模块、代码结构、类之间关系等顶层代码设计进行的重构。对于大型重构来说，今天我们重点讲解最有效的一个手段，那就是“解耦”。解耦的目的是实现代码高内聚、松耦合。关于解耦，我准备分下面三个部分来给你讲解。</p><ul>\n<li>“解耦”为何如此重要？</li>\n<li>如何判定代码是否需要“解耦”？</li>\n<li>如何给代码“解耦”？</li>\n</ul><p>话不多说，现在就让我们正式开始今天的学习吧！</p><h2>“解耦”为何如此重要？</h2><p>软件设计与开发最重要的工作之一就是应对复杂性。人处理复杂性的能力是有限的。过于复杂的代码往往在可读性、可维护性上都不友好。那如何来控制代码的复杂性呢？手段有很多，我个人认为，最关键的就是解耦，保证代码松耦合、高内聚。如果说重构是保证代码质量不至于腐化到无可救药地步的有效手段，那么利用解耦的方法对代码重构，就是保证代码不至于复杂到无法控制的有效手段。</p><p>我们在<a href=\"https://time.geekbang.org/column/article/179615\">第22讲</a>有介绍，什么是“高内聚、松耦合”。如果印象不深，你可以再去回顾一下。实际上，“高内聚、松耦合”是一个比较通用的设计思想，不仅可以指导细粒度的类和类之间关系的设计，还能指导粗粒度的系统、架构、模块的设计。相对于编码规范，它能够在更高层次上提高代码的可读性和可维护性。</p><!-- [[[read_end]]] --><p>不管是阅读代码还是修改代码，“高内聚、松耦合”的特性可以让我们聚焦在某一模块或类中，不需要了解太多其他模块或类的代码，让我们的焦点不至于过于发散，降低了阅读和修改代码的难度。而且，因为依赖关系简单，耦合小，修改代码不至于牵一发而动全身，代码改动比较集中，引入bug的风险也就减少了很多。同时，“高内聚、松耦合”的代码可测试性也更加好，容易mock或者很少需要mock外部依赖的模块或者类。</p><p>除此之外，代码“高内聚、松耦合”，也就意味着，代码结构清晰、分层和模块化合理、依赖关系简单、模块或类之间的耦合小，那代码整体的质量就不会差。即便某个具体的类或者模块设计得不怎么合理，代码质量不怎么高，影响的范围是非常有限的。我们可以聚焦于这个模块或者类，做相应的小型重构。而相对于代码结构的调整，这种改动范围比较集中的小型重构的难度就容易多了。</p><h2>代码是否需要“解耦”？</h2><p>那现在问题来了，我们该怎么判断代码的耦合程度呢？或者说，怎么判断代码是否符合“高内聚、松耦合”呢？再或者说，如何判断系统是否需要解耦重构呢？</p><p>间接的衡量标准有很多，前面我们讲到了一些，比如，看修改代码会不会牵一发而动全身。除此之外，还有一个直接的衡量标准，也是我在阅读源码的时候经常会用到的，那就是把模块与模块之间、类与类之间的依赖关系画出来，根据依赖关系图的复杂性来判断是否需要解耦重构。</p><p>如果依赖关系复杂、混乱，那从代码结构上来讲，可读性和可维护性肯定不是太好，那我们就需要考虑是否可以通过解耦的方法，让依赖关系变得清晰、简单。当然，这种判断还是有比较强的主观色彩，但是可以作为一种参考和梳理依赖的手段，配合间接的衡量标准一块来使用。</p><h2>如何给代码“解耦”？</h2><p>前面我们能讲了解耦的重要性，以及如何判断是否需要解耦，接下来，我们再来看一下，如何进行解耦。</p><h3>1.封装与抽象</h3><p>封装和抽象作为两个非常通用的设计思想，可以应用在很多设计场景中，比如系统、模块、lib、组件、接口、类等等的设计。封装和抽象可以有效地隐藏实现的复杂性，隔离实现的易变性，给依赖的模块提供稳定且易用的抽象接口。</p><p>比如，Unix系统提供的open()文件操作函数，我们用起来非常简单，但是底层实现却非常复杂，涉及权限控制、并发控制、物理存储等等。我们通过将其封装成一个抽象的open()函数，能够有效控制代码复杂性的蔓延，将复杂性封装在局部代码中。除此之外，因为open()函数基于抽象而非具体的实现来定义，所以我们在改动open()函数的底层实现的时候，并不需要改动依赖它的上层代码，也符合我们前面提到的“高内聚、松耦合”代码的评判标准。</p><h3>2.中间层</h3><p>引入中间层能简化模块或类之间的依赖关系。下面这张图是引入中间层前后的依赖关系对比图。在引入数据存储中间层之前，A、B、C三个模块都要依赖内存一级缓存、Redis二级缓存、DB持久化存储三个模块。在引入中间层之后，三个模块只需要依赖数据存储一个模块即可。从图上可以看出，中间层的引入明显地简化了依赖关系，让代码结构更加清晰。</p><p><img src=\"https://static001.geekbang.org/resource/image/cb/52/cbcefa78026fd1d0cb9837dde9adae52.jpg\" alt=\"\"></p><p>除此之外，我们在进行重构的时候，引入中间层可以起到过渡的作用，能够让开发和重构同步进行，不互相干扰。比如，某个接口设计得有问题，我们需要修改它的定义，同时，所有调用这个接口的代码都要做相应的改动。如果新开发的代码也用到这个接口，那开发就跟重构冲突了。为了让重构能小步快跑，我们可以分下面四个阶段来完成接口的修改。</p><ul>\n<li>第一阶段：引入一个中间层，包裹老的接口，提供新的接口定义。</li>\n<li>第二阶段：新开发的代码依赖中间层提供的新接口。</li>\n<li>第三阶段：将依赖老接口的代码改为调用新接口。</li>\n<li>第四阶段：确保所有的代码都调用新接口之后，删除掉老的接口。</li>\n</ul><p>这样，每个阶段的开发工作量都不会很大，都可以在很短的时间内完成。重构跟开发冲突的概率也变小了。</p><h3>3.模块化</h3><p>模块化是构建复杂系统常用的手段。不仅在软件行业，在建筑、机械制造等行业，这个手段也非常有用。对于一个大型复杂系统来说，没有人能掌控所有的细节。之所以我们能搭建出如此复杂的系统，并且能维护得了，最主要的原因就是将系统划分成各个独立的模块，让不同的人负责不同的模块，这样即便在不了解全部细节的情况下，管理者也能协调各个模块，让整个系统有效运转。</p><p>聚焦到软件开发上面，很多大型软件（比如Windows）之所以能做到几百、上千人有条不紊地协作开发，也归功于模块化做得好。不同的模块之间通过API来进行通信，每个模块之间耦合很小，每个小的团队聚焦于一个独立的高内聚模块来开发，最终像搭积木一样将各个模块组装起来，构建成一个超级复杂的系统。</p><p>我们再聚焦到代码层面。合理地划分模块能有效地解耦代码，提高代码的可读性和可维护性。所以，我们在开发代码的时候，一定要有模块化意识，将每个模块都当作一个独立的lib一样来开发，只提供封装了内部实现细节的接口给其他模块使用，这样可以减少不同模块之间的耦合度。</p><p>实际上，从刚刚的讲解中我们也可以发现，模块化的思想无处不在，像SOA、微服务、lib库、系统内模块划分，甚至是类、函数的设计，都体现了模块化思想。如果追本溯源，模块化思想更加本质的东西就是分而治之。</p><h3>4.其他设计思想和原则</h3><p>“高内聚、松耦合”是一个非常重要的设计思想，能够有效提高代码的可读性和可维护性，缩小功能改动导致的代码改动范围。实际上，在前面的章节中，我们已经多次提到过这个设计思想。很多设计原则都以实现代码的“高内聚、松耦合”为目的。我们来一块总结回顾一下都有哪些原则。</p><ul>\n<li>单一职责原则</li>\n</ul><p>我们前面提到，内聚性和耦合性并非独立的。高内聚会让代码更加松耦合，而实现高内聚的重要指导原则就是单一职责原则。模块或者类的职责设计得单一，而不是大而全，那依赖它的类和它依赖的类就会比较少，代码耦合也就相应的降低了。</p><ul>\n<li>基于接口而非实现编程</li>\n</ul><p>基于接口而非实现编程能通过接口这样一个中间层，隔离变化和具体的实现。这样做的好处是，在有依赖关系的两个模块或类之间，一个模块或者类的改动，不会影响到另一个模块或类。实际上，这就相当于将一种强依赖关系（强耦合）解耦为了弱依赖关系（弱耦合）。</p><ul>\n<li>依赖注入</li>\n</ul><p>跟基于接口而非实现编程思想类似，依赖注入也是将代码之间的强耦合变为弱耦合。尽管依赖注入无法将本应该有依赖关系的两个类，解耦为没有依赖关系，但可以让耦合关系没那么紧密，容易做到插拔替换。</p><ul>\n<li>多用组合少用继承</li>\n</ul><p>我们知道，继承是一种强依赖关系，父类与子类高度耦合，且这种耦合关系非常脆弱，牵一发而动全身，父类的每一次改动都会影响所有的子类。相反，组合关系是一种弱依赖关系，这种关系更加灵活，所以，对于继承结构比较复杂的代码，利用组合来替换继承，也是一种解耦的有效手段。</p><ul>\n<li>迪米特法则</li>\n</ul><p>迪米特法则讲的是，不该有直接依赖关系的类之间，不要有依赖；有依赖关系的类之间，尽量只依赖必要的接口。从定义上，我们明显可以看出，这条原则的目的就是为了实现代码的松耦合。至于如何应用这条原则来解耦代码，你可以回过头去阅读一下第22讲，这里我就不赘述了。</p><p>除了上面讲到的这些设计思想和原则之外，还有一些设计模式也是为了解耦依赖，比如观察者模式，有关这一部分的内容，我们留在设计模式模块中慢慢讲解。</p><h2>重点回顾</h2><p>好了，今天的内容到此就讲完了。我们来一块总结回顾一下，你需要重点掌握的内容。</p><p><strong>1.“解耦”为何如此重要？</strong></p><p>过于复杂的代码往往在可读性、可维护性上都不友好。解耦保证代码松耦合、高内聚，是控制代码复杂度的有效手段。代码高内聚、松耦合，也就是意味着，代码结构清晰、分层模块化合理、依赖关系简单、模块或类之间的耦合小，那代码整体的质量就不会差。</p><p><strong>2.代码是否需要“解耦”？</strong></p><p>间接的衡量标准有很多，比如，看修改代码是否牵一发而动全身。直接的衡量标准是把模块与模块、类与类之间的依赖关系画出来，根据依赖关系图的复杂性来判断是否需要解耦重构。</p><p><strong>3.如何给代码“解耦”？</strong></p><p>给代码解耦的方法有：封装与抽象、中间层、模块化，以及一些其他的设计思想与原则，比如：单一职责原则、基于接口而非实现编程、依赖注入、多用组合少用继承、迪米特法则等。当然，还有一些设计模式，比如观察者模式。</p><h2>课堂讨论</h2><p>实际上，在我们平时的开发中，解耦的思想到处可见，比如，Spring中的AOP能实现业务与非业务代码的解耦，IOC能实现对象的构造和使用的解耦。除此之外，你还能想到哪些解耦的应用场景吗？</p><p>欢迎在留言区写下你的思考和答案，和同学一起交流和分享。如果有收获，也欢迎你把这篇文章分享给你的朋友。</p>",
                "article_title": "30 | 理论四：如何通过封装、抽象、模块化、中间层等解耦代码？"
            },
            {
                "title": "31 | 理论五：让你最快速地改善代码质量的20条编程规范（上）",
                "herf": "https://time.geekbang.org/column/article/188622",
                "id": "188622",
                "content": "<p>前面我们讲了很多设计原则，后面还会讲到很多设计模式，利用好它们可以有效地改善代码质量。但是，这些知识的合理应用非常依赖个人经验，用不好有时候会适得其反。而我们接下来要讲的编码规范正好相反。编码规范大部分都简单明了，在代码细节方面，能立竿见影地改善质量。除此之外，我们前面也讲到，持续低层次、小规模重构依赖的基本上都是编码规范，这也是改善代码可读性的有效手段。</p><p>关于编码规范、如何编写可读代码，很多书籍已经讲得很好了，我在前面的加餐中也推荐过几本经典书籍。不过，这里我根据我自己的开发经验，总结罗列了20条我个人觉得最好用的编码规范。掌握这20条编码规范，能你最快速地改善代码质量。因为内容比较多，所以，我分为三节课来讲解，分别介绍编码规范的三个部分：命名与注释（Naming and Comments）、代码风格（Code Style）和编程技巧（Coding Tips）。</p><h2>命名</h2><p>大到项目名、模块名、包名、对外暴露的接口，小到类名、函数名、变量名、参数名，只要是做开发，我们就逃不过“起名字”这一关。命名的好坏，对于代码的可读性来说非常重要，甚至可以说是起决定性作用的。除此之外，命名能力也体现了一个程序员的基本编程素养。这也是我把“命名”放到第一个来讲解的原因。</p><!-- [[[read_end]]] --><p>取一个特别合适的名字是一件非常有挑战的事情，即便是对母语是英语的程序员来说，也是如此。而对于我们这些英语非母语的程序员来说，想要起一个能准确达意的名字，更是难上加难了。</p><p>实际上，命名这件事说难也不难，关键还是看你重不重视，愿不愿意花时间。对于影响范围比较大的命名，比如包名、接口、类名，我们一定要反复斟酌、推敲。实在想不到好名字的时候，可以去GitHub上用相关的关键词联想搜索一下，看看类似的代码是怎么命名的。</p><p>那具体应该怎么命名呢？好的命名有啥标准吗？接下来，我就从4点来讲解我的经验。</p><h3>1.命名多长最合适？</h3><p>在过往的团队和项目中，我遇到过两种截然不同的同事。有一种同事特别喜欢用很长的命名方式，觉得命名一定要准确达意，哪怕长一点也没关系，所以，这类同事的项目里，类名、函数名都很长。另外一种同事喜欢用短的命名方式，能用缩写就尽量用缩写，所以，项目里到处都是包含各种缩写的命名。你觉得这两种命名方式，哪种更值得推荐呢？</p><p>在我看来，尽管长的命名可以包含更多的信息，更能准确直观地表达意图，但是，如果函数、变量的命名很长，那由它们组成的语句就会很长。在代码列长度有限制的情况下，就会经常出现一条语句被分割成两行的情况，这其实会影响代码可读性。</p><p>实际上，在足够表达其含义的情况下，命名当然是越短越好。但是，大部分情况下，短的命名都没有长的命名更能达意。所以，很多书籍或者文章都不推荐在命名时使用缩写。对于一些默认的、大家都比较熟知的词，我比较推荐用缩写。这样一方面能让命名短一些，另一方面又不影响阅读理解，比如，sec表示second、str表示string、num表示number、doc表示document。除此之外，对于作用域比较小的变量，我们可以使用相对短的命名，比如一些函数内的临时变量。相反，对于类名这种作用域比较大的，我更推荐用长的命名方式。</p><p>总之，命名的一个原则就是以能准确达意为目标。不过，对于代码的编写者来说，自己对代码的逻辑很清楚，总感觉用什么样的命名都可以达意，实际上，对于不熟悉你代码的同事来讲，可能就不这么认为了。所以，命名的时候，我们一定要学会换位思考，假设自己不熟悉这块代码，从代码阅读者的角度去考量命名是否足够直观。</p><h3>2.利用上下文简化命名</h3><p>我们先来看一个简单的例子。</p><pre><code>public class User {\n  private String userName;\n  private String userPassword;\n  private String userAvatarUrl;\n  //...\n}\n</code></pre><p>在User类这样一个上下文中，我们没有在成员变量的命名中重复添加“user”这样一个前缀单词，而是直接命名为name、password、avatarUrl。在使用这些属性时候，我们能借助对象这样一个上下文，表意也足够明确。具体代码如下所示：</p><pre><code>User user = new User();\nuser.getName(); // 借助user对象这个上下文\n</code></pre><p>除了类之外，函数参数也可以借助函数这个上下文来简化命名。关于这一点，我举了下面这个例子，你一看就能明白，我就不多啰嗦了。</p><pre><code>public void uploadUserAvatarImageToAliyun(String userAvatarImageUri);\n//利用上下文简化为：\npublic void uploadUserAvatarImageToAliyun(String imageUri);\n</code></pre><h3>3.命名要可读、可搜索</h3><p>首先，我们来看，什么是命名可读。先解释一下，我这里所说的“可读”，指的是不要用一些特别生僻、难发音的英文单词来命名。</p><p>过去我曾参加过两个项目，一个叫plateaux，另一个叫eyrie，从项目立项到结束，自始至终都没有几个人能叫对这两个项目的名字。在沟通的时候，每当有人提到这两个项目的名字的时候，都会尴尬地卡顿一下。虽然我们并不排斥一些独特的命名方式，但起码得让大部分人看一眼就能知道怎么读。比如，我在Google参与过的一个项目，名叫inkstone，虽然你不一定知道它表示什么意思，但基本上都能读得上来，不影响沟通交流，这就算是一个比较好的项目命名。</p><p>我们再来讲一下命名可搜索。我们在IDE中编写代码的时候，经常会用“关键词联想”的方法来自动补全和搜索。比如，键入某个对象“.get”，希望IDE返回这个对象的所有get开头的方法。再比如，通过在IDE搜索框中输入“<em>Array</em>”，搜索JDK中数组相关的类。所以，我们在命名的时候，最好能符合整个项目的命名习惯。大家都用“selectXXX”表示查询，你就不要用“queryXXX”；大家都用“insertXXX”表示插入一条数据，你就要不用“addXXX”，统一规约是很重要的，能减少很多不必要的麻烦。</p><h3>4.如何命名接口和抽象类？</h3><p>对于接口的命名，一般有两种比较常见的方式。一种是加前缀“I”，表示一个Interface。比如IUserService，对应的实现类命名为UserService。另一种是不加前缀，比如UserService，对应的实现类加后缀“Impl”，比如UserServiceImpl。</p><p>对于抽象类的命名，也有两种方式，一种是带上前缀“Abstract”，比如AbstractConfiguration；另一种是不带前缀“Abstract”。实际上，对于接口和抽象类，选择哪种命名方式都是可以的，只要项目里能够统一就行。</p><h2>注释</h2><p>命名很重要，注释跟命名同等重要。很多书籍认为，好的命名完全可以替代注释。如果需要注释，那说明命名不够好，需要在命名上下功夫，而不是添加注释。实际上，我个人觉得，这样的观点有点太过极端。命名再好，毕竟有长度限制，不可能足够详尽，而这个时候，注释就是一个很好的补充。</p><h3>1.注释到底该写什么？</h3><p>注释的目的就是让代码更容易看懂。只要符合这个要求的内容，你就可以将它写到注释里。总结一下，注释的内容主要包含这样三个方面：做什么、为什么、怎么做。我来举一个例子给你具体解释一下。</p><pre><code>/**\n* (what) Bean factory to create beans. \n* \n* (why) The class likes Spring IOC framework, but is more lightweight. \n*\n* (how) Create objects from different sources sequentially:\n* user specified object &gt; SPI &gt; configuration &gt; default object.\n*/\npublic class BeansFactory {\n  // ...\n}\n</code></pre><p>有些人认为，注释是要提供一些代码没有的额外信息，所以不要写“做什么、怎么做”，这两方面在代码中都可以体现出来，只需要写清楚“为什么”，表明代码的设计意图即可。我个人不是特别认可这样的观点，理由主要有下面3点。</p><ul>\n<li>注释比代码承载的信息更多</li>\n</ul><p>命名的主要目的是解释“做什么”。比如，void increaseWalletAvailableBalance(BigDecimal amount)表明这个函数用来增加钱包的可用余额，boolean isValidatedPassword表明这个变量用来标识是否是合法密码。函数和变量如果命名得好，确实可以不用再在注释中解释它是做什么的。但是，对于类来说，包含的信息比较多，一个简单的命名就不够全面详尽了。这个时候，在注释中写明“做什么”就合情合理了。</p><ul>\n<li>注释起到总结性作用、文档的作用</li>\n</ul><p>代码之下无秘密。阅读代码可以明确地知道代码是“怎么做”的，也就是知道代码是如何实现的，那注释中是不是就不用写“怎么做”了？实际上也可以写。在注释中，关于具体的代码实现思路，我们可以写一些总结性的说明、特殊情况的说明。这样能够让阅读代码的人通过注释就能大概了解代码的实现思路，阅读起来就会更加容易。</p><p>实际上，对于有些比较复杂的类或者接口，我们可能还需要在注释中写清楚“如何用”，举一些简单的quick start的例子，让使用者在不阅读代码的情况下，快速地知道该如何使用。</p><ul>\n<li>一些总结性注释能让代码结构更清晰</li>\n</ul><p>对于逻辑比较复杂的代码或者比较长的函数，如果不好提炼、不好拆分成小的函数调用，那我们可以借助总结性的注释来让代码结构更清晰、更有条理。</p><pre><code>public boolean isValidPasword(String password) {\n  // check if password is null or empty\n  if (StringUtils.isBlank(password)) {\n    return false;\n  }\n\n  // check if the length of password is between 4 and 64\n  int length = password.length();\n  if (length &lt; 4 || length &gt; 64) {\n    return false;\n  }\n    \n  // check if password contains only a~z,0~9,dot\n  for (int i = 0; i &lt; length; ++i) {\n    char c = password.charAt(i);\n    if (!((c &gt;= 'a' &amp;&amp; c &lt;= 'z') || (c &gt;= '0' &amp;&amp; c &lt;= '9') || c == '.')) {\n      return false;\n    }\n  }\n  return true;\n}\n</code></pre><h3>2.注释是不是越多越好？</h3><p>注释太多和太少都有问题。太多，有可能意味着代码写得不够可读，需要写很多注释来补充。除此之外，注释太多也会对代码本身的阅读起到干扰。而且，后期的维护成本也比较高，有时候代码改了，注释忘了同步修改，就会让代码阅读者更加迷惑。当然，如果代码中一行注释都没有，那只能说明这个程序员很懒，我们要适当督促一下，让他注意添加一些必要的注释。</p><p>按照我的经验来说，类和函数一定要写注释，而且要写得尽可能全面、详细，而函数内部的注释要相对少一些，一般都是靠好的命名、提炼函数、解释性变量、总结性注释来提高代码的可读性。</p><h2>重点总结</h2><p>好了，今天的内容到此就讲完了。我们来一块总结回顾一下，你需要掌握的重点内容。</p><p><strong>1.关于命名</strong></p><ul>\n<li>命名的关键是能准确达意。对于不同作用域的命名，我们可以适当地选择不同的长度。作用域小的变量（比如临时变量），可以适当地选择短一些的命名方式。除此之外，命名中也可以使用一些耳熟能详的缩写。</li>\n<li>我们可以借助类的信息来简化属性、函数的命名，利用函数的信息来简化函数参数的命名。</li>\n<li>命名要可读、可搜索。不要使用生僻的、不好读的英文单词来命名。除此之外，命名要符合项目的统一规范，不要用些反直觉的命名。</li>\n<li>接口有两种命名方式：一种是在接口中带前缀“I”；另一种是在接口的实现类中带后缀“Impl”。对于抽象类的命名，也有两种方式，一种是带上前缀“Abstract”，一种是不带前缀。这两种命名方式都可以，关键是要在项目中统一。</li>\n</ul><p><strong>2.关于注释</strong></p><ul>\n<li>注释的目的就是让代码更容易看懂。只要符合这个要求的内容，你就可以将它写到注释里。总结一下，注释的内容主要包含这样三个方面：做什么、为什么、怎么做。对于一些复杂的类和接口，我们可能还需要写明“如何用”。</li>\n<li>注释本身有一定的维护成本，所以并非越多越好。类和函数一定要写注释，而且要写得尽可能全面、详细，而函数内部的注释要相对少一些，一般都是靠好的命名、提炼函数、解释性变量、总结性注释来提高代码可读性。</li>\n</ul><h2>课堂讨论</h2><ol>\n<li>在讲到“用总结性注释让代码结构更清晰”的时候，我们举了一个isValidPassword()函数的例子，在代码可读性方面，这个函数还有哪些可以继续优化的地方呢？</li>\n<li>关于注释，你推荐使用英文还是中文来书写呢？理由是什么呢？</li>\n</ol><p>欢迎在留言区写下你的答案，和同学一起交流和分享。如果有收获，也欢迎你把这篇文章分享给你的朋友。</p>",
                "article_title": "31 | 理论五：让你最快速地改善代码质量的20条编程规范（上）"
            },
            {
                "title": "32 | 理论五：让你最快速地改善代码质量的20条编程规范（中）",
                "herf": "https://time.geekbang.org/column/article/188857",
                "id": "188857",
                "content": "<p>上一节课中我们讲了命名和注释，这一节课我们来讲一下代码风格（Code Style）。说起代码风格，我们其实很难说哪种风格更好。最重要的，也是最需要我们做到的，是在团队、项目中保持风格统一，让代码像同一个人写出来的，整齐划一。这样能减少阅读干扰，提高代码的可读性。这才是我们在实际工作中想要实现的目标。</p><p>关于代码风格，我总结了6点我认为最值得关注的，今天跟你一块讨论学习一下。</p><h2>1.类、函数多大才合适？</h2><p>总体上来讲，类或函数的代码行数不能太多，但也不能太少。类或函数的代码行数太多，一个类上千行，一个函数几百行，逻辑过于繁杂，阅读代码的时候，很容易就会看了后面忘了前面。相反，类或函数的代码行数太少，在代码总量相同的情况下，被分割成的类和函数就会相应增多，调用关系就会变得更复杂，阅读某个代码逻辑的时候，需要频繁地在n多类或者n多函数之间跳来跳去，阅读体验也不好。</p><p>那一个类或函数有多少行代码才最合适呢？</p><p>我们在<a href=\"https://time.geekbang.org/column/article/171771\">第15讲</a>中提到过，要给出一个精确的量化值是很难的。当时我们还跟做饭做了类比，对于“放盐少许”中的“少许”，即便是大厨也很难告诉你一个特别具体的量值。</p><p>对于函数代码行数的最大限制，网上有一种说法，那就是不要超过一个显示屏的垂直高度。比如，在我的电脑上，如果要让一个函数的代码完整地显示在IDE中，那最大代码行数不能超过50。这个说法我觉得挺有道理的。因为超过一屏之后，在阅读代码的时候，为了串联前后的代码逻辑，就可能需要频繁地上下滚动屏幕，阅读体验不好不说，还容易出错。</p><!-- [[[read_end]]] --><p>对于类的代码行数的最大限制，这个就更难给出一个确切的值了。我们在第15讲中也给出了一个间接的判断标准，那就是，当一个类的代码读起来让你感觉头大了，实现某个功能时不知道该用哪个函数了，想用哪个函数翻半天都找不到了，只用到一个小功能要引入整个类（类中包含很多无关此功能实现的函数）的时候，这就说明类的行数过多了。</p><h2>2.一行代码多长最合适？</h2><p>在<a href=\"https://google.github.io/styleguide/javaguide.html\">Google Java Style Guide</a>文档中，一行代码最长限制为100个字符。不过，不同的编程语言、不同的规范、不同的项目团队，对此的限制可能都不相同。不管这个限制是多少，总体上来讲我们要遵循的一个原则是：一行代码最长不能超过IDE显示的宽度。需要滚动鼠标才能查看一行的全部代码，显然不利于代码的阅读。当然，这个限制也不能太小，太小会导致很多稍长点的语句被折成两行，也会影响到代码的整洁，不利于阅读。</p><h2>3.善用空行分割单元块</h2><p>对于比较长的函数，如果逻辑上可以分为几个独立的代码块，在不方便将这些独立的代码块抽取成小函数的情况下，为了让逻辑更加清晰，除了上一节课中提到的用总结性注释的方法之外，我们还可以使用空行来分割各个代码块。</p><p>除此之外，在类的成员变量与函数之间、静态成员变量与普通成员变量之间、各函数之间、甚至各成员变量之间，我们都可以通过添加空行的方式，让这些不同模块的代码之间，界限更加明确。写代码就类似写文章，善于应用空行，可以让代码的整体结构看起来更加有清晰、有条理。</p><h2>4.四格缩进还是两格缩进？</h2><p>“PHP是世界上最好的编程语言？代码换行应该四格缩进还是两格缩进？”这应该是程序员争论得最多的两个话题了。据我所知，Java语言倾向于两格缩进，PHP语言倾向于四格缩进。至于到底应该是两格缩进还是四格缩进，我觉得这个取决于个人喜好。只要项目内部能够统一就行了。</p><p>当然，还有一个选择的标准，那就是跟业内推荐的风格统一、跟著名开源项目统一。当我们需要拷贝一些开源的代码到项目里的时候，能够让引入的代码跟我们项目本身的代码，保持风格统一。</p><p>不过，我个人比较推荐使用两格缩进，这样可以节省空间。特别是在代码嵌套层次比较深的情况下，累计缩进较多的话，容易导致一个语句被折成两行，影响代码可读性。</p><p>除此之外，值得强调的是，不管是用两格缩进还是四格缩进，一定不要用tab键缩进。因为在不同的IDE下，tab键的显示宽度不同，有的显示为四格缩进，有的显示为两格缩进。如果在同一个项目中，不同的同事使用不同的缩进方式（空格缩进或tab键缩进），有可能会导致有的代码显示为两格缩进、有的代码显示为四格缩进。</p><h2>5.大括号是否要另起一行？</h2><p>左大括号是否要另起一行呢？这个也有争论。据我所知，PHP程序员喜欢另起一行，Java程序员喜欢跟上一条语句放到一起。具体代码示例如下所示：</p><pre><code>// PHP\nclass ClassName\n{\n    public function foo()\n    {\n        // method body\n    }\n}\n\n// Java\npublic class ClassName {\n  public void foo() {\n    // method body\n  }\n}\n</code></pre><p>我个人还是比较推荐，将括号放到跟语句同一行的风格。理由跟上面类似，节省代码行数。但是将大括号另起新的一行的方式，也有它的优势。这样的话，左右括号可以垂直对齐，哪些代码属于哪一个代码块，更一目了然。</p><p>不过，还是那句话，大括号跟上一条语句在同一行，还是另起新的一行，只要团队统一、业内统一、跟开源项目看齐就好了，没有绝对的优劣之分。</p><h2>6.类中成员的排列顺序</h2><p>在Java类文件中，先要书写类所属的包名，然后再罗列import引入的依赖类。在Google编码规范中，依赖类按照字母序从小到大排列。</p><p>在类中，成员变量排在函数的前面。成员变量之间或函数之间，都是按照“先静态（静态函数或静态成员变量）、后普通（非静态函数或非静态成员变量）”的方式来排列的。除此之外，成员变量之间或函数之间，还会按照作用域范围从大到小的顺序来排列，先写public成员变量或函数，然后是protected的，最后是private的。</p><p>不过，不同的编程语言中，类内部成员的排列顺序可能会有比较大的差别。比如C++中，成员变量会习惯性放到函数后面。除此之外，函数之间的排列顺序，会按照刚刚我们提到的作用域的大小来排列。实际上，还有另外一种排列习惯，那就是把有调用关系的函数放到一块。比如，一个public函数调用了另外一个private函数，那就把这两者放到一块。</p><h2>重点回顾</h2><p>好了，今天的内容到此就讲完了。我们一块来总结回顾一下，你需要重点掌握的内容。这一节课我们通过6点，来给你讲了代码风格中的注意点。</p><p><strong>1.函数、类多大才合适？</strong></p><p>函数的代码行数不要超过一屏幕的大小，比如50行。类的大小限制比较难确定。</p><p><strong>2.一行代码多长最合适？</strong></p><p>最好不要超过IDE显示的宽度。当然，限制也不能太小，太小会导致很多稍微长点的语句被折成两行，也会影响到代码的整洁，不利于阅读。</p><p><strong>3.善用空行分割单元块</strong></p><p>对于比较长的函数，为了让逻辑更加清晰，可以使用空行来分割各个代码块。在类内部，成员变量与函数之间、静态成员变量与普通成员变量之间、函数之间，甚至成员变量之间，都可以通过添加空行的方式，让不同模块的代码之间的界限更加明确。</p><p><strong>4.四格缩进还是两格缩进？</strong></p><p>我个人比较推荐使用两格缩进，这样可以节省空间，特别是在代码嵌套层次比较深的情况下。除此之外，值得强调的是，不管是用两格缩进还是四格缩进，一定不要用tab键缩进。</p><p><strong>5.大括号是否要另起一行？</strong></p><p>我个人还是比较推荐将大括号放到跟上一条语句同一行的风格，这样可以节省代码行数。但是，将大括号另起一行，也有它的优势，那就是，左右括号可以垂直对齐，哪些代码属于哪一个代码块，更加一目了然。</p><p><strong>6.类中成员的排列顺序</strong></p><p>在Google Java编程规范中，依赖类按照字母序从小到大排列。类中先写成员变量后写函数。成员变量之间或函数之间，先写静态成员变量或函数，后写普通变量或函数，并且按照作用域大小依次排列。</p><p>今天讲到所有的代码风格都没有对错和优劣之分，只要能在团队、项目中统一即可，不过，最好能跟业内推荐的风格、开源项目的代码风格相一致。</p><h2>课堂讨论</h2><p>聊一聊你熟悉的编程语言的代码风格，比如是四格缩进还是两格缩进？试着给自己的项目整理一份编程规范。</p><p>欢迎在留言区写下你的答案，和同学一起交流和分享。如果有收获，也欢迎你把这篇文章分享给你的朋友。</p>",
                "article_title": "32 | 理论五：让你最快速地改善代码质量的20条编程规范（中）"
            },
            {
                "title": "33 | 理论五：让你最快速地改善代码质量的20条编程规范（下）",
                "herf": "https://time.geekbang.org/column/article/188882",
                "id": "188882",
                "content": "<p>上两节课，我们讲了命名和注释、代码风格，今天我们来讲一些比较实用的编程技巧，帮你切实地提高代码可读性。这部分技巧比较琐碎，也很难罗列全面，我仅仅总结了一些我认为比较关键的，更多的技巧需要你在实践中自己慢慢总结、积累。</p><p>话不多说，让我们正式开始今天的学习吧！</p><h2>1.把代码分割成更小的单元块</h2><p>大部分人阅读代码的习惯都是，先看整体再看细节。所以，我们要有模块化和抽象思维，善于将大块的复杂逻辑提炼成类或者函数，屏蔽掉细节，让阅读代码的人不至于迷失在细节中，这样能极大地提高代码的可读性。不过，只有代码逻辑比较复杂的时候，我们其实才建议提炼类或者函数。毕竟如果提炼出的函数只包含两三行代码，在阅读代码的时候，还得跳过去看一下，这样反倒增加了阅读成本。</p><p>这里我举一个例子来进一步解释一下。代码具体如下所示。重构前，在invest()函数中，最开始的那段关于时间处理的代码，是不是很难看懂？重构之后，我们将这部分逻辑抽象成一个函数，并且命名为isLastDayOfMonth，从名字就能清晰地了解它的功能，判断今天是不是当月的最后一天。这里，我们就是通过将复杂的逻辑代码提炼成函数，大大提高了代码的可读性。</p><pre><code>// 重构前的代码\npublic void invest(long userId, long financialProductId) {\n  Calendar calendar = Calendar.getInstance();\n  calendar.setTime(date);\n  calendar.set(Calendar.DATE, (calendar.get(Calendar.DATE) + 1));\n  if (calendar.get(Calendar.DAY_OF_MONTH) == 1) {\n    return;\n  }\n  //...\n}\n\n// 重构后的代码：提炼函数之后逻辑更加清晰\npublic void invest(long userId, long financialProductId) {\n  if (isLastDayOfMonth(new Date())) {\n    return;\n  }\n  //...\n}\n\npublic boolean isLastDayOfMonth(Date date) {\n  Calendar calendar = Calendar.getInstance();\n  calendar.setTime(date);\n  calendar.set(Calendar.DATE, (calendar.get(Calendar.DATE) + 1));\n  if (calendar.get(Calendar.DAY_OF_MONTH) == 1) {\n   return true;\n  }\n  return false;\n}\n</code></pre><!-- [[[read_end]]] --><h2>2.避免函数参数过多</h2><p>我个人觉得，函数包含3、4个参数的时候还是能接受的，大于等于5个的时候，我们就觉得参数有点过多了，会影响到代码的可读性，使用起来也不方便。针对参数过多的情况，一般有2种处理方法。</p><ul>\n<li>考虑函数是否职责单一，是否能通过拆分成多个函数的方式来减少参数。示例代码如下所示：</li>\n</ul><pre><code>public User getUser(String username, String telephone, String email);\n\n// 拆分成多个函数\npublic User getUserByUsername(String username);\npublic User getUserByTelephone(String telephone);\npublic User getUserByEmail(String email);\n</code></pre><ul>\n<li>将函数的参数封装成对象。示例代码如下所示：</li>\n</ul><pre><code>public void postBlog(String title, String summary, String keywords, String content, String category, long authorId);\n\n// 将参数封装成对象\npublic class Blog {\n  private String title;\n  private String summary;\n  private String keywords;\n  private Strint content;\n  private String category;\n  private long authorId;\n}\npublic void postBlog(Blog blog);\n</code></pre><p>除此之外，如果函数是对外暴露的远程接口，将参数封装成对象，还可以提高接口的兼容性。在往接口中添加新的参数的时候，老的远程接口调用者有可能就不需要修改代码来兼容新的接口了。</p><h2>3.勿用函数参数来控制逻辑</h2><p>不要在函数中使用布尔类型的标识参数来控制内部逻辑，true的时候走这块逻辑，false的时候走另一块逻辑。这明显违背了单一职责原则和接口隔离原则。我建议将其拆成两个函数，可读性上也要更好。我举个例子来说明一下。</p><pre><code>public void buyCourse(long userId, long courseId, boolean isVip);\n\n// 将其拆分成两个函数\npublic void buyCourse(long userId, long courseId);\npublic void buyCourseForVip(long userId, long courseId);\n</code></pre><p>不过，如果函数是private私有函数，影响范围有限，或者拆分之后的两个函数经常同时被调用，我们可以酌情考虑保留标识参数。示例代码如下所示：</p><pre><code>// 拆分成两个函数的调用方式\nboolean isVip = false;\n//...省略其他逻辑...\nif (isVip) {\n  buyCourseForVip(userId, courseId);\n} else {\n  buyCourse(userId, courseId);\n}\n\n// 保留标识参数的调用方式更加简洁\nboolean isVip = false;\n//...省略其他逻辑...\nbuyCourse(userId, courseId, isVip);\n</code></pre><p>除了布尔类型作为标识参数来控制逻辑的情况外，还有一种“根据参数是否为null”来控制逻辑的情况。针对这种情况，我们也应该将其拆分成多个函数。拆分之后的函数职责更明确，不容易用错。具体代码示例如下所示：</p><pre><code>public List&lt;Transaction&gt; selectTransactions(Long userId, Date startDate, Date endDate) {\n  if (startDate != null &amp;&amp; endDate != null) {\n    // 查询两个时间区间的transactions\n  }\n  if (startDate != null &amp;&amp; endDate == null) {\n    // 查询startDate之后的所有transactions\n  }\n  if (startDate == null &amp;&amp; endDate != null) {\n    // 查询endDate之前的所有transactions\n  }\n  if (startDate == null &amp;&amp; endDate == null) {\n    // 查询所有的transactions\n  }\n}\n\n// 拆分成多个public函数，更加清晰、易用\npublic List&lt;Transaction&gt; selectTransactionsBetween(Long userId, Date startDate, Date endDate) {\n  return selectTransactions(userId, startDate, endDate);\n}\n\npublic List&lt;Transaction&gt; selectTransactionsStartWith(Long userId, Date startDate) {\n  return selectTransactions(userId, startDate, null);\n}\n\npublic List&lt;Transaction&gt; selectTransactionsEndWith(Long userId, Date endDate) {\n  return selectTransactions(userId, null, endDate);\n}\n\npublic List&lt;Transaction&gt; selectAllTransactions(Long userId) {\n  return selectTransactions(userId, null, null);\n}\n\nprivate List&lt;Transaction&gt; selectTransactions(Long userId, Date startDate, Date endDate) {\n  // ...\n}\n</code></pre><h2>4.函数设计要职责单一</h2><p>我们在前面讲到单一职责原则的时候，针对的是类、模块这样的应用对象。实际上，对于函数的设计来说，更要满足单一职责原则。相对于类和模块，函数的粒度比较小，代码行数少，所以在应用单一职责原则的时候，没有像应用到类或者模块那样模棱两可，能多单一就多单一。</p><p>具体的代码示例如下所示：</p><pre><code>public boolean checkUserIfExisting(String telephone, String username, String email)  { \n  if (!StringUtils.isBlank(telephone)) {\n    User user = userRepo.selectUserByTelephone(telephone);\n    return user != null;\n  }\n  \n  if (!StringUtils.isBlank(username)) {\n    User user = userRepo.selectUserByUsername(username);\n    return user != null;\n  }\n  \n  if (!StringUtils.isBlank(email)) {\n    User user = userRepo.selectUserByEmail(email);\n    return user != null;\n  }\n  \n  return false;\n}\n\n// 拆分成三个函数\npublic boolean checkUserIfExistingByTelephone(String telephone);\npublic boolean checkUserIfExistingByUsername(String username);\npublic boolean checkUserIfExistingByEmail(String email);\n</code></pre><h2>5.移除过深的嵌套层次</h2><p>代码嵌套层次过深往往是因为if-else、switch-case、for循环过度嵌套导致的。我个人建议，嵌套最好不超过两层，超过两层之后就要思考一下是否可以减少嵌套。过深的嵌套本身理解起来就比较费劲，除此之外，嵌套过深很容易因为代码多次缩进，导致嵌套内部的语句超过一行的长度而折成两行，影响代码的整洁。</p><p>解决嵌套过深的方法也比较成熟，有下面4种常见的思路。</p><ul>\n<li>去掉多余的if或else语句。代码示例如下所示：</li>\n</ul><pre><code>// 示例一\npublic double caculateTotalAmount(List&lt;Order&gt; orders) {\n  if (orders == null || orders.isEmpty()) {\n    return 0.0;\n  } else { // 此处的else可以去掉\n    double amount = 0.0;\n    for (Order order : orders) {\n      if (order != null) {\n        amount += (order.getCount() * order.getPrice());\n      }\n    }\n    return amount;\n  }\n}\n\n// 示例二\npublic List&lt;String&gt; matchStrings(List&lt;String&gt; strList,String substr) {\n  List&lt;String&gt; matchedStrings = new ArrayList&lt;&gt;();\n  if (strList != null &amp;&amp; substr != null) {\n    for (String str : strList) {\n      if (str != null) { // 跟下面的if语句可以合并在一起\n        if (str.contains(substr)) {\n          matchedStrings.add(str);\n        }\n      }\n    }\n  }\n  return matchedStrings;\n}\n</code></pre><ul>\n<li>使用编程语言提供的continue、break、return关键字，提前退出嵌套。代码示例如下所示：</li>\n</ul><pre><code>// 重构前的代码\npublic List&lt;String&gt; matchStrings(List&lt;String&gt; strList,String substr) {\n  List&lt;String&gt; matchedStrings = new ArrayList&lt;&gt;();\n  if (strList != null &amp;&amp; substr != null){ \n    for (String str : strList) {\n      if (str != null &amp;&amp; str.contains(substr)) {\n        matchedStrings.add(str);\n        // 此处还有10行代码...\n      }\n    }\n  }\n  return matchedStrings;\n}\n\n// 重构后的代码：使用continue提前退出\npublic List&lt;String&gt; matchStrings(List&lt;String&gt; strList,String substr) {\n  List&lt;String&gt; matchedStrings = new ArrayList&lt;&gt;();\n  if (strList != null &amp;&amp; substr != null){ \n    for (String str : strList) {\n      if (str == null || !str.contains(substr)) {\n        continue; \n      }\n      matchedStrings.add(str);\n      // 此处还有10行代码...\n    }\n  }\n  return matchedStrings;\n}\n</code></pre><ul>\n<li>调整执行顺序来减少嵌套。具体的代码示例如下所示：</li>\n</ul><pre><code>// 重构前的代码\npublic List&lt;String&gt; matchStrings(List&lt;String&gt; strList,String substr) {\n  List&lt;String&gt; matchedStrings = new ArrayList&lt;&gt;();\n  if (strList != null &amp;&amp; substr != null) {\n    for (String str : strList) {\n      if (str != null) {\n        if (str.contains(substr)) {\n          matchedStrings.add(str);\n        }\n      }\n    }\n  }\n  return matchedStrings;\n}\n\n// 重构后的代码：先执行判空逻辑，再执行正常逻辑\npublic List&lt;String&gt; matchStrings(List&lt;String&gt; strList,String substr) {\n  if (strList == null || substr == null) { //先判空\n    return Collections.emptyList();\n  }\n\n  List&lt;String&gt; matchedStrings = new ArrayList&lt;&gt;();\n  for (String str : strList) {\n    if (str != null) {\n      if (str.contains(substr)) {\n        matchedStrings.add(str);\n      }\n    }\n  }\n  return matchedStrings;\n}\n</code></pre><ul>\n<li>将部分嵌套逻辑封装成函数调用，以此来减少嵌套。具体的代码示例如下所示：</li>\n</ul><pre><code>// 重构前的代码\npublic List&lt;String&gt; appendSalts(List&lt;String&gt; passwords) {\n  if (passwords == null || passwords.isEmpty()) {\n    return Collections.emptyList();\n  }\n  \n  List&lt;String&gt; passwordsWithSalt = new ArrayList&lt;&gt;();\n  for (String password : passwords) {\n    if (password == null) {\n      continue;\n    }\n    if (password.length() &lt; 8) {\n      // ...\n    } else {\n      // ...\n    }\n  }\n  return passwordsWithSalt;\n}\n\n// 重构后的代码：将部分逻辑抽成函数\npublic List&lt;String&gt; appendSalts(List&lt;String&gt; passwords) {\n  if (passwords == null || passwords.isEmpty()) {\n    return Collections.emptyList();\n  }\n\n  List&lt;String&gt; passwordsWithSalt = new ArrayList&lt;&gt;();\n  for (String password : passwords) {\n    if (password == null) {\n      continue;\n    }\n    passwordsWithSalt.add(appendSalt(password));\n  }\n  return passwordsWithSalt;\n}\n\nprivate String appendSalt(String password) {\n  String passwordWithSalt = password;\n  if (password.length() &lt; 8) {\n    // ...\n  } else {\n    // ...\n  }\n  return passwordWithSalt;\n}\n</code></pre><p>除此之外，常用的还有通过使用多态来替代if-else、switch-case条件判断的方法。这个思路涉及代码结构的改动，我们会在后面的章节中讲到，这里就暂时不展开说明了。</p><h2>6.学会使用解释性变量</h2><p>常用的用解释性变量来提高代码的可读性的情况有下面2种。</p><ul>\n<li>常量取代魔法数字。示例代码如下所示：</li>\n</ul><pre><code>public double CalculateCircularArea(double radius) {\n  return (3.1415) * radius * radius;\n}\n\n// 常量替代魔法数字\npublic static final Double PI = 3.1415;\npublic double CalculateCircularArea(double radius) {\n  return PI * radius * radius;\n}\n</code></pre><ul>\n<li>使用解释性变量来解释复杂表达式。示例代码如下所示：</li>\n</ul><pre><code>if (date.after(SUMMER_START) &amp;&amp; date.before(SUMMER_END)) {\n  // ...\n} else {\n  // ...\n}\n\n// 引入解释性变量后逻辑更加清晰\nboolean isSummer = date.after(SUMMER_START)&amp;&amp;date.before(SUMMER_END);\nif (isSummer) {\n  // ...\n} else {\n  // ...\n} \n</code></pre><h2>重点回顾</h2><p>好了，今天的内容到此就讲完了。除了今天讲的编程技巧，前两节课我们还分别讲解了命名与注释、代码风格。现在，我们一块来回顾复习一下这三节课的重点内容。</p><p><strong>1.关于命名</strong></p><ul>\n<li>命名的关键是能准确达意。对于不同作用域的命名，我们可以适当地选择不同的长度。</li>\n<li>我们可以借助类的信息来简化属性、函数的命名，利用函数的信息来简化函数参数的命名。</li>\n<li>命名要可读、可搜索。不要使用生僻的、不好读的英文单词来命名。命名要符合项目的统一规范，也不要用些反直觉的命名。</li>\n<li>接口有两种命名方式：一种是在接口中带前缀“I”；另一种是在接口的实现类中带后缀“Impl”。对于抽象类的命名，也有两种方式，一种是带上前缀“Abstract”，一种是不带前缀。这两种命名方式都可以，关键是要在项目中统一。</li>\n</ul><p><strong>2.关于注释</strong></p><ul>\n<li>注释的内容主要包含这样三个方面：做什么、为什么、怎么做。对于一些复杂的类和接口，我们可能还需要写明“如何用”。</li>\n<li>类和函数一定要写注释，而且要写得尽可能全面详细。函数内部的注释要相对少一些，一般都是靠好的命名、提炼函数、解释性变量、总结性注释来提高代码可读性。</li>\n</ul><p><strong>3.关于代码风格</strong></p><ul>\n<li>函数、类多大才合适？函数的代码行数不要超过一屏幕的大小，比如50行。类的大小限制比较难确定。</li>\n<li>一行代码多长最合适？最好不要超过IDE的显示宽度。当然，也不能太小，否则会导致很多稍微长点的语句被折成两行，也会影响到代码的整洁，不利于阅读。</li>\n<li>善用空行分割单元块。对于比较长的函数，为了让逻辑更加清晰，可以使用空行来分割各个代码块。</li>\n<li>四格缩进还是两格缩进？我个人比较推荐使用两格缩进，这样可以节省空间，尤其是在代码嵌套层次比较深的情况下。不管是用两格缩进还是四格缩进，一定不要用tab键缩进。</li>\n<li>大括号是否要另起一行？将大括号放到跟上一条语句同一行，可以节省代码行数。但是将大括号另起新的一行的方式，左右括号可以垂直对齐，哪些代码属于哪一个代码块，更加一目了然。</li>\n<li>类中成员怎么排列？在Google Java编程规范中，依赖类按照字母序从小到大排列。类中先写成员变量后写函数。成员变量之间或函数之间，先写静态成员变量或函数，后写普通变量或函数，并且按照作用域大小依次排列。</li>\n</ul><p><strong>4.关于编码技巧</strong></p><ul>\n<li>将复杂的逻辑提炼拆分成函数和类。</li>\n<li>通过拆分成多个函数或将参数封装为对象的方式，来处理参数过多的情况。</li>\n<li>函数中不要使用参数来做代码执行逻辑的控制。</li>\n<li>函数设计要职责单一。</li>\n<li>移除过深的嵌套层次，方法包括：去掉多余的if或else语句，使用continue、break、return关键字提前退出嵌套，调整执行顺序来减少嵌套，将部分嵌套逻辑抽象成函数。</li>\n<li>用字面常量取代魔法数。</li>\n<li>用解释性变量来解释复杂表达式，以此提高代码可读性。</li>\n</ul><p><strong>5.统一编码规范</strong></p><p>除了这三节讲到的比较细节的知识点之外，最后，还有一条非常重要的，那就是，项目、团队，甚至公司，一定要制定统一的编码规范，并且通过Code Review督促执行，这对提高代码质量有立竿见影的效果。</p><h2>课堂讨论</h2><p>到此为止，我们整个20条编码规范就讲完了。不知道你掌握了多少呢？除了今天我提到的这些，还有哪些其他的编程技巧，可以明显改善代码的可读性？</p><p>试着在留言区总结罗列一下，和同学一起交流和分享。如果有收获，也欢迎你把这篇文章分享给你的朋友。</p>",
                "article_title": "33 | 理论五：让你最快速地改善代码质量的20条编程规范（下）"
            },
            {
                "title": "34 | 实战一（上）：通过一段ID生成器代码，学习如何发现代码质量问题",
                "herf": "https://time.geekbang.org/column/article/190979",
                "id": "190979",
                "content": "<p>在前面几节课中，我们讲了一些跟重构相关的理论知识，比如：持续重构、单元测试、代码的可测试性、解耦、编码规范。用一句话总结一下，重构就是发现代码质量问题，并且对其进行优化的过程。</p><p>前面的内容相对还是偏理论。今天，我就借助一个大家都很熟悉的ID生成器代码，给你展示一下重构的大致过程。整个内容分为两节课。这一节课我们讲述如何发现代码质量问题，下一节课讲述如何针对发现的质量问题，对其进行优化，将它从“能用”变得“好用”。</p><p>话不多说，让我们正式开始今天的学习吧！</p><h2>ID生成器需求背景介绍</h2><p>“ID”中文翻译为“标识（Identifier）”。这个概念在生活、工作中随处可见，比如身份证、商品条形码、二维码、车牌号、驾照号。聚焦到软件开发中，ID常用来表示一些业务信息的唯一标识，比如订单的单号或者数据库中的唯一主键，比如地址表中的ID字段（实际上是没有业务含义的，对用户来说是透明的，不需要关注）。</p><p>假设你正在参与一个后端业务系统的开发，为了方便在请求出错时排查问题，我们在编写代码的时候会在关键路径上打印日志。某个请求出错之后，我们希望能搜索出这个请求对应的所有日志，以此来查找问题的原因。而实际情况是，在日志文件中，不同请求的日志会交织在一起。如果没有东西来标识哪些日志属于同一个请求，我们就无法关联同一个请求的所有日志。</p><!-- [[[read_end]]] --><p>这听起来有点像微服务中的调用链追踪。不过，微服务中的调用链追踪是服务间的追踪，我们现在要实现的是服务内的追踪。</p><p>借鉴微服务调用链追踪的实现思路，我们可以给每个请求分配一个唯一ID，并且保存在请求的上下文（Context）中，比如，处理请求的工作线程的局部变量中。在Java语言中，我们可以将ID存储在Servlet线程的ThreadLocal中，或者利用Slf4j日志框架的MDC（Mapped Diagnostic Contexts）来实现（实际上底层原理也是基于线程的ThreadLocal）。每次打印日志的时候，我们从请求上下文中取出请求ID，跟日志一块输出。这样，同一个请求的所有日志都包含同样的请求ID信息，我们就可以通过请求ID来搜索同一个请求的所有日志了。</p><p>好了，需求背景我们已经讲清楚了，至于具体如何实现整个需求，我就不展开来讲解了。如果你感兴趣的话，可以自己试着去设计实现一下。我们接下来只关注其中生成请求ID这部分功能的开发。</p><h2>一份“能用”的代码实现</h2><p>假设leader让小王负责这个ID生成器的开发。对于稍微有点开发经验的程序员来说，实现这样一个简单的ID生成器，并不是件难事。所以，小王很快就完成了任务，将代码写了出来，具体如下所示：</p><pre><code>public class IdGenerator {\n  private static final Logger logger = LoggerFactory.getLogger(IdGenerator.class);\n\n  public static String generate() {\n    String id = &quot;&quot;;\n    try {\n      String hostName = InetAddress.getLocalHost().getHostName();\n      String[] tokens = hostName.split(&quot;\\\\.&quot;);\n      if (tokens.length &gt; 0) {\n        hostName = tokens[tokens.length - 1];\n      }\n      char[] randomChars = new char[8];\n      int count = 0;\n      Random random = new Random();\n      while (count &lt; 8) {\n        int randomAscii = random.nextInt(122);\n        if (randomAscii &gt;= 48 &amp;&amp; randomAscii &lt;= 57) {\n          randomChars[count] = (char)('0' + (randomAscii - 48));\n          count++;\n        } else if (randomAscii &gt;= 65 &amp;&amp; randomAscii &lt;= 90) {\n          randomChars[count] = (char)('A' + (randomAscii - 65));\n          count++;\n        } else if (randomAscii &gt;= 97 &amp;&amp; randomAscii &lt;= 122) {\n          randomChars[count] = (char)('a' + (randomAscii - 97));\n          count++;\n        }\n      }\n      id = String.format(&quot;%s-%d-%s&quot;, hostName,\n              System.currentTimeMillis(), new String(randomChars));\n    } catch (UnknownHostException e) {\n      logger.warn(&quot;Failed to get the host name.&quot;, e);\n    }\n\n    return id;\n  }\n}\n</code></pre><p>上面的代码生成的ID示例如下所示。整个ID由三部分组成。第一部分是本机名的最后一个字段。第二部分是当前时间戳，精确到毫秒。第三部分是8位的随机字符串，包含大小写字母和数字。尽管这样生成的ID并不是绝对唯一的，有重复的可能，但事实上重复的概率非常低。对于我们的日志追踪来说，极小概率的ID重复是完全可以接受的。</p><pre><code>103-1577456311467-3nR3Do45\n103-1577456311468-0wnuV5yw\n103-1577456311468-sdrnkFxN\n103-1577456311468-8lwk0BP0\n</code></pre><p>不过，在我看来，像小王的这份代码只能算得上“能用”，勉强及格。我为啥这么说呢？这段代码只有短短不到40行，里面却有很多值得优化的地方。你可以先思考一下，在纸上试着罗列一下这段代码存在的问题，然后再对比来看我下面的讲解。</p><h2>如何发现代码质量问题？</h2><p>从大处着眼的话，我们可以参考之前讲过的代码质量评判标准，看这段代码是否可读、可扩展、可维护、灵活、简洁、可复用、可测试等等。落实到具体细节，我们可以从以下几个方面来审视代码。</p><ul>\n<li>目录设置是否合理、模块划分是否清晰、代码结构是否满足“高内聚、松耦合”？</li>\n<li>是否遵循经典的设计原则和设计思想（SOLID、DRY、KISS、YAGNI、LOD等）？</li>\n<li>设计模式是否应用得当？是否有过度设计？</li>\n<li>代码是否容易扩展？如果要添加新功能，是否容易实现？</li>\n<li>代码是否可以复用？是否可以复用已有的项目代码或类库？是否有重复造轮子？</li>\n<li>代码是否容易测试？单元测试是否全面覆盖了各种正常和异常的情况？</li>\n<li>代码是否易读？是否符合编码规范（比如命名和注释是否恰当、代码风格是否一致等）？</li>\n</ul><p>以上是一些通用的关注点，可以作为常规检查项，套用在任何代码的重构上。除此之外，我们还要关注代码实现是否满足业务本身特有的功能和非功能需求。我罗列了一些比较有共性的问题，如下所示。这份列表可能还不够全面，剩下的需要你针对具体的业务、具体的代码去具体分析。</p><ul>\n<li>代码是否实现了预期的业务需求？</li>\n<li>逻辑是否正确？是否处理了各种异常情况？</li>\n<li>日志打印是否得当？是否方便debug排查问题？</li>\n<li>接口是否易用？是否支持幂等、事务等？</li>\n<li>代码是否存在并发问题？是否线程安全？</li>\n<li>性能是否有优化空间，比如，SQL、算法是否可以优化？</li>\n<li>是否有安全漏洞？比如输入输出校验是否全面？</li>\n</ul><p><strong>现在，对照上面的检查项，我们来看一下，小王编写的代码有哪些问题。</strong></p><p>首先，IdGenerator的代码比较简单，只有一个类，所以，不涉及目录设置、模块划分、代码结构问题，也不违反基本的SOLID、DRY、KISS、YAGNI、LOD等设计原则。它没有应用设计模式，所以也不存在不合理使用和过度设计的问题。</p><p>其次，IdGenerator设计成了实现类而非接口，调用者直接依赖实现而非接口，违反基于接口而非实现编程的设计思想。实际上，将IdGenerator设计成实现类，而不定义接口，问题也不大。如果哪天ID生成算法改变了，我们只需要直接修改实现类的代码就可以。但是，如果项目中需要同时存在两种ID生成算法，也就是要同时存在两个IdGenerator实现类。比如，我们需要将这个框架给更多的系统来使用。系统在使用的时候，可以灵活地选择它需要的生成算法。这个时候，我们就需要将IdGenerator定义为接口，并且为不同的生成算法定义不同的实现类。</p><p>再次，把IdGenerator的generate()函数定义为静态函数，会影响使用该函数的代码的可测试性。同时，generate()函数的代码实现依赖运行环境（本机名）、时间函数、随机函数，所以generate()函数本身的可测试性也不好，需要做比较大的重构。除此之外，小王也没有编写单元测试代码，我们需要在重构时对其进行补充。</p><p>最后，虽然IdGenerator只包含一个函数，并且代码行数也不多，但代码的可读性并不好。特别是随机字符串生成的那部分代码，一方面，代码完全没有注释，生成算法比较难读懂，另一方面，代码里有很多魔法数，严重影响代码的可读性。在重构的时候，我们需要重点提高这部分代码的可读性。</p><p><strong>刚刚我们参照跟业务本身无关的、通用的代码质量关注点，对小王的代码进行了评价。现在，我们再对照业务本身的功能和非功能需求，重新审视一下小王的代码。</strong></p><p>前面我们提到，虽然小王的代码生成的ID并非绝对的唯一，但是对于追踪打印日志来说，是可以接受小概率ID冲突的，满足我们预期的业务需求。不过，获取hostName这部分代码逻辑貌似有点问题，并未处理“hostName为空”的情况。除此之外，尽管代码中针对获取不到本机名的情况做了异常处理，但是小王对异常的处理是在IdGenerator内部将其吐掉，然后打印一条报警日志，并没有继续往上抛出。这样的异常处理是否得当呢？你可以先自己思考一下，我们把这部分内容放到第36、37讲中具体讲解。</p><p>小王代码的日志打印得当，日志描述能够准确反应问题，方便debug，并且没有过多的冗余日志。IdGenerator只暴露一个generate()接口供使用者使用，接口的定义简单明了，不存在不易用问题。generate()函数代码中没有涉及共享变量，所以代码线程安全，多线程环境下调用generate()函数不存在并发问题。</p><p>性能方面，ID的生成不依赖外部存储，在内存中生成，并且日志的打印频率也不会很高，所以小王的代码在性能方面足以应对目前的应用场景。不过，每次生成ID都需要获取本机名，获取主机名会比较耗时，所以，这部分可以考虑优化一下。还有，randomAscii的范围是0～122，但可用数字仅包含三段子区间（0~9，a~z，A~Z），极端情况下会随机生成很多三段区间之外的无效数字，需要循环很多次才能生成随机字符串，所以随机字符串的生成算法也可以优化一下。</p><p><strong>刚刚我们还讲到，有一些代码质量问题不具有共性，我们没法一一罗列，需要你针对具体的业务、具体的代码去具体分析。那像小王的这份代码，你还能发现有哪些具体问题吗？</strong></p><p>在generate()函数的while循环里面，三个if语句内部的代码非常相似，而且实现稍微有点过于复杂了，实际上可以进一步简化，将这三个if合并在一起。具体如何来做，我们留在下一节课中讲解。</p><p>今天的知识内容我们讲到这里其实就差不多了。那跟随我看到这里，你有没有觉得，你的内功加深了很多呢？之前看到一段代码，你想要重构，但不知道该如何入手，也不知道该如何评价这段代码写得好坏，更不知道该如何系统、全面地进行分析。而现在，你可以很轻松地罗列出这段代码的质量缺陷，并且做到有章可循、全面系统、无遗漏。之所以现在能做到这样，那是得益于前面很多理论知识的学习和铺垫。所谓“会者不难，难者不会”，其实就是这个道理！</p><p>如果我们没有前面n多知识点的铺垫，比如，面向对象和面向过程的区别、面向对象的四大特性、面向过程编程的弊端以及如何控制弊端带来的副作用、需求分析方法、类的设计思路、类之间的关系、接口和抽象类的区别、各种设计原则和思想等等，我相信很多人都不能完美地解决今天的问题。</p><p>那你可能要说了，今天这段代码并没有涉及之前所有的知识点啊？你说得没错。但是，<strong>如果没有知识点的全面积累，我们就无法构建出大的知识框架，更不知道知识的边界在哪里，也就无法形成系统的方法论。即便你能歪打误撞回答全面，也不会像现在这样对自己的答案如此自信和笃定。</strong></p><h2>重点回顾</h2><p>好了，今天的内容到此就讲完了。我们来一块总结回顾一下，你需要重点掌握的内容。</p><p>今天我们其实就重点讲了一个问题，那就是，如何发现代码质量问题？这其实是我整理的一个发现代码质量问题的checklist。之后，你在review自己的代码时，可以参考这两个checklist来进行全面的review。</p><p>首先，从大处着眼的话，我们可以参考之前讲过的代码质量评判标准，看代码是否可读、可扩展、可维护、灵活、简洁、可复用、可测试等。落实到具体细节，我们可以从以下7个方面来审视代码。</p><p><img src=\"https://static001.geekbang.org/resource/image/04/c9/041e22cac6ce2ba3481e246c119adfc9.jpg\" alt=\"\"></p><p>这些都是一些通用的关注点，可以作为一些常规检查项，套用在任何代码的重构上。除此之外，我们还要关注代码实现是否满足业务本身特有的功能和非功能需求。一些比较共性的关注点如下所示：</p><p><img src=\"https://static001.geekbang.org/resource/image/98/98/9894233257994a69102afa960692ce98.jpg\" alt=\"\"></p><h2>课堂讨论</h2><p>在今天的代码中，打印日志的Logger对象被定义为static final的，并且在类内部创建，这是否影响到IdGenerator类代码的可测试性？是否应该将Logger对象通过依赖注入的方式注入到IdGenerator类中呢？</p><p>欢迎在留言区写下你的答案，和同学一起交流和分享。如果有收获，也欢迎你把这篇文章分享给你的朋友。</p>",
                "article_title": "34 | 实战一（上）：通过一段ID生成器代码，学习如何发现代码质量问题"
            },
            {
                "title": "35 | 实战一（下）：手把手带你将ID生成器代码从“能用”重构为“好用”",
                "herf": "https://time.geekbang.org/column/article/191621",
                "id": "191621",
                "content": "<p>上一节课中，我们结合ID生成器代码讲解了如何发现代码质量问题。虽然ID生成器的需求非常简单，代码行数也不多，但看似非常简单的代码，实际上还是有很多优化的空间。综合评价一下的话，小王的代码也只能算是“能用”、勉强及格。我们大部分人写出来的代码都能达到这个程度。如果想要在团队中脱颖而出，我们就不能只满足于这个60分及格，大家都能做的事情，我们要做得更好才行。</p><p>上一节课我们讲了，为什么这份代码只能得60分，这一节课我们再讲一下，如何将60分的代码重构为80分、90分，让它从“能用”变得“好用”。话不多说，让我们正式开始今天的学习吧！</p><h2>回顾代码和制定重构计划</h2><p>为了方便你查看和对比，我把上一节课中的代码拷贝到这里。</p><pre><code>public class IdGenerator {\n  private static final Logger logger = LoggerFactory.getLogger(IdGenerator.class);\n\n  public static String generate() {\n    String id = &quot;&quot;;\n    try {\n      String hostName = InetAddress.getLocalHost().getHostName();\n      String[] tokens = hostName.split(&quot;\\\\.&quot;);\n      if (tokens.length &gt; 0) {\n        hostName = tokens[tokens.length - 1];\n      }\n      char[] randomChars = new char[8];\n      int count = 0;\n      Random random = new Random();\n      while (count &lt; 8) {\n        int randomAscii = random.nextInt(122);\n        if (randomAscii &gt;= 48 &amp;&amp; randomAscii &lt;= 57) {\n          randomChars[count] = (char)('0' + (randomAscii - 48));\n          count++;\n        } else if (randomAscii &gt;= 65 &amp;&amp; randomAscii &lt;= 90) {\n          randomChars[count] = (char)('A' + (randomAscii - 65));\n          count++;\n        } else if (randomAscii &gt;= 97 &amp;&amp; randomAscii &lt;= 122) {\n          randomChars[count] = (char)('a' + (randomAscii - 97));\n          count++;\n        }\n      }\n      id = String.format(&quot;%s-%d-%s&quot;, hostName,\n              System.currentTimeMillis(), new String(randomChars));\n    } catch (UnknownHostException e) {\n      logger.warn(&quot;Failed to get the host name.&quot;, e);\n    }\n\n    return id;\n  }\n}\n</code></pre><p>前面讲到系统设计和实现的时候，我们多次讲到要循序渐进、小步快跑。重构代码的过程也应该遵循这样的思路。每次改动一点点，改好之后，再进行下一轮的优化，保证每次对代码的改动不会过大，能在很短的时间内完成。所以，我们将上一节课中发现的代码质量问题，分成四次重构来完成，具体如下所示。</p><ul>\n<li>第一轮重构：提高代码的可读性</li>\n<li>第二轮重构：提高代码的可测试性</li>\n<li>第三轮重构：编写完善的单元测试</li>\n<li>第四轮重构：所有重构完成之后添加注释</li>\n</ul><!-- [[[read_end]]] --><h2>第一轮重构：提高代码的可读性</h2><p>首先，我们要解决最明显、最急需改进的代码可读性问题。具体有下面几点：</p><ul>\n<li>hostName变量不应该被重复使用，尤其当这两次使用时的含义还不同的时候；</li>\n<li>将获取hostName的代码抽离出来，定义为getLastfieldOfHostName()函数；</li>\n<li>删除代码中的魔法数，比如，57、90、97、122；</li>\n<li>将随机数生成的代码抽离出来，定义为generateRandomAlphameric()函数；</li>\n<li>generate()函数中的三个if逻辑重复了，且实现过于复杂，我们要对其进行简化；</li>\n<li>对IdGenerator类重命名，并且抽象出对应的接口。</li>\n</ul><p>这里我们重点讨论下最后一个修改。实际上，对于ID生成器的代码，有下面三种类的命名方式。你觉得哪种更合适呢？</p><p><img src=\"https://static001.geekbang.org/resource/image/8f/6b/8f0de72351eeb9138c7a3b8199767a6b.jpg\" alt=\"\"></p><p>我们来逐一分析一下三种命名方式。</p><p>第一种命名方式，将接口命名为IdGenerator，实现类命名为LogTraceIdGenerator，这可能是很多人最先想到的命名方式了。在命名的时候，我们要考虑到，以后两个类会如何使用、会如何扩展。从使用和扩展的角度来分析，这样的命名就不合理了。</p><p>首先，如果我们扩展新的日志ID生成算法，也就是要创建另一个新的实现类，因为原来的实现类已经叫LogTraceIdGenerator了，命名过于通用，那新的实现类就不好取名了，无法取一个跟LogTraceIdGenerator平行的名字了。</p><p>其次，你可能会说，假设我们没有日志ID的扩展需求，但要扩展其他业务的ID生成算法，比如针对用户的（UserldGenerator）、订单的（OrderIdGenerator），第一种命名方式是不是就是合理的呢？答案也是否定的。基于接口而非实现编程，主要的目的是为了方便后续灵活地替换实现类。而LogTraceIdGenerator、UserIdGenerator、OrderIdGenerator三个类从命名上来看，涉及的是完全不同的业务，不存在互相替换的场景。也就是说，我们不可能在有关日志的代码中，进行下面这种替换。所以，让这三个类实现同一个接口，实际上是没有意义的。</p><pre><code>IdGenearator idGenerator = new LogTraceIdGenerator();\n替换为:\nIdGenearator idGenerator = new UserIdGenerator();\n</code></pre><p>第二种命名方式是不是就合理了呢？答案也是否定的。其中，LogTraceIdGenerator接口的命名是合理的，但是HostNameMillisIdGenerator实现类暴露了太多实现细节，只要代码稍微有所改动，就可能需要改动命名，才能匹配实现。</p><p>第三种命名方式是我比较推荐的。在目前的ID生成器代码实现中，我们生成的ID是一个随机ID，不是递增有序的，所以，命名成RandomIdGenerator是比较合理的，即便内部生成算法有所改动，只要生成的还是随机的ID，就不需要改动命名。如果我们需要扩展新的ID生成算法，比如要实现一个递增有序的ID生成算法，那我们可以命名为SequenceIdGenerator。</p><p>实际上，更好的一种命名方式是，我们抽象出两个接口，一个是IdGenerator，一个是LogTraceIdGenerator，LogTraceIdGenerator继承IdGenerator。实现类实现接口LogTraceIdGenerator，命名为RandomIdGenerator、SequenceIdGenerator等。这样，实现类可以复用到多个业务模块中，比如前面提到的用户、订单。</p><p>根据上面的优化策略，我们对代码进行第一轮的重构，重构之后的代码如下所示：</p><pre><code>public interface IdGenerator {\n  String generate();\n}\n\npublic interface LogTraceIdGenerator extends IdGenerator {\n}\n\npublic class RandomIdGenerator implements LogTraceIdGenerator {\n  private static final Logger logger = LoggerFactory.getLogger(RandomIdGenerator.class);\n\n  @Override\n  public String generate() {\n    String substrOfHostName = getLastfieldOfHostName();\n    long currentTimeMillis = System.currentTimeMillis();\n    String randomString = generateRandomAlphameric(8);\n    String id = String.format(&quot;%s-%d-%s&quot;,\n            substrOfHostName, currentTimeMillis, randomString);\n    return id;\n  }\n\n  private String getLastfieldOfHostName() {\n    String substrOfHostName = null;\n    try {\n      String hostName = InetAddress.getLocalHost().getHostName();\n      String[] tokens = hostName.split(&quot;\\\\.&quot;);\n      substrOfHostName = tokens[tokens.length - 1];\n      return substrOfHostName;\n    } catch (UnknownHostException e) {\n      logger.warn(&quot;Failed to get the host name.&quot;, e);\n    }\n    return substrOfHostName;\n  }\n\n  private String generateRandomAlphameric(int length) {\n    char[] randomChars = new char[length];\n    int count = 0;\n    Random random = new Random();\n    while (count &lt; length) {\n      int maxAscii = 'z';\n      int randomAscii = random.nextInt(maxAscii);\n      boolean isDigit= randomAscii &gt;= '0' &amp;&amp; randomAscii &lt;= '9';\n      boolean isUppercase= randomAscii &gt;= 'A' &amp;&amp; randomAscii &lt;= 'Z';\n      boolean isLowercase= randomAscii &gt;= 'a' &amp;&amp; randomAscii &lt;= 'z';\n      if (isDigit|| isUppercase || isLowercase) {\n        randomChars[count] = (char) (randomAscii);\n        ++count;\n      }\n    }\n    return new String(randomChars);\n  }\n}\n\n//代码使用举例\nLogTraceIdGenerator logTraceIdGenerator = new RandomIdGenerator();\n</code></pre><h2>第二轮重构：提高代码的可测试性</h2><p>关于代码可测试性的问题，主要包含下面两个方面：</p><ul>\n<li>generate()函数定义为静态函数，会影响使用该函数的代码的可测试性；</li>\n<li>generate()函数的代码实现依赖运行环境（本机名）、时间函数、随机函数，所以generate()函数本身的可测试性也不好。</li>\n</ul><p>对于第一点，我们已经在第一轮重构中解决了。我们将RandomIdGenerator类中的generate()静态函数重新定义成了普通函数。调用者可以通过依赖注入的方式，在外部创建好RandomIdGenerator对象后注入到自己的代码中，从而解决静态函数调用影响代码可测试性的问题。</p><p>对于第二点，我们需要在第一轮重构的基础之上再进行重构。重构之后的代码如下所示，主要包括以下几个代码改动。</p><ul>\n<li>从getLastfieldOfHostName()函数中，将逻辑比较复杂的那部分代码剥离出来，定义为getLastSubstrSplittedByDot()函数。因为getLastfieldOfHostName()函数依赖本地主机名，所以，剥离出主要代码之后这个函数变得非常简单，可以不用测试。我们重点测试getLastSubstrSplittedByDot()函数即可。</li>\n<li>将generateRandomAlphameric()和getLastSubstrSplittedByDot()这两个函数的访问权限设置为protected。这样做的目的是，可以直接在单元测试中通过对象来调用两个函数进行测试。</li>\n<li>给generateRandomAlphameric()和getLastSubstrSplittedByDot()两个函数添加Google Guava的annotation @VisibleForTesting。这个annotation没有任何实际的作用，只起到标识的作用，告诉其他人说，这两个函数本该是private访问权限的，之所以提升访问权限到protected，只是为了测试，只能用于单元测试中。</li>\n</ul><pre><code>public class RandomIdGenerator implements LogTraceIdGenerator {\n  private static final Logger logger = LoggerFactory.getLogger(RandomIdGenerator.class);\n\n  @Override\n  public String generate() {\n    String substrOfHostName = getLastfieldOfHostName();\n    long currentTimeMillis = System.currentTimeMillis();\n    String randomString = generateRandomAlphameric(8);\n    String id = String.format(&quot;%s-%d-%s&quot;,\n            substrOfHostName, currentTimeMillis, randomString);\n    return id;\n  }\n\n  private String getLastfieldOfHostName() {\n    String substrOfHostName = null;\n    try {\n      String hostName = InetAddress.getLocalHost().getHostName();\n      substrOfHostName = getLastSubstrSplittedByDot(hostName);\n    } catch (UnknownHostException e) {\n      logger.warn(&quot;Failed to get the host name.&quot;, e);\n    }\n    return substrOfHostName;\n  }\n\n  @VisibleForTesting\n  protected String getLastSubstrSplittedByDot(String hostName) {\n    String[] tokens = hostName.split(&quot;\\\\.&quot;);\n    String substrOfHostName = tokens[tokens.length - 1];\n    return substrOfHostName;\n  }\n\n  @VisibleForTesting\n  protected String generateRandomAlphameric(int length) {\n    char[] randomChars = new char[length];\n    int count = 0;\n    Random random = new Random();\n    while (count &lt; length) {\n      int maxAscii = 'z';\n      int randomAscii = random.nextInt(maxAscii);\n      boolean isDigit= randomAscii &gt;= '0' &amp;&amp; randomAscii &lt;= '9';\n      boolean isUppercase= randomAscii &gt;= 'A' &amp;&amp; randomAscii &lt;= 'Z';\n      boolean isLowercase= randomAscii &gt;= 'a' &amp;&amp; randomAscii &lt;= 'z';\n      if (isDigit|| isUppercase || isLowercase) {\n        randomChars[count] = (char) (randomAscii);\n        ++count;\n      }\n    }\n    return new String(randomChars);\n  }\n}\n</code></pre><p>在上一节课的课堂讨论中，我们提到，打印日志的Logger对象被定义为static final的，并且在类内部创建，这是否影响到代码的可测试性？是否应该将Logger对象通过依赖注入的方式注入到类中呢？</p><p>依赖注入之所以能提高代码可测试性，主要是因为，通过这样的方式我们能轻松地用mock对象替换依赖的真实对象。那我们为什么要mock这个对象呢？这是因为，这个对象参与逻辑执行（比如，我们要依赖它输出的数据做后续的计算）但又不可控。对于Logger对象来说，我们只往里写入数据，并不读取数据，不参与业务逻辑的执行，不会影响代码逻辑的正确性，所以，我们没有必要mock Logger对象。</p><p>除此之外，一些只是为了存储数据的值对象，比如String、Map、UseVo，我们也没必要通过依赖注入的方式来创建，直接在类中通过new创建就可以了。</p><h2>第三轮重构：编写完善的单元测试</h2><p>经过上面的重构之后，代码存在的比较明显的问题，基本上都已经解决了。我们现在为代码补全单元测试。RandomIdGenerator类中有4个函数。</p><pre><code>public String generate();\nprivate String getLastfieldOfHostName();\n@VisibleForTesting\nprotected String getLastSubstrSplittedByDot(String hostName);\n@VisibleForTesting\nprotected String generateRandomAlphameric(int length);\n</code></pre><p>我们先来看后两个函数。这两个函数包含的逻辑比较复杂，是我们测试的重点。而且，在上一步重构中，为了提高代码的可测试性，我们已经将这两个部分代码跟不可控的组件（本机名、随机函数、时间函数）进行了隔离。所以，我们只需要设计完备的单元测试用例即可。具体的代码实现如下所示（注意，我们使用了JUnit测试框架）：</p><pre><code>public class RandomIdGeneratorTest {\n  @Test\n  public void testGetLastSubstrSplittedByDot() {\n    RandomIdGenerator idGenerator = new RandomIdGenerator();\n    String actualSubstr = idGenerator.getLastSubstrSplittedByDot(&quot;field1.field2.field3&quot;);\n    Assert.assertEquals(&quot;field3&quot;, actualSubstr);\n\n    actualSubstr = idGenerator.getLastSubstrSplittedByDot(&quot;field1&quot;);\n    Assert.assertEquals(&quot;field1&quot;, actualSubstr);\n\n    actualSubstr = idGenerator.getLastSubstrSplittedByDot(&quot;field1#field2$field3&quot;);\n    Assert.assertEquals(&quot;field1#field2#field3&quot;, actualSubstr);\n  }\n\n  // 此单元测试会失败，因为我们在代码中没有处理hostName为null或空字符串的情况\n  // 这部分优化留在第36、37节课中讲解\n  @Test\n  public void testGetLastSubstrSplittedByDot_nullOrEmpty() {\n    RandomIdGenerator idGenerator = new RandomIdGenerator();\n    String actualSubstr = idGenerator.getLastSubstrSplittedByDot(null);\n    Assert.assertNull(actualSubstr);\n\n    actualSubstr = idGenerator.getLastSubstrSplittedByDot(&quot;&quot;);\n    Assert.assertEquals(&quot;&quot;, actualSubstr);\n  }\n\n  @Test\n  public void testGenerateRandomAlphameric() {\n    RandomIdGenerator idGenerator = new RandomIdGenerator();\n    String actualRandomString = idGenerator.generateRandomAlphameric(6);\n    Assert.assertNotNull(actualRandomString);\n    Assert.assertEquals(6, actualRandomString.length());\n    for (char c : actualRandomString.toCharArray()) {\n      Assert.assertTrue(('0' &lt; c &amp;&amp; c &lt; '9') || ('a' &lt; c &amp;&amp; c &lt; 'z') || ('A' &lt; c &amp;&amp; c &lt; 'Z'));\n    }\n  }\n\n  // 此单元测试会失败，因为我们在代码中没有处理length&lt;=0的情况\n  // 这部分优化留在第36、37节课中讲解\n  @Test\n  public void testGenerateRandomAlphameric_lengthEqualsOrLessThanZero() {\n    RandomIdGenerator idGenerator = new RandomIdGenerator();\n    String actualRandomString = idGenerator.generateRandomAlphameric(0);\n    Assert.assertEquals(&quot;&quot;, actualRandomString);\n\n    actualRandomString = idGenerator.generateRandomAlphameric(-1);\n    Assert.assertNull(actualRandomString);\n  }\n}\n</code></pre><p>我们再来看generate()函数。这个函数也是我们唯一一个暴露给外部使用的public函数。虽然逻辑比较简单，最好还是测试一下。但是，它依赖主机名、随机函数、时间函数，我们该如何测试呢？需要mock这些函数的实现吗？</p><p>实际上，这要分情况来看。我们前面讲过，写单元测试的时候，测试对象是函数定义的功能，而非具体的实现逻辑。这样我们才能做到，函数的实现逻辑改变了之后，单元测试用例仍然可以工作。那generate()函数实现的功能是什么呢？这完全是由代码编写者自己来定义的。</p><p>比如，针对同一份generate()函数的代码实现，我们可以有3种不同的功能定义，对应3种不同的单元测试。</p><ol>\n<li>如果我们把generate()函数的功能定义为：“生成一个随机唯一ID”，那我们只要测试多次调用generate()函数生成的ID是否唯一即可。</li>\n<li>如果我们把generate()函数的功能定义为：“生成一个只包含数字、大小写字母和中划线的唯一ID”，那我们不仅要测试ID的唯一性，还要测试生成的ID是否只包含数字、大小写字母和中划线。</li>\n<li>如果我们把generate()函数的功能定义为：“生成唯一ID，格式为：{主机名substr}-{时间戳}-{8位随机数}。在主机名获取失败时，返回：null-{时间戳}-{8位随机数}”，那我们不仅要测试ID的唯一性，还要测试生成的ID是否完全符合格式要求。</li>\n</ol><p><strong>总结一下，单元测试用例如何写，关键看你如何定义函数。</strong>针对generate()函数的前两种定义，我们不需要mock获取主机名函数、随机函数、时间函数等，但对于第3种定义，我们需要mock获取主机名函数，让其返回null，测试代码运行是否符合预期。</p><p>最后，我们来看下getLastfieldOfHostName()函数。实际上，这个函数不容易测试，因为它调用了一个静态函数（InetAddress.getLocalHost().getHostName();），并且这个静态函数依赖运行环境。但是，这个函数的实现非常简单，肉眼基本上可以排除明显的bug，所以我们可以不为其编写单元测试代码。毕竟，我们写单元测试的目的是为了减少代码bug，而不是为了写单元测试而写单元测试。</p><p>当然，如果你真的想要对它进行测试，我们也是有办法的。一种办法是使用更加高级的测试框架。比如PowerMock，它可以mock静态函数。另一种方式是将获取本机名的逻辑再封装为一个新的函数。不过，后一种方法会造成代码过度零碎，也会稍微影响到代码的可读性，这个需要你自己去权衡利弊来做选择。</p><h2>第四轮重构：添加注释</h2><p>前面我们提到，注释不能太多，也不能太少，主要添加在类和函数上。有人说，好的命名可以替代注释，清晰的表达含义。这点对于变量的命名来说是适用的，但对于类或函数来说就不一定对了。类或函数包含的逻辑往往比较复杂，单纯靠命名很难清晰地表明实现了什么功能，这个时候我们就需要通过注释来补充。比如，前面我们提到的对于generate()函数的3种功能定义，就无法用命名来体现，需要补充到注释里面。</p><p>对于如何写注释，你可以参看我们在<a href=\"https://time.geekbang.org/column/article/188622\">第31节课</a>中的讲解。总结一下，主要就是写清楚：做什么、为什么、怎么做、怎么用，对一些边界条件、特殊情况进行说明，以及对函数输入、输出、异常进行说明。</p><pre><code>/**\n * Id Generator that is used to generate random IDs.\n *\n * &lt;p&gt;\n * The IDs generated by this class are not absolutely unique,\n * but the probability of duplication is very low.\n */\npublic class RandomIdGenerator implements LogTraceIdGenerator {\n  private static final Logger logger = LoggerFactory.getLogger(RandomIdGenerator.class);\n\n  /**\n   * Generate the random ID. The IDs may be duplicated only in extreme situation.\n   *\n   * @return an random ID\n   */\n  @Override\n  public String generate() {\n    //...\n  }\n\n  /**\n   * Get the local hostname and\n   * extract the last field of the name string splitted by delimiter '.'.\n   *\n   * @return the last field of hostname. Returns null if hostname is not obtained.\n   */\n  private String getLastfieldOfHostName() {\n    //...\n  }\n\n  /**\n   * Get the last field of {@hostName} splitted by delemiter '.'.\n   *\n   * @param hostName should not be null\n   * @return the last field of {@hostName}. Returns empty string if {@hostName} is empty string.\n   */\n  @VisibleForTesting\n  protected String getLastSubstrSplittedByDot(String hostName) {\n    //...\n  }\n\n  /**\n   * Generate random string which\n   * only contains digits, uppercase letters and lowercase letters.\n   *\n   * @param length should not be less than 0\n   * @return the random string. Returns empty string if {@length} is 0\n   */\n  @VisibleForTesting\n  protected String generateRandomAlphameric(int length) {\n    //...\n  }\n}\n</code></pre><h2>重点回顾</h2><p>好了，今天的内容到此就讲完了。我们一块来总结回顾一下，你需要掌握的重点内容。</p><p>在这节课中，我带你将小王写的凑活能用的代码，重构成了结构更加清晰、更加易读、更易测试的代码，并且为其补全了单元测试。这其中涉及的知识点都是我们在理论篇中讲过的内容，比较细节和零碎，我就不一一带你回顾了，如果哪里不是很清楚，你可以回到前面章节去复习一下。</p><p>实际上，通过这节课，我更想传达给你的是下面这样几个开发思想，我觉得这比我给你讲解具体的知识点更加有意义。</p><ol>\n<li>即便是非常简单的需求，不同水平的人写出来的代码，差别可能会很大。我们要对代码质量有所追求，不能只是凑活能用就好。花点心思写一段高质量的代码，比写100段凑活能用的代码，对你的代码能力提高更有帮助。</li>\n<li>知其然知其所以然，了解优秀代码设计的演变过程，比学习优秀设计本身更有价值。知道为什么这么做，比单纯地知道怎么做更重要，这样可以避免你过度使用设计模式、思想和原则。</li>\n<li>设计思想、原则、模式本身并没有太多“高大上”的东西，都是一些简单的道理，而且知识点也并不多，关键还是锻炼具体代码具体分析的能力，把知识点恰当地用在项目中。</li>\n<li>我经常讲，高手之间的竞争都是在细节。大的架构设计、分层、分模块思路实际上都差不多。没有项目是靠一些不为人知的设计来取胜的，即便有，很快也能被学习过去。所以，关键还是看代码细节处理得够不够好。这些细节的差别累积起来，会让代码质量有质的差别。所以，要想提高代码质量，还是要在细节处下功夫。</li>\n</ol><h2>课堂讨论</h2><ol>\n<li>获取主机名失败的时候，generate()函数应该返回什么最合适呢？是特殊ID、null、空字符，还是异常？在小王的代码实现中，获取主机名失败异常在IdGenerator内部被吞掉了，打印一条报警日志，并没有继续往上抛出，这样的异常处理是否得当？</li>\n<li>为了隐藏代码实现细节，我们把getLastSubstrSplittedByDot(String hostName)函数命名替换成getLastSubstrByDelimiter(String hostName)，这样是否更加合理？为什么？</li>\n</ol><p>欢迎在留言区写下你的答案，和同学一起交流和分享。如果有收获，也欢迎你把这篇文章分享给你的朋友。</p>",
                "article_title": "35 | 实战一（下）：手把手带你将ID生成器代码从“能用”重构为“好用”"
            },
            {
                "title": "36 | 实战二（上）：程序出错该返回啥？NULL、异常、错误码、空对象？",
                "herf": "https://time.geekbang.org/column/article/191642",
                "id": "191642",
                "content": "<p>我们可以把函数的运行结果分为两类。一类是预期的结果，也就是函数在正常情况下输出的结果。一类是非预期的结果，也就是函数在异常（或叫出错）情况下输出的结果。比如，在上一节课中，获取本机名的函数，在正常情况下，函数返回字符串格式的本机名；在异常情况下，获取本机名失败，函数返回UnknownHostException异常对象。</p><p>在正常情况下，函数返回数据的类型非常明确，但是，在异常情况下，函数返回的数据类型却非常灵活，有多种选择。除了刚刚提到的类似UnknownHostException这样的异常对象之外，函数在异常情况下还可以返回错误码、NULL值、特殊值（比如-1）、空对象（比如空字符串、空集合）等。</p><p>每一种异常返回数据类型，都有各自的特点和适用场景。但有的时候，在异常情况下，函数到底该返回什么样的数据类型，并不那么容易判断。比如，上节课中，在本机名获取失败的时候，ID生成器的generate()函数应该返回什么呢？是异常？空字符？还是NULL值？又或者是其他特殊值（比如null-15293834874-fd3A9KBn，null表示本机名未获取到）呢？</p><p>函数是代码的一个非常重要的编写单元，而函数的异常处理，又是我们在编写函数的时候，时刻都要考虑的。所以，今天我们就聊一聊，如何设计函数在异常情况下的返回数据类型。</p><!-- [[[read_end]]] --><p>话不多说，让我们正式开始今天的学习吧！</p><h2>从上节课的ID生成器代码讲起</h2><p>上两节课中，我们把一份非常简单的ID生成器的代码，从“能用”重构成了“好用”。最终给出的代码看似已经很完美了，但是如果我们再用心推敲一下，代码中关于出错处理的方式，还有进一步优化的空间，值得我们拿出来再讨论一下。</p><p>为了方便你查看，我将上节课的代码拷贝到了这里。</p><pre><code>public class RandomIdGenerator implements IdGenerator {\n  private static final Logger logger = LoggerFactory.getLogger(RandomIdGenerator.class);\n\n  @Override\n  public String generate() {\n    String substrOfHostName = getLastFiledOfHostName();\n    long currentTimeMillis = System.currentTimeMillis();\n    String randomString = generateRandomAlphameric(8);\n    String id = String.format(&quot;%s-%d-%s&quot;,\n            substrOfHostName, currentTimeMillis, randomString);\n    return id;\n  }\n\n  private String getLastFiledOfHostName() {\n    String substrOfHostName = null;\n    try {\n      String hostName = InetAddress.getLocalHost().getHostName();\n      substrOfHostName = getLastSubstrSplittedByDot(hostName);\n    } catch (UnknownHostException e) {\n      logger.warn(&quot;Failed to get the host name.&quot;, e);\n    }\n    return substrOfHostName;\n  }\n\n  @VisibleForTesting\n  protected String getLastSubstrSplittedByDot(String hostName) {\n    String[] tokens = hostName.split(&quot;\\\\.&quot;);\n    String substrOfHostName = tokens[tokens.length - 1];\n    return substrOfHostName;\n  }\n\n  @VisibleForTesting\n  protected String generateRandomAlphameric(int length) {\n    char[] randomChars = new char[length];\n    int count = 0;\n    Random random = new Random();\n    while (count &lt; length) {\n      int maxAscii = 'z';\n      int randomAscii = random.nextInt(maxAscii);\n      boolean isDigit= randomAscii &gt;= '0' &amp;&amp; randomAscii &lt;= '9';\n      boolean isUppercase= randomAscii &gt;= 'A' &amp;&amp; randomAscii &lt;= 'Z';\n      boolean isLowercase= randomAscii &gt;= 'a' &amp;&amp; randomAscii &lt;= 'z';\n      if (isDigit|| isUppercase || isLowercase) {\n        randomChars[count] = (char) (randomAscii);\n        ++count;\n      }\n    }\n    return new String(randomChars);\n  }\n}\n</code></pre><p>这段代码中有四个函数。针对这四个函数的出错处理方式，我总结出下面这样几个问题。</p><ul>\n<li>对于generate()函数，如果本机名获取失败，函数返回什么？这样的返回值是否合理？</li>\n<li>对于getLastFiledOfHostName()函数，是否应该将UnknownHostException异常在函数内部吞掉（try-catch并打印日志）？还是应该将异常继续往上抛出？如果往上抛出的话，是直接把UnknownHostException异常原封不动地抛出，还是封装成新的异常抛出？</li>\n<li>对于getLastSubstrSplittedByDot(String hostName)函数，如果hostName为NULL或者是空字符串，这个函数应该返回什么？</li>\n<li>对于generateRandomAlphameric(int length)函数，如果length小于0或者等于0，这个函数应该返回什么？</li>\n</ul><p>对于上面这几个问题，你可以试着思考下，我先不做解答。等我们学完本节课的理论内容之后，我们下一节课再一块来分析。这一节我们重点讲解一些理论方面的知识。</p><h2>函数出错应该返回啥？</h2><p>关于函数出错返回数据类型，我总结了4种情况，它们分别是：错误码、NULL值、空对象、异常对象。接下来，我们就一一来看它们的用法以及适用场景。</p><h3>1.返回错误码</h3><p>C语言中没有异常这样的语法机制，因此，返回错误码便是最常用的出错处理方式。而在Java、Python等比较新的编程语言中，大部分情况下，我们都用异常来处理函数出错的情况，极少会用到错误码。</p><p>在C语言中，错误码的返回方式有两种：一种是直接占用函数的返回值，函数正常执行的返回值放到出参中；另一种是将错误码定义为全局变量，在函数执行出错时，函数调用者通过这个全局变量来获取错误码。针对这两种方式，我举个例子来进一步解释。具体代码如下所示：</p><pre><code>// 错误码的返回方式一：pathname/flags/mode为入参；fd为出参，存储打开的文件句柄。\nint open(const char *pathname, int flags, mode_t mode, int* fd) {\n  if (/*文件不存在*/) {\n    return EEXIST;\n  }\n  \n  if (/*没有访问权限*/) {\n    return EACCESS;\n  }\n  \n  if (/*打开文件成功*/) {\n    return SUCCESS; // C语言中的宏定义：#define SUCCESS 0\n  }\n  // ...\n}\n//使用举例\nint fd;\nint result = open(“c:\\test.txt”, O_RDWR, S_IRWXU|S_IRWXG|S_IRWXO, &amp;fd);\nif (result == SUCCESS) {\n  // 取出fd使用\n} else if (result == EEXIST) {\n  //...\n} else if (result == EACESS) {\n  //...\n}\n\n// 错误码的返回方式二：函数返回打开的文件句柄，错误码放到errno中。\nint errno; // 线程安全的全局变量\nint open(const char *pathname, int flags, mode_t mode）{\n  if (/*文件不存在*/) {\n    errno = EEXIST;\n    return -1;\n  }\n  \n  if (/*没有访问权限*/) {\n    errno = EACCESS;\n    return -1;\n  }\n  \n  // ...\n}\n// 使用举例\nint hFile = open(“c:\\test.txt”, O_RDWR, S_IRWXU|S_IRWXG|S_IRWXO);\nif (-1 == hFile) {\n  printf(&quot;Failed to open file, error no: %d.\\n&quot;, errno);\n  if (errno == EEXIST ) {\n    // ...        \n  } else if(errno == EACCESS) {\n    // ...    \n  }\n  // ...\n}\n</code></pre><p>实际上，如果你熟悉的编程语言中有异常这种语法机制，那就尽量不要使用错误码。异常相对于错误码，有诸多方面的优势，比如可以携带更多的错误信息（exception中可以有message、stack trace等信息）等。关于异常，我们待会还会非常详细地讲解。</p><h3>2.返回NULL值</h3><p>在多数编程语言中，我们用NULL来表示“不存在”这种语义。不过，网上很多人不建议函数返回NULL值，认为这是一种不好的设计思路，主要的理由有以下两个。</p><ul>\n<li>如果某个函数有可能返回NULL值，我们在使用它的时候，忘记了做NULL值判断，就有可能会抛出<strong>空指针异常</strong>（Null Pointer Exception，缩写为NPE）。</li>\n<li>如果我们定义了很多返回值可能为NULL的函数，那代码中就会充斥着大量的NULL值判断逻辑，一方面写起来比较繁琐，另一方面它们跟正常的业务逻辑耦合在一起，会影响代码的可读性。</li>\n</ul><p>我举个例子解释一下，具体代码如下所示：</p><pre><code>public class UserService {\n  private UserRepo userRepo; // 依赖注入\n  \n  public User getUser(String telephone) {\n    // 如果用户不存在，则返回null\n    return null;\n  }\n}\n\n// 使用函数getUser()\nUser user = userService.getUser(&quot;18917718965&quot;);\nif (user != null) { // 做NULL值判断，否则有可能会报NPE\n  String email = user.getEmail();\n  if (email != null) { // 做NULL值判断，否则有可能会报NPE\n    String escapedEmail = email.replaceAll(&quot;@&quot;, &quot;#&quot;);\n  }\n}\n</code></pre><p>那我们是否可以用异常来替代NULL值，在查找用户不存在的时候，让函数抛出UserNotFoundException异常呢？</p><p>我个人觉得，尽管返回NULL值有诸多弊端，但对于以get、find、select、search、query等单词开头的查找函数来说，数据不存在，并非一种异常情况，这是一种正常行为。所以，返回代表不存在语义的NULL值比返回异常更加合理。</p><p>不过，话说回来，刚刚讲的这个理由，也并不是特别有说服力。对于查找数据不存在的情况，函数到底是该用NULL值还是异常，有一个比较重要的参考标准是，看项目中的其他类似查找函数都是如何定义的，只要整个项目遵从统一的约定即可。如果项目从零开始开发，并没有统一约定和可以参考的代码，那你选择两者中的任何一种都可以。你只需要在函数定义的地方注释清楚，让调用者清晰地知道数据不存在的时候会返回什么就可以了。</p><p>再补充说明一点，对于查找函数来说，除了返回数据对象之外，有的还会返回下标位置，比如Java中的indexOf()函数，用来实现在某个字符串中查找另一个子串第一次出现的位置。函数的返回值类型为基本类型int。这个时候，我们就无法用NULL值来表示不存在的情况了。对于这种情况，我们有两种处理思路，一种是返回NotFoundException，一种是返回一个特殊值，比如-1。不过，显然-1更加合理，理由也是同样的，也就是说“没有查找到”是一种正常而非异常的行为。</p><h3>3.返回空对象</h3><p>刚刚我们讲到，返回NULL值有各种弊端。应对这个问题有一个比较经典的策略，那就是应用空对象设计模式（Null Object Design Pattern）。关于这个设计模式，我们在后面章节会详细讲，现在就不展开来讲解了。不过，我们今天来讲两种比较简单、比较特殊的空对象，那就是<strong>空字符串</strong>和<strong>空集合</strong>。</p><p>当函数返回的数据是字符串类型或者集合类型的时候，我们可以用空字符串或空集合替代NULL值，来表示不存在的情况。这样，我们在使用函数的时候，就可以不用做NULL值判断。我举个例子来解释下。具体代码如下所示：</p><pre><code>// 使用空集合替代NULL\npublic class UserService {\n  private UserRepo userRepo; // 依赖注入\n  \n  public List&lt;User&gt; getUsers(String telephonePrefix) {\n   // 没有查找到数据\n    return Collections.emptyList();\n  }\n}\n// getUsers使用示例\nList&lt;User&gt; users = userService.getUsers(&quot;189&quot;);\nfor (User user : users) { //这里不需要做NULL值判断\n  // ...\n}\n\n// 使用空字符串替代NULL\npublic String retrieveUppercaseLetters(String text) {\n  // 如果text中没有大写字母，返回空字符串，而非NULL值\n  return &quot;&quot;;\n}\n// retrieveUppercaseLetters()使用举例\nString uppercaseLetters = retrieveUppercaseLetters(&quot;wangzheng&quot;);\nint length = uppercaseLetters.length();// 不需要做NULL值判断 \nSystem.out.println(&quot;Contains &quot; + length + &quot; upper case letters.&quot;);\n</code></pre><h3>4.抛出异常对象</h3><p>尽管前面讲了很多函数出错的返回数据类型，但是，最常用的函数出错处理方式就是抛出异常。异常可以携带更多的错误信息，比如函数调用栈信息。除此之外，异常可以将正常逻辑和异常逻辑的处理分离开来，这样代码的可读性就会更好。</p><p>不同的编程语言的异常语法稍有不同。像C++和大部分的动态语言（Python、Ruby、JavaScript等）都只定义了一种异常类型：运行时异常（Runtime Exception）。而像Java，除了运行时异常外，还定义了另外一种异常类型：编译时异常（Compile Exception）。</p><p>对于运行时异常，我们在编写代码的时候，可以不用主动去try-catch，编译器在编译代码的时候，并不会检查代码是否有对运行时异常做了处理。相反，对于编译时异常，我们在编写代码的时候，需要主动去try-catch或者在函数定义中声明，否则编译就会报错。所以，运行时异常也叫作非受检异常（Unchecked Exception），编译时异常也叫作受检异常（Checked Exception）。</p><p>如果你熟悉的编程语言中，只定义了一种异常类型，那用起来反倒比较简单。如果你熟悉的编程语言中（比如Java），定义了两种异常类型，那在异常出现的时候，我们应该选择抛出哪种异常类型呢？是受检异常还是非受检异常？</p><p>对于代码bug（比如数组越界）以及不可恢复异常（比如数据库连接失败），即便我们捕获了，也做不了太多事情，所以，我们倾向于使用非受检异常。对于可恢复异常、业务异常，比如提现金额大于余额的异常，我们更倾向于使用受检异常，明确告知调用者需要捕获处理。</p><p>我举一个例子解释一下，代码如下所示。当Redis的地址（参数address）没有设置的时候，我们直接使用默认的地址（比如本地地址和默认端口）；当Redis的地址格式不正确的时候，我们希望程序能fail-fast，也就是说，把这种情况当成不可恢复的异常，直接抛出运行时异常，将程序终止掉。</p><pre><code>// address格式：&quot;192.131.2.33:7896&quot;\npublic void parseRedisAddress(String address) {\n  this.host = RedisConfig.DEFAULT_HOST;\n  this.port = RedisConfig.DEFAULT_PORT;\n  \n  if (StringUtils.isBlank(address)) {\n    return;\n  }\n\n  String[] ipAndPort = address.split(&quot;:&quot;);\n  if (ipAndPort.length != 2) {\n    throw new RuntimeException(&quot;...&quot;);\n  }\n  \n  this.host = ipAndPort[0];\n  // parseInt()解析失败会抛出NumberFormatException运行时异常\n  this.port = Integer.parseInt(ipAndPort[1]);\n}\n</code></pre><p>实际上，Java支持的受检异常一直被人诟病，很多人主张所有的异常情况都应该使用非受检异常。支持这种观点的理由主要有以下三个。</p><ul>\n<li>受检异常需要显式地在函数定义中声明。如果函数会抛出很多受检异常，那函数的定义就会非常冗长，这就会影响代码的可读性，使用起来也不方便。</li>\n<li>编译器强制我们必须显示地捕获所有的受检异常，代码实现会比较繁琐。而非受检异常正好相反，我们不需要在定义中显示声明，并且是否需要捕获处理，也可以自由决定。</li>\n<li>受检异常的使用违反开闭原则。如果我们给某个函数新增一个受检异常，这个函数所在的函数调用链上的所有位于其之上的函数都需要做相应的代码修改，直到调用链中的某个函数将这个新增的异常try-catch处理掉为止。而新增非受检异常可以不改动调用链上的代码。我们可以灵活地选择在某个函数中集中处理，比如在Spring中的AOP切面中集中处理异常。</li>\n</ul><p>不过，非受检异常也有弊端，它的优点其实也正是它的缺点。从刚刚的表述中，我们可以看出，非受检异常使用起来更加灵活，怎么处理的主动权这里就交给了程序员。我们前面也讲到，过于灵活会带来不可控，非受检异常不需要显式地在函数定义中声明，那我们在使用函数的时候，就需要查看代码才能知道具体会抛出哪些异常。非受检异常不需要强制捕获处理，那程序员就有可能漏掉一些本应该捕获处理的异常。</p><p>对于应该用受检异常还是非受检异常，网上的争论有很多，但并没有一个非常强有力的理由能够说明一个就一定比另一个更好。所以，我们只需要根据团队的开发习惯，在同一个项目中，制定统一的异常处理规范即可。</p><p><strong>刚刚我们讲了两种异常类型，现在我们再来讲下，如何处理函数抛出的异常？</strong>总结一下，一般有下面三种处理方法。</p><ul>\n<li>直接吞掉。具体的代码示例如下所示：</li>\n</ul><pre><code>public void func1() throws Exception1 {\n  // ...\n}\n\npublic void func2() {\n  //...\n  try {\n    func1();\n  } catch(Exception1 e) {\n    log.warn(&quot;...&quot;, e); //吐掉：try-catch打印日志\n  }\n  //...\n}\n</code></pre><ul>\n<li>原封不动地re-throw。具体的代码示例如下所示：</li>\n</ul><pre><code>public void func1() throws Exception1 {\n  // ...\n}\n\n\npublic void func2() throws Exception1 {//原封不动的re-throw Exception1\n  //...\n  func1();\n  //...\n}\n</code></pre><ul>\n<li>包装成新的异常re-throw。具体的代码示例如下所示：</li>\n</ul><pre><code>public void func1() throws Exception1 {\n  // ...\n}\n\n\npublic void func2() throws Exception2 {\n  //...\n  try {\n    func1();\n  } catch(Exception1 e) {\n   throw new Exception2(&quot;...&quot;, e); // wrap成新的Exception2然后re-throw\n  }\n  //...\n}\n</code></pre><p>当我们面对函数抛出异常的时候，应该选择上面的哪种处理方式呢？我总结了下面三个参考原则：</p><ul>\n<li>如果func1()抛出的异常是可以恢复，且func2()的调用方并不关心此异常，我们完全可以在func2()内将func1()抛出的异常吞掉；</li>\n<li>如果func1()抛出的异常对func2()的调用方来说，也是可以理解的、关心的 ，并且在业务概念上有一定的相关性，我们可以选择直接将func1抛出的异常re-throw；</li>\n<li>如果func1()抛出的异常太底层，对func2()的调用方来说，缺乏背景去理解、且业务概念上无关，我们可以将它重新包装成调用方可以理解的新异常，然后re-throw。</li>\n</ul><p>总之，是否往上继续抛出，要看上层代码是否关心这个异常。关心就将它抛出，否则就直接吞掉。是否需要包装成新的异常抛出，看上层代码是否能理解这个异常、是否业务相关。如果能理解、业务相关就可以直接抛出，否则就封装成新的异常抛出。关于这部分理论知识，我们在下一节课中，会结合ID生成器的代码来进一步讲解。</p><h2>重点回顾</h2><p>好了，今天的内容到此就讲完了。我们一块来总结回顾一下，你需要掌握的重点内容。</p><p>对于函数出错返回数据类型，我总结了4种情况，它们分别是：错误码、NULL值、空对象、异常对象。</p><p><strong>1.返回错误码</strong></p><p>C语言没有异常这样的语法机制，返回错误码便是最常用的出错处理方式。而Java、Python等比较新的编程语言中，大部分情况下，我们都用异常来处理函数出错的情况，极少会用到错误码。</p><p><strong>2.返回NULL值</strong></p><p>在多数编程语言中，我们用NULL来表示“不存在”这种语义。对于查找函数来说，数据不存在并非一种异常情况，是一种正常行为，所以返回表示不存在语义的NULL值比返回异常更加合理。</p><p><strong>3.返回空对象</strong></p><p>返回NULL值有各种弊端，对此有一个比较经典的应对策略，那就是应用空对象设计模式。当函数返回的数据是字符串类型或者集合类型的时候，我们可以用空字符串或空集合替代NULL值，来表示不存在的情况。这样，我们在使用函数的时候，就可以不用做NULL值判断。</p><p><strong>4.抛出异常对象</strong></p><p>尽管前面讲了很多函数出错的返回数据类型，但是，最常用的函数出错处理方式是抛出异常。异常有两种类型：受检异常和非受检异常。</p><p>对于应该用受检异常还是非受检异常，网上的争论有很多，但也并没有一个非常强有力的理由，说明一个就一定比另一个更好。所以，我们只需要根据团队的开发习惯，在同一个项目中，制定统一的异常处理规范即可。</p><p>对于函数抛出的异常，我们有三种处理方法：直接吞掉、直接往上抛出、包裹成新的异常抛出。这一部分我们留在下一节课中结合实战进一步讲解。</p><h2>课堂讨论</h2><p>结合我们今天学的理论知识，试着回答一下在文章开头针对RandomIdGenerator提到的四个问题。</p><p>欢迎在留言区写下你的答案，和同学一起交流和分享。如果有收获，也欢迎你把这篇文章分享给你的朋友。</p>",
                "article_title": "36 | 实战二（上）：程序出错该返回啥？NULL、异常、错误码、空对象？"
            },
            {
                "title": "37 | 实战二（下）：重构ID生成器项目中各函数的异常处理代码",
                "herf": "https://time.geekbang.org/column/article/191647",
                "id": "191647",
                "content": "<p>平时进行软件设计开发的时候，我们除了要保证正常情况下的逻辑运行正确之外，还需要编写大量额外的代码，来处理有可能出现的异常情况，以保证代码在任何情况下，都在我们的掌控之内，不会出现非预期的运行结果。程序的bug往往都出现在一些边界条件和异常情况下，所以说，异常处理得好坏直接影响了代码的健壮性。全面、合理地处理各种异常能有效减少代码bug，也是保证代码质量的一个重要手段。</p><p>在上一节课中，我们讲解了几种异常情况的处理方式，比如返回错误码、NULL值、空对象、异常对象。针对最常用的异常对象，我们还重点讲解了两种异常类型的应用场景，以及针对函数抛出的异常的三种处理方式：直接吞掉、原封不动地抛出和包裹成新的异常抛出。</p><p>除此之外，在上一节课的开头，我们还针对ID生成器的代码，提出了4个有关异常处理的问题。今天，我们就用一节课的时间，结合上一节课讲到的理论知识，来逐一解答一下这几个问题。</p><p>话不多说，让我们正式开始今天的内容吧！</p><h2>重构generate()函数</h2><p>首先，我们来看，对于generate()函数，如果本机名获取失败，函数返回什么？这样的返回值是否合理？</p><pre><code>  public String generate() {\n    String substrOfHostName = getLastFieldOfHostName();\n    long currentTimeMillis = System.currentTimeMillis();\n    String randomString = generateRandomAlphameric(8);\n    String id = String.format(&quot;%s-%d-%s&quot;,\n            substrOfHostName, currentTimeMillis, randomString);\n    return id;\n  }\n</code></pre><p>ID由三部分构成：本机名、时间戳和随机数。时间戳和随机数的生成函数不会出错，唯独主机名有可能获取失败。在目前的代码实现中，如果主机名获取失败，substrOfHostName为NULL，那generate()函数会返回类似“null-16723733647-83Ab3uK6”这样的数据。如果主机名获取失败，substrOfHostName为空字符串，那generate()函数会返回类似“-16723733647-83Ab3uK6”这样的数据。</p><!-- [[[read_end]]] --><p>在异常情况下，返回上面两种特殊的ID数据格式，这样的做法是否合理呢？这个其实很难讲，我们要看具体的业务是怎么设计的。不过，我更倾向于明确地将异常告知调用者。所以，这里最好是抛出受检异常，而非特殊值。</p><p>按照这个设计思路，我们对generate()函数进行重构。重构之后的代码如下所示：</p><pre><code>  public String generate() throws IdGenerationFailureException {\n    String substrOfHostName = getLastFieldOfHostName();\n    if (substrOfHostName == null || substrOfHostName.isEmpty()) {\n      throw new IdGenerationFailureException(&quot;host name is empty.&quot;);\n    }\n    long currentTimeMillis = System.currentTimeMillis();\n    String randomString = generateRandomAlphameric(8);\n    String id = String.format(&quot;%s-%d-%s&quot;,\n            substrOfHostName, currentTimeMillis, randomString);\n    return id;\n  }\n</code></pre><h2>重构getLastFieldOfHostName()函数</h2><p>对于getLastFieldOfHostName()函数，是否应该将UnknownHostException异常在函数内部吞掉（try-catch并打印日志），还是应该将异常继续往上抛出？如果往上抛出的话，是直接把UnknownHostException异常原封不动地抛出，还是封装成新的异常抛出？</p><pre><code>  private String getLastFieldOfHostName() {\n    String substrOfHostName = null;\n    try {\n      String hostName = InetAddress.getLocalHost().getHostName();\n      substrOfHostName = getLastSubstrSplittedByDot(hostName);\n    } catch (UnknownHostException e) {\n      logger.warn(&quot;Failed to get the host name.&quot;, e);\n    }\n    return substrOfHostName;\n }\n</code></pre><p>现在的处理方式是当主机名获取失败的时候，getLastFieldOfHostName()函数返回NULL值。我们前面讲过，是返回NULL值还是异常对象，要看获取不到数据是正常行为，还是异常行为。获取主机名失败会影响后续逻辑的处理，并不是我们期望的，所以，它是一种异常行为。这里最好是抛出异常，而非返回NULL值。</p><p>至于是直接将UnknownHostException抛出，还是重新封装成新的异常抛出，要看函数跟异常是否有业务相关性。getLastFieldOfHostName()函数用来获取主机名的最后一个字段，UnknownHostException异常表示主机名获取失败，两者算是业务相关，所以可以直接将UnknownHostException抛出，不需要重新包裹成新的异常。</p><p>按照上面的设计思路，我们对getLastFieldOfHostName()函数进行重构。重构后的代码如下所示：</p><pre><code> private String getLastFieldOfHostName() throws UnknownHostException{\n    String substrOfHostName = null;\n    String hostName = InetAddress.getLocalHost().getHostName();\n    substrOfHostName = getLastSubstrSplittedByDot(hostName);\n    return substrOfHostName;\n }\n</code></pre><p>getLastFieldOfHostName()函数修改之后，generate()函数也要做相应的修改。我们需要在generate()函数中，捕获getLastFieldOfHostName()抛出的UnknownHostException异常。当我们捕获到这个异常之后，应该怎么处理呢？</p><p>按照之前的分析，ID生成失败的时候，我们需要明确地告知调用者。所以，我们不能在generate()函数中，将UnknownHostException这个异常吞掉。那我们应该原封不动地抛出，还是封装成新的异常抛出呢？</p><p>我们选择后者。在generate()函数中，我们需要捕获UnknownHostException异常，并重新包裹成新的异常IdGenerationFailureException往上抛出。之所以这么做，有下面三个原因。</p><ul>\n<li>调用者在使用generate()函数的时候，只需要知道它生成的是随机唯一ID，并不关心ID是如何生成的。也就说是，这是依赖抽象而非实现编程。如果generate()函数直接抛出UnknownHostException异常，实际上是暴露了实现细节。</li>\n<li>从代码封装的角度来讲，我们不希望将UnknownHostException这个比较底层的异常，暴露给更上层的代码，也就是调用generate()函数的代码。而且，调用者拿到这个异常的时候，并不能理解这个异常到底代表了什么，也不知道该如何处理。</li>\n<li>UnknownHostException异常跟generate()函数，在业务概念上没有相关性。</li>\n</ul><p>按照上面的设计思路，我们对generate()的函数再次进行重构。重构后的代码如下所示：</p><pre><code>  public String generate() throws IdGenerationFailureException {\n    String substrOfHostName = null;\n    try {\n      substrOfHostName = getLastFieldOfHostName();\n    } catch (UnknownHostException e) {\n      throw new IdGenerationFailureException(&quot;host name is empty.&quot;);\n    }\n    long currentTimeMillis = System.currentTimeMillis();\n    String randomString = generateRandomAlphameric(8);\n    String id = String.format(&quot;%s-%d-%s&quot;,\n            substrOfHostName, currentTimeMillis, randomString);\n    return id;\n  }\n</code></pre><h2>重构getLastSubstrSplittedByDot()函数</h2><p>对于getLastSubstrSplittedByDot(String hostName)函数，如果hostName为NULL或者空字符串，这个函数应该返回什么？</p><pre><code>  @VisibleForTesting\n  protected String getLastSubstrSplittedByDot(String hostName) {\n    String[] tokens = hostName.split(&quot;\\\\.&quot;);\n    String substrOfHostName = tokens[tokens.length - 1];\n    return substrOfHostName;\n  }\n</code></pre><p>理论上讲，参数传递的正确性应该有程序员来保证，我们无需做NULL值或者空字符串的判断和特殊处理。调用者本不应该把NULL值或者空字符串传递给getLastSubstrSplittedByDot()函数。如果传递了，那就是code bug，需要修复。但是，话说回来，谁也保证不了程序员就一定不会传递NULL值或者空字符串。那我们到底该不该做NULL值或空字符串的判断呢？</p><p>如果函数是private类私有的，只在类内部被调用，完全在你自己的掌控之下，自己保证在调用这个private函数的时候，不要传递NULL值或空字符串就可以了。所以，我们可以不在private函数中做NULL值或空字符串的判断。如果函数是public的，你无法掌控会被谁调用以及如何调用（有可能某个同事一时疏忽，传递进了NULL值，这种情况也是存在的），为了尽可能提高代码的健壮性，我们最好是在public函数中做NULL值或空字符串的判断。</p><p>那你可能会说，getLastSubstrSplittedByDot()是protected的，既不是private函数，也不是public函数，那要不要做NULL值或空字符串的判断呢？</p><p>之所以将它设置为protected，是为了方便写单元测试。不过，单元测试可能要测试一些corner case，比如输入是NULL值或者空字符串的情况。所以，这里我们最好也加上NULL值或空字符串的判断逻辑。虽然加上有些冗余，但多加些检验总归不会错的。</p><p>按照这个设计思路，我们对getLastSubstrSplittedByDot()函数进行重构。重构之后的代码如下所示：</p><pre><code>  @VisibleForTesting\n  protected String getLastSubstrSplittedByDot(String hostName) {\n    if (hostName == null || hostName.isEmpty()) {\n      throw IllegalArgumentException(&quot;...&quot;); //运行时异常\n    }\n    String[] tokens = hostName.split(&quot;\\\\.&quot;);\n    String substrOfHostName = tokens[tokens.length - 1];\n    return substrOfHostName;\n  }\n</code></pre><p>按照上面讲的，我们在使用这个函数的时候，自己也要保证不传递NULL值或者空字符串进去。所以，getLastFieldOfHostName()函数的代码也要作相应的修改。修改之后的代码如下所示：</p><pre><code> private String getLastFieldOfHostName() throws UnknownHostException{\n    String substrOfHostName = null;\n    String hostName = InetAddress.getLocalHost().getHostName();\n    if (hostName == null || hostName.isEmpty()) { // 此处做判断\n      throw new UnknownHostException(&quot;...&quot;);\n    }\n    substrOfHostName = getLastSubstrSplittedByDot(hostName);\n    return substrOfHostName;\n }\n</code></pre><h2>重构generateRandomAlphameric()函数</h2><p>对于generateRandomAlphameric(int length)函数，如果length &lt; 0或length = 0，这个函数应该返回什么？</p><pre><code>  @VisibleForTesting\n  protected String generateRandomAlphameric(int length) {\n    char[] randomChars = new char[length];\n    int count = 0;\n    Random random = new Random();\n    while (count &lt; length) {\n      int maxAscii = 'z';\n      int randomAscii = random.nextInt(maxAscii);\n      boolean isDigit= randomAscii &gt;= '0' &amp;&amp; randomAscii &lt;= '9';\n      boolean isUppercase= randomAscii &gt;= 'A' &amp;&amp; randomAscii &lt;= 'Z';\n      boolean isLowercase= randomAscii &gt;= 'a' &amp;&amp; randomAscii &lt;= 'z';\n      if (isDigit|| isUppercase || isLowercase) {\n        randomChars[count] = (char) (randomAscii);\n        ++count;\n      }\n    }\n    return new String(randomChars);\n  }\n}\n</code></pre><p>我们先来看length  &lt;  0的情况。生成一个长度为负值的随机字符串是不符合常规逻辑的，是一种异常行为。所以，当传入的参数length  &lt;  0的时候，我们抛出IllegalArgumentException异常。</p><p>我们再来看length = 0的情况。length = 0是否是异常行为呢？这就看你自己怎么定义了。我们既可以把它定义为一种异常行为，抛出IllegalArgumentException异常，也可以把它定义为一种正常行为，让函数在入参length = 0的情况下，直接返回空字符串。不管选择哪种处理方式，最关键的一点是，要在函数注释中，明确告知length = 0的情况下，会返回什么样的数据。</p><h2>重构之后的RandomIdGenerator代码</h2><p>对RandomIdGenerator类中各个函数异常情况处理代码的重构，到此就结束了。为了方便查看，我把重构之后的代码，重新整理之后贴在这里了。你可以对比着看一下，跟你的重构思路是否一致。</p><pre><code>public class RandomIdGenerator implements IdGenerator {\n  private static final Logger logger = LoggerFactory.getLogger(RandomIdGenerator.class);\n\n  @Override\n  public String generate() throws IdGenerationFailureException {\n    String substrOfHostName = null;\n    try {\n      substrOfHostName = getLastFieldOfHostName();\n    } catch (UnknownHostException e) {\n      throw new IdGenerationFailureException(&quot;...&quot;, e);\n    }\n    long currentTimeMillis = System.currentTimeMillis();\n    String randomString = generateRandomAlphameric(8);\n    String id = String.format(&quot;%s-%d-%s&quot;,\n            substrOfHostName, currentTimeMillis, randomString);\n    return id;\n  }\n\n  private String getLastFieldOfHostName() throws UnknownHostException{\n    String substrOfHostName = null;\n    String hostName = InetAddress.getLocalHost().getHostName();\n    if (hostName == null || hostName.isEmpty()) {\n      throw new UnknownHostException(&quot;...&quot;);\n    }\n    substrOfHostName = getLastSubstrSplittedByDot(hostName);\n    return substrOfHostName;\n  }\n\n  @VisibleForTesting\n  protected String getLastSubstrSplittedByDot(String hostName) {\n    if (hostName == null || hostName.isEmpty()) {\n      throw new IllegalArgumentException(&quot;...&quot;);\n    }\n\n    String[] tokens = hostName.split(&quot;\\\\.&quot;);\n    String substrOfHostName = tokens[tokens.length - 1];\n    return substrOfHostName;\n  }\n\n  @VisibleForTesting\n  protected String generateRandomAlphameric(int length) {\n    if (length &lt;= 0) {\n      throw new IllegalArgumentException(&quot;...&quot;);\n    }\n\n    char[] randomChars = new char[length];\n    int count = 0;\n    Random random = new Random();\n    while (count &lt; length) {\n      int maxAscii = 'z';\n      int randomAscii = random.nextInt(maxAscii);\n      boolean isDigit= randomAscii &gt;= '0' &amp;&amp; randomAscii &lt;= '9';\n      boolean isUppercase= randomAscii &gt;= 'A' &amp;&amp; randomAscii &lt;= 'Z';\n      boolean isLowercase= randomAscii &gt;= 'a' &amp;&amp; randomAscii &lt;= 'z';\n      if (isDigit|| isUppercase || isLowercase) {\n        randomChars[count] = (char) (randomAscii);\n        ++count;\n      }\n    }\n    return new String(randomChars);\n  }\n}\n</code></pre><h2>重点回顾</h2><p>好了，今天的内容到此就讲完了。我们一块来总结回顾一下，你需要重点掌握的内容。</p><p>今天的内容比较偏实战，是对上节课学到的理论知识的一个应用。从今天的实战中，你学到了哪些更高层的软件设计和开发思想呢？我这里抛砖引玉，总结了下面3点。</p><ul>\n<li>再简单的代码，看上去再完美的代码，只要我们下功夫去推敲，总有可以优化的空间，就看你愿不愿把事情做到极致。</li>\n<li>如果你内功不够深厚，理论知识不够扎实，那你就很难参透开源项目的代码到底优秀在哪里。就像如果我们没有之前的理论学习，没有今天我给你一点一点重构、讲解、分析，只是给你最后重构好的RandomIdGenerator的代码，你真的能学到它的设计精髓吗？</li>\n<li>对比<a href=\"https://time.geekbang.org/column/article/190979\">第34节课</a>最初小王的IdGenerator代码和最终的RandomIdGenerator代码，它们一个是“能用”，一个是“好用”，天壤之别。作为一名程序员，起码对代码要有追求啊，不然跟咸鱼有啥区别！</li>\n</ul><h2>课堂讨论</h2><p>我们花了4节课的时间，对一个非常简单的、不到40行的ID生成器代码，做了多次迭代重构。除了刚刚我在“重点回顾”中讲到的那几点之外，从这个迭代重构的过程中，你还学到哪些更有价值的东西？</p><p>欢迎在留言区写下你的思考和想法，和同学一起交流和分享。如果有收获，也欢迎你把这篇文章分享给你的朋友。</p>",
                "article_title": "37 | 实战二（下）：重构ID生成器项目中各函数的异常处理代码"
            }
        ]
    },
    {
        "chapterTitle": "设计原则与思想：总结课 (3讲)",
        "children": [
            {
                "title": "38 | 总结回顾面向对象、设计原则、编程规范、重构技巧等知识点",
                "herf": "https://time.geekbang.org/column/article/193093",
                "id": "193093",
                "content": "<p>到今天为止，设计原则和思想已经全部讲完了，其中包括：面向对象、设计原则、规范与重构三个模块的内容。除此之外，我们还学习了贯穿整个专栏的代码质量评判标准。专栏的进度已经接近一半，马上就要进入设计模式内容的学习了。在此之前，我先带你一块来总结回顾一下，我们已经学过的所有知识点。</p><p>今天的内容比较多，有一万多字，但都是之前学过的，算是一个总结回顾，主要是想带你复习一下，温故而知新。如果你看了之后，感觉都有印象，那就说明学得还不错；如果还能在脑子里形成自己的知识架构，闭上眼睛都能回忆上来，那说明你学得很好；如果能有自己的理解，并且在项目开发中，开始思考代码质量问题，开始用已经学过的设计原则和思想来审视代码，那说明你已经掌握这些内容的精髓。</p><p><img src=\"https://static001.geekbang.org/resource/image/f3/d3/f3262ef8152517d3b11bfc3f2d2b12d3.png\" alt=\"\"></p><h2>一、代码质量评判标准</h2><p><strong>如何评价代码质量的高低？</strong></p><p>代码质量的评价有很强的主观性，描述代码质量的词汇也有很多，比如可读性、可维护性、灵活、优雅、简洁。这些词汇是从不同的维度去评价代码质量的。它们之间有互相作用，并不是独立的，比如，代码的可读性好、可扩展性好就意味着代码的可维护性好。代码质量高低是一个综合各种因素得到的结论。我们并不能通过单一维度去评价一段代码的好坏。</p><p><strong>最常用的评价标准有哪几个？</strong></p><!-- [[[read_end]]] --><p>最常用到几个评判代码质量的标准有：可维护性、可读性、可扩展性、灵活性、简洁性、可复用性、可测试性。其中，可维护性、可读性、可扩展性又是提到最多的、最重要的三个评价标准。</p><p><strong>如何才能写出高质量的代码？</strong></p><p>要写出高质量代码，我们就需要掌握一些更加细化、更加能落地的编程方法论，这就包含面向对象设计思想、设计原则、设计模式、编码规范、重构技巧等。</p><p><img src=\"https://static001.geekbang.org/resource/image/34/2b/34c51d1eb44ffc099d448ad10bcda82b.jpg\" alt=\"\"></p><h2>二、面向对象</h2><h3>1.面向对象概述</h3><p>现在，主流的编程范式或者编程风格有三种，它们分别是面向过程、面向对象和函数式编程。面向对象这种编程风格又是这其中最主流的。现在比较流行的编程语言大部分都是面向对象编程语言。大部分项目也都是基于面向对象编程风格开发的。面向对象编程因为其具有丰富的特性（封装、抽象、继承、多态），可以实现很多复杂的设计思路，是很多设计原则、设计模式编码实现的基础。</p><h3>2.面向对象四大特性</h3><p>封装也叫作信息隐藏或者数据访问保护。类通过暴露有限的访问接口，授权外部仅能通过类提供的方法来访问内部信息或者数据。它需要编程语言提供权限访问控制语法来支持，例如Java中的private、protected、public关键字。封装特性存在的意义，一方面是保护数据不被随意修改，提高代码的可维护性；另一方面是仅暴露有限的必要接口，提高类的易用性。</p><p>如果说封装主要讲如何隐藏信息、保护数据，那抽象就是讲如何隐藏方法的具体实现，让使用者只需要关心方法提供了哪些功能，不需要知道这些功能是如何实现的。抽象可以通过接口类或者抽象类来实现。抽象存在的意义，一方面是修改实现不需要改变定义；另一方面，它也是处理复杂系统的有效手段，能有效地过滤掉不必要关注的信息。</p><p>继承用来表示类之间的is-a关系，分为两种模式：单继承和多继承。单继承表示一个子类只继承一个父类，多继承表示一个子类可以继承多个父类。为了实现继承这个特性，编程语言需要提供特殊的语法机制来支持。继承主要是用来解决代码复用的问题。</p><p>多态是指子类可以替换父类，在实际的代码运行过程中，调用子类的方法实现。多态这种特性也需要编程语言提供特殊的语法机制来实现，比如继承、接口类、duck-typing。多态可以提高代码的扩展性和复用性，是很多设计模式、设计原则、编程技巧的代码实现基础。</p><h3>3.面向对象VS面向过程</h3><p>面向对象编程相比面向过程编程的优势主要有三个。</p><ul>\n<li>对于大规模复杂程序的开发，程序的处理流程并非单一的一条主线，而是错综复杂的网状结构。面向对象编程比起面向过程编程，更能应对这种复杂类型的程序开发。</li>\n<li>面向对象编程相比面向过程编程，具有更加丰富的特性（封装、抽象、继承、多态）。利用这些特性编写出来的代码，更加易扩展、易复用、易维护。</li>\n<li>从编程语言跟机器打交道方式的演进规律中，我们可以总结出：面向对象编程语言比起面向过程编程语言，更加人性化、更加高级、更加智能。</li>\n</ul><p>面向对象编程一般使用面向对象编程语言来进行，但是，不用面向对象编程语言，我们照样可以进行面向对象编程。反过来讲，即便我们使用面向对象编程语言，写出来的代码也不一定是面向对象编程风格的，也有可能是面向过程编程风格的。</p><p>面向对象和面向过程两种编程风格并不是非黑即白、完全对立的。在用面向对象编程语言开发的软件中，面向过程风格的代码并不少见，甚至在一些标准的开发库（比如JDK、Apache Commons、Google Guava）中，也有很多面向过程风格的代码。</p><p>不管使用面向过程还是面向对象哪种风格来写代码，我们最终的目的还是写出易维护、易读、易复用、易扩展的高质量代码。只要我们能避免面向过程编程风格的一些弊端，控制好它的副作用，在掌控范围内为我们所用，我们就大可不用避讳在面向对象编程中写面向过程风格的代码。</p><h3>4.面向对象分析、设计与编程</h3><p>面向对象分析（OOA）、面向对象设计（OOD）、面向对象编程（OOP），是面向对象开发的三个主要环节。简单点讲，面向对象分析就是要搞清楚做什么，面向对象设计就是要搞清楚怎么做，面向对象编程就是将分析和设计的的结果翻译成代码的过程。</p><p>需求分析的过程实际上是一个不断迭代优化的过程。我们不要试图一下就给出一个完美的解决方案，而是先给出一个粗糙的、基础的方案，有一个迭代的基础，然后再慢慢优化。这样一个思考过程能让我们摆脱无从下手的窘境。</p><p>面向对象设计和实现要做的事情就是把合适的代码放到合适的类中。至于到底选择哪种划分方法，判定的标准是让代码尽量地满足“松耦合、高内聚”、单一职责、对扩展开放对修改关闭等我们之前讲到的各种设计原则和思想，尽量地做到代码可复用、易读、易扩展、易维护。</p><p>面向对象分析的产出是详细的需求描述。面向对象设计的产出是类。在面向对象设计这一环节中，我们将需求描述转化为具体的类的设计。这个环节的工作可以拆分为下面四个部分。</p><ul>\n<li>划分职责进而识别出有哪些类</li>\n</ul><p>根据需求描述，我们把其中涉及的功能点，一个一个罗列出来，然后再去看哪些功能点职责相近，操作同样的属性，可否归为同一个类。</p><ul>\n<li>定义类及其属性和方法</li>\n</ul><p>我们识别出需求描述中的动词，作为候选的方法，再进一步过滤筛选出真正的方法，把功能点中涉及的名词，作为候选属性，然后同样再进行过滤筛选。</p><ul>\n<li>定义类与类之间的交互关系</li>\n</ul><p>UML统一建模语言中定义了六种类之间的关系。它们分别是：泛化、实现、关联、聚合、组合、依赖。我们从更加贴近编程的角度，对类与类之间的关系做了调整，保留了四个关系：泛化、实现、组合、依赖。</p><ul>\n<li>将类组装起来并提供执行入口</li>\n</ul><p>我们要将所有的类组装在一起，提供一个执行入口。这个入口可能是一个main()函数，也可能是一组给外部用的API接口。通过这个入口，我们能触发整个代码跑起来。</p><h3>5.接口VS抽象类</h3><p>抽象类不允许被实例化，只能被继承。它可以包含属性和方法。方法既可以包含代码实现，也可以不包含代码实现。不包含代码实现的方法叫作抽象方法。子类继承抽象类，必须实现抽象类中的所有抽象方法。接口不能包含属性（Java可以定义静态常量），只能声明方法，方法不能包含代码实现（Java8以后可以有默认实现）。类实现接口的时候，必须实现接口中声明的所有方法。</p><p>抽象类是对成员变量和方法的抽象，是一种is-a关系，是为了解决代码复用问题。接口仅仅是对方法的抽象，是一种has-a关系，表示具有某一组行为特性，是为了解决解耦问题，隔离接口和具体的实现，提高代码的扩展性。</p><p>什么时候该用抽象类？什么时候该用接口？实际上，判断的标准很简单。如果要表示一种is-a的关系，并且是为了解决代码复用问题，我们就用抽象类；如果要表示\b一种has-a关系，并且是为了解决抽象而非代码复用问题，那我们就用接口。</p><h3>6.基于接口而非实现编程</h3><p>应用这条原则，可以将接口和实现相分离，封装不稳定的实现，暴露稳定的接口。上游系统面向接口而非实现编程，不依赖不稳定的实现细节，这样当实现发生变化的时候，上游系统的代码基本上不需要做改动，以此来降低耦合性，提高扩展性。</p><p>实际上，“基于接口而非实现编程”这条原则的另一个表述方式是，“基于抽象而非实现编程”。后者的表述方式其实更能体现这条原则的设计初衷。在软件开发中，最大的挑战之一就是需求的不断变化，这也是考验代码设计好坏的一个标准。</p><p>越抽象、越顶层、越脱离具体某一实现的设计，越能提高代码的灵活性，越能应对未来的需求变化。好的代码设计，不仅能应对当下的需求，而且在将来需求发生变化的时候，仍然能够在不破坏原有代码设计的情况下灵活应对。而抽象就是提高代码扩展性、灵活性、可维护性最有效的手段之一。</p><h3>7.多用组合少用继承</h3><p><strong>为什么不推荐使用继承？</strong></p><p>继承是面向对象的四大特性之一，用来表示类之间的is-a关系，可以解决代码复用的问题。虽然继承有诸多作用，但继承层次过深、过复杂，也会影响到代码的可维护性。在这种情况下，我们应该尽量少用，甚至不用继承。</p><p><strong>组合相比继承有哪些优势？</strong></p><p>继承主要有三个作用：表示is-a关系、支持多态特性、代码复用。而这三个作用都可以通过组合、接口、委托三个技术手段来达成。除此之外，利用组合还能解决层次过深、过复杂的继承关系影响代码可维护性的问题。</p><p><strong>如何判断该用组合还是继承？</strong></p><p>尽管我们鼓励多用组合少用继承，但组合也并不是完美的，继承也并非一无是处。在实际的项目开发中，我们还是要根据具体的情况，来选择该用继承还是组合。如果类之间的继承结构稳定，层次比较浅，关系不复杂，我们就可以大胆地使用继承。反之，我们就尽量使用组合来替代继承。除此之外，还有一些设计模式、特殊的应用场景，会固定使用继承或者组合。</p><h3>8.贫血模型VS充血模型</h3><p>我们平时做Web项目的业务开发，大部分都是基于贫血模型的MVC三层架构，在专栏中我把它称为传统的开发模式。之所以称之为“传统”，是相对于新兴的基于充血模型的DDD开发模式来说的。基于贫血模型的传统开发模式，是典型的面向过程的编程风格。相反，基于充血模型的DDD开发模式，是典型的面向对象的编程风格。</p><p>不过，DDD也并非银弹。对于业务不复杂的系统开发来说，基于贫血模型的传统开发模式简单够用，基于充血模型的DDD开发模式有点大材小用，无法发挥作用。相反，对于业务复杂的系统开发来说，基于充血模型的DDD开发模式，因为前期需要在设计上投入更多时间和精力，来提高代码的复用性和可维护性，所以相比基于贫血模型的开发模式，更加有优势。</p><p>基于充血模型的DDD开发模式跟基于贫血模型的传统开发模式相比，主要区别在Service层。在基于充血模型的开发模式下，我们将部分原来在Service类中的业务逻辑移动到了一个充血的Domain领域模型中，让Service类的实现依赖这个Domain类。不过，Service类并不会完全移除，而是负责一些不适合放在Domain类中的功能。比如，负责与Repository层打交道、跨领域模型的业务聚合功能、幂等事务等非功能性的工作。</p><p>基于充血模型的DDD开发模式跟基于贫血模型的传统开发模式相比，Controller层和Repository层的代码基本上相同。这是因为，Repository层的Entity生命周期有限，Controller层的VO只是单纯作为一种DTO。两部分的业务逻辑都不会太复杂。业务逻辑主要集中在Service层。所以，Repository层和Controller层继续沿用贫血模型的设计思路是没有问题的。</p><p><img src=\"https://static001.geekbang.org/resource/image/f4/e7/f4ce06502a9782d200e8e10a90bf2ce7.jpg\" alt=\"\"></p><h2>三、设计原则</h2><h3>1.SOLID原则：SRP单一职责原则</h3><p>一个类只负责完成一个职责或者功能。单一职责原则通过避免设计大而全的类，避免将不相关的功能耦合在一起，来提高类的内聚性。同时，类职责单一，类依赖的和被依赖的其他类也会变少，减少了代码的耦合性，以此来实现代码的高内聚、松耦合。但是，如果拆分得过细，实际上会适得其反，反倒会降低内聚性，也会影响代码的可维护性。</p><p>不同的应用场景、不同阶段的需求背景、不同的业务层面，对同一个类的职责是否单一，可能会有不同的判定结果。实际上，一些侧面的判断指标更具有指导意义和可执行性，比如，出现下面这些情况就有可能说明这类的设计不满足单一职责原则：</p><ul>\n<li>类中的代码行数、函数或者属性过多；</li>\n<li>类依赖的其他类过多或者依赖类的其他类过多；</li>\n<li>私有方法过多；</li>\n<li>比较难给类起一个合适的名字；</li>\n<li>类中大量的方法都是集中操作类中的某几个属性。</li>\n</ul><h3>2.SOLID原则：OCP开闭原则</h3><p><strong>如何理解“对扩展开放、修改关闭”？</strong></p><p>添加一个新的功能，应该是通过在已有代码基础上扩展代码（新增模块、类、方法、属性等），而非修改已有代码（修改模块、类、方法、属性等）的方式来完成。关于定义，我们有两点要注意。第一点是，开闭原则并不是说完全杜绝修改，而是以最小的修改代码的代价来完成新功能的开发。第二点是，同样的代码改动，在粗代码粒度下，可能被认定为“修改”；在细代码粒度下，可能又被认定为“扩展”。</p><p><strong>如何做到“对扩展开放、修改关闭”？</strong></p><p>我们要时刻具备扩展意识、抽象意识、封装意识。在写代码的时候，我们要多花点时间思考一下，这段代码未来可能有哪些需求变更，如何设计代码结构，事先留好扩展点，以便在未来需求变更的时候，在不改动代码整体结构、做到最小代码改动的情况下，将新的代码灵活地插入到扩展点上。</p><p>很多设计原则、设计思想、设计模式，都是以提高代码的扩展性为最终目的的。特别是23种经典设计模式，大部分都是为了解决代码的扩展性问题而总结出来的，都是以开闭原则为指导原则的。最常用来提高代码扩展性的方法有：多态、依赖注入、基于接口而非实现编程，以及大部分的设计模式（比如，装饰、策略、模板、职责链、状态）。</p><h3>3.SOLID原则：LSP里式替换原则</h3><p>子类对象（object of subtype/derived class）能够替换程序（program）中父类对象（object of base/parent class）出现的任何地方，并且保证原来程序的逻辑行为（behavior）不变及正确性不被破坏。</p><p>里式替换原则是用来指导继承关系中子类该如何设计的一个原则。理解里式替换原则，最核心的就是理解“design by contract，按照协议来设计”这几个字。父类定义了函数的“约定”（或者叫协议），那子类可以改变函数的内部实现逻辑，但不能改变函数的原有“约定”。这里的“约定”包括：函数声明要实现的功能；对输入、输出、异常的约定；甚至包括注释中所罗列的任何特殊说明。</p><p>理解这个原则，我们还要弄明白，里式替换原则跟多态的区别。虽然从定义描述和代码实现上来看，多态和里式替换有点类似，但它们关注的角度是不一样的。多态是面向对象编程的一大特性，也是面向对象编程语言的一种语法。它是一种代码实现的思路。而里式替换是一种设计原则，用来指导继承关系中子类该如何设计，子类的设计要保证在替换父类的时候，不改变原有程序的逻辑及不破坏原有程序的正确性。</p><h3>4.SOLID原则：ISP接口隔离原则</h3><p>接口隔离原则的描述是：客户端不应该强迫依赖它不需要的接口。其中的“客户端”，可以理解为接口的调用者或者使用者。理解“接口隔离原则”的重点是理解其中的“接口”二字。这里有三种不同的理解。</p><p>如果把“接口”理解为一组接口集合，可以是某个微服务的接口，也可以是某个类库的接口等。如果部分接口只被部分调用者使用，我们就需要将这部分接口隔离出来，单独给这部分调用者使用，而不强迫其他调用者也依赖这部分不会被用到的接口。</p><p>如果把“接口”理解为单个API接口或函数，部分调用者只需要函数中的部分功能，那我们就需要把函数拆分成粒度更细的多个函数，让调用者只依赖它需要的那个细粒度函数。</p><p>如果把“接口”理解为OOP中的接口，也可以理解为面向对象编程语言中的接口语法。那接口的设计要尽量单一，不要让接口的实现类和调用者，依赖不需要的接口函数。</p><p>单一职责原则针对的是模块、类、接口的设计。接口隔离原则相对于单一职责原则，一方面更侧重于接口的设计，另一方面它的思考的角度也是不同的。接口隔离原则提供了一种判断接口的职责是否单一的标准：通过调用者如何使用接口来间接地判定。如果调用者只使用部分接口或接口的部分功能，那接口的设计就不够职责单一。</p><h3>5.SOLID原则：DIP依赖倒置原则</h3><p><strong>控制反转：</strong>实际上，控制反转是一个比较笼统的设计思想，并不是一种具体的实现方法，一般用来指导框架层面的设计。这里所说的“控制”指的是对程序执行流程的控制，而“反转”指的是在没有使用框架之前，程序员自己控制整个程序的执行。在使用框架之后，整个程序的执行流程通过框架来控制。流程的控制权从程序员“反转”给了框架。</p><p><strong>依赖注入：</strong>依赖注入和控制反转恰恰相反，它是一种具体的编码技巧。我们不通过new的方式在类内部创建依赖类的对象，而是将依赖的类对象在外部创建好之后，通过构造函数、函数参数等方式传递（或“注入”）给类来使用。</p><p><strong>依赖注入框架：</strong>我们通过依赖注入框架提供的扩展点，简单配置一下所有需要的类及其类与类之间的依赖关系，就可以实现由框架来自动创建对象、管理对象的生命周期、依赖注入等原本需要程序员来做的事情。</p><p><strong>依赖反转原则：</strong>依赖反转原则也叫作依赖倒置原则。这条原则跟控制反转有点类似，主要用来指导框架层面的设计。高层模块不依赖低层模块，它们共同依赖同一个抽象。抽象不需要依赖具体实现细节，具体实现细节依赖抽象。</p><h3>6.KISS、YAGNI原则</h3><p>KISS原则的中文描述是：尽量保持简单。KISS原则是保持代码可读和可维护的重要手段。KISS原则中的“简单“”并不是以代码行数来考量的。代码行数越少并不代表代码越简单，我们还要考虑逻辑复杂度、实现难度、代码的可读性等。而且，本身就复杂的问题，用复杂的方法解决，也并不违背KISS原则。除此之外，同样的代码，在某个业务场景下满足KISS原则，换一个应用场景可能就不满足了。</p><p>对于如何写出满足KISS原则的代码，我总结了下面几条指导原则：</p><ul>\n<li>不要使用同事可能不懂的技术来实现代码；</li>\n<li>不要重复造轮子，善于使用已经有的工具类库；</li>\n<li>不要过度优化。</li>\n</ul><p>YAGNI原则的英文全称是：You Ain’t Gonna Need It。直译就是：你不会需要它。这条原则也算是万金油了。当用在软件开发中的时候，它的意思是：不要去设计当前用不到的功能；不要去编写当前用不到的代码。实际上，这条原则的核心思想就是：不要做过度设计。</p><p>YAGNI原则跟KISS原则并非一回事儿。KISS原则讲的是“如何做”的问题（尽量保持简单），而YAGNI原则说的是“要不要做”的问题（当前不需要的就不要做）。</p><h3>7.DRY原则</h3><p>DRY原则中文描述是：不要重复自己，将它应用在编程中，可以理解为：不要写重复的代码。</p><p>专栏中讲到了三种代码重复的情况：实现逻辑重复、功能语义重复、代码执行重复。实现逻辑重复，但功能语义不重复的代码，并不违反DRY原则。实现逻辑不重复，但功能语义重复的代码，也算是违反DRY原则。而代码执行重复也算是违反DRY原则。</p><p>除此之外，我们还讲到了提高代码复用性的一些手段，包括：减少代码耦合、满足单一职责原则、模块化、业务与非业务逻辑分离、通用代码下沉、继承、多态、抽象、封装、应用模板等设计模式。复用意识也非常重要。在设计每个模块、类、函数的时候，要像设计一个外部API一样去思考它的复用性。</p><p>我们在第一次写代码的时候，如果当下没有复用的需求，而未来的复用需求也不是特别明确，并且开发可复用代码的成本比较高，那我们就不需要考虑代码的复用性。在之后开发新的功能的时候，发现可以复用之前写的这段代码，那我们就重构这段代码，让其变得更加可复用。</p><p>相比于代码的可复用性，DRY原则适用性更强些。我们可以不写可复用的代码，但一定不能写重复的代码。</p><h3>8.LOD原则</h3><p><strong>如何理解“高内聚、松耦合”？</strong></p><p>“高内聚、松耦合”是一个非常重要的设计思想，能够有效提高代码的可读性和可维护性，缩小功能改动导致的代码改动范围。“高内聚”用来指导类本身的设计，“松耦合”用来指导类与类之间依赖关系的设计。所谓高内聚，就是指相近的功能应该放到同一个类中，不相近的功能不要放到同一类中。相近的功能往往会被同时修改，放到同一个类中，修改会比较集中。所谓“松耦合”指的是，在代码中，类与类之间的依赖关系简单清晰。即使两个类有依赖关系，一个类的代码改动也不会或者很少导致依赖类的代码改动。</p><p><strong>如何理解“迪米特法则”？</strong></p><p>迪米特法则的描述为：不该有直接依赖关系的类之间，不要有依赖；有依赖关系的类之间，尽量只依赖必要的接口。迪米特法则是希望减少类之间的耦合，让类越独立越好。每个类都应该少了解系统的其他部分。一旦发生变化，需要了解这一变化的类就会比较少。</p><p><img src=\"https://static001.geekbang.org/resource/image/fb/9f/fbf1ae0ce08d4ea890b80944c2b8309f.jpg\" alt=\"\"></p><h2>四、规范与重构</h2><h3>1.重构概述</h3><p><strong>重构的目的：为什么重构（why）？</strong></p><p>对于项目来言，重构可以保持代码质量持续处于一个可控状态，不至于腐化到无可救药的地步。对于个人而言，重构非常锻炼一个人的代码能力，并且是一件非常有成就感的事情。它是我们学习的经典设计思想、原则、模式、编程规范等理论知识的练兵场。</p><p><strong>重构的对象：重构什么（what）？</strong></p><p>按照重构的规模，我们可以将重构大致分为大规模高层次的重构和小规模低层次的重构。大规模高层次重构包括对代码分层、模块化、解耦、梳理类之间的交互关系、抽象复用组件等等。这部分工作利用的更多的是比较抽象、比较顶层的设计思想、原则、模式。小规模低层次的重构包括规范命名、注释、修正函数参数过多、消除超大类、提取重复代码等编程细节问题，主要是针对类、函数级别的重构。小规模低层次的重构更多的是利用编码规范这一理论知识。</p><p><strong>重构的时机：什么时候重构（when）？</strong></p><p>我反复强调，我们一定要建立持续重构意识，把重构作为开发必不可少的部分融入到开发中，而不是等到代码出现很大问题的时候，再大刀阔斧地重构。</p><p><strong>重构的方法：如何重构（how）？</strong></p><p>大规模高层次的重构难度比较大，需要有组织、有计划地进行，分阶段地小步快跑，时刻保持代码处于一个可运行的状态。而小规模低层次的重构，因为影响范围小，改动耗时短，所以，只要你愿意并且有时间，随时随地都可以去做。</p><h3>2.单元测试</h3><p><strong>什么是单元测试？</strong></p><p>单元测试是代码层面的测试，用于测试“自己”编写的代码的逻辑正确性。单元测试顾名思义是测试一个“单元”，这个“单元”一般是类或函数，而不是模块或者系统。</p><p><strong>为什么要写单元测试？</strong></p><p>单元测试能有效地发现代码中的Bug、代码设计上的问题。写单元测试的过程本身就是代码重构的过程。单元测试是对集成测试的有力补充，能帮助我们快速熟悉代码，是TDD可落地执行的折中方案。</p><p><strong>如何编写单元测试？</strong></p><p>写单元测试就是针对代码设计覆盖各种输入、异常、边界条件的测试用例，并将其翻译成代码的过程。我们可以利用一些测试框架来简化测试代码的编写。对于单元测试，我们需要建立以下正确的认知：</p><ul>\n<li>编写单元测试尽管繁琐，但并不是太耗时；</li>\n<li>我们可以稍微放低单元测试的质量要求；</li>\n<li>覆盖率作为衡量单元测试好坏的唯一标准是不合理的；</li>\n<li>写单元测试一般不需要了解代码的实现逻辑；</li>\n<li>单元测试框架无法测试多半是代码的可测试性不好。</li>\n</ul><p><strong>单元测试为何难落地执行？</strong></p><p>一方面，写单元测试本身比较繁琐，技术挑战不大，很多程序员不愿意去写。另一方面，国内研发比较偏向“快糙猛”，容易因为开发进度紧，导致单元测试的执行虎头蛇尾，最后，没有建立对单元测试的正确认识，觉得可有可无，单靠督促很难执行得很好。</p><h3>3.代码的可测试性</h3><p><strong>什么是代码的可测试性？</strong></p><p>粗略地讲，所谓代码的可测试性，就是针对代码编写单元测试的难易程度。对于一段代码，如果很难为其编写单元测试，或者单元测试写起来很费劲，需要依靠单元测试框架很高级的特性，那往往就意味着代码设计得不够合理，代码的可测试性不好。</p><p><strong>编写可测试性代码的最有效手段</strong></p><p>依赖注入是编写可测试性代码的最有效手段。通过依赖注入，我们在编写单元测试代码的时候，可以通过mock的方法将不可控的依赖变得可控，这也是我们在编写单元测试的过程中最有技术挑战的地方。除了mock方式，我们还可以利用二次封装来解决某些代码行为不可控的情况。</p><p><strong>常见的Anti-Patterns</strong></p><p>典型的、常见的测试不友好的代码有下面这5种：</p><ul>\n<li>代码中包含未决行为逻辑；</li>\n<li>滥用可变全局变量；</li>\n<li>滥用静态方法；</li>\n<li>使用复杂的继承关系；</li>\n<li>高度耦合的代码。</li>\n</ul><h3>4.大型重构：解耦</h3><p><strong>“解耦”为何如此重要？</strong></p><p>过于复杂的代码往往在可读性、可维护性上都不友好。解耦，保证代码松耦合、高内聚，是控制代码复杂度的有效手段。如果代码高内聚、松耦合，也就是意味着，代码结构清晰、分层、模块化合理、依赖关系简单、模块或类之间的耦合小，那代码整体的质量就不会差。</p><p><strong>代码是否需要“解耦”？</strong></p><p>间接的衡量标准有很多，比如：改动一个模块或类的代码受影响的模块或类是否有很多、改动一个模块或者类的代码依赖的模块或者类是否需要改动、代码的可测试性是否好等等。直接的衡量标准是把模块与模块之间及其类与类之间的依赖关系画出来，根据依赖关系图的复杂性来判断是否需要解耦重构。</p><p><strong>如何给代码“解耦”？</strong></p><p>给代码解耦的方法有：封装与抽象、中间层、模块化，以及一些其他的设计思想与原则，比如：单一职责原则、基于接口而非实现编程、依赖注入、多用组合少用继承、迪米特法则。当然，还有一些设计模式，比如观察者模式。</p><h3>5.小型重构：编码规范</h3><p>前面我们讲了很多设计原则，后面还会讲到很多设计模式，利用好它们都可以有效地改善代码的质量。但是，这些知识的合理应用非常依赖个人经验，有时候用不好会适得其反。但是编码规范正好相反，大部分都简单明了，在代码的细节方面，能立竿见影地改善质量。除此之外，我们前面也讲到，持续低层次小规模重构依赖的基本上都是这些编码规范，也是改善代码可读性的有效手段。</p><p>根据我自己的开发经验，我总结罗列了20条我认为最应该关注、最好用的编码规范，分为三个大的方面：命名与注释（Naming and Comments）、代码风格（Code Style）、编程技巧（Coding Tips）。</p><p><strong>命名与注释</strong></p><ul>\n<li>命名的关键是能准确的达意。对于不同作用域的命名，我们可以适当的选择不同的长度，作用域小的命名，比如临时变量等，可以适当的选择短一些的命名方式。除此之外，命名中个也可以使用一些耳熟能详的缩写。</li>\n<li>我们借助类的信息来简化属性、函数的命名，利用函数的信息来简化函数参数的命名。</li>\n<li>命名要可读、可搜索。不要使用生僻的、不好读的英文单词来命名。除此之外，命名要符合项目的统一规范，也不要用些反直觉的命名。</li>\n<li>接口有两种命名方式。一种是在接口中带前缀\"I\"，另一种是在接口的实现类中带后缀“Impl”。两种命名方式都可以，关键是要在项目中统一。对于抽象类的命名，我们更倾向于带有前缀“Abstract”。</li>\n<li>注释的目的就是让代码更容易看懂，只要符合这个要求，你就可以写。总结一下的话，注释主要包含这样三个方面的内容：做什么、为什么、怎么做。对于一些复杂的类和接口，我们可能还需要写明“如何用”。</li>\n<li>注释本身有一定的维护成本，所以并非越多越好。类和函数一定要写注释，而且要写的尽可能全面详细些，而函数内部的注释会相对少一些，一般都是靠好的命名和提炼函数、解释性变量、总结性注释来做到代码易读。</li>\n</ul><p><strong>代码风格</strong></p><p>代码风格都没有对错和优劣之分，不同的编程语言风格都不太一样，只要能在团队、项目中统一即可，不过，最好能跟业内推荐的风格、开源项目的代码风格相一致。所以，这里就不展开罗列了，你可以对照着自己熟悉的编程语言的代码风格，自己复习一下。</p><p><strong>编程技巧</strong></p><ul>\n<li>将复杂的逻辑提炼拆分成函数和类；</li>\n<li>通过拆分成多个函数的方式来处理参数过多的情况；</li>\n<li>通过将参数封装为对象来处理参数过多的情况；</li>\n<li>函数中不要使用参数来做代码执行逻辑的控制；</li>\n<li>移除过深的嵌套层次，方法包括：去掉多余的if或else语句，使用continue、break、return关键字提前退出嵌套，调整执行顺序来减少嵌套，将部分嵌套逻辑抽象成函数；</li>\n<li>用字面常量取代魔法数；</li>\n<li>利用解释性变量来解释复杂表达式。</li>\n</ul><p><strong>统一编码规范</strong></p><p>除了细节的知识点之外，最后，还有一条非常重要的，那就是，项目、团队，甚至公司，一定要制定统一的编码规范，并且通过Code Review督促执行，这对提高代码质量有立竿见影的效果。</p><p><img src=\"https://static001.geekbang.org/resource/image/fc/8a/fc56f7c2b348d324c93a09dd0dee538a.jpg\" alt=\"\"></p><h2>课堂讨论</h2><p>不知不觉我们已经学了这么多内容，在复习完这部分内容之后，你可以在留言区说一说你的掌握程度，看自己符合我开篇中讲到的哪个层次。</p><p>如果有帮助，欢迎你收藏这篇文章，并且把它分享给你的朋友。</p>",
                "article_title": "38 | 总结回顾面向对象、设计原则、编程规范、重构技巧等知识点"
            },
            {
                "title": "39 | 运用学过的设计原则和思想完善之前讲的性能计数器项目（上）",
                "herf": "https://time.geekbang.org/column/article/193221",
                "id": "193221",
                "content": "<p>在<a href=\"https://time.geekbang.org/column/article/179644\">第25节</a>、<a href=\"https://time.geekbang.org/column/article/179673\">第26节</a>中，我们讲了如何对一个性能计数器框架进行分析、设计与实现，并且实践了之前学过的一些设计原则和设计思想。当时我们提到，小步快跑、逐步迭代是一种非常实用的开发模式。所以，针对这个框架的开发，我们分多个版本来逐步完善。</p><p>在第25、26节课中，我们实现了框架的第一个版本，它只包含最基本的一些功能，在设计与实现上还有很多不足。所以，接下来，我会针对这些不足，继续迭代开发两个版本：版本2和版本3，分别对应第39节和第40节的内容。</p><p>在版本2中，我们会利用之前学过的重构方法，对版本1的设计与实现进行重构，解决版本1存在的设计问题，让它满足之前学过的设计原则、思想、编程规范。在版本3中，我们再对版本2进行迭代，并且完善框架的功能和非功能需求，让其满足第25节课中罗列的所有需求。</p><p>话不多说，让我们正式开始版本2的设计与实现吧！</p><h2>回顾版本1的设计与实现</h2><p>首先，让我们一块回顾一下版本1的设计与实现。当然，如果时间充足，你最好能再重新看一下第25、26节的内容。在版本1中，整个框架的代码被划分为下面这几个类。</p><ul>\n<li>MetricsCollector：负责打点采集原始数据，包括记录每次接口请求的响应时间和请求时间戳，并调用MetricsStorage提供的接口来存储这些原始数据。</li>\n<li>MetricsStorage和RedisMetricsStorage：负责原始数据的存储和读取。</li>\n<li>Aggregator：是一个工具类，负责各种统计数据的计算，比如响应时间的最大值、最小值、平均值、百分位值、接口访问次数、tps。</li>\n<li>ConsoleReporter和EmailReporter：相当于一个上帝类（God Class），定时根据给定的时间区间，从数据库中取出数据，借助Aggregator类完成统计工作，并将统计结果输出到相应的终端，比如命令行、邮件。</li>\n</ul><!-- [[[read_end]]] --><p>MetricCollector、MetricsStorage、RedisMetricsStorage的设计与实现比较简单，不是版本2重构的重点。今天，我们重点来看一下Aggregator和ConsoleReporter、EmailReporter这几个类。</p><p><strong>我们先来看一下Aggregator类存在的问题。</strong></p><p>Aggregator类里面只有一个静态函数，有50行左右的代码量，负责各种统计数据的计算。当要添加新的统计功能的时候，我们需要修改aggregate()函数代码。一旦越来越多的统计功能添加进来之后，这个函数的代码量会持续增加，可读性、可维护性就变差了。因此，我们需要在版本2中对其进行重构。</p><pre><code>public class Aggregator {\n  public static RequestStat aggregate(List&lt;RequestInfo&gt; requestInfos, long durationInMillis) {\n    double maxRespTime = Double.MIN_VALUE;\n    double minRespTime = Double.MAX_VALUE;\n    double avgRespTime = -1;\n    double p999RespTime = -1;\n    double p99RespTime = -1;\n    double sumRespTime = 0;\n    long count = 0;\n    for (RequestInfo requestInfo : requestInfos) {\n      ++count;\n      double respTime = requestInfo.getResponseTime();\n      if (maxRespTime &lt; respTime) {\n        maxRespTime = respTime;\n      }\n      if (minRespTime &gt; respTime) {\n        minRespTime = respTime;\n      }\n      sumRespTime += respTime;\n    }\n    if (count != 0) {\n      avgRespTime = sumRespTime / count;\n    }\n    long tps = (long)(count / durationInMillis * 1000);\n    Collections.sort(requestInfos, new Comparator&lt;RequestInfo&gt;() {\n      @Override\n      public int compare(RequestInfo o1, RequestInfo o2) {\n        double diff = o1.getResponseTime() - o2.getResponseTime();\n        if (diff &lt; 0.0) {\n          return -1;\n        } else if (diff &gt; 0.0) {\n          return 1;\n        } else {\n          return 0;\n        }\n      }\n    });\n \n    if (count != 0) {\n      int idx999 = (int)(count * 0.999);\n      int idx99 = (int)(count * 0.99);\n      p999RespTime = requestInfos.get(idx999).getResponseTime();\n      p99RespTime = requestInfos.get(idx99).getResponseTime();\n    }\n    RequestStat requestStat = new RequestStat();\n    requestStat.setMaxResponseTime(maxRespTime);\n    requestStat.setMinResponseTime(minRespTime);\n    requestStat.setAvgResponseTime(avgRespTime);\n    requestStat.setP999ResponseTime(p999RespTime);\n    requestStat.setP99ResponseTime(p99RespTime);\n    requestStat.setCount(count);\n    requestStat.setTps(tps);\n    return requestStat;\n  }\n}\n\npublic class RequestStat {\n  private double maxResponseTime;\n  private double minResponseTime;\n  private double avgResponseTime;\n  private double p999ResponseTime;\n  private double p99ResponseTime;\n  private long count;\n  private long tps;\n  //...省略getter/setter方法...\n}\n</code></pre><p><strong>我们再来看一下ConsoleReporter和EmailReporter这两个类存在的问题。</strong></p><p>ConsoleReporter和EmailReporter两个类中存在代码重复问题。在这两个类中，从数据库中取数据、做统计的逻辑都是相同的，可以抽取出来复用，否则就违反了DRY原则。</p><p>整个类负责的事情比较多，不相干的逻辑糅合在里面，职责不够单一。特别是显示部分的代码可能会比较复杂（比如Email的显示方式），最好能将这部分显示逻辑剥离出来，设计成一个独立的类。</p><p>除此之外，因为代码中涉及线程操作，并且调用了Aggregator的静态函数，所以代码的可测试性也有待提高。</p><pre><code>public class ConsoleReporter {\n  private MetricsStorage metricsStorage;\n  private ScheduledExecutorService executor;\n\n  public ConsoleReporter(MetricsStorage metricsStorage) {\n    this.metricsStorage = metricsStorage;\n    this.executor = Executors.newSingleThreadScheduledExecutor();\n  }\n\n  public void startRepeatedReport(long periodInSeconds, long durationInSeconds) {\n    executor.scheduleAtFixedRate(new Runnable() {\n      @Override\n      public void run() {\n        long durationInMillis = durationInSeconds * 1000;\n        long endTimeInMillis = System.currentTimeMillis();\n        long startTimeInMillis = endTimeInMillis - durationInMillis;\n        Map&lt;String, List&lt;RequestInfo&gt;&gt; requestInfos =\n                metricsStorage.getRequestInfos(startTimeInMillis, endTimeInMillis);\n        Map&lt;String, RequestStat&gt; stats = new HashMap&lt;&gt;();\n        for (Map.Entry&lt;String, List&lt;RequestInfo&gt;&gt; entry : requestInfos.entrySet()) {\n          String apiName = entry.getKey();\n          List&lt;RequestInfo&gt; requestInfosPerApi = entry.getValue();\n          RequestStat requestStat = Aggregator.aggregate(requestInfosPerApi, durationInMillis);\n          stats.put(apiName, requestStat);\n        }\n        System.out.println(&quot;Time Span: [&quot; + startTimeInMillis + &quot;, &quot; + endTimeInMillis + &quot;]&quot;);\n        Gson gson = new Gson();\n        System.out.println(gson.toJson(stats));\n      }\n    }, 0, periodInSeconds, TimeUnit.SECONDS);\n  }\n\n}\n\npublic class EmailReporter {\n  private static final Long DAY_HOURS_IN_SECONDS = 86400L;\n\n  private MetricsStorage metricsStorage;\n  private EmailSender emailSender;\n  private List&lt;String&gt; toAddresses = new ArrayList&lt;&gt;();\n\n  public EmailReporter(MetricsStorage metricsStorage) {\n    this(metricsStorage, new EmailSender(/*省略参数*/));\n  }\n\n  public EmailReporter(MetricsStorage metricsStorage, EmailSender emailSender) {\n    this.metricsStorage = metricsStorage;\n    this.emailSender = emailSender;\n  }\n\n  public void addToAddress(String address) {\n    toAddresses.add(address);\n  }\n\n  public void startDailyReport() {\n    Calendar calendar = Calendar.getInstance();\n    calendar.add(Calendar.DATE, 1);\n    calendar.set(Calendar.HOUR_OF_DAY, 0);\n    calendar.set(Calendar.MINUTE, 0);\n    calendar.set(Calendar.SECOND, 0);\n    calendar.set(Calendar.MILLISECOND, 0);\n    Date firstTime = calendar.getTime(); \n    Timer timer = new Timer();\n    timer.schedule(new TimerTask() {\n      @Override\n      public void run() {\n        long durationInMillis = DAY_HOURS_IN_SECONDS * 1000;\n        long endTimeInMillis = System.currentTimeMillis();\n        long startTimeInMillis = endTimeInMillis - durationInMillis;\n        Map&lt;String, List&lt;RequestInfo&gt;&gt; requestInfos =\n                metricsStorage.getRequestInfos(startTimeInMillis, endTimeInMillis);\n        Map&lt;String, RequestStat&gt; stats = new HashMap&lt;&gt;();\n        for (Map.Entry&lt;String, List&lt;RequestInfo&gt;&gt; entry : requestInfos.entrySet()) {\n          String apiName = entry.getKey();\n          List&lt;RequestInfo&gt; requestInfosPerApi = entry.getValue();\n          RequestStat requestStat = Aggregator.aggregate(requestInfosPerApi, durationInMillis);\n          stats.put(apiName, requestStat);\n        }\n        // TODO: 格式化为html格式，并且发送邮件\n      }\n    }, firstTime, DAY_HOURS_IN_SECONDS * 1000);\n  }\n\n}\n</code></pre><h2>针对版本1的问题进行重构</h2><p>Aggregator类和ConsoleReporter、EmailReporter类主要负责统计显示的工作。在第26节中，我们提到，如果我们把统计显示所要完成的功能逻辑细分一下，主要包含下面4点：</p><ol>\n<li>根据给定的时间区间，从数据库中拉取数据；</li>\n<li>根据原始数据，计算得到统计数据；</li>\n<li>将统计数据显示到终端（命令行或邮件）；</li>\n<li>定时触发以上三个过程的执行。</li>\n</ol><p>之前的划分方法是将所有的逻辑都放到ConsoleReporter和EmailReporter这两个上帝类中，而Aggregator只是一个包含静态方法的工具类。这样的划分方法存在前面提到的一些问题，我们需要对其进行重新划分。</p><p>面向对象设计中的最后一步是组装类并提供执行入口，所以，组装前三部分逻辑的上帝类是必须要有的。我们可以将上帝类做的很轻量级，把核心逻辑都剥离出去，形成独立的类，上帝类只负责组装类和串联执行流程。这样做的好处是，代码结构更加清晰，底层核心逻辑更容易被复用。按照这个设计思路，具体的重构工作包含以下4个方面。</p><ul>\n<li>第1个逻辑：根据给定时间区间，从数据库中拉取数据。这部分逻辑已经被封装在MetricsStorage类中了，所以这部分不需要处理。</li>\n<li>第2个逻辑：根据原始数据，计算得到统计数据。我们可以将这部分逻辑移动到Aggregator类中。这样Aggregator类就不仅仅是只包含统计方法的工具类了。按照这个思路，重构之后的代码如下所示：</li>\n</ul><pre><code>public class Aggregator {\n  public Map&lt;String, RequestStat&gt; aggregate(\n          Map&lt;String, List&lt;RequestInfo&gt;&gt; requestInfos, long durationInMillis) {\n    Map&lt;String, RequestStat&gt; requestStats = new HashMap&lt;&gt;();\n    for (Map.Entry&lt;String, List&lt;RequestInfo&gt;&gt; entry : requestInfos.entrySet()) {\n      String apiName = entry.getKey();\n      List&lt;RequestInfo&gt; requestInfosPerApi = entry.getValue();\n      RequestStat requestStat = doAggregate(requestInfosPerApi, durationInMillis);\n      requestStats.put(apiName, requestStat);\n    }\n    return requestStats;\n  }\n\n  private RequestStat doAggregate(List&lt;RequestInfo&gt; requestInfos, long durationInMillis) {\n    List&lt;Double&gt; respTimes = new ArrayList&lt;&gt;();\n    for (RequestInfo requestInfo : requestInfos) {\n      double respTime = requestInfo.getResponseTime();\n      respTimes.add(respTime);\n    }\n\n    RequestStat requestStat = new RequestStat();\n    requestStat.setMaxResponseTime(max(respTimes));\n    requestStat.setMinResponseTime(min(respTimes));\n    requestStat.setAvgResponseTime(avg(respTimes));\n    requestStat.setP999ResponseTime(percentile999(respTimes));\n    requestStat.setP99ResponseTime(percentile99(respTimes));\n    requestStat.setCount(respTimes.size());\n    requestStat.setTps((long) tps(respTimes.size(), durationInMillis/1000));\n    return requestStat;\n  }\n\n  // 以下的函数的代码实现均省略...\n  private double max(List&lt;Double&gt; dataset) {}\n  private double min(List&lt;Double&gt; dataset) {}\n  private double avg(List&lt;Double&gt; dataset) {}\n  private double tps(int count, double duration) {}\n  private double percentile999(List&lt;Double&gt; dataset) {}\n  private double percentile99(List&lt;Double&gt; dataset) {}\n  private double percentile(List&lt;Double&gt; dataset, double ratio) {}\n}\n</code></pre><ul>\n<li>第3个逻辑：将统计数据显示到终端。我们将这部分逻辑剥离出来，设计成两个类：ConsoleViewer类和EmailViewer类，分别负责将统计结果显示到命令行和邮件中。具体的代码实现如下所示：</li>\n</ul><pre><code>public interface StatViewer {\n  void output(Map&lt;String, RequestStat&gt; requestStats, long startTimeInMillis, long endTimeInMills);\n}\n\npublic class ConsoleViewer implements StatViewer {\n  public void output(\n          Map&lt;String, RequestStat&gt; requestStats, long startTimeInMillis, long endTimeInMills) {\n    System.out.println(&quot;Time Span: [&quot; + startTimeInMillis + &quot;, &quot; + endTimeInMills + &quot;]&quot;);\n    Gson gson = new Gson();\n    System.out.println(gson.toJson(requestStats));\n  }\n}\n\npublic class EmailViewer implements StatViewer {\n  private EmailSender emailSender;\n  private List&lt;String&gt; toAddresses = new ArrayList&lt;&gt;();\n\n  public EmailViewer() {\n    this.emailSender = new EmailSender(/*省略参数*/);\n  }\n\n  public EmailViewer(EmailSender emailSender) {\n    this.emailSender = emailSender;\n  }\n\n  public void addToAddress(String address) {\n    toAddresses.add(address);\n  }\n\n  public void output(\n          Map&lt;String, RequestStat&gt; requestStats, long startTimeInMillis, long endTimeInMills) {\n    // format the requestStats to HTML style.\n    // send it to email toAddresses.\n  }\n}\n</code></pre><ul>\n<li>第4个逻辑：组装类并定时触发执行统计显示。在将核心逻辑剥离出来之后，这个类的代码变得更加简洁、清晰，只负责组装各个类（MetricsStorage、Aggegrator、StatViewer）来完成整个工作流程。重构之后的代码如下所示：</li>\n</ul><pre><code>public class ConsoleReporter {\n  private MetricsStorage metricsStorage;\n  private Aggregator aggregator;\n  private StatViewer viewer;\n  private ScheduledExecutorService executor;\n\n  public ConsoleReporter(MetricsStorage metricsStorage, Aggregator aggregator, StatViewer viewer) {\n    this.metricsStorage = metricsStorage;\n    this.aggregator = aggregator;\n    this.viewer = viewer;\n    this.executor = Executors.newSingleThreadScheduledExecutor();\n  }\n\n  public void startRepeatedReport(long periodInSeconds, long durationInSeconds) {\n    executor.scheduleAtFixedRate(new Runnable() {\n      @Override\n      public void run() {\n        long durationInMillis = durationInSeconds * 1000;\n        long endTimeInMillis = System.currentTimeMillis();\n        long startTimeInMillis = endTimeInMillis - durationInMillis;\n        Map&lt;String, List&lt;RequestInfo&gt;&gt; requestInfos =\n                metricsStorage.getRequestInfos(startTimeInMillis, endTimeInMillis);\n        Map&lt;String, RequestStat&gt; requestStats = aggregator.aggregate(requestInfos, durationInMillis);\n        viewer.output(requestStats, startTimeInMillis, endTimeInMillis);\n      }\n    }, 0L, periodInSeconds, TimeUnit.SECONDS);\n  }\n\n}\n\npublic class EmailReporter {\n  private static final Long DAY_HOURS_IN_SECONDS = 86400L;\n\n  private MetricsStorage metricsStorage;\n  private Aggregator aggregator;\n  private StatViewer viewer;\n\n  public EmailReporter(MetricsStorage metricsStorage, Aggregator aggregator, StatViewer viewer) {\n    this.metricsStorage = metricsStorage;\n    this.aggregator = aggregator;\n    this.viewer = viewer;\n  }\n\n  public void startDailyReport() {\n    Calendar calendar = Calendar.getInstance();\n    calendar.add(Calendar.DATE, 1);\n    calendar.set(Calendar.HOUR_OF_DAY, 0);\n    calendar.set(Calendar.MINUTE, 0);\n    calendar.set(Calendar.SECOND, 0);\n    calendar.set(Calendar.MILLISECOND, 0);\n    Date firstTime = calendar.getTime();\n    Timer timer = new Timer();\n    timer.schedule(new TimerTask() {\n      @Override\n      public void run() {\n        long durationInMillis = DAY_HOURS_IN_SECONDS * 1000;\n        long endTimeInMillis = System.currentTimeMillis();\n        long startTimeInMillis = endTimeInMillis - durationInMillis;\n        Map&lt;String, List&lt;RequestInfo&gt;&gt; requestInfos =\n                metricsStorage.getRequestInfos(startTimeInMillis, endTimeInMillis);\n        Map&lt;String, RequestStat&gt; stats = aggregator.aggregate(requestInfos, durationInMillis);\n        viewer.output(stats, startTimeInMillis, endTimeInMillis);\n      }\n    }, firstTime, DAY_HOURS_IN_SECONDS * 1000);\n  }\n} \n</code></pre><p>经过上面的重构之后，我们现在再来看一下，现在框架该如何来使用。</p><p>我们需要在应用启动的时候，创建好ConsoleReporter对象，并且调用它的startRepeatedReport()函数，来启动定时统计并输出数据到终端。同理，我们还需要创建好EmailReporter对象，并且调用它的startDailyReport()函数，来启动每日统计并输出数据到制定邮件地址。我们通过MetricsCollector类来收集接口的访问情况，这部分收集代码会跟业务逻辑代码耦合在一起，或者统一放到类似Spring AOP的切面中完成。具体的使用代码示例如下：</p><pre><code>public class PerfCounterTest {\n  public static void main(String[] args) {\n    MetricsStorage storage = new RedisMetricsStorage();\n    Aggregator aggregator = new Aggregator();\n\n    // 定时触发统计并将结果显示到终端\n    ConsoleViewer consoleViewer = new ConsoleViewer();\n    ConsoleReporter consoleReporter = new ConsoleReporter(storage, aggregator, consoleViewer);\n    consoleReporter.startRepeatedReport(60, 60);\n\n    // 定时触发统计并将结果输出到邮件\n    EmailViewer emailViewer = new EmailViewer();\n    emailViewer.addToAddress(&quot;wangzheng@xzg.com&quot;);\n    EmailReporter emailReporter = new EmailReporter(storage, aggregator, emailViewer);\n    emailReporter.startDailyReport();\n\n    // 收集接口访问数据\n    MetricsCollector collector = new MetricsCollector(storage);\n    collector.recordRequest(new RequestInfo(&quot;register&quot;, 123, 10234));\n    collector.recordRequest(new RequestInfo(&quot;register&quot;, 223, 11234));\n    collector.recordRequest(new RequestInfo(&quot;register&quot;, 323, 12334));\n    collector.recordRequest(new RequestInfo(&quot;login&quot;, 23, 12434));\n    collector.recordRequest(new RequestInfo(&quot;login&quot;, 1223, 14234));\n\n    try {\n      Thread.sleep(100000);\n    } catch (InterruptedException e) {\n      e.printStackTrace();\n    }\n  }\n}\n</code></pre><h2>Review版本2的设计与实现</h2><p>现在，我们Review一下，针对版本1重构之后，版本2的设计与实现。</p><p>重构之后，MetricsStorage负责存储，Aggregator负责统计，StatViewer（ConsoleViewer、EmailViewer）负责显示，三个类各司其职。ConsoleReporter和EmailReporter负责组装这三个类，将获取原始数据、聚合统计、显示统计结果到终端这三个阶段的工作串联起来，定时触发执行。</p><p>除此之外，MetricsStorage、Aggregator、StatViewer三个类的设计也符合迪米特法则。它们只与跟自己有直接相关的数据进行交互。MetricsStorage输出的是RequestInfo相关数据。Aggregator类输入的是RequestInfo数据，输出的是RequestStat数据。StatViewer输入的是RequestStat数据。</p><p>针对版本1和版本2，我画了一张它们的类之间依赖关系的对比图，如下所示。从图中，我们可以看出，重构之后的代码结构更加清晰、有条理。这也印证了之前提到的：面向对象设计和实现要做的事情，就是把合适的代码放到合适的类中。</p><p><img src=\"https://static001.geekbang.org/resource/image/13/34/1303d16f75c7266cef9105f540c54834.jpg\" alt=\"\"></p><p>刚刚我们分析了代码的整体结构和依赖关系，我们现在再来具体看每个类的设计。</p><p>Aggregator类从一个只包含一个静态函数的工具类，变成了一个普通的聚合统计类。现在，我们可以通过依赖注入的方式，将其组装进ConsoleReporter和EmailReporter类中，这样就更加容易编写单元测试。</p><p>Aggregator类在重构前，所有的逻辑都集中在aggregate()函数内，代码行数较多，代码的可读性和可维护性较差。在重构之后，我们将每个统计逻辑拆分成独立的函数，aggregate()函数变得比较单薄，可读性提高了。尽管我们要添加新的统计功能，还是要修改aggregate()函数，但现在的aggregate()函数代码行数很少，结构非常清晰，修改起来更加容易，可维护性提高。</p><p>目前来看，Aggregator的设计还算合理。但是，如果随着更多的统计功能的加入，Aggregator类的代码会越来越多。这个时候，我们可以将统计函数剥离出来，设计成独立的类，以解决Aggregator类的无限膨胀问题。不过，暂时来说没有必要这么做，毕竟将每个统计函数独立成类，会增加类的个数，也会影响到代码的可读性和可维护性。</p><p>ConsoleReporter和EmailReporter经过重构之后，代码的重复问题变小了，但仍然没有完全解决。尽管这两个类不再调用Aggregator的静态方法，但因为涉及多线程和时间相关的计算，代码的测试性仍然不够好。这两个问题我们留在下一节课中解决，你也可以留言说说的你解决方案。</p><h2>重点回顾</h2><p>好了，今天的内容到此就讲完了。我们一块来总结回顾一下，你需要掌握的重点内容。</p><p>面向对象设计中的最后一步是组装类并提供执行入口，也就是上帝类要做的事情。这个上帝类是没办法去掉的，但我们可以将上帝类做得很轻量级，把核心逻辑都剥离出去，下沉形成独立的类。上帝类只负责组装类和串联执行流程。这样做的好处是，代码结构更加清晰，底层核心逻辑更容易被复用。</p><p>面向对象设计和实现要做的事情，就是把合适的代码放到合适的类中。当我们要实现某个功能的时候，不管如何设计，所需要编写的代码量基本上是一样的，唯一的区别就是如何将这些代码划分到不同的类中。不同的人有不同的划分方法，对应得到的代码结构（比如类与类之间交互等）也不尽相同。</p><p>好的设计一定是结构清晰、有条理、逻辑性强，看起来一目了然，读完之后常常有一种原来如此的感觉。差的设计往往逻辑、代码乱塞一通，没有什么设计思路可言，看起来莫名其妙，读完之后一头雾水。</p><h2>课堂讨论</h2><ol>\n<li>今天我们提到，重构之后的ConsoleReporter和EmailReporter仍然存在代码重复和可测试性差的问题，你可以思考一下，应该如何解决呢？</li>\n<li>从上面的使用示例中，我们可以看出，框架易用性有待提高：ConsoleReporter和EmailReporter的创建过程比较复杂，使用者需要正确地组装各种类才行。对于框架的易用性，你有没有什么办法改善一下呢？</li>\n</ol><p>欢迎在留言区写下你的思考和想法，和同学一起交流和分享。如果有收获，也欢迎你把这篇文章分享给你的朋友。</p>",
                "article_title": "39 | 运用学过的设计原则和思想完善之前讲的性能计数器项目（上）"
            },
            {
                "title": "40 | 运用学过的设计原则和思想完善之前讲的性能计数器项目（下）",
                "herf": "https://time.geekbang.org/column/article/193555",
                "id": "193555",
                "content": "<p>上一节课中，我们针对版本1存在的问题（特别是Aggregator类、ConsoleReporter和EmailReporter类）进行了重构优化。经过重构之后，代码结构更加清晰、合理、有逻辑性。不过，在细节方面还是存在一些问题，比如ConsoleReporter、EmailReporter类仍然存在代码重复、可测试性差的问题。今天，我们就在版本3中持续重构这部分代码。</p><p>除此之外，在版本3中，我们还会继续完善框架的功能和非功能需求。比如，让原始数据的采集和存储异步执行，解决聚合统计在数据量大的情况下会导致内存吃紧问题，以及提高框架的易用性等，让它成为一个能用且好用的框架。</p><p>话不多说，让我们正式开始版本3的设计与实现吧！</p><h2>代码重构优化</h2><p>我们知道，继承能解决代码重复的问题。我们可以将ConsoleReporter和EmailReporter中的相同代码逻辑，提取到父类ScheduledReporter中，以解决代码重复问题。按照这个思路，重构之后的代码如下所示：</p><pre><code>public abstract class ScheduledReporter {\n  protected MetricsStorage metricsStorage;\n  protected Aggregator aggregator;\n  protected StatViewer viewer;\n\n  public ScheduledReporter(MetricsStorage metricsStorage, Aggregator aggregator, StatViewer viewer) {\n    this.metricsStorage = metricsStorage;\n    this.aggregator = aggregator;\n    this.viewer = viewer;\n  }\n\n  protected void doStatAndReport(long startTimeInMillis, long endTimeInMillis) {\n    long durationInMillis = endTimeInMillis -  startTimeInMillis;\n    Map&lt;String, List&lt;RequestInfo&gt;&gt; requestInfos =\n            metricsStorage.getRequestInfos(startTimeInMillis, endTimeInMillis);\n    Map&lt;String, RequestStat&gt; requestStats = aggregator.aggregate(requestInfos, durationInMillis);\n    viewer.output(requestStats, startTimeInMillis, endTimeInMillis);\n  }\n\n}\n</code></pre><p>ConsoleReporter和EmailReporter代码重复的问题解决了，那我们再来看一下代码的可测试性问题。因为ConsoleReporter和EmailReporter的代码比较相似，且EmailReporter的代码更复杂些，所以，关于如何重构来提高其可测试性，我们拿EmailReporter来举例说明。将重复代码提取到父类ScheduledReporter之后，EmailReporter代码如下所示：</p><!-- [[[read_end]]] --><pre><code>public class EmailReporter extends ScheduledReporter {\n  private static final Long DAY_HOURS_IN_SECONDS = 86400L;\n\n  private MetricsStorage metricsStorage;\n  private Aggregator aggregator;\n  private StatViewer viewer;\n\n  public EmailReporter(MetricsStorage metricsStorage, Aggregator aggregator, StatViewer viewer) {\n    this.metricsStorage = metricsStorage;\n    this.aggregator = aggregator;\n    this.viewer = viewer;\n  }\n\n  public void startDailyReport() {\n    Calendar calendar = Calendar.getInstance();\n    calendar.add(Calendar.DATE, 1);\n    calendar.set(Calendar.HOUR_OF_DAY, 0);\n    calendar.set(Calendar.MINUTE, 0);\n    calendar.set(Calendar.SECOND, 0);\n    calendar.set(Calendar.MILLISECOND, 0);\n    Date firstTime = calendar.getTime();\n\n    Timer timer = new Timer();\n    timer.schedule(new TimerTask() {\n      @Override\n      public void run() {\n        long durationInMillis = DAY_HOURS_IN_SECONDS * 1000;\n        long endTimeInMillis = System.currentTimeMillis();\n        long startTimeInMillis = endTimeInMillis - durationInMillis;\n        doStatAndReport(startTimeInMillis, endTimeInMillis);\n      }\n    }, firstTime, DAY_HOURS_IN_SECONDS * 1000);\n  }\n}\n</code></pre><p>前面提到，之所以EmailReporter可测试性不好，一方面是因为用到了线程（定时器也相当于多线程），另一方面是因为涉及时间的计算逻辑。</p><p>实际上，在经过上一步的重构之后，EmailReporter中的startDailyReport()函数的核心逻辑已经被抽离出去了，较复杂的、容易出bug的就只剩下计算firstTime的那部分代码了。我们可以将这部分代码继续抽离出来，封装成一个函数，然后，单独针对这个函数写单元测试。重构之后的代码如下所示：</p><pre><code>public class EmailReporter extends ScheduledReporter {\n  // 省略其他代码...\n  public void startDailyReport() {\n    Date firstTime = trimTimeFieldsToZeroOfNextDay();\n    Timer timer = new Timer();\n    timer.schedule(new TimerTask() {\n      @Override\n      public void run() {\n        // 省略其他代码...\n      }\n    }, firstTime, DAY_HOURS_IN_SECONDS * 1000);\n  }\n\n  // 设置成protected而非private是为了方便写单元测试\n  @VisibleForTesting\n  protected Date trimTimeFieldsToZeroOfNextDay() {\n    Calendar calendar = Calendar.getInstance(); // 这里可以获取当前时间\n    calendar.add(Calendar.DATE, 1);\n    calendar.set(Calendar.HOUR_OF_DAY, 0);\n    calendar.set(Calendar.MINUTE, 0);\n    calendar.set(Calendar.SECOND, 0);\n    calendar.set(Calendar.MILLISECOND, 0);\n    return calendar.getTime();\n  }\n}\n</code></pre><p>简单的代码抽离成trimTimeFieldsToZeroOfNextDay()函数之后，虽然代码更加清晰了，一眼就能从名字上知道这段代码的意图（获取当前时间的下一天的0点时间），但我们发现这个函数的可测试性仍然不好，因为它强依赖当前的系统时间。实际上，这个问题挺普遍的。一般的解决方法是，将强依赖的部分通过参数传递进来，这有点类似我们之前讲的依赖注入。按照这个思路，我们再对trimTimeFieldsToZeroOfNextDay()函数进行重构。重构之后的代码如下所示：</p><pre><code>public class EmailReporter extends ScheduledReporter {\n  // 省略其他代码...\n  public void startDailyReport() {\n    // new Date()可以获取当前时间\n    Date firstTime = trimTimeFieldsToZeroOfNextDay(new Date());\n    Timer timer = new Timer();\n    timer.schedule(new TimerTask() {\n      @Override\n      public void run() {\n        // 省略其他代码...\n      }\n    }, firstTime, DAY_HOURS_IN_SECONDS * 1000);\n  }\n\n  protected Date trimTimeFieldsToZeroOfNextDay(Date date) {\n    Calendar calendar = Calendar.getInstance(); // 这里可以获取当前时间\n    calendar.setTime(date); // 重新设置时间\n    calendar.add(Calendar.DATE, 1);\n    calendar.set(Calendar.HOUR_OF_DAY, 0);\n    calendar.set(Calendar.MINUTE, 0);\n    calendar.set(Calendar.SECOND, 0);\n    calendar.set(Calendar.MILLISECOND, 0);\n    return calendar.getTime();\n  }\n}\n</code></pre><p>经过这次重构之后，trimTimeFieldsToZeroOfNextDay()函数不再强依赖当前的系统时间，所以非常容易对其编写单元测试。你可以把它作为练习，写一下这个函数的单元测试。</p><p>不过，EmailReporter类中startDailyReport()还是涉及多线程，针对这个函数该如何写单元测试呢？我的看法是，这个函数不需要写单元测试。为什么这么说呢？我们可以回到写单元测试的初衷来分析这个问题。单元测试是为了提高代码质量，减少bug。如果代码足够简单，简单到bug无处隐藏，那我们就没必要为了写单元测试而写单元测试，或者为了追求单元测试覆盖率而写单元测试。经过多次代码重构之后，startDailyReport()函数里面已经没有多少代码逻辑了，所以，完全没必要对它写单元测试了。</p><h2>功能需求完善</h2><p>经过了多个版本的迭代、重构，我们现在来重新Review一下，目前的设计与实现是否已经完全满足第25讲中最初的功能需求了。</p><p>最初的功能需求描述是下面这个样子的，我们来重新看一下。</p><blockquote>\n<p>我们希望设计开发一个小的框架，能够获取接口调用的各种统计信息，比如响应时间的最大值（max）、最小值（min）、平均值（avg）、百分位值（percentile），接口调用次数（count）、频率（tps） 等，并且支持将统计结果以各种显示格式（比如：JSON格式、网页格式、自定义显示格式等）输出到各种终端（Console命令行、HTTP网页、Email、日志文件、自定义输出终端等），以方便查看。</p>\n</blockquote><p>经过整理拆解之后的需求列表如下所示：</p><blockquote>\n<p>接口统计信息：包括接口响应时间的统计信息，以及接口调用次数的统计信息等。<br>\n统计信息的类型：max、min、avg、percentile、count、tps等。<br>\n统计信息显示格式：JSON、HTML、自定义显示格式。<br>\n统计信息显示终端：Console、Email、HTTP网页、日志、自定义显示终端。</p>\n</blockquote><p>经过挖掘，我们还得到一些隐藏的需求，如下所示：</p><blockquote>\n<p>统计触发方式：包括主动和被动两种。主动表示以一定的频率定时统计数据，并主动推送到显示终端，比如邮件推送。被动表示用户触发统计，比如用户在网页中选择要统计的时间区间，触发统计，并将结果显示给用户。</p>\n</blockquote><blockquote>\n<p>统计时间区间：框架需要支持自定义统计时间区间，比如统计最近10分钟的某接口的tps、访问次数，或者统计12月11日00点到12月12日00点之间某接口响应时间的最大值、最小值、平均值等。</p>\n</blockquote><blockquote>\n<p>统计时间间隔：对于主动触发统计，我们还要支持指定统计时间间隔，也就是多久触发一次统计显示。比如，每间隔10s统计一次接口信息并显示到命令行中，每间隔24小时发送一封统计信息邮件。</p>\n</blockquote><p>版本3已经实现了大部分的功能，还有以下几个小的功能点没有实现。你可以将这些还没有实现的功能，自己实现一下，继续迭代出框架的第4个版本。</p><ul>\n<li>被动触发统计的方式，也就是需求中提到的通过网页展示统计信息。实际上，这部分代码的实现也并不难。我们可以复用框架现在的代码，编写一些展示页面和提供获取统计数据的接口即可。</li>\n<li>对于自定义显示终端，比如显示数据到自己开发的监控平台，这就有点类似通过网页来显示数据，不过更加简单些，只需要提供一些获取统计数据的接口，监控平台通过这些接口拉取数据来显示即可。</li>\n<li>自定义显示格式。在框架现在的代码实现中，显示格式和显示终端（比如Console、Email）是紧密耦合在一起的，比如，Console只能通过JSON格式来显示统计数据，Email只能通过某种固定的HTML格式显示数据，这样的设计还不够灵活。我们可以将显示格式设计成独立的类，将显示终端和显示格式的代码分离，让显示终端支持配置不同的显示格式。具体的代码实现留给你自己思考，我这里就不多说了。</li>\n</ul><h2>非功能需求完善</h2><p>Review完了功能需求的完善程度，现在，我们再来看，版本3的非功能性需求的完善程度。在第25讲中，我们提到，针对这个框架的开发，我们需要考虑的非功能性需求包括：易用性、性能、扩展性、容错性、通用性。我们现在就依次来看一下这几个方面。</p><h3>1.易用性</h3><p>所谓的易用性，顾名思义，就是框架是否好用。框架的使用者将框架集成到自己的系统中时，主要用到MetricsCollector和EmailReporter、ConsoleReporter这几个类。通过MetricsCollector类来采集数据，通过EmailReporter、ConsoleReporter类来触发主动统计数据、显示统计结果。示例代码如下所示：</p><pre><code>public class PerfCounterTest {\n  public static void main(String[] args) {\n    MetricsStorage storage = new RedisMetricsStorage();\n    Aggregator aggregator = new Aggregator();\n\n    // 定时触发统计并将结果显示到终端\n    ConsoleViewer consoleViewer = new ConsoleViewer();\n    ConsoleReporter consoleReporter = new ConsoleReporter(storage, aggregator, consoleViewer);\n    consoleReporter.startRepeatedReport(60, 60);\n    \n    // 定时触发统计并将结果输出到邮件\n    EmailViewer emailViewer = new EmailViewer();\n    emailViewer.addToAddress(&quot;wangzheng@xzg.com&quot;);\n    EmailReporter emailReporter = new EmailReporter(storage, aggregator, emailViewer);\n    emailReporter.startDailyReport();\n\n    // 收集接口访问数据\n    MetricsCollector collector = new MetricsCollector(storage);\n    collector.recordRequest(new RequestInfo(&quot;register&quot;, 123, 10234));\n    collector.recordRequest(new RequestInfo(&quot;register&quot;, 223, 11234));\n    collector.recordRequest(new RequestInfo(&quot;register&quot;, 323, 12334));\n    collector.recordRequest(new RequestInfo(&quot;login&quot;, 23, 12434));\n    collector.recordRequest(new RequestInfo(&quot;login&quot;, 1223, 14234));\n\n    try {\n      Thread.sleep(100000);\n    } catch (InterruptedException e) {\n      e.printStackTrace();\n    }\n  }\n}\n</code></pre><p>从上面的使用示例中，我们可以看出，框架用起来还是稍微有些复杂的，需要组装各种类，比如需要创建MetricsStorage对象、Aggregator对象、ConsoleViewer对象，然后注入到ConsoleReporter中，才能使用ConsoleReporter。除此之外，还有可能存在误用的情况，比如把EmailViewer传递进了ConsoleReporter中。总体上来讲，框架的使用方式暴露了太多细节给用户，过于灵活也带来了易用性的降低。</p><p>为了让框架用起来更加简单（能将组装的细节封装在框架中，不暴露给框架使用者），又不失灵活性（可以自由组装不同的MetricsStorage实现类、StatViewer实现类到ConsoleReporter或EmailReporter），也不降低代码的可测试性（通过依赖注入来组装类，方便在单元测试中mock），我们可以额外地提供一些封装了默认依赖的构造函数，让使用者自主选择使用哪种构造函数来构造对象。这段话理解起来有点复杂，我把按照这个思路重构之后的代码放到了下面，你可以结合着一块看一下。</p><pre><code>public class MetricsCollector {\n  private MetricsStorage metricsStorage;\n\n  // 兼顾代码的易用性，新增一个封装了默认依赖的构造函数\n  public MetricsCollectorB() {\n    this(new RedisMetricsStorage());\n  }\n\n  // 兼顾灵活性和代码的可测试性，这个构造函数继续保留\n  public MetricsCollectorB(MetricsStorage metricsStorage) {\n    this.metricsStorage = metricsStorage;\n  }\n  // 省略其他代码...\n}\n\npublic class ConsoleReporter extends ScheduledReporter {\n  private ScheduledExecutorService executor;\n  \n  // 兼顾代码的易用性，新增一个封装了默认依赖的构造函数\n  public ConsoleReporter() {\n    this(new RedisMetricsStorage(), new Aggregator(), new ConsoleViewer());\n  }\n\n  // 兼顾灵活性和代码的可测试性，这个构造函数继续保留\n  public ConsoleReporter(MetricsStorage metricsStorage, Aggregator aggregator, StatViewer viewer) {\n    super(metricsStorage, aggregator, viewer);\n    this.executor = Executors.newSingleThreadScheduledExecutor();\n  }\n  // 省略其他代码...\n}\n\npublic class EmailReporter extends ScheduledReporter {\n  private static final Long DAY_HOURS_IN_SECONDS = 86400L;\n\n  // 兼顾代码的易用性，新增一个封装了默认依赖的构造函数\n  public EmailReporter(List&lt;String&gt; emailToAddresses) {\n    this(new RedisMetricsStorage(), new Aggregator(), new EmailViewer(emailToAddresses));\n  }\n  \n  // 兼顾灵活性和代码的可测试性，这个构造函数继续保留\n  public EmailReporter(MetricsStorage metricsStorage, Aggregator aggregator, StatViewer viewer) {\n    super(metricsStorage, aggregator, viewer);\n  }\n  // 省略其他代码...\n}\n</code></pre><p>现在，我们再来看下框架如何来使用。具体使用示例如下所示。看起来是不是简单多了呢？</p><pre><code>public class PerfCounterTest {\n  public static void main(String[] args) {\n    ConsoleReporter consoleReporter = new ConsoleReporter();\n    consoleReporter.startRepeatedReport(60, 60);\n\n    List&lt;String&gt; emailToAddresses = new ArrayList&lt;&gt;();\n    emailToAddresses.add(&quot;wangzheng@xzg.com&quot;);\n    EmailReporter emailReporter = new EmailReporter(emailToAddresses);\n    emailReporter.startDailyReport();\n\n    MetricsCollector collector = new MetricsCollector();\n    collector.recordRequest(new RequestInfo(&quot;register&quot;, 123, 10234));\n    collector.recordRequest(new RequestInfo(&quot;register&quot;, 223, 11234));\n    collector.recordRequest(new RequestInfo(&quot;register&quot;, 323, 12334));\n    collector.recordRequest(new RequestInfo(&quot;login&quot;, 23, 12434));\n    collector.recordRequest(new RequestInfo(&quot;login&quot;, 1223, 14234));\n\n    try {\n      Thread.sleep(100000);\n    } catch (InterruptedException e) {\n      e.printStackTrace();\n    }\n  }\n}\n</code></pre><p>如果你足够细心，可能已经发现，RedisMeticsStorage和EmailViewer还需要另外一些配置信息才能构建成功，比如Redis的地址，Email邮箱的POP3服务器地址、发送地址。这些配置并没有在刚刚代码中体现到，那我们该如何获取呢？</p><p>我们可以将这些配置信息放到配置文件中，在框架启动的时候，读取配置文件中的配置信息到一个Configuration单例类。RedisMetricsStorage类和EmailViewer类都可以从这个Configuration类中获取需要的配置信息来构建自己。</p><h3>2.性能</h3><p>对于需要集成到业务系统的框架来说，我们不希望框架本身代码的执行效率，对业务系统有太多性能上的影响。对于性能计数器这个框架来说，一方面，我们希望它是低延迟的，也就是说，统计代码不影响或很少影响接口本身的响应时间；另一方面，我们希望框架本身对内存的消耗不能太大。</p><p>对于性能这一点，落实到具体的代码层面，需要解决两个问题，也是我们之前提到过的，一个是采集和存储要异步来执行，因为存储基于外部存储（比如Redis），会比较慢，异步存储可以降低对接口响应时间的影响。另一个是当需要聚合统计的数据量比较大的时候，一次性加载太多的数据到内存，有可能会导致内存吃紧，甚至内存溢出，这样整个系统都会瘫痪掉。</p><p>针对第一个问题，我们通过在MetricsCollector中引入Google Guava EventBus来解决。实际上，我们可以把EventBus看作一个“生产者-消费者”模型或者“发布-订阅”模型，采集的数据先放入内存共享队列中，另一个线程读取共享队列中的数据，写入到外部存储（比如Redis）中。具体的代码实现如下所示：</p><pre><code>public class MetricsCollector {\n  private static final int DEFAULT_STORAGE_THREAD_POOL_SIZE = 20;\n\n  private MetricsStorage metricsStorage;\n  private EventBus eventBus;\n\n  public MetricsCollector(MetricsStorage metricsStorage) {\n    this(metricsStorage, DEFAULT_STORAGE_THREAD_POOL_SIZE);\n  }\n\n  public MetricsCollector(MetricsStorage metricsStorage, int threadNumToSaveData) {\n    this.metricsStorage = metricsStorage;\n    this.eventBus = new AsyncEventBus(Executors.newFixedThreadPool(threadNumToSaveData));\n    this.eventBus.register(new EventListener());\n  }\n\n  public void recordRequest(RequestInfo requestInfo) {\n    if (requestInfo == null || StringUtils.isBlank(requestInfo.getApiName())) {\n      return;\n    }\n    eventBus.post(requestInfo);\n  }\n\n  public class EventListener {\n    @Subscribe\n    public void saveRequestInfo(RequestInfo requestInfo) {\n      metricsStorage.saveRequestInfo(requestInfo);\n    }\n  }\n}\n</code></pre><p>针对第二个问题，解决的思路比较简单，但代码实现稍微有点复杂。当统计的时间间隔较大的时候，需要统计的数据量就会比较大。我们可以将其划分为一些小的时间区间（比如10分钟作为一个统计单元），针对每个小的时间区间分别进行统计，然后将统计得到的结果再进行聚合，得到最终整个时间区间的统计结果。不过，这个思路只适合响应时间的max、min、avg，及其接口请求count、tps的统计，对于响应时间的percentile的统计并不适用。</p><p>对于percentile的统计要稍微复杂一些，具体的解决思路是这样子的：我们分批从Redis中读取数据，然后存储到文件中，再根据响应时间从小到大利用外部排序算法来进行排序（具体的实现方式可以看一下《数据结构与算法之美》专栏）。排序完成之后，再从文件中读取第count*percentile（count表示总的数据个数，percentile就是百分比，99百分位就是0.99）个数据，就是对应的percentile响应时间。</p><p>这里我只给出了除了percentile之外的统计信息的计算代码，如下所示。对于percentile的计算，因为代码量比较大，留给你自己实现。</p><pre><code>public class ScheduleReporter {\n  private static final long MAX_STAT_DURATION_IN_MILLIS = 10 * 60 * 1000; // 10minutes\n\n  protected MetricsStorage metricsStorage;\n  protected Aggregator aggregator;\n  protected StatViewer viewer;\n\n  public ScheduleReporter(MetricsStorage metricsStorage, Aggregator aggregator, StatViewer viewer) {\n    this.metricsStorage = metricsStorage;\n    this.aggregator = aggregator;\n    this.viewer = viewer;\n  }\n\n  protected void doStatAndReport(long startTimeInMillis, long endTimeInMillis) {\n    Map&lt;String, RequestStat&gt; stats = doStat(startTimeInMillis, endTimeInMillis);\n    viewer.output(stats, startTimeInMillis, endTimeInMillis);\n  }\n\n  private Map&lt;String, RequestStat&gt; doStat(long startTimeInMillis, long endTimeInMillis) {\n    Map&lt;String, List&lt;RequestStat&gt;&gt; segmentStats = new HashMap&lt;&gt;();\n    long segmentStartTimeMillis = startTimeInMillis;\n    while (segmentStartTimeMillis &lt; endTimeInMillis) {\n      long segmentEndTimeMillis = segmentStartTimeMillis + MAX_STAT_DURATION_IN_MILLIS;\n      if (segmentEndTimeMillis &gt; endTimeInMillis) {\n        segmentEndTimeMillis = endTimeInMillis;\n      }\n      Map&lt;String, List&lt;RequestInfo&gt;&gt; requestInfos =\n              metricsStorage.getRequestInfos(segmentStartTimeMillis, segmentEndTimeMillis);\n      if (requestInfos == null || requestInfos.isEmpty()) {\n        continue;\n      }\n      Map&lt;String, RequestStat&gt; segmentStat = aggregator.aggregate(\n              requestInfos, segmentEndTimeMillis - segmentStartTimeMillis);\n      addStat(segmentStats, segmentStat);\n      segmentStartTimeMillis += MAX_STAT_DURATION_IN_MILLIS;\n    }\n\n    long durationInMillis = endTimeInMillis - startTimeInMillis;\n    Map&lt;String, RequestStat&gt; aggregatedStats = aggregateStats(segmentStats, durationInMillis);\n    return aggregatedStats;\n  }\n\n  private void addStat(Map&lt;String, List&lt;RequestStat&gt;&gt; segmentStats,\n                       Map&lt;String, RequestStat&gt; segmentStat) {\n    for (Map.Entry&lt;String, RequestStat&gt; entry : segmentStat.entrySet()) {\n      String apiName = entry.getKey();\n      RequestStat stat = entry.getValue();\n      List&lt;RequestStat&gt; statList = segmentStats.putIfAbsent(apiName, new ArrayList&lt;&gt;());\n      statList.add(stat);\n    }\n  }\n\n  private Map&lt;String, RequestStat&gt; aggregateStats(Map&lt;String, List&lt;RequestStat&gt;&gt; segmentStats,\n                                                  long durationInMillis) {\n    Map&lt;String, RequestStat&gt; aggregatedStats = new HashMap&lt;&gt;();\n    for (Map.Entry&lt;String, List&lt;RequestStat&gt;&gt; entry : segmentStats.entrySet()) {\n      String apiName = entry.getKey();\n      List&lt;RequestStat&gt; apiStats = entry.getValue();\n      double maxRespTime = Double.MIN_VALUE;\n      double minRespTime = Double.MAX_VALUE;\n      long count = 0;\n      double sumRespTime = 0;\n      for (RequestStat stat : apiStats) {\n        if (stat.getMaxResponseTime() &gt; maxRespTime) maxRespTime = stat.getMaxResponseTime();\n        if (stat.getMinResponseTime() &lt; minRespTime) minRespTime = stat.getMinResponseTime();\n        count += stat.getCount();\n        sumRespTime += (stat.getCount() * stat.getAvgResponseTime());\n      }\n      RequestStat aggregatedStat = new RequestStat();\n      aggregatedStat.setMaxResponseTime(maxRespTime);\n      aggregatedStat.setMinResponseTime(minRespTime);\n      aggregatedStat.setAvgResponseTime(sumRespTime / count);\n      aggregatedStat.setCount(count);\n      aggregatedStat.setTps(count / durationInMillis * 1000);\n      aggregatedStats.put(apiName, aggregatedStat);\n    }\n    return aggregatedStats;\n  }\n}\n</code></pre><h3>3.扩展性</h3><p>前面我们提到，框架的扩展性有别于代码的扩展性，是从使用者的角度来讲的，特指使用者可以在不修改框架源码，甚至不拿到框架源码的情况下，为框架扩展新的功能。</p><p>在刚刚讲到框架的易用性的时候，我们给出了框架如何使用的代码示例。从示例中，我们可以发现，框架在兼顾易用性的同时，也可以灵活地替换各种类对象，比如MetricsStorage、StatViewer。举个例子来说，如果我们要让框架基于HBase来存储原始数据而非Redis，那我们只需要设计一个实现MetricsStorage接口的HBaseMetricsStorage类，传递给MetricsCollector和ConsoleReporter、EmailReporter类即可。</p><h3>4.容错性</h3><p>容错性这一点也非常重要。对于这个框架来说，不能因为框架本身的异常导致接口请求出错。所以，对框架可能存在的各种异常情况，我们都要考虑全面。</p><p>在现在的框架设计与实现中，采集和存储是异步执行，即便Redis挂掉或者写入超时，也不会影响到接口的正常响应。除此之外，Redis异常，可能会影响到数据统计显示（也就是ConsoleReporter、EmailReporter负责的工作），但并不会影响到接口的正常响应。</p><h3>5.通用性</h3><p>为了提高框架的复用性，能够灵活应用到各种场景中，框架在设计的时候，要尽可能通用。我们要多去思考一下，除了接口统计这样一个需求，这个框架还可以适用到其他哪些场景中。比如是否还可以处理其他事件的统计信息，比如SQL请求时间的统计、业务统计（比如支付成功率）等。关于这一点，我们在现在的版本3中暂时没有考虑到，你可以自己思考一下。</p><h2>重点回顾</h2><p>好了，今天的内容到此就讲完了。我们一块来总结回顾一下，你需要掌握的重点内容。</p><p>还记得吗？在第25、26讲中，我们提到，针对性能计数器这个框架的开发，要想一下子实现我们罗列的所有功能，对任何人来说都是比较有挑战的。而经过这几个版本的迭代之后，我们不知不觉地就完成了几乎所有的需求，包括功能性和非功能性的需求。</p><p>在第25讲中，我们实现了一个最小原型，虽然非常简陋，所有的代码都塞在一个类中，但它帮我们梳理清楚了需求。在第26讲中，我们实现了框架的第1个版本，这个版本只包含最基本的功能，并且初步利用面向对象的设计方法，把不同功能的代码划分到了不同的类中。</p><p>在第39讲中，我们实现了框架的第2个版本，这个版本对第1个版本的代码结构进行了比较大的调整，让整体代码结构更加合理、清晰、有逻辑性。</p><p>在第40讲中，我们实现了框架的第3个版本，对第2个版本遗留的细节问题进行了重构，并且重点解决了框架的易用性和性能问题。</p><p>从上面的迭代过程，我们可以发现，大部分情况下，我们都是针对问题解决问题，每个版本都聚焦一小部分问题，所以整个过程也没有感觉到有太大难度。尽管我们迭代了3个版本，但目前的设计和实现还有很多值得进一步优化和完善的地方，但限于专栏的篇幅，继续优化的工作留给你自己来完成。</p><p>最后，我希望你不仅仅关注这个框架本身的设计和实现，更重要的是学会这个逐步优化的方法，以及其中涉及的一些编程技巧、设计思路，能够举一反三地用在其他项目中。</p><h2>课堂讨论</h2><p>最后，还是给你留一道课堂讨论题。</p><p>正常情况下，ConsoleReporter的startRepeatedReport()函数只会被调用一次。但是，如果被多次调用，那就会存在问题。具体会有什么问题呢？又该如何解决呢？</p><p>欢迎在留言区写下你的答案，和同学一起交流和分享。如果有收获，也欢迎你把这篇文章分享给你的朋友。</p><p><a href=\"https://jinshuju.net/f/cZuRmd\"><img src=\"https://static001.geekbang.org/resource/image/8b/43/8b7e755ddb44e490848a052c5dc11043.jpg\" alt=\"\"></a></p>",
                "article_title": "40 | 运用学过的设计原则和思想完善之前讲的性能计数器项目（下）"
            }
        ]
    },
    {
        "chapterTitle": "设计模式与范式：创建型 (7讲)",
        "children": [
            {
                "title": "41 | 单例模式（上）：为什么说支持懒加载的双重检测不比饿汉式更优？",
                "herf": "https://time.geekbang.org/column/article/194035",
                "id": "194035",
                "content": "<p>从今天开始，我们正式进入到设计模式的学习。我们知道，经典的设计模式有23种。其中，常用的并不是很多。据我的工作经验来看，常用的可能都不到一半。如果随便抓一个程序员，让他说一说最熟悉的3种设计模式，那其中肯定会包含今天要讲的单例模式。</p><p>网上有很多讲解单例模式的文章，但大部分都侧重讲解，如何来实现一个线程安全的单例。我今天也会讲到各种单例的实现方法，但是，这并不是我们专栏学习的重点，我重点还是希望带你搞清楚下面这样几个问题（第一个问题会在今天讲解，后面三个问题放到下一节课中讲解）。</p><ul>\n<li>为什么要使用单例？</li>\n<li>单例存在哪些问题？</li>\n<li>单例与静态类的区别？</li>\n<li>有何替代的解决方案？</li>\n</ul><p>话不多说，让我们带着这些问题，正式开始今天的学习吧！</p><h2>为什么要使用单例？</h2><p><strong>单例设计模式</strong>（Singleton Design Pattern）理解起来非常简单。一个类只允许创建一个对象（或者实例），那这个类就是一个单例类，这种设计模式就叫作单例设计模式，简称单例模式。</p><p>对于单例的概念，我觉得没必要解释太多，你一看就能明白。我们重点看一下，为什么我们需要单例这种设计模式？它能解决哪些问题？接下来我通过两个实战案例来讲解。</p><h3>实战案例一：处理资源访问冲突</h3><p>我们先来看第一个例子。在这个例子中，我们自定义实现了一个往文件中打印日志的Logger类。具体的代码实现如下所示：</p><!-- [[[read_end]]] --><pre><code>public class Logger {\n  private FileWriter writer;\n  \n  public Logger() {\n    File file = new File(&quot;/Users/wangzheng/log.txt&quot;);\n    writer = new FileWriter(file, true); //true表示追加写入\n  }\n  \n  public void log(String message) {\n    writer.write(message);\n  }\n}\n\n// Logger类的应用示例：\npublic class UserController {\n  private Logger logger = new Logger();\n  \n  public void login(String username, String password) {\n    // ...省略业务逻辑代码...\n    logger.log(username + &quot; logined!&quot;);\n  }\n}\n\npublic class OrderController {\n  private Logger logger = new Logger();\n  \n  public void create(OrderVo order) {\n    // ...省略业务逻辑代码...\n    logger.log(&quot;Created an order: &quot; + order.toString());\n  }\n}\n</code></pre><p>看完代码之后，先别着急看我下面的讲解，你可以先思考一下，这段代码存在什么问题。</p><p>在上面的代码中，我们注意到，所有的日志都写入到同一个文件/Users/wangzheng/log.txt中。在UserController和OrderController中，我们分别创建两个Logger对象。在Web容器的Servlet多线程环境下，如果两个Servlet线程同时分别执行login()和create()两个函数，并且同时写日志到log.txt文件中，那就有可能存在日志信息互相覆盖的情况。</p><p>为什么会出现互相覆盖呢？我们可以这么类比着理解。在多线程环境下，如果两个线程同时给同一个共享变量加1，因为共享变量是竞争资源，所以，共享变量最后的结果有可能并不是加了2，而是只加了1。同理，这里的log.txt文件也是竞争资源，两个线程同时往里面写数据，就有可能存在互相覆盖的情况。</p><p><img src=\"https://static001.geekbang.org/resource/image/2b/c2/2b0e6141d10399430c59169af4edc3c2.jpg\" alt=\"\"></p><p>那如何来解决这个问题呢？我们最先想到的就是通过加锁的方式：给log()函数加互斥锁（Java中可以通过synchronized的关键字），同一时刻只允许一个线程调用执行log()函数。具体的代码实现如下所示：</p><pre><code>public class Logger {\n  private FileWriter writer;\n\n  public Logger() {\n    File file = new File(&quot;/Users/wangzheng/log.txt&quot;);\n    writer = new FileWriter(file, true); //true表示追加写入\n  }\n  \n  public void log(String message) {\n    synchronized(this) {\n      writer.write(mesasge);\n    }\n  }\n}\n</code></pre><p>不过，你仔细想想，这真的能解决多线程写入日志时互相覆盖的问题吗？答案是否定的。这是因为，这种锁是一个对象级别的锁，一个对象在不同的线程下同时调用log()函数，会被强制要求顺序执行。但是，不同的对象之间并不共享同一把锁。在不同的线程下，通过不同的对象调用执行log()函数，锁并不会起作用，仍然有可能存在写入日志互相覆盖的问题。</p><p><img src=\"https://static001.geekbang.org/resource/image/20/29/203eb5070c3820b48500d4ab95732f29.jpg\" alt=\"\"></p><p>我这里稍微补充一下，在刚刚的讲解和给出的代码中，我故意“隐瞒”了一个事实：我们给log()函数加不加对象级别的锁，其实都没有关系。因为FileWriter本身就是线程安全的，它的内部实现中本身就加了对象级别的锁，因此，在外层调用write()函数的时候，再加对象级别的锁实际上是多此一举。因为不同的Logger对象不共享FileWriter对象，所以，FileWriter对象级别的锁也解决不了数据写入互相覆盖的问题。</p><p>那我们该怎么解决这个问题呢？实际上，要想解决这个问题也不难，我们只需要把对象级别的锁，换成类级别的锁就可以了。让所有的对象都共享同一把锁。这样就避免了不同对象之间同时调用log()函数，而导致的日志覆盖问题。具体的代码实现如下所示：</p><pre><code>public class Logger {\n  private FileWriter writer;\n\n  public Logger() {\n    File file = new File(&quot;/Users/wangzheng/log.txt&quot;);\n    writer = new FileWriter(file, true); //true表示追加写入\n  }\n  \n  public void log(String message) {\n    synchronized(Logger.class) { // 类级别的锁\n      writer.write(mesasge);\n    }\n  }\n}\n</code></pre><p>除了使用类级别锁之外，实际上，解决资源竞争问题的办法还有很多，分布式锁是最常听到的一种解决方案。不过，实现一个安全可靠、无bug、高性能的分布式锁，并不是件容易的事情。除此之外，并发队列（比如Java中的BlockingQueue）也可以解决这个问题：多个线程同时往并发队列里写日志，一个单独的线程负责将并发队列中的数据，写入到日志文件。这种方式实现起来也稍微有点复杂。</p><p>相对于这两种解决方案，单例模式的解决思路就简单一些了。单例模式相对于之前类级别锁的好处是，不用创建那么多Logger对象，一方面节省内存空间，另一方面节省系统文件句柄（对于操作系统来说，文件句柄也是一种资源，不能随便浪费）。</p><p>我们将Logger设计成一个单例类，程序中只允许创建一个Logger对象，所有的线程共享使用的这一个Logger对象，共享一个FileWriter对象，而FileWriter本身是对象级别线程安全的，也就避免了多线程情况下写日志会互相覆盖的问题。</p><p>按照这个设计思路，我们实现了Logger单例类。具体代码如下所示：</p><pre><code>public class Logger {\n  private FileWriter writer;\n  private static final Logger instance = new Logger();\n\n  private Logger() {\n    File file = new File(&quot;/Users/wangzheng/log.txt&quot;);\n    writer = new FileWriter(file, true); //true表示追加写入\n  }\n  \n  public static Logger getInstance() {\n    return instance;\n  }\n  \n  public void log(String message) {\n    writer.write(mesasge);\n  }\n}\n\n// Logger类的应用示例：\npublic class UserController {\n  public void login(String username, String password) {\n    // ...省略业务逻辑代码...\n    Logger.getInstance().log(username + &quot; logined!&quot;);\n  }\n}\n\npublic class OrderController {  \n  public void create(OrderVo order) {\n    // ...省略业务逻辑代码...\n    Logger.getInstance().log(&quot;Created a order: &quot; + order.toString());\n  }\n}\n</code></pre><h3>实战案例二：表示全局唯一类</h3><p>从业务概念上，如果有些数据在系统中只应保存一份，那就比较适合设计为单例类。</p><p>比如，配置信息类。在系统中，我们只有一个配置文件，当配置文件被加载到内存之后，以对象的形式存在，也理所应当只有一份。</p><p>再比如，唯一递增ID号码生成器（<a href=\"https://time.geekbang.org/column/article/190979\">第34讲</a>中我们讲的是唯一ID生成器，这里讲的是唯一递增ID生成器），如果程序中有两个对象，那就会存在生成重复ID的情况，所以，我们应该将ID生成器类设计为单例。</p><pre><code>import java.util.concurrent.atomic.AtomicLong;\npublic class IdGenerator {\n  // AtomicLong是一个Java并发库中提供的一个原子变量类型,\n  // 它将一些线程不安全需要加锁的复合操作封装为了线程安全的原子操作，\n  // 比如下面会用到的incrementAndGet().\n  private AtomicLong id = new AtomicLong(0);\n  private static final IdGenerator instance = new IdGenerator();\n  private IdGenerator() {}\n  public static IdGenerator getInstance() {\n    return instance;\n  }\n  public long getId() { \n    return id.incrementAndGet();\n  }\n}\n\n// IdGenerator使用举例\nlong id = IdGenerator.getInstance().getId();\n</code></pre><p>实际上，今天讲到的两个代码实例（Logger、IdGenerator），设计的都并不优雅，还存在一些问题。至于有什么问题以及如何改造，今天我暂时卖个关子，下一节课我会详细讲解。</p><h2>如何实现一个单例？</h2><p>尽管介绍如何实现一个单例模式的文章已经有很多了，但为了保证内容的完整性，我这里还是简单介绍一下几种经典实现方式。概括起来，要实现一个单例，我们需要关注的点无外乎下面几个：</p><ul>\n<li>构造函数需要是private访问权限的，这样才能避免外部通过new创建实例；</li>\n<li>考虑对象创建时的线程安全问题；</li>\n<li>考虑是否支持延迟加载；</li>\n<li>考虑getInstance()性能是否高（是否加锁）。</li>\n</ul><p>如果你对这块已经很熟悉了，你可以当作复习。注意，下面的几种单例实现方式是针对Java语言语法的，如果你熟悉的是其他语言，不妨对比Java的这几种实现方式，自己试着总结一下，利用你熟悉的语言，该如何实现。</p><h3>1.饿汉式</h3><p>饿汉式的实现方式比较简单。在类加载的时候，instance静态实例就已经创建并初始化好了，所以，instance实例的创建过程是线程安全的。不过，这样的实现方式不支持延迟加载（在真正用到IdGenerator的时候，再创建实例），从名字中我们也可以看出这一点。具体的代码实现如下所示：</p><pre><code>public class IdGenerator { \n  private AtomicLong id = new AtomicLong(0);\n  private static final IdGenerator instance = new IdGenerator();\n  private IdGenerator() {}\n  public static IdGenerator getInstance() {\n    return instance;\n  }\n  public long getId() { \n    return id.incrementAndGet();\n  }\n}\n</code></pre><p>有人觉得这种实现方式不好，因为不支持延迟加载，如果实例占用资源多（比如占用内存多）或初始化耗时长（比如需要加载各种配置文件），提前初始化实例是一种浪费资源的行为。最好的方法应该在用到的时候再去初始化。不过，我个人并不认同这样的观点。</p><p>如果初始化耗时长，那我们最好不要等到真正要用它的时候，才去执行这个耗时长的初始化过程，这会影响到系统的性能（比如，在响应客户端接口请求的时候，做这个初始化操作，会导致此请求的响应时间变长，甚至超时）。采用饿汉式实现方式，将耗时的初始化操作，提前到程序启动的时候完成，这样就能避免在程序运行的时候，再去初始化导致的性能问题。</p><p>如果实例占用资源多，按照fail-fast的设计原则（有问题及早暴露），那我们也希望在程序启动时就将这个实例初始化好。如果资源不够，就会在程序启动的时候触发报错（比如Java中的 PermGen Space OOM），我们可以立即去修复。这样也能避免在程序运行一段时间后，突然因为初始化这个实例占用资源过多，导致系统崩溃，影响系统的可用性。</p><h3>2.懒汉式</h3><p>有饿汉式，对应的，就有懒汉式。懒汉式相对于饿汉式的优势是支持延迟加载。具体的代码实现如下所示：</p><pre><code>public class IdGenerator { \n  private AtomicLong id = new AtomicLong(0);\n  private static IdGenerator instance;\n  private IdGenerator() {}\n  public static synchronized IdGenerator getInstance() {\n    if (instance == null) {\n      instance = new IdGenerator();\n    }\n    return instance;\n  }\n  public long getId() { \n    return id.incrementAndGet();\n  }\n}\n</code></pre><p>不过懒汉式的缺点也很明显，我们给getInstance()这个方法加了一把大锁（synchronzed），导致这个函数的并发度很低。量化一下的话，并发度是1，也就相当于串行操作了。而这个函数是在单例使用期间，一直会被调用。如果这个单例类偶尔会被用到，那这种实现方式还可以接受。但是，如果频繁地用到，那频繁加锁、释放锁及并发度低等问题，会导致性能瓶颈，这种实现方式就不可取了。</p><h3>3.双重检测</h3><p>饿汉式不支持延迟加载，懒汉式有性能问题，不支持高并发。那我们再来看一种既支持延迟加载、又支持高并发的单例实现方式，也就是双重检测实现方式。</p><p>在这种实现方式中，只要instance被创建之后，即便再调用getInstance()函数也不会再进入到加锁逻辑中了。所以，这种实现方式解决了懒汉式并发度低的问题。具体的代码实现如下所示：</p><pre><code>public class IdGenerator { \n  private AtomicLong id = new AtomicLong(0);\n  private static IdGenerator instance;\n  private IdGenerator() {}\n  public static IdGenerator getInstance() {\n    if (instance == null) {\n      synchronized(IdGenerator.class) { // 此处为类级别的锁\n        if (instance == null) {\n          instance = new IdGenerator();\n        }\n      }\n    }\n    return instance;\n  }\n  public long getId() { \n    return id.incrementAndGet();\n  }\n}\n</code></pre><p>网上有人说，这种实现方式有些问题。因为指令重排序，可能会导致IdGenerator对象被new出来，并且赋值给instance之后，还没来得及初始化（执行构造函数中的代码逻辑），就被另一个线程使用了。</p><p>要解决这个问题，我们需要给instance成员变量加上volatile关键字，禁止指令重排序才行。实际上，只有很低版本的Java才会有这个问题。我们现在用的高版本的Java已经在JDK内部实现中解决了这个问题（解决的方法很简单，只要把对象new操作和初始化操作设计为原子操作，就自然能禁止重排序）。关于这点的详细解释，跟特定语言有关，我就不展开讲了，感兴趣的同学可以自行研究一下。</p><h3>4.静态内部类</h3><p>我们再来看一种比双重检测更加简单的实现方法，那就是利用Java的静态内部类。它有点类似饿汉式，但又能做到了延迟加载。具体是怎么做到的呢？我们先来看它的代码实现。</p><pre><code>public class IdGenerator { \n  private AtomicLong id = new AtomicLong(0);\n  private IdGenerator() {}\n\n  private static class SingletonHolder{\n    private static final IdGenerator instance = new IdGenerator();\n  }\n  \n  public static IdGenerator getInstance() {\n    return SingletonHolder.instance;\n  }\n \n  public long getId() { \n    return id.incrementAndGet();\n  }\n}\n</code></pre><p>SingletonHolder 是一个静态内部类，当外部类IdGenerator被加载的时候，并不会创建SingletonHolder实例对象。只有当调用getInstance()方法时，SingletonHolder才会被加载，这个时候才会创建instance。instance的唯一性、创建过程的线程安全性，都由JVM来保证。所以，这种实现方法既保证了线程安全，又能做到延迟加载。</p><h3>5.枚举</h3><p>最后，我们介绍一种最简单的实现方式，基于枚举类型的单例实现。这种实现方式通过Java枚举类型本身的特性，保证了实例创建的线程安全性和实例的唯一性。具体的代码如下所示：</p><pre><code>public enum IdGenerator {\n  INSTANCE;\n  private AtomicLong id = new AtomicLong(0);\n \n  public long getId() { \n    return id.incrementAndGet();\n  }\n}\n</code></pre><h2>重点回顾</h2><p>好了，今天的内容到此就讲完了。我们来总结回顾一下，你需要掌握的重点内容。</p><p><strong>1.单例的定义</strong></p><p>单例设计模式（Singleton Design Pattern）理解起来非常简单。一个类只允许创建一个对象（或者叫实例），那这个类就是一个单例类，这种设计模式就叫作单例设计模式，简称单例模式。</p><p><strong>2.单例的用处</strong></p><p>从业务概念上，有些数据在系统中只应该保存一份，就比较适合设计为单例类。比如，系统的配置信息类。除此之外，我们还可以使用单例解决资源访问冲突的问题。</p><p><strong>3.单例的实现</strong></p><p>单例有下面几种经典的实现方式。</p><ul>\n<li>饿汉式</li>\n</ul><p>饿汉式的实现方式，在类加载的期间，就已经将instance静态实例初始化好了，所以，instance实例的创建是线程安全的。不过，这样的实现方式不支持延迟加载实例。</p><ul>\n<li>懒汉式</li>\n</ul><p>懒汉式相对于饿汉式的优势是支持延迟加载。这种实现方式会导致频繁加锁、释放锁，以及并发度低等问题，频繁的调用会产生性能瓶颈。</p><ul>\n<li>双重检测</li>\n</ul><p>双重检测实现方式既支持延迟加载、又支持高并发的单例实现方式。只要instance被创建之后，再调用getInstance()函数都不会进入到加锁逻辑中。所以，这种实现方式解决了懒汉式并发度低的问题。</p><ul>\n<li>静态内部类</li>\n</ul><p>利用Java的静态内部类来实现单例。这种实现方式，既支持延迟加载，也支持高并发，实现起来也比双重检测简单。</p><ul>\n<li>枚举</li>\n</ul><p>最简单的实现方式，基于枚举类型的单例实现。这种实现方式通过Java枚举类型本身的特性，保证了实例创建的线程安全性和实例的唯一性。</p><h2>课堂讨论</h2><ol>\n<li>在你所熟悉的编程语言的类库中，有哪些类是单例类？又为什么要设计成单例类呢？</li>\n<li>在第一个实战案例中，除了我们讲到的类级别锁、分布式锁、并发队列、单例模式等解决方案之外，实际上还有一种非常简单的解决日志互相覆盖问题的方法，你想到了吗？</li>\n</ol><p>可以在留言区说一说，和同学一起交流和分享。如果有收获，也欢迎你把这篇文章分享给你的朋友。</p>",
                "article_title": "41 | 单例模式（上）：为什么说支持懒加载的双重检测不比饿汉式更优？"
            },
            {
                "title": "42 | 单例模式（中）：我为什么不推荐使用单例模式？又有何替代方案？",
                "herf": "https://time.geekbang.org/column/article/194068",
                "id": "194068",
                "content": "<p>上一节课中，我们通过两个实战案例，讲解了单例模式的一些应用场景，比如，避免资源访问冲突、表示业务概念上的全局唯一类。除此之外，我们还学习了Java语言中，单例模式的几种实现方法。如果你熟悉的是其他编程语言，不知道你课后有没有自己去对照着实现一下呢？</p><p>尽管单例是一个很常用的设计模式，在实际的开发中，我们也确实经常用到它，但是，有些人认为单例是一种反模式（anti-pattern），并不推荐使用。所以，今天，我就针对这个说法详细地讲讲这几个问题：单例这种设计模式存在哪些问题？为什么会被称为反模式？如果不用单例，该如何表示全局唯一类？有何替代的解决方案？</p><p>话不多说，让我们带着这些问题，正式开始今天的学习吧！</p><h2>单例存在哪些问题?</h2><p>大部分情况下，我们在项目中使用单例，都是用它来表示一些全局唯一类，比如配置信息类、连接池类、ID生成器类。单例模式书写简洁、使用方便，在代码中，我们不需要创建对象，直接通过类似IdGenerator.getInstance().getId()这样的方法来调用就可以了。但是，这种使用方法有点类似硬编码（hard code），会带来诸多问题。接下来，我们就具体看看到底有哪些问题。</p><h3>1.单例对OOP特性的支持不友好</h3><!-- [[[read_end]]] --><p>我们知道，OOP的四大特性是封装、抽象、继承、多态。单例这种设计模式对于其中的抽象、继承、多态都支持得不好。为什么这么说呢？我们还是通过IdGenerator这个例子来讲解。</p><pre><code>public class Order {\n  public void create(...) {\n    //...\n    long id = IdGenerator.getInstance().getId();\n    //...\n  }\n}\n\npublic class User {\n  public void create(...) {\n    // ...\n    long id = IdGenerator.getInstance().getId();\n    //...\n  }\n}\n</code></pre><p>IdGenerator的使用方式违背了基于接口而非实现的设计原则，也就违背了广义上理解的OOP的抽象特性。如果未来某一天，我们希望针对不同的业务采用不同的ID生成算法。比如，订单ID和用户ID采用不同的ID生成器来生成。为了应对这个需求变化，我们需要修改所有用到IdGenerator类的地方，这样代码的改动就会比较大。</p><pre><code>public class Order {\n  public void create(...) {\n    //...\n    long id = IdGenerator.getInstance().getId();\n    // 需要将上面一行代码，替换为下面一行代码\n    long id = OrderIdGenerator.getIntance().getId();\n    //...\n  }\n}\n\npublic class User {\n  public void create(...) {\n    // ...\n    long id = IdGenerator.getInstance().getId();\n    // 需要将上面一行代码，替换为下面一行代码\n    long id = UserIdGenerator.getIntance().getId();\n  }\n}\n</code></pre><p>除此之外，单例对继承、多态特性的支持也不友好。这里我之所以会用“不友好”这个词，而非“完全不支持”，是因为从理论上来讲，单例类也可以被继承、也可以实现多态，只是实现起来会非常奇怪，会导致代码的可读性变差。不明白设计意图的人，看到这样的设计，会觉得莫名其妙。所以，一旦你选择将某个类设计成到单例类，也就意味着放弃了继承和多态这两个强有力的面向对象特性，也就相当于损失了可以应对未来需求变化的扩展性。</p><h3>2.单例会隐藏类之间的依赖关系</h3><p>我们知道，代码的可读性非常重要。在阅读代码的时候，我们希望一眼就能看出类与类之间的依赖关系，搞清楚这个类依赖了哪些外部类。</p><p>通过构造函数、参数传递等方式声明的类之间的依赖关系，我们通过查看函数的定义，就能很容易识别出来。但是，单例类不需要显示创建、不需要依赖参数传递，在函数中直接调用就可以了。如果代码比较复杂，这种调用关系就会非常隐蔽。在阅读代码的时候，我们就需要仔细查看每个函数的代码实现，才能知道这个类到底依赖了哪些单例类。</p><h3>3.单例对代码的扩展性不友好</h3><p>我们知道，单例类只能有一个对象实例。如果未来某一天，我们需要在代码中创建两个实例或多个实例，那就要对代码有比较大的改动。你可能会说，会有这样的需求吗？既然单例类大部分情况下都用来表示全局类，怎么会需要两个或者多个实例呢？</p><p>实际上，这样的需求并不少见。我们拿数据库连接池来举例解释一下。</p><p>在系统设计初期，我们觉得系统中只应该有一个数据库连接池，这样能方便我们控制对数据库连接资源的消耗。所以，我们把数据库连接池类设计成了单例类。但之后我们发现，系统中有些SQL语句运行得非常慢。这些SQL语句在执行的时候，长时间占用数据库连接资源，导致其他SQL请求无法响应。为了解决这个问题，我们希望将慢SQL与其他SQL隔离开来执行。为了实现这样的目的，我们可以在系统中创建两个数据库连接池，慢SQL独享一个数据库连接池，其他SQL独享另外一个数据库连接池，这样就能避免慢SQL影响到其他SQL的执行。</p><p>如果我们将数据库连接池设计成单例类，显然就无法适应这样的需求变更，也就是说，单例类在某些情况下会影响代码的扩展性、灵活性。所以，数据库连接池、线程池这类的资源池，最好还是不要设计成单例类。实际上，一些开源的数据库连接池、线程池也确实没有设计成单例类。</p><h3>4.单例对代码的可测试性不友好</h3><p>单例模式的使用会影响到代码的可测试性。如果单例类依赖比较重的外部资源，比如DB，我们在写单元测试的时候，希望能通过mock的方式将它替换掉。而单例类这种硬编码式的使用方式，导致无法实现mock替换。</p><p>除此之外，如果单例类持有成员变量（比如IdGenerator中的id成员变量），那它实际上相当于一种全局变量，被所有的代码共享。如果这个全局变量是一个可变全局变量，也就是说，它的成员变量是可以被修改的，那我们在编写单元测试的时候，还需要注意不同测试用例之间，修改了单例类中的同一个成员变量的值，从而导致测试结果互相影响的问题。关于这一点，你可以回过头去看下<a href=\"https://time.geekbang.org/column/article/186691\">第29讲</a>中的“其他常见的Anti-Patterns：全局变量”那部分的代码示例和讲解。</p><h3>5.单例不支持有参数的构造函数</h3><p>单例不支持有参数的构造函数，比如我们创建一个连接池的单例对象，我们没法通过参数来指定连接池的大小。针对这个问题，我们来看下都有哪些解决方案。</p><p>第一种解决思路是：创建完实例之后，再调用init()函数传递参数。需要注意的是，我们在使用这个单例类的时候，要先调用init()方法，然后才能调用getInstance()方法，否则代码会抛出异常。具体的代码实现如下所示：</p><pre><code>public class Singleton {\n  private static Singleton instance = null;\n  private final int paramA;\n  private final int paramB;\n\n  private Singleton(int paramA, int paramB) {\n    this.paramA = paramA;\n    this.paramB = paramB;\n  }\n\n  public static Singleton getInstance() {\n    if (instance == null) {\n       throw new RuntimeException(&quot;Run init() first.&quot;);\n    }\n    return instance;\n  }\n\n  public synchronized static Singleton init(int paramA, int paramB) {\n    if (instance != null){\n       throw new RuntimeException(&quot;Singleton has been created!&quot;);\n    }\n    instance = new Singleton(paramA, paramB);\n    return instance;\n  }\n}\n\nSingleton.init(10, 50); // 先init，再使用\nSingleton singleton = Singleton.getInstance();\n</code></pre><p>第二种解决思路是：将参数放到getIntance()方法中。具体的代码实现如下所示：</p><pre><code>public class Singleton {\n  private static Singleton instance = null;\n  private final int paramA;\n  private final int paramB;\n\n  private Singleton(int paramA, int paramB) {\n    this.paramA = paramA;\n    this.paramB = paramB;\n  }\n\n  public synchronized static Singleton getInstance(int paramA, int paramB) {\n    if (instance == null) {\n      instance = new Singleton(paramA, paramB);\n    }\n    return instance;\n  }\n}\n\nSingleton singleton = Singleton.getInstance(10, 50);\n</code></pre><p>不知道你有没有发现，上面的代码实现稍微有点问题。如果我们如下两次执行getInstance()方法，那获取到的singleton1和signleton2的paramA和paramB都是10和50。也就是说，第二次的参数（20，30）没有起作用，而构建的过程也没有给与提示，这样就会误导用户。这个问题如何解决呢？留给你自己思考，你可以在留言区说说你的解决思路。</p><pre><code>Singleton singleton1 = Singleton.getInstance(10, 50);\nSingleton singleton2 = Singleton.getInstance(20, 30);\n</code></pre><p>第三种解决思路是：将参数放到另外一个全局变量中。具体的代码实现如下。Config是一个存储了paramA和paramB值的全局变量。里面的值既可以像下面的代码那样通过静态常量来定义，也可以从配置文件中加载得到。实际上，这种方式是最值得推荐的。</p><pre><code>public class Config {\n  public static final int PARAM_A = 123;\n  public static final int PARAM_B = 245;\n}\n\npublic class Singleton {\n  private static Singleton instance = null;\n  private final int paramA;\n  private final int paramB;\n\n  private Singleton() {\n    this.paramA = Config.PARAM_A;\n    this.paramB = Config.PARAM_B;\n  }\n\n  public synchronized static Singleton getInstance() {\n    if (instance == null) {\n      instance = new Singleton();\n    }\n    return instance;\n  }\n}\n</code></pre><h2>有何替代解决方案？</h2><p>刚刚我们提到了单例的很多问题，你可能会说，即便单例有这么多问题，但我不用不行啊。我业务上有表示全局唯一类的需求，如果不用单例，我怎么才能保证这个类的对象全局唯一呢？</p><p>为了保证全局唯一，除了使用单例，我们还可以用静态方法来实现。这也是项目开发中经常用到的一种实现思路。比如，上一节课中讲的ID唯一递增生成器的例子，用静态方法实现一下，就是下面这个样子：</p><pre><code>// 静态方法实现方式\npublic class IdGenerator {\n  private static AtomicLong id = new AtomicLong(0);\n  \n  public static long getId() { \n    return id.incrementAndGet();\n  }\n}\n// 使用举例\nlong id = IdGenerator.getId();\n</code></pre><p>不过，静态方法这种实现思路，并不能解决我们之前提到的问题。实际上，它比单例更加不灵活，比如，它无法支持延迟加载。我们再来看看有没有其他办法。实际上，单例除了我们之前讲到的使用方法之外，还有另外一种使用方法。具体的代码如下所示：</p><pre><code>// 1. 老的使用方式\npublic demofunction() {\n  //...\n  long id = IdGenerator.getInstance().getId();\n  //...\n}\n\n// 2. 新的使用方式：依赖注入\npublic demofunction(IdGenerator idGenerator) {\n  long id = idGenerator.getId();\n}\n// 外部调用demofunction()的时候，传入idGenerator\nIdGenerator idGenerator = IdGenerator.getInsance();\ndemofunction(idGenerator);\n</code></pre><p>基于新的使用方式，我们将单例生成的对象，作为参数传递给函数（也可以通过构造函数传递给类的成员变量），可以解决单例隐藏类之间依赖关系的问题。不过，对于单例存在的其他问题，比如对OOP特性、扩展性、可测性不友好等问题，还是无法解决。</p><p>所以，如果要完全解决这些问题，我们可能要从根上，寻找其他方式来实现全局唯一类。实际上，类对象的全局唯一性可以通过多种不同的方式来保证。我们既可以通过单例模式来强制保证，也可以通过工厂模式、IOC容器（比如Spring IOC容器）来保证，还可以通过程序员自己来保证（自己在编写代码的时候自己保证不要创建两个类对象）。这就类似Java中内存对象的释放由JVM来负责，而C++中由程序员自己负责，道理是一样的。</p><p>对于替代方案工厂模式、IOC容器的详细讲解，我们放到后面的章节中讲解。</p><h2>重点回顾</h2><p>好了，今天的内容到此就讲完了。我们来一块总结回顾一下，你需要掌握的重点内容。</p><p><strong>1.单例存在哪些问题？</strong></p><ul>\n<li>单例对OOP特性的支持不友好</li>\n<li>单例会隐藏类之间的依赖关系</li>\n<li>单例对代码的扩展性不友好</li>\n<li>单例对代码的可测试性不友好</li>\n<li>单例不支持有参数的构造函数</li>\n</ul><p><strong>2.单例有什么替代解决方案？</strong></p><p>为了保证全局唯一，除了使用单例，我们还可以用静态方法来实现。不过，静态方法这种实现思路，并不能解决我们之前提到的问题。如果要完全解决这些问题，我们可能要从根上，寻找其他方式来实现全局唯一类了。比如，通过工厂模式、IOC容器（比如Spring IOC容器）来保证，由程序员自己来保证（自己在编写代码的时候自己保证不要创建两个类对象）。</p><p>有人把单例当作反模式，主张杜绝在项目中使用。我个人觉得这有点极端。模式没有对错，关键看你怎么用。如果单例类并没有后续扩展的需求，并且不依赖外部系统，那设计成单例类就没有太大问题。对于一些全局的类，我们在其他地方new的话，还要在类之间传来传去，不如直接做成单例类，使用起来简洁方便。</p><h2>课堂讨论</h2><p>1.如果项目中已经用了很多单例模式，比如下面这段代码，我们该如何在尽量减少代码改动的情况下，通过重构代码来提高代码的可测试性呢？</p><pre><code>public class Demo {\n  private UserRepo userRepo; // 通过构造哈函数或IOC容器依赖注入\n  \n  public boolean validateCachedUser(long userId) {\n    User cachedUser = CacheManager.getInstance().getUser(userId);\n    User actualUser = userRepo.getUser(userId);\n    // 省略核心逻辑：对比cachedUser和actualUser...\n  }\n}\n</code></pre><p>2.在单例支持参数传递的第二种解决方案中，如果我们两次执行getInstance(paramA, paramB)方法，第二次传递进去的参数是不生效的，而构建的过程也没有给与提示，这样就会误导用户。这个问题如何解决呢？</p><pre><code>Singleton singleton1 = Singleton.getInstance(10, 50);\nSingleton singleton2 = Singleton.getInstance(20, 30);\n</code></pre><p>欢迎留言和我分享你的思考和见解。如果有收获，也欢迎你把文章分享给你的朋友。</p>",
                "article_title": "42 | 单例模式（中）：我为什么不推荐使用单例模式？又有何替代方案？"
            },
            {
                "title": "43 | 单例模式（下）：如何设计实现一个集群环境下的分布式单例模式？",
                "herf": "https://time.geekbang.org/column/article/196790",
                "id": "196790",
                "content": "<p>上两节课中，我们针对单例模式，讲解了单例的应用场景、几种常见的代码实现和存在的问题，并粗略给出了替换单例模式的方法，比如工厂模式、IOC容器。今天，我们再进一步扩展延伸一下，一块讨论一下下面这几个问题：</p><ul>\n<li>如何理解单例模式中的唯一性？</li>\n<li>如何实现线程唯一的单例？</li>\n<li>如何实现集群环境下的单例？</li>\n<li>如何实现一个多例模式？</li>\n</ul><p>今天的内容稍微有点“烧脑”，希望你在看的过程中多思考一下。话不多说，让我们正式开始今天的学习吧！</p><h2>如何理解单例模式中的唯一性？</h2><p>首先，我们重新看一下单例的定义：“一个类只允许创建唯一一个对象（或者实例），那这个类就是一个单例类，这种设计模式就叫作单例设计模式，简称单例模式。”</p><p>定义中提到，“一个类只允许创建唯一一个对象”。那对象的唯一性的作用范围是什么呢？是指线程内只允许创建一个对象，还是指进程内只允许创建一个对象？答案是后者，也就是说，单例模式创建的对象是进程唯一的。这里有点不好理解，我来详细地解释一下。</p><p>我们编写的代码，通过编译、链接，组织在一起，就构成了一个操作系统可以执行的文件，也就是我们平时所说的“可执行文件”（比如Windows下的exe文件）。可执行文件实际上就是代码被翻译成操作系统可理解的一组指令，你完全可以简单地理解为就是代码本身。</p><!-- [[[read_end]]] --><p>当我们使用命令行或者双击运行这个可执行文件的时候，操作系统会启动一个进程，将这个执行文件从磁盘加载到自己的进程地址空间（可以理解操作系统为进程分配的内存存储区，用来存储代码和数据）。接着，进程就一条一条地执行可执行文件中包含的代码。比如，当进程读到代码中的User user = new User();这条语句的时候，它就在自己的地址空间中创建一个user临时变量和一个User对象。</p><p>进程之间是不共享地址空间的，如果我们在一个进程中创建另外一个进程（比如，代码中有一个fork()语句，进程执行到这条语句的时候会创建一个新的进程），操作系统会给新进程分配新的地址空间，并且将老进程地址空间的所有内容，重新拷贝一份到新进程的地址空间中，这些内容包括代码、数据（比如user临时变量、User对象）。</p><p>所以，单例类在老进程中存在且只能存在一个对象，在新进程中也会存在且只能存在一个对象。而且，这两个对象并不是同一个对象，这也就说，单例类中对象的唯一性的作用范围是进程内的，在进程间是不唯一的。</p><h2>如何实现线程唯一的单例？</h2><p>刚刚我们讲了单例类对象是进程唯一的，一个进程只能有一个单例对象。那如何实现一个线程唯一的单例呢？</p><p>我们先来看一下，什么是线程唯一的单例，以及“线程唯一”和“进程唯一”的区别。</p><p>“进程唯一”指的是进程内唯一，进程间不唯一。类比一下，“线程唯一”指的是线程内唯一，线程间可以不唯一。实际上，“进程唯一”还代表了线程内、线程间都唯一，这也是“进程唯一”和“线程唯一”的区别之处。这段话听起来有点像绕口令，我举个例子来解释一下。</p><p>假设IdGenerator是一个线程唯一的单例类。在线程A内，我们可以创建一个单例对象a。因为线程内唯一，在线程A内就不能再创建新的IdGenerator对象了，而线程间可以不唯一，所以，在另外一个线程B内，我们还可以重新创建一个新的单例对象b。</p><p>尽管概念理解起来比较复杂，但线程唯一单例的代码实现很简单，如下所示。在代码中，我们通过一个HashMap来存储对象，其中key是线程ID，value是对象。这样我们就可以做到，不同的线程对应不同的对象，同一个线程只能对应一个对象。实际上，Java语言本身提供了ThreadLocal工具类，可以更加轻松地实现线程唯一单例。不过，ThreadLocal底层实现原理也是基于下面代码中所示的HashMap。</p><pre><code>public class IdGenerator {\n  private AtomicLong id = new AtomicLong(0);\n\n  private static final ConcurrentHashMap&lt;Long, IdGenerator&gt; instances\n          = new ConcurrentHashMap&lt;&gt;();\n\n  private IdGenerator() {}\n\n  public static IdGenerator getInstance() {\n    Long currentThreadId = Thread.currentThread().getId();\n    instances.putIfAbsent(currentThreadId, new IdGenerator());\n    return instances.get(currentThreadId);\n  }\n\n  public long getId() {\n    return id.incrementAndGet();\n  }\n}\n</code></pre><h2>如何实现集群环境下的单例？</h2><p>刚刚我们讲了“进程唯一”的单例和“线程唯一”的单例，现在，我们再来看下，“集群唯一”的单例。</p><p>首先，我们还是先来解释一下，什么是“集群唯一”的单例。</p><p>我们还是将它跟“进程唯一”“线程唯一”做个对比。“进程唯一”指的是进程内唯一、进程间不唯一。“线程唯一”指的是线程内唯一、线程间不唯一。集群相当于多个进程构成的一个集合，“集群唯一”就相当于是进程内唯一、进程间也唯一。也就是说，不同的进程间共享同一个对象，不能创建同一个类的多个对象。</p><p>我们知道，经典的单例模式是进程内唯一的，那如何实现一个进程间也唯一的单例呢？如果严格按照不同的进程间共享同一个对象来实现，那集群唯一的单例实现起来就有点难度了。</p><p>具体来说，我们需要把这个单例对象序列化并存储到外部共享存储区（比如文件）。进程在使用这个单例对象的时候，需要先从外部共享存储区中将它读取到内存，并反序列化成对象，然后再使用，使用完成之后还需要再存储回外部共享存储区。</p><p>为了保证任何时刻，在进程间都只有一份对象存在，一个进程在获取到对象之后，需要对对象加锁，避免其他进程再将其获取。在进程使用完这个对象之后，还需要显式地将对象从内存中删除，并且释放对对象的加锁。</p><p>按照这个思路，我用伪代码实现了一下这个过程，具体如下所示：</p><pre><code>public class IdGenerator {\n  private AtomicLong id = new AtomicLong(0);\n  private static IdGenerator instance;\n  private static SharedObjectStorage storage = FileSharedObjectStorage(/*入参省略，比如文件地址*/);\n  private static DistributedLock lock = new DistributedLock();\n  \n  private IdGenerator() {}\n\n  public synchronized static IdGenerator getInstance() \n    if (instance == null) {\n      lock.lock();\n      instance = storage.load(IdGenerator.class);\n    }\n    return instance;\n  }\n  \n  public synchroinzed void freeInstance() {\n    storage.save(this, IdGeneator.class);\n    instance = null; //释放对象\n    lock.unlock();\n  }\n  \n  public long getId() { \n    return id.incrementAndGet();\n  }\n}\n\n// IdGenerator使用举例\nIdGenerator idGeneator = IdGenerator.getInstance();\nlong id = idGenerator.getId();\nIdGenerator.freeInstance();\n</code></pre><h2>如何实现一个多例模式？</h2><p>跟单例模式概念相对应的还有一个多例模式。那如何实现一个多例模式呢？</p><p>“单例”指的是，一个类只能创建一个对象。对应地，“多例”指的就是，一个类可以创建多个对象，但是个数是有限制的，比如只能创建3个对象。如果用代码来简单示例一下的话，就是下面这个样子：</p><pre><code>public class BackendServer {\n  private long serverNo;\n  private String serverAddress;\n\n  private static final int SERVER_COUNT = 3;\n  private static final Map&lt;Long, BackendServer&gt; serverInstances = new HashMap&lt;&gt;();\n\n  static {\n    serverInstances.put(1L, new BackendServer(1L, &quot;192.134.22.138:8080&quot;));\n    serverInstances.put(2L, new BackendServer(2L, &quot;192.134.22.139:8080&quot;));\n    serverInstances.put(3L, new BackendServer(3L, &quot;192.134.22.140:8080&quot;));\n  }\n\n  private BackendServer(long serverNo, String serverAddress) {\n    this.serverNo = serverNo;\n    this.serverAddress = serverAddress;\n  }\n\n  public BackendServer getInstance(long serverNo) {\n    return serverInstances.get(serverNo);\n  }\n\n  public BackendServer getRandomInstance() {\n    Random r = new Random();\n    int no = r.nextInt(SERVER_COUNT)+1;\n    return serverInstances.get(no);\n  }\n}\n</code></pre><p>实际上，对于多例模式，还有一种理解方式：同一类型的只能创建一个对象，不同类型的可以创建多个对象。这里的“类型”如何理解呢？</p><p>我们还是通过一个例子来解释一下，具体代码如下所示。在代码中，logger name就是刚刚说的“类型”，同一个logger name获取到的对象实例是相同的，不同的logger name获取到的对象实例是不同的。</p><pre><code>public class Logger {\n  private static final ConcurrentHashMap&lt;String, Logger&gt; instances\n          = new ConcurrentHashMap&lt;&gt;();\n\n  private Logger() {}\n\n  public static Logger getInstance(String loggerName) {\n    instances.putIfAbsent(loggerName, new Logger());\n    return instances.get(loggerName);\n  }\n\n  public void log() {\n    //...\n  }\n}\n\n//l1==l2, l1!=l3\nLogger l1 = Logger.getInstance(&quot;User.class&quot;);\nLogger l2 = Logger.getInstance(&quot;User.class&quot;);\nLogger l3 = Logger.getInstance(&quot;Order.class&quot;);\n</code></pre><p>这种多例模式的理解方式有点类似工厂模式。它跟工厂模式的不同之处是，多例模式创建的对象都是同一个类的对象，而工厂模式创建的是不同子类的对象，关于这一点，下一节课中就会讲到。实际上，它还有点类似享元模式，两者的区别等到我们讲到享元模式的时候再来分析。除此之外，实际上，枚举类型也相当于多例模式，一个类型只能对应一个对象，一个类可以创建多个对象。</p><h2>重点回顾</h2><p>好了，今天的内容到此就讲完了。我们来一块总结回顾一下，你需要掌握的重点内容。</p><p>今天的内容比较偏理论，在实际的项目开发中，没有太多的应用。讲解的目的，主要还是拓展你的思路，锻炼你的逻辑思维能力，加深你对单例的认识。</p><p><strong>1.如何理解单例模式的唯一性？</strong></p><p>单例类中对象的唯一性的作用范围是“进程唯一”的。“进程唯一”指的是进程内唯一，进程间不唯一；“线程唯一”指的是线程内唯一，线程间可以不唯一。实际上，“进程唯一”就意味着线程内、线程间都唯一，这也是“进程唯一”和“线程唯一”的区别之处。“集群唯一”指的是进程内唯一、进程间也唯一。</p><p><strong>2.如何实现线程唯一的单例？</strong></p><p>我们通过一个HashMap来存储对象，其中key是线程ID，value是对象。这样我们就可以做到，不同的线程对应不同的对象，同一个线程只能对应一个对象。实际上，Java语言本身提供了ThreadLocal并发工具类，可以更加轻松地实现线程唯一单例。</p><p><strong>3.如何实现集群环境下的单例？</strong></p><p>我们需要把这个单例对象序列化并存储到外部共享存储区（比如文件）。进程在使用这个单例对象的时候，需要先从外部共享存储区中将它读取到内存，并反序列化成对象，然后再使用，使用完成之后还需要再存储回外部共享存储区。为了保证任何时刻在进程间都只有一份对象存在，一个进程在获取到对象之后，需要对对象加锁，避免其他进程再将其获取。在进程使用完这个对象之后，需要显式地将对象从内存中删除，并且释放对对象的加锁。</p><p><strong>4.如何实现一个多例模式？</strong></p><p>“单例”指的是一个类只能创建一个对象。对应地，“多例”指的就是一个类可以创建多个对象，但是个数是有限制的，比如只能创建3个对象。多例的实现也比较简单，通过一个Map来存储对象类型和对象之间的对应关系，来控制对象的个数。</p><h2>课堂讨论</h2><p>在文章中，我们讲到单例唯一性的作用范围是进程，实际上，对于Java语言来说，单例类对象的唯一性的作用范围并非进程，而是类加载器（Class Loader），你能自己研究并解释一下为什么吗？</p><p>欢迎在留言区写下你的答案，和同学一起交流和分享。如果有收获，也欢迎你把这篇文章分享给你的朋友。</p>",
                "article_title": "43 | 单例模式（下）：如何设计实现一个集群环境下的分布式单例模式？"
            },
            {
                "title": "44 | 工厂模式（上）：我为什么说没事不要随便用工厂模式创建对象？",
                "herf": "https://time.geekbang.org/column/article/197254",
                "id": "197254",
                "content": "<p>上几节课我们讲了单例模式，今天我们再来讲另外一个比较常用的创建型模式：工厂模式（Factory Design Pattern）。</p><p>一般情况下，工厂模式分为三种更加细分的类型：简单工厂、工厂方法和抽象工厂。不过，在GoF的《设计模式》一书中，它将简单工厂模式看作是工厂方法模式的一种特例，所以工厂模式只被分成了工厂方法和抽象工厂两类。实际上，前面一种分类方法更加常见，所以，在今天的讲解中，我们沿用第一种分类方法。</p><p>在这三种细分的工厂模式中，简单工厂、工厂方法原理比较简单，在实际的项目中也比较常用。而抽象工厂的原理稍微复杂点，在实际的项目中相对也不常用。所以，我们今天讲解的重点是前两种工厂模式。对于抽象工厂，你稍微了解一下即可。</p><p>除此之外，我们讲解的重点也不是原理和实现，因为这些都很简单，重点还是带你搞清楚应用场景：什么时候该用工厂模式？相对于直接new来创建对象，用工厂模式来创建究竟有什么好处呢？</p><p>话不多说，让我们正式开始今天的学习吧！</p><h2>简单工厂（Simple Factory）</h2><p>首先，我们来看，什么是简单工厂模式。我们通过一个例子来解释一下。</p><p>在下面这段代码中，我们根据配置文件的后缀（json、xml、yaml、properties），选择不同的解析器（JsonRuleConfigParser、XmlRuleConfigParser……），将存储在文件中的配置解析成内存对象RuleConfig。</p><!-- [[[read_end]]] --><pre><code>public class RuleConfigSource {\n  public RuleConfig load(String ruleConfigFilePath) {\n    String ruleConfigFileExtension = getFileExtension(ruleConfigFilePath);\n    IRuleConfigParser parser = null;\n    if (&quot;json&quot;.equalsIgnoreCase(ruleConfigFileExtension)) {\n      parser = new JsonRuleConfigParser();\n    } else if (&quot;xml&quot;.equalsIgnoreCase(ruleConfigFileExtension)) {\n      parser = new XmlRuleConfigParser();\n    } else if (&quot;yaml&quot;.equalsIgnoreCase(ruleConfigFileExtension)) {\n      parser = new YamlRuleConfigParser();\n    } else if (&quot;properties&quot;.equalsIgnoreCase(ruleConfigFileExtension)) {\n      parser = new PropertiesRuleConfigParser();\n    } else {\n      throw new InvalidRuleConfigException(\n             &quot;Rule config file format is not supported: &quot; + ruleConfigFilePath);\n    }\n\n    String configText = &quot;&quot;;\n    //从ruleConfigFilePath文件中读取配置文本到configText中\n    RuleConfig ruleConfig = parser.parse(configText);\n    return ruleConfig;\n  }\n\n  private String getFileExtension(String filePath) {\n    //...解析文件名获取扩展名，比如rule.json，返回json\n    return &quot;json&quot;;\n  }\n}\n</code></pre><p>在“规范和重构”那一部分中，我们有讲到，为了让代码逻辑更加清晰，可读性更好，我们要善于将功能独立的代码块封装成函数。按照这个设计思路，我们可以将代码中涉及parser创建的部分逻辑剥离出来，抽象成createParser()函数。重构之后的代码如下所示：</p><pre><code>  public RuleConfig load(String ruleConfigFilePath) {\n    String ruleConfigFileExtension = getFileExtension(ruleConfigFilePath);\n    IRuleConfigParser parser = createParser(ruleConfigFileExtension);\n    if (parser == null) {\n      throw new InvalidRuleConfigException(\n              &quot;Rule config file format is not supported: &quot; + ruleConfigFilePath);\n    }\n\n    String configText = &quot;&quot;;\n    //从ruleConfigFilePath文件中读取配置文本到configText中\n    RuleConfig ruleConfig = parser.parse(configText);\n    return ruleConfig;\n  }\n\n  private String getFileExtension(String filePath) {\n    //...解析文件名获取扩展名，比如rule.json，返回json\n    return &quot;json&quot;;\n  }\n\n  private IRuleConfigParser createParser(String configFormat) {\n    IRuleConfigParser parser = null;\n    if (&quot;json&quot;.equalsIgnoreCase(configFormat)) {\n      parser = new JsonRuleConfigParser();\n    } else if (&quot;xml&quot;.equalsIgnoreCase(configFormat)) {\n      parser = new XmlRuleConfigParser();\n    } else if (&quot;yaml&quot;.equalsIgnoreCase(configFormat)) {\n      parser = new YamlRuleConfigParser();\n    } else if (&quot;properties&quot;.equalsIgnoreCase(configFormat)) {\n      parser = new PropertiesRuleConfigParser();\n    }\n    return parser;\n  }\n}\n</code></pre><p>为了让类的职责更加单一、代码更加清晰，我们还可以进一步将createParser()函数剥离到一个独立的类中，让这个类只负责对象的创建。而这个类就是我们现在要讲的简单工厂模式类。具体的代码如下所示：</p><pre><code>public class RuleConfigSource {\n  public RuleConfig load(String ruleConfigFilePath) {\n    String ruleConfigFileExtension = getFileExtension(ruleConfigFilePath);\n    IRuleConfigParser parser = RuleConfigParserFactory.createParser(ruleConfigFileExtension);\n    if (parser == null) {\n      throw new InvalidRuleConfigException(\n              &quot;Rule config file format is not supported: &quot; + ruleConfigFilePath);\n    }\n\n    String configText = &quot;&quot;;\n    //从ruleConfigFilePath文件中读取配置文本到configText中\n    RuleConfig ruleConfig = parser.parse(configText);\n    return ruleConfig;\n  }\n\n  private String getFileExtension(String filePath) {\n    //...解析文件名获取扩展名，比如rule.json，返回json\n    return &quot;json&quot;;\n  }\n}\n\npublic class RuleConfigParserFactory {\n  public static IRuleConfigParser createParser(String configFormat) {\n    IRuleConfigParser parser = null;\n    if (&quot;json&quot;.equalsIgnoreCase(configFormat)) {\n      parser = new JsonRuleConfigParser();\n    } else if (&quot;xml&quot;.equalsIgnoreCase(configFormat)) {\n      parser = new XmlRuleConfigParser();\n    } else if (&quot;yaml&quot;.equalsIgnoreCase(configFormat)) {\n      parser = new YamlRuleConfigParser();\n    } else if (&quot;properties&quot;.equalsIgnoreCase(configFormat)) {\n      parser = new PropertiesRuleConfigParser();\n    }\n    return parser;\n  }\n}\n</code></pre><p>大部分工厂类都是以“Factory”这个单词结尾的，但也不是必须的，比如Java中的DateFormat、Calender。除此之外，工厂类中创建对象的方法一般都是create开头，比如代码中的createParser()，但有的也命名为getInstance()、createInstance()、newInstance()，有的甚至命名为valueOf()（比如Java String类的valueOf()函数）等等，这个我们根据具体的场景和习惯来命名就好。</p><p>在上面的代码实现中，我们每次调用RuleConfigParserFactory的createParser()的时候，都要创建一个新的parser。实际上，如果parser可以复用，为了节省内存和对象创建的时间，我们可以将parser事先创建好缓存起来。当调用createParser()函数的时候，我们从缓存中取出parser对象直接使用。</p><p>这有点类似单例模式和简单工厂模式的结合，具体的代码实现如下所示。在接下来的讲解中，我们把上一种实现方法叫作简单工厂模式的第一种实现方法，把下面这种实现方法叫作简单工厂模式的第二种实现方法。</p><pre><code>public class RuleConfigParserFactory {\n  private static final Map&lt;String, RuleConfigParser&gt; cachedParsers = new HashMap&lt;&gt;();\n\n  static {\n    cachedParsers.put(&quot;json&quot;, new JsonRuleConfigParser());\n    cachedParsers.put(&quot;xml&quot;, new XmlRuleConfigParser());\n    cachedParsers.put(&quot;yaml&quot;, new YamlRuleConfigParser());\n    cachedParsers.put(&quot;properties&quot;, new PropertiesRuleConfigParser());\n  }\n\n  public static IRuleConfigParser createParser(String configFormat) {\n    if (configFormat == null || configFormat.isEmpty()) {\n      return null;//返回null还是IllegalArgumentException全凭你自己说了算\n    }\n    IRuleConfigParser parser = cachedParsers.get(configFormat.toLowerCase());\n    return parser;\n  }\n}\n</code></pre><p>对于上面两种简单工厂模式的实现方法，如果我们要添加新的parser，那势必要改动到RuleConfigParserFactory的代码，那这是不是违反开闭原则呢？实际上，如果不是需要频繁地添加新的parser，只是偶尔修改一下RuleConfigParserFactory代码，稍微不符合开闭原则，也是完全可以接受的。</p><p>除此之外，在RuleConfigParserFactory的第一种代码实现中，有一组if分支判断逻辑，是不是应该用多态或其他设计模式来替代呢？实际上，如果if分支并不是很多，代码中有if分支也是完全可以接受的。应用多态或设计模式来替代if分支判断逻辑，也并不是没有任何缺点的，它虽然提高了代码的扩展性，更加符合开闭原则，但也增加了类的个数，牺牲了代码的可读性。关于这一点，我们在后面章节中会详细讲到。</p><p>总结一下，尽管简单工厂模式的代码实现中，有多处if分支判断逻辑，违背开闭原则，但权衡扩展性和可读性，这样的代码实现在大多数情况下（比如，不需要频繁地添加parser，也没有太多的parser）是没有问题的。</p><h2>工厂方法（Factory Method）</h2><p>如果我们非得要将if分支逻辑去掉，那该怎么办呢？比较经典处理方法就是利用多态。按照多态的实现思路，对上面的代码进行重构。重构之后的代码如下所示：</p><pre><code>public interface IRuleConfigParserFactory {\n  IRuleConfigParser createParser();\n}\n\npublic class JsonRuleConfigParserFactory implements IRuleConfigParserFactory {\n  @Override\n  public IRuleConfigParser createParser() {\n    return new JsonRuleConfigParser();\n  }\n}\n\npublic class XmlRuleConfigParserFactory implements IRuleConfigParserFactory {\n  @Override\n  public IRuleConfigParser createParser() {\n    return new XmlRuleConfigParser();\n  }\n}\n\npublic class YamlRuleConfigParserFactory implements IRuleConfigParserFactory {\n  @Override\n  public IRuleConfigParser createParser() {\n    return new YamlRuleConfigParser();\n  }\n}\n\npublic class PropertiesRuleConfigParserFactory implements IRuleConfigParserFactory {\n  @Override\n  public IRuleConfigParser createParser() {\n    return new PropertiesRuleConfigParser();\n  }\n}\n</code></pre><p>实际上，这就是工厂方法模式的典型代码实现。这样当我们新增一种parser的时候，只需要新增一个实现了IRuleConfigParserFactory接口的Factory类即可。所以，<strong>工厂方法模式比起简单工厂模式更加符合开闭原则。</strong></p><p>从上面的工厂方法的实现来看，一切都很完美，但是实际上存在挺大的问题。问题存在于这些工厂类的使用上。接下来，我们看一下，如何用这些工厂类来实现RuleConfigSource的load()函数。具体的代码如下所示：</p><pre><code>public class RuleConfigSource {\n  public RuleConfig load(String ruleConfigFilePath) {\n    String ruleConfigFileExtension = getFileExtension(ruleConfigFilePath);\n\n    IRuleConfigParserFactory parserFactory = null;\n    if (&quot;json&quot;.equalsIgnoreCase(ruleConfigFileExtension)) {\n      parserFactory = new JsonRuleConfigParserFactory();\n    } else if (&quot;xml&quot;.equalsIgnoreCase(ruleConfigFileExtension)) {\n      parserFactory = new XmlRuleConfigParserFactory();\n    } else if (&quot;yaml&quot;.equalsIgnoreCase(ruleConfigFileExtension)) {\n      parserFactory = new YamlRuleConfigParserFactory();\n    } else if (&quot;properties&quot;.equalsIgnoreCase(ruleConfigFileExtension)) {\n      parserFactory = new PropertiesRuleConfigParserFactory();\n    } else {\n      throw new InvalidRuleConfigException(&quot;Rule config file format is not supported: &quot; + ruleConfigFilePath);\n    }\n    IRuleConfigParser parser = parserFactory.createParser();\n\n    String configText = &quot;&quot;;\n    //从ruleConfigFilePath文件中读取配置文本到configText中\n    RuleConfig ruleConfig = parser.parse(configText);\n    return ruleConfig;\n  }\n\n  private String getFileExtension(String filePath) {\n    //...解析文件名获取扩展名，比如rule.json，返回json\n    return &quot;json&quot;;\n  }\n}\n</code></pre><p>从上面的代码实现来看，工厂类对象的创建逻辑又耦合进了load()函数中，跟我们最初的代码版本非常相似，引入工厂方法非但没有解决问题，反倒让设计变得更加复杂了。那怎么来解决这个问题呢？</p><p><strong>我们可以为工厂类再创建一个简单工厂，也就是工厂的工厂，用来创建工厂类对象。</strong>这段话听起来有点绕，我把代码实现出来了，你一看就能明白了。其中，RuleConfigParserFactoryMap类是创建工厂对象的工厂类，getParserFactory()返回的是缓存好的单例工厂对象。</p><pre><code>public class RuleConfigSource {\n  public RuleConfig load(String ruleConfigFilePath) {\n    String ruleConfigFileExtension = getFileExtension(ruleConfigFilePath);\n\n    IRuleConfigParserFactory parserFactory = RuleConfigParserFactoryMap.getParserFactory(ruleConfigFileExtension);\n    if (parserFactory == null) {\n      throw new InvalidRuleConfigException(&quot;Rule config file format is not supported: &quot; + ruleConfigFilePath);\n    }\n    IRuleConfigParser parser = parserFactory.createParser();\n\n    String configText = &quot;&quot;;\n    //从ruleConfigFilePath文件中读取配置文本到configText中\n    RuleConfig ruleConfig = parser.parse(configText);\n    return ruleConfig;\n  }\n\n  private String getFileExtension(String filePath) {\n    //...解析文件名获取扩展名，比如rule.json，返回json\n    return &quot;json&quot;;\n  }\n}\n\n//因为工厂类只包含方法，不包含成员变量，完全可以复用，\n//不需要每次都创建新的工厂类对象，所以，简单工厂模式的第二种实现思路更加合适。\npublic class RuleConfigParserFactoryMap { //工厂的工厂\n  private static final Map&lt;String, IRuleConfigParserFactory&gt; cachedFactories = new HashMap&lt;&gt;();\n\n  static {\n    cachedFactories.put(&quot;json&quot;, new JsonRuleConfigParserFactory());\n    cachedFactories.put(&quot;xml&quot;, new XmlRuleConfigParserFactory());\n    cachedFactories.put(&quot;yaml&quot;, new YamlRuleConfigParserFactory());\n    cachedFactories.put(&quot;properties&quot;, new PropertiesRuleConfigParserFactory());\n  }\n\n  public static IRuleConfigParserFactory getParserFactory(String type) {\n    if (type == null || type.isEmpty()) {\n      return null;\n    }\n    IRuleConfigParserFactory parserFactory = cachedFactories.get(type.toLowerCase());\n    return parserFactory;\n  }\n}\n</code></pre><p>当我们需要添加新的规则配置解析器的时候，我们只需要创建新的parser类和parser factory类，并且在RuleConfigParserFactoryMap类中，将新的parser factory对象添加到cachedFactories中即可。代码的改动非常少，基本上符合开闭原则。</p><p>实际上，对于规则配置文件解析这个应用场景来说，工厂模式需要额外创建诸多Factory类，也会增加代码的复杂性，而且，每个Factory类只是做简单的new操作，功能非常单薄（只有一行代码），也没必要设计成独立的类，所以，在这个应用场景下，简单工厂模式简单好用，比工厂方法模式更加合适。</p><p><strong>那什么时候该用工厂方法模式，而非简单工厂模式呢？</strong></p><p>我们前面提到，之所以将某个代码块剥离出来，独立为函数或者类，原因是这个代码块的逻辑过于复杂，剥离之后能让代码更加清晰，更加可读、可维护。但是，如果代码块本身并不复杂，就几行代码而已，我们完全没必要将它拆分成单独的函数或者类。</p><p>基于这个设计思想，当对象的创建逻辑比较复杂，不只是简单的new一下就可以，而是要组合其他类对象，做各种初始化操作的时候，我们推荐使用工厂方法模式，将复杂的创建逻辑拆分到多个工厂类中，让每个工厂类都不至于过于复杂。而使用简单工厂模式，将所有的创建逻辑都放到一个工厂类中，会导致这个工厂类变得很复杂。</p><p>除此之外，在某些场景下，如果对象不可复用，那工厂类每次都要返回不同的对象。如果我们使用简单工厂模式来实现，就只能选择第一种包含if分支逻辑的实现方式。如果我们还想避免烦人的if-else分支逻辑，这个时候，我们就推荐使用工厂方法模式。</p><h2>抽象工厂（Abstract Factory）</h2><p>讲完了简单工厂、工厂方法，我们再来看抽象工厂模式。抽象工厂模式的应用场景比较特殊，没有前两种常用，所以不是我们本节课学习的重点，你简单了解一下就可以了。</p><p>在简单工厂和工厂方法中，类只有一种分类方式。比如，在规则配置解析那个例子中，解析器类只会根据配置文件格式（Json、Xml、Yaml……）来分类。但是，如果类有两种分类方式，比如，我们既可以按照配置文件格式来分类，也可以按照解析的对象（Rule规则配置还是System系统配置）来分类，那就会对应下面这8个parser类。</p><pre><code>针对规则配置的解析器：基于接口IRuleConfigParser\nJsonRuleConfigParser\nXmlRuleConfigParser\nYamlRuleConfigParser\nPropertiesRuleConfigParser\n\n针对系统配置的解析器：基于接口ISystemConfigParser\nJsonSystemConfigParser\nXmlSystemConfigParser\nYamlSystemConfigParser\nPropertiesSystemConfigParser\n</code></pre><p>针对这种特殊的场景，如果还是继续用工厂方法来实现的话，我们要针对每个parser都编写一个工厂类，也就是要编写8个工厂类。如果我们未来还需要增加针对业务配置的解析器（比如IBizConfigParser），那就要再对应地增加4个工厂类。而我们知道，过多的类也会让系统难维护。这个问题该怎么解决呢？</p><p>抽象工厂就是针对这种非常特殊的场景而诞生的。我们可以让一个工厂负责创建多个不同类型的对象（IRuleConfigParser、ISystemConfigParser等），而不是只创建一种parser对象。这样就可以有效地减少工厂类的个数。具体的代码实现如下所示：</p><pre><code>public interface IConfigParserFactory {\n  IRuleConfigParser createRuleParser();\n  ISystemConfigParser createSystemParser();\n  //此处可以扩展新的parser类型，比如IBizConfigParser\n}\n\npublic class JsonConfigParserFactory implements IConfigParserFactory {\n  @Override\n  public IRuleConfigParser createRuleParser() {\n    return new JsonRuleConfigParser();\n  }\n\n  @Override\n  public ISystemConfigParser createSystemParser() {\n    return new JsonSystemConfigParser();\n  }\n}\n\npublic class XmlConfigParserFactory implements IConfigParserFactory {\n  @Override\n  public IRuleConfigParser createRuleParser() {\n    return new XmlRuleConfigParser();\n  }\n\n  @Override\n  public ISystemConfigParser createSystemParser() {\n    return new XmlSystemConfigParser();\n  }\n}\n\n// 省略YamlConfigParserFactory和PropertiesConfigParserFactory代码\n</code></pre><h2>\b重点回顾</h2><p>好了，今天的内容到此就讲完了。我们来一块总结回顾一下，你需要重点掌握的内容。</p><p>在今天讲的三种工厂模式中，简单工厂和工厂方法比较常用，抽象工厂的应用场景比较特殊，所以很少用到，不是我们学习的重点。所以，下面我重点对前两种工厂模式的应用场景进行总结。</p><p>当创建逻辑比较复杂，是一个“大工程”的时候，我们就考虑使用工厂模式，封装对象的创建过程，将对象的创建和使用相分离。何为创建逻辑比较复杂呢？我总结了下面两种情况。</p><ul>\n<li>第一种情况：类似规则配置解析的例子，代码中存在if-else分支判断，动态地根据不同的类型创建不同的对象。针对这种情况，我们就考虑使用工厂模式，将这一大坨if-else创建对象的代码抽离出来，放到工厂类中。</li>\n<li>还有一种情况，尽管我们不需要根据不同的类型创建不同的对象，但是，单个对象本身的创建过程比较复杂，比如前面提到的要组合其他类对象，做各种初始化操作。在这种情况下，我们也可以考虑使用工厂模式，将对象的创建过程封装到工厂类中。</li>\n</ul><p>对于第一种情况，当每个对象的创建逻辑都比较简单的时候，我推荐使用简单工厂模式，将多个对象的创建逻辑放到一个工厂类中。当每个对象的创建逻辑都比较复杂的时候，为了避免设计一个过于庞大的简单工厂类，我推荐使用工厂方法模式，将创建逻辑拆分得更细，每个对象的创建逻辑独立到各自的工厂类中。同理，对于第二种情况，因为单个对象本身的创建逻辑就比较复杂，所以，我建议使用工厂方法模式。</p><p>除了刚刚提到的这几种情况之外，如果创建对象的逻辑并不复杂，那我们就直接通过new来创建对象就可以了，不需要使用工厂模式。</p><p>现在，我们上升一个思维层面来看工厂模式，它的作用无外乎下面这四个。这也是判断要不要使用工厂模式的最本质的参考标准。</p><ul>\n<li>封装变化：创建逻辑有可能变化，封装成工厂类之后，创建逻辑的变更对调用者透明。</li>\n<li>代码复用：\b创建代码抽离到独立的工厂类之后可以复用。</li>\n<li>隔离复杂性：封装复杂的创建逻辑，调用者无需了解如何创建对象。</li>\n<li>控制复杂度：将创建代码抽离出来，让原本的函数或类职责更单一，代码更简洁。</li>\n</ul><h2>课堂讨论</h2><ol>\n<li>工厂模式是一种非常常用的设计模式，在很多开源项目、工具类中到处可见，比如Java中的Calendar、DateFormat类。除此之外，你还知道哪些用工厂模式实现类？可以留言说一说它们为什么要设计成工厂模式类？</li>\n<li>实际上，简单工厂模式还叫作静态工厂方法模式（Static Factory Method Pattern）。之所以叫静态工厂方法模式，是因为其中创建对象的方法是静态的。那为什么要设置成静态的呢？设置成静态的，在使用的时候，是否会影响到代码的可测试性呢？</li>\n</ol><p>欢迎在留言区写下你的答案，和同学一起交流和分享。如果有收获，也欢迎你把这篇文章分享给你的朋友。</p>",
                "article_title": "44 | 工厂模式（上）：我为什么说没事不要随便用工厂模式创建对象？"
            },
            {
                "title": "45 | 工厂模式（下）：如何设计实现一个Dependency Injection框架？",
                "herf": "https://time.geekbang.org/column/article/198614",
                "id": "198614",
                "content": "<p>在上一节课我们讲到，当创建对象是一个“大工程”的时候，我们一般会选择使用工厂模式，来封装对象复杂的创建过程，将对象的创建和使用分离，让代码更加清晰。那何为“大工程”呢？上一节课中我们讲了两种情况，一种是创建过程涉及复杂的if-else分支判断，另一种是对象创建需要组装多个其他类对象或者需要复杂的初始化过程。</p><p>今天，我们再来讲一个创建对象的“大工程”，依赖注入框架，或者叫依赖注入容器（Dependency Injection Container），简称DI容器。在今天的讲解中，我会带你一块搞清楚这样几个问题：DI容器跟我们讲的工厂模式又有何区别和联系？DI容器的核心功能有哪些，以及如何实现一个简单的DI容器？</p><p>话不多说，让我们正式开始今天的学习吧！</p><h2>工厂模式和DI容器有何区别？</h2><p>实际上，DI容器底层最基本的设计思路就是基于工厂模式的。DI容器相当于一个大的工厂类，负责在程序启动的时候，根据配置（要创建哪些类对象，每个类对象的创建需要依赖哪些其他类对象）事先创建好对象。当应用程序需要使用某个类对象的时候，直接从容器中获取即可。正是因为它持有一堆对象，所以这个框架才被称为“容器”。</p><p>DI容器相对于我们上节课讲的工厂模式的例子来说，它处理的是更大的对象创建工程。上节课讲的工厂模式中，一个工厂类只负责某个类对象或者某一组相关类对象（继承自同一抽象类或者接口的子类）的创建，而DI容器负责的是整个应用中所有类对象的创建。</p><!-- [[[read_end]]] --><p>除此之外，DI容器负责的事情要比单纯的工厂模式要多。比如，它还包括配置的解析、对象生命周期的管理。接下来，我们就详细讲讲，一个简单的DI容器应该包含哪些核心功能。</p><h2>DI容器的核心功能有哪些？</h2><p>总结一下，一个简单的DI容器的核心功能一般有三个：配置解析、对象创建和对象生命周期管理。</p><p><strong>首先，我们来看配置解析。</strong></p><p>在上节课讲的工厂模式中，工厂类要创建哪个类对象是事先确定好的，并且是写死在工厂类代码中的。作为一个通用的框架来说，框架代码跟应用代码应该是高度解耦的，DI容器事先并不知道应用会创建哪些对象，不可能把某个应用要创建的对象写死在框架代码中。所以，我们需要通过一种形式，让应用告知DI容器要创建哪些对象。这种形式就是我们要讲的配置。</p><p>我们将需要由DI容器来创建的类对象和创建类对象的必要信息（使用哪个构造函数以及对应的构造函数参数都是什么等等），放到配置文件中。容器读取配置文件，根据配置文件提供的信息来创建对象。</p><p>下面是一个典型的Spring容器的配置文件。Spring容器读取这个配置文件，解析出要创建的两个对象：rateLimiter和redisCounter，并且得到两者的依赖关系：rateLimiter依赖redisCounter。</p><pre><code>public class RateLimiter {\n  private RedisCounter redisCounter;\n  public RateLimiter(RedisCounter redisCounter) {\n    this.redisCounter = redisCounter;\n  }\n  public void test() {\n    System.out.println(&quot;Hello World!&quot;);\n  }\n  //...\n}\n\npublic class RedisCounter {\n  private String ipAddress;\n  private int port;\n  public RedisCounter(String ipAddress, int port) {\n    this.ipAddress = ipAddress;\n    this.port = port;\n  }\n  //...\n}\n\n配置文件beans.xml：\n&lt;beans&gt;\n   &lt;bean id=&quot;rateLimiter&quot; class=&quot;com.xzg.RateLimiter&quot;&gt;\n      &lt;constructor-arg ref=&quot;redisCounter&quot;/&gt;\n   &lt;/bean&gt;\n \n   &lt;bean id=&quot;redisCounter&quot; class=&quot;com.xzg.redisCounter&quot;&gt;\n     &lt;constructor-arg type=&quot;String&quot; value=&quot;127.0.0.1&quot;&gt;\n     &lt;constructor-arg type=&quot;int&quot; value=1234&gt;\n   &lt;/bean&gt;\n&lt;/beans&gt;\n</code></pre><p><strong>其次，我们再来看对象创建。</strong></p><p>在DI容器中，如果我们给每个类都对应创建一个工厂类，那项目中类的个数会成倍增加，这会增加代码的维护成本。要解决这个问题并不难。我们只需要将所有类对象的创建都放到一个工厂类中完成就可以了，比如BeansFactory。</p><p>你可能会说，如果要创建的类对象非常多，BeansFactory中的代码会不会线性膨胀（代码量跟创建对象的个数成正比）呢？实际上并不会。待会讲到DI容器的具体实现的时候，我们会讲“反射”这种机制，它能在程序运行的过程中，动态地加载类、创建对象，不需要事先在代码中写死要创建哪些对象。所以，不管是创建一个对象还是十个对象，BeansFactory工厂类代码都是一样的。</p><p><strong>最后，我们来看对象的生命周期管理。</strong></p><p>上一节课我们讲到，简单工厂模式有两种实现方式，一种是每次都返回新创建的对象，另一种是每次都返回同一个事先创建好的对象，也就是所谓的单例对象。在Spring框架中，我们可以通过配置scope属性，来区分这两种不同类型的对象。scope=prototype表示返回新创建的对象，scope=singleton表示返回单例对象。</p><p>除此之外，我们还可以配置对象是否支持懒加载。如果lazy-init=true，对象在真正被使用到的时候（比如：BeansFactory.getBean(“userService”)）才被被创建；如果lazy-init=false，对象在应用启动的时候就事先创建好。</p><p>不仅如此，我们还可以配置对象的init-method和destroy-method方法，比如init-method=loadProperties()，destroy-method=updateConfigFile()。DI容器在创建好对象之后，会主动调用init-method属性指定的方法来初始化对象。在对象被最终销毁之前，DI容器会主动调用destroy-method属性指定的方法来做一些清理工作，比如释放数据库连接池、关闭文件。</p><h2>如何实现一个简单的DI容器？</h2><p>实际上，用Java语言来实现一个简单的DI容器，核心逻辑只需要包括这样两个部分：配置文件解析、根据配置文件通过“反射”语法来创建对象。</p><h3>1.最小原型设计</h3><p>因为我们主要是讲解设计模式，所以，在今天的讲解中，我们只实现一个DI容器的最小原型。像Spring框架这样的DI容器，它支持的配置格式非常灵活和复杂。为了简化代码实现，重点讲解原理，在最小原型中，我们只支持下面配置文件中涉及的配置语法。</p><pre><code>配置文件beans.xml\n&lt;beans&gt;\n   &lt;bean id=&quot;rateLimiter&quot; class=&quot;com.xzg.RateLimiter&quot;&gt;\n      &lt;constructor-arg ref=&quot;redisCounter&quot;/&gt;\n   &lt;/bean&gt;\n \n   &lt;bean id=&quot;redisCounter&quot; class=&quot;com.xzg.redisCounter&quot; scope=&quot;singleton&quot; lazy-init=&quot;true&quot;&gt;\n     &lt;constructor-arg type=&quot;String&quot; value=&quot;127.0.0.1&quot;&gt;\n     &lt;constructor-arg type=&quot;int&quot; value=1234&gt;\n   &lt;/bean&gt;\n&lt;/bean\n</code></pre><p>最小原型的使用方式跟Spring框架非常类似，示例代码如下所示：</p><pre><code>public class Demo {\n  public static void main(String[] args) {\n    ApplicationContext applicationContext = new ClassPathXmlApplicationContext(\n            &quot;beans.xml&quot;);\n    RateLimiter rateLimiter = (RateLimiter) applicationContext.getBean(&quot;rateLimiter&quot;);\n    rateLimiter.test();\n    //...\n  }\n}\n</code></pre><h3>2.提供执行入口</h3><p>前面我们讲到，面向对象设计的最后一步是：组装类并提供执行入口。在这里，执行入口就是一组暴露给外部使用的接口和类。</p><p>通过刚刚的最小原型使用示例代码，我们可以看出，执行入口主要包含两部分：ApplicationContext和ClassPathXmlApplicationContext。其中，ApplicationContext是接口，ClassPathXmlApplicationContext是接口的实现类。两个类具体实现如下所示：</p><pre><code>public interface ApplicationContext {\n  Object getBean(String beanId);\n}\n\npublic class ClassPathXmlApplicationContext implements ApplicationContext {\n  private BeansFactory beansFactory;\n  private BeanConfigParser beanConfigParser;\n\n  public ClassPathXmlApplicationContext(String configLocation) {\n    this.beansFactory = new BeansFactory();\n    this.beanConfigParser = new XmlBeanConfigParser();\n    loadBeanDefinitions(configLocation);\n  }\n\n  private void loadBeanDefinitions(String configLocation) {\n    InputStream in = null;\n    try {\n      in = this.getClass().getResourceAsStream(&quot;/&quot; + configLocation);\n      if (in == null) {\n        throw new RuntimeException(&quot;Can not find config file: &quot; + configLocation);\n      }\n      List&lt;BeanDefinition&gt; beanDefinitions = beanConfigParser.parse(in);\n      beansFactory.addBeanDefinitions(beanDefinitions);\n    } finally {\n      if (in != null) {\n        try {\n          in.close();\n        } catch (IOException e) {\n          // TODO: log error\n        }\n      }\n    }\n  }\n\n  @Override\n  public Object getBean(String beanId) {\n    return beansFactory.getBean(beanId);\n  }\n}\n</code></pre><p>从上面的代码中，我们可以看出，ClassPathXmlApplicationContext负责组装BeansFactory和BeanConfigParser两个类，串联执行流程：从classpath中加载XML格式的配置文件，通过BeanConfigParser解析为统一的BeanDefinition格式，然后，BeansFactory根据BeanDefinition来创建对象。</p><h3>3.配置文件解析</h3><p>配置文件解析主要包含BeanConfigParser接口和XmlBeanConfigParser实现类，负责将配置文件解析为BeanDefinition结构，以便BeansFactory根据这个结构来创建对象。</p><p>配置文件的解析比较繁琐，不涉及我们专栏要讲的理论知识，不是我们讲解的重点，所以这里我只给出两个类的大致设计思路，并未给出具体的实现代码。如果感兴趣的话，你可以自行补充完整。具体的代码框架如下所示：</p><pre><code>public interface BeanConfigParser {\n  List&lt;BeanDefinition&gt; parse(InputStream inputStream);\n  List&lt;BeanDefinition&gt; parse(String configContent);\n}\n\npublic class XmlBeanConfigParser implements BeanConfigParser {\n\n  @Override\n  public List&lt;BeanDefinition&gt; parse(InputStream inputStream) {\n    String content = null;\n    // TODO:...\n    return parse(content);\n  }\n\n  @Override\n  public List&lt;BeanDefinition&gt; parse(String configContent) {\n    List&lt;BeanDefinition&gt; beanDefinitions = new ArrayList&lt;&gt;();\n    // TODO:...\n    return beanDefinitions;\n  }\n\n}\n\npublic class BeanDefinition {\n  private String id;\n  private String className;\n  private List&lt;ConstructorArg&gt; constructorArgs = new ArrayList&lt;&gt;();\n  private Scope scope = Scope.SINGLETON;\n  private boolean lazyInit = false;\n  // 省略必要的getter/setter/constructors\n \n  public boolean isSingleton() {\n    return scope.equals(Scope.SINGLETON);\n  }\n\n\n  public static enum Scope {\n    SINGLETON,\n    PROTOTYPE\n  }\n  \n  public static class ConstructorArg {\n    private boolean isRef;\n    private Class type;\n    private Object arg;\n    // 省略必要的getter/setter/constructors\n  }\n}\n</code></pre><h3>4.核心工厂类设计</h3><p>最后，我们来看，BeansFactory是如何设计和实现的。这也是我们这个DI容器最核心的一个类了。它负责根据从配置文件解析得到的BeanDefinition来创建对象。</p><p>如果对象的scope属性是singleton，那对象创建之后会缓存在singletonObjects这样一个map中，下次再请求此对象的时候，直接从map中取出返回，不需要重新创建。如果对象的scope属性是prototype，那每次请求对象，BeansFactory都会创建一个新的对象返回。</p><p>实际上，BeansFactory创建对象用到的主要技术点就是Java中的反射语法：一种动态加载类和创建对象的机制。我们知道，JVM在启动的时候会根据代码自动地加载类、创建对象。至于都要加载哪些类、创建哪些对象，这些都是在代码中写死的，或者说提前写好的。但是，如果某个对象的创建并不是写死在代码中，而是放到配置文件中，我们需要在程序运行期间，动态地根据配置文件来加载类、创建对象，那这部分工作就没法让JVM帮我们自动完成了，我们需要利用Java提供的反射语法自己去编写代码。</p><p>搞清楚了反射的原理，BeansFactory的代码就不难看懂了。具体代码实现如下所示：</p><pre><code>public class BeansFactory {\n  private ConcurrentHashMap&lt;String, Object&gt; singletonObjects = new ConcurrentHashMap&lt;&gt;();\n  private ConcurrentHashMap&lt;String, BeanDefinition&gt; beanDefinitions = new ConcurrentHashMap&lt;&gt;();\n\n  public void addBeanDefinitions(List&lt;BeanDefinition&gt; beanDefinitionList) {\n    for (BeanDefinition beanDefinition : beanDefinitionList) {\n      this.beanDefinitions.putIfAbsent(beanDefinition.getId(), beanDefinition);\n    }\n\n    for (BeanDefinition beanDefinition : beanDefinitionList) {\n      if (beanDefinition.isLazyInit() == false &amp;&amp; beanDefinition.isSingleton()) {\n        createBean(beanDefinition);\n      }\n    }\n  }\n\n  public Object getBean(String beanId) {\n    BeanDefinition beanDefinition = beanDefinitions.get(beanId);\n    if (beanDefinition == null) {\n      throw new NoSuchBeanDefinitionException(&quot;Bean is not defined: &quot; + beanId);\n    }\n    return createBean(beanDefinition);\n  }\n\n  @VisibleForTesting\n  protected Object createBean(BeanDefinition beanDefinition) {\n    if (beanDefinition.isSingleton() &amp;&amp; singletonObjects.contains(beanDefinition.getId())) {\n      return singletonObjects.get(beanDefinition.getId());\n    }\n\n    Object bean = null;\n    try {\n      Class beanClass = Class.forName(beanDefinition.getClassName());\n      List&lt;BeanDefinition.ConstructorArg&gt; args = beanDefinition.getConstructorArgs();\n      if (args.isEmpty()) {\n        bean = beanClass.newInstance();\n      } else {\n        Class[] argClasses = new Class[args.size()];\n        Object[] argObjects = new Object[args.size()];\n        for (int i = 0; i &lt; args.size(); ++i) {\n          BeanDefinition.ConstructorArg arg = args.get(i);\n          if (!arg.getIsRef()) {\n            argClasses[i] = arg.getType();\n            argObjects[i] = arg.getArg();\n          } else {\n            BeanDefinition refBeanDefinition = beanDefinitions.get(arg.getArg());\n            if (refBeanDefinition == null) {\n              throw new NoSuchBeanDefinitionException(&quot;Bean is not defined: &quot; + arg.getArg());\n            }\n            argClasses[i] = Class.forName(refBeanDefinition.getClassName());\n            argObjects[i] = createBean(refBeanDefinition);\n          }\n        }\n        bean = beanClass.getConstructor(argClasses).newInstance(argObjects);\n      }\n    } catch (ClassNotFoundException | IllegalAccessException\n            | InstantiationException | NoSuchMethodException | InvocationTargetException e) {\n      throw new BeanCreationFailureException(&quot;&quot;, e);\n    }\n\n    if (bean != null &amp;&amp; beanDefinition.isSingleton()) {\n      singletonObjects.putIfAbsent(beanDefinition.getId(), bean);\n      return singletonObjects.get(beanDefinition.getId());\n    }\n    return bean;\n  }\n}\n</code></pre><h2>重点回顾</h2><p>好了，今天的内容到此就讲完了。我们来一块总结回顾一下，你需要重点掌握的内容。</p><p>DI容器在一些软件开发中已经成为了标配，比如Spring IOC、Google Guice。但是，大部分人可能只是把它当作一个黑盒子来使用，并未真正去了解它的底层是如何实现的。当然，如果只是做一些简单的小项目，简单会用就足够了，但是，如果我们面对的是非常复杂的系统，当系统出现问题的时候，对底层原理的掌握程度，决定了我们排查问题的能力，直接影响到我们排查问题的效率。</p><p>今天，我们讲解了一个简单的DI容器的实现原理，其核心逻辑主要包括：配置文件解析，以及根据配置文件通过“反射”语法来创建对象。其中，创建对象的过程就应用到了我们在学的工厂模式。对象创建、组装、管理完全有DI容器来负责，跟具体业务代码解耦，让程序员聚焦在业务代码的开发上。</p><h2>课堂讨论</h2><p>BeansFactory类中的createBean()函数是一个递归函数。当构造函数的参数是ref类型时，会递归地创建ref属性指向的对象。如果我们在配置文件中错误地配置了对象之间的依赖关系，导致存在循环依赖，那BeansFactory的createBean()函数是否会出现堆栈溢出？又该如何解决这个问题呢？</p><p>你可以可以在留言区说一说，和同学一起交流和分享。如果有收获，也欢迎你把这篇文章分享给你的朋友。</p>",
                "article_title": "45 | 工厂模式（下）：如何设计实现一个Dependency Injection框架？"
            },
            {
                "title": "46 | 建造者模式：详解构造函数、set方法、建造者模式三种对象创建方式",
                "herf": "https://time.geekbang.org/column/article/199674",
                "id": "199674",
                "content": "<p>上两节课中，我们学习了工厂模式，讲了工厂模式的应用场景，并带你实现了一个简单的DI容器。今天，我们再来学习另外一个比较常用的创建型设计模式，<strong>Builder模式</strong>，中文翻译为<strong>建造者模式</strong>或者<strong>构建者模式</strong>，也有人叫它<strong>生成器模式</strong>。</p><p>实际上，建造者模式的原理和代码实现非常简单，掌握起来并不难，难点在于应用场景。比如，你有没有考虑过这样几个问题：直接使用构造函数或者配合set方法就能创建对象，为什么还需要建造者模式来创建呢？建造者模式和工厂模式都可以创建对象，那它们两个的区别在哪里呢？</p><p>话不多说，带着上面两个问题，让我们开始今天的学习吧！</p><h2>为什么需要建造者模式？</h2><p>在平时的开发中，创建一个对象最常用的方式是，使用new关键字调用类的构造函数来完成。我的问题是，什么情况下这种方式就不适用了，就需要采用建造者模式来创建对象呢？你可以先思考一下，下面我通过一个例子来带你看一下。</p><p>假设有这样一道设计面试题：我们需要定义一个资源池配置类ResourcePoolConfig。这里的资源池，你可以简单理解为线程池、连接池、对象池等。在这个资源池配置类中，有以下几个成员变量，也就是可配置项。现在，请你编写代码实现这个ResourcePoolConfig类。</p><!-- [[[read_end]]] --><p><img src=\"https://static001.geekbang.org/resource/image/21/59/21f970b7c0d6b5afa6aa09ca14f55059.jpg\" alt=\"\"></p><p>只要你稍微有点开发经验，那实现这样一个类对你来说并不是件难事。最常见、最容易想到的实现思路如下代码所示。因为maxTotal、maxIdle、minIdle不是必填变量，所以在创建ResourcePoolConfig对象的时候，我们通过往构造函数中，给这几个参数传递null值，来表示使用默认值。</p><pre><code>public class ResourcePoolConfig {\n  private static final int DEFAULT_MAX_TOTAL = 8;\n  private static final int DEFAULT_MAX_IDLE = 8;\n  private static final int DEFAULT_MIN_IDLE = 0;\n\n  private String name;\n  private int maxTotal = DEFAULT_MAX_TOTAL;\n  private int maxIdle = DEFAULT_MAX_IDLE;\n  private int minIdle = DEFAULT_MIN_IDLE;\n\n  public ResourcePoolConfig(String name, Integer maxTotal, Integer maxIdle, Integer minIdle) {\n    if (StringUtils.isBlank(name)) {\n      throw new IllegalArgumentException(&quot;name should not be empty.&quot;);\n    }\n    this.name = name;\n\n    if (maxTotal != null) {\n      if (maxTotal &lt;= 0) {\n        throw new IllegalArgumentException(&quot;maxTotal should be positive.&quot;);\n      }\n      this.maxTotal = maxTotal;\n    }\n\n    if (maxIdle != null) {\n      if (maxIdle &lt; 0) {\n        throw new IllegalArgumentException(&quot;maxIdle should not be negative.&quot;);\n      }\n      this.maxIdle = maxIdle;\n    }\n\n    if (minIdle != null) {\n      if (minIdle &lt; 0) {\n        throw new IllegalArgumentException(&quot;minIdle should not be negative.&quot;);\n      }\n      this.minIdle = minIdle;\n    }\n  }\n  //...省略getter方法...\n}\n</code></pre><p>现在，ResourcePoolConfig只有4个可配置项，对应到构造函数中，也只有4个参数，参数的个数不多。但是，如果可配置项逐渐增多，变成了8个、10个，甚至更多，那继续沿用现在的设计思路，构造函数的参数列表会变得很长，代码在可读性和易用性上都会变差。在使用构造函数的时候，我们就容易搞错各参数的顺序，传递进错误的参数值，导致非常隐蔽的bug。</p><pre><code>// 参数太多，导致可读性差、参数可能传递错误\nResourcePoolConfig config = new ResourcePoolConfig(&quot;dbconnectionpool&quot;, 16, null, 8, null, false , true, 10, 20，false， true);\n</code></pre><p>解决这个问题的办法你应该也已经想到了，那就是用set()函数来给成员变量赋值，以替代冗长的构造函数。我们直接看代码，具体如下所示。其中，配置项name是必填的，所以我们把它放到构造函数中设置，强制创建类对象的时候就要填写。其他配置项maxTotal、maxIdle、minIdle都不是必填的，所以我们通过set()函数来设置，让使用者自主选择填写或者不填写。</p><pre><code>public class ResourcePoolConfig {\n  private static final int DEFAULT_MAX_TOTAL = 8;\n  private static final int DEFAULT_MAX_IDLE = 8;\n  private static final int DEFAULT_MIN_IDLE = 0;\n\n  private String name;\n  private int maxTotal = DEFAULT_MAX_TOTAL;\n  private int maxIdle = DEFAULT_MAX_IDLE;\n  private int minIdle = DEFAULT_MIN_IDLE;\n  \n  public ResourcePoolConfig(String name) {\n    if (StringUtils.isBlank(name)) {\n      throw new IllegalArgumentException(&quot;name should not be empty.&quot;);\n    }\n    this.name = name;\n  }\n\n  public void setMaxTotal(int maxTotal) {\n    if (maxTotal &lt;= 0) {\n      throw new IllegalArgumentException(&quot;maxTotal should be positive.&quot;);\n    }\n    this.maxTotal = maxTotal;\n  }\n\n  public void setMaxIdle(int maxIdle) {\n    if (maxIdle &lt; 0) {\n      throw new IllegalArgumentException(&quot;maxIdle should not be negative.&quot;);\n    }\n    this.maxIdle = maxIdle;\n  }\n\n  public void setMinIdle(int minIdle) {\n    if (minIdle &lt; 0) {\n      throw new IllegalArgumentException(&quot;minIdle should not be negative.&quot;);\n    }\n    this.minIdle = minIdle;\n  }\n  //...省略getter方法...\n}\n</code></pre><p>接下来，我们来看新的ResourcePoolConfig类该如何使用。我写了一个示例代码，如下所示。没有了冗长的函数调用和参数列表，代码在可读性和易用性上提高了很多。</p><pre><code>// ResourcePoolConfig使用举例\nResourcePoolConfig config = new ResourcePoolConfig(&quot;dbconnectionpool&quot;);\nconfig.setMaxTotal(16);\nconfig.setMaxIdle(8);\n</code></pre><p>至此，我们仍然没有用到建造者模式，通过构造函数设置必填项，通过set()方法设置可选配置项，就能实现我们的设计需求。如果我们把问题的难度再加大点，比如，还需要解决下面这三个问题，那现在的设计思路就不能满足了。</p><ul>\n<li>我们刚刚讲到，name是必填的，所以，我们把它放到构造函数中，强制创建对象的时候就设置。如果必填的配置项有很多，把这些必填配置项都放到构造函数中设置，那构造函数就又会出现参数列表很长的问题。如果我们把必填项也通过set()方法设置，那校验这些必填项是否已经填写的逻辑就无处安放了。</li>\n<li>除此之外，假设配置项之间有一定的依赖关系，比如，如果用户设置了maxTotal、maxIdle、minIdle其中一个，就必须显式地设置另外两个；或者配置项之间有一定的约束条件，比如，maxIdle和minIdle要小于等于maxTotal。如果我们继续使用现在的设计思路，那这些配置项之间的依赖关系或者约束条件的校验逻辑就无处安放了。</li>\n<li>如果我们希望ResourcePoolConfig类对象是不可变对象，也就是说，对象在创建好之后，就不能再修改内部的属性值。要实现这个功能，我们就不能在ResourcePoolConfig类中暴露set()方法。</li>\n</ul><p>为了解决这些问题，建造者模式就派上用场了。</p><p>我们可以把校验逻辑放置到Builder类中，先创建建造者，并且通过set()方法设置建造者的变量值，然后在使用build()方法真正创建对象之前，做集中的校验，校验通过之后才会创建对象。除此之外，我们把ResourcePoolConfig的构造函数改为private私有权限。这样我们就只能通过建造者来创建ResourcePoolConfig类对象。并且，ResourcePoolConfig没有提供任何set()方法，这样我们创建出来的对象就是不可变对象了。</p><p>我们用建造者模式重新实现了上面的需求，具体的代码如下所示：</p><pre><code>public class ResourcePoolConfig {\n  private String name;\n  private int maxTotal;\n  private int maxIdle;\n  private int minIdle;\n\n  private ResourcePoolConfig(Builder builder) {\n    this.name = builder.name;\n    this.maxTotal = builder.maxTotal;\n    this.maxIdle = builder.maxIdle;\n    this.minIdle = builder.minIdle;\n  }\n  //...省略getter方法...\n\n  //我们将Builder类设计成了ResourcePoolConfig的内部类。\n  //我们也可以将Builder类设计成独立的非内部类ResourcePoolConfigBuilder。\n  public static class Builder {\n    private static final int DEFAULT_MAX_TOTAL = 8;\n    private static final int DEFAULT_MAX_IDLE = 8;\n    private static final int DEFAULT_MIN_IDLE = 0;\n\n    private String name;\n    private int maxTotal = DEFAULT_MAX_TOTAL;\n    private int maxIdle = DEFAULT_MAX_IDLE;\n    private int minIdle = DEFAULT_MIN_IDLE;\n\n    public ResourcePoolConfig build() {\n      // 校验逻辑放到这里来做，包括必填项校验、依赖关系校验、约束条件校验等\n      if (StringUtils.isBlank(name)) {\n        throw new IllegalArgumentException(&quot;...&quot;);\n      }\n      if (maxIdle &gt; maxTotal) {\n        throw new IllegalArgumentException(&quot;...&quot;);\n      }\n      if (minIdle &gt; maxTotal || minIdle &gt; maxIdle) {\n        throw new IllegalArgumentException(&quot;...&quot;);\n      }\n\n      return new ResourcePoolConfig(this);\n    }\n\n    public Builder setName(String name) {\n      if (StringUtils.isBlank(name)) {\n        throw new IllegalArgumentException(&quot;...&quot;);\n      }\n      this.name = name;\n      return this;\n    }\n\n    public Builder setMaxTotal(int maxTotal) {\n      if (maxTotal &lt;= 0) {\n        throw new IllegalArgumentException(&quot;...&quot;);\n      }\n      this.maxTotal = maxTotal;\n      return this;\n    }\n\n    public Builder setMaxIdle(int maxIdle) {\n      if (maxIdle &lt; 0) {\n        throw new IllegalArgumentException(&quot;...&quot;);\n      }\n      this.maxIdle = maxIdle;\n      return this;\n    }\n\n    public Builder setMinIdle(int minIdle) {\n      if (minIdle &lt; 0) {\n        throw new IllegalArgumentException(&quot;...&quot;);\n      }\n      this.minIdle = minIdle;\n      return this;\n    }\n  }\n}\n\n// 这段代码会抛出IllegalArgumentException，因为minIdle&gt;maxIdle\nResourcePoolConfig config = new ResourcePoolConfig.Builder()\n        .setName(&quot;dbconnectionpool&quot;)\n        .setMaxTotal(16)\n        .setMaxIdle(10)\n        .setMinIdle(12)\n        .build();\n</code></pre><p>\b</p><p>实际上，使用建造者模式创建对象，还能避免对象存在无效状态。我再举个例子解释一下。比如我们定义了一个长方形类，如果不使用建造者模式，采用先创建后set的方式，那就会导致在第一个set之后，对象处于无效状态。具体代码如下所示：</p><pre><code>Rectangle r = new Rectange(); // r is invalid\nr.setWidth(2); // r is invalid\nr.setHeight(3); // r is valid\n</code></pre><p>为了避免这种无效状态的存在，我们就需要使用构造函数一次性初始化好所有的成员变量。如果构造函数参数过多，我们就需要考虑使用建造者模式，先设置建造者的变量，然后再一次性地创建对象，让对象一直处于有效状态。</p><p>实际上，如果我们并不是很关心对象是否有短暂的无效状态，也不是太在意对象是否是可变的。比如，对象只是用来映射数据库读出来的数据，那我们直接暴露set()方法来设置类的成员变量值是完全没问题的。而且，使用建造者模式来构建对象，代码实际上是有点重复的，ResourcePoolConfig类中的成员变量，要在Builder类中重新再定义一遍。</p><h2>与工厂模式有何区别？</h2><p>从上面的讲解中，我们可以看出，建造者模式是让建造者类来负责对象的创建工作。上一节课中讲到的工厂模式，是由工厂类来负责对象创建的工作。那它们之间有什么区别呢？</p><p>实际上，工厂模式是用来创建不同但是相关类型的对象（继承同一父类或者接口的一组子类），由给定的参数来决定创建哪种类型的对象。建造者模式是用来创建一种类型的复杂对象，通过设置不同的可选参数，“定制化”地创建不同的对象。</p><p>网上有一个经典的例子很好地解释了两者的区别。</p><p>顾客走进一家餐馆点餐，我们利用工厂模式，根据用户不同的选择，来制作不同的食物，比如披萨、汉堡、沙拉。对于披萨来说，用户又有各种配料可以定制，比如奶酪、西红柿、起司，我们通过建造者模式根据用户选择的不同配料来制作披萨。</p><p>实际上，我们也不要太学院派，非得把工厂模式、建造者模式分得那么清楚，我们需要知道的是，每个模式为什么这么设计，能解决什么问题。<strong>只有了解了这些最本质的东西，我们才能不生搬硬套，才能灵活应用，甚至可以混用各种模式创造出新的模式，来解决特定场景的问题。</strong></p><h2>重点回顾</h2><p>好了，今天的内容到此就讲完了。我们一块来总结回顾一下，你需要重点掌握的内容。</p><p>建造者模式的原理和实现比较简单，重点是掌握应用场景，避免过度使用。</p><p>如果一个类中有很多属性，为了避免构造函数的参数列表过长，影响代码的可读性和易用性，我们可以通过构造函数配合set()方法来解决。但是，如果存在下面情况中的任意一种，我们就要考虑使用建造者模式了。</p><ul>\n<li>我们把类的必填属性放到构造函数中，强制创建对象的时候就设置。如果必填的属性有很多，把这些必填属性都放到构造函数中设置，那构造函数就又会出现参数列表很长的问题。如果我们把必填属性通过set()方法设置，那校验这些必填属性是否已经填写的逻辑就无处安放了。</li>\n<li>如果类的属性之间有一定的依赖关系或者约束条件，我们继续使用构造函数配合set()方法的设计思路，那这些依赖关系或约束条件的校验逻辑就无处安放了。</li>\n<li>如果我们希望创建不可变对象，也就是说，对象在创建好之后，就不能再修改内部的属性值，要实现这个功能，我们就不能在类中暴露set()方法。构造函数配合set()方法来设置属性值的方式就不适用了。</li>\n</ul><p>除此之外，在今天的讲解中，我们还对比了工厂模式和建造者模式的区别。工厂模式是用来创建不同但是相关类型的对象（继承同一父类或者接口的一组子类），由给定的参数来决定创建哪种类型的对象。建造者模式是用来创建一种类型的复杂对象，可以通过设置不同的可选参数，“定制化”地创建不同的对象。</p><h2>课堂讨论</h2><p>在下面的ConstructorArg类中，当isRef为true的时候，arg表示String类型的refBeanId，type不需要设置；当isRef为false的时候，arg、type都需要设置。请根据这个需求，完善ConstructorArg类。</p><pre><code> public class ConstructorArg {\n    private boolean isRef;\n    private Class type;\n    private Object arg;\n    // TODO: 待完善...\n  }\n</code></pre><p>欢迎留言和我分享你的想法，如果有收获，你也可以把这篇文章分享给你的朋友。</p>",
                "article_title": "46 | 建造者模式：详解构造函数、set方法、建造者模式三种对象创建方式"
            },
            {
                "title": "47 | 原型模式：如何最快速地clone一个HashMap散列表？",
                "herf": "https://time.geekbang.org/column/article/200786",
                "id": "200786",
                "content": "<p>对于创建型模式，前面我们已经讲了单例模式、工厂模式、建造者模式，今天我们来讲最后一个：原型模式。</p><p>对于熟悉JavaScript语言的前端程序员来说，原型模式是一种比较常用的开发模式。这是因为，有别于Java、C++等基于类的面向对象编程语言，JavaScript是一种基于原型的面向对象编程语言。即便JavaScript现在也引入了类的概念，但它也只是基于原型的语法糖而已。不过，如果你熟悉的是Java、C++等这些编程语言，那在实际的开发中，就很少用到原型模式了。</p><p>今天的讲解跟具体某一语言的语法机制无关，而是通过一个clone散列表的例子带你搞清楚：原型模式的应用场景，以及它的两种实现方式：深拷贝和浅拷贝。虽然原型模式的原理和代码实现非常简单，但今天举的例子还是稍微有点复杂的，你要跟上我的思路，多动脑思考一下。</p><p>话不多说，让我们正式开始今天的学习吧！</p><h2>原型模式的原理与应用</h2><p>如果对象的创建成本比较大，而同一个类的不同对象之间差别不大（大部分字段都相同），在这种情况下，我们可以利用对已有对象（原型）进行复制（或者叫拷贝）的方式来创建新对象，以达到节省创建时间的目的。这种基于原型来创建对象的方式就叫作<strong>原型设计模式</strong>（Prototype Design Pattern），简称<strong>原型模式</strong>。</p><!-- [[[read_end]]] --><p><strong>那何为“对象的创建成本比较大”？</strong></p><p>实际上，创建对象包含的申请内存、给成员变量赋值这一过程，本身并不会花费太多时间，或者说对于大部分业务系统来说，这点时间完全是可以忽略的。应用一个复杂的模式，只得到一点点的性能提升，这就是所谓的过度设计，得不偿失。</p><p>但是，如果对象中的数据需要经过复杂的计算才能得到（比如排序、计算哈希值），或者需要从RPC、网络、数据库、文件系统等非常慢速的IO中读取，这种情况下，我们就可以利用原型模式，从其他已有对象中直接拷贝得到，而不用每次在创建新对象的时候，都重复执行这些耗时的操作。</p><p><strong>这么说还是比较理论，接下来，我们通过一个例子来解释一下刚刚这段话。</strong></p><p>假设数据库中存储了大约10万条“搜索关键词”信息，每条信息包含关键词、关键词被搜索的次数、信息最近被更新的时间等。系统A在启动的时候会加载这份数据到内存中，用于处理某些其他的业务需求。为了方便快速地查找某个关键词对应的信息，我们给关键词建立一个散列表索引。</p><p>如果你熟悉的是Java语言，可以直接使用语言中提供的HashMap容器来实现。其中，HashMap的key为搜索关键词，value为关键词详细信息（比如搜索次数）。我们只需要将数据从数据库中读取出来，放入HashMap就可以了。</p><p>不过，我们还有另外一个系统B，专门用来分析搜索日志，定期（比如间隔10分钟）批量地更新数据库中的数据，并且标记为新的数据版本。比如，在下面的示例图中，我们对v2版本的数据进行更新，得到v3版本的数据。这里我们假设只有更新和新添关键词，没有删除关键词的行为。</p><p><img src=\"https://static001.geekbang.org/resource/image/05/0e/05233c28ddda51b81dfd946ffdef640e.jpg\" alt=\"\"></p><p>为了保证系统A中数据的实时性（不一定非常实时，但数据也不能太旧），系统A需要定期根据数据库中的数据，更新内存中的索引和数据。</p><p>我们该如何实现这个需求呢？</p><p>实际上，也不难。我们只需要在系统A中，记录当前数据的版本Va对应的更新时间Ta，从数据库中捞出更新时间大于Ta的所有搜索关键词，也就是找出Va版本与最新版本数据的“差集”，然后针对差集中的每个关键词进行处理。如果它已经在散列表中存在了，我们就更新相应的搜索次数、更新时间等信息；如果它在散列表中不存在，我们就将它插入到散列表中。</p><p>按照这个设计思路，我给出的示例代码如下所示：</p><pre><code>public class Demo {\n  private ConcurrentHashMap&lt;String, SearchWord&gt; currentKeywords = new ConcurrentHashMap&lt;&gt;();\n  private long lastUpdateTime = -1;\n\n  public void refresh() {\n    // 从数据库中取出更新时间&gt;lastUpdateTime的数据，放入到currentKeywords中\n    List&lt;SearchWord&gt; toBeUpdatedSearchWords = getSearchWords(lastUpdateTime);\n    long maxNewUpdatedTime = lastUpdateTime;\n    for (SearchWord searchWord : toBeUpdatedSearchWords) {\n      if (searchWord.getLastUpdateTime() &gt; maxNewUpdatedTime) {\n        maxNewUpdatedTime = searchWord.getLastUpdateTime();\n      }\n      if (currentKeywords.containsKey(searchWord.getKeyword())) {\n        currentKeywords.replace(searchWord.getKeyword(), searchWord);\n      } else {\n        currentKeywords.put(searchWord.getKeyword(), searchWord);\n      }\n    }\n\n    lastUpdateTime = maxNewUpdatedTime;\n  }\n\n  private List&lt;SearchWord&gt; getSearchWords(long lastUpdateTime) {\n    // TODO: 从数据库中取出更新时间&gt;lastUpdateTime的数据\n    return null;\n  }\n}\n</code></pre><p>不过，现在，我们有一个特殊的要求：任何时刻，系统A中的所有数据都必须是同一个版本的，要么都是版本a，要么都是版本b，不能有的是版本a，有的是版本b。那刚刚的更新方式就不能满足这个要求了。除此之外，我们还要求：在更新内存数据的时候，系统A不能处于不可用状态，也就是不能停机更新数据。</p><p>那我们该如何实现现在这个需求呢？</p><p>实际上，也不难。我们把正在使用的数据的版本定义为“服务版本”，当我们要更新内存中的数据的时候，我们并不是直接在服务版本（假设是版本a数据）上更新，而是重新创建另一个版本数据（假设是版本b数据），等新的版本数据建好之后，再一次性地将服务版本从版本a切换到版本b。这样既保证了数据一直可用，又避免了中间状态的存在。</p><p>按照这个设计思路，我给出的示例代码如下所示：</p><pre><code>public class Demo {\n  private HashMap&lt;String, SearchWord&gt; currentKeywords=new HashMap&lt;&gt;();\n\n  public void refresh() {\n    HashMap&lt;String, SearchWord&gt; newKeywords = new LinkedHashMap&lt;&gt;();\n\n    // 从数据库中取出所有的数据，放入到newKeywords中\n    List&lt;SearchWord&gt; toBeUpdatedSearchWords = getSearchWords();\n    for (SearchWord searchWord : toBeUpdatedSearchWords) {\n      newKeywords.put(searchWord.getKeyword(), searchWord);\n    }\n\n    currentKeywords = newKeywords;\n  }\n\n  private List&lt;SearchWord&gt; getSearchWords() {\n    // TODO: 从数据库中取出所有的数据\n    return null;\n  }\n}\n</code></pre><p>不过，在上面的代码实现中，newKeywords构建的成本比较高。我们需要将这10万条数据从数据库中读出，然后计算哈希值，构建newKeywords。这个过程显然是比较耗时。为了提高效率，原型模式就派上用场了。</p><p>我们拷贝currentKeywords数据到newKeywords中，然后从数据库中只捞出新增或者有更新的关键词，更新到newKeywords中。而相对于10万条数据来说，每次新增或者更新的关键词个数是比较少的，所以，这种策略大大提高了数据更新的效率。</p><p>按照这个设计思路，我给出的示例代码如下所示：</p><pre><code>public class Demo {\n  private HashMap&lt;String, SearchWord&gt; currentKeywords=new HashMap&lt;&gt;();\n  private long lastUpdateTime = -1;\n\n  public void refresh() {\n    // 原型模式就这么简单，拷贝已有对象的数据，更新少量差值\n    HashMap&lt;String, SearchWord&gt; newKeywords = (HashMap&lt;String, SearchWord&gt;) currentKeywords.clone();\n\n    // 从数据库中取出更新时间&gt;lastUpdateTime的数据，放入到newKeywords中\n    List&lt;SearchWord&gt; toBeUpdatedSearchWords = getSearchWords(lastUpdateTime);\n    long maxNewUpdatedTime = lastUpdateTime;\n    for (SearchWord searchWord : toBeUpdatedSearchWords) {\n      if (searchWord.getLastUpdateTime() &gt; maxNewUpdatedTime) {\n        maxNewUpdatedTime = searchWord.getLastUpdateTime();\n      }\n      if (newKeywords.containsKey(searchWord.getKeyword())) {\n        SearchWord oldSearchWord = newKeywords.get(searchWord.getKeyword());\n        oldSearchWord.setCount(searchWord.getCount());\n        oldSearchWord.setLastUpdateTime(searchWord.getLastUpdateTime());\n      } else {\n        newKeywords.put(searchWord.getKeyword(), searchWord);\n      }\n    }\n\n    lastUpdateTime = maxNewUpdatedTime;\n    currentKeywords = newKeywords;\n  }\n\n  private List&lt;SearchWord&gt; getSearchWords(long lastUpdateTime) {\n    // TODO: 从数据库中取出更新时间&gt;lastUpdateTime的数据\n    return null;\n  }\n}\n</code></pre><p>这里我们利用了Java中的clone()语法来复制一个对象。如果你熟悉的语言没有这个语法，那把数据从currentKeywords中一个个取出来，然后再重新计算哈希值，放入到newKeywords中也是可以接受的。毕竟，最耗时的还是从数据库中取数据的操作。相对于数据库的IO操作来说，内存操作和CPU计算的耗时都是可以忽略的。</p><p>不过，不知道你有没有发现，实际上，刚刚的代码实现是有问题的。要弄明白到底有什么问题，我们需要先了解另外两个概念：深拷贝（Deep Copy）和浅拷贝（Shallow Copy）。</p><h2>原型模式的实现方式：深拷贝和浅拷贝</h2><p>我们来看，在内存中，用散列表组织的搜索关键词信息是如何存储的。我画了一张示意图，大致结构如下所示。从图中我们可以发现，散列表索引中，每个结点存储的key是搜索关键词，value是SearchWord对象的内存地址。SearchWord对象本身存储在散列表之外的内存空间中。</p><p><img src=\"https://static001.geekbang.org/resource/image/f5/d2/f5ba85952b27a569687e2d44352216d2.jpg\" alt=\"\"></p><p>浅拷贝和深拷贝的区别在于，浅拷贝只会复制图中的索引（散列表），不会复制数据（SearchWord对象）本身。相反，深拷贝不仅仅会复制索引，还会复制数据本身。浅拷贝得到的对象（newKeywords）跟原始对象（currentKeywords）共享数据（SearchWord对象），而深拷贝得到的是一份完完全全独立的对象。具体的对比如下图所示：</p><p><img src=\"https://static001.geekbang.org/resource/image/74/82/74bceb7a0736957daaa4abeba6826182.jpg\" alt=\"\"></p><p><img src=\"https://static001.geekbang.org/resource/image/b9/1b/b978d054ab3183b9e0ae461e6abac81b.jpg\" alt=\"\"></p><p>在Java语言中，Object类的clone()方法执行的就是我们刚刚说的浅拷贝。它只会拷贝对象中的基本数据类型的数据（比如，int、long），以及引用对象（SearchWord）的内存地址，不会递归地拷贝引用对象本身。</p><p>在上面的代码中，我们通过调用HashMap上的clone()浅拷贝方法来实现原型模式。当我们通过newKeywords更新SearchWord对象的时候（比如，更新“设计模式”这个搜索关键词的访问次数），newKeywords和currentKeywords因为指向相同的一组SearchWord对象，就会导致currentKeywords中指向的SearchWord，有的是老版本的，有的是新版本的，就没法满足我们之前的需求：currentKeywords中的数据在任何时刻都是同一个版本的，不存在介于老版本与新版本之间的中间状态。</p><p>现在，我们又该如何来解决这个问题呢？</p><p>我们可以将浅拷贝替换为深拷贝。newKeywords不仅仅复制currentKeywords的索引，还把SearchWord对象也复制一份出来，这样newKeywords和currentKeywords就指向不同的SearchWord对象，也就不存在更新newKeywords的数据会导致currentKeywords的数据也被更新的问题了。</p><p>那如何实现深拷贝呢？总结一下的话，有下面两种方法。</p><p>第一种方法：递归拷贝对象、对象的引用对象以及引用对象的引用对象……直到要拷贝的对象只包含基本数据类型数据，没有引用对象为止。根据这个思路对之前的代码进行重构。重构之后的代码如下所示：</p><pre><code>public class Demo {\n  private HashMap&lt;String, SearchWord&gt; currentKeywords=new HashMap&lt;&gt;();\n  private long lastUpdateTime = -1;\n\n  public void refresh() {\n    // Deep copy\n    HashMap&lt;String, SearchWord&gt; newKeywords = new HashMap&lt;&gt;();\n    for (HashMap.Entry&lt;String, SearchWord&gt; e : currentKeywords.entrySet()) {\n      SearchWord searchWord = e.getValue();\n      SearchWord newSearchWord = new SearchWord(\n              searchWord.getKeyword(), searchWord.getCount(), searchWord.getLastUpdateTime());\n      newKeywords.put(e.getKey(), newSearchWord);\n    }\n\n    // 从数据库中取出更新时间&gt;lastUpdateTime的数据，放入到newKeywords中\n    List&lt;SearchWord&gt; toBeUpdatedSearchWords = getSearchWords(lastUpdateTime);\n    long maxNewUpdatedTime = lastUpdateTime;\n    for (SearchWord searchWord : toBeUpdatedSearchWords) {\n      if (searchWord.getLastUpdateTime() &gt; maxNewUpdatedTime) {\n        maxNewUpdatedTime = searchWord.getLastUpdateTime();\n      }\n      if (newKeywords.containsKey(searchWord.getKeyword())) {\n        SearchWord oldSearchWord = newKeywords.get(searchWord.getKeyword());\n        oldSearchWord.setCount(searchWord.getCount());\n        oldSearchWord.setLastUpdateTime(searchWord.getLastUpdateTime());\n      } else {\n        newKeywords.put(searchWord.getKeyword(), searchWord);\n      }\n    }\n\n    lastUpdateTime = maxNewUpdatedTime;\n    currentKeywords = newKeywords;\n  }\n\n  private List&lt;SearchWord&gt; getSearchWords(long lastUpdateTime) {\n    // TODO: 从数据库中取出更新时间&gt;lastUpdateTime的数据\n    return null;\n  }\n\n}\n</code></pre><p>第二种方法：先将对象序列化，然后再反序列化成新的对象。具体的示例代码如下所示：</p><pre><code>public Object deepCopy(Object object) {\n  ByteArrayOutputStream bo = new ByteArrayOutputStream();\n  ObjectOutputStream oo = new ObjectOutputStream(bo);\n  oo.writeObject(object);\n  \n  ByteArrayInputStream bi = new ByteArrayInputStream(bo.toByteArray());\n  ObjectInputStream oi = new ObjectInputStream(bi);\n  \n  return oi.readObject();\n}\n</code></pre><p>刚刚的两种实现方法，不管采用哪种，深拷贝都要比浅拷贝耗时、耗内存空间。针对我们这个应用场景，有没有更快、更省内存的实现方式呢？</p><p>我们可以先采用浅拷贝的方式创建newKeywords。对于需要更新的SearchWord对象，我们再使用深度拷贝的方式创建一份新的对象，替换newKeywords中的老对象。毕竟需要更新的数据是很少的。这种方式即利用了浅拷贝节省时间、空间的优点，又能保证currentKeywords中的中数据都是老版本的数据。具体的代码实现如下所示。这也是标题中讲到的，在我们这个应用场景下，最快速clone散列表的方式。</p><pre><code>public class Demo {\n  private HashMap&lt;String, SearchWord&gt; currentKeywords=new HashMap&lt;&gt;();\n  private long lastUpdateTime = -1;\n\n  public void refresh() {\n    // Shallow copy\n    HashMap&lt;String, SearchWord&gt; newKeywords = (HashMap&lt;String, SearchWord&gt;) currentKeywords.clone();\n\n    // 从数据库中取出更新时间&gt;lastUpdateTime的数据，放入到newKeywords中\n    List&lt;SearchWord&gt; toBeUpdatedSearchWords = getSearchWords(lastUpdateTime);\n    long maxNewUpdatedTime = lastUpdateTime;\n    for (SearchWord searchWord : toBeUpdatedSearchWords) {\n      if (searchWord.getLastUpdateTime() &gt; maxNewUpdatedTime) {\n        maxNewUpdatedTime = searchWord.getLastUpdateTime();\n      }\n      if (newKeywords.containsKey(searchWord.getKeyword())) {\n        newKeywords.remove(searchWord.getKeyword());\n      }\n      newKeywords.put(searchWord.getKeyword(), searchWord);\n    }\n\n    lastUpdateTime = maxNewUpdatedTime;\n    currentKeywords = newKeywords;\n  }\n\n  private List&lt;SearchWord&gt; getSearchWords(long lastUpdateTime) {\n    // TODO: 从数据库中取出更新时间&gt;lastUpdateTime的数据\n    return null;\n  }\n}\n</code></pre><h2>重点回顾</h2><p>好了，今天的内容到此就讲完了。我们一块来总结回顾一下，你需要重点掌握的内容。</p><p><strong>1.什么是原型模式？</strong></p><p>如果对象的创建成本比较大，而同一个类的不同对象之间差别不大（大部分字段都相同），在这种情况下，我们可以利用对已有对象（原型）进行复制（或者叫拷贝）的方式，来创建新对象，以达到节省创建时间的目的。这种基于原型来创建对象的方式就叫作原型设计模式，简称原型模式。</p><p><strong>2.原型模式的两种实现方法</strong></p><p>原型模式有两种实现方法，深拷贝和浅拷贝。浅拷贝只会复制对象中基本数据类型数据和引用对象的内存地址，不会递归地复制引用对象，以及引用对象的引用对象……而深拷贝得到的是一份完完全全独立的对象。所以，深拷贝比起浅拷贝来说，更加耗时，更加耗内存空间。</p><p>如果要拷贝的对象是不可变对象，浅拷贝共享不可变对象是没问题的，但对于可变对象来说，浅拷贝得到的对象和原始对象会共享部分数据，就有可能出现数据被修改的风险，也就变得复杂多了。除非像我们今天实战中举的那个例子，需要从数据库中加载10万条数据并构建散列表索引，操作非常耗时，这种情况下比较推荐使用浅拷贝，否则，没有充分的理由，不要为了一点点的性能提升而使用浅拷贝。</p><h2>课堂讨论</h2><ol>\n<li>在今天的应用场景中，如果不仅往数据库中添加和更新关键词，还删除关键词，这种情况下，又该如何实现呢？</li>\n<li>在<a href=\"https://time.geekbang.org/column/article/164907\">第7讲</a>中，为了让ShoppingCart的getItems()方法返回不可变对象，我们如下来实现代码。当时，我们指出这样的实现思路还是有点问题。因为当调用者通过ShoppingCart的getItems()获取到items之后，我们还是可以修改容器中每个对象（ShoppingCartItem）的数据。学完本节课之后，现在你有没有解决方法了呢？</li>\n</ol><pre><code>public class ShoppingCart {\n  // ...省略其他代码...\n  public List&lt;ShoppingCartItem&gt; getItems() {\n    return Collections.unmodifiableList(this.items);\n  }\n}\n\n// Testing Code in main method:\nShoppingCart cart = new ShoppingCart();\nList&lt;ShoppingCartItem&gt; items = cart.getItems();\nitems.clear();//try to modify the list\n// Exception in thread &quot;main&quot; java.lang.UnsupportedOperationExceptio \n\nShoppingCart cart = new ShoppingCart();\ncart.add(new ShoppingCartItem(...));\nList&lt;ShoppingCartItem&gt; items = cart.getItems();\nShoppingCartItem item = items.get(0);\nitem.setPrice(19.0); // 这里修改了item的价格属性\n</code></pre><p>欢迎留言和我分享你的疑惑和见解，如果有收获，也欢迎你把这篇文章分享给你的朋友。</p>",
                "article_title": "47 | 原型模式：如何最快速地clone一个HashMap散列表？"
            }
        ]
    },
    {
        "chapterTitle": "设计模式与范式：结构型 (8讲)",
        "children": [
            {
                "title": "48 | 代理模式：代理在RPC、缓存、监控等场景中的应用",
                "herf": "https://time.geekbang.org/column/article/201823",
                "id": "201823",
                "content": "<p>前面几节，我们学习了设计模式中的创建型模式。创建型模式主要解决对象的创建问题，封装复杂的创建过程，解耦对象的创建代码和使用代码。</p><p>其中，单例模式用来创建全局唯一的对象。工厂模式用来创建不同但是相关类型的对象（继承同一父类或者接口的一组子类），由给定的参数来决定创建哪种类型的对象。建造者模式是用来创建复杂对象，可以通过设置不同的可选参数，“定制化”地创建不同的对象。原型模式针对创建成本比较大的对象，利用对已有对象进行复制的方式进行创建，以达到节省创建时间的目的。</p><p>从今天起，我们开始学习另外一种类型的设计模式：结构型模式。结构型模式主要总结了一些类或对象组合在一起的经典结构，这些经典的结构可以解决特定应用场景的问题。结构型模式包括：代理模式、桥接模式、装饰器模式、适配器模式、门面模式、组合模式、享元模式。今天我们要讲其中的代理模式。它也是在实际开发中经常被用到的一种设计模式。</p><p>话不多说，让我们正式开始今天的学习吧！</p><h2>代理模式的原理解析</h2><p><strong>代理模式</strong>（Proxy Design Pattern）的原理和代码实现都不难掌握。它在不改变原始类（或叫被代理类）代码的情况下，通过引入代理类来给原始类附加功能。我们通过一个简单的例子来解释一下这段话。</p><!-- [[[read_end]]] --><p>这个例子来自我们在第25、26、39、40节中讲的性能计数器。当时我们开发了一个MetricsCollector类，用来收集接口请求的原始数据，比如访问时间、处理时长等。在业务系统中，我们采用如下方式来使用这个MetricsCollector类：</p><pre><code>public class UserController {\n  //...省略其他属性和方法...\n  private MetricsCollector metricsCollector; // 依赖注入\n\n  public UserVo login(String telephone, String password) {\n    long startTimestamp = System.currentTimeMillis();\n\n    // ... 省略login逻辑...\n\n    long endTimeStamp = System.currentTimeMillis();\n    long responseTime = endTimeStamp - startTimestamp;\n    RequestInfo requestInfo = new RequestInfo(&quot;login&quot;, responseTime, startTimestamp);\n    metricsCollector.recordRequest(requestInfo);\n\n    //...返回UserVo数据...\n  }\n\n  public UserVo register(String telephone, String password) {\n    long startTimestamp = System.currentTimeMillis();\n\n    // ... 省略register逻辑...\n\n    long endTimeStamp = System.currentTimeMillis();\n    long responseTime = endTimeStamp - startTimestamp;\n    RequestInfo requestInfo = new RequestInfo(&quot;register&quot;, responseTime, startTimestamp);\n    metricsCollector.recordRequest(requestInfo);\n\n    //...返回UserVo数据...\n  }\n}\n</code></pre><p>很明显，上面的写法有两个问题。第一，性能计数器框架代码侵入到业务代码中，跟业务代码高度耦合。如果未来需要替换这个框架，那替换的成本会比较大。第二，收集接口请求的代码跟业务代码无关，本就不应该放到一个类中。业务类最好职责更加单一，只聚焦业务处理。</p><p>为了将框架代码和业务代码解耦，代理模式就派上用场了。代理类UserControllerProxy和原始类UserController实现相同的接口IUserController。UserController类只负责业务功能。代理类UserControllerProxy负责在业务代码执行前后附加其他逻辑代码，并通过委托的方式调用原始类来执行业务代码。具体的代码实现如下所示：</p><pre><code>public interface IUserController {\n  UserVo login(String telephone, String password);\n  UserVo register(String telephone, String password);\n}\n\npublic class UserController implements IUserController {\n  //...省略其他属性和方法...\n\n  @Override\n  public UserVo login(String telephone, String password) {\n    //...省略login逻辑...\n    //...返回UserVo数据...\n  }\n\n  @Override\n  public UserVo register(String telephone, String password) {\n    //...省略register逻辑...\n    //...返回UserVo数据...\n  }\n}\n\npublic class UserControllerProxy implements IUserController {\n  private MetricsCollector metricsCollector;\n  private UserController userController;\n\n  public UserControllerProxy(UserController userController) {\n    this.userController = userController;\n    this.metricsCollector = new MetricsCollector();\n  }\n\n  @Override\n  public UserVo login(String telephone, String password) {\n    long startTimestamp = System.currentTimeMillis();\n\n    // 委托\n    UserVo userVo = userController.login(telephone, password);\n\n    long endTimeStamp = System.currentTimeMillis();\n    long responseTime = endTimeStamp - startTimestamp;\n    RequestInfo requestInfo = new RequestInfo(&quot;login&quot;, responseTime, startTimestamp);\n    metricsCollector.recordRequest(requestInfo);\n\n    return userVo;\n  }\n\n  @Override\n  public UserVo register(String telephone, String password) {\n    long startTimestamp = System.currentTimeMillis();\n\n    UserVo userVo = userController.register(telephone, password);\n\n    long endTimeStamp = System.currentTimeMillis();\n    long responseTime = endTimeStamp - startTimestamp;\n    RequestInfo requestInfo = new RequestInfo(&quot;register&quot;, responseTime, startTimestamp);\n    metricsCollector.recordRequest(requestInfo);\n\n    return userVo;\n  }\n}\n\n//UserControllerProxy使用举例\n//因为原始类和代理类实现相同的接口，是基于接口而非实现编程\n//将UserController类对象替换为UserControllerProxy类对象，不需要改动太多代码\nIUserController userController = new UserControllerProxy(new UserController());\n</code></pre><p>参照基于接口而非实现编程的设计思想，将原始类对象替换为代理类对象的时候，为了让代码改动尽量少，在刚刚的代理模式的代码实现中，代理类和原始类需要实现相同的接口。但是，如果原始类并没有定义接口，并且原始类代码并不是我们开发维护的（比如它来自一个第三方的类库），我们也没办法直接修改原始类，给它重新定义一个接口。在这种情况下，我们该如何实现代理模式呢？</p><p>对于这种外部类的扩展，我们一般都是采用继承的方式。这里也不例外。我们让代理类继承原始类，然后扩展附加功能。原理很简单，不需要过多解释，你直接看代码就能明白。具体代码如下所示：</p><pre><code>public class UserControllerProxy extends UserController {\n  private MetricsCollector metricsCollector;\n\n  public UserControllerProxy() {\n    this.metricsCollector = new MetricsCollector();\n  }\n\n  public UserVo login(String telephone, String password) {\n    long startTimestamp = System.currentTimeMillis();\n\n    UserVo userVo = super.login(telephone, password);\n\n    long endTimeStamp = System.currentTimeMillis();\n    long responseTime = endTimeStamp - startTimestamp;\n    RequestInfo requestInfo = new RequestInfo(&quot;login&quot;, responseTime, startTimestamp);\n    metricsCollector.recordRequest(requestInfo);\n\n    return userVo;\n  }\n\n  public UserVo register(String telephone, String password) {\n    long startTimestamp = System.currentTimeMillis();\n\n    UserVo userVo = super.register(telephone, password);\n\n    long endTimeStamp = System.currentTimeMillis();\n    long responseTime = endTimeStamp - startTimestamp;\n    RequestInfo requestInfo = new RequestInfo(&quot;register&quot;, responseTime, startTimestamp);\n    metricsCollector.recordRequest(requestInfo);\n\n    return userVo;\n  }\n}\n//UserControllerProxy使用举例\nUserController userController = new UserControllerProxy();\n</code></pre><h2>动态代理的原理解析</h2><p>不过，刚刚的代码实现还是有点问题。一方面，我们需要在代理类中，将原始类中的所有的方法，都重新实现一遍，并且为每个方法都附加相似的代码逻辑。另一方面，如果要添加的附加功能的类有不止一个，我们需要针对每个类都创建一个代理类。</p><p>如果有50个要添加附加功能的原始类，那我们就要创建50个对应的代理类。这会导致项目中类的个数成倍增加，增加了代码维护成本。并且，每个代理类中的代码都有点像模板式的“重复”代码，也增加了不必要的开发成本。那这个问题怎么解决呢？</p><p>我们可以使用动态代理来解决这个问题。所谓<strong>动态代理</strong>（Dynamic Proxy），就是我们不事先为每个原始类编写代理类，而是在运行的时候，动态地创建原始类对应的代理类，然后在系统中用代理类替换掉原始类。那如何实现动态代理呢？</p><p>如果你熟悉的是Java语言，实现动态代理就是件很简单的事情。因为Java语言本身就已经提供了动态代理的语法（实际上，动态代理底层依赖的就是Java的反射语法）。我们来看一下，如何用Java的动态代理来实现刚刚的功能。具体的代码如下所示。其中，MetricsCollectorProxy作为一个动态代理类，动态地给每个需要收集接口请求信息的类创建代理类。</p><pre><code>public class MetricsCollectorProxy {\n  private MetricsCollector metricsCollector;\n\n  public MetricsCollectorProxy() {\n    this.metricsCollector = new MetricsCollector();\n  }\n\n  public Object createProxy(Object proxiedObject) {\n    Class&lt;?&gt;[] interfaces = proxiedObject.getClass().getInterfaces();\n    DynamicProxyHandler handler = new DynamicProxyHandler(proxiedObject);\n    return Proxy.newProxyInstance(proxiedObject.getClass().getClassLoader(), interfaces, handler);\n  }\n\n  private class DynamicProxyHandler implements InvocationHandler {\n    private Object proxiedObject;\n\n    public DynamicProxyHandler(Object proxiedObject) {\n      this.proxiedObject = proxiedObject;\n    }\n\n    @Override\n    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n      long startTimestamp = System.currentTimeMillis();\n      Object result = method.invoke(proxiedObject, args);\n      long endTimeStamp = System.currentTimeMillis();\n      long responseTime = endTimeStamp - startTimestamp;\n      String apiName = proxiedObject.getClass().getName() + &quot;:&quot; + method.getName();\n      RequestInfo requestInfo = new RequestInfo(apiName, responseTime, startTimestamp);\n      metricsCollector.recordRequest(requestInfo);\n      return result;\n    }\n  }\n}\n\n//MetricsCollectorProxy使用举例\nMetricsCollectorProxy proxy = new MetricsCollectorProxy();\nIUserController userController = (IUserController) proxy.createProxy(new UserController());\n</code></pre><p>实际上，Spring AOP底层的实现原理就是基于动态代理。用户\b配置好需要给哪些类创建代理，并定义好在执行原始类的业务代码前后执行哪些附加功能。Spring为这些类创建动态代理对象，并在JVM中替代原始类对象。原本在代码中执行的原始类的方法，被换作执行代理类的方法，也就实现了给原始类添加附加功能的目的。</p><h2>代理模式的应用场景</h2><p>代理模式的应用场景非常多，我这里列举一些比较常见的用法，希望你能举一反三地应用在你的项目开发中。</p><h3>1.业务系统的非功能性需求开发</h3><p>代理模式最常用的一个应用场景就是，在业务系统中开发一些非功能性需求，比如：监控、统计、鉴权、限流、事务、幂等、日志。我们将这些附加功能与业务功能解耦，放到代理类中统一处理，让程序员只需要关注业务方面的开发。实际上，前面举的搜集接口请求信息的例子，就是这个应用场景的一个典型例子。</p><p>如果你熟悉Java语言和Spring开发框架，这部分工作都是可以在Spring AOP切面中完成的。前面我们也提到，Spring AOP底层的实现原理就是基于动态代理。</p><h3>2.代理模式在RPC、缓存中的应用</h3><p><strong>实际上，RPC框架也可以看作一种代理模式</strong>，GoF的《设计模式》一书中把它称作远程代理。通过远程代理，将网络通信、数据编解码等细节隐藏起来。客户端在使用RPC服务的时候，就像使用本地函数一样，无需了解跟服务器交互的细节。除此之外，RPC服务的开发者也只需要开发业务逻辑，就像开发本地使用的函数一样，不需要关注跟客户端的交互细节。</p><p>关于远程代理的代码示例，我自己实现了一个简单的RPC框架Demo，放到了GitHub中，你可以点击这里的<a href=\"https://github.com/wangzheng0822/codedesign/tree/master/com/xzg/cd/rpc\">链接</a>查看。</p><p><strong>我们再来看代理模式在缓存中的应用。</strong>假设我们要开发一个接口请求的缓存功能，对于某些接口请求，如果入参相同，在设定的过期时间内，直接返回缓存结果，而不用重新进行逻辑处理。比如，针对获取用户个人信息的需求，我们可以开发两个接口，一个支持缓存，一个支持实时查询。对于需要实时数据的需求，我们让其调用实时查询接口，对于不需要实时数据的需求，我们让其调用支持缓存的接口。那如何来实现接口请求的缓存功能呢？</p><p>最简单的实现方法就是刚刚我们讲到的，给每个需要支持缓存的查询需求都开发两个不同的接口，一个支持缓存，一个支持实时查询。但是，这样做显然增加了开发成本，而且会让代码看起来非常臃肿（接口个数成倍增加），也不方便缓存接口的集中管理（增加、删除缓存接口）、集中配置（比如配置每个接口缓存过期时间）。</p><p>针对这些问题，代理模式就能派上用场了，确切地说，应该是动态代理。如果是基于Spring框架来开发的话，那就可以在AOP切面中完成接口缓存的功能。在应用启动的时候，我们从配置文件中加载需要支持缓存的接口，以及相应的缓存策略（比如过期时间）等。当请求到来的时候，我们在AOP切面中拦截请求，如果请求中带有支持缓存的字段（比如http://…?..&amp;cached=true），我们便从缓存（内存缓存或者Redis缓存等）中获取数据直接返回。</p><h2>重点回顾</h2><p>好了，今天的内容到此就讲完了。我们一块来总结回顾一下，你需要掌握的重点内容。</p><p><strong>1.代理模式的原理与实现</strong></p><p>在不改变原始类（或叫被代理类）的情况下，通过引入代理类来给原始类附加功能。一般情况下，我们让代理类和原始类实现同样的接口。但是，如果原始类并没有定义接口，并且原始类代码并不是我们开发维护的。在这种情况下，我们可以通过让代理类继承原始类的方法来实现代理模式。</p><p><strong>2.动态代理的原理与实现</strong></p><p>静态代理需要针对每个类都创建一个代理类，并且每个代理类中的代码都有点像模板式的“重复”代码，增加了维护成本和开发成本。对于静态代理存在的问题，我们可以通过动态代理来解决。我们不事先为每个原始类编写代理类，而是在运行的时候动态地创建原始类对应的代理类，然后在系统中用代理类替换掉原始类。</p><p><strong>3.代理模式的应用场景</strong></p><p>代理模式常用在业务系统中开发一些非功能性需求，比如：监控、统计、鉴权、限流、事务、幂等、日志。我们将这些附加功能与业务功能解耦，放到代理类统一处理，让程序员只需要关注业务方面的开发。除此之外，代理模式还可以用在RPC、缓存等应用场景中。</p><h2>课堂讨论</h2><ol>\n<li>除了Java语言之外，在你熟悉的其他语言中，如何实现动态代理呢？</li>\n<li>我们今天讲了两种代理模式的实现方法，一种是基于组合，一种基于继承，请对比一下两者的优缺点。</li>\n</ol><p>欢迎留言和我分享你的思考，如果有收获，也欢迎你把这篇文章分享给你的朋友。</p>",
                "article_title": "48 | 代理模式：代理在RPC、缓存、监控等场景中的应用"
            },
            {
                "title": "49 | 桥接模式：如何实现支持不同类型和渠道的消息推送系统？",
                "herf": "https://time.geekbang.org/column/article/202786",
                "id": "202786",
                "content": "<p>上一节课我们学习了第一种结构型模式：代理模式。它在不改变原始类（或者叫被代理类）代码的情况下，通过引入代理类来给原始类附加功能。代理模式在平时的开发经常被用到，常用在业务系统中开发一些非功能性需求，比如：监控、统计、鉴权、限流、事务、幂等、日志。</p><p>今天，我们再学习另外一种结构型模式：桥接模式。桥接模式的代码实现非常简单，但是理解起来稍微有点难度，并且应用场景也比较局限，所以，相当于代理模式来说，桥接模式在实际的项目中并没有那么常用，你只需要简单了解，见到能认识就可以，并不是我们学习的重点。</p><p>话不多说，让我们正式开始今天的学习吧！</p><h2>桥接模式的原理解析</h2><p><strong>桥接模式</strong>，也叫作<strong>桥梁模式</strong>，英文是<strong>Bridge Design Pattern</strong>。这个模式可以说是23种设计模式中最难理解的模式之一了。我查阅了比较多的书籍和资料之后发现，对于这个模式有两种不同的理解方式。</p><p>当然，这其中“最纯正”的理解方式，当属GoF的《设计模式》一书中对桥接模式的定义。毕竟，这23种经典的设计模式，最初就是由这本书总结出来的。在GoF的《设计模式》一书中，桥接模式是这么定义的：“Decouple an abstraction from its implementation so that the two can vary independently。”翻译成中文就是：“将抽象和实现解耦，让它们可以独立变化。”</p><!-- [[[read_end]]] --><p>关于桥接模式，很多书籍、资料中，还有另外一种理解方式：“一个类存在两个（或多个）独立变化的维度，我们通过组合的方式，让这两个（或多个）维度可以独立进行扩展。”通过组合关系来替代继承关系，避免继承层次的指数级爆炸。这种理解方式非常类似于，我们之前讲过的“组合优于继承”设计原则，所以，这里我就不多解释了。我们重点看下GoF的理解方式。</p><p>GoF给出的定义非常的简短，单凭这一句话，估计没几个人能看懂是什么意思。所以，我们通过JDBC驱动的例子来解释一下。JDBC驱动是桥接模式的经典应用。我们先来看一下，如何利用JDBC驱动来查询数据库。具体的代码如下所示：</p><pre><code>Class.forName(&quot;com.mysql.jdbc.Driver&quot;);//加载及注册JDBC驱动程序\nString url = &quot;jdbc:mysql://localhost:3306/sample_db?user=root&amp;password=your_password&quot;;\nConnection con = DriverManager.getConnection(url);\nStatement stmt = con.createStatement()；\nString query = &quot;select * from test&quot;;\nResultSet rs=stmt.executeQuery(query);\nwhile(rs.next()) {\n  rs.getString(1);\n  rs.getInt(2);\n}\n</code></pre><p>如果我们想要把MySQL数据库换成Oracle数据库，只需要把第一行代码中的com.mysql.jdbc.Driver换成oracle.jdbc.driver.OracleDriver就可以了。当然，也有更灵活的实现方式，我们可以把需要加载的Driver类写到配置文件中，当程序启动的时候，自动从配置文件中加载，这样在切换数据库的时候，我们都不需要修改代码，只需要修改配置文件就可以了。</p><p>不管是改代码还是改配置，在项目中，从一个数据库切换到另一种数据库，都只需要改动很少的代码，或者完全不需要改动代码，那如此优雅的数据库切换是如何实现的呢？</p><p>源码之下无秘密。要弄清楚这个问题，我们先从com.mysql.jdbc.Driver这个类的代码看起。我摘抄了部分相关代码，放到了这里，你可以看一下。</p><pre><code>package com.mysql.jdbc;\nimport java.sql.SQLException;\n\npublic class Driver extends NonRegisteringDriver implements java.sql.Driver {\n\tstatic {\n\t\ttry {\n\t\t\tjava.sql.DriverManager.registerDriver(new Driver());\n\t\t} catch (SQLException E) {\n\t\t\tthrow new RuntimeException(&quot;Can't register driver!&quot;);\n\t\t}\n\t}\n\n\t/**\n\t * Construct a new driver and register it with DriverManager\n\t * @throws SQLException if a database error occurs.\n\t */\n\tpublic Driver() throws SQLException {\n\t\t// Required for Class.forName().newInstance()\n\t}\n}\n</code></pre><p>结合com.mysql.jdbc.Driver的代码实现，我们可以发现，当执行Class.forName(“com.mysql.jdbc.Driver”)这条语句的时候，实际上是做了两件事情。第一件事情是要求JVM查找并加载指定的Driver类，第二件事情是执行该类的静态代码，也就是将MySQL Driver注册到DriverManager类中。</p><p>现在，我们再来看一下，DriverManager类是干什么用的。具体的代码如下所示。当我们把具体的Driver实现类（比如，com.mysql.jdbc.Driver）注册到DriverManager之后，后续所有对JDBC接口的调用，都会委派到对具体的Driver实现类来执行。而Driver实现类都实现了相同的接口（java.sql.Driver ），这也是可以灵活切换Driver的原因。</p><pre><code>public class DriverManager {\n  private final static CopyOnWriteArrayList&lt;DriverInfo&gt; registeredDrivers = new CopyOnWriteArrayList&lt;DriverInfo&gt;();\n\n  //...\n  static {\n    loadInitialDrivers();\n    println(&quot;JDBC DriverManager initialized&quot;);\n  }\n  //...\n\n  public static synchronized void registerDriver(java.sql.Driver driver) throws SQLException {\n    if (driver != null) {\n      registeredDrivers.addIfAbsent(new DriverInfo(driver));\n    } else {\n      throw new NullPointerException();\n    }\n  }\n\n  public static Connection getConnection(String url, String user, String password) throws SQLException {\n    java.util.Properties info = new java.util.Properties();\n    if (user != null) {\n      info.put(&quot;user&quot;, user);\n    }\n    if (password != null) {\n      info.put(&quot;password&quot;, password);\n    }\n    return (getConnection(url, info, Reflection.getCallerClass()));\n  }\n  //...\n}\n</code></pre><p>桥接模式的定义是“将抽象和实现解耦，让它们可以独立变化”。那弄懂定义中“抽象”和“实现”两个概念，就是理解桥接模式的关键。那在JDBC这个例子中，什么是“抽象”？什么是“实现”呢？</p><p>实际上，JDBC本身就相当于“抽象”。注意，这里所说的“抽象”，指的并非“抽象类”或“接口”，而是跟具体的数据库无关的、被抽象出来的一套“类库”。具体的Driver（比如，com.mysql.jdbc.Driver）就相当于“实现”。注意，这里所说的“实现”，也并非指“接口的实现类”，而是跟具体数据库相关的一套“类库”。JDBC和Driver独立开发，通过对象之间的组合关系，组装在一起。JDBC的所有逻辑操作，最终都委托给Driver来执行。</p><p>我画了一张图帮助你理解，你可以结合着我刚才的讲解一块看。</p><p><img src=\"https://static001.geekbang.org/resource/image/81/40/812234b0717043a67c2d62ea8e783b40.jpg\" alt=\"\"></p><h2>桥接模式的应用举例</h2><p>在<a href=\"https://time.geekbang.org/column/article/176075\">第16节</a>中，我们讲过一个API接口监控告警的例子：根据不同的告警规则，触发不同类型的告警。告警支持多种通知渠道，包括：邮件、短信、微信、自动语音电话。通知的紧急程度有多种类型，包括：SEVERE（严重）、URGENCY（紧急）、NORMAL（普通）、TRIVIAL（无关紧要）。不同的紧急程度对应不同的通知渠道。比如，SERVE（严重）级别的消息会通过“自动语音电话”告知相关人员。</p><p>在当时的代码实现中，关于发送告警信息那部分代码，我们只给出了粗略的设计，现在我们来一块实现一下。我们先来看最简单、最直接的一种实现方式。代码如下所示：</p><pre><code>public enum NotificationEmergencyLevel {\n  SEVERE, URGENCY, NORMAL, TRIVIAL\n}\n\npublic class Notification {\n  private List&lt;String&gt; emailAddresses;\n  private List&lt;String&gt; telephones;\n  private List&lt;String&gt; wechatIds;\n\n  public Notification() {}\n\n  public void setEmailAddress(List&lt;String&gt; emailAddress) {\n    this.emailAddresses = emailAddress;\n  }\n\n  public void setTelephones(List&lt;String&gt; telephones) {\n    this.telephones = telephones;\n  }\n\n  public void setWechatIds(List&lt;String&gt; wechatIds) {\n    this.wechatIds = wechatIds;\n  }\n\n  public void notify(NotificationEmergencyLevel level, String message) {\n    if (level.equals(NotificationEmergencyLevel.SEVERE)) {\n      //...自动语音电话\n    } else if (level.equals(NotificationEmergencyLevel.URGENCY)) {\n      //...发微信\n    } else if (level.equals(NotificationEmergencyLevel.NORMAL)) {\n      //...发邮件\n    } else if (level.equals(NotificationEmergencyLevel.TRIVIAL)) {\n      //...发邮件\n    }\n  }\n}\n\n//在API监控告警的例子中，我们如下方式来使用Notification类：\npublic class ErrorAlertHandler extends AlertHandler {\n  public ErrorAlertHandler(AlertRule rule, Notification notification){\n    super(rule, notification);\n  }\n\n\n  @Override\n  public void check(ApiStatInfo apiStatInfo) {\n    if (apiStatInfo.getErrorCount() &gt; rule.getMatchedRule(apiStatInfo.getApi()).getMaxErrorCount()) {\n      notification.notify(NotificationEmergencyLevel.SEVERE, &quot;...&quot;);\n    }\n  }\n}\n</code></pre><p>Notification类的代码实现有一个最明显的问题，那就是有很多if-else分支逻辑。实际上，如果每个分支中的代码都不复杂，后期也没有无限膨胀的可能（增加更多if-else分支判断），那这样的设计问题并不大，没必要非得一定要摒弃if-else分支逻辑。</p><p>不过，Notification的代码显然不符合这个条件。因为每个if-else分支中的代码逻辑都比较复杂，发送通知的所有逻辑都扎堆在Notification类中。我们知道，类的代码越多，就越难读懂，越难修改，维护的成本也就越高。很多设计模式都是试图将庞大的类拆分成更细小的类，然后再通过某种更合理的结构组装在一起。</p><p>针对Notification的代码，我们将不同渠道的发送逻辑剥离出来，形成独立的消息发送类（MsgSender相关类）。其中，Notification类相当于抽象，MsgSender类相当于实现，两者可以独立开发，通过组合关系（也就是桥梁）任意组合在一起。所谓任意组合的意思就是，不同紧急程度的消息和发送渠道之间的对应关系，不是在代码中固定写死的，我们可以动态地去指定（比如，通过读取配置来获取对应关系）。</p><p>按照这个设计思路，我们对代码进行重构。重构之后的代码如下所示：</p><pre><code>public interface MsgSender {\n  void send(String message);\n}\n\npublic class TelephoneMsgSender implements MsgSender {\n  private List&lt;String&gt; telephones;\n\n  public TelephoneMsgSender(List&lt;String&gt; telephones) {\n    this.telephones = telephones;\n  }\n\n  @Override\n  public void send(String message) {\n    //...\n  }\n\n}\n\npublic class EmailMsgSender implements MsgSender {\n  // 与TelephoneMsgSender代码结构类似，所以省略...\n}\n\npublic class WechatMsgSender implements MsgSender {\n  // 与TelephoneMsgSender代码结构类似，所以省略...\n}\n\npublic abstract class Notification {\n  protected MsgSender msgSender;\n\n  public Notification(MsgSender msgSender) {\n    this.msgSender = msgSender;\n  }\n\n  public abstract void notify(String message);\n}\n\npublic class SevereNotification extends Notification {\n  public SevereNotification(MsgSender msgSender) {\n    super(msgSender);\n  }\n\n  @Override\n  public void notify(String message) {\n    msgSender.send(message);\n  }\n}\n\npublic class UrgencyNotification extends Notification {\n  // 与SevereNotification代码结构类似，所以省略...\n}\npublic class NormalNotification extends Notification {\n  // 与SevereNotification代码结构类似，所以省略...\n}\npublic class TrivialNotification extends Notification {\n  // 与SevereNotification代码结构类似，所以省略...\n}\n</code></pre><h2>重点回顾</h2><p>好了，今天的内容到此就讲完了。我们一块来总结回顾一下，你需要重点掌握的内容。</p><p>总体上来讲，桥接模式的原理比较难理解，但代码实现相对简单。</p><p>对于这个模式有两种不同的理解方式。在GoF的《设计模式》一书中，桥接模式被定义为：“将抽象和实现解耦，让它们可以独立变化。”在其他资料和书籍中，还有另外一种更加简单的理解方式：“一个类存在两个（或多个）独立变化的维度，我们通过组合的方式，让这两个（或多个）维度可以独立进行扩展。”</p><p>对于第一种GoF的理解方式，弄懂定义中“抽象”和“实现”两个概念，是理解它的关键。定义中的“抽象”，指的并非“抽象类”或“接口”，而是被抽象出来的一套“类库”，它只包含骨架代码，真正的业务逻辑需要委派给定义中的“实现”来完成。而定义中的“实现”，也并非“接口的实现类”，而是一套独立的“类库”。“抽象”和“实现”独立开发，通过对象之间的组合关系，组装在一起。</p><p>对于第二种理解方式，它非常类似我们之前讲过的“组合优于继承”设计原则，通过组合关系来替代继承关系，避免继承层次的指数级爆炸。</p><h2>课堂讨论</h2><p>在桥接模式的第二种理解方式的第一段代码实现中，Notification类中的三个成员变量通过set方法来设置，但是这样的代码实现存在一个明显的问题，那就是emailAddresses、telephones、wechatIds中的数据有可能在Notification类外部被修改，那如何重构代码才能避免这种情况的发生呢？</p><pre><code>public class Notification {\n  private List&lt;String&gt; emailAddresses;\n  private List&lt;String&gt; telephones;\n  private List&lt;String&gt; wechatIds;\n\n  public Notification() {}\n\n  public void setEmailAddress(List&lt;String&gt; emailAddress) {\n    this.emailAddresses = emailAddress;\n  }\n\n  public void setTelephones(List&lt;String&gt; telephones) {\n    this.telephones = telephones;\n  }\n\n  public void setWechatIds(List&lt;String&gt; wechatIds) {\n    this.wechatIds = wechatIds;\n  }\n  //...\n}\n</code></pre><p>欢迎留言和我分享你的思考和疑惑。如果有收获，也欢迎你把这篇文章分享给你的朋友。</p>",
                "article_title": "49 | 桥接模式：如何实现支持不同类型和渠道的消息推送系统？"
            },
            {
                "title": "50 | 装饰器模式：通过剖析Java IO类库源码学习装饰器模式",
                "herf": "https://time.geekbang.org/column/article/204845",
                "id": "204845",
                "content": "<p>上一节课我们学习了桥接模式，桥接模式有两种理解方式。第一种理解方式是“将抽象和实现解耦，让它们能独立开发”。这种理解方式比较特别，应用场景也不多。另一种理解方式更加简单，类似“组合优于继承”设计原则，这种理解方式更加通用，应用场景比较多。不管是哪种理解方式，它们的代码结构都是相同的，都是一种类之间的组合关系。</p><p>今天，我们通过剖析Java IO类的设计思想，再学习一种新的结构型模式，装饰器模式。它的代码结构跟桥接模式非常相似，不过，要解决的问题却大不相同。</p><p>话不多说，让我们正式开始今天的学习吧！</p><h2>Java IO类的“奇怪”用法</h2><p>Java IO类库非常庞大和复杂，有几十个类，负责IO数据的读取和写入。如果对Java IO类做一下分类，我们可以从下面两个维度将它划分为四类。具体如下所示：</p><p><img src=\"https://static001.geekbang.org/resource/image/50/05/507526c2e4b255a45c60722df14f9a05.jpg\" alt=\"\"></p><p>针对不同的读取和写入场景，Java IO又在这四个父类基础之上，扩展出了很多子类。具体如下所示：</p><p><img src=\"https://static001.geekbang.org/resource/image/50/13/5082df8e7d5a4d44a34811b9f562d613.jpg\" alt=\"\"></p><p>在我初学Java的时候，曾经对Java IO的一些用法产生过很大疑惑，比如下面这样一段代码。我们打开文件test.txt，从中读取数据。其中，InputStream是一个抽象类，FileInputStream是专门用来读取文件流的子类。BufferedInputStream是一个支持带缓存功能的数据读取类，可以提高数据读取的效率。</p><!-- [[[read_end]]] --><pre><code>InputStream in = new FileInputStream(&quot;/user/wangzheng/test.txt&quot;);\nInputStream bin = new BufferedInputStream(in);\nbyte[] data = new byte[128];\nwhile (bin.read(data) != -1) {\n  //...\n}\n</code></pre><p>初看上面的代码，我们会觉得Java IO的用法比较麻烦，需要先创建一个FileInputStream对象，然后再传递给BufferedInputStream对象来使用。我在想，Java IO为什么不设计一个继承FileInputStream并且支持缓存的BufferedFileInputStream类呢？这样我们就可以像下面的代码中这样，直接创建一个BufferedFileInputStream类对象，打开文件读取数据，用起来岂不是更加简单？</p><pre><code>InputStream bin = new BufferedFileInputStream(&quot;/user/wangzheng/test.txt&quot;);\nbyte[] data = new byte[128];\nwhile (bin.read(data) != -1) {\n  //...\n}\n</code></pre><h2>基于继承的设计方案</h2><p>如果InputStream只有一个子类FileInputStream的话，那我们在FileInputStream基础之上，再设计一个孙子类BufferedFileInputStream，也算是可以接受的，毕竟继承结构还算简单。但实际上，继承InputStream的子类有很多。我们需要给每一个InputStream的子类，再继续派生支持缓存读取的子类。</p><p>除了支持缓存读取之外，如果我们还需要对功能进行其他方面的增强，比如下面的DataInputStream类，支持按照基本数据类型（int、boolean、long等）来读取数据。</p><pre><code>FileInputStream in = new FileInputStream(&quot;/user/wangzheng/test.txt&quot;);\nDataInputStream din = new DataInputStream(in);\nint data = din.readInt();\n</code></pre><p>在这种情况下，如果我们继续按照继承的方式来实现的话，就需要再继续派生出DataFileInputStream、DataPipedInputStream等类。如果我们还需要既支持缓存、又支持按照基本类型读取数据的类，那就要再继续派生出BufferedDataFileInputStream、BufferedDataPipedInputStream等n多类。这还只是附加了两个增强功能，如果我们需要附加更多的增强功能，那就会导致组合爆炸，类继承结构变得无比复杂，代码既不好扩展，也不好维护。这也是我们在<a href=\"https://time.geekbang.org/column/article/169593\">第10节</a>中讲的不推荐使用继承的原因。</p><h2>基于装饰器模式的设计方案</h2><p>在第10节中，我们还讲到“组合优于继承”，可以“使用组合来替代继承”。针对刚刚的继承结构过于复杂的问题，我们可以通过将继承关系改为组合关系来解决。下面的代码展示了Java IO的这种设计思路。不过，我对代码做了简化，只抽象出了必要的代码结构，如果你感兴趣的话，可以直接去查看JDK源码。</p><pre><code>public abstract class InputStream {\n  //...\n  public int read(byte b[]) throws IOException {\n    return read(b, 0, b.length);\n  }\n  \n  public int read(byte b[], int off, int len) throws IOException {\n    //...\n  }\n  \n  public long skip(long n) throws IOException {\n    //...\n  }\n\n  public int available() throws IOException {\n    return 0;\n  }\n  \n  public void close() throws IOException {}\n\n  public synchronized void mark(int readlimit) {}\n    \n  public synchronized void reset() throws IOException {\n    throw new IOException(&quot;mark/reset not supported&quot;);\n  }\n\n  public boolean markSupported() {\n    return false;\n  }\n}\n\npublic class BufferedInputStream extends InputStream {\n  protected volatile InputStream in;\n\n  protected BufferedInputStream(InputStream in) {\n    this.in = in;\n  }\n  \n  //...实现基于缓存的读数据接口...  \n}\n\npublic class DataInputStream extends InputStream {\n  protected volatile InputStream in;\n\n  protected DataInputStream(InputStream in) {\n    this.in = in;\n  }\n  \n  //...实现读取基本类型数据的接口\n}\n</code></pre><p>看了上面的代码，你可能会问，那装饰器模式就是简单的“用组合替代继承”吗？当然不是。从Java IO的设计来看，装饰器模式相对于简单的组合关系，还有两个比较特殊的地方。</p><p><strong>第一个比较特殊的地方是：装饰器类和原始类继承同样的父类，这样我们可以对原始类“嵌套”多个装饰器类。</strong>比如，下面这样一段代码，我们对FileInputStream嵌套了两个装饰器类：BufferedInputStream和DataInputStream，让它既支持缓存读取，又支持按照基本数据类型来读取数据。</p><pre><code>InputStream in = new FileInputStream(&quot;/user/wangzheng/test.txt&quot;);\nInputStream bin = new BufferedInputStream(in);\nDataInputStream din = new DataInputStream(bin);\nint data = din.readInt();\n</code></pre><p><strong>第二个比较特殊的地方是：装饰器类是对功能的增强，这也是装饰器模式应用场景的一个重要特点。</strong>实际上，符合“组合关系”这种代码结构的设计模式有很多，比如之前讲过的代理模式、桥接模式，还有现在的装饰器模式。尽管它们的代码结构很相似，但是每种设计模式的意图是不同的。就拿比较相似的代理模式和装饰器模式来说吧，代理模式中，代理类附加的是跟原始类无关的功能，而在装饰器模式中，装饰器类附加的是跟原始类相关的增强功能。</p><pre><code>// 代理模式的代码结构(下面的接口也可以替换成抽象类)\npublic interface IA {\n  void f();\n}\npublic class A impelements IA {\n  public void f() { //... }\n}\npublic class AProxy implements IA {\n  private IA a;\n  public AProxy(IA a) {\n    this.a = a;\n  }\n  \n  public void f() {\n    // 新添加的代理逻辑\n    a.f();\n    // 新添加的代理逻辑\n  }\n}\n\n// 装饰器模式的代码结构(下面的接口也可以替换成抽象类)\npublic interface IA {\n  void f();\n}\npublic class A implements IA {\n  public void f() { //... }\n}\npublic class ADecorator implements IA {\n  private IA a;\n  public ADecorator(IA a) {\n    this.a = a;\n  }\n  \n  public void f() {\n    // 功能增强代码\n    a.f();\n    // 功能增强代码\n  }\n}\n</code></pre><p>实际上，如果去查看JDK的源码，你会发现，BufferedInputStream、DataInputStream并非继承自InputStream，而是另外一个叫FilterInputStream的类。那这又是出于什么样的设计意图，才引入这样一个类呢？</p><p>我们再重新来看一下BufferedInputStream类的代码。InputStream是一个抽象类而非接口，而且它的大部分函数（比如read()、available()）都有默认实现，按理来说，我们只需要在BufferedInputStream类中重新实现那些需要增加缓存功能的函数就可以了，其他函数继承InputStream的默认实现。但实际上，这样做是行不通的。</p><p>对于即便是不需要增加缓存功能的函数来说，BufferedInputStream还是必须把它重新实现一遍，简单包裹对InputStream对象的函数调用。具体的代码示例如下所示。如果不重新实现，那BufferedInputStream类就无法将最终读取数据的任务，委托给传递进来的InputStream对象来完成。这一部分稍微有点不好理解，你自己多思考一下。</p><pre><code>public class BufferedInputStream extends InputStream {\n  protected volatile InputStream in;\n\n  protected BufferedInputStream(InputStream in) {\n    this.in = in;\n  }\n  \n  // f()函数不需要增强，只是重新调用一下InputStream in对象的f()\n  public void f() {\n    in.f();\n  }  \n}\n</code></pre><p>实际上，DataInputStream也存在跟BufferedInputStream同样的问题。为了避免代码重复，Java IO抽象出了一个装饰器父类FilterInputStream，代码实现如下所示。InputStream的所有的装饰器类（BufferedInputStream、DataInputStream）都继承自这个装饰器父类。这样，装饰器类只需要实现它需要增强的方法就可以了，其他方法继承装饰器父类的默认实现。</p><pre><code>public class FilterInputStream extends InputStream {\n  protected volatile InputStream in;\n\n  protected FilterInputStream(InputStream in) {\n    this.in = in;\n  }\n\n  public int read() throws IOException {\n    return in.read();\n  }\n\n  public int read(byte b[]) throws IOException {\n    return read(b, 0, b.length);\n  }\n   \n  public int read(byte b[], int off, int len) throws IOException {\n    return in.read(b, off, len);\n  }\n\n  public long skip(long n) throws IOException {\n    return in.skip(n);\n  }\n\n  public int available() throws IOException {\n    return in.available();\n  }\n\n  public void close() throws IOException {\n    in.close();\n  }\n\n  public synchronized void mark(int readlimit) {\n    in.mark(readlimit);\n  }\n\n  public synchronized void reset() throws IOException {\n    in.reset();\n  }\n\n  public boolean markSupported() {\n    return in.markSupported();\n  }\n}\n</code></pre><h2>重点回顾</h2><p>好了，今天的内容到此就讲完了。我们一块来总结回顾一下，你需要重点掌握的内容。</p><p>装饰器模式主要解决继承关系过于复杂的问题，通过组合来替代继承。它主要的作用是给原始类添加增强功能。这也是判断是否该用装饰器模式的一个重要的依据。除此之外，装饰器模式还有一个特点，那就是可以对原始类嵌套使用多个装饰器。为了满足这个应用场景，在设计的时候，装饰器类需要跟原始类继承相同的抽象类或者接口。</p><h2>课堂讨论</h2><p>在上节课中，我们讲到，可以通过代理模式给接口添加缓存功能。在这节课中，我们又通过装饰者模式给InputStream添加缓存读取数据功能。那对于“添加缓存”这个应用场景来说，我们到底是该用代理模式还是装饰器模式呢？你怎么看待这个问题？</p><p>欢迎留言和我分享你的思考，如果有收获，也欢迎你把这篇文章分享给你的朋友。</p>",
                "article_title": "50 | 装饰器模式：通过剖析Java IO类库源码学习装饰器模式"
            },
            {
                "title": "51 | 适配器模式：代理、适配器、桥接、装饰，这四个模式有何区别？",
                "herf": "https://time.geekbang.org/column/article/205912",
                "id": "205912",
                "content": "<p>前面几节课我们学习了代理模式、桥接模式、装饰器模式，今天，我们再来学习一个比较常用的结构型模式：适配器模式。这个模式相对来说还是比较简单、好理解的，应用场景也很具体，总体上来讲比较好掌握。</p><p>关于适配器模式，今天我们主要学习它的两种实现方式，类适配器和对象适配器，以及5种常见的应用场景。同时，我还会通过剖析slf4j日志框架，来给你展示这个模式在真实项目中的应用。除此之外，在文章的最后，我还对代理、桥接、装饰器、适配器，这4种代码结构非常相似的设计模式做简单的对比，对这几节内容做一个简单的总结。</p><p>话不多说，让我们正式开始今天的学习吧！</p><h2>适配器模式的原理与实现</h2><p><strong>适配器模式</strong>的英文翻译是<strong>Adapter Design Pattern</strong>。顾名思义，这个模式就是用来做适配的，它将不兼容的接口转换为可兼容的接口，让原本由于接口不兼容而不能一起工作的类可以一起工作。对于这个模式，有一个经常被拿来解释它的例子，就是USB转接头充当适配器，把两种不兼容的接口，通过转接变得可以一起工作。</p><p>原理很简单，我们再来看下它的代码实现。适配器模式有两种实现方式：类适配器和对象适配器。其中，类适配器使用继承关系来实现，对象适配器使用组合关系来实现。具体的代码实现如下所示。其中，ITarget表示要转化成的接口定义。Adaptee是一组不兼容ITarget接口定义的接口，Adaptor将Adaptee转化成一组符合ITarget接口定义的接口。</p><!-- [[[read_end]]] --><pre><code>// 类适配器: 基于继承\npublic interface ITarget {\n  void f1();\n  void f2();\n  void fc();\n}\n\npublic class Adaptee {\n  public void fa() { //... }\n  public void fb() { //... }\n  public void fc() { //... }\n}\n\npublic class Adaptor extends Adaptee implements ITarget {\n  public void f1() {\n    super.fa();\n  }\n  \n  public void f2() {\n    //...重新实现f2()...\n  }\n  \n  // 这里fc()不需要实现，直接继承自Adaptee，这是跟对象适配器最大的不同点\n}\n\n// 对象适配器：基于组合\npublic interface ITarget {\n  void f1();\n  void f2();\n  void fc();\n}\n\npublic class Adaptee {\n  public void fa() { //... }\n  public void fb() { //... }\n  public void fc() { //... }\n}\n\npublic class Adaptor implements ITarget {\n  private Adaptee adaptee;\n  \n  public Adaptor(Adaptee adaptee) {\n    this.adaptee = adaptee;\n  }\n  \n  public void f1() {\n    adaptee.fa(); //委托给Adaptee\n  }\n  \n  public void f2() {\n    //...重新实现f2()...\n  }\n  \n  public void fc() {\n    adaptee.fc();\n  }\n}\n</code></pre><p>针对这两种实现方式，在实际的开发中，到底该如何选择使用哪一种呢？判断的标准主要有两个，一个是Adaptee接口的个数，另一个是Adaptee和ITarget的契合程度。</p><ul>\n<li>如果Adaptee接口并不多，那两种实现方式都可以。</li>\n<li>如果Adaptee接口很多，而且Adaptee和ITarget接口定义大部分都相同，那我们推荐使用类适配器，因为Adaptor复用父类Adaptee的接口，比起对象适配器的实现方式，Adaptor的代码量要少一些。</li>\n<li>如果Adaptee接口很多，而且Adaptee和ITarget接口定义大部分都不相同，那我们推荐使用对象适配器，因为组合结构相对于继承更加灵活。</li>\n</ul><h2>适配器模式应用场景总结</h2><p>原理和实现讲完了，都不复杂。我们再来看，到底什么时候会用到适配器模式呢？</p><p>一般来说，适配器模式可以看作一种“补偿模式”，用来补救设计上的缺陷。应用这种模式算是“无奈之举”。如果在设计初期，我们就能协调规避接口不兼容的问题，那这种模式就没有应用的机会了。</p><p>前面我们反复提到，适配器模式的应用场景是“接口不兼容”。那在实际的开发中，什么情况下才会出现接口不兼容呢？我建议你先自己思考一下这个问题，然后再来看我下面的总结 。</p><h3>1.封装有缺陷的接口设计</h3><p>假设我们依赖的外部系统在接口设计方面有缺陷（比如包含大量静态方法），引入之后会影响到我们自身代码的可测试性。为了隔离设计上的缺陷，我们希望对外部系统提供的接口进行二次封装，抽象出更好的接口设计，这个时候就可以使用适配器模式了。</p><p>具体我还是举个例子来解释一下，你直接看代码应该会更清晰。具体代码如下所示：</p><pre><code>public class CD { //这个类来自外部sdk，我们无权修改它的代码\n  //...\n  public static void staticFunction1() { //... }\n  \n  public void uglyNamingFunction2() { //... }\n\n  public void tooManyParamsFunction3(int paramA, int paramB, ...) { //... }\n  \n   public void lowPerformanceFunction4() { //... }\n}\n\n// 使用适配器模式进行重构\npublic class ITarget {\n  void function1();\n  void function2();\n  void fucntion3(ParamsWrapperDefinition paramsWrapper);\n  void function4();\n  //...\n}\n// 注意：适配器类的命名不一定非得末尾带Adaptor\npublic class CDAdaptor extends CD implements ITarget {\n  //...\n  public void function1() {\n     super.staticFunction1();\n  }\n  \n  public void function2() {\n    super.uglyNamingFucntion2();\n  }\n  \n  public void function3(ParamsWrapperDefinition paramsWrapper) {\n     super.tooManyParamsFunction3(paramsWrapper.getParamA(), ...);\n  }\n  \n  public void function4() {\n    //...reimplement it...\n  }\n}\n</code></pre><h3>2.统一多个类的接口设计</h3><p>某个功能的实现依赖多个外部系统（或者说类）。通过适配器模式，将它们的接口适配为统一的接口定义，然后我们就可以使用多态的特性来复用代码逻辑。具体我还是举个例子来解释一下。</p><p>假设我们的系统要对用户输入的文本内容做敏感词过滤，为了提高过滤的召回率，我们引入了多款第三方敏感词过滤系统，依次对用户输入的内容进行过滤，过滤掉尽可能多的敏感词。但是，每个系统提供的过滤接口都是不同的。这就意味着我们没法复用一套逻辑来调用各个系统。这个时候，我们就可以使用适配器模式，将所有系统的接口适配为统一的接口定义，这样我们可以复用调用敏感词过滤的代码。</p><p>你可以配合着下面的代码示例，来理解我刚才举的这个例子。</p><pre><code>public class ASensitiveWordsFilter { // A敏感词过滤系统提供的接口\n  //text是原始文本，函数输出用***替换敏感词之后的文本\n  public String filterSexyWords(String text) {\n    // ...\n  }\n  \n  public String filterPoliticalWords(String text) {\n    // ...\n  } \n}\n\npublic class BSensitiveWordsFilter  { // B敏感词过滤系统提供的接口\n  public String filter(String text) {\n    //...\n  }\n}\n\npublic class CSensitiveWordsFilter { // C敏感词过滤系统提供的接口\n  public String filter(String text, String mask) {\n    //...\n  }\n}\n\n// 未使用适配器模式之前的代码：代码的可测试性、扩展性不好\npublic class RiskManagement {\n  private ASensitiveWordsFilter aFilter = new ASensitiveWordsFilter();\n  private BSensitiveWordsFilter bFilter = new BSensitiveWordsFilter();\n  private CSensitiveWordsFilter cFilter = new CSensitiveWordsFilter();\n  \n  public String filterSensitiveWords(String text) {\n    String maskedText = aFilter.filterSexyWords(text);\n    maskedText = aFilter.filterPoliticalWords(maskedText);\n    maskedText = bFilter.filter(maskedText);\n    maskedText = cFilter.filter(maskedText, &quot;***&quot;);\n    return maskedText;\n  }\n}\n\n// 使用适配器模式进行改造\npublic interface ISensitiveWordsFilter { // 统一接口定义\n  String filter(String text);\n}\n\npublic class ASensitiveWordsFilterAdaptor implements ISensitiveWordsFilter {\n  private ASensitiveWordsFilter aFilter;\n  public String filter(String text) {\n    String maskedText = aFilter.filterSexyWords(text);\n    maskedText = aFilter.filterPoliticalWords(maskedText);\n    return maskedText;\n  }\n}\n//...省略BSensitiveWordsFilterAdaptor、CSensitiveWordsFilterAdaptor...\n\n// 扩展性更好，更加符合开闭原则，如果添加一个新的敏感词过滤系统，\n// 这个类完全不需要改动；而且基于接口而非实现编程，代码的可测试性更好。\npublic class RiskManagement { \n  private List&lt;ISensitiveWordsFilter&gt; filters = new ArrayList&lt;&gt;();\n \n  public void addSensitiveWordsFilter(ISensitiveWordsFilter filter) {\n    filters.add(filter);\n  }\n  \n  public String filterSensitiveWords(String text) {\n    String maskedText = text;\n    for (ISensitiveWordsFilter filter : filters) {\n      maskedText = filter.filter(maskedText);\n    }\n    return maskedText;\n  }\n}\n</code></pre><h3>3.替换依赖的外部系统</h3><p>当我们把项目中依赖的一个外部系统替换为另一个外部系统的时候，利用适配器模式，可以减少对代码的改动。具体的代码示例如下所示：</p><pre><code>// 外部系统A\npublic interface IA {\n  //...\n  void fa();\n}\npublic class A implements IA {\n  //...\n  public void fa() { //... }\n}\n// 在我们的项目中，外部系统A的使用示例\npublic class Demo {\n  private IA a;\n  public Demo(IA a) {\n    this.a = a;\n  }\n  //...\n}\nDemo d = new Demo(new A());\n\n// 将外部系统A替换成外部系统B\npublic class BAdaptor implemnts IA {\n  private B b;\n  public BAdaptor(B b) {\n    this.b= b;\n  }\n  public void fa() {\n    //...\n    b.fb();\n  }\n}\n// 借助BAdaptor，Demo的代码中，调用IA接口的地方都无需改动，\n// 只需要将BAdaptor如下注入到Demo即可。\nDemo d = new Demo(new BAdaptor(new B()));\n</code></pre><h3>4.兼容老版本接口</h3><p>在做版本升级的时候，对于一些要废弃的接口，我们不直接将其删除，而是暂时保留，并且标注为deprecated，并将内部实现逻辑委托为新的接口实现。这样做的好处是，让使用它的项目有个过渡期，而不是强制进行代码修改。这也可以粗略地看作适配器模式的一个应用场景。同样，我还是通过一个例子，来进一步解释一下。</p><p>JDK1.0中包含一个遍历集合容器的类Enumeration。JDK2.0对这个类进行了重构，将它改名为Iterator类，并且对它的代码实现做了优化。但是考虑到如果将Enumeration直接从JDK2.0中删除，那使用JDK1.0的项目如果切换到JDK2.0，代码就会编译不通过。为了避免这种情况的发生，我们必须把项目中所有使用到Enumeration的地方，都修改为使用Iterator才行。</p><p>单独一个项目做Enumeration到Iterator的替换，勉强还能接受。但是，使用Java开发的项目太多了，一次JDK的升级，导致所有的项目不做代码修改就会编译报错，这显然是不合理的。这就是我们经常所说的不兼容升级。为了做到兼容使用低版本JDK的老代码，我们可以暂时保留Enumeration类，并将其实现替换为直接调用Itertor。代码示例如下所示：</p><pre><code>public class Collections {\n  public static Emueration emumeration(final Collection c) {\n    return new Enumeration() {\n      Iterator i = c.iterator();\n      \n      public boolean hasMoreElments() {\n        return i.hashNext();\n      }\n      \n      public Object nextElement() {\n        return i.next():\n      }\n    }\n  }\n}\n</code></pre><h3>5.适配不同格式的数据</h3><p>前面我们讲到，适配器模式主要用于接口的适配，实际上，它还可以用在不同格式的数据之间的适配。比如，把从不同征信系统拉取的不同格式的征信数据，统一为相同的格式，以方便存储和使用。再比如，Java中的Arrays.asList()也可以看作一种数据适配器，将数组类型的数据转化为集合容器类型。</p><pre><code>List&lt;String&gt; stooges = Arrays.asList(&quot;Larry&quot;, &quot;Moe&quot;, &quot;Curly&quot;);\n</code></pre><h2>剖析适配器模式在Java日志中的应用</h2><p>Java中有很多日志框架，在项目开发中，我们常常用它们来打印日志信息。其中，比较常用的有log4j、logback，以及JDK提供的JUL(java.util.logging)和Apache的JCL(Jakarta Commons Logging)等。</p><p>大部分日志框架都提供了相似的功能，比如按照不同级别（debug、info、warn、erro……）打印日志等，但它们却并没有实现统一的接口。这主要可能是历史的原因，它不像JDBC那样，一开始就制定了数据库操作的接口规范。</p><p>如果我们只是开发一个自己用的项目，那用什么日志框架都可以，log4j、logback随便选一个就好。但是，如果我们开发的是一个集成到其他系统的组件、框架、类库等，那日志框架的选择就没那么随意了。</p><p>比如，项目中用到的某个组件使用log4j来打印日志，而我们项目本身使用的是logback。将组件引入到项目之后，我们的项目就相当于有了两套日志打印框架。每种日志框架都有自己特有的配置方式。所以，我们要针对每种日志框架编写不同的配置文件（比如，日志存储的文件地址、打印日志的格式）。如果引入多个组件，每个组件使用的日志框架都不一样，那日志本身的管理工作就变得非常复杂。所以，为了解决这个问题，我们需要统一日志打印框架。</p><p>如果你是做Java开发的，那Slf4j这个\b日志框架你肯定不陌生，它相当于JDBC规范，提供了一套打印日志的统一接口规范。不过，它只定义了接口，并没有提供具体的实现，需要配合其他日志框架（log4j、logback……）来使用。</p><p>不仅如此，Slf4j的出现晚于JUL、JCL、log4j等日志框架，所以，这些日志框架也不可能牺牲掉版本兼容性，将接口改造成符合Slf4j接口规范。Slf4j也事先考虑到了这个问题，所以，它不仅仅提供了统一的接口定义，还提供了针对不同日志框架的适配器。对不同日志框架的接口进行二次封装，适配成统一的Slf4j接口定义。具体的代码示例如下所示：</p><pre><code>// slf4j统一的接口定义\npackage org.slf4j;\npublic interface Logger {\n  public boolean isTraceEnabled();\n  public void trace(String msg);\n  public void trace(String format, Object arg);\n  public void trace(String format, Object arg1, Object arg2);\n  public void trace(String format, Object[] argArray);\n  public void trace(String msg, Throwable t);\n \n  public boolean isDebugEnabled();\n  public void debug(String msg);\n  public void debug(String format, Object arg);\n  public void debug(String format, Object arg1, Object arg2)\n  public void debug(String format, Object[] argArray)\n  public void debug(String msg, Throwable t);\n\n  //...省略info、warn、error等一堆接口\n}\n\n// log4j日志框架的适配器\n// Log4jLoggerAdapter实现了LocationAwareLogger接口，\n// 其中LocationAwareLogger继承自Logger接口，\n// 也就相当于Log4jLoggerAdapter实现了Logger接口。\npackage org.slf4j.impl;\npublic final class Log4jLoggerAdapter extends MarkerIgnoringBase\n  implements LocationAwareLogger, Serializable {\n  final transient org.apache.log4j.Logger logger; // log4j\n \n  public boolean isDebugEnabled() {\n    return logger.isDebugEnabled();\n  }\n \n  public void debug(String msg) {\n    logger.log(FQCN, Level.DEBUG, msg, null);\n  }\n \n  public void debug(String format, Object arg) {\n    if (logger.isDebugEnabled()) {\n      FormattingTuple ft = MessageFormatter.format(format, arg);\n      logger.log(FQCN, Level.DEBUG, ft.getMessage(), ft.getThrowable());\n    }\n  }\n \n  public void debug(String format, Object arg1, Object arg2) {\n    if (logger.isDebugEnabled()) {\n      FormattingTuple ft = MessageFormatter.format(format, arg1, arg2);\n      logger.log(FQCN, Level.DEBUG, ft.getMessage(), ft.getThrowable());\n    }\n  }\n \n  public void debug(String format, Object[] argArray) {\n    if (logger.isDebugEnabled()) {\n      FormattingTuple ft = MessageFormatter.arrayFormat(format, argArray);\n      logger.log(FQCN, Level.DEBUG, ft.getMessage(), ft.getThrowable());\n    }\n  }\n \n  public void debug(String msg, Throwable t) {\n    logger.log(FQCN, Level.DEBUG, msg, t);\n  }\n  //...省略一堆接口的实现...\n}\n</code></pre><p>所以，在开发业务系统或者开发框架、组件的时候，我们统一使用Slf4j提供的接口来编写打印日志的代码，具体使用哪种日志框架实现（log4j、logback……），是可以动态地指定的（使用Java的SPI技术，这里我不多解释，你自行研究吧），只需要将相应的SDK导入到项目中即可。</p><p>不过，你可能会说，如果一些老的项目没有使用Slf4j，而是直接使用比如JCL来打印日志，那如果想要替换成其他日志框架，比如log4j，该怎么办呢？实际上，Slf4j不仅仅提供了从其他日志框架到Slf4j的适配器，还提供了反向适配器，也就是从Slf4j到其他日志框架的适配。我们可以先将JCL切换为Slf4j，然后再将Slf4j切换为log4j。经过两次适配器的转换，我们就能成功将log4j切换为了logback。</p><h2>代理、桥接、装饰器、适配器4种设计模式的区别</h2><p>代理、桥接、装饰器、适配器，这4种模式是比较常用的结构型设计模式。它们的代码结构非常相似。笼统来说，它们都可以称为Wrapper模式，也就是通过Wrapper类二次封装原始类。</p><p>尽管代码结构相似，但这4种设计模式的用意完全不同，也就是说要解决的问题、应用场景不同，这也是它们的主要区别。这里我就简单说一下它们之间的区别。</p><p><strong>代理模式：</strong>代理模式在不改变原始类接口的条件下，为原始类定义一个代理类，主要目的是控制访问，而非加强功能，这是它跟装饰器模式最大的不同。</p><p><strong>桥接模式：</strong>桥接模式的目的是将接口部分和实现部分分离，从而让它们可以较为容易、也相对独立地加以改变。</p><p><strong>装饰器模式：</strong>装饰者模式在不改变原始类接口的情况下，对原始类功能进行增强，并且支持多个装饰器的嵌套使用。</p><p><strong>适配器模式：</strong>适配器模式是一种事后的补救策略。适配器提供跟原始类不同的接口，而代理模式、装饰器模式提供的都是跟原始类相同的接口。</p><h2>重点回顾</h2><p>好了，今天的内容到此就讲完了。让我们一块来总结回顾一下，你需要重点掌握的内容。</p><p>适配器模式是用来做适配，它将不兼容的接口转换为可兼容的接口，让原本由于接口不兼容而不能一起工作的类可以一起工作。适配器模式有两种实现方式：类适配器和对象适配器。其中，类适配器使用继承关系来实现，对象适配器使用组合关系来实现。</p><p>一般来说，适配器模式可以看作一种“补偿模式”，用来补救设计上的缺陷。应用这种模式算是“无奈之举”，如果在设计初期，我们就能协调规避接口不兼容的问题，那这种模式就没有应用的机会了。</p><p>那在实际的开发中，什么情况下才会出现接口不兼容呢？我总结下了下面这样5种场景：</p><ul>\n<li>封装有缺陷的接口设计</li>\n<li>统一多个类的接口设计</li>\n<li>替换依赖的外部系统</li>\n<li>兼容老版本接口</li>\n<li>适配不同格式的数据</li>\n</ul><h2>课堂讨论</h2><p>今天我们讲到，适配器有两种实现方式：类适配器、对象适配器。那我们之前讲到的代理模式、装饰器模式，是否也同样可以有两种实现方式（类代理模式、对象代理模式，以及类装饰器模式、对象装饰器模式）呢？</p><p>欢迎留言和我分享你的思考，如果有收获，也欢迎你把这篇文章分享给你的朋友。</p>",
                "article_title": "51 | 适配器模式：代理、适配器、桥接、装饰，这四个模式有何区别？"
            },
            {
                "title": "52 | 门面模式：如何设计合理的接口粒度以兼顾接口的易用性和通用性？",
                "herf": "https://time.geekbang.org/column/article/206409",
                "id": "206409",
                "content": "<p>前面我们已经学习了代理模式、桥接模式、装饰器模式、适配器模式，这4种结构型设计模式。今天，我们再来学习一种新的结构型模式：门面模式。门面模式原理和实现都特别简单，应用场景也比较明确，主要在接口设计方面使用。</p><p>如果你平时的工作涉及接口开发，不知道你有没有遇到关于接口粒度的问题呢？</p><p>为了保证接口的可复用性（或者叫通用性），我们需要将接口尽量设计得细粒度一点，职责单一一点。但是，如果接口的粒度过小，在接口的使用者开发一个业务功能时，就会导致需要调用n多细粒度的接口才能完成。调用者肯定会抱怨接口不好用。</p><p>相反，如果接口粒度设计得太大，一个接口返回n多数据，要做n多事情，就会导致接口不够通用、可复用性不好。接口不可复用，那针对不同的调用者的业务需求，我们就需要开发不同的接口来满足，这就会导致系统的接口无限膨胀。</p><p>那如何来解决接口的可复用性（通用性）和易用性之间的矛盾呢？通过今天对于门面模式的学习，我想你心中会有答案。话不多说，让我们正式开始今天的学习吧！</p><h2>门面模式的原理与实现</h2><p>门面模式，也叫外观模式，英文全称是Facade Design Pattern。在GoF的《设计模式》一书中，门面模式是这样定义的：</p><blockquote>\n<p>Provide a unified interface to a set of interfaces in a subsystem. Facade Pattern defines a higher-level interface that makes the subsystem easier to use.</p>\n</blockquote><!-- [[[read_end]]] --><p>翻译成中文就是：门面模式为子系统提供一组统一的接口，定义一组高层接口让子系统更易用。</p><p>这个定义很简洁，我再进一步解释一下。</p><p>假设有一个系统A，提供了a、b、c、d四个接口。系统B完成某个业务功能，需要调用A系统的a、b、d接口。利用门面模式，我们提供一个包裹a、b、d接口调用的门面接口x，给系统B直接使用。</p><p>不知道你会不会有这样的疑问，让系统B直接调用a、b、d感觉没有太大问题呀，为什么还要提供一个包裹a、b、d的接口x呢？关于这个问题，我通过一个具体的例子来解释一下。</p><p>假设我们刚刚提到的系统A是一个后端服务器，系统B是App客户端。App客户端通过后端服务器提供的接口来获取数据。我们知道，App和服务器之间是通过移动网络通信的，网络通信耗时比较多，为了提高App的响应速度，我们要尽量减少App与服务器之间的网络通信次数。</p><p>假设，完成某个业务功能（比如显示某个页面信息）需要“依次”调用a、b、d三个接口，因自身业务的特点，不支持并发调用这三个接口。</p><p>如果我们现在发现App客户端的响应速度比较慢，排查之后发现，是因为过多的接口调用过多的网络通信。针对这种情况，我们就可以利用门面模式，让后端服务器提供一个包裹a、b、d三个接口调用的接口x。App客户端调用一次接口x，来获取到所有想要的数据，将网络通信的次数从3次减少到1次，也就提高了App的响应速度。</p><p>这里举的例子只是应用门面模式的其中一个意图，也就是解决性能问题。实际上，不同的应用场景下，使用门面模式的意图也不同。接下来，我们就来看一下门面模式的各种应用场景。</p><h2>门面模式的应用场景举例</h2><p>在GoF给出的定义中提到，“门面模式让子系统更加易用”，实际上，它除了解决易用性问题之外，还能解决其他很多方面的问题。关于这一点，我总结罗列了3个常用的应用场景，你可以参考一下，举一反三地借鉴到自己的项目中。</p><p>除此之外，我还要强调一下，门面模式定义中的“子系统（subsystem）”也可以有多种理解方式。它既可以是一个完整的系统，也可以是更细粒度的类或者模块。关于这一点，在下面的讲解中也会有体现。</p><h3>1.解决易用性问题</h3><p>门面模式可以用来封装系统的底层实现，隐藏系统的复杂性，提供一组更加简单易用、更高层的接口。比如，Linux系统调用函数就可以看作一种“门面”。它是Linux操作系统暴露给开发者的一组“特殊”的编程接口，它封装了底层更基础的Linux内核调用。再比如，Linux的Shell命令，实际上也可以看作一种门面模式的应用。它继续封装系统调用，提供更加友好、简单的命令，让我们可以直接通过执行命令来跟操作系统交互。</p><p>我们前面也多次讲过，设计原则、思想、模式很多都是相通的，是同一个道理不同角度的表述。实际上，从隐藏实现复杂性，提供更易用接口这个意图来看，门面模式有点类似之前讲到的迪米特法则（最少知识原则）和接口隔离原则：两个有交互的系统，只暴露有限的必要的接口。除此之外，门面模式还有点类似之前提到封装、抽象的设计思想，提供更抽象的接口，封装底层实现细节。</p><h3>2.解决性能问题</h3><p>关于利用门面模式解决性能问题这一点，刚刚我们已经讲过了。我们通过将多个接口调用替换为一个门面接口调用，减少网络通信成本，提高App客户端的响应速度。所以，关于这点，我就不再举例说明了。我们来讨论一下这样一个问题：从代码实现的角度来看，该如何组织门面接口和非门面接口？</p><p>如果门面接口不多，我们完全可以将它跟非门面接口放到一块，也不需要特殊标记，当作普通接口来用即可。如果门面接口很多，我们可以在已有的接口之上，再重新抽象出一层，专门放置门面接口，从类、包的命名上跟原来的接口层做区分。如果门面接口特别多，并且很多都是跨多个子系统的，我们可以将门面接口放到一个新的子系统中。</p><h3>3.解决分布式事务问题</h3><p>关于利用门面模式来解决分布式事务问题，我们通过一个例子来解释一下。</p><p>在一个金融系统中，有两个业务领域模型，用户和钱包。这两个业务领域模型都对外暴露了一系列接口，比如用户的增删改查接口、钱包的增删改查接口。假设有这样一个业务场景：在用户注册的时候，我们不仅会创建用户（在数据库User表中），还会给用户创建一个钱包（在数据库的Wallet表中）。</p><p>对于这样一个简单的业务需求，我们可以通过依次调用用户的创建接口和钱包的创建接口来完成。但是，用户注册需要支持事务，也就是说，创建用户和钱包的两个操作，要么都成功，要么都失败，不能一个成功、一个失败。</p><p>要支持两个接口调用在一个事务中执行，是比较难实现的，这涉及分布式事务问题。虽然我们可以通过引入分布式事务框架或者事后补偿的机制来解决，但代码实现都比较复杂。而最简单的解决方案是，利用数据库事务或者Spring框架提供的事务（如果是Java语言的话），在一个事务中，执行创建用户和创建钱包这两个SQL操作。这就要求两个SQL操作要在一个接口中完成，所以，我们可以借鉴门面模式的思想，再设计一个包裹这两个操作的新接口，让新接口在一个事务中执行两个SQL操作。</p><h2>重点回顾</h2><p>好了，今天的内容到此就讲完了。我们来一块总结回顾一下，你需要重点掌握的内容。</p><p>我们知道，类、模块、系统之间的“通信”，一般都是通过接口调用来完成的。接口设计的好坏，直接影响到类、模块、系统是否好用。所以，我们要多花点心思在接口设计上。我经常说，<strong>完成接口设计，就相当于完成了一半的开发任务。只要接口设计得好，那代码就差不到哪里去。</strong></p><p>接口粒度设计得太大，太小都不好。太大会导致接口不可复用，太小会导致接口不易用。在实际的开发中，接口的可复用性和易用性需要“微妙”的权衡。针对这个问题，我的一个基本的处理原则是，<strong>尽量保持接口的可复用性，但针对特殊情况，允许提供冗余的门面接口，来提供更易用的接口</strong>。</p><p>门面模式除了解决接口易用性问题之外，我们今天还讲到了其他2个应用场景，用它来解决性能问题和分布式事务问题。</p><h2>课堂讨论</h2><ol>\n<li>适配器模式和门面模式的共同点是，将不好用的接口适配成好用的接口。你可以试着总结一下它们的区别吗？</li>\n<li>在你过往的项目开发中，有没有遇到过不合理的接口需求？又或者，有没有遇到过非常难用的接口？可以留言“吐槽”一下。</li>\n</ol><p>欢迎留言和我分享，如果有收获，也欢迎你把这篇文章分享给你的朋友。</p>",
                "article_title": "52 | 门面模式：如何设计合理的接口粒度以兼顾接口的易用性和通用性？"
            },
            {
                "title": "53 | 组合模式：如何设计实现支持递归遍历的文件系统目录树结构？",
                "herf": "https://time.geekbang.org/column/article/207456",
                "id": "207456",
                "content": "<p>结构型设计模式就快要讲完了，还剩下两个不那么常用的：组合模式和享元模式。今天，我们来讲一下<strong>组合模式</strong>（Composite Design Pattern）。</p><p>组合模式跟我们之前讲的面向对象设计中的“组合关系（通过组合来组装两个类）”，完全是两码事。这里讲的“组合模式”，主要是用来处理树形结构数据。这里的“数据”，你可以简单理解为一组对象集合，待会我们会详细讲解。</p><p>正因为其应用场景的特殊性，数据必须能表示成树形结构，这也导致了这种模式在实际的项目开发中并不那么常用。但是，一旦数据满足树形结构，应用这种模式就能发挥很大的作用，能让代码变得非常简洁。</p><p>话不多说，让我们正式开始今天的学习吧！</p><h2>组合模式的原理与实现</h2><p>在GoF的《设计模式》一书中，组合模式是这样定义的：</p><blockquote>\n<p>Compose objects into tree structure to represent part-whole hierarchies.Composite lets client treat individual objects and compositions of objects uniformly.</p>\n</blockquote><p>翻译成中文就是：将一组对象组织（Compose）成树形结构，以表示一种“部分-整体”的层次结构。组合让客户端（在很多设计模式书籍中，“客户端”代指代码的使用者。）可以统一单个对象和组合对象的处理逻辑。</p><!-- [[[read_end]]] --><p>接下来，对于组合模式，我举个例子来给你解释一下。</p><p>假设我们有这样一个需求：设计一个类来表示文件系统中的目录，能方便地实现下面这些功能：</p><ul>\n<li>动态地添加、删除某个目录下的子目录或文件；</li>\n<li>统计指定目录下的文件个数；</li>\n<li>统计指定目录下的文件总大小。</li>\n</ul><p>我这里给出了这个类的骨架代码，如下所示。其中的核心逻辑并未实现，你可以试着自己去补充完整，再来看我的讲解。在下面的代码实现中，我们把文件和目录统一用FileSystemNode类来表示，并且通过isFile属性来区分。</p><pre><code>public class FileSystemNode {\n  private String path;\n  private boolean isFile;\n  private List&lt;FileSystemNode&gt; subNodes = new ArrayList&lt;&gt;();\n\n  public FileSystemNode(String path, boolean isFile) {\n    this.path = path;\n    this.isFile = isFile;\n  }\n\n  public int countNumOfFiles() {\n    // TODO:...\n  }\n\n  public long countSizeOfFiles() {\n    // TODO:...\n  }\n\n  public String getPath() {\n    return path;\n  }\n\n  public void addSubNode(FileSystemNode fileOrDir) {\n    subNodes.add(fileOrDir);\n  }\n\n  public void removeSubNode(FileSystemNode fileOrDir) {\n    int size = subNodes.size();\n    int i = 0;\n    for (; i &lt; size; ++i) {\n      if (subNodes.get(i).getPath().equalsIgnoreCase(fileOrDir.getPath())) {\n        break;\n      }\n    }\n    if (i &lt; size) {\n      subNodes.remove(i);\n    }\n  }\n}\n</code></pre><p>实际上，如果你看过我的《数据结构与算法之美》专栏，想要补全其中的countNumOfFiles()和countSizeOfFiles()这两个函数，并不是件难事，实际上这就是树上的递归遍历算法。对于文件，我们直接返回文件的个数（返回1）或大小。对于目录，我们遍历目录中每个子目录或者文件，递归计算它们的个数或大小，然后求和，就是这个目录下的文件个数和文件大小。</p><p>我把两个函数的代码实现贴在下面了，你可以对照着看一下。</p><pre><code>  public int countNumOfFiles() {\n    if (isFile) {\n      return 1;\n    }\n    int numOfFiles = 0;\n    for (FileSystemNode fileOrDir : subNodes) {\n      numOfFiles += fileOrDir.countNumOfFiles();\n    }\n    return numOfFiles;\n  }\n\n  public long countSizeOfFiles() {\n    if (isFile) {\n      File file = new File(path);\n      if (!file.exists()) return 0;\n      return file.length();\n    }\n    long sizeofFiles = 0;\n    for (FileSystemNode fileOrDir : subNodes) {\n      sizeofFiles += fileOrDir.countSizeOfFiles();\n    }\n    return sizeofFiles;\n  }\n</code></pre><p>单纯从功能实现角度来说，上面的代码没有问题，已经实现了我们想要的功能。但是，如果我们开发的是一个大型系统，从扩展性（文件或目录可能会对应不同的操作）、业务建模（文件和目录从业务上是两个概念）、代码的可读性（文件和目录区分对待更加符合人们对业务的认知）的角度来说，我们最好对文件和目录进行区分设计，定义为File和Directory两个类。</p><p>按照这个设计思路，我们对代码进行重构。重构之后的代码如下所示：</p><pre><code>public abstract class FileSystemNode {\n  protected String path;\n\n  public FileSystemNode(String path) {\n    this.path = path;\n  }\n\n  public abstract int countNumOfFiles();\n  public abstract long countSizeOfFiles();\n\n  public String getPath() {\n    return path;\n  }\n}\n\npublic class File extends FileSystemNode {\n  public File(String path) {\n    super(path);\n  }\n\n  @Override\n  public int countNumOfFiles() {\n    return 1;\n  }\n\n  @Override\n  public long countSizeOfFiles() {\n    java.io.File file = new java.io.File(path);\n    if (!file.exists()) return 0;\n    return file.length();\n  }\n}\n\npublic class Directory extends FileSystemNode {\n  private List&lt;FileSystemNode&gt; subNodes = new ArrayList&lt;&gt;();\n\n  public Directory(String path) {\n    super(path);\n  }\n\n  @Override\n  public int countNumOfFiles() {\n    int numOfFiles = 0;\n    for (FileSystemNode fileOrDir : subNodes) {\n      numOfFiles += fileOrDir.countNumOfFiles();\n    }\n    return numOfFiles;\n  }\n\n  @Override\n  public long countSizeOfFiles() {\n    long sizeofFiles = 0;\n    for (FileSystemNode fileOrDir : subNodes) {\n      sizeofFiles += fileOrDir.countSizeOfFiles();\n    }\n    return sizeofFiles;\n  }\n\n  public void addSubNode(FileSystemNode fileOrDir) {\n    subNodes.add(fileOrDir);\n  }\n\n  public void removeSubNode(FileSystemNode fileOrDir) {\n    int size = subNodes.size();\n    int i = 0;\n    for (; i &lt; size; ++i) {\n      if (subNodes.get(i).getPath().equalsIgnoreCase(fileOrDir.getPath())) {\n        break;\n      }\n    }\n    if (i &lt; size) {\n      subNodes.remove(i);\n    }\n  }\n}\n</code></pre><p>文件和目录类都设计好了，我们来看，如何用它们来表示一个文件系统中的目录树结构。具体的代码示例如下所示：</p><pre><code>public class Demo {\n  public static void main(String[] args) {\n    /**\n     * /\n     * /wz/\n     * /wz/a.txt\n     * /wz/b.txt\n     * /wz/movies/\n     * /wz/movies/c.avi\n     * /xzg/\n     * /xzg/docs/\n     * /xzg/docs/d.txt\n     */\n    Directory fileSystemTree = new Directory(&quot;/&quot;);\n    Directory node_wz = new Directory(&quot;/wz/&quot;);\n    Directory node_xzg = new Directory(&quot;/xzg/&quot;);\n    fileSystemTree.addSubNode(node_wz);\n    fileSystemTree.addSubNode(node_xzg);\n\n    File node_wz_a = new File(&quot;/wz/a.txt&quot;);\n    File node_wz_b = new File(&quot;/wz/b.txt&quot;);\n    Directory node_wz_movies = new Directory(&quot;/wz/movies/&quot;);\n    node_wz.addSubNode(node_wz_a);\n    node_wz.addSubNode(node_wz_b);\n    node_wz.addSubNode(node_wz_movies);\n\n    File node_wz_movies_c = new File(&quot;/wz/movies/c.avi&quot;);\n    node_wz_movies.addSubNode(node_wz_movies_c);\n\n    Directory node_xzg_docs = new Directory(&quot;/xzg/docs/&quot;);\n    node_xzg.addSubNode(node_xzg_docs);\n\n    File node_xzg_docs_d = new File(&quot;/xzg/docs/d.txt&quot;);\n    node_xzg_docs.addSubNode(node_xzg_docs_d);\n\n    System.out.println(&quot;/ files num:&quot; + fileSystemTree.countNumOfFiles());\n    System.out.println(&quot;/wz/ files num:&quot; + node_wz.countNumOfFiles());\n  }\n}\n</code></pre><p>我们对照着这个例子，再重新看一下组合模式的定义：“将一组对象（文件和目录）组织成树形结构，以表示一种‘部分-整体’的层次结构（目录与子目录的嵌套结构）。组合模式让客户端可以统一单个对象（文件）和组合对象（目录）的处理逻辑（递归遍历）。”</p><p>实际上，刚才讲的这种组合模式的设计思路，与其说是一种设计模式，倒不如说是对业务场景的一种数据结构和算法的抽象。其中，数据可以表示成树这种数据结构，业务需求可以通过在树上的递归遍历算法来实现。</p><h2>组合模式的应用场景举例</h2><p>刚刚我们讲了文件系统的例子，对于组合模式，我这里再举一个例子。搞懂了这两个例子，你基本上就算掌握了组合模式。在实际的项目中，遇到类似的可以表示成树形结构的业务场景，你只要“照葫芦画瓢”去设计就可以了。</p><p>假设我们在开发一个OA系统（办公自动化系统）。公司的组织结构包含部门和员工两种数据类型。其中，部门又可以包含子部门和员工。在数据库中的表结构如下所示：</p><p><img src=\"https://static001.geekbang.org/resource/image/5b/8b/5b19dc0c296f728328794eab1f16a38b.jpg\" alt=\"\"></p><p>我们希望在内存中构建整个公司的人员架构图（部门、子部门、员工的隶属关系），并且提供接口计算出部门的薪资成本（隶属于这个部门的所有员工的薪资和）。</p><p>部门包含子部门和员工，这是一种嵌套结构，可以表示成树这种数据结构。计算每个部门的薪资开支这样一个需求，也可以通过在树上的遍历算法来实现。所以，从这个角度来看，这个应用场景可以使用组合模式来设计和实现。</p><p>这个例子的代码结构跟上一个例子的很相似，代码实现我直接贴在了下面，你可以对比着看一下。其中，HumanResource是部门类（Department）和员工类（Employee）抽象出来的父类，为的是能统一薪资的处理逻辑。Demo中的代码负责从数据库中读取数据并在内存中构建组织架构图。</p><pre><code>public abstract class HumanResource {\n  protected long id;\n  protected double salary;\n\n  public HumanResource(long id) {\n    this.id = id;\n  }\n\n  public long getId() {\n    return id;\n  }\n\n  public abstract double calculateSalary();\n}\n\npublic class Employee extends HumanResource {\n  public Employee(long id, double salary) {\n    super(id);\n    this.salary = salary;\n  }\n\n  @Override\n  public double calculateSalary() {\n    return salary;\n  }\n}\n\npublic class Department extends HumanResource {\n  private List&lt;HumanResource&gt; subNodes = new ArrayList&lt;&gt;();\n\n  public Department(long id) {\n    super(id);\n  }\n\n  @Override\n  public double calculateSalary() {\n    double totalSalary = 0;\n    for (HumanResource hr : subNodes) {\n      totalSalary += hr.calculateSalary();\n    }\n    this.salary = totalSalary;\n    return totalSalary;\n  }\n\n  public void addSubNode(HumanResource hr) {\n    subNodes.add(hr);\n  }\n}\n\n// 构建组织架构的代码\npublic class Demo {\n  private static final long ORGANIZATION_ROOT_ID = 1001;\n  private DepartmentRepo departmentRepo; // 依赖注入\n  private EmployeeRepo employeeRepo; // 依赖注入\n\n  public void buildOrganization() {\n    Department rootDepartment = new Department(ORGANIZATION_ROOT_ID);\n    buildOrganization(rootDepartment);\n  }\n\n  private void buildOrganization(Department department) {\n    List&lt;Long&gt; subDepartmentIds = departmentRepo.getSubDepartmentIds(department.getId());\n    for (Long subDepartmentId : subDepartmentIds) {\n      Department subDepartment = new Department(subDepartmentId);\n      department.addSubNode(subDepartment);\n      buildOrganization(subDepartment);\n    }\n    List&lt;Long&gt; employeeIds = employeeRepo.getDepartmentEmployeeIds(department.getId());\n    for (Long employeeId : employeeIds) {\n      double salary = employeeRepo.getEmployeeSalary(employeeId);\n      department.addSubNode(new Employee(employeeId, salary));\n    }\n  }\n}\n</code></pre><p>我们再拿组合模式的定义跟这个例子对照一下：“将一组对象（员工和部门）组织成树形结构，以表示一种‘部分-整体’的层次结构（部门与子部门的嵌套结构）。组合模式让客户端可以统一单个对象（员工）和组合对象（部门）的处理逻辑（递归遍历）。”</p><h2>重点回顾</h2><p>好了，今天的内容到此就讲完了。我们一块来总结回顾一下，你需要重点掌握的内容。</p><p>组合模式的设计思路，与其说是一种设计模式，倒不如说是对业务场景的一种数据结构和算法的抽象。其中，数据可以表示成树这种数据结构，业务需求可以通过在树上的递归遍历算法来实现。</p><p>组合模式，将一组对象组织成树形结构，将单个对象和组合对象都看做树中的节点，以统一处理逻辑，并且它利用树形结构的特点，递归地处理每个子树，依次简化代码实现。使用组合模式的前提在于，你的业务场景必须能够表示成树形结构。所以，组合模式的应用场景也比较局限，它并不是一种很常用的设计模式。</p><h2>课堂讨论</h2><p>在文件系统那个例子中，countNumOfFiles()和countSizeOfFiles()这两个函数实现的效率并不高，因为每次调用它们的时候，都要重新遍历一遍子树。有没有什么办法可以提高这两个函数的执行效率呢（注意：文件系统还会涉及频繁的删除、添加文件操作，也就是对应Directory类中的addSubNode()和removeSubNode()函数）？</p><p>欢迎留言和我分享你的想法。如果有收获，也欢迎你把这篇文章分享给你的朋友。</p>",
                "article_title": "53 | 组合模式：如何设计实现支持递归遍历的文件系统目录树结构？"
            },
            {
                "title": "54 | 享元模式（上）：如何利用享元模式优化文本编辑器的内存占用？",
                "herf": "https://time.geekbang.org/column/article/208572",
                "id": "208572",
                "content": "<p>上一节课中，我们讲了组合模式。组合模式并不常用，主要用在数据能表示成树形结构、能通过树的遍历算法来解决的场景中。今天，我们再来学习一个不那么常用的模式，<strong>享元模式</strong>（Flyweight Design Pattern）。这也是我们要学习的最后一个结构型模式。</p><p>跟其他所有的设计模式类似，享元模式的原理和实现也非常简单。今天，我会通过棋牌游戏和文本编辑器两个实际的例子来讲解。除此之外，我还会讲到它跟单例、缓存、对象池的区别和联系。在下一节课中，我会带你剖析一下享元模式在Java Integer、String中的应用。</p><p>话不多说，让我们正式开始今天的学习吧！</p><h2>享元模式原理与实现</h2><p>所谓“享元”，顾名思义就是被共享的单元。享元模式的意图是复用对象，节省内存，前提是享元对象是不可变对象。</p><p>具体来讲，当一个系统中存在大量重复对象的时候，如果这些重复的对象是不可变对象，我们就可以利用享元模式将对象设计成享元，在内存中只保留一份实例，供多处代码引用。这样可以减少内存中对象的数量，起到节省内存的目的。实际上，不仅仅相同对象可以设计成享元，对于相似对象，我们也可以将这些对象中相同的部分（字段）提取出来，设计成享元，让这些大量相似对象引用这些享元。</p><!-- [[[read_end]]] --><p>这里我稍微解释一下，定义中的“不可变对象”指的是，一旦通过构造函数初始化完成之后，它的状态（对象的成员变量或者属性）就不会再被修改了。所以，不可变对象不能暴露任何set()等修改内部状态的方法。之所以要求享元是不可变对象，那是因为它会被多处代码共享使用，避免一处代码对享元进行了修改，影响到其他使用它的代码。</p><p>接下来，我们通过一个简单的例子解释一下享元模式。</p><p>假设我们在开发一个棋牌游戏（比如象棋）。一个游戏厅中有成千上万个“房间”，每个房间对应一个棋局。棋局要保存每个棋子的数据，比如：棋子类型（将、相、士、炮等）、棋子颜色（红方、黑方）、棋子在棋局中的位置。利用这些数据，我们就能显示一个完整的棋盘给玩家。具体的代码如下所示。其中，ChessPiece类表示棋子，ChessBoard类表示一个棋局，里面保存了象棋中30个棋子的信息。</p><pre><code>public class ChessPiece {//棋子\n  private int id;\n  private String text;\n  private Color color;\n  private int positionX;\n  private int positionY;\n\n  public ChessPiece(int id, String text, Color color, int positionX, int positionY) {\n    this.id = id;\n    this.text = text;\n    this.color = color;\n    this.positionX = positionX;\n    this.positionY = positionX;\n  }\n\n  public static enum Color {\n    RED, BLACK\n  }\n\n  // ...省略其他属性和getter/setter方法...\n}\n\npublic class ChessBoard {//棋局\n  private Map&lt;Integer, ChessPiece&gt; chessPieces = new HashMap&lt;&gt;();\n\n  public ChessBoard() {\n    init();\n  }\n\n  private void init() {\n    chessPieces.put(1, new ChessPiece(1, &quot;車&quot;, ChessPiece.Color.BLACK, 0, 0));\n    chessPieces.put(2, new ChessPiece(2,&quot;馬&quot;, ChessPiece.Color.BLACK, 0, 1));\n    //...省略摆放其他棋子的代码...\n  }\n\n  public void move(int chessPieceId, int toPositionX, int toPositionY) {\n    //...省略...\n  }\n}\n</code></pre><p>为了记录每个房间当前的棋局情况，我们需要给每个房间都创建一个ChessBoard棋局对象。因为游戏大厅中有成千上万的房间（实际上，百万人同时在线的游戏大厅也有很多），那保存这么多棋局对象就会消耗大量的内存。有没有什么办法来节省内存呢？</p><p>这个时候，享元模式就可以派上用场了。像刚刚的实现方式，在内存中会有大量的相似对象。这些相似对象的id、text、color都是相同的，唯独positionX、positionY不同。实际上，我们可以将棋子的id、text、color属性拆分出来，设计成独立的类，并且作为享元供多个棋盘复用。这样，棋盘只需要记录每个棋子的位置信息就可以了。具体的代码实现如下所示：</p><pre><code>// 享元类\npublic class ChessPieceUnit {\n  private int id;\n  private String text;\n  private Color color;\n\n  public ChessPieceUnit(int id, String text, Color color) {\n    this.id = id;\n    this.text = text;\n    this.color = color;\n  }\n\n  public static enum Color {\n    RED, BLACK\n  }\n\n  // ...省略其他属性和getter方法...\n}\n\npublic class ChessPieceUnitFactory {\n  private static final Map&lt;Integer, ChessPieceUnit&gt; pieces = new HashMap&lt;&gt;();\n\n  static {\n    pieces.put(1, new ChessPieceUnit(1, &quot;車&quot;, ChessPieceUnit.Color.BLACK));\n    pieces.put(2, new ChessPieceUnit(2,&quot;馬&quot;, ChessPieceUnit.Color.BLACK));\n    //...省略摆放其他棋子的代码...\n  }\n\n  public static ChessPieceUnit getChessPiece(int chessPieceId) {\n    return pieces.get(chessPieceId);\n  }\n}\n\npublic class ChessPiece {\n  private ChessPieceUnit chessPieceUnit;\n  private int positionX;\n  private int positionY;\n\n  public ChessPiece(ChessPieceUnit unit, int positionX, int positionY) {\n    this.chessPieceUnit = unit;\n    this.positionX = positionX;\n    this.positionY = positionY;\n  }\n  // 省略getter、setter方法\n}\n\npublic class ChessBoard {\n  private Map&lt;Integer, ChessPiece&gt; chessPieces = new HashMap&lt;&gt;();\n\n  public ChessBoard() {\n    init();\n  }\n\n  private void init() {\n    chessPieces.put(1, new ChessPiece(\n            ChessPieceUnitFactory.getChessPiece(1), 0,0));\n    chessPieces.put(1, new ChessPiece(\n            ChessPieceUnitFactory.getChessPiece(2), 1,0));\n    //...省略摆放其他棋子的代码...\n  }\n\n  public void move(int chessPieceId, int toPositionX, int toPositionY) {\n    //...省略...\n  }\n}\n</code></pre><p>在上面的代码实现中，我们利用工厂类来缓存ChessPieceUnit信息（也就是id、text、color）。通过工厂类获取到的ChessPieceUnit就是享元。所有的ChessBoard对象共享这30个ChessPieceUnit对象（因为象棋中只有30个棋子）。在使用享元模式之前，记录1万个棋局，我们要创建30万（30*1万）个棋子的ChessPieceUnit对象。利用享元模式，我们只需要创建30个享元对象供所有棋局共享使用即可，大大节省了内存。</p><p>那享元模式的原理讲完了，我们来总结一下它的代码结构。实际上，它的代码实现非常简单，主要是通过工厂模式，在工厂类中，通过一个Map来缓存已经创建过的享元对象，来达到复用的目的。</p><h2>享元模式在文本编辑器中的应用</h2><p>弄懂了享元模式的原理和实现之后，我们再来看另外一个例子，也就是文章标题中给出的：如何利用享元模式来优化文本编辑器的内存占用？</p><p>你可以把这里提到的文本编辑器想象成Office的Word。不过，为了简化需求背景，我们假设这个文本编辑器只实现了文字编辑功能，不包含图片、表格等复杂的编辑功能。对于简化之后的文本编辑器，我们要在内存中表示一个文本文件，只需要记录文字和格式两部分信息就可以了，其中，格式又包括文字的字体、大小、颜色等信息。</p><p>尽管在实际的文档编写中，我们一般都是按照文本类型（标题、正文……）来设置文字的格式，标题是一种格式，正文是另一种格式等等。但是，从理论上讲，我们可以给文本文件中的每个文字都设置不同的格式。为了实现如此灵活的格式设置，并且代码实现又不过于太复杂，我们把每个文字都当作一个独立的对象来看待，并且在其中包含它的格式信息。具体的代码示例如下所示：</p><pre><code>public class Character {//文字\n  private char c;\n\n  private Font font;\n  private int size;\n  private int colorRGB;\n\n  public Character(char c, Font font, int size, int colorRGB) {\n    this.c = c;\n    this.font = font;\n    this.size = size;\n    this.colorRGB = colorRGB;\n  }\n}\n\npublic class Editor {\n  private List&lt;Character&gt; chars = new ArrayList&lt;&gt;();\n\n  public void appendCharacter(char c, Font font, int size, int colorRGB) {\n    Character character = new Character(c, font, size, colorRGB);\n    chars.add(character);\n  }\n}\n</code></pre><p>在文本编辑器中，我们每敲一个文字，都会调用Editor类中的appendCharacter()方法，创建一个新的Character对象，保存到chars数组中。如果一个文本文件中，有上万、十几万、几十万的文字，那我们就要在内存中存储这么多Character对象。那有没有办法可以节省一点内存呢？</p><p>实际上，在一个文本文件中，用到的字体格式不会太多，毕竟不大可能有人把每个文字都设置成不同的格式。所以，对于字体格式，我们可以将它设计成享元，让不同的文字共享使用。按照这个设计思路，我们对上面的代码进行重构。重构后的代码如下所示：</p><pre><code>public class CharacterStyle {\n  private Font font;\n  private int size;\n  private int colorRGB;\n\n  public CharacterStyle(Font font, int size, int colorRGB) {\n    this.font = font;\n    this.size = size;\n    this.colorRGB = colorRGB;\n  }\n\n  @Override\n  public boolean equals(Object o) {\n    CharacterStyle otherStyle = (CharacterStyle) o;\n    return font.equals(otherStyle.font)\n            &amp;&amp; size == otherStyle.size\n            &amp;&amp; colorRGB == otherStyle.colorRGB;\n  }\n}\n\npublic class CharacterStyleFactory {\n  private static final List&lt;CharacterStyle&gt; styles = new ArrayList&lt;&gt;();\n\n  public static CharacterStyle getStyle(Font font, int size, int colorRGB) {\n    CharacterStyle newStyle = new CharacterStyle(font, size, colorRGB);\n    for (CharacterStyle style : styles) {\n      if (style.equals(newStyle)) {\n        return style;\n      }\n    }\n    styles.add(newStyle);\n    return newStyle;\n  }\n}\n\npublic class Character {\n  private char c;\n  private CharacterStyle style;\n\n  public Character(char c, CharacterStyle style) {\n    this.c = c;\n    this.style = style;\n  }\n}\n\npublic class Editor {\n  private List&lt;Character&gt; chars = new ArrayList&lt;&gt;();\n\n  public void appendCharacter(char c, Font font, int size, int colorRGB) {\n    Character character = new Character(c, CharacterStyleFactory.getStyle(font, size, colorRGB));\n    chars.add(character);\n  }\n}\n</code></pre><h2>享元模式vs单例、缓存、对象池</h2><p>在上面的讲解中，我们多次提到“共享”“缓存”“复用”这些字眼，那它跟单例、缓存、对象池这些概念有什么区别呢？我们来简单对比一下。</p><p><strong>我们先来看享元模式跟单例的区别。</strong></p><p>在单例模式中，一个类只能创建一个对象，而在享元模式中，一个类可以创建多个对象，每个对象被多处代码引用共享。实际上，享元模式有点类似于之前讲到的单例的变体：多例。</p><p>我们前面也多次提到，区别两种设计模式，不能光看代码实现，而是要看设计意图，也就是要解决的问题。尽管从代码实现上来看，享元模式和多例有很多相似之处，但从设计意图上来看，它们是完全不同的。应用享元模式是为了对象复用，节省内存，而应用多例模式是为了限制对象的个数。</p><p><strong>我们再来看享元模式跟缓存的区别。</strong></p><p>在享元模式的实现中，我们通过工厂类来“缓存”已经创建好的对象。这里的“缓存”实际上是“存储”的意思，跟我们平时所说的“数据库缓存”“CPU缓存”“MemCache缓存”是两回事。我们平时所讲的缓存，主要是为了提高访问效率，而非复用。</p><p><strong>最后我们来看享元模式跟对象池的区别。</strong></p><p>对象池、连接池（比如数据库连接池）、线程池等也是为了复用，那它们跟享元模式有什么区别呢？</p><p>你可能对连接池、线程池比较熟悉，对对象池比较陌生，所以，这里我简单解释一下对象池。像C++这样的编程语言，内存的管理是由程序员负责的。为了避免频繁地进行对象创建和释放导致内存碎片，我们可以预先申请一片连续的内存空间，也就是这里说的对象池。每次创建对象时，我们从对象池中直接取出一个空闲对象来使用，对象使用完成之后，再放回到对象池中以供后续复用，而非直接释放掉。</p><p>虽然对象池、连接池、线程池、享元模式都是为了复用，但是，如果我们再细致地抠一抠“复用”这个字眼的话，对象池、连接池、线程池等池化技术中的“复用”和享元模式中的“复用”实际上是不同的概念。</p><p>池化技术中的“复用”可以理解为“重复使用”，主要目的是节省时间（比如从数据库池中取一个连接，不需要重新创建）。在任意时刻，每一个对象、连接、线程，并不会被多处使用，而是被一个使用者独占，当使用完成之后，放回到池中，再由其他使用者重复利用。享元模式中的“复用”可以理解为“共享使用”，在整个生命周期中，都是被所有使用者共享的，主要目的是节省空间。</p><h2>重点回顾</h2><p>好了，今天的内容到此就讲完了。我们来一块总结回顾一下，你需要重点掌握的内容。</p><p><strong>1.享元模式的原理</strong></p><p>所谓“享元”，顾名思义就是被共享的单元。享元模式的意图是复用对象，节省内存，前提是享元对象是不可变对象。具体来讲，当一个系统中存在大量重复对象的时候，我们就可以利用享元模式，将对象设计成享元，在内存中只保留一份实例，供多处代码引用，这样可以减少内存中对象的数量，以起到节省内存的目的。实际上，不仅仅相同对象可以设计成享元，对于相似对象，我们也可以将这些对象中相同的部分（字段），提取出来设计成享元，让这些大量相似对象引用这些享元。</p><p><strong>2.享元模式的实现</strong></p><p>享元模式的代码实现非常简单，主要是通过工厂模式，在工厂类中，通过一个Map或者List来缓存已经创建好的享元对象，以达到复用的目的。</p><p><strong>3.享元模式VS单例、缓存、对象池</strong></p><p>我们前面也多次提到，区别两种设计模式，不能光看代码实现，而是要看设计意图，也就是要解决的问题。这里的区别也不例外。</p><p>我们可以用简单几句话来概括一下它们之间的区别。应用单例模式是为了保证对象全局唯一。应用享元模式是为了实现对象复用，节省内存。缓存是为了提高访问效率，而非复用。池化技术中的“复用”理解为“重复使用”，主要是为了节省时间。</p><h2>课堂讨论</h2><ol>\n<li>在棋牌游戏的例子中，有没有必要把ChessPiecePosition设计成享元呢？</li>\n<li>在文本编辑器的例子中，调用CharacterStyleFactory类的getStyle()方法，需要在styles数组中遍历查找，而遍历查找比较耗时，是否可以优化一下呢？</li>\n</ol><p>欢迎留言和我分享你的想法。如果有收获，也欢迎你把这篇文章分享给你的朋友。</p>",
                "article_title": "54 | 享元模式（上）：如何利用享元模式优化文本编辑器的内存占用？"
            },
            {
                "title": "55 | 享元模式（下）：剖析享元模式在Java Integer、String中的应用",
                "herf": "https://time.geekbang.org/column/article/209343",
                "id": "209343",
                "content": "<p>上一节课，我们通过棋牌游戏和文本编辑器这样两个实际的例子，学习了享元模式的原理、实现以及应用场景。用一句话总结一下，享元模式中的“享元”指被共享的单元。享元模式通过复用对象，以达到节省内存的目的。</p><p>今天，我再用一节课的时间带你剖析一下，享元模式在Java Integer、String中的应用。如果你不熟悉Java编程语言，那也不用担心看不懂，因为今天的内容主要还是介绍设计思路，跟语言本身关系不大。</p><p>话不多说，让我们正式开始今天的学习吧！</p><h2>享元模式在Java Integer中的应用</h2><p>我们先来看下面这样一段代码。你可以先思考下，这段代码会输出什么样的结果。</p><pre><code>Integer i1 = 56;\nInteger i2 = 56;\nInteger i3 = 129;\nInteger i4 = 129;\nSystem.out.println(i1 == i2);\nSystem.out.println(i3 == i4);\n</code></pre><p>如果不熟悉Java语言，你可能会觉得，i1和i2值都是56，i3和i4值都是129，i1跟i2值相等，i3跟i4值相等，所以输出结果应该是两个true。这样的分析是不对的，主要还是因为你对Java语法不熟悉。要正确地分析上面的代码，我们需要弄清楚下面两个问题：</p><ul>\n<li>如何判定两个Java对象是否相等（也就代码中的“==”操作符的含义）？</li>\n<li>什么是自动装箱（Autoboxing）和自动拆箱（Unboxing）？</li>\n</ul><p>在<a href=\"https://time.geekbang.org/column/article/166698\">加餐一</a>中，我们讲到，Java为基本数据类型提供了对应的包装器类型。具体如下所示：</p><!-- [[[read_end]]] --><p><img src=\"https://static001.geekbang.org/resource/image/5f/a0/5f93c0412c9ee8b563383c3583693ba0.jpg\" alt=\"\"></p><p>所谓的自动装箱，就是自动将基本数据类型转换为包装器类型。所谓的自动拆箱，也就是自动将包装器类型转化为基本数据类型。具体的代码示例如下所示：</p><pre><code>Integer i = 56; //自动装箱\nint j = i; //自动拆箱\n</code></pre><p>数值56是基本数据类型int，当赋值给包装器类型（Integer）变量的时候，触发自动装箱操作，创建一个Integer类型的对象，并且赋值给变量i。其底层相当于执行了下面这条语句：</p><pre><code>Integer i = 59；底层执行了：Integer i = Integer.valueOf(59);\n</code></pre><p>反过来，当把包装器类型的变量i，赋值给基本数据类型变量j的时候，触发自动拆箱操作，将i中的数据取出，赋值给j。其底层相当于执行了下面这条语句：</p><pre><code>int j = i; 底层执行了：int j = i.intValue();\n</code></pre><p>弄清楚了自动装箱和自动拆箱，我们再来看，如何判定两个对象是否相等？不过，在此之前，我们先要搞清楚，Java对象在内存中是如何存储的。我们通过下面这个例子来说明一下。</p><pre><code>User a = new User(123, 23); // id=123, age=23\n</code></pre><p>针对这条语句，我画了一张内存存储结构图，如下所示。a存储的值是User对象的内存地址，在图中就表现为a指向User对象。</p><p><img src=\"https://static001.geekbang.org/resource/image/04/dc/04f879d7d72b96965f4e06a21ff13bdc.jpg\" alt=\"\"></p><p>当我们通过“==”来判定两个对象是否相等的时候，实际上是在判断两个局部变量存储的地址是否相同，换句话说，是在判断两个局部变量是否指向相同的对象。</p><p>了解了Java的这几个语法之后，我们重新看一下开头的那段代码。</p><pre><code>Integer i1 = 56;\nInteger i2 = 56;\nInteger i3 = 129;\nInteger i4 = 129;\nSystem.out.println(i1 == i2);\nSystem.out.println(i3 == i4);\n</code></pre><p>前4行赋值语句都会触发自动装箱操作，也就是会创建Integer对象并且赋值给i1、i2、i3、i4这四个变量。根据刚刚的讲解，i1、i2尽管存储的数值相同，都是56，但是指向不同的Integer对象，所以通过“==”来判定是否相同的时候，会返回false。同理，i3==i4判定语句也会返回false。</p><p>不过，上面的分析还是不对，答案并非是两个false，而是一个true，一个false。看到这里，你可能会比较纳闷了。实际上，这正是因为Integer用到了享元模式来复用对象，才导致了这样的运行结果。当我们通过自动装箱，也就是调用valueOf()来创建Integer对象的时候，如果要创建的Integer对象的值在-128到127之间，会从IntegerCache类中直接返回，否则才调用new方法创建。看代码更加清晰一些，Integer类的valueOf()函数的具体代码如下所示：</p><pre><code>public static Integer valueOf(int i) {\n    if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)\n        return IntegerCache.cache[i + (-IntegerCache.low)];\n    return new Integer(i);\n}\n</code></pre><p>实际上，这里的IntegerCache相当于，我们上一节课中讲的生成享元对象的工厂类，只不过名字不叫xxxFactory而已。我们来看它的具体代码实现。这个类是Integer的内部类，你也可以自行查看JDK源码。</p><pre><code>/**\n * Cache to support the object identity semantics of autoboxing for values between\n * -128 and 127 (inclusive) as required by JLS.\n *\n * The cache is initialized on first usage.  The size of the cache\n * may be controlled by the {@code -XX:AutoBoxCacheMax=&lt;size&gt;} option.\n * During VM initialization, java.lang.Integer.IntegerCache.high property\n * may be set and saved in the private system properties in the\n * sun.misc.VM class.\n */\nprivate static class IntegerCache {\n    static final int low = -128;\n    static final int high;\n    static final Integer cache[];\n\n    static {\n        // high value may be configured by property\n        int h = 127;\n        String integerCacheHighPropValue =\n            sun.misc.VM.getSavedProperty(&quot;java.lang.Integer.IntegerCache.high&quot;);\n        if (integerCacheHighPropValue != null) {\n            try {\n                int i = parseInt(integerCacheHighPropValue);\n                i = Math.max(i, 127);\n                // Maximum array size is Integer.MAX_VALUE\n                h = Math.min(i, Integer.MAX_VALUE - (-low) -1);\n            } catch( NumberFormatException nfe) {\n                // If the property cannot be parsed into an int, ignore it.\n            }\n        }\n        high = h;\n\n        cache = new Integer[(high - low) + 1];\n        int j = low;\n        for(int k = 0; k &lt; cache.length; k++)\n            cache[k] = new Integer(j++);\n\n        // range [-128, 127] must be interned (JLS7 5.1.7)\n        assert IntegerCache.high &gt;= 127;\n    }\n\n    private IntegerCache() {}\n}\n</code></pre><p>为什么IntegerCache只缓存-128到127之间的整型值呢？</p><p>在IntegerCache的代码实现中，当这个类被加载的时候，缓存的享元对象会被集中一次性创建好。毕竟整型值太多了，我们不可能在IntegerCache类中预先创建好所有的整型值，这样既占用太多内存，也使得加载IntegerCache类的时间过长。所以，我们只能选择缓存对于大部分应用来说最常用的整型值，也就是一个字节的大小（-128到127之间的数据）。</p><p>实际上，JDK也提供了方法来让我们可以自定义缓存的最大值，有下面两种方式。如果你通过分析应用的JVM内存占用情况，发现-128到255之间的数据占用的内存比较多，你就可以用如下方式，将缓存的最大值从127调整到255。不过，这里注意一下，JDK并没有提供设置最小值的方法。</p><pre><code>//方法一：\n-Djava.lang.Integer.IntegerCache.high=255\n//方法二：\n-XX:AutoBoxCacheMax=255\n</code></pre><p>现在，让我们再回到最开始的问题，因为56处于-128和127之间，i1和i2会指向相同的享元对象，所以i1==i2返回true。而129大于127，并不会被缓存，每次都会创建一个全新的对象，也就是说，i3和i4指向不同的Integer对象，所以i3==i4返回false。</p><p>实际上，除了Integer类型之外，其他包装器类型，比如Long、Short、Byte等，也都利用了享元模式来缓存-128到127之间的数据。比如，Long类型对应的LongCache享元工厂类及valueOf()函数代码如下所示：</p><pre><code>private static class LongCache {\n    private LongCache(){}\n\n    static final Long cache[] = new Long[-(-128) + 127 + 1];\n\n    static {\n        for(int i = 0; i &lt; cache.length; i++)\n            cache[i] = new Long(i - 128);\n    }\n}\n\npublic static Long valueOf(long l) {\n    final int offset = 128;\n    if (l &gt;= -128 &amp;&amp; l &lt;= 127) { // will cache\n        return LongCache.cache[(int)l + offset];\n    }\n    return new Long(l);\n}\n</code></pre><p>在我们平时的开发中，对于下面这样三种创建整型对象的方式，我们优先使用后两种。</p><pre><code>Integer a = new Integer(123);\nInteger a = 123;\nInteger a = Integer.valueOf(123);\n</code></pre><p>第一种创建方式并不会使用到IntegerCache，而后面两种创建方法可以利用IntegerCache缓存，返回共享的对象，以达到节省内存的目的。举一个极端一点的例子，假设程序需要创建1万个-128到127之间的Integer对象。使用第一种创建方式，我们需要分配1万个Integer对象的内存空间；使用后两种创建方式，我们最多只需要分配256个Integer对象的内存空间。</p><h2>享元模式在Java String中的应用</h2><p>刚刚我们讲了享元模式在Java Integer类中的应用，现在，我们再来看下，享元模式在Java String类中的应用。同样，我们还是先来看一段代码，你觉得这段代码输出的结果是什么呢？</p><pre><code>String s1 = &quot;小争哥&quot;;\nString s2 = &quot;小争哥&quot;;\nString s3 = new String(&quot;小争哥&quot;);\n\nSystem.out.println(s1 == s2);\nSystem.out.println(s1 == s3);\n</code></pre><p>上面代码的运行结果是：一个true，一个false。跟Integer类的设计思路相似，String类利用享元模式来复用相同的字符串常量（也就是代码中的“小争哥”）。JVM会专门开辟一块存储区来存储字符串常量，这块存储区叫作“字符串常量池”。上面代码对应的内存存储结构如下所示：</p><p><img src=\"https://static001.geekbang.org/resource/image/2d/2d/2dfc18575c22efccca191c566b24a22d.jpg\" alt=\"\"></p><p>不过，String类的享元模式的设计，跟Integer类稍微有些不同。Integer类中要共享的对象，是在类加载的时候，就集中一次性创建好的。但是，对于字符串来说，我们没法事先知道要共享哪些字符串常量，所以没办法事先创建好，只能在某个字符串常量第一次被用到的时候，存储到常量池中，当之后再用到的时候，直接引用常量池中已经存在的即可，就不需要再重新创建了。</p><h2>重点回顾</h2><p>好了，今天的内容到此就讲完了。我们一块来总结回顾一下，你需要重点掌握的内容。</p><p>在Java Integer的实现中，-128到127之间的整型对象会被事先创建好，缓存在IntegerCache类中。当我们使用自动装箱或者valueOf()来创建这个数值区间的整型对象时，会复用IntegerCache类事先创建好的对象。这里的IntegerCache类就是享元工厂类，事先创建好的整型对象就是享元对象。</p><p>在Java String类的实现中，JVM开辟一块存储区专门存储字符串常量，这块存储区叫作字符串常量池，类似于Integer中的IntegerCache。不过，跟IntegerCache不同的是，它并非事先创建好需要共享的对象，而是在程序的运行期间，根据需要来创建和缓存字符串常量。</p><p>除此之外，这里我再补充强调一下。</p><p>实际上，享元模式对JVM的垃圾回收并不友好。因为享元工厂类一直保存了对享元对象的引用，这就导致享元对象在没有任何代码使用的情况下，也并不会被JVM垃圾回收机制自动回收掉。因此，在某些情况下，如果对象的生命周期很短，也不会被密集使用，利用享元模式反倒可能会浪费更多的内存。所以，除非经过线上验证，利用享元模式真的可以大大节省内存，否则，就不要过度使用这个模式，为了一点点内存的节省而引入一个复杂的设计模式，得不偿失啊。</p><h2>课堂讨论</h2><p>IntegerCache只能缓存事先指定好的整型对象，那我们是否可以借鉴String的设计思路，不事先指定需要缓存哪些整型对象，而是在程序的运行过程中，当用到某个整型对象的时候，创建好放置到IntegerCache，下次再被用到的时候，直接从IntegerCache中返回呢？</p><p>如果可以这么做，请你按照这个思路重新实现一下IntegerCache类，并且能够做到在某个对象没有任何代码使用的时候，能被JVM垃圾回收机制回收掉。</p><p>欢迎留言和我分享你的想法，如果有收获，欢迎你把这篇文章分享给你的朋友。</p>",
                "article_title": "55 | 享元模式（下）：剖析享元模式在Java Integer、String中的应用"
            }
        ]
    },
    {
        "chapterTitle": "设计模式与范式：行为型 (18讲)",
        "children": [
            {
                "title": "56 | 观察者模式（上）：详解各种应用场景下观察者模式的不同实现方式",
                "herf": "https://time.geekbang.org/column/article/210170",
                "id": "210170",
                "content": "<p>我们常把23种经典的设计模式分为三类：创建型、结构型、行为型。前面我们已经学习了创建型和结构型，从今天起，我们开始学习行为型设计模式。我们知道，创建型设计模式主要解决“对象的创建”问题，结构型设计模式主要解决“类或对象的组合或组装”问题，那行为型设计模式主要解决的就是“类或对象之间的交互”问题。</p><p>行为型设计模式比较多，有11个，几乎占了23种经典设计模式的一半。它们分别是：观察者模式、模板模式、策略模式、职责链模式、状态模式、迭代器模式、访问者模式、备忘录模式、命令模式、解释器模式、中介模式。</p><p>今天，我们学习第一个行为型设计模式，也是在实际的开发中用得比较多的一种模式：观察者模式。根据应用场景的不同，观察者模式会对应不同的代码实现方式：有同步阻塞的实现方式，也有异步非阻塞的实现方式；有进程内的实现方式，也有跨进程的实现方式。今天我会重点讲解原理、实现、应用场景。下一节课，我会带你一块实现一个基于观察者模式的异步非阻塞的EventBus，加深你对这个模式的理解。</p><p>话不多说，让我们正式开始今天的学习吧！</p><h2>原理及应用场景剖析</h2><p><strong>观察者模式</strong>（Observer Design Pattern）也被称为<strong>发布订阅模式</strong>（Publish-Subscribe Design Pattern）。在GoF的《设计模式》一书中，它的定义是这样的：</p><!-- [[[read_end]]] --><blockquote>\n<p>Define a one-to-many dependency between objects so that when one object changes state, all its dependents are notified and updated automatically.</p>\n</blockquote><p>翻译成中文就是：在对象之间定义一个一对多的依赖，当一个对象状态改变的时候，所有依赖的对象都会自动收到通知。</p><p>一般情况下，被依赖的对象叫作<strong>被观察者</strong>（Observable），依赖的对象叫作<strong>观察者</strong>（Observer）。不过，在实际的项目开发中，这两种对象的称呼是比较灵活的，有各种不同的叫法，比如：Subject-Observer、Publisher-Subscriber、Producer-Consumer、EventEmitter-EventListener、Dispatcher-Listener。不管怎么称呼，只要应用场景符合刚刚给出的定义，都可以看作观察者模式。</p><p>实际上，观察者模式是一个比较抽象的模式，根据不同的应用场景和需求，有完全不同的实现方式，待会我们会详细地讲到。现在，我们先来看其中最经典的一种实现方式。这也是在讲到这种模式的时候，很多书籍或资料给出的最常见的实现方式。具体的代码如下所示：</p><pre><code>public interface Subject {\n  void registerObserver(Observer observer);\n  void removeObserver(Observer observer);\n  void notifyObservers(Message message);\n}\n\npublic interface Observer {\n  void update(Message message);\n}\n\npublic class ConcreteSubject implements Subject {\n  private List&lt;Observer&gt; observers = new ArrayList&lt;Observer&gt;();\n\n  @Override\n  public void registerObserver(Observer observer) {\n    observers.add(observer);\n  }\n\n  @Override\n  public void removeObserver(Observer observer) {\n    observers.remove(observer);\n  }\n\n  @Override\n  public void notifyObservers(Message message) {\n    for (Observer observer : observers) {\n      observer.update(message);\n    }\n  }\n\n}\n\npublic class ConcreteObserverOne implements Observer {\n  @Override\n  public void update(Message message) {\n    //TODO: 获取消息通知，执行自己的逻辑...\n    System.out.println(&quot;ConcreteObserverOne is notified.&quot;);\n  }\n}\n\npublic class ConcreteObserverTwo implements Observer {\n  @Override\n  public void update(Message message) {\n    //TODO: 获取消息通知，执行自己的逻辑...\n    System.out.println(&quot;ConcreteObserverTwo is notified.&quot;);\n  }\n}\n\npublic class Demo {\n  public static void main(String[] args) {\n    ConcreteSubject subject = new ConcreteSubject();\n    subject.registerObserver(new ConcreteObserverOne());\n    subject.registerObserver(new ConcreteObserverTwo());\n    subject.notifyObservers(new Message());\n  }\n}\n</code></pre><p>实际上，上面的代码算是观察者模式的“模板代码”，只能反映大体的设计思路。在真实的软件开发中，并不需要照搬上面的模板代码。观察者模式的实现方法各式各样，函数、类的命名等会根据业务场景的不同有很大的差别，比如register函数还可以叫作attach，remove函数还可以叫作detach等等。不过，万变不离其宗，设计思路都是差不多的。</p><p>原理和代码实现都非常简单，也比较好理解，不需要我过多的解释。我们还是通过一个具体的例子来重点讲一下，什么情况下需要用到这种设计模式？或者说，这种设计模式能解决什么问题呢？</p><p>假设我们在开发一个P2P投资理财系统，用户注册成功之后，我们会给用户发放投资体验金。代码实现大致是下面这个样子的：</p><pre><code>public class UserController {\n  private UserService userService; // 依赖注入\n  private PromotionService promotionService; // 依赖注入\n\n  public Long register(String telephone, String password) {\n    //省略输入参数的校验代码\n    //省略userService.register()异常的try-catch代码\n    long userId = userService.register(telephone, password);\n    promotionService.issueNewUserExperienceCash(userId);\n    return userId;\n  }\n}\n</code></pre><p>虽然注册接口做了两件事情，注册和发放体验金，违反单一职责原则，但是，如果没有扩展和修改的需求，现在的代码实现是可以接受的。如果非得用观察者模式，就需要引入更多的类和更加复杂的代码结构，反倒是一种过度设计。</p><p>相反，如果需求频繁变动，比如，用户注册成功之后，不再发放体验金，而是改为发放优惠券，并且还要给用户发送一封“欢迎注册成功”的站内信。这种情况下，我们就需要频繁地修改register()函数中的代码，违反开闭原则。而且，如果注册成功之后需要执行的后续操作越来越多，那register()函数的逻辑会变得越来越复杂，也就影响到代码的可读性和可维护性。</p><p>这个时候，观察者模式就能派上用场了。利用观察者模式，我对上面的代码进行了重构。重构之后的代码如下所示：</p><pre><code>public interface RegObserver {\n  void handleRegSuccess(long userId);\n}\n\npublic class RegPromotionObserver implements RegObserver {\n  private PromotionService promotionService; // 依赖注入\n\n  @Override\n  public void handleRegSuccess(long userId) {\n    promotionService.issueNewUserExperienceCash(userId);\n  }\n}\n\npublic class RegNotificationObserver implements RegObserver {\n  private NotificationService notificationService;\n\n  @Override\n  public void handleRegSuccess(long userId) {\n    notificationService.sendInboxMessage(userId, &quot;Welcome...&quot;);\n  }\n}\n\npublic class UserController {\n  private UserService userService; // 依赖注入\n  private List&lt;RegObserver&gt; regObservers = new ArrayList&lt;&gt;();\n\n  // 一次性设置好，之后也不可能动态的修改\n  public void setRegObservers(List&lt;RegObserver&gt; observers) {\n    regObservers.addAll(observers);\n  }\n\n  public Long register(String telephone, String password) {\n    //省略输入参数的校验代码\n    //省略userService.register()异常的try-catch代码\n    long userId = userService.register(telephone, password);\n\n    for (RegObserver observer : regObservers) {\n      observer.handleRegSuccess(userId);\n    }\n\n    return userId;\n  }\n}\n</code></pre><p>当我们需要添加新的观察者的时候，比如，用户注册成功之后，推送用户注册信息给大数据征信系统，基于观察者模式的代码实现，UserController类的register()函数完全不需要修改，只需要再添加一个实现了RegObserver接口的类，并且通过setRegObservers()函数将它注册到UserController类中即可。</p><p>不过，你可能会说，当我们把发送体验金替换为发送优惠券的时候，需要修改RegPromotionObserver类中handleRegSuccess()函数的代码，这还是违反开闭原则呀？你说得没错，不过，相对于register()函数来说，handleRegSuccess()函数的逻辑要简单很多，修改更不容易出错，引入bug的风险更低。</p><p>前面我们已经学习了很多设计模式，不知道你有没有发现，实际上，<strong>设计模式要干的事情就是解耦。创建型模式是将创建和使用代码解耦，结构型模式是将不同功能代码解耦，行为型模式是将不同的行为代码解耦，具体到观察者模式，它是将观察者和被观察者代码解耦。</strong>借助设计模式，我们利用更好的代码结构，将一大坨代码拆分成职责更单一的小类，让其满足开闭原则、高内聚松耦合等特性，以此来控制和应对代码的复杂性，提高代码的可扩展性。</p><h2>基于不同应用场景的不同实现方式</h2><p>观察者模式的应用场景非常广泛，小到代码层面的解耦，大到架构层面的系统解耦，再或者一些产品的设计思路，都有这种模式的影子，比如，邮件订阅、RSS Feeds，本质上都是观察者模式。</p><p>不同的应用场景和需求下，这个模式也有截然不同的实现方式，开篇的时候我们也提到，有同步阻塞的实现方式，也有异步非阻塞的实现方式；有进程内的实现方式，也有跨进程的实现方式。</p><p>之前讲到的实现方式，从刚刚的分类方式上来看，它是一种同步阻塞的实现方式。观察者和被观察者代码在同一个线程内执行，被观察者一直阻塞，直到所有的观察者代码都执行完成之后，才执行后续的代码。对照上面讲到的用户注册的例子，register()函数依次调用执行每个观察者的handleRegSuccess()函数，等到都执行完成之后，才会返回结果给客户端。</p><p>如果注册接口是一个调用比较频繁的接口，对性能非常敏感，希望接口的响应时间尽可能短，那我们可以将同步阻塞的实现方式改为异步非阻塞的实现方式，以此来减少响应时间。具体来讲，当userService.register()函数执行完成之后，我们启动一个新的线程来执行观察者的handleRegSuccess()函数，这样userController.register()函数就不需要等到所有的handleRegSuccess()函数都执行完成之后才返回结果给客户端。userController.register()函数从执行3个SQL语句才返回，减少到只需要执行1个SQL语句就返回，响应时间粗略来讲减少为原来的1/3。</p><p>那如何实现一个异步非阻塞的观察者模式呢？简单一点的做法是，在每个handleRegSuccess()函数中，创建一个新的线程执行代码。不过，我们还有更加优雅的实现方式，那就是基于EventBus来实现。今天，我们就不展开讲解了。在下一讲中，我会用一节课的时间，借鉴Google Guava EventBus框架的设计思想，手把手带你开发一个支持异步非阻塞的EventBus框架。它可以复用在任何需要异步非阻塞观察者模式的应用场景中。</p><p>刚刚讲到的两个场景，不管是同步阻塞实现方式还是异步非阻塞实现方式，都是进程内的实现方式。如果用户注册成功之后，我们需要发送用户信息给大数据征信系统，而大数据征信系统是一个独立的系统，跟它之间的交互是跨不同进程的，那如何实现一个跨进程的观察者模式呢？</p><p>如果大数据征信系统提供了发送用户注册信息的RPC接口，我们仍然可以沿用之前的实现思路，在handleRegSuccess()函数中调用RPC接口来发送数据。但是，我们还有更加优雅、更加常用的一种实现方式，那就是基于消息队列（Message Queue，比如ActiveMQ）来实现。</p><p>当然，这种实现方式也有弊端，那就是需要引入一个新的系统（消息队列），增加了维护成本。不过，它的好处也非常明显。在原来的实现方式中，观察者需要注册到被观察者中，被观察者需要依次遍历观察者来发送消息。而基于消息队列的实现方式，被观察者和观察者解耦更加彻底，两部分的耦合更小。被观察者完全不感知观察者，同理，观察者也完全不感知被观察者。被观察者只管发送消息到消息队列，观察者只管从消息队列中读取消息来执行相应的逻辑。</p><h2>重点回顾</h2><p>好了，今天的内容到此就讲完了。我们一块来总结回顾一下，你需要重点掌握的内容。</p><p>设计模式要干的事情就是解耦，创建型模式是将创建和使用代码解耦，结构型模式是将不同功能代码解耦，行为型模式是将不同的行为代码解耦，具体到观察者模式，它将观察者和被观察者代码解耦。借助设计模式，我们利用更好的代码结构，将一大坨代码拆分成职责更单一的小类，让其满足开闭原则、高内聚低耦合等特性，以此来控制和应对代码的复杂性，提高代码的可扩展性。</p><p>观察者模式的应用场景非常广泛，小到代码层面的解耦，大到架构层面的系统解耦，再或者一些产品的设计思路，都有这种模式的影子，比如，邮件订阅、RSS Feeds，本质上都是观察者模式。不同的应用场景和需求下，这个模式也有截然不同的实现方式，有同步阻塞的实现方式，也有异步非阻塞的实现方式；有进程内的实现方式，也有跨进程的实现方式。</p><h2>课堂讨论</h2><ol>\n<li>请对比一下“生产者-消费者”模型和观察者模式的区别和联系。</li>\n<li>除了今天提到的观察者模式的几个应用场景，比如邮件订阅，你还能想到有哪些其他的应用场景吗？</li>\n</ol><p>欢迎留言和我分享你的想法。如果有收获，欢迎你把这篇文章分享给你的朋友。</p>",
                "article_title": "56 | 观察者模式（上）：详解各种应用场景下观察者模式的不同实现方式"
            },
            {
                "title": "57 | 观察者模式（下）：如何实现一个异步非阻塞的EventBus框架？",
                "herf": "https://time.geekbang.org/column/article/211239",
                "id": "211239",
                "content": "<p>上一节课中，我们学习了观察者模式的原理、实现、应用场景，重点介绍了不同应用场景下，几种不同的实现方式，包括：同步阻塞、异步非阻塞、进程内、进程间的实现方式。</p><p>同步阻塞是最经典的实现方式，主要是为了代码解耦；异步非阻塞除了能实现代码解耦之外，还能提高代码的执行效率；进程间的观察者模式解耦更加彻底，一般是基于消息队列来实现，用来实现不同进程间的被观察者和观察者之间的交互。</p><p>今天，我们聚焦于异步非阻塞的观察者模式，带你实现一个类似Google Guava EventBus的通用框架。等你学完本节课之后，你会发现，实现一个框架也并非一件难事。</p><p>话不多说，让我们正式开始今天的学习吧！</p><h2>异步非阻塞观察者模式的简易实现</h2><p>上一节课中，我们讲到，对于异步非阻塞观察者模式，如果只是实现一个简易版本，不考虑任何通用性、复用性，实际上是非常容易的。</p><p>我们有两种实现方式。其中一种是：在每个handleRegSuccess()函数中创建一个新的线程执行代码逻辑；另一种是：在UserController的register()函数中使用线程池来执行每个观察者的handleRegSuccess()函数。两种实现方式的具体代码如下所示：</p><!-- [[[read_end]]] --><pre><code>// 第一种实现方式，其他类代码不变，就没有再重复罗列\npublic class RegPromotionObserver implements RegObserver {\n  private PromotionService promotionService; // 依赖注入\n\n  @Override\n  public void handleRegSuccess(Long userId) {\n    Thread thread = new Thread(new Runnable() {\n      @Override\n      public void run() {\n        promotionService.issueNewUserExperienceCash(userId);\n      }\n    });\n    thread.start();\n  }\n}\n\n// 第二种实现方式，其他类代码不变，就没有再重复罗列\npublic class UserController {\n  private UserService userService; // 依赖注入\n  private List&lt;RegObserver&gt; regObservers = new ArrayList&lt;&gt;();\n  private Executor executor;\n\n  public UserController(Executor executor) {\n    this.executor = executor;\n  }\n\n  public void setRegObservers(List&lt;RegObserver&gt; observers) {\n    regObservers.addAll(observers);\n  }\n\n  public Long register(String telephone, String password) {\n    //省略输入参数的校验代码\n    //省略userService.register()异常的try-catch代码\n    long userId = userService.register(telephone, password);\n\n    for (RegObserver observer : regObservers) {\n      executor.execute(new Runnable() {\n        @Override\n        public void run() {\n          observer.handleRegSuccess(userId);\n        }\n      });\n    }\n\n    return userId;\n  }\n}\n</code></pre><p>对于第一种实现方式，频繁地创建和销毁线程比较耗时，并且并发线程数无法控制，创建过多的线程会导致堆栈溢出。第二种实现方式，尽管利用了线程池解决了第一种实现方式的问题，但线程池、异步执行逻辑都耦合在了register()函数中，增加了这部分业务代码的维护成本。</p><p>如果我们的需求更加极端一点，需要在同步阻塞和异步非阻塞之间灵活切换，那就要不停地修改UserController的代码。除此之外，如果在项目中，不止一个业务模块需要用到异步非阻塞观察者模式，那这样的代码实现也无法做到复用。</p><p>我们知道，框架的作用有：隐藏实现细节，降低开发难度，做到代码复用，解耦业务与非业务代码，让程序员聚焦业务开发。针对异步非阻塞观察者模式，我们也可以将它抽象成框架来达到这样的效果，而这个框架就是我们这节课要讲的EventBus。</p><h2>EventBus框架功能需求介绍</h2><p>EventBus翻译为“事件总线”，它提供了实现观察者模式的骨架代码。我们可以基于此框架，非常容易地在自己的业务场景中实现观察者模式，不需要从零开始开发。其中，Google Guava EventBus就是一个比较著名的EventBus框架，它不仅仅支持异步非阻塞模式，同时也支持同步阻塞模式</p><p>现在，我们就通过例子来看一下，Guava EventBus具有哪些功能。还是上节课那个用户注册的例子，我们用Guava EventBus重新实现一下，代码如下所示：</p><pre><code>public class UserController {\n  private UserService userService; // 依赖注入\n\n  private EventBus eventBus;\n  private static final int DEFAULT_EVENTBUS_THREAD_POOL_SIZE = 20;\n\n  public UserController() {\n    //eventBus = new EventBus(); // 同步阻塞模式\n    eventBus = new AsyncEventBus(Executors.newFixedThreadPool(DEFAULT_EVENTBUS_THREAD_POOL_SIZE)); // 异步非阻塞模式\n  }\n\n  public void setRegObservers(List&lt;Object&gt; observers) {\n    for (Object observer : observers) {\n      eventBus.register(observer);\n    }\n  }\n\n  public Long register(String telephone, String password) {\n    //省略输入参数的校验代码\n    //省略userService.register()异常的try-catch代码\n    long userId = userService.register(telephone, password);\n\n    eventBus.post(userId);\n\n    return userId;\n  }\n}\n\npublic class RegPromotionObserver {\n  private PromotionService promotionService; // 依赖注入\n\n  @Subscribe\n  public void handleRegSuccess(Long userId) {\n    promotionService.issueNewUserExperienceCash(userId);\n  }\n}\n\npublic class RegNotificationObserver {\n  private NotificationService notificationService;\n\n  @Subscribe\n  public void handleRegSuccess(Long userId) {\n    notificationService.sendInboxMessage(userId, &quot;...&quot;);\n  }\n}\n</code></pre><p>利用EventBus框架实现的观察者模式，跟从零开始编写的观察者模式相比，从大的流程上来说，实现思路大致一样，都需要定义Observer，并且通过register()函数注册Observer，也都需要通过调用某个函数（比如，EventBus中的post()函数）来给Observer发送消息（在EventBus中消息被称作事件event）。</p><p>但在实现细节方面，它们又有些区别。基于EventBus，我们不需要定义Observer接口，任意类型的对象都可以注册到EventBus中，通过@Subscribe注解来标明类中哪个函数可以接收被观察者发送的消息。</p><p>接下来，我们详细地讲一下，Guava EventBus的几个主要的类和函数。</p><ul>\n<li>EventBus、AsyncEventBus</li>\n</ul><p>Guava EventBus对外暴露的所有可调用接口，都封装在EventBus类中。其中，EventBus实现了同步阻塞的观察者模式，AsyncEventBus继承自EventBus，提供了异步非阻塞的观察者模式。具体使用方式如下所示：</p><pre><code>EventBus eventBus = new EventBus(); // 同步阻塞模式\nEventBus eventBus = new AsyncEventBus(Executors.newFixedThreadPool(8))；// 异步阻塞模式\n</code></pre><ul>\n<li>register()函数</li>\n</ul><p>EventBus类提供了register()函数用来注册观察者。具体的函数定义如下所示。它可以接受任何类型（Object）的观察者。而在经典的观察者模式的实现中，register()函数必须接受实现了同一Observer接口的类对象。</p><pre><code>public void register(Object object);\n</code></pre><ul>\n<li>unregister()函数</li>\n</ul><p>相对于register()函数，unregister()函数用来从EventBus中删除某个观察者。我就不多解释了，具体的函数定义如下所示：</p><pre><code>public void unregister(Object object);\n</code></pre><ul>\n<li>post()函数</li>\n</ul><p>EventBus类提供了post()函数，用来给观察者发送消息。具体的函数定义如下所示：</p><pre><code>public void post(Object event);\n</code></pre><p>跟经典的观察者模式的不同之处在于，当我们调用post()函数发送消息的时候，并非把消息发送给所有的观察者，而是发送给可匹配的观察者。所谓可匹配指的是，能接收的消息类型是发送消息（post函数定义中的event）类型的父类。我举个例子来解释一下。</p><p>比如，AObserver能接收的消息类型是XMsg，BObserver能接收的消息类型是YMsg，CObserver能接收的消息类型是ZMsg。其中，XMsg是YMsg的父类。当我们如下发送消息的时候，相应能接收到消息的可匹配观察者如下所示：</p><pre><code>XMsg xMsg = new XMsg();\nYMsg yMsg = new YMsg();\nZMsg zMsg = new ZMsg();\npost(xMsg); =&gt; AObserver接收到消息\npost(yMsg); =&gt; AObserver、BObserver接收到消息\npost(zMsg); =&gt; CObserver接收到消息\n</code></pre><p>你可能会问，每个Observer能接收的消息类型是在哪里定义的呢？我们来看下Guava EventBus最特别的一个地方，那就是@Subscribe注解。</p><ul>\n<li>@Subscribe注解</li>\n</ul><p>EventBus通过@Subscribe注解来标明，某个函数能接收哪种类型的消息。具体的使用代码如下所示。在DObserver类中，我们通过@Subscribe注解了两个函数f1()、f2()。</p><pre><code>public DObserver {\n  //...省略其他属性和方法...\n  \n  @Subscribe\n  public void f1(PMsg event) { //... }\n  \n  @Subscribe\n  public void f2(QMsg event) { //... }\n}\n</code></pre><p>当通过register()函数将DObserver 类对象注册到EventBus的时候，EventBus会根据@Subscribe注解找到f1()和f2()，并且将两个函数能接收的消息类型记录下来（PMsg-&gt;f1，QMsg-&gt;f2）。当我们通过post()函数发送消息（比如QMsg消息）的时候，EventBus会通过之前的记录（QMsg-&gt;f2），调用相应的函数（f2）。</p><h2>手把手实现一个EventBus框架</h2><p>Guava EventBus的功能我们已经讲清楚了，总体上来说，还是比较简单的。接下来，我们就重复造轮子，“山寨”一个EventBus出来。</p><p>我们重点来看，EventBus中两个核心函数register()和post()的实现原理。弄懂了它们，基本上就弄懂了整个EventBus框架。下面两张图是这两个函数的实现原理图。</p><p><img src=\"https://static001.geekbang.org/resource/image/ce/c6/ce842666fa3dc92bb8f4f2d8e75d12c6.jpg\" alt=\"\"></p><p><img src=\"https://static001.geekbang.org/resource/image/bf/45/bf7ef52a40b1e35b18f369265caca645.jpg\" alt=\"\"></p><p>从图中我们可以看出，最关键的一个数据结构是Observer注册表，记录了消息类型和可接收消息函数的对应关系。当调用register()函数注册观察者的时候，EventBus通过解析@Subscribe注解，生成Observer注册表。当调用post()函数发送消息的时候，EventBus通过注册表找到相应的可接收消息的函数，然后通过Java的反射语法来动态地创建对象、执行函数。对于同步阻塞模式，EventBus在一个线程内依次执行相应的函数。对于异步非阻塞模式，EventBus通过一个线程池来执行相应的函数。</p><p>弄懂了原理，实现起来就简单多了。整个小框架的代码实现包括5个类：EventBus、AsyncEventBus、Subscribe、ObserverAction、ObserverRegistry。接下来，我们依次来看下这5个类。</p><h3>1.Subscribe</h3><p>Subscribe是一个注解，用于标明观察者中的哪个函数可以接收消息。</p><pre><code>@Retention(RetentionPolicy.RUNTIME)\n@Target(ElementType.METHOD)\n@Beta\npublic @interface Subscribe {}\n</code></pre><h3>2.ObserverAction</h3><p>ObserverAction类用来表示@Subscribe注解的方法，其中，target表示观察者类，method表示方法。它主要用在ObserverRegistry观察者注册表中。</p><pre><code>public class ObserverAction {\n  private Object target;\n  private Method method;\n\n  public ObserverAction(Object target, Method method) {\n    this.target = Preconditions.checkNotNull(target);\n    this.method = method;\n    this.method.setAccessible(true);\n  }\n\n  public void execute(Object event) { // event是method方法的参数\n    try {\n      method.invoke(target, event);\n    } catch (InvocationTargetException | IllegalAccessException e) {\n      e.printStackTrace();\n    }\n  }\n}\n</code></pre><h3>3.ObserverRegistry</h3><p>ObserverRegistry类就是前面讲到的Observer注册表，是最复杂的一个类，框架中几乎所有的核心逻辑都在这个类中。这个类大量使用了Java的反射语法，不过代码整体来说都不难理解，其中，一个比较有技巧的地方是CopyOnWriteArraySet的使用。</p><p>CopyOnWriteArraySet，顾名思义，在写入数据的时候，会创建一个新的set，并且将原始数据clone到新的set中，在新的set中写入数据完成之后，再用新的set替换老的set。这样就能保证在写入数据的时候，不影响数据的读取操作，以此来解决读写并发问题。除此之外，CopyOnWriteSet还通过加锁的方式，避免了并发写冲突。具体的作用你可以去查看一下CopyOnWriteSet类的源码，一目了然。</p><pre><code>public class ObserverRegistry {\n  private ConcurrentMap&lt;Class&lt;?&gt;, CopyOnWriteArraySet&lt;ObserverAction&gt;&gt; registry = new ConcurrentHashMap&lt;&gt;();\n\n  public void register(Object observer) {\n    Map&lt;Class&lt;?&gt;, Collection&lt;ObserverAction&gt;&gt; observerActions = findAllObserverActions(observer);\n    for (Map.Entry&lt;Class&lt;?&gt;, Collection&lt;ObserverAction&gt;&gt; entry : observerActions.entrySet()) {\n      Class&lt;?&gt; eventType = entry.getKey();\n      Collection&lt;ObserverAction&gt; eventActions = entry.getValue();\n      CopyOnWriteArraySet&lt;ObserverAction&gt; registeredEventActions = registry.get(eventType);\n      if (registeredEventActions == null) {\n        registry.putIfAbsent(eventType, new CopyOnWriteArraySet&lt;&gt;());\n        registeredEventActions = registry.get(eventType);\n      }\n      registeredEventActions.addAll(eventActions);\n    }\n  }\n\n  public List&lt;ObserverAction&gt; getMatchedObserverActions(Object event) {\n    List&lt;ObserverAction&gt; matchedObservers = new ArrayList&lt;&gt;();\n    Class&lt;?&gt; postedEventType = event.getClass();\n    for (Map.Entry&lt;Class&lt;?&gt;, CopyOnWriteArraySet&lt;ObserverAction&gt;&gt; entry : registry.entrySet()) {\n      Class&lt;?&gt; eventType = entry.getKey();\n      Collection&lt;ObserverAction&gt; eventActions = entry.getValue();\n      if (postedEventType.isAssignableFrom(eventType)) {\n        matchedObservers.addAll(eventActions);\n      }\n    }\n    return matchedObservers;\n  }\n\n  private Map&lt;Class&lt;?&gt;, Collection&lt;ObserverAction&gt;&gt; findAllObserverActions(Object observer) {\n    Map&lt;Class&lt;?&gt;, Collection&lt;ObserverAction&gt;&gt; observerActions = new HashMap&lt;&gt;();\n    Class&lt;?&gt; clazz = observer.getClass();\n    for (Method method : getAnnotatedMethods(clazz)) {\n      Class&lt;?&gt;[] parameterTypes = method.getParameterTypes();\n      Class&lt;?&gt; eventType = parameterTypes[0];\n      if (!observerActions.containsKey(eventType)) {\n        observerActions.put(eventType, new ArrayList&lt;&gt;());\n      }\n      observerActions.get(eventType).add(new ObserverAction(observer, method));\n    }\n    return observerActions;\n  }\n\n  private List&lt;Method&gt; getAnnotatedMethods(Class&lt;?&gt; clazz) {\n    List&lt;Method&gt; annotatedMethods = new ArrayList&lt;&gt;();\n    for (Method method : clazz.getDeclaredMethods()) {\n      if (method.isAnnotationPresent(Subscribe.class)) {\n        Class&lt;?&gt;[] parameterTypes = method.getParameterTypes();\n        Preconditions.checkArgument(parameterTypes.length == 1,\n                &quot;Method %s has @Subscribe annotation but has %s parameters.&quot;\n                        + &quot;Subscriber methods must have exactly 1 parameter.&quot;,\n                method, parameterTypes.length);\n        annotatedMethods.add(method);\n      }\n    }\n    return annotatedMethods;\n  }\n}\n</code></pre><h3>4.EventBus</h3><p>EventBus实现的是阻塞同步的观察者模式。看代码你可能会有些疑问，这明明就用到了线程池Executor啊。实际上，MoreExecutors.directExecutor()是Google Guava提供的工具类，看似是多线程，实际上是单线程。之所以要这么实现，主要还是为了跟AsyncEventBus统一代码逻辑，做到代码复用。</p><pre><code>public class EventBus {\n  private Executor executor;\n  private ObserverRegistry registry = new ObserverRegistry();\n\n  public EventBus() {\n    this(MoreExecutors.directExecutor());\n  }\n\n  protected EventBus(Executor executor) {\n    this.executor = executor;\n  }\n\n  public void register(Object object) {\n    registry.register(object);\n  }\n\n  public void post(Object event) {\n    List&lt;ObserverAction&gt; observerActions = registry.getMatchedObserverActions(event);\n    for (ObserverAction observerAction : observerActions) {\n      executor.execute(new Runnable() {\n        @Override\n        public void run() {\n          observerAction.execute(event);\n        }\n      });\n    }\n  }\n}\n</code></pre><h3>5.AsyncEventBus</h3><p>有了EventBus，AsyncEventBus的实现就非常简单了。为了实现异步非阻塞的观察者模式，它就不能再继续使用MoreExecutors.directExecutor()了，而是需要在构造函数中，由调用者注入线程池。</p><pre><code>public class AsyncEventBus extends EventBus {\n  public AsyncEventBus(Executor executor) {\n    super(executor);\n  }\n}\n</code></pre><p>至此，我们用了不到200行代码，就实现了一个还算凑活能用的EventBus，从功能上来讲，它跟Google Guava EventBus几乎一样。不过，如果去查看<a href=\"https://github.com/google/guava\">Google Guava EventBus的源码</a>，你会发现，在实现细节方面，相比我们现在的实现，它其实做了很多优化，比如优化了在注册表中查找消息可匹配函数的算法。如果有时间的话，建议你去读一下它的源码。</p><h2>重点回顾</h2><p>好了，今天的内容到此就讲完了。我们来一块总结回顾一下，你需要重点掌握的内容。</p><p>框架的作用有：隐藏实现细节，降低开发难度，做到代码复用，解耦业务与非业务代码，让程序员聚焦业务开发。针对异步非阻塞观察者模式，我们也可以将它抽象成框架来达到这样的效果，而这个框架就是我们这节课讲的EventBus。EventBus翻译为“事件总线”，它提供了实现观察者模式的骨架代码。我们可以基于此框架，非常容易地在自己的业务场景中实现观察者模式，不需要从零开始开发。</p><p>很多人觉得做业务开发没有技术挑战，实际上，做业务开发也会涉及很多非业务功能的开发，比如今天讲到的EventBus。在平时的业务开发中，我们要善于抽象这些非业务的、可复用的功能，并积极地把它们实现成通用的框架。</p><h2>课堂讨论</h2><p>在今天内容的第二个模块“EventBus框架功能需求介绍”中，我们用Guava EventBus重新实现了UserController，实际上，代码还是不够解耦。UserController还是耦合了很多跟观察者模式相关的非业务代码，比如创建线程池、注册Observer。为了让UserController更加聚焦在业务功能上，你有什么重构的建议吗？</p><p>欢迎留言和我分享你的想法。如果有收获，也欢迎你把这篇文章分享给你的朋友。</p>",
                "article_title": "57 | 观察者模式（下）：如何实现一个异步非阻塞的EventBus框架？"
            },
            {
                "title": "58 | 模板模式（上）：剖析模板模式在JDK、Servlet、JUnit等中的应用",
                "herf": "https://time.geekbang.org/column/article/212049",
                "id": "212049",
                "content": "<p>上两节课我们学习了第一个行为型设计模式，观察者模式。针对不同的应用场景，我们讲解了不同的实现方式，有同步阻塞、异步非阻塞的实现方式，也有进程内、进程间的实现方式。除此之外，我还带你手把手实现了一个简单的EventBus框架。</p><p>今天，我们再学习另外一种行为型设计模式，模板模式。我们多次强调，绝大部分设计模式的原理和实现，都非常简单，难的是掌握应用场景，搞清楚能解决什么问题。模板模式也不例外。模板模式主要是用来解决复用和扩展两个问题。我们今天会结合Java Servlet、JUnit TestCase、Java InputStream、Java AbstractList四个例子来具体讲解这两个作用。</p><p>话不多说，让我们正式开始今天的学习吧！</p><h2>模板模式的原理与实现</h2><p>模板模式，全称是模板方法设计模式，英文是Template Method Design Pattern。在GoF的《设计模式》一书中，它是这么定义的：</p><blockquote>\n<p>Define the skeleton of an algorithm in an operation, deferring some steps to subclasses. Template Method lets subclasses redefine certain steps of an algorithm without changing the algorithm’s structure.</p>\n</blockquote><!-- [[[read_end]]] --><p>翻译成中文就是：模板方法模式在一个方法中定义一个算法骨架，并将某些步骤推迟到子类中实现。模板方法模式可以让子类在不改变算法整体结构的情况下，重新定义算法中的某些步骤。</p><p>这里的“算法”，我们可以理解为广义上的“业务逻辑”，并不特指数据结构和算法中的“算法”。这里的算法骨架就是“模板”，包含算法骨架的方法就是“模板方法”，这也是模板方法模式名字的由来。</p><p>原理很简单，代码实现就更加简单，我写了一个示例代码，如下所示。templateMethod()函数定义为final，是为了避免子类重写它。method1()和method2()定义为abstract，是为了强迫子类去实现。不过，这些都不是必须的，在实际的项目开发中，模板模式的代码实现比较灵活，待会儿讲到应用场景的时候，我们会有具体的体现。</p><pre><code>public abstract class AbstractClass {\n  public final void templateMethod() {\n    //...\n    method1();\n    //...\n    method2();\n    //...\n  }\n  \n  protected abstract void method1();\n  protected abstract void method2();\n}\n\npublic class ConcreteClass1 extends AbstractClass {\n  @Override\n  protected void method1() {\n    //...\n  }\n  \n  @Override\n  protected void method2() {\n    //...\n  }\n}\n\npublic class ConcreteClass2 extends AbstractClass {\n  @Override\n  protected void method1() {\n    //...\n  }\n  \n  @Override\n  protected void method2() {\n    //...\n  }\n}\n\nAbstractClass demo = ConcreteClass1();\ndemo.templateMethod();\n</code></pre><h2>模板模式作用一：复用</h2><p>开篇的时候，我们讲到模板模式有两大作用：复用和扩展。我们先来看它的第一个作用：复用。</p><p>模板模式把一个算法中不变的流程抽象到父类的模板方法templateMethod()中，将可变的部分method1()、method2()留给子类ContreteClass1和ContreteClass2来实现。所有的子类都可以复用父类中模板方法定义的流程代码。我们通过两个小例子来更直观地体会一下。</p><h3>1.Java InputStream</h3><p>Java IO类库中，有很多类的设计用到了模板模式，比如InputStream、OutputStream、Reader、Writer。我们拿InputStream来举例说明一下。</p><p>我把InputStream部分相关代码贴在了下面。在代码中，read()函数是一个模板方法，定义了读取数据的整个流程，并且暴露了一个可以由子类来定制的抽象方法。不过这个方法也被命名为了read()，只是参数跟模板方法不同。</p><pre><code>public abstract class InputStream implements Closeable {\n  //...省略其他代码...\n  \n  public int read(byte b[], int off, int len) throws IOException {\n    if (b == null) {\n      throw new NullPointerException();\n    } else if (off &lt; 0 || len &lt; 0 || len &gt; b.length - off) {\n      throw new IndexOutOfBoundsException();\n    } else if (len == 0) {\n      return 0;\n    }\n\n    int c = read();\n    if (c == -1) {\n      return -1;\n    }\n    b[off] = (byte)c;\n\n    int i = 1;\n    try {\n      for (; i &lt; len ; i++) {\n        c = read();\n        if (c == -1) {\n          break;\n        }\n        b[off + i] = (byte)c;\n      }\n    } catch (IOException ee) {\n    }\n    return i;\n  }\n  \n  public abstract int read() throws IOException;\n}\n\npublic class ByteArrayInputStream extends InputStream {\n  //...省略其他代码...\n  \n  @Override\n  public synchronized int read() {\n    return (pos &lt; count) ? (buf[pos++] &amp; 0xff) : -1;\n  }\n}\n</code></pre><h3>2.Java AbstractList</h3><p>在Java AbstractList类中，addAll()函数可以看作模板方法，add()是子类需要重写的方法，尽管没有声明为abstract的，但函数实现直接抛出了UnsupportedOperationException异常。前提是，如果子类不重写是不能使用的。</p><pre><code>public boolean addAll(int index, Collection&lt;? extends E&gt; c) {\n    rangeCheckForAdd(index);\n    boolean modified = false;\n    for (E e : c) {\n        add(index++, e);\n        modified = true;\n    }\n    return modified;\n}\n\npublic void add(int index, E element) {\n    throw new UnsupportedOperationException();\n}\n</code></pre><h2>模板模式作用二：扩展</h2><p>模板模式的第二大作用的是扩展。这里所说的扩展，并不是指代码的扩展性，而是指框架的扩展性，有点类似我们之前讲到的控制反转，你可以结合<a href=\"https://time.geekbang.org/column/article/177444\">第19节</a>来一块理解。基于这个作用，模板模式常用在框架的开发中，让框架用户可以在不修改框架源码的情况下，定制化框架的功能。我们通过Junit TestCase、Java Servlet两个例子来解释一下。</p><h3>1.Java Servlet</h3><p>对于Java Web项目开发来说，常用的开发框架是SpringMVC。利用它，我们只需要关注业务代码的编写，底层的原理几乎不会涉及。但是，如果我们抛开这些高级框架来开发Web项目，必然会用到Servlet。实际上，使用比较底层的Servlet来开发Web项目也不难。我们只需要定义一个继承HttpServlet的类，并且重写其中的doGet()或doPost()方法，来分别处理get和post请求。具体的代码示例如下所示：</p><pre><code>public class HelloServlet extends HttpServlet {\n  @Override\n  protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n    this.doPost(req, resp);\n  }\n  \n  @Override\n  protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n    resp.getWriter().write(&quot;Hello World.&quot;);\n  }\n}\n</code></pre><p>除此之外，我们还需要在配置文件web.xml中做如下配置。Tomcat、Jetty等Servlet容器在启动的时候，会自动加载这个配置文件中的URL和Servlet之间的映射关系。</p><pre><code>&lt;servlet&gt;\n    &lt;servlet-name&gt;HelloServlet&lt;/servlet-name&gt;\n    &lt;servlet-class&gt;com.xzg.cd.HelloServlet&lt;/servlet-class&gt;\n&lt;/servlet&gt;\n\n&lt;servlet-mapping&gt;\n    &lt;servlet-name&gt;HelloServlet&lt;/servlet-name&gt;\n    &lt;url-pattern&gt;/hello&lt;/url-pattern&gt;\n&lt;/servlet-mapping&gt;\n</code></pre><p>当我们在浏览器中输入网址（比如，<a href=\"http://127.0.0.1:8080/hello\">http://127.0.0.1:8080/hello</a> ）的时候，Servlet容器会接收到相应的请求，并且根据URL和Servlet之间的映射关系，找到相应的Servlet（HelloServlet），然后执行它的service()方法。service()方法定义在父类HttpServlet中，它会调用doGet()或doPost()方法，然后输出数据（“Hello world”）到网页。</p><p>我们现在来看，HttpServlet的service()函数长什么样子。</p><pre><code>public void service(ServletRequest req, ServletResponse res)\n    throws ServletException, IOException\n{\n    HttpServletRequest  request;\n    HttpServletResponse response;\n    if (!(req instanceof HttpServletRequest &amp;&amp;\n            res instanceof HttpServletResponse)) {\n        throw new ServletException(&quot;non-HTTP request or response&quot;);\n    }\n    request = (HttpServletRequest) req;\n    response = (HttpServletResponse) res;\n    service(request, response);\n}\n\nprotected void service(HttpServletRequest req, HttpServletResponse resp)\n    throws ServletException, IOException\n{\n    String method = req.getMethod();\n    if (method.equals(METHOD_GET)) {\n        long lastModified = getLastModified(req);\n        if (lastModified == -1) {\n            // servlet doesn't support if-modified-since, no reason\n            // to go through further expensive logic\n            doGet(req, resp);\n        } else {\n            long ifModifiedSince = req.getDateHeader(HEADER_IFMODSINCE);\n            if (ifModifiedSince &lt; lastModified) {\n                // If the servlet mod time is later, call doGet()\n                // Round down to the nearest second for a proper compare\n                // A ifModifiedSince of -1 will always be less\n                maybeSetLastModified(resp, lastModified);\n                doGet(req, resp);\n            } else {\n                resp.setStatus(HttpServletResponse.SC_NOT_MODIFIED);\n            }\n        }\n    } else if (method.equals(METHOD_HEAD)) {\n        long lastModified = getLastModified(req);\n        maybeSetLastModified(resp, lastModified);\n        doHead(req, resp);\n    } else if (method.equals(METHOD_POST)) {\n        doPost(req, resp);\n    } else if (method.equals(METHOD_PUT)) {\n        doPut(req, resp);\n    } else if (method.equals(METHOD_DELETE)) {\n        doDelete(req, resp);\n    } else if (method.equals(METHOD_OPTIONS)) {\n        doOptions(req,resp);\n    } else if (method.equals(METHOD_TRACE)) {\n        doTrace(req,resp);\n    } else {\n        String errMsg = lStrings.getString(&quot;http.method_not_implemented&quot;);\n        Object[] errArgs = new Object[1];\n        errArgs[0] = method;\n        errMsg = MessageFormat.format(errMsg, errArgs);\n        resp.sendError(HttpServletResponse.SC_NOT_IMPLEMENTED, errMsg);\n    }\n}\n</code></pre><p>从上面的代码中我们可以看出，HttpServlet的service()方法就是一个模板方法，它实现了整个HTTP请求的执行流程，doGet()、doPost()是模板中可以由子类来定制的部分。实际上，这就相当于Servlet框架提供了一个扩展点（doGet()、doPost()方法），让框架用户在不用修改Servlet框架源码的情况下，将业务代码通过扩展点镶嵌到框架中执行。</p><h3>2.JUnit TestCase</h3><p>跟Java Servlet类似，JUnit框架也通过模板模式提供了一些功能扩展点（setUp()、tearDown()等），让框架用户可以在这些扩展点上扩展功能。</p><p>在使用JUnit测试框架来编写单元测试的时候，我们编写的测试类都要继承框架提供的TestCase类。在TestCase类中，runBare()函数是模板方法，它定义了执行测试用例的整体流程：先执行setUp()做些准备工作，然后执行runTest()运行真正的测试代码，最后执行tearDown()做扫尾工作。</p><p>TestCase类的具体代码如下所示。尽管setUp()、tearDown()并不是抽象函数，还提供了默认的实现，不强制子类去重新实现，但\b这部分也是可以在子类中定制的，所以也符合模板模式的定义。</p><pre><code>public abstract class TestCase extends Assert implements Test {\n  public void runBare() throws Throwable {\n    Throwable exception = null;\n    setUp();\n    try {\n      runTest();\n    } catch (Throwable running) {\n      exception = running;\n    } finally {\n      try {\n        tearDown();\n      } catch (Throwable tearingDown) {\n        if (exception == null) exception = tearingDown;\n      }\n    }\n    if (exception != null) throw exception;\n  }\n  \n  /**\n  * Sets up the fixture, for example, open a network connection.\n  * This method is called before a test is executed.\n  */\n  protected void setUp() throws Exception {\n  }\n\n  /**\n  * Tears down the fixture, for example, close a network connection.\n  * This method is called after a test is executed.\n  */\n  protected void tearDown() throws Exception {\n  }\n}\n</code></pre><h2>重点回顾</h2><p>好了，今天的内容到此就讲完了。我们一块来总结回顾一下，你需要重点掌握的内容。</p><p>模板方法模式在一个方法中定义一个算法骨架，并将某些步骤推迟到子类中实现。模板方法模式可以让子类在不改变算法整体结构的情况下，重新定义算法中的某些步骤。这里的“算法”，我们可以理解为广义上的“业务逻辑”，并不特指数据结构和算法中的“算法”。这里的算法骨架就是“模板”，包含算法骨架的方法就是“模板方法”，这也是模板方法模式名字的由来。</p><p>在模板模式经典的实现中，模板方法定义为final，可以避免被子类重写。需要子类重写的方法定义为abstract，可以强迫子类去实现。不过，在实际项目开发中，模板模式的实现比较灵活，以上两点都不是必须的。</p><p>模板模式有两大作用：复用和扩展。其中，复用指的是，所有的子类可以复用父类中提供的模板方法的代码。扩展指的是，框架通过模板模式提供功能扩展点，让框架用户可以在不修改框架源码的情况下，基于扩展点定制化框架的功能。</p><h2>课堂讨论</h2><p>假设一个框架中的某个类暴露了两个模板方法，并且定义了一堆供模板方法调用的抽象方法，代码示例如下所示。在项目开发中，即便我们只用到这个类的其中一个模板方法，我们还是要在子类中把所有的抽象方法都实现一遍，这相当于无效劳动，有没有其他方式来解决这个问题呢？</p><pre><code>public abstract class AbstractClass {\n  public final void templateMethod1() {\n    //...\n    method1();\n    //...\n    method2();\n    //...\n  }\n  \n  public final void templateMethod2() {\n    //...\n    method3();\n    //...\n    method4();\n    //...\n  }\n  \n  protected abstract void method1();\n  protected abstract void method2();\n  protected abstract void method3();\n  protected abstract void method4();\n}\n</code></pre><p>欢迎留言和我分享你的想法。如果有收获，也欢迎你把这篇文章分享给你的朋友。</p>",
                "article_title": "58 | 模板模式（上）：剖析模板模式在JDK、Servlet、JUnit等中的应用"
            },
            {
                "title": "59 | 模板模式（下）：模板模式与Callback回调函数有何区别和联系？",
                "herf": "https://time.geekbang.org/column/article/212802",
                "id": "212802",
                "content": "<p>上一节课中，我们学习了模板模式的原理、实现和应用。它常用在框架开发中，通过提供功能扩展点，让框架用户在不修改框架源码的情况下，基于扩展点定制化框架的功能。除此之外，模板模式还可以起到代码复用的作用。</p><p>复用和扩展是模板模式的两大作用，实际上，还有另外一个技术概念，也能起到跟模板模式相同的作用，那就是<strong>回调</strong>（Callback）。今天我们今天就来看一下，回调的原理、实现和应用，以及它跟模板模式的区别和联系。</p><p>话不多说，让我们正式开始今天的学习吧！</p><h2>回调的原理解析</h2><p>相对于普通的函数调用来说，回调是一种双向调用关系。A类事先注册某个函数F到B类，A类在调用B类的P函数的时候，B类反过来调用A类注册给它的F函数。这里的F函数就是“回调函数”。A调用B，B反过来又调用A，这种调用机制就叫作“回调”。</p><p>A类如何将回调函数传递给B类呢？不同的编程语言，有不同的实现方法。C语言可以使用函数指针，Java则需要使用包裹了回调函数的类对象，我们简称为回调对象。这里我用Java语言举例说明一下。代码如下所示：</p><pre><code>public interface ICallback {\n  void methodToCallback();\n}\n\npublic class BClass {\n  public void process(ICallback callback) {\n    //...\n    callback.methodToCallback();\n    //...\n  }\n}\n\npublic class AClass {\n  public static void main(String[] args) {\n    BClass b = new BClass();\n    b.process(new ICallback() { //回调对象\n      @Override\n      public void methodToCallback() {\n        System.out.println(&quot;Call back me.&quot;);\n      }\n    });\n  }\n}\n</code></pre><p>上面就是Java语言中回调的典型代码实现。从代码实现中，我们可以看出，回调跟模板模式一样，也具有复用和扩展的功能。除了回调函数之外，BClass类的process()函数中的逻辑都可以复用。如果ICallback、BClass类是框架代码，AClass是使用框架的客户端代码，我们可以通过ICallback定制process()函数，也就是说，框架因此具有了扩展的能力。</p><!-- [[[read_end]]] --><p>实际上，回调不仅可以应用在代码设计上，在更高层次的架构设计上也比较常用。比如，通过三方支付系统来实现支付功能，用户在发起支付请求之后，一般不会一直阻塞到支付结果返回，而是注册回调接口（类似回调函数，一般是一个回调用的URL）给三方支付系统，等三方支付系统执行完成之后，将结果通过回调接口返回给用户。</p><p>回调可以分为同步回调和异步回调（或者延迟回调）。同步回调指在函数返回之前执行回调函数；异步回调指的是在函数返回之后执行回调函数。上面的代码实际上是同步回调的实现方式，在process()函数返回之前，执行完回调函数methodToCallback()。而上面支付的例子是异步回调的实现方式，发起支付之后不需要等待回调接口被调用就直接返回。从应用场景上来看，同步回调看起来更像模板模式，异步回调看起来更像观察者模式。</p><h2>应用举例一：JdbcTemplate</h2><p>Spring提供了很多Template类，比如，JdbcTemplate、RedisTemplate、RestTemplate。尽管都叫作xxxTemplate，但它们并非基于模板模式来实现的，而是基于回调来实现的，确切地说应该是同步回调。而同步回调从应用场景上很像模板模式，所以，在命名上，这些类使用Template（模板）这个单词作为后缀。</p><p>这些Template类的设计思路都很相近，所以，我们只拿其中的JdbcTemplate来举例分析一下。对于其他Template类，你可以阅读源码自行分析。</p><p>在前面的章节中，我们也多次提到，Java提供了JDBC类库来封装不同类型的数据库操作。不过，直接使用JDBC来编写操作数据库的代码，还是有点复杂的。比如，下面这段是使用JDBC来查询用户信息的代码。</p><pre><code>public class JdbcDemo {\n  public User queryUser(long id) {\n    Connection conn = null;\n    Statement stmt = null;\n    try {\n      //1.加载驱动\n      Class.forName(&quot;com.mysql.jdbc.Driver&quot;);\n      conn = DriverManager.getConnection(&quot;jdbc:mysql://localhost:3306/demo&quot;, &quot;xzg&quot;, &quot;xzg&quot;);\n\n      //2.创建statement类对象，用来执行SQL语句\n      stmt = conn.createStatement();\n\n      //3.ResultSet类，用来存放获取的结果集\n      String sql = &quot;select * from user where id=&quot; + id;\n      ResultSet resultSet = stmt.executeQuery(sql);\n\n      String eid = null, ename = null, price = null;\n\n      while (resultSet.next()) {\n        User user = new User();\n        user.setId(resultSet.getLong(&quot;id&quot;));\n        user.setName(resultSet.getString(&quot;name&quot;));\n        user.setTelephone(resultSet.getString(&quot;telephone&quot;));\n        return user;\n      }\n    } catch (ClassNotFoundException e) {\n      // TODO: log...\n    } catch (SQLException e) {\n      // TODO: log...\n    } finally {\n      if (conn != null)\n        try {\n          conn.close();\n        } catch (SQLException e) {\n          // TODO: log...\n        }\n      if (stmt != null)\n        try {\n          stmt.close();\n        } catch (SQLException e) {\n          // TODO: log...\n        }\n    }\n    return null;\n  }\n\n}\n</code></pre><p>queryUser()函数包含很多流程性质的代码，跟业务无关，比如，加载驱动、创建数据库连接、创建statement、关闭连接、关闭statement、处理异常。针对不同的SQL执行请求，这些流程性质的代码是相同的、可以复用的，我们不需要每次都重新敲一遍。</p><p>针对这个问题，Spring提供了JdbcTemplate，对JDBC进一步封装，来简化数据库编程。使用JdbcTemplate查询用户信息，我们只需要编写跟这个业务有关的代码，其中包括，查询用户的SQL语句、查询结果与User对象之间的映射关系。其他流程性质的代码都封装在了JdbcTemplate类中，不需要我们每次都重新编写。我用JdbcTemplate重写了上面的例子，代码简单了很多，如下所示：</p><pre><code>public class JdbcTemplateDemo {\n  private JdbcTemplate jdbcTemplate;\n\n  public User queryUser(long id) {\n    String sql = &quot;select * from user where id=&quot;+id;\n    return jdbcTemplate.query(sql, new UserRowMapper()).get(0);\n  }\n\n  class UserRowMapper implements RowMapper&lt;User&gt; {\n    public User mapRow(ResultSet rs, int rowNum) throws SQLException {\n      User user = new User();\n      user.setId(rs.getLong(&quot;id&quot;));\n      user.setName(rs.getString(&quot;name&quot;));\n      user.setTelephone(rs.getString(&quot;telephone&quot;));\n      return user;\n    }\n  }\n}\n</code></pre><p>那JdbcTemplate底层具体是如何实现的呢？我们来看一下它的源码。因为JdbcTemplate代码比较多，我只摘抄了部分相关代码，贴到了下面。其中，JdbcTemplate通过回调的机制，将不变的执行流程抽离出来，放到模板方法execute()中，将可变的部分设计成回调StatementCallback，由用户来定制。query()函数是对execute()函数的二次封装，让接口用起来更加方便。</p><pre><code>@Override\npublic &lt;T&gt; List&lt;T&gt; query(String sql, RowMapper&lt;T&gt; rowMapper) throws DataAccessException {\n return query(sql, new RowMapperResultSetExtractor&lt;T&gt;(rowMapper));\n}\n\n@Override\npublic &lt;T&gt; T query(final String sql, final ResultSetExtractor&lt;T&gt; rse) throws DataAccessException {\n Assert.notNull(sql, &quot;SQL must not be null&quot;);\n Assert.notNull(rse, &quot;ResultSetExtractor must not be null&quot;);\n if (logger.isDebugEnabled()) {\n  logger.debug(&quot;Executing SQL query [&quot; + sql + &quot;]&quot;);\n }\n\n class QueryStatementCallback implements StatementCallback&lt;T&gt;, SqlProvider {\n  @Override\n  public T doInStatement(Statement stmt) throws SQLException {\n   ResultSet rs = null;\n   try {\n    rs = stmt.executeQuery(sql);\n    ResultSet rsToUse = rs;\n    if (nativeJdbcExtractor != null) {\n     rsToUse = nativeJdbcExtractor.getNativeResultSet(rs);\n    }\n    return rse.extractData(rsToUse);\n   }\n   finally {\n    JdbcUtils.closeResultSet(rs);\n   }\n  }\n  @Override\n  public String getSql() {\n   return sql;\n  }\n }\n\n return execute(new QueryStatementCallback());\n}\n\n@Override\npublic &lt;T&gt; T execute(StatementCallback&lt;T&gt; action) throws DataAccessException {\n Assert.notNull(action, &quot;Callback object must not be null&quot;);\n\n Connection con = DataSourceUtils.getConnection(getDataSource());\n Statement stmt = null;\n try {\n  Connection conToUse = con;\n  if (this.nativeJdbcExtractor != null &amp;&amp;\n    this.nativeJdbcExtractor.isNativeConnectionNecessaryForNativeStatements()) {\n   conToUse = this.nativeJdbcExtractor.getNativeConnection(con);\n  }\n  stmt = conToUse.createStatement();\n  applyStatementSettings(stmt);\n  Statement stmtToUse = stmt;\n  if (this.nativeJdbcExtractor != null) {\n   stmtToUse = this.nativeJdbcExtractor.getNativeStatement(stmt);\n  }\n  T result = action.doInStatement(stmtToUse);\n  handleWarnings(stmt);\n  return result;\n }\n catch (SQLException ex) {\n  // Release Connection early, to avoid potential connection pool deadlock\n  // in the case when the exception translator hasn't been initialized yet.\n  JdbcUtils.closeStatement(stmt);\n  stmt = null;\n  DataSourceUtils.releaseConnection(con, getDataSource());\n  con = null;\n  throw getExceptionTranslator().translate(&quot;StatementCallback&quot;, getSql(action), ex);\n }\n finally {\n  JdbcUtils.closeStatement(stmt);\n  DataSourceUtils.releaseConnection(con, getDataSource());\n }\n}\n</code></pre><h2>应用举例二：setClickListener(）</h2><p>在客户端开发中，我们经常给控件注册事件监听器，比如下面这段代码，就是在Android应用开发中，给Button控件的点击事件注册监听器。</p><pre><code>Button button = (Button)findViewById(R.id.button);\nbutton.setOnClickListener(new OnClickListener() {\n  @Override\n  public void onClick(View v) {\n    System.out.println(&quot;I am clicked.&quot;);\n  }\n});\n</code></pre><p>从代码结构上来看，事件监听器很像回调，即传递一个包含回调函数（onClick()）的对象给另一个函数。从应用场景上来看，它又很像观察者模式，即事先注册观察者（OnClickListener），当用户点击按钮的时候，发送点击事件给观察者，并且执行相应的onClick()函数。</p><p>我们前面讲到，回调分为同步回调和异步回调。这里的回调算是异步回调，我们往setOnClickListener()函数中注册好回调函数之后，并不需要等待回调函数执行。这也印证了我们前面讲的，异步回调比较像观察者模式。</p><h2>应用举例三：addShutdownHook()</h2><p>Hook可以翻译成“钩子”，那它跟Callback有什么区别呢？</p><p>网上有人认为Hook就是Callback，两者说的是一回事儿，只是表达不同而已。而有人觉得Hook是Callback的一种应用。Callback更侧重语法机制的描述，Hook更加侧重应用场景的描述。我个人比较认可后面一种说法。不过，这个也不重要，我们只需要见了代码能认识，遇到场景会用就可以了。</p><p>Hook比较经典的应用场景是Tomcat和JVM的shutdown hook。接下来，我们拿JVM来举例说明一下。JVM提供了Runtime.addShutdownHook(Thread hook)方法，可以注册一个JVM关闭的Hook。当应用程序关闭的时候，JVM会自动调用Hook代码。代码示例如下所示：</p><pre><code>public class ShutdownHookDemo {\n\n  private static class ShutdownHook extends Thread {\n    public void run() {\n      System.out.println(&quot;I am called during shutting down.&quot;);\n    }\n  }\n\n  public static void main(String[] args) {\n    Runtime.getRuntime().addShutdownHook(new ShutdownHook());\n  }\n\n}\n</code></pre><p>我们再来看addShutdownHook()的代码实现，如下所示。这里我只给出了部分相关代码。</p><pre><code>public class Runtime {\n  public void addShutdownHook(Thread hook) {\n    SecurityManager sm = System.getSecurityManager();\n    if (sm != null) {\n      sm.checkPermission(new RuntimePermission(&quot;shutdownHooks&quot;));\n    }\n    ApplicationShutdownHooks.add(hook);\n  }\n}\n\nclass ApplicationShutdownHooks {\n    /* The set of registered hooks */\n    private static IdentityHashMap&lt;Thread, Thread&gt; hooks;\n    static {\n            hooks = new IdentityHashMap&lt;&gt;();\n        } catch (IllegalStateException e) {\n            hooks = null;\n        }\n    }\n\n    static synchronized void add(Thread hook) {\n        if(hooks == null)\n            throw new IllegalStateException(&quot;Shutdown in progress&quot;);\n\n        if (hook.isAlive())\n            throw new IllegalArgumentException(&quot;Hook already running&quot;);\n\n        if (hooks.containsKey(hook))\n            throw new IllegalArgumentException(&quot;Hook previously registered&quot;);\n\n        hooks.put(hook, hook);\n    }\n\n    static void runHooks() {\n        Collection&lt;Thread&gt; threads;\n        synchronized(ApplicationShutdownHooks.class) {\n            threads = hooks.keySet();\n            hooks = null;\n        }\n\n        for (Thread hook : threads) {\n            hook.start();\n        }\n        for (Thread hook : threads) {\n            while (true) {\n                try {\n                    hook.join();\n                    break;\n                } catch (InterruptedException ignored) {\n                }\n            }\n        }\n    }\n}\n</code></pre><p>从代码中我们可以发现，有关Hook的逻辑都被封装到ApplicationShutdownHooks类中了。当应用程序关闭的时候，JVM会调用这个类的runHooks()方法，创建多个线程，并发地执行多个Hook。我们在注册完Hook之后，并不需要等待Hook执行完成，所以，这也算是一种异步回调。</p><h2>模板模式 VS 回调</h2><p>回调的原理、实现和应用到此就都讲完了。接下来，我们从应用场景和代码实现两个角度，来对比一下模板模式和回调。</p><p>从应用场景上来看\b，同步回调跟模板模式几乎一致。它们都是在一个大的算法骨架中，自由替换其中的某个步骤，起到代码复用和扩展的目的。而异步回调跟模板模式有较大差别，更像是观察者模式。</p><p>从代码实现上来看，回调和模板模式完全不同。回调基于组合关系来实现，把一个对象传递给另一个对象，是一种对象之间的关系；模板模式基于继承关系来实现，子类重写父类的抽象方法，是一种类之间的关系。</p><p>前面我们也讲到，组合优于继承。实际上，这里也不例外。在代码实现上，回调相对于模板模式会更加灵活，主要体现在下面几点。</p><ul>\n<li>像Java这种只支持单继承的语言，基于模板模式编写的子类，已经继承了一个父类，不再具有继承的能力。</li>\n<li>回调可以使用匿名类来创建回调对象，可以不用事先定义类；而模板模式针对不同的实现都要定义不同的子类。</li>\n<li>如果某个类中定义了多个模板方法，每个方法都有对应的抽象方法，那即便我们只用到其中的一个模板方法，子类也必须实现所有的抽象方法。而回调就更加灵活，我们只需要往用到的模板方法中注入回调对象即可。</li>\n</ul><p>还记得上一节课的课堂讨论题目吗？看到这里，相信你应该有了答案了吧？</p><h2>重点回顾</h2><p>好了，今天的内容到此就讲完了。我们一块来总结回顾一下，你需要重点掌握的内容。</p><p>今天，我们重点介绍了回调。它跟模板模式具有相同的作用：代码复用和扩展。在一些框架、类库、组件等的设计中经常会用到。</p><p>相对于普通的函数调用，回调是一种双向调用关系。A类事先注册某个函数F到B类，A类在调用B类的P函数的时候，B类反过来调用A类注册给它的F函数。这里的F函数就是“回调函数”。A调用B，B反过来又调用A，这种调用机制就叫作“回调”。</p><p>回调可以细分为同步回调和异步回调。从应用场景上来看，同步回调看起来更像模板模式，异步回调看起来更像观察者模式。回调跟模板模式的区别，更多的是在代码实现上，而非应用场景上。回调基于组合关系来实现，模板模式基于继承关系来实现，回调比模板模式更加灵活。</p><h2>课堂讨论</h2><p>对于Callback和Hook的区别，你有什么不同的理解吗？在你熟悉的编程语言中，有没有提供相应的语法概念？是叫Callback，还是Hook呢？</p><p>欢迎留言和我分享你的想法。如果有收获，欢迎你把这篇文章分享给你的朋友。</p>",
                "article_title": "59 | 模板模式（下）：模板模式与Callback回调函数有何区别和联系？"
            },
            {
                "title": "60 | 策略模式（上）：如何避免冗长的if-else/switch分支判断代码？",
                "herf": "https://time.geekbang.org/column/article/214014",
                "id": "214014",
                "content": "<p>上两节课中，我们学习了模板模式。模板模式主要起到代码复用和扩展的作用。除此之外，我们还讲到了回调，它跟模板模式的作用类似，但使用起来更加灵活。它们之间的主要区别在于代码实现，模板模式基于继承来实现，回调基于组合来实现。</p><p>今天，我们开始学习另外一种行为型模式，策略模式。在实际的项目开发中，这个模式也比较常用。最常见的应用场景是，利用它来避免冗长的if-else或switch分支判断。不过，它的作用还不止如此。它也可以像模板模式那样，提供框架的扩展点等等。</p><p>对于策略模式，我们分两节课来讲解。今天，我们讲解策略模式的原理和实现，以及如何用它来避免分支判断逻辑。下一节课，我会通过一个具体的例子，来详细讲解策略模式的应用场景以及真正的设计意图。</p><p>话不多说，让我们正式开始今天的学习吧！</p><h2>策略模式的原理与实现</h2><p>策略模式，英文全称是Strategy Design Pattern。在GoF的《设计模式》一书中，它是这样定义的：</p><blockquote>\n<p>Define a family of algorithms, encapsulate each one, and make them interchangeable. Strategy lets the algorithm vary independently from clients that use it.</p>\n</blockquote><!-- [[[read_end]]] --><p>翻译成中文就是：定义一族算法类，将每个算法分别封装起来，让它们可以互相替换。策略模式可以使算法的变化独立于使用它们的客户端（这里的客户端代指使用算法的代码）。</p><p>我们知道，工厂模式是解耦对象的创建和使用，观察者模式是解耦观察者和被观察者。策略模式跟两者类似，也能起到解耦的作用，不过，它解耦的是策略的定义、创建、使用这三部分。接下来，我就详细讲讲一个完整的策略模式应该包含的这三个部分。</p><h3>1.策略的定义</h3><p>策略类的定义比较简单，包含一个策略接口和一组实现这个接口的策略类。因为所有的策略类都实现相同的接口，所以，客户端代码基于接口而非实现编程，可以灵活地替换不同的策略。示例代码如下所示：</p><pre><code>public interface Strategy {\n  void algorithmInterface();\n}\n\npublic class ConcreteStrategyA implements Strategy {\n  @Override\n  public void  algorithmInterface() {\n    //具体的算法...\n  }\n}\n\npublic class ConcreteStrategyB implements Strategy {\n  @Override\n  public void  algorithmInterface() {\n    //具体的算法...\n  }\n}\n</code></pre><h3>2.策略的创建</h3><p>因为策略模式会包含一组策略，在使用它们的时候，一般会通过类型（type）来判断创建哪个策略来使用。为了封装创建逻辑，我们需要对客户端代码屏蔽创建细节。我们可以把根据type创建策略的逻辑抽离出来，放到工厂类中。示例代码如下所示：</p><pre><code>public class StrategyFactory {\n  private static final Map&lt;String, Strategy&gt; strategies = new HashMap&lt;&gt;();\n\n  static {\n    strategies.put(&quot;A&quot;, new ConcreteStrategyA());\n    strategies.put(&quot;B&quot;, new ConcreteStrategyB());\n  }\n\n  public static Strategy getStrategy(String type) {\n    if (type == null || type.isEmpty()) {\n      throw new IllegalArgumentException(&quot;type should not be empty.&quot;);\n    }\n    return strategies.get(type);\n  }\n}\n</code></pre><p>一般来讲，如果策略类是无状态的，不包含成员变量，只是纯粹的算法实现，这样的策略对象是可以被共享使用的，不需要在每次调用getStrategy()的时候，都创建一个新的策略对象。针对这种情况，我们可以使用上面这种工厂类的实现方式，事先创建好每个策略对象，缓存到工厂类中，用的时候直接返回。</p><p>相反，如果策略类是有状态的，根据业务场景的需要，我们希望每次从工厂方法中，获得的都是新创建的策略对象，而不是缓存好可共享的策略对象，那我们就需要按照如下方式来实现策略工厂类。</p><pre><code>public class StrategyFactory {\n  public static Strategy getStrategy(String type) {\n    if (type == null || type.isEmpty()) {\n      throw new IllegalArgumentException(&quot;type should not be empty.&quot;);\n    }\n\n    if (type.equals(&quot;A&quot;)) {\n      return new ConcreteStrategyA();\n    } else if (type.equals(&quot;B&quot;)) {\n      return new ConcreteStrategyB();\n    }\n\n    return null;\n  }\n}\n</code></pre><h3>3.策略的使用</h3><p>刚刚讲了策略的定义和创建，现在，我们再来看一下，策略的使用。</p><p>我们知道，策略模式包含一组可选策略，客户端代码一般如何确定使用哪个策略呢？最常见的是运行时动态确定使用哪种策略，这也是策略模式最典型的应用场景。</p><p>这里的“运行时动态”指的是，我们事先并不知道会使用哪个策略，而是在程序运行期间，根据配置、用户输入、计算结果等这些不确定因素，动态决定使用哪种策略。接下来，我们通过一个例子来解释一下。</p><pre><code>// 策略接口：EvictionStrategy\n// 策略类：LruEvictionStrategy、FifoEvictionStrategy、LfuEvictionStrategy...\n// 策略工厂：EvictionStrategyFactory\n\npublic class UserCache {\n  private Map&lt;String, User&gt; cacheData = new HashMap&lt;&gt;();\n  private EvictionStrategy eviction;\n\n  public UserCache(EvictionStrategy eviction) {\n    this.eviction = eviction;\n  }\n\n  //...\n}\n\n// 运行时动态确定，根据配置文件的配置决定使用哪种策略\npublic class Application {\n  public static void main(String[] args) throws Exception {\n    EvictionStrategy evictionStrategy = null;\n    Properties props = new Properties();\n    props.load(new FileInputStream(&quot;./config.properties&quot;));\n    String type = props.getProperty(&quot;eviction_type&quot;);\n    evictionStrategy = EvictionStrategyFactory.getEvictionStrategy(type);\n    UserCache userCache = new UserCache(evictionStrategy);\n    //...\n  }\n}\n\n// 非运行时动态确定，在代码中指定使用哪种策略\npublic class Application {\n  public static void main(String[] args) {\n    //...\n    EvictionStrategy evictionStrategy = new LruEvictionStrategy();\n    UserCache userCache = new UserCache(evictionStrategy);\n    //...\n  }\n}\n</code></pre><p>从上面的代码中，我们也可以看出，“非运行时动态确定”，也就是第二个Application中的使用方式，并不能发挥策略模式的优势。在这种应用场景下，策略模式实际上退化成了“面向对象的多态特性”或“基于接口而非实现编程原则”。</p><h2>如何利用策略模式避免分支判断？</h2><p>实际上，能够移除分支判断逻辑的模式不仅仅有策略模式，后面我们要讲的状态模式也可以。对于使用哪种模式，具体还要看应用场景来定。 策略模式适用于根据不同类型的动态，决定使用哪种策略这样一种应用场景。</p><p>我们先通过一个例子来看下，if-else或switch-case分支判断逻辑是如何产生的。具体的代码如下所示。在这个例子中，我们没有使用策略模式，而是将策略的定义、创建、使用直接耦合在一起。</p><pre><code>public class OrderService {\n  public double discount(Order order) {\n    double discount = 0.0;\n    OrderType type = order.getType();\n    if (type.equals(OrderType.NORMAL)) { // 普通订单\n      //...省略折扣计算算法代码\n    } else if (type.equals(OrderType.GROUPON)) { // 团购订单\n      //...省略折扣计算算法代码\n    } else if (type.equals(OrderType.PROMOTION)) { // 促销订单\n      //...省略折扣计算算法代码\n    }\n    return discount;\n  }\n}\n</code></pre><p>如何来移除掉分支判断逻辑呢？那策略模式就派上用场了。我们使用策略模式对上面的代码重构，将不同类型订单的打折策略设计成策略类，并由工厂类来负责创建策略对象。具体的代码如下所示：</p><pre><code>// 策略的定义\npublic interface DiscountStrategy {\n  double calDiscount(Order order);\n}\n// 省略NormalDiscountStrategy、GrouponDiscountStrategy、PromotionDiscountStrategy类代码...\n\n// 策略的创建\npublic class DiscountStrategyFactory {\n  private static final Map&lt;OrderType, DiscountStrategy&gt; strategies = new HashMap&lt;&gt;();\n\n  static {\n    strategies.put(OrderType.NORMAL, new NormalDiscountStrategy());\n    strategies.put(OrderType.GROUPON, new GrouponDiscountStrategy());\n    strategies.put(OrderType.PROMOTION, new PromotionDiscountStrategy());\n  }\n\n  public static DiscountStrategy getDiscountStrategy(OrderType type) {\n    return strategies.get(type);\n  }\n}\n\n// 策略的使用\npublic class OrderService {\n  public double discount(Order order) {\n    OrderType type = order.getType();\n    DiscountStrategy discountStrategy = DiscountStrategyFactory.getDiscountStrategy(type);\n    return discountStrategy.calDiscount(order);\n  }\n}\n</code></pre><p>重构之后的代码就没有了if-else分支判断语句了。实际上，这得益于策略工厂类。在工厂类中，我们用Map来缓存策略，根据type直接从Map中获取对应的策略，从而避免if-else分支判断逻辑。等后面讲到使用状态模式来避免分支判断逻辑的时候，你会发现，它们使用的是同样的套路。本质上都是借助“查表法”，根据type查表（代码中的strategies就是表）替代根据type分支判断。</p><p>但是，如果业务场景需要每次都创建不同的策略对象，我们就要用另外一种工厂类的实现方式了。具体的代码如下所示：</p><pre><code>public class DiscountStrategyFactory {\n  public static DiscountStrategy getDiscountStrategy(OrderType type) {\n    if (type == null) {\n      throw new IllegalArgumentException(&quot;Type should not be null.&quot;);\n    }\n    if (type.equals(OrderType.NORMAL)) {\n      return new NormalDiscountStrategy();\n    } else if (type.equals(OrderType.GROUPON)) {\n      return new GrouponDiscountStrategy();\n    } else if (type.equals(OrderType.PROMOTION)) {\n      return new PromotionDiscountStrategy();\n    }\n    return null;\n  }\n}\n</code></pre><p>这种实现方式相当于把原来的if-else分支逻辑，从OrderService类中转移到了工厂类中，实际上并没有真正将它移除。关于这个问题如何解决，我今天先暂时卖个关子。你可以在留言区说说你的想法，我在下一节课中再讲解。</p><h2>重点回顾</h2><p>好了，今天的内容到此就讲完了。我们一块来总结回顾一下，你需要重点掌握的内容。</p><p>策略模式定义一族算法类，将每个算法分别封装起来，让它们可以互相替换。策略模式可以使算法的变化独立于使用它们的客户端（这里的客户端代指使用算法的代码）。</p><p>策略模式用来解耦策略的定义、创建、使用。实际上，一个完整的策略模式就是由这三个部分组成的。</p><ul>\n<li>策略类的定义比较简单，包含一个策略接口和一组实现这个接口的策略类。</li>\n<li>策略的创建由工厂类来完成，封装策略创建的细节。</li>\n<li>策略模式包含一组策略可选，客户端代码如何选择使用哪个策略，有两种确定方法：编译时静态确定和运行时动态确定。其中，“运行时动态确定”才是策略模式最典型的应用场景。</li>\n</ul><p>除此之外，我们还可以通过策略模式来移除if-else分支判断。实际上，这得益于策略工厂类，更本质上点讲，是借助“查表法”，根据type查表替代根据type分支判断。</p><h2>课堂讨论</h2><p>今天我们讲到，在策略工厂类中，如果每次都要返回新的策略对象，我们还是需要在工厂类中编写if-else分支判断逻辑，那这个问题该如何解决呢？</p><p>欢迎留言和我分享你的想法。如果有收获，也欢迎你把这篇文章分享给你的朋友。</p>",
                "article_title": "60 | 策略模式（上）：如何避免冗长的if-else/switch分支判断代码？"
            },
            {
                "title": "61 | 策略模式（下）：如何实现一个支持给不同大小文件排序的小程序？",
                "herf": "https://time.geekbang.org/column/article/215132",
                "id": "215132",
                "content": "<p>上一节课，我们主要介绍了策略模式的原理和实现，以及如何利用策略模式来移除if-else或者switch-case分支判断逻辑。今天，我们结合“给文件排序”这样一个具体的例子，来详细讲一讲策略模式的设计意图和应用场景。</p><p>除此之外，在今天的讲解中，我还会通过一步一步地分析、重构，给你展示一个设计模式是如何“创造”出来的。通过今天的学习，你会发现，<strong>设计原则和思想其实比设计模式更加普适和重要，掌握了代码的设计原则和思想，我们甚至可以自己创造出来新的设计模式</strong>。</p><p>话不多说，让我们正式开始今天的学习吧！</p><h2>问题与解决思路</h2><p>假设有这样一个需求，希望写一个小程序，实现对一个文件进行排序的功能。文件中只包含整型数，并且，相邻的数字通过逗号来区隔。如果由你来编写这样一个小程序，你会如何来实现呢？你可以把它当作面试题，先自己思考一下，再来看我下面的讲解。</p><p>你可能会说，这不是很简单嘛，只需要将文件中的内容读取出来，并且通过逗号分割成一个一个的数字，放到内存数组中，然后编写某种排序算法（比如快排），或者直接使用编程语言提供的排序函数，对数组进行排序，最后再将数组中的数据写入文件就可以了。</p><p>但是，如果文件很大呢？比如有10GB大小，因为内存有限（比如只有8GB大小），我们没办法一次性加载文件中的所有数据到内存中，这个时候，我们就要利用外部排序算法（具体怎么做，可以参看我的另一个专栏《数据结构与算法之美》中的“排序”相关章节）了。</p><!-- [[[read_end]]] --><p>如果文件更大，比如有100GB大小，我们为了利用CPU多核的优势，可以在外部排序的基础之上进行优化，加入多线程并发排序的功能，这就有点类似“单机版”的MapReduce。</p><p>如果文件非常大，比如有1TB大小，即便是单机多线程排序，这也算很慢了。这个时候，我们可以使用真正的MapReduce框架，利用多机的处理能力，提高排序的效率。</p><h2>代码实现与分析</h2><p>解决思路讲完了，不难理解。接下来，我们看一下，如何将解决思路翻译成代码实现。</p><p>我先用最简单直接的方式将它实现出来。具体代码我贴在下面了，你可以先看一下。因为我们是在讲设计模式，不是讲算法，所以，在下面的代码实现中，我只给出了跟设计模式相关的骨架代码，并没有给出每种排序算法的具体代码实现。感兴趣的话，你可以自行实现一下。</p><pre><code>public class Sorter {\n  private static final long GB = 1000 * 1000 * 1000;\n\n  public void sortFile(String filePath) {\n    // 省略校验逻辑\n    File file = new File(filePath);\n    long fileSize = file.length();\n    if (fileSize &lt; 6 * GB) { // [0, 6GB)\n      quickSort(filePath);\n    } else if (fileSize &lt; 10 * GB) { // [6GB, 10GB)\n      externalSort(filePath);\n    } else if (fileSize &lt; 100 * GB) { // [10GB, 100GB)\n      concurrentExternalSort(filePath);\n    } else { // [100GB, ~)\n      mapreduceSort(filePath);\n    }\n  }\n\n  private void quickSort(String filePath) {\n    // 快速排序\n  }\n\n  private void externalSort(String filePath) {\n    // 外部排序\n  }\n\n  private void concurrentExternalSort(String filePath) {\n    // 多线程外部排序\n  }\n\n  private void mapreduceSort(String filePath) {\n    // 利用MapReduce多机排序\n  }\n}\n\npublic class SortingTool {\n  public static void main(String[] args) {\n    Sorter sorter = new Sorter();\n    sorter.sortFile(args[0]);\n  }\n}\n</code></pre><p>在“编码规范”那一部分我们讲过，函数的行数不能过多，最好不要超过一屏的大小。所以，为了避免sortFile()函数过长，我们把每种排序算法从sortFile()函数中抽离出来，拆分成4个独立的排序函数。</p><p>如果只是开发一个简单的工具，那上面的代码实现就足够了。毕竟，代码不多，后续修改、扩展的需求也不多，怎么写都不会导致代码不可维护。但是，如果我们是在开发一个大型项目，排序文件只是其中的一个功能模块，那我们就要在代码设计、代码质量上下点儿功夫了。只有每个小的功能模块都写好，整个项目的代码才能不差。</p><p>在刚刚的代码中，我们并没有给出每种排序算法的代码实现。实际上，如果自己实现一下的话，你会发现，每种排序算法的实现逻辑都比较复杂，代码行数都比较多。所有排序算法的代码实现都堆在Sorter一个类中，这就会导致这个类的代码很多。而在“编码规范”那一部分中，我们也讲到，一个类的代码太多也会影响到可读性、可维护性。除此之外，所有的排序算法都设计成Sorter的私有函数，也会影响代码的可复用性。</p><h2>代码优化与重构</h2><p>只要掌握了我们之前讲过的设计原则和思想，针对上面的问题，即便我们想不到该用什么设计模式来重构，也应该能知道该如何解决，那就是将Sorter类中的某些代码拆分出来，独立成职责更加单一的小类。实际上，拆分是应对类或者函数代码过多、应对代码复杂性的一个常用手段。按照这个解决思路，我们对代码进行重构。重构之后的代码如下所示：</p><pre><code>public interface ISortAlg {\n  void sort(String filePath);\n}\n\npublic class QuickSort implements ISortAlg {\n  @Override\n  public void sort(String filePath) {\n    //...\n  }\n}\n\npublic class ExternalSort implements ISortAlg {\n  @Override\n  public void sort(String filePath) {\n    //...\n  }\n}\n\npublic class ConcurrentExternalSort implements ISortAlg {\n  @Override\n  public void sort(String filePath) {\n    //...\n  }\n}\n\npublic class MapReduceSort implements ISortAlg {\n  @Override\n  public void sort(String filePath) {\n    //...\n  }\n}\n\npublic class Sorter {\n  private static final long GB = 1000 * 1000 * 1000;\n\n  public void sortFile(String filePath) {\n    // 省略校验逻辑\n    File file = new File(filePath);\n    long fileSize = file.length();\n    ISortAlg sortAlg;\n    if (fileSize &lt; 6 * GB) { // [0, 6GB)\n      sortAlg = new QuickSort();\n    } else if (fileSize &lt; 10 * GB) { // [6GB, 10GB)\n      sortAlg = new ExternalSort();\n    } else if (fileSize &lt; 100 * GB) { // [10GB, 100GB)\n      sortAlg = new ConcurrentExternalSort();\n    } else { // [100GB, ~)\n      sortAlg = new MapReduceSort();\n    }\n    sortAlg.sort(filePath);\n  }\n}\n</code></pre><p>经过拆分之后，每个类的代码都不会太多，每个类的逻辑都不会太复杂，代码的可读性、可维护性提高了。除此之外，我们将排序算法设计成独立的类，跟具体的业务逻辑（代码中的if-else那部分逻辑）解耦，也让排序算法能够复用。这一步实际上就是策略模式的第一步，也就是将策略的定义分离出来。</p><p>实际上，上面的代码还可以继续优化。每种排序类都是无状态的，我们没必要在每次使用的时候，都重新创建一个新的对象。所以，我们可以使用工厂模式对对象的创建进行封装。按照这个思路，我们对代码进行重构。重构之后的代码如下所示：</p><pre><code>public class SortAlgFactory {\n  private static final Map&lt;String, ISortAlg&gt; algs = new HashMap&lt;&gt;();\n\n  static {\n    algs.put(&quot;QuickSort&quot;, new QuickSort());\n    algs.put(&quot;ExternalSort&quot;, new ExternalSort());\n    algs.put(&quot;ConcurrentExternalSort&quot;, new ConcurrentExternalSort());\n    algs.put(&quot;MapReduceSort&quot;, new MapReduceSort());\n  }\n\n  public static ISortAlg getSortAlg(String type) {\n    if (type == null || type.isEmpty()) {\n      throw new IllegalArgumentException(&quot;type should not be empty.&quot;);\n    }\n    return algs.get(type);\n  }\n}\n\npublic class Sorter {\n  private static final long GB = 1000 * 1000 * 1000;\n\n  public void sortFile(String filePath) {\n    // 省略校验逻辑\n    File file = new File(filePath);\n    long fileSize = file.length();\n    ISortAlg sortAlg;\n    if (fileSize &lt; 6 * GB) { // [0, 6GB)\n      sortAlg = SortAlgFactory.getSortAlg(&quot;QuickSort&quot;);\n    } else if (fileSize &lt; 10 * GB) { // [6GB, 10GB)\n      sortAlg = SortAlgFactory.getSortAlg(&quot;ExternalSort&quot;);\n    } else if (fileSize &lt; 100 * GB) { // [10GB, 100GB)\n      sortAlg = SortAlgFactory.getSortAlg(&quot;ConcurrentExternalSort&quot;);\n    } else { // [100GB, ~)\n      sortAlg = SortAlgFactory.getSortAlg(&quot;MapReduceSort&quot;);\n    }\n    sortAlg.sort(filePath);\n  }\n}\n</code></pre><p>经过上面两次重构之后，现在的代码实际上已经符合策略模式的代码结构了。我们通过策略模式将策略的定义、创建、使用解耦，让每一部分都不至于太复杂。不过，Sorter类中的sortFile()函数还是有一堆if-else逻辑。这里的if-else逻辑分支不多、也不复杂，这样写完全没问题。但如果你特别想将if-else分支判断移除掉，那也是有办法的。我直接给出代码，你一看就能明白。实际上，这也是基于查表法来解决的，其中的“algs”就是“表”。</p><pre><code>public class Sorter {\n  private static final long GB = 1000 * 1000 * 1000;\n  private static final List&lt;AlgRange&gt; algs = new ArrayList&lt;&gt;();\n  static {\n    algs.add(new AlgRange(0, 6*GB, SortAlgFactory.getSortAlg(&quot;QuickSort&quot;)));\n    algs.add(new AlgRange(6*GB, 10*GB, SortAlgFactory.getSortAlg(&quot;ExternalSort&quot;)));\n    algs.add(new AlgRange(10*GB, 100*GB, SortAlgFactory.getSortAlg(&quot;ConcurrentExternalSort&quot;)));\n    algs.add(new AlgRange(100*GB, Long.MAX_VALUE, SortAlgFactory.getSortAlg(&quot;MapReduceSort&quot;)));\n  }\n\n  public void sortFile(String filePath) {\n    // 省略校验逻辑\n    File file = new File(filePath);\n    long fileSize = file.length();\n    ISortAlg sortAlg = null;\n    for (AlgRange algRange : algs) {\n      if (algRange.inRange(fileSize)) {\n        sortAlg = algRange.getAlg();\n        break;\n      }\n    }\n    sortAlg.sort(filePath);\n  }\n\n  private static class AlgRange {\n    private long start;\n    private long end;\n    private ISortAlg alg;\n\n    public AlgRange(long start, long end, ISortAlg alg) {\n      this.start = start;\n      this.end = end;\n      this.alg = alg;\n    }\n\n    public ISortAlg getAlg() {\n      return alg;\n    }\n\n    public boolean inRange(long size) {\n      return size &gt;= start &amp;&amp; size &lt; end;\n    }\n  }\n}\n</code></pre><p>现在的代码实现就更加优美了。我们把可变的部分隔离到了策略工厂类和Sorter类中的静态代码段中。当要添加一个新的排序算法时，我们只需要修改策略工厂类和Sort类中的静态代码段，其他代码都不需要修改，这样就将代码改动最小化、集中化了。</p><p>你可能会说，即便这样，当我们添加新的排序算法的时候，还是需要修改代码，并不完全符合开闭原则。有什么办法让我们完全满足开闭原则呢？</p><p>对于Java语言来说，我们可以通过反射来避免对策略工厂类的修改。具体是这么做的：我们通过一个配置文件或者自定义的annotation来标注都有哪些策略类；策略工厂类读取配置文件或者搜索被annotation标注的策略类，然后通过反射动态地加载这些策略类、创建策略对象；当我们新添加一个策略的时候，只需要将这个新添加的策略类添加到配置文件或者用annotation标注即可。还记得上一节课的课堂讨论题吗？我们也可以用这种方法来解决。</p><p>对于Sorter来说，我们可以通过同样的方法来避免修改。我们通过将文件大小区间和算法之间的对应关系放到配置文件中。当添加新的排序算法时，我们只需要改动配置文件即可，不需要改动代码。</p><h2>重点回顾</h2><p>好了，今天的内容到此就讲完了。我们一块来总结回顾一下，你需要重点掌握的内容。</p><p>一提到if-else分支判断，有人就觉得它是烂代码。如果if-else分支判断不复杂、代码不多，这并没有任何问题，毕竟if-else分支判断几乎是所有编程语言都会提供的语法，存在即有理由。遵循KISS原则，怎么简单怎么来，就是最好的设计。非得用策略模式，搞出n多类，反倒是一种过度设计。</p><p>一提到策略模式，有人就觉得，它的作用是避免if-else分支判断逻辑。实际上，这种认识是很片面的。策略模式主要的作用还是解耦策略的定义、创建和使用，控制代码的复杂度，让每个部分都不至于过于复杂、代码量过多。除此之外，对于复杂代码来说，策略模式还能让其满足开闭原则，添加新策略的时候，最小化、集中化代码改动，减少引入bug的风险。</p><p>实际上，设计原则和思想比设计模式更加普适和重要。掌握了代码的设计原则和思想，我们能更清楚的了解，为什么要用某种设计模式，就能更恰到好处地应用设计模式。</p><h2>课堂讨论</h2><ol>\n<li>在过去的项目开发中，你有没有用过策略模式，都是为了解决什么问题才使用的？</li>\n<li>你可以说一说，在什么情况下，我们才有必要去掉代码中的if-else或者switch-case分支逻辑呢？</li>\n</ol><p>欢迎留言和我分享你的想法。如果有收获，也欢迎你把这篇文章分享给你的朋友。</p>",
                "article_title": "61 | 策略模式（下）：如何实现一个支持给不同大小文件排序的小程序？"
            },
            {
                "title": "62 | 职责链模式（上）：如何实现可灵活扩展算法的敏感信息过滤框架？",
                "herf": "https://time.geekbang.org/column/article/216278",
                "id": "216278",
                "content": "<p>前几节课中，我们学习了模板模式、策略模式，今天，我们来学习职责链模式。这三种模式具有相同的作用：复用和扩展，在实际的项目开发中比较常用，特别是框架开发中，我们可以利用它们来提供框架的扩展点，能够让框架的使用者在不修改框架源码的情况下，基于扩展点定制化框架的功能。</p><p>今天，我们主要讲解职责链模式的原理和实现。除此之外，我还会利用职责链模式，带你实现一个可以灵活扩展算法的敏感词过滤框架。下一节课，我们会更加贴近实战，通过剖析Servlet Filter、Spring Interceptor来看，如何利用职责链模式实现框架中常用的过滤器、拦截器。</p><p>话不多说，让我们正式开始今天的学习吧！</p><h2>职责链模式的原理和实现</h2><p>职责链模式的英文翻译是Chain Of Responsibility Design Pattern。在GoF的《设计模式》中，它是这么定义的：</p><blockquote>\n<p>Avoid coupling the sender of a request to its receiver by giving more than one object a chance to handle the request. Chain the receiving objects and pass the request along the chain until an object handles it.</p>\n</blockquote><!-- [[[read_end]]] --><p>翻译成中文就是：将请求的发送和接收解耦，让多个接收对象都有机会处理这个请求。将这些接收对象串成一条链，并沿着这条链传递这个请求，直到链上的某个接收对象能够处理它为止。</p><p>这么说比较抽象，我用更加容易理解的话来进一步解读一下。</p><p>在职责链模式中，多个处理器（也就是刚刚定义中说的“接收对象”）依次处理同一个请求。一个请求先经过A处理器处理，然后再把请求传递给B处理器，B处理器处理完后再传递给C处理器，以此类推，形成一个链条。链条上的每个处理器各自承担各自的处理职责，所以叫作职责链模式。</p><p>关于职责链模式，我们先来看看它的代码实现。结合代码实现，你会更容易理解它的定义。职责链模式有多种实现方式，我们这里介绍两种比较常用的。</p><p>第一种实现方式如下所示。其中，Handler是所有处理器类的抽象父类，handle()是抽象方法。每个具体的处理器类（HandlerA、HandlerB）的handle()函数的代码结构类似，如果它能处理该请求，就不继续往下传递；如果不能处理，则交由后面的处理器来处理（也就是调用successor.handle()）。HandlerChain是处理器链，从数据结构的角度来看，它就是一个记录了链头、链尾的链表。其中，记录链尾是为了方便添加处理器。</p><pre><code>public abstract class Handler {\n  protected Handler successor = null;\n\n  public void setSuccessor(Handler successor) {\n    this.successor = successor;\n  }\n\n  public abstract void handle();\n}\n\npublic class HandlerA extends Handler {\n  @Override\n  public void handle() {\n    boolean handled = false;\n    //...\n    if (!handled &amp;&amp; successor != null) {\n      successor.handle();\n    }\n  }\n}\n\npublic class HandlerB extends Handler {\n  @Override\n  public void handle() {\n    boolean handled = false;\n    //...\n    if (!handled &amp;&amp; successor != null) {\n      successor.handle();\n    } \n  }\n}\n\npublic class HandlerChain {\n  private Handler head = null;\n  private Handler tail = null;\n\n  public void addHandler(Handler handler) {\n    handler.setSuccessor(null);\n\n    if (head == null) {\n      head = handler;\n      tail = handler;\n      return;\n    }\n\n    tail.setSuccessor(handler);\n    tail = handler;\n  }\n\n  public void handle() {\n    if (head != null) {\n      head.handle();\n    }\n  }\n}\n\n// 使用举例\npublic class Application {\n  public static void main(String[] args) {\n    HandlerChain chain = new HandlerChain();\n    chain.addHandler(new HandlerA());\n    chain.addHandler(new HandlerB());\n    chain.handle();\n  }\n}\n</code></pre><p>实际上，上面的代码实现不够优雅。处理器类的handle()函数，不仅包含自己的业务逻辑，还包含对下一个处理器的调用，也就是代码中的successor.handle()。一个不熟悉这种代码结构的程序员，在添加新的处理器类的时候，很有可能忘记在handle()函数中调用successor.handle()，这就会导致代码出现bug。</p><p>针对这个问题，我们对代码进行重构，利用模板模式，将调用successor.handle()的逻辑从具体的处理器类中剥离出来，放到抽象父类中。这样具体的处理器类只需要实现自己的业务逻辑就可以了。重构之后的代码如下所示：</p><pre><code>public abstract class Handler {\n  protected Handler successor = null;\n\n  public void setSuccessor(Handler successor) {\n    this.successor = successor;\n  }\n\n  public final void handle() {\n    boolean handled = doHandle();\n    if (successor != null &amp;&amp; !handled) {\n      successor.handle();\n    }\n  }\n\n  protected abstract boolean doHandle();\n}\n\npublic class HandlerA extends Handler {\n  @Override\n  protected boolean doHandle() {\n    boolean handled = false;\n    //...\n    return handled;\n  }\n}\n\npublic class HandlerB extends Handler {\n  @Override\n  protected boolean doHandle() {\n    boolean handled = false;\n    //...\n    return handled;\n  }\n}\n\n// HandlerChain和Application代码不变\n</code></pre><p>我们再来看第二种实现方式，代码如下所示。这种实现方式更加简单。HandlerChain类用数组而非链表来保存所有的处理器，并且需要在HandlerChain的handle()函数中，依次调用每个处理器的handle()函数。</p><pre><code>public interface IHandler {\n  boolean handle();\n}\n\npublic class HandlerA implements IHandler {\n  @Override\n  public boolean handle() {\n    boolean handled = false;\n    //...\n    return handled;\n  }\n}\n\npublic class HandlerB implements IHandler {\n  @Override\n  public boolean handle() {\n    boolean handled = false;\n    //...\n    return handled;\n  }\n}\n\npublic class HandlerChain {\n  private List&lt;IHandler&gt; handlers = new ArrayList&lt;&gt;();\n\n  public void addHandler(IHandler handler) {\n    this.handlers.add(handler);\n  }\n\n  public void handle() {\n    for (IHandler handler : handlers) {\n      boolean handled = handler.handle();\n      if (handled) {\n        break;\n      }\n    }\n  }\n}\n\n// 使用举例\npublic class Application {\n  public static void main(String[] args) {\n    HandlerChain chain = new HandlerChain();\n    chain.addHandler(new HandlerA());\n    chain.addHandler(new HandlerB());\n    chain.handle();\n  }\n}\n</code></pre><p>在GoF给出的定义中，如果处理器链上的某个处理器能够处理这个请求，那就不会继续往下传递请求。实际上，职责链模式还有一种变体，那就是请求会被所有的处理器都处理一遍，不存在中途终止的情况。这种变体也有两种实现方式：用链表存储处理器和用数组存储处理器，跟上面的两种实现方式类似，只需要稍微修改即可。</p><p>我这里只给出其中一种实现方式，如下所示。另外一种实现方式你对照着上面的实现自行修改。</p><pre><code>public abstract class Handler {\n  protected Handler successor = null;\n\n  public void setSuccessor(Handler successor) {\n    this.successor = successor;\n  }\n\n  public final void handle() {\n    doHandle();\n    if (successor != null) {\n      successor.handle();\n    }\n  }\n\n  protected abstract void doHandle();\n}\n\npublic class HandlerA extends Handler {\n  @Override\n  protected void doHandle() {\n    //...\n  }\n}\n\npublic class HandlerB extends Handler {\n  @Override\n  protected void doHandle() {\n    //...\n  }\n}\n\npublic class HandlerChain {\n  private Handler head = null;\n  private Handler tail = null;\n\n  public void addHandler(Handler handler) {\n    handler.setSuccessor(null);\n\n    if (head == null) {\n      head = handler;\n      tail = handler;\n      return;\n    }\n\n    tail.setSuccessor(handler);\n    tail = handler;\n  }\n\n  public void handle() {\n    if (head != null) {\n      head.handle();\n    }\n  }\n}\n\n// 使用举例\npublic class Application {\n  public static void main(String[] args) {\n    HandlerChain chain = new HandlerChain();\n    chain.addHandler(new HandlerA());\n    chain.addHandler(new HandlerB());\n    chain.handle();\n  }\n}\n</code></pre><h2>职责链模式的应用场景举例</h2><p>职责链模式的原理和实现讲完了，我们再通过一个实际的例子，来学习一下职责链模式的应用场景。</p><p>对于支持UGC（User Generated Content，用户生成内容）的应用（比如论坛）来说，用户生成的内容（比如，在论坛中发表的帖子）可能会包含一些敏感词（比如涉黄、广告、反动等词汇）。针对这个应用场景，我们就可以利用职责链模式来过滤这些敏感词。</p><p>对于包含敏感词的内容，我们有两种处理方式，一种是直接禁止发布，另一种是给敏感词打马赛克（比如，用***替换敏感词）之后再发布。第一种处理方式符合GoF给出的职责链模式的定义，第二种处理方式是职责链模式的变体。</p><p>我们这里只给出第一种实现方式的代码示例，如下所示，并且，我们只给出了代码实现的骨架，具体的敏感词过滤算法并没有给出，你可以参看我的另一个专栏<a href=\"https://time.geekbang.org/column/intro/100017301\">《数据结构与算法之美》</a>中多模式字符串匹配的相关章节自行实现。</p><pre><code>public interface SensitiveWordFilter {\n  boolean doFilter(Content content);\n}\n\npublic class SexyWordFilter implements SensitiveWordFilter {\n  @Override\n  public boolean doFilter(Content content) {\n    boolean legal = true;\n    //...\n    return legal;\n  }\n}\n\n// PoliticalWordFilter、AdsWordFilter类代码结构与SexyWordFilter类似\n\npublic class SensitiveWordFilterChain {\n  private List&lt;SensitiveWordFilter&gt; filters = new ArrayList&lt;&gt;();\n\n  public void addFilter(SensitiveWordFilter filter) {\n    this.filters.add(filter);\n  }\n\n  // return true if content doesn't contain sensitive words.\n  public boolean filter(Content content) {\n    for (SensitiveWordFilter filter : filters) {\n      if (!filter.doFilter(content)) {\n        return false;\n      }\n    }\n    return true;\n  }\n}\n\npublic class ApplicationDemo {\n  public static void main(String[] args) {\n    SensitiveWordFilterChain filterChain = new SensitiveWordFilterChain();\n    filterChain.addFilter(new AdsWordFilter());\n    filterChain.addFilter(new SexyWordFilter());\n    filterChain.addFilter(new PoliticalWordFilter());\n\n    boolean legal = filterChain.filter(new Content());\n    if (!legal) {\n      // 不发表\n    } else {\n      // 发表\n    }\n  }\n}\n</code></pre><p>看了上面的实现，你可能会说，我像下面这样也可以实现敏感词过滤功能，而且代码更加简单，为什么非要使用职责链模式呢？这是不是过度设计呢？</p><pre><code>public class SensitiveWordFilter {\n  // return true if content doesn't contain sensitive words.\n  public boolean filter(Content content) {\n    if (!filterSexyWord(content)) {\n      return false;\n    }\n\n    if (!filterAdsWord(content)) {\n      return false;\n    }\n\n    if (!filterPoliticalWord(content)) {\n      return false;\n    }\n\n    return true;\n  }\n\n  private boolean filterSexyWord(Content content) {\n    //....\n  }\n\n  private boolean filterAdsWord(Content content) {\n    //...\n  }\n\n  private boolean filterPoliticalWord(Content content) {\n    //...\n  }\n}\n</code></pre><p>我们前面多次讲过，应用设计模式主要是为了应对代码的复杂性，让其满足开闭原则，提高代码的扩展性。这里应用职责链模式也不例外。实际上，我们在讲解<a href=\"https://time.geekbang.org/column/article/214014\">策略模式</a>的时候，也讲过类似的问题，比如，为什么要用策略模式？当时的给出的理由，与现在应用职责链模式的理由，几乎是一样的，你可以结合着当时的讲解一块来看下。</p><p><strong>首先，我们来看，职责链模式如何应对代码的复杂性。</strong></p><p>将大块代码逻辑拆分成函数，将大类拆分成小类，是应对代码复杂性的常用方法。应用职责链模式，我们把各个敏感词过滤函数继续拆分出来，设计成独立的类，进一步简化了SensitiveWordFilter类，让SensitiveWordFilter类的代码不会过多，过复杂。</p><p><strong>其次，我们再来看，职责链模式如何让代码满足开闭原则，提高代码的扩展性。</strong></p><p>当我们要扩展新的过滤算法的时候，比如，我们还需要过滤特殊符号，按照非职责链模式的代码实现方式，我们需要修改SensitiveWordFilter的代码，违反开闭原则。不过，这样的修改还算比较集中，也是可以接受的。而职责链模式的实现方式更加优雅，只需要新添加一个Filter类，并且通过addFilter()函数将它添加到FilterChain中即可，其他代码完全不需要修改。</p><p>不过，你可能会说，即便使用职责链模式来实现，当添加新的过滤算法的时候，还是要修改客户端代码（ApplicationDemo），这样做也没有完全符合开闭原则。</p><p>实际上，细化一下的话，我们可以把上面的代码分成两类：框架代码和客户端代码。其中，ApplicationDemo属于客户端代码，也就是使用框架的代码。除ApplicationDemo之外的代码属于敏感词过滤框架代码。</p><p>假设敏感词过滤框架并不是我们开发维护的，而是我们引入的一个第三方框架，我们要扩展一个新的过滤算法，不可能直接去修改框架的源码。这个时候，利用职责链模式就能达到开篇所说的，在不修改框架源码的情况下，基于职责链模式提供的扩展点，来扩展新的功能。换句话说，我们在框架这个代码范围内实现了开闭原则。</p><p>除此之外，利用职责链模式相对于不用职责链的实现方式，还有一个好处，那就是配置过滤算法更加灵活，可以只选择使用某几个过滤算法。</p><h2>重点回顾</h2><p>好了，今天的内容到此就讲完了。我们一块儿总结回顾一下，你需要重点掌握的内容。</p><p>在职责链模式中，多个处理器依次处理同一个请求。一个请求先经过A处理器处理，然后再把请求传递给B处理器，B处理器处理完后再传递给C处理器，以此类推，形成一个链条。链条上的每个处理器各自承担各自的处理职责，所以叫作职责链模式。</p><p>在GoF的定义中，一旦某个处理器能处理这个请求，就不会继续将请求传递给后续的处理器了。当然，在实际的开发中，也存在对这个模式的变体，那就是请求不会中途终止传递，而是会被所有的处理器都处理一遍。</p><p>职责链模式有两种常用的实现。一种是使用链表来存储处理器，另一种是使用数组来存储处理器，后面一种实现方式更加简单。</p><h2>课堂讨论</h2><p>今天讲到利用职责链模式，我们可以让框架代码满足开闭原则。添加一个新的处理器，只需要修改客户端代码。如果我们希望客户端代码也满足开闭原则，不修改任何代码，你有什么办法可以做到呢？</p><p>欢迎留言和我分享你的想法。如果有收获，也欢迎你把这篇文章分享给你的朋友。</p>",
                "article_title": "62 | 职责链模式（上）：如何实现可灵活扩展算法的敏感信息过滤框架？"
            },
            {
                "title": "63 | 职责链模式（下）：框架中常用的过滤器、拦截器是如何实现的？",
                "herf": "https://time.geekbang.org/column/article/217395",
                "id": "217395",
                "content": "<p>上一节课，我们学习职责链模式的原理与实现，并且通过一个敏感词过滤框架的例子，展示了职责链模式的设计意图。本质上来说，它跟大部分设计模式一样，都是为了解耦代码，应对代码的复杂性，让代码满足开闭原则，提高代码的可扩展性。</p><p>除此之外，我们还提到，职责链模式常用在框架的开发中，为框架提供扩展点，让框架的使用者在不修改框架源码的情况下，基于扩展点添加新的功能。实际上，更具体点来说，职责链模式最常用来开发框架的过滤器和拦截器。今天，我们就通过Servlet Filter、Spring Interceptor这两个Java开发中常用的组件，来具体讲讲它在框架开发中的应用。</p><p>话不多说，让我们正式开始今天的学习吧！</p><h2>Servlet Filter</h2><p>Servlet Filter是Java Servlet规范中定义的组件，翻译成中文就是过滤器，它可以实现对HTTP请求的过滤功能，比如鉴权、限流、记录日志、验证参数等等。因为它是Servlet规范的一部分，所以，只要是支持Servlet的Web容器（比如，Tomcat、Jetty等），都支持过滤器功能。为了帮助你理解，我画了一张示意图阐述它的工作原理，如下所示。</p><p><img src=\"https://static001.geekbang.org/resource/image/32/21/3296abd63a61ebdf4eff3a6530979e21.jpg\" alt=\"\"></p><p>在实际项目中，我们该如何使用Servlet Filter呢？我写了一个简单的示例代码，如下所示。添加一个过滤器，我们只需要定义一个实现javax.servlet.Filter接口的过滤器类，并且将它配置在web.xml配置文件中。Web容器启动的时候，会读取web.xml中的配置，创建过滤器对象。当有请求到来的时候，会先经过过滤器，然后才由Servlet来处理。</p><!-- [[[read_end]]] --><pre><code>public class LogFilter implements Filter {\n  @Override\n  public void init(FilterConfig filterConfig) throws ServletException {\n    // 在创建Filter时自动调用，\n    // 其中filterConfig包含这个Filter的配置参数，比如name之类的（从配置文件中读取的）\n  }\n\n  @Override\n  public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {\n    System.out.println(&quot;拦截客户端发送来的请求.&quot;);\n    chain.doFilter(request, response);\n    System.out.println(&quot;拦截发送给客户端的响应.&quot;);\n  }\n\n  @Override\n  public void destroy() {\n    // 在销毁Filter时自动调用\n  }\n}\n\n// 在web.xml配置文件中如下配置：\n&lt;filter&gt;\n  &lt;filter-name&gt;logFilter&lt;/filter-name&gt;\n  &lt;filter-class&gt;com.xzg.cd.LogFilter&lt;/filter-class&gt;\n&lt;/filter&gt;\n&lt;filter-mapping&gt;\n    &lt;filter-name&gt;logFilter&lt;/filter-name&gt;\n    &lt;url-pattern&gt;/*&lt;/url-pattern&gt;\n&lt;/filter-mapping&gt;\n</code></pre><p>从刚刚的示例代码中，我们发现，添加过滤器非常方便，不需要修改任何代码，定义一个实现javax.servlet.Filter的类，再改改配置就搞定了，完全符合开闭原则。那Servlet Filter是如何做到如此好的扩展性的呢？我想你应该已经猜到了，它利用的就是职责链模式。现在，我们通过剖析它的源码，详细地看看它底层是如何实现的。</p><p>在上一节课中，我们讲到，职责链模式的实现包含处理器接口（IHandler）或抽象类（Handler），以及处理器链（HandlerChain）。对应到Servlet Filter，javax.servlet.Filter就是处理器接口，FilterChain就是处理器链。接下来，我们重点来看FilterChain是如何实现的。</p><p>不过，我们前面也讲过，Servlet只是一个规范，并不包含具体的实现，所以，Servlet中的FilterChain只是一个接口定义。具体的实现类由遵从Servlet规范的Web容器来提供，比如，ApplicationFilterChain类就是Tomcat提供的FilterChain的实现类，源码如下所示。</p><p>为了让代码更易读懂，我对代码进行了简化，只保留了跟设计思路相关的代码片段。完整的代码你可以自行去Tomcat中查看。</p><pre><code>public final class ApplicationFilterChain implements FilterChain {\n  private int pos = 0; //当前执行到了哪个filter\n  private int n; //filter的个数\n  private ApplicationFilterConfig[] filters;\n  private Servlet servlet;\n  \n  @Override\n  public void doFilter(ServletRequest request, ServletResponse response) {\n    if (pos &lt; n) {\n      ApplicationFilterConfig filterConfig = filters[pos++];\n      Filter filter = filterConfig.getFilter();\n      filter.doFilter(request, response, this);\n    } else {\n      // filter都处理完毕后，执行servlet\n      servlet.service(request, response);\n    }\n  }\n  \n  public void addFilter(ApplicationFilterConfig filterConfig) {\n    for (ApplicationFilterConfig filter:filters)\n      if (filter==filterConfig)\n         return;\n\n    if (n == filters.length) {//扩容\n      ApplicationFilterConfig[] newFilters = new ApplicationFilterConfig[n + INCREMENT];\n      System.arraycopy(filters, 0, newFilters, 0, n);\n      filters = newFilters;\n    }\n    filters[n++] = filterConfig;\n  }\n}\n</code></pre><p>ApplicationFilterChain中的doFilter()函数的代码实现比较有技巧，实际上是一个递归调用。你可以用每个Filter（比如LogFilter）的doFilter()的代码实现，直接替换ApplicationFilterChain的第12行代码，一眼就能看出是递归调用了。我替换了一下，如下所示。</p><pre><code>  @Override\n  public void doFilter(ServletRequest request, ServletResponse response) {\n    if (pos &lt; n) {\n      ApplicationFilterConfig filterConfig = filters[pos++];\n      Filter filter = filterConfig.getFilter();\n      //filter.doFilter(request, response, this);\n      //把filter.doFilter的代码实现展开替换到这里\n      System.out.println(&quot;拦截客户端发送来的请求.&quot;);\n      chain.doFilter(request, response); // chain就是this\n      System.out.println(&quot;拦截发送给客户端的响应.&quot;)\n    } else {\n      // filter都处理完毕后，执行servlet\n      servlet.service(request, response);\n    }\n  }\n</code></pre><p>这样实现主要是为了在一个doFilter()方法中，支持双向拦截，既能拦截客户端发送来的请求，也能拦截发送给客户端的响应，你可以结合着LogFilter那个例子，以及对比待会要讲到的Spring Interceptor，来自己理解一下。而我们上一节课给出的两种实现方式，都没法做到在业务逻辑执行的前后，同时添加处理代码。</p><h2>Spring Interceptor</h2><p>刚刚讲了Servlet Filter，现在我们来讲一个功能上跟它非常类似的东西，Spring Interceptor，翻译成中文就是拦截器。尽管英文单词和中文翻译都不同，但这两者基本上可以看作一个概念，都用来实现对HTTP请求进行拦截处理。</p><p>它们不同之处在于，Servlet Filter是Servlet规范的一部分，实现依赖于Web容器。Spring Interceptor是Spring MVC框架的一部分，由Spring MVC框架来提供实现。客户端发送的请求，会先经过Servlet Filter，然后再经过Spring Interceptor，最后到达具体的业务代码中。我画了一张图来阐述一个请求的处理流程，具体如下所示。</p><p><img src=\"https://static001.geekbang.org/resource/image/fe/68/febaa9220cb9ad2f0aafd4e5c3c19868.jpg\" alt=\"\"></p><p>在项目中，我们该如何使用Spring Interceptor呢？我写了一个简单的示例代码，如下所示。LogInterceptor实现的功能跟刚才的LogFilter完全相同，只是实现方式上稍有区别。LogFilter对请求和响应的拦截是在doFilter()一个函数中实现的，而LogInterceptor对请求的拦截在preHandle()中实现，对响应的拦截在postHandle()中实现。</p><pre><code>public class LogInterceptor implements HandlerInterceptor {\n\n  @Override\n  public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {\n    System.out.println(&quot;拦截客户端发送来的请求.&quot;);\n    return true; // 继续后续的处理\n  }\n\n  @Override\n  public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception {\n    System.out.println(&quot;拦截发送给客户端的响应.&quot;);\n  }\n\n  @Override\n  public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception {\n    System.out.println(&quot;这里总是被执行.&quot;);\n  }\n}\n\n//在Spring MVC配置文件中配置interceptors\n&lt;mvc:interceptors&gt;\n   &lt;mvc:interceptor&gt;\n       &lt;mvc:mapping path=&quot;/*&quot;/&gt;\n       &lt;bean class=&quot;com.xzg.cd.LogInterceptor&quot; /&gt;\n   &lt;/mvc:interceptor&gt;\n&lt;/mvc:interceptors&gt;\n</code></pre><p>同样，我们还是来剖析一下，Spring Interceptor底层是如何实现的。</p><p>当然，它也是基于职责链模式实现的。其中，HandlerExecutionChain类是职责链模式中的处理器链。它的实现相较于Tomcat中的ApplicationFilterChain来说，逻辑更加清晰，不需要使用递归来实现，主要是因为它将请求和响应的拦截工作，拆分到了两个函数中实现。HandlerExecutionChain的源码如下所示，同样，我对代码也进行了一些简化，只保留了关键代码。</p><pre><code>public class HandlerExecutionChain {\n private final Object handler;\n private HandlerInterceptor[] interceptors;\n \n public void addInterceptor(HandlerInterceptor interceptor) {\n  initInterceptorList().add(interceptor);\n }\n\n boolean applyPreHandle(HttpServletRequest request, HttpServletResponse response) throws Exception {\n  HandlerInterceptor[] interceptors = getInterceptors();\n  if (!ObjectUtils.isEmpty(interceptors)) {\n   for (int i = 0; i &lt; interceptors.length; i++) {\n    HandlerInterceptor interceptor = interceptors[i];\n    if (!interceptor.preHandle(request, response, this.handler)) {\n     triggerAfterCompletion(request, response, null);\n     return false;\n    }\n   }\n  }\n  return true;\n }\n\n void applyPostHandle(HttpServletRequest request, HttpServletResponse response, ModelAndView mv) throws Exception {\n  HandlerInterceptor[] interceptors = getInterceptors();\n  if (!ObjectUtils.isEmpty(interceptors)) {\n   for (int i = interceptors.length - 1; i &gt;= 0; i--) {\n    HandlerInterceptor interceptor = interceptors[i];\n    interceptor.postHandle(request, response, this.handler, mv);\n   }\n  }\n }\n\n void triggerAfterCompletion(HttpServletRequest request, HttpServletResponse response, Exception ex)\n   throws Exception {\n  HandlerInterceptor[] interceptors = getInterceptors();\n  if (!ObjectUtils.isEmpty(interceptors)) {\n   for (int i = this.interceptorIndex; i &gt;= 0; i--) {\n    HandlerInterceptor interceptor = interceptors[i];\n    try {\n     interceptor.afterCompletion(request, response, this.handler, ex);\n    } catch (Throwable ex2) {\n     logger.error(&quot;HandlerInterceptor.afterCompletion threw exception&quot;, ex2);\n    }\n   }\n  }\n }\n}\n</code></pre><p>在Spring框架中，DispatcherServlet的doDispatch()方法来分发请求，它在真正的业务逻辑执行前后，执行HandlerExecutionChain中的applyPreHandle()和applyPostHandle()函数，用来实现拦截的功能。具体的代码实现很简单，你自己应该能脑补出来，这里就不罗列了。感兴趣的话，你可以自行去查看。</p><h2>重点回顾</h2><p>好了，今天的内容到此就讲完了。我们一块来总结回顾一下，你需要重点掌握的内容。</p><p>职责链模式常用在框架开发中，用来实现框架的过滤器、拦截器功能，让框架的使用者在不需要修改框架源码的情况下，添加新的过滤拦截功能。这也体现了之前讲到的对扩展开放、对修改关闭的设计原则。</p><p>今天，我们通过Servlet Filter、Spring Interceptor两个实际的例子，给你展示了在框架开发中职责链模式具体是怎么应用的。从源码中，我们还可以发现，尽管上一节课中我们有给出职责链模式的经典代码实现，但在实际的开发中，我们还是要具体问题具体对待，代码实现会根据不同的需求有所变化。实际上，这一点对于所有的设计模式都适用。</p><h2>课堂讨论</h2><ol>\n<li>前面在讲代理模式的时候，我们提到，Spring AOP是基于代理模式来实现的。在实际的项目开发中，我们可以利用AOP来实现访问控制功能，比如鉴权、限流、日志等。今天我们又讲到，Servlet Filter、Spring Interceptor也可以用来实现访问控制。那在项目开发中，类似权限这样的访问控制功能，我们该选择三者（AOP、Servlet Filter、Spring Interceptor）中的哪个来实现呢？有什么参考标准吗？</li>\n<li>除了我们讲到的Servlet Filter、Spring Interceptor之外，Dubbo Filter、Netty ChannelPipeline也是职责链模式的实际应用案例，你能否找一个你熟悉的并且用到职责链模式的框架，像我一样分析一下它的底层实现呢？</li>\n</ol><p>欢迎留言和我分享你的想法。如果有收获，欢迎你把这篇文章分享给你的朋友。</p>",
                "article_title": "63 | 职责链模式（下）：框架中常用的过滤器、拦截器是如何实现的？"
            },
            {
                "title": "64 | 状态模式：游戏、工作流引擎中常用的状态机是如何实现的？",
                "herf": "https://time.geekbang.org/column/article/218375",
                "id": "218375",
                "content": "<p>从今天起，我们开始学习状态模式。在实际的软件开发中，状态模式并不是很常用，但是在能够用到的场景里，它可以发挥很大的作用。从这一点上来看，它有点像我们之前讲到的组合模式。</p><p>状态模式一般用来实现状态机，而状态机常用在游戏、工作流引擎等系统开发中。不过，状态机的实现方式有多种，除了状态模式，比较常用的还有分支逻辑法和查表法。今天，我们就详细讲讲这几种实现方式，并且对比一下它们的优劣和应用场景。</p><p>话不多说，让我们正式开始今天的学习吧！</p><h2>什么是有限状态机？</h2><p>有限状态机，英文翻译是Finite State Machine，缩写为FSM，简称为状态机。状态机有3个组成部分：状态（State）、事件（Event）、动作（Action）。其中，事件也称为转移条件（Transition Condition）。事件触发状态的转移及动作的执行。不过，动作不是必须的，也可能只转移状态，不执行任何动作。</p><p>对于刚刚给出的状态机的定义，我结合一个具体的例子，来进一步解释一下。</p><p>“超级马里奥”游戏不知道你玩过没有？在游戏中，马里奥可以变身为多种形态，比如小马里奥（Small Mario）、超级马里奥（Super Mario）、火焰马里奥（Fire Mario）、斗篷马里奥（Cape Mario）等等。在不同的游戏情节下，各个形态会互相转化，并相应的增减积分。比如，初始形态是小马里奥，吃了蘑菇之后就会变成超级马里奥，并且增加100积分。</p><!-- [[[read_end]]] --><p>实际上，马里奥形态的转变就是一个状态机。其中，马里奥的不同形态就是状态机中的“状态”，游戏情节（比如吃了蘑菇）就是状态机中的“事件”，加减积分就是状态机中的“动作”。比如，吃蘑菇这个事件，会触发状态的转移：从小马里奥转移到超级马里奥，以及触发动作的执行（增加100积分）。</p><p>为了方便接下来的讲解，我对游戏背景做了简化，只保留了部分状态和事件。简化之后的状态转移如下图所示：</p><p><img src=\"https://static001.geekbang.org/resource/image/5a/6c/5aa0310b9b3ea08794cfc2f376c8f96c.jpg\" alt=\"\"></p><p>我们如何编程来实现上面的状态机呢？换句话说，如何将上面的状态转移图翻译成代码呢？</p><p>我写了一个骨架代码，如下所示。其中，obtainMushRoom()、obtainCape()、obtainFireFlower()、meetMonster()这几个函数，能够根据当前的状态和事件，更新状态和增减积分。不过，具体的代码实现我暂时并没有给出。你可以把它当做面试题，试着补全一下，然后再来看我下面的讲解，这样你的收获会更大。</p><pre><code>public enum State {\n  SMALL(0),\n  SUPER(1),\n  FIRE(2),\n  CAPE(3);\n\n  private int value;\n\n  private State(int value) {\n    this.value = value;\n  }\n\n  public int getValue() {\n    return this.value;\n  }\n}\n\npublic class MarioStateMachine {\n  private int score;\n  private State currentState;\n\n  public MarioStateMachine() {\n    this.score = 0;\n    this.currentState = State.SMALL;\n  }\n\n  public void obtainMushRoom() {\n    //TODO\n  }\n\n  public void obtainCape() {\n    //TODO\n  }\n\n  public void obtainFireFlower() {\n    //TODO\n  }\n\n  public void meetMonster() {\n    //TODO\n  }\n\n  public int getScore() {\n    return this.score;\n  }\n\n  public State getCurrentState() {\n    return this.currentState;\n  }\n}\n\npublic class ApplicationDemo {\n  public static void main(String[] args) {\n    MarioStateMachine mario = new MarioStateMachine();\n    mario.obtainMushRoom();\n    int score = mario.getScore();\n    State state = mario.getCurrentState();\n    System.out.println(&quot;mario score: &quot; + score + &quot;; state: &quot; + state);\n  }\n}\n</code></pre><h2>状态机实现方式一：分支逻辑法</h2><p>对于如何实现状态机，我总结了三种方式。其中，最简单直接的实现方式是，参照状态转移图，将每一个状态转移，原模原样地直译成代码。这样编写的代码会包含大量的if-else或switch-case分支判断逻辑，甚至是嵌套的分支判断逻辑，所以，我把这种方法暂且命名为分支逻辑法。</p><p>按照这个实现思路，我将上面的骨架代码补全一下。补全之后的代码如下所示：</p><pre><code>public class MarioStateMachine {\n  private int score;\n  private State currentState;\n\n  public MarioStateMachine() {\n    this.score = 0;\n    this.currentState = State.SMALL;\n  }\n\n  public void obtainMushRoom() {\n    if (currentState.equals(State.SMALL)) {\n      this.currentState = State.SUPER;\n      this.score += 100;\n    }\n  }\n\n  public void obtainCape() {\n    if (currentState.equals(State.SMALL) || currentState.equals(State.SUPER) ) {\n      this.currentState = State.CAPE;\n      this.score += 200;\n    }\n  }\n\n  public void obtainFireFlower() {\n    if (currentState.equals(State.SMALL) || currentState.equals(State.SUPER) ) {\n      this.currentState = State.FIRE;\n      this.score += 300;\n    }\n  }\n\n  public void meetMonster() {\n    if (currentState.equals(State.SUPER)) {\n      this.currentState = State.SMALL;\n      this.score -= 100;\n      return;\n    }\n\n    if (currentState.equals(State.CAPE)) {\n      this.currentState = State.SMALL;\n      this.score -= 200;\n      return;\n    }\n\n    if (currentState.equals(State.FIRE)) {\n      this.currentState = State.SMALL;\n      this.score -= 300;\n      return;\n    }\n  }\n\n  public int getScore() {\n    return this.score;\n  }\n\n  public State getCurrentState() {\n    return this.currentState;\n  }\n}\n</code></pre><p>对于简单的状态机来说，分支逻辑这种实现方式是可以接受的。但是，对于复杂的状态机来说，这种实现方式极易漏写或者错写某个状态转移。除此之外，代码中充斥着大量的if-else或者switch-case分支判断逻辑，可读性和可维护性都很差。如果哪天修改了状态机中的某个状态转移，我们要在冗长的分支逻辑中找到对应的代码进行修改，很容易改错，引入bug。</p><h2>状态机实现方式二：查表法</h2><p>实际上，上面这种实现方法有点类似hard code，对于复杂的状态机来说不适用，而状态机的第二种实现方式查表法，就更加合适了。接下来，我们就一块儿来看下，如何利用查表法来补全骨架代码。</p><p>实际上，除了用状态转移图来表示之外，状态机还可以用二维表来表示，如下所示。在这个二维表中，第一维表示当前状态，第二维表示事件，值表示当前状态经过事件之后，转移到的新状态及其执行的动作。</p><p><img src=\"https://static001.geekbang.org/resource/image/4f/91/4f4ea3787bd955918578181e18173491.jpg\" alt=\"\"></p><p>相对于分支逻辑的实现方式，查表法的代码实现更加清晰，可读性和可维护性更好。当修改状态机时，我们只需要修改transitionTable和actionTable两个二维数组即可。实际上，如果我们把这两个二维数组存储在配置文件中，当需要修改状态机时，我们甚至可以不修改任何代码，只需要修改配置文件就可以了。具体的代码如下所示：</p><pre><code>public enum Event {\n  GOT_MUSHROOM(0),\n  GOT_CAPE(1),\n  GOT_FIRE(2),\n  MET_MONSTER(3);\n\n  private int value;\n\n  private Event(int value) {\n    this.value = value;\n  }\n\n  public int getValue() {\n    return this.value;\n  }\n}\n\npublic class MarioStateMachine {\n  private int score;\n  private State currentState;\n\n  private static final State[][] transitionTable = {\n          {SUPER, CAPE, FIRE, SMALL},\n          {SUPER, CAPE, FIRE, SMALL},\n          {CAPE, CAPE, CAPE, SMALL},\n          {FIRE, FIRE, FIRE, SMALL}\n  };\n\n  private static final int[][] actionTable = {\n          {+100, +200, +300, +0},\n          {+0, +200, +300, -100},\n          {+0, +0, +0, -200},\n          {+0, +0, +0, -300}\n  };\n\n  public MarioStateMachine() {\n    this.score = 0;\n    this.currentState = State.SMALL;\n  }\n\n  public void obtainMushRoom() {\n    executeEvent(Event.GOT_MUSHROOM);\n  }\n\n  public void obtainCape() {\n    executeEvent(Event.GOT_CAPE);\n  }\n\n  public void obtainFireFlower() {\n    executeEvent(Event.GOT_FIRE);\n  }\n\n  public void meetMonster() {\n    executeEvent(Event.MET_MONSTER);\n  }\n\n  private void executeEvent(Event event) {\n    int stateValue = currentState.getValue();\n    int eventValue = event.getValue();\n    this.currentState = transitionTable[stateValue][eventValue];\n    this.score += actionTable[stateValue][eventValue];\n  }\n\n  public int getScore() {\n    return this.score;\n  }\n\n  public State getCurrentState() {\n    return this.currentState;\n  }\n\n}\n</code></pre><h2>状态机实现方式三：状态模式</h2><p>在查表法的代码实现中，事件触发的动作只是简单的积分加减，所以，我们用一个int类型的二维数组actionTable就能表示，二维数组中的值表示积分的加减值。但是，如果要执行的动作并非这么简单，而是一系列复杂的逻辑操作（比如加减积分、写数据库，还有可能发送消息通知等等），我们就没法用如此简单的二维数组来表示了。这也就是说，查表法的实现方式有一定局限性。</p><p>虽然分支逻辑的实现方式不存在这个问题，但它又存在前面讲到的其他问题，比如分支判断逻辑较多，导致代码可读性和可维护性不好等。实际上，针对分支逻辑法存在的问题，我们可以使用状态模式来解决。</p><p>状态模式通过将事件触发的状态转移和动作执行，拆分到不同的状态类中，来避免分支判断逻辑。我们还是结合代码来理解这句话。</p><p>利用状态模式，我们来补全MarioStateMachine类，补全后的代码如下所示。</p><p>其中，IMario是状态的接口，定义了所有的事件。SmallMario、SuperMario、CapeMario、FireMario是IMario接口的实现类，分别对应状态机中的4个状态。原来所有的状态转移和动作执行的代码逻辑，都集中在MarioStateMachine类中，现在，这些代码逻辑被分散到了这4个状态类中。</p><pre><code>public interface IMario { //所有状态类的接口\n  State getName();\n  //以下是定义的事件\n  void obtainMushRoom();\n  void obtainCape();\n  void obtainFireFlower();\n  void meetMonster();\n}\n\npublic class SmallMario implements IMario {\n  private MarioStateMachine stateMachine;\n\n  public SmallMario(MarioStateMachine stateMachine) {\n    this.stateMachine = stateMachine;\n  }\n\n  @Override\n  public State getName() {\n    return State.SMALL;\n  }\n\n  @Override\n  public void obtainMushRoom() {\n    stateMachine.setCurrentState(new SuperMario(stateMachine));\n    stateMachine.setScore(stateMachine.getScore() + 100);\n  }\n\n  @Override\n  public void obtainCape() {\n    stateMachine.setCurrentState(new CapeMario(stateMachine));\n    stateMachine.setScore(stateMachine.getScore() + 200);\n  }\n\n  @Override\n  public void obtainFireFlower() {\n    stateMachine.setCurrentState(new FireMario(stateMachine));\n    stateMachine.setScore(stateMachine.getScore() + 300);\n  }\n\n  @Override\n  public void meetMonster() {\n    // do nothing...\n  }\n}\n\npublic class SuperMario implements IMario {\n  private MarioStateMachine stateMachine;\n\n  public SuperMario(MarioStateMachine stateMachine) {\n    this.stateMachine = stateMachine;\n  }\n\n  @Override\n  public State getName() {\n    return State.SUPER;\n  }\n\n  @Override\n  public void obtainMushRoom() {\n    // do nothing...\n  }\n\n  @Override\n  public void obtainCape() {\n    stateMachine.setCurrentState(new CapeMario(stateMachine));\n    stateMachine.setScore(stateMachine.getScore() + 200);\n  }\n\n  @Override\n  public void obtainFireFlower() {\n    stateMachine.setCurrentState(new FireMario(stateMachine));\n    stateMachine.setScore(stateMachine.getScore() + 300);\n  }\n\n  @Override\n  public void meetMonster() {\n    stateMachine.setCurrentState(new SmallMario(stateMachine));\n    stateMachine.setScore(stateMachine.getScore() - 100);\n  }\n}\n\n// 省略CapeMario、FireMario类...\n\npublic class MarioStateMachine {\n  private int score;\n  private IMario currentState; // 不再使用枚举来表示状态\n\n  public MarioStateMachine() {\n    this.score = 0;\n    this.currentState = new SmallMario(this);\n  }\n\n  public void obtainMushRoom() {\n    this.currentState.obtainMushRoom();\n  }\n\n  public void obtainCape() {\n    this.currentState.obtainCape();\n  }\n\n  public void obtainFireFlower() {\n    this.currentState.obtainFireFlower();\n  }\n\n  public void meetMonster() {\n    this.currentState.meetMonster();\n  }\n\n  public int getScore() {\n    return this.score;\n  }\n\n  public State getCurrentState() {\n    return this.currentState.getName();\n  }\n\n  public void setScore(int score) {\n    this.score = score;\n  }\n\n  public void setCurrentState(IMario currentState) {\n    this.currentState = currentState;\n  }\n}\n</code></pre><p>上面的代码实现不难看懂，我只强调其中的一点，即MarioStateMachine和各个状态类之间是双向依赖关系。MarioStateMachine依赖各个状态类是理所当然的，但是，反过来，各个状态类为什么要依赖MarioStateMachine呢？这是因为，各个状态类需要更新MarioStateMachine中的两个变量，score和currentState。</p><p>实际上，上面的代码还可以继续优化，我们可以将状态类设计成单例，毕竟状态类中不包含任何成员变量。但是，当将状态类设计成单例之后，我们就无法通过构造函数来传递MarioStateMachine了，而状态类又要依赖MarioStateMachine，那该如何解决这个问题呢？</p><p>实际上，在<a href=\"https://time.geekbang.org/column/article/194068\">第42讲</a>单例模式的讲解中，我们提到过几种解决方法，你可以回过头去再查看一下。在这里，我们可以通过函数参数将MarioStateMachine传递进状态类。根据这个设计思路，我们对上面的代码进行重构。重构之后的代码如下所示：</p><pre><code>public interface IMario {\n  State getName();\n  void obtainMushRoom(MarioStateMachine stateMachine);\n  void obtainCape(MarioStateMachine stateMachine);\n  void obtainFireFlower(MarioStateMachine stateMachine);\n  void meetMonster(MarioStateMachine stateMachine);\n}\n\npublic class SmallMario implements IMario {\n  private static final SmallMario instance = new SmallMario();\n  private SmallMario() {}\n  public static SmallMario getInstance() {\n    return instance;\n  }\n\n  @Override\n  public State getName() {\n    return State.SMALL;\n  }\n\n  @Override\n  public void obtainMushRoom(MarioStateMachine stateMachine) {\n    stateMachine.setCurrentState(SuperMario.getInstance());\n    stateMachine.setScore(stateMachine.getScore() + 100);\n  }\n\n  @Override\n  public void obtainCape(MarioStateMachine stateMachine) {\n    stateMachine.setCurrentState(CapeMario.getInstance());\n    stateMachine.setScore(stateMachine.getScore() + 200);\n  }\n\n  @Override\n  public void obtainFireFlower(MarioStateMachine stateMachine) {\n    stateMachine.setCurrentState(FireMario.getInstance());\n    stateMachine.setScore(stateMachine.getScore() + 300);\n  }\n\n  @Override\n  public void meetMonster(MarioStateMachine stateMachine) {\n    // do nothing...\n  }\n}\n\n// 省略SuperMario、CapeMario、FireMario类...\n\npublic class MarioStateMachine {\n  private int score;\n  private IMario currentState;\n\n  public MarioStateMachine() {\n    this.score = 0;\n    this.currentState = SmallMario.getInstance();\n  }\n\n  public void obtainMushRoom() {\n    this.currentState.obtainMushRoom(this);\n  }\n\n  public void obtainCape() {\n    this.currentState.obtainCape(this);\n  }\n\n  public void obtainFireFlower() {\n    this.currentState.obtainFireFlower(this);\n  }\n\n  public void meetMonster() {\n    this.currentState.meetMonster(this);\n  }\n\n  public int getScore() {\n    return this.score;\n  }\n\n  public State getCurrentState() {\n    return this.currentState.getName();\n  }\n\n  public void setScore(int score) {\n    this.score = score;\n  }\n\n  public void setCurrentState(IMario currentState) {\n    this.currentState = currentState;\n  }\n}\n</code></pre><p>实际上，像游戏这种比较复杂的状态机，包含的状态比较多，我优先推荐使用查表法，而状态模式会引入非常多的状态类，会导致代码比较难维护。相反，像电商下单、外卖下单这种类型的状态机，它们的状态并不多，状态转移也比较简单，但事件触发执行的动作包含的业务逻辑可能会比较复杂，所以，更加推荐使用状态模式来实现。</p><h2>重点回顾</h2><p>好了，今天的内容到此就讲完了。我们一块来总结回顾一下，你需要重点掌握的内容。</p><p>今天我们讲解了状态模式。虽然网上有各种状态模式的定义，但是你只要记住状态模式是状态机的一种实现方式即可。状态机又叫有限状态机，它有3个部分组成：状态、事件、动作。其中，事件也称为转移条件。事件触发状态的转移及动作的执行。不过，动作不是必须的，也可能只转移状态，不执行任何动作。</p><p>针对状态机，今天我们总结了三种实现方式。</p><p>第一种实现方式叫分支逻辑法。利用if-else或者switch-case分支逻辑，参照状态转移图，将每一个状态转移原模原样地直译成代码。对于简单的状态机来说，这种实现方式最简单、最直接，是首选。</p><p>第二种实现方式叫查表法。对于状态很多、状态转移比较复杂的状态机来说，查表法比较合适。通过二维数组来表示状态转移图，能极大地提高代码的可读性和可维护性。</p><p>第三种实现方式叫状态模式。对于状态并不多、状态转移也比较简单，但事件触发执行的动作包含的业务逻辑可能比较复杂的状态机来说，我们首选这种实现方式。</p><h2>课堂讨论</h2><p>状态模式的代码实现还存在一些问题，比如，状态接口中定义了所有的事件函数，这就导致，即便某个状态类并不需要支持其中的某个或者某些事件，但也要实现所有的事件函数。不仅如此，添加一个事件到状态接口，所有的状态类都要做相应的修改。针对这些问题，你有什么解决方法吗？</p><p>欢迎留言和我分享你的想法。如果有收获，欢迎你把这篇文章分享给你的朋友。</p>",
                "article_title": "64 | 状态模式：游戏、工作流引擎中常用的状态机是如何实现的？"
            },
            {
                "title": "65 | 迭代器模式（上）：相比直接遍历集合数据，使用迭代器有哪些优势？",
                "herf": "https://time.geekbang.org/column/article/219290",
                "id": "219290",
                "content": "<p>上一节课，我们学习了状态模式。状态模式是状态机的一种实现方法。它通过将事件触发的状态转移和动作执行，拆分到不同的状态类中，以此来避免状态机类中的分支判断逻辑，应对状态机类代码的复杂性。</p><p>今天，我们学习另外一种行为型设计模式，迭代器模式。它用来遍历集合对象。不过，很多编程语言都将迭代器作为一个基础的类库，直接提供出来了。在平时开发中，特别是业务开发，我们直接使用即可，很少会自己去实现一个迭代器。不过，知其然知其所以然，弄懂原理能帮助我们更好的使用这些工具类，所以，我觉得还是有必要学习一下这个模式。</p><p>我们知道，大部分编程语言都提供了多种遍历集合的方式，比如for循环、foreach循环、迭代器等。所以，今天我们除了讲解迭代器的原理和实现之外，还会重点讲一下，相对于其他遍历方式，利用迭代器来遍历集合的优势。</p><p>话不多说，让我们正式开始今天的学习吧！</p><h2>迭代器模式的原理和实现</h2><p>迭代器模式（Iterator Design Pattern），也叫作游标模式（Cursor Design Pattern）。</p><p>在开篇中我们讲到，它用来遍历集合对象。这里说的“集合对象”也可以叫“容器”“聚合对象”，实际上就是包含一组对象的对象，比如数组、链表、树、图、跳表。迭代器模式将集合对象的遍历操作从集合类中拆分出来，放到迭代器类中，让两者的职责更加单一。</p><!-- [[[read_end]]] --><p>迭代器是用来遍历容器的，所以，一个完整的迭代器模式一般会涉及<strong>容器</strong>和<strong>容器迭代器</strong>两部分内容。为了达到基于接口而非实现编程的目的，容器又包含容器接口、容器实现类，迭代器又包含迭代器接口、迭代器实现类。对于迭代器模式，我画了一张简单的类图，你可以看一看，先有个大致的印象。</p><p><img src=\"https://static001.geekbang.org/resource/image/cb/ec/cb72b5921681ac13d4fc05237597d2ec.jpg\" alt=\"\"></p><p>接下来，我们通过一个例子来具体讲，如何实现一个迭代器。</p><p>开篇中我们有提到，大部分编程语言都提供了遍历容器的迭代器类，我们在平时开发中，直接拿来用即可，几乎不大可能从零编写一个迭代器。不过，这里为了讲解迭代器的实现原理，我们假设某个新的编程语言的基础类库中，还没有提供线性容器对应的迭代器，需要我们从零开始开发。现在，我们一块来看具体该如何去做。</p><p>我们知道，线性数据结构包括数组和链表，在大部分编程语言中都有对应的类来封装这两种数据结构，在开发中直接拿来用就可以了。假设在这种新的编程语言中，这两个数据结构分别对应ArrayList和LinkedList两个类。除此之外，我们从两个类中抽象出公共的接口，定义为List接口，以方便开发者基于接口而非实现编程，编写的代码能在两种数据存储结构之间灵活切换。</p><p>现在，我们针对ArrayList和LinkedList两个线性容器，设计实现对应的迭代器。按照之前给出的迭代器模式的类图，我们定义一个迭代器接口Iterator，以及针对两种容器的具体的迭代器实现类ArrayIterator和ListIterator。</p><p>我们先来看下Iterator接口的定义。具体的代码如下所示：</p><pre><code>// 接口定义方式一\npublic interface Iterator&lt;E&gt; {\n  boolean hasNext();\n  void next();\n  E currentItem();\n}\n\n// 接口定义方式二\npublic interface Iterator&lt;E&gt; {\n  boolean hasNext();\n  E next();\n}\n</code></pre><p>Iterator接口有两种定义方式。</p><p>在第一种定义中，next()函数用来将游标后移一位元素，currentItem()函数用来返回当前游标指向的元素。在第二种定义中，返回当前元素与后移一位这两个操作，要放到同一个函数next()中完成。</p><p>第一种定义方式更加灵活一些，比如我们可以多次调用currentItem()查询当前元素，而不移动游标。所以，在接下来的实现中，我们选择第一种接口定义方式。</p><p>现在，我们再来看下ArrayIterator的代码实现，具体如下所示。代码实现非常简单，不需要太多解释。你可以结合着我给出的demo，自己理解一下。</p><pre><code>public class ArrayIterator&lt;E&gt; implements Iterator&lt;E&gt; {\n  private int cursor;\n  private ArrayList&lt;E&gt; arrayList;\n\n  public ArrayIterator(ArrayList&lt;E&gt; arrayList) {\n    this.cursor = 0;\n    this.arrayList = arrayList;\n  }\n\n  @Override\n  public boolean hasNext() {\n    return cursor != arrayList.size(); //注意这里，cursor在指向最后一个元素的时候，hasNext()仍旧返回true。\n  }\n\n  @Override\n  public void next() {\n    cursor++;\n  }\n\n  @Override\n  public E currentItem() {\n    if (cursor &gt;= arrayList.size()) {\n      throw new NoSuchElementException();\n    }\n    return arrayList.get(cursor);\n  }\n}\n\npublic class Demo {\n  public static void main(String[] args) {\n    ArrayList&lt;String&gt; names = new ArrayList&lt;&gt;();\n    names.add(&quot;xzg&quot;);\n    names.add(&quot;wang&quot;);\n    names.add(&quot;zheng&quot;);\n    \n    Iterator&lt;String&gt; iterator = new ArrayIterator(names);\n    while (iterator.hasNext()) {\n      System.out.println(iterator.currentItem());\n      iterator.next();\n    }\n  }\n}\n</code></pre><p>在上面的代码实现中，我们需要将待遍历的容器对象，通过构造函数传递给迭代器类。实际上，为了封装迭代器的创建细节，我们可以在容器中定义一个iterator()方法，来创建对应的迭代器。为了能实现基于接口而非实现编程，我们还需要将这个方法定义在List接口中。具体的代码实现和使用示例如下所示：</p><pre><code>public interface List&lt;E&gt; {\n  Iterator iterator();\n  //...省略其他接口函数...\n}\n\npublic class ArrayList&lt;E&gt; implements List&lt;E&gt; {\n  //...\n  public Iterator iterator() {\n    return new ArrayIterator(this);\n  }\n  //...省略其他代码\n}\n\npublic class Demo {\n  public static void main(String[] args) {\n    List&lt;String&gt; names = new ArrayList&lt;&gt;();\n    names.add(&quot;xzg&quot;);\n    names.add(&quot;wang&quot;);\n    names.add(&quot;zheng&quot;);\n    \n    Iterator&lt;String&gt; iterator = names.iterator();\n    while (iterator.hasNext()) {\n      System.out.println(iterator.currentItem());\n      iterator.next();\n    }\n  }\n}\n</code></pre><p>对于LinkedIterator，它的代码结构跟ArrayIterator完全相同，我这里就不给出具体的代码实现了，你可以参照ArrayIterator自己去写一下。</p><p>结合刚刚的例子，我们来总结一下迭代器的设计思路。总结下来就三句话：迭代器中需要定义hasNext()、currentItem()、next()三个最基本的方法。待遍历的容器对象通过依赖注入传递到迭代器类中。容器通过iterator()方法来创建迭代器。</p><p>这里我画了一张类图，如下所示。实际上就是对上面那张类图的细化，你可以结合着一块看。</p><p><img src=\"https://static001.geekbang.org/resource/image/b6/30/b685b61448aaa638b03b5bf3d9d93330.jpg\" alt=\"\"></p><h2>迭代器模式的优势</h2><p>迭代器的原理和代码实现讲完了。接下来，我们来一块看一下，使用迭代器遍历集合的优势。</p><p>一般来讲，遍历集合数据有三种方法：for循环、foreach循环、iterator迭代器。对于这三种方式，我拿Java语言来举例说明一下。具体的代码如下所示：</p><pre><code>List&lt;String&gt; names = new ArrayList&lt;&gt;();\nnames.add(&quot;xzg&quot;);\nnames.add(&quot;wang&quot;);\nnames.add(&quot;zheng&quot;);\n\n// 第一种遍历方式：for循环\nfor (int i = 0; i &lt; names.size(); i++) {\n  System.out.print(names.get(i) + &quot;,&quot;);\n}\n\n// 第二种遍历方式：foreach循环\nfor (String name : names) {\n  System.out.print(name + &quot;,&quot;)\n}\n\n// 第三种遍历方式：迭代器遍历\nIterator&lt;String&gt; iterator = names.iterator();\nwhile (iterator.hasNext()) {\n  System.out.print(iterator.next() + &quot;,&quot;);//Java中的迭代器接口是第二种定义方式，next()既移动游标又返回数据\n}\n</code></pre><p>实际上，foreach循环只是一个语法糖而已，底层是基于迭代器来实现的。也就是说，上面代码中的第二种遍历方式（foreach循环代码）的底层实现，就是第三种遍历方式（迭代器遍历代码）。这两种遍历方式可以看作同一种遍历方式，也就是迭代器遍历方式。</p><p>从上面的代码来看，for循环遍历方式比起迭代器遍历方式，代码看起来更加简洁。那我们为什么还要用迭代器来遍历容器呢？为什么还要给容器设计对应的迭代器呢？原因有以下三个。</p><p>首先，对于类似数组和链表这样的数据结构，遍历方式比较简单，直接使用for循环来遍历就足够了。但是，对于复杂的数据结构（比如树、图）来说，有各种复杂的遍历方式。比如，树有前中后序、按层遍历，图有深度优先、广度优先遍历等等。如果由客户端代码来实现这些遍历算法，势必增加开发成本，而且容易写错。如果将这部分遍历的逻辑写到容器类中，也会导致容器类代码的复杂性。</p><p>前面也多次提到，应对复杂性的方法就是拆分。我们可以将遍历操作拆分到迭代器类中。比如，针对图的遍历，我们就可以定义DFSIterator、BFSIterator两个迭代器类，让它们分别来实现深度优先遍历和广度优先遍历。</p><p>其次，将游标指向的当前位置等信息，存储在迭代器类中，每个迭代器独享游标信息。这样，我们就可以创建多个不同的迭代器，同时对同一个容器进行遍历而互不影响。</p><p>最后，容器和迭代器都提供了抽象的接口，方便我们在开发的时候，基于接口而非具体的实现编程。当需要切换新的遍历算法的时候，比如，从前往后遍历链表切换成从后往前遍历链表，客户端代码只需要将迭代器类从LinkedIterator切换为ReversedLinkedIterator即可，其他代码都不需要修改。除此之外，添加新的遍历算法，我们只需要扩展新的迭代器类，也更符合开闭原则。</p><h2>重点回顾</h2><p>好了，今天的内容到此就讲完了。我们一块来总结回顾一下，你需要重点掌握的内容。</p><p>迭代器模式，也叫游标模式。它用来遍历集合对象。这里说的“集合对象”，我们也可以叫“容器”“聚合对象”，实际上就是包含一组对象的对象，比如，数组、链表、树、图、跳表。</p><p>一个完整的迭代器模式，一般会涉及容器和容器迭代器两部分内容。为了达到基于接口而非实现编程的目的，容器又包含容器接口、容器实现类，迭代器又包含迭代器接口、迭代器实现类。容器中需要定义iterator()方法，用来创建迭代器。迭代器接口中需要定义hasNext()、currentItem()、next()三个最基本的方法。容器对象通过依赖注入传递到迭代器类中。</p><p>遍历集合一般有三种方式：for循环、foreach循环、迭代器遍历。后两种本质上属于一种，都可以看作迭代器遍历。相对于for循环遍历，利用迭代器来遍历有下面三个优势：</p><ul>\n<li>迭代器模式封装集合内部的复杂数据结构，开发者不需要了解如何遍历，直接使用容器提供的迭代器即可；</li>\n<li>迭代器模式将集合对象的遍历操作从集合类中拆分出来，放到迭代器类中，让两者的职责更加单一；</li>\n<li>迭代器模式让添加新的遍历算法更加容易，更符合开闭原则。除此之外，因为迭代器都实现自相同的接口，在开发中，基于接口而非实现编程，替换迭代器也变得更加容易。</li>\n</ul><h2>课堂讨论</h2><ol>\n<li>在Java中，如果在使用迭代器的同时删除容器中的元素，会导致迭代器报错，这是为什么呢？如何来解决这个问题呢？</li>\n<li>除了编程语言中基础类库提供的针对集合对象的迭代器之外，实际上，迭代器还有其他的应用场景，比如MySQL ResultSet类提供的first()、last()、previous()等方法，也可以看作一种迭代器，你能分析一下它的代码实现吗？</li>\n</ol><p>欢迎留言和我分享你的想法。如果有收获，欢迎你把这篇文章分享给你的朋友。</p>",
                "article_title": "65 | 迭代器模式（上）：相比直接遍历集合数据，使用迭代器有哪些优势？"
            },
            {
                "title": "66 | 迭代器模式（中）：遍历集合的同时，为什么不能增删集合元素？",
                "herf": "https://time.geekbang.org/column/article/219964",
                "id": "219964",
                "content": "<p>上一节课中，我们通过给ArrayList、LinkedList容器实现迭代器，学习了迭代器模式的原理、实现和设计意图。迭代器模式主要作用是解耦容器代码和遍历代码，这也印证了我们前面多次讲过的应用设计模式的主要目的是解耦。</p><p>上一节课中讲解的内容都比较基础，今天，我们来深挖一下，如果在使用迭代器遍历集合的同时增加、删除集合中的元素，会发生什么情况？应该如何应对？如何在遍历的同时安全地删除集合元素？</p><p>话不多说，让我们正式开始今天的内容吧！</p><h2>在遍历的同时增删集合元素会发生什么？</h2><p>在通过迭代器来遍历集合元素的同时，增加或者删除集合中的元素，有可能会导致某个元素被重复遍历或遍历不到。不过，并不是所有情况下都会遍历出错，有的时候也可以正常遍历，所以，这种行为称为<strong>结果不可预期行为</strong>或者<strong>未决行为</strong>，也就是说，运行结果到底是对还是错，要视情况而定。</p><p>怎么理解呢？我们通过一个例子来解释一下。我们还是延续上一节课实现的ArrayList迭代器的例子。为了方便你查看，我把相关的代码都重新拷贝到这里了。</p><pre><code>public interface Iterator&lt;E&gt; {\n  boolean hasNext();\n  void next();\n  E currentItem();\n}\n\npublic class ArrayIterator&lt;E&gt; implements Iterator&lt;E&gt; {\n  private int cursor;\n  private ArrayList&lt;E&gt; arrayList;\n\n  public ArrayIterator(ArrayList&lt;E&gt; arrayList) {\n    this.cursor = 0;\n    this.arrayList = arrayList;\n  }\n\n  @Override\n  public boolean hasNext() {\n    return cursor &lt; arrayList.size();\n  }\n\n  @Override\n  public void next() {\n    cursor++;\n  }\n\n  @Override\n  public E currentItem() {\n    if (cursor &gt;= arrayList.size()) {\n      throw new NoSuchElementException();\n    }\n    return arrayList.get(cursor);\n  }\n}\n\npublic interface List&lt;E&gt; {\n  Iterator iterator();\n}\n\npublic class ArrayList&lt;E&gt; implements List&lt;E&gt; {\n  //...\n  public Iterator iterator() {\n    return new ArrayIterator(this);\n  }\n  //...\n}\n\npublic class Demo {\n  public static void main(String[] args) {\n    List&lt;String&gt; names = new ArrayList&lt;&gt;();\n    names.add(&quot;a&quot;);\n    names.add(&quot;b&quot;);\n    names.add(&quot;c&quot;);\n    names.add(&quot;d&quot;);\n\n    Iterator&lt;String&gt; iterator = names.iterator();\n    iterator.next();\n    names.remove(&quot;a&quot;);\n  }\n}\n</code></pre><p>我们知道，ArrayList底层对应的是数组这种数据结构，在执行完第55行代码的时候，数组中存储的是a、b、c、d四个元素，迭代器的游标cursor指向元素a。当执行完第56行代码的时候，游标指向元素b，到这里都没有问题。</p><!-- [[[read_end]]] --><p>为了保持数组存储数据的连续性，数组的删除操作会涉及元素的搬移（详细的讲解你可以去看我的另一个专栏《数据结构与算法之美》）。当执行到第57行代码的时候，我们从数组中将元素a删除掉，b、c、d三个元素会依次往前搬移一位，这就会导致游标本来指向元素b，现在变成了指向元素c。原本在执行完第56行代码之后，我们还可以遍历到b、c、d三个元素，但在执行完第57行代码之后，我们只能遍历到c、d两个元素，b遍历不到了。</p><p>对于上面的描述，我画了一张图，你可以对照着理解。</p><p><img src=\"https://static001.geekbang.org/resource/image/d8/e9/d86223f2b0f996ebb2b21e5abbeceae9.jpg\" alt=\"\"></p><p>不过，如果第57行代码删除的不是游标前面的元素（元素a）以及游标所在位置的元素（元素b），而是游标后面的元素（元素c和d），这样就不会存在任何问题了，不会存在某个元素遍历不到的情况了。</p><p>所以，我们前面说，在遍历的过程中删除集合元素，结果是不可预期的，有时候没问题（删除元素c或d），有时候就有问题（删除元素a或b），这个要视情况而定（到底删除的是哪个位置的元素），就是这个意思。</p><p>在遍历的过程中删除集合元素，有可能会导致某个元素遍历不到，那在遍历的过程中添加集合元素，会发生什么情况呢？还是结合刚刚那个例子来讲解，我们将上面的代码稍微改造一下，把删除元素改为添加元素。具体的代码如下所示：</p><pre><code>public class Demo {\n  public static void main(String[] args) {\n    List&lt;String&gt; names = new ArrayList&lt;&gt;();\n    names.add(&quot;a&quot;);\n    names.add(&quot;b&quot;);\n    names.add(&quot;c&quot;);\n    names.add(&quot;d&quot;);\n\n    Iterator&lt;String&gt; iterator = names.iterator();\n    iterator.next();\n    names.add(0, &quot;x&quot;);\n  }\n}\n</code></pre><p>在执行完第10行代码之后，数组中包含a、b、c、d四个元素，游标指向b这个元素，已经跳过了元素a。在执行完第11行代码之后，我们将x插入到下标为0的位置，a、b、c、d四个元素依次往后移动一位。这个时候，游标又重新指向了元素a。元素a被游标重复指向两次，也就是说，元素a存在被重复遍历的情况。</p><p>跟删除情况类似，如果我们在游标的后面添加元素，就不会存在任何问题。所以，在遍历的同时添加集合元素也是一种不可预期行为。</p><p>同样，对于上面的添加元素的情况，我们也画了一张图，如下所示，你可以对照着理解。</p><p><img src=\"https://static001.geekbang.org/resource/image/4c/d2/4cd27c2dcdb2be169ef30194899c19d2.jpg\" alt=\"\"></p><h2>如何应对遍历时改变集合导致的未决行为？</h2><p>当通过迭代器来遍历集合的时候，增加、删除集合元素会导致不可预期的遍历结果。实际上，“不可预期”比直接出错更加可怕，有的时候运行正确，有的时候运行错误，一些隐藏很深、很难debug的bug就是这么产生的。那我们如何才能避免出现这种不可预期的运行结果呢？</p><p>有两种比较干脆利索的解决方案：一种是遍历的时候不允许增删元素，另一种是增删元素之后让遍历报错。</p><p>实际上，第一种解决方案比较难实现，我们要确定遍历开始和结束的时间点。遍历开始的时间节点我们很容易获得。我们可以把创建迭代器的时间点作为遍历开始的时间点。但是，遍历结束的时间点该如何来确定呢？</p><p>你可能会说，遍历到最后一个元素的时候就算结束呗。但是，在实际的软件开发中，每次使用迭代器来遍历元素，并不一定非要把所有元素都遍历一遍。如下所示，我们找到一个值为b的元素就提前结束了遍历。</p><pre><code>public class Demo {\n  public static void main(String[] args) {\n    List&lt;String&gt; names = new ArrayList&lt;&gt;();\n    names.add(&quot;a&quot;);\n    names.add(&quot;b&quot;);\n    names.add(&quot;c&quot;);\n    names.add(&quot;d&quot;);\n\n    Iterator&lt;String&gt; iterator = names.iterator();\n    while (iterator.hasNext()) {\n      String name = iterator.currentItem();\n      if (name.equals(&quot;b&quot;)) {\n        break;\n      }\n    }\n  }\n}\n</code></pre><p>你可能还会说，那我们可以在迭代器类中定义一个新的接口finishIteration()，主动告知容器迭代器使用完了，你可以增删元素了，示例代码如下所示。但是，这就要求程序员在使用完迭代器之后要主动调用这个函数，也增加了开发成本，还很容易漏掉。</p><pre><code>public class Demo {\n  public static void main(String[] args) {\n    List&lt;String&gt; names = new ArrayList&lt;&gt;();\n    names.add(&quot;a&quot;);\n    names.add(&quot;b&quot;);\n    names.add(&quot;c&quot;);\n    names.add(&quot;d&quot;);\n\n    Iterator&lt;String&gt; iterator = names.iterator();\n    while (iterator.hasNext()) {\n      String name = iterator.currentItem();\n      if (name.equals(&quot;b&quot;)) {\n        iterator.finishIteration();//主动告知容器这个迭代器用完了\n        break;\n      }\n    }\n  }\n}\n</code></pre><p>实际上，第二种解决方法更加合理。Java语言就是采用的这种解决方案，增删元素之后，让遍历报错。接下来，我们具体来看一下如何实现。</p><p>怎么确定在遍历时候，集合有没有增删元素呢？我们在ArrayList中定义一个成员变量modCount，记录集合被修改的次数，集合每调用一次增加或删除元素的函数，就会给modCount加1。当通过调用集合上的iterator()函数来创建迭代器的时候，我们把modCount值传递给迭代器的expectedModCount成员变量，之后每次调用迭代器上的hasNext()、next()、currentItem()函数，我们都会检查集合上的modCount是否等于expectedModCount，也就是看，在创建完迭代器之后，modCount是否改变过。</p><p>如果两个值不相同，那就说明集合存储的元素已经改变了，要么增加了元素，要么删除了元素，之前创建的迭代器已经不能正确运行了，再继续使用就会产生不可预期的结果，所以我们选择fail-fast解决方式，抛出运行时异常，结束掉程序，让程序员尽快修复这个因为不正确使用迭代器而产生的bug。</p><p>上面的描述翻译成代码就是下面这样子。你可以结合着代码一起理解我刚才的讲解。</p><pre><code>public class ArrayIterator implements Iterator {\n  private int cursor;\n  private ArrayList arrayList;\n  private int expectedModCount;\n\n  public ArrayIterator(ArrayList arrayList) {\n    this.cursor = 0;\n    this.arrayList = arrayList;\n    this.expectedModCount = arrayList.modCount;\n  }\n\n  @Override\n  public boolean hasNext() {\n    checkForComodification();\n    return cursor &lt; arrayList.size();\n  }\n\n  @Override\n  public void next() {\n    checkForComodification();\n    cursor++;\n  }\n\n  @Override\n  public Object currentItem() {\n    checkForComodification();\n    return arrayList.get(cursor);\n  }\n  \n  private void checkForComodification() {\n    if (arrayList.modCount != expectedModCount)\n        throw new ConcurrentModificationException();\n  }\n}\n\n//代码示例\npublic class Demo {\n  public static void main(String[] args) {\n    List&lt;String&gt; names = new ArrayList&lt;&gt;();\n    names.add(&quot;a&quot;);\n    names.add(&quot;b&quot;);\n    names.add(&quot;c&quot;);\n    names.add(&quot;d&quot;);\n\n    Iterator&lt;String&gt; iterator = names.iterator();\n    iterator.next();\n    names.remove(&quot;a&quot;);\n    iterator.next();//抛出ConcurrentModificationException异常\n  }\n}\n</code></pre><h2>如何在遍历的同时安全地删除集合元素？</h2><p>像Java语言，迭代器类中除了前面提到的几个最基本的方法之外，还定义了一个remove()方法，能够在遍历集合的同时，安全地删除集合中的元素。不过，需要说明的是，它并没有提供添加元素的方法。毕竟迭代器的主要作用是遍历，添加元素放到迭代器里本身就不合适。</p><p>我个人觉得，Java迭代器中提供的remove()方法还是比较鸡肋的，作用有限。它只能删除游标指向的前一个元素，而且一个next()函数之后，只能跟着最多一个remove()操作，多次调用remove()操作会报错。我还是通过一个例子来解释一下。</p><pre><code>public class Demo {\n  public static void main(String[] args) {\n    List&lt;String&gt; names = new ArrayList&lt;&gt;();\n    names.add(&quot;a&quot;);\n    names.add(&quot;b&quot;);\n    names.add(&quot;c&quot;);\n    names.add(&quot;d&quot;);\n\n    Iterator&lt;String&gt; iterator = names.iterator();\n    iterator.next();\n    iterator.remove();\n    iterator.remove(); //报错，抛出IllegalStateException异常\n  }\n}\n</code></pre><p>现在，我们一块来看下，为什么通过迭代器就能安全的删除集合中的元素呢？源码之下无秘密。我们来看下remove()函数是如何实现的，代码如下所示。稍微提醒一下，在Java实现中，迭代器类是容器类的内部类，并且next()函数不仅将游标后移一位，还会返回当前的元素。</p><pre><code>public class ArrayList&lt;E&gt; {\n  transient Object[] elementData;\n  private int size;\n\n  public Iterator&lt;E&gt; iterator() {\n    return new Itr();\n  }\n\n  private class Itr implements Iterator&lt;E&gt; {\n    int cursor;       // index of next element to return\n    int lastRet = -1; // index of last element returned; -1 if no such\n    int expectedModCount = modCount;\n\n    Itr() {}\n\n    public boolean hasNext() {\n      return cursor != size;\n    }\n\n    @SuppressWarnings(&quot;unchecked&quot;)\n    public E next() {\n      checkForComodification();\n      int i = cursor;\n      if (i &gt;= size)\n        throw new NoSuchElementException();\n      Object[] elementData = ArrayList.this.elementData;\n      if (i &gt;= elementData.length)\n        throw new ConcurrentModificationException();\n      cursor = i + 1;\n      return (E) elementData[lastRet = i];\n    }\n    \n    public void remove() {\n      if (lastRet &lt; 0)\n        throw new IllegalStateException();\n      checkForComodification();\n\n      try {\n        ArrayList.this.remove(lastRet);\n        cursor = lastRet;\n        lastRet = -1;\n        expectedModCount = modCount;\n      } catch (IndexOutOfBoundsException ex) {\n        throw new ConcurrentModificationException();\n      }\n    }\n  }\n}\n</code></pre><p>在上面的代码实现中，迭代器类新增了一个lastRet成员变量，用来记录游标指向的前一个元素。通过迭代器去删除这个元素的时候，我们可以更新迭代器中的游标和lastRet值，来保证不会因为删除元素而导致某个元素遍历不到。如果通过容器来删除元素，并且希望更新迭代器中的游标值来保证遍历不出错，我们就要维护这个容器都创建了哪些迭代器，每个迭代器是否还在使用等信息，代码实现就变得比较复杂了。</p><h2>重点回顾</h2><p>好了，今天的内容到此就讲完了。我们一块来总结回顾一下，你需要重点掌握的内容。</p><p>在通过迭代器来遍历集合元素的同时，增加或者删除集合中的元素，有可能会导致某个元素被重复遍历或遍历不到。不过，并不是所有情况下都会遍历出错，有的时候也可以正常遍历，所以，这种行为称为结果不可预期行为或者未决行为。实际上，“不可预期”比直接出错更加可怕，有的时候运行正确，有的时候运行错误，一些隐藏很深、很难debug的bug就是这么产生的。</p><p>有两种比较干脆利索的解决方案，来避免出现这种不可预期的运行结果。一种是遍历的时候不允许增删元素，另一种是增删元素之后让遍历报错。第一种解决方案比较难实现，因为很难确定迭代器使用结束的时间点。第二种解决方案更加合理。Java语言就是采用的这种解决方案。增删元素之后，我们选择fail-fast解决方式，让遍历操作直接抛出运行时异常。</p><p>像Java语言，迭代器类中除了前面提到的几个最基本的方法之外，还定义了一个remove()方法，能够在遍历集合的同时，安全地删除集合中的元素。</p><h2>课堂讨论</h2><p>1、基于文章中给出的Java迭代器的实现代码，如果一个容器对象同时创建了两个迭代器，一个迭代器调用了remove()方法删除了集合中的一个元素，那另一个迭代器是否还可用？或者，我换个问法，下面代码中的第13行的运行结果是什么？</p><pre><code>public class Demo {\n  public static void main(String[] args) {\n    List&lt;String&gt; names = new ArrayList&lt;&gt;();\n    names.add(&quot;a&quot;);\n    names.add(&quot;b&quot;);\n    names.add(&quot;c&quot;);\n    names.add(&quot;d&quot;);\n\n    Iterator&lt;String&gt; iterator1 = names.iterator();\n    Iterator&lt;String&gt; iterator2 = names.iterator();\n    iterator1.next();\n    iterator1.remove();\n    iterator2.next(); // 运行结果？\n  }\n}\n</code></pre><p>2、LinkedList底层基于链表，如果在遍历的同时，增加删除元素，会出现哪些不可预期的行为呢？</p><p>欢迎留言和我分享你的想法。如果有收获，欢迎你把这篇文章分享给你的朋友。</p>",
                "article_title": "66 | 迭代器模式（中）：遍历集合的同时，为什么不能增删集合元素？"
            },
            {
                "title": "67 | 迭代器模式（下）：如何设计实现一个支持“快照”功能的iterator？",
                "herf": "https://time.geekbang.org/column/article/221269",
                "id": "221269",
                "content": "<p>上两节课，我们学习了迭代器模式的原理、实现，并且分析了在遍历集合的同时增删集合元素，产生不可预期结果的原因以及应对策略。</p><p>今天，我们再来看这样一个问题：如何实现一个支持“快照”功能的迭代器？这个问题算是对上一节课内容的延伸思考，为的是帮你加深对迭代器模式的理解，也是对你分析、解决问题的一种锻炼。你可以把它当作一个面试题或者练习题，在看我的讲解之前，先试一试自己能否顺利回答上来。</p><p>话不多说，让我们正式开始今天的学习吧！</p><h2>问题描述</h2><p>我们先来介绍一下问题的背景：如何实现一个支持“快照”功能的迭代器模式？</p><p>理解这个问题最关键的是理解“快照”两个字。所谓“快照”，指我们为容器创建迭代器的时候，相当于给容器拍了一张快照（Snapshot）。之后即便我们增删容器中的元素，快照中的元素并不会做相应的改动。而迭代器遍历的对象是快照而非容器，这样就避免了在使用迭代器遍历的过程中，增删容器中的元素，导致的不可预期的结果或者报错。</p><p>接下来，我举一个例子来解释一下上面这段话。具体的代码如下所示。容器list中初始存储了3、8、2三个元素。尽管在创建迭代器iter1之后，容器list删除了元素3，只剩下8、2两个元素，但是，通过iter1遍历的对象是快照，而非容器list本身。所以，遍历的结果仍然是3、8、2。同理，iter2、iter3也是在各自的快照上遍历，输出的结果如代码中注释所示。</p><!-- [[[read_end]]] --><pre><code>List&lt;Integer&gt; list = new ArrayList&lt;&gt;();\nlist.add(3);\nlist.add(8);\nlist.add(2);\n\nIterator&lt;Integer&gt; iter1 = list.iterator();//snapshot: 3, 8, 2\nlist.remove(new Integer(2));//list：3, 8\nIterator&lt;Integer&gt; iter2 = list.iterator();//snapshot: 3, 8\nlist.remove(new Integer(3));//list：8\nIterator&lt;Integer&gt; iter3 = list.iterator();//snapshot: 3\n\n// 输出结果：3 8 2\nwhile (iter1.hasNext()) {\n  System.out.print(iter1.next() + &quot; &quot;);\n}\nSystem.out.println();\n\n// 输出结果：3 8\nwhile (iter2.hasNext()) {\n  System.out.print(iter1.next() + &quot; &quot;);\n}\nSystem.out.println();\n\n// 输出结果：8\nwhile (iter3.hasNext()) {\n  System.out.print(iter1.next() + &quot; &quot;);\n}\nSystem.out.println();\n</code></pre><p>如果由你来实现上面的功能，你会如何来做呢？下面是针对这个功能需求的骨架代码，其中包含ArrayList、SnapshotArrayIterator两个类。对于这两个类，我只定义了必须的几个关键接口，完整的代码实现我并没有给出。你可以试着去完善一下，然后再看我下面的讲解。</p><pre><code>public ArrayList&lt;E&gt; implements List&lt;E&gt; {\n  // TODO: 成员变量、私有函数等随便你定义\n  \n  @Override\n  public void add(E obj) {\n    //TODO: 由你来完善\n  }\n  \n  @Override\n  public void remove(E obj) {\n    // TODO: 由你来完善\n  }\n  \n  @Override\n  public Iterator&lt;E&gt; iterator() {\n    return new SnapshotArrayIterator(this);\n  }\n}\n\npublic class SnapshotArrayIterator&lt;E&gt; implements Iterator&lt;E&gt; {\n  // TODO: 成员变量、私有函数等随便你定义\n  \n  @Override\n  public boolean hasNext() {\n    // TODO: 由你来完善\n  }\n  \n  @Override\n  public E next() {//返回当前元素，并且游标后移一位\n    // TODO: 由你来完善\n  }\n}\n</code></pre><h2>解决方案一</h2><p>我们先来看最简单的一种解决办法。在迭代器类中定义一个成员变量snapshot来存储快照。每当创建迭代器的时候，都拷贝一份容器中的元素到快照中，后续的遍历操作都基于这个迭代器自己持有的快照来进行。具体的代码实现如下所示：</p><pre><code>public class SnapshotArrayIterator&lt;E&gt; implements Iterator&lt;E&gt; {\n  private int cursor;\n  private ArrayList&lt;E&gt; snapshot;\n\n  public SnapshotArrayIterator(ArrayList&lt;E&gt; arrayList) {\n    this.cursor = 0;\n    this.snapshot = new ArrayList&lt;&gt;();\n    this.snapshot.addAll(arrayList);\n  }\n\n  @Override\n  public boolean hasNext() {\n    return cursor &lt; snapshot.size();\n  }\n\n  @Override\n  public E next() {\n    E currentItem = snapshot.get(cursor);\n    cursor++;\n    return currentItem;\n  }\n}\n</code></pre><p>这个解决方案虽然简单，但代价也有点高。每次创建迭代器的时候，都要拷贝一份数据到快照中，会增加内存的消耗。如果一个容器同时有多个迭代器在遍历元素，就会导致数据在内存中重复存储多份。不过，庆幸的是，Java中的拷贝属于浅拷贝，也就是说，容器中的对象并非真的拷贝了多份，而只是拷贝了对象的引用而已。关于深拷贝、浅拷贝，我们在<a href=\"https://time.geekbang.org/column/article/200786\">第47讲</a>中有详细的讲解，你可以回过头去再看一下。</p><p>那有没有什么方法，既可以支持快照，又不需要拷贝容器呢？</p><h2>解决方案二</h2><p>我们再来看第二种解决方案。</p><p>我们可以在容器中，为每个元素保存两个时间戳，一个是添加时间戳addTimestamp，一个是删除时间戳delTimestamp。当元素被加入到集合中的时候，我们将addTimestamp设置为当前时间，将delTimestamp设置成最大长整型值（Long.MAX_VALUE）。当元素被删除时，我们将delTimestamp更新为当前时间，表示已经被删除。</p><p>注意，这里只是标记删除，而非真正将它从容器中删除。</p><p>同时，每个迭代器也保存一个迭代器创建时间戳snapshotTimestamp，也就是迭代器对应的快照的创建时间戳。当使用迭代器来遍历容器的时候，只有满足addTimestamp&lt;snapshotTimestamp&lt;delTimestamp的元素，才是属于这个迭代器的快照。</p><p>如果元素的addTimestamp&gt;snapshotTimestamp，说明元素在创建了迭代器之后才加入的，不属于这个迭代器的快照；如果元素的delTimestamp&lt;snapshotTimestamp，说明元素在创建迭代器之前就被删除掉了，也不属于这个迭代器的快照。</p><p>这样就在不拷贝容器的情况下，在容器本身上借助时间戳实现了快照功能。具体的代码实现如下所示。注意，我们没有考虑ArrayList的扩容问题，感兴趣的话，你可以自己完善一下。</p><pre><code>public class ArrayList&lt;E&gt; implements List&lt;E&gt; {\n  private static final int DEFAULT_CAPACITY = 10;\n\n  private int actualSize; //不包含标记删除元素\n  private int totalSize; //包含标记删除元素\n\n  private Object[] elements;\n  private long[] addTimestamps;\n  private long[] delTimestamps;\n\n  public ArrayList() {\n    this.elements = new Object[DEFAULT_CAPACITY];\n    this.addTimestamps = new long[DEFAULT_CAPACITY];\n    this.delTimestamps = new long[DEFAULT_CAPACITY];\n    this.totalSize = 0;\n    this.actualSize = 0;\n  }\n\n  @Override\n  public void add(E obj) {\n    elements[totalSize] = obj;\n    addTimestamps[totalSize] = System.currentTimeMillis();\n    delTimestamps[totalSize] = Long.MAX_VALUE;\n    totalSize++;\n    actualSize++;\n  }\n\n  @Override\n  public void remove(E obj) {\n    for (int i = 0; i &lt; totalSize; ++i) {\n      if (elements[i].equals(obj)) {\n        delTimestamps[i] = System.currentTimeMillis();\n        actualSize--;\n      }\n    }\n  }\n\n  public int actualSize() {\n    return this.actualSize;\n  }\n\n  public int totalSize() {\n    return this.totalSize;\n  }\n\n  public E get(int i) {\n    if (i &gt;= totalSize) {\n      throw new IndexOutOfBoundsException();\n    }\n    return (E)elements[i];\n  }\n\n  public long getAddTimestamp(int i) {\n    if (i &gt;= totalSize) {\n      throw new IndexOutOfBoundsException();\n    }\n    return addTimestamps[i];\n  }\n\n  public long getDelTimestamp(int i) {\n    if (i &gt;= totalSize) {\n      throw new IndexOutOfBoundsException();\n    }\n    return delTimestamps[i];\n  }\n}\n\npublic class SnapshotArrayIterator&lt;E&gt; implements Iterator&lt;E&gt; {\n  private long snapshotTimestamp;\n  private int cursorInAll; // 在整个容器中的下标，而非快照中的下标\n  private int leftCount; // 快照中还有几个元素未被遍历\n  private ArrayList&lt;E&gt; arrayList;\n\n  public SnapshotArrayIterator(ArrayList&lt;E&gt; arrayList) {\n    this.snapshotTimestamp = System.currentTimeMillis();\n    this.cursorInAll = 0;\n    this.leftCount = arrayList.actualSize();;\n    this.arrayList = arrayList;\n\n    justNext(); // 先跳到这个迭代器快照的第一个元素\n  }\n\n  @Override\n  public boolean hasNext() {\n    return this.leftCount &gt;= 0; // 注意是&gt;=, 而非&gt;\n  }\n\n  @Override\n  public E next() {\n    E currentItem = arrayList.get(cursorInAll);\n    justNext();\n    return currentItem;\n  }\n\n  private void justNext() {\n    while (cursorInAll &lt; arrayList.totalSize()) {\n      long addTimestamp = arrayList.getAddTimestamp(cursorInAll);\n      long delTimestamp = arrayList.getDelTimestamp(cursorInAll);\n      if (snapshotTimestamp &gt; addTimestamp &amp;&amp; snapshotTimestamp &lt; delTimestamp) {\n        leftCount--;\n        break;\n      }\n      cursorInAll++;\n    }\n  }\n}\n</code></pre><p>实际上，上面的解决方案相当于解决了一个问题，又引入了另外一个问题。ArrayList底层依赖数组这种数据结构，原本可以支持快速的随机访问，在O(1)时间复杂度内获取下标为i的元素，但现在，删除数据并非真正的删除，只是通过时间戳来标记删除，这就导致无法支持按照下标快速随机访问了。如果你对数组随机访问这块知识点不了解，可以去看我的《数据结构与算法之美》专栏，这里我就不展开讲解了。</p><p>现在，我们来看怎么解决这个问题：让容器既支持快照遍历，又支持随机访问？</p><p>解决的方法也不难，我稍微提示一下。我们可以在ArrayList中存储两个数组。一个支持标记删除的，用来实现快照遍历功能；一个不支持标记删除的（也就是将要删除的数据直接从数组中移除），用来支持随机访问。对应的代码我这里就不给出了，感兴趣的话你可以自己实现一下。</p><h2>重点回顾</h2><p>好了，今天的内容到此就讲完了。我们一块来总结回顾一下，你需要重点掌握的内容。</p><p>今天我们讲了如何实现一个支持“快照”功能的迭代器。其实这个问题本身并不是学习的重点，因为在真实的项目开发中，我们几乎不会遇到这样的需求。所以，基于今天的内容我不想做过多的总结。我想和你说一说，为什么我要来讲今天的内容呢？</p><p>实际上，学习本节课的内容，如果你只是从前往后看一遍，看懂就觉得ok了，那收获几乎是零。一个好学习方法是，把它当作一个思考题或者面试题，在看我的讲解之前，自己主动思考如何解决，并且把解决方案用代码实现一遍，然后再来看跟我的讲解有哪些区别。这个过程对你分析问题、解决问题的能力的锻炼，代码设计能力、编码能力的锻炼，才是最有价值的，才是我们这篇文章的意义所在。所谓“知识是死的，能力才是活的”就是这个道理。</p><p>其实，不仅仅是这一节的内容，整个专栏的学习都是这样的。</p><p>在《数据结构与算法之美》专栏中，有同学曾经对我说，他看了很多遍我的专栏，几乎看懂了所有的内容，他觉得都掌握了，但是，在最近第一次面试中，面试官给他出了一个结合实际开发的算法题，他还是没有思路，当时脑子一片放空，问我学完这个专栏之后，要想应付算法面试，还要学哪些东西，有没有推荐的书籍。</p><p>我看了他的面试题之后发现，用我专栏里讲的知识是完全可以解决的，而且，专栏里已经讲过类似的问题，只是换了个业务背景而已。之所以他没法回答上来，还是没有将知识转化成解决问题的能力，因为他只是被动地“看”，从来没有主动地“思考”。<strong>只掌握了知识，没锻炼能力，遇到实际的问题还是没法自己去分析、思考、解决</strong>。</p><p>我给他的建议是，把专栏里的每个开篇问题都当做面试题，自己去思考一下，然后再看解答。这样整个专栏学下来，对能力的锻炼就多了，再遇到算法面试也就不会一点思路都没有了。同理，学习《设计模式之美》这个专栏也应该如此。</p><h2>课堂讨论</h2><p>在今天讲的解决方案二中，删除元素只是被标记删除。被删除的元素即便在没有迭代器使用的情况下，也不会从数组中真正移除，这就会导致不必要的内存占用。针对这个问题，你有进一步优化的方法吗？</p><p>欢迎留言和我分享你的思考。如果有收获，欢迎你把这篇文章分享给你的朋友。</p>",
                "article_title": "67 | 迭代器模式（下）：如何设计实现一个支持“快照”功能的iterator？"
            },
            {
                "title": "68 | 访问者模式（上）：手把手带你还原访问者模式诞生的思维过程",
                "herf": "https://time.geekbang.org/column/article/221852",
                "id": "221852",
                "content": "<p>前面我们讲到，大部分设计模式的原理和实现都很简单，不过也有例外，比如今天要讲的访问者模式。它可以算是23种经典设计模式中最难理解的几个之一。因为它难理解、难实现，应用它会导致代码的可读性、可维护性变差，所以，访问者模式在实际的软件开发中很少被用到，在没有特别必要的情况下，建议你不要使用访问者模式。</p><p>尽管如此，为了让你以后读到应用了访问者模式的代码的时候，能一眼就能看出代码的设计意图，同时为了整个专栏内容的完整性，我觉得还是有必要给你讲一讲这个模式。除此之外，为了最大化学习效果，我今天不只是单纯地讲解原理和实现，更重要的是，我会手把手带你还原访问者模式诞生的思维过程，让你切身感受到创造一种新的设计模式出来并不是件难事。</p><p>话不多说，让我们正式开始今天的学习吧！</p><h2>带你“发明”访问者模式</h2><p>假设我们从网站上爬取了很多资源文件，它们的格式有三种：PDF、PPT、Word。我们现在要开发一个工具来处理这批资源文件。这个工具的其中一个功能是，把这些资源文件中的文本内容抽取出来放到txt文件中。如果让你来实现，你会怎么来做呢？</p><p>实现这个功能并不难，不同的人有不同的写法，我将其中一种代码实现方式贴在这里。其中，ResourceFile是一个抽象类，包含一个抽象函数extract2txt()。PdfFile、PPTFile、WordFile都继承ResourceFile类，并且重写了extract2txt()函数。在ToolApplication中，我们可以利用多态特性，根据对象的实际类型，来决定执行哪个方法。</p><!-- [[[read_end]]] --><pre><code>public abstract class ResourceFile {\n  protected String filePath;\n\n  public ResourceFile(String filePath) {\n    this.filePath = filePath;\n  }\n\n  public abstract void extract2txt();\n}\n\npublic class PPTFile extends ResourceFile {\n  public PPTFile(String filePath) {\n    super(filePath);\n  }\n\n  @Override\n  public void extract2txt() {\n    //...省略一大坨从PPT中抽取文本的代码...\n    //...将抽取出来的文本保存在跟filePath同名的.txt文件中...\n    System.out.println(&quot;Extract PPT.&quot;);\n  }\n}\n\npublic class PdfFile extends ResourceFile {\n  public PdfFile(String filePath) {\n    super(filePath);\n  }\n\n  @Override\n  public void extract2txt() {\n    //...\n    System.out.println(&quot;Extract PDF.&quot;);\n  }\n}\n\npublic class WordFile extends ResourceFile {\n  public WordFile(String filePath) {\n    super(filePath);\n  }\n\n  @Override\n  public void extract2txt() {\n    //...\n    System.out.println(&quot;Extract WORD.&quot;);\n  }\n}\n\n// 运行结果是：\n// Extract PDF.\n// Extract WORD.\n// Extract PPT.\npublic class ToolApplication {\n  public static void main(String[] args) {\n    List&lt;ResourceFile&gt; resourceFiles = listAllResourceFiles(args[0]);\n    for (ResourceFile resourceFile : resourceFiles) {\n      resourceFile.extract2txt();\n    }\n  }\n\n  private static List&lt;ResourceFile&gt; listAllResourceFiles(String resourceDirectory) {\n    List&lt;ResourceFile&gt; resourceFiles = new ArrayList&lt;&gt;();\n    //...根据后缀(pdf/ppt/word)由工厂方法创建不同的类对象(PdfFile/PPTFile/WordFile)\n    resourceFiles.add(new PdfFile(&quot;a.pdf&quot;));\n    resourceFiles.add(new WordFile(&quot;b.word&quot;));\n    resourceFiles.add(new PPTFile(&quot;c.ppt&quot;));\n    return resourceFiles;\n  }\n}\n</code></pre><p>如果工具的功能不停地扩展，不仅要能抽取文本内容，还要支持压缩、提取文件元信息（文件名、大小、更新时间等等）构建索引等一系列的功能，那如果我们继续按照上面的实现思路，就会存在这样几个问题：</p><ul>\n<li>违背开闭原则，添加一个新的功能，所有类的代码都要修改；</li>\n<li>虽然功能增多，每个类的代码都不断膨胀，可读性和可维护性都变差了；</li>\n<li>把所有比较上层的业务逻辑都耦合到PdfFile、PPTFile、WordFile类中，导致这些类的职责不够单一，变成了大杂烩。</li>\n</ul><p>针对上面的问题，我们常用的解决方法就是拆分解耦，把业务操作跟具体的数据结构解耦，设计成独立的类。这里我们按照访问者模式的演进思路来对上面的代码进行重构。重构之后的代码如下所示。</p><pre><code>public abstract class ResourceFile {\n  protected String filePath;\n  public ResourceFile(String filePath) {\n    this.filePath = filePath;\n  }\n}\n\npublic class PdfFile extends ResourceFile {\n  public PdfFile(String filePath) {\n    super(filePath);\n  }\n  //...\n}\n//...PPTFile、WordFile代码省略...\npublic class Extractor {\n  public void extract2txt(PPTFile pptFile) {\n    //...\n    System.out.println(&quot;Extract PPT.&quot;);\n  }\n\n  public void extract2txt(PdfFile pdfFile) {\n    //...\n    System.out.println(&quot;Extract PDF.&quot;);\n  }\n\n  public void extract2txt(WordFile wordFile) {\n    //...\n    System.out.println(&quot;Extract WORD.&quot;);\n  }\n}\n\npublic class ToolApplication {\n  public static void main(String[] args) {\n    Extractor extractor = new Extractor();\n    List&lt;ResourceFile&gt; resourceFiles = listAllResourceFiles(args[0]);\n    for (ResourceFile resourceFile : resourceFiles) {\n      extractor.extract2txt(resourceFile);\n    }\n  }\n\n  private static List&lt;ResourceFile&gt; listAllResourceFiles(String resourceDirectory) {\n    List&lt;ResourceFile&gt; resourceFiles = new ArrayList&lt;&gt;();\n    //...根据后缀(pdf/ppt/word)由工厂方法创建不同的类对象(PdfFile/PPTFile/WordFile)\n    resourceFiles.add(new PdfFile(&quot;a.pdf&quot;));\n    resourceFiles.add(new WordFile(&quot;b.word&quot;));\n    resourceFiles.add(new PPTFile(&quot;c.ppt&quot;));\n    return resourceFiles;\n  }\n}\n</code></pre><p>这其中最关键的一点设计是，我们把抽取文本内容的操作，设计成了三个重载函数。函数重载是Java、C++这类面向对象编程语言中常见的语法机制。所谓重载函数是指，在同一类中函数名相同、参数不同的一组函数。</p><p>不过，如果你足够细心，就会发现，上面的代码是编译通过不了的，第37行会报错。这是为什么呢？</p><p>我们知道，多态是一种动态绑定，可以在运行时获取对象的实际类型，来运行实际类型对应的方法。而函数重载是一种静态绑定，在编译时并不能获取对象的实际类型，而是根据声明类型执行声明类型对应的方法。</p><p>在上面代码的第35～38行中，resourceFiles包含的对象的声明类型都是ResourceFile，而我们并没有在Extractor类中定义参数类型是ResourceFile的extract2txt()重载函数，所以在编译阶段就通过不了，更别说在运行时根据对象的实际类型执行不同的重载函数了。那如何解决这个问题呢？</p><p>解决的办法稍微有点难理解，我们先来看代码，然后我再来给你慢慢解释。</p><pre><code>public abstract class ResourceFile {\n  protected String filePath;\n  public ResourceFile(String filePath) {\n    this.filePath = filePath;\n  }\n  abstract public void accept(Extractor extractor);\n}\n\npublic class PdfFile extends ResourceFile {\n  public PdfFile(String filePath) {\n    super(filePath);\n  }\n\n  @Override\n  public void accept(Extractor extractor) {\n    extractor.extract2txt(this);\n  }\n\n  //...\n}\n\n//...PPTFile、WordFile跟PdfFile类似，这里就省略了...\n//...Extractor代码不变...\n\npublic class ToolApplication {\n  public static void main(String[] args) {\n    Extractor extractor = new Extractor();\n    List&lt;ResourceFile&gt; resourceFiles = listAllResourceFiles(args[0]);\n    for (ResourceFile resourceFile : resourceFiles) {\n      resourceFile.accept(extractor);\n    }\n  }\n\n  private static List&lt;ResourceFile&gt; listAllResourceFiles(String resourceDirectory) {\n    List&lt;ResourceFile&gt; resourceFiles = new ArrayList&lt;&gt;();\n    //...根据后缀(pdf/ppt/word)由工厂方法创建不同的类对象(PdfFile/PPTFile/WordFile)\n    resourceFiles.add(new PdfFile(&quot;a.pdf&quot;));\n    resourceFiles.add(new WordFile(&quot;b.word&quot;));\n    resourceFiles.add(new PPTFile(&quot;c.ppt&quot;));\n    return resourceFiles;\n  }\n}\n</code></pre><p>在执行第30行的时候，根据多态特性，程序会调用实际类型的accept函数，比如PdfFile的accept函数，也就是第16行代码。而16行代码中的this类型是PdfFile的，在编译的时候就确定了，所以会调用extractor的extract2txt(PdfFile pdfFile)这个重载函数。这个实现思路是不是很有技巧？这是理解访问者模式的关键所在，也是我之前所说的访问者模式不好理解的原因。</p><p>现在，如果要继续添加新的功能，比如前面提到的压缩功能，根据不同的文件类型，使用不同的压缩算法来压缩资源文件，那我们该如何实现呢？我们需要实现一个类似Extractor类的新类Compressor类，在其中定义三个重载函数，实现对不同类型资源文件的压缩。除此之外，我们还要在每个资源文件类中定义新的accept重载函数。具体的代码如下所示：</p><pre><code>public abstract class ResourceFile {\n  protected String filePath;\n  public ResourceFile(String filePath) {\n    this.filePath = filePath;\n  }\n  abstract public void accept(Extractor extractor);\n  abstract public void accept(Compressor compressor);\n}\n\npublic class PdfFile extends ResourceFile {\n  public PdfFile(String filePath) {\n    super(filePath);\n  }\n\n  @Override\n  public void accept(Extractor extractor) {\n    extractor.extract2txt(this);\n  }\n\n  @Override\n  public void accept(Compressor compressor) {\n    compressor.compress(this);\n  }\n\n  //...\n}\n}\n//...PPTFile、WordFile跟PdfFile类似，这里就省略了...\n//...Extractor代码不变\n\npublic class ToolApplication {\n  public static void main(String[] args) {\n    Extractor extractor = new Extractor();\n    List&lt;ResourceFile&gt; resourceFiles = listAllResourceFiles(args[0]);\n    for (ResourceFile resourceFile : resourceFiles) {\n      resourceFile.accept(extractor);\n    }\n\n    Compressor compressor = new Compressor();\n    for(ResourceFile resourceFile : resourceFiles) {\n      resourceFile.accept(compressor);\n    }\n  }\n\n  private static List&lt;ResourceFile&gt; listAllResourceFiles(String resourceDirectory) {\n    List&lt;ResourceFile&gt; resourceFiles = new ArrayList&lt;&gt;();\n    //...根据后缀(pdf/ppt/word)由工厂方法创建不同的类对象(PdfFile/PPTFile/WordFile)\n    resourceFiles.add(new PdfFile(&quot;a.pdf&quot;));\n    resourceFiles.add(new WordFile(&quot;b.word&quot;));\n    resourceFiles.add(new PPTFile(&quot;c.ppt&quot;));\n    return resourceFiles;\n  }\n}\n</code></pre><p>上面代码还存在一些问题，添加一个新的业务，还是需要修改每个资源文件类，违反了开闭原则。针对这个问题，我们抽象出来一个Visitor接口，包含是三个命名非常通用的visit()重载函数，分别处理三种不同类型的资源文件。具体做什么业务处理，由实现这个Visitor接口的具体的类来决定，比如Extractor负责抽取文本内容，Compressor负责压缩。当我们新添加一个业务功能的时候，资源文件类不需要做任何修改，只需要修改ToolApplication的代码就可以了。</p><p>按照这个思路我们可以对代码进行重构，重构之后的代码如下所示：</p><pre><code>public abstract class ResourceFile {\n  protected String filePath;\n  public ResourceFile(String filePath) {\n    this.filePath = filePath;\n  }\n  abstract public void accept(Visitor vistor);\n}\n\npublic class PdfFile extends ResourceFile {\n  public PdfFile(String filePath) {\n    super(filePath);\n  }\n\n  @Override\n  public void accept(Visitor visitor) {\n    visitor.visit(this);\n  }\n\n  //...\n}\n//...PPTFile、WordFile跟PdfFile类似，这里就省略了...\n\npublic interface Visitor {\n  void visit(PdfFile pdfFile);\n  void visit(PPTFile pdfFile);\n  void visit(WordFile pdfFile);\n}\n\npublic class Extractor implements Visitor {\n  @Override\n  public void visit(PPTFile pptFile) {\n    //...\n    System.out.println(&quot;Extract PPT.&quot;);\n  }\n\n  @Override\n  public void visit(PdfFile pdfFile) {\n    //...\n    System.out.println(&quot;Extract PDF.&quot;);\n  }\n\n  @Override\n  public void visit(WordFile wordFile) {\n    //...\n    System.out.println(&quot;Extract WORD.&quot;);\n  }\n}\n\npublic class Compressor implements Visitor {\n  @Override\n  public void visit(PPTFile pptFile) {\n    //...\n    System.out.println(&quot;Compress PPT.&quot;);\n  }\n\n  @Override\n  public void visit(PdfFile pdfFile) {\n    //...\n    System.out.println(&quot;Compress PDF.&quot;);\n  }\n\n  @Override\n  public void visit(WordFile wordFile) {\n    //...\n    System.out.println(&quot;Compress WORD.&quot;);\n  }\n\n}\n\npublic class ToolApplication {\n  public static void main(String[] args) {\n    Extractor extractor = new Extractor();\n    List&lt;ResourceFile&gt; resourceFiles = listAllResourceFiles(args[0]);\n    for (ResourceFile resourceFile : resourceFiles) {\n      resourceFile.accept(extractor);\n    }\n\n    Compressor compressor = new Compressor();\n    for(ResourceFile resourceFile : resourceFiles) {\n      resourceFile.accept(compressor);\n    }\n  }\n\n  private static List&lt;ResourceFile&gt; listAllResourceFiles(String resourceDirectory) {\n    List&lt;ResourceFile&gt; resourceFiles = new ArrayList&lt;&gt;();\n    //...根据后缀(pdf/ppt/word)由工厂方法创建不同的类对象(PdfFile/PPTFile/WordFile)\n    resourceFiles.add(new PdfFile(&quot;a.pdf&quot;));\n    resourceFiles.add(new WordFile(&quot;b.word&quot;));\n    resourceFiles.add(new PPTFile(&quot;c.ppt&quot;));\n    return resourceFiles;\n  }\n}\n</code></pre><h2>重新来看访问者模式</h2><p>刚刚我带你一步一步还原了访问者模式诞生的思维过程，现在，我们回过头来总结一下，这个模式的原理和代码实现。</p><p>访问者者模式的英文翻译是Visitor Design Pattern。在GoF的《设计模式》一书中，它是这么定义的：</p><blockquote>\n<p>Allows for one or more operation to be applied to a set of objects at runtime, decoupling the operations from the object structure.</p>\n</blockquote><p>翻译成中文就是：允许一个或者多个操作应用到一组对象上，解耦操作和对象本身。</p><p>定义比较简单，结合前面的例子不难理解，我就不过多解释了。对于访问者模式的代码实现，实际上，在上面例子中，经过层层重构之后的最终代码，就是标准的访问者模式的实现代码。这里，我又总结了一张类图，贴在了下面，你可以对照着前面的例子代码一块儿来看一下。</p><p><img src=\"https://static001.geekbang.org/resource/image/c4/65/c42c636c5384da5bd5343618305db865.jpg\" alt=\"\"></p><p>最后，我们再来看下，访问者模式的应用场景。</p><p>一般来说，访问者模式针对的是一组类型不同的对象（PdfFile、PPTFile、WordFile）。不过，尽管这组对象的类型是不同的，但是，它们继承相同的父类（ResourceFile）或者实现相同的接口。在不同的应用场景下，\b我们需要对这组对象进行一系列不相关的业务操作（抽取文本、压缩等），但为了避免不断添加功能导致类（PdfFile、PPTFile、WordFile）不断膨胀，职责越来越不单一，以及避免频繁地添加功能导致的频繁代码修改，我们使用访问者模式，将对象与操作解耦，将这些业务操作抽离出来，定义在独立细分的访问者类（Extractor、Compressor）中。</p><h2>重点回顾</h2><p>好了，今天的内容到此就讲完了。我们一块来总结回顾一下，你需要重点掌握的内容。</p><p>访问者模式允许一个或者多个操作应用到一组对象上，设计意图是解耦操作和对象本身，保持类职责单一、满足开闭原则以及应对代码的复杂性。</p><p>对于访问者模式，学习的主要难点在代码实现。而代码实现比较复杂的主要原因是，函数重载在大部分面向对象编程语言中是静态绑定的。也就是说，调用类的哪个重载函数，是在编译期间，由参数的声明类型决定的，而非运行时，根据参数的实际类型决定的。</p><p>正是因为代码实现难理解，所以，在项目中应用这种模式，会导致代码的可读性比较差。如果你的同事不了解这种设计模式，可能就会读不懂、维护不了你写的代码。所以，除非不得已，不要使用这种模式。</p><h2>课堂讨论</h2><p>实际上，今天举的例子不用访问者模式也可以搞定，你能够想到其他实现思路吗？</p><p>欢迎留言和我分享你的想法。如果有收获，也欢迎你把这篇文章分享给你的朋友。</p>",
                "article_title": "68 | 访问者模式（上）：手把手带你还原访问者模式诞生的思维过程"
            },
            {
                "title": "69 | 访问者模式（下）：为什么支持双分派的语言不需要访问者模式？",
                "herf": "https://time.geekbang.org/column/article/222762",
                "id": "222762",
                "content": "<p>上一节课中，我们学习了访问者模式的原理和实现，并且还原了访问者模式诞生的思维过程。总体上来讲，这个模式的代码实现比较难，所以应用场景并不多。从应用开发的角度来说，它的确不是我们学习的重点。</p><p>不过，我们前面反复说过，学习我的专栏，并不只是让你掌握知识，更重要的是锻炼你分析、解决问题的能力，锻炼你的逻辑思维能力，所以，今天我们继续把访问者模式作为引子，一块讨论一下这样两个问题，希望能激发你的深度思考：</p><ul>\n<li>为什么支持双分派的语言不需要访问者模式呢？</li>\n<li>除了访问者模式，上一节课中的例子还有其他实现方案吗？</li>\n</ul><p>话不多说，让我们正式开始今天的学习吧！</p><h2>为什么支持双分派的语言不需要访问者模式？</h2><p>实际上，讲到访问者模式，大部分书籍或者资料都会讲到Double Dispatch，中文翻译为双分派。虽然学习访问者模式，并不用非得理解这个概念，我们前面的讲解就没有提到它，但是，为了让你在查看其它书籍或者资料的时候，不会卡在这个概念上，我觉得有必要在这里讲一下。</p><p>除此之外，我觉得，学习Double Dispatch还能加深你对访问者模式的理解，而且能一并帮你搞清楚今天文章标题中的这个问题：为什么支持双分派的语言就不需要访问者模式？这个问题在面试中可是会被问到的哦！</p><!-- [[[read_end]]] --><p>既然有Double Dispatch，对应的就有Single Dispatch。所谓<strong>Single Dispatch</strong>，指的是执行哪个对象的方法，根据对象的运行时类型来决定；执行对象的哪个方法，根据方法参数的编译时类型来决定。所谓<strong>Double Dispatch</strong>，指的是执行哪个对象的方法，根据对象的运行时类型来决定；执行对象的哪个方法，根据方法参数的运行时类型来决定。</p><p><strong>如何理解“Dispatch”这个单词呢？</strong> 在面向对象编程语言中，我们可以把方法调用理解为一种消息传递，也就是“Dispatch”。一个对象调用另一个对象的方法，就相当于给它发送一条消息。这条消息起码要包含对象名、方法名、方法参数。</p><p><strong>如何理解“Single”“Double”这两个单词呢？</strong>“Single”“Double”指的是执行哪个对象的哪个方法，跟几个因素的运行时类型有关。我们进一步解释一下。Single Dispatch之所以称为“Single”，是因为执行哪个对象的哪个方法，只跟“对象”的运行时类型有关。Double Dispatch之所以称为“Double”，是因为执行哪个对象的哪个方法，跟“对象”和“方法参数”两者的运行时类型有关。</p><p>具体到编程语言的语法机制，Single Dispatch和Double Dispatch跟多态和函数重载直接相关。当前主流的面向对象编程语言（比如，Java、C++、C#）都只支持Single Dispatch，不支持Double Dispatch。</p><p>接下来，我们拿Java语言来举例说明一下。</p><p>Java支持多态特性，代码可以在运行时获得对象的实际类型（也就是前面提到的运行时类型），然后根据实际类型决定调用哪个方法。尽管Java支持函数重载，但Java设计的函数重载的语法规则是，并不是在运行时，根据传递进函数的参数的实际类型，来决定调用哪个重载函数，而是在编译时，根据传递进函数的参数的声明类型（也就是前面提到的编译时类型），来决定调用哪个重载函数。也就是说，具体执行哪个对象的哪个方法，只跟对象的运行时类型有关，跟参数的运行时类型无关。所以，Java语言只支持Single Dispatch。</p><p>这么说比较抽象，我举个例子来具体说明一下，代码如下所示：</p><pre><code>public class ParentClass {\n  public void f() {\n    System.out.println(&quot;I am ParentClass's f().&quot;);\n  }\n}\n\npublic class ChildClass extends ParentClass {\n  public void f() {\n    System.out.println(&quot;I am ChildClass's f().&quot;);\n  }\n}\n\npublic class SingleDispatchClass {\n  public void polymorphismFunction(ParentClass p) {\n    p.f();\n  }\n\n  public void overloadFunction(ParentClass p) {\n    System.out.println(&quot;I am overloadFunction(ParentClass p).&quot;);\n  }\n\n  public void overloadFunction(ChildClass c) {\n    System.out.println(&quot;I am overloadFunction(ChildClass c).&quot;);\n  }\n}\n\npublic class DemoMain {\n  public static void main(String[] args) {\n    SingleDispatchClass demo = new SingleDispatchClass();\n    ParentClass p = new ChildClass();\n    demo.polymorphismFunction(p);//执行哪个对象的方法，由对象的实际类型决定\n    demo.overloadFunction(p);//执行对象的哪个方法，由参数对象的声明类型决定\n  }\n}\n\n//代码执行结果:\nI am ChildClass's f().\nI am overloadFunction(ParentClass p).\n</code></pre><p>在上面的代码中，第31行代码的polymorphismFunction()函数，执行p的实际类型的f()函数，也就是ChildClass的f()函数。第32行代码的overloadFunction()函数，匹配的是重载函数中的overloadFunction(ParentClass p)，也就是根据p的声明类型来决定匹配哪个重载函数。</p><p>假设Java语言支持Double Dispatch，那下面的代码（摘抄自上节课中第二段代码，建议结合上节课的讲解一块理解）中的第37行就不会报错。代码会在运行时，根据参数（resourceFile）的实际类型（PdfFile、PPTFile、WordFile），来决定使用extract2txt的三个重载函数中的哪一个。那下面的代码实现就能正常运行了，也就不需要访问者模式了。这也回答了为什么支持Double Dispatch的语言不需要访问者模式。</p><pre><code>public abstract class ResourceFile {\n  protected String filePath;\n  public ResourceFile(String filePath) {\n    this.filePath = filePath;\n  }\n}\n\npublic class PdfFile extends ResourceFile {\n  public PdfFile(String filePath) {\n    super(filePath);\n  }\n  //...\n}\n//...PPTFile、WordFile代码省略...\npublic class Extractor {\n  public void extract2txt(PPTFile pptFile) {\n    //...\n    System.out.println(&quot;Extract PPT.&quot;);\n  }\n\n  public void extract2txt(PdfFile pdfFile) {\n    //...\n    System.out.println(&quot;Extract PDF.&quot;);\n  }\n\n  public void extract2txt(WordFile wordFile) {\n    //...\n    System.out.println(&quot;Extract WORD.&quot;);\n  }\n}\n\npublic class ToolApplication {\n  public static void main(String[] args) {\n    Extractor extractor = new Extractor();\n    List&lt;ResourceFile&gt; resourceFiles = listAllResourceFiles(args[0]);\n    for (ResourceFile resourceFile : resourceFiles) {\n      extractor.extract2txt(resourceFile);\n    }\n  }\n\n  private static List&lt;ResourceFile&gt; listAllResourceFiles(String resourceDirectory) {\n    List&lt;ResourceFile&gt; resourceFiles = new ArrayList&lt;&gt;();\n    //...根据后缀(pdf/ppt/word)由工厂方法创建不同的类对象(PdfFile/PPTFile/WordFile)\n    resourceFiles.add(new PdfFile(&quot;a.pdf&quot;));\n    resourceFiles.add(new WordFile(&quot;b.word&quot;));\n    resourceFiles.add(new PPTFile(&quot;c.ppt&quot;));\n    return resourceFiles;\n  }\n}\n</code></pre><h2>除了访问者模式，上一节的例子还有其他实现方案吗？</h2><p>上节课，我通过一个例子来给你展示了，访问者模式是如何一步一步设计出来的。我们这里再一块回顾一下那个例子。我们从网站上爬取了很多资源文件，它们的格式有三种：PDF、PPT、Word。我们要开发一个工具来处理这批资源文件，这其中就包含抽取文本内容、压缩资源文件、提取文件元信息等。</p><p>实际上，开发这个工具有很多种代码设计和实现思路。为了讲解访问者模式，上节课我们选择了用访问者模式来实现。实际上，我们还有其他的实现方法，比如，我们还可以利用工厂模式来实现，定义一个包含extract2txt()接口函数的Extractor接口。PdfExtractor、PPTExtractor、WordExtractor类实现Extractor接口，并且在各自的extract2txt()函数中，分别实现Pdf、PPT、Word格式文件的文本内容抽取。ExtractorFactory工厂类根据不同的文件类型，返回不同的Extractor。</p><p>这个实现思路其实更加简单，我们直接看代码。</p><pre><code>public abstract class ResourceFile {\n  protected String filePath;\n  public ResourceFile(String filePath) {\n    this.filePath = filePath;\n  }\n  public abstract ResourceFileType getType();\n}\n\npublic class PdfFile extends ResourceFile {\n  public PdfFile(String filePath) {\n    super(filePath);\n  }\n\n  @Override\n  public ResourceFileType getType() {\n    return ResourceFileType.PDF;\n  }\n\n  //...\n}\n\n//...PPTFile/WordFile跟PdfFile代码结构类似，此处省略...\n\npublic interface Extractor {\n  void extract2txt(ResourceFile resourceFile);\n}\n\npublic class PdfExtractor implements Extractor {\n  @Override\n  public void extract2txt(ResourceFile resourceFile) {\n    //...\n  }\n}\n\n//...PPTExtractor/WordExtractor跟PdfExtractor代码结构类似，此处省略...\n\npublic class ExtractorFactory {\n  private static final Map&lt;ResourceFileType, Extractor&gt; extractors = new HashMap&lt;&gt;();\n  static {\n    extractors.put(ResourceFileType.PDF, new PdfExtractor());\n    extractors.put(ResourceFileType.PPT, new PPTExtractor());\n    extractors.put(ResourceFileType.WORD, new WordExtractor());\n  }\n\n  public static Extractor getExtractor(ResourceFileType type) {\n    return extractors.get(type);\n  }\n}\n\npublic class ToolApplication {\n  public static void main(String[] args) {\n    List&lt;ResourceFile&gt; resourceFiles = listAllResourceFiles(args[0]);\n    for (ResourceFile resourceFile : resourceFiles) {\n      Extractor extractor = ExtractorFactory.getExtractor(resourceFile.getType());\n      extractor.extract2txt(resourceFile);\n    }\n  }\n\n  private static List&lt;ResourceFile&gt; listAllResourceFiles(String resourceDirectory) {\n    List&lt;ResourceFile&gt; resourceFiles = new ArrayList&lt;&gt;();\n    //...根据后缀(pdf/ppt/word)由工厂方法创建不同的类对象(PdfFile/PPTFile/WordFile)\n    resourceFiles.add(new PdfFile(&quot;a.pdf&quot;));\n    resourceFiles.add(new WordFile(&quot;b.word&quot;));\n    resourceFiles.add(new PPTFile(&quot;c.ppt&quot;));\n    return resourceFiles;\n  }\n}\n</code></pre><p>当需要添加新的功能的时候，比如压缩资源文件，类似抽取文本内容功能的代码实现，我们只需要添加一个Compressor接口，PdfCompressor、PPTCompressor、WordCompressor三个实现类，以及创建它们的CompressorFactory工厂类即可。唯一需要修改的只有最上层的ToolApplication类。基本上符合“对扩展开放、对修改关闭”的设计原则。</p><p>对于资源文件处理工具这个例子，如果工具提供的功能并不是非常多，只有几个而已，那我更推荐使用工厂模式的实现方式，毕竟代码更加清晰、易懂。相反，如果工具提供非常多的功能，比如有十几个，那我更推荐使用访问者模式，因为访问者模式需要定义的类要比工厂模式的实现方式少很多，类太多也会影响到代码的可维护性。</p><h2>重点回顾</h2><p>好了，今天内容到此就讲完了。我们一块来总结回顾一下，你需要重点掌握的内容。</p><p>总体上来讲，访问者模式难以理解，应用场景有限，不是特别必需，我不建议在项目中使用它。所以，对于上节课中的处理资源文件的例子，我更推荐使用工厂模式来设计和实现。</p><p>除此之外，我们今天重点讲解了Double Dispatch。在面向对象编程语言中，方法调用可以理解为一种消息传递（Dispatch）。一个对象调用另一个对象的方法，就相当于给它发送一条消息，这条消息起码要包含对象名、方法名和方法参数。</p><p>所谓Single Dispatch，指的是执行哪个对象的方法，根据对象的运行时类型来决定；执行对象的哪个方法，根据方法参数的编译时类型来决定。所谓Double Dispatch，指的是执行哪个对象的方法，根据对象的运行时类型来决定；执行对象的哪个方法，根据方法参数的运行时类型来决定。</p><p>具体到编程语言的语法机制，Single Dispatch和Double Dispatch跟多态和函数重载直接相关。当前主流的面向对象编程语言（比如，Java、C++、C#）都只支持Single Dispatch，不支持Double Dispatch。</p><h2>课堂讨论</h2><ol>\n<li>访问者模式将操作与对象分离，是否违背面向对象设计原则？你怎么看待这个问题呢？</li>\n<li>在解释Single Dispatch的代码示例中，如果我们把SingleDispatchClass的代码改成下面这样，其他代码不变，那DemoMain的输出结果会是什么呢？为什么会是这样的结果呢？</li>\n</ol><pre><code>public class SingleDispatchClass {\n  public void polymorphismFunction(ParentClass p) {\n    p.f();\n  }\n\n  public void overloadFunction(ParentClass p) {\n    p.f();\n  }\n\n  public void overloadFunction(ChildClass c) {\n    c.f();\n  }\n}\n</code></pre><p>欢迎留言和我分享你的想法。如果有收获，也欢迎你把这篇文章分享给你的朋友。</p>",
                "article_title": "69 | 访问者模式（下）：为什么支持双分派的语言不需要访问者模式？"
            },
            {
                "title": "70 | 备忘录模式：对于大对象的备份和恢复，如何优化内存和时间的消耗？",
                "herf": "https://time.geekbang.org/column/article/223947",
                "id": "223947",
                "content": "<p>上两节课，我们学习了访问者模式。在23种设计模式中，访问者模式的原理和实现可以说是最难理解的了，特别是它的代码实现。其中，用Single Dispatch来模拟Double Dispatch的实现思路尤其不好理解。不知道你有没有将它拿下呢？如果还没有弄得很清楚，那就要多看几遍、多自己动脑经琢磨一下。</p><p>今天，我们学习另外一种行为型模式，备忘录模式。这个模式理解、掌握起来不难，代码实现比较灵活，应用场景也比较明确和有限，主要是用来防丢失、撤销、恢复等。所以，相对于上两节课，今天的内容学起来相对会比较轻松些。</p><p>话不多说，让我们正式开始今天的学习吧！</p><h2>备忘录模式的原理与实现</h2><p>备忘录模式，也叫快照（Snapshot）模式，英文翻译是Memento Design Pattern。在GoF的《设计模式》一书中，备忘录模式是这么定义的：</p><blockquote>\n<p>Captures and externalizes an object’s internal state so that it can be restored later, all without violating encapsulation.</p>\n</blockquote><p>翻译成中文就是：在不违背封装原则的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，以便之后恢复对象为先前的状态。</p><!-- [[[read_end]]] --><p>在我看来，这个模式的定义主要表达了两部分内容。一部分是，存储副本以便后期恢复。这一部分很好理解。另一部分是，要在不违背封装原则的前提下，进行对象的备份和恢复。这部分不太好理解。接下来，我就结合一个例子来解释一下，特别带你搞清楚这两个问题：</p><ul>\n<li>为什么存储和恢复副本会违背封装原则？</li>\n<li>备忘录模式是如何做到不违背封装原则的？</li>\n</ul><p>假设有这样一道面试题，希望你编写一个小程序，可以接收命令行的输入。用户输入文本时，程序将其追加存储在内存文本中；用户输入“:list”，程序在命令行中输出内存文本的内容；用户输入“:undo”，程序会撤销上一次输入的文本，也就是从内存文本中将上次输入的文本删除掉。</p><p>我举了个小例子来解释一下这个需求，如下所示：</p><pre><code>&gt;hello\n&gt;:list\nhello\n&gt;world\n&gt;:list\nhelloworld\n&gt;:undo\n&gt;:list\nhello\n</code></pre><p>怎么来编程实现呢？你可以打开IDE自己先试着编写一下，然后再看我下面的讲解。整体上来讲，这个小程序实现起来并不复杂。我写了一种实现思路，如下所示：</p><pre><code>public class InputText {\n  private StringBuilder text = new StringBuilder();\n\n  public String getText() {\n    return text.toString();\n  }\n\n  public void append(String input) {\n    text.append(input);\n  }\n\n  public void setText(String text) {\n    this.text.replace(0, this.text.length(), text);\n  }\n}\n\npublic class SnapshotHolder {\n  private Stack&lt;InputText&gt; snapshots = new Stack&lt;&gt;();\n\n  public InputText popSnapshot() {\n    return snapshots.pop();\n  }\n\n  public void pushSnapshot(InputText inputText) {\n    InputText deepClonedInputText = new InputText();\n    deepClonedInputText.setText(inputText.getText());\n    snapshots.push(deepClonedInputText);\n  }\n}\n\npublic class ApplicationMain {\n  public static void main(String[] args) {\n    InputText inputText = new InputText();\n    SnapshotHolder snapshotsHolder = new SnapshotHolder();\n    Scanner scanner = new Scanner(System.in);\n    while (scanner.hasNext()) {\n      String input = scanner.next();\n      if (input.equals(&quot;:list&quot;)) {\n        System.out.println(inputText.getText());\n      } else if (input.equals(&quot;:undo&quot;)) {\n        InputText snapshot = snapshotsHolder.popSnapshot();\n        inputText.setText(snapshot.getText());\n      } else {\n        snapshotsHolder.pushSnapshot(inputText);\n        inputText.append(input);\n      }\n    }\n  }\n}\n</code></pre><p>实际上，备忘录模式的实现很灵活，也没有很固定的实现方式，在不同的业务需求、不同编程语言下，代码实现可能都不大一样。上面的代码基本上已经实现了最基本的备忘录的功能。但是，如果我们深究一下的话，还有一些问题要解决，那就是前面定义中提到的第二点：要在不违背封装原则的前提下，进行对象的备份和恢复。而上面的代码并不满足这一点，主要体现在下面两方面：</p><ul>\n<li>第一，为了能用快照恢复InputText对象，我们在InputText类中定义了setText()函数，但这个函数有可能会被其他业务使用，所以，暴露不应该暴露的函数违背了封装原则；</li>\n<li>第二，快照本身是不可变的，理论上讲，不应该包含任何set()等修改内部状态的函数，但在上面的代码实现中，“快照“这个业务模型复用了InputText类的定义，而InputText类本身有一系列修改内部状态的函数，所以，用InputText类来表示快照违背了封装原则。</li>\n</ul><p>针对以上问题，我们对代码做两点修改。其一，定义一个独立的类（Snapshot类）来表示快照，而不是复用InputText类。这个类只暴露get()方法，没有set()等任何修改内部状态的方法。其二，在InputText类中，我们把setText()方法重命名为restoreSnapshot()方法，用意更加明确，只用来恢复对象。</p><p>按照这个思路，我们对代码进行重构。重构之后的代码如下所示：</p><pre><code>public class InputText {\n  private StringBuilder text = new StringBuilder();\n\n  public String getText() {\n    return text.toString();\n  }\n\n  public void append(String input) {\n    text.append(input);\n  }\n\n  public Snapshot createSnapshot() {\n    return new Snapshot(text.toString());\n  }\n\n  public void restoreSnapshot(Snapshot snapshot) {\n    this.text.replace(0, this.text.length(), snapshot.getText());\n  }\n}\n\npublic class Snapshot {\n  private String text;\n\n  public Snapshot(String text) {\n    this.text = text;\n  }\n\n  public String getText() {\n    return this.text;\n  }\n}\n\npublic class SnapshotHolder {\n  private Stack&lt;Snapshot&gt; snapshots = new Stack&lt;&gt;();\n\n  public Snapshot popSnapshot() {\n    return snapshots.pop();\n  }\n\n  public void pushSnapshot(Snapshot snapshot) {\n    snapshots.push(snapshot);\n  }\n}\n\npublic class ApplicationMain {\n  public static void main(String[] args) {\n    InputText inputText = new InputText();\n    SnapshotHolder snapshotsHolder = new SnapshotHolder();\n    Scanner scanner = new Scanner(System.in);\n    while (scanner.hasNext()) {\n      String input = scanner.next();\n      if (input.equals(&quot;:list&quot;)) {\n        System.out.println(inputText.toString());\n      } else if (input.equals(&quot;:undo&quot;)) {\n        Snapshot snapshot = snapshotsHolder.popSnapshot();\n        inputText.restoreSnapshot(snapshot);\n      } else {\n        snapshotsHolder.pushSnapshot(inputText.createSnapshot());\n        inputText.append(input);\n      }\n    }\n  }\n}\n</code></pre><p>实际上，上面的代码实现就是典型的备忘录模式的代码实现，也是很多书籍（包括GoF的《设计模式》）中给出的实现方法。</p><p>除了备忘录模式，还有一个跟它很类似的概念，“备份”，它在我们平时的开发中更常听到。那备忘录模式跟“备份”有什么区别和联系呢？实际上，这两者的应用场景很类似，都应用在防丢失、恢复、撤销等场景中。它们的区别在于，备忘录模式更侧重于代码的设计和实现，备份更侧重架构设计或产品设计。这个不难理解，这里我就不多说了。</p><h2>如何优化内存和时间消耗？</h2><p>前面我们只是简单介绍了备忘录模式的原理和经典实现，现在我们再继续深挖一下。如果要备份的对象数据比较大，备份频率又比较高，那快照占用的内存会比较大，备份和恢复的耗时会比较长。这个问题该如何解决呢？</p><p>不同的应用场景下有不同的解决方法。比如，我们前面举的那个例子，应用场景是利用备忘录来实现撤销操作，而且仅仅支持顺序撤销，也就是说，每次操作只能撤销上一次的输入，不能跳过上次输入撤销之前的输入。在具有这样特点的应用场景下，为了节省内存，我们不需要在快照中存储完整的文本，只需要记录少许信息，比如在获取快照当下的文本长度，用这个值结合InputText类对象存储的文本来做撤销操作。</p><p>我们再举一个例子。假设每当有数据改动，我们都需要生成一个备份，以备之后恢复。如果需要备份的数据很大，这样高频率的备份，不管是对存储（内存或者硬盘）的消耗，还是对时间的消耗，都可能是无法接受的。想要解决这个问题，我们一般会采用“低频率全量备份”和“高频率增量备份”相结合的方法。</p><p>全量备份就不用讲了，它跟我们上面的例子类似，就是把所有的数据“拍个快照”保存下来。所谓“增量备份”，指的是记录每次操作或数据变动。</p><p>当我们需要恢复到某一时间点的备份的时候，如果这一时间点有做全量备份，我们直接拿来恢复就可以了。如果这一时间点没有对应的全量备份，我们就先找到最近的一次全量备份，然后用它来恢复，之后执行此次全量备份跟这一时间点之间的所有增量备份，也就是对应的操作或者数据变动。这样就能减少全量备份的数量和频率，减少对时间、内存的消耗。</p><h2>重点回顾</h2><p>好了，今天的内容到此就讲完了。我们一块来总结回顾一下，你需要重点掌握的内容。</p><p>备忘录模式也叫快照模式，具体来说，就是在不违背封装原则的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，以便之后恢复对象为先前的状态。这个模式的定义表达了两部分内容：一部分是，存储副本以便后期恢复；另一部分是，要在不违背封装原则的前提下，进行对象的备份和恢复。</p><p>备忘录模式的应用场景也比较明确和有限，主要是用来防丢失、撤销、恢复等。它跟平时我们常说的“备份”很相似。两者的主要区别在于，备忘录模式更侧重于代码的设计和实现，备份更侧重架构设计或产品设计。</p><p>对于大对象的备份来说，备份占用的存储空间会比较大，备份和恢复的耗时会比较长。针对这个问题，不同的业务场景有不同的处理方式。比如，只备份必要的恢复信息，结合最新的数据来恢复；再比如，全量备份和增量备份相结合，低频全量备份，高频增量备份，两者结合来做恢复。</p><h2>课堂讨论</h2><p>今天我们讲到，备份在架构或产品设计中比较常见，比如，重启Chrome可以选择恢复之前打开的页面，你还能想到其他类似的应用场景吗？</p><p>欢迎留言和我分享你的想法。如果有收获，也欢迎你把这篇文章分享给你的朋友。</p>",
                "article_title": "70 | 备忘录模式：对于大对象的备份和恢复，如何优化内存和时间的消耗？"
            },
            {
                "title": "71 | 命令模式：如何利用命令模式实现一个手游后端架构？",
                "herf": "https://time.geekbang.org/column/article/224549",
                "id": "224549",
                "content": "<p>设计模式模块已经接近尾声了，现在我们只剩下3个模式还没有学习，它们分别是：命令模式、解释器模式、中介模式。这3个模式使用频率低、理解难度大，只在非常特定的应用场景下才会用到，所以，不是我们学习的重点，你只需要稍微了解，见了能认识就可以了。</p><p>今天呢，我们来学习其中的命令模式。在学习这个模式的过程中，你可能会遇到的最大的疑惑是，感觉命令模式没啥用，是一种过度设计，有更加简单的设计思路可以替代。所以，我今天讲解的重点是这个模式的设计意图，带你搞清楚到底什么情况下才真正需要使用它。</p><p>话不多说，让我们正式开始今天的学习吧！</p><h2>命令模式的原理解读</h2><p>命令模式的英文翻译是Command Design Pattern。在GoF的《设计模式》一书中，它是这么定义的：</p><blockquote>\n<p>The command pattern encapsulates a request as an object, thereby letting us parameterize other objects with different requests, queue or log requests, and support undoable operations.</p>\n</blockquote><p>翻译成中文就是下面这样。为了帮助你理解，我对这个翻译稍微做了补充和解释，也一起放在了下面的括号中。</p><!-- [[[read_end]]] --><p>命令模式将请求（命令）封装为一个对象，这样可以使用不同的请求参数化其他对象（将不同请求依赖注入到其他对象），并且能够支持请求（命令）的排队执行、记录日志、撤销等（附加控制）功能。</p><p>对于GoF给出的定义，我这里再进一步解读一下。</p><p>落实到编码实现，命令模式用的最核心的实现手段，是将函数封装成对象。我们知道，C语言支持函数指针，我们可以把函数当作变量传递来传递去。但是，在大部分编程语言中，函数没法儿作为参数传递给其他函数，也没法儿赋值给变量。借助命令模式，我们可以将函数封装成对象。具体来说就是，设计一个包含这个函数的类，实例化一个对象传来传去，这样就可以实现把函数像对象一样使用。从实现的角度来说，它类似我们之前讲过的回调。</p><p>当我们把函数封装成对象之后，对象就可以存储下来，方便控制执行。所以，命令模式的主要作用和应用场景，是用来控制命令的执行，比如，异步、延迟、排队执行命令、撤销重做命令、存储命令、给命令记录日志等等，这才是命令模式能发挥独一无二作用的地方。</p><h2>命令模式的实战讲解</h2><p>上面的讲解比较偏理论，比较不好理解，我这里再结合一个具体的例子来解释一下。</p><p>假设我们正在开发一个类似《天天酷跑》或者《QQ卡丁车》这样的手游。这种游戏本身的复杂度集中在客户端。后端基本上只负责数据（比如积分、生命值、装备）的更新和查询，所以，后端逻辑相对于客户端来说，要简单很多。</p><p>考虑到你可能对游戏开发不熟悉，我这里稍微交代一些背景知识。</p><p>为了提高性能，我们会把游戏中玩家的信息保存在内存中。在游戏进行的过程中，只更新内存中的数据，游戏结束之后，再将内存中的数据存档，也就是持久化到数据库中。为了降低实现的难度，一般来说，同一个游戏场景里的玩家，会被分配到同一台服务上。这样，一个玩家拉取同一个游戏场景中的其他玩家的信息，就不需要跨服务器去查找了，实现起来就简单了很多。</p><p>一般来说，游戏客户端和服务器之间的数据交互是比较频繁的，所以，为了节省网络连接建立的开销，客户端和服务器之间一般采用长连接的方式来通信。通信的格式有多种，比如Protocol Buffer、JSON、XML，甚至可以自定义格式。不管是什么格式，客户端发送给服务器的请求，一般都包括两部分内容：指令和数据。其中，指令我们也可以叫作事件，数据是执行这个指令所需的数据。</p><p>服务器在接收到客户端的请求之后，会解析出指令和数据，并且根据指令的不同，执行不同的处理逻辑。对于这样的一个业务场景，一般有两种架构实现思路。</p><p>常用的一种实现思路是利用多线程。一个线程接收请求，接收到请求之后，启动一个新的线程来处理请求。具体点讲，一般是通过一个主线程来接收客户端发来的请求。每当接收到一个请求之后，就从一个专门用来处理请求的线程池中，捞出一个空闲线程来处理。</p><p>另一种实现思路是在一个线程内轮询接收请求和处理请求。这种处理方式不太常见。尽管它无法利用多线程多核处理的优势，但是对于IO密集型的业务来说，它避免了多线程不停切换对性能的损耗，并且克服了多线程编程Bug比较难调试的缺点，也算是手游后端服务器开发中比较常见的架构模式了。</p><p>我们接下来就重点讲一下第二种实现方式。</p><p>整个手游后端服务器轮询获取客户端发来的请求，获取到请求之后，借助命令模式，把请求包含的数据和处理逻辑封装为命令对象，并存储在内存队列中。然后，再从队列中取出一定数量的命令来执行。执行完成之后，再重新开始新的一轮轮询。具体的示例代码如下所示，你可以结合着一块看下。</p><pre><code>public interface Command {\n  void execute();\n}\n\npublic class GotDiamondCommand implements Command {\n  // 省略成员变量\n\n  public GotDiamondCommand(/*数据*/) {\n    //...\n  }\n\n  @Override\n  public void execute() {\n    // 执行相应的逻辑\n  }\n}\n//GotStartCommand/HitObstacleCommand/ArchiveCommand类省略\n\npublic class GameApplication {\n  private static final int MAX_HANDLED_REQ_COUNT_PER_LOOP = 100;\n  private Queue&lt;Command&gt; queue = new LinkedList&lt;&gt;();\n\n  public void mainloop() {\n    while (true) {\n      List&lt;Request&gt; requests = new ArrayList&lt;&gt;();\n      \n      //省略从epoll或者select中获取数据，并封装成Request的逻辑，\n      //注意设置超时时间，如果很长时间没有接收到请求，就继续下面的逻辑处理。\n      \n      for (Request request : requests) {\n        Event event = request.getEvent();\n        Command command = null;\n        if (event.equals(Event.GOT_DIAMOND)) {\n          command = new GotDiamondCommand(/*数据*/);\n        } else if (event.equals(Event.GOT_STAR)) {\n          command = new GotStartCommand(/*数据*/);\n        } else if (event.equals(Event.HIT_OBSTACLE)) {\n          command = new HitObstacleCommand(/*数据*/);\n        } else if (event.equals(Event.ARCHIVE)) {\n          command = new ArchiveCommand(/*数据*/);\n        } // ...一堆else if...\n\n        queue.add(command);\n      }\n\n      int handledCount = 0;\n      while (handledCount &lt; MAX_HANDLED_REQ_COUNT_PER_LOOP) {\n        if (queue.isEmpty()) {\n          break;\n        }\n        Command command = queue.poll();\n        command.execute();\n      }\n    }\n  }\n}\n</code></pre><h2>命令模式 VS 策略模式</h2><p>看了刚才的讲解，你可能会觉得，命令模式跟策略模式、工厂模式非常相似啊，那它们的区别在哪里呢？不仅如此，在留言区中我还看到有不止一个同学反映，感觉学过的很多模式都很相似。不知道你有没有类似的感觉呢？</p><p>实际上，这个问题我之前简单提到过，可能没有作为重点来说，有些同学印象不是很深刻，这里我就再跟你讲一讲。</p><p>实际上，每个设计模式都应该由两部分组成：第一部分是应用场景，即这个模式可以解决哪类问题；第二部分是解决方案，即这个模式的设计思路和具体的代码实现。不过，代码实现并不是模式必须包含的。如果你单纯地只关注解决方案这一部分，甚至只关注代码实现，就会产生大部分模式看起来都很相似的错觉。</p><p>实际上，设计模式之间的主要区别还是在于设计意图，也就是应用场景。单纯地看设计思路或者代码实现，有些模式确实很相似，比如策略模式和工厂模式。</p><p>之前讲策略模式的时候，我们有讲到，策略模式包含策略的定义、创建和使用三部分，从代码结构上来，它非常像工厂模式。它们的区别在于，策略模式侧重“策略”或“算法”这个特定的应用场景，用来解决根据运行时状态从一组策略中选择不同策略的问题，而工厂模式侧重封装对象的创建过程，这里的对象没有任何业务场景的限定，可以是策略，但也可以是其他东西。从设计意图上来，这两个模式完全是两回事儿。</p><p>有了刚刚的铺垫，接下来，我们再来看命令模式跟策略模式的区别。你可能会觉得，命令的执行逻辑也可以看作策略，那它是不是就是策略模式了呢？实际上，这两者有一点细微的区别。</p><p>在策略模式中，不同的策略具有相同的目的、不同的实现、互相之间可以替换。比如，BubbleSort、SelectionSort都是为了实现排序的，只不过一个是用冒泡排序算法来实现的，另一个是用选择排序算法来实现的。而在命令模式中，不同的命令具有不同的目的，对应不同的处理逻辑，并且互相之间不可替换。</p><h2>重点回顾</h2><p>好了，今天的内容到此就讲完了。我们一块来总结回顾一下，你需要重点掌握的内容。</p><p>命令模式在平时工作中并不常用，你稍微了解一下就可以。今天，我重点讲解了它的设计意图，也就是能解决什么问题。</p><p>落实到编码实现，命令模式用到最核心的实现手段，就是将函数封装成对象。我们知道，在大部分编程语言中，函数是没法作为参数传递给其他函数的，也没法赋值给变量。借助命令模式，我们将函数封装成对象，这样就可以实现把函数像对象一样使用。</p><p>命令模式的主要作用和应用场景，是用来控制命令的执行，比如，异步、延迟、排队执行命令、撤销重做命令、存储命令、给命令记录日志等等，这才是命令模式能发挥独一无二作用的地方。</p><h2>课堂讨论</h2><p>从我们已经学过的这些设计模式中，找两个代码实现或者设计思路很相似的模式，说一说它们的不同点。</p><p>欢迎留言和我分享你的想法。如果有收获，也欢迎你把这篇文章分享给你的朋友。</p>",
                "article_title": "71 | 命令模式：如何利用命令模式实现一个手游后端架构？"
            },
            {
                "title": "72 | 解释器模式：如何设计实现一个自定义接口告警规则功能？",
                "herf": "https://time.geekbang.org/column/article/225904",
                "id": "225904",
                "content": "<p>上一节课，我们学习了命令模式。命令模式将请求封装成对象，方便作为函数参数传递和赋值给变量。它主要的应用场景是给命令的执行附加功能，换句话说，就是控制命令的执行，比如，排队、异步、延迟执行命令、给命令执行记录日志、撤销重做命令等等。总体上来讲，命令模式的应用范围并不广。</p><p>今天，我们来学习解释器模式，它用来描述如何构建一个简单的“语言”解释器。比起命令模式，解释器模式更加小众，只在一些特定的领域会被用到，比如编译器、规则引擎、正则表达式。所以，解释器模式也不是我们学习的重点，你稍微了解一下就可以了。</p><p>话不多说，让我们正式开始今天的学习吧！</p><h2>解释器模式的原理和实现</h2><p>解释器模式的英文翻译是Interpreter Design Pattern。在GoF的《设计模式》一书中，它是这样定义的：</p><blockquote>\n<p>Interpreter pattern is used to defines a grammatical representation for a language and provides an interpreter to deal with this grammar.</p>\n</blockquote><p>翻译成中文就是：解释器模式为某个语言定义它的语法（或者叫文法）表示，并定义一个解释器用来处理这个语法。</p><!-- [[[read_end]]] --><p>看了定义，你估计会一头雾水，因为这里面有很多我们平时开发中很少接触的概念，比如“语言”“语法”“解释器”。实际上，这里的“语言”不仅仅指我们平时说的中、英、日、法等各种语言。从广义上来讲，只要是能承载信息的载体，我们都可以称之为“语言”，比如，古代的结绳记事、盲文、哑语、摩斯密码等。</p><p>要想了解“语言”表达的信息，我们就必须定义相应的语法规则。这样，书写者就可以根据语法规则来书写“句子”（专业点的叫法应该是“表达式”），阅读者根据语法规则来阅读“句子”，这样才能做到信息的正确传递。而我们要讲的解释器模式，其实就是用来实现根据语法规则解读“句子”的解释器。</p><p>为了让你更好地理解定义，我举一个比较贴近生活的例子来解释一下。</p><p>实际上，理解这个概念，我们可以类比中英文翻译。我们知道，把英文翻译成中文是有一定规则的。这个规则就是定义中的“语法”。我们开发一个类似Google Translate这样的翻译器，这个翻译器能够根据语法规则，将输入的中文翻译成英文。这里的翻译器就是解释器模式定义中的“解释器”。</p><p>刚刚翻译器这个例子比较贴近生活，现在，我们再举个更加贴近编程的例子。</p><p>假设我们定义了一个新的加减乘除计算“语言”，语法规则如下：</p><ul>\n<li>运算符只包含加、减、乘、除，并且没有优先级的概念；</li>\n<li>表达式（也就是前面提到的“句子”）中，先书写数字，后书写运算符，空格隔开；</li>\n<li>按照先后顺序，取出两个数字和一个运算符计算结果，结果重新放入数字的最头部位置，循环上述过程，直到只剩下一个数字，这个数字就是表达式最终的计算结果。</li>\n</ul><p>我们举个例子来解释一下上面的语法规则。</p><p>比如“ 8 3 2 4 - + * ”这样一个表达式，我们按照上面的语法规则来处理，取出数字“8 3”和“-”运算符，计算得到5，于是表达式就变成了“ 5 2 4 + * ”。然后，我们再取出“ 5 2 ”和“ + ”运算符，计算得到7，表达式就变成了“ 7 4 * ”。最后，我们取出“ 7 4”和“ * ”运算符，最终得到的结果就是28。</p><p>看懂了上面的语法规则，我们将它用代码实现出来，如下所示。代码非常简单，用户按照上面的规则书写表达式，传递给interpret()函数，就可以得到最终的计算结果。</p><pre><code>public class ExpressionInterpreter {\n  private Deque&lt;Long&gt; numbers = new LinkedList&lt;&gt;();\n\n  public long interpret(String expression) {\n    String[] elements = expression.split(&quot; &quot;);\n    int length = elements.length;\n    for (int i = 0; i &lt; (length+1)/2; ++i) {\n      numbers.addLast(Long.parseLong(elements[i]));\n    }\n\n    for (int i = (length+1)/2; i &lt; length; ++i) {\n      String operator = elements[i];\n      boolean isValid = &quot;+&quot;.equals(operator) || &quot;-&quot;.equals(operator)\n              || &quot;*&quot;.equals(operator) || &quot;/&quot;.equals(operator);\n      if (!isValid) {\n        throw new RuntimeException(&quot;Expression is invalid: &quot; + expression);\n      }\n\n      long number1 = numbers.pollFirst();\n      long number2 = numbers.pollFirst();\n      long result = 0;\n      if (operator.equals(&quot;+&quot;)) {\n        result = number1 + number2;\n      } else if (operator.equals(&quot;-&quot;)) {\n        result = number1 - number2;\n      } else if (operator.equals(&quot;*&quot;)) {\n        result = number1 * number2;\n      } else if (operator.equals(&quot;/&quot;)) {\n        result = number1 / number2;\n      }\n      numbers.addFirst(result);\n    }\n\n    if (numbers.size() != 1) {\n      throw new RuntimeException(&quot;Expression is invalid: &quot; + expression);\n    }\n\n    return numbers.pop();\n  }\n}\n</code></pre><p>在上面的代码实现中，语法规则的解析逻辑（第23、25、27、29行）都集中在一个函数中，对于简单的语法规则的解析，这样的设计就足够了。但是，对于复杂的语法规则的解析，逻辑复杂，代码量多，所有的解析逻辑都耦合在一个函数中，这样显然是不合适的。这个时候，我们就要考虑拆分代码，将解析逻辑拆分到独立的小类中。</p><p>该怎么拆分呢？我们可以借助解释器模式。</p><p>解释器模式的代码实现比较灵活，没有固定的模板。我们前面也说过，应用设计模式主要是应对代码的复杂性，实际上，解释器模式也不例外。它的代码实现的核心思想，就是将语法解析的工作拆分到各个小类中，以此来避免大而全的解析类。一般的做法是，将语法规则拆分成一些小的独立的单元，然后对每个单元进行解析，最终合并为对整个语法规则的解析。</p><p>前面定义的语法规则有两类表达式，一类是数字，一类是运算符，运算符又包括加减乘除。利用解释器模式，我们把解析的工作拆分到NumberExpression、AdditionExpression、SubstractionExpression、MultiplicationExpression、DivisionExpression这样五个解析类中。</p><p>按照这个思路，我们对代码进行重构，重构之后的代码如下所示。当然，因为加减乘除表达式的解析比较简单，利用解释器模式的设计思路，看起来有点过度设计。不过呢，这里我主要是为了解释原理，你明白意思就好，不用过度细究这个例子。</p><pre><code>public interface Expression {\n  long interpret();\n}\n\npublic class NumberExpression implements Expression {\n  private long number;\n\n  public NumberExpression(long number) {\n    this.number = number;\n  }\n\n  public NumberExpression(String number) {\n    this.number = Long.parseLong(number);\n  }\n\n  @Override\n  public long interpret() {\n    return this.number;\n  }\n}\n\npublic class AdditionExpression implements Expression {\n  private Expression exp1;\n  private Expression exp2;\n\n  public AdditionExpression(Expression exp1, Expression exp2) {\n    this.exp1 = exp1;\n    this.exp2 = exp2;\n  }\n\n  @Override\n  public long interpret() {\n    return exp1.interpret() + exp2.interpret();\n  }\n}\n// SubstractionExpression/MultiplicationExpression/DivisionExpression与AdditionExpression代码结构类似，这里就省略了\n\npublic class ExpressionInterpreter {\n  private Deque&lt;Expression&gt; numbers = new LinkedList&lt;&gt;();\n\n  public long interpret(String expression) {\n    String[] elements = expression.split(&quot; &quot;);\n    int length = elements.length;\n    for (int i = 0; i &lt; (length+1)/2; ++i) {\n      numbers.addLast(new NumberExpression(elements[i]));\n    }\n\n    for (int i = (length+1)/2; i &lt; length; ++i) {\n      String operator = elements[i];\n      boolean isValid = &quot;+&quot;.equals(operator) || &quot;-&quot;.equals(operator)\n              || &quot;*&quot;.equals(operator) || &quot;/&quot;.equals(operator);\n      if (!isValid) {\n        throw new RuntimeException(&quot;Expression is invalid: &quot; + expression);\n      }\n\n      Expression exp1 = numbers.pollFirst();\n      Expression exp2 = numbers.pollFirst();\n      Expression combinedExp = null;\n      if (operator.equals(&quot;+&quot;)) {\n        combinedExp = new AdditionExpression(exp1, exp2);\n      } else if (operator.equals(&quot;-&quot;)) {\n        combinedExp = new AdditionExpression(exp1, exp2);\n      } else if (operator.equals(&quot;*&quot;)) {\n        combinedExp = new AdditionExpression(exp1, exp2);\n      } else if (operator.equals(&quot;/&quot;)) {\n        combinedExp = new AdditionExpression(exp1, exp2);\n      }\n      long result = combinedExp.interpret();\n      numbers.addFirst(new NumberExpression(result));\n    }\n\n    if (numbers.size() != 1) {\n      throw new RuntimeException(&quot;Expression is invalid: &quot; + expression);\n    }\n\n    return numbers.pop().interpret();\n  }\n}\n</code></pre><h2>解释器模式实战举例</h2><p>接下来，我们再来看一个更加接近实战的例子，也就是咱们今天标题中的问题：如何实现一个自定义接口告警规则功能？</p><p>在我们平时的项目开发中，监控系统非常重要，它可以时刻监控业务系统的运行情况，及时将异常报告给开发者。比如，如果每分钟接口出错数超过100，监控系统就通过短信、微信、邮件等方式发送告警给开发者。</p><p>一般来讲，监控系统支持开发者自定义告警规则，比如我们可以用下面这样一个表达式，来表示一个告警规则，它表达的意思是：每分钟API总出错数超过100或者每分钟API总调用数超过10000就触发告警。</p><pre><code>api_error_per_minute &gt; 100 || api_count_per_minute &gt; 10000\n</code></pre><p>在监控系统中，告警模块只负责根据统计数据和告警规则，判断是否触发告警。至于每分钟API接口出错数、每分钟接口调用数等统计数据的计算，是由其他模块来负责的。其他模块将统计数据放到一个Map中（数据的格式如下所示），发送给告警模块。接下来，我们只关注告警模块。</p><pre><code>Map&lt;String, Long&gt; apiStat = new HashMap&lt;&gt;();\napiStat.put(&quot;api_error_per_minute&quot;, 103);\napiStat.put(&quot;api_count_per_minute&quot;, 987);\n</code></pre><p>为了简化讲解和代码实现，我们假设自定义的告警规则只包含“||、&amp;&amp;、&gt;、&lt;、==”这五个运算符，其中，“&gt;、&lt;、==”运算符的优先级高于“||、&amp;&amp;”运算符，“&amp;&amp;”运算符优先级高于“||”。在表达式中，任意元素之间需要通过空格来分隔。除此之外，用户可以自定义要监控的key，比如前面的api_error_per_minute、api_count_per_minute。</p><p>那如何实现上面的需求呢？我写了一个骨架代码，如下所示，其中的核心的实现我没有给出，你可以当作面试题，自己试着去补全一下，然后再看我的讲解。</p><pre><code>public class AlertRuleInterpreter {\n\n  // key1 &gt; 100 &amp;&amp; key2 &lt; 1000 || key3 == 200\n  public AlertRuleInterpreter(String ruleExpression) {\n    //TODO:由你来完善\n  }\n\n  //&lt;String, Long&gt; apiStat = new HashMap&lt;&gt;();\n  //apiStat.put(&quot;key1&quot;, 103);\n  //apiStat.put(&quot;key2&quot;, 987);\n  public boolean interpret(Map&lt;String, Long&gt; stats) {\n    //TODO:由你来完善\n  }\n\n}\n\npublic class DemoTest {\n  public static void main(String[] args) {\n    String rule = &quot;key1 &gt; 100 &amp;&amp; key2 &lt; 30 || key3 &lt; 100 || key4 == 88&quot;;\n    AlertRuleInterpreter interpreter = new AlertRuleInterpreter(rule);\n    Map&lt;String, Long&gt; stats = new HashMap&lt;&gt;();\n    stats.put(&quot;key1&quot;, 101l);\n    stats.put(&quot;key3&quot;, 121l);\n    stats.put(&quot;key4&quot;, 88l);\n    boolean alert = interpreter.interpret(stats);\n    System.out.println(alert);\n  }\n}\n</code></pre><p>实际上，我们可以把自定义的告警规则，看作一种特殊“语言”的语法规则。我们实现一个解释器，能够根据规则，针对用户输入的数据，判断是否触发告警。利用解释器模式，我们把解析表达式的逻辑拆分到各个小类中，避免大而复杂的大类的出现。按照这个实现思路，我把刚刚的代码补全，如下所示，你可以拿你写的代码跟我写的对比一下。</p><pre><code>public interface Expression {\n  boolean interpret(Map&lt;String, Long&gt; stats);\n}\n\npublic class GreaterExpression implements Expression {\n  private String key;\n  private long value;\n\n  public GreaterExpression(String strExpression) {\n    String[] elements = strExpression.trim().split(&quot;\\\\s+&quot;);\n    if (elements.length != 3 || !elements[1].trim().equals(&quot;&gt;&quot;)) {\n      throw new RuntimeException(&quot;Expression is invalid: &quot; + strExpression);\n    }\n    this.key = elements[0].trim();\n    this.value = Long.parseLong(elements[2].trim());\n  }\n\n  public GreaterExpression(String key, long value) {\n    this.key = key;\n    this.value = value;\n  }\n\n  @Override\n  public boolean interpret(Map&lt;String, Long&gt; stats) {\n    if (!stats.containsKey(key)) {\n      return false;\n    }\n    long statValue = stats.get(key);\n    return statValue &gt; value;\n  }\n}\n\n// LessExpression/EqualExpression跟GreaterExpression代码类似，这里就省略了\n\npublic class AndExpression implements Expression {\n  private List&lt;Expression&gt; expressions = new ArrayList&lt;&gt;();\n\n  public AndExpression(String strAndExpression) {\n    String[] strExpressions = strAndExpression.split(&quot;&amp;&amp;&quot;);\n    for (String strExpr : strExpressions) {\n      if (strExpr.contains(&quot;&gt;&quot;)) {\n        expressions.add(new GreaterExpression(strExpr));\n      } else if (strExpr.contains(&quot;&lt;&quot;)) {\n        expressions.add(new LessExpression(strExpr));\n      } else if (strExpr.contains(&quot;==&quot;)) {\n        expressions.add(new EqualExpression(strExpr));\n      } else {\n        throw new RuntimeException(&quot;Expression is invalid: &quot; + strAndExpression);\n      }\n    }\n  }\n\n  public AndExpression(List&lt;Expression&gt; expressions) {\n    this.expressions.addAll(expressions);\n  }\n\n  @Override\n  public boolean interpret(Map&lt;String, Long&gt; stats) {\n    for (Expression expr : expressions) {\n      if (!expr.interpret(stats)) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n}\n\npublic class OrExpression implements Expression {\n  private List&lt;Expression&gt; expressions = new ArrayList&lt;&gt;();\n\n  public OrExpression(String strOrExpression) {\n    String[] andExpressions = strOrExpression.split(&quot;\\\\|\\\\|&quot;);\n    for (String andExpr : andExpressions) {\n      expressions.add(new AndExpression(andExpr));\n    }\n  }\n\n  public OrExpression(List&lt;Expression&gt; expressions) {\n    this.expressions.addAll(expressions);\n  }\n\n  @Override\n  public boolean interpret(Map&lt;String, Long&gt; stats) {\n    for (Expression expr : expressions) {\n      if (expr.interpret(stats)) {\n        return true;\n      }\n    }\n    return false;\n  }\n}\n\npublic class AlertRuleInterpreter {\n  private Expression expression;\n\n  public AlertRuleInterpreter(String ruleExpression) {\n    this.expression = new OrExpression(ruleExpression);\n  }\n\n  public boolean interpret(Map&lt;String, Long&gt; stats) {\n    return expression.interpret(stats);\n  }\n} \n</code></pre><h2>重点回顾</h2><p>好了，今天的内容到此就讲完了。我们一块来总结回顾一下，你需要重点掌握的内容。</p><p>解释器模式为某个语言定义它的语法（或者叫文法）表示，并定义一个解释器用来处理这个语法。实际上，这里的“语言”不仅仅指我们平时说的中、英、日、法等各种语言。从广义上来讲，只要是能承载信息的载体，我们都可以称之为“语言”，比如，古代的结绳记事、盲文、哑语、摩斯密码等。</p><p>要想了解“语言”要表达的信息，我们就必须定义相应的语法规则。这样，书写者就可以根据语法规则来书写“句子”（专业点的叫法应该是“表达式”），阅读者根据语法规则来阅读“句子”，这样才能做到信息的正确传递。而我们要讲的解释器模式，其实就是用来实现根据语法规则解读“句子”的解释器。</p><p>解释器模式的代码实现比较灵活，没有固定的模板。我们前面说过，应用设计模式主要是应对代码的复杂性，解释器模式也不例外。它的代码实现的核心思想，就是将语法解析的工作拆分到各个小类中，以此来避免大而全的解析类。一般的做法是，将语法规则拆分一些小的独立的单元，然后对每个单元进行解析，最终合并为对整个语法规则的解析。</p><h2>课堂讨论</h2><p>1.在你过往的项目经历或阅读源码的时候，有没有用到或者见过解释器模式呢？<br>\n2.在告警规则解析的例子中，如果我们要在表达式中支持括号“（）”，那如何对代码进行重构呢？你可以把它当作练习，试着编写一下代码。</p><p>欢迎留言和我分享你的想法。如果有收获，也欢迎你把这篇文章分享给你的朋友。</p>",
                "article_title": "72 | 解释器模式：如何设计实现一个自定义接口告警规则功能？"
            },
            {
                "title": "73 | 中介模式：什么时候用中介模式？什么时候用观察者模式？",
                "herf": "https://time.geekbang.org/column/article/226710",
                "id": "226710",
                "content": "<p>今天，我们来学习23种经典设计模式中的最后一个，中介模式。跟前面刚刚讲过的命令模式、解释器模式类似，中介模式也属于不怎么常用的模式，应用场景比较特殊、有限，但是，跟它俩不同的是，中介模式理解起来并不难，代码实现也非常简单，学习难度要小很多。</p><p>如果你对中介模式有所了解，你可能会知道，中介模式跟之前讲过的观察者模式有点相似，所以，今天我们还会详细讨论下这两种模式的区别。</p><p>话不多说，让我们正式开始今天的学习吧！</p><h2>中介模式的原理和实现</h2><p>中介模式的英文翻译是Mediator Design Pattern。在GoF中的《设计模式》一书中，它是这样定义的：</p><blockquote>\n<p>Mediator pattern defines a separate (mediator) object that encapsulates the interaction between a set of objects and the objects delegate their interaction to a mediator object instead of interacting with each other directly.</p>\n</blockquote><p>翻译成中文就是：中介模式定义了一个单独的（中介）对象，来封装一组对象之间的交互。将这组对象之间的交互委派给与中介对象交互，来避免对象之间的直接交互。</p><!-- [[[read_end]]] --><p>还记得我们在<a href=\"https://time.geekbang.org/column/article/187761\">第30节课</a>中讲的“如何给代码解耦”吗？其中一个方法就是引入中间层。</p><p>实际上，中介模式的设计思想跟中间层很像，通过引入中介这个中间层，将一组对象之间的交互关系（或者说依赖关系）从多对多（网状关系）转换为一对多（星状关系）。原来一个对象要跟n个对象交互，现在只需要跟一个中介对象交互，从而最小化对象之间的交互关系，降低了代码的复杂度，提高了代码的可读性和可维护性。</p><p>这里我画了一张对象交互关系的对比图。其中，右边的交互图是利用中介模式对左边交互关系优化之后的结果，从图中我们可以很直观地看出，右边的交互关系更加清晰、简洁。</p><p><img src=\"https://static001.geekbang.org/resource/image/43/9f/4376d541bf17a029f37aa76009ef3a9f.jpg\" alt=\"\"></p><p>提到中介模式，有一个比较经典的例子不得不说，那就是航空管制。</p><p>为了让飞机在飞行的时候互不干扰，每架飞机都需要知道其他飞机每时每刻的位置，这就需要时刻跟其他飞机通信。飞机通信形成的通信网络就会无比复杂。这个时候，我们通过引入“塔台”这样一个中介，让每架飞机只跟塔台来通信，发送自己的位置给塔台，由塔台来负责每架飞机的航线调度。这样就大大简化了通信网络。</p><p>刚刚举的是生活中的例子，我们再举一个跟编程开发相关的例子。这个例子与UI控件有关，算是中介模式比较经典的应用，很多书籍在讲到中介模式的时候，都会拿它来举例。</p><p>假设我们有一个比较复杂的对话框，对话框中有很多控件，比如按钮、文本框、下拉框等。当我们对某个控件进行操作的时候，其他控件会做出相应的反应，比如，我们在下拉框中选择“注册”，注册相关的控件就会显示在对话框中。如果我们在下拉框中选择“登陆”，登陆相关的控件就会显示在对话框中。</p><p>按照通常我们习惯的UI界面的开发方式，我们将刚刚的需求用代码实现出来，就是下面这个样子。在这种实现方式中，控件和控件之间互相操作、互相依赖。</p><pre><code>public class UIControl {\n  private static final String LOGIN_BTN_ID = &quot;login_btn&quot;;\n  private static final String REG_BTN_ID = &quot;reg_btn&quot;;\n  private static final String USERNAME_INPUT_ID = &quot;username_input&quot;;\n  private static final String PASSWORD_INPUT_ID = &quot;pswd_input&quot;;\n  private static final String REPEATED_PASSWORD_INPUT_ID = &quot;repeated_pswd_input&quot;;\n  private static final String HINT_TEXT_ID = &quot;hint_text&quot;;\n  private static final String SELECTION_ID = &quot;selection&quot;;\n\n  public static void main(String[] args) {\n    Button loginButton = (Button)findViewById(LOGIN_BTN_ID);\n    Button regButton = (Button)findViewById(REG_BTN_ID);\n    Input usernameInput = (Input)findViewById(USERNAME_INPUT_ID);\n    Input passwordInput = (Input)findViewById(PASSWORD_INPUT_ID);\n    Input repeatedPswdInput = (Input)findViewById(REPEATED_PASSWORD_INPUT_ID);\n    Text hintText = (Text)findViewById(HINT_TEXT_ID);\n    Selection selection = (Selection)findViewById(SELECTION_ID);\n\n    loginButton.setOnClickListener(new OnClickListener() {\n      @Override\n      public void onClick(View v) {\n        String username = usernameInput.text();\n        String password = passwordInput.text();\n        //校验数据...\n        //做业务处理...\n      }\n    });\n\n    regButton.setOnClickListener(new OnClickListener() {\n      @Override\n      public void onClick(View v) {\n      //获取usernameInput、passwordInput、repeatedPswdInput数据...\n      //校验数据...\n      //做业务处理...\n      }\n    });\n\n    //...省略selection下拉选择框相关代码....\n  }\n}\n</code></pre><p>我们再按照中介模式，将上面的代码重新实现一下。在新的代码实现中，各个控件只跟中介对象交互，中介对象负责所有业务逻辑的处理。</p><pre><code>public interface Mediator {\n  void handleEvent(Component component, String event);\n}\n\npublic class LandingPageDialog implements Mediator {\n  private Button loginButton;\n  private Button regButton;\n  private Selection selection;\n  private Input usernameInput;\n  private Input passwordInput;\n  private Input repeatedPswdInput;\n  private Text hintText;\n\n  @Override\n  public void handleEvent(Component component, String event) {\n    if (component.equals(loginButton)) {\n      String username = usernameInput.text();\n      String password = passwordInput.text();\n      //校验数据...\n      //做业务处理...\n    } else if (component.equals(regButton)) {\n      //获取usernameInput、passwordInput、repeatedPswdInput数据...\n      //校验数据...\n      //做业务处理...\n    } else if (component.equals(selection)) {\n      String selectedItem = selection.select();\n      if (selectedItem.equals(&quot;login&quot;)) {\n        usernameInput.show();\n        passwordInput.show();\n        repeatedPswdInput.hide();\n        hintText.hide();\n        //...省略其他代码\n      } else if (selectedItem.equals(&quot;register&quot;)) {\n        //....\n      }\n    }\n  }\n}\n\npublic class UIControl {\n  private static final String LOGIN_BTN_ID = &quot;login_btn&quot;;\n  private static final String REG_BTN_ID = &quot;reg_btn&quot;;\n  private static final String USERNAME_INPUT_ID = &quot;username_input&quot;;\n  private static final String PASSWORD_INPUT_ID = &quot;pswd_input&quot;;\n  private static final String REPEATED_PASSWORD_INPUT_ID = &quot;repeated_pswd_input&quot;;\n  private static final String HINT_TEXT_ID = &quot;hint_text&quot;;\n  private static final String SELECTION_ID = &quot;selection&quot;;\n\n  public static void main(String[] args) {\n    Button loginButton = (Button)findViewById(LOGIN_BTN_ID);\n    Button regButton = (Button)findViewById(REG_BTN_ID);\n    Input usernameInput = (Input)findViewById(USERNAME_INPUT_ID);\n    Input passwordInput = (Input)findViewById(PASSWORD_INPUT_ID);\n    Input repeatedPswdInput = (Input)findViewById(REPEATED_PASSWORD_INPUT_ID);\n    Text hintText = (Text)findViewById(HINT_TEXT_ID);\n    Selection selection = (Selection)findViewById(SELECTION_ID);\n\n    Mediator dialog = new LandingPageDialog();\n    dialog.setLoginButton(loginButton);\n    dialog.setRegButton(regButton);\n    dialog.setUsernameInput(usernameInput);\n    dialog.setPasswordInput(passwordInput);\n    dialog.setRepeatedPswdInput(repeatedPswdInput);\n    dialog.setHintText(hintText);\n    dialog.setSelection(selection);\n\n    loginButton.setOnClickListener(new OnClickListener() {\n      @Override\n      public void onClick(View v) {\n        dialog.handleEvent(loginButton, &quot;click&quot;);\n      }\n    });\n\n    regButton.setOnClickListener(new OnClickListener() {\n      @Override\n      public void onClick(View v) {\n        dialog.handleEvent(regButton, &quot;click&quot;);\n      }\n    });\n\n    //....\n  }\n}\n</code></pre><p>从代码中我们可以看出，原本业务逻辑会分散在各个控件中，现在都集中到了中介类中。实际上，这样做既有好处，也有坏处。好处是简化了控件之间的交互，坏处是中介类有可能会变成大而复杂的“上帝类”（God Class）。所以，在使用中介模式的时候，我们要根据实际的情况，平衡对象之间交互的复杂度和中介类本身的复杂度。</p><h2>中介模式 VS 观察者模式</h2><p>前面讲观察者模式的时候，我们讲到，观察者模式有多种实现方式。虽然经典的实现方式没法彻底解耦观察者和被观察者，观察者需要注册到被观察者中，被观察者状态更新需要调用观察者的update()方法。但是，在跨进程的实现方式中，我们可以利用消息队列实现彻底解耦，观察者和被观察者都只需要跟消息队列交互，观察者完全不知道被观察者的存在，被观察者也完全不知道观察者的存在。</p><p>我们前面提到，中介模式也是为了解耦对象之间的交互，所有的参与者都只与中介进行交互。而观察者模式中的消息队列，就有点类似中介模式中的“中介”，观察者模式的中观察者和被观察者，就有点类似中介模式中的“参与者”。那问题来了：中介模式和观察者模式的区别在哪里呢？什么时候选择使用中介模式？什么时候选择使用观察者模式呢？</p><p>在观察者模式中，尽管一个参与者既可以是观察者，同时也可以是被观察者，但是，大部分情况下，交互关系往往都是单向的，一个参与者要么是观察者，要么是被观察者，不会兼具两种身份。也就是说，在观察者模式的应用场景中，参与者之间的交互关系比较有条理。</p><p>而中介模式正好相反。只有当参与者之间的交互关系错综复杂，维护成本很高的时候，我们才考虑使用中介模式。毕竟，中介模式的应用会带来一定的副作用，前面也讲到，它有可能会产生大而复杂的上帝类。除此之外，如果一个参与者状态的改变，其他参与者执行的操作有一定先后顺序的要求，这个时候，中介模式就可以利用中介类，通过先后调用不同参与者的方法，来实现顺序的控制，而观察者模式是无法实现这样的顺序要求的。</p><h2>重点回顾</h2><p>好了，今天的内容到此就讲完了。我们一块来总结回顾一下，你需要重点掌握的内容。</p><p>中介模式的设计思想跟中间层很像，通过引入中介这个中间层，将一组对象之间的交互关系（或者依赖关系）从多对多（网状关系）转换为一对多（星状关系）。原来一个对象要跟n个对象交互，现在只需要跟一个中介对象交互，从而最小化对象之间的交互关系，降低了代码的复杂度，提高了代码的可读性和可维护性。</p><p>观察者模式和中介模式都是为了实现参与者之间的解耦，简化交互关系。两者的不同在于应用场景上。在观察者模式的应用场景中，参与者之间的交互比较有条理，一般都是单向的，一个参与者只有一个身份，要么是观察者，要么是被观察者。而在中介模式的应用场景中，参与者之间的交互关系错综复杂，既可以是消息的发送者、也可以同时是消息的接收者。</p><h2>课堂讨论</h2><p>在讲观察者模式的时候，我们有讲到EventBus框架。当时我们认为它是观察者模式的实现框架。EventBus作为一个事件处理的中心，事件的派送、订阅都通过这个中心来完成，那是不是更像中介模式的实现框架呢？</p><p>欢迎留言和我分享你的想法。如果有收获，也欢迎你把这篇文章分享给你的朋友。</p>",
                "article_title": "73 | 中介模式：什么时候用中介模式？什么时候用观察者模式？"
            }
        ]
    },
    {
        "chapterTitle": "设计模式与范式：总结课 (2讲)",
        "children": [
            {
                "title": "74 | 总结回顾23种经典设计模式的原理、背后的思想、应用场景等",
                "herf": "https://time.geekbang.org/column/article/227452",
                "id": "227452",
                "content": "<p>到今天为止，23种经典的设计模式已经全部讲完了。咱们整个专栏也完成了3/4，马上就要进入实战环节了。在进入新模块的学习之前，我照例带你做一下总结回顾。23种经典设计模式共分为3种类型，分别是创建型、结构型和行为型。今天，我们把这3种类型分成3个对应的小模块，逐一带你回顾一下每一种设计模式的原理、实现、设计意图和应用场景。</p><p>和之前的总结文一样，今天的内容比较多，有近万字，但都是咱们之前学过的，看起来应该不会太费劲，但却能检验你是否真的掌握了这些内容。</p><p>还是那句话，如果你看了之后，感觉都有印象，那就说明学得还不错；如果还能在脑子里形成自己的知识架构，闭上眼睛都能回忆上来，那说明你学得很好；如果能有自己的理解，并且在项目开发中，开始思考代码质量问题，开始用已经学过的设计模式来解决代码问题，那说明你已经掌握这些内容的精髓。</p><p><img src=\"https://static001.geekbang.org/resource/image/bd/0a/bdc5e66fe65d4801ebe32e96c813e20a.png\" alt=\"\"></p><p>话不多说，让我们正式开始今天的复习吧！</p><h2>一、创建型设计模式</h2><p>创建型设计模式包括：单例模式、工厂模式、建造者模式、原型模式。它主要解决对象的创建问题，封装复杂的创建过程，解耦对象的创建代码和使用代码。</p><h3>1.单例模式</h3><p>单例模式用来创建全局唯一的对象。一个类只允许创建一个对象（或者叫实例），那这个类就是一个单例类，这种设计模式就叫作单例模式。单例有几种经典的实现方式，它们分别是：饿汉式、懒汉式、双重检测、静态内部类、枚举。</p><!-- [[[read_end]]] --><p>尽管单例是一个很常用的设计模式，在实际的开发中，我们也确实经常用到它，但是，有些人认为单例是一种反模式（anti-pattern），并不推荐使用，主要的理由有以下几点：</p><ul>\n<li>单例对OOP特性的支持不友好</li>\n<li>单例会隐藏类之间的依赖关系</li>\n<li>单例对代码的扩展性不友好</li>\n<li>单例对代码的可测试性不友好</li>\n<li>单例不支持有参数的构造函数</li>\n</ul><p>那有什么替代单例的解决方案呢？如果要完全解决这些问题，我们可能要从根上寻找其他方式来实现全局唯一类。比如，通过工厂模式、IOC容器来保证全局唯一性。</p><p>有人把单例当作反模式，主张杜绝在项目中使用。我个人觉得这有点极端。模式本身没有对错，关键看你怎么用。如果单例类并没有后续扩展的需求，并且不依赖外部系统，那设计成单例类就没有太大问题。对于一些全局类，我们在其他地方new的话，还要在类之间传来传去，不如直接做成单例类，使用起来简洁方便。</p><p>除此之外，我们还讲到了进程唯一单例、线程唯一单例、集群唯一单例、多例等扩展知识点，这一部分在实际的开发中并不会被用到，但是可以扩展你的思路、锻炼你的逻辑思维。这里我就不带你回顾了，你可以自己回忆一下。</p><h3>2.工厂模式</h3><p>工厂模式包括简单工厂、工厂方法、抽象工厂这3种细分模式。其中，简单工厂和工厂方法比较常用，抽象工厂的应用场景比较特殊，所以很少用到，不是我们学习的重点。</p><p>工厂模式用来创建不同但是相关类型的对象（继承同一父类或者接口的一组子类），由给定的参数来决定创建哪种类型的对象。实际上，如果创建对象的逻辑并不复杂，那我们直接通过new来创建对象就可以了，不需要使用工厂模式。当创建逻辑比较复杂，是一个“大工程”的时候，我们就考虑使用工厂模式，封装对象的创建过程，将对象的创建和使用相分离。</p><p>当每个对象的创建逻辑都比较简单的时候，我推荐使用简单工厂模式，将多个对象的创建逻辑放到一个工厂类中。当每个对象的创建逻辑都比较复杂的时候，为了避免设计一个过于庞大的工厂类，我们推荐使用工厂方法模式，将创建逻辑拆分得更细，每个对象的创建逻辑独立到各自的工厂类中。</p><p>详细点说，工厂模式的作用有下面4个，这也是判断要不要使用工厂模式最本质的参考标准。</p><ul>\n<li>封装变化：创建逻辑有可能变化，封装成工厂类之后，创建逻辑的变更对调用者透明。</li>\n<li>代码复用：\b创建代码抽离到独立的工厂类之后可以复用。</li>\n<li>隔离复杂性：封装复杂的创建逻辑，调用者无需了解如何创建对象。</li>\n<li>控制复杂度：将创建代码抽离出来，让原本的函数或类职责更单一，代码更简洁。</li>\n</ul><p>除此之外，我们还讲了工厂模式一个非常经典的应用场景：依赖注入框架，比如Spring IOC、Google Guice，它用来集中创建、组装、管理对象，跟具体业务代码解耦，让程序员聚焦在业务代码的开发上。DI框架已经成为了我们平时开发的必备框架，在专栏中，我还带你实现了一个简单的DI框架，你可以再回过头去看看。</p><h3>3.建造者模式</h3><p>建造者模式用来创建复杂对象，可以通过设置不同的可选参数，“定制化”地创建不同的对象。建造者模式的原理和实现比较简单，重点是掌握应用场景，避免过度使用。</p><p>如果一个类中有很多属性，为了避免构造函数的参数列表过长，影响代码的可读性和易用性，我们可以通过构造函数配合set()方法来解决。但是，如果存在下面情况中的任意一种，我们就要考虑使用建造者模式了。</p><ul>\n<li>我们把类的必填属性放到构造函数中，强制创建对象的时候就设置。如果必填的属性有很多，把这些必填属性都放到构造函数中设置，那构造函数就又会出现参数列表很长的问题。如果我们把必填属性通过set()方法设置，那校验这些必填属性是否已经填写的逻辑就无处安放了。</li>\n<li>如果类的属性之间有一定的依赖关系或者约束条件，我们继续使用构造函数配合set()方法的设计思路，那这些依赖关系或约束条件的校验逻辑就无处安放了。</li>\n<li>如果我们希望创建不可变对象，也就是说，对象在创建好之后，就不能再修改内部的属性值，要实现这个功能，我们就不能在类中暴露set()方法。构造函数配合set()方法来设置属性值的方式就不适用了。</li>\n</ul><h3>4.原型模式</h3><p>如果对象的创建成本比较大，而同一个类的不同对象之间差别不大（大部分字段都相同），在这种情况下，我们可以利用对已有对象（原型）进行复制（或者叫拷贝）的方式，来创建新对象，以达到节省创建时间的目的。这种基于原型来创建对象的方式就叫作原型模式。</p><p>原型模式有两种实现方法，深拷贝和浅拷贝。浅拷贝只会复制对象中基本数据类型数据和引用对象的内存地址，不会递归地复制引用对象，以及引用对象的引用对象……而深拷贝得到的是一份完完全全独立的对象。所以，深拷贝比起浅拷贝来说，更加耗时，更加耗内存空间。</p><p>如果要拷贝的对象是不可变对象，浅拷贝共享不可变对象是没问题的，但对于可变对象来说，浅拷贝得到的对象和原始对象会共享部分数据，就有可能出现数据被修改的风险，也就变得复杂多了。操作非常耗时的情况下，我们比较推荐使用浅拷贝，否则，没有充分的理由，不要为了一点点的性能提升而使用浅拷贝。</p><h2>二、结构型设计模式</h2><p>结构型模式主要总结了一些类或对象组合在一起的经典结构，这些经典的结构可以解决特定应用场景的问题。结构型模式包括：代理模式、桥接模式、装饰器模式、适配器模式、门面模式、组合模式、享元模式。</p><h3>1.代理模式</h3><p>代理模式在不改变原始类接口的条件下，为原始类定义一个代理类，主要目的是控制访问，而非加强功能，这是它跟装饰器模式最大的不同。一般情况下，我们让代理类和原始类实现同样的接口。但是，如果原始类并没有定义接口，并且原始类代码并不是我们开发维护的。在这种情况下，我们可以通过让代理类继承原始类的方法来实现代理模式。</p><p>静态代理需要针对每个类都创建一个代理类，并且每个代理类中的代码都有点像模板式的“重复”代码，增加了维护成本和开发成本。对于静态代理存在的问题，我们可以通过动态代理来解决。我们不事先为每个原始类编写代理类，而是在运行的时候动态地创建原始类对应的代理类，然后在系统中用代理类替换掉原始类。</p><p>代理模式常用在业务系统中开发一些非功能性需求，比如：监控、统计、鉴权、限流、事务、幂等、日志。我们将这些附加功能与业务功能解耦，放到代理类统一处理，让程序员只需要关注业务方面的开发。除此之外，代理模式还可以用在RPC、缓存等应用场景中。</p><h3>2.桥接模式</h3><p>桥接模式的代码实现非常简单，但是理解起来稍微有点难度，并且应用场景也比较局限，所以，相对来说，桥接模式在实际的项目中并没有那么常用，你只需要简单了解，见到能认识就可以了，并不是我们学习的重点。</p><p>桥接模式有两种理解方式。第一种理解方式是“将抽象和实现解耦，让它们能独立开发”。这种理解方式比较特别，应用场景也不多。另一种理解方式更加简单，等同于“组合优于继承”设计原则，这种理解方式更加通用，应用场景比较多。不管是哪种理解方式，它们的代码结构都是相同的，都是一种类之间的组合关系。</p><p>对于第一种理解方式，弄懂定义中“抽象”和“实现”两个概念，是理解它的关键。定义中的“抽象”，指的并非“抽象类”或“接口”，而是被抽象出来的一套“类库”，它只包含骨架代码，真正的业务逻辑需要委派给定义中的“实现”来完成。而定义中的“实现”，也并非“接口的实现类”，而是的一套独立的“类库”。“抽象”和“实现”独立开发，通过对象之间的组合关系组装在一起。</p><h3>3.装饰器模式</h3><p>装饰器模式主要解决继承关系过于复杂的问题，通过组合来替代继承，给原始类添加增强功能。这也是判断是否该用装饰器模式的一个重要的依据。除此之外，装饰器模式还有一个特点，那就是可以对原始类嵌套使用多个装饰器。为了满足这样的需求，在设计的时候，装饰器类需要跟原始类继承相同的抽象类或者接口。</p><h3>4.适配器模式</h3><p>代理模式、装饰器模式提供的都是跟原始类相同的接口，而适配器提供跟原始类不同的接口。适配器模式是用来做适配的，它将不兼容的接口转换为可兼容的接口，让原本由于接口不兼容而不能一起工作的类可以一起工作。适配器模式有两种实现方式：类适配器和对象适配器。其中，类适配器使用继承关系来实现，对象适配器使用组合关系来实现。</p><p>适配器模式是一种事后的补救策略，用来补救设计上的缺陷。应用这种模式算是“无奈之举”。如果在设计初期，我们就能规避接口不兼容的问题，那这种模式就无用武之地了。在实际的开发中，什么情况下才会出现接口不兼容呢？我总结下了下面这5种场景：</p><ul>\n<li>封装有缺陷的接口设计</li>\n<li>统一多个类的接口设计</li>\n<li>替换依赖的外部系统</li>\n<li>兼容老版本接口</li>\n<li>适配不同格式的数据</li>\n</ul><h3>5.门面模式</h3><p>门面模式原理、实现都非常简单，应用场景比较明确。它通过封装细粒度的接口，提供组合各个细粒度接口的高层次接口，来提高接口的易用性，或者解决性能、分布式事务等问题。</p><h3>6.组合模式</h3><p>组合模式跟我们之前讲的面向对象设计中的“组合关系（通过组合来组装两个类）”，完全是两码事。这里讲的“组合模式”，主要是用来处理树形结构数据。正因为其应用场景的特殊性，数据必须能表示成树形结构，这也导致了这种模式在实际的项目开发中并不那么常用。但是，一旦数据满足树形结构，应用这种模式就能发挥很大的作用，能让代码变得非常简洁。</p><p>组合模式的设计思路，与其说是一种设计模式，倒不如说是对业务场景的一种数据结构和算法的抽象。其中，数据可以表示成树这种数据结构，业务需求可以通过在树上的递归遍历算法来实现。组合模式，将一组对象组织成树形结构，将单个对象和组合对象都看作树中的节点，以统一处理逻辑，并且它利用树形结构的特点，递归地处理每个子树，依次简化代码实现。</p><h3>7.享元模式</h3><p>所谓“享元”，顾名思义就是被共享的单元。享元模式的意图是复用对象，节省内存，前提是享元对象是不可变对象。</p><p>具体来讲，当一个系统中存在大量重复对象的时候，我们就可以利用享元模式，将对象设计成享元，在内存中只保留一份实例，供多处代码引用，这样可以减少内存中对象的数量，以起到节省内存的目的。实际上，不仅仅相同对象可以设计成享元，对于相似对象，我们也可以将这些对象中相同的部分（字段），提取出来设计成享元，让这些大量相似对象引用这些享元。</p><h2>三、行为型设计模式</h2><p>我们知道，创建型设计模式主要解决“对象的创建”问题，结构型设计模式主要解决“类或对象的组合”问题，那行为型设计模式主要解决的就是“类或对象之间的交互”问题。行为型模式比较多，有11种，它们分别是：观察者模式、模板模式、策略模式、职责链模式、迭代器模式、状态模式、访问者模式、备忘录模式、命令模式、解释器模式、中介模式。</p><h3>1.观察者模式</h3><p>观察者模式将观察者和被观察者代码解耦。观察者模式的应用场景非常广泛，小到代码层面的解耦，大到架构层面的系统解耦，再或者一些产品的设计思路，都有这种模式的影子，比如，邮件订阅、RSS Feeds，本质上都是观察者模式。</p><p>不同的应用场景和需求下，这个模式也有截然不同的实现方式：有同步阻塞的实现方式，也有异步非阻塞的实现方式；有进程内的实现方式，也有跨进程的实现方式。同步阻塞是最经典的实现方式，主要是为了代码解耦；异步非阻塞除了能实现代码解耦之外，还能提高代码的执行效率；进程间的观察者模式解耦更加彻底，一般是基于消息队列来实现，用来实现不同进程间的被观察者和观察者之间的交互。</p><p>框架的作用有隐藏实现细节，降低开发难度，实现代码复用，解耦业务与非业务代码，让程序员聚焦业务开发。针对异步非阻塞观察者模式，我们也可以将它抽象成EventBus框架来达到这样的效果。EventBus翻译为“事件总线”，它提供了实现观察者模式的骨架代码。我们可以基于此框架非常容易地在自己的业务场景中实现观察者模式，不需要从零开始开发。</p><h3>2.模板模式</h3><p>模板方法模式在一个方法中定义一个算法骨架，并将某些步骤推迟到子类中实现。模板方法模式可以让子类在不改变算法整体结构的情况下，重新定义算法中的某些步骤。这里的“算法”，我们可以理解为广义上的“业务逻辑”，并不特指数据结构和算法中的“算法”。这里的算法骨架就是“模板”，包含算法骨架的方法就是“模板方法”，这也是模板方法模式名字的由来。</p><p>模板模式有两大作用：复用和扩展。其中复用指的是，所有的子类可以复用父类中提供的模板方法的代码。扩展指的是，框架通过模板模式提供功能扩展点，让框架用户可以在不修改框架源码的情况下，基于扩展点定制化框架的功能。</p><p>除此之外，我们还讲到回调。它跟模板模式具有相同的作用：代码复用和扩展。在一些框架、类库、组件等的设计中经常会用到，比如JdbcTemplate就是用了回调。</p><p>相对于普通的函数调用，回调是一种双向调用关系。A类事先注册某个函数F到B类，A类在调用B类的P函数的时候，B类反过来调用A类注册给它的F函数。这里的F函数就是“回调函数”。A调用B，B反过来又调用A，这种调用机制就叫作“回调”。</p><p>回调可以细分为同步回调和异步回调。从应用场景上来看，同步回调看起来更像模板模式，异步回调看起来更像观察者模式。回调跟模板模式的区别，更多的是在代码实现上，而非应用场景上。回调基于组合关系来实现，模板模式基于继承关系来实现。回调比模板模式更加灵活。</p><h3>3.策略模式</h3><p>策略模式定义一组算法类，将每个算法分别封装起来，让它们可以互相替换。策略模式可以使算法的变化独立于使用它们的客户端（这里的客户端代指使用算法的代码）。策略模式用来解耦策略的定义、创建、使用。实际上，一个完整的策略模式就是由这三个部分组成的。</p><p>策略类的定义比较简单，包含一个策略接口和一组实现这个接口的策略类。策略的创建由工厂类来完成，封装策略创建的细节。策略模式包含一组策略可选，客户端代码选择使用哪个策略，有两种确定方法：编译时静态确定和运行时动态确定。其中，“运行时动态确定”才是策略模式最典型的应用场景。</p><p>在实际的项目开发中，策略模式也比较常用。最常见的应用场景是，利用它来避免冗长的if-else或switch分支判断。不过，它的作用还不止如此。它也可以像模板模式那样，提供框架的扩展点等等。实际上，策略模式主要的作用还是解耦策略的定义、创建和使用，控制代码的复杂度，让每个部分都不至于过于复杂、代码量过多。除此之外，对于复杂代码来说，策略模式还能让其满足开闭原则，添加新策略的时候，最小化、集中化代码改动，减少引入bug的风险。</p><h3>4.职责链模式</h3><p>在职责链模式中，多个处理器依次处理同一个请求。一个请求先经过A处理器处理，然后再把请求传递给B处理器，B处理器处理完后再传递给C处理器，以此类推，形成一个链条。链条上的每个处理器各自承担各自的处理职责，所以叫作职责链模式。</p><p>在GoF的定义中，一旦某个处理器能处理这个请求，就不会继续将请求传递给后续的处理器了。当然，在实际的开发中，也存在对这个模式的变体，那就是请求不会中途终止传递，而是会被所有的处理器都处理一遍。</p><p>职责链模式常用在框架开发中，用来实现过滤器、拦截器功能，让框架的使用者在不需要修改框架源码的情况下，添加新的过滤、拦截功能。这也体现了之前讲到的对扩展开放、对修改关闭的设计原则。</p><h3>5.迭代器模式</h3><p>迭代器模式也叫游标模式，它用来遍历集合对象。这里说的“集合对象”，我们也可以叫“容器”“聚合对象”，实际上就是包含一组对象的对象，比如，数组、链表、树、图、跳表。迭代器模式主要作用是解耦容器代码和遍历代码。大部分编程语言都提供了现成的迭代器可以使用，我们不需要从零开始开发。</p><p>遍历集合一般有三种方式：for循环、foreach循环、迭代器遍历。后两种本质上属于一种，都可以看作迭代器遍历。相对于for循环遍历，利用迭代器来遍历有3个优势：</p><ul>\n<li>迭代器模式封装集合内部的复杂数据结构，开发者不需要了解如何遍历，直接使用容器提供的迭代器即可；</li>\n<li>迭代器模式将集合对象的遍历操作从集合类中拆分出来，放到迭代器类中，让两者的职责更加单一；</li>\n<li>迭代器模式让添加新的遍历算法更加容易，更符合开闭原则。除此之外，因为迭代器都实现自相同的接口，在开发中，基于接口而非实现编程，替换迭代器也变得更加容易。</li>\n</ul><p>在通过迭代器来遍历集合元素的同时，增加或者删除集合中的元素，有可能会导致某个元素被重复遍历或遍历不到。针对这个问题，有两种比较干脆利索的解决方案，来避免出现这种不可预期的运行结果。一种是遍历的时候不允许增删元素，另一种是增删元素之后让遍历报错。第一种解决方案比较难实现，因为很难确定迭代器使用结束的时间点。第二种解决方案更加合理，Java语言就是采用的这种解决方案。增删元素之后，我们选择fail-fast解决方式，让遍历操作直接抛出运行时异常。</p><h3>6.状态模式</h3><p>状态模式一般用来实现状态机，而状态机常用在游戏、工作流引擎等系统开发中。状态机又叫有限状态机，它由3个部分组成：状态、事件、动作。其中，事件也称为转移条件。事件触发状态的转移及动作的执行。不过，动作不是必须的，也可能只转移状态，不执行任何动作。</p><p>针对状态机，我们总结了三种实现方式。</p><p>第一种实现方式叫分支逻辑法。利用if-else或者switch-case分支逻辑，参照状态转移图，将每一个状态转移原模原样地直译成代码。对于简单的状态机来说，这种实现方式最简单、最直接，是首选。</p><p>第二种实现方式叫查表法。对于状态很多、状态转移比较复杂的状态机来说，查表法比较合适。通过二维数组来表示状态转移图，能极大地提高代码的可读性和可维护性。</p><p>第三种实现方式就是利用状态模式。对于状态并不多、状态转移也比较简单，但事件触发执行的动作包含的业务逻辑可能比较复杂的状态机来说，我们首选这种实现方式。</p><h3>7.访问者模式</h3><p>访问者模式允许一个或者多个操作应用到一组对象上，设计意图是解耦操作和对象本身，保持类职责单一、满足开闭原则以及应对代码的复杂性。</p><p>对于访问者模式，学习的主要难点在代码实现。而代码实现比较复杂的主要原因是，函数重载在大部分面向对象编程语言中是静态绑定的。也就是说，调用类的哪个重载函数，是在编译期间，由参数的声明类型决定的，而非运行时，根据参数的实际类型决定的。除此之外，我们还讲到Double Disptach。如果某种语言支持Double Dispatch，那就不需要访问者模式了。</p><p>正是因为代码实现难理解，所以，在项目中应用这种模式，会导致代码的可读性比较差。如果你的同事不了解这种设计模式，可能就会读不懂、维护不了你写的代码。所以，除非不得已，不要使用这种模式。</p><h3>8.备忘录模式</h3><p>备忘录模式也叫快照模式，具体来说，就是在不违背封装原则的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，以便之后恢复对象为先前的状态。这个模式的定义表达了两部分内容：一部分是，存储副本以便后期恢复；另一部分是，要在不违背封装原则的前提下，进行对象的备份和恢复。</p><p>备忘录模式的应用场景也比较明确和有限，主要用来防丢失、撤销、恢复等。它跟平时我们常说的“备份”很相似。两者的主要区别在于，备忘录模式更侧重于代码的设计和实现，备份更侧重架构设计或产品设计。</p><p>对于大对象的备份来说，备份占用的存储空间会比较大，备份和恢复的耗时会比较长。针对这个问题，不同的业务场景有不同的处理方式。比如，只备份必要的恢复信息，结合最新的数据来恢复；再比如，全量备份和增量备份相结合，低频全量备份，高频增量备份，两者结合来做恢复。</p><h3>9.命令模式</h3><p>命令模式在平时工作中并不常用，你稍微了解一下就可以。</p><p>落实到编码实现，命令模式用到最核心的实现手段，就是将函数封装成对象。我们知道，在大部分编程语言中，函数是没法作为参数传递给其他函数的，也没法赋值给变量。借助命令模式，我们将函数封装成对象，这样就可以实现把函数像对象一样使用。</p><p>命令模式的主要作用和应用场景，是用来控制命令的执行，比如，异步、延迟、排队执行命令、撤销重做命令、存储命令、给命令记录日志等，这才是命令模式能发挥独一无二作用的地方。</p><h3>10.解释器模式</h3><p>解释器模式为某个语言定义它的语法（或者叫文法）表示，并定义一个解释器用来处理这个语法。实际上，这里的“语言”不仅仅指我们平时说的中、英、日、法等各种语言。从广义上来讲，只要是能承载信息的载体，我们都可以称之为“语言”，比如，古代的结绳记事、盲文、哑语、摩斯密码等。</p><p>要想了解“语言”要表达的信息，我们就必须定义相应的语法规则。这样，书写者就可以根据语法规则来书写“句子”（专业点的叫法应该是“表达式”），阅读者根据语法规则来阅读“句子”，这样才能做到信息的正确传递。而我们要讲的解释器模式，其实就是用来实现根据语法规则解读“句子”的解释器。</p><p>解释器模式的代码实现比较灵活，没有固定的模板。我们前面说过，应用设计模式主要是应对代码的复杂性，解释器模式也不例外。它的代码实现的核心思想，就是将语法解析的工作拆分到各个小类中，以此来避免大而全的解析类。一般的做法是，将语法规则拆分一些小的独立的单元，然后对每个单元进行解析，最终合并为对整个语法规则的解析。</p><h3>11.中介模式</h3><p>中介模式的设计思想跟中间层很像，通过引入中介这个中间层，将一组对象之间的交互关系（或者说依赖关系）从多对多（网状关系）转换为一对多（星状关系）。原来一个对象要跟n个对象交互，现在只需要跟一个中介对象交互，从而最小化对象之间的交互关系，降低了代码的复杂度，提高了代码的可读性和可维护性。</p><p>观察者模式和中介模式都是为了实现参与者之间的解耦，简化交互关系。两者的不同在于应用场景上。在观察者模式的应用场景中，参与者之间的交互比较有条理，一般都是单向的，一个参与者只有一个身份，要么是观察者，要么是被观察者。而在中介模式的应用场景中，参与者之间的交互关系错综复杂，既可以是消息的发送者、也可以同时是消息的接收者。</p><h2>课堂讨论</h2><p>终于学完了这23种设计模式，针对这些设计模式，你还有哪些疑问？可以在留言区说一说。</p><p>如果有收获，欢迎你收藏这篇文章，反复阅读，并把它分享给你的朋友。</p>",
                "article_title": "74 | 总结回顾23种经典设计模式的原理、背后的思想、应用场景等"
            },
            {
                "title": "75 | 在实际的项目开发中，如何避免过度设计？又如何避免设计不足？",
                "herf": "https://time.geekbang.org/column/article/229157",
                "id": "229157",
                "content": "<p>设计模式的理论部分已经全部学习完了。现在，你可能已经蠢蠢欲动，想要赶紧实践一把，把这些理论应用到自己的项目中。不过，这里我要给你提个醒了，千万别手里拿着锤子就看什么都是钉子啊。</p><p>在我过往的项目经历中，经常遇到两种同事。</p><p>一种同事会过度设计。在开始编写代码之前，他会花很长时间做代码设计，在开发过程中应用各种设计模式，美其名曰未雨绸缪，希望代码更加灵活，为未来的扩展打好基础，实则过度设计，未来的需求并不一定会实现，实际上是增加了代码的复杂度，以后的所有开发都要在这套复杂的设计基础之上来完成。</p><p>除此之外，还有一种是设计不足。怎么简单怎么来，写出来的代码能跑就可以，顶多算是demo，看似在实践KISS、YAGNI原则，实则忽略了设计环节，代码毫无扩展性、灵活性可言，添加、修改一个很小的功能就要改动很多代码。</p><p>所以，今天我想和你聊一下，在实际的项目开发中，如何避免过度设计，以及如何避免设计不足。话不多说，让我们正式开始今天的内容吧！</p><h2>设计的初衷是提高代码质量</h2><p>创业时，我们经常会讲到一个词：初心。这词说的其实就是，你到底是为什么干这件事。不管走多远、产品经过多少迭代、转变多少次方向，“初心”一般都不会随便改。当我们在为产品该不该转型、该不该做某个功能而拿捏不定的时候，想想它符不符合我们创业的初心，有时候就自然有答案了。</p><!-- [[[read_end]]] --><p>实际上，应用设计模式也是如此。应用设计模式只是方法，最终的目的，也就是初心，是提高代码的质量。具体点说就是，提高代码的可读性、可扩展性、可维护性等。所有的设计都是围绕着这个初心来做的。</p><p>所以，在做代码设计的时候，你一定要先问下自己，为什么要这样设计，为什么要应用这种设计模式，这样做是否能真正地提高代码质量，能提高代码质量的哪些方面。如果自己很难讲清楚，或者给出的理由都比较牵强，没有压倒性的优势，那基本上就可以断定这是一种过度设计，是为了设计而设计。</p><p>实际上，设计原则和思想是心法，设计模式只是招式。掌握心法，以不变应万变，无招胜有招。所以，设计原则和思想比设计模式更加普适、重要。掌握了设计原则和思想，我们能更清楚地了解为什么要用某种设计模式，就能更恰到好处地应用设计模式，甚至我们还可以自己创造出来新的设计模式。</p><h2>设计的过程是先有问题后有方案</h2><p>如果我们把写出的代码看作产品，那做产品的时候，我们先要思考痛点在哪里，用户的真正需求在哪里，然后再看要开发哪些功能去满足，而不是先拍脑袋想出一个花哨的功能，再去东搬西凑硬编出一个需求来。</p><p>代码设计也是类似的。我们先要去分析代码存在的痛点，比如可读性不好、可扩展性不好等等，然后再针对性地利用设计模式去改善，而不是看到某个场景之后，觉得跟之前在某本书中看到的某个设计模式的应用场景很相似，就套用上去，也不考虑到底合不合适，最后如果有人问起了，就再找几个不痛不痒、很不具体的伪需求来搪塞，比如提高了代码的扩展性、满足了开闭原则等等。</p><p>实际上，很多没有太多开发经验的新手，往往在学完设计模式之后会非常“学生气”，拿原理当真理，不懂得具体问题具体分析，手里拿着锤子看哪都是钉子，不分青红皂白，上来就是套用某个设计模式。写完之后，看着自己写的很复杂的代码，还沾沾自喜，甚至到处炫耀。这完全是无知地炫技，半瓶子不满大抵就是这个样子的。等你慢慢成长之后，回过头来再看自己当年的代码，我相信你应该会感到脸红的。这里我的话说得有点重，我主要还是担心你以后在项目中，过度设计被别人鄙视，所以提前给你打个预防针！</p><p>所以，我的专栏讲解中，一直是从问题讲起，一步一步给你展示为什么要用某个设计模式，而不是一开始就告诉你最终的设计。实际上，这还不是最重要的，最重要的是我想培养你分析问题、解决问题的能力。这样，看到某段代码之后，你就能够自己分析得头头是道，说出它好的地方、不好的地方，为什么好、为什么不好，不好的如何改善，可以应用哪种设计模式，应用了之后有哪些副作用要控制等等。</p><p>相反，如果你只是掌握了理论知识，即便你把23种设计模式的原理和实现背得滚瓜烂熟，不具备具体问题具体分析的能力，在面对真实项目的千变万化的代码的时候，很容易就会滥用设计模式，过度设计。</p><h2>设计的应用场景是复杂代码</h2><p>很多设计模式相关的书籍都会举一些简单的例子，这些例子仅仅具有教学意义，只是为了讲解设计模式的原理和实现，力求在有限篇幅内给你讲明白。而很多人就会误以为这些简单的例子就是这些设计模式的典型应用场景，常常照葫芦画瓢地应用到自己的项目中，用复杂的设计模式去解决简单的问题，还振振有词地说某某经典书中就是这么写的。在我看来，这是很多初学者因为缺乏经验，在学完设计模式之后，在项目中过度设计的首要原因。</p><p>前面我们讲到，设计模式要干的事情就是解耦，也就是利用更好的代码结构将一大坨代码拆分成职责更单一的小类，让其满足高内聚低耦合等特性。创建型模式是将创建和使用代码解耦，结构型模式是将不同的功能代码解耦，行为型模式是将不同的行为代码解耦。而解耦的主要目的是应对代码的复杂性。设计模式就是为了解决复杂代码问题而产生的。</p><p>因此，对于复杂代码，比如项目代码量多、开发周期长、参与开发的人员多，我们前期要多花点时间在设计上，越是复杂代码，花在设计上的时间就要越多。</p><p>不仅如此，每次提交的代码，都要保证代码质量，都要经过足够的思考和精心的设计，这样才能避免烂代码效应（每次提交的代码质量都不是太好，最终积累起来整个项目的质量就变得很差）。</p><p>相反，如果你参与的只是一个简单的项目，代码量不多，开发人员也不多，那简单的问题用简单的解决方案就好，不要引入过于复杂的设计模式，将简单问题复杂化。</p><h2>持续重构能有效避免过度设计</h2><p>我们知道，应用设计模式会提高代码的可扩展性，但同时也会带来代码可读性的降低，复杂度的升高。一旦我们引入某个复杂的设计，之后即便在很长一段时间都没有扩展的需求，我们也不可能将这个复杂的设计删除，整个团队都要一直背负着这个复杂的设计前行。</p><p>为了避免错误的需求预判导致的过度设计，我非常推崇持续重构的开发方法。持续重构不仅仅是保证代码质量的重要手段，也是避免过度设计的有效方法。在真正有痛点的时候，我们再去考虑用设计模式来解决，而不是一开始就为不一定实现的未来需求而应用设计模式。</p><p>当对要不要应用某种设计模式感到模棱两可的时候，你可以思考一下，如果暂时不用这种设计模式，随着代码的演进，当某一天不得不去使用它的时候，重构的代码是否很大。如果不是，那能不用就不用，怎么简单就怎么来。说句实话，对于10万行以内的代码，团队成员稳定，对代码涉及的业务比较熟悉的情况下，即便将所有的代码都推倒重写，也不会花太多时间，因此也不必为代码的扩展性太过担忧。</p><h2>避免设计不足的3个必要条件</h2><p>前面大部分讲到的都是如何避免过度设计，我们再稍微讲讲如何避免设计不足。</p><p>首先，你要有一定理论知识的储备。</p><p>比如你要熟练掌握各种设计原则、思想、编码规范、设计模式。理论知识是解决问题的工具，是前人智慧的结晶。没有理论知识，就相当于游戏中没有厉害的装备，虽然可以靠身手徒手打怪，但肯定会影响你最高水平的发挥。</p><p>其次，你还要有一定的刻意训练。</p><p>很多同学很苦恼，说理论知识都学过，但是很容易忘记，遇到问题也想不到对应的知识点。实际上，这就是缺乏理论结合实践的刻意训练。我们回想一下上学的时候，我们是如何学习的。老师讲解完某个知识点之后，往往会配合讲解几道例题，然后再让你做上个几十道题去强化这个知识点。这样当你再遇到类似的问题的时候，就能不由自主地联想到相应的知识点。而工作之后，我们自己看书学知识，别说拿几个场景来实践了，大部分都是走马观花地看看，没有经过刻意的训练，知识积累不了，能力也锻炼不了，等于白学。</p><p>最后，你一定要有代码质量意识、设计意识。</p><p>在写代码之前，要多想想未来会有哪些扩展的需求，哪部分是会变的，哪部分是不变的，这样写会不会导致之后添加新的功能比较困难，代码的可读性好不好等代码质量问题。有了这样的意识，实际上，你就离写出高质量的代码不远了。</p><h2>不要脱离具体的场景去谈设计</h2><p>设计是一个非常主观的事情，不夸张地讲，可以称之为一门“艺术”。那相应地，好坏就很难评判了。如果真的要评判，我们要放到具体的场景中。脱离具体的场景去谈论设计是否合理，都是空谈。这就像我们经常说的，脱离业务谈架构都是“耍流氓”。</p><p>比如，一个手游项目是否能被市场接受，往往非常不确定。很多手游项目开发出来之后，市场反馈很差，立马就放弃了。除此之外，尽快上市占领市场也是一款手游致胜的关键。所以，对于手游项目的开发来说，往往前期不会花太多的时间在代码设计、代码质量上。</p><p>相反，如果你开发的是MMORPG大型端游，一般都要投资上亿资金，几百号人开发好几年，推倒重来的成本很大。这个时候，代码质量就非常关键了。前期就要多花点时间在设计上，否则，代码质量太差，bug太多，后期无法维护，也会导致很多用户弃而选择同类型的其他家的游戏。</p><p>再比如，如果我们开发的是偏底层的、框架类的、通用的代码，那代码质量就比较重要，因为一旦出现问题或者代码改动，影响面就比较大。相反，如果我们开发的是业务系统或者不需要长期维护的项目，那稍微放低点代码质量的要求，也是没问题的，而且，自己的代码跟其他项目没有太多耦合，即便出了问题，影响也不大。</p><h2>课堂讨论</h2><p>如何避免过度设计？如何避免设计不足？关于这个话题，你还有哪些心得体会、经验教训可以在留言区说一说，分享给大家。</p><p>如果有收获，欢迎你把这篇文章分享给你的朋友。</p>",
                "article_title": "75 | 在实际的项目开发中，如何避免过度设计？又如何避免设计不足？"
            }
        ]
    },
    {
        "chapterTitle": "开源与项目实战：开源实战 (14讲)",
        "children": [
            {
                "title": "76 |  开源实战一（上）：通过剖析Java JDK源码学习灵活应用设计模式",
                "herf": "https://time.geekbang.org/column/article/229996",
                "id": "229996",
                "content": "<p>从今天开始，我们就正式地进入到实战环节。实战环节包括两部分，一部分是开源项目实战，另一部分是项目实战。</p><p>在开源项目实战部分，我会带你剖析几个经典的开源项目中用到的设计原则、思想和模式，这其中就包括对Java JDK、Unix、Google Guava、Spring、MyBatis这样五个开源项目的分析。在项目实战部分，我们精心挑选了几个实战项目，手把手地带你利用之前学过的设计原则、思想、模式，来对它们进行分析、设计和代码实现，这其中就包括鉴权限流、幂等重试、灰度发布这样三个项目。</p><p>接下来的两节课，我们重点剖析Java JDK中用到的几种常见的设计模式。学习的目的是让你体会，在真实的项目开发中，要学会活学活用，切不可过于死板，生搬硬套设计模式的设计与实现。除此之外，针对每个模式，我们不可能像前面学习理论知识那样，分析得细致入微，很多都是点到为止。在已经具备之前理论知识的前提下，我想你可以跟着我的指引自己去研究，有哪里不懂的话，也可以再回过头去看下之前的理论讲解。</p><p>话不多说，让我们正式开始今天的学习吧！</p><h2>工厂模式在Calendar类中的应用</h2><p>在前面讲到工厂模式的时候，大部分工厂类都是以Factory作为后缀来命名，并且工厂类主要负责创建对象这样一件事情。但在实际的项目开发中，工厂类的设计更加灵活。那我们就来看下，工厂模式在Java JDK中的一个应用：java.util.Calendar。从命名上，我们无法看出它是一个工厂类。</p><!-- [[[read_end]]] --><p>Calendar类提供了大量跟日期相关的功能代码，同时，又提供了一个getInstance()工厂方法，用来根据不同的TimeZone和Locale创建不同的Calendar子类对象。也就是说，功能代码和工厂方法代码耦合在了一个类中。所以，即便我们去查看它的源码，如果不细心的话，也很难发现它用到了工厂模式。同时，因为它不单单是一个工厂类，所以，它并没有以Factory作为后缀来命名。</p><p>Calendar类的相关代码如下所示，大部分代码都已经省略，我只给出了getInstance()工厂方法的代码实现。从代码中，我们可以看出，getInstance()方法可以根据不同TimeZone和Locale，创建不同的Calendar子类对象，比如BuddhistCalendar、JapaneseImperialCalendar、GregorianCalendar，这些细节完全封装在工厂方法中，使用者只需要传递当前的时区和地址，就能够获得一个Calendar类对象来使用，而获得的对象具体是哪个Calendar子类的对象，使用者在使用的时候并不关心。</p><pre><code>public abstract class Calendar implements Serializable, Cloneable, Comparable&lt;Calendar&gt; {\n  //...\n  public static Calendar getInstance(TimeZone zone, Locale aLocale){\n    return createCalendar(zone, aLocale);\n  }\n\n  private static Calendar createCalendar(TimeZone zone,Locale aLocale) {\n    CalendarProvider provider = LocaleProviderAdapter.getAdapter(\n        CalendarProvider.class, aLocale).getCalendarProvider();\n    if (provider != null) {\n      try {\n        return provider.getInstance(zone, aLocale);\n      } catch (IllegalArgumentException iae) {\n        // fall back to the default instantiation\n      }\n    }\n\n    Calendar cal = null;\n    if (aLocale.hasExtensions()) {\n      String caltype = aLocale.getUnicodeLocaleType(&quot;ca&quot;);\n      if (caltype != null) {\n        switch (caltype) {\n          case &quot;buddhist&quot;:\n            cal = new BuddhistCalendar(zone, aLocale);\n            break;\n          case &quot;japanese&quot;:\n            cal = new JapaneseImperialCalendar(zone, aLocale);\n            break;\n          case &quot;gregory&quot;:\n            cal = new GregorianCalendar(zone, aLocale);\n            break;\n        }\n      }\n    }\n    if (cal == null) {\n      if (aLocale.getLanguage() == &quot;th&quot; &amp;&amp; aLocale.getCountry() == &quot;TH&quot;) {\n        cal = new BuddhistCalendar(zone, aLocale);\n      } else if (aLocale.getVariant() == &quot;JP&quot; &amp;&amp; aLocale.getLanguage() == &quot;ja&quot; &amp;&amp; aLocale.getCountry() == &quot;JP&quot;) {\n        cal = new JapaneseImperialCalendar(zone, aLocale);\n      } else {\n        cal = new GregorianCalendar(zone, aLocale);\n      }\n    }\n    return cal;\n  }\n  //...\n}\n</code></pre><h2>建造者模式在Calendar类中的应用</h2><p>还是刚刚的Calendar类，它不仅仅用到了工厂模式，还用到了建造者模式。我们知道，建造者模式有两种实现方法，一种是单独定义一个Builder类，另一种是将Builder实现为原始类的内部类。Calendar就采用了第二种实现思路。我们先来看代码再讲解，相关代码我贴在了下面。</p><pre><code>public abstract class Calendar implements Serializable, Cloneable, Comparable&lt;Calendar&gt; {\n  //...\n  public static class Builder {\n    private static final int NFIELDS = FIELD_COUNT + 1;\n    private static final int WEEK_YEAR = FIELD_COUNT;\n    private long instant;\n    private int[] fields;\n    private int nextStamp;\n    private int maxFieldIndex;\n    private String type;\n    private TimeZone zone;\n    private boolean lenient = true;\n    private Locale locale;\n    private int firstDayOfWeek, minimalDaysInFirstWeek;\n\n    public Builder() {}\n    \n    public Builder setInstant(long instant) {\n        if (fields != null) {\n            throw new IllegalStateException();\n        }\n        this.instant = instant;\n        nextStamp = COMPUTED;\n        return this;\n    }\n    //...省略n多set()方法\n    \n    public Calendar build() {\n      if (locale == null) {\n        locale = Locale.getDefault();\n      }\n      if (zone == null) {\n        zone = TimeZone.getDefault();\n      }\n      Calendar cal;\n      if (type == null) {\n        type = locale.getUnicodeLocaleType(&quot;ca&quot;);\n      }\n      if (type == null) {\n        if (locale.getCountry() == &quot;TH&quot; &amp;&amp; locale.getLanguage() == &quot;th&quot;) {\n          type = &quot;buddhist&quot;;\n        } else {\n          type = &quot;gregory&quot;;\n        }\n      }\n      switch (type) {\n        case &quot;gregory&quot;:\n          cal = new GregorianCalendar(zone, locale, true);\n          break;\n        case &quot;iso8601&quot;:\n          GregorianCalendar gcal = new GregorianCalendar(zone, locale, true);\n          // make gcal a proleptic Gregorian\n          gcal.setGregorianChange(new Date(Long.MIN_VALUE));\n          // and week definition to be compatible with ISO 8601\n          setWeekDefinition(MONDAY, 4);\n          cal = gcal;\n          break;\n        case &quot;buddhist&quot;:\n          cal = new BuddhistCalendar(zone, locale);\n          cal.clear();\n          break;\n        case &quot;japanese&quot;:\n          cal = new JapaneseImperialCalendar(zone, locale, true);\n          break;\n        default:\n          throw new IllegalArgumentException(&quot;unknown calendar type: &quot; + type);\n      }\n      cal.setLenient(lenient);\n      if (firstDayOfWeek != 0) {\n        cal.setFirstDayOfWeek(firstDayOfWeek);\n        cal.setMinimalDaysInFirstWeek(minimalDaysInFirstWeek);\n      }\n      if (isInstantSet()) {\n        cal.setTimeInMillis(instant);\n        cal.complete();\n        return cal;\n      }\n\n      if (fields != null) {\n        boolean weekDate = isSet(WEEK_YEAR) &amp;&amp; fields[WEEK_YEAR] &gt; fields[YEAR];\n        if (weekDate &amp;&amp; !cal.isWeekDateSupported()) {\n          throw new IllegalArgumentException(&quot;week date is unsupported by &quot; + type);\n        }\n        for (int stamp = MINIMUM_USER_STAMP; stamp &lt; nextStamp; stamp++) {\n          for (int index = 0; index &lt;= maxFieldIndex; index++) {\n            if (fields[index] == stamp) {\n              cal.set(index, fields[NFIELDS + index]);\n              break;\n             }\n          }\n        }\n\n        if (weekDate) {\n          int weekOfYear = isSet(WEEK_OF_YEAR) ? fields[NFIELDS + WEEK_OF_YEAR] : 1;\n          int dayOfWeek = isSet(DAY_OF_WEEK) ? fields[NFIELDS + DAY_OF_WEEK] : cal.getFirstDayOfWeek();\n          cal.setWeekDate(fields[NFIELDS + WEEK_YEAR], weekOfYear, dayOfWeek);\n        }\n        cal.complete();\n      }\n      return cal;\n    }\n  }\n}\n</code></pre><p>看了上面的代码，我有一个问题请你思考一下：既然已经有了getInstance()工厂方法来创建Calendar类对象，为什么还要用Builder来创建Calendar类对象呢？这两者之间的区别在哪里呢？</p><p>实际上，在前面讲到这两种模式的时候，我们对它们之间的区别做了详细的对比，现在，我们再来一块回顾一下。工厂模式是用来创建不同但是相关类型的对象（继承同一父类或者接口的一组子类），由给定的参数来决定创建哪种类型的对象。建造者模式用来创建一种类型的复杂对象，通过设置不同的可选参数，“定制化”地创建不同的对象。</p><p>网上有一个经典的例子很好地解释了两者的区别。</p><blockquote>\n<p>顾客走进一家餐馆点餐，我们利用工厂模式，根据用户不同的选择，来制作不同的食物，比如披萨、汉堡、沙拉。对于披萨来说，用户又有各种配料可以定制，比如奶酪、西红柿、起司，我们通过建造者模式根据用户选择的不同配料来制作不同的披萨。</p>\n</blockquote><p>粗看Calendar的Builder类的build()方法，你可能会觉得它有点像工厂模式。你的感觉没错，前面一半代码确实跟getInstance()工厂方法类似，根据不同的type创建了不同的Calendar子类。实际上，后面一半代码才属于标准的建造者模式，根据setXXX()方法设置的参数，来定制化刚刚创建的Calendar子类对象。</p><p>你可能会说，这还能算是建造者模式吗？我用<a href=\"https://time.geekbang.org/column/article/199674\">第46讲</a>的一段话来回答你：</p><blockquote>\n<p>我们也不要太学院派，非得把工厂模式、建造者模式分得那么清楚，我们需要知道的是，每个模式为什么这么设计，能解决什么问题。只有了解了这些最本质的东西，我们才能不生搬硬套，才能灵活应用，甚至可以混用各种模式，创造出新的模式来解决特定场景的问题。</p>\n</blockquote><p>实际上，从Calendar这个例子，我们也能学到，不要过于死板地套用各种模式的原理和实现，不要不敢做丝毫的改动。模式是死的，用的人是活的。在实际上的项目开发中，不仅各种模式可以混合在一起使用，而且具体的代码实现，也可以根据具体的功能需求做灵活的调整。</p><h2>装饰器模式在Collections类中的应用</h2><p>我们前面讲到，Java IO类库是装饰器模式的非常经典的应用。实际上，Java的Collections类也用到了装饰器模式。</p><p>Collections类是一个集合容器的工具类，提供了很多静态方法，用来创建各种集合容器，比如通过unmodifiableColletion()静态方法，来创建UnmodifiableCollection类对象。而这些容器类中的UnmodifiableCollection类、CheckedCollection和SynchronizedCollection类，就是针对Collection类的装饰器类。</p><p>因为刚刚提到的这三个装饰器类，在代码结构上几乎一样，所以，我们这里只拿其中的UnmodifiableCollection类来举例讲解一下。UnmodifiableCollection类是Collections类的一个内部类，相关代码我摘抄到了下面，你可以先看下。</p><pre><code>public class Collections {\n  private Collections() {}\n    \n  public static &lt;T&gt; Collection&lt;T&gt; unmodifiableCollection(Collection&lt;? extends T&gt; c) {\n    return new UnmodifiableCollection&lt;&gt;(c);\n  }\n\n  static class UnmodifiableCollection&lt;E&gt; implements Collection&lt;E&gt;,   Serializable {\n    private static final long serialVersionUID = 1820017752578914078L;\n    final Collection&lt;? extends E&gt; c;\n\n    UnmodifiableCollection(Collection&lt;? extends E&gt; c) {\n      if (c==null)\n        throw new NullPointerException();\n      this.c = c;\n    }\n\n    public int size()                   {return c.size();}\n    public boolean isEmpty()            {return c.isEmpty();}\n    public boolean contains(Object o)   {return c.contains(o);}\n    public Object[] toArray()           {return c.toArray();}\n    public &lt;T&gt; T[] toArray(T[] a)       {return c.toArray(a);}\n    public String toString()            {return c.toString();}\n\n    public Iterator&lt;E&gt; iterator() {\n      return new Iterator&lt;E&gt;() {\n        private final Iterator&lt;? extends E&gt; i = c.iterator();\n\n        public boolean hasNext() {return i.hasNext();}\n        public E next()          {return i.next();}\n        public void remove() {\n          throw new UnsupportedOperationException();\n        }\n        @Override\n        public void forEachRemaining(Consumer&lt;? super E&gt; action) {\n          // Use backing collection version\n          i.forEachRemaining(action);\n        }\n      };\n    }\n\n    public boolean add(E e) {\n      throw new UnsupportedOperationException();\n    }\n    public boolean remove(Object o) {\n       hrow new UnsupportedOperationException();\n    }\n    public boolean containsAll(Collection&lt;?&gt; coll) {\n      return c.containsAll(coll);\n    }\n    public boolean addAll(Collection&lt;? extends E&gt; coll) {\n      throw new UnsupportedOperationException();\n    }\n    public boolean removeAll(Collection&lt;?&gt; coll) {\n      throw new UnsupportedOperationException();\n    }\n    public boolean retainAll(Collection&lt;?&gt; coll) {\n      throw new UnsupportedOperationException();\n    }\n    public void clear() {\n      throw new UnsupportedOperationException();\n    }\n\n    // Override default methods in Collection\n    @Override\n    public void forEach(Consumer&lt;? super E&gt; action) {\n      c.forEach(action);\n    }\n    @Override\n    public boolean removeIf(Predicate&lt;? super E&gt; filter) {\n      throw new UnsupportedOperationException();\n    }\n    @SuppressWarnings(&quot;unchecked&quot;)\n    @Override\n    public Spliterator&lt;E&gt; spliterator() {\n      return (Spliterator&lt;E&gt;)c.spliterator();\n    }\n    @SuppressWarnings(&quot;unchecked&quot;)\n    @Override\n    public Stream&lt;E&gt; stream() {\n      return (Stream&lt;E&gt;)c.stream();\n    }\n    @SuppressWarnings(&quot;unchecked&quot;)\n    @Override\n    public Stream&lt;E&gt; parallelStream() {\n      return (Stream&lt;E&gt;)c.parallelStream();\n    }\n  }\n}\n</code></pre><p>看了上面的代码，请你思考一下，为什么说UnmodifiableCollection类是Collection类的装饰器类呢？这两者之间可以看作简单的接口实现关系或者类继承关系吗？</p><p>我们前面讲过，装饰器模式中的装饰器类是对原始类功能的增强。尽管UnmodifiableCollection类可以算是对Collection类的一种功能增强，但这点还不具备足够的说服力来断定UnmodifiableCollection就是Collection类的装饰器类。</p><p>实际上，最关键的一点是，UnmodifiableCollection的构造函数接收一个Collection类对象，然后对其所有的函数进行了包裹（Wrap）：重新实现（比如add()函数）或者简单封装（比如stream()函数）。而简单的接口实现或者继承，并不会如此来实现UnmodifiableCollection类。所以，从代码实现的角度来说，UnmodifiableCollection类是典型的装饰器类。</p><h2>适配器模式在Collections类中的应用</h2><p>在<a href=\"https://time.geekbang.org/column/article/205912\">第51讲</a>中我们讲到，适配器模式可以用来兼容老的版本接口。当时我们举了一个JDK的例子，这里我们再重新仔细看一下。</p><p>老版本的JDK提供了Enumeration类来遍历容器。新版本的JDK用Iterator类替代Enumeration类来遍历容器。为了兼容老的客户端代码（使用老版本JDK的代码），我们保留了Enumeration类，并且在Collections类中，仍然保留了enumaration()静态方法（因为我们一般都是通过这个静态函数来创建一个容器的Enumeration类对象）。</p><p>不过，保留Enumeration类和enumeration()函数，都只是为了兼容，实际上，跟适配器没有一点关系。那到底哪一部分才是适配器呢？</p><p>在新版本的JDK中，Enumeration类是适配器类。它适配的是客户端代码（使用Enumeration类）和新版本JDK中新的迭代器Iterator类。不过，从代码实现的角度来说，这个适配器模式的代码实现，跟经典的适配器模式的代码实现，差别稍微有点大。enumeration()静态函数的逻辑和Enumeration适配器类的代码耦合在一起，enumeration()静态函数直接通过new的方式创建了匿名类对象。具体的代码如下所示：</p><pre><code>/**\n * Returns an enumeration over the specified collection.  This provides\n * interoperability with legacy APIs that require an enumeration\n * as input.\n *\n * @param  &lt;T&gt; the class of the objects in the collection\n * @param c the collection for which an enumeration is to be returned.\n * @return an enumeration over the specified collection.\n * @see Enumeration\n */\npublic static &lt;T&gt; Enumeration&lt;T&gt; enumeration(final Collection&lt;T&gt; c) {\n  return new Enumeration&lt;T&gt;() {\n    private final Iterator&lt;T&gt; i = c.iterator();\n\n    public boolean hasMoreElements() {\n      return i.hasNext();\n    }\n\n    public T nextElement() {\n      return i.next();\n    }\n  };\n}\n</code></pre><h2>重点回顾</h2><p>好了，今天的内容到此就讲完了。我们一块来总结回顾一下，你需要重点掌握的内容。</p><p>今天，我重点讲了工厂模式、建造者模式、装饰器模式、适配器模式，这四种模式在Java JDK中的应用，主要目的是给你展示真实项目中是如何灵活应用设计模式的。</p><p>从今天的讲解中，我们可以学习到，尽管在之前的理论讲解中，我们都有讲到每个模式的经典代码实现，但是，在真实的项目开发中，这些模式的应用更加灵活，代码实现更加自由，可以根据具体的业务场景、功能需求，对代码实现做很大的调整，甚至还可能会对模式本身的设计思路做调整。</p><p>比如，Java JDK中的Calendar类，就耦合了业务功能代码、工厂方法、建造者类三种类型的代码，而且，在建造者类的build()方法中，前半部分是工厂方法的代码实现，后半部分才是真正的建造者模式的代码实现。这也告诉我们，在项目中应用设计模式，切不可生搬硬套，过于学院派，要学会结合实际情况做灵活调整，做到心中无剑胜有剑。</p><h2>课堂讨论</h2><p>在Java中，经常用到的StringBuilder类是否是建造者模式的应用呢？你可以试着像我一样从源码的角度去剖析一下。</p><p>欢迎留言和我分享你的想法。如果有收获，也欢迎你把这篇文章分享给你的朋友。</p>",
                "article_title": "76 |  开源实战一（上）：通过剖析Java JDK源码学习灵活应用设计模式"
            },
            {
                "title": "77 | 开源实战一（下）：通过剖析Java JDK源码学习灵活应用设计模式",
                "herf": "https://time.geekbang.org/column/article/230708",
                "id": "230708",
                "content": "<p>上一节课，我们讲解了工厂模式、建造者模式、装饰器模式、适配器模式在Java JDK中的应用，其中，Calendar类用到了工厂模式和建造者模式，Collections类用到了装饰器模式、适配器模式。学习的重点是让你了解，在真实的项目中模式的实现和应用更加灵活、多变，会根据具体的场景做实现或者设计上的调整。</p><p>今天，我们继续延续这个话题，再重点讲一下模板模式、观察者模式这两个模式在JDK中的应用。除此之外，我还会对在理论部分已经讲过的一些模式在JDK中的应用做一个汇总，带你一块回忆复习一下。</p><p>话不多说，让我们正式开始今天的学习吧！</p><h2>模板模式在Collections类中的应用</h2><p>我们前面提到，策略、模板、职责链三个模式常用在框架的设计中，提供框架的扩展点，让框架使用者，在不修改框架源码的情况下，基于扩展点定制化框架的功能。Java中的Collections类的sort()函数就是利用了模板模式的这个扩展特性。</p><p>首先，我们看下Collections.sort()函数是如何使用的。我写了一个示例代码，如下所示。这个代码实现了按照不同的排序方式（按照年龄从小到大、按照名字字母序从小到大、按照成绩从大到小）对students数组进行排序。</p><!-- [[[read_end]]] --><pre><code>public class Demo {\n  public static void main(String[] args) {\n    List&lt;Student&gt; students = new ArrayList&lt;&gt;();\n    students.add(new Student(&quot;Alice&quot;, 19, 89.0f));\n    students.add(new Student(&quot;Peter&quot;, 20, 78.0f));\n    students.add(new Student(&quot;Leo&quot;, 18, 99.0f));\n\n    Collections.sort(students, new AgeAscComparator());\n    print(students);\n    \n    Collections.sort(students, new NameAscComparator());\n    print(students);\n    \n    Collections.sort(students, new ScoreDescComparator());\n    print(students);\n  }\n\n  public static void print(List&lt;Student&gt; students) {\n    for (Student s : students) {\n      System.out.println(s.getName() + &quot; &quot; + s.getAge() + &quot; &quot; + s.getScore());\n    }\n  }\n\n  public static class AgeAscComparator implements Comparator&lt;Student&gt; {\n    @Override\n    public int compare(Student o1, Student o2) {\n      return o1.getAge() - o2.getAge();\n    }\n  }\n\n  public static class NameAscComparator implements Comparator&lt;Student&gt; {\n    @Override\n    public int compare(Student o1, Student o2) {\n      return o1.getName().compareTo(o2.getName());\n    }\n  }\n\n  public static class ScoreDescComparator implements Comparator&lt;Student&gt; {\n    @Override\n    public int compare(Student o1, Student o2) {\n      if (Math.abs(o1.getScore() - o2.getScore()) &lt; 0.001) {\n        return 0;\n      } else if (o1.getScore() &lt; o2.getScore()) {\n        return 1;\n      } else {\n        return -1;\n      }\n    }\n  }\n}\n</code></pre><p>结合刚刚这个例子，我们再来看下，为什么说Collections.sort()函数用到了模板模式？</p><p>Collections.sort()实现了对集合的排序。为了扩展性，它将其中“比较大小”这部分逻辑，委派给用户来实现。如果我们把比较大小这部分逻辑看作整个排序逻辑的其中一个步骤，那我们就可以把它看作模板模式。不过，从代码实现的角度来看，它看起来有点类似之前讲过的JdbcTemplate，并不是模板模式的经典代码实现，而是基于Callback回调机制来实现的。</p><p>不过，在其他资料中，我还看到有人说，Collections.sort()使用的是策略模式。这样的说法也不是没有道理的。如果我们并不把“比较大小”看作排序逻辑中的一个步骤，而是看作一种算法或者策略，那我们就可以把它看作一种策略模式的应用。</p><p>不过，这也不是典型的策略模式，我们前面讲到，在典型的策略模式中，策略模式分为策略的定义、创建、使用这三部分。策略通过工厂模式来创建，并且在程序运行期间，根据配置、用户输入、计算结果等这些不确定因素，动态决定使用哪种策略。而在Collections.sort()函数中，策略的创建并非通过工厂模式，策略的使用也非动态确定。</p><h2>观察者模式在JDK中的应用</h2><p>在讲到观察者模式的时候，我们重点讲解了Google Guava的EventBus框架，它提供了观察者模式的骨架代码。使用EventBus，我们不需要从零开始开发观察者模式。实际上，Java JDK也提供了观察者模式的简单框架实现。在平时的开发中，如果我们不希望引入Google Guava开发库，可以直接使用Java语言本身提供的这个框架类。</p><p>不过，它比EventBus要简单多了，只包含两个类：java.util.Observable和java.util.Observer。前者是被观察者，后者是观察者。它们的代码实现也非常简单，为了方便你查看，我直接copy-paste到了这里。</p><pre><code>public interface Observer {\n    void update(Observable o, Object arg);\n}\n\npublic class Observable {\n    private boolean changed = false;\n    private Vector&lt;Observer&gt; obs;\n\n    public Observable() {\n        obs = new Vector&lt;&gt;();\n    }\n\n    public synchronized void addObserver(Observer o) {\n        if (o == null)\n            throw new NullPointerException();\n        if (!obs.contains(o)) {\n            obs.addElement(o);\n        }\n    }\n\n    public synchronized void deleteObserver(Observer o) {\n        obs.removeElement(o);\n    }\n\n    public void notifyObservers() {\n        notifyObservers(null);\n    }\n\n    public void notifyObservers(Object arg) {\n        Object[] arrLocal;\n\n        synchronized (this) {\n            if (!changed)\n                return;\n            arrLocal = obs.toArray();\n            clearChanged();\n        }\n\n        for (int i = arrLocal.length-1; i&gt;=0; i--)\n            ((Observer)arrLocal[i]).update(this, arg);\n    }\n\n    public synchronized void deleteObservers() {\n        obs.removeAllElements();\n    }\n\n    protected synchronized void setChanged() {\n        changed = true;\n    }\n\n    protected synchronized void clearChanged() {\n        changed = false;\n    }\n}\n</code></pre><p>对于Observable、Observer的代码实现，大部分都很好理解，我们重点来看其中的两个地方。一个是changed成员变量，另一个是notifyObservers()函数。</p><p><strong>我们先来看changed成员变量。</strong></p><p>它用来表明被观察者（Observable）有没有状态更新。当有状态更新时，我们需要手动调用setChanged()函数，将changed变量设置为true，这样才能在调用notifyObservers()函数的时候，真正触发观察者（Observer）执行update()函数。否则，即便你调用了notifyObservers()函数，观察者的update()函数也不会被执行。</p><p>也就是说，当通知观察者被观察者状态更新的时候，我们需要依次调用setChanged()和notifyObservers()两个函数，单独调用notifyObservers()函数是不起作用的。你觉得这样的设计是不是多此一举呢？这个问题留给你思考，你可以在留言区说说你的看法。</p><p><strong>我们再来看notifyObservers()函数。</strong></p><p>为了保证在多线程环境下，添加、移除、通知观察者三个操作之间不发生冲突，Observable类中的大部分函数都通过synchronized加了锁，不过，也有特例，notifyObservers()这函数就没有加synchronized锁。这是为什么呢？在JDK的代码实现中，notifyObservers()函数是如何保证跟其他函数操作不冲突的呢？这种加锁方法是否存在问题？又存在什么问题呢？</p><p>notifyObservers()函数之所以没有像其他函数那样，一把大锁加在整个函数上，主要还是出于性能的考虑。<br>\nnotifyObservers()函数依次执行每个观察者的update()函数，每个update()函数执行的逻辑提前未知，有可能会很耗时。如果在notifyObservers()函数上加synchronized锁，notifyObservers()函数持有锁的时间就有可能会很长，这就会导致其他线程迟迟获取不到锁，影响整个Observable类的并发性能。</p><p>我们知道，Vector类不是线程安全的，在多线程环境下，同时添加、删除、遍历Vector类对象中的元素，会出现不可预期的结果。所以，在JDK的代码实现中，为了避免直接给notifyObservers()函数加锁而出现性能问题，JDK采用了一种折中的方案。这个方案有点类似于我们之前讲过的让迭代器支持”快照“的解决方案。</p><p>在notifyObservers()函数中，我们先拷贝一份观察者列表，赋值给函数的局部变量，我们知道，局部变量是线程私有的，并不在线程间共享。这个拷贝出来的线程私有的观察者列表就相当于一个快照。我们遍历快照，逐一执行每个观察者的update()函数。而这个遍历执行的过程是在快照这个局部变量上操作的，不存在线程安全问题，不需要加锁。所以，我们只需要对拷贝创建快照的过程加锁，加锁的范围减少了很多，并发性能提高了。</p><p>为什么说这是一种折中的方案呢？这是因为，这种加锁方法实际上是存在一些问题的。在创建好快照之后，添加、删除观察者都不会更新快照，新加入的观察者就不会被通知到，新删除的观察者仍然会被通知到。这种权衡是否能接受完全看你的业务场景。实际上，这种处理方式也是多线程编程中减小锁粒度、提高并发性能的常用方法。</p><h2>单例模式在Runtime类中的应用</h2><p>JDK中java.lang.Runtime类就是一个单例类。这个类你有没有比较眼熟呢？是的，我们之前讲到Callback回调的时候，添加shutdown hook就是通过这个类来实现的。</p><p>每个Java应用在运行时会启动一个JVM进程，每个JVM进程都只对应一个Runtime实例，用于查看JVM状态以及控制JVM行为。进程内唯一，所以比较适合设计为单例。在编程的时候，我们不能自己去实例化一个Runtime对象，只能通过getRuntime()静态方法来获得。</p><p>Runtime类的的代码实现如下所示。这里面只包含部分相关代码，其他代码做了省略。从代码中，我们也可以看出，它使用了最简单的饿汉式的单例实现方式。</p><pre><code>/**\n * Every Java application has a single instance of class\n * &lt;code&gt;Runtime&lt;/code&gt; that allows the application to interface with\n * the environment in which the application is running. The current\n * runtime can be obtained from the &lt;code&gt;getRuntime&lt;/code&gt; method.\n * &lt;p&gt;\n * An application cannot create its own instance of this class.\n *\n * @author  unascribed\n * @see     java.lang.Runtime#getRuntime()\n * @since   JDK1.0\n */\npublic class Runtime {\n  private static Runtime currentRuntime = new Runtime();\n\n  public static Runtime getRuntime() {\n    return currentRuntime;\n  }\n  \n  /** Don't let anyone else instantiate this class */\n  private Runtime() {}\n  \n  //....\n  public void addShutdownHook(Thread hook) {\n    SecurityManager sm = System.getSecurityManager();\n    if (sm != null) {\n       sm.checkPermission(new RuntimePermission(&quot;shutdownHooks&quot;));\n    }\n    ApplicationShutdownHooks.add(hook);\n  }\n  //...\n}\n</code></pre><h2>其他模式在JDK中的应用汇总</h2><p>实际上，我们在讲解理论部分的时候，已经讲过很多模式在Java JDK中的应用了。这里我们一块再回顾一下，如果你对哪一部分有所遗忘，可以再回过头去看下。</p><p>在讲到模板模式的时候，我们结合Java Servlet、JUnit TestCase、Java InputStream、Java AbstractList四个例子，来具体讲解了它的两个作用：扩展性和复用性。<br>\n在讲到享元模式的时候，我们讲到Integer类中的-128~127之间的整型对象是可以复用的，还讲到String类型中的常量字符串也是可以复用的。这些都是享元模式的经典应用。</p><p>在讲到职责链模式的时候，我们讲到\bJava Servlet中的Filter就是通过职责链来实现的，同时还对比了Spring中的interceptor。实际上，拦截器、过滤器这些功能绝大部分都是采用职责链模式来实现的。</p><p>在讲到的迭代器模式的时候，我们重点剖析了Java中Iterator迭代器的实现，手把手带你实现了一个针对线性数据结构的迭代器。</p><h2>重点回顾</h2><p>好了，今天的内容到此就讲完了。我们一块来总结回顾一下，你需要重点掌握的内容。</p><p>这两节课主要剖析了JDK中用到的几个经典设计模式，其中重点剖析的有：工厂模式、建造者模式、装饰器模式、适配器模式、模板模式、观察者模式，除此之外，我们还汇总了其他模式在JDK中的应用，比如：单例模式、享元模式、职责链模式、迭代器模式。</p><p>实际上，源码都很简单，理解起来都不难，都没有跳出我们之前讲解的理论知识的范畴。学习的重点并不是表面上去理解、记忆某某类用了某某设计模式，而是让你了解我反复强调的一点，也是标题中突出的一点，在真实的项目开发中，如何灵活应用设计模式，做到活学活用，能够根据具体的场景、需求，做灵活的设计和实现上的调整。这也是模式新手和老手的最大区别。</p><h2>课堂讨论</h2><p>针对Java JDK中观察者模式的代码实现，我有两个问题请你思考。</p><ol>\n<li>每个函数都加一把synchronized大锁，会不会影响并发性能？有没有优化的方法？</li>\n<li>changed成员变量是否多此一举？</li>\n</ol><p>欢迎留言和我分享你的想法，如果有收获，也欢迎你把这篇文章分享给你的朋友。</p>",
                "article_title": "77 | 开源实战一（下）：通过剖析Java JDK源码学习灵活应用设计模式"
            },
            {
                "title": "78 | 开源实战二（上）：从Unix开源开发学习应对大型复杂项目开发",
                "herf": "https://time.geekbang.org/column/article/232061",
                "id": "232061",
                "content": "<p>软件开发的难度无外乎两点，一是技术难，意思是说，代码量不一定多，但要解决的问题比较难，需要用到一些比较深的技术解决方案或者算法，不是靠“堆人”就能搞定的，比如自动驾驶、图像识别、高性能消息队列等；二是复杂度，意思是说，技术不难，但项目很庞大，业务复杂，代码量多，参与开发的人多，比如物流系统、财务系统等。第一点涉及细分专业的领域知识，跟我们专栏要讲的设计、编码无关，所以我们重点来讲第二点，如何应对软件开发的复杂度。</p><p>简单的“hello world”程序，谁都能写得出来。几千行的代码谁都能维护得了。但是，当代码超过几万行、十几万，甚至几十万行、上百万行的时候，软件的复杂度就会呈指数级增长。这种情况下，我们不仅仅要求程序运行得了，运行得正确，还要求代码看得懂、维护得了。实际上，复杂度不仅仅体现在代码本身，还体现在协作研发上，如何管理庞大的团队，来进行有条不紊地协作开发，也是一个很复杂的难题。</p><p>如何应对复杂软件开发？Unix开源项目就是一个值得学习的例子。</p><p>Unix从1969年诞生，一直演进至今，代码量有几百万行，如此庞大的项目开发，能够如此完美的协作开发，并且长期维护，保持足够的代码质量，这里面有很多成功的经验可以借鉴。所以，接下来，我们就以Unix开源项目的开发为引子，分三节课的时间，通过下面三个话题，详细地讲讲应对复杂软件开发的方法论。希望这些经验能为你所用，在今后面对复杂项目开发的时候，能让你有条不紊、有章可循地从容应对。</p><!-- [[[read_end]]] --><ul>\n<li>从设计原则和思想的角度来看，如何应对庞大而复杂的项目开发？</li>\n<li>从研发管理和开发技巧的角度来看，如何应对庞大而复杂的项目开发？</li>\n<li>聚焦在Code Review上来看，如何通过Code Reviwe保持项目的代码质量？</li>\n</ul><p>话不多说，让我们正式开始今天的学习吧！</p><h2>封装与抽象</h2><p>在Unix、Linux系统中，有一句经典的话，“Everything is a file”，翻译成中文就是“一切皆文件”。这句话的意思就是，在Unix、Linux系统中，很多东西都被抽象成“文件”这样一个概念，比如Socket、驱动、硬盘、系统信息等。它们使用文件系统的路径作为统一的命名空间（namespace），使用统一的read、write标准函数来访问。</p><p>比如，我们要查看CPU的信息，在Linux系统中，我们只需要使用Vim、Gedit等编辑器或者cat命令，像打开其他文件一样，打开/proc/cpuinfo，就能查看到相应的信息。除此之外，我们还可以通过查看/proc/uptime文件，了解系统运行了多久，查看/proc/version了解系统的内核版本等。</p><p>实际上，“一切皆文件”就体现了封装和抽象的设计思想。</p><p>封装了不同类型设备的访问细节，抽象为统一的文件访问方式，更高层的代码就能基于统一的访问方式，来访问底层不同类型的设备。这样做的好处是，隔离底层设备访问的复杂性。统一的访问方式能够简化上层代码的编写，并且代码更容易复用。</p><p>除此之外，抽象和封装还能有效控制代码复杂性的蔓延，将复杂性封装在局部代码中，隔离实现的易变性，提供简单、统一的访问接口，让其他模块来使用，其他模块基于抽象的接口而非具体的实现编程，代码会更加稳定。</p><h2>分层与模块化</h2><p>前面我们也提到，模块化是构建复杂系统的常用手段。</p><p>对于像Unix这样的复杂系统，没有人能掌控所有的细节。之所以我们能开发出如此复杂的系统，并且能维护得了，最主要的原因就是将系统划分成各个独立的模块，比如进程调度、进程通信、内存管理、虚拟文件系统、网络接口等模块。不同的模块之间通过接口来进行通信，模块之间耦合很小，每个小的团队聚焦于一个独立的高内聚模块来开发，最终像搭积木一样，将各个模块组装起来，构建成一个超级复杂的系统。</p><p>除此之外，Unix、Linux等大型系统之所以能做到几百、上千人有条不紊地协作开发，也归功于模块化做得好。不同的团队负责不同的模块开发，这样即便在不了解全部细节的情况下，管理者也能协调各个模块，让整个系统有效运转。</p><p>实际上，除了模块化之外，分层也是我们常用来架构复杂系统的方法。</p><p>我们常说，计算机领域的任何问题都可以通过增加一个间接的中间层来解决，这本身就体现了分层的重要性。比如，Unix系统也是基于分层开发的，它可以大致上分为三层，分别是内核、系统调用、应用层。每一层都对上层封装实现细节，暴露抽象的接口来调用。而且，任意一层都可以被重新实现，不会影响到其他层的代码。</p><p>面对复杂系统的开发，我们要善于应用分层技术，把容易复用、跟具体业务关系不大的代码，尽量下沉到下层，把容易变动、跟具体业务强相关的代码，尽量上移到上层。</p><h2>基于接口通信</h2><p>刚刚我们讲了分层、模块化，那不同的层之间、不同的模块之间，是如何通信的呢？一般来讲都是通过接口调用。在设计模块（module）或者层（layer）要暴露的接口的时候，我们要学会隐藏实现，接口从命名到定义都要抽象一些，尽量少涉及具体的实现细节。</p><p>比如，Unix系统提供的open()文件操作函数，底层实现非常复杂，涉及权限控制、并发控制、物理存储，但我们用起来却非常简单。除此之外，因为open()函数基于抽象而非具体的实现来定义，所以我们在改动open()函数的底层实现的时候，并不需要改动依赖它的上层代码。</p><h2>高内聚、松耦合</h2><p>高内聚、松耦合是一个比较通用的设计思想，内聚性好、耦合少的代码，能让我们在修改或者阅读代码的时候，聚集到在一个小范围的模块或者类中，不需要了解太多其他模块或类的代码，让我们的焦点不至于太发散，也就降低了阅读和修改代码的难度。而且，因为依赖关系简单，耦合小，修改代码不会牵一发而动全身，代码改动比较集中，引入bug的风险也就减少了很多。</p><p>实际上，刚刚讲到的很多方法，比如封装、抽象、分层、模块化、基于接口通信，都能有效地实现代码的高内聚、松耦合。反过来，代码的高内聚、松耦合，也就意味着，抽象、封装做到比较到位、代码结构清晰、分层和模块化合理、依赖关系简单，那代码整体的质量就不会太差。即便某个具体的类或者模块设计得不怎么合理，代码质量不怎么高，影响的范围也是非常有限的。我们可以聚焦于这个模块或者类做相应的小型重构。而相对于代码结构的调整，这种改动范围比较集中的小型重构的难度就小多了。</p><h2>为扩展而设计</h2><p>越是复杂项目，越要在前期设计上多花点时间。提前思考项目中未来可能会有哪些功能需要扩展，提前预留好扩展点，以便在未来需求变更的时候，在不改动代码整体结构的情况下，轻松地添加新功能。</p><p>做到代码可扩展，需要代码满足开闭原则。特别是像Unix这样的开源项目，有n多人参与开发，任何人都可以提交代码到代码库中。代码满足开闭原则，基于扩展而非修改来添加新功能，最小化、集中化代码改动，避免新代码影响到老代码，降低引入bug的风险。</p><p>除了满足开闭原则，做到代码可扩展，我们前面也提到很多方法，比如封装和抽象，基于接口编程等。识别出代码可变部分和不可变部分，将可变部分封装起来，隔离变化，提供抽象化的不可变接口，供上层系统使用。当具体的实现发生变化的时候，我们只需要基于相同的抽象接口，扩展一个新的实现，替换掉老的实现即可，上游系统的代码几乎不需要修改。</p><h2>KISS首要原则</h2><p>简单清晰、可读性好，是任何大型软件开发要遵循的首要原则。只要可读性好，即便扩展性不好，顶多就是多花点时间、多改动几行代码的事情。但是，如果可读性不好，连看都看不懂，那就不是多花时间可以解决得了的了。如果你对现有代码的逻辑似懂非懂，抱着尝试的心态去修改代码，引入bug的可能性就会很大。</p><p>不管是自己还是团队，在参与大型项目开发的时候，要尽量避免过度设计、过早优化，在扩展性和可读性有冲突的时候，或者在两者之间权衡，模棱两可的时候，应该选择遵循KISS原则，首选可读性。</p><h2>最小惊奇原则</h2><p>《Unix编程艺术》一书中提到一个Unix的经典设计原则，叫“最小惊奇原则”，英文是“The Least Surprise Principle”。实际上，这个原则等同于“遵守开发规范”，意思是，在做设计或者编码的时候要遵守统一的开发规范，避免反直觉的设计。实际上，关于这一点，我们在前面的编码规范部分也讲到过。</p><p>遵从统一的编码规范，所有的代码都像一个人写出来的，能有效地减少阅读干扰。在大型软件开发中，参与开发的人员很多，如果每个人都按照自己的编码习惯来写代码，那整个项目的代码风格就会千奇百怪，这个类是这种编码风格，另一个类又是另外一种风格。在阅读的时候，我们要不停地切换去适应不同的编码风格，可读性就变差了。所以，对于大型项目的开发来说，我们要特别重视遵守统一的开发规范。</p><h2>重点回顾</h2><p>好了，今天的内容到此就讲完了。我们一块来总结回顾一下，你需要重点掌握的内容。</p><p>今天，我们主要从设计原则和思想的角度，也可以说是从设计开发的角度，来学习如何应对复杂软件开发。我总计了7点我认为比较重要的。这7点前面我们都详细讲过，如果你对哪块理解得不够清楚，可以回过头去再看下。这7点分别是：</p><ul>\n<li>封装与抽象</li>\n<li>分层与模块化</li>\n<li>基于接口通信</li>\n<li>高内聚、松耦合</li>\n<li>为扩展而设计</li>\n<li>KISS首要原则</li>\n<li>最小惊奇原则</li>\n</ul><p>当然，这7点之间并不是相互独立的，有几点是互相支持的，比如“高内聚、松耦合”与抽象封装、分层模块化、基于接口通信。有几点是互相冲突的， 比如KISS原则与为扩展而设计，这都需要我们根据实际情况去权衡。</p><h2>课堂讨论</h2><p>从设计原则和思想的角度来看，你觉得哪些原则或思想在大型软件开发中最能发挥作用，最能有效地应对代码的复杂性？</p><p>欢迎留言和我分享你的想法。如果有收获，也欢迎你把这篇文章分享给你的朋友。</p>",
                "article_title": "78 | 开源实战二（上）：从Unix开源开发学习应对大型复杂项目开发"
            },
            {
                "title": "79 | 开源实战二（中）：从Unix开源开发学习应对大型复杂项目开发",
                "herf": "https://time.geekbang.org/column/article/232427",
                "id": "232427",
                "content": "<p>我们知道，项目越复杂、代码量越多、参与开发人员越多、开发维护时间越长，我们就越是要重视代码质量。代码质量下降会导致项目研发困难重重，比如：开发效率低，招了很多人，天天加班，出活却不多；线上bug频发，查找bug困难，领导发飙，中层束手无策，工程师抱怨不断。</p><p>导致代码质量不高的原因有很多，比如：代码无注释，无文档，命名差，层次结构不清晰，调用关系混乱，到处hardcode，充斥着各种临时解决方案等等。那怎么才能时刻保证代码质量呢？当然，首要的是团队技术素质要过硬，能够适当地利用设计原则、思想、模式编写高质量的代码。除此之外，还有一些外在的方法可循。</p><p>今天，我就从研发管理和开发技巧的角度来带你看下，面对大型复杂项目的开发，如何长期保证代码质量，让代码长期可维护。</p><p>话不多说，让我们正式开始今天的学习吧！</p><h2>1. 吹毛求疵般地执行编码规范</h2><p>严格执行代码规范，可以使一个项目乃至整个公司的代码具有完全统一的风格，就像同一个人编写的。而且，命名良好的变量、函数、类和注释，也可以提高代码的可读性。编码规范不难掌握，关键是要严格执行。在Code Review时，我们一定要严格要求，看到不符合规范的代码，一定要指出并要求修改。</p><!-- [[[read_end]]] --><p>但是，据我了解，实际情况往往事与愿违。虽然大家都知道优秀的代码规范是怎样的，但在具体写代码的过程中，执行得却不好。我觉得，这种情况产生的主要原因还是不够重视。很多人会觉得，一个变量或者函数命名成啥样，关系并不大。所以命名时不推敲，注释也不写，Code Review的时候也都一副事不关己的心态，觉得没必要太抠细节。日积月累，项目代码就会变得越来越差。所以我这里还是要强调一下，细节决定成败，代码规范的严格执行极为关键。</p><h2>2.编写高质量的单元测试</h2><p>单元测试是最容易执行且对提高代码质量见效最快的方法之一。高质量的单元测试不仅仅要求测试覆盖率要高，还要求测试的全面性，除了测试正常逻辑的执行之外，还要重点、全面地测试异常下的执行情况。毕竟代码出问题的地方大部分都发生在异常、边界条件下。</p><p>对于大型复杂项目，集成测试、黑盒测试都很难测试全面，因为组合爆炸，穷举所有测试用例的成本很高，几乎是不可能的。单元测试就是很好的补充。它可以在类、函数这些细粒度的代码层面，保证代码运行无误。底层细粒度的代码bug少了，组合起来构建而成的整个系统的bug也就相应的减少了。</p><h2>3.不流于形式的Code Review</h2><p>如果说很多工程师对单元测试不怎么重视，那对Code Review就是不怎么接受。我之前跟一些同行聊起Code Review的时候，很多人的反应是，这玩意儿不可能很好地执行，形式大于效果，纯粹是浪费时间。是的，即便Code Review做得再流畅，也是要花时间的。所以，在业务开发任务繁重的时候，Code Review往往会流于形式、虎头蛇尾，效果确实不怎么好。</p><p>但我们并不能因此就否定Code Review本身的价值。在Google、Facebook等外企中，Code Review应用得非常成功，已经成为了开发流程中不可或缺的一部分。所以，要想真正发挥Code Review的作用，关键还是要执行到位，不能流于形式。</p><h2>4.开发未动、文档先行</h2><p>对大部分工程师来说，编写技术文档是件挺让人“反感”的事情。一般来讲，在开发某个系统或者重要模块或者功能之前，我们应该先写技术文档，然后，发送给同组或者相关同事审查，在审查没有问题的情况下再开发。这样能够保证事先达成共识，开发出来的东西不至于走样。而且，当开发完成之后，进行Code Review的时候，代码审查者通过阅读开发文档，也可以快速理解代码。</p><p>除此之外，对于团队和公司来讲，文档是重要的财富。对新人熟悉代码或任务的交接等，技术文档很有帮助。而且，作为一个规范化的技术团队，技术文档是一种摒弃作坊式开发和个人英雄主义的有效方法，是保证团队有效协作的途径。</p><h2>5.持续重构、重构、重构</h2><p>我个人比较反对平时不注重代码质量，堆砌烂代码，实在维护不了了就大刀阔斧地重构甚至重写。有的时候，因为项目代码太多，重构很难做到彻底，最后又搞出来一个四不像的怪物，这就更麻烦了！</p><p>优秀的代码或架构不是一开始就能设计好的，就像优秀的公司或产品也都是迭代出来的。我们无法100%预见未来的需求，也没有足够的精力、时间、资源为遥远的未来买单。所以，随着系统的演进，重构是不可避免的。</p><p>虽然我刚刚说不支持大刀阔斧、推倒重来式的大重构，但持续的小重构我还是比较提倡的。它也是时刻保证代码质量、防止代码腐化的有效手段。换句话说，不要等到问题堆得太多了再去解决，要时刻有人对代码整体质量负责任，平时没事就改改代码。千万不要觉得重构代码就是浪费时间，不务正业！</p><p>特别是一些业务开发团队，有时候为了快速完成一个业务需求，只追求速度，到处hard code，在完全不考虑非功能性需求、代码质量的情况下，堆砌烂代码。实际上，这种情况还是比较常见的。不过没关系，等你有时间了，一定要记着重构，不然烂代码越堆越多，总有一天代码会变得无法维护。</p><h2>6.对项目与团队进行拆分</h2><p>我们知道，团队人比较少，比如十几个人的时候，代码量不多，不超过10万行，怎么开发、怎么管理都没问题，大家互相都比较了解彼此做的东西。即便代码质量太差了，我们大不了把它重写一遍。但是，对于一个大型项目来说，参与开发的人员会比较多，代码量很大，有几十万、甚至几百万行代码，有几十、甚至几百号人同时开发维护，那研发管理就变得极其重要。</p><p>面对大型复杂项目，我们不仅仅需要对代码进行拆分，还需要对研发团队进行拆分。上一节课我们讲到了一些代码拆分的方法，比如模块化、分层等。同理，我们也可以把大团队拆成几个小团队。每个小团队对应负责一个小的项目（模块、微服务等），这样每个团队负责的项目包含的代码都不至于很多，也不至于出现代码质量太差无法维护的情况。</p><h2>重点回顾</h2><p>好了，今天的内容到此就讲完了。我们一块来总结回顾一下，你需要重点掌握的内容。</p><p>实际上，我刚刚讲的6条方法论应该都没啥新奇的，也没有葵花宝典似的杀手锏，说出来感觉都很简单。而且，现在互联网这么发达，信息都很透明，所以大方向我觉得你应该都知道，具体的策略和架构各家也都差不多，最后谁做得好，关键在于执行和细节。</p><p>我经常听人说，我们做了单元测试、Code Review啊，但到最后，项目还是一堆bug，代码质量还是很差。这个时候，我们就要去思考一下，单元测试、Code Review做得到底够不够好，从决策到执行再到考核是否形成了闭环，不要口号喊的100分，落实到执行只有50分，最后又没有很好的考核机制，好坏大家也都不知道。所以，一句话总结一下：切忌敏于言而讷于行。</p><p>除此之外，我们刚刚讲的所有方法都治标不治本。软件开发过程中的问题往往千奇百怪。要想每个问题都能顺利解决，除了理论知识和经验之外，更重要的是要具备分析问题、解决问题的能力。这也是为什么很多公司很重视应届生招聘，希望从一开始就招聘一些有潜力的员工。找到对的人、用对好的人，打造优秀的技术文化，才是一直保持卓越的根本。</p><h2>课堂讨论</h2><p>从研发管理和开发技巧的角度，你还有哪些能够有效保持项目代码质量的经验，可以分享给大家？</p><p>欢迎留言和我分享你的想法。如果有收获，也欢迎你把这篇文章分享给你的朋友。</p>",
                "article_title": "79 | 开源实战二（中）：从Unix开源开发学习应对大型复杂项目开发"
            },
            {
                "title": "80 | 开源实战二（下）：从Unix开源开发学习应对大型复杂项目开发",
                "herf": "https://time.geekbang.org/column/article/232687",
                "id": "232687",
                "content": "<p>上两节课，我们分别从代码编写、研发管理的角度，学习了如何应对大型复杂软件开发。在研发管理这一部分，我们又讲到比较重要的几点，它们分别是编码规范、单元测试、持续重构和Code Review。其中，前三点在专栏的理论部分都有比较详细的讲解，而唯独Code Review我们还没有讲过，所以，今天我就借机会和你补充一下这一部分的内容。</p><p>很多年前，我跟一个有十几年研发经验的某一线大厂的技术专家聊天，聊天中我提起了Code Review，他便对Code Review一顿否定。他说，Code Review比较浪费时间，往往会虎头蛇尾，不可能在企业中很好地落地执行。当我又提起，Code Review在Google执行得很好，并且是已经习以为常的开发流程的时候，他竟然说这绝对不可能。</p><p>一个技术不错，可以玩转各种架构、框架、中间件的资深IT从业者，居然对Code Review有如此的偏见，这到底是哪里出了问题呢？我觉得问题主要还是出自认知上。</p><p>所以，今天，我并不打算讲关于如何做Code Review的方法论，我更希望充当一个Code Review布道师的角色，讲一讲为什么要进行Code Review，Code Review的价值在哪里，让你重视、认可Code Review。因为我觉得，只要从认知上接受了Code Review，对于高智商的IT人群来说，搞清楚如何做Code Review并不是件难事。而且，Google也开源了它自己的Code Review最佳实践，网上很容易搜到，你完全可以对照着来做。</p><!-- [[[read_end]]] --><p>话不多说，让我们正式开始今天的内容吧！</p><h2>我为什么如此强调Code Review？</h2><p>Code Review中文叫代码审查。据我了解，在国内绝大部分的互联网企业里面，很少有将Code Review执行得很好的，这其中包括BAT这些大厂。特别是在一些需求变动大、项目工期紧的业务开发部门，就更不可能有Code Review流程了。代码写完之后随手就提交上去，然后丢给测试狠命测，发现bug再修改。</p><p>相反，一些外企非常重视Code Review，特别是FLAG这些大厂，Code Review落地执行得非常好。在Google工作的几年里，我也切实体会到了Code Review的好处。这里我就结合我自身的真实感受讲一讲Code Review的价值，试着“说服”一下你。</p><h3>1.Code Review践行“三人行必有我师”</h3><p>有时候你可能会觉得，团队中的资深员工或者技术leader的技术比较牛，写的代码很好，他们的代码就不需要Review了，我们重点Review资历浅的员工的代码就可以了。实际上，这种认识是不对的。</p><p>我们都知道，Google工程师的平均研发水平都很高，但即便如此，我们发现，不管谁提交的代码，包括Jeff Dean的，只要需要Review，都会收到很多comments（修改意见）。中国有句老话，“三人行必有我师”，我觉得用在这里非常合适。即便自己觉得写得已经很好的代码，只要经过不停地推敲，都有持续改进的空间。</p><p>所以，永远不要觉得自己很厉害，写的代码就不需要别人Review了；永远不要觉得自己水平很一般，就没有资格给别人Review了；更不要觉得技术大牛让你Review代码只是缺少你的一个“approve”，随便看看就可以。</p><h3>2.Code Review能摒弃“个人英雄主义”</h3><p>在一个成熟的公司里，所有的架构设计、实现，都应该是一个团队的产出。尽管这个过程可能会由某个人来主导，但应该是整个团队共同智慧的结晶。</p><p>如果一个人默默地写代码提交，不经过团队的Review，这样的代码蕴含的是一个人的智慧。代码的质量完全依赖于这个人的技术水平。这就会导致代码质量参差不齐。如果经过团队多人Review、打磨，代码蕴含的是整个团队的智慧，可以保证代码按照团队中的最高水准输出。</p><h3>3.Code Review能有效提高代码可读性</h3><p>前面我们反复强调，在大部分情况下，代码的可读性比任何其他方面（比如扩展性等）都重要。可读性好，代表后期维护成本低，线上bug容易排查，新人容易熟悉代码，老人离职时代码容易接手。而且，可读性好，也说明代码足够简单，出错可能性小、bug少。</p><p>不过，自己看自己写的代码，总是会觉得很易读，但换另外一个人来读你的代码，他可能就不这么认为了。毕竟自己写的代码，其中涉及的业务、技术自己很熟悉，别人不一定会熟悉。既然自己对可读性的判断很容易出现错觉，那Code Review就是一种考察代码可读性的很好手段。如果代码审查者很费劲才能看懂你写的代码，那就说明代码的可读性有待提高了。</p><p>还有，不知道你有没有这样的感受，写代码的时候，时间一长，改动的文件一多，就感觉晕乎乎的，脑子不清醒，逻辑不清晰？有句话讲，“旁观者清，当局者迷”，说的就是这个意思。Code Review能有效地解决“当局者迷”的问题。在正式开始Code Review之前，当我们将代码提交到Review Board（Code Review的工具界面）之后，所有的代码改动都放到了一块，看起来一目了然、清晰可见。这个时候，还没有等其他同事Review，我们自己就能发现很多问题。</p><h3>4.Code Review是技术传帮带的有效途径</h3><p>良好的团队需要技术和业务的“传帮带”，那如何来做“传帮带”呢？当然，业务上面，我们可能通过文档或口口相传的方式，那技术呢？如何培养初级工程师的技术能力呢？Code Review就是一种很好的途径。每次Code Review都是一次真实案例的讲解。通过Code Review，在实践中将技术传递给初级工程师，比让他们自己学习、自己摸索来得更高效！</p><h3>5.Code Review保证代码不止一个人熟悉</h3><p>如果一段代码只有一个人熟悉，如果这个同事休假了或离职了，代码交接起来就比较费劲。有时候，我们单纯只看代码还看不大懂，又要跟PM、业务团队、或者其他技术团队，再重复来一轮沟通，搞的其他团队的人都很烦。而Code Review能保证任何代码同时都至少有两个同事熟悉，互为备份，有备无患，除非两个同事同时都离职……</p><h3>6.Code Review能打造良好的技术氛围</h3><p>提交代码Review的人，希望自己写的代码足够优秀，毕竟被同事Review出很多问题，是件很丢人的事情。而做Code review的人，也希望自己尽可能地提出有建设性意见，展示自己的能力。所以，Code Review还能增进技术交流，活跃技术氛围，培养大家的极客精神，以及对代码质量的追求。</p><p>一个良好的技术氛围，能让团队有很强的自驱力。不用技术leader反复强调代码质量有多重要，团队中的成员就会自己主动去关注代码质量的问题。这比制定各种规章制度、天天督促执行要更加有效。实际上，我多说一句，好的技术氛围也能降低团队的离职率。</p><h3>7.Code Review是一种技术沟通方式</h3><p>Talk is cheap，show me the code。怎么“show”，通过Code Review工具来“show”，这样也方便别人反馈意见。特别是对于跨不同办公室、跨时区的沟通，Code Review是一种很好的沟通方式。我今天白天写的代码，明天来上班的时候，跨时区的同事已经帮我Review好了，我就可以改改提交，继续写新的代码了。这样的协作效率会很高。</p><h3>8.Code Review能提高团队的自律性</h3><p>在开发过程中，难免会有人不自律，存在侥幸心理：反正我写的代码也没人看，随便写写就提交了。Code Review相当于一次代码直播，曝光dirty code，有一定的威慑力。这样大家就不敢随便应付一下就提交代码了。</p><h2>如何在团队中落地执行Code Review？</h2><p>刚刚讲了这么多Code Review的好处，我觉得大部分你应该都能认可，但我猜你可能会说，Google之所以能很好地执行Code Review，一方面是因为有经验的传承，起步阶段已经过去了；另一方面是本身员工技术素质、水平就很高，那在一个技术水平没那么强的团队，在起步阶段或项目工期很紧的情况下，如何落地执行Code Review呢？</p><p>接下来，我就很多人关于Code Review的一些疑惑，谈谈我自己的看法。</p><p><strong>有人认为，Code Review流程太长，太浪费时间，特别是工期紧的时候，今天改的代码，明天就要上，如果要等同事Review，同事有可能没时间，这样就来不及。这个时候该怎么办呢？</strong></p><p>我所经历的项目还没有一个因为工期紧，导致没有时间Code Review的。工期都是人排的，稍微排松点就行了啊。我觉得关键还是在于整个公司对Code Review的接受程度。而且，Code Review熟练之后，并不需要花费太长的时间。尽管开始做Code Review的时候，你可能因为不熟练，需要有一个checklist对照着来做。起步阶段可能会比较耗时。但当你熟练之后，Code Review就像键盘盲打一样，你已经忘记了哪个手指按的是哪个键了，扫一遍代码就能揪出绝大部分问题。</p><p><strong>有人认为，业务一直在变，今天写的代码明天可能就要再改，代码可能不会长期维护，写得太好也没用。这种情况下是不是就不需要Code Review了呢？</strong></p><p>这种现象在游戏开发、一些早期的创业公司或者项目验证阶段比较常见。项目讲求短平快，先验证产品，再优化技术。如果确实面对的还只是生存问题，代码质量确实不是首要的，特殊情况下，不做Code Review是支持的！</p><p>有人说，团队成员技术水平不高，过往也没有Code Review的经验，不知道Review什么，也Review不出什么。自己代码都没写明白，不知道什么样的代码是好的，什么样的代码是差的，更不要说Review别人的代码了。在Code Review的时候，团队成员大眼瞪小眼，只能Review点语法，形式大于效果。这种情况该怎么办？</p><p>这种情况也挺常见。不过没关系，团队的技术水平都是可以培养的。我们可以先让资深同事、技术好的同事或技术leader，来Review其他所有人的代码。Review的过程本身就是一种“传帮带”的过程。慢慢地，整个团队就知道该如何Review了。虽然这可能会有一个相当长的过程，但如果真的想在团队中执行Code Review，这不失为一种“曲线救国”的方法。</p><p><strong>还有人说，刚开始Code Review的时候，大家都还挺认真，但时间长了，大家觉得这事跟KPI无关，而且我还要看别人的代码，理解别人写的代码的业务，多浪费时间啊。慢慢地，Code Review就变得流于形式了。有人提交了代码，随便抓个人Review。Review的人也不认真，随便扫一眼就点“approve”。这种情况该如何应对？</strong></p><p>我的对策是这样的。首先，要明确的告诉Code Review的重要性，要严格执行，让大家不要懈怠，适当的时候可以“杀鸡儆猴”。其次，可以像Google一样，将Code Review间接地跟KPI、升职等联系在一块，高级工程师有义务做Code Review，就像有义务做技术面试一样。再次，想办法活跃团队的技术氛围，把Code Review作为一种展示自己技术的机会，带动起大家对Code Review的积极性，提高大家对Code Review的认同感。</p><p>最后，我再多说几句。Google的Code Review是做得很好的，可以说是谷歌保持代码高质量最有效的手段之一了。Google的Code Review非常严格，多一个空行，多一个空格，注释有拼错的单词，变量命名得不够好，都会被指出来要求修改。之所以如此吹毛求疵，并非矫枉过正，而是要给大家传递一个信息：代码质量非常重要，一点都不能马虎。</p><h2>重点回顾</h2><p>好了，今天的内容到此就讲完了。我们一块来总结回顾一下，你需要重点掌握的内容。</p><p>今天，我们主要讲了为什么要做Code Review，Code Review的价值在哪里。我的总结如下：Code Review践行“三人行必有我师”、能摒弃“个人英雄主义”、能有效提高代码可读性、是技术传帮带的有效途径、能保证代码不止一个人熟悉、能打造良好的技术氛围、是一种技术沟通方式、能提高团队的自律性。</p><p>除此之外，我还对Code Review在落地执行过程中的一些问题，做了简单的答疑。我这里就不再重复罗列了。如果你在Code Review过程中遇到同样的问题，希望我的建议对你有所帮助。</p><h2>课堂讨论</h2><p>对是否应该做Code Review，你有什么看法呢？你所在的公司是否有严格的Code Review呢？在Code Review的过程中，你又遇到了哪些问题？</p><p>欢迎留言和我分享你的想法。如果有收获，也欢迎你把这篇文章分享给你的朋友。</p>",
                "article_title": "80 | 开源实战二（下）：从Unix开源开发学习应对大型复杂项目开发"
            },
            {
                "title": "81 | 开源实战三（上）：借Google Guava学习发现和开发通用功能模块",
                "herf": "https://time.geekbang.org/column/article/233742",
                "id": "233742",
                "content": "<p>上几节课，我们拿Unix这个超级大型开源软件的开发作为引子，从代码设计编写和研发管理两个角度，讲了如何应对大型复杂项目的开发。接下来，我们再讲一下Google开源的Java开发库Google Guava。</p><p>Google Guava是一个非常成功、非常受欢迎的开源项目。它在GitHub上由近3.7万的stars。在Java项目开发中应用很广泛。当然，我们并不会讲解其中的每个类、接口如何使用，而是重点讲解其背后蕴含的设计思想、使用的设计模式。内容比较多，我分三节课来讲解。</p><ul>\n<li>第一节课，我们对Google Guava做一个简单介绍，并借此讲一下如何开发一个通用的功能模块。</li>\n<li>第二节课，我们讲Google Guava中用到的几种设计模式，会补充讲解之前没有讲到的Immutable模式。</li>\n<li>第三节课，我们借Google Guava补充讲解三大编程范式中的最后一个：函数式编程。</li>\n</ul><p>话不多说，让我们正式开始今天的学习吧！</p><h2>Google Guava介绍</h2><p>考虑到你可能不熟悉Google Guava，我先对它做下简单的介绍。</p><p>Google Guava是Google公司内部Java开发工具库的开源版本。Google内部的很多Java项目都在使用它。它提供了一些JDK没有提供的功能，以及对JDK已有功能的增强功能。其中就包括：集合（Collections）、缓存（Caching）、原生类型支持（Primitives Support）、并发库（Concurrency Libraries）、通用注解（Common Annotation）、字符串处理（Strings Processing）、数学计算（Math）、I/O、事件总线（EventBus）等等。</p><!-- [[[read_end]]] --><p>我截取了Google Guava的包结构图，贴到了这里，你看起来更加直观些。</p><p><img src=\"https://static001.geekbang.org/resource/image/1c/45/1ce23ffd03045dadf2bad7e126337045.png\" alt=\"\"></p><p>我们知道，JDK的全称是Java Development Kit。它本身就是Java提供的工具类库。那现在请你思考一下，既然有了JDK，为什么Google还要开发一套新的类库Google Guava？是否是重复早轮子？两者的差异化在哪里？</p><p>带着这个问题，结合Google Guava，我们来学习如何在业务开发中，发现通用的功能模块，以及如何将它开发成类库、框架或者功能组件。等到学习完之后，我希望你能自己回答这个问题。</p><h2>如何发现通用的功能模块？</h2><p>很多人觉得做业务开发没有挑战，实际上，做业务开发也会涉及很多非业务功能的开发，比如我们前面讲到的ID生成器、性能计数器、EventBus、DI容器，以及后面会讲到的限流框架、幂等框架、灰度组件。关键在于，我们要有善于发现、善于抽象的能力，并且具有扎实的设计、开发能力，能够发现这些非业务的、可复用的功能点，并且从业务逻辑中将其解耦抽象出来，设计并开发成独立的功能模块。</p><p>在我看来，在业务开发中，跟业务无关的通用功能模块，常见的一般有三类：类库（library）、框架（framework）、功能组件（component）等。</p><p>其中，Google Guava属于类库，提供一组API接口。EventBus、DI容器属于框架，提供骨架代码，能让业务开发人员聚焦在业务开发部分，在预留的扩展点里填充业务代码。ID生成器、性能计数器属于功能组件，提供一组具有某一特殊功能的API接口，有点类似类库，但更加聚焦和重量级，比如，ID生成器有可能会依赖Redis等外部系统，不像类库那么简单。</p><p>前面提到的限流、幂等、灰度，到底是属于框架还是功能组件，我们要视具体情况而定。如果业务代码嵌套在它们里面开发，那就可以称它们为框架。如果它们只是开放API接口，供业务系统调用，那就可以称它们为组件。不过，叫什么没有太大关系，不必太深究概念。</p><p>那我们如何发现项目中的这些通用的功能模块呢？</p><p>实际上，不管是类库、框架还是功能组件，这些通用功能模块有两个最大的特点：复用和业务无关。Google Guava就是一个典型的例子。</p><p>如果没有复用场景，那也就没有了抽离出来，设计成独立模块的必要了。如果与业务有关又可复用，大部分情况下会设计成独立的系统（比如微服务），而不是类库、框架或功能组件。所以，如果你负责开发的代码，与业务无关并且可能会被复用，那你就可以考虑将它独立出来，开发成类库、框架、功能组件等通用功能模块。</p><p>稍微补充一下，我们这里讲的是，在业务开发中，如何发现通用的功能模块。除了业务开发团队之外，很多公司还有一些基础架构团队、架构开发团队，他们除了开发类库、框架、功能组件之外，也会开发一些通用的系统、中间件，比如，Google MapReduce、Kafka消息中间件、监控系统、分布式调用链追踪系统等。</p><h2>如何开发通用的功能模块？</h2><p>当我们发现了通用功能模块的开发需求之后，如何将它设计开发成一个优秀的类库、框架或功能组件呢？今天，我们不讲具体的开发技巧，具体的开发技巧在后面Spring开源实战那部分，我们会讲到一些，我今天打算先讲一些更普适的开发思想。我觉得先有了这些，你应该更容易理解后面的内容。</p><p>作为通用的类库、框架、功能组件，我们希望开发出来之后，不仅仅是自己项目使用，还能用在其他团队的项目中，甚至可以开源出来供更多人所用，这样才能发挥它更大的价值，构建自己的影响力。</p><p>所以，对于这些类库、框架、功能组件的开发，我们不能闭门造车，要把它们当作“产品”来开发。这个产品是一个“技术产品”，我们的目标用户是“程序员”，解决的是他们的“开发痛点”。我们要多换位思考，站在用户的角度上，来想他们到底想要什么样的功能。</p><p>对于一个技术产品来说，尽管Bug少、性能好等技术指标至关重要，但是否易用、易集成、易插拔、文档是否全面、是否容易上手等，这些产品素质也非常重要，甚至还能起到决定性作用。往往就是这些很容易忽视、不被重视的东西，会决定一个技术产品是否能在众多的同类中脱颖而出。</p><p>具体到Google Guava，它是一个开发类库，目标用户是Java开发工程师，解决用户主要痛点是，相对于JDK，提供更多的工具类，简化代码编写，比如，它提供了用来判断null值的Preconditions类；Splitter、Joiner、CharMatcher字符串处理类；Multisets、Multimaps、Tables等更丰富的Collections类等等。</p><p>它的优势有这样几点：第一，由Google管理、长期维护，经过充分的单元测试，代码质量有保证；第二，可靠、性能好、高度优化，比如Google Guava提供的Immutable Collections要比JDK的unmodifiableCollection性能好；第三，全面、完善的文档，容易上手，学习成本低，你可以去看下它的Github Wiki。</p><p>刚刚讲的是“产品意识”，我们再来讲讲“服务意识”。我经常在团队中说，如果你开发的东西是提供给其他团队用的，你一定要有“服务意识”。对于程序员来说，这点可能比“产品意识”更加欠缺。</p><p>首先，从心态上，别的团队使用我们开发出来的技术产品，我们要学会感谢。这点很重要。心态不同了，做起事来就会有微妙的不同。其次，除了写代码，我们还要有抽出大量时间答疑、充当客服角色的心理准备。有了这个心理准备，别的团队的人在问你问题的时候，你也就不会很烦了。</p><p>相对于业务代码来说，开发这种被多处复用的通用代码，对代码质量的要求更高些，因为这些项目的影响面更大，一旦出现bug，会牵连很多系统或其他项目。特别是如果你要把项目开源，影响就更大了。所以，这类项目的代码质量一般都很好，开发这类项目对代码能力的锻炼更有大。这也是我经常推荐别人通过阅读著名开源项目代码、参与开源项目来提高技术的原因。</p><p>具体到Google Guava，它是Google员工开发的，单元测试很完善，注释写得很规范，代码写得也很好，可以说是学习Google开发经验的一手资料，建议你如果有时间的话，可以认真阅读一下它的代码。</p><p>尽管开发这些通用功能模块更加锻炼技术，但我们也不要重复造轮子，能复用的尽量复用。而且，在项目中，如果你想把所有的通用功能都开发为独立的类库、框架、功能组件，这就有点大动干戈了，有可能会得不到领导的支持。毕竟从项目中将这部分通用功能独立出来开发，比起作为项目的一部分来开发，会更加耗时。</p><p>所以，权衡一下的话，我建议初期先把这些通用的功能作为项目的一部分来开发。不过，在开发的时候，我们做好模块化工作，将它们尽量跟其他模块划清界限，通过接口、扩展点等松耦合的方式跟其他模式交互。等到时机成熟了，我们再将它从项目中剥离出来。因为之前模块化做的好，耦合程度低，剥离出来的成本也就不会很高。</p><h2>重点回顾</h2><p>好了，今天的内容到此就讲完了。我们一块来总结回顾一下，你需要重点掌握的内容。</p><p>做业务开发也会涉及很多非业务功能的开发。我们要有善于发现、善于抽象的能力，并且具有扎实的设计、开发能力，能够发现这些非业务的、可复用的功能点，并且从业务逻辑中将其解耦抽象出来，设计并开发成独立的功能模块，比如类库、框架、功能组件。</p><p>实际上，不管是类库、框架还是功能组件，这些通用功能模块最大的两个特点就是复用和业务无关。如果你开发的这块代码，业务无关并且可能会被复用，那就可以考虑将它独立出来，开发成类库、框架、功能组件等。</p><p>当我们发现了通用功能模块的开发需求之后，如何将它设计开发成一个优秀的类库、框架或功能组件呢？这里我们讲了一些更普适的开发思想，比如产品意识、服务意识、代码质量意识、不要重复造轮子等。</p><p>除此之外，我特别建议你去阅读一下Google Guava的开源代码。它的代码不复杂，很容易读懂，不会有太大阅读负担，但它是你获取Google公司开发经验的一手资料，特别是在单元测试、编码规范方面。</p><h2>课堂讨论</h2><p>针对你正在参与开发的项目，思考一下，有哪些通用的功能模块可以抽象出来，设计开发成独立的类库、框架、功能组件？它们都可能会包括哪些功能点呢？试着自己设计一下吧！</p><p>欢迎留言和我分享你的想法，如果有收获，也欢迎你把这篇文章分享给你的朋友。</p>",
                "article_title": "81 | 开源实战三（上）：借Google Guava学习发现和开发通用功能模块"
            },
            {
                "title": "82 | 开源实战三（中）：剖析Google Guava中用到的几种设计模式",
                "herf": "https://time.geekbang.org/column/article/234758",
                "id": "234758",
                "content": "<p>上一节课，我们通过Google Guava这样一个优秀的开源类库，讲解了如何在业务开发中，发现跟业务无关、可以复用的通用功能模块，并将它们从业务代码中抽离出来，设计开发成独立的类库、框架或功能组件。</p><p>今天，我们再来学习一下，Google Guava中用到的几种经典设计模式：Builder模式、Wrapper模式，以及之前没讲过的Immutable模式。</p><p>话不多说，让我们正式开始今天的学习吧！</p><h2>Builder模式在Guava中的应用</h2><p>在项目开发中，我们经常用到缓存。它可以非常有效地提高访问速度。</p><p>常用的缓存系统有Redis、Memcache等。但是，如果要缓存的数据比较少，我们完全没必要在项目中独立部署一套缓存系统。毕竟系统都有一定出错的概率，项目中包含的系统越多，那组合起来，项目整体出错的概率就会升高，可用性就会降低。同时，多引入一个系统就要多维护一个系统，项目维护的成本就会变高。</p><p>取而代之，我们可以在系统内部构建一个内存缓存，跟系统集成在一起开发、部署。那如何构建内存缓存呢？我们可以基于JDK提供的类，比如HashMap，从零开始开发内存缓存。不过，从零开发一个内存缓存，涉及的工作就会比较多，比如缓存淘汰策略等。为了简化开发，我们就可以使用Google Guava提供的现成的缓存工具类com.google.common.cache.*。</p><!-- [[[read_end]]] --><p>使用Google Guava来构建内存缓存非常简单，我写了一个例子贴在了下面，你可以看下。</p><pre><code>public class CacheDemo {\n  public static void main(String[] args) {\n    Cache&lt;String, String&gt; cache = CacheBuilder.newBuilder()\n            .initialCapacity(100)\n            .maximumSize(1000)\n            .expireAfterWrite(10, TimeUnit.MINUTES)\n            .build();\n\n    cache.put(&quot;key1&quot;, &quot;value1&quot;);\n    String value = cache.getIfPresent(&quot;key1&quot;);\n    System.out.println(value);\n  }\n}\n</code></pre><p>从上面的代码中，我们可以发现，Cache对象是通过CacheBuilder这样一个Builder类来创建的。为什么要由Builder类来创建Cache对象呢？我想这个问题应该对你来说没难度了吧。</p><p>你可以先想一想，然后再来看我的回答。构建一个缓存，需要配置n多参数，比如过期时间、淘汰策略、最大缓存大小等等。相应地，Cache类就会包含n多成员变量。我们需要在构造函数中，设置这些成员变量的值，但又不是所有的值都必须设置，设置哪些值由用户来决定。为了满足这个需求，我们就需要定义多个包含不同参数列表的构造函数。</p><p>为了避免构造函数的参数列表过长、不同的构造函数过多，我们一般有两种解决方案。其中，一个解决方案是使用Builder模式；另一个方案是先通过无参构造函数创建对象，然后再通过setXXX()方法来逐一设置需要的设置的成员变量。</p><p>那我再问你一个问题，为什么Guava选择第一种而不是第二种解决方案呢？使用第二种解决方案是否也可以呢？答案是不行的。至于为什么，我们看下源码就清楚了。我把CacheBuilder类中的build()函数摘抄到了下面，你可以先看下。</p><pre><code>public &lt;K1 extends K, V1 extends V&gt; Cache&lt;K1, V1&gt; build() {\n  this.checkWeightWithWeigher();\n  this.checkNonLoadingCache();\n  return new LocalManualCache(this);\n}\n\nprivate void checkNonLoadingCache() {\n  Preconditions.checkState(this.refreshNanos == -1L, &quot;refreshAfterWrite requires a LoadingCache&quot;);\n}\n\nprivate void checkWeightWithWeigher() {\n  if (this.weigher == null) {\n    Preconditions.checkState(this.maximumWeight == -1L, &quot;maximumWeight requires weigher&quot;);\n  } else if (this.strictParsing) {\n    Preconditions.checkState(this.maximumWeight != -1L, &quot;weigher requires maximumWeight&quot;);\n  } else if (this.maximumWeight == -1L) {\n    logger.log(Level.WARNING, &quot;ignoring weigher specified without maximumWeight&quot;);\n  }\n\n}\n</code></pre><p>看了代码，你是否有了答案呢？实际上，答案我们在讲Builder模式的时候已经讲过了。现在，我们再结合CacheBuilder的源码重新说下。</p><p>必须使用Builder模式的主要原因是，在真正构造Cache对象的时候，我们必须做一些必要的参数校验，也就是build()函数中前两行代码要做的工作。如果采用无参默认构造函数加setXXX()方法的方案，这两个校验就无处安放了。而不经过校验，创建的Cache对象有可能是不合法、不可用的。</p><h2>Wrapper模式在Guava中的应用</h2><p>在Google Guava的collection包路径下，有一组以Forwarding开头命名的类。我截了这些类中的一部分贴到了下面，你可以看下。</p><p><img src=\"https://static001.geekbang.org/resource/image/ac/7d/ac5ce5f711711c0b86149f402e76177d.png\" alt=\"\"></p><p>这组Forwarding类很多，但实现方式都很相似。我摘抄了其中的ForwardingCollection中的部分代码到这里，你可以下先看下代码，然后思考下这组Forwarding类是干什么用的。</p><pre><code>@GwtCompatible\npublic abstract class ForwardingCollection&lt;E&gt; extends ForwardingObject implements Collection&lt;E&gt; {\n  protected ForwardingCollection() {\n  }\n\n  protected abstract Collection&lt;E&gt; delegate();\n\n  public Iterator&lt;E&gt; iterator() {\n    return this.delegate().iterator();\n  }\n\n  public int size() {\n    return this.delegate().size();\n  }\n\n  @CanIgnoreReturnValue\n  public boolean removeAll(Collection&lt;?&gt; collection) {\n    return this.delegate().removeAll(collection);\n  }\n\n  public boolean isEmpty() {\n    return this.delegate().isEmpty();\n  }\n\n  public boolean contains(Object object) {\n    return this.delegate().contains(object);\n  }\n\n  @CanIgnoreReturnValue\n  public boolean add(E element) {\n    return this.delegate().add(element);\n  }\n\n  @CanIgnoreReturnValue\n  public boolean remove(Object object) {\n    return this.delegate().remove(object);\n  }\n\n  public boolean containsAll(Collection&lt;?&gt; collection) {\n    return this.delegate().containsAll(collection);\n  }\n\n  @CanIgnoreReturnValue\n  public boolean addAll(Collection&lt;? extends E&gt; collection) {\n    return this.delegate().addAll(collection);\n  }\n\n  @CanIgnoreReturnValue\n  public boolean retainAll(Collection&lt;?&gt; collection) {\n    return this.delegate().retainAll(collection);\n  }\n\n  public void clear() {\n    this.delegate().clear();\n  }\n\n  public Object[] toArray() {\n    return this.delegate().toArray();\n  }\n  \n  //...省略部分代码...\n}\n</code></pre><p>光看ForwardingCollection的代码实现，你可能想不到它的作用。我再给点提示，举一个它的用法示例，如下所示：</p><pre><code>public class AddLoggingCollection&lt;E&gt; extends ForwardingCollection&lt;E&gt; {\n  private static final Logger logger = LoggerFactory.getLogger(AddLoggingCollection.class);\n  private Collection&lt;E&gt; originalCollection;\n\n  public AddLoggingCollection(Collection&lt;E&gt; originalCollection) {\n    this.originalCollection = originalCollection;\n  }\n\n  @Override\n  protected Collection delegate() {\n    return this.originalCollection;\n  }\n\n  @Override\n  public boolean add(E element) {\n    logger.info(&quot;Add element: &quot; + element);\n    return this.delegate().add(element);\n  }\n\n  @Override\n  public boolean addAll(Collection&lt;? extends E&gt; collection) {\n    logger.info(&quot;Size of elements to add: &quot; + collection.size());\n    return this.delegate().addAll(collection);\n  }\n\n}\n</code></pre><p>结合源码和示例，我想你应该知道这组Forwarding类的作用了吧？</p><p>在上面的代码中，AddLoggingCollection是基于代理模式实现的一个代理类，它在原始Collection类的基础之上，针对“add”相关的操作，添加了记录日志的功能。</p><p>我们前面讲到，代理模式、装饰器、适配器模式可以统称为Wrapper模式，通过Wrapper类二次封装原始类。它们的代码实现也很相似，都可以通过组合的方式，将Wrapper类的函数实现委托给原始类的函数来实现。</p><pre><code>public interface Interf {\n  void f1();\n  void f2();\n}\npublic class OriginalClass implements Interf {\n  @Override\n  public void f1() { //... }\n  @Override\n  public void f2() { //... }\n}\n\npublic class WrapperClass implements Interf {\n  private OriginalClass oc;\n  public WrapperClass(OriginalClass oc) {\n    this.oc = oc;\n  }\n  @Override\n  public void f1() {\n    //...附加功能...\n    this.oc.f1();\n    //...附加功能...\n  }\n  @Override\n  public void f2() {\n    this.oc.f2();\n  }\n}\n</code></pre><p>实际上，这个ForwardingCollection类是一个“默认Wrapper类”或者叫“缺省Wrapper类”。这类似于在装饰器模式那一节课中，讲到的FilterInputStream缺省装饰器类。你可以再重新看下<a href=\"https://time.geekbang.org/column/article/204845\">第50讲</a>装饰器模式的相关内容。</p><p>如果我们不使用这个ForwardinCollection类，而是让AddLoggingCollection代理类直接实现Collection接口，那Collection接口中的所有方法，都要在AddLoggingCollection类中实现一遍，而真正需要添加日志功能的只有add()和addAll()两个函数，其他函数的实现，都只是类似Wrapper类中f2()函数的实现那样，简单地委托给原始collection类对象的对应函数。</p><p>为了简化Wrapper模式的代码实现，Guava提供一系列缺省的Forwarding类。用户在实现自己的Wrapper类的时候，基于缺省的Forwarding类来扩展，就可以只实现自己关心的方法，其他不关心的方法使用缺省Forwarding类的实现，就像AddLoggingCollection类的实现那样。</p><h2>Immutable模式在Guava中的应用</h2><p>Immutable模式，中文叫作不变模式，它并不属于经典的23种设计模式，但作为一种较常用的设计思路，可以总结为一种设计模式来学习。之前在理论部分，我们只稍微提到过Immutable模式，但没有独立的拿出来详细讲解，我们这里借Google Guava再补充讲解一下。</p><p>一个对象的状态在对象创建之后就不再改变，这就是所谓的不变模式。其中涉及的类就是<strong>不变类</strong>（Immutable Class），对象就是<strong>不变对象</strong>（Immutable Object）。在Java中，最常用的不变类就是String类，String对象一旦创建之后就无法改变。</p><p>不变模式可以分为两类，一类是普通不变模式，另一类是深度不变模式（Deeply Immutable Pattern）。普通的不变模式指的是，对象中包含的引用对象是可以改变的。如果不特别说明，通常我们所说的不变模式，指的就是普通的不变模式。深度不变模式指的是，对象包含的引用对象也不可变。它们两个之间的关系，有点类似之前讲过的浅拷贝和深拷贝之间的关系。我举了一个例子来进一步解释一下，代码如下所示：</p><pre><code>// 普通不变模式\npublic class User {\n  private String name;\n  private int age;\n  private Address addr;\n  \n  public User(String name, int age, Address addr) {\n    this.name = name;\n    this.age = age;\n    this.addr = addr;\n  }\n  // 只有getter方法，无setter方法...\n}\n\npublic class Address {\n  private String province;\n  private String city;\n  public Address(String province, String city) {\n    this.province = province;\n    this.city= city;\n  }\n  // 有getter方法，也有setter方法...\n}\n\n// 深度不变模式\npublic class User {\n  private String name;\n  private int age;\n  private Address addr;\n  \n  public User(String name, int age, Address addr) {\n    this.name = name;\n    this.age = age;\n    this.addr = addr;\n  }\n  // 只有getter方法，无setter方法...\n}\n\npublic class Address {\n  private String province;\n  private String city;\n  public Address(String province, String city) {\n    this.province = province;\n    this.city= city;\n  }\n  // 只有getter方法，无setter方法..\n}\n</code></pre><p>在某个业务场景下，如果一个对象符合创建之后就不会被修改这个特性，那我们就可以把它设计成不变类。显式地强制它不可变，这样能避免意外被修改。那如何将一个类设置为不变类呢？其实方法很简单，只要这个类满足：所有的成员变量都通过构造函数一次性设置好，不暴露任何set等修改成员变量的方法。除此之外，因为数据不变，所以不存在并发读写问题，因此不变模式常用在多线程环境下，来避免线程加锁。所以，不变模式也常被归类为多线程设计模式。</p><p>接下来，我们来看一种特殊的不变类，那就是不变集合。Google Guava针对集合类（Collection、List、Set、Map…）提供了对应的不变集合类（ImmutableCollection、ImmutableList、ImmutableSet、ImmutableMap…）。刚刚我们讲过，不变模式分为两种，普通不变模式和深度不变模式。Google Guava提供的不变集合类属于前者，也就是说，集合中的对象不会增删，但是对象的成员变量（或叫属性值）是可以改变的。</p><p>实际上，Java JDK也提供了不变集合类（UnmodifiableCollection、UnmodifiableList、UnmodifiableSet、UnmodifiableMap…）。那它跟Google Guava提供的不变集合类的区别在哪里呢？我举个例子你就明白了，代码如下所示：</p><pre><code>public class ImmutableDemo {\n  public static void main(String[] args) {\n    List&lt;String&gt; originalList = new ArrayList&lt;&gt;();\n    originalList.add(&quot;a&quot;);\n    originalList.add(&quot;b&quot;);\n    originalList.add(&quot;c&quot;);\n\n    List&lt;String&gt; jdkUnmodifiableList = Collections.unmodifiableList(originalList);\n    List&lt;String&gt; guavaImmutableList = ImmutableList.copyOf(originalList);\n\n    //jdkUnmodifiableList.add(&quot;d&quot;); // 抛出UnsupportedOperationException\n    // guavaImmutableList.add(&quot;d&quot;); // 抛出UnsupportedOperationException\n    originalList.add(&quot;d&quot;);\n\n    print(originalList); // a b c d\n    print(jdkUnmodifiableList); // a b c d\n    print(guavaImmutableList); // a b c\n  }\n\n  private static void print(List&lt;String&gt; list) {\n    for (String s : list) {\n      System.out.print(s + &quot; &quot;);\n    }\n    System.out.println();\n  }\n}\n</code></pre><h2>重点回顾</h2><p>好了，今天的内容到此就讲完了。我们一块来总结回顾一下，你需要重点掌握的内容。</p><p>今天我们学习了Google Guava中都用到的几个设计模式：Builder模式、Wrapper模式、Immutable模式。还是那句话，内容本身不重要，你也不用死记硬背Google Guava的某某类用到了某某设计模式。实际上，我想通过这些源码的剖析，传达给你下面这些东西。</p><p>我们在阅读源码的时候，要问问自己，为什么它要这么设计？不这么设计行吗？还有更好的设计吗？实际上，很多人缺少这种“质疑”精神，特别是面对权威（经典书籍、著名源码、权威人士）的时候。</p><p>我觉得我本人是最不缺质疑精神的一个人，我喜欢挑战权威，喜欢以理服人。就好比在今天的讲解中，我把ForwardingCollection等类理解为缺省Wrapper类，可以用在装饰器、代理、适配器三种Wrapper模式中，简化代码编写。如果你去看Google Guava在GitHub上的Wiki，你会发现，它对ForwardingCollection类的理解跟我是不一样的。它把ForwardingCollection类单纯地理解为缺省的装饰器类，只用在装饰器模式中。我个人觉得我的理解更加好些，不知道你怎么认为呢？</p><p>除此之外，在专栏的最开始，我也讲到，学习设计模式能让你更好的阅读源码、理解源码。如果我们没有之前的理论学习，那对于很多源码的阅读，可能都只停留在走马观花的层面上，根本学习不到它的精髓。这就好比今天讲到的CacheBuilder。我想大部分人都知道它是利用了Builder模式，但如果对Builder模式没有深入的了解，很少人能讲清楚为什么要用Builder模式，不用构造函数加set方法的方式来实现。</p><h2>课堂讨论</h2><p>从最后一段代码中，我们可以发现，JDK不变集合和Google Guava不变集合都不可增删数据。但是，当原始集合增加数据之后，JDK不变集合的数据随之增加，而Google Guava的不变集合的数据并没有增加。这是两者最大的区别。那这两者底层分别是如何实现不变的呢？</p><p>欢迎留言和我分享你的想法，如果有收获，也欢迎你把这篇文章分享给你的朋友。</p>",
                "article_title": "82 | 开源实战三（中）：剖析Google Guava中用到的几种设计模式"
            },
            {
                "title": "83 | 开源实战三（下）：借Google Guava学习三大编程范式中的函数式编程",
                "herf": "https://time.geekbang.org/column/article/235334",
                "id": "235334",
                "content": "<p>现在主流的编程范式主要有三种，面向过程、面向对象和函数式编程。在理论部分，我们已经详细讲过前两种了。今天，我们再借机会讲讲剩下的一种，函数式编程。</p><p>函数式编程并非一个很新的东西，早在50多年前就已经出现了。近几年，函数式编程越来越被人关注，出现了很多新的函数式编程语言，比如Clojure、Scala、Erlang等。一些非函数式编程语言也加入了很多特性、语法、类库来支持函数式编程，比如Java、Python、Ruby、JavaScript等。除此之外，Google Guava也有对函数式编程的增强功能。</p><p>函数式编程因其编程的特殊性，仅在科学计算、数据处理、统计分析等领域，才能更好地发挥它的优势，所以，我个人觉得，它并不能完全替代更加通用的面向对象编程范式。但是，作为一种补充，它也有很大存在、发展和学习的意义。所以，我觉得有必要在专栏里带你一块学习一下。</p><p>话不多说，让我们正式开始今天的学习吧！</p><h2>到底什么是函数式编程?</h2><p>函数式编程的英文翻译是Functional Programming。 那到底什么是函数式编程呢？</p><p>在前面的章节中，我们讲到，面向过程、面向对象编程并没有严格的官方定义。在当时的讲解中，我也只是给出了我自己总结的定义。而且，当时给出的定义也只是对两个范式主要特性的总结，并不是很严格。实际上，函数式编程也是如此，也没有一个严格的官方定义。所以，接下来，我就从特性上来告诉你，什么是函数式编程。</p><!-- [[[read_end]]] --><p>严格上来讲，函数式编程中的“函数”，并不是指我们编程语言中的“函数”概念，而是指数学“函数”或者“表达式”（比如，y=f(x)）。不过，在编程实现的时候，对于数学“函数”或“表达式”，我们一般习惯性地将它们设计成函数。所以，如果不深究的话，函数式编程中的“函数”也可以理解为编程语言中的“函数”。</p><p>每个编程范式都有自己独特的地方，这就是它们会被抽象出来作为一种范式的原因。面向对象编程最大的特点是：以类、对象作为组织代码的单元以及它的四大特性。面向过程编程最大的特点是：以函数作为组织代码的单元，数据与方法相分离。那函数式编程最独特的地方又在哪里呢？</p><p>实际上，函数式编程最独特的地方在于它的编程思想。函数式编程认为，程序可以用一系列数学函数或表达式的组合来表示。函数式编程是程序面向数学的更底层的抽象，将计算过程描述为表达式。不过，这样说你肯定会有疑问，真的可以把任何程序都表示成一组数学表达式吗？</p><p>理论上讲是可以的。但是，并不是所有的程序都适合这么做。函数式编程有它自己适合的应用场景，比如开篇提到的科学计算、数据处理、统计分析等。在这些领域，程序往往比较容易用数学表达式来表示，比起非函数式编程，实现同样的功能，函数式编程可以用很少的代码就能搞定。但是，对于强业务相关的大型业务系统开发来说，费劲吧啦地将它抽象成数学表达式，硬要用函数式编程来实现，显然是自讨苦吃。相反，在这种应用场景下，面向对象编程更加合适，写出来的代码更加可读、可维护。</p><p>刚刚讲的是函数式编程的编程思想，如果我们再具体到编程实现，函数式编程跟面向过程编程一样，也是以函数作为组织代码的单元。不过，它跟面向过程编程的区别在于，它的函数是无状态的。何为无状态？简单点讲就是，函数内部涉及的变量都是局部变量，不会像面向对象编程那样，共享类成员变量，也不会像面向过程编程那样，共享全局变量。函数的执行结果只与入参有关，跟其他任何外部变量无关。同样的入参，不管怎么执行，得到的结果都是一样的。这实际上就是数学函数或数学表达式的基本要求。我举个例子来简单解释一下。</p><pre><code>// 有状态函数: 执行结果依赖b的值是多少，即便入参相同，多次执行函数，函数的返回值有可能不同，因为b值有可能不同。\nint b;\nint increase(int a) {\n  return a + b;\n}\n\n// 无状态函数：执行结果不依赖任何外部变量值，只要入参相同，不管执行多少次，函数的返回值就相同\nint increase(int a, int b) {\n  return a + b;\n}\n</code></pre><p>这里稍微总结一下，不同的编程范式之间并不是截然不同的，总是有一些相同的编程规则。比如，不管是面向过程、面向对象还是函数式编程，它们都有变量、函数的概念，最顶层都要有main函数执行入口，来组装编程单元（类、函数等）。只不过，面向对象的编程单元是类或对象，面向过程的编程单元是函数，函数式编程的编程单元是无状态函数。</p><h2>Java对函数式编程的支持</h2><p>我们前面讲到，实现面向对象编程不一定非得使用面向对象编程语言，同理，实现函数式编程也不一定非得使用函数式编程语言。现在，很多面向对象编程语言，也提供了相应的语法、类库来支持函数式编程。</p><p>接下来，我们就看下Java这种面向对象编程语言，对函数式编程的支持，借机加深一下你对函数式编程的理解。我们先来看下面这样一段非常典型的Java函数式编程的代码。</p><pre><code>public class FPDemo {\n  public static void main(String[] args) {\n    Optional&lt;Integer&gt; result = Stream.of(&quot;f&quot;, &quot;ba&quot;, &quot;hello&quot;)\n            .map(s -&gt; s.length())\n            .filter(l -&gt; l &lt;= 3)\n            .max((o1, o2) -&gt; o1-o2);\n    System.out.println(result.get()); // 输出2\n  }\n}\n</code></pre><p>这段代码的作用是从一组字符串数组中，过滤出长度小于等于3的字符串，并且求得这其中的最大长度。</p><p>如果你不了解Java函数式编程的语法，看了上面的代码或许会有些懵，主要的原因是，Java为函数式编程引入了三个新的语法概念：Stream类、Lambda表达式和函数接口（Functional Inteface）。Stream类用来支持通过“.”级联多个函数操作的代码编写方式；引入Lambda表达式的作用是简化代码编写；函数接口的作用是让我们可以把函数包裹成函数接口，来实现把函数当做参数一样来使用（Java不像C一样支持函数指针，可以把函数直接当参数来使用）。</p><p><strong>首先，我们来看下Stream类。</strong></p><p>假设我们要计算这样一个表达式：(3-1)*2+5。如果按照普通的函数调用的方式写出来，就是下面这个样子：</p><pre><code>add(multiply(subtract(3,1),2),5);\n</code></pre><p>不过，这样编写代码看起来会比较难理解，我们换个更易读的写法，如下所示：</p><pre><code>subtract(3,1).multiply(2).add(5);\n</code></pre><p>我们知道，在Java中，“.”表示调用某个对象的方法。为了支持上面这种级联调用方式，我们让每个函数都返回一个通用的类型：Stream类对象。在Stream类上的操作有两种：中间操作和终止操作。中间操作返回的仍然是Stream类对象，而终止操作返回的是确定的值结果。</p><p>我们再来看之前的例子。我对代码做了注释解释，如下所示。其中，map、filter是中间操作，返回Stream类对象，可以继续级联其他操作；max是终止操作，返回的不是Stream类对象，无法再继续往下级联处理了。</p><pre><code>public class FPDemo {\n  public static void main(String[] args) {\n    Optional&lt;Integer&gt; result = Stream.of(&quot;f&quot;, &quot;ba&quot;, &quot;hello&quot;) // of返回Stream&lt;String&gt;对象\n            .map(s -&gt; s.length()) // map返回Stream&lt;Integer&gt;对象\n            .filter(l -&gt; l &lt;= 3) // filter返回Stream&lt;Integer&gt;对象\n            .max((o1, o2) -&gt; o1-o2); // max终止操作：返回Optional&lt;Integer&gt;\n    System.out.println(result.get()); // 输出2\n  }\n}\n</code></pre><p><strong>其次，我们再来看下Lambda表达式。</strong></p><p>我们前面讲到，Java引入Lambda表达式的主要作用是简化代码编写。实际上，我们也可以不用Lambda表达式来书写例子中的代码。我们拿其中的map函数来举例说明一下。</p><p>下面有三段代码，第一段代码展示了map函数的定义，实际上，map函数接收的参数是一个Function接口，也就是待会儿要讲到的函数接口。第二段代码展示了map函数的使用方式。第三段代码是针对第二段代码用Lambda表达式简化之后的写法。实际上，Lambda表达式在Java中只是一个语法糖而已，底层是基于函数接口来实现的，也就是第二段代码展示的写法。</p><pre><code>// Stream中map函数的定义：\npublic interface Stream&lt;T&gt; extends BaseStream&lt;T, Stream&lt;T&gt;&gt; {\n  &lt;R&gt; Stream&lt;R&gt; map(Function&lt;? super T, ? extends R&gt; mapper);\n  //...省略其他函数...\n}\n\n// Stream中map的使用方法：\nStream.of(&quot;fo&quot;, &quot;bar&quot;, &quot;hello&quot;).map(new Function&lt;String, Integer&gt;() {\n  @Override\n  public Integer apply(String s) {\n    return s.length();\n  }\n});\n\n// 用Lambda表达式简化后的写法：\nStream.of(&quot;fo&quot;, &quot;bar&quot;, &quot;hello&quot;).map(s -&gt; s.length());\n</code></pre><p>Lambda表达式语法不是我们学习的重点。我这里只稍微介绍一下。如果感兴趣，你可以自行深入研究。</p><p>Lambda表达式包括三部分：输入、函数体、输出。表示出来的话就是下面这个样子：</p><pre><code>(a, b) -&gt; { 语句1； 语句2；...; return 输出; } //a,b是输入参数\n</code></pre><p>实际上，Lambda表达式的写法非常灵活。我们刚刚给出的是标准写法，还有很多简化写法。比如，如果输入参数只有一个，可以省略()，直接写成a-&gt;{…}；如果没有入参，可以直接将输入和箭头都省略掉，只保留函数体；如果函数体只有一个语句，那可以将{}省略掉；如果函数没有返回值，return语句就可以不用写了。</p><p>如果我们把之前例子中的Lambda表达式，全部替换为函数接口的实现方式，就是下面这样子的。代码是不是多了很多？</p><pre><code>Optional&lt;Integer&gt; result = Stream.of(&quot;f&quot;, &quot;ba&quot;, &quot;hello&quot;)\n        .map(s -&gt; s.length())\n        .filter(l -&gt; l &lt;= 3)\n        .max((o1, o2) -&gt; o1-o2);\n        \n// 还原为函数接口的实现方式\nOptional&lt;Integer&gt; result2 = Stream.of(&quot;fo&quot;, &quot;bar&quot;, &quot;hello&quot;)\n        .map(new Function&lt;String, Integer&gt;() {\n          @Override\n          public Integer apply(String s) {\n            return s.length();\n          }\n        })\n        .filter(new Predicate&lt;Integer&gt;() {\n          @Override\n          public boolean test(Integer l) {\n            return l &lt;= 3;\n          }\n        })\n        .max(new Comparator&lt;Integer&gt;() {\n          @Override\n          public int compare(Integer o1, Integer o2) {\n            return o1 - o2;\n          }\n        });\n</code></pre><p><strong>最后，我们来看下函数接口。</strong></p><p>实际上，上面一段代码中的Function、Predicate、Comparator都是函数接口。我们知道，C语言支持函数指针，它可以把函数直接当变量来使用。但是，Java没有函数指针这样的语法。所以，它通过函数接口，将函数包裹在接口中，当作变量来使用。</p><p>实际上，函数接口就是接口。不过，它也有自己特别的地方，那就是要求只包含一个未实现的方法。因为只有这样，Lambda表达式才能明确知道匹配的是哪个接口。如果有两个未实现的方法，并且接口入参、返回值都一样，那Java在翻译Lambda表达式的时候，就不知道表达式对应哪个方法了。</p><p>我把Java提供的Function、Predicate这两个函数接口的源码，摘抄过来贴到了下面，你可以对照着它们，理解我刚刚对函数接口的讲解。</p><pre><code>@FunctionalInterface\npublic interface Function&lt;T, R&gt; {\n    R apply(T t);  // 只有这一个未实现的方法\n\n    default &lt;V&gt; Function&lt;V, R&gt; compose(Function&lt;? super V, ? extends T&gt; before) {\n        Objects.requireNonNull(before);\n        return (V v) -&gt; apply(before.apply(v));\n    }\n\n    default &lt;V&gt; Function&lt;T, V&gt; andThen(Function&lt;? super R, ? extends V&gt; after) {\n        Objects.requireNonNull(after);\n        return (T t) -&gt; after.apply(apply(t));\n    }\n\n    static &lt;T&gt; Function&lt;T, T&gt; identity() {\n        return t -&gt; t;\n    }\n}\n\n@FunctionalInterface\npublic interface Predicate&lt;T&gt; {\n    boolean test(T t); // 只有这一个未实现的方法\n\n    default Predicate&lt;T&gt; and(Predicate&lt;? super T&gt; other) {\n        Objects.requireNonNull(other);\n        return (t) -&gt; test(t) &amp;&amp; other.test(t);\n    }\n\n    default Predicate&lt;T&gt; negate() {\n        return (t) -&gt; !test(t);\n    }\n\n    default Predicate&lt;T&gt; or(Predicate&lt;? super T&gt; other) {\n        Objects.requireNonNull(other);\n        return (t) -&gt; test(t) || other.test(t);\n    }\n\n    static &lt;T&gt; Predicate&lt;T&gt; isEqual(Object targetRef) {\n        return (null == targetRef)\n                ? Objects::isNull\n                : object -&gt; targetRef.equals(object);\n    }\n}\n</code></pre><p>以上讲的就是Java对函数式编程的语法支持，我想，最开始给到的那个函数式编程的例子，现在你应该能轻松看懂了吧？</p><h2>Guava对函数式编程的增强</h2><p>如果你是Google Guava的设计者，对于Java函数式编程，Google Guava还能做些什么呢？</p><p>颠覆式创新是很难的。不过我们可以进行一些补充，一方面，可以增加Stream类上的操作（类似map、filter、max这样的终止操作和中间操作），另一方面，也可以增加更多的函数接口（类似Function、Predicate这样的函数接口）。实际上，我们还可以设计一些类似Stream类的新的支持级联操作的类。这样，使用Java配合Guava进行函数式编程会更加方便。</p><p>但是，跟我们预期的相反，Google Guava并没有提供太多函数式编程的支持，仅仅封装了几个遍历集合操作的接口，代码如下所示：</p><pre><code>Iterables.transform(Iterable, Function);\nIterators.transform(Iterator, Function);\nCollections.transfrom(Collection, Function);\nLists.transform(List, Function);\nMaps.transformValues(Map, Function);\nMultimaps.transformValues(Mltimap, Function);\n...\nIterables.filter(Iterable, Predicate);\nIterators.filter(Iterator, Predicate);\nCollections2.filter(Collection, Predicate);\n...\n</code></pre><p>从Google Guava的GitHub Wiki中，我们发现，Google对于函数式编程的使用还是很谨慎的，认为过度地使用函数式编程，会导致代码可读性变差，强调不要滥用。这跟我前面对函数式编程的观点是一致的。所以，在函数式编程方面，Google Guava并没有提供太多的支持。</p><p>之所以对遍历集合操作做了优化，主要是因为函数式编程一个重要的应用场景就是遍历集合。如果不使用函数式编程，我们只能for循环，一个一个的处理集合中的数据。使用函数式编程，可以大大简化遍历集合操作的代码编写，一行代码就能搞定，而且在可读性方面也没有太大损失。</p><h2>重点回顾</h2><p>好了，今天的内容到此就讲完了。我们一块来总结回顾一下，你需要重点掌握的内容。</p><p>今天，我们讲了一下三大编程范式中的最后一个，函数式编程。尽管越来越多的编程语言开始支持函数式编程，但我个人觉得，它只能是其他编程范式的补充，用在一些特殊的领域发挥它的特殊作用，没法完全替代面向对象、面向过程编程范式。</p><p>关于什么是函数式编程，实际上不是很好理解。函数式编程中的“函数”，并不是指我们编程语言中的“函数”概念，而是数学中的“函数”或者“表达式”概念。函数式编程认为，程序可以用一系列数学函数或表达式的组合来表示。</p><p>具体到编程实现，函数式编程以无状态函数作为组织代码的单元。函数的执行结果只与入参有关，跟其他任何外部变量无关。同样的入参，不管怎么执行，得到的结果都是一样。</p><p>具体到Java语言，它提供了三个语法机制来支持函数式编程。它们分别是Stream类、Lambda表达式和函数接口。Google Guava对函数式编程的一个重要应用场景，遍历集合，做了优化，但并没有太多的支持，并且我们强调，不要为了节省代码行数，滥用函数式编程，导致代码可读性变差。</p><h2>课堂讨论</h2><p>你可以说一说函数式编程的优点和缺点，以及你对函数式编程的看法。你觉得它能否替代面向对象编程，成为最主流的编程范式？</p><p>欢迎留言和我分享你的想法，如果有收获，也欢迎你把这篇文章分享给你的朋友。</p>",
                "article_title": "83 | 开源实战三（下）：借Google Guava学习三大编程范式中的函数式编程"
            },
            {
                "title": "84 | 开源实战四（上）：剖析Spring框架中蕴含的经典设计思想或原则",
                "herf": "https://time.geekbang.org/column/article/236935",
                "id": "236935",
                "content": "<p>在Java世界里，Spring框架已经几乎成为项目开发的必备框架。作为如此优秀和受欢迎的开源项目，它是我们源码阅读的首选材料之一，不管是设计思想，还是代码实现，都有很多值得我们学习的地方。接下来，我们就详细讲讲Spring框架中蕴含的设计思想、原则和模式。因为内容比较多，我分三部分来讲解。</p><ul>\n<li>第一部分，我们讲解Spring框架中蕴含的经典设计思想或原则。</li>\n<li>第二部分，我们讲解Spring框架中用来支持扩展的两种设计模式。</li>\n<li>第三部分，我们总结罗列Spring框架中用到的其他十几种设计模式。</li>\n</ul><p>今天，我们就讲下第一部分：Spring框架中蕴含的一些设计思想或原则，这其中就包括：约定大于配置、低侵入松耦合、模块化轻量级等。这些设计思想都很通用，掌握之后，我们可以借鉴用到其他框架的开发中。</p><p>话不多少，让我们正式开始今天的学习吧！</p><h2>Spring框架简单介绍</h2><p>考虑到你可能不熟悉Spring，我这里对它做下简单介绍。我们常说的Spring框架，是指Spring Framework基础框架。Spring Framework是整个Spring生态（也被称作Spring全家桶）的基石。除了Spring Framework，Spring全家桶中还有更多基于Spring Framework开发出来的、整合更多功能的框架，比如Spring Boot、Spring Cloud。</p><!-- [[[read_end]]] --><p>在Spring全家桶中，Spring Framework是最基础、最底层的一部分。它提供了最基础、最核心的IOC和AOP功能。当然，它包含的功能还不仅如此，还有其他比如事务管理（Transactions）、MVC框架（Spring MVC）等很多功能。下面这个表格，是我从Spring官网上找的，关于Spring Framework的功能介绍，你可以大略地看下有个印象。</p><p><img src=\"https://static001.geekbang.org/resource/image/1a/41/1ab07ad6aed0f06cbce9547552281041.jpeg\" alt=\"\"></p><p>在Spring Framework中，Spring MVC出镜率很高，经常被单独拎出来使用。它是支持Web开发的MVC框架，提供了URL路由、Session管理、模板引擎等跟Web开发相关的一系列功能。</p><p>Spring Boot是基于Spring Framework开发的。它更加专注于微服务开发。之所以名字里带有“Boot”一词，跟它的设计初衷有关。Spring Boot的设计初衷是快速启动一个项目，利用它可以快速地实现一个项目的开发、部署和运行。Spring Boot支持的所有功能都是围绕着这个初衷设计的，比如：集成很多第三方开发包、简化配置（比如，规约优于配置）、集成内嵌Web容器（比如，Tomcat、Jetty）等。</p><p>单个的微服务开发，使用Spring Boot就足够了，但是，如果要构建整个微服务集群，就需要用到Spring Cloud了。Spring Cloud主要负责微服务集群的服务治理工作，包含很多独立的功能组件，比如Spring Cloud Sleuth调用链追踪、Spring Cloud Config配置中心等。</p><h2>从Spring看框架的作用</h2><p>如果你使用过一些框架来做开发，你应该能感受到使用框架开发的优势。这里我稍微总结一下。利用框架的好处有：解耦业务和非业务开发、让程序员聚焦在业务开发上；隐藏复杂实现细节、降低开发难度、减少代码bug；实现代码复用、节省开发时间；规范化标准化项目开发、降低学习和维护成本等等。实际上，如果要用一句话来总结一下的话，那就是简化开发！</p><p>对于刚刚的总结，我们再详细解释一下。</p><p>相比单纯的CRUD业务代码开发，非业务代码开发要更难一些。所以，将一些非业务的通用代码开发为框架，在项目中复用，除了节省开发时间之外，也降低了项目开发的难度。除此之外，框架经过多个项目的多次验证，比起每个项目都重新开发，代码的bug会相对少一些。而且，不同的项目使用相同的框架，对于研发人员来说，从一个项目切换到另一个项目的学习成本，也会降低很多。</p><p>接下来，我们再拿常见的Web项目开发来举例说明一下。</p><p>通过在项目中引入Spring MVC开发框架，开发一个Web应用，我们只需要创建Controller、Service、Repository三层类，在其中填写相应的业务代码，然后做些简单的配置，告知框架Controller、Service、Repository类之间的调用关系，剩下的非业务相关的工作，比如，对象的创建、组装、管理，请求的解析、封装，URL与Controller之间的映射，都由框架来完成。</p><p>不仅如此，如果我们直接引入功能更强大的Spring Boot，那将应用部署到Web容器的工作都省掉了。Spring Boot内嵌了Tomcat、Jetty等Web容器。在编写完代码之后，我们用一条命令就能完成项目的部署、运行。</p><h2>Spring框架蕴含的设计思想</h2><p>在Google Guava源码讲解中，我们讲到开发通用功能模块的一些比较普适的开发思想，比如产品意识、服务意识、代码质量意识、不要重复早轮子等。今天，我们剖析一下Spring框架背后的一些经典设计思想（或开发技巧）。这些设计思想并非Spring独有，都比较通用，能借鉴应用在很多通用功能模块的设计开发中。\b这也是我们学习Spring源码的价值所在。</p><h3>1.约定优于配置</h3><p>在使用Spring开发的项目中，配置往往会比较复杂、繁琐。比如，我们利用Spring MVC来开发Web应用，需要配置每个Controller类以及Controller类中的接口对应的URL。</p><p>如何来简化配置呢？一般来讲，有两种方法，一种是基于注解，另一种是基于约定。这两种配置方式在Spring中都有用到。Spring在最小化配置方面做得淋漓尽致，有很多值得我们借鉴的地方。</p><p>基于注解的配置方式，我们在指定类上使用指定的注解，来替代集中的XML配置。比如，我们使用@RequestMapping注解，在Controller类或者接口上，标注对应的URL；使用@Transaction注解表明支持事务等。</p><p>基于约定的配置方式，也常叫作“约定优于配置”或者“规约优于配置”（Convention over Configuration）。通过约定的代码结构或者命名来减少配置。说直白点，就是提供配置的默认值，优先使用默认值。程序员只需要设置那些偏离约定的配置就可以了。</p><p>比如，在Spring JPA（基于ORM框架、JPA规范的基础上，封装的一套JPA应用框架）中，我们约定类名默认跟表名相同，属性名默认跟表字段名相同，String类型对应数据库中的varchar类型，long类型对应数据库中的bigint类型等等。</p><p>基于刚刚的约定，代码中定义的Order类就对应数据库中的“order”表。只有在偏离这一约定的时候，例如数据库中表命名为“order_info”而非“order”，我们才需要显示地去配置类与表的映射关系（Order类-&gt;order_info表）。</p><p>实际上，约定优于配置，很好地体现了“二八法则”。在平时的项目开发中，80%的配置使用默认配置就可以了，只有20%的配置必须用户显式地去设置。所以，基于约定来配置，在没有牺牲配置灵活性的前提下，节省了我们大量编写配置的时间，省掉了很多不动脑子的纯体力劳动，提高了开发效率。除此之外，基于相同的约定来做开发，也减少了项目的学习成本和维护成本。</p><h3>2.低侵入、松耦合</h3><p>框架的侵入性是衡量框架好坏的重要指标。所谓低侵入指的是，框架代码很少耦合在业务代码中。低侵入意味着，当我们要替换一个框架的时候，对原有的业务代码改动会很少。相反，如果一个框架是高度侵入的，代码高度侵入到业务代码中，那替换成另一个框架的成本将非常高，甚至几乎不可能。这也是一些长期维护的老项目，使用的框架、技术比较老旧，又无法更新的一个很重要的原因。</p><p>实际上，低侵入是Spring框架遵循的一个非常重要的设计思想。</p><p>Spring提供的IOC容器，在不需要Bean继承任何父类或者实现任何接口的情况下，仅仅通过配置，就能将它们纳入进Spring的管理中。如果我们换一个IOC容器，也只是重新配置一下就可以了，原有的Bean都不需要任何修改。</p><p>除此之外，Spring提供的AOP功能，也体现了低侵入的特性。在项目中，对于非业务功能，比如请求日志、数据采点、安全校验、事务等等，我们没必要将它们侵入进业务代码中。因为一旦侵入，这些代码将分散在各个业务代码中，删除、修改的成本就变得很高。而基于AOP这种开发模式，将非业务代码集中放到切面中，删除、修改的成本就变得很低了。</p><h3>3.模块化、轻量级</h3><p>我们知道，十几年前，EJB是Java企业级应用的主流开发框架。但是，它非常臃肿、复杂，侵入性、耦合性高，开发、维护和学习成本都不低。所以，为了替代笨重的EJB，Rod Johnson开发了一套开源的Interface21框架，提供了最基本的IOC功能。实际上，Interface21框架就是Spring框架的前身。</p><p>但是，随着不断的发展，Spring现在也不单单只是一个只包含IOC功能的小框架了，它显然已经壮大成了一个“平台”或者叫“生态”，包含了各种五花八门的功能。尽管如此，但它也并没有重蹈覆辙，变成一个像EJB那样的庞大难用的框架。那Spring是怎么做到的呢？</p><p>这就要归功于Spring的模块化设计思想。我们先看一张图，如下所示，它是Spring Framework的模块和分层介绍图。</p><p><img src=\"https://static001.geekbang.org/resource/image/69/2c/699208dbe6b43ee397a020ea733c342c.png\" alt=\"\"></p><p>从图中我们可以看出，Spring在分层、模块化方面做得非常好。每个模块都只负责一个相对独立的功能。模块之间关系，仅有上层对下层的依赖关系，而同层之间以及下层对上层，几乎没有依赖和耦合。除此之外，在依赖Spring的项目中，开发者可以有选择地引入某几个模块，而不会因为需要一个小的功能，就被强迫引入整个Spring框架。所以，尽管Spring Framework包含的模块很多，已经有二十几个，但每个模块都非常轻量级，都可以单独拿来使用。正因如此，到现在，Spring框架仍然可以被称为是一个轻量级的开发框架。</p><h3>4.再封装、再抽象</h3><p>Spring不仅仅提供了各种Java项目开发的常用功能模块，而且还对市面上主流的中间件、系统的访问类库，做了进一步的封装和抽象，提供了更高层次、更统一的访问接口。</p><p>比如，Spring提供了spring-data-redis模块，对Redis Java开发类库（比如Jedis、Lettuce）做了进一步的封装，适配Spring的访问方式，让编程访问Redis更加简单。</p><p>还有我们下节课要讲的Spring Cache，实际上也是一种再封装、再抽象。它定义了统一、抽象的Cache访问接口，这些接口不依赖具体的Cache实现（Redis、Guava Cache、Caffeine等）。在项目中，我们基于Spring提供的抽象统一的接口来访问Cache。这样，我们就能在不修改代码的情况下，实现不同Cache之间的切换。</p><p>除此之外，还记得我们之前在模板模式中，讲过的JdbcTemplate吗？实际上，它也是对JDBC的进一步封装和抽象，为的是进一步简化数据库编程。不仅如此，Spring对JDBC异常也做了进一步的封装。封装的数据库异常继承自DataAccessException运行时异常。这类异常在开发中无需强制捕获，从而减少了不必要的异常捕获和处理。除此之外，Spring封装的数据库异常，还屏蔽了不同数据库异常的细节（比如，不同的数据库对同一报错定义了不同的错误码），让异常的处理更加简单。</p><h2>\b重点回顾</h2><p>好了，今天的内容到此就讲完了。我们一块来总结回顾一下，你需要重点掌握的内容。</p><p>借助Spring框架，我们总结了框架的作用：解耦业务和非业务开发、让程序员聚焦在业务开发上；隐藏复杂实现细节、降低开发难度、减少代码bug；实现代码复用、节省开发时间；规范化标准化项目开发、降低学习和维护成本等。实际上，如果要用一句话来总结一下的话，那就是简化开发！</p><p>除此之外，我们还重点讲解了Sping背后蕴含的一些经典设计思想，主要有：约定优于配置，低侵入、松耦合，模块化、轻量级，再封装、再抽象。这些设计思想都比较通用，我们可以借鉴到其他框架的开发中。</p><h2>课堂讨论</h2><ol>\n<li>“约定优于配置”在很多开发场景中都有体现，比如Maven、Gradle构建工具，它们约定了一套默认的项目目录结构，除此之外，你还能想到体现这条设计思想的其他哪些开发场景吗？</li>\n<li>参照Spring的设计思想，分析一个你熟悉框架、类库、功能组件背后的设计思想。</li>\n</ol><p>欢迎留言和我分享你的想法，如果有收获，也欢迎你把这篇文章分享给你的朋友。</p>",
                "article_title": "84 | 开源实战四（上）：剖析Spring框架中蕴含的经典设计思想或原则"
            },
            {
                "title": "85 | 开源实战四（中）：剖析Spring框架中用来支持扩展的两种设计模式",
                "herf": "https://time.geekbang.org/column/article/237810",
                "id": "237810",
                "content": "<p>上一节课中，我们学习了Spring框架背后蕴藏的一些经典设计思想，比如约定优于配置、低侵入松耦合、模块化轻量级等等。我们可以将这些设计思想借鉴到其他框架开发中，在大的设计层面提高框架的代码质量。这也是我们在专栏中讲解这部分内容的原因。</p><p>除了上一节课中讲到的设计思想，实际上，可扩展也是大部分框架应该具备的一个重要特性。所谓的框架可扩展，我们之前也提到过，意思就是，框架使用者在不修改框架源码的情况下，基于扩展点定制扩展新的功能。</p><p>前面在理论部分，我们也讲到，常用来实现扩展特性的设计模式有：观察者模式、模板模式、职责链模式、策略模式等。今天，我们再剖析Spring框架为了支持可扩展特性用的2种设计模式：观察者模式和模板模式。</p><p>话不多说，让我们正式开始今天的学习吧！</p><h2>观察者模式在Spring中的应用</h2><p>在前面我们讲到，Java、Google Guava都提供了观察者模式的实现框架。Java提供的框架比较简单，只包含java.util.Observable和java.util.Observer两个类。Google Guava提供的框架功能比较完善和强大：通过EventBus事件总线来实现观察者模式。实际上，Spring也提供了观察者模式的实现框架。今天，我们就再来讲一讲它。</p><!-- [[[read_end]]] --><p>Spring中实现的观察者模式包含三部分：Event事件（相当于消息）、Listener监听者（相当于观察者）、Publisher发送者（相当于被观察者）。我们通过一个例子来看下，Spring提供的观察者模式是怎么使用的。代码如下所示：</p><pre><code>// Event事件\npublic class DemoEvent extends ApplicationEvent {\n  private String message;\n\n  public DemoEvent(Object source, String message) {\n    super(source);\n  }\n\n  public String getMessage() {\n    return this.message;\n  }\n}\n\n// Listener监听者\n@Component\npublic class DemoListener implements ApplicationListener&lt;DemoEvent&gt; {\n  @Override\n  public void onApplicationEvent(DemoEvent demoEvent) {\n    String message = demoEvent.getMessage();\n    System.out.println(message);\n  }\n}\n\n// Publisher发送者\n@Component\npublic class DemoPublisher {\n  @Autowired\n  private ApplicationContext applicationContext;\n\n  public void publishEvent(DemoEvent demoEvent) {\n    this.applicationContext.publishEvent(demoEvent);\n  }\n}\n</code></pre><p>从代码中，我们可以看出，框架使用起来并不复杂，主要包含三部分工作：定义一个继承ApplicationEvent的事件（DemoEvent）；定义一个实现了ApplicationListener的监听器（DemoListener）；定义一个发送者（DemoPublisher），发送者调用ApplicationContext来发送事件消息。</p><p>其中，ApplicationEvent和ApplicationListener的代码实现都非常简单，内部并不包含太多属性和方法。实际上，它们最大的作用是做类型标识之用（继承自ApplicationEvent的类是事件，实现ApplicationListener的类是监听器）。</p><pre><code>public abstract class ApplicationEvent extends EventObject {\n  private static final long serialVersionUID = 7099057708183571937L;\n  private final long timestamp = System.currentTimeMillis();\n\n  public ApplicationEvent(Object source) {\n    super(source);\n  }\n\n  public final long getTimestamp() {\n    return this.timestamp;\n  }\n}\n\npublic class EventObject implements java.io.Serializable {\n    private static final long serialVersionUID = 5516075349620653480L;\n    protected transient Object  source;\n\n    public EventObject(Object source) {\n        if (source == null)\n            throw new IllegalArgumentException(&quot;null source&quot;);\n        this.source = source;\n    }\n\n    public Object getSource() {\n        return source;\n    }\n\n    public String toString() {\n        return getClass().getName() + &quot;[source=&quot; + source + &quot;]&quot;;\n    }\n}\n\npublic interface ApplicationListener&lt;E extends ApplicationEvent&gt; extends EventListener {\n  void onApplicationEvent(E var1);\n}\n</code></pre><p>在前面讲到观察者模式的时候，我们提到，观察者需要事先注册到被观察者（JDK的实现方式）或者事件总线（EventBus的实现方式）中。那在Spring的实现中，观察者注册到了哪里呢？又是如何注册的呢？</p><p>我想你应该猜到了，我们把观察者注册到了ApplicationContext对象中。这里的ApplicationContext就相当于Google EventBus框架中的“事件总线”。不过，稍微提醒一下，ApplicationContext这个类并不只是为观察者模式服务的。它底层依赖BeanFactory（IOC的主要实现类），提供应用启动、运行时的上下文信息，是访问这些信息的最顶层接口。</p><p>实际上，具体到源码来说，ApplicationContext只是一个接口，具体的代码实现包含在它的实现类AbstractApplicationContext中。我把跟观察者模式相关的代码，摘抄到了下面。你只需要关注它是如何发送事件和注册监听者就好，其他细节不需要细究。</p><pre><code>public abstract class AbstractApplicationContext extends ... {\n  private final Set&lt;ApplicationListener&lt;?&gt;&gt; applicationListeners;\n  \n  public AbstractApplicationContext() {\n    this.applicationListeners = new LinkedHashSet();\n    //...\n  }\n  \n  public void publishEvent(ApplicationEvent event) {\n    this.publishEvent(event, (ResolvableType)null);\n  }\n\n  public void publishEvent(Object event) {\n    this.publishEvent(event, (ResolvableType)null);\n  }\n\n  protected void publishEvent(Object event, ResolvableType eventType) {\n    //...\n    Object applicationEvent;\n    if (event instanceof ApplicationEvent) {\n      applicationEvent = (ApplicationEvent)event;\n    } else {\n      applicationEvent = new PayloadApplicationEvent(this, event);\n      if (eventType == null) {\n        eventType = ((PayloadApplicationEvent)applicationEvent).getResolvableType();\n      }\n    }\n\n    if (this.earlyApplicationEvents != null) {\n      this.earlyApplicationEvents.add(applicationEvent);\n    } else {\n      this.getApplicationEventMulticaster().multicastEvent(\n            (ApplicationEvent)applicationEvent, eventType);\n    }\n\n    if (this.parent != null) {\n      if (this.parent instanceof AbstractApplicationContext) {\n        ((AbstractApplicationContext)this.parent).publishEvent(event, eventType);\n      } else {\n        this.parent.publishEvent(event);\n      }\n    }\n  }\n  \n  public void addApplicationListener(ApplicationListener&lt;?&gt; listener) {\n    Assert.notNull(listener, &quot;ApplicationListener must not be null&quot;);\n    if (this.applicationEventMulticaster != null) {\n    this.applicationEventMulticaster.addApplicationListener(listener);\n    } else {\n      this.applicationListeners.add(listener);\n    }  \n  }\n  \n  public Collection&lt;ApplicationListener&lt;?&gt;&gt; getApplicationListeners() {\n    return this.applicationListeners;\n  }\n  \n  protected void registerListeners() {\n    Iterator var1 = this.getApplicationListeners().iterator();\n\n    while(var1.hasNext()) {\n      ApplicationListener&lt;?&gt; listener = (ApplicationListener)var1.next();     this.getApplicationEventMulticaster().addApplicationListener(listener);\n    }\n\n    String[] listenerBeanNames = this.getBeanNamesForType(ApplicationListener.class, true, false);\n    String[] var7 = listenerBeanNames;\n    int var3 = listenerBeanNames.length;\n\n    for(int var4 = 0; var4 &lt; var3; ++var4) {\n      String listenerBeanName = var7[var4];\n      this.getApplicationEventMulticaster().addApplicationListenerBean(listenerBeanName);\n    }\n\n    Set&lt;ApplicationEvent&gt; earlyEventsToProcess = this.earlyApplicationEvents;\n    this.earlyApplicationEvents = null;\n    if (earlyEventsToProcess != null) {\n      Iterator var9 = earlyEventsToProcess.iterator();\n\n      while(var9.hasNext()) {\n        ApplicationEvent earlyEvent = (ApplicationEvent)var9.next();\n        this.getApplicationEventMulticaster().multicastEvent(earlyEvent);\n      }\n    }\n  }\n}\n</code></pre><p>从上面的代码中，我们发现，真正的消息发送，实际上是通过ApplicationEventMulticaster这个类来完成的。这个类的源码我只摘抄了最关键的一部分，也就是multicastEvent()这个消息发送函数。不过，它的代码也并不复杂，我就不多解释了。这里我稍微提示一下，它通过线程池，支持异步非阻塞、同步阻塞这两种类型的观察者模式。</p><pre><code>public void multicastEvent(ApplicationEvent event) {\n  this.multicastEvent(event, this.resolveDefaultEventType(event));\n}\n\npublic void multicastEvent(final ApplicationEvent event, ResolvableType eventType) {\n  ResolvableType type = eventType != null ? eventType : this.resolveDefaultEventType(event);\n  Iterator var4 = this.getApplicationListeners(event, type).iterator();\n\n  while(var4.hasNext()) {\n    final ApplicationListener&lt;?&gt; listener = (ApplicationListener)var4.next();\n    Executor executor = this.getTaskExecutor();\n    if (executor != null) {\n      executor.execute(new Runnable() {\n        public void run() {\n          SimpleApplicationEventMulticaster.this.invokeListener(listener, event);\n        }\n      });\n    } else {\n      this.invokeListener(listener, event);\n    }\n  }\n\n}\n</code></pre><p>借助Spring提供的观察者模式的骨架代码，如果我们要在Spring下实现某个事件的发送和监听，只需要做很少的工作，定义事件、定义监听器、往ApplicationContext中发送事件就可以了，剩下的工作都由Spring框架来完成。实际上，这也体现了Spring框架的扩展性，也就是在不需要修改任何代码的情况下，扩展新的事件和监听。</p><h2>模板模式在Spring中的应用</h2><p>刚刚讲的是观察者模式在Spring中的应用，现在我们再讲下模板模式。</p><p>我们来看下一下经常在面试中被问到的一个问题：请你说下Spring Bean的创建过程包含哪些主要的步骤。这其中就涉及模板模式。它也体现了Spring的扩展性。利用模板模式，Spring能让用户定制Bean的创建过程。</p><p>Spring Bean的创建过程，可以大致分为两大步：对象的创建和对象的初始化。</p><p>对象的创建是通过反射来动态生成对象，而不是new方法。不管是哪种方式，说白了，总归还是调用构造函数来生成对象，没有什么特殊的。对象的初始化有两种实现方式。一种是在类中自定义一个初始化函数，并且通过配置文件，显式地告知Spring，哪个函数是初始化函数。我举了一个例子解释一下。如下所示，在配置文件中，我们通过init-method属性来指定初始化函数。</p><pre><code>public class DemoClass {\n  //...\n  \n  public void initDemo() {\n    //...初始化..\n  }\n}\n\n// 配置：需要通过init-method显式地指定初始化方法\n&lt;bean id=&quot;demoBean&quot; class=&quot;com.xzg.cd.DemoClass&quot; init-method=&quot;initDemo&quot;&gt;&lt;/bean&gt;\n</code></pre><p>这种初始化方式有一个缺点，初始化函数并不固定，由用户随意定义，这就需要Spring通过反射，在运行时动态地调用这个初始化函数。而反射又会影响代码执行的性能，那有没有替代方案呢？</p><p>Spring提供了另外一个定义初始化函数的方法，那就是让类实现Initializingbean接口。这个接口包含一个固定的初始化函数定义（afterPropertiesSet()函数）。Spring在初始化Bean的时候，可以直接通过bean.afterPropertiesSet()的方式，调用Bean对象上的这个函数，而不需要使用反射来调用了。我举个例子解释一下，代码如下所示。</p><pre><code>public class DemoClass implements InitializingBean{\n  @Override\n  public void afterPropertiesSet() throws Exception {\n    //...初始化...      \n  }\n}\n\n// 配置：不需要显式地指定初始化方法\n&lt;bean id=&quot;demoBean&quot; class=&quot;com.xzg.cd.DemoClass&quot;&gt;&lt;/bean&gt;\n</code></pre><p>尽管这种实现方式不会用到反射，执行效率提高了，但业务代码（DemoClass）跟框架代码（InitializingBean）耦合在了一起。框架代码侵入到了业务代码中，替换框架的成本就变高了。所以，我并不是太推荐这种写法。</p><p>实际上，在Spring对Bean整个生命周期的管理中，还有一个跟初始化相对应的过程，那就是Bean的销毁过程。我们知道，在Java中，对象的回收是通过JVM来自动完成的。但是，我们可以在将Bean正式交给JVM垃圾回收前，执行一些销毁操作（比如关闭文件句柄等等）。</p><p>销毁过程跟初始化过程非常相似，也有两种实现方式。一种是通过配置destroy-method指定类中的销毁函数，另一种是让类实现DisposableBean接口。因为destroy-method、DisposableBean跟init-method、InitializingBean非常相似，所以，这部分我们就不详细讲解了，你可以自行研究下。</p><p>实际上，Spring针对对象的初始化过程，还做了进一步的细化，将它拆分成了三个小步骤：初始化前置操作、初始化、初始化后置操作。其中，中间的初始化操作就是我们刚刚讲的那部分，初始化的前置和后置操作，定义在接口BeanPostProcessor中。BeanPostProcessor的接口定义如下所示：</p><pre><code>public interface BeanPostProcessor {\n  Object postProcessBeforeInitialization(Object var1, String var2) throws BeansException;\n\n  Object postProcessAfterInitialization(Object var1, String var2) throws BeansException;\n}\n</code></pre><p>我们再来看下，如何通过BeanPostProcessor来定义初始化前置和后置操作？</p><p>我们只需要定义一个实现了BeanPostProcessor接口的处理器类，并在配置文件中像配置普通Bean一样去配置就可以了。Spring中的ApplicationContext会自动检测在配置文件中实现了BeanPostProcessor接口的所有Bean，并把它们注册到BeanPostProcessor处理器列表中。在Spring容器创建Bean的过程中，Spring会逐一去调用这些处理器。</p><p>通过上面的分析，我们基本上弄清楚了Spring Bean的整个生命周期（创建加销毁）。针对这个过程，我画了一张图，你可以结合着刚刚讲解一块看下。</p><p><img src=\"https://static001.geekbang.org/resource/image/ca/4d/cacaf86b03a9432a4885385d2869264d.jpg\" alt=\"\"></p><p>不过，你可能会说，这里哪里用到了模板模式啊？模板模式不是需要定义一个包含模板方法的抽象模板类，以及定义子类实现模板方法吗？</p><p>实际上，这里的模板模式的实现，并不是标准的抽象类的实现方式，而是有点类似我们前面讲到的Callback回调的实现方式，也就是将要执行的函数封装成对象（比如，初始化方法封装成InitializingBean对象），传递给模板（BeanFactory）来执行。</p><h2>重点回顾</h2><p>好了，今天的内容到此就讲完了。我们一块来总结回顾一下，你需要重点掌握的内容。</p><p>今天我讲到了Spring中用到的两种支持扩展的设计模式，观察者模式和模板模式。</p><p>其中，观察者模式在Java、Google Guava、Spring中都有提供相应的实现代码。在平时的项目开发中，基于这些实现代码，我们可以轻松地实现一个观察者模式。</p><p>Java提供的框架比较简单，只包含java.util.Observable和java.util.Observer两个类。Google Guava提供的框架功能比较完善和强大，可以通过EventBus事件总线来实现观察者模式。Spring提供了观察者模式包含Event事件、Listener监听者、Publisher发送者三部分。事件发送到ApplicationContext中，然后，ApplicationConext将消息发送给事先注册好的监听者。</p><p>除此之外，我们还讲到模板模式在Spring中的一个典型应用，那就是Bean的创建过程。Bean的创建包含两个大的步骤，对象的创建和对象的初始化。其中，对象的初始化又可以分解为3个小的步骤：初始化前置操作、初始化、初始化后置操作。</p><h2>课堂讨论</h2><p>在Google Guava的EventBus实现中，被观察者发送消息到事件总线，事件总线根据消息的类型，将消息发送给可匹配的观察者。那在Spring提供的观察者模式的实现中，是否也支持按照消息类型匹配观察者呢？如果能，它是如何实现的？如果不能，你有什么方法可以让它支持吗？</p><p>欢迎留言和我分享你的想法。如果有收获，也欢迎你把这篇文章分享给你的朋友。</p>",
                "article_title": "85 | 开源实战四（中）：剖析Spring框架中用来支持扩展的两种设计模式"
            },
            {
                "title": "86 | 开源实战四（下）：总结Spring框架用到的11种设计模式",
                "herf": "https://time.geekbang.org/column/article/238418",
                "id": "238418",
                "content": "<p>上一节课，我们讲解了Spring中支持扩展功能的两种设计模式：观察者模式和模板模式。这两种模式能够帮助我们创建扩展点，让框架的使用者在不修改源码的情况下，基于扩展点定制化框架功能。</p><p>实际上，Spring框架中用到的设计模式非常多，不下十几种。我们今天就总结罗列一下它们。限于篇幅，我不可能对每种设计模式都进行非常详细的讲解。有些前面已经讲过的或者比较简单的，我就点到为止。如果有什么不是很懂的地方，你可以通过阅读源码，查阅之前的理论讲解，自己去搞定它。如果一直跟着我的课程学习，相信你现在已经具备这样的学习能力。</p><p>话不多说，让我们正式开始今天的学习吧！</p><h2>适配器模式在Spring中的应用</h2><p>在Spring MVC中，定义一个Controller最常用的方式是，通过@Controller注解来标记某个类是Controller类，通过@RequesMapping注解来标记函数对应的URL。不过，定义一个Controller远不止这一种方法。我们还可以通过让类实现Controller接口或者Servlet接口，来定义一个Controller。针对这三种定义方式，我写了三段示例代码，如下所示：</p><pre><code>// 方法一：通过@Controller、@RequestMapping来定义\n@Controller\npublic class DemoController {\n    @RequestMapping(&quot;/employname&quot;)\n    public ModelAndView getEmployeeName() {\n        ModelAndView model = new ModelAndView(&quot;Greeting&quot;);        \n        model.addObject(&quot;message&quot;, &quot;Dinesh&quot;);       \n        return model; \n    }  \n}\n\n// 方法二：实现Controller接口 + xml配置文件:配置DemoController与URL的对应关系\npublic class DemoController implements Controller {\n    @Override\n    public ModelAndView handleRequest(HttpServletRequest req, HttpServletResponse resp) throws Exception {\n        ModelAndView model = new ModelAndView(&quot;Greeting&quot;);\n        model.addObject(&quot;message&quot;, &quot;Dinesh Madhwal&quot;);\n        return model;\n    }\n}\n\n// 方法三：实现Servlet接口 + xml配置文件:配置DemoController类与URL的对应关系\npublic class DemoServlet extends HttpServlet {\n  @Override\n  protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n    this.doPost(req, resp);\n  }\n  \n  @Override\n  protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n    resp.getWriter().write(&quot;Hello World.&quot;);\n  }\n}\n</code></pre><!-- [[[read_end]]] --><p>在应用启动的时候，Spring容器会加载这些Controller类，并且解析出URL对应的处理函数，封装成Handler对象，存储到HandlerMapping对象中。当有请求到来的时候，DispatcherServlet从HanderMapping中，查找请求URL对应的Handler，然后调用执行Handler对应的函数代码，最后将执行结果返回给客户端。</p><p>但是，不同方式定义的Controller，其函数的定义（函数名、入参、返回值等）是不统一的。如上示例代码所示，方法一中的函数的定义很随意、不固定，方法二中的函数定义是handleRequest()、方法三中的函数定义是service()（看似是定义了doGet()、doPost()，实际上，这里用到了模板模式，Servlet中的service()调用了doGet()或doPost()方法，DispatcherServlet调用的是service()方法）。DispatcherServlet需要根据不同类型的Controller，调用不同的函数。下面是具体的伪代码：</p><pre><code>Handler handler = handlerMapping.get(URL);\nif (handler instanceof Controller) {\n  ((Controller)handler).handleRequest(...);\n} else if (handler instanceof Servlet) {\n  ((Servlet)handler).service(...);\n} else if (hanlder 对应通过注解来定义的Controller) {\n  反射调用方法...\n}\n</code></pre><p>从代码中我们可以看出，这种实现方式会有很多if-else分支判断，而且，如果要增加一个新的Controller的定义方法，我们就要在DispatcherServlet类代码中，对应地增加一段如上伪代码所示的if逻辑。这显然不符合开闭原则。</p><p>实际上，我们可以利用是适配器模式对代码进行改造，让其满足开闭原则，能更好地支持扩展。在<a href=\"https://time.geekbang.org/column/article/205912\">第51节课</a>中，我们讲到，适配器其中一个作用是“统一多个类的接口设计”。利用适配器模式，我们将不同方式定义的Controller类中的函数，适配为统一的函数定义。这样，我们就能在DispatcherServlet类代码中，移除掉if-else分支判断逻辑，调用统一的函数。</p><p>刚刚讲了大致的设计思路，我们再具体看下Spring的代码实现。</p><p>Spring定义了统一的接口HandlerAdapter，并且对每种Controller定义了对应的适配器类。这些适配器类包括：AnnotationMethodHandlerAdapter、SimpleControllerHandlerAdapter、SimpleServletHandlerAdapter等。源码我贴到了下面，你可以结合着看下。</p><pre><code>public interface HandlerAdapter {\n  boolean supports(Object var1);\n\n  ModelAndView handle(HttpServletRequest var1, HttpServletResponse var2, Object var3) throws Exception;\n\n  long getLastModified(HttpServletRequest var1, Object var2);\n}\n\n// 对应实现Controller接口的Controller\npublic class SimpleControllerHandlerAdapter implements HandlerAdapter {\n  public SimpleControllerHandlerAdapter() {\n  }\n\n  public boolean supports(Object handler) {\n    return handler instanceof Controller;\n  }\n\n  public ModelAndView handle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {\n    return ((Controller)handler).handleRequest(request, response);\n  }\n\n  public long getLastModified(HttpServletRequest request, Object handler) {\n    return handler instanceof LastModified ? ((LastModified)handler).getLastModified(request) : -1L;\n  }\n}\n\n// 对应实现Servlet接口的Controller\npublic class SimpleServletHandlerAdapter implements HandlerAdapter {\n  public SimpleServletHandlerAdapter() {\n  }\n\n  public boolean supports(Object handler) {\n    return handler instanceof Servlet;\n  }\n\n  public ModelAndView handle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {\n    ((Servlet)handler).service(request, response);\n    return null;\n  }\n\n  public long getLastModified(HttpServletRequest request, Object handler) {\n    return -1L;\n  }\n}\n\n//AnnotationMethodHandlerAdapter对应通过注解实现的Controller，\n//代码太多了，我就不贴在这里了\n</code></pre><p>在DispatcherServlet类中，我们就不需要区分对待不同的Controller对象了，统一调用HandlerAdapter的handle()函数就可以了。按照这个思路实现的伪代码如下所示。你看，这样就没有烦人的if-else逻辑了吧？</p><pre><code>// 之前的实现方式\nHandler handler = handlerMapping.get(URL);\nif (handler instanceof Controller) {\n  ((Controller)handler).handleRequest(...);\n} else if (handler instanceof Servlet) {\n  ((Servlet)handler).service(...);\n} else if (hanlder 对应通过注解来定义的Controller) {\n  反射调用方法...\n}\n\n// 现在实现方式\nHandlerAdapter handlerAdapter = handlerMapping.get(URL);\nhandlerAdapter.handle(...);\n</code></pre><h2>策略模式在Spring中的应用</h2><p>我们前面讲到，Spring AOP是通过动态代理来实现的。熟悉Java的同学应该知道，具体到代码实现，Spring支持两种动态代理实现方式，一种是JDK提供的动态代理实现方式，另一种是Cglib提供的动态代理实现方式。</p><p>前者需要被代理的类有抽象的接口定义，后者不需要（这两种动态代理实现方式的更多区别请自行百度研究吧）。针对不同的被代理类，Spring会在运行时动态地选择不同的动态代理实现方式。这个应用场景实际上就是策略模式的典型应用场景。</p><p>我们前面讲过，策略模式包含三部分，策略的定义、创建和使用。接下来，我们具体看下，这三个部分是如何体现在Spring源码中的。</p><p>在策略模式中，策略的定义这一部分很简单。我们只需要定义一个策略接口，让不同的策略类都实现这一个策略接口。对应到Spring源码，AopProxy是策略接口，JdkDynamicAopProxy、CglibAopProxy是两个实现了AopProxy接口的策略类。其中，AopProxy接口的定义如下所示：</p><pre><code>public interface AopProxy {\n  Object getProxy();\n  Object getProxy(ClassLoader var1);\n}\n</code></pre><p>在策略模式中，策略的创建一般通过工厂方法来实现。对应到Spring源码，AopProxyFactory是一个工厂类接口，DefaultAopProxyFactory是一个默认的工厂类，用来创建AopProxy对象。两者的源码如下所示：</p><pre><code>public interface AopProxyFactory {\n  AopProxy createAopProxy(AdvisedSupport var1) throws AopConfigException;\n}\n\npublic class DefaultAopProxyFactory implements AopProxyFactory, Serializable {\n  public DefaultAopProxyFactory() {\n  }\n\n  public AopProxy createAopProxy(AdvisedSupport config) throws AopConfigException {\n    if (!config.isOptimize() &amp;&amp; !config.isProxyTargetClass() &amp;&amp; !this.hasNoUserSuppliedProxyInterfaces(config)) {\n      return new JdkDynamicAopProxy(config);\n    } else {\n      Class&lt;?&gt; targetClass = config.getTargetClass();\n      if (targetClass == null) {\n        throw new AopConfigException(&quot;TargetSource cannot determine target class: Either an interface or a target is required for proxy creation.&quot;);\n      } else {\n        return (AopProxy)(!targetClass.isInterface() &amp;&amp; !Proxy.isProxyClass(targetClass) ? new ObjenesisCglibAopProxy(config) : new JdkDynamicAopProxy(config));\n      }\n    }\n  }\n\n  //用来判断用哪个动态代理实现方式\n  private boolean hasNoUserSuppliedProxyInterfaces(AdvisedSupport config) {\n    Class&lt;?&gt;[] ifcs = config.getProxiedInterfaces();\n    return ifcs.length == 0 || ifcs.length == 1 &amp;&amp; SpringProxy.class.isAssignableFrom(ifcs[0]);\n  }\n}\n</code></pre><p>策略模式的典型应用场景，一般是通过环境变量、状态值、计算结果等动态地决定使用哪个策略。对应到Spring源码中，我们可以参看刚刚给出的DefaultAopProxyFactory类中的createAopProxy()函数的代码实现。其中，第10行代码是动态选择哪种策略的判断条件。</p><h2>组合模式在Spring中的应用</h2><p>上节课讲到Spring“再封装、再抽象”设计思想的时候，我们提到了Spring Cache。Spring Cache提供了一套抽象的Cache接口。使用它我们能够\b统一不同缓存实现（Redis、Google Guava…）的不同的访问方式。Spring中针对不同缓存实现的不同缓存访问类，都依赖这个接口，比如：EhCacheCache、GuavaCache、NoOpCache、RedisCache、JCacheCache、ConcurrentMapCache、CaffeineCache。Cache接口的源码如下所示：</p><pre><code>public interface Cache {\n  String getName();\n  Object getNativeCache();\n  Cache.ValueWrapper get(Object var1);\n  &lt;T&gt; T get(Object var1, Class&lt;T&gt; var2);\n  &lt;T&gt; T get(Object var1, Callable&lt;T&gt; var2);\n  void put(Object var1, Object var2);\n  Cache.ValueWrapper putIfAbsent(Object var1, Object var2);\n  void evict(Object var1);\n  void clear();\n\n  public static class ValueRetrievalException extends RuntimeException {\n    private final Object key;\n\n    public ValueRetrievalException(Object key, Callable&lt;?&gt; loader, Throwable ex) {\n      super(String.format(&quot;Value for key '%s' could not be loaded using '%s'&quot;, key, loader), ex);\n      this.key = key;\n    }\n\n    public Object getKey() {\n      return this.key;\n    }\n  }\n\n  public interface ValueWrapper {\n    Object get();\n  }\n}\n</code></pre><p>在实际的开发中，一个项目有可能会用到多种不同的缓存，比如既用到Google Guava缓存，也用到Redis缓存。除此之外，同一个缓存实例，也可以根据业务的不同，分割成多个小的逻辑缓存单元（或者叫作命名空间）。</p><p>为了管理多个缓存，Spring还提供了缓存管理功能。不过，它包含的功能很简单，主要有这样两部分：一个是根据缓存名字（创建Cache对象的时候要设置name属性）获取Cache对象；另一个是获取管理器管理的所有缓存的名字列表。对应的Spring源码如下所示：</p><pre><code>public interface CacheManager {\n  Cache getCache(String var1);\n  Collection&lt;String&gt; getCacheNames();\n}\n</code></pre><p>刚刚给出的是CacheManager接口的定义，那如何来实现这两个接口呢？实际上，这就要用到了我们之前讲过的组合模式。</p><p>我们前面讲过，组合模式主要应用在能表示成树形结构的一组数据上。树中的结点分为叶子节点和中间节点两类。对应到Spring源码，EhCacheManager、SimpleCacheManager、NoOpCacheManager、RedisCacheManager等表示叶子节点，CompositeCacheManager表示中间节点。</p><p>叶子节点包含的是它所管理的Cache对象，中间节点包含的是其他CacheManager管理器，既可以是CompositeCacheManager，也可以是具体的管理器，比如EhCacheManager、RedisManager等。</p><p>我把CompositeCacheManger的代码贴到了下面，你可以结合着讲解一块看下。其中，getCache()、getCacheNames()两个函数的实现都用到了递归。这正是树形结构最能发挥优势的地方。</p><pre><code>public class CompositeCacheManager implements CacheManager, InitializingBean {\n  private final List&lt;CacheManager&gt; cacheManagers = new ArrayList();\n  private boolean fallbackToNoOpCache = false;\n\n  public CompositeCacheManager() {\n  }\n\n  public CompositeCacheManager(CacheManager... cacheManagers) {\n    this.setCacheManagers(Arrays.asList(cacheManagers));\n  }\n\n  public void setCacheManagers(Collection&lt;CacheManager&gt; cacheManagers) {\n    this.cacheManagers.addAll(cacheManagers);\n  }\n\n  public void setFallbackToNoOpCache(boolean fallbackToNoOpCache) {\n    this.fallbackToNoOpCache = fallbackToNoOpCache;\n  }\n\n  public void afterPropertiesSet() {\n    if (this.fallbackToNoOpCache) {\n      this.cacheManagers.add(new NoOpCacheManager());\n    }\n\n  }\n\n  public Cache getCache(String name) {\n    Iterator var2 = this.cacheManagers.iterator();\n\n    Cache cache;\n    do {\n      if (!var2.hasNext()) {\n        return null;\n      }\n\n      CacheManager cacheManager = (CacheManager)var2.next();\n      cache = cacheManager.getCache(name);\n    } while(cache == null);\n\n    return cache;\n  }\n\n  public Collection&lt;String&gt; getCacheNames() {\n    Set&lt;String&gt; names = new LinkedHashSet();\n    Iterator var2 = this.cacheManagers.iterator();\n\n    while(var2.hasNext()) {\n      CacheManager manager = (CacheManager)var2.next();\n      names.addAll(manager.getCacheNames());\n    }\n\n    return Collections.unmodifiableSet(names);\n  }\n}\n</code></pre><h2>装饰器模式在Spring中的应用</h2><p>我们知道，缓存一般都是配合数据库来使用的。如果写缓存成功，但数据库事务回滚了，那缓存中就会有脏数据。为了解决这个问题，我们需要将缓存的写操作和数据库的写操作，放到同一个事务中，要么都成功，要么都失败。</p><p>实现这样一个功能，Spring使用到了装饰器模式。TransactionAwareCacheDecorator增加了对事务的支持，在事务提交、回滚的时候分别对Cache的数据进行处理。</p><p>TransactionAwareCacheDecorator实现Cache接口，并且将所有的操作都委托给targetCache来实现，对其中的写操作添加了事务功能。这是典型的装饰器模式的应用场景和代码实现，我就不多作解释了。</p><pre><code>public class TransactionAwareCacheDecorator implements Cache {\n  private final Cache targetCache;\n\n  public TransactionAwareCacheDecorator(Cache targetCache) {\n    Assert.notNull(targetCache, &quot;Target Cache must not be null&quot;);\n    this.targetCache = targetCache;\n  }\n\n  public Cache getTargetCache() {\n    return this.targetCache;\n  }\n\n  public String getName() {\n    return this.targetCache.getName();\n  }\n\n  public Object getNativeCache() {\n    return this.targetCache.getNativeCache();\n  }\n\n  public ValueWrapper get(Object key) {\n    return this.targetCache.get(key);\n  }\n\n  public &lt;T&gt; T get(Object key, Class&lt;T&gt; type) {\n    return this.targetCache.get(key, type);\n  }\n\n  public &lt;T&gt; T get(Object key, Callable&lt;T&gt; valueLoader) {\n    return this.targetCache.get(key, valueLoader);\n  }\n\n  public void put(final Object key, final Object value) {\n    if (TransactionSynchronizationManager.isSynchronizationActive()) {\n      TransactionSynchronizationManager.registerSynchronization(new TransactionSynchronizationAdapter() {\n        public void afterCommit() {\n          TransactionAwareCacheDecorator.this.targetCache.put(key, value);\n        }\n      });\n    } else {\n      this.targetCache.put(key, value);\n    }\n  }\n  \n  public ValueWrapper putIfAbsent(Object key, Object value) {\n    return this.targetCache.putIfAbsent(key, value);\n  }\n\n  public void evict(final Object key) {\n    if (TransactionSynchronizationManager.isSynchronizationActive()) {\n      TransactionSynchronizationManager.registerSynchronization(new TransactionSynchronizationAdapter() {\n        public void afterCommit() {\n          TransactionAwareCacheDecorator.this.targetCache.evict(key);\n        }\n      });\n    } else {\n      this.targetCache.evict(key);\n    }\n\n  }\n\n  public void clear() {\n    if (TransactionSynchronizationManager.isSynchronizationActive()) {\n      TransactionSynchronizationManager.registerSynchronization(new TransactionSynchronizationAdapter() {\n        public void afterCommit() {\n          TransactionAwareCacheDecorator.this.targetCache.clear();\n        }\n      });\n    } else {\n      this.targetCache.clear();\n    }\n  }\n}\n</code></pre><h2>工厂模式在Spring中的应用</h2><p>在Spring中，工厂模式最经典的应用莫过于实现IOC容器，对应的Spring源码主要是BeanFactory类和ApplicationContext相关类（AbstractApplicationContext、ClassPathXmlApplicationContext、FileSystemXmlApplicationContext…）。除此之外，在理论部分，我还带你手把手实现了一个简单的IOC容器。你可以回过头去再看下。</p><p>在Spring中，创建Bean的方式有很多种，比如前面提到的纯构造函数、无参构造函数加setter方法。我写了一个例子来说明这两种创建方式，代码如下所示：</p><pre><code>public class Student {\n  private long id;\n  private String name;\n  \n  public Student(long id, String name) {\n    this.id = id;\n    this.name = name;\n  }\n  \n  public void setId(long id) {\n    this.id = id;\n  }\n  \n  public void setName(String name) {\n    this.name = name;\n  }\n}\n\n// 使用构造函数来创建Bean\n&lt;bean id=&quot;student&quot; class=&quot;com.xzg.cd.Student&quot;&gt;\n    &lt;constructor-arg name=&quot;id&quot; value=&quot;1&quot;/&gt;\n    &lt;constructor-arg name=&quot;name&quot; value=&quot;wangzheng&quot;/&gt;\n&lt;/bean&gt;\n\n// 使用无参构造函数+setter方法来创建Bean\n&lt;bean id=&quot;student&quot; class=&quot;com.xzg.cd.Student&quot;&gt;\n    &lt;property name=&quot;id&quot; value=&quot;1&quot;&gt;&lt;/property&gt;\n    &lt;property name=&quot;name&quot; value=&quot;wangzheng&quot;&gt;&lt;/property&gt;\n&lt;/bean&gt;\n</code></pre><p>实际上，除了这两种创建Bean的方式之外，我们还可以通过工厂方法来创建Bean。还是刚刚这个例子，用这种方式来创建Bean的话就是下面这个样子：</p><pre><code>public class StudentFactory {\n  private static Map&lt;Long, Student&gt; students = new HashMap&lt;&gt;();\n  \n  static{\n    map.put(1, new Student(1,&quot;wang&quot;));\n    map.put(2, new Student(2,&quot;zheng&quot;));\n    map.put(3, new Student(3,&quot;xzg&quot;));\n  }\n \n  public static Student getStudent(long id){\n    return students.get(id);\n  }\n}\n\n// 通过工厂方法getStudent(2)来创建BeanId=&quot;zheng&quot;&quot;的Bean\n&lt;bean id=&quot;zheng&quot; class=&quot;com.xzg.cd.StudentFactory&quot; factory-method=&quot;getStudent&quot;&gt;\n    &lt;constructor-arg value=&quot;2&quot;&gt;&lt;/constructor-arg&gt;           \n&lt;/bean&gt;\n</code></pre><h2>其他模式在Spring中的应用</h2><p>前面的几个模式在Spring中的应用讲解的都比较详细，接下来的几个模式，大部分都是我们之前讲过的，这里只是简单总结一下，点到为止，如果你对哪块有遗忘，可以回过头去看下理论部分的讲解。</p><p>SpEL，全称叫Spring Expression Language，是Spring中常用来编写配置的表达式语言。它定义了一系列的语法规则。我们只要按照这些语法规则来编写表达式，Spring就能解析出表达式的含义。实际上，这就是我们前面讲到的解释器模式的典型应用场景。</p><p>因为解释器模式没有一个非常固定的代码实现结构，而且Spring中SpEL相关的代码也比较多，所以这里就不带你一块阅读源码了。如果感兴趣或者项目中正好要实现类似的功能的时候，你可以再去阅读、借鉴它的代码实现。代码主要集中在spring-expresssion这个模块下面。</p><p>前面讲到单例模式的时候，我提到过，单例模式有很多弊端，比如单元测试不友好等。应对策略就是通过IOC容器来管理对象，通过IOC容器来实现对象的唯一性的控制。实际上，这样实现的单例并非真正的单例，它的唯一性的作用范围仅仅在同一个IOC容器内。</p><p>除此之外，Spring还用到了观察者模式、模板模式、职责链模式、代理模式。其中，观察者模式、模板模式在上一节课已经详细讲过了。</p><p>实际上，在Spring中，只要后缀带有Template的类，基本上都是模板类，而且大部分都是用Callback回调来实现的，比如JdbcTemplate、RedisTemplate等。剩下的两个模式在Spring中的应用应该人尽皆知了。职责链模式在Spring中的应用是拦截器（Interceptor），代理模式经典应用是AOP。</p><h2>重点回顾</h2><p>好了，今天的内容到此就讲完了。我们一块来总结回顾一下，你需要重点掌握的内容。</p><p>我们今天提到的设计模式有11种，它们分别是适配器模式、策略模式、组合模式、装饰器模式、工厂模式、单例模式、解释器模式、观察者模式、模板模式、职责链模式、代理模式，基本上占了23种设计模式的一半。这还只是我所知道的，实际上，Spring用到的设计模式可能还要更多。你看，设计模式并非“花拳绣腿”吧，它在实际的项目开发中，确实有很多应用，确实可以发挥很大的作用。</p><p>还是那句话，对于今天的内容，你不需要去记忆哪个类用到了哪个设计模式。你只需要跟着我的讲解，把每个设计模式在Spring中的应用场景，搞懂就可以了。看到类似的代码，能够立马识别出它用到了哪种设计模式；看到类似的应用场景，能够立马反映出要用哪种模式去解决，这样就说明你已经掌握得足够好了。</p><h2>课堂讨论</h2><p>我们前面讲到，除了纯构造函数、构造函数加setter方法和工厂方法之外，还有另外一个经常用来创建对象的模式，Builder模式。如果我们让Spring支持通过Builder模式来创建Bean，应该如何来编写代码和配置呢？你可以设计一下吗？</p><p>欢迎留言和我分享你的想法。如果有收获，也欢迎你把这篇文章分享给你的朋友。</p>",
                "article_title": "86 | 开源实战四（下）：总结Spring框架用到的11种设计模式"
            },
            {
                "title": "87 | 开源实战五（上）：MyBatis如何权衡易用性、性能和灵活性？",
                "herf": "https://time.geekbang.org/column/article/239239",
                "id": "239239",
                "content": "<p>上几节课我们讲到了Spring框架，剖析了背后蕴含的一些通用设计思想，以及用到的十几种设计模式。从今天开始，我们再剖析另外一个Java项目开发中经常用到的框架：MyBatis。因为内容比较多，同样，我们也分三节课来讲解。</p><ul>\n<li>第一节课，我们分析MyBatis如何权衡代码的易用性、性能和灵活性。</li>\n<li>第二节课，我们学习如何利用职责链与代理模式实现MyBatis Plugin。</li>\n<li>第三节课，我们总结罗列一下MyBatis框架中用到的十几种设计模式。</li>\n</ul><p>话不多说，让我们正式开始今天的学习吧！</p><h2>Mybatis和ORM框架介绍</h2><p>熟悉Java的同学应该知道，MyBatis是一个ORM（Object Relational Mapping，对象-关系映射）框架。ORM框架主要是根据类和数据库表之间的映射关系，帮助程序员自动实现对象与数据库中数据之间的互相转化。说得更具体点就是，ORM负责将程序中的对象存储到数据库中、将数据库中的数据转化为程序中的对象。实际上，Java中的ORM框架有很多，除了刚刚提到的MyBatis之外，还有Hibernate、TopLink等。</p><p>在剖析Spring框架的时候，我们讲到，如果用一句话来总结框架作用的话，那就是简化开发。MyBatis框架也不例外。它简化的是数据库方面的开发。那MyBatis是如何简化数据库开发的呢？我们结合<a href=\"https://time.geekbang.org/column/article/212802\">第59讲</a>中的JdbcTemplate的例子来说明一下。</p><!-- [[[read_end]]] --><p>在第59讲中，我们讲到，Java提供了JDBC类库来封装不同类型的数据库操作。不过，直接使用JDBC来进行数据库编程，还是有点麻烦的。于是，Spring提供了JdbcTemplate，对JDBC进一步封装，来进一步简化数据库编程。</p><p>使用JdbcTemplate进行数据库编程，我们只需要编写跟业务相关的代码（比如，SQL语句、数据库中数据与对象之间的互相转化的代码），其他流程性质的代码（比如，加载驱动、创建数据库连接、创建statement、关闭连接、关闭statement等）都封装在了JdbcTemplate类中，不需要我们重复编写。</p><p>当时，为了展示使用JdbcTemplate是如何简化数据库编程的，我们还举了一个查询数据库中用户信息的例子。还是同样这个例子，我再来看下，使用MyBatis该如何实现，是不是比使用JdbcTemplate更加简单。</p><p>因为MyBatis依赖JDBC驱动，所以，在项目中使用MyBatis，除了需要引入MyBatis框架本身（mybatis.jar）之外，还需要引入JDBC驱动（比如，访问MySQL的JDBC驱动实现类库mysql-connector-java.jar）。将两个jar包引入项目之后，我们就可以开始编程了。使用MyBatis来访问数据库中用户信息的代码如下所示：</p><pre><code>// 1. 定义UserDO\npublic class UserDo {\n  private long id;\n  private String name;\n  private String telephone;\n  // 省略setter/getter方法\n}\n\n// 2. 定义访问接口\npublic interface UserMapper {\n  public UserDo selectById(long id);\n}\n\n// 3. 定义映射关系：UserMapper.xml\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;\n&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org/DTD Mapper 3.0//EN&quot;\n        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot; &gt;\n&lt;mapper namespace=&quot;cn.xzg.cd.a87.repo.mapper.UserMapper&quot;&gt;\n    &lt;select id=&quot;selectById&quot; resultType=&quot;cn.xzg.cd.a87.repo.UserDo&quot;&gt;\n        select * from user where id=#{id}\n    &lt;/select&gt;\n&lt;/mapper&gt;\n\n// 4. 全局配置文件: mybatis.xml\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;\n&lt;!DOCTYPE configuration\n        PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;\n        &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;\n&lt;configuration&gt;\n    &lt;environments default=&quot;dev&quot;&gt;\n        &lt;environment id=&quot;dev&quot;&gt;\n            &lt;transactionManager type=&quot;JDBC&quot;&gt;&lt;/transactionManager&gt;\n            &lt;dataSource type=&quot;POOLED&quot;&gt;\n                &lt;property name=&quot;driver&quot; value=&quot;com.mysql.jdbc.Driver&quot; /&gt;\n                &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/test?useUnicode=true&amp;characterEncoding=UTF-8&quot; /&gt;\n                &lt;property name=&quot;username&quot; value=&quot;root&quot; /&gt;\n                &lt;property name=&quot;password&quot; value=&quot;...&quot; /&gt;\n            &lt;/dataSource&gt;\n        &lt;/environment&gt;\n    &lt;/environments&gt;\n    &lt;mappers&gt;\n        &lt;mapper resource=&quot;mapper/UserMapper.xml&quot;/&gt;\n    &lt;/mappers&gt;\n&lt;/configuration&gt;\n</code></pre><p>需要注意的是，在UserMapper.xml配置文件中，我们只定义了接口和SQL语句之间的映射关系，并没有显式地定义类（UserDo）字段与数据库表（user）字段之间的映射关系。实际上，这就体现了“约定优于配置”的设计原则。类字段与数据库表字段之间使用了默认映射关系：类字段跟数据库表中拼写相同的字段一一映射。当然，如果没办法做到一一映射，我们也可以自定义它们之间的映射关系。</p><p>有了上面的代码和配置，我们就可以像下面这样来访问数据库中的用户信息了。</p><pre><code>public class MyBatisDemo {\n  public static void main(String[] args) throws IOException {\n    Reader reader = Resources.getResourceAsReader(&quot;mybatis.xml&quot;);\n    SqlSessionFactory sessionFactory = new SqlSessionFactoryBuilder().build(reader);\n    SqlSession session = sessionFactory.openSession();\n    UserMapper userMapper = session.getMapper(UserMapper.class);\n    UserDo userDo = userMapper.selectById(8);\n    //...\n  }\n}\n</code></pre><p>从代码中，我们可以看出，相对于使用JdbcTemplate的实现方式，使用MyBatis的实现方式更加灵活。在使用JdbcTemplate的实现方式中，对象与数据库中数据之间的转化代码、SQL语句，是硬编码在业务代码中的。而在使用MyBatis的实现方式中，类字段与数据库字段之间的映射关系、接口与SQL之间的映射关系，是写在XML配置文件中的，是跟代码相分离的，这样会更加灵活、清晰，维护起来更加方便。</p><h2>如何平衡易用性、性能和灵活性？</h2><p>刚刚我们对MyBatis框架做了简单介绍，接下来，我们再对比一下另外两个框架：JdbcTemplate和Hibernate。通过对比我们来看，MyBatis是如何权衡代码的易用性、性能和灵活性的。</p><p>我们先来看JdbcTemplate。相对于MyBatis来说，JdbcTemplate更加轻量级。因为它对JDBC只做了很简单的封装，所以性能损耗比较少。相对于其他两个框架来说，它的性能最好。但是，它的缺点也比较明显，那就是SQL与代码耦合在一起，而且不具备ORM的功能，需要自己编写代码，解析对象跟数据库中的数据之间的映射关系。所以，在易用性上它不及其他两个框架。</p><p>我们再来看Hibernate。相对于MyBatis来说，Hibernate更加重量级。Hibernate提供了更加高级的映射功能，能够根据业务需求自动生成SQL语句。我们不需要像使用MyBatis那样自己编写SQL。因此，有的时候，我们也把MyBatis称作半自动化的ORM框架，把Hibernate称作全自动化的ORM框架。不过，虽然自动生成SQL简化了开发，但是毕竟是自动生成的，没有针对性的优化。在性能方面，这样得到的SQL可能没有程序员编写得好。同时，这样也丧失了程序员自己编写SQL的灵活性。</p><p>实际上，不管用哪种实现方式，从数据库中取出数据并且转化成对象，这个过程涉及的代码逻辑基本是一致的。不同实现方式的区别，只不过是哪部分代码逻辑放到了哪里。有的框架提供的功能比较强大，大部分代码逻辑都由框架来完成，程序员只需要实现很小的一部分代码就可以了。这样框架的易用性就更好些。但是，框架集成的功能越多，为了处理逻辑的通用性，就会引入更多额外的处理代码。比起针对具体问题具体编程，这样性能损耗就相对大一些。</p><p>所以，粗略地讲，有的时候，框架的易用性和性能成对立关系。追求易用性，那性能就差一些。相反，追求性能，易用性就差一些。除此之外，使用起来越简单，那灵活性就越差。这就好比我们用的照相机。傻瓜相机按下快门就能拍照，但没有复杂的单反灵活。</p><p>实际上，JdbcTemplate、MyBatis、Hibernate这几个框架也体现了刚刚说的这个规律。</p><p>JdbcTemplate提供的功能最简单，易用性最差，性能损耗最少，用它编程性能最好。Hibernate提供的功能最完善，易用性最好，但相对来说性能损耗就最高了。MyBatis介于两者中间，在易用性、性能、灵活性三个方面做到了权衡。它支撑程序员自己编写SQL，能够延续程序员对SQL知识的积累。相对于完全黑盒子的Hibernate，很多程序员反倒是更加喜欢MyBatis这种半透明的框架。这也提醒我们，过度封装，提供过于简化的开发方式，也会丧失开发的灵活性。</p><h2>重点回顾</h2><p>好了，今天的内容到此就讲完了。我们一块来总结回顾一下，你需要重点掌握的内容。</p><p>如果你熟悉Java和MyBatis，那你应该掌握今天讲到JDBC、JdbcTemplate、MyBatis、Hibernate之间的区别。JDBC是Java访问数据库的开发规范，提供了一套抽象的统一的开发接口，隐藏不同数据库的访问细节。</p><p>JdbcTemplate、MyBatis、Hibernate都是对JDBC的二次封装，为的是进一步简化数据库开发。其中，JdbcTemplate不能算得上是ORM框架，因为还需要程序员自己编程来实现对象和数据库数据之间的互相转化。相对于Hibernate这种连SQL都不用程序员自己写的全自动ORM框架，MyBatis算是一种半自动化的ORM框架。</p><p>如果你不熟悉Java和MyBatis，作为背景介绍，那你简单了解一下MyBatis和ORM就可以了。不过，在你熟悉的语言中，应该也有相应的ORM框架，你也可以对比着去分析一下。</p><p>今天的内容除了起到对MyBatis做背景介绍之外，我们还学习了代码的易用性、性能、灵活性之间的关系。一般来讲，提供的高级功能越多，那性能损耗就会越大些；用起来越简单，提供越简化的开发方式，那灵活性也就相对越低。</p><h2>课堂讨论</h2><p>在你的项目开发中，有没有用过哪些框架，能够切实地提高开发效率，减少不必要的体力劳动？</p><p>欢迎留言和我分享你的想法。如果有收获，也欢迎你把这篇文章分享给你的朋友。</p>",
                "article_title": "87 | 开源实战五（上）：MyBatis如何权衡易用性、性能和灵活性？"
            },
            {
                "title": "88 | 开源实战五（中）：如何利用职责链与代理模式实现MyBatis Plugin？",
                "herf": "https://time.geekbang.org/column/article/240147",
                "id": "240147",
                "content": "<p>上节课，我们对MyBatis框架做了简单的背景介绍，并且通过对比各种ORM框架，学习了代码的易用性、性能、灵活性之间的关系。一般来讲，框架提供的高级功能越多，那性能损耗就会越大；框架用起来越简单，提供越简化的使用方式，那灵活性也就越低。</p><p>接下来的两节课，我们再学习一下MyBatis用到一些经典设计模式。其中，今天，我们主要讲解MyBatis Plugin。尽管名字叫Plugin（插件），但它实际上跟之前讲到的Servlet Filter（过滤器）、Spring Interceptor（拦截器）类似，设计的初衷都是为了框架的扩展性，用到的主要设计模式都是职责链模式。</p><p>不过，相对于Servlet Filter和Spring Interceptor，MyBatis Plugin中职责链模式的代码实现稍微有点复杂。它是借助动态代理模式来实现的职责链。今天我就带你看下，如何利用这两个模式实现MyBatis Plugin。</p><p>话不多说，让我们正式开始今天的学习吧！</p><h2>MyBatis Plugin功能介绍</h2><p>实际上，MyBatis Plugin跟Servlet Filter、Spring Interceptor的功能是类似的，都是在不需要修改原有流程代码的情况下，拦截某些方法调用，在拦截的方法调用的前后，执行一些额外的代码逻辑。它们的唯一区别在于拦截的位置是不同的。Servlet Filter主要拦截Servlet请求，Spring Interceptor主要拦截Spring管理的Bean方法（比如Controller类的方法等），而MyBatis Plugin主要拦截的是MyBatis在执行SQL的过程中涉及的一些方法。</p><!-- [[[read_end]]] --><p>MyBatis Plugin使用起来比较简单，我们通过一个例子来快速看下。</p><p>假设我们需要统计应用中每个SQL的执行耗时，如果使用MyBatis Plugin来实现的话，我们只需要定义一个SqlCostTimeInterceptor类，让它实现MyBatis的Interceptor接口，并且，在MyBatis的全局配置文件中，简单声明一下这个插件就可以了。具体的代码和配置如下所示：</p><pre><code>@Intercepts({\n        @Signature(type = StatementHandler.class, method = &quot;query&quot;, args = {Statement.class, ResultHandler.class}),\n        @Signature(type = StatementHandler.class, method = &quot;update&quot;, args = {Statement.class}),\n        @Signature(type = StatementHandler.class, method = &quot;batch&quot;, args = {Statement.class})})\npublic class SqlCostTimeInterceptor implements Interceptor {\n  private static Logger logger = LoggerFactory.getLogger(SqlCostTimeInterceptor.class);\n\n  @Override\n  public Object intercept(Invocation invocation) throws Throwable {\n    Object target = invocation.getTarget();\n    long startTime = System.currentTimeMillis();\n    StatementHandler statementHandler = (StatementHandler) target;\n    try {\n      return invocation.proceed();\n    } finally {\n      long costTime = System.currentTimeMillis() - startTime;\n      BoundSql boundSql = statementHandler.getBoundSql();\n      String sql = boundSql.getSql();\n      logger.info(&quot;执行 SQL：[ {} ]执行耗时[ {} ms]&quot;, sql, costTime);\n    }\n  }\n\n  @Override\n  public Object plugin(Object target) {\n    return Plugin.wrap(target, this);\n  }\n\n  @Override\n  public void setProperties(Properties properties) {\n    System.out.println(&quot;插件配置的信息：&quot;+properties);\n  }\n}\n\n&lt;!-- MyBatis全局配置文件：mybatis-config.xml --&gt;\n&lt;plugins&gt;\n  &lt;plugin interceptor=&quot;com.xzg.cd.a88.SqlCostTimeInterceptor&quot;&gt;\n    &lt;property name=&quot;someProperty&quot; value=&quot;100&quot;/&gt;\n  &lt;/plugin&gt;\n&lt;/plugins&gt;\n</code></pre><p>因为待会我会详细地介绍MyBatis Plugin的底层实现原理，所以，这里暂时不对上面的代码做详细地解释。现在，我们只重点看下@Intercepts注解这一部分。</p><p>我们知道，不管是拦截器、过滤器还是插件，都需要明确地标明拦截的目标方法。@Intercepts注解实际上就是起了这个作用。其中，@Intercepts注解又可以嵌套@Signature注解。一个@Signature注解标明一个要拦截的目标方法。如果要拦截多个方法，我们可以像例子中那样，编写多条@Signature注解。</p><p>@Signature注解包含三个元素：type、method、args。其中，type指明要拦截的类、method指明方法名、args指明方法的参数列表。通过指定这三个元素，我们就能完全确定一个要拦截的方法。</p><p>默认情况下，MyBatis Plugin允许拦截的方法有下面这样几个：</p><p><img src=\"https://static001.geekbang.org/resource/image/cd/d1/cd0aae4a0758ac0913ad28988a6718d1.jpg\" alt=\"\"></p><p>为什么默认允许拦截的是这样几个类的方法呢？</p><p>MyBatis底层是通过Executor类来执行SQL的。Executor类会创建StatementHandler、ParameterHandler、ResultSetHandler三个对象，并且，首先使用ParameterHandler设置SQL中的占位符参数，然后使用StatementHandler执行SQL语句，最后使用ResultSetHandler封装执行结果。所以，我们只需要拦截Executor、ParameterHandler、ResultSetHandler、StatementHandler这几个类的方法，基本上就能满足我们对整个SQL执行流程的拦截了。</p><p>实际上，除了统计SQL的执行耗时，利用MyBatis Plugin，我们还可以做很多事情，比如分库分表、自动分页、数据脱敏、加密解密等等。如果感兴趣的话，你可以自己实现一下。</p><h2>MyBatis Plugin的设计与实现</h2><p>刚刚我们简单介绍了MyBatis Plugin是如何使用的。现在，我们再剖析一下源码，看看如此简洁的使用方式，底层是如何实现的，隐藏了哪些复杂的设计。</p><p>相对于Servlet Filter、Spring Interceptor中职责链模式的代码实现，MyBatis Plugin的代码实现还是蛮有技巧的，因为它是借助动态代理来实现职责链的。</p><p>在<a href=\"https://time.geekbang.org/column/article/216278\">第62节</a>和<a href=\"https://time.geekbang.org/column/article/217395\">第63节</a>中，我们讲到，职责链模式的实现一般包含处理器（Handler）和处理器链（HandlerChain）两部分。这两个部分对应到Servlet Filter的源码就是Filter和FilterChain，对应到Spring Interceptor的源码就是HandlerInterceptor和HandlerExecutionChain，对应到MyBatis Plugin的源码就是Interceptor和InterceptorChain。除此之外，MyBatis Plugin还包含另外一个非常重要的类：Plugin。它用来生成被拦截对象的动态代理。</p><p>集成了MyBatis的应用在启动的时候，MyBatis框架会读取全局配置文件（前面例子中的mybatis-config.xml文件），解析出Interceptor（也就是例子中的SqlCostTimeInterceptor），并且将它注入到Configuration类的InterceptorChain对象中。这部分逻辑对应到源码如下所示：</p><pre><code>public class XMLConfigBuilder extends BaseBuilder {\n  //解析配置\n  private void parseConfiguration(XNode root) {\n    try {\n     //省略部分代码...\n      pluginElement(root.evalNode(&quot;plugins&quot;)); //解析插件\n    } catch (Exception e) {\n      throw new BuilderException(&quot;Error parsing SQL Mapper Configuration. Cause: &quot; + e, e);\n    }\n  }\n\n  //解析插件\n   private void pluginElement(XNode parent) throws Exception {\n    if (parent != null) {\n      for (XNode child : parent.getChildren()) {\n        String interceptor = child.getStringAttribute(&quot;interceptor&quot;);\n        Properties properties = child.getChildrenAsProperties();\n        //创建Interceptor类对象\n        Interceptor interceptorInstance = (Interceptor) resolveClass(interceptor).newInstance();\n        //调用Interceptor上的setProperties()方法设置properties\n        interceptorInstance.setProperties(properties);\n        //下面这行代码会调用InterceptorChain.addInterceptor()方法\n        configuration.addInterceptor(interceptorInstance);\n      }\n    }\n  }\n}\n\n// Configuration类的addInterceptor()方法的代码如下所示\npublic void addInterceptor(Interceptor interceptor) {\n  interceptorChain.addInterceptor(interceptor);\n}\n</code></pre><p>我们再来看Interceptor和InterceptorChain这两个类的代码，如下所示。Interceptor的setProperties()方法就是一个单纯的setter方法，主要是为了方便通过配置文件配置Interceptor的一些属性值，没有其他作用。Interceptor类中intecept()和plugin()函数，以及InterceptorChain类中的pluginAll()函数，是最核心的三个函数，我们待会再详细解释。</p><pre><code>public class Invocation {\n  private final Object target;\n  private final Method method;\n  private final Object[] args;\n  // 省略构造函数和getter方法...\n  public Object proceed() throws InvocationTargetException, IllegalAccessException {\n    return method.invoke(target, args);\n  }\n}\npublic interface Interceptor {\n  Object intercept(Invocation invocation) throws Throwable;\n  Object plugin(Object target);\n  void setProperties(Properties properties);\n}\n\npublic class InterceptorChain {\n  private final List&lt;Interceptor&gt; interceptors = new ArrayList&lt;Interceptor&gt;();\n\n  public Object pluginAll(Object target) {\n    for (Interceptor interceptor : interceptors) {\n      target = interceptor.plugin(target);\n    }\n    return target;\n  }\n\n  public void addInterceptor(Interceptor interceptor) {\n    interceptors.add(interceptor);\n  }\n  \n  public List&lt;Interceptor&gt; getInterceptors() {\n    return Collections.unmodifiableList(interceptors);\n  }\n}\n</code></pre><p>解析完配置文件之后，所有的Interceptor都加载到了InterceptorChain中。接下来，我们再来看下，这些拦截器是在什么时候被触发执行的？又是如何被触发执行的呢？</p><p>前面我们提到，在执行SQL的过程中，MyBatis会创建Executor、StatementHandler、ParameterHandler、ResultSetHandler这几个类的对象，对应的创建代码在Configuration类中，如下所示：</p><pre><code>public Executor newExecutor(Transaction transaction, ExecutorType executorType) {\n  executorType = executorType == null ? defaultExecutorType : executorType;\n  executorType = executorType == null ? ExecutorType.SIMPLE : executorType;\n  Executor executor;\n  if (ExecutorType.BATCH == executorType) {\n    executor = new BatchExecutor(this, transaction);\n  } else if (ExecutorType.REUSE == executorType) {\n    executor = new ReuseExecutor(this, transaction);\n  } else {\n    executor = new SimpleExecutor(this, transaction);\n  }\n  if (cacheEnabled) {\n    executor = new CachingExecutor(executor);\n  }\n  executor = (Executor) interceptorChain.pluginAll(executor);\n  return executor;\n}\n\npublic ParameterHandler newParameterHandler(MappedStatement mappedStatement, Object parameterObject, BoundSql boundSql) {\n  ParameterHandler parameterHandler = mappedStatement.getLang().createParameterHandler(mappedStatement, parameterObject, boundSql);\n  parameterHandler = (ParameterHandler) interceptorChain.pluginAll(parameterHandler);\n  return parameterHandler;\n}\n\npublic ResultSetHandler newResultSetHandler(Executor executor, MappedStatement mappedStatement, RowBounds rowBounds, ParameterHandler parameterHandler,\n    ResultHandler resultHandler, BoundSql boundSql) {\n  ResultSetHandler resultSetHandler = new DefaultResultSetHandler(executor, mappedStatement, parameterHandler, resultHandler, boundSql, rowBounds);\n  resultSetHandler = (ResultSetHandler) interceptorChain.pluginAll(resultSetHandler);\n  return resultSetHandler;\n}\n\npublic StatementHandler newStatementHandler(Executor executor, MappedStatement mappedStatement, Object parameterObject, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql) {\n  StatementHandler statementHandler = new RoutingStatementHandler(executor, mappedStatement, parameterObject, rowBounds, resultHandler, boundSql);\n  statementHandler = (StatementHandler) interceptorChain.pluginAll(statementHandler);\n  return statementHandler;\n}\n</code></pre><p>从上面的代码中，我们可以发现，这几个类对象的创建过程都调用了InteceptorChain的pluginAll()方法。这个方法的代码前面已经给出了。你可以回过头去再看一眼。它的代码实现很简单，嵌套调用InterceptorChain上每个Interceptor的plugin()方法。plugin()是一个接口方法（不包含实现代码），需要由用户给出具体的实现代码。在之前的例子中，SQLTimeCostInterceptor的plugin()方法通过直接调用Plugin的wrap()方法来实现。wrap()方法的代码实现如下所示：</p><pre><code>// 借助Java InvocationHandler实现的动态代理模式\npublic class Plugin implements InvocationHandler {\n  private final Object target;\n  private final Interceptor interceptor;\n  private final Map&lt;Class&lt;?&gt;, Set&lt;Method&gt;&gt; signatureMap;\n\n  private Plugin(Object target, Interceptor interceptor, Map&lt;Class&lt;?&gt;, Set&lt;Method&gt;&gt; signatureMap) {\n    this.target = target;\n    this.interceptor = interceptor;\n    this.signatureMap = signatureMap;\n  }\n\n  // wrap()静态方法，用来生成target的动态代理，\n  // 动态代理对象=target对象+interceptor对象。\n  public static Object wrap(Object target, Interceptor interceptor) {\n    Map&lt;Class&lt;?&gt;, Set&lt;Method&gt;&gt; signatureMap = getSignatureMap(interceptor);\n    Class&lt;?&gt; type = target.getClass();\n    Class&lt;?&gt;[] interfaces = getAllInterfaces(type, signatureMap);\n    if (interfaces.length &gt; 0) {\n      return Proxy.newProxyInstance(\n          type.getClassLoader(),\n          interfaces,\n          new Plugin(target, interceptor, signatureMap));\n    }\n    return target;\n  }\n\n  // 调用target上的f()方法，会触发执行下面这个方法。\n  // 这个方法包含：执行interceptor的intecept()方法 + 执行target上f()方法。\n  @Override\n  public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n    try {\n      Set&lt;Method&gt; methods = signatureMap.get(method.getDeclaringClass());\n      if (methods != null &amp;&amp; methods.contains(method)) {\n        return interceptor.intercept(new Invocation(target, method, args));\n      }\n      return method.invoke(target, args);\n    } catch (Exception e) {\n      throw ExceptionUtil.unwrapThrowable(e);\n    }\n  }\n\n  private static Map&lt;Class&lt;?&gt;, Set&lt;Method&gt;&gt; getSignatureMap(Interceptor interceptor) {\n    Intercepts interceptsAnnotation = interceptor.getClass().getAnnotation(Intercepts.class);\n    // issue #251\n    if (interceptsAnnotation == null) {\n      throw new PluginException(&quot;No @Intercepts annotation was found in interceptor &quot; + interceptor.getClass().getName());      \n    }\n    Signature[] sigs = interceptsAnnotation.value();\n    Map&lt;Class&lt;?&gt;, Set&lt;Method&gt;&gt; signatureMap = new HashMap&lt;Class&lt;?&gt;, Set&lt;Method&gt;&gt;();\n    for (Signature sig : sigs) {\n      Set&lt;Method&gt; methods = signatureMap.get(sig.type());\n      if (methods == null) {\n        methods = new HashSet&lt;Method&gt;();\n        signatureMap.put(sig.type(), methods);\n      }\n      try {\n        Method method = sig.type().getMethod(sig.method(), sig.args());\n        methods.add(method);\n      } catch (NoSuchMethodException e) {\n        throw new PluginException(&quot;Could not find method on &quot; + sig.type() + &quot; named &quot; + sig.method() + &quot;. Cause: &quot; + e, e);\n      }\n    }\n    return signatureMap;\n  }\n\n  private static Class&lt;?&gt;[] getAllInterfaces(Class&lt;?&gt; type, Map&lt;Class&lt;?&gt;, Set&lt;Method&gt;&gt; signatureMap) {\n    Set&lt;Class&lt;?&gt;&gt; interfaces = new HashSet&lt;Class&lt;?&gt;&gt;();\n    while (type != null) {\n      for (Class&lt;?&gt; c : type.getInterfaces()) {\n        if (signatureMap.containsKey(c)) {\n          interfaces.add(c);\n        }\n      }\n      type = type.getSuperclass();\n    }\n    return interfaces.toArray(new Class&lt;?&gt;[interfaces.size()]);\n  }\n}\n</code></pre><p>实际上，Plugin是借助Java InvocationHandler实现的动态代理类。用来代理给target对象添加Interceptor功能。其中，要代理的target对象就是Executor、StatementHandler、ParameterHandler、ResultSetHandler这四个类的对象。wrap()静态方法是一个工具函数，用来生成target对象的动态代理对象。</p><p>当然，只有interceptor与target互相匹配的时候，wrap()方法才会返回代理对象，否则就返回target对象本身。怎么才算是匹配呢？那就是interceptor通过@Signature注解要拦截的类包含target对象，具体可以参看wrap()函数的代码实现（上面一段代码中的第16~19行）。</p><p>MyBatis中的职责链模式的实现方式比较特殊。它对同一个目标对象嵌套多次代理（也就是InteceptorChain中的pluginAll()函数要执行的任务）。每个代理对象（Plugin对象）代理一个拦截器（Interceptor对象）功能。为了方便你查看，我将pluginAll()函数的代码又拷贝到了下面。</p><pre><code>public Object pluginAll(Object target) {\n  // 嵌套代理\n  for (Interceptor interceptor : interceptors) {\n    target = interceptor.plugin(target);\n    // 上面这行代码等于下面这行代码，target(代理对象)=target(目标对象)+interceptor(拦截器功能)\n    // target = Plugin.wrap(target, interceptor);\n  }\n  return target;\n}\n\n// MyBatis像下面这样创建target(Executor、StatementHandler、ParameterHandler、ResultSetHandler），相当于多次嵌套代理\nObject target = interceptorChain.pluginAll(target);\n</code></pre><p>当执行Executor、StatementHandler、ParameterHandler、ResultSetHandler这四个类上的某个方法的时候，MyBatis会嵌套执行每层代理对象（Plugin对象）上的invoke()方法。而invoke()方法会先执行代理对象中的interceptor的intecept()函数，然后再执行被代理对象上的方法。就这样，一层一层地把代理对象上的intercept()函数执行完之后，MyBatis才最终执行那4个原始类对象上的方法。</p><h2>重点回顾</h2><p>好了，今天内容到此就讲完了。我们来一块总结回顾一下，你需要重点掌握的内容。</p><p>今天，我们带你剖析了如何利用职责链模式和动态代理模式来实现MyBatis Plugin。至此，我们就已经学习了三种职责链常用的应用场景：过滤器（Servlet Filter）、拦截器（Spring Interceptor）、插件（MyBatis Plugin）。</p><p>职责链模式的实现一般包含处理器和处理器链两部分。这两个部分对应到Servlet Filter的源码就是Filter和FilterChain，对应到Spring Interceptor的源码就是HandlerInterceptor和HandlerExecutionChain，对应到MyBatis Plugin的源码就是Interceptor和InterceptorChain。除此之外，MyBatis Plugin还包含另外一个非常重要的类：Plugin类。它用来生成被拦截对象的动态代理。</p><p>在这三种应用场景中，职责链模式的实现思路都不大一样。其中，Servlet Filter采用递归来实现拦截方法前后添加逻辑。Spring Interceptor的实现比较简单，把拦截方法前后要添加的逻辑放到两个方法中实现。MyBatis Plugin采用嵌套动态代理的方法来实现，实现思路很有技巧。</p><h2>课堂讨论</h2><p>Servlet Filter、Spring Interceptor可以用来拦截用户自己定义的类的方法，而MyBatis Plugin默认可以拦截的只有Executor、StatementHandler、ParameterHandler、ResultSetHandler这四个类的方法，而且这四个类是MyBatis实现的类，并非用户自己定义的类。那MyBatis Plugin为什么不像Servlet Filter、Spring Interceptor那样，提供拦截用户自定义类的方法的功能呢？</p><p>欢迎留言和我分享你的想法。如果有收获，也欢迎你把这篇文章分享给你的朋友。</p>",
                "article_title": "88 | 开源实战五（中）：如何利用职责链与代理模式实现MyBatis Plugin？"
            },
            {
                "title": "89 | 开源实战五（下）：总结MyBatis框架中用到的10种设计模式",
                "herf": "https://time.geekbang.org/column/article/240971",
                "id": "240971",
                "content": "<p>上节课，我带你剖析了利用职责链模式和动态代理模式实现MyBatis Plugin。至此，我们已经学习了三种职责链常用的应用场景：过滤器（Servlet Filter）、拦截器（Spring Interceptor）、插件（MyBatis Plugin）。</p><p>今天，我们再对MyBatis用到的设计模式做一个总结。它用到的设计模式也不少，就我所知的不下十几种。有些我们前面已经讲到，有些比较简单。有了前面这么多讲的学习和训练，我想你现在应该已经具备了一定的研究和分析能力，能够自己做查缺补漏，把提到的所有源码都搞清楚。所以，在今天的课程中，如果有哪里有疑问，你尽可以去查阅源码，自己先去学习一下，有不懂的地方，再到评论区和大家一起交流。</p><p>话不多说，让我们正式开始今天的学习吧！</p><h2>SqlSessionFactoryBuilder：为什么要用建造者模式来创建SqlSessionFactory？</h2><p>在<a href=\"https://time.geekbang.org/column/article/239239\">第87讲</a>中，我们通过一个查询用户的例子展示了用MyBatis进行数据库编程。为了方便你查看，我把相关的代码重新摘抄到这里。</p><pre><code>public class MyBatisDemo {\n  public static void main(String[] args) throws IOException {\n    Reader reader = Resources.getResourceAsReader(&quot;mybatis.xml&quot;);\n    SqlSessionFactory sessionFactory = new SqlSessionFactoryBuilder().build(reader);\n    SqlSession session = sessionFactory.openSession();\n    UserMapper userMapper = session.getMapper(UserMapper.class);\n    UserDo userDo = userMapper.selectById(8);\n    //...\n  }\n}\n</code></pre><p>针对这段代码，请你思考一下下面这个问题。</p><p>之前讲到建造者模式的时候，我们使用Builder类来创建对象，一般都是先级联一组setXXX()方法来设置属性，然后再调用build()方法最终创建对象。但是，在上面这段代码中，通过SqlSessionFactoryBuilder来创建SqlSessionFactory并不符合这个套路。它既没有setter方法，而且build()方法也并非无参，需要传递参数。除此之外，从上面的代码来看，SqlSessionFactory对象的创建过程也并不复杂。那直接通过构造函数来创建SqlSessionFactory不就行了吗？为什么还要借助建造者模式创建SqlSessionFactory呢？</p><!-- [[[read_end]]] --><p>要回答这个问题，我们就要先看下SqlSessionFactoryBuilder类的源码。我把源码摘抄到了这里，如下所示：</p><pre><code>public class SqlSessionFactoryBuilder {\n  public SqlSessionFactory build(Reader reader) {\n    return build(reader, null, null);\n  }\n\n  public SqlSessionFactory build(Reader reader, String environment) {\n    return build(reader, environment, null);\n  }\n\n  public SqlSessionFactory build(Reader reader, Properties properties) {\n    return build(reader, null, properties);\n  }\n\n  public SqlSessionFactory build(Reader reader, String environment, Properties properties) {\n    try {\n      XMLConfigBuilder parser = new XMLConfigBuilder(reader, environment, properties);\n      return build(parser.parse());\n    } catch (Exception e) {\n      throw ExceptionFactory.wrapException(&quot;Error building SqlSession.&quot;, e);\n    } finally {\n      ErrorContext.instance().reset();\n      try {\n        reader.close();\n      } catch (IOException e) {\n        // Intentionally ignore. Prefer previous error.\n      }\n    }\n  }\n\n  public SqlSessionFactory build(InputStream inputStream) {\n    return build(inputStream, null, null);\n  }\n\n  public SqlSessionFactory build(InputStream inputStream, String environment) {\n    return build(inputStream, environment, null);\n  }\n\n  public SqlSessionFactory build(InputStream inputStream, Properties properties) {\n    return build(inputStream, null, properties);\n  }\n\n  public SqlSessionFactory build(InputStream inputStream, String environment, Properties properties) {\n    try {\n      XMLConfigBuilder parser = new XMLConfigBuilder(inputStream, environment, properties);\n      return build(parser.parse());\n    } catch (Exception e) {\n      throw ExceptionFactory.wrapException(&quot;Error building SqlSession.&quot;, e);\n    } finally {\n      ErrorContext.instance().reset();\n      try {\n        inputStream.close();\n      } catch (IOException e) {\n        // Intentionally ignore. Prefer previous error.\n      }\n    }\n  }\n    \n  public SqlSessionFactory build(Configuration config) {\n    return new DefaultSqlSessionFactory(config);\n  }\n}\n</code></pre><p>SqlSessionFactoryBuilder类中有大量的build()重载函数。为了方便你查看，以及待会儿跟SqlSessionFactory类的代码作对比，我把重载函数定义抽象出来，贴到这里。</p><pre><code>public class SqlSessionFactoryBuilder {\n  public SqlSessionFactory build(Reader reader);\n  public SqlSessionFactory build(Reader reader, String environment);\n  public SqlSessionFactory build(Reader reader, Properties properties);\n  public SqlSessionFactory build(Reader reader, String environment, Properties properties);\n  \n  public SqlSessionFactory build(InputStream inputStream);\n  public SqlSessionFactory build(InputStream inputStream, String environment);\n  public SqlSessionFactory build(InputStream inputStream, Properties properties);\n  public SqlSessionFactory build(InputStream inputStream, String environment, Properties properties);\n\n  // 上面所有的方法最终都调用这个方法    \n  public SqlSessionFactory build(Configuration config);\n}\n</code></pre><p>我们知道，如果一个类包含很多成员变量，而构建对象并不需要设置所有的成员变量，只需要选择性地设置其中几个就可以。为了满足这样的构建需求，我们就要定义多个包含不同参数列表的构造函数。为了避免构造函数过多、参数列表过长，我们一般通过无参构造函数加setter方法或者通过建造者模式来解决。</p><p>从建造者模式的设计初衷上来看，SqlSessionFactoryBuilder虽然带有Builder后缀，但不要被它的名字所迷惑，它并不是标准的建造者模式。一方面，原始类SqlSessionFactory的构建只需要一个参数，并不复杂。另一方面，Builder类SqlSessionFactoryBuilder仍然定义了n多包含不同参数列表的构造函数。</p><p>实际上，SqlSessionFactoryBuilder设计的初衷只不过是为了简化开发。因为构建SqlSessionFactory需要先构建Configuration，而构建Configuration是非常复杂的，需要做很多工作，比如配置的读取、解析、创建n多对象等。为了将构建SqlSessionFactory的过程隐藏起来，对程序员透明，MyBatis就设计了SqlSessionFactoryBuilder类封装这些构建细节。</p><h2>SqlSessionFactory：到底属于工厂模式还是建造器模式？</h2><p>在刚刚那段MyBatis示例代码中，我们通过SqlSessionFactoryBuilder创建了SqlSessionFactory，然后再通过SqlSessionFactory创建了SqlSession。刚刚我们讲了SqlSessionFactoryBuilder，现在我们再来看下SqlSessionFactory。</p><p>从名字上，你可能已经猜到，SqlSessionFactory是一个工厂类，用到的设计模式是工厂模式。不过，它跟SqlSessionFactoryBuilder类似，名字有很大的迷惑性。实际上，它也并不是标准的工厂模式。为什么这么说呢？我们先来看下SqlSessionFactory类的源码。</p><pre><code>public interface SqlSessionFactory {\n  SqlSession openSession();\n  SqlSession openSession(boolean autoCommit);\n  SqlSession openSession(Connection connection);\n  SqlSession openSession(TransactionIsolationLevel level);\n  SqlSession openSession(ExecutorType execType);\n  SqlSession openSession(ExecutorType execType, boolean autoCommit);\n  SqlSession openSession(ExecutorType execType, TransactionIsolationLevel level);\n  SqlSession openSession(ExecutorType execType, Connection connection);\n  Configuration getConfiguration();\n}\n</code></pre><p>SqlSessionFactory是一个接口，DefaultSqlSessionFactory是它唯一的实现类。DefaultSqlSessionFactory源码如下所示：</p><pre><code>public class DefaultSqlSessionFactory implements SqlSessionFactory {\n  private final Configuration configuration;\n  public DefaultSqlSessionFactory(Configuration configuration) {\n    this.configuration = configuration;\n  }\n\n  @Override\n  public SqlSession openSession() {\n    return openSessionFromDataSource(configuration.getDefaultExecutorType(), null, false);\n  }\n\n  @Override\n  public SqlSession openSession(boolean autoCommit) {\n    return openSessionFromDataSource(configuration.getDefaultExecutorType(), null, autoCommit);\n  }\n\n  @Override\n  public SqlSession openSession(ExecutorType execType) {\n    return openSessionFromDataSource(execType, null, false);\n  }\n\n  @Override\n  public SqlSession openSession(TransactionIsolationLevel level) {\n    return openSessionFromDataSource(configuration.getDefaultExecutorType(), level, false);\n  }\n\n  @Override\n  public SqlSession openSession(ExecutorType execType, TransactionIsolationLevel level) {\n    return openSessionFromDataSource(execType, level, false);\n  }\n\n  @Override\n  public SqlSession openSession(ExecutorType execType, boolean autoCommit) {\n    return openSessionFromDataSource(execType, null, autoCommit);\n  }\n\n  @Override\n  public SqlSession openSession(Connection connection) {\n    return openSessionFromConnection(configuration.getDefaultExecutorType(), connection);\n  }\n\n  @Override\n  public SqlSession openSession(ExecutorType execType, Connection connection) {\n    return openSessionFromConnection(execType, connection);\n  }\n\n  @Override\n  public Configuration getConfiguration() {\n    return configuration;\n  }\n\n  private SqlSession openSessionFromDataSource(ExecutorType execType, TransactionIsolationLevel level, boolean autoCommit) {\n    Transaction tx = null;\n    try {\n      final Environment environment = configuration.getEnvironment();\n      final TransactionFactory transactionFactory = getTransactionFactoryFromEnvironment(environment);\n      tx = transactionFactory.newTransaction(environment.getDataSource(), level, autoCommit);\n      final Executor executor = configuration.newExecutor(tx, execType);\n      return new DefaultSqlSession(configuration, executor, autoCommit);\n    } catch (Exception e) {\n      closeTransaction(tx); // may have fetched a connection so lets call close()\n      throw ExceptionFactory.wrapException(&quot;Error opening session.  Cause: &quot; + e, e);\n    } finally {\n      ErrorContext.instance().reset();\n    }\n  }\n\n  private SqlSession openSessionFromConnection(ExecutorType execType, Connection connection) {\n    try {\n      boolean autoCommit;\n      try {\n        autoCommit = connection.getAutoCommit();\n      } catch (SQLException e) {\n        // Failover to true, as most poor drivers\n        // or databases won't support transactions\n        autoCommit = true;\n      }      \n      final Environment environment = configuration.getEnvironment();\n      final TransactionFactory transactionFactory = getTransactionFactoryFromEnvironment(environment);\n      final Transaction tx = transactionFactory.newTransaction(connection);\n      final Executor executor = configuration.newExecutor(tx, execType);\n      return new DefaultSqlSession(configuration, executor, autoCommit);\n    } catch (Exception e) {\n      throw ExceptionFactory.wrapException(&quot;Error opening session.  Cause: &quot; + e, e);\n    } finally {\n      ErrorContext.instance().reset();\n    }\n  }\n  //...省略部分代码...\n}\n</code></pre><p>从SqlSessionFactory和DefaultSqlSessionFactory的源码来看，它的设计非常类似刚刚讲到的SqlSessionFactoryBuilder，通过重载多个openSession()函数，支持通过组合autoCommit、Executor、Transaction等不同参数，来创建SqlSession对象。标准的工厂模式通过type来创建继承同一个父类的不同子类对象，而这里只不过是通过传递进不同的参数，来创建同一个类的对象。所以，它更像建造者模式。</p><p>虽然设计思路基本一致，但一个叫xxxBuilder（SqlSessionFactoryBuilder），一个叫xxxFactory（SqlSessionFactory）。而且，叫xxxBuilder的也并非标准的建造者模式，叫xxxFactory的也并非标准的工厂模式。所以，我个人觉得，MyBatis对这部分代码的设计还是值得优化的。</p><p>实际上，这两个类的作用只不过是为了创建SqlSession对象，没有其他作用。所以，我更建议参照Spring的设计思路，把SqlSessionFactoryBuilder和SqlSessionFactory的逻辑，放到一个叫“ApplicationContext”的类中。让这个类来全权负责读入配置文件，创建Congfiguration，生成SqlSession。</p><h2>BaseExecutor：模板模式跟普通的继承有什么区别？</h2><p>如果去查阅SqlSession与DefaultSqlSession的源码，你会发现，SqlSession执行SQL的业务逻辑，都是委托给了Executor来实现。Executor相关的类主要是用来执行SQL。其中，Executor本身是一个接口；BaseExecutor是一个抽象类，实现了Executor接口；而BatchExecutor、SimpleExecutor、ReuseExecutor三个类继承BaseExecutor抽象类。</p><p>那BatchExecutor、SimpleExecutor、ReuseExecutor三个类跟BaseExecutor是简单的继承关系，还是模板模式关系呢？怎么来判断呢？我们看一下BaseExecutor的源码就清楚了。</p><pre><code>public abstract class BaseExecutor implements Executor {\n  //...省略其他无关代码...\n  \n  @Override\n  public int update(MappedStatement ms, Object parameter) throws SQLException {\n    ErrorContext.instance().resource(ms.getResource()).activity(&quot;executing an update&quot;).object(ms.getId());\n    if (closed) {\n      throw new ExecutorException(&quot;Executor was closed.&quot;);\n    }\n    clearLocalCache();\n    return doUpdate(ms, parameter);\n  }\n\n  public List&lt;BatchResult&gt; flushStatements(boolean isRollBack) throws SQLException {\n    if (closed) {\n      throw new ExecutorException(&quot;Executor was closed.&quot;);\n    }\n    return doFlushStatements(isRollBack);\n  }\n\n  private &lt;E&gt; List&lt;E&gt; queryFromDatabase(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql) throws SQLException {\n    List&lt;E&gt; list;\n    localCache.putObject(key, EXECUTION_PLACEHOLDER);\n    try {\n      list = doQuery(ms, parameter, rowBounds, resultHandler, boundSql);\n    } finally {\n      localCache.removeObject(key);\n    }\n    localCache.putObject(key, list);\n    if (ms.getStatementType() == StatementType.CALLABLE) {\n      localOutputParameterCache.putObject(key, parameter);\n    }\n    return list;\n  }\n\n  @Override\n  public &lt;E&gt; Cursor&lt;E&gt; queryCursor(MappedStatement ms, Object parameter, RowBounds rowBounds) throws SQLException {\n    BoundSql boundSql = ms.getBoundSql(parameter);\n    return doQueryCursor(ms, parameter, rowBounds, boundSql);\n  }\n\n  protected abstract int doUpdate(MappedStatement ms, Object parameter) throws SQLException;\n\n  protected abstract List&lt;BatchResult&gt; doFlushStatements(boolean isRollback) throws SQLException;\n\n  protected abstract &lt;E&gt; List&lt;E&gt; doQuery(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql) throws SQLException;\n\n  protected abstract &lt;E&gt; Cursor&lt;E&gt; doQueryCursor(MappedStatement ms, Object parameter, RowBounds rowBounds, BoundSql boundSql) throws SQLException;\n}\n</code></pre><p>模板模式基于继承来实现代码复用。如果抽象类中包含模板方法，模板方法调用有待子类实现的抽象方法，那这一般就是模板模式的代码实现。而且，在命名上，模板方法与抽象方法一般是一一对应的，抽象方法在模板方法前面多一个“do”，比如，在BaseExecutor类中，其中一个模板方法叫update()，那对应的抽象方法就叫doUpdate()。</p><h2>SqlNode：如何利用解释器模式来解析动态SQL？</h2><p>支持配置文件中编写动态SQL，是MyBatis一个非常强大的功能。所谓动态SQL，就是在SQL中可以包含在trim、if、#{}等语法标签，在运行时根据条件来生成不同的SQL。这么说比较抽象，我举个例子解释一下。</p><pre><code>&lt;update id=&quot;update&quot; parameterType=&quot;com.xzg.cd.a89.User&quot;\n   UPDATE user\n   &lt;trim prefix=&quot;SET&quot; prefixOverrides=&quot;,&quot;&gt;\n       &lt;if test=&quot;name != null and name != ''&quot;&gt;\n           name = #{name}\n       &lt;/if&gt;\n       &lt;if test=&quot;age != null and age != ''&quot;&gt;\n           , age = #{age}\n       &lt;/if&gt;\n       &lt;if test=&quot;birthday != null and birthday != ''&quot;&gt;\n           , birthday = #{birthday}\n       &lt;/if&gt;\n   &lt;/trim&gt;\n   where id = ${id}\n&lt;/update&gt;\n</code></pre><p>显然，动态SQL的语法规则是MyBatis自定义的。如果想要根据语法规则，替换掉动态SQL中的动态元素，生成真正可以执行的SQL语句，MyBatis还需要实现对应的解释器。这一部分功能就可以看做是解释器模式的应用。实际上，如果你去查看它的代码实现，你会发现，它跟我们在前面讲解释器模式时举的那两个例子的代码结构非常相似。</p><p>我们前面提到，解释器模式在解释语法规则的时候，一般会把规则分割成小的单元，特别是可以嵌套的小单元，针对每个小单元来解析，最终再把解析结果合并在一起。这里也不例外。MyBatis把每个语法小单元叫SqlNode。SqlNode的定义如下所示：</p><pre><code>public interface SqlNode {\n boolean apply(DynamicContext context);\n}\n</code></pre><p>对于不同的语法小单元，MyBatis定义不同的SqlNode实现类。</p><p><img src=\"https://static001.geekbang.org/resource/image/03/9f/0365945b91a00e3b98d0c09b2665f59f.png\" alt=\"\"></p><p>整个解释器的调用入口在DynamicSqlSource.getBoundSql方法中，它调用了rootSqlNode.apply(context)方法。因为整体的代码结构跟<a href=\"https://time.geekbang.org/column/article/225904\">第72讲</a>中的例子基本一致，所以每个SqlNode实现类的代码，我就不带你一块阅读了，感兴趣的话你可以自己去看下。</p><h2>ErrorContext：如何实现一个线程唯一的单例模式？</h2><p>在单例模式那一部分我们讲到，单例模式是进程唯一的。同时，我们还讲到单例模式的几种变形，比如线程唯一的单例、集群唯一的单例等。在MyBatis中，ErrorContext这个类就是标准单例的变形：线程唯一的单例。</p><p>它的代码实现我贴到下面了。它基于Java中的ThreadLocal来实现。如果不熟悉ThreadLocal，你可以回过头去看下<a href=\"https://time.geekbang.org/column/article/196790\">第43讲</a>中线程唯一的单例的实现方法。实际上，这里的ThreadLocal就相当于那里的ConcurrentHashMap。</p><pre><code>public class ErrorContext {\n  private static final String LINE_SEPARATOR = System.getProperty(&quot;line.separator&quot;,&quot;\\n&quot;);\n  private static final ThreadLocal&lt;ErrorContext&gt; LOCAL = new ThreadLocal&lt;ErrorContext&gt;();\n\n  private ErrorContext stored;\n  private String resource;\n  private String activity;\n  private String object;\n  private String message;\n  private String sql;\n  private Throwable cause;\n\n  private ErrorContext() {\n  }\n\n  public static ErrorContext instance() {\n    ErrorContext context = LOCAL.get();\n    if (context == null) {\n      context = new ErrorContext();\n      LOCAL.set(context);\n    }\n    return context;\n  }\n}\n</code></pre><h2>Cache：为什么要用装饰器模式而不设计成继承子类？</h2><p>我们前面提到，MyBatis是一个ORM框架。实际上，它不只是简单地完成了对象和数据库数据之间的互相转化，还提供了很多其他功能，比如缓存、事务等。接下来，我们再讲讲它的缓存实现。</p><p>在MyBatis中，缓存功能由接口Cache定义。PerpetualCache类是最基础的缓存类，是一个大小无限的缓存。除此之外，MyBatis还设计了9个包裹PerpetualCache类的装饰器类，用来实现功能增强。它们分别是：FifoCache、LoggingCache、LruCache、ScheduledCache、SerializedCache、SoftCache、SynchronizedCache、WeakCache、TransactionalCache。</p><pre><code>public interface Cache {\n  String getId();\n  void putObject(Object key, Object value);\n  Object getObject(Object key);\n  Object removeObject(Object key);\n  void clear();\n  int getSize();\n  ReadWriteLock getReadWriteLock();\n}\n\npublic class PerpetualCache implements Cache {\n  private final String id;\n  private Map&lt;Object, Object&gt; cache = new HashMap&lt;Object, Object&gt;();\n\n  public PerpetualCache(String id) {\n    this.id = id;\n  }\n\n  @Override\n  public String getId() {\n    return id;\n  }\n\n  @Override\n  public int getSize() {\n    return cache.size();\n  }\n\n  @Override\n  public void putObject(Object key, Object value) {\n    cache.put(key, value);\n  }\n\n  @Override\n  public Object getObject(Object key) {\n    return cache.get(key);\n  }\n\n  @Override\n  public Object removeObject(Object key) {\n    return cache.remove(key);\n  }\n\n  @Override\n  public void clear() {\n    cache.clear();\n  }\n\n  @Override\n  public ReadWriteLock getReadWriteLock() {\n    return null;\n  }\n  //省略部分代码...\n}\n</code></pre><p>这9个装饰器类的代码结构都类似，我只将其中的LruCache的源码贴到这里。从代码中我们可以看出，它是标准的装饰器模式的代码实现。</p><pre><code>public class LruCache implements Cache {\n  private final Cache delegate;\n  private Map&lt;Object, Object&gt; keyMap;\n  private Object eldestKey;\n\n  public LruCache(Cache delegate) {\n    this.delegate = delegate;\n    setSize(1024);\n  }\n\n  @Override\n  public String getId() {\n    return delegate.getId();\n  }\n\n  @Override\n  public int getSize() {\n    return delegate.getSize();\n  }\n\n  public void setSize(final int size) {\n    keyMap = new LinkedHashMap&lt;Object, Object&gt;(size, .75F, true) {\n      private static final long serialVersionUID = 4267176411845948333L;\n\n      @Override\n      protected boolean removeEldestEntry(Map.Entry&lt;Object, Object&gt; eldest) {\n        boolean tooBig = size() &gt; size;\n        if (tooBig) {\n          eldestKey = eldest.getKey();\n        }\n        return tooBig;\n      }\n    };\n  }\n\n  @Override\n  public void putObject(Object key, Object value) {\n    delegate.putObject(key, value);\n    cycleKeyList(key);\n  }\n\n  @Override\n  public Object getObject(Object key) {\n    keyMap.get(key); //touch\n    return delegate.getObject(key);\n  }\n\n  @Override\n  public Object removeObject(Object key) {\n    return delegate.removeObject(key);\n  }\n\n  @Override\n  public void clear() {\n    delegate.clear();\n    keyMap.clear();\n  }\n\n  @Override\n  public ReadWriteLock getReadWriteLock() {\n    return null;\n  }\n\n  private void cycleKeyList(Object key) {\n    keyMap.put(key, key);\n    if (eldestKey != null) {\n      delegate.removeObject(eldestKey);\n      eldestKey = null;\n    }\n  }\n}\n</code></pre><p>之所以MyBatis采用装饰器模式来实现缓存功能，是因为装饰器模式采用了组合，而非继承，更加灵活，能够有效地避免继承关系的组合爆炸。关于这一点，你可以回过头去看下<a href=\"https://time.geekbang.org/column/article/169593\">第10讲</a>的内容。</p><h2>PropertyTokenizer：如何利用迭代器模式实现一个属性解析器？</h2><p>前面我们讲到，迭代器模式常用来替代for循环遍历集合元素。Mybatis的PropertyTokenizer类实现了Java Iterator接口，是一个迭代器，用来对配置属性进行解析。具体的代码如下所示：</p><pre><code>// person[0].birthdate.year 会被分解为3个PropertyTokenizer对象。其中，第一个PropertyTokenizer对象的各个属性值如注释所示。\b\npublic class PropertyTokenizer implements Iterator&lt;PropertyTokenizer&gt; {\n  private String name; // person\n  private final String indexedName; // person[0]\n  private String index; // 0\n  private final String children; // birthdate.year\n\n  public PropertyTokenizer(String fullname) {\n    int delim = fullname.indexOf('.');\n    if (delim &gt; -1) {\n      name = fullname.substring(0, delim);\n      children = fullname.substring(delim + 1);\n    } else {\n      name = fullname;\n      children = null;\n    }\n    indexedName = name;\n    delim = name.indexOf('[');\n    if (delim &gt; -1) {\n      index = name.substring(delim + 1, name.length() - 1);\n      name = name.substring(0, delim);\n    }\n  }\n\n  public String getName() {\n    return name;\n  }\n\n  public String getIndex() {\n    return index;\n  }\n\n  public String getIndexedName() {\n    return indexedName;\n  }\n\n  public String getChildren() {\n    return children;\n  }\n\n  @Override\n  public boolean hasNext() {\n    return children != null;\n  }\n\n  @Override\n  public PropertyTokenizer next() {\n    return new PropertyTokenizer(children);\n  }\n\n  @Override\n  public void remove() {\n    throw new UnsupportedOperationException(&quot;Remove is not supported, as it has no meaning in the context of properties.&quot;);\n  }\n}\n</code></pre><p>实际上，PropertyTokenizer类也并非标准的迭代器类。它将配置的解析、解析之后的元素、迭代器，这三部分本该放到三个类中的代码，都耦合在一个类中，所以看起来稍微有点难懂。不过，这样做的好处是能够做到惰性解析。我们不需要事先将整个配置，解析成多个PropertyTokenizer对象。只有当我们在调用next()函数的时候，才会解析其中部分配置。</p><h2>Log：如何使用适配器模式来适配不同的日志框架？</h2><p>\b在适配器模式那节课中我们讲过，Slf4j框架为了统一各个不同的日志框架（Log4j、JCL、Logback等），提供了一套统一的日志接口。不过，MyBatis并没有直接使用Slf4j提供的统一日志规范，而是自己又重复造轮子，定义了一套自己的日志访问接口。</p><pre><code>public interface Log {\n  boolean isDebugEnabled();\n  boolean isTraceEnabled();\n  void error(String s, Throwable e);\n  void error(String s);\n  void debug(String s);\n  void trace(String s);\n  void warn(String s);\n}\n</code></pre><p>针对Log接口，MyBatis还提供了各种不同的实现类，分别使用不同的日志框架来实现Log接口。</p><p><img src=\"https://static001.geekbang.org/resource/image/95/14/95946f9e9c524cc06279114f7a654f14.png\" alt=\"\"></p><p>这几个实现类的代码结构基本上一致。我把其中的Log4jImpl的源码贴到了这里。我们知道，在适配器模式中，传递给适配器构造函数的是被适配的类对象，而这里是clazz（相当于日志名称name），所以，从代码实现上来讲，它并非标准的适配器模式。但是，从应用场景上来看，这里确实又起到了适配的作用，是典型的适配器模式的应用场景。</p><pre><code>import org.apache.ibatis.logging.Log;\nimport org.apache.log4j.Level;\nimport org.apache.log4j.Logger;\n\npublic class Log4jImpl implements Log {\n  private static final String FQCN = Log4jImpl.class.getName();\n  private final Logger log;\n\n  public Log4jImpl(String clazz) {\n    log = Logger.getLogger(clazz);\n  }\n\n  @Override\n  public boolean isDebugEnabled() {\n    return log.isDebugEnabled();\n  }\n\n  @Override\n  public boolean isTraceEnabled() {\n    return log.isTraceEnabled();\n  }\n\n  @Override\n  public void error(String s, Throwable e) {\n    log.log(FQCN, Level.ERROR, s, e);\n  }\n\n  @Override\n  public void error(String s) {\n    log.log(FQCN, Level.ERROR, s, null);\n  }\n\n  @Override\n  public void debug(String s) {\n    log.log(FQCN, Level.DEBUG, s, null);\n  }\n\n  @Override\n  public void trace(String s) {\n    log.log(FQCN, Level.TRACE, s, null);\n  }\n\n  @Override\n  public void warn(String s) {\n    log.log(FQCN, Level.WARN, s, null);\n  }\n}\n</code></pre><h2>重点回顾</h2><p>好了，今天的内容到此就讲完了。我们一块来总结回顾一下，你需要重点掌握的内容。</p><p>今天，我们讲到了MyBatis中用到的8种设计模式，它们分别是：建造者模式、工厂模式、模板模式、解释器模式、单例模式、装饰器模式、迭代器模式、适配器模式。加上上一节课中讲到的职责链和动态代理，我们总共讲了10种设计模式。</p><p>还是那句老话，你不需要记忆哪个类用到了哪个模式，因为不管你看多少遍，甚至记住并没有什么用。我希望你不仅仅只是把文章看了，更希望你能动手把MyBatis源码下载下来，自己去阅读一下相关的源码，锻炼自己阅读源码的能力。这比单纯看文章效果要好很多倍。</p><p>除此之外，从这两节课的讲解中，不知道你有没有发现，MyBatis对很多设计模式的实现，都并非标准的代码实现，都做了比较多的自我改进。实际上，这就是所谓的灵活应用，只借鉴不照搬，根据具体问题针对性地去解决。</p><h2>课堂讨论</h2><p>今天我们提到，SqlSessionFactoryBuilder跟SqlSessionFactory虽然名字后缀不同，但是设计思路一致，都是为了隐藏SqlSession的创建细节。从这一点上来看，命名有点不够统一。而且，我们还提到，SqlSessionFactoryBuilder并非标准的建造者模式，SqlSessionFactory也并非标准的工厂模式。对此你有什么看法呢？</p><p>欢迎留言和我分享你的想法。如果有收获，也欢迎你把这篇文章分享给你的朋友。</p>",
                "article_title": "89 | 开源实战五（下）：总结MyBatis框架中用到的10种设计模式"
            }
        ]
    },
    {
        "chapterTitle": "开源与项目实战：项目实战 (9讲)",
        "children": [
            {
                "title": "90 | 项目实战一：设计实现一个支持各种算法的限流框架（分析）",
                "herf": "https://time.geekbang.org/column/article/242314",
                "id": "242314",
                "content": "<p>结束了开源实战，从今天开始我们正式进入项目实战模块。在开源实战中，我带你一块剖析了几个著名的开源项目，比如Spring、MyBatis、Google Guava等，剖析了它们背后蕴含的设计思想、原则和模式。</p><p>如果说前面讲开源实战是学习别人怎么做，那现在我们讲项目实战就是带你一块做。在这个过程中，我会带你实践之前学过的设计思想、原则和模式，给你展示怎么应用这些理论知识，让你开发出跟前面那些著名开源项目一样优秀的软件。</p><p>在项目实战中，我找了三个稍微有点难度的项目：限流框架、幂等框架、灰度发布组件，带你一起来实现。针对每一个项目，我都会从分析、设计、实现这三个部分来讲解。当然，还是那句老话，项目本身的讲解不是重点，重点还是学习它们背后的开发套路。这才是最有价值的部分。</p><p>接下来的三节课，我们讲第一个实战项目，限流框架。今天，我们先讲其中的分析环节，介绍项目背景，分析项目需求。</p><p>话不多说，让我们正式开始今天的学习吧！</p><h2>项目背景</h2><p>我们先来讲下需求诞生的背景。这个背景跟我们下一个实战项目幂等框架也有关系，所以要从很久很久讲起，希望你能耐心看完，不然后面可能会看不懂。</p><p>公司成立初期，团队人少。公司集中精力开发一个金融理财产品（我们把这个项目叫做X项目）。整个项目只做了简单的前后端分离，后端的所有代码都在一个GitHub仓库中，整个后端作为一个应用来部署，没有划分微服务。</p><!-- [[[read_end]]] --><p>遇到了行业风口，公司发展得不错，公司开始招更多人，开发更多的金融产品，比如专注房贷的理财产品、专注供应链的产品、专注消费贷的借款端产品等等。在产品形态上，每个金融产品都做成了独立的App。</p><p>对于不同的金融产品，尽管移动端长得不一样，但是后端的很多功能、代码都是可以复用的。为了快速上线，针对每个应用，公司都成立一个新的团队，然后拷贝X项目的代码，在此基础之上修改、添加新的功能。</p><p>这样成立新团队，拷贝老代码，改改就能上线一个新产品的开发模式，在一开始很受欢迎。产品上线快，也给公司赢得了竞争上的优势。但时间一长，这样的开发模式暴露出来的问题就越来越多了。而且随着公司的发展，公司也过了急速扩张期，人招得太多，公司开始考虑研发效率问题了。</p><p>因为所有的项目的代码都是从X项目拷贝来的，多个团队同时维护相似的代码，显然是重复劳动，协作起来也非常麻烦。任何团队发现代码的bug，都要同步到其他团队做相同的修改。而且，各个团队对代码独立迭代，改得面目全非，即便要添加一个通用的功能，每个团队也都要基于自己的代码再重复开发。</p><p>除此之外，公司成立初期，各个方面条件有限，只能招到开发水平一般的员工，而且追求快速上线，所以，X项目的代码质量很差，结构混乱、命名不规范、到处是临时解决方案、埋了很多坑，在烂代码之上不停地堆砌烂代码，时间长了，代码的可读性越来越差、维护成本越来越高，甚至高过了重新开发的成本。</p><p>这个时候该怎么办呢？如果让你出出主意，你有什么好的建议吗？</p><p>我们可以把公共的功能、代码抽离出来，形成一个独立的项目，部署成一个公共服务平台。所有金融产品的后端还是参照MVC三层架构独立开发，不过，它们只实现自己特有的功能，对于一些公共的功能，通过远程调用公共服务平台提供的接口来实现。</p><p>这里提到的公共服务平台，有点类似现在比较火的“中台”或“微服务”。不过，为了减少部署、维护多个微服务的成本，我们把所有公共的功能，放到一个项目中开发，放到一个应用中部署。只不过，我们要未雨绸缪，事先按照领域模型，将代码的模块化做好，等到真的有哪个模块的接口调用过于集中，性能出现瓶颈的时候，我们再把它拆分出来，设计成独立的微服务来开发和部署。</p><p>经过这样的拆分之后，我们可以指派一个团队，集中维护公共服务平台的代码。开发一个新的金融产品，也只需要更少的人员来参与，因为他们只需要开发、维护产品特有的功能和代码就可以了。整体上，维护成本降低了。除此之外，公共服务平台的代码集中到了一个团队手里，重构起来不需要协调其他团队和项目，也便于我们重构、改善代码质量。</p><h2>需求背景</h2><p>对于公共服务平台来说，接口请求来自很多不同的系统（后面统称为调用方），比如各种金融产品的后端系统。在系统上线一段时间里，我们遇到了很多问题。比如，因为调用方代码bug 、不正确地使用服务（比如启动Job来调用接口获取数据）、业务上面的突发流量（比如促销活动），导致来自某个调用方的接口请求数突增，过度争用服务的线程资源，而来自其他调用方的接口请求，因此来不及响应而排队等待，导致接口请求的响应时间大幅增加，甚至出现超时。</p><p>为了解决这个问题，你有什么好的建议呢？我先来说说我的。</p><p>我们可以开发接口限流功能，限制每个调用方对接口请求的频率。当超过预先设定的访问频率后，我们就触发限流熔断，比如，限制调用方app-1对公共服务平台总的接口请求频率不超过1000次/秒，超过之后的接口请求都会被拒绝。除此之外，为了更加精细化地限流，除了限制每个调用方对公共服务平台总的接口请求频率之外，我们还希望能对单独某个接口的访问频率进行限制，比如，限制app-1对接口/user/query的访问频率为每秒钟不超过100次。</p><p>我们希望开发出来的东西有一定的影响力，即便做不到在行业内有影响力，起码也要做到在公司范围内有影响力。所以，从一开始，我们就不想把这个限流功能，做成只有我们项目可用。我们希望把它开发成一个通用的框架，能够应用到各个业务系统中，甚至可以集成到微服务治理平台中。实际上，这也体现了业务开发中要具备的抽象意识、框架意识。我们要善于识别出通用的功能模块，将它抽象成通用的框架、组件、类库等。</p><h2>需求分析</h2><p>刚刚我们花了很大篇幅来介绍项目背景和需求背景，接下来，我们再对需求进行更加详细的分析和整理。</p><p>前面我们已经讲过一些需求分析的方法，比如画线框图、写用户用例、测试驱动开发等等。这里，我们借助用户用例和测试驱动开发的思想，先去思考，如果框架最终被开发出来之后，它会如何被使用。我一般会找一个框架的应用场景，针对这个场景写一个框架使用的Demo程序，这样能够很直观地看到框架长什么样子。知道了框架应该长什么样，就相当于应试教育中确定了考试题目。针对明确的考题去想解决方案，这是我们多年应试教育锻炼之后最擅长做的。</p><p>对于限流框架来说，我们来看下它的应用场景。</p><p>首先我们需要设置限流规则。为了做到在不修改代码的前提下修改规则，我们一般会把规则放到配置文件中（比如XML、YAML配置文件）。在集成了限流框架的应用启动的时候，限流框架会将限流规则，按照事先定义的语法，解析并加载到内存中。我写了一个限流规则的Demo配置，如下所示：</p><pre><code>configs:\n- appId: app-1\n  limits:\n  - api: /v1/user\n    limit: 100\n  - api: /v1/order\n    limit: 50\n- appId: app-2\n  limits:\n  - api: /v1/user\n    limit: 50\n  - api: /v1/order\n    limit: 50\n</code></pre><p>在接收到接口请求之后，应用会将请求发送给限流框架，限流框架会告诉应用，这个接口请求是允许继续处理，还是触发限流熔断。如果我们用代码来将这个过程表示出来的话，就是下面这个Demo的样子。如果项目使用的是Spring框架，我们可以利用Spring AOP，把这段限流代码放在统一的切面中，在切面中拦截接口请求，解析出请求对应的调用方APP ID和URL，然后验证是否对此调用方的这个接口请求进行限流。</p><pre><code>String appId = &quot;app-1&quot;; // 调用方APP-ID\nString url = &quot;http://www.eudemon.com/v1/user/12345&quot;;// 请求url\nRateLimiter ratelimiter = new RateLimiter();\nboolean passed = ratelimiter.limit(appId, url);\nif (passed) {\n  // 放行接口请求，继续后续的处理。\n} else {\n  // 接口请求被限流。\n}\n</code></pre><p>结合刚刚的Demo，从使用的角度来说，限流框架主要包含两部分功能：配置限流规则和提供编程接口（RateLimiter类）验证请求是否被限流。不过，作为通用的框架，除了功能性需求之外，非功能性需求也非常重要，有时候会决定一个框架的成败，比如，框架的易用性、扩展性、灵活性、性能、容错性等。</p><p>对于限流框架，我们来看它都有哪些非功能性需求。</p><p>易用性方面，我们希望限流规则的配置、编程接口的使用都很简单。我们希望提供各种不同的限流算法，比如基于内存的单机限流算法、基于Redis的分布式限流算法，能够让使用者自由选择。除此之外，因为大部分项目都是基于Spring开发的，我们还希望限流框架能非常方便地集成到使用Spring框架的项目中。</p><p>扩展性、灵活性方面，我们希望能够灵活地扩展各种限流算法。同时，我们还希望支持不同格式（JSON、YAML、XML等格式）、不同数据源（本地文件配置或Zookeeper集中配置等）的限流规则的配置方式。</p><p>性能方面，因为每个接口请求都要被检查是否限流，这或多或少会增加接口请求的响应时间。而对于响应时间比较敏感的接口服务来说，我们要让限流框架尽可能低延迟，尽可能减少对接口请求本身响应时间的影响。</p><p>容错性方面，接入限流框架是为了提高系统的可用性、稳定性，不能因为限流框架的异常，反过来影响到服务本身的可用性。所以，限流框架要有高度的容错性。比如，分布式限流算法依赖集中存储器Redis。如果Redis挂掉了，限流逻辑无法正常运行，这个时候业务接口也要能正常服务才行。</p><h2>重点回顾</h2><p>好了，今天的内容到此就讲完了。我们一块来总结回顾一下，你需要重点掌握的内容。</p><p>今天，我们主要对限流框架做了大的项目背景、需求背景介绍，以及更加具体的需求分析，明确了要做什么，为下两节课的设计和实现做准备。</p><p>从今天的讲解中，不知道你有没有发现，基本的功能需求其实没有多少，但将非功能性需求考虑进去之后，明显就复杂了很多。还是那句老话，<strong>写出能用的代码很简单，写出好用的代码很难。</strong>对于限流框架来说，非功能性需求是设计与实现的难点。怎么做到易用、灵活、可扩展、低延迟、高容错，才是开发的重点，也是我们接下来两节课要讲解的重点。</p><p>除此之外，今天我们还实践了一些需求分析的方法，比如画线框图、写用户用例、测试驱动开发等等。针对限流框架，我们借助用户用例和测试驱动开发的思想，先去思考，如果框架最终被开发出来之后，它会如何被使用。针对具体的场景去做分析，更加清晰直观。</p><h2>课堂讨论</h2><p>在今天介绍项目背景的时候，我讲了公司遇到的一个开发问题，并提出了解决方案，你也可以留言分享一下，你所在公司或者项目中，遇到过哪些比较头疼的开发问题，又是如何解决的？</p><p>欢迎留言和我分享你的想法。如果有收获，也欢迎你把这篇文章分享给你的朋友。</p>",
                "article_title": "90 | 项目实战一：设计实现一个支持各种算法的限流框架（分析）"
            },
            {
                "title": "91 | 项目实战一：设计实现一个支持各种算法的限流框架（设计）",
                "herf": "https://time.geekbang.org/column/article/243175",
                "id": "243175",
                "content": "<p>上一节课，我们介绍了限流框架产生的项目背景，并且对需求做了分析，这其中包括功能性需求和非功能性需求，算是在正式开始设计之前的一个铺垫。</p><p>前面提到，我们把项目实战分为分析、设计、实现三部分来讲解。其中，分析环节跟之前讲过的面向对象分析很相似，都是做需求的梳理。但是，项目实战中的设计和实现，跟面向对象设计和实现就不是一回事儿了。这里的“设计”指的是系统设计，主要是划分模块，对模块进行设计。这里的“实现”实际上等于面向对象设计加实现。因为我们前面讲到，面向对象设计与实现是聚焦在代码层面的，主要产出的是类的设计和实现。</p><p>今天，我们分限流规则、限流算法、限流模式、集成使用这4个模块，来讲解限流框架的设计思路。上节课我们提到，限流框架的基本功能非常简单，复杂在于它的非功能性需求，所以，我们今天讲解的重点是，看如何通过合理的设计，实现一个满足易用、易扩展、灵活、低延时、高容错等非功能性需求的限流框架。</p><p>话不多说，让我们正式开始今天的学习吧！</p><h2>限流规则</h2><p>框架需要定义限流规则的语法格式，包括调用方、接口、限流阈值、时间粒度这几个元素。框架用户按照这个语法格式来配置限流规则。我举了一个例子来说明一下，如下所示。其中，unit表示限流时间粒度，默认情况下是1秒。limit表示在unit时间粒度内最大允许的请求次数。拿第一条规则来举例，它表示的意思就是：调用方app-1对接口/v1/user每分钟的最大请求次数不能超过100次。</p><!-- [[[read_end]]] --><pre><code>configs:\n- appId: app-1\n  limits:\n  - api: /v1/user\n    limit: 100\n    unit：60\n  - api: /v1/order\n    limit: 50\n- appId: app-2\n  limits:\n  - api: /v1/user\n    limit: 50\n  - api: /v1/order\n    limit: 50\n</code></pre><p>对于限流时间粒度的选择，我们既可以选择限制1 秒钟内不超过1000次，也可以选择限制10毫秒内不超过10次，还可以选择限制1分钟内不超过6万次。虽然看起来这几种限流规则是等价的，但过大的时间粒度会达不到限流的效果。比如，有可能6万次请求集中在1秒中到达，限制1分钟不超过6万次，就起不到保护的作用；相反，因为接口访问在细时间粒度上随机性很大，并不会很均匀。过小的时间粒度，会误杀很多本不应该限流的请求。所以，尽管越细的时间粒度限流整形效果越好，流量曲线越平滑，但也并不是时间粒度越小越合适。</p><p>我们知道，Spring框架支持各种格式的配置文件，比如XML、YAML、Porperties等。除此之外，基于约定优于配置原则，Spring框架用户只需要将配置文件按照约定来命名，并且放置到约定的路径下，Spring框架就能按照约定自动查找和加载配置文件。</p><p>大部分Java程序员已经习惯了Spring的配置方式，基于我们前面讲的最小惊奇原则，在限流框架中，我们也延续Spring的配置方式，支持XML、YAML、Properties等几种配置文件格式，同时，约定默认的配置文件名为ratelimiter-rule.yaml，默认放置在classpath路径中。</p><p>除此之外，为了提高框架的兼容性、易用性，除了刚刚讲的本地文件的配置方式之外，我们还希望兼容从其他数据源获取配置的方式，比如Zookeeper或者自研的配置中心。</p><h2>限流算法</h2><p>常见的限流算法有：固定时间窗口限流算法、滑动时间窗口限流算法、令牌桶限流算法、漏桶限流算法。其中，固定时间窗口限流算法最简单。我们只需要选定一个起始时间起点，之后每来一个接口请求，我们都给计数器（记录当前时间窗口内的访问次数）加一，如果在当前时间窗口内，根据限流规则（比如每秒钟最大允许100次接口请求），累加访问次数超过限流值（比如100次），就触发限流熔断，拒绝接口请求。当进入下一个时间窗口之后，计数器清零重新计数。</p><p>不过，固定时间窗口的限流算法的缺点也很明显。这种算法的限流策略过于粗略，无法应对两个时间窗口临界时间内的突发流量。我们来举一个例子。假设我们限流规则为每秒钟不超过100次接口请求。第一个1秒时间窗口内，100次接口请求都集中在最后的10毫秒内，在第二个1秒时间窗口内，100次接口请求都集中在最开始的10毫秒内。虽然两个时间窗口内流量都符合限流要求 (小于等于100个接口请求)，但在两个时间窗口临界的20毫秒内集中有200次接口请求，固定时间窗口限流算法没法对这种情况进行限流，集中在这20毫秒内的200次请求有可能会压垮系统。</p><p>为了让流量更加平滑，于是就有了更加高级的滑动时间窗口限流算法、令牌桶限流算法和漏桶限流算法。因为我们主要讲设计而非技术，所以其他几种限流算法，留给你自己去研究，你也可以参看我之前写的关于限流框架的技术文档。</p><p>尽管固定时间窗口限流算法没法做到让流量很平滑，但大部分情况下，它已经够用了。默认情况下，框架使用固定时间窗口限流算法做限流。不过，考虑到框架的扩展性，我们需要预先做好设计，预留好扩展点，方便今后扩展其他限流算法。除此之外，为了提高框架的易用性、灵活性，我们最好将其他几种常用的限流算法，也在框架中实现出来，供框架用户根据自己业务场景自由选择。</p><h2>限流模式</h2><p>刚刚讲的是限流算法，我们再讲讲限流模式。我们把限流模式分为两种：单机限流和分布式限流。所谓单机限流，就是针对单个实例的访问频率进行限制。注意这里的单机并不是真的一台物理机器，而是一个服务实例，因为有可能一台物理机器部署多个实例。所谓的分布式限流，就是针对某个服务的多个实例的总的访问频率进行限制。我举个例子来解释一下。</p><p>假设我们开发了一个用户相关的微服务，为了提高服务能力，我们部署了5个实例。我们限制某个调用方，对单个实例的某个接口的访问频率，不能超过100次/秒。这就是单机限流。我们限制某个调用方，对5个实例的某个接口的总访问频率，不能超过500次/秒。这就是所谓的分布式限流。</p><p>从实现的角度来分析，单机限流和分布式限流的主要区别在接口访问计数器的实现。单机限流只需要在单个实例中维护自己的接口请求计数器。而分布式限流需要集中管理计数器（比如使用Redis存储接口访问计数），这样才能做到多个实例对同一个计数器累加计数，以便实现对多个实例总访问频率的限制。</p><p>前面我们讲到框架要高容错，不能因为框架的异常，影响到集成框架的应用的可用性和稳定性。除此之外，我们还讲到框架要低延迟。限流逻辑的执行不能占用太长时间，不能或者很少影响接口请求本身的响应时间。因为分布式限流基于外部存储Redis，网络通信成本较高，实际上，高容错、低延迟设计的主要场景就是基于Redis实现的分布式限流。</p><p>对于Redis的各种异常情况，我们处理起来并不难，捕获并封装为统一的异常，向上抛出或者吞掉就可以了。比较难处理的是Redis访问超时。Redis访问超时会严重影响接口的响应时间，甚至导致接口请求超时。所以，在访问Redis时，我们需要设置合理的超时时间。一旦超时，我们就判定为限流失效，继续执行接口请求。Redis 访问超时时间的设置既不能太大也不能太小，太大可能会影响到接口的响应时间，太小可能会导致太多的限流失效。我们可以通过压测或者线上监控，获取到Redis访问时间分布情况，再结合接口可以容忍的限流延迟时间，权衡设置一个较合理的Redis超时时间。</p><h2>集成使用</h2><p>前面剖析Spring框架的时候，我们讲到低侵入松耦合设计思想。限流框架也应该满足这个设计思想。因为框架是需要集成到应用中使用的，我们希望框架尽可能低侵入，与业务代码松耦合，替换、删除起来也更容易些。</p><p>除此之外，在剖析MyBatis框架的时候，我们讲到MyBatis框架是为了简化数据库编程。实际上，为了进一步简化开发，MyBatis还提供了MyBatis-Spring类库，方便在使用了Spring框架的项目中集成MyBatis框架。我们也可以借鉴MyBatis-Spring，开发一个Ratelimiter-Spring类库，能够方便使用了Spring的项目集成限流框架，将易用性做到极致。</p><h2>重点回顾</h2><p>好了，今天的内容到此就讲完了。我们一块来总结回顾一下，你需要重点掌握的内容。</p><p>我们将这个限流框架划分为限流规则、限流算法、限流模式、集成使用者这四个模块来分析讲解。除了功能方面的设计之外，我们重点讲了如何满足易用、灵活、易扩展、低延迟、高容错这些非功能性需求。</p><p>针对限流规则，大部分Java程序员已经习惯了Spring的配置方式。基于最小惊奇原则，在限流框架中，我们也延续Spring的配置方式，支持XML、YAML、Properties等几种配置文件格式。同时，借鉴Spring的约定优于配置设计原则，限流框架用户只需要将配置文件按照约定来命名，并且放置到约定的路径下，框架就能按照约定自动查找和加载配置文件。除此之外，为了提高框架的兼容性、易用性，除了本地文件的配置方式之外，我们还希望兼容从其他数据源获取配置的方式，比如Zookeeper或者自研的配置中心。</p><p>针对限流算法，尽管固定时间窗口限流算法没法做到让流量很平滑，但大部分情况下，它已经够用了。默认情况下，框架使用固定时间窗口限流算法做限流。不过，考虑到框架的扩展性，我们需要预先做好设计，预留好扩展点，方便今后扩展其他限流算法。除此之外，为了提高框架的易用性、灵活性，我们将其他几种常用的限流算法也在框架中实现出来，供框架用户根据自己的业务场景自由选择。</p><p>针对限流模式，因为分布式限流基于外部存储Redis，网络通信成本较高，框架的高容错和低延迟的设计，主要是针对基于Redis的分布式限流模式。不能因为Redis的异常，影响到集成框架的应用的可用性和稳定性。不能因为Redis访问超时，导致接口访问超时。</p><p>针对集成使用，我们希望框架低侵入，跟业务代码松耦合。应用集成框架的代码，尽可能集中、不分散，这样删除、替换起来就容易很多。除此之外，为了将框架的易用性做到极致，我们借鉴MyBatis-Spring类库，设计实现一个RateLimiter-Spring类库，方便集成了Spring框架的应用集成限流框架。</p><h2>课堂讨论</h2><p>今天，我们提到配置限流规则的时候，时间粒度不能太大，也不能太小，限流值也要设置得合理，太大起不到限流的作用，太小容易误杀。那请你思考一下，如何选择合理的时间粒度和限流值？如何验证设置的合理性？</p><p>欢迎留言和我分享你的想法。如果有收获，也欢迎你把这篇文章分享给你的朋友。</p>",
                "article_title": "91 | 项目实战一：设计实现一个支持各种算法的限流框架（设计）"
            },
            {
                "title": "92 | 项目实战一：设计实现一个支持各种算法的限流框架（实现）",
                "herf": "https://time.geekbang.org/column/article/243961",
                "id": "243961",
                "content": "<p>上一节课，我们介绍了如何通过合理的设计，来实现功能性需求的同时，满足易用、易扩展、灵活、低延迟、高容错等非功能性需求。在设计的过程中，我们也借鉴了之前讲过的一些开源项目的设计思想。比如，我们借鉴了Spring的低侵入松耦合、约定优于配置等设计思想，还借鉴了MyBatis通过MyBatis-Spring类库将框架的易用性做到极致等设计思路。</p><p>今天，我们讲解这样一个问题，针对限流框架的开发，如何做高质量的代码实现。说的具体点就是，如何利用之前讲过的设计思想、原则、模式、编码规范、重构技巧等，写出易读、易扩展、易维护、灵活、简洁、可复用、易测试的代码。</p><p>话不多少，让我们正式开始今天的学习吧！</p><h2>V1版本功能需求</h2><p>我们前面提到，优秀的代码是重构出来的，复杂的代码是慢慢堆砌出来的。小步快跑、逐步迭代是我比较推崇的开发模式。所以，针对限流框架，我们也不用想一下子就做得大而全。况且，在专栏有限的篇幅内，我们也不可能将一个大而全的代码阐述清楚。所以，我们可以先实现一个包含核心功能、基本功能的V1版本。</p><p>针对上两节课中给出的需求和设计，我们重新梳理一下，看看有哪些功能要放到V1版本中实现。</p><p>在V1版本中，对于接口类型，我们只支持HTTP接口（也就URL）的限流，暂时不支持RPC等其他类型的接口限流。对于限流规则，我们只支持本地文件配置，配置文件格式只支持YAML。对于限流算法，我们只支持固定时间窗口算法。对于限流模式，我们只支持单机限流。</p><!-- [[[read_end]]] --><p>尽管功能“裁剪”之后，V1版本实现起来简单多了，但在编程开发的同时，我们还是要考虑代码的扩展性，预留好扩展点。这样，在接下来的新版本开发中，我们才能够轻松地扩展新的限流算法、限流模式、限流规则格式和数据源。</p><h2>最小原型代码</h2><p>上节课我们讲到，项目实战中的实现等于面向对象设计加实现。而面向对象设计与实现一般可以分为四个步骤：划分职责识别类、定义属性和方法、定义类之间的交互关系、组装类并提供执行入口。在<a href=\"https://time.geekbang.org/column/article/171767\">第14讲</a>中，我还带你用这个方法，设计和实现了一个接口鉴权框架。如果你印象不深刻了，可以回过头去再看下。</p><p>不过，我们前面也讲到，在平时的工作中，大部分程序员都是边写代码边做设计，边思考边重构，并不会严格地按照步骤，先做完类的设计再去写代码。而且，如果想一下子就把类设计得很好、很合理，也是比较难的。过度追求完美主义，只会导致迟迟下不了手，连第一行代码也敲不出来。所以，我的习惯是，先完全不考虑设计和代码质量，先把功能完成，先把基本的流程走通，哪怕所有的代码都写在一个类中也无所谓。然后，我们再针对这个MVP代码（最小原型代码）做优化重构，比如，将代码中比较独立的代码块抽离出来，定义成独立的类或函数。</p><p>我们按照先写MVP代码的思路，把代码实现出来。它的目录结构如下所示。代码非常简单，只包含5个类，接下来，我们针对每个类一一讲解一下。</p><pre><code>com.xzg.ratelimiter\n  --RateLimiter\ncom.xzg.ratelimiter.rule\n  --ApiLimit\n  --RuleConfig\n  --RateLimitRule\ncom.xzg.ratelimiter.alg\n  --RateLimitAlg\n</code></pre><p><strong>我们先来看下RateLimiter类。</strong>代码如下所示：</p><pre><code>public class RateLimiter {\n  private static final Logger log = LoggerFactory.getLogger(RateLimiter.class);\n  // 为每个api在内存中存储限流计数器\n  private ConcurrentHashMap&lt;String, RateLimitAlg&gt; counters = new ConcurrentHashMap&lt;&gt;();\n  private RateLimitRule rule;\n\n  public RateLimiter() {\n    // 将限流规则配置文件ratelimiter-rule.yaml中的内容读取到RuleConfig中\n    InputStream in = null;\n    RuleConfig ruleConfig = null;\n    try {\n      in = this.getClass().getResourceAsStream(&quot;/ratelimiter-rule.yaml&quot;);\n      if (in != null) {\n        Yaml yaml = new Yaml();\n        ruleConfig = yaml.loadAs(in, RuleConfig.class);\n      }\n    } finally {\n      if (in != null) {\n        try {\n          in.close();\n        } catch (IOException e) {\n          log.error(&quot;close file error:{}&quot;, e);\n        }\n      }\n    }\n\n    // 将限流规则构建成支持快速查找的数据结构RateLimitRule\n    this.rule = new RateLimitRule(ruleConfig);\n  }\n\n  public boolean limit(String appId, String url) throws InternalErrorException {\n    ApiLimit apiLimit = rule.getLimit(appId, url);\n    if (apiLimit == null) {\n      return true;\n    }\n\n    // 获取api对应在内存中的限流计数器（rateLimitCounter）\n    String counterKey = appId + &quot;:&quot; + apiLimit.getApi();\n    RateLimitAlg rateLimitCounter = counters.get(counterKey);\n    if (rateLimitCounter == null) {\n      RateLimitAlg newRateLimitCounter = new RateLimitAlg(apiLimit.getLimit());\n      rateLimitCounter = counters.putIfAbsent(counterKey, newRateLimitCounter);\n      if (rateLimitCounter == null) {\n        rateLimitCounter = newRateLimitCounter;\n      }\n    }\n\n    // 判断是否限流\n    return rateLimitCounter.tryAcquire();\n  }\n}\n</code></pre><p>RateLimiter类用来串联整个限流流程。它先读取限流规则配置文件，映射为内存中的Java对象（RuleConfig），然后再将这个中间结构构建成一个支持快速查询的数据结构（RateLimitRule）。除此之外，这个类还提供供用户直接使用的最顶层接口（limit()接口）。</p><p><strong>我们再来看下RuleConfig和ApiLimit两个类。</strong>代码如下所示：</p><pre><code>public class RuleConfig {\n  private List&lt;AppRuleConfig&gt; configs;\n\n  public List&lt;AppRuleConfig&gt; getConfigs() {\n    return configs;\n  }\n\n  public void setConfigs(List&lt;AppRuleConfig&gt; configs) {\n    this.configs = configs;\n  }\n\n  public static class AppRuleConfig {\n    private String appId;\n    private List&lt;ApiLimit&gt; limits;\n\n    public AppRuleConfig() {}\n\n    public AppRuleConfig(String appId, List&lt;ApiLimit&gt; limits) {\n      this.appId = appId;\n      this.limits = limits;\n    }\n    //...省略getter、setter方法...\n  }\n}\n\npublic class ApiLimit {\n  private static final int DEFAULT_TIME_UNIT = 1; // 1 second\n  private String api;\n  private int limit;\n  private int unit = DEFAULT_TIME_UNIT;\n\n  public ApiLimit() {}\n\n  public ApiLimit(String api, int limit) {\n    this(api, limit, DEFAULT_TIME_UNIT);\n  }\n\n  public ApiLimit(String api, int limit, int unit) {\n    this.api = api;\n    this.limit = limit;\n    this.unit = unit;\n  }\n  // ...省略getter、setter方法...\n}\n</code></pre><p>从代码中，我们可以看出来，RuleConfig类嵌套了另外两个类AppRuleConfig和ApiLimit。这三个类跟配置文件的三层嵌套结构完全对应。我把对应关系标注在了下面的示例中，你可以对照着代码看下。</p><pre><code>configs:          &lt;!--对应RuleConfig--&gt;\n- appId: app-1    &lt;!--对应AppRuleConfig--&gt;\n  limits:\n  - api: /v1/user &lt;!--对应ApiLimit--&gt;\n    limit: 100\n    unit：60\n  - api: /v1/order\n    limit: 50\n- appId: app-2\n  limits:\n  - api: /v1/user\n    limit: 50\n  - api: /v1/order\n    limit: 50\n</code></pre><p><strong>我们再来看下RateLimitRule这个类。</strong></p><p>你可能会好奇，有了RuleConfig来存储限流规则，为什么还要RateLimitRule类呢？这是因为，限流过程中会频繁地查询接口对应的限流规则，为了尽可能地提高查询速度，我们需要将限流规则组织成一种支持按照URL快速查询的数据结构。考虑到URL的重复度比较高，且需要按照前缀来匹配，我们这里选择使用Trie树这种数据结构。我举了个例子解释一下，如下图所示。左边的限流规则对应到Trie树，就是图中右边的样子。</p><p><img src=\"https://static001.geekbang.org/resource/image/1c/6b/1cf3743dd97fe52ccae5ef62c604976b.jpg\" alt=\"\"></p><p>RateLimitRule的实现代码比较多，我就不在这里贴出来了，我只给出它的定义，如下所示。如果你感兴趣的话，可以自己实现一下，也可以参看我的另一个专栏《数据结构与算法之美》的<a href=\"https://time.geekbang.org/column/article/80388?utm_term=zeusNGLWQ&amp;utm_source=xiangqingye&amp;utm_medium=geektime&amp;utm_campaign=end&amp;utm_content=xiangqingyelink1104\">第55讲</a>。在那节课中，我们对各种接口匹配算法有非常详细的讲解。</p><pre><code>public class RateLimitRule {\n  public RateLimitRule(RuleConfig ruleConfig) {\n    //...\n  }\n\n  public ApiLimit getLimit(String appId, String api) {\n    //...\n  }\n}\n</code></pre><p><strong>最后，我们看下RateLimitAlg这个类。</strong></p><p>这个类是限流算法实现类。它实现了最简单的固定时间窗口限流算法。每个接口都要在内存中对应一个RateLimitAlg对象，记录在当前时间窗口内已经被访问的次数。RateLimitAlg类的代码如下所示。对于代码的算法逻辑，你可以看下上节课中对固定时间窗口限流算法的讲解。</p><pre><code>public class RateLimitAlg {\n  /* timeout for {@code Lock.tryLock() }. */\n  private static final long TRY_LOCK_TIMEOUT = 200L;  // 200ms.\n  private Stopwatch stopwatch;\n  private AtomicInteger currentCount = new AtomicInteger(0);\n  private final int limit;\n  private Lock lock = new ReentrantLock();\n\n  public RateLimitAlg(int limit) {\n    this(limit, Stopwatch.createStarted());\n  }\n\n  @VisibleForTesting\n  protected RateLimitAlg(int limit, Stopwatch stopwatch) {\n    this.limit = limit;\n    this.stopwatch = stopwatch;\n  }\n\n  public boolean tryAcquire() throws InternalErrorException {\n    int updatedCount = currentCount.incrementAndGet();\n    if (updatedCount &lt;= limit) {\n      return true;\n    }\n\n    try {\n      if (lock.tryLock(TRY_LOCK_TIMEOUT, TimeUnit.MILLISECONDS)) {\n        try {\n          if (stopwatch.elapsed(TimeUnit.MILLISECONDS) &gt; TimeUnit.SECONDS.toMillis(1)) {\n            currentCount.set(0);\n            stopwatch.reset();\n          }\n          updatedCount = currentCount.incrementAndGet();\n          return updatedCount &lt;= limit;\n        } finally {\n          lock.unlock();\n        }\n      } else {\n        throw new InternalErrorException(&quot;tryAcquire() wait lock too long:&quot; + TRY_LOCK_TIMEOUT + &quot;ms&quot;);\n      }\n    } catch (InterruptedException e) {\n      throw new InternalErrorException(&quot;tryAcquire() is interrupted by lock-time-out.&quot;, e);\n    }\n  }\n}\n</code></pre><h2>Review最小原型代码</h2><p>刚刚给出的MVP代码，虽然总共也就200多行，但已经实现了V1版本中规划的功能。不过，从代码质量的角度来看，它还有很多值得优化的地方。现在，我们现在站在一个Code Reviewer的角度，来分析一下这段代码的设计和实现。</p><p>结合SOLID、DRY、KISS、LOD、基于接口而非实现编程、高内聚松耦合等经典的设计思想和原则，以及编码规范，我们从代码质量评判标准的角度重点剖析一下，这段代码在可读性、扩展性等方面的表现。其他方面的表现，比如复用性、可测试性等，这些你可以比葫芦画瓢，自己来进行分析。</p><p><strong>首先，我们来看下代码的可读性。</strong></p><p>影响代码可读性的因素有很多。我们重点关注目录设计（package包）是否合理、模块划分是否清晰、代码结构是否高内聚低耦合，以及是否符合统一的编码规范这几点。</p><p>因为涉及的代码不多，目录结构前面也给出了，总体来说比较简单，所以目录设计、包的划分没有问题。</p><p>按照上节课中的模块划分，RuleConfig、ApiLimit、RateLimitRule属于“限流规则”模块，负责限流规则的构建和查询。RateLimitAlg属于“限流算法”模块，提供了基于内存的单机固定时间窗口限流算法。RateLimiter类属于“集成使用”模块，作为最顶层类，组装其他类，提供执行入口（也就是调用入口）。不过，RateLimiter类作为执行入口，我们希望它只负责组装工作，而不应该包含具体的业务逻辑，所以，RateLimiter类中，从配置文件中读取限流规则这块逻辑，应该拆分出来设计成独立的类。</p><p>如果我们把类与类之间的依赖关系图画出来，你会发现，它们之间的依赖关系很简单，每个类的职责也比较单一，所以类的设计满足单一职责原则、LOD迪米特法则、高内聚松耦合的要求。</p><p>从编码规范上来讲，没有超级大的类、函数、代码块。类、函数、变量的命名基本能达意，也符合最小惊奇原则。虽然，有些命名不能一眼就看出是干啥的，有些命名采用了缩写，比如RateLimitAlg，但是我们起码能猜个八九不离十，结合注释（限于篇幅注释都没有写，并不代表不需要写），很容易理解和记忆。</p><p>总结一下，在最小原型代码中，目录设计、代码结构、模块划分、类的设计还算合理清晰，基本符合编码规范，代码的可读性不错！</p><p><strong>其次，我们再来看下代码的扩展性。</strong></p><p>实际上，这段代码最大的问题就是它的扩展性，也是我们最关注的，毕竟后续还有更多版本的迭代开发。编写可扩展代码，关键是要建立扩展意识。这就像下象棋，我们要多往前想几步，为以后做准备。在写代码的时候，我们要时刻思考，这段代码如果要扩展新的功能，那是否可以在尽量少改动代码的情况下完成，还是需要要大动干戈，推倒重写。</p><p>具体到MVP代码，不易扩展的最大原因是，没有遵循基于接口而非实现的编程思想，没有接口抽象意识。比如，RateLimitAlg类只是实现了固定时间窗口限流算法，也没有提炼出更加抽象的算法接口。如果我们要替换其他限流算法，就要改动比较多的代码。其他类的设计也有同样的问题，比如RateLimitRule。</p><p>除此之外，在RateLimiter类中，配置文件的名称、路径，是硬编码在代码中的。尽管我们说约定优于配置，但也要兼顾灵活性，能够让用户在需要的时候，自定义配置文件名称、路径。而且，配置文件的格式只支持Yaml，之后扩展其他格式，需要对这部分代码做很大的改动。</p><h2>重构最小原型代码</h2><p>根据刚刚对MVP代码的剖析，我们发现，它的可读性没有太大问题，问题主要在于可扩展性。主要的修改点有两个，一个是将RateLimiter中的规则配置文件的读取解析逻辑拆出来，设计成独立的类，另一个是参照基于接口而非实现编程思想，对于RateLimitRule、RateLimitAlg类提炼抽象接口。</p><p>按照这个修改思路，我们对代码进行重构。重构之后的目录结构如下所示。我对每个类都稍微做了说明，你可以对比着重构前的目录结构来看。</p><pre><code>// 重构前：\ncom.xzg.ratelimiter\n  --RateLimiter\ncom.xzg.ratelimiter.rule\n  --ApiLimit\n  --RuleConfig\n  --RateLimitRule\ncom.xzg.ratelimiter.alg\n  --RateLimitAlg\n  \n// 重构后：\ncom.xzg.ratelimiter\n  --RateLimiter(有所修改)\ncom.xzg.ratelimiter.rule\n  --ApiLimit(不变)\n  --RuleConfig(不变)\n  --RateLimitRule(抽象接口)\n  --TrieRateLimitRule(实现类，就是重构前的RateLimitRule）\ncom.xzg.ratelimiter.rule.parser\n  --RuleConfigParser(抽象接口)\n  --YamlRuleConfigParser(Yaml格式配置文件解析类)\n  --JsonRuleConfigParser(Json格式配置文件解析类)\ncom.xzg.ratelimiter.rule.datasource\n  --RuleConfigSource(抽象接口)\n  --FileRuleConfigSource(基于本地文件的配置类)\ncom.xzg.ratelimiter.alg\n  --RateLimitAlg(抽象接口)\n  --FixedTimeWinRateLimitAlg(实现类，就是重构前的RateLimitAlg)\n</code></pre><p>其中，RateLimiter类重构之后的代码如下所示。代码的改动集中在构造函数中，通过调用RuleConfigSource来实现了限流规则配置文件的加载。</p><pre><code>public class RateLimiter {\n  private static final Logger log = LoggerFactory.getLogger(RateLimiter.class);\n  // 为每个api在内存中存储限流计数器\n  private ConcurrentHashMap&lt;String, RateLimitAlg&gt; counters = new ConcurrentHashMap&lt;&gt;();\n  private RateLimitRule rule;\n\n  public RateLimiter() {\n    //改动主要在这里：调用RuleConfigSource类来实现配置加载\n    RuleConfigSource configSource = new FileRuleConfigSource();\n    RuleConfig ruleConfig = configSource.load();\n    this.rule = new TrieRateLimitRule(ruleConfig);\n  }\n\n  public boolean limit(String appId, String url) throws InternalErrorException, InvalidUrlException {\n    //...代码不变...\n  }\n}\n</code></pre><p>我们再来看下，从RateLimiter中拆分出来的限流规则加载的逻辑，现在是如何设计的。这部分涉及的类主要是下面几个。我把关键代码也贴在了下面。其中，各个Parser和RuleConfigSource类的设计有点类似策略模式，如果要添加新的格式的解析，只需要实现对应的Parser类，并且添加到FileRuleConfig类的PARSER_MAP中就可以了。</p><pre><code>com.xzg.ratelimiter.rule.parser\n  --RuleConfigParser(抽象接口)\n  --YamlRuleConfigParser(Yaml格式配置文件解析类)\n  --JsonRuleConfigParser(Json格式配置文件解析类)\ncom.xzg.ratelimiter.rule.datasource\n  --RuleConfigSource(抽象接口)\n  --FileRuleConfigSource(基于本地文件的配置类)\n  \npublic interface RuleConfigParser {\n  RuleConfig parse(String configText);\n  RuleConfig parse(InputStream in);\n}\n\npublic interface RuleConfigSource {\n  RuleConfig load();\n}\n\npublic class FileRuleConfigSource implements RuleConfigSource {\n  private static final Logger log = LoggerFactory.getLogger(FileRuleConfigSource.class);\n\n  public static final String API_LIMIT_CONFIG_NAME = &quot;ratelimiter-rule&quot;;\n  public static final String YAML_EXTENSION = &quot;yaml&quot;;\n  public static final String YML_EXTENSION = &quot;yml&quot;;\n  public static final String JSON_EXTENSION = &quot;json&quot;;\n\n  private static final String[] SUPPORT_EXTENSIONS =\n      new String[] {YAML_EXTENSION, YML_EXTENSION, JSON_EXTENSION};\n  private static final Map&lt;String, RuleConfigParser&gt; PARSER_MAP = new HashMap&lt;&gt;();\n\n  static {\n    PARSER_MAP.put(YAML_EXTENSION, new YamlRuleConfigParser());\n    PARSER_MAP.put(YML_EXTENSION, new YamlRuleConfigParser());\n    PARSER_MAP.put(JSON_EXTENSION, new JsonRuleConfigParser());\n  }\n\n  @Override\n  public RuleConfig load() {\n    for (String extension : SUPPORT_EXTENSIONS) {\n      InputStream in = null;\n      try {\n        in = this.getClass().getResourceAsStream(&quot;/&quot; + getFileNameByExt(extension));\n        if (in != null) {\n          RuleConfigParser parser = PARSER_MAP.get(extension);\n          return parser.parse(in);\n        }\n      } finally {\n        if (in != null) {\n          try {\n            in.close();\n          } catch (IOException e) {\n            log.error(&quot;close file error:{}&quot;, e);\n          }\n        }\n      }\n    }\n    return null;\n  }\n\n  private String getFileNameByExt(String extension) {\n    return API_LIMIT_CONFIG_NAME + &quot;.&quot; + extension;\n  }\n}\n</code></pre><h2>重点回顾</h2><p>好了，今天的内容到此就讲完了。我们一块来总结回顾一下，你需要重点掌握的内容。</p><p>优秀的代码是重构出来的，复杂的代码是慢慢堆砌出来的。小步快跑、逐步迭代是我比较推崇的开发模式。追求完美主义会让我们迟迟无法下手。所以，为了克服这个问题，一方面，我们可以规划多个小版本来开发，不断迭代优化；另一方面，在编程实现的过程中，我们可以先实现MVP代码，以此来优化重构。</p><p>如何对MVP代码优化重构呢？我们站在Code Reviewer的角度，结合SOLID、DRY、KISS、LOD、基于接口而非实现编程、高内聚松耦合等经典的设计思想和原则，以及编码规范，从代码质量评判标准的角度，来剖析代码在可读性、扩展性、可维护性、灵活、简洁、复用性、可测试性等方面的表现，并且针对性地去优化不足。</p><h2>课堂讨论</h2><ol>\n<li>针对MVP代码，如果让你做code review，你还能发现哪些问题？如果让你做重构，你还会做哪些修改和优化？</li>\n<li>如何重构代码，支持自定义限流规则配置文件名和路径？如果你熟悉Java，你可以去了解一下Spring的设计思路，看看如何借鉴到限流框架中来解决这个问题？</li>\n</ol><p>欢迎留言和我分享你的想法。如果有收获，也欢迎你把这篇文章分享给你的朋友。</p>",
                "article_title": "92 | 项目实战一：设计实现一个支持各种算法的限流框架（实现）"
            },
            {
                "title": "93 | 项目实战二：设计实现一个通用的接口幂等框架（分析）",
                "herf": "https://time.geekbang.org/column/article/245022",
                "id": "245022",
                "content": "<p>上三节课，我带你分析、设计、实现了一个接口限流框架。在分析阶段，我们讲到需求分析的两大方面，功能性需求分析和非功能性需求分析。在设计阶段，我们讲了如何通过合理的设计，在实功能性需求的前提下，满足易用、易扩展、灵活、高性能、高容错等非功能性需求。在实现阶段，我们讲了如何利用设计思想、原则、模式、编码规范等，编写可读、可扩展等高质量的代码实现。</p><p>从今天开始，我们来实战一个新的项目，开发一个通用的接口幂等框架。跟限流框架一样，我们还是分为分析、设计、实现三个部分，对应三节课来讲解。</p><p>话不多说，让我们正式开始今天的学习吧！</p><h2>需求场景</h2><p>我们先来看下幂等框架的需求场景。</p><p>还记得之前讲到的限流框架的项目背景吗？为了复用代码，我们把通用的功能设计成了公共服务平台。公司内部的其他金融产品的后台系统，会调用公共服务平台的服务，不需要完全从零开始开发。公共服务平台提供的是RESTful接口。为了简化开发，调用方一般使用Feign框架（一个HTTP框架）来访问公共服务平台的接口。</p><p>调用方访问公共服务平台的接口，会有三种可能的结果：成功、失败和超时。前两种结果非常明确，调用方可以自己决定收到结果之后如何处理。结果为“成功”，万事大吉。结果为“失败”，一般情况下，调用方会将失败的结果，反馈给用户（移动端App），让用户自行决定是否重试。</p><!-- [[[read_end]]] --><p>但是，当接口请求超时时，处理起来就没那么容易了。有可能业务逻辑已经执行成功了，只是公共服务平台返回结果给调用方的时候超时了，但也有可能业务逻辑没有执行成功，比如，因为数据库当时存在集中写入，导致部分数据写入超时。总之，超时对应的执行结果是未决的。那调用方调用接口超时时（基于Feign框架开发的话，一般是收到Timeout异常），该如何处理呢？</p><p>如果接口只包含查询、删除、更新这些操作，那接口天然是幂等的。所以，超时之后，重新再执行一次，也没有任何副作用。不过，这里有两点需要特殊说明一下。</p><p>删除操作需要当心ABA问题。删除操作超时了，又触发一次删除，但在这次删除之前，又有一次新的插入。后一次删除操作删除了新插入的数据，而新插入的数据本不应该删除。不过，大部分业务都可以容忍ABA问题。对于少数不能容忍的业务场景，我们可以针对性的特殊处理。</p><p>除此之外，细究起来，update x = x+delta这样格式的更新操作并非幂等，只有update x=y这样格式的更新操作才是幂等的。不过，后者也存在跟删除同样的ABA问题。</p><p>如果接口包含修改操作（插入操作、update x=x+delta更新操作），多次重复执行有可能会导致业务上的错误，这是不能接受的。如果插入的数据包含数据库唯一键，可以利用数据库唯一键的排他性，保证不会重复插入数据。除此之外，一般我会建议调用方按照这样几种方式来处理。</p><p><strong>第一种处理方式</strong>是，调用方访问公共服务平台接口超时时，返回清晰明确的提醒给用户，告知执行结果未知，让用户自己判断是否重试。不过，你可能会说，如果用户看到了超时提醒，但还是重新发起了操作，比如重新发起了转账、充值等操作，那该怎么办呢？实际上，对这种情况，技术是无能为力的。因为两次操作都是用户主动发起的，我们无法判断第二次的转账、充值是新的操作，还是基于上一次超时的重试行为。</p><p><strong>第二种处理方式</strong>是，调用方调用其他接口，来查询超时操作的结果，明确超时操作对应的业务，是执行成功了还是失败了，然后再基于明确的结果做处理。但是这种处理方法存在一个问题，那就是并不是所有的业务操作，都方便查询操作结果。</p><p><strong>第三种处理方式</strong>是，调用方在遇到接口超时之后，直接发起重试操作。这样就需要接口支持幂等。我们可以选择在业务代码中触发重试，也可以将重试的操作放到Feign框架中完成。因为偶尔发生的超时，在正常的业务逻辑中编写一大坨补救代码，这样做会影响到代码的可读性，有点划不来。当然，如果项目中需要支持超时重试的业务不多，那对于仅有几个业务，特殊处理一下也未尝不可。但是，如果项目中需要支持超时重试的业务比较多，我们最好是把超时重试这些非业务相关的逻辑，统一在框架层面解决。</p><p>对响应时间敏感的调用方来说，它们服务的是移动端的用户，过长的等待时间，还不如直接返回超时给用户。所以，这种情况下，第一种处理方式是比较推荐的。但是，对响应时间不敏感的调用方来说，比如Job类的调用方，我推荐选择后两种处理方式，能够提高处理的成功率。而第二种处理方法，本身有一定的局限性，因为并不是所有业务操作都方便查询是否执行成功。第三种保证接口幂等的处理方式，是比较通用的解决方案。所以，我们针对这种处理方式，抽象出一套统一的幂等框架，简化幂等接口的开发。</p><h2>需求分析</h2><p>刚刚我们介绍了幂等框架的需求背景：超时重试需要接口幂等的支持。接下来，我们再对需求进行更加详细的分析和整理，这其中就包括功能性需求和非功能性需求。</p><p><strong>不过，在此之前，我们需要先搞清楚一个重要的概念：幂等号。</strong></p><p>前面多次提到“幂等”，那“幂等”到底是什么意思呢？放到接口调用的这个场景里，幂等的意思是，针对同一个接口，多次发起同一个业务请求，必须保证业务只执行一次。那如何判定两次接口请求是同一个业务请求呢？也就是说，如何判断两次接口请求是重试关系？而非独立的两个业务请求？比如，两次调用转账接口，尽管转账用户、金额等参数都一样，但我们也无法判断这两个转账请求就是重试关系。</p><p>实际上，要确定重试关系，我们就需要给同一业务请求一个唯一标识，也就是“幂等号”！如果两个接口请求，带有相同的幂等号，那我们就判断它们是重试关系，是同一个业务请求，不要重复执行。</p><p>幂等号需要保证全局唯一性。它可以有业务含义，比如，用户手机号码是唯一的，对于用户注册接口来说，我们可以拿它作为幂等号。不过，这样就会导致幂等框架的实现，无法完全脱离具体的业务。所以，我们更加倾向于，通过某种算法来随机生成没有业务含义的幂等号。</p><p><strong>幂等号的概念搞清楚了，我们再来看下框架的功能性需求。</strong></p><p>前面也介绍了一些需求分析整理方法，比如画线框图、写用户用例、基于测试驱动开发等。跟限流框架类似，这里我们也借助用户用例和测试驱动开发的思想，先去思考，如果框架最终被开发出来之后，它会如何被使用。我写了一个框架使用的Demo示例，如下所示。</p><pre><code>///////// 使用方式一: 在业务代码中处理幂等 ////////////\n// 接口调用方\nIdempotence idempotence = new Idempotence();\nString idempotenceId = idempotence.createId();\nOrder order = createOrderWithIdempotence(..., idempotenceId);\n\n// 接口实现方\npublic class OrderController {\n  private Idempotence idempontence; // 依赖注入\n  \n  public Order createOrderWithIdempotence(..., String idempotenceId) {\n    // 前置操作\n    boolean existed = idempotence.check(idempotenceId);\n    if (existed) {\n      // 两种处理方式：\n      // 1. 查询order，并且返回；\n      // 2. 返回duplication operation Exception\n    }\n    idempotence.record(idempotenceId);\n        \n    //...执行正常业务逻辑\n  }\n  \n  public Order createOrder(...) {\n    //...\n  }\n}\n\n///////// 使用方式二：在框架层面处理幂等 //////////////\n// 接口调用方\nIdempotence idempotence = new Idempotence();\nString idempotenceId = idempotence.createId();\n//...通过feign框架将幂等号添加到http header中...\n\n// 接口实现方\npublic class OrderController {\n  @IdempotenceRequired\n  public Order createOrder(...) {\n    //...\n  }\n}\n\n// 在AOP切面中处理幂等\n@Aspect\npublic class IdempotenceSupportAdvice {\n  @Autowired\n  private Idempotence idempotence;\n\n@Pointcut(&quot;@annotation(com.xzg.cd.idempotence.annotation.IdempotenceRequired)&quot;)\n  public void controllerPointcut() {\n  }\n\n  @Around(value = &quot;controllerPointcut()&quot;)\n  public Object around(ProceedingJoinPoint joinPoint) throws Throwable {\n    // 从HTTP header中获取幂等号idempotenceId\n    \n    // 前置操作\n    boolean existed = idempotence.check(idempotenceId);\n    if (existed) {\n      // 两种处理方式：\n      // 1. 查询order，并且返回；\n      // 2. 返回duplication operation Exception\n    }\n    idempotence.record(idempotenceId)\n    \n    Object result = joinPoint.proceed();    \n    return result;\n  }\n}\n</code></pre><p>结合刚刚的Demo，从使用的角度来说，幂等框架的主要处理流程是这样的。接口调用方生成幂等号，并且跟随接口请求，将幂等号传递给接口实现方。接口实现方接收到接口请求之后，按照约定，从HTTP Header或者接口参数中，解析出幂等号，然后通过幂等号查询幂等框架。如果幂等号已经存在，说明业务已经执行或正在执行，则直接返回；如果幂等号不存在，说明业务没有执行过，则记录幂等号，继续执行业务。</p><p><strong>对于幂等框架，我们再来看下，它都有哪些非功能性需求。</strong></p><p>在易用性方面，我们希望框架接入简单方便，学习成本低。只需编写简单的配置以及少许代码，就能完成接入。除此之外，框架最好对业务代码低侵入松耦合，在统一的地方（比如Spring AOP中）接入幂等框架，而不是将它耦合在业务代码中。</p><p>在性能方面，针对每个幂等接口，在正式处理业务逻辑之前，我们都要添加保证幂等的处理逻辑。这或多或少地会增加接口请求的响应时间。而对于响应时间比较敏感的接口服务来说，我们要让幂等框架尽可能低延迟，尽可能减少对接口请求本身响应时间的影响。</p><p>在容错性方面，跟限流框架相同，不能因为幂等框架本身的异常，导致接口响应异常，影响服务本身的可用性。所以，幂等框架要有高度的容错性。比如，存储幂等号的外部存储器挂掉了，幂等逻辑无法正常运行，这个时候业务接口也要能正常服务才行。</p><h2>重点回顾</h2><p>好了，今天的内容到此就讲完了。我们一块来总结回顾一下，你需要重点掌握的内容。</p><p>今天我们介绍了幂等框架的一个需求场景，那就是接口超时重试。大部分情况下，如果接口只包含查询、删除、更新这些操作，那接口天然是幂等的。除此之外，如果接口包含修改操作（插入操作或update x=x+delta更新操作），保证接口的幂等性就需要做一些额外的工作。</p><p>现在开源的东西那么多，但幂等框架非常少见。原因是幂等性的保证是业务强相关的。大部分保证幂等性的方式都是针对具体的业务具体处理，比如利用业务数据中的ID唯一性来处理插入操作的幂等性。但是，针对每个需要幂等的业务逻辑，单独编写代码处理，一方面对程序员的开发能力要求比较高，另一方面开发成本也比较高。</p><p>为了简化接口幂等的开发，我们希望开发一套统一的幂等框架，脱离具体的业务，让程序员通过简单的配置和少量代码，就能将非幂等接口改造成幂等接口。</p><h2>课堂讨论</h2><ol>\n<li>重试无处不在，比如，Nginx、Dubbo、Feign等重试机制，你还能想到哪些其他的重试场景吗？</li>\n<li>超时重试只是接口幂等的一个需求场景。除此之外，处理消息队列中消息重复的一种常用方法，就是将消息对应的业务逻辑设计成幂等的。因为业务逻辑是幂等的，所以多次接收重复消息不会导致重复执行业务逻辑。除了这些场景，你还知道有哪些其他场景需要用到幂等设计？</li>\n</ol><p>欢迎留言和我分享你的想法。如果有收获，也欢迎你把这篇文章分享给你的朋友。</p>",
                "article_title": "93 | 项目实战二：设计实现一个通用的接口幂等框架（分析）"
            },
            {
                "title": "94 | 项目实战二：设计实现一个通用的接口幂等框架（设计）",
                "herf": "https://time.geekbang.org/column/article/245788",
                "id": "245788",
                "content": "<p>上一节课，我们介绍了幂等框架的一个重要需求场景，接口超时重试。为了避免同一业务被多次重复执行，接口需要支持幂等特性。同时，我们还对功能性需求和非功能性需求做了梳理。今天，我们来讲解幂等框架的设计思路。</p><p>跟限流框架类似，幂等框架的功能性需求也比较简单，但要考虑处理的异常情况有很多，比如业务代码异常、业务系统宕机、幂等框架异常。今天，我们重点讲解如何应对这些异常情况，设计一个高度容错的幂等框架。</p><p>话不多说，让我们正式开始今天的学习吧！</p><h2>幂等处理正常流程</h2><p>调用方从发起接口请求到接收到响应，一般要经过三个阶段。第一个阶段是调用方发送请求并被实现方接收，第二个阶段是执行接口对应的业务逻辑，第三个阶段是将执行结果返回给调用方。为了实现接口幂等，我们需要将幂等相关的逻辑，添加在这三个阶段中。</p><p>正常情况下，幂等号随着请求传递到接口实现方之后，接口实现方将幂等号解析出来，传递给幂等框架。幂等框架先去数据库（比如Redis）中查找这个幂等号是否已经存在。如果存在，说明业务逻辑已经或者正在执行，就不要重复执行了。如果幂等号不存在，就将幂等号存储在数据库中，然后再执行相应的业务逻辑。</p><p>正常情况下，幂等处理流程是非常简单的，难点在于如何应对异常情况。在这三个阶段中，如果第一个阶段出现异常，比如发送请求失败或者超时，幂等号还没有记录下来，重试请求会被执行，符合我们的预期。如果第三个阶段出现异常，业务逻辑执行完成了，只是在发送结果给调用方的时候，失败或者超时了，这个时候，幂等号已经记录下来，重试请求不会被执行，也符合我们的预期。也就是说，第一、第三阶段出现异常，上述的幂等处理逻辑都可以正确应对。</p><!-- [[[read_end]]] --><p>但是，如果第二个阶段业务执行的过程出现异常，处理起来就复杂多了。接下来，我们就看下幂等框架该如何应对这一阶段的各种异常。我分了三类异常来讲解，它们分别是业务代码异常、业务系统宕机、幂等框架异常。</p><h2>业务代码异常处理</h2><p>当业务代码在执行过程中抛出异常的时候，我们是否应该认定为业务处理失败，然后将已经记录的幂等号删除，允许重新执行业务逻辑呢？</p><p>对于这个问题，我们要分业务异常和系统异常来区分对待。那什么是业务异常？什么是系统异常呢？我举个例子解释一下。比如，A用户发送消息给B用户，但是查询B用户不存在，抛出UserNotExisting异常，我们把这种业务上不符合预期叫做业务异常。因为数据库挂掉了，业务代码访问数据库时，就会报告数据库异常，我们把这种非业务层面的、系统级的异常，叫做系统异常。</p><p>遇到业务异常（比如UserNotExisting异常），我们不删除已经记录的幂等号，不允许重新执行同样的业务逻辑，因为再次重新执行也是徒劳的，还是会报告异常。相反，遇到系统异常（比如数据库访问异常），我们将已经记录的幂等号删除，允许重新执行这段业务逻辑。因为在系统级问题修复之后（比如数据库恢复了），重新执行之前失败的业务逻辑，就有可能会成功。</p><p>实际上，为了让幂等框架尽可能的灵活，低侵入业务逻辑，发生异常（不管是业务异常还是系统异常），是否允许再重试执行业务逻辑，交给开发这块业务的工程师来决定是最合适的了，毕竟他最清楚针对每个异常该如何处理。而幂等框架本身不参与这个决定，它只需要提供删除幂等号的接口，由业务工程师来决定遇到异常的时候，是否需要调用这个删除接口，删除已经记录的幂等号。</p><h2>业务系统宕机处理</h2><p>刚刚分析的是代码异常，我们再来看下，如果在业务处理的过程中，业务系统宕机了（你可以简单理解为部署了业务系统的机器宕机了），幂等框架是否还能正确工作呢？</p><p>如果幂等号已经记录下了，但是因为机器宕机，业务还没来得及执行，按照刚刚的幂等框架的处理流程，即便机器重启，业务也不会再被触发执行了，这个时候该怎么办呢？除此之外，如果记录幂等号成功了，但是在捕获到系统异常之后，要删除幂等号之前，机器宕机了，这个时候又该怎么办？</p><p>如果希望幂等号的记录和业务的执行完全一致，我们就要把它们放到一个事务中。执行成功，必然会记录幂等号；执行失败，幂等号记录也会被自动回滚。因为幂等框架和业务系统各自使用独立的数据库来记录数据，所以，这里涉及的事务属于分布式事务。如果为了解决这个问题，引入分布式事务，那幂等框架的开发难度提高了很多，并且框架使用起来也复杂了很多，性能也会有所损失。</p><p>针对这个问题，我们还有另外一种解决方案。那就是，在存储业务数据的业务数据库（ 比如MySQL）中，建一张表来记录幂等号。幂等号先存储到业务数据库中，然后再同步给幂等框架的Redis数据库。这样做的好处是，我们不需要引入分布式事务框架，直接利用业务数据库本身的事务属性，保证业务数据和幂等号的写入操作，要么都成功，要么都失败。不过，这个解决方案会导致幂等逻辑，跟业务逻辑没有完全解耦，不符合我们之前讲到的低侵入、松耦合的设计思想。</p><p>实际上，做工程不是做理论。对于这种极少发生的异常，在工程中，我们能够做到，在出错时能及时发现问题、能够根据记录的信息人工修复就可以了。虽然看起来解决方案不优雅，不够智能，不够自动化，但是，这比编写一大坨复杂的代码逻辑来解决，要好使得多。所以，我们建议业务系统记录SQL的执行日志，在日志中附加上幂等号。这样我们就能在机器宕机时，根据日志来判断业务执行情况和幂等号的记录是否一致。</p><h2>幂等框架异常处理</h2><p>我们前面提到，限流框架本身的异常，不能导致接口响应异常。那对于幂等框架来说，是否也适用这条设计原则呢？</p><p>对于限流来说，限流框架执行异常（比如，Redis访问超时或者访问失败），我们可以触发服务降级，让限流功能暂时不起作用，接口还能正常执行。如果大量的限流接口调用异常，在具有完善监控的情况下，这些异常很快就会被运维发现并且修复，所以，短暂的限流失效，也不会对业务系统产生太多影响。毕竟限流只是一个针对突发情况的保护机制，平时并不起作用。如果偶尔的极个别的限流接口调用异常，本不应该被放过的几个接口请求，因为限流的暂时失效被放过了，对于这种情况，绝大部分业务场景都是可以接受的。毕竟限流不可能做到非常精确，多放过一两个接口请求几乎没影响。</p><p>对于幂等来说，尽管它应对的也是超时重试等特殊场景，但是，如果本不应该重新执行的业务逻辑，因为幂等功能的暂时失效，被重复执行了，就会导致业务出错（比如，多次执行转账，钱多转了）。对于这种情况，绝大部分业务场景都是无法接受的。所以，在幂等逻辑执行异常时，我们选择让接口请求也失败，相应的业务逻辑就不会被重复执行了。毕竟接口请求失败（比如转钱没转成功），比业务执行出错（比如多转了钱），修复的成本要低很多。</p><h2>重点回顾</h2><p>好了，今天的内容到此就讲完了。我们一块来总结回顾一下，你需要重点掌握的内容。</p><p>今天，我们讲解了幂等框架的设计思路。在正常情况下，幂等框架的处理流程是比较简单的，调用方生成幂等号，传递给实现方，实现方记录幂等号或者用幂等号判重。但是，幂等框架要处理的异常情况很多，这也是设计的复杂之处和难点之处。</p><p>我们针对三种不同类型的异常，讲解了幂等框架的应对思路。</p><p>对于业务代码异常，为了让幂等框架尽可能的灵活，低侵入业务逻辑，发生异常（不管是业务异常还是系统异常），是否允许再重试执行业务逻辑，交给开发这块业务的工程师来决定。</p><p>对于业务系统宕机，对于这种极少发生的异常，在工程中，我们能够做到，在出错时能及时发现问题、能够根据记录的信息人工修复，就可以了。所以，我们建议业务系统记录SQL的执行日志，在日志中附加上幂等号。这样我们就能在机器宕机时，根据日志来判断业务执行情况和幂等号的记录是否一致。</p><p>对于幂等框架异常，跟限流框架异常处理对策不同，在幂等逻辑执行异常时，我们选择让接口请求也失败，相应的业务逻辑就不会被重复执行了，业务就不会出错。毕竟接口请求失败，比业务执行出错，修复的成本要低很多。</p><p>虽然幂等框架要处理的异常很多，但考虑到开发成本以及简单易用性，我们对某些异常的处理在工程上做了妥协，交由业务系统或者人工介入处理。这样就大大简化了幂等框架开发的复杂度和难度。</p><h2>课堂讨论</h2><p>我常说，异常情况考虑是否全面，处理是否得当，很能体现一个程序员的逻辑思维能力、工程能力。除了我们今天讲到的异常，在幂等框架中，你还能想到有哪些其他异常情况会发生？又该如何应对呢？</p><p>欢迎留言和我分享你的想法。如果有收获，也欢迎你把这篇文章分享给你的朋友。</p>",
                "article_title": "94 | 项目实战二：设计实现一个通用的接口幂等框架（设计）"
            },
            {
                "title": "95 | 项目实战二：设计实现一个通用的接口幂等框架（实现）",
                "herf": "https://time.geekbang.org/column/article/246379",
                "id": "246379",
                "content": "<p>上一节课，我们讲解了幂等框架的设计思路。在正常情况下，幂等框架的处理流程是比较简单的。调用方生成幂等号，传递给实现方，实现方记录幂等号或者用幂等号判重。但是，幂等框架要处理的异常情况很多，这也是设计的复杂之处和难点之处。比如，代码运行异常、业务系统宕机、幂等框架异常。</p><p>虽然幂等框架要处理的异常很多，但考虑到开发成本以及简单易用性，我们对某些异常的处理在工程上做了妥协，交由业务系统或者人工介入处理。这样就大大简化了幂等框架开发的复杂度和难度。</p><p>今天，我们针对幂等框架的设计思路，讲解如何编码实现。跟限流框架的讲解相同，对于幂等框架，我们也会还原它的整个开发过程，从V1版本需求、最小原型代码讲起，然后讲解如何review代码发现问题、重构代码解决问题，最终得到一份易读、易扩展、易维护、灵活、可测试的高质量代码实现。</p><p>话不多说，让我们正式开始今天的学习吧！</p><h2>V1版本功能需求</h2><p>上一节课给出的设计思路比较零散，重点还是在讲设计的缘由，为什么要这么设计。今天，我们再重新整理一下，经过上一节课的分析梳理最终得到的设计思路。虽然上一节课的分析很复杂、很烧脑，但思从深而行从简，最终得到的幂等框架的设计思路是很简单的，主要包含下面这样两个主要的功能开发点：</p><!-- [[[read_end]]] --><ul>\n<li>实现生成幂等号的功能；</li>\n<li>实现存储、查询、删除幂等号的功能。</li>\n</ul><p>因为功能非常简单，所以，我们就不再进一步裁剪了。在V1版本中，我们会实现上面罗列的所有功能。针对这两个功能点，我们先来说下实现思路。</p><p><strong>我们先来看，如何生成幂等号。</strong></p><p>幂等号用来标识两个接口请求是否是同一个业务请求，换句话说，两个接口请求是否是重试关系，而非独立的两个请求。接口调用方需要在发送接口请求的同时，将幂等号一块传递给接口实现方。那如何来生成幂等号呢？一般有两种生成方式。一种方式是集中生成并且分派给调用方，另一种方式是直接由调用方生成。</p><p>对于第一种生成方式，我们需要部署一套幂等号的生成系统，并且提供相应的远程接口（Restful或者RPC接口），调用方通过调用远程接口来获取幂等号。这样做的好处是，对调用方完全隐藏了幂等号的实现细节。当我们需要改动幂等号的生成算法时，调用方不需要改动任何代码。</p><p>对于第二种生成方式，调用方按照跟接口实现方预先商量好的算法，自己来生成幂等号。这种实现方式的好处在于，不用像第一种方式那样调用远程接口，所以执行效率更高。但是，一旦需要修改幂等号的生成算法，就需要修改每个调用方的代码。</p><p>并且，每个调用方自己实现幂等号的生成算法也会有问题。一方面，重复开发，违反DRY原则。另一方面，工程师的开发水平层次不齐，代码难免会有bug。除此之外，对于复杂的幂等号生成算法，比如依赖外部系统Redis等，显然更加适合上一种实现方式，可以避免调用方为了使用幂等号引入新的外部系统。</p><p>权衡来讲，既考虑到生成幂等号的效率，又考虑到代码维护的成本，我们选择第二种实现方式，并且在此基础上做些改进，由幂等框架来统一提供幂等号生成算法的代码实现，并封装成开发类库，提供给各个调用方复用。除此之外，我们希望生成幂等号的算法尽可能的简单，不依赖其他外部系统。</p><p>实际上，对于幂等号的唯一要求就是全局唯一。全局唯一ID的生成算法有很多。比如，简单点的有取UUID，复杂点的可以把应用名拼接在UUID上，方便做问题排查。总体上来讲，幂等号的生成算法并不难。</p><p><strong>我们再来看，如何实现幂等号的存储、查询和删除。</strong></p><p>从现在的需求来看，幂等号只是为了判重。在数据库中，我们只需要存储一个幂等号就可以，不需要太复杂的存储结构，所以，我们不选择使用复杂的关系型数据库，而是选择使用更加简单的、读写更加快速的键值数据库，比如Redis。</p><p>在幂等判重逻辑中，我们需要先检查幂等号是否存在。如果没有存在，再将幂等号存储进Redis。多个线程（同一个业务实例的多个线程）或者多进程（多个业务实例）同时执行刚刚的“检查-设置”逻辑时，就会存在竞争关系（竞态，race condition）。比如，A线程检查幂等号不存在，在A线程将幂等号存储进Redis之前，B线程也检查幂等号不存在，这样就会导致业务被重复执行。为了避免这种情况发生，我们要给“检查-设置”操作加锁，让同一时间只有一个线程能执行。除此之外，为了避免多进程之间的竞争，普通的线程锁还不起作用，我们需要分布式锁。</p><p>引入分布式锁会增加开发的难度和复杂度，而Redis本身就提供了把“检查-设置”操作作为原子操作执行的命令：setnx(key, value)。它先检查key是否存在，如果存在，则返回结果0；如果不存在，则将key值存下来，并将值设置为value，返回结果1。因为Redis本身是单线程执行命令的，所以不存在刚刚讲到的并发问题。</p><h2>最小原型代码实现</h2><p>V1版本要实现的功能和实现思路，现在已经很明确了。现在，我们来看下具体的代码实现。还是跟限流框架同样的实现方法，我们先不考虑设计和代码质量，怎么简单怎么来，先写出MVP代码，然后基于这个最简陋的版本做优化重构。</p><p>V1版本的功能非常简单，我们用一个类就能搞定，代码如下所示。只用了不到30行代码，就搞定了一个框架，是不是觉得有点不可思议。对于这段代码，你可以先思考下，有哪些值得优化的地方。</p><pre><code>public class Idempotence {\n  private JedisCluster jedisCluster;\n\n  public Idempotence(String redisClusterAddress, GenericObjectPoolConfig config) {\n    String[] addressArray= redisClusterAddress.split(&quot;;&quot;);\n    Set&lt;HostAndPort&gt; redisNodes = new HashSet&lt;&gt;();\n    for (String address : addressArray) {\n      String[] hostAndPort = address.split(&quot;:&quot;);\n      redisNodes.add(new HostAndPort(hostAndPort[0], Integer.valueOf(hostAndPort[1])));\n    }\n    this.jedisCluster = new JedisCluster(redisNodes, config);\n  }\n  \n  public String genId() {\n    return UUID.randomUUID().toString();\n  }\n\n  public boolean saveIfAbsent(String idempotenceId) {\n    Long success = jedisCluster.setnx(idempotenceId, &quot;1&quot;);\n    return success == 1;\n  }\n\n  public void delete(String idempotenceId) {\n    jedisCluster.del(idempotenceId);\n  }\n}\n</code></pre><h2>Review最小原型代码</h2><p>尽管MVP代码很少，但仔细推敲，也有很多值得优化的地方。现在，我们就站在Code Reviewer的角度，分析一下这段代码。我把我的所有意见都放到代码注释中了，你可以对照着代码一块看下。</p><pre><code>public class Idempotence {\n  // comment-1: 如果要替换存储方式，是不是很麻烦呢？\n  private JedisCluster jedisCluster;\n\n  // comment-2: 如果幂等框架要跟业务系统复用jedisCluster连接呢？\n  // comment-3: 是不是应该注释说明一下redisClusterAddress的格式，以及config是否可以传递进null呢？\n  public Idempotence(String redisClusterAddress, GenericObjectPoolConfig config) {\n    // comment-4: 这段逻辑放到构造函数里，不容易写单元测试呢\n    String[] addressArray= redisClusterAddress.split(&quot;;&quot;);\n    Set&lt;HostAndPort&gt; redisNodes = new HashSet&lt;&gt;();\n    for (String address : addressArray) {\n      String[] hostAndPort = address.split(&quot;:&quot;);\n      redisNodes.add(new HostAndPort(hostAndPort[0], Integer.valueOf(hostAndPort[1])));\n    }\n    this.jedisCluster = new JedisCluster(redisNodes, config);\n  }\n  \n  // comment-5: generateId()是不是比缩写要好点？\n  // comment-6: 根据接口隔离原则，这个函数跟其他函数的使用场景完全不同，这个函数主要用在调用方，其他函数用在实现方，是不是应该分别放到两个类中？\n  public String genId() {\n    return UUID.randomUUID().toString();\n  }\n\n  // comment-7: 返回值的意义是不是应该注释说明一下？\n  public boolean saveIfAbsent(String idempotenceId) {\n    Long success = jedisCluster.setnx(idempotenceId, &quot;1&quot;);\n    return success == 1;\n  }\n\n  public void delete(String idempotenceId) {\n    jedisCluster.del(idempotenceId);\n  }\n}\n</code></pre><p>总结一下，MVP代码主要涉及下面这样几个问题。</p><ul>\n<li><strong>代码可读性问题</strong>：有些函数的参数和返回值的格式和意义不够明确，需要注释补充解释一下。genId()函数使用了缩写，全拼generateId()可能更好些！</li>\n<li><strong>代码可扩展性问题</strong>：按照现在的代码实现方式，如果改变幂等号的存储方式和生成算法，代码修改起来会比较麻烦。除此之外，基于接口隔离原则，我们应该将genId()函数跟其他函数分离开来，放到两个类中。独立变化，隔离修改，更容易扩展！</li>\n<li><strong>代码可测试性问题</strong>：解析Redis Cluster地址的代码逻辑较复杂，但因为放到了构造函数中，无法对它编写单元测试。</li>\n<li><strong>代码灵活性问题</strong>：业务系统有可能希望幂等框架复用已经建立好的jedisCluster，而不是单独给幂等框架创建一个jedisCluster。</li>\n</ul><h2>重构最小原型代码</h2><p>实际上，问题找到了，修改起来就容易多了。针对刚刚罗列的几个问题，我们对MVP代码进行重构，重构之后的代码如下所示。</p><pre><code>// 代码目录结构\ncom.xzg.cd.idempotence\n --Idempotence\n --IdempotenceIdGenerator(幂等号生成类)\n --IdempotenceStorage(接口：用来读写幂等号)\n --RedisClusterIdempotenceStorage(IdempotenceStorage的实现类)\n\n// 每个类的代码实现\npublic class Idempotence {\n  private IdempotenceStorage storage;\n\n  public Idempotence(IdempotenceStorage storage) {\n    this.storage = storage;\n  }\n\n  public boolean saveIfAbsent(String idempotenceId) {\n    return storage.saveIfAbsent(idempotenceId);\n  }\n\n  public void delete(String idempotenceId) {\n    storage.delete(idempotenceId);\n  }\n}\n\npublic class IdempotenceIdGenerator {\n  public String generateId() {\n    return UUID.randomUUID().toString();\n  }\n}\n\npublic interface IdempotenceStorage {\n  boolean saveIfAbsent(String idempotenceId);\n  void delete(String idempotenceId);\n}\n\npublic class RedisClusterIdempotenceStorage implements IdempotenceStorage {\n  private JedisCluster jedisCluster;\n\n  /**\n   * Constructor\n   * @param redisClusterAddress the format is 128.91.12.1:3455;128.91.12.2:3452;289.13.2.12:8978\n   * @param config should not be null\n   */\n  public RedisIdempotenceStorage(String redisClusterAddress, GenericObjectPoolConfig config) {\n    Set&lt;HostAndPort&gt; redisNodes = parseHostAndPorts(redisClusterAddress);\n    this.jedisCluster = new JedisCluster(redisNodes, config);\n  }\n\n  public RedisIdempotenceStorage(JedisCluster jedisCluster) {\n    this.jedisCluster = jedisCluster;\n  }\n\n  /**\n   * Save {@idempotenceId} into storage if it does not exist.\n   * @param idempotenceId the idempotence ID\n   * @return true if the {@idempotenceId} is saved, otherwise return false\n   */\n  public boolean saveIfAbsent(String idempotenceId) {\n    Long success = jedisCluster.setnx(idempotenceId, &quot;1&quot;);\n    return success == 1;\n  }\n\n  public void delete(String idempotenceId) {\n    jedisCluster.del(idempotenceId);\n  }\n\n  @VisibleForTesting\n  protected Set&lt;HostAndPort&gt; parseHostAndPorts(String redisClusterAddress) {\n    String[] addressArray= redisClusterAddress.split(&quot;;&quot;);\n    Set&lt;HostAndPort&gt; redisNodes = new HashSet&lt;&gt;();\n    for (String address : addressArray) {\n      String[] hostAndPort = address.split(&quot;:&quot;);\n      redisNodes.add(new HostAndPort(hostAndPort[0], Integer.valueOf(hostAndPort[1])));\n    }\n    return redisNodes;\n  }\n}\n</code></pre><p>接下来，我再总结罗列一下，针对之前发现的问题，我们都做了哪些代码改动。主要有下面这样几点，你可以结合着代码一块看下。</p><p><strong>在代码可读性方面，</strong>我们对构造函数、saveIfAbsense()函数的参数和返回值做了注释，并且将genId()函数改为全拼generateId()。不过，对于这个函数来说，缩写实际上问题也不大。</p><p><strong>在代码可扩展性方面，</strong>我们按照基于接口而非实现的编程原则，将幂等号的读写独立出来，设计成IdempotenceStorage接口和RedisClusterIdempotenceStorage实现类。RedisClusterIdempotenceStorage实现了基于Redis Cluster的幂等号读写。如果我们需要替换新的幂等号读写方式，比如基于单个Redis而非Redis Cluster，我们就可以再定义一个实现了IdempotenceStorage接口的实现类：RedisIdempotenceStorage。</p><p>除此之外，按照接口隔离原则，我们将生成幂等号的代码抽离出来，放到IdempotenceIdGenerator类中。这样，调用方只需要依赖这个类的代码就可以了。幂等号生成算法的修改，跟幂等号存储逻辑的修改，两者完全独立，一个修改不会影响另外一个。</p><p><strong>在代码可测试性方面，</strong>我们把原本放在构造函数中的逻辑抽离出来，放到了parseHostAndPorts()函数中。这个函数本应该是Private访问权限的，但为了方便编写单元测试，我们把它设置为成了Protected访问权限，并且通过注解@VisibleForTesting做了标明。</p><p><strong>在代码灵活性方面，</strong>为了方便复用业务系统已经建立好的jedisCluster，我们提供了一个新的构造函数，支持业务系统直接传递jedisCluster来创建Idempotence对象。</p><h2>重点回顾</h2><p>好了，今天的内容到此就讲完了。我们一块来总结回顾一下，你需要重点掌握的内容。</p><p>我们前面花了两节课的时间，用很大的篇幅在讲需求和设计，特别是设计的缘由。而真正到了实现环节，我们只用了不到30行代码，就实现了幂等框架。这就很好体现了“思从深而行从简”的道理。对于不到30行代码，很多人觉得不大可能有啥优化空间了，但我们今天还是提出了7个优化建议，并且对代码结构做了比较大的调整。这说明，只要仔细推敲，再小的代码都有值得优化的地方。</p><p>不过，之前有人建议我举一些大型项目中的例子，最好是上万行代码的那种，不要举这种几十行的小例子。大项目和小项目在编码这个层面，实际上没有太大区别。再宏大的工程、再庞大的项目，也是一行一行写出来的。那些上来就要看上万行代码，分析庞大项目的，大部分都还没有理解编码的精髓。编码本身就是一个很细节的事情，牛不牛也都隐藏在一行一行的代码中。空谈架构、设计、大道理，实际上没有太多意义，对你帮助不大。能沉下心来把细节都做好那才是真的牛！</p><h2>课堂讨论</h2><ol>\n<li>针对MVP代码，我有两个问题留给你思考。其中一个问题是，delete()是应该返回void值还是boolean值？如果删除出错，应该如何处理？另一个问题是，需不需要给幂等号生成算法抽象出一个接口呢？为什么？</li>\n<li>在后续的版本规划中，你觉得幂等框架还可以继续扩展哪些功能？或者做哪些优化？如果让你规划第二个版本，你会做哪些东西？</li>\n</ol><p>欢迎留言和我分享你的想法。如果有收获，也欢迎你把这篇文章分享给你的朋友。</p>",
                "article_title": "95 | 项目实战二：设计实现一个通用的接口幂等框架（实现）"
            },
            {
                "title": "96 | 项目实战三：设计实现一个支持自定义规则的灰度发布组件（分析）",
                "herf": "https://time.geekbang.org/column/article/247776",
                "id": "247776",
                "content": "<p>到现在为止，我已经带你学习了接口限流框架和接口幂等框架两个实战项目。接下来，我再带你实战一个新的项目：灰度发布组件。这也是我们专栏的最后一个实战项目。还是老套路，我们把它分为分析、设计、实现三个部分、对应三节课来讲解。今天，我们对灰度发布组件进行需求分析，搞清楚这个组件应该具有哪些功能性和非功能性需求。</p><p>话不多说，让我们正式开始今天的学习吧！</p><h2>需求场景</h2><p>还记得我们之前接口限流和幂等框架的项目背景吗？我们开发了一个公共服务平台，提供公共业务功能，给其他产品的后端系统调用，避免重复开发相同的业务代码。</p><p>最初，公共服务平台提供的是，基于某个开源RPC框架的RPC格式的接口。在上线一段时间后，我们发现这个开源RPC框架的Bug很多，多次因为框架本身的Bug，导致整个公共服务平台的接口不可用，但又因为团队成员对框架源码不熟悉，并且框架的代码质量本身也不高，排查、修复起来花费了很长时间，影响面非常大。所以，我们评估下来，觉着这个框架的可靠性不够，维护成本、二次开发成本都太高，最终决定替换掉它。</p><p>对于引入新的框架，我们的要求是成熟、简单，并且与我们现有的技术栈（Spring）相吻合。这样，即便出了问题，我们也能利用之前积累的知识、经验来快速解决。所以，我们决定直接使用Spring框架来提供RESTful格式的远程接口。</p><!-- [[[read_end]]] --><p>把RPC接口替换成RESTful接口，除了需要修改公共服务平台的代码之外，调用方的接口调用代码也要做相应的修改。除此之外，对于公共服务平台的代码，尽管我们只是改动接口暴露方式，对业务代码基本上没有改动，但是，我们也并不能保证就完全不出问题。所以，为了保险起见，我们希望灰度替换掉老的RPC服务，而不是一刀切，在某个时间点上，让所有的调用方一下子都变成调用新的Resful接口。</p><p><strong>我们来看下具体如何来做。</strong></p><p>因为替换的过程是灰度的，所以老的RPC服务不能下线，同时还要部署另外一套新的RESTful服务。我们先让业务不是很重要、流量不大的某个调用方，替换成调用新的RESTful接口。经过这个调用方一段时间的验证之后，如果新的RESTful接口没有问题，我们再逐步让其他调用方，替换成调用新的RESTful接口。</p><p>但是，如果万一中途出现问题，我们就需要将调用方的代码回滚，再重新部署，这就会导致调用方一段时间内服务不可用。而且，如果新的代码还包含调用方自身新的业务代码，简单通过Git回滚代码重新部署，会导致新的业务代码也被回滚。所以，为了避免这种情况的发生，我们就得手动将调用新的RESTful接口的代码删除，再改回为调用老的RPC接口。</p><p>除此之外，为了不影响调用方本身业务的开发进度，调用方基于回滚之后的老代码，来做新功能开发，那替换成新的RESTful接口的那部分代码，要想再重新merge回去就比较难了，有可能会出现代码冲突，需要再重新开发。</p><p><strong>怎么解决代码回滚成本比较高的问题呢？</strong>你可以先思考一下，再看我的讲解。</p><p>在替换新的接口调用方式的时候，调用方并不直接将调用RPC接口的代码逻辑删除，而是新增调用RESTful接口的代码，通过一个功能开关，灵活切换走老的代码逻辑还是新的代码逻辑。代码示例如下所示。如果callRestfulApi为true，就会走新的代码逻辑，调用RESTful接口，相反，就会走老的代码逻辑，继续调用RPC接口。</p><pre><code>boolean callRestfulApi = true;\n\nif (!callRestfulApi) {\n  // 老的调用RPC接口的代码逻辑\n} else {\n  // 新的调用Resful接口的代码逻辑\n}\n</code></pre><p>不过，更改callRestfulApi的值需要修改代码，而修改代码就要重新部署，这样的设计还是不够灵活。优化的方法，我想你应该已经想到了，把这个值放到配置文件或者配置中心就可以了。</p><p>为了更加保险，不只是使用功能开关做新老接口调用方式的切换，我们还希望调用方在替换某个接口的时候，先让小部分接口请求，调用新的RESTful接口，剩下的大部分接口请求，还是调用老的RPC接口，验证没有问题之后，再逐步加大调用新接口的请求比例，最终，将所有的接口请求，都替换成调用新的接口。这就是所谓的“灰度”。</p><p><strong>那这个灰度功能又该如何实现呢？</strong>同样，你还是先思考一下，再来看我的讲解。</p><p>首先，我们要决定使用什么来做灰度，也就是灰度的对象。我们可以针对请求携带的时间戳信息、业务ID等信息，按照区间、比例或者具体的值来做灰度。我举个例子来解释一下。</p><p>假设，我们要灰度的是根据用户ID查询用户信息接口。接口请求会携带用户ID信息，所以，我们就可以把用户ID作为灰度的对象。为了实现逐渐放量，我们先配置用户ID是918、879、123（具体的值）的查询请求调用新接口，验证没有问题之后，我们再扩大范围，让用户ID在1020~1120（区间值）之间的查询请求调用新接口。</p><p>如果验证之后还是没有问题，我们再继续扩大范围，让10%比例（比例值）的查询请求调用新接口（对应用户ID跟10取模求余小于1的请求）。以此类推，灰度范围逐步扩大到20%、30%、50%直到100%。当灰度比例达到100%，并且运行一段时间没有问题之后，调用方就可以把老的代码逻辑删除掉了。</p><p>实际上，类似的灰度需求场景还有很多。比如，在金融产品的清结算系统中，我们修改了清结算的算法。为了安全起见，我们可以灰度替换新的算法，把贷款ID作为灰度对象，先对某几个贷款应用新的算法，如果没有问题，再继续按照区间或者比例，扩大灰度范围。</p><p>除此之外，为了保证代码万无一失，提前做好预案，添加或者修改一些复杂功能、核心功能，即便不做灰度，我们也建议通过功能开关，灵活控制这些功能的上下线。在不需要重新部署和重启系统的情况，做到快速回滚或新老代码逻辑的切换。</p><h2>需求分析</h2><p>从实现的角度来讲，调用方只需要把灰度规则和功能开关，按照某种事先约定好的格式，存储到配置文件或者配置中心，在系统启动的时候，从中读取配置到内存中，之后，看灰度对象是否落在灰度范围内，以此来判定是否执行新的代码逻辑。但为了避免每个调用方都重复开发，我们把功能开关和灰度相关的代码，抽象封装为一个灰度组件，提供给各个调用方来复用。</p><p>这里需要强调一点，我们这里的灰度，是代码级别的灰度，目的是保证项目质量，规避重大代码修改带来的不确定性风险。实际上，我们平时经常讲的灰度，一般都是产品层面或者系统层面的灰度。</p><p>所谓产品层面，有点类似A/B Testing，让不同的用户看到不同的功能，对比两组用户的使用体验，收集数据，改进产品。所谓系统层面的灰度，往往不在代码层面上实现，一般是通过配置负载均衡或者API-Gateway，来实现分配流量到不同版本的系统上。系统层面的灰度也是为了平滑上线功能，但比起我们讲到的代码层面的灰度，就没有那么细粒度了，开发和运维成本也相对要高些。</p><p><strong>现在，我们就来具体看下，灰度组件都有哪些功能性需求。</strong></p><p>我们还是从使用的角度来分析。组件使用者需要设置一个key值，来唯一标识要灰度的功能，然后根据自己业务数据的特点，选择一个灰度对象（比如用户ID），在配置文件或者配置中心中，配置这个key对应的灰度规则和功能开关。配置的格式类似下面这个样子：</p><pre><code>features:\n- key: call_newapi_getUserById\n  enabled: true // enabled为true时，rule才生效\n  rule: {893,342,1020-1120,%30} // 按照用户ID来做灰度\n- key: call_newapi_registerUser\n  enabled: true\n  rule: {1391198723, %10}  //按照手机号来做灰度\n- key: newalgo_loan\n  enabled: true\n  rule: {0-1000} //按照贷款(loan)的金额来做灰度\n</code></pre><p>灰度组件在业务系统启动的时候，会将这个灰度配置，按照事先定义的语法，解析并加载到内存对象中，业务系统直接使用组件提供的灰度判定接口，给业务系统使用，来判定某个灰度对象是否灰度执行新的代码逻辑。配置的加载解析、灰度判定逻辑这部分代码，都不需要业务系统来从零开发。</p><pre><code>public interface DarkFeature {\n  boolean enabled();\n  boolean dark(String darkTarget); //darkTarget是灰度对象，比如前面提到的用户ID、手机号码、金额等\n}\n</code></pre><p>所以，总结一下的话，灰度组件跟限流框架很类似，它也主要包含两部分功能：灰度规则配置解析和提供编程接口（DarkFeature）判定是否灰度。</p><p>跟限流框架类似，除了功能性需求，我们还要分析非功能性需求。不过，因为前面已经有了限流框架的非功能性需求的讲解，对于灰度组件的非功能性需求，我就留给你自己来分析。在下一节课中，我会再给出我的分析思路，到时候，你可以对比一下。</p><h2>重点回顾</h2><p>好了，今天的内容到此就讲完了。我们一块来总结回顾一下，你需要重点掌握的内容。</p><p>灰度发布可以分为三个不同层面的灰度：产品层面的灰度、系统层面的灰度和代码层面的灰度。我们今天重点讲解代码层面的灰度，通过编程来控制是否执行新的代码逻辑，以及灰度执行新的代码逻辑。</p><p>代码层面的灰度，主要解决代码质量问题，通过逐渐放量灰度执行，来降低重大代码改动带来的风险。在出现问题之后，在不需要修改代码、重新部署、重启系统的情况下，实现快速地回滚。相对于系统层面的灰度，它可以做得更加细粒度，更加灵活、简单、好维护，但也存在着代码侵入的问题，灰度代码跟业务代码耦合在一起。</p><p>灰度组件跟之前讲过的限流框架很相似，主要包含配置的解析加载和灰度判定逻辑。除此之外，对于非功能性需求，我们留在下一节课中讲解。</p><h2>课堂讨论</h2><p>参照限流框架的非功能性需求，分析一下灰度组件的非功能性需求。</p><p>欢迎留言和我分享你的想法。如果有收获，也欢迎你把这篇文章分享给你的朋友。</p>",
                "article_title": "96 | 项目实战三：设计实现一个支持自定义规则的灰度发布组件（分析）"
            },
            {
                "title": "97  | 项目实战三：设计实现一个支持自定义规则的灰度发布组件（设计）",
                "herf": "https://time.geekbang.org/column/article/248714",
                "id": "248714",
                "content": "<p>上一节课，我们介绍了灰度组件的一个需求场景，将公共服务平台的RPC接口，灰度替换为新的RESTful接口，通过灰度逐步放量，支持快速回滚等手段，来规避代码质量问题带来的不确定性风险。</p><p>跟前面两个框架类似，灰度组件的功能性需求也比较简单。上一节课我们做了简单分析，今天我们再介绍一下，这个组件的非功能性需求，以及如何通过合理的设计来满足这些非功能性需求。</p><p>话不多说，让我们正式开始今天的学习吧！</p><h2>非功能性需求</h2><p>上一节课中，我给你留了一个作业，参照限流框架，分析一下灰度组件的非功能性需求。对于限流框架，我们主要从易用性、扩展性、灵活性、性能、容错性这几个方面，来分析它的非功能性需求。对于灰度组件，我们同样也从这几个方面来分析。</p><h3>易用性</h3><p>在前面讲到限流框架和幂等框架的时候，我们都提到了“低侵入松耦合”的设计思想。因为框架需要集成到业务系统中使用，我们希望它尽可能低侵入，与业务代码松耦合，替换、移除起来更容易些。因为接口的限流和幂等跟具体的业务是无关的，我们可以把限流和幂等相关的逻辑，跟业务代码解耦，统一放到公共的地方来处理（比如Spring AOP切面中）。</p><p>但是，对于灰度来说，我们实现的灰度功能是代码级别的细粒度的灰度，而替代掉原来的if-else逻辑，是针对一个业务一个业务来做的，跟业务强相关，要做到跟业务代码完全解耦，是不现实的。所以，在侵入性这一点上，灰度组件只能做妥协，容忍一定程度的侵入。</p><!-- [[[read_end]]] --><p>除此之外，在灰度的过程中，我们要不停地修改灰度规则，在测试没有出现问题的情况下，逐渐放量。从运维的角度来说，如果每次修改灰度规则都要重启系统，显然是比较麻烦的。所以，我们希望支持灰度规则的热更新，也就是说，当我们在配置文件中，修改了灰度规则之后，系统在不重启的情况下会自动加载、更新灰度规则。</p><h3>扩展性、灵活性</h3><p>跟限流框架一样，我们希望支持不同格式（JSON、YAML、XML等）、不同存储方式（本地配置文件、Redis、Zookeeper、或者自研配置中心等）的灰度规则配置方式。这一点在限流框架中已经详细讲过了，在灰度组件中我们就不重复讲解了。</p><p>除此之外，对于灰度规则本身，在上一节课的示例中，我们定义了三种灰度规则语法格式：具体值（比如893）、区间值（比如1020-1120）、比例值（比如%30）。不过，这只能处理比较简单的灰度规则。如果我们要支持更加复杂的灰度规则，比如只对30天内购买过某某商品并且退货次数少于10次的用户进行灰度，现在的灰度规则语法就无法支持了。所以，如何支持更加灵活的、复杂的灰度规则，也是我们设计实现的重点和难点。</p><h3>性能</h3><p>在性能方面，灰度组件的处理难度，并不像限流框架那么高。在限流框架中，对于分布式限流模式，接口请求访问计数存储在中心存储器中，比如Redis。而Redis本身的读写性能以及限流框架与Redis的通信延迟，都会很大地影响到限流本身的性能，进而影响到接口响应时间。所以，对于分布式限流来说，低延迟高性能是设计实现的难点和重点。</p><p>但是，对于灰度组件来说，灰度的判断逻辑非常简单，而且不涉及访问外部存储，所以性能一般不会有太大问题。不过，我们仍然需要把灰度规则组织成快速查找的数据结构，能够支持快速判定某个灰度对象（darkTarget，比如用户ID）是否落在灰度规则设定的区间内。</p><h3>容错性</h3><p>在限流框架中，我们要求高度容错，不能因为框架本身的异常，导致接口响应异常。从业务上来讲，我们一般能容忍限流框架的暂时、小规模的失效，所以，限流框架对于异常的处理原则是，尽可能捕获所有异常，并且内部“消化”掉，不要往上层业务代码中抛出。</p><p>对于幂等框架来说，我们不能容忍框架暂时、小规模的失效，因为这种失效会导致业务有可能多次被执行，发生业务数据的错误。所以，幂等框架对于异常的处理原则是，按照fail-fast原则，如果异常导致幂等逻辑无法正常执行，让业务代码也中止。因为业务执行失败，比业务执行出错，修复的成本更低。</p><p>对于灰度组件来说，上面的两种对异常的处理思路都是可以接受的。在灰度组件出现异常时，我们既可以选择中止业务，也可以选择让业务继续执行。如果让业务继续执行，本不应该被灰度到的业务对象，就有可能被执行。这是否能接受，还是要看具体的业务。不过，我个人倾向于采用类似幂等框架的处理思路，在出现异常时中止业务。</p><h2>框架设计思路</h2><p>根据刚刚对灰度组件的非功能性需求分析，以及跟限流框架、幂等框架非功能性需求的对比，我们可以看出，在性能和容错性方面，灰度组件并没有需要特别要处理的地方，重点需要关注的是易用性、扩展性、灵活性。详细来说，主要包括这样两点：支持更灵活、更复杂的灰度规则和支持灰度规则热更新。接下来，我们就重点讲一下，针对这两个重点问题的设计思路。</p><p><strong>首先，我们来看，如何支持更灵活、更复杂的灰度规则。</strong></p><p>灰度规则的配置也是跟业务强相关的。业务方需要根据要灰度的业务特点，找到灰度对象（上节课中的darkTarget，比如用户ID），然后按照给出的灰度规则语法格式，配置相应的灰度规则。</p><p>对于像刚刚提到的那种复杂的灰度规则（只对30天内购买过某某商品并且退货次数少于10次的用户进行灰度），通过定义语法规则来支持，是很难实现的。所以，针对复杂灰度规则，我们换个思路来实现。</p><p>我暂时想到了两种解决方法。其中一种是使用规则引擎，比如Drools，可以在配置文件中调用Java代码。另一种是支持编程实现灰度规则，这样做灵活性更高。不过，缺点是更新灰度规则需要更新代码，重新部署。</p><p>对于大部分业务的灰度，我们使用前面定义的最基本的语法规则（具体值、区间值、比例值）就能满足了。对于极个别复杂的灰度规则，我们借鉴Spring的编程式配置，由业务方编程实现，具体如何来做，我们放到下一节课的代码实现中讲解。这样既兼顾了易用性，又兼顾了灵活性。</p><p>之所以选择第二种实现方式，而不是使用Drools规则引擎，主要是出于不想为了不常用的功能，引入复杂的第三方框架，提高开发成本和灰度框架本身的学习成本。</p><p><strong>其次，我们来看，如何实现灰度规则热更新。</strong></p><p>规则热更新这样一个功能，并非灰度组件特有的，很多场景下都有类似的需求。在第25、26讲中，讲到性能计数器项目的时候，我们也提到过这个需求。</p><p>灰度规则的热更新实现起来并不难。我们创建一个定时器，每隔固定时间（比如1分钟），从配置文件中，读取灰度规则配置信息，并且解析加载到内存中，替换掉老的灰度规则。需要特别强调的是，更新灰度规则，涉及读取配置、解析、构建等一系列操作，会花费比较长的时间，我们不能因为更新规则，就暂停了灰度服务。所以，在设计和实现灰度规则更新的时候，我们要支持更新和查询并发执行。具体如何来做，我们留在下一节课的实现中详细讲解。</p><h2>重点回顾</h2><p>好了，今天的内容到此就讲完了。我们一块来总结回顾一下，你需要重点掌握的内容。</p><p>今天，我们对比限流框架、幂等框架，讲解了灰度组件的非功能性需求，主要包含易用性、扩展性、灵活性、性能、容错性这样几个方面，并且针对性地解释了对应的设计思路。</p><p>在易用性方面，我们重点讲解了“低侵入、松耦合”的设计思想。限流、幂等因为其跟业务无关，可以做到最大程度跟业务解耦，做到低侵入。但是，我们这里实现的代码层面的灰度，因为跟业务强相关，所以，跟业务代码耦合的比较紧密，比较难做到低侵入。</p><p>在扩展性、灵活性方面，除了像限流框架那样，支持各种格式、存储方式的配置方式之外，灰度组件还希望能支持复杂的灰度规则。对于大部分业务的灰度，我们使用最基本的语法规则（具体值、区间值、比例值）就能满足了。对于极个别复杂的灰度规则，我们借鉴Spring的编程式配置，由业务方编程实现。</p><p>在性能方面，灰度组件没有需要特殊处理的地方。我们只需要把灰度规则组织成快速查找的数据结构，能够支持快速判定某个灰度对象（darkTarget，比如用户ID），是否落在灰度规则设定的区间内。</p><p>在容错性方面，限流框架要高度容错，容忍短暂、小规模的限流失效，但不容忍框架异常导致的接口响应异常。幂等框架正好相反，不容忍幂等功能的失效，一旦出现异常，幂等功能失效，我们的处理原则是让业务也失败。这两种处理思路都可以用在灰度组件对异常的处理中。我个人倾向于采用幂等框架的处理思路。</p><h2>课堂讨论</h2><p>在项目实战这部分中，我们多次讲到“低侵入、松耦合”的设计思路，我们平时使用Logger框架，在业务代码中打印日志，算不算是对业务代码的侵入、耦合？</p><p>欢迎留言和我分享你的想法。如果有收获，也欢迎你把这篇文章分享给你的朋友。</p>",
                "article_title": "97  | 项目实战三：设计实现一个支持自定义规则的灰度发布组件（设计）"
            },
            {
                "title": "98 | 项目实战三：设计实现一个支持自定义规则的灰度发布组件（实现）",
                "herf": "https://time.geekbang.org/column/article/249369",
                "id": "249369",
                "content": "<p>上两节课，我们讲解了灰度组件的需求和设计思路。不管是之前讲过的限流、幂等框架，还是现在正在讲的灰度组件，这些框架、组件、类库的功能性需求都不复杂，相反，非功能性需求是开发的重点、难点。</p><p>今天，我们按照上节课给出的灰度组件的设计思路，讲解如何进行编码实现。不过今天对实现的讲解，跟前面两个实战项目有所不同。在前面两个项目中，我都是手把手地从最基础的MVP代码讲起，然后讲解如何review代码发现问题、重构代码解决问题，最终得到一份还算高质量的代码。考虑到已经有前面两个项目的学习和锻炼了，你应该对开发套路、思考路径很熟悉了，所以，今天我们换个讲法，就不从最基础的讲起了，而是重点讲解实现思路。</p><p>话不多说，让我们正式开始今天的学习吧！</p><h2>灰度组件功能需求整理</h2><p>针对上两节课给出的开发需求和设计思路，我们还是按照老套路，从中剥离出V1版本要实现的内容。为了方便我讲解和你查看，我把灰度组件的开发需求和设计思路，重新整理罗列了一下，放到了这里。</p><h3>1.灰度规则的格式和存储方式</h3><p>我们希望支持不同格式（JSON、YAML、XML等）、不同存储方式（本地配置文件、Redis、Zookeeper、或者自研配置中心等）的灰度规则配置方式。实际上，这一点跟之前的限流框架中限流规则的格式和存储方式完全一致，代码实现也是相同的，所以在接下来的讲解中，就不重复啰嗦了，你可以回过头去看下<a href=\"https://time.geekbang.org/column/article/243961\">第92讲</a>。</p><!-- [[[read_end]]] --><h3>2.灰度规则的语法格式</h3><p>我们支持三种灰度规则语法格式：具体值（比如893）、区间值（比如1020-1120）、比例值（比如%30）。除此之外，对于更加复杂的灰度规则，比如只对30天内购买过某某商品并且退货次数少于10次的用户进行灰度，我们通过编程的方式来实现。</p><h3>3.灰度规则的内存组织方式</h3><p>类似于限流框架中的限流规则，我们需要把灰度规则组织成支持快速查找的数据结构，能够快速判定某个灰度对象（darkTarget，比如用户ID），是否落在灰度规则设定的范围内。</p><h3>4.灰度规则热更新</h3><p>修改了灰度规则之后，我们希望不重新部署和重启系统，新的灰度规则就能生效，所以，我们需要支持灰度规则热更新。</p><p>在V1版本中，对于第一点灰度规则的格式和存储方式，我们只支持YAML格式本地文件的配置存储方式。对于剩下的三点，我们都要进行实现。考虑到V1版本要实现的内容比较多，我们分两步来实现代码，第一步先将大的流程、框架搭建好，第二步再进一步添加、丰富、优化功能。</p><h2>实现灰度组件基本功能</h2><p>在第一步中，我们先实现基于YAML格式的本地文件的灰度规则配置方式，以及灰度规则热更新，并且只支持三种基本的灰度规则语法格式。基于编程实现灰度规则的方式，我们留在第二步实现。</p><p>我们先把这个基本功能的开发需求，用代码实现出来。它的目录结构及其Demo示例如下所示。代码非常简单，只包含4个类。接下来，我们针对每个类再详细讲解一下。</p><pre><code>// 代码目录结构\ncom.xzg.darklaunch\n  --DarkLaunch(框架的最顶层入口类)\n  --DarkFeature(每个feature的灰度规则)\n  --DarkRule(灰度规则)\n  --DarkRuleConfig(用来映射配置到内存中)\n\n// Demo示例\npublic class DarkDemo {\n  public static void main(String[] args) {\n    DarkLaunch darkLaunch = new DarkLaunch();\n    DarkFeature darkFeature = darkLaunch.getDarkFeature(&quot;call_newapi_getUserById&quot;);\n    System.out.println(darkFeature.enabled());\n    System.out.println(darkFeature.dark(893));\n  }\n}\n\n// 灰度规则配置(dark-rule.yaml)放置在classpath路径下\nfeatures:\n- key: call_newapi_getUserById\n  enabled: true\n  rule: {893,342,1020-1120,%30}\n- key: call_newapi_registerUser\n  enabled: true\n  rule: {1391198723, %10}\n- key: newalgo_loan\n  enabled: true\n  rule: {0-1000}\n</code></pre><p>从Demo代码中，我们可以看出，对于业务系统来说，灰度组件的两个直接使用的类是DarkLaunch类和DarkFeature类。</p><p><strong>我们先来看DarkLaunch类。</strong>这个类是灰度组件的最顶层入口类。它用来组装其他类对象，串联整个操作流程，提供外部调用的接口。</p><p>DarkLaunch类先读取灰度规则配置文件，映射为内存中的Java对象（DarkRuleConfig），然后再将这个中间结构，构建成一个支持快速查询的数据结构（DarkRule）。除此之外，它还负责定期更新灰度规则，也就是前面提到的灰度规则热更新。</p><p>为了避免更新规则和查询规则的并发执行冲突，在更新灰度规则的时候，我们并非直接操作老的DarkRule，而是先创建一个新的DarkRule，然后等新的DarkRule都构建好之后，再“瞬间”赋值给老的DarkRule。你可以结合着下面的代码一块看下。</p><pre><code>public class DarkLaunch {\n  private static final Logger log = LoggerFactory.getLogger(DarkLaunch.class);\n  private static final int DEFAULT_RULE_UPDATE_TIME_INTERVAL = 60; // in seconds\n  private DarkRule rule;\n  private ScheduledExecutorService executor;\n\n  public DarkLaunch(int ruleUpdateTimeInterval) {\n    loadRule();\n    this.executor = Executors.newSingleThreadScheduledExecutor();\n    this.executor.scheduleAtFixedRate(new Runnable() {\n      @Override\n      public void run() {\n        loadRule();\n      }\n    }, ruleUpdateTimeInterval, ruleUpdateTimeInterval, TimeUnit.SECONDS);\n  }\n\n  public DarkLaunch() {\n    this(DEFAULT_RULE_UPDATE_TIME_INTERVAL);\n  }\n\n  private void loadRule() {\n    // 将灰度规则配置文件dark-rule.yaml中的内容读取DarkRuleConfig中\n    InputStream in = null;\n    DarkRuleConfig ruleConfig = null;\n    try {\n      in = this.getClass().getResourceAsStream(&quot;/dark-rule.yaml&quot;);\n      if (in != null) {\n        Yaml yaml = new Yaml();\n        ruleConfig = yaml.loadAs(in, DarkRuleConfig.class);\n      }\n    } finally {\n      if (in != null) {\n        try {\n          in.close();\n        } catch (IOException e) {\n          log.error(&quot;close file error:{}&quot;, e);\n        }\n      }\n    }\n\n    if (ruleConfig == null) {\n      throw new RuntimeException(&quot;Can not load dark rule.&quot;);\n    }\n    // 更新规则并非直接在this.rule上进行，\n    // 而是通过创建一个新的DarkRule，然后赋值给this.rule，\n    // 来避免更新规则和规则查询的并发冲突问题\n    DarkRule newRule = new DarkRule(ruleConfig);\n    this.rule = newRule;\n  }\n\n  public DarkFeature getDarkFeature(String featureKey) {\n    DarkFeature darkFeature = this.rule.getDarkFeature(featureKey);\n    return darkFeature;\n  }\n}\n</code></pre><p><strong>我们再来看下DarkRuleConfig类。</strong>这个类功能非常简单，只是用来将灰度规则映射到内存中。具体的代码如下所示：</p><pre><code>public class DarkRuleConfig {\n  private List&lt;DarkFeatureConfig&gt; features;\n\n  public List&lt;DarkFeatureConfig&gt; getFeatures() {\n    return this.features;\n  }\n\n  public void setFeatures(List&lt;DarkFeatureConfig&gt; features) {\n    this.features = features;\n  }\n\n  public static class DarkFeatureConfig {\n    private String key;\n    private boolean enabled;\n    private String rule;\n    // 省略getter、setter方法\n  }\n}\n</code></pre><p>从代码中，我们可以看出来，DarkRuleConfig类嵌套了一个内部类DarkFeatureConfig。这两个类跟配置文件的两层嵌套结构完全对应。我把对应关系标注在了下面的示例中，你可以对照着代码看下。</p><pre><code>&lt;!--对应DarkRuleConfig--&gt;\nfeatures:                       \n- key: call_newapi_getUserById  &lt;!--对应DarkFeatureConfig--&gt;\n  enabled: true\n  rule: {893,342,1020-1120,%30}\n- key: call_newapi_registerUser &lt;!--对应DarkFeatureConfig--&gt;\n  enabled: true\n  rule: {1391198723, %10}\n- key: newalgo_loan             &lt;!--对应DarkFeatureConfig--&gt;\n  enabled: true\n  rule: {0-1000}\n</code></pre><p><strong>我们再来看下DarkRule。</strong>DarkRule包含所有要灰度的业务功能的灰度规则。它用来支持根据业务功能标识（feature key），快速查询灰度规则（DarkFeature）。代码也比较简单，具体如下所示：</p><pre><code>public class DarkRule {\n  private Map&lt;String, DarkFeature&gt; darkFeatures = new HashMap&lt;&gt;();\n\n  public DarkRule(DarkRuleConfig darkRuleConfig) {\n    List&lt;DarkRuleConfig.DarkFeatureConfig&gt; darkFeatureConfigs = darkRuleConfig.getFeatures();\n    for (DarkRuleConfig.DarkFeatureConfig darkFeatureConfig : darkFeatureConfigs) {\n      darkFeatures.put(darkFeatureConfig.getKey(), new DarkFeature(darkFeatureConfig));\n    }\n  }\n\n  public DarkFeature getDarkFeature(String featureKey) {\n    return darkFeatures.get(featureKey);\n  }\n}\n</code></pre><p><strong>我们最后来看下DarkFeature类。</strong>DarkFeature类表示每个要灰度的业务功能的灰度规则。DarkFeature将配置文件中灰度规则，解析成一定的结构（比如RangeSet），方便快速判定某个灰度对象是否落在灰度规则范围内。具体的代码如下所示：</p><pre><code>public class DarkFeature {\n  private String key;\n  private boolean enabled;\n  private int percentage;\n  private RangeSet&lt;Long&gt; rangeSet = TreeRangeSet.create();\n\n  public DarkFeature(DarkRuleConfig.DarkFeatureConfig darkFeatureConfig) {\n    this.key = darkFeatureConfig.getKey();\n    this.enabled = darkFeatureConfig.getEnabled();\n    String darkRule = darkFeatureConfig.getRule().trim();\n    parseDarkRule(darkRule);\n  }\n\n  @VisibleForTesting\n  protected void parseDarkRule(String darkRule) {\n    if (!darkRule.startsWith(&quot;{&quot;) || !darkRule.endsWith(&quot;}&quot;)) {\n      throw new RuntimeException(&quot;Failed to parse dark rule: &quot; + darkRule);\n    }\n\n    String[] rules = darkRule.substring(1, darkRule.length() - 1).split(&quot;,&quot;);\n    this.rangeSet.clear();\n    this.percentage = 0;\n    for (String rule : rules) {\n      rule = rule.trim();\n      if (StringUtils.isEmpty(rule)) {\n        continue;\n      }\n\n      if (rule.startsWith(&quot;%&quot;)) {\n        int newPercentage = Integer.parseInt(rule.substring(1));\n        if (newPercentage &gt; this.percentage) {\n          this.percentage = newPercentage;\n        }\n      } else if (rule.contains(&quot;-&quot;)) {\n        String[] parts = rule.split(&quot;-&quot;);\n        if (parts.length != 2) {\n          throw new RuntimeException(&quot;Failed to parse dark rule: &quot; + darkRule);\n        }\n        long start = Long.parseLong(parts[0]);\n        long end = Long.parseLong(parts[1]);\n        if (start &gt; end) {\n          throw new RuntimeException(&quot;Failed to parse dark rule: &quot; + darkRule);\n        }\n        this.rangeSet.add(Range.closed(start, end));\n      } else {\n        long val = Long.parseLong(rule);\n        this.rangeSet.add(Range.closed(val, val));\n      }\n    }\n  }\n\n  public boolean enabled() {\n    return this.enabled;\n  }\n\n  public boolean dark(long darkTarget) {\n    boolean selected = this.rangeSet.contains(darkTarget);\n    if (selected) {\n      return true;\n    }\n\n    long reminder = darkTarget % 100;\n    if (reminder &gt;= 0 &amp;&amp; reminder &lt; this.percentage) {\n      return true;\n    }\n\n    return false;\n  }\n\n  public boolean dark(String darkTarget) {\n    long target = Long.parseLong(darkTarget);\n    return dark(target);\n  }\n}\n</code></pre><h2>添加、优化灰度组件功能</h2><p>在第一步中，我们完成了灰度组件的基本功能。在第二步中，我们再实现基于编程的灰度规则配置方式，用来支持更加复杂、更加灵活的灰度规则。</p><p>我们需要对于第一步实现的代码，进行一些改造。改造之后的代码目录结构如下所示。其中，DarkFeature、DarkRuleConfig的基本代码不变，新增了IDarkFeature接口，DarkLaunch、DarkRule的代码有所改动，用来支持编程实现灰度规则。</p><pre><code>// 第一步的代码目录结构\ncom.xzg.darklaunch\n  --DarkLaunch(框架的最顶层入口类)\n  --DarkFeature(每个feature的灰度规则)\n  --DarkRule(灰度规则)\n  --DarkRuleConfig(用来映射配置到内存中)\n\n// 第二步的代码目录结构\ncom.xzg.darklaunch\n  --DarkLaunch(框架的最顶层入口类，代码有改动)\n  --IDarkFeature(抽象接口)\n  --DarkFeature(实现IDarkFeature接口，基于配置文件的灰度规则，代码不变)\n  --DarkRule(灰度规则，代码有改动)\n  --DarkRuleConfig(用来映射配置到内存中，代码不变)\n</code></pre><p>我们先来看下IDarkFeature接口，它用来抽象从配置文件中得到的灰度规则，以及编程实现的灰度规则。具体代码如下所示：</p><pre><code>public interface IDarkFeature {\n  boolean enabled();\n  boolean dark(long darkTarget);\n  boolean dark(String darkTarget);\n}\n</code></pre><p>基于这个抽象接口，业务系统可以自己编程实现复杂的灰度规则，然后添加到DarkRule中。为了避免配置文件中的灰度规则热更新时，覆盖掉编程实现的灰度规则，在DarkRule中，我们对从配置文件中加载的灰度规则和编程实现的灰度规则分开存储。按照这个设计思路，我们对DarkRule类进行重构。重构之后的代码如下所示：</p><pre><code>public class DarkRule {\n  // 从配置文件中加载的灰度规则\n  private Map&lt;String, IDarkFeature&gt; darkFeatures = new HashMap&lt;&gt;();\n  // 编程实现的灰度规则\n  private ConcurrentHashMap&lt;String, IDarkFeature&gt; programmedDarkFeatures = new ConcurrentHashMap&lt;&gt;();\n\n  public void addProgrammedDarkFeature(String featureKey, IDarkFeature darkFeature) {\n    programmedDarkFeatures.put(featureKey, darkFeature);\n  }\n\n  public void setDarkFeatures(Map&lt;String, IDarkFeature&gt; newDarkFeatures) {\n    this.darkFeatures = newDarkFeatures;\n  }\n\n  public IDarkFeature getDarkFeature(String featureKey) {\n    IDarkFeature darkFeature = programmedDarkFeatures.get(featureKey);\n    if (darkFeature != null) {\n      return darkFeature;\n    }\n    return darkFeatures.get(featureKey);\n  }\n}\n</code></pre><p>因为DarkRule代码有所修改，对应地，DarkLaunch的代码也需要做少许改动，主要有一处修改和一处新增代码，具体如下所示，我在代码中都做了注释，就不再重复解释了。</p><pre><code>public class DarkLaunch {\n  private static final Logger log = LoggerFactory.getLogger(DarkLaunch.class);\n  private static final int DEFAULT_RULE_UPDATE_TIME_INTERVAL = 60; // in seconds\n  private DarkRule rule = new DarkRule();\n  private ScheduledExecutorService executor;\n\n  public DarkLaunch(int ruleUpdateTimeInterval) {\n    loadRule();\n    this.executor = Executors.newSingleThreadScheduledExecutor();\n    this.executor.scheduleAtFixedRate(new Runnable() {\n      @Override\n      public void run() {\n        loadRule();\n      }\n    }, ruleUpdateTimeInterval, ruleUpdateTimeInterval, TimeUnit.SECONDS);\n  }\n\n  public DarkLaunch() {\n    this(DEFAULT_RULE_UPDATE_TIME_INTERVAL);\n  }\n\n  private void loadRule() {\n    InputStream in = null;\n    DarkRuleConfig ruleConfig = null;\n    try {\n      in = this.getClass().getResourceAsStream(&quot;/dark-rule.yaml&quot;);\n      if (in != null) {\n        Yaml yaml = new Yaml();\n        ruleConfig = yaml.loadAs(in, DarkRuleConfig.class);\n      }\n    } finally {\n      if (in != null) {\n        try {\n          in.close();\n        } catch (IOException e) {\n          log.error(&quot;close file error:{}&quot;, e);\n        }\n      }\n    }\n\n    if (ruleConfig == null) {\n      throw new RuntimeException(&quot;Can not load dark rule.&quot;);\n    }\n    \n    // 修改：单独更新从配置文件中得到的灰度规则，不覆盖编程实现的灰度规则\n    Map&lt;String, IDarkFeature&gt; darkFeatures = new HashMap&lt;&gt;();\n    List&lt;DarkRuleConfig.DarkFeatureConfig&gt; darkFeatureConfigs = ruleConfig.getFeatures();\n    for (DarkRuleConfig.DarkFeatureConfig darkFeatureConfig : darkFeatureConfigs) {\n      darkFeatures.put(darkFeatureConfig.getKey(), new DarkFeature(darkFeatureConfig));\n    }\n    this.rule.setDarkFeatures(darkFeatures);\n  }\n\n  // 新增：添加编程实现的灰度规则的接口\n  public void addProgrammedDarkFeature(String featureKey, IDarkFeature darkFeature) {\n    this.rule.addProgrammedDarkFeature(featureKey, darkFeature);\n  }\n\n  public IDarkFeature getDarkFeature(String featureKey) {\n    IDarkFeature darkFeature = this.rule.getDarkFeature(featureKey);\n    return darkFeature;\n  }\n}\n</code></pre><p>灰度组件的代码实现就讲完了。我们再通过一个Demo来看下，目前实现的灰度组件该如何使用。结合着Demo，再去理解上面的代码，会更容易些。Demo代码如下所示：</p><pre><code>// 灰度规则配置(dark-rule.yaml)，放到classpath路径下\nfeatures:\n- key: call_newapi_getUserById\n  enabled: true\n  rule: {893,342,1020-1120,%30}\n- key: call_newapi_registerUser\n  enabled: true\n  rule: {1391198723, %10}\n- key: newalgo_loan\n  enabled: true\n  rule: {0-100}\n  \n// 编程实现的灰度规则\npublic class UserPromotionDarkRule implements IDarkFeature {\n  @Override\n  public boolean enabled() {\n    return true;\n  }\n\n  @Override\n  public boolean dark(long darkTarget) {\n    // 灰度规则自己想怎么写就怎么写\n    return false;\n  }\n\n  @Override\n  public boolean dark(String darkTarget) {\n    // 灰度规则自己想怎么写就怎么写\n    return false;\n  }\n}\n\n// Demo\npublic class Demo {\n  public static void main(String[] args) {\n    DarkLaunch darkLaunch = new DarkLaunch(); // 默认加载classpath下dark-rule.yaml文件中的灰度规则\n    darkLaunch.addProgrammedDarkFeature(&quot;user_promotion&quot;, new UserPromotionDarkRule()); // 添加编程实现的灰度规则\n    IDarkFeature darkFeature = darkLaunch.getDarkFeature(&quot;user_promotion&quot;);\n    System.out.println(darkFeature.enabled());\n    System.out.println(darkFeature.dark(893));\n  }\n}\n</code></pre><h2>重点回顾</h2><p>好了，今天的内容到此就讲完了。我们一块来总结回顾一下，你需要重点掌握的内容。</p><p>到今天为止，项目实战环节就彻底结束了。在这一部分中，我们通过限流、幂等、灰度这三个实战项目，带你从需求分析、系统设计、代码实现这三个环节，学习了如何进行功能性、非功能性需求分析，如何通过合理的设计，完成功能性需求的同时，满足非功能性需求，以及如何编写高质量的代码实现。</p><p>实际上，项目本身的分析、设计、实现并不重要，不必对细节过于纠结。我希望通过这三个例子，分享我的思考路径、开发套路，让你借鉴并举一反三地应用到你平时的项目开发中。我觉得这才是最有价值的，才是你学习的重点。</p><p>如果你学完这一部分之后，对于项目中的一些通用的功能，能够开始下意识地主动思考代码复用的问题，考虑如何抽象成框架、类库、组件，并且对于如何开发，也不再觉得无从下手，而是觉得有章可循，那我觉得你就学到了这一部分的精髓。</p><h2>课堂讨论</h2><p>在DarkFeature类中，灰度规则的解析代码设计的不够优雅，你觉得问题在哪里呢？又该如何重构呢？</p><p>欢迎留言和我分享你的想法。如果有收获，也欢迎你把这篇文章分享给你的朋友。</p>",
                "article_title": "98 | 项目实战三：设计实现一个支持自定义规则的灰度发布组件（实现）"
            }
        ]
    },
    {
        "chapterTitle": "开源与项目实战：总结课 (2讲)",
        "children": [
            {
                "title": "99 | 总结回顾：在实际软件开发中常用的设计思想、原则和模式",
                "herf": "https://time.geekbang.org/column/article/250942",
                "id": "250942",
                "content": "<p>到今天为止，理论部分和实战部分都已经讲完了，整个专栏也接近尾声了。我这里用两节课的时间，带你一块复习一下前面学到的知识点。跟前面的讲解相对应，这两节课分别是针对理论部分和实战部分进行回顾总结。</p><p>今天，我先来带你回顾一下整个专栏的知识体系。我们整个专栏围绕着编写高质量代码展开，涵盖了代码设计的方方面面，主要包括面向对象、设计原则、编码规范、重构技巧、设计模式这五个部分。我们就从这五个方面，带你一块把之前学过的知识点串一遍。</p><p><img src=\"https://static001.geekbang.org/resource/image/f3/d3/f3262ef8152517d3b11bfc3f2d2b12d3.png\" alt=\"\"></p><p>话不多说，让我们正式开始今天的学习吧！</p><h2>面向对象</h2><p>相对于面向过程、函数式编程，面向对象是现在最主流的编程范式。纯面向过程的编程方法，现在已经不多见了，而新的函数式编程，因为它的应用场景比较局限，所以大多作为面向对象编程的一种补充，用在科学计算、大数据处理等特殊领域。</p><p>它提供了丰富的特性，比如封装、抽象、继承、多态，有助于实现复杂的设计思路，是很多设计原则、设计模式等编程实现的基础。</p><p>在面向对象这一部分，我们要重点掌握面向对象的四大特性：封装、抽象、继承、多态，以及面向对象编程与面向过程编程的区别。需要特别注意的是，在平时的面向对象编程开发中，我们要避免编写出面向过程风格的代码。</p><p>除此之外，我们还重点学习了面向对象分析（OOA）、设计（OOD）、编程（OOP）。其中，面向对象分析就是需求分析，面向对象设计是代码层面的设计，输出的设计结果是类。面向对象编程就是将设计的结果翻译成代码的过程。</p><!-- [[[read_end]]] --><p>在专栏中，我们重点讲解了面向对象设计这一部分。我们可以把面向对象设计分为四个环节：划分职责并识别出有哪些类、定义类及其属性和方法、定义类之间的交互关系、组装类并提供执行入口。我们通过几个项目案例，带你实战了一下设计过程，希望你能面对开发需求的时候，不会无从下手，做到有章可循，按照我们的给出的步骤，有条不紊地完成设计。</p><p>在面向对象这一部分，我们还额外讲到了两个设计思想：基于接口而非实现的设计思想、多用组合少用继承的设计思想。这两个设计思想虽然简单，但非常实用，应用它们能让代码更加灵活，更加容易扩展，所以，这两个设计思想几乎贯穿在我们整个专栏的代码实现中。</p><h2>设计原则</h2><p>在专栏的最开始，我们总结了一套评判代码质量的标准，比如可读性、可维护性、可扩展性、复用性等，这是从代码整体质量的角度来评判的。但是，落实到具体的细节，我们往往从是否符合设计原则，来对代码设计进行评判。比如，我们说这段代码的可扩展性比较差，主要原因是违背了开闭原则。这也就是说，相对于可读性、可维护性、可扩展性等代码整体质量的评判标准，设计原则更加具体，能够更加明确地指出代码存在的问题。</p><p>在专栏中，我们重点讲解了一些经典的设计原则，大部分都耳熟能详。它们分别是SOLID原则、DRY原则、KISS原则、YAGNI原则、LOD原则。这些原则的定义描述都很简单，看似都很好理解，但也都比较抽象，比较难落地指导具体的编程。所以，学习的重点是透彻理解它们的设计初衷，掌握它们能解决哪些编程问题，有哪些常用的应用场景。</p><p>SOLID原则并非一个原则。它包含：单一职责原则（SRP）、开闭原则（OCP）、里氏替换原则（LSP）、接口隔离原则（ISP）、依赖倒置原则（DIP）。其中，里氏替换和接口隔离这两个设计原则并不那么常用，稍微了解就可以了。我们重点学习了单一职责、开闭、依赖倒置这三个原则。</p><p>单一职责原则是类职责划分的重要参考依据，是保证代码”高内聚“的有效手段，是面向对象设计前两步（划分职责并识别出有哪些类、定义类及其属性和方法）的主要指导原则。单一职责原则的难点在于，对代码职责是否足够单一的判定。这要根据具体的场景来具体分析。同一个类的设计，在不同的场景下，对职责是否单一的判定，可能是不同的。</p><p>开闭原则是保证代码可扩展性的重要指导原则，是对代码扩展性的具体解读。很多设计模式诞生的初衷都是为了提高代码的扩展性，都是以满足开闭原则为设计目的的。实际上，尽管开闭原则描述为对扩展开放、对修改关闭，但也并不是说杜绝一切代码修改，正确的理解是以最小化修改代价来完成新功能的添加。实际上，在平时的开发中，我们要时刻思考，目前的设计在以后应对新功能扩展的时候，是否能做到不需要大的代码修改（比如调整代码结构）就能完成。</p><p>依赖倒置原则主要用来指导框架层面的设计。高层模块不依赖低层模块，它们共同依赖同一个抽象。深挖一下的话，我们要把它跟控制反转、依赖注入、依赖注入框架做区分。实际上，比依赖倒置原则更加常用的是依赖注入。它用来指导如何编写可测试性代码，换句话说，编写可测试代码的诀窍就是应用依赖注入。</p><p>KISS、YAGNI可以说是两个万金油原则，小到代码、大到架构、产品，很多场景都能套用这两条原则。其中，YAGNI原则表示暂时不需要的就不要做，KISS原则表示要做就要尽量保持简单。跟单一职责原则类似，掌握这两个原则的难点也是在于，对代码是否符合KISS、YAGNI原则的判定。这也需要根据具体的场景来具体分析，在某个时间点、某个场景下，某段代码符合KISS、YAGNI原则，换个时间点、换个场景，可能就不符合了。</p><p>DRY原则主要是提醒你不要写重复的代码，这个倒是不难掌握。LOD原则又叫最小知道原则，不该有直接依赖关系的类之间，不要有依赖；有依赖关系的类之间，尽量只依赖必要的接口。如果说单一职责原则是为了实现“高内聚”， 那这个原则就是为了实现“松耦合”。</p><h2>编码规范</h2><p>编码规范很重要，特别是对于初入职、开发经验不多的程序员，遵从好的编码规范，能让你写出来的代码至少不会太烂。而且，编码规范都比较具体，不像设计原则、模式、思想那样，比较抽象，需要融入很多个人的理解和思考，需要根据具体的场景具体分析，所以，它落地执行起来更加容易。</p><p>虽然我们讲了很多设计思想、原则、模式，但是，大部分代码都不需要用到这么复杂的设计，即便用到，可能也就只是用到极个别的知识点，而且用的也不会很频繁。但是，编码规范就不一样了。编码规范影响到你写的每个类、函数、变量。你编写每行代码的时候都要思考是否符合编码规范。</p><p>除此之外，编程规范主要解决代码的可读性问题。我个人觉得，在编写代码的时候，我们要把可读性放到首位。只有在代码可读性比较好的情况下，我们再去考虑代码的扩展性、灵活性等。一般来说，一个可读性比较好的代码，对它修改、扩展、重构都不是难事，因为这些工作的前提都是先读懂代码。</p><p>不过，专栏中只是总结了一些最常用的、最能明显改善代码质量的编码规范，更进一步的学习你可以参考《重构》《代码大全》《代码整洁之道》等书籍，或者参看你公司内部的编码规范。</p><h2>重构技巧</h2><p>重构作为保持代码质量不腐化的有效手段，利用的就是面向对象、设计原则、设计模式、编码规范这些理论。在重构的过程中，我们用代码质量评判标准来评判代码的整体质量，然后对照设计原则来发现代码存在的具体问题，最后用设计模式或者编码规范对存在的问题进行改善。</p><p>持续重构除了能保证代码质量不腐化之外，还能有效避免过度设计。有了持续重构意识，我们就不会因为担心设计不足而过度设计。我们先按照最简单的思路来设计，然后在后续的开发过程中逐步迭代重构。</p><p>在专栏中，我们还对重构进行了粗略的分类，分为大规模高层次的重构和小规模低层次的重构。不管哪种重构，保证重构不出错，除了熟悉代码之外，还有就是完善的单元测试。</p><h2>设计模式</h2><p>如果说设计原则相当于编程心法，那设计模式相当于具体的招式。设计模式是针对软件开发中经常遇到的一些设计问题，总结出来的一套解决方案或者设计思路。我们用设计原则来评判代码设计哪里有问题，然后再通过具体的设计模式来改善。相对于其他部分来讲，设计模式是最容易学习的，但也是最容易被滥用的，所以，我们在第75讲中还专门讲了如何避免过度设计。</p><p>经典的设计模式有23种，分三种类型：创建型、结构型和行为型。其中，创建型设计模式主要解决“对象的创建”问题，结构型设计模式主要解决“类或对象的组合”问题，行为型设计模式主要解决“类或对象之间的交互”问题。</p><p>虽然专栏中讲到的设计模式有很多种，但常用的并不多，主要有：单例、工厂、建造者、代理、装饰器、适配器、观察者、模板、策略、职责链、迭代器这11种，所以，你只要集中精力，把这11种搞明白就可以了，剩下的那12种稍微了解，混个眼熟，等到真正用到的时候，再深入地去研究学习就可以了。</p><h2>课堂讨论</h2><p>很多人反映学了就忘，对于上面的这些知识点，你记住了百分之多少呢？你是怎么克服学了就忘的问题的呢？</p><p>欢迎留言和我分享你的想法，如果有收获，也欢迎你把这篇文章分享给你的朋友。</p>",
                "article_title": "99 | 总结回顾：在实际软件开发中常用的设计思想、原则和模式"
            },
            {
                "title": "100 | 如何将设计思想、原则、模式等理论知识应用到项目中？",
                "herf": "https://time.geekbang.org/column/article/251930",
                "id": "251930",
                "content": "<p>上一节课，我们对整个专栏的理论知识点做了串讲复习，不知道你掌握得如何？对于上节课总结的重点内容，我希望你能多花点时间搞透彻，对于一些不那么重要的内容，我建议你把专栏当作工具资料，用到的时候随手查阅，再深入学习研究。</p><p>实际上，很多小伙伴反应，虽然理论掌握得差不多，专栏也很贴近实战，每个知识点的讲解都有结合实际的代码案例，并且最后还有集中的项目实战，但落实到自己写代码的时候，还是无法将学到的理论知识很好地应用到其中。今天，我们就再聊一聊，如何将设计思想、原则、模式等理论知识应用到实际的项目开发中。</p><p>话不多说，让我们正式开始今天的学习吧！</p><h2>吃透理论、先把书读厚再把书读薄</h2><p>把理论知识灵活地应用到实践的前提是，对理论有透彻、无盲点的理解。如果我们对理论知识掌握得似懂非懂，在实际软件开发中，遇到跟专栏中讲过的问题类似，我们可以照葫芦画瓢去解决，但是，如果问题背景稍有改变，我们就会比较难联想到对应的理论知识，更难灵活地应用理论去解决。</p><p>要想透彻理解专栏中的每个知识点，一个是要多看几遍，二是要有死磕精神。虽然这两个方法可能已经是老生常谈了，听起来也没有什么高大上的，但从我自身的学习经验来讲，它们确实很有用。</p><p><strong>书读百遍其义自见。</strong>有的时候，对某个知识点，如果看一遍看不懂，你就硬着头皮多看几遍，或者隔几天再回过头来看一遍，你会发现原来很多看不懂的地方，自然而然就懂了。</p><!-- [[[read_end]]] --><p><strong>慢就是快，快就是慢。</strong>专栏涉及的内容很多，但我们花一年把所有的知识点学透彻，实际上是件一劳永逸的事情。这个过程虽然看似漫长，但收益却很多。对比而言，如果你只是为了追求结课速度，花一两个月、甚至一两个礼拜，把课程学完。这看似很快，但实际上收获会很少。</p><p><strong>先把书读厚，再把书读薄。</strong>反复地学、持续地看。先把书读厚，等到你把所有的知识点都理解透彻，并且在脑子里建立起清晰的知识体系之后，你会发现，实际上专栏的内容也就那么点东西，并不难记忆。前提是你先要花时间把书读厚，然后才能做到把书读薄。</p><p>虽然这里我们讲到书读百遍其义自见，也讲到死磕精神，但是，我必须强调一下，有的时候，对于某个知识点，我们看了很多遍、死磕了很长时间，如果还是没法透彻理解，我们也不要过于钻牛角尖，非得“现在立刻马上就要”把它拿下。我们可以先把这个知识点放一放，先看看后面的内容，隔一段时间，让知识沉淀、消化一下，再回过头来看也是可以的。</p><h2>在实战中反复学习、模仿和借鉴</h2><p>很多人说，理论的知识学了就忘，忘了是不是就等于白学了呢？实际上不是的，起码对于我们这个专栏的内容来说，并非如此。在专栏中，几乎每个知识点，我都结合具体的案例和代码来讲解，目的就是为了让你在实战中学习。所以，你学习的重点不是理论知识，而是跟随我的思维逻辑，学习如何分析代码问题，解决代码问题。通过专栏，经过上百个代码案例的剖析学习，即便理论知识你有可能会忘记，但这种潜移默化的能力锻炼，是不会丢掉的。</p><p>对于新手来说，最好的学习方法之一就是“模仿”。我之前在《数据结构和算法之美》专栏中，也曾经讲过，如果你是一名算法或者编程初学者，自己编写代码实现各种数据结构和算法，可能会比较困难。在这种情况下，你就可以先从“照抄”开始，把所有的代码都抄一遍或者抄几遍，然后再慢慢地过渡到自己去默写。</p><p>对于我们这个专栏来说，如果你项目经验不多，要想把理论一下子就灵活地应用到项目中，实际上这个要求也有点过高了。同样，你也可以先从模仿开始，对于项目中遇到的跟专栏中相似的开发场景，你可以借鉴专栏中的设计思路、代码实现。实际上，除了专栏中的案例之外，我们还有很多借鉴的来源，比如我们前面剖析过的经典开源项目（Spring、MyBatis），还有项目中大牛同事写的代码等等。</p><p>有人为了刷LeetCode、刷算法题，会积累一些算法模板，对于相似的问题，套用算法模板来快速解决。同样的，我们也可以积累设计模板、代码模板，对于相似的功能需求，我们可以套路设计模板、代码模板来解决。比如，在前面讲到的限流框架、灰度组件中，加载配置文件这样一个常用功能的设计和实现，我们就可以抽象成模板。对于其他项目中类似的功能需求，直接套用就可以，不用从零开始设计和实现了。</p><h2>刻意思考、刻意训练、追求极致</h2><p>要想把理论知识应用到项目中，并且做到润物细无声、融会贯通、无招胜有招，我们需要经过漫长的刻意思考和刻意训练。</p><p>拿到一个功能需求的时候，我们先去思考一下如何设计，而不是上来就写代码。写代码时，我们也要时刻思考代码是否遵循了经典的设计思想、设计原则，比如是否足够可扩展、是否满足SOLID原则、可读性如何等等。</p><p>写完代码之后，我们再思考一下，代码是否有进一步优化的空间。做Code Review的时候，看到别人的优秀的代码，我们就去思考一下，有哪些值得借鉴的地方。</p><p>总之，在平时的开发中，我们要刻意的去做这种跟代码质量、代码设计相关的思考训练。时间长了，这种思考就能成为习惯和本能反应，慢慢地，你的代码能力也就不自觉地提高了。</p><p>刻意训练的过程在前期会比较痛苦。为了尽可能写出高质量的代码，为了刻意训练在代码中应用理论知识，原本半天就能写好的代码，可能需要好几天才能完成。在最开始的时候，我建议你把专栏中讲到的经典的设计思想、原则、模式，打印出来贴在电脑旁，每次写代码的时候，对照着每个知识点，一个一个去审视代码。</p><p>跟前面讲到的花很多时间把理论知识搞透彻的道理一样，刻意训练虽然在前期需要投入更多的时间和精力，但也是一件一劳永逸的事情。等到训练到一定程度之后，你就会发现，在不依赖这个知识点列表的情况下，你开始不自主地考虑代码质量问题、设计问题，不经意写出的代码，就完全符合高质量代码的要求了，而且，写出好的代码并不会花费更多的时间了。相反，如果不愿意为刻意训练付出时间和精力，每次写代码都马马虎虎，代码质量永远都提高不了，也永远都达不到灵活应用理论知识到项目中。</p><p>我经常说，多花点心思和时间把一段代码写好、优化到极致，比写十段凑活能用的代码，对提高代码能力更有效。实际上，这就好比刷LeetCode算法题，对于一些经典算法的经典题目，我们一定要刻意地多花点时间搞清楚，死磕一下。虽然死磕的过程很痛苦，可能会花掉你很多时间，但一旦搞明白之后，其他类似的题目都可以很快解决。相反，如果看到不会的问题，连思考都不思考，就去看答案，那做十道题，也还是没有太多长进，看到题目不看答案还是写不出来。</p><h2>课堂讨论</h2><p>关于如何将设计思想、原则、模式等理论知识应用到项目中，除了我分享的这些经验之外，你还有哪些经验可以分享给大家呢？另外，经过这么长的学习和训练，在自己参与的项目中，你是否开始关注代码质量问题，代码能力是否有提升了呢？</p><p>欢迎留言和我分享你的想法，如果有收获，也欢迎你把这篇文章分享给你的朋友。</p>",
                "article_title": "100 | 如何将设计思想、原则、模式等理论知识应用到项目中？"
            }
        ]
    },
    {
        "chapterTitle": "不定期加餐 (11讲)",
        "children": [
            {
                "title": "加餐一 | 用一篇文章带你了解专栏中用到的所有Java语法",
                "herf": "https://time.geekbang.org/column/article/166698",
                "id": "166698",
                "content": "<p>尽管说设计模式跟编程语言没有直接关系，但是，我们也无法完全脱离代码来讲设计模式。我本人熟悉的是Java语言，所以专栏中的代码示例我都是用Java语言来写的。考虑到有些同学并不熟悉Java语言，我今天用一篇文章介绍一下专栏中用到的Java语法。</p><p>如果你有一定的编程基础，熟悉一门编程语言，结合我今天讲的Java语法知识，那看懂专栏中的代码基本不成问题。</p><p>如果你熟悉的是C/C++、C#、PHP，那几乎不用费多大力气，就能看懂Java代码。我当时从C++转到Java，也只看了一天的书，基本语法就全部掌握了。</p><p>如果你熟悉的是Python、Go、Ruby、JavaScript，这些语言的语法可能跟Java的区别稍微有些大，但是，通过这篇文章，做到能看懂也不是难事儿。</p><p>好了，现在，就让我们一块儿看下，专栏中用到的所有Java语言的语法。</p><h2>Hello World</h2><p>我们先来看一下，Java语言的Hello World代码如何编写。</p><p>在Java中，所有的代码都必须写在类里面，所以，我们定义一个HelloWorld类。main()函数是程序执行的入口。main()函数中调用了Java开发包JDK提供的打印函数System.out.println()来打印hello world字符串。除此之外，Java中有两种代码注释方式，第一种是“//注释…”双斜杠，表示后面的字符串都是注释，第二种是“/*注释…*/”，表示中间的内容都是注释。</p><!-- [[[read_end]]] --><pre><code>/*hello world程序*/\npublic class HelloWorld {\n    public static void main(String []args) {\n        System.out.println(&quot;Hello World&quot;); //打印Hello World\n    }\n}\n</code></pre><h2>基本数据类型</h2><p>Java语言中的基本数据类型跟其他语言类似，主要有下面几种：</p><ul>\n<li>整型类型：byte（字节）、short（短整型）、int（整型）、long（长整型）</li>\n<li>浮点类型：float（单精度浮点）、double（双精度浮点）</li>\n<li>字符型：char</li>\n<li>布尔型：boolean</li>\n</ul><p>如下，我们来定义一个基本类型变量：</p><pre><code>int a = 6;\n</code></pre><p>除此之外，为了方便我们使用，Java还提供了一些封装这些基本数据类型的类，这些类实现了一些常用的功能函数，可以直接拿来使用。常用的有下面几个类：</p><ul>\n<li>Integer：对应封装了基本类型int；</li>\n<li>Long：对应封装了基本类型long；</li>\n<li>Float：对应封装了基本类型float；</li>\n<li>Double：对应封装了基本类型double；</li>\n<li>Boolean：对应封装了基本类型boolean；</li>\n<li>String：对应封装了字符串类型char[]。</li>\n</ul><p>如下，我们来定义一个Integer对象：</p><pre><code>Integer oa = new Integer(6);\n</code></pre><h2>数组</h2><p>Java中，我们使用[]来定义一个数组，如下所示：</p><pre><code>int a[] = new int[10]; //定义了一个长度是10的int类型数组\n</code></pre><p>在Java中，我们通过如下方式访问数组中的元素：</p><pre><code>a[1] = 3; //将下标是1的数组元素赋值为3\nSystem.out.println(a[2]); //打印下标是2的数组元素值\n</code></pre><h2>流程控制</h2><p>流程控制语句跟其他语言类似，主要有下面几种。</p><ul>\n<li>if-else语句，代码示例如下所示：</li>\n</ul><pre><code>// 用法一\nint a;\nif (a &gt; 1) {\n  //执行代码块\n} else {\n  //执行代码块\n}\n\n// 用法二\nint a;\nif (a &gt; 1) {\n  //执行代码块\n} else if (a == 1) {\n  //执行代码块\n} else {\n  //执行代码块\n}\n</code></pre><ul>\n<li>switch-case语句，代码示例如下所示：</li>\n</ul><pre><code>int a;\nswitch (a) {\n  case 1:\n    //执行代码块\n    break;\n  case 2:\n    //执行代码块\n    break;\n  default:\n    //默认执行代码\n}\n</code></pre><ul>\n<li>for、while循环，代码示例如下所示：</li>\n</ul><pre><code>for (int i = 0; i &lt; 10; ++i) {\n  // 循环执行10次此代码块\n}\n\nint i = 0;\nwhile (i &lt; 10) {\n  // 循环执行10次此代码块\n}\n</code></pre><ul>\n<li>continue、break、return，代码示例如下所示：</li>\n</ul><pre><code>for (int i = 0; i &lt; 10; ++i) {\n  if (i == 4) {\n    continue; //跳过本次循环，不会打印出4这个值\n  }\n  System.out.println(i);\n}\n\nfor (int i = 0; i &lt; 10; ++i) {\n  if (i == 4) {\n    break; //提前终止循环，只会打印0、1、2、3\n  }\n  System.out.println(i);\n}\n\npublic void func(int a) {\n  if (a == 1) {\n    return; //结束一个函数，从此处返回\n  }\n  System.out.println(a);\n}\n</code></pre><h2>类、对象</h2><p>Java语言使用关键词class来定义一个类，类中包含成员变量（也叫作属性）和方法（也叫作函数），其中有一种特殊的函数叫作构造函数，其命名比较固定，跟类名相同。除此之外，Java语言通过new关键词来创建一个类的对象，并且可以通过构造函数，初始化一些成员变量的值。代码示例如下所示：</p><pre><code>public class Dog { // 定义了一个Dog类\n  private int age; // 属性或者成员变量\n  private int weight;\n\n  public Dog(int age, int weight) { // 构造函数\n    this.age = age;\n    this.weight = weight;\n  }\n\n  public int getAge() { // 函数或者方法\n    return age;\n  }\n  \n  public int getWeigt() {\n    return weight;\n  }\n  \n  public void run() {\n    // ...\n  }\n}\n\nDog dog1 = new Dog(2, 10);//通过new关键词创建了一个Dog对象dog1\nint age = dog1.getAge();//调用dog1的getAge()方法\ndog1.run();//调用dog1的run()方法\n</code></pre><h2>权限修饰符</h2><p>在前面的代码示例中，我们多次用到private、public，它们跟protected一起，构成了Java语言的三个权限修饰符。权限修饰符可以修饰函数、成员变量。</p><ul>\n<li>private修饰的函数或者成员变量，只能在类内部使用。</li>\n<li>protected修饰的函数或者成员变量，可以在类及其子类内使用。</li>\n<li>public修饰的函数或者成员变量，可以被任意访问。</li>\n</ul><p>除此之外，权限修饰符还可以修饰类，不过，专栏中所有的类定义都是public访问权限的，所以，我们可以不用去了解三个修饰符修饰类的区别。</p><p>对于权限修饰符的理解，我们可以参看下面的代码示例：</p><pre><code>public class Dog {// public修饰类\n  private int age; // private修饰属性，只能在类内部使用\n  private int weight;\n  \n  public Dog(int age, int weight) {\n    this.age = age;\n    this.weight = weight;\n  }\n\n  public int getAge() { //public修饰的方法，任意代码都是可以调用\n    return age;\n  }\n  \n  public void run() {\n    // ...\n  }\n\n}\n</code></pre><h2>继承</h2><p>Java语言使用extends关键字来实现继承。被继承的类叫作父类，继承类叫作子类。子类继承父类的所有非private属性和方法。具体的代码示例如下所示：</p><pre><code>public class Animal { // 父类\n  protected int age;\n  protected int weight;\n  \n  public Animal(int age, int weight) {\n    this.age = age;\n    this.weight = weight;\n  }\n  \n  public int getAge() { // 函数或者方法\n    return age;\n  }\n  \n  public int getWeigt() {\n    return weight;\n  }\n  \n  public void run() {\n    // ...\n  }\n}\n\npublic class Dog extends Animal { // 子类\n  public Dog(int age, int weight) { // 构造函数\n    super(age, weight); //调用父类的构造函数\n  }\n\n  public void wangwang() {\n    //...\n  }\n}\n\npublic class Cat extends Animal { //子类\n  public Cat(int age, int weight) { // 构造函数\n    super(age, weight); //调用父类的构造函数\n  }\n  \n  public void miaomiao() {\n    //...\n  }\n}\n\n//使用举例\nDog dog = new Dog(2, 8);\ndog.run();\ndog.wangwang();\nCat cat = new Cat(1, 3);\ncat.run();\ncat.miaomiao();\n</code></pre><h2>接口</h2><p>Java语言通过interface关键字来定义接口。接口中只能声明方法，不能包含实现，也不能定义属性。类通过implements关键字来实现接口中定义的方法。在专栏的第8讲中，我们会详细讲解接口，所以，这里我只简单介绍一下语法。具体的代码示例如下所示：</p><pre><code>public interface Runnable {\n  void run();\n}\n\npublic class Dog implements Runnable {\n  private int age; // 属性或者成员变量\n  private int weight;\n\n  public Dog(int age, int weight) { // 构造函数\n    this.age = age;\n    this.weight = weight;\n  }\n\n  public int getAge() { // 函数或者方法\n    return age;\n  }\n\n  public int getWeigt() {\n    return weight;\n  }\n\n  @Override \n  public void run() { //实现接口中定义的run()方法\n    // ...\n  }\n}\n</code></pre><h2>容器</h2><p>Java提供了一些现成的容器。容器可以理解为一些工具类，底层封装了各种数据结构。比如ArrayList底层就是数组，LinkedList底层就是链表，HashMap底层就是散列表等。这些容器我们可以拿来直接使用，不用从零开始开发，大大提高了编码的效率。具体的代码示例如下所示：</p><pre><code>public class DemoA {\n  private ArrayList&lt;User&gt; users;\n  \n  public void addUser(User user) {\n    users.add(user);\n  }\n}\n</code></pre><h2>异常处理</h2><p>Java提供了异常这种出错处理机制。我们可以指直接使用JDK提供的现成的异常类，也可以自定义异常。在Java中，我们通过关键字throw来抛出一个异常，通过throws声明函数抛出异常，通过try-catch-finally语句来捕获异常。代码示例如下所示：</p><pre><code>public class UserNotFoundException extends Exception { // 自定义一个异常\n  public UserNotFoundException() {\n    super();\n  }\n\n  public UserNotFoundException(String message) {\n    super(message);\n  }\n\n  public UserNotFoundException(String message, Throwable e) {\n    super(message, e);\n  }\n}\n\npublic class UserService {\n  private UserRepository userRepo;\n  public UserService(UseRepository userRepo) {\n    this.userRepo = userRepo;\n  }\n\n  public User getUserById(long userId) throws UserNotFoundException {\n    User user = userRepo.findUserById(userId);\n    if (user == null) { // throw用来抛出异常\n      throw new UserNotFoundException();//代码从此处返回\n    }\n    return user;\n  }\n}\n\npublic class UserController {\n  private UserService userService;\n  public UserController(UserService userService) {\n    this.userService = userService;\n  }\n  \n  public User getUserById(long userId) {\n    User user = null;\n    try { //捕获异常\n      user = userService.getUserById(userId);\n    } catch (UserNotFoundException e) {\n      System.out.println(&quot;User not found: &quot; + userId);\n    } finally { //不管异常会不会发生，finally包裹的语句块总会被执行\n      System.out.println(&quot;I am always printed.&quot;);\n    }\n    return user;\n  }\n}\n</code></pre><h2>package包</h2><p>Java通过pacakge关键字来分门别类地组织类，通过import关键字来引入类或者package。具体的代码示例如下所示：</p><pre><code>/*class DemoA*/\npackage com.xzg.cd; // 包名com.xzg.cd\n\npublic class DemoA {\n  //...\n}\n\n/*class DemoB*/\npackage com.xzg.alg;\n\nimport java.util.HashMap; // Java工具包JDK中的类\nimport java.util.Map;\nimport com.xzg.cd.DemoA;\n\npublic class DemoB {\n  //...\n}\n</code></pre><h2>总结</h2><p>今天，我带你一块学习了专栏中用到的所有的Java基本语法。不过，我希望你不要纠结于专栏或者某某书籍到底是用什么编程语言来写的。语言层面的东西完全不会限制我的讲解和你的理解。这就像我们读小说一样，不管它是用英语写的，还是中文写的，故事都可以同样精彩。而且，多了解一些Java语法，对于你今后阅读Java语言编写的书籍或者文档，也很有帮助。</p><p>实际上，我之前在Google工作的时候，大家都不太在意自己熟悉的是哪种编程语言，很多同事都是“现学现卖”，什么项目适合用什么语言就现学什么语言。除此之外，Google在招聘的时候，也不限定候选人一定要熟悉哪种编程语言，也很少问跟语言特性相关的问题。因为他们觉得，编程语言只是一个工具，对于一个有一定学习能力的人，学习一门编程语言并不是件难事。</p><p>除此之外，对于专栏中的代码示例，你也可以用你熟悉语言重新实现一遍，我相信这也是件很有意义的事情，也更能加深你对内容的理解。</p><h2>课堂讨论</h2><p>不同的公司开发使用的编程语言可能不一样，比如阿里一般都是用Java，今日头条用Go、C++比较多。在招聘上，这些公司都倾向于招聘熟悉相应编程语言的同学，毕竟熟练掌握一门语言也是要花不少时间的，而且用熟悉的编程语言来开发，肯定会更得心应手，更不容易出错。今天课堂讨论的话题有两个：</p><ol>\n<li>分享一下你学习一门编程语言的经历，从入门到熟练掌握，大约花了多久的时间？有什么好的学习编程语言的方法？</li>\n<li>在一个程序员的技术能力评价体系中，你觉得“熟练使用某种编程语言”所占的比重有多大？</li>\n</ol><p>欢迎在留言区写下你的想法，和同学一起交流和分享。如果有收获，也欢迎你把这篇文章分享给你的朋友。</p>",
                "article_title": "加餐一 | 用一篇文章带你了解专栏中用到的所有Java语法"
            },
            {
                "title": "加餐二 | 设计模式、重构、编程规范等相关书籍推荐",
                "herf": "https://time.geekbang.org/column/article/172690",
                "id": "172690",
                "content": "<p>有关设计模式、重构、编程规范等的经典书籍很多，有很多你应该已经听说过、甚至看过。今天，我就结合我的经验，对这些书籍进行一个整理和点评。你可以据此来选择适合你的书籍，结合着专栏一块儿来学习，这样学习效果会更好。</p><h3>1.《设计模式》</h3><p><img src=\"https://static001.geekbang.org/resource/image/1d/ab/1deb18c033909ca544195435696e1aab.png\" alt=\"\"></p><p>学习设计模式，不知道GoF的《设计模式》估计会被人笑话的。这本书是设计模式的开山之作。经典的23种设计模式最早就诞生于这本书。这本书很薄，只有200多页。但是，我个人觉得，这本书还是比较晦涩难懂的。回想起来，我在读大学的时候，就读过几遍此书，但每次都是一知半解，读一遍忘一遍。如果你是设计模式的初学者，不建议从这本书看起。如果你对设计模式已经有所了解，还是蛮推荐你去看下这本经典书的。</p><h3>2.《Head First设计模式》</h3><p><img src=\"https://static001.geekbang.org/resource/image/32/2d/32bf8494047fbdcf4fb1acb0cb1b4f2d.png\" alt=\"\"></p><p>如果说刚刚提到的《设计模式》是最经典的设计模式书籍，那《Head First设计模式》就是最通俗易懂的。这本书看起来很厚，但每页里的内容并没有那么密集。这本书最大的特点就是口语化、场景化。整本书围绕几个人的对话来展开。里面的例子比较脱离实践，但比较容易看懂。如果你之前对设计模式没有太多了解，这本书无疑是你的首选。</p><h3>3.《Java与模式》</h3><p><img src=\"https://static001.geekbang.org/resource/image/69/0e/6996f3e8c094051d44e94bbbbb94f60e.png\" alt=\"\"></p><p>这本书可能并没有那么多人知道，出版的时间也比较久远，而且是跟Java语言比较紧耦合，里面很多例子都是在剖析JDK里的设计模式。不过这可能是最贴近实战的一本设计模式书籍了，里面包含的实战案例，应该是目前我读过的设计模式书籍中最多的。不过，我个人觉得文笔稍微有些晦涩，有些内容可能要反复读一下才能理解。如果你熟悉Java语言，在我推荐的其他书籍都看完的前提下，没事的时候可以看看这本书。</p><!-- [[[read_end]]] --><h3>4.《深入浅出面向对象分析与设计》</h3><p><img src=\"https://static001.geekbang.org/resource/image/25/a4/25ef700c48d79b68b994ebab67fb8fa4.png\" alt=\"\"></p><p>这本书跟《Head Frist设计模式》都是出自“Head First”系列，写作风格也相同，不过也略显啰嗦。从书名中我们就可以看出，这本书主要是讲面向对象分析和设计。实际上，很多关于面向对象分析和设计书籍都侧重讲UML，讲得真的好的书籍却并不多。除此之外，我觉得面向对象分析和设计的理论知识并不多，关键还是实践。所以，如果你工作比较忙，看我的专栏就足够了。如果你特别想系统地学一下的话，看看这本书也完全足够了。</p><h3>5.《代码大全》</h3><p><img src=\"https://static001.geekbang.org/resource/image/66/a8/6612c56e4d5f1d67ecd678d9810938a8.png\" alt=\"\"></p><p>这是一本有近千页大部头。不过，这本书讲的东西很杂，不是很聚焦，涵盖了软件开发方法、编程技巧、编码规范、重构等等诸多方面。书如其名，这本书其实更像是软件开发方面的工具类的百科全书。在读过我推荐的其他书籍之后，这本书快速地翻一遍就可以了。</p><h3>6.《代码整洁之道》</h3><p><img src=\"https://static001.geekbang.org/resource/image/09/47/09063c31913414e8c93fb5469fea7f47.png\" alt=\"\"></p><p>这本书非常值得推荐。它主要是讲编码规范，除此之外，还讲到了一些有关设计原则、单元测试、并发编程的东西。因为内容比较侧重编码规范，所以每个知识点都非常明确，能够很容易落地指导你的开发，能够立竿见影地改善你的代码质量。</p><h3>7.《编写可读代码的艺术》</h3><p><img src=\"https://static001.geekbang.org/resource/image/a0/91/a07e5ed7549e272055c0730821431491.png\" alt=\"\"></p><p>从书名我们就可以看出，本书主要是教你如何写出可读性好的代码，实际上也是在讲比较偏向细节的编码规范。它的内容跟《代码整洁之道》有部分重复，但是推荐你也看一下。《代码整洁之道》《代码大全》《编写可读代码的艺术》三本书是讲编码规范方面的三大著作。看完这三本书，基本的编码规范你就掌握全了。</p><h3>8.《重构》</h3><p><img src=\"https://static001.geekbang.org/resource/image/ac/02/ac08ba290bdb1081f5f0efa1deab2502.png\" alt=\"\"></p><p>这本书的作者是Martin Fowler，他写了很多跟软件开发相关的经典书籍。这本《重构》无疑是他最经典的作品。书中讲到了诸多代码的坏味道，并且给出了相应的改进方法，是作者一手开发经验的总结输出。我推荐本书的原因倒不是说书里面的内容有多真知灼见、让人耳目一新，而是这本书的内容总结得非常全面，很适合帮你去做一个整体、系统的梳理。</p><h3>9.《重构与模式》</h3><p><img src=\"https://static001.geekbang.org/resource/image/01/d1/011c721627e3fa1c7b0ea5230a42f9d1.png\" alt=\"\"></p><p>我们之前讲过，设计模式一个重要的应用场景就是代码重构。这本书主要讲如何应用设计模式来重构代码，改善代码设计。如果说《重构》是讲如何做低层次的重构，那这本书就是在讲如何做高层次的重构，也就是我们专栏中要讲到的小重构和大重构。这本书非常推荐你读一下，它能让你知道，为什么要用设计模式，如何有的放矢地应用设计模式，而非只是无痛呻吟。</p><h3>10.《修改代码的艺术》</h3><p><img src=\"https://static001.geekbang.org/resource/image/c2/f7/c25b98e63f7fef3f8c12a972b2ac62f7.png\" alt=\"\"></p><p>如果说《重构》那本书是从编码规范上来讲如何重构，《重构和模式》是从设计模式上来讲如何重构，那这本书可以粗鲁地归为从面向对象设计思想、设计原则上来讲重构。除此之外，这本书更偏向于教你如何来重构，不像上面两本书那样聚焦，所以是一个很好的补充。这三本书合起来称为重构“三部曲”。这本书的示例代码是用C++写的，不过也很容易看懂，很推荐你读一下。</p><h2>总结</h2><p>今天的加餐内容就这些，我来稍微总结回顾一下推荐的书籍。这些书我基本上都看过，并且很多都看了好几遍，如果你时间宽裕，想要真正掌握写出优秀代码的能力，非常推荐你认真看一下，相信会对你有非常大的帮助。</p><p><img src=\"https://static001.geekbang.org/resource/image/5d/41/5dd01ae60a6b904756492f4aecd4d041.png\" alt=\"\"></p><h2>课堂讨论</h2><p>我罗列的书籍中，你读过哪几本？哪一本或者几本对你影响最大？除了我罗列的这些，还有哪些书籍你觉得值得推荐？</p><p>欢迎在留言区写下你的答案，和同学一起交流和分享。如果有收获，也欢迎你把这篇文章分享给你的朋友。</p>",
                "article_title": "加餐二 | 设计模式、重构、编程规范等相关书籍推荐"
            },
            {
                "title": "春节特别加餐 | 王争：如何学习《设计模式之美》专栏？",
                "herf": "https://time.geekbang.org/column/article/192789",
                "id": "192789",
                "content": "<p>你好，我是王争。今天是春节，首先祝你在新的一年，学业进步，工作顺利。放假期间，也不要忘记学习啊！</p><p>到此为止，咱们的《设计模式之美》快要更新过半了。很多小伙伴反馈的问题我都看到了。这里我也来讲一下，到底该如何学习《设计模式之美》专栏，才能做到事半功倍、有的放矢？</p><p><strong>《设计模式之美》专栏相对于我的另一个专栏《数据结构与算法之美》来说，内容看似更容易，实际上却更难。</strong>为什么这么说呢？</p><p>从我写作的角度来说，《设计模式之美》要更加有难度。因为《数据结构与算法之美》的知识点都比较明确，一篇讲一个数据结构或算法。我只需要把原理、实现讲清楚，再举个实战的例子就基本大功告成了。</p><p>但是，《设计模式之美》中的知识点就没那么明确了。每个知识点到底该如何讲，并没有太多的参考。特别是专栏的前一部分，设计原则和思想，我在写专栏的时候参考了大量的书籍和资料。不瞒你说，大部分现有资料都讲得很浅，而且“互相借鉴”的痕迹也很明显。如果你之前对设计原则、思想、模式有所了解，或者看过挺多相关的书籍，应该能发现，我的专栏跟其他书籍的讲解还是有比较大的区别，这其中融入了我很多自己的思考和见解，这也是我的专栏与其他书籍区别最大的地方。</p><p>相对应的，从你学习的角度来说，《设计模式之美》也更有难度。它的难跟算法的难还不大一样。算法是原理难、实现难，最后才是应用难。而设计模式正好相反，原理、实现都挺简单的，基本上你一看就会觉得懂了，但是真正的能把它用到项目中，还是比较难的。对于很多人来说，你问他个具体的设计原则、思想、模式的原理和实现，他都能回答得头头是道，但是，在实际的项目开发中，写出来的代码质量还是很差。这种情况出现的原因还是相关的知识点都过于抽象，通俗点讲就是有点“假大空”，不够具体、不太能落地，导致理论和实践容易脱节。</p><!-- [[[read_end]]] --><p>所以，有些小伙伴总感觉《设计模式之美》学起来比《数据结构与算法之美》要简单，容易看懂，实际上这是种错觉。如果你也有这种感觉，那你要警醒了，因为你可能并没有真正读懂专栏的精髓。说了这么多，接下来我就讲讲，我为什么说你可能没有体会到文章的精髓，以及到底该如何来学习这个专栏。</p><h2>1.建立完善的知识体系</h2><p>你可能已经注意到，虽然这个专栏的名字叫《设计模式之美》，但专栏内容并不局限于此。实际上，整个专栏是围绕着教你如何编写高质量代码来设计的。</p><p>在整个专栏中，我试图给你建立完善的知识体系，所以，从内容上来讲，涵盖了编写高质量代码的方方面面，比如面向对象、设计原则、设计思想、编码规范、重构技巧、设计模式。虽然在有限的100篇文章、50万字内，我可能没法儿把每一个知识点都讲解得无比详细、全面，但我整理的这份知识框架，相当于给你指出了一个深入研究的方向，你可以按图索骥，积累起来会更快。先建立整体的知识框架，再慢慢深入、各个攻破，这也是学习任何一门新技术、新知识最有效的方法。</p><p>所以，<span class=\"orange\">这里给你布置一个小任务，闭上眼睛，想一想整个专栏都会讲哪些内容？已经讲过的设计原则和思想，都讲了哪些内容？你能想起来多少？</span></p><h2>2.建立代码质量意识</h2><p>实际上，建立正确的技术认知和技术观，比单纯学技术、学知识点更重要。</p><p>我举个例子，专栏中讲到单元测试的时候，并没有讲跟某个测试框架相关的技术点。因为我觉得这些很容易通过看文档学习，而我也不可能写得比文档更全面、更权威。实际上，通过那节课，我想要让你了解的是单元测试的好处，让你真正意识到单元测试的重要性，从心底认可这件事。还有，我在讲到重构的时候，也一直在强调要建立持续重构意识。整个专栏也都是在传递给你代码质量的重要性，让你意识到好代码和差代码的差别在哪里。</p><p>在学完专栏的时候，如果某些原则、思想、模式你记不大清了，那也没关系，只要你能在写代码的时候，能不由自主地去思考代码质量，有意识地去打磨代码，对代码质量有所追求了，那就说明你入门了，也就达到了我们专栏学习的目的。至于具体的知识点，随着时间的推移有所忘记，实际上并不碍事，多看几遍，多实践实践就好了。</p><p>这里，我也问你一个问题，<span class=\"orange\">你可以想一想，你写代码或者读别人代码\b的时候，是否开始思考代码质量问题呢？如果还没有，那再给你布置一个任务，在今后的一个月内，写代码前、中、后，都思考一下代码的扩展性、可读性、可维护性、可测试性等代码质量问题，看看自己编写的代码是否符合这些质量要求，有没有需要继续优化重构的地方。</span></p><h2>3.主动学习而非被动学习</h2><p>“师傅领进门，修行靠个人”，这句话说得特别好。同样听一个老师讲课，一个班级里面总有人会考90分，甚至满分，也会总会有人考不及格。差距在哪里呢？道理很简单，那就是你有没有用心学习。</p><p>类比到我们的专栏学习中，如果你只是走马观花地看一遍、跟听小说一样听一遍，收获肯定是甚微的，也就会出现常说的“过不几天就忘了”的情况。因为这是一种被动学习方法，左耳朵进右耳朵出，脑子里怎么会留住东西呢？相反，如果你能学会主动学习、主动思考，遇到不会的、理解不了的知识点，自己主动去思考一下、查查资料，或者跟同事讨论一下，试着把专栏里的内容自己总结一下，认真思考每一个课后题，这样的学习效果要比被动学习强好几倍。</p><p>关于这一点，我也给你留个作业：<span class=\"orange\">找一篇你觉得还没有透彻理解的文章，花上一天的时间，把里面的代码自己实现一遍，把文章的重点内容自己思考、整理，输出成文章。你可以看看，这样是否要比单纯看一遍收获更多呢？</span></p><h2>4.多读几遍更有收获</h2><p>《设计模式之美》专栏的内容都不难理解，每篇文章仅有四五千字，十几分钟的音频，但是，多读几遍你就会发现，每读一遍都会有不同的收获。</p><p>如果你只是看一遍、听一遍，怎么能达到像我一样对知识点的理解程度呢？我自己在写专栏的时候，可是查阅了大量的文章和资料。有的时候，一篇文章我要写好几天，这期间有长时间、高强度的阅读、思考和揣摩。你如果都不愿意花跟我一样多的时间，怎么能期望跟我有一样的水平呢？</p><p>一个人的认知和理解能力是受限于他的经历和经验的。如果你刚毕业不久，开发经验不多，看专栏的时候，难免会抓不住重点或者理解得不够透彻。那该怎么办呢？我的建议是，千万不要把学习专栏看成一蹴而就的事情，看完一遍就丢在一边了，而是要反反复复进行学习。看一遍理论之后，你可以在项目中尝试着实践一下，然后回过头来再看一遍，直到没有新的知识点可以汲取为止。这个过程可能需要持续很长时间，可能是1年、2年甚至是3年、5年，但只有这样，你才能积累出真正的能力、建立真正的竞争壁垒，而不只是学一些快餐知识、填补眼前的焦虑。</p><p>在《数据结构与算法之美》专栏中，我也说过，你要做一个长一点的学习计划。实际上，学习《设计模式之美》专栏也是如此，毕竟这两门课都是比较基础的，而且跟我们平时的开发比较相关，多花点时间在基础的知识上，收益要远大于学习很多花哨的新技术、新框架。</p><p>关于这一点，我再给你布置一个作业：<span class=\"orange\">找专栏中一篇文章，反复读上10遍（当然是带着思考去读哈）。你看看是不是比只读一遍要理解得更透彻？是不是之前不能理解的地方自然就理解了呢？是不是每次读的时候都有新的收获？</span></p><h2>5.学会把代码写到极致</h2><p>我经常说，写100段烂代码都不如写1段好代码，对代码能力的提高大。实际上，这个道理也可以应用到任何学习工作中，堆量只需要时间，但并不是每个人都能把事情做到极致，而能把一件事情做到极致的人，往往也能把其他很多事情做到极致。这也是为什么，很多人在某一行业做得很好，跨行去做另一个看似不相干的事情也同样能做得非常好。牛人往往都是能把一件事情做到极致的人。如果所有的事情都只能做到一般好，那你注定也只能做一个平凡的人。</p><p>关于这一点，我也布置一个作业给你：<span class=\"orange\">找一段你觉得写得很烂的代码，花上一个礼拜的时间，反复思考如何优化，把它优化到足够好。</span></p><h2>总结</h2><p>说了这么多，说实话，我知道这些道理很多人都知道。但是，能真正落实执行，并且执行到位的人不多。就光我说的这几个作业，估计能100%完成的也没有几个人。</p><p>你说人和人之间的差距在哪里？就在这里。</p><p>不要期望我的专栏有什么杀手锏可以教给你，不要期望看了我的专栏之后不费力气就能成为代码高手。还是那句话，师傅领进门，修行靠个人。我能做的就是尽量地将知识讲得通俗、透彻，把我的经验尽可能地传授给你，而这些只占1%，剩下99%都要靠你自己去努力。</p><p>如果说成为代码高手是万里长征，那我只能给你指明方向，告诉你如何去走。剩下的万里长征没人能替你去走，需要你一步一步、踏踏实实，自己去走完。</p><h2>课堂讨论</h2><p>最后，你可以在留言区讲一讲自己的<strong>新年学习计划</strong>。</p><p>如果有收获，欢迎收藏这篇文章，并把它分享给你的朋友。</p>",
                "article_title": "春节特别加餐 | 王争：如何学习《设计模式之美》专栏？"
            },
            {
                "title": "加餐三 | 聊一聊Google是如何做Code Review的",
                "herf": "https://time.geekbang.org/column/article/252937",
                "id": "252937",
                "content": "<p>100篇的正文已经全部结束了，估计你学得也有点累了吧？时隔这么久，正文终于结束了，从今天起，我们继续加餐内容。</p><p>跟正文内容相比，加餐内容我希望尽量轻松有趣，帮你拓展知识面，主要是课后的一些小分享，有的会以讲故事为主，但我也希望它能给你带来收获。如果能够引发你的思考和共鸣那就更好了。所以，我也希望你在留言区，多说说自己的感受和看法，多多与我互动。</p><p>话不多说，让我们正式开始今天加餐的内容吧！</p><h2>为什么国内企业不重视Code Review？</h2><p>在专栏<a href=\"https://time.geekbang.org/column/article/232687\">第80讲</a>中，我列举了Code Review的重要性，在项目中执行Code Review会带来哪些好处，以及如何克服一些常见的难题，在项目中启动Code Review等等。今天，我们想再继续这个话题，和你聊一下Code Review。不过，我刚才也说了，今天的内容会相对轻松一些，我会主要给你讲讲我在Google做Code Review的一些经验和心得。</p><p>我们都知道，Google在Code Review方面做得非常好，可以说是很多公司学习的榜样。从我个人的经历来说，我的技术成长相当大的一部分得益于当年在Google的Code Review。所以，我也希望更多的同行能意识到Code Review的重要性，能够在项目中推行Code Review，受益于Code Review。</p><!-- [[[read_end]]] --><p>但据我了解，国内的大部分公司都不怎么接受Code Review，在开发中，根本没有Code Review的流程。所以，我一直思考，到底是什么原因，导致这么优秀的一种开发模式，在国内的技术圈内没有被发扬光大。很多人会认为，主要原因是，项目工期紧，没时间做Code Review。我觉得这只是表面的原因，最根本的原因还是缺少技术文化传承。</p><p>我们知道，普遍而言，越是大公司里的工程师，技术能力会越强，技术影响力会越大。这些公司的工程师，即便跳槽去其他公司，一般都会担任核心成员或者Leader的角色。但是，在国内，即便像BAT这些输出有影响力工程师最多的一线公司，也没有很好地实践Code Review，相对应的，这些公司的工程师也就没有一手的Code Review的经验和感受，更无法了解到Code Review的好处，也更不会在团队、公司，甚至技术圈中去推行Code Review了。</p><p>打个不恰当的比方，这些一线互联网公司的工程师一直接受着“996”狼性文化价值观的熏陶，即便跳槽去其他公司，作为资深员工或者技术Leader，他们也会带领新的团队开始996，最终导致整个IT行业的加班氛围都很浓，不加班反倒会显得不正常。</p><p>用996作类比，如果BAT这些比较有技术影响力的公司，内部对Code Review很认可，执行得非常好，从这些公司往外输出的工程师，就会像我一样，大力传播Code Review。星星之火可以燎原，慢慢地，整个技术圈就会接受并且推行Code Review了。</p><p>实际上，据我所知，不只是我，只要是从Google跳槽出来的工程师，到了其他公司之后，都特别热衷于传播Code Review。而且，只要是被Google工程师带领过的团队，在开发流程中严格执行过Code Review的团队，对Code Review都无比认可。所以，我个人觉得，很多人不认可、不推行Code Review，最直接的原因还是没有经历过Code Review，没有有经验的人来带。</p><p>实际上，才开始接触Code Review的时候，我也比较反感。我刚毕业就进入了Google，在此之前，上学的时候，尽管也写了很多代码，也参与过一些垂直课题的研发，但是，那时候的开发只是为了完成功能，从来没有考虑过代码质量问题、代码设计问题，更别提Code Review了。现在想想，自己当时对Code Review的认知水平，跟现在很多国内工程师的认知其实是差不多的。</p><p>所以，在一开始进入Google的时候，对于Code Review我也是不怎么接受的。我第一次提交的代码不足百行，就被Leader Review出了n多问题，而且大部分问题都非常细节，比如变量的命名不够达意、注释不够规范、多了一个空行、少了一个空格之类的。对于这些琐碎的细节，我当时心里挺排斥的，心想：我是来“造火箭”的，为什么成天纠结于这些“拧螺丝”的事情呢？</p><p>现在回去想想，当时的想法真的挺幼稚的。</p><p>如果站在团队协作的角度来看，对于一个长期维护、多人参与、代码比较多的项目来说，代码的可读性、可维护性等与质量相关的问题，是非常重要的。所以，Code Review作为保证代码质量的最有效手段之一，也就非常有必要了。如此吹毛求疵地执行Code Review，看似非常极端，但也表明了公司强硬的态度、坚定的立场，就是要把Code Review执行彻底。这也是Code Review没有在Google流于形式的一个很大的原因。</p><p>在入职一段时间后，来来回回经过多次Code Review之后，我的代码质量整体提高了很多，被Review出的问题也越来越少了，我也切身地体会到Code Review的好处。因此，慢慢地，对这件事，我从排斥变得认可。与此同时，我也慢慢地开始Review别人的代码了。</p><h2>Google是如何进行Code Review的？</h2><p>在Google，我们把每次提交的代码片段叫做一个CL，全称是Change List。它就相当于GitHub中的PR（Pull Request）。每个CL都要至少一个Owner和一个具有Readability的同事Approve，才能提交到代码仓库中。其中，Owner一般都是技术Leader或者项目负责人，而Readability是一个证书，表示你具有了写出可读代码、符合编码规范代码的能力。Readability会细化到每种编程语言，比如Java Readability、C++ Readability等。</p><p>如果你想申请某种语言的Readability，你就要提交一段至少包含100行代码、并且稍微有点复杂的CL给Readablity评审委员会。评审委员会会指派一个资深工程师Review你的代码，给你一些修改建议，然后，你需要根据修改建议对代码进行修改，再提交Review。这样来来回回几次之后，他觉得没问题了，就会给你颁发Readability。有了Readability之后，你的Review才真的能起到Approve的作用。当然，即便没有Readability，你对同事代码的Review本身也是有价值的。所以，并非只有Readability的人才能Review别人的代码。</p><p>在Google，每种编程语言都有对应的编码规范。但是，Code Review本身并没有统一的Check list。在Code Review的时候，除了编码规范可以参考之外，大部分都是靠工程师自身的经验来Review。不过，Review考虑的也无外乎这样几个常见的方面：代码结构是否合理、代码是否容易理解、业务是否正确、异常考虑是否全面、是否有隐藏的bug、线程是否安全、性能是否满足业务需求、是否符合编码规范等等。</p><p>Code Review听起来很复杂，要考虑的点很多，但实际上，等到你做熟练了之后，并不会花费太长的时间。一个CL从提交Review到最终合并到代码仓库，一般也就需要一天的时间。当然，对于一些比较大的CL、比较复杂的CL、有比较多争议的CL，以及一些新手的CL，可能会花费比较多的时间。</p><p>但是，大部分情况下，我们都不提倡太大的CL。太大的CL对代码审查者来说是很大的负担，Review过程会很慢，会导致代码迟迟提交不上去。</p><p>对于比较复杂的CL，我们一般建议要写好文档，或者通过类似Jira这样的项目工具，详细描述CL的前因后果、上下文背景。这样，代码审查者就能一眼看懂代码包含的设计意图。对于争议比较多的CL，我们建议直接当面沟通，这样也更加有效率。对于一些新手的CL，因为他们对编码规范等不熟练，可能来来回回要改好几次，才能满足要求，但这个过程是每个新人都要经历的，多改几次就好了。</p><p>实际上，Code Review并不神秘，如果你想了解更多关于Code Review的事情，可以去读一读Google官方公布的<a href=\"https://google.github.io/eng-practices/review/reviewer/\">Code Review最佳实践</a>。当然，如果有什么疑问，你也可以在留言区问我。</p><p>让国内大部分IT从业人士认识到Code Review的重要性，形成Code Review的技术文化，可能还需要一个漫长的时间。不过，我特别希望，你在学完专栏之后，能够意识到Code Review的重要性。有朝一日，当你成了领导，有了话语权、影响力之后，能够推动在团队、公司内进行Code Review，甚至为Code Review在整个国内技术圈中发扬光大贡献一份力量。</p><h2>课堂讨论</h2><p>你觉得为什么国内的大部分公司都不重视Code Review，在开发中都没有Code Review流程呢？你觉得如何把Code Review在国内技术圈中发扬光大呢？有什么好的建议吗？</p><p>欢迎留言和我分享你的想法，如果有收获，也欢迎你把这篇文章分享给你的朋友。</p>",
                "article_title": "加餐三 | 聊一聊Google是如何做Code Review的"
            },
            {
                "title": "加餐四 | 聊一聊Google那些让我快速成长的地方",
                "herf": "https://time.geekbang.org/column/article/254190",
                "id": "254190",
                "content": "<p>我一直强调，在项目中实践、由点及面的学习，是提高技术最有效的途径。但是，好的技术氛围、培养机制，也能打破通过项目单一成长的限制，获得更多项目之外的收获。很多公司，特别是一些大公司，在关注员工工作效率、工作产出的同时，也十分关注员工的个人成长、职场发展。今天，我就和你聊一聊Google有哪些让我快速成长的地方。</p><h2>完善的培训课程</h2><p>Google内部的课程是非常多的。有些是线下分享，有些是线上录播课程。在内容方面，课程也多种多样，有新技术的DogFood（比如我当年就参加过Go语言的），有入门级的101教程（比如针对后端工程师的前端入门课），还有比较有深度的系列教程（比如AI相关的课程）。所有的课程，只要你感兴趣，都可以自由选择来学习。</p><p>而且，最近我还听说，Google有个“G2G”学习计划，全称是Googler to Googler，意思就是Googlers之间互相学习。只要你有值得分享的东西，都可以录制成视频分享给其他同事。同理，你也可以从其他同事那里学习他们分享的技术。</p><p>总之，Google内部有大把的优质课程供你学习，这点对于好学的人来说，是非常幸福的一件事情。而且，得益于以结果为导向的企业文化，Google非常鼓励员工自我充电学习，不像有些公司反对员工占用上班时间来学习。</p><!-- [[[read_end]]] --><h2>公开的文档和代码</h2><p>除了各种线下和线上的课程之外，Google还有另外一块非常宝贵的学习资料，那就是文档和代码。在Google，除了特别核心的一些代码，比如跟搜索质量相关的代码，几乎所有的文档和代码都是公开的，你可以随意查看某个感兴趣的项目的设计文档和代码，比如Google Adwords的文档和代码等等。</p><p>你可能会说，Google就不怕员工泄露代码吗？在这一点上，Google相对是比较信任员工的。毕竟在招聘入口上做了过滤，员工本身的素质都不差，这点我们在下一篇加餐中还会讲到。</p><p>我们知道，Google有非常多优秀的开发框架，有些是开源的，有些是还没有公布、只限内部使用的。不管你对哪个开发框架感兴趣，你都可以在公司内部获取到一手的文档资料。通过阅读别人的文档，除了学习这些框架如何使用之外，我们还能学到很多关于设计、架构、解决方案等方面的经验和知识。</p><p>实际上，我觉得，代码公开最大好处并非是，你没事的时候就可以阅读别人的代码，毕竟泛泛地去读，效率也不会很高，收获也并不会很大，读完就忘了。相反，我一直强调，带着问题去学习是更有效的一种学习方法。所以，我觉得代码公开最大的好处是，当你想要实现某个功能的时候，或者为实现某个功能绞尽脑汁的时候，你只需要搜索一下代码仓库，就可以找到很多类似的优质代码做参考。对于很多新人或者初级工程师来说，参考别人的设计和实现，这样一方面可以提高开发速度、保证代码质量，另一方面也可以从高手那里学习好的设计思路和实现技巧，提高自己的设计和实现能力。</p><p>相反，据我所知，很多公司的代码都是限制访问的，员工只能查看一小部分相关项目的代码，极端情况下，只能阅读自己参与的项目的代码。相对而言，Google就“大方”很多。除了Code Review之外，我觉得，从n多Google高手的代码中学习设计和实现，是提高代码水平的另一个非常重要的渠道，也是让我代码能力成长最快的地方之一。</p><h2>清晰的成长路径</h2><p>除了有那么多课程、文档、代码来供我们自我学习之外，Google也非常关注员工的个人成长，希望能跟员工共同进步，而不只是将员工当成达成目标的工具。所以，在不同的阶段，公司会帮组员工制定不同的成长计划。</p><p>我们知道，像国内的一些大公司，比如BAT，在新员工入职的时候，一般都会有集中几天的入职培训。我当年加入Google的时候并没有这样的培训。我只参加过一次TGIF（Thanks God It’s Friday）上NewGoogler的欢迎仪式。</p><p>Google虽然没有集中的培训，但对于新入职的员工，公司会有一个新人的学习计划，主要涉及编码规范、单元测试、Code Review、开发工具、行为准则等方面的内容。我觉得，这一点对新人来说还是挺友好的。新人可以根据指引，一步一步完成学习计划里的内容，不会因为刚入职还未参加项目，而觉得无事可做。除此之外，在新员工入职时，公司还会分配一个同事作为mentor（导师）。任何工作、生活中的问题，你都可以向他请教，帮助你快速地融入公司。</p><p>除此之外，在工作中，每隔半年，你的Leader还会跟你一块制定OKR，也就是接下来半年你要做的事情，除了工作内容，这里面还会包含你的个人成长部分，比如你可以学习数据挖掘相关的知识，把这部分内容直接写到OKR中，这部分甚至可以跟你的工作没有任何关系，只是你对自己的自我提升。</p><p>不仅如此，你的Leader还会帮你制定升职计划。如果你有意申请下一轮晋升，领导一般会提前跟你一块规划，如何来做才能达成这个目标，比如做什么项目、做哪些有影响力的事情、管理多大的团队等等，也会有意安排一些帮你晋升的事情给你做。</p><p>为了不让工程师一直呆在舒适区，Google还非常鼓励内部转岗，希望员工不要一直做一个项目，鼓励员工跳出舒适区，换岗到其他团队，用不熟悉的语言、不熟悉的技术，去做一些不熟悉的项目。虽然我们知道，内部转岗机制也并非Google所特有的，很多公司都有，但是，真的执行得很顺畅的却不多。大部分公司都是跟风喊喊口号，员工真的要转岗的时候，条条关卡、困难重重。</p><p>上面的这些机制，貌似也没有什么特别的，很多公司都有。我要特别说的是，在Google，一对一的沟通非常多，特别是跟自己的Leader或者Manager，一般一两周就有一次，聊一聊自己这周的工作、想法、迷惑。这种沟通也能让你把工作、个人成长中的困难、疑问，及时反馈给领导，领导也可以及时地了解你的想法，对你进行指导，这也能避免很多工程师闷头干活，感觉不爽就立刻离职的情况。</p><h2>课堂讨论</h2><p>在你的职业生涯中，你觉得哪段工作经历对你的个人成长最有帮助？为什么呢？</p><p>欢迎留言和我分享你的想法。如果有收获，也欢迎你把这篇文章分享给你的朋友。</p>",
                "article_title": "加餐四 | 聊一聊Google那些让我快速成长的地方"
            },
            {
                "title": "加餐五 | 听一听小争哥对Google工程师文化的解读",
                "herf": "https://time.geekbang.org/column/article/255037",
                "id": "255037",
                "content": "<p>在技术圈里，我们经常听到“工程师文化”这个词。很多公司的HR、管理层都热衷于研究Google、Facebook、Netflix等大公司的文化，希望能打造成和它们一样优秀的工程师文化。</p><p>过去几年，好几位朋友也问过我，怎么才能打造跟Google一样的工程师文化？实际上回答这个问题之前，我们先要搞清楚，到底什么是工程师文化，Google的工程师文化是什么。今天，我就针对这三个问题，聊一聊我对Google工程师文化的理解。</p><p>话不多说，让我们正式开始今天的内容吧！</p><h2>什么是工程师文化？</h2><p>我觉得，很多人对“工程师文化”这个词有误解，以为它是一个描述词，甚至是褒义词，表示工程师占主导的公司文化。实际上，我觉得，“工程师文化”是一个名词，你可以类比饮食文化、穿衣文化来理解，它指的是技术团队的价值观（这个团队最看重什么，比如效率、质量等等），更直白点讲就是做事风格。</p><p>每个技术团队都有自己的工程师文化，不管这种文化有没有被书面或者口头上表达出来。不过，工程师文化包含很多方面，就像人的价值观一样，有爱情观、金钱观、人生观等等。所以，它很难用一句话来总结。但因为某些公司的工程师文化中的某些方面比较突出、比较有个性，我们常用这些特殊点来“以偏概全”地代指，比如某些公司的工程师文化是“狼性文化”“奋斗文化”“996文化”“PPT文化”“养老院文化”等等。</p><!-- [[[read_end]]] --><p>工程师文化会潜移默化地影响团队中的每个人，不认同这种文化的人会选择离开，最终留下的人价值观都会趋同。形成好的工程师文化的主要目的是，公司希望通过文化而非管理和流程，来驱动团队中的每个人，步调一致地工作和交流。</p><h2>Google的工程师文化是什么？</h2><p>为什么很多公司都要学习Google的工程师文化呢？我觉得主要原因是，Google凝聚了很多优秀的人才，并且往外输出了很多优秀的技术和产品，侧面上证明了Google工程师文化的优秀，所以，很多公司也希望能借鉴Google的工程师文化，把自己的技术团队也打造成像Google的技术团队那样，执行力强、工作效率高、创新能力强的优秀团队。</p><p>目标很明确，就是要打造优秀的技术团队。但要达成这样的目标，首先要理解Google的工程师文化是什么样的。</p><p>实际上，不同的人对Google工程师文化的理解是不同的。有些人把Google的工程师文化理解为，重视代码质量、重视效率、工匠精神、技术驱动、扁平化管理等等，还有些人甚至理解为，昂贵的电脑和座椅、按摩和报销等各种福利、少开会不加班、免费一日三餐、无限供应的零食等等。</p><p>当然，上面提到的这些在Google都是真实存在的。不过，这都是表象。如果只是学这些表面上的东西，“抄不到”Google工程师文化的本质和精髓，我们也就很难打造成像Google一样的工程师文化了。<strong>那Google工程师文化的本质是什么呢？我觉得，如果用一句话来描述的话，那就应该是“尖子生”文化。</strong></p><p>这里所说的“尖子生”，跟我们上学时候的“尖子生”是一个意思。不知道你学校里有没有“尖子生班”？或者你有没有在“尖子生班”待过？一般来说，“尖子生班”的同学在各个方面都表现得非常优秀，而且，这种优秀不仅仅体现在学习上面，其他非学习相关的活动也表现得很好。最值得一提的是，这种优秀是自发形成的，不需要老师的督促和刻意的培养。</p><p>类比到Google的工程师文化，Google可以算作工程师中的“尖子生班”。我们知道，Google用人条件很苛刻、招聘要求很高，身边的同事个个都具有光鲜的背景和履历，称为”尖子生“不足为过。这些最顶尖的工程师聚集在一起，不出意外的情况下，稍加引导，就能形成优秀的工程师文化，高产出、高效率、高创新是必然的。至于前面提到的其他方面，比如重视代码质量、工匠精神、重视效率等等，更是不在话下。</p><h2>如何打造像Google一样的工程师文化？</h2><p>表面上的东西很容易“借鉴”，比如为员工购买昂贵的电脑和座椅，但要想打造像Google一样的工程师文化，本质上还是要在”人“上下功夫。招聘最优秀的人才，给足钱、自由和尊重，这些人必然就会发挥最大的价值。</p><p>乔布斯曾经说过，A类工程师招聘A类工程师，B类工程师只能招聘C类工程师。之所以这么说，是因为A类工程师有足够的能力来正确地辨别A、B、C类工程师，有足够的自信去接纳跟自己一样优秀、甚至更加优秀的人才。所以，为了严把人才入口，我们一定要让公司内最优秀的工程师来负责招聘。</p><p>当然，并不是每个公司都可以像Google这样，有足够的背景去吸引最优秀的工程师、有足够的投入去招聘最优秀的工程师。但是，我们仍然可以招聘一小撮足够优秀的工程师，让这小部分工程师影响公司里更多的人，带动起我们想要的工程师文化。这就好比，打造一个全是尖子生的尖子班很难，但我们可以在班级里找几个学习榜样，让这一小撮榜样带动起整个班级的学习氛围。</p><p>除了在招聘上下功夫，在人才培养上，我们要尽可能留住最符合公司工程师文化的员工，让他们在公司内部有好的职场发展，避免劣币驱逐良币。比如，我们的工程师文化是“马屁文化”，如果你是领导，就要让经常拍你马屁的人升职加薪，慢慢地其他人就会效仿，不接受的人就会离职，“马屁文化”就逐渐形成了。</p><p>实际上，我们也不一定非得追求将公司的工程师文化，打造成像Google的一样，毕竟每个公司都有自己的特点，都有自己的发展阶段，完全照抄也不现实。我个人觉得，相对于外企来说，国内企业中跟“人”相关的文化，普遍做得不是太让人满意，比如，以人为本，以结果为导向，讨论就事论事，奖惩公开透明，不搞上下级关系等等，先把这些跟”人“相关的文化搞好，跟”技术“相关的文化，比如重视代码质量、工匠精神、追求效率等等，搞起来就相对容易多了。</p><h2>课堂讨论</h2><p>聊一聊你最喜欢的工程师文化是什么样子的？最讨厌的工程师文化是什么样子的？</p><p>欢迎留言和我分享你的想法。如果有收获，也欢迎你把这篇文章分享给你的朋友。</p>",
                "article_title": "加餐五 | 听一听小争哥对Google工程师文化的解读"
            },
            {
                "title": "加餐六 | 什么才是所谓的编程能力？如何考察一个人的编程能力？",
                "herf": "https://time.geekbang.org/column/article/255697",
                "id": "255697",
                "content": "<p>在招聘要求里，我们经常看到“要求候选人有扎实的编程能力”。在面试反馈中，我们也经常看到面试官用“编程能力很强”来评价候选人。那到底什么是编程能力呢？如何考察一个人的编程能力呢？又如何提高编程能力呢？今天，我们就编程能力这个话题展开聊一聊。</p><p>话不多说，让我们正式开始今天的内容吧！</p><h2>什么是编程能力？</h2><p>所谓编程能力，指的是把“逻辑”（或者说“功能”“业务”）翻译成代码的能力。所谓编程能力强，指的是，不仅能编写正确的代码，而且编写代码的速度很快，写出来的代码bug很少、性能很好、质量很高。</p><p>更加具体点讲，一个编程能力强的人，能熟练使用编程语言、开发类库等工具，思路清晰，面对复杂的逻辑，能够编写出bug free的代码，能够合理地利用数据结构和算法编写高效的代码，能够灵活地使用设计思想、原则和模式，编写易读、易扩展、易维护、可复用的高质量代码。</p><p>相反，一个编程能力差的人，往往逻辑思维能力比较差，面对复杂的逻辑，编写代码的速度很慢，而且容易考虑不周，写出来的代码bug很多，更没有性能意识，不懂得如何分析代码的时间复杂度、空间复杂度，更不懂得如何借助现成的数据结构和算法来优化代码性能。除此之外，写代码的时候，几乎不考虑代码的可读性、可扩展性等质量问题，只追求能运行就可以。</p><!-- [[[read_end]]] --><h2>如何考察编程能力？</h2><p>前面我给出了编程能力的简单的定义，从定义中，我们能很清楚地了解，考察一个人的编程能力的几个要素。总结一下，我觉得主要包含这样三个方面：编程语言，数据结构和算法，设计思想、原则和模式。</p><p>考察编程能力，那就离不开写代码。所以，在面试中，我一般都会出道编程题，让候选人写段代码看看，也就是所谓的“白板编程”。白板编程在外企面试中比较流行，国内有些候选人不怎么能接受，特别是工作年限比较长的候选人，一听说要写个代码，就觉得这是在“羞辱”他，觉得不应该从这么基础的东西考起。</p><p>不过从我多年的面试经验来看，这种拒绝写代码的“大龄码农”，满嘴“架构、高可用、高并发、分布式”，往往代码写得惨不忍睹。所以，只要是应聘一线技术研发岗的候选人，不管是资深工程师、架构师，还是技术Leader，我都会要求他现场写一段代码。因为这是最直接、最有效检验这个人基本技术素养的途径。</p><p>一般来讲，编程语言都可以快速掌握，所以，我一般都不会把它拎出来单独考察，只是顺带着考察一下就可以了。我会重点考察后两个方面：数据结构和算法，设计思想、原则和模式。但是，要想设计一个题目，既能考察到这两方面的知识，又能在不到1个小时的面试时间内完成，还是挺难的。所以，对于这两个方面，我一般都分开来考察。我今天重点讲对数据结构和算法的考察，对于设计思想原则和模式的考察，我后面有文章专门来讲。</p><p>对于数据结构和算法的考察，我个人不建议面试题目涉及需要记忆的算法，比如被很多人诟病的面试题：写个快排。没有人会天天背诵快排算法，候选人写不出来也理所应当。如果我们换个问法，比如给候选人讲一下快排的思想，然后让候选人用代码实现，测试候选人的代码翻译能力，我觉得这反倒是一个比较好的面试题。除此之外，我也不建议面试题目涉及特殊解题方法或技巧，比如需要用到线段树、并查集等高级数据结构。毕竟大家在工作中不常用到这些知识，不知道或者忘记了我觉得也很正常。</p><p>所以，那种不依赖很强的算法背景和特殊的解题技巧的题目，比较适合用来面试。比如像下面这样的面试题就比较好：“写一个函数将IPv4地址字符串（仅包含数字、点、空格）转化成32位整数。另外，数字和点之间的空格是合法的，其他情况均为非法地址，要求输出合法地址的32位整型结果。”</p><p>我觉得这种题目是比较公平的，对于没有刷过题的人来说也很友好，因为它纯粹是在考察候选人的基本编程素质：逻辑思维是否清晰，细节是否考虑全面，是否能写出bug free的代码，是否有计算机思维，会关注时间空间复杂度等。</p><h2>如何提高编程能力？</h2><p>刚刚我们讲了什么是编程能力，如何考察编程能力，现在，我们讲下如何提高编程能力。实际上，我的两个专栏《数据结构与算法之美》《设计模式之美》，就是为了提高你的编程能力而设计的。《数据结构与算法之美》专栏教你如何写出高性能代码，《设计模式之美》专栏教你如何编写易读、易扩展、易维护的高质量代码。</p><p>方向很明确，但是要真的提高编程能力，光学不练肯定是不行的。</p><p>对于数据结构和算法的练习，我们推荐你多刷LeetCode上的题目。刷题不仅仅能加强你对数据结构和算法的掌握，还能锻炼你的逻辑思维能力、写出bug free代码的能力、快速实现复杂逻辑的能力，也能锻炼你的性能意识。所以，刷题不只是为了面试，刷题对这些能力的锻炼，都有助于你在平时的业务开发中写出好的代码。</p><p>对于设计思想原则和模式的练习，它就不像算法练习那样有现成的题库了。所以，要在平时的开发中进行练习。比如，拿到一个功能需求的时候，我们先去思考一下如何设计，而不是上来就写代码。写代码时，我们时刻思考代码是否遵循了经典的设计思想、设计原则，比如是否足够可扩展、是否满足SOLID原则、可读性如何等等。写完代码之后，我们再思考一下，代码是否有进一步优化的空间。做Code Review的时候，看到别人的优秀的代码，我们就去思考一下，有哪些值得借鉴的地方。总之，在平时的开发中，我们要刻意地去做这种跟代码质量、代码设计相关的思考训练。时间长了，这种思考就能成为习惯、本能反应，慢慢地，你的代码能力也就不自觉地提高了。这一部分内容你可以回过头去再看下第100篇，我们前面有非常详细的讲解。</p><h2>课堂讨论</h2><p>实际上，不管从事什么行业，要积累的东西都可以分为“变”与“不变”两类。“不变”的是内功，“变”的是招式。我们要善于发现、持续积累那种“不变”的能力，而不是要去盲目追逐一直都在“变”的招式。除了编程能力之外，在IT技术领域，你觉得还有哪些不变的内功？</p><p>欢迎留言和我分享你的想法。如果有收获，也欢迎你把这篇文章分享给你的朋友。</p>",
                "article_title": "加餐六 | 什么才是所谓的编程能力？如何考察一个人的编程能力？"
            },
            {
                "title": "加餐七 | 基础学科的知识如何转化成实际的技术生产力？",
                "herf": "https://time.geekbang.org/column/article/256866",
                "id": "256866",
                "content": "<p>我相信，很多程序员都已经意识到基础知识的重要性，觉得要夯实基础，才能走得更远，但同时对于如何将基础知识转化成开发“生产力”仍然有些疑惑。所以，你可能看了很多基础的书籍，比如操作系统、组成原理、编译原理等，但还是觉得很迷茫，觉得在开发中用不上，起码在平时的CRUD业务开发中用不上。</p><p>实际上，这些基础的知识确实很难直接转化成开发“生产力”，但并不代表就没有用，今天，我们聊一聊为什么要学习基础学科知识，以及基础学科知识是如何转化成“生产力”的？</p><p>话不多说，让我们正式开始今天的内容吧！</p><h2>没有直接用得上并不代表没有用</h2><p>很多人反映，大学里学的很多基础学科都没用，工作之后都用不到。这种感觉是没错的。实际上，不只是基础学科，任何一门技术，能够经常用在工作中的那部分，都只占20%左右。这也符合我们常说的“二八法则”。</p><p>不知道你有没有听过这样一个故事：有一个人想要一个葫芦，于是他就种了一棵葫芦树。葫芦树叶子生了虫子，有人建议他赶紧杀杀虫。这个人却说，我要的是葫芦，管葫芦叶子干嘛。你可能会觉得，故事里的这个人的想法很荒唐，但其实我们也经常犯这种错误。比如说，类比到我们学知识，尽管常用的可能只有20%，但这并不代表我们只需要学习那20%就够了。要想得到那20%最有用的知识，我们需要学习很多周边知识做铺垫才行。</p><!-- [[[read_end]]] --><p>实际上，我多次强调，构建一个完善的知识体系、知识框架很重要。有些知识能直接转化成生产力，有些知识是为了学习其他知识充当“脚手架”。要想对应用层的知识学得比别人快、学得比别人透彻，铺垫性的基础学科知识就必不可少。</p><h2>现在用不到并不代表以后用不到</h2><p>你可能会说，我科班出身、基础扎实，但跟其他培训出身、只会使用框架干活的同事，在工作中的表现差不多啊，并没有感觉到有太多优势。实际上，如果只是做比较“低级”的CRUD工作，项目本身没有难度、没有挑战，那基础再扎实、技术再好，可能也都发挥不了你的优势，跟其他人拉不开差距。这就相当于跟大妈在菜市场比算账，你高数、微积分学得再好都没用，都比不上大妈算得快。但换个有挑战的工作环境、换个有难度的项目，又或者当你成为更高级别的工程师的时候，这些基础知识可能就会用得上了。</p><p>编程这件事本来就不难，随便培训3、5个月，就能上手干活。基础知识掌握得牢固，在工作初期，可能确实体现不出优势，毕竟大家都是从最基础、最没有技术含量的活干起的。在初期，那些框架、工具用得熟练的人，反倒更有优势，更容易出活、干得更快。但是，只会框架、工具的人，技术天花板是很低的，很多东西都只能学得一知半解、无法深入，很快就会遇到技术成长的瓶颈。相反，基础扎实的人更经得起时间的考验，技术研究的越深入，优势就会越明显。尽管基础知识短期内没法给你带来收益，但长远来看会持续发挥作用。</p><p>很多知识用不到，可能只是暂时用不到。书到用时方恨少。等到用到了，再去学习，就有点来不及了。基础学科知识学起来比较慢，所以，还是要在平时多下功夫，提前学扎实。学习基础学科的知识，不能太急功近利，只看重眼前的利益。</p><h2>学了记不住并不代表就是白学了</h2><p>对于知识的学习，特别是偏理论的基础学科知识的学习，有很多人说，学完之后，关上书啥都回忆不起来，学完不用，过不几天就忘得干干净净。其实，这些现象是很正常的。实际上，如果你一直追求“记住”“不忘”，那就还是应试教育的思维方式。</p><p>知识是用来解决问题的，而不是用来记忆考试的。说句实话，你可能不信，我在写这两个专栏的时候，写完后面的就忘了前面的，全部写完之后，基本就都忘得差不多了。不过，因为我在脑海里构建了整个的知识框架，并且大部分知识难点都已经被我攻克，所以，当工作中需要某块知识的时候，即便细节记不清了，我也只需要稍微查看一下资料，就能全部回忆起来。</p><p>除此之外，学习本身就是一种能力的锻炼。比如，我们在学习算法和设计模式这两个专栏的过程中，从最基础的自学能力、理解能力、逻辑思维能力，到时间空间复杂度分析能力、分析发现解决代码问题能力，都有锻炼到。所以，即便知识的细节忘记了，也并不妨碍我们编写出高性能、高质量的代码。这种对能力的锻炼，比单纯的知识记忆要有意义得多。</p><p>我之前还听过这样一个故事。给一个3岁的小孩每天读一篇希腊文写成的文章，坚持1年的时间。等小孩长大一点之后，拿之前文章里的内容再考他，他完全回忆不起来。但当他开始学习希腊文的时候，他比其他同龄人学得都要快。从这个故事中，我们可以发现，忘记并不等于就白学了，学习对于一个人的影响是潜移默化的。基础学科知识的学习更是如此。你要相信，它总有一天会发挥作用的 ，机会都是给有准备的人，我们要学会“延迟满足”。</p><p>总结一下，比起编程语言、框架、工具，基础学科知识确实很难直接转化成生产力，但它却是你构建整个“技能树”的根本，构建整个“知识大楼”的地基。基础掌握不牢，你对很多应用层技术的理解就会不够有深度，略知皮毛，只能做个技术熟练工。相反，基础扎实能让你学东西更快、更有深度、理解更透彻，也就间接地增强了你的开发能力。可以这么说，在一定程度上，基础知识本身，就是技术生产力。</p><h2>课堂讨论</h2><p>你觉得计算机的基础学科知识有哪些？聊一聊你对学习基础科学知识重要性的认识。</p><p>欢迎留言和我分享你的想法，如果有收获，也欢迎你把这篇文章分享给你的朋友。</p>",
                "article_title": "加餐七 | 基础学科的知识如何转化成实际的技术生产力？"
            },
            {
                "title": "加餐八 | 程序员怎么才能让自己走得更高、更远？",
                "herf": "https://time.geekbang.org/column/article/257513",
                "id": "257513",
                "content": "<p>大学就像一个笼子，跑得快的人拖着笼子跑，跑得慢的人被笼子拖着跑，他们之间最大的差距，顶多只有笼子的长度那么大。但等到一毕业，笼门一打开 ，跑得快的人很快就把跑得慢的远远甩在后面。有人不到30岁就升到了阿里P8，有人35岁了还为拿个P7 Offer在拼命。</p><p>为什么几乎同样的起点、差不多的资质，有些人在职场发展得这么好，一路顺风顺水，而有些人却总是觉得怀才不遇，领导不行？今天，我们就来聊一聊，程序员怎么才能让自己走得更高、更远？</p><p>话不多说，让我们正式开始今天的内容吧！</p><h2>技术、业务、能力是立命之本</h2><p>我觉得，不管哪个行业，混得好的人都要有两把刷子。对于程序员来说，我觉得这两把刷子包括技术、业务和能力这三方面。很多人担心出现35岁中年危机，觉得自己能干的事，刚毕业一两年的人也能干得了。我觉得这主要还是因为没有在这三个方面积累出竞争壁垒。</p><p><strong>我觉得，技术方面的竞争壁垒主要来自，在一个细分技术领域长期</strong><strong>、</strong><strong>深入的积累。</strong></p><p>如果要想在技术上形成壁垒，我们就要从事一些有技术难度、技术挑战的岗位，比如基础架构、中间件、数据库等偏底层的开发，又或者是人工智能算法等入行门槛比较高的细分领域。在这些领域，你需要较长时间的经验积累，才能成为这一领域的专家，别人无法在短期内超过你，这就是技术竞争壁垒。</p><!-- [[[read_end]]] --><p><strong>对于大部分业务开发工程师来说，很多人平时都是使用框架、工具，翻译业务代码，工作没有太多技术含量，技术上可能很难形成竞争壁垒。这个时候，你也不用苦恼，我们在业务上也同样可以形成竞争壁垒。</strong></p><p>实际上，技术驱动的公司很少，即便像Google这样公认的技术驱动的公司，里面90%的项目都是业务、产品驱动的。真正高精尖的技术也只集中在某一小撮项目中。你可能会说，Google的很多产品的用户、访问量都很高，这些高性能、高并发的要求不是很考验程序员的技术吗？实际上，这些有挑战的技术问题，都是比较有共性的，大部分都通过底层系统解决了，比如MapReduce、BigTable、GFS等。业务研发工程师只需要恰当地使用这些高精尖的系统来实现业务就可以了。</p><p>在业务驱动的项目中，特别是一些业务比较复杂的下项目，比如，金融系统、银行系统、财务系统、清结算系统、物流系统等，我们还可以积累一些业务壁垒。如果你之前的工作都是从事偏向业务系统的开发，靠技术只能面到阿里P7这个层级。如果想面到阿里的P8、P9，靠的就不仅仅只是技术了，还需要对某个业务的深入积累。实际上，很多领导之所以能做领导，不是技术牛逼，而是对业务熟悉。</p><p><strong>不过，并不是所有的业务系统开发，业务都有足够的复杂度，可以让你积累竞争壁垒。对于技术没有太大挑战，业务也不复杂的项目开发，我们可以多积累自己的能力。</strong></p><p>这里所说的能力，指的是成事能力、解决问题的能力。实际上，很多问题的解决，即便是技术问题的解决，靠的都不是技术，而是一个人最基本的解决问题的能力。这其中就包括分析总结能力、逻辑思维能力、沟通协调能力、自我驱动能力等等。</p><p>比起固定的技术和业务知识，这种成事能力、解决问题的能力，我觉得对于混职场来说可能更加重要。在职场中，职位越高，这种成事能力就越重要，毕竟企业最终还是看结果的，而不是看你技术有多好。</p><h2>学历、项目、履历是入场门票</h2><p>经常听人吐槽，面试造火箭，入职拧螺丝。也经常听人抱怨，有些公司太看重学历，因为学历拒掉了我，却招了一个技术比我差的前同事，仅仅因为他是985名校毕业。</p><p>现在，学IT的人越来越多，招聘市场也逐渐从卖家市场变成了买家市场。很多公司开始提高招人要求，不仅加大面试难度，为了提高招聘效率，还会在学历、过往是否有大公司经历等方面，先过滤掉一批候选人。</p><p>你可能会说，学历高的不一定技术好，学历低的也有技术很好的。你说得没错。但一般来讲，虽然都说做技术学历不重要，但好学校的学生对计算机基础知识掌握得更好，学习能力、逻辑思维更强，相对要聪明一些，而且在工作中，我们也发现，成绩好的同学往往在工作中表现出很强的执行力和快速交付能力，在工作中的表现普遍也更优秀。站在公司整体招聘的角度来说，通过学历来过滤候选人是一个比较高效的手段，毕竟公司也不在乎因此漏掉一两个优秀的候选人，或者错招一两个不优秀的候选人。</p><p>实际上，比起短短的1个小时的面试，我个人也更倾向于通过学历、项目（项目经历是否有技术难度）、履历（是否有知名公司的工作经历、以及职位高低），这些过去的能够证明能力的经历来判断一个候选人。特别是对于一些中高端的岗位，好的学历、项目、履历基本上有碾压性的优势。我自己做面试官多年，基本上在看完候选人的简历之后，对符不符合我们招聘要求，心里就有个八九不离十的判断了。在面试开始的前10分钟，我基本上已经决定要不要录用他了。后面的面试只是为了进一步证实自己刚刚的决定而已。</p><p>如果说技术、业务、能力是程序员的立命之本，它们决定了你能不能在职场这场比赛中胜出，那学历、项目、履历就是入场门票，决定了你可以选择哪个比赛赛道，是Google、Facebook，还是BAT，又或者是完全不知名的小公司。</p><p>所以，在夯实技术、业务、能力的同时，你也要学会“面向简历打工”“面向跳槽打工”，提前做一些职业规划，把自己的履历弄好看点，比如，学历太低的就去考个好点的学历，在公司内部努力去选择做一些有技术含量的项目，跳槽去一些知名点的互联网公司等等。</p><h2>不要让职场软技能成为短板</h2><p>在职场中，我常常听到有人抱怨说，旁边的同事明明技术一般，却升到很高的职位，而自己技术很好，却发展一般。实际上，怀才不遇大多数都是因为忽视了职场软技能。这些人的特点大多是性格耿直、脾气暴躁、眼里容不了沙子、斗天斗地斗空气。而且，大部分情况下，他们都会觉得自己做得很好，领导不识货，同事都没他强。</p><p>职场不是学校，影响你向上发展的因素很多，肯定不是单靠技术，所以，学生思维要不得。在上学的时候，学得好坏，一份试卷见分晓。要想成绩好，闷头学就行了，你也不需要什么团队合作。但是，毕业之后，技术的好坏、代码写得好坏、活干得好坏，就没有那么容易客观评价、量化评价了。所以，这就会出现你自己觉得工作做得很好，而领导却不这么认为的情况。</p><p>而且，技术好其实并不代表贡献多。我也见过很多技术好的人，比较爱自嗨，成天鼓捣些高精尖的技术。实际上，不管是从短期还是长期看，这些技术都没有给团队、公司带来收益。当然，我也并不是完全摒弃个人成长，让你完全奉献给公司。我只是觉得，作为员工，要学会跟公司共同成长。只有你的成长为公司的成长贡献了力量，为公司、为领导解决了问题，公司才愿意为你的付出买单，你才有升职加薪的机会。</p><p>总的来讲，要想职场混得好，一些必须的沟通、协作、总结汇报等软技能还是不能忽视的，当然，我也不是推崇，纯靠“耍手段”上位。我只是觉得，这方面起码不能成为你的短板，不要让这些非技术、非能力的因素，阻碍了你职场的发展。</p><h2>课堂讨论</h2><p>作为“前浪”的你，还有哪些经验、教训，可以分享给“后浪”，让“后浪”在职场发展上少走些弯路呢？又或者作为“后浪”的你，有哪些职场的疑惑、迷茫，想向“前浪”请教呢？</p><p>可以在留言区说一说。如果有收获，也欢迎你把今天的内容分享给你的朋友。</p>",
                "article_title": "加餐八 | 程序员怎么才能让自己走得更高、更远？"
            },
            {
                "title": "加餐九 | 作为面试官或候选人，如何面试或回答设计模式问题？",
                "herf": "https://time.geekbang.org/column/article/258207",
                "id": "258207",
                "content": "<p>在<a href=\"https://time.geekbang.org/column/article/255697\">加餐六</a>中，我们讲到，对于程序员的编程能力，我们一般从数据结构和算法、设计模式这两个方面来考察。加餐六重点讲到了如何考察数据结构和算法，今天，我们重点讲讲，如何考察设计模式。</p><p>除此之外，很多人反映，在面试中被问到设计模式问题的时候，一般都没有什么思路，基本都是想到哪说到哪。今天，我就总结一下回答设计模式相关面试题的一些套路，希望能让你在今后的面试中有章可循。</p><p>话不多说，让我们正式开始今天的内容吧！</p><h2>作为面试官，如何面试设计模式问题？</h2><p>有些面试官喜欢让候选人手写常用的设计模式，比如单例模式、工厂模式，以此来考察候选人对设计模式的掌握程度。实际上，对于比较常用的设计模式，盲写的要求并不过分，毕竟在开发中，徒手写个单例模式、工厂模式，也是常有的事情。</p><p>不过，这种偏向记忆的面试题目，实际上是一种应试考试的面试方式。一方面，它没有区分度，另一方面，候选人容易突击准备。这往往考察不出候选人真正的代码设计和实现能力。我们学习设计模式的初衷是提高代码质量。学习设计模式的重点，是掌握应用场景、能解决哪些问题，而非记忆定义、代码实现。所以，我面试时有个原则，不直接问记忆性问题和过于理论性问题。</p><p>筛选候选人就是筛选将来与你共事的人。我们面试的最终目的，还是希望能在短短的1小时内，粗略地看出候选人在今后工作中的表现。相对应的，在面试中考察候选人设计模式相关的知识，是看他在今后的项目中，能否写出易读、易扩展、易维护的高质量代码。</p><!-- [[[read_end]]] --><p>为了更准确地反映候选人在以后的工作中的表现，最好的面试方式是拿真实项目来考察，而且最好是候选人入职之后要参加的项目。当然，这个要求稍微有点高了。一般来讲，其实只要比较贴近真实项目就可以了。</p><p><strong>对设计和代码能力的考察，我一般有两种面试思路。</strong></p><p>第一种，给候选人一个功能需求，让他去做代码设计和实现，然后，基于他的代码实现，讨论代码的可读性、扩展性等代码质量方面的问题，然后让候选人继续优化，直到满意为止。第二种是，给候选人一段有质量问题的代码，让他去做Code Review，找出代码存在的问题，然后做代码重构。实际上，在我们的专栏中，很多文章中的例子，都符合刚刚两种面试思路。比如第<a href=\"https://time.geekbang.org/column/article/179644\">25</a>、<a href=\"https://time.geekbang.org/column/article/179673\">26</a>、<a href=\"https://time.geekbang.org/column/article/193221\">39</a>、<a href=\"https://time.geekbang.org/column/article/193555\">40</a>讲，<a href=\"https://time.geekbang.org/column/article/190979\">34</a>、<a href=\"https://time.geekbang.org/column/article/191621\">35</a>讲，<a href=\"https://time.geekbang.org/column/article/191642\">36</a>、<a href=\"https://time.geekbang.org/column/article/191647\">37</a>讲。你可以回过头去再看下。</p><p>这里我要重点强调一下，这种代码设计实现问题，本身没有标准答案，背景又过于复杂开放，如果只是丢给候选人回答，中间没有任何交流和引导，候选人很难抓住重点，展现出你心里期望的表现。所以，面试的过程切忌像笔试一样，一问一答单向沟通。相反，我们要把面试当做一场与未来同事的技术讨论，在讨论的过程中去感受候选人的技术实力。</p><p>当候选人写完代码之后，如果面试官一个问题都不提，然后就跳到其他面试题目，这种体验，不管是对候选人，还是面试官来说，都不是很好。相反，如果面试官能一语中的地提出设计中的缺陷，深入地跟候选人去讨论，这样一方面能给候选人充分发挥的机会，另一方面，也会赢来候选人对公司技术的认可。</p><h2>作为候选人，如何回答设计模式问题？</h2><p>刚刚我们从面试官的角度，讲解了如何面试设计模式相关的问题。现在，我们再从候选人的角度，讲下如何回答设计模式相关的问题。</p><p>刚刚我讲到，很多面试官喜欢让候选人手写常用设计模式的代码实现，虽然我本身比较讨厌这种面试方式，但保不齐有些面试官喜欢。应对这种面试问题，你只能面试前突击复习一下了。</p><p>刚刚我也讲到，我个人比较喜欢拿真实的功能需求和代码来面试候选人。一种面试题是给功能需求，让候选人写代码，另一种面试题是给代码，让候选人做Code Review和代码重构。针对这两种类型的面试题，我分别讲讲应该如何应对。</p><p>对于第一种面试题目，我们首先要明确需求。大部分情况下，面试官给出的功能需求，都是比较笼统、模糊的，这本身就是为了考察你的沟通能力、分析能力，是否能通过挖掘、假设、取舍，搞清楚具体的需求，梳理出可以执行落地的需求列表。</p><p>跟面试官确定好需求之后，就可以开始设计和实现了。前面也提到，面试的目的是考察候选人在真实项目开发中的表现。在工作中，我们都是从最简单的设计和实现方案做起，所以，回答这种设计面试题，也不要一下子就搞得太复杂，为了设计而设计，非得用些比较复杂的设计模式。</p><p>不过，在用最简单方式实现之后，你可以再讲一下，如何基于某某设计模式，进一步对代码进行解耦，进一步提高代码的扩展性。基于这种最简单的代码，再行讨论优化，这样跟面试官讨论起来，也会更加言之有物。这也能体现你的代码演进思维，以及具体问题具体分析的能力。更加详细的回答套路，你可以参看第<a href=\"https://time.geekbang.org/column/article/171760\">13</a>、<a href=\"https://time.geekbang.org/column/article/171767\">14</a>讲。</p><p>比起第一种题目，第二种面试题目会更加明确、具体。你就把它当作一次真实的Code Review来回答就好了。对于如何进行Code Review，你可以回过头去再看下<a href=\"https://time.geekbang.org/column/article/190979\">第34讲</a>，里面有罗列一些Code Review的checklist。</p><p>实际上，回答这种没有固定答案的开放性问题，你要跟面试官多问多沟通，不要觉得问多了就是自己理解能力不够，就会导致面试官反感。相反，面试官不仅不会反感，反倒会觉得你是一个思路开阔、有想法的人。如果你只是自己闷头写代码，面试官有可能会觉得你不善沟通。</p><h2>课堂讨论</h2><p>作为面试官，你是如何考察候选人的代码设计和实现能力的呢？作为候选人，你遇到过最想吐槽的设计模式相关的面试题是什么样的？</p><p>欢迎留言和我分享，如果有收获，也欢迎你把这篇文章分享给你的朋友。</p>",
                "article_title": "加餐九 | 作为面试官或候选人，如何面试或回答设计模式问题？"
            },
            {
                "title": "加餐十 | 如何接手一坨烂业务代码？如何在烂业务代码中成长？",
                "herf": "https://time.geekbang.org/column/article/259489",
                "id": "259489",
                "content": "<p>在我们的职业生涯中，很少有机会可以从零开发一个项目，大部分都是接手别人的代码继续开发，或者做些维护性开发。而且，对于大部分业务系统来说，因为业务导向，需求倒逼，开发工期紧，团队往往都不是很重视代码质量，快速上线是第一要务。所以，很多团队的代码质量一般都不怎么高。埋坑无数、没有文档、也没有注释，代码读不懂、也不敢改，这对于新人来说，会非常苦恼。今天，我们就聊一聊，如何接手一坨烂业务代码，以及如在烂业务代码中的成长？</p><p>话不多说，让我们正式开始今天的内容吧！</p><h2>如何接手一坨烂业务代码？</h2><p>在我过去10年的工作经历中，我接手过很多个代码质量比较烂的项目。这些项目都有很多共性的特点，大部分都已经维护了两三年，甚至五六年之久，代码量很大，有十几万行以上，并且大部分代码都没有任何注释，业务功能非常庞杂，也没有对应的业务文档。</p><p>除此之外，代码中还充斥着各种临时解决方案（Workaround）、硬编码（Hard Code）、遗留代码（Legacy Code），还有很多匪夷所思的设计。对于有些设计来说，我们称之为“反人类”设计或者“故意挖坑”，一点都不为过。如果没有老员工给你解释上下文，你万万都想不到它为什么这么设计和实现。</p><!-- [[[read_end]]] --><p>实际上，<strong>要想接手一个业务系统，前提是要读懂代码，而读懂代码的关键，是要熟悉业务。</strong>只要业务搞清楚了，代码只不过是对业务的翻译，对照着业务看代码实现，看懂并不是件难事。不过，我所接手的这几个项目，基本上都是零文档，所有的业务知识都是靠口口相传。所以，搞清楚业务，就成了接手项目最难的事情了。</p><p>面对如此庞大的项目代码，没有文档，几乎就是两眼一抹黑。原来参与这个项目开发的老同事，有的离职，有的去做其他新项目，一直问他们也不好意思，所以，大部分情况下，我都只能硬着头皮，通过阅读代码反推业务功能。</p><p>如果代码质量比较高，模块划分清晰，命名规范，那通过读代码反推业务，也并非不可能的事情。但真实的情况往往事与愿违，就像我们前面提到的，代码中充斥着临时解决方案、硬编码、遗留代码等各种坑，这就使反推业务变得非常困难。对于代码中的这些坑，尽管我不想一直麻烦同事，但也只有多问才能最快速地解决。</p><p>在读代码的过程中，我非常重视知识的文档化，我会把读懂的每个业务都写到文档中。当然，这其中也包括前面提到的各种坑。对于复杂的业务流程，我还会画一些流程图。读代码的过程非常痛苦，花了好几个月，我才有信心说，自己几乎把所有代码都搞清楚了。同时，我也做了一件过去几年都没有人做的事情，那就是补充完整了技术文档和业务文档，之后再有新同事加入，看了我的文档，就可以很快了解代码、了解业务，很快就能上手开发代码。</p><p>总结一下，即便代码再烂，只要有完善的业务文档，先理解业务，再去看代码，几乎就没啥难度了。对于零文档的项目，大部分情况下，我们只能通过代码来反推业务。当然，对于有些坑来说，必要的情况下，我们也要询问前辈来搞定。在读代码的过程中，我们要将得到的知识文档化，这也是对公司和团队来说最有价值的部分。</p><h2>如何在烂业务代码中成长？</h2><p>有人一遇到这种烂业务代码，就觉得很心烦，我反倒不一样。恰恰相反，相比接手好代码，我觉得接手烂代码，虽然过程更加痛苦，但同时也会给我更多施展才华的空间、锻炼技术的机会，我的成长也会更多。</p><p>除此之外，很多人觉得做偏底层的开发（基础架构、框架、中间件等开发）才锻炼技术，做业务系统没有挑战，技术上没有成长，对此非常苦恼。实际上，我觉得这种看法是比较片面的。做业务开发的难度不亚于底层开发，做好也不是件容易的事情，同样可以积累技术、锻炼能力。</p><p>偏底层的开发更加考验程序员在某一细分领域的技术深度，偏业务的开发更加考验程序员的能力，比如沟通能力、分析问题解决问题能力、权衡取舍能力、架构能力等，毕竟业务多种多样，问题千奇百怪，单一细分领域的经验很难应对所有问题。</p><p><strong>实际上，业务系统的开发难度一般来自两个方面：高性能要求和业务复杂。</strong></p><p>解决性能问题，你需要具备一定的架构能力，有一定的技术广度，需要对各种基础架构、框架、中间件都有所了解。光了解还不够，还要有一定的技术深度，最好能对原理甚至是源码有所研究。除此之外，还要有一定的使用经验。广度、深度、经验三者配合，这样才能做到恰到好处组合这些技术搭建架构，解决性能问题，并且在出现问题之后才能快速地解决。</p><p>应对大型项目的业务复杂性，要想让项目代码一直在你的掌控范围内，你需要有很强的业务建模能力、复杂逻辑的抽象能力、代码翻译能力等。对于一个人的基本素质、基础能力的要求要更高。实际上，对于复杂业务系统来说，对业务的熟悉也能成为你的竞争壁垒，成为升职加薪的砝码。我前面也讲到，低级别的晋升靠技术，比如升阿里的P7，高级别的晋升靠业务，比如升阿里的P8、P9，或者换个说法，高级别的晋升，靠业务比单纯靠技术，更容易一些。</p><p>如果你参与的项目，性能要求高、业务也复杂，那恭喜你，好好干就成了。如果你参与的项目，在性能和复杂度上，只兼具其中一点，那也不错，值得一做。如果你参与的项目，既没有性能压力、业务也不复杂，那也别太着急，走着瞧，实在不行再跳槽。</p><h2>课堂讨论</h2><p>在过往的项目经历中，你有没有像我一样，接手过代码质量比较差的代码？你又是如何顺利接手的呢？</p><p>欢迎留言和我分享你的想法。如果有收获，也欢迎你把这篇文章分享给你的朋友。</p>",
                "article_title": "加餐十 | 如何接手一坨烂业务代码？如何在烂业务代码中成长？"
            }
        ]
    },
    {
        "chapterTitle": "结束语 (1讲)",
        "children": [
            {
                "title": "结束语  | 聊一聊机遇、方向、能力、努力！",
                "herf": "https://time.geekbang.org/column/article/260184",
                "id": "260184",
                "content": "<p>你好，我是王争。从专栏上线到今天，足足有8个月的时间了。在这8个月里，我陪你一块完成了100篇正文和11篇加餐的学习。今天，我要正式地跟你说声再见了。</p><p>你可能知道，除了《设计模式之美》这个专栏，我还有另外一个专栏《数据结构与算法之美》。两个专栏加起来已经有10万多读者了。算法专栏一直稳居极客时间的TOP  1。设计模式专栏发布时间较晚，但上升势头很好，跻身TOP  10指日可待。当然，这不是什么了不起的成绩，也并非我一个人努力的结果。我说这些当然也不是为了炫耀。</p><p>成绩虽小，算不上成功，但起码称得上“成事（做成了一件事情）”。在这篇结束语里面，我打算结合我自己写专栏的经历，跟你聊一聊对人一生有很大影响的四样东西：机遇、方向、能力、努力，我觉得它们一起决定了你是否能“成事”。</p><h2>机遇</h2><p>我觉得，能赶上“知识付费”的风口，在最火热的时间段，推出了算法专栏，这是算法专栏能卖得这么好的最主要的外在原因。当时，大部分人对“知识付费”还认识不清，看到有人来讲课、分享经验，激动不已，于是开始一直“剁手买买买”。除此之外，还有一个很大原因是，当时并没有多少人讲算法，碰巧很多人在算法知识这方面也比较欠缺，所以，我的专栏不仅碰到了风口，还抢占了先机。现在，风口已经过去，大部分人对“知识付费”的认识也变得越来越理性。所以，如果算法专栏现在才推出，没有风口、没有先机，我不敢说一定卖得不好，但肯定不会像之前那么火爆。</p><!-- [[[read_end]]] --><p>实际上，风口还有另外一些叫法。会说的人把它称作“机遇、机会”，大部分人把它称作“运气”，也有人叫它“狗屎运”，还有人把它称之为“命”。我们经常听到，某某某因为赌对了公司，公司上市，财务自由了；或者，某某某因为加入得早，随着公司的快速发展，自然而然升成了高管。每当这个时候，我们往往羡慕不已，甚至还会有点嫉妒地说，他当年还没我混得好之类的。实际上，你也不要羡慕嫉妒恨，小富靠俭，大富由天。运气，就是这么不公平、不讲道理。</p><p>不过，话说回来，人生很长，每个人都有翻盘的机会，就看你是否能抓得住了。哈佛大学曾做过一个调查。调查说，人的一生一般会有七次机会。你只需要抓住其中的一两次机会，一下子就能拉开跟同龄人之间的距离，甚至改变人生方向、改变命运。像我，抓住了“知识付费”的机会，所以就小火了一把。</p><h2>方向</h2><p>俗话说，选择努力的方向，有时候比单纯的努力更重要。为什么没你牛的人混得比你好？如果你找不到自身的原因，那就只能从机遇和方向上找答案了。</p><p>之所以专栏卖得火爆，除了遇到了“知识付费”风口之外，还有一个很重要的外在因素，那就是专栏的选题很好。不管是算法，还是设计模式，两个专栏的选题都是比较偏底层技能、通用知识的，受众比较广。相反，如果专栏选题本身比较小众，写得再好，可能买的人也不会很多。</p><p>不过，人生不像写专栏那么简单。很多时候，面对选择，我们很难一眼就能断定哪个会更好，往往都是事后分析，觉得某某选择很正确或者很后悔，甚至大部分情况下，我们都只能被动选择。就拿我自己来举例吧，有些朋友知道，在写设计模式这个专栏的时候，我离职了，说实话，是被迫离职。</p><p>因为写专栏确实比较费时间、费精力，我很难平衡工作、生活、写专栏三件事。生活不能耽误，专栏也不能停更，所以，我只能被迫选择放弃工作了。这样的选择，对我来说还是挺难的。因为一旦选择离开职场，就意味着要选择一种新的“讨生活”方式。而新的“讨生活”方式，到底是不是更好的方式，还要过几年才能见分晓。</p><h2>能力</h2><p>刚刚我们聊的是两个外因，现在，我们再聊下内因。实际上，很少有风口、机会、方向是只有你自己能看到、而别人看不到的。你能看到的，很多人都能看到。但并不是任何扑风口的人，都能飞上天。要想成功，你的能力也非常重要。</p><p>就像我的算法、设计模式专栏一样，这两个选题方向，估计很多人都想得到。而且，在我写之前，很多知识付费平台也已经上线了类似选题的课程。不过，这些课程大都不温不火。我的算法能带动算法学潮、设计模式能逆势而上，也说明了我多少有两把刷子。即便相同的选题方向，换做其他人来写，未必有我写得好，未必有我的课卖得好。</p><p>前面我也提到，因为写设计模式专栏，我选择了从职场离开。实际上，这并非拍脑袋决定的。我自认为在“卖弄文字”“教书育人”方面还是有点优势的。当然，这样的认知并非自我感觉良好，有客观数据和事实来支撑。所以，选择离开职场，从零开始一个新的方向，集中精力All In到自己擅长的事情上，对我来说，可能是“被迫”做的更好的选择。</p><h2>努力</h2><p>“努力决定下限，运气决定上限”，这句话我想你应该听过吧？“运气”可遇而不可求，但努不努力是我们可以掌控的。在任何领域，想要做到TOP  1，你可能需要一些运气和天赋，但要做到TOP  10，一般人只要努力就能做到。这就好比创业，要做成今日头条、拼多多那样金字塔尖上的企业很难，可能不是简单努力就能成的，但要只是想讨个生活，很多时候只要努把力就够了。</p><p>再回到我的专栏。尽管前面我把写好专栏，归因于机遇、方向、能力，描述得很轻松，实际上，尽管机遇有了，方向对了，能力也很强，但写好专栏也并没有你想象得那么简单，我也要付出很大的努力，写稿到半夜也是常有的事情。而且，稍有不慎，还要接受读者的吐槽。这其中的辛酸、误解、孤独只有我一个人知道。</p><p>而且，光是写稿到半夜，也并不能成就一个好的专栏。这就像光靠突击，也并不能让我们一下子变成技术大牛。能写出好的专栏，主要还是得益于我之前多年的积累。有句话说得很好：哪有什么一鸣惊人，不过是十年如一日地坚持。</p><h2>最后</h2><p>时光不语，静等花开。从默默无闻到崭露头角，一般只需一瞬间，看似一瞬间，可能要等十几年。年轻人一定不要心急，不要焦虑，要耐得住性子。当你的能力撑不起你的野心的时候，当你感到怀才不遇的时候，当你迷茫找不着方向的时候，你只需要努力、坚持，再努力、再坚持，慢慢地，你就会变得越来越强大，方向就会变得越来越清晰，机会就会越来越青睐你。</p><p>好了，最后我还给你准备了一份毕业调查问卷。欢迎点击下方图片，畅所欲言，让我知道你的想法！</p><p><a href=\"https://jinshuju.net/f/uomZGt\"><img src=\"https://static001.geekbang.org/resource/image/0d/ae/0dc8d169dffb5dd46eeb636e5f04daae.jpg\" alt=\"\"></a></p>",
                "article_title": "结束语  | 聊一聊机遇、方向、能力、努力！"
            }
        ]
    }
]