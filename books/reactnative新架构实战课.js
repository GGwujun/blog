exports.category = "frontend";
exports.title = "reactnative新架构实战课";
exports.data = [
  {
    chapterTitle: "开篇词",
    children: [
      {
        title: "开篇词｜为什么要选择 React Native 做你的跨端方案？",
        id: 499434,
        content:
          '<p>你好，我是蒋宏伟。我目前在58同城担任前端架构师，也是 58RN 框架的负责人。</p><p>六年来，我一直在围绕着 React Native 搞开发、搞基建、搞探索。从最初一线的 React Native 业务开发，到后来开始负责 58RN 的基础设施建设，再到 2021 年，我开始冲在最前沿做 React Native 新架构的调研，我用了 6 年的时间，朝着同一个方向一步一步地往前行。</p><p>在这期间，也得益于我所在的58用价中台的大前端团队，我接触到了各式各样的大前端技术。除了 React Native 之外，我直接负责过的跨端技术还有 Hybrid、小程序、Cocos 游戏，而且我也经常和 iOS、Android，以及 Flutter 的同学进行交流。</p><p><strong>我深刻地知道，没有完美的跨端技术，只有适合的场景。脱离适用场景去谈跨端技术没有什么意义。</strong></p><p>那么， React Native 适合哪些场景呢？</p><p><strong>第一，业务更新迭代较快的团队与出海团队。</strong></p><p>React Native 上手成本较低。对前端同学来说，React Native 和前端技术生态重合度很高，学习成本很低；对客户端同学来说，React Native 省去了大量的编译耗时，并且自带跨端光环， 一份源码可以同时编译成 Android 和 iOS 原生应用，并发布到安卓和苹果应用商店上。</p><!-- [[[read_end]]] --><p>所以，在一些业务迭代快的团队中，使用React Native 跨端方案不仅能够节约开发成本，还能带来接近原生的体验和性能。比如，现在大火的直播、短视频赛道中，React Native 能够通过集成声网提供原生 SDK，快速开发出一个直播、短视频应用。</p><p>而且，据我所知，一些出海团队也在使用 React Native 进行开发。针对于出海应用， React Native 有一套 Expo 方案，Expo 提供了一整套 React Native 的技术基础建设，极大地降低了开发一个新应用的成本，这就能帮助这些出海 App 用最低的成本、最快的速度获取海外用户。</p><p><strong>第二，既要支持动态更新，又要支持复杂业务的场景。</strong></p><p>在国内，无论大公司、小公司都钟情于应用的动态更新。因为动态更新能降低产品的试错成本。如果产品策略有调整，可以立马上线，线上有小问题也可以快速修复。但能够既满足动态更新，又能跨端，还能满足复杂业务需求的只有 JavaScript 语言。</p><p>目前几个主流的跨端框架，除了React Native之外，还有小程序、Weex、Flutter。但小程序只能让你的应用运行在别人的 App 上，Weex最终未能大规模流行起来，而Flutter使用的语言是Dart而非JavaScript，并不能很好支持动态更新。</p><p>换句话说，除了基于 JavaScript 的自研框架外，<strong>目前能够既支持动态更新，又支持复杂业务的主流移动跨端框架只有使用 JavaScript 开发的 React Native。</strong></p><h2>为什么你应该学习 React Native ？</h2><p><strong>首先，React Native 是一个非常流行的跨端框架，开发者认可度很高。</strong></p><p>根据权威网站数据，现在使用 React Native 的开发者已经越来越多了。在 <a href="https://www.npmtrends.com/react-native"> npm trends</a> 网站上你可以看到，react-native 框架每周的下载次数，已经从5年前的不到10万次，到现在超过了 80 万次，5 年时间翻了 8 倍之多。</p><p><img src="https://static001.geekbang.org/resource/image/d7/50/d75660fb448113ba4279962f88bc7b50.png?wh=1920x760" alt="图片"></p><p>这意味着，React Native 有一个繁荣和不断迭代的生态。</p><p>对于个人而言，强大的生态意味着很多功能都不用自己写，从社区拿来用就行，这极大地降低了开发成本。你可以在社区中选择最适合你业务的技术工具，比如状态管理、路由、动画、工具库和原生扩展等等。对于企业来说，使用 React Native 这类成熟框架开发移动应用成本更低，风险也更低，企业也更愿意招聘相关开发者。</p><p><strong>其次，React Native 是一个跨领域的融合技术，它是你现有技术的自然延伸。</strong></p><p>React Native 的生态和 JavaScript、React、iOS、Android 甚至 Node.js 的生态都有很大的交集。在 React Native 生态中，有来自各种技术领域的思想碰撞。相信你学习 React Native 时，这种感受会非常明显。</p><p>如果你是一个前端工程师，已经掌握 JavaScript、React 的相关技术，那么对 React Native 的学习，可以让你了解到那些独属于 Android 和 iOS 原生平台的特性。</p><p>比如，你可以亲手尝试使用 WebView 容器来加载 Web 页面，甚至你还可以用 WebView 中的 JavaScript 去调用 React Native 中的 JavaScript，把 Native 暴露给 React Native 的支付能力再暴露给 Web，这样你能更加深刻地体会到 Hybrid 的实现原理。</p><p>如果你是客户端工程师，已经掌握Android 或 iOS 的这些技术了，那你只需要学习一下 JavaScript 和 React 这些流行的前端技术即可，相信你能从中体会到热重载、热更新和跨端带来的乐趣。</p><p>而且，React Native 这门融合技术还有另一个好处，它能让前端和客户端更加紧密的协作。日常开发中，前端和客户端经常需要协作，比如很多公司就专门设立了大前端部门，为的就是方便前端和客户端一起做事。要更好地共事，就需要学会站在对方角度思考问题，通过学习 React Native 你就能了解对方技术栈的特点，就更容易换位思考，而这也能帮助你快速成长。</p><p><strong>更关键的是，React Native 新架构已经确定会在今年正式发布。</strong></p><p>2022 年，对于 React Native 来说是一个大年，因为重构已久的 React Native 新架构已经确定会在今年正式推出，目前的 0.68 版本已经出了新架构的测试版。根据业内已有的报告和我们团队的调研结果，相对于老架构，新架构在最关键的性能问题上有了非常大的提升，这将会为 React Native 开启一个全新的阶段。</p><h2>期待已久的新架构会带来什么？</h2><p>React Native 是 2013 年在 Facebook 一个内部的黑客马拉松项目中诞生的，到今年 2022 年新架构出来，已经整整十年了。</p><p>它诞生于移动互联网大爆发时代，当时国内外各大互联网公司都相继提出了“Mobile First”、“All in 无线”之类的口号。但后来，React Native 也因为性能等问题，让类似 Airbnb 这样的团队选择了放弃。</p><p>但技术的车轮还是滚滚向前，并不会停下它的脚步。</p><p>2021 年 7 月，经历 4 年漫长的等待，当我得知 React Native 新架构已经在 Facebook 落地的消息时，真是万分激动，期待已久的 <a href="https://www.infoq.cn/article/txsiq1wogk6il4bnqmja">React Native 新架构终于要来了</a>，于是我马上开始了新架构的调研。</p><p><img src="https://static001.geekbang.org/resource/image/b8/de/b8f55be43f5243a91de6aea7a00575de.png?wh=1920x1104" alt="图片"></p><p>到今天，经历过大半年的调研，我也大概摸清楚了 React Native 新架构的技术底层原理和发展方向，目前来看它至少会有这几个值得期待的亮点：</p><p><strong>首先，React Native 新架构的启动性能会有 2 倍左右的提升。</strong></p><p>React Native 新架构默认用的 JavaScript 引擎是 Hermes 引擎。Hermes 是一款专为移动端打造的 JavaScript 引擎，它支持 JavaScript 的 AOT 预编译。</p><p>一般而言，要执行一段 JavaScript 代码，首先要将 JavaScript 代码编译为字节码，再把字节码编译为二进制的机器码，才能被 CPU 等硬件执行。而 AOT 预编译技术可以让你在本地提前将 JavaScript 编译成字节码。这样一来，在启动 React Native 应用时，相对于老架构 JSCore 引擎的就少了一个步骤，因此 React Native 新架构的启动性能会有很大的提升。</p><p><strong>其次，React Native 新架构的通信性能会有 3 倍左右的提升。</strong></p><p>React Native 老架构通信用的是 JS Bridge，JS Bridge 的通信方式是“发送消息”。React Native 新架构通信的是 JSI（JavaScript Interface），JSI 把很多底层的 C++ 接口都直接暴露给了 JavaScript。有了 JSI 后，React Native 中的 JavaScript 就直接调用 C++了，就像 node.js 使用 addon 调用 C++ 、 Flutter 用 FFI 调用 C++ ，以及 Java 使用 JNI 调用 C++ 一样。</p><p>所以，使用 JSI 意味着不用发送消息，而是直接调用，没有序列化和反序列。少了这些多余的步骤，操作指令的传递效率就会高很多。</p><p><strong>第三，React Native 新架构的渲染流水有了很大的变化，这会带来更好的用户体验。</strong></p><p>在老架构中，React Native 只有异步渲染这一种方式。而我们知道原生视图的渲染是同步的，这时如果把 React Native 渲染到原生视图中，就可能导致布局抖动问题。而新架构提供了同步的渲染能力，这就提供了一种新的可能：一方面我们可以在原生页面中嵌套 React Native 视图，另一方面 React Native 应用也能更方便地引入一些需要同步 API 的原生组件。</p><p>另外，还有一个我非常关注的方向，就是 React Native 团队正在基于 React Native 新架构研究服务端渲染方案。React Native 的 SSR 和 Airbnb 的自行研发<a href="https://medium.com/airbnb-engineering/whats-next-for-mobile-at-airbnb-5e71618576ab">服务端渲染框架</a>原理非常类似。国内的<a href="https://ppt.infoq.cn/slide/show?cid=94&pid=3696">美团团队也在 React Native 老架构之上实现了 SSR</a>，据说美团的<strong>页面渲染速度最快能达到50ms</strong>。</p><p>希望在不远的将来，React Native SSR 能出一个类似于 Web 服务端渲染的 Next.js 的通用方案，用更低成本解决性能痛点。</p><p>总之我们有理由相信，React Native 新架构会给我们带来巨大的惊喜。</p><h2>这门课是怎么设计的？</h2><p>在调研新架构的过程中，我发现 React Native 本身的迭代非常快，现在并没有比较适合初学者和进阶者系统学习 React Native 的课程。我当时想等 React Native 新架构出来后，再出一个基于 React Native 新架构的课程，也算是回馈社区了。</p><p>但后来我决定采用<strong>动态专栏</strong>的形式和你见面。因为我发现，面对一个前沿技术，如果我们真要等它完全成熟了再来研究，可能就晚了。更重要的是，只有<strong>先坐上 React Native 新架构的这趟列车，才能享受到前沿技术变革带来的红利</strong>。</p><p>但技术的实时性和课程的完整性又应该如何兼顾呢？</p><p>于是，我想到一个办法，先用 24 讲把 React Native 完整地给你介绍一遍，再用一年的时间，用12 讲的内容和你一起跟进 React Native 新架构最前沿的变化和进展。</p><p><img src="https://static001.geekbang.org/resource/image/c8/2b/c816a5fa34106a6b5073af7fbb15c72b.jpg?wh=1357x1323" alt="图片"></p><p><strong>第一部分是核心基础篇。</strong>这里我们主要是把基础打牢，带你深入学习 React和React Native 的基础知识，包括状态和组件的使用，及其背后的设计原理，还有开发 UI 和调试代码的经验技巧。在这个阶段，我们的目标是要让你能够搭建一个 React Native 页面，我希望通过实践的方式，让你收获搭建 React Native 页面的能力，而不仅仅只是知识。</p><p><strong>第二部分是社区生态篇。</strong>这一部分中，我们的首要目的是帮你开阔眼界，让你知道社区有哪些成熟方案，需要时能够拿来即用，同时也让你能够借助 React Native 生态中最常用的几个工具，搭建一个完整的 React Native 应用。搭建一个完整应用是很有挑战的一件事情，我会把我搭建好的一个简易电商应用放在 GitHub 给你参考，希望能让你在代码层面，而不仅仅只是文字层面有所收获。</p><p><strong>第三部分是基础设施建设篇。</strong>这里我们会从技术应用层面，给你介绍从构建 React Native 混合应用到热更新，再到性能调优的全过程，让你能为团队搭建基础设施建设出谋献策，进一步提升你的架构能力。</p><p>而且，我还邀请了和我一起共事多年的两位老搭档况众文和朴惠姝，他们是 58RN Native 方向的负责人，我们会共同地把多年搭建 React Native 基础设施的心得和你分享。</p><p>后面动态更新的 12 讲，我会采用<strong>每个月 1 篇</strong>的更新形式，帮你跟踪 React Native 新架构的最新进展，并和你聊聊和 React Native 新架构相关的最前沿的新技术，包括且不限于 Hermes、Fabric、JSI、React Native Skia、React Native SSR ，等等。</p><p>具体你可以看看下面的目录：</p><p><img src="https://static001.geekbang.org/resource/image/bb/1c/bb6535058e049f5b9d20200f845e041c.jpg?wh=1564x5219" alt=""></p><p>最后，我希望这门课程能够帮到那些曾经和我一样对 React Native 跨端技术充满好奇的人，那些想弄明白如何搭建一套跨端基础设施的人，以及那些希望自己能够冲在技术最前沿的探索和创新的人。</p><p><strong>技术的世界如此精彩，我们当然不应该躺平，愿你的好奇、勇敢和行动能得到相应的回报。</strong></p>',
        article_title: "开篇词｜为什么要选择 React Native 做你的跨端方案？",
      },
    ],
  },
  {
    chapterTitle: "React Native 核心基础篇",
    children: [
      {
        title: "01｜学习 React Native，你需要掌握哪些知识？",
        id: 499446,
        content:
          '<p>你好，我是蒋宏伟。</p><p>在专栏的第一讲，我们先打个“基础”，让你对即将要学习的 React Native 核心基础知识有个心理准备。</p><p>这些年，我经常活跃于公司内外的交流群中，和大家讨论一些问题，比如：状态管理该怎么选，长列表的性能问题该怎么解决，遇到紧急的线上 BUG 该怎么处理，等等。</p><p>这些我们都是日常开发时经常会遇到的问题，出现这些问题的其中一个原因，就是对 React Native 的基础知识掌握得不够牢固。</p><p>当然，这些问题在我们的核心基础篇中都会有答案。不过在第一讲中，我不打算和你说这些细节，而是带你看看 React Native 基础知识的地图，让你知道自己该学什么、要学什么，让你对基础知识有一个整体的认知。</p><h2>基础知识</h2><p>那所谓的基础知识是什么呢？<strong>我认为能够满足开发业务的最小知识集合都是基础。</strong>比如，语言、框架和一些编程的必备工具，还有 React Native 框架和社区提供的核心组件、核心 API，再有就是熟悉工作流包括搭建环境、开发流程、上线流程，这些都是 React Native 的基础知识。</p><p>不过，每个人的技术背景不一样、工作年限也不一样，新手可能对大部分的基础知识都不太熟悉。而已经有过多年 React Native 开发经验的老手，对有些基础知识的使用方法都已经掌握得差不多了，千人千面。</p><!-- [[[read_end]]] --><p>但我认为，无论是新手还是老手，你都应该系统地、有深度地再学习一遍，把基础打扎实了。我相信，核心基础篇能给你带来更深刻、更系统的认知。</p><p>那些需要深层理解的知识，我会把它给你讲清楚、讲透彻，让你弄明白它是怎么来的，又有哪些使用技巧，底层原理又是什么。</p><p>在广度上，为了能让你对基础知识有个系统的了解，我为你准备了一张知识地图。即便有些知识，我们没有进行深层的讲解，你也可以根据知识地图和补充材料中的提示，自己搜索。</p><p><img src="https://static001.geekbang.org/resource/image/93/17/9396e0ecf7d24b0a7eb84be5445f4017.jpg?wh=1920x1869" alt="图片"></p><p>其中，蓝色背景和蓝色文字的内容就是我们专栏核心基础篇中的重点内容，那些灰色背景、灰色文字的内容就是你需要自己学习和掌握的基础知识。如果灰色部分中有不是很了解的知识点，你可以根据知识地图自学一下，遇到了任何问题，都欢迎你给我留言。</p><p>你可以看到，在这张知识地图中，我把知识分为了三类。</p><p>第一类是开发语言、React 框架、开发必备工具这些预备知识。虽然这些预备知识，并不是 React Native 本身的重点内容，但这些都是你在开发之前需要掌握的。如果你对 JavaScript 不了解，你可以参考 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/A_re-introduction_to_JavaScript">MDN JS 教程</a> 自行学下一下，其中  npm 等工具使用起来会比较简单，你可以参考 <a href="https://www.npmjs.cn">npm 中文文档</a> 自行摸索学习。但考虑到有些小伙伴对 React 可能没有那么熟悉，所以这方面的预备知识，我还会用三讲的内容进行讲解。</p><p>第二类知识是 React Native 本身的知识。组件是这类知识中的重点，包括框架提供的组件和社区提供的组件，这方面我会重点讲解。但 API 类的知识，本身比较简单，所以我只挑选了样式内容和你进行讲解。至于其他 API 知识，你在用的时候，查查 <a href="https://reactnative.cn">React Native 官方文档</a>就能很快学会了。</p><p>第三类知识是工作流中的实操知识。学习实操类知识最好的方法，其实是根据手册一步一步操作，所以这一块我不会细讲。但其中有些能帮你节约自己独立探索时间的经验类的知识，比如 UI 开发技巧和逻辑调试思路，我也会和你分享。</p><p>专栏的核心基础篇分为 12 讲，它是一个总分总的结构，今天这一讲就是对基础知识的整体认知，第 11 讲、第 12 讲就是对基础知识的项目实战，那中间的几讲就是我为你挑选的几个最重要的基础知识点。我希望通过知识地图和实战案例，把这基础知识点给你串起来，让这些知识能够真正为你所用。接下来，我就给你简要介绍下核心基础篇的这几类知识点。</p><h2>第一部分：React框架</h2><p>我们刚才说，学习 React Native 要掌握的第一类知识，包含了 React 框架。众所周知，React Native 是一个基于 React 的原生应用框架。那学习 React 最关键的就是，理解<strong>React 是一个基于组件的、声明式的 UI 框架</strong>，我把这句话拆开和你解释。</p><p>先来看 React 的第一个特点：<strong>基于组件（Component-Based）</strong>。</p><p>最开始 React 只能用来写 Web 应用，它是在 2013 年正式开始开源的。在此之前，业内的大多数 Web 框架都是 MVC 框架。 MVC 框架解决了代码大杂烩的问题，它把代码分成了职责分明的三层，M 指的是数据模型 Modal，V 指的视图模板 View，C 指的是控制器 Controller。MVC 强调的是数据、视图和逻辑之间松耦合，其文件结构也是按这三类分门别类地组织起来的。</p><p>但 React 不一样，React 强调的是组件的可组合型。在 React 中，颗粒度最小的是浏览器提供的 HTML 标签，或者是 React Native 框架提供的组件。这些颗粒度最小的基础标签、基础组件可以相互嵌套、拼装成一个颗粒度稍大一些的自定义组件。小的自定义组件可以拼装成大的自定义组件，大的自定义组件又可以拼装成页面和应用。</p><p>从代码大杂烩，到 MCV 三层架构，再到 React 的自定义组件，代码组织形式经历很大的变化。React 基于组件的代码组织形式，也经历住了时间的考验，证明了它的优秀。</p><p>React Native 应用也继承了“基于组件的”特性，它可以让我们将一个大的 UI 页面，拆分成若干个颗粒度更小的自定义组件，这能让我们的应用更容易扩展和维护。</p><p>接着我们再来看 React 的第二个特点：<strong>声明式（Declarative）</strong>。</p><p>声明式是什么呢？所谓的“声明式的”就是，你只需要告诉程序“做什么”（What），程序会自动帮你解决“怎么做”（How）的问题，这让我们创建复杂的交互应用变得轻而易举。</p><p>你使用过的 HTML 也算一种“声明式”的语言。不同的是， HTML 功能太简单了，而且它也不是图灵完备的语言。但 React 不一样，它使用的是 JavaScript 来描述 UI 页面的结构，并且在 JavaScript 中创建了一种类似 HTML 的方言，也就是JSX 语法扩展。</p><p>JSX 语法既保留了 JavaScript 的灵活、强大和图灵完备特性，也保留了 HTML 这类“声明式”语言易写、易读的特点。</p><p>还值得多说一句的是，“声明式”是一种编程范式，它与“命令式”编程范式相对立的，它们之间是“是什么”（What）和“怎么做”（How）的对立关系。“命令式”就好像你自己开车，你得自己控制方向盘。而“声明式”就好像完全自动驾驶的汽车，你告诉它要去哪儿，它就会自己开到哪。</p><p>声明式编程是一个大的概念，除了我们前面提到了 HTML 所属的领域专属语言（DSL）之外，还有函数式编程等子编程范式。熟悉 React 的同学可能就知道了，React 借鉴了大量的函数式编程的思想。核心基础篇中的函数组件、hook，还有我们后面要讲的状态管理工具 Redux 和新架构原理，都大量使用了函数式编程的思想。</p><p>好了，现在你知道了，React Native 的基础是 React，而 React 又是一个基于组件的、声明式的 UI 框架，因此后面我会花两讲的内容和你介绍，这两个特点背后的基础知识：组件 Component 和状态 State。</p><h2>第二部分：核心组件和样式</h2><p>第二类你需要掌握的基础知识是 React Native 的核心组件和样式。</p><p>先说样式。<strong>样式决定了页面的“颜值”</strong>，它可以控制组件的颜色、字形、排列、大小，等等。有意思的是，Web 中的 CSS 是一门博大精深的学问，要学很久，但 React Native 中的样式内容却很少，它核心声明文件也就 600 多行代码。而且根据我的调研，大家也很少使用 React Native 样式工具、样式库来辅助开发，大部分时候使用默认的样式表 StyleSheet 的 “CSS In JS”写法就够用了。</p><p>那为什么 React Native 能用这么少的样式，来满足复杂的 UI 开发呢？</p><p>关键原因就是，React Native 的组件非常丰富，组件提供的属性满足了那些复杂“颜值”需求。比如，Web CSS 中的粘性定位   <code>position:sticky</code>，就可以用 React  Native 中滚动组件 ScrollView 的粘性头部 <code>StickyHeaderComponent</code> 属性来满足，而且 React  Native 的功能还更强大一些。</p><p>因此，我会花很大的篇幅和你重点讲讲 React Native 中的组件，包括图片组件 Image、点按组件 Pressable、输入组件 TextInput、列表组件 RecyclerListView。选择这 4 个组件来讲，不仅仅是因为它们用的频率高，我们要学习它的使用方法，<strong>我们也要去研究它的原理，希望它们背后的设计思想能够为我所用。</strong></p><p>学习这 4 种组件，其实各有侧重。学习图片组件时，我们最应该关注的是<strong>加载性能和开发的便捷性应该如何取舍</strong>。比如，内置图片性能是好，但会增加包体积，而且加上容易删掉难；远程图片加载慢了点，但只需要管理远程地址，更新也是非常方便；又比如 Base64 会导致图片体积增加 1/4，但是它在热更新的情况下，能让图片第一时间展示出来。这些方案应该怎么选？又有没有自动化的、工程化的方法帮忙我们管理图片，进一步降低我们选择成本呢？</p><p>学习点按组件、输入组件时，我们最应该关注的是<strong>交互体验</strong>。点按按钮很简单，但做好交互体验这件事不简单。一个 App 的体验好不好，PM、UI、UX 设计得好与不好是一方面，但最终还是得靠工程师来实现。比如微信右上角的 + 号按钮，在屏幕上面不是那么好点，微信工程师就把它的可点击范围扩大了一些，让大家容易点中，这些都是值得我们学习的。</p><p>学习列表组件时，我们最应该关注的是 <strong>FPS 流畅度，</strong>也就是滚动性能。React Native 老版本提供的 FlatList 的滚动性能不是很好，在低端机器上会有点卡，但是社区中提供了性能更好的 RecyclerListView，我们得学会用起来。</p><h2>第三部分：实践经验和实战练习</h2><p>然后，在项目实战练习之前，我还会和你讲讲有哪些高效开发 UI 的技巧，和调试疑难杂症的实践经验，帮你少走弯路。</p><p>核心基础篇的最后，就是项目的实战练习了。整个核心基础篇的目的，是希望能让你搭建一个简易的电商首页。我始终相信，只有实战才能将学到的知识变现为自己能力。</p><p>搭建一个电商首页，我们要解决两个问题。第一个问题是，现在电商首页大都是瀑布流形式的，在 React Native 如何实现一个高性能的瀑布流组件呢？社区中并没有现成答案，但是我们可以基于社区组件自己动手进行改造，我会带你一步一步实现一个高性能的瀑布流组件。</p><p>要解决的第二个问题是，搭建项目的最佳实践是什么？如果你是项目的负责人，你会怎么思考，来保障项目的可扩展性和可维护性？根据我的个人经验和业内的最佳实践，我总结出了一套适合我自己的方案，在《页面实战》这一讲中，我也会把它分享给你。</p><p>但我明白，你要把这些知识都学好，还得靠自己在实战中动手、摸索，因此我还会给你留作业，特别是 React Native 新手，请你一定要重视作业的重要性。</p><h2>小结</h2><p>好了，介绍到这里相信你已经知道学习 React Native 要掌握那些基础知识了，这些知识分为三类：</p><ol>\n<li>React 类知识。React 是一个基于组件的、声明式的 UI 框架，而用好 React 的关键是用好自定义组件和状态，这也是你学好这门专栏必要的前提条件；</li>\n<li>React Native 本身的知识。这是核心基础篇的重点内容，它不仅包括 UI 怎么写、组件怎么用，你还去了解它们背后的原理，去提高页面的加载性能、交互体验、FPS 流畅度；</li>\n<li>实践类知识。这里主要是开发 UI 和调试代码的一些经验技巧，并且我也给你留了一个搭建简易电商网页的任务，我希望你以此实战为你学习核心基础篇的目标，同时也通过这个项目实战检验自己的学习成果，将知识内化为自己的能力。</li>\n</ol><p>相信你通过核心基础篇 12 讲的学习，咱们一步一个脚印前进，一定能把基础打扎实了，轻松应对业务开发中的各种挑战。</p><h2>作业</h2><ol>\n<li>如果你是新手，你可以参考 <a href="https://reactnative.dev/docs/0.65/environment-setup">React Native 官网</a> 和 <a href="https://reactnative.cn/docs/0.63/environment-setup">React Native 中文网</a> 搭建一套原生环境。搭建环境是学习的第一步，iOS 或 Android 环境你可以任选其一，先把 React Native 在你的电脑里跑起来。</li>\n<li>如果你是有经验的 React Native 开发者，你可以看一下<a href="https://docs.qq.com/sheet/DQWdsZ0RORkpFQmVj?tab=BB08J2">《大家开发 RN 都用什么？》</a>这份调查表单，看看其他开发者都在用什么，也欢迎你给我留言告诉我，你开发 React Native 都用的是什么。</li>\n</ol><p>欢迎在留言区留言，分享你和 React Native 的故事。我是蒋宏伟，咱们下节课见。</p>',
        article_title: "01｜学习 React Native，你需要掌握哪些知识？",
      },
      {
        title: "02｜Component：搭建静态页面的正确思路是什么？",
        id: 500633,
        content:
          '<p>你好，我是蒋宏伟。</p><p>上一讲我们说到，React/React Native 开启了“基于组件”构建应用的潮流。</p><p>在工作中，特别是业务类的开发需求，绝大多数都是写页面。写页面分为两步，第一步是搭建静态页面，第二步是给静态页面添加交互让它动起来。这第一步至关重要，它决定了 UI 设计稿要拆分成哪些组件，这些组件又是如何组织起来的，这些都会影响程序的可扩展性和可维护性，甚至还有团队的合作方法。</p><p>我们这一讲的目的，就是让你有一个正确的基于组件搭建静态页面的思路，不让第一步走偏。要知道，如果后面再去纠正，要花费的成本就大了去了。</p><h2>组件：可组合、可复用的“拆稿”方式</h2><p>在开始使用组件这种方式构建静态页面之前，请你先思考一个问题，为什么 React/React Native 选择了基于组件的架构方式呢？</p><p>理论上，除了组件这种方式外，常见的构建应用方式还有：类似 HTML/CSS/JavaScript 这种的分层架构、基于 MVC 的分层架构。那为什么 React/React Native 没有选择这两种架构方式呢？</p><p><strong>这是因为，基于组件的架构模式，或许是现在重展示、重交互应用的最好选择。</strong></p><p>记得我 2015 年刚入门的时候，还有一种岗位叫做网页重构工程师，我还面过这种岗位。那个时候，架构模式就是把 UI 设计稿拆成 3 层：HTML、CSS、JavaScript。网页重构工程师负责 HTML、CSS 部分，前端工程师负责 JavaScript 部分。但是后来我发现网页重构工程师这种岗位越来越少了，也庆幸自己没有上错车。</p><!-- [[[read_end]]] --><p>现在，相信你也看到了，把 UI 设计稿拆成完全独立的 HTML/CSS/JavaScript三个部分的这种架构已经不是主流了；2010 年开源的、代表 MVC 架构模式的 AngularJS也被 Angular（v2 及更高版本）这种基于组件的架构模式所代替了；现在 iOS、Android 应用也有很多是基于组件开发的。</p><p>为什么会有这种现象呢？我先给你看一张架构对比图，你先可以体会一下它们之间的区别，找找原因：</p><p><img src="https://static001.geekbang.org/resource/image/00/b6/00e902a0949ecfa5a8748ef66df420b6.jpg?wh=1920x524" alt="图片"></p><p>现代应用都很复杂，而且非常重交互、重展示。如果 React Native 选择的是类似 HTML/CSS/JavaScript 的模板、样式、逻辑分离的分层架构，那可想而知，我们的三层代码都会非常臃肿。</p><p>如果 React Native 选择的是 MVC 架构，把逻辑控制、数据模型和视图进行分层，对程序横向分层纵向打通，这样代码颗粒度是会变小。但在重交互的前提下，层和层之间、列和列之间的数据流向却更复杂了。流动的方向不止是 MVC 架构图中画 “3+3” 的 6 个方向，而是层和层之间的 “3<em>3</em>2” 个方向，列和列之间的 “3<em>3</em>2” 个方向，非常复杂。</p><p>React/React Native 选择的是基于组件的架构模式，它有三个好处：</p><ul>\n<li>第一，组件是内聚的，组件内既有逻辑，又有状态，还有视图，一个组件可以独立完成一件事情，这也使得 UI 模块复用变得简单；</li>\n<li>第二，组件之间是可以组合的，一个页面可以拆分成若干个大组件，大组件也可以拆分成小组件，当某个组件变大变臃肿时也可以进一步地拆分；</li>\n<li>第三，组件和组件之间的数据流向永远是确定，永远是从上往下流动的，简单明了。</li>\n</ul><p><strong>组件可组合、可复用的特性，和组件之间单向数据流的模式</strong>，在现代应用重交互重展示的情况下，显然更吃香，这也是 React/React Native 选择基于组件来构建应用的原因。</p><h2>单一责任原则</h2><p>现在我们回到第一步，基于组件搭建静态页面。</p><p>我们直接来看一个具体的例子。这里我放了一个简易商品列表页的 UI 设计稿，你可以先停下来思考一下，想一想你会把它拆成那些组件？你这么拆的原因又是什么？</p><p><img src="https://static001.geekbang.org/resource/image/d4/23/d4264b371fee1038da912e7737afce23.png?wh=1000x802" alt="图片"></p><p>我们直接来揭晓答案，拆组件要准守一个原则，<strong>单一责任原则</strong>。</p><p>这也是 React 官方倡导的原则，这个原则的意思是<strong>每个组件都应该只有一个单一的功能，并且这个组件和其他组件没有相互依赖</strong>。当然，完全没有相互依赖是不可能的，但这种思路具有很高的指导价值，一个组件的依赖越少，设计得越好。</p><p>给你举个例子，一个组件你引用的依赖越多，这些依赖就像陌生的英语单词，你得去其他文件中去查词典，才能知道这些依赖的意思。依赖越多，越难读懂，也越难维护。</p><p>因此，为了可读性、可维护性、可测试性，就要减少组件的外部依赖，这就是单一责任原则的指导价值。</p><p>这样说来，在拆分简易商品列表页的 UI 设计稿时，我们就要尽可能地拆的更细一些，保证每个组件的责任单一，因为涉及到 UI 稿建议你打开文稿查看一下，那我们拆分结果如图所示：</p><p><img src="https://static001.geekbang.org/resource/image/e2/94/e22a8ff50c7bbdb637ed6eb42892dd94.png?wh=1000x594" alt="图片"></p><p>你可以看到，这个简易商品列表已经被拆分了 3 个组件，具体如下：</p><ol>\n<li>ProductTable（紫色）：它是商品列表组件，显示商品列表和表头；</li>\n<li>Category（青色）：它是类别组件，显示一类商品的种类；</li>\n<li>Product（黄色）：它是商品组件，显示某个具体的商品名称和价格。</li>\n</ol><h2>宿主组件：生产基础视图的工厂</h2><p>当你有了怎么把 UI 设计稿拆分成组件的思路后，接下来就要构建静态页面了。</p><p>要构建静态页面，就要有基础的视图材料。在 React Native 中那些最基础、不可再拆的视图材料，大都是由 React Native 框架提供的<strong>宿主视图</strong>。</p><p>比如，UI 设计稿中的水果名称：“苹果”、“火龙果”，价格：“￥1”、“￥2”，还有最顶部的搜索框，这些都是宿主视图。</p><p>而生产宿主视图的工厂，就是宿主组件（Host Components）。这些<strong>宿主组件通常是 React Native 框架提供的组件，它们和你用 JavaScript 自定义的组件不同，宿主组件是直接由 iOS/Android 原生平台实现的。</strong></p><p>除了 React Native 框架提供的宿主组件外，一些社区库也提供了宿主组件，甚至你自己也可以创建宿主组件。</p><p>它们共同的特点是，这些宿主组件上层是 JavaScript 部分，底层是 Native 部分，这两部分是通过 React Native 框架联系起来的。也就是说，你调用宿主组件时，底层直接渲染的是 Native 视图。</p><p>那么，我们这个简易商品列表页的 UI 设计稿中，用到了那些宿主组件呢？其实有三种：</p><ul>\n<li>容器组件 View：顾名思义它就是一个容器，可以用来包裹其他的组件，类似于 Web 中用于嵌套的 div；</li>\n<li>文字组件 Text：设计稿中的文字，比如水果名字“苹果”、“梨子”，价格“1元”、“3元”等等，这些类似于 Web 中装载文字的 span。</li>\n<li>安全区域组件 SafeAreaView：它是最外层的容器组件，用于适配 iPhoneX等的刘海儿屏。</li>\n</ul><p>宿主组件就是一个生产基础视图的工厂，你可以用 Text 组件实例化不同的文字视图。比如，我们可以实例化一个“苹果”文字，也可以再实例化另一个“火龙果”文字，代码如下：</p><pre><code class="language-plain">import {Text} from \'react-native\';\n\nconst element1 = &lt;Text&gt;苹果&lt;/Text&gt; // JSX \nconst element2 = &lt;Text&gt;火龙果&lt;/Text&gt; // JSX \n</code></pre><p>你看啊，在这段用 JavaScript 书写的代码中，使用了<strong>类似 HTML 的声明式语法，JSX</strong>。我们先从 react-native 框架中引入了 Text 组件，然后通过 JSX 语法，用一对单闭合标签将 Text 组件进行实例化，生成 Text 元素 element1。当 element1 这个元素渲染到手机屏幕上，就是文字“苹果”了，element2 就是文字“火龙果”。</p><h2>复合组件：纯 JavaScript 函数</h2><p>现在，你已经有了构建静态页面的宿主组件了，接下来你需要用这些宿主组件，搭建你自己事先拆好的自定义组件了，包括：</p><ul>\n<li>ProductTable 商品列表组件\n<ul>\n<li>Category 类别组件</li>\n<li>Product 商品组件</li>\n</ul>\n</li>\n</ul><p>要创建自定义的宿主组件，你必须写 Native 代码。但上面 3 个自定义组件，<strong>你可以直接用 JavaScript 创建，不用写 Native 代码，这类组件也叫复合组件（Composite Components）</strong>。这些复合组件是基于宿主组件或其他复合组件搭建而成的。</p><p>现在我们来创建第一个自定义的复合组件：Product 商品组件，它的示例代码如下：</p><pre><code class="language-plain">export default function Product({product = {name: \'苹果\', price: \'1元\'} }) {\n  return (\n    &lt;View style={{flexDirection: \'row\', marginTop: 5}}&gt;\n      &lt;Text style={{flex: 1}}&gt;{product.name}&lt;/Text&gt;\n      &lt;Text style={{width: 50}}&gt;{product.price}&lt;/Text&gt;\n    &lt;/View&gt;\n  );\n}\n</code></pre><p>这段代码，对于一些新手来说可能有点长，我分四步和你解释：<br>\n第一步，导出组件。还记得单一责任原则吗？一个组件的责任要单一，一个文件的责任也要单一。因此通常一个文件中只有一个组件，用<code>export default</code>就可以将它导出，让其他文件<code>import</code>引入使用。</p><p>第二步，定义函数。组件是一种特殊的函数。组件名字的首字母一定是大写的，示例中的<code>Product</code>是组件，因此它的 <code>P</code>是大写的（当然，还有类组件，但用得会越来越少，这里我们不探讨，你可以自己额外搜些资料）。</p><p>第三步，接收入参。组件能从其父组件中接参数，而且组件是函数，因此该参数就是函数的入参，通常命名为属性 <code>props</code>。<code>props</code> 是一个对象，因此也可以直接对它进行解构，直接获取对象中的值。</p><p>示例代码中用的就是用解构的方式来获取参数的，它直接获取了<code>product</code>参数，这里的<code>product</code> 是数据因此<code>p</code>是小写的。</p><p>第四步，返回 JSX。组件的返回值就是 JSX，我们前面也提到过，它是用来描述 UI 页面的，JSX 最终生成的是视图元素、文字元素。这里我们初始化了一个<code>&lt;View/&gt;</code>元素，和两个<code>&lt;Text/&gt;</code>元素。</p><p>我们概括一下，自定义复合组件就是一个纯粹的 JavaScript 函数，谁调用它，谁就可以给它传入参数，同样它调用谁，它就可以给谁传入参数，而 JSX 闭合标签就是调用函数的语法糖。</p><h2>静态页面的最终实现</h2><p>现在你知道了 Product 商品组件如何定义，那么 Category 类别组件、ProductTable 商品列表组件对你来说，也就很容易了。</p><p>最后我们来看下，静态页的最终实现，完整代码有点长，我就不都贴出来了，你可以看看文末补充材料中的链接，现在我们只看下它整体长什么样子：</p><pre><code class="language-plain">// index.js\nAppRegistry.registerComponent(\'appName\', () =&gt; App);\n\n\n\n// App.js\nconst PRODUCTS = [\n  {category: \'水果\', price: \'￥1\', name: \'PingGuo\'},\n];\n\nexport default function App() {\n  return (\n    &lt;SafeAreaView style={{marginHorizontal: 30}}&gt;\n      &lt;ProductTable products={PRODUCTS} /&gt;\n    &lt;/SafeAreaView&gt;\n  );\n}\n\n// ProductTable.js\nimport Category from \'./Category\';\nimport Product from \'./Product\';\n\nexport default function ProductTable({products}){\n  // ...\n  &lt;Category category={products[i].category}\n  // ...\n  &lt;Product product={products[i]} \n  // ...  \n}\n\n// Category.js\nexport default function Category({category}){}\n\n// ProductTable.js\nexport default function Product({product}) {}\n</code></pre><p>这里我定义了五个文件，每个文件中都最多有一个的组件。</p><ul>\n<li>index.js 文件：它是根文件，在该文件中<code>registerComponent</code>方法，会调用根组件 App，然后开始逐级调用，渲染应用；</li>\n<li>App 组件：在 App 组件中，用于表示商品信息的数据变量 <code>PRODUCTS</code>，在被调用时会通过 ProductTable 组件的 <code>products</code> 属性传递下去；</li>\n<li>ProductTable 组件：它被 App 组件调用后，它的调用入参就是 <code>products</code>。<code>products</code> 是一个数组，数组中的每一项就是 <code>Product</code>组件的入参<code>product</code>。每一项中的分类，就是<code>Category</code> 组件的入参 <code>category</code>。还是一样，组件首字母是大写的，属性、入参的首字母是小写的；</li>\n<li>Category 组件：它会被 ProductTable 组件调用两次，第一次调用接收的入参<code>category</code>是“水果”，第二次是“蔬菜”；</li>\n<li>Product 组件：它会被 ProductTable 组件调用 6 次，生成 6 个不同的商品元素，展示在手机屏幕上。</li>\n</ul><p><strong>简而言之，组件间的数据是单向流动的，是逐层往下传递的。</strong>调用是从根组件开始的，根组件会调用其子组件，子组件会调用子子组件，以此类推。调用过程中，数据会被当做组件的属性，层层传递下去。</p><h2>总结</h2><p>前面我们说了，React/React Native 之所以选择基于组件的方式来构建应用，原因就在于组件更能够满足现代应用重交互重展示的特点。</p><p>搭建 React Native 静态页面的核心就是搭建组件。它的整体思路是，从上往下拆出组件，从下往上把拆出来的组件进行逐一实现和拼装。</p><p>在这一讲中，我们搭建的静态页是一个无交互的、轻展示的应用，但 React/React Native 也表现得很好。只要我们遵循单一责任原则，对 UI 设计稿进行拆分，我们就能设计出一个可扩展的、可维护的应用。</p><p>即使后续这个应用有了复杂的交互、有了复杂的展示形式，它也能很好地扩展。我们只需把那些复杂的组件，那些不再符合单一责任原则的组件，进行拆分就可以了。</p><p>最后，请你牢牢记住，宿主组件是最基础的材料，所有我们自定义的复合组件都基于宿主组件搭建出来的，而复合组件又能搭建出更上层的复合组件，这样一步一步，我们才能把静态页面搭建完成。</p><h2>补充材料</h2><ul>\n<li>学习 React 最好的地方就是 <a href="https://beta.reactjs.org/">React 官网</a>。我给的官网地址是新官方地址，目前还是 beta 版本，但不妨碍它是学习 React 最好的地方。这一讲中商品列表静态页的案例，也是参考的 React 新官网改编的；</li>\n<li>这节课里完整的商品列表静态页代码，我放在了 <a href="https://github.com/jiangleo/react-native-classroom.git">GitHub</a> 上；</li>\n<li>关于 React 为什么选择基于组件的架构方式，而不是 MVC，在 2013 年的<a href="https://zh-hans.reactjs.org/blog/2013/06/05/why-react.html">《我们为什么要构建 React?》</a>这篇文章汇中，React 团队给出了答案。</li>\n</ul><h2>思考题</h2><p>静态页面很难体现组件架构相对其他架构的优势。我再找了一个带交互的页面，这个页面可以搜索商品和过滤无库存的商品。请你思考一下，当我们按照搜索、过滤、列表、种类、商品五个维度，用 MVC 方式来架构页面时，它的数据流向是什么样的？它相对于组件架构的优点缺点又是什么？</p><p><img src="https://static001.geekbang.org/resource/image/c1/7c/c10647a47d8b2ed5ff0a07cbacb40d7c.png?wh=730x1000" alt="图片"></p><p>欢迎你在评论区分享你的观点，我是蒋宏伟，咱们下节课见。</p>',
        article_title: "02｜Component：搭建静态页面的正确思路是什么？",
      },
      {
        title: "03｜Style：关于样式你需要知道的三件事",
        id: 501650,
        content:
          '<p>你好，我是蒋宏伟。</p><p>上一讲我们说到，搭建页面的第一步是搭建静态页面，拿到设计稿后要从上往下拆成组件，再从下往上把组件进行实现。</p><p>但组件只是页面的架子。如果你不使用任何样式，组件只能遵循默认的布局规则、默认字号颜色，铺在屏幕上，看起来就像调试的 log 信息一样，也没有什么体验可言。</p><p>俗话说人靠衣装、佛靠金装，页面体验要好就离不开样式的帮助。大家对 App 的第一印象，就是对页面样式的第一印象。虽说样式设计上是由设计师负责，但最终落地还得靠代码。如何把设计师给的设计稿在不同大小的机型上还原实现，通过验收，是工作中实实在在要面对的考验。</p><p>还原设计稿还只是最基本的要求，作为开发者，你还得要关心开发成本、可维护性、布局性能等事情。比如，有哪些样式库可以节约开发成本？代码量大了需求有变动，样式怎么改起来更方便？React Native 的布局性能究竟怎样，多层嵌套的复杂布局会不会导致性能问题？</p><p>所以今天，围绕着上面这些话题，我和你一起聊聊，关于样式你需要知道的三件事：</p><ul>\n<li>React Native 组件样式都有哪些？</li>\n<li>React Native 的 Flex 布局有哪些特点？</li>\n<li>React Native 样式代码如何管理？</li>\n</ul><h2>组件样式 = 通用样式 + “私有”样式</h2><!-- [[[read_end]]] --><p>我们先来说说，React Native 组件样式都有哪些。</p><p>还原设计稿离不开样式的支持，样式决定了组件在屏幕中的样子。大部分 React Native 提供的框架组件都有样式属性，也就是 style 属性。比如，你要改变文字的颜色，就需要给 Text 组件的 style 属性传一个 <code>{color: \'red\'}</code> 对象。如果要设置文字一个圆角边框，那就要稍微复杂一点了，需要三个样式值：边框颜色 borderColor、边框宽度 borderWidth、边框半径 borderRadius，比如这段示例代码：</p><pre><code class="language-plain">// 文字颜色\n&lt;Text style={{color:\'red\'}}&gt;\n// 圆角边框 \n&lt;Text style={{borderColor:\'green\', borderWidth: 1, borderRadius: 5}}&gt;  \n</code></pre><p>不过，不同组件的支持的样式可能会有些不同。比如，上面这段代码中，文字颜色 color 只有 Text 和 TextInput 组件有，图片组件  Image 没有文字也不需要 color 样式。而边框样式 border*（比如 borderColor、borderWidth、boderRadius 等等），容器组件 View、文字组件 Text、图片组件 Image 都有。</p><p>那我们怎么知道哪个组件都有哪些样式？要死记硬背吗？当然不用。</p><p>一方面，通过 TypeScript 声明文件，编辑器会提醒你某个组件都有哪些样式。另一方面，React Native 的组件样式是有规则的，你只需要把那些高频样式用会就可以了，其他低频样式，等要用到的时候再翻文档也不迟。</p><p>组件样式是有继承关系的，可以分为三层：</p><ul>\n<li>第一层是通用样式；</li>\n<li>第二层是 View 组件样式；</li>\n<li>第三层是 Text、Image 等其他组件样式。</li>\n</ul><p>我把组件样式的三层继承规则整理成了一张图片，相信你看完之后会有更深刻的理解：</p><p><img src="https://static001.geekbang.org/resource/image/2d/9c/2d0dbe2764f676b3bac28330b7ba969c.jpg?wh=1920x1047" alt="图片"></p><p>通用样式包括布局 Layout、变换 Transform 和阴影 Shadow。容器组件要不要展示归布局 Layout 管，位置确定后要往左边挪点还是旋转个角度归变换 Transform 管，要立体感要加个阴影归 Shadow 管。</p><p>View 组件样式继承了所有通用样式，包括布局 Layout、变换 Transform、阴影 Shadow，除此之外，还有自己的“私有”样式，比如背景颜色 backgroundColor、透明度 opacity、背面可见 backfaceVisibility。另外，Android API 28 以下用的阴影属性 elevation 也是 View 的“私有”样式，为了记忆方便，你也可以将其归类到阴影 Shadow 上。</p><p>大部分组件，比如 Text、Image 组件，都继承了 View 组件样式。因此 View 组件的背景色 backgroundColor、Android 低版本阴影 elevation 等“私有”样式，其实也可以算作通用样式。</p><p>但 Text 组件、Image 组件的“私有”样式，就不能相互通用了。文字颜色 color、字体大小 fontSize、文字行高 lineHeight，这些是文字组件独有的，图片组件就不能用。图片大小模型样式 resizeMode 是图片独有的，文字组件也不能用。</p><p>简而言之，组件样式 = 通用样式 + “私有”样式，View 组件样式可以算作通用样式，而Text 和 Image 组件各有各的“私有”样式。</p><h2>Flex：跨平台、高性能、易上手</h2><p>在所有样式中，你用的最多一定是布局样式（Layout），而布局样式中大部分都是 Flex 相关的弹性布局。</p><p>React Native 在 2015 年诞生之初，就选择使用 Flex 作为默认的布局方式，到现在为止也仅仅只支持了 Flex 弹性盒子布局和 Absolute 绝对定位这两种布局方法。而 Flex 这种布局方式，也经受住了时间的考验，得到更多开发者的认同。</p><p>Flex 布局有三个特点：<strong>跨平台</strong>、<strong>高性能</strong>、<strong>易上手</strong>。</p><p>首先 Flex 布局是跨平台的，这里说的跨平台有两层含义。第一层含义是 Flex 布局并不是 React Native 所独有的，在 Web、Android、iOS 平台也都在用，Flex 布局知识的可迁移性很强。无论是前端开发还是客户端开发，你在你当前领域掌握的 Flex 知识，可以直接拿到 React Native 上用，反之亦然。</p><p>跨平台的第二层含义是，React Native 的布局引擎 Yoga 是 Android、iOS 通用的。你给组件写的 Flex 布局代码，最终都会被 Yoga 引擎计算为精确的坐标系，然后按照计算后的坐标系把组件渲染到屏幕上，这个布局计算在双端是一致。</p><p>有些同学写代码的时候，可能一开始就担心，“这么写是不是会嵌套太深了，会不会引起布局性能问题？”，“设计师给的布局太复杂了，性能会不会不好啊？”。其实这些性能问题大可不必担心，正常写就行，Flex 布局用的 Yoga 引擎性能很好。</p><p>我这里放了一张布局引擎性能对比图，图片来源于 Github 开源仓库<a href="https://github.com/layoutBox/LayoutFrameworkBenchmark"> 《Layout Framework Benchmark》</a>。核心代码贡献者 Luc Dion 是一位 iOS 开发工程，他用 100 次 UICollectionView 布局耗时作为基准，横向对比了多款 iOS 布局引擎性能。其中就包括由苹果官方提供了 UIStackViews 和 Auto layout 布局引擎，还有使用 Yoga 实现 FlexLayout 布局引擎。</p><p><img src="https://static001.geekbang.org/resource/image/61/f7/612209db97553841a1d49bf207e7eef7.png?wh=1000x736" alt="图片"></p><p>在图中你可以看出，虽然 iPhone 每代的性能越来越好，100 次 UICollectionView 的布局耗时越来越少。但从框架性能角度看，<strong>使用 Yoga 实现的FlexLayout 布局引擎比苹果官方提供了 UIStackViews 和 Auto layout 布局引擎，耗时减少了将近一个量级。</strong></p><p>这样看来，React Native 中的 Flex 布局确实是挺好的，那上手难不难？不难，易学易用，上手就会。</p><p>前面我们也提到过，Flex 其实是一种通用的布局方式，它引入了弹性布局的概念，这个概念在各平台都是一样的。但在具体的写法上，各个平台可能会有一些差异。</p><p>我用最常见三种布局给你举些例子，它们包括从上往下排列布局、左图右文布局、文字居中布局。你可以感受一下，React Native 的 Flex 布局，和你在其他平台使用过的 Flex 布局有什么差异。</p><p><strong>第一个例子，从上往下排列布局。</strong></p><p>在同一个父容器中，放三个子容器 View，父容器不写任何的样式，子容器只给一个固定高度，三个子容器就是从上往下排列的。</p><p>这里强调一下，父容器 VIew 的默认样式是<code>{display: "flex",flexDirection:\'column\'}</code>。也就是说，父容器是弹性盒子，且主轴是纵轴，子元素会沿着纵轴（主轴）方向排列，因此在父元素不写任何样式时，子元素是从上往下排列的。</p><p>示例代码如下：</p><pre><code class="language-plain">&lt;View&gt;\n  &lt;View style={{height: 50, backgroundColor: \'powderblue\'}} /&gt;\n  &lt;View style={{height: 50, backgroundColor: \'skyblue\'}} /&gt;\n  &lt;View style={{height: 50, backgroundColor: \'steelblue\'}} /&gt;\n&lt;/View&gt;\n</code></pre><p><strong>第二个例子，左图右文布局。</strong></p><p>在同一个父容器中，放一个 Image 和一个 Text。为了让图片文字左右排列，我们需要给父容器设置布局样式<code>{flexDirection: \'row\'}</code>。为了让图片不拉伸变形，我们需要给图片 Image 设置一个固定宽高。为了让文字将剩余宽度铺满，我们需要给文字 Text 设置 <code>{flex: 1}</code>。这时，父容器的主轴是横轴，子元素会沿着横轴（主轴）方向排列，整体布局是左图右文。具体的代码如下：</p><pre><code class="language-plain">&lt;View style={{flexDirection: \'row\'}}&gt;\n  &lt;Image\n    style={{width: 100, height: 100}}\n    source={{\n    uri: \'https://placeimg.com/640/480/cats\',\n  }}\n  /&gt;\n  &lt;Text style={{flex: 1,fontSize: 18}}&gt;我是文字&lt;/Text&gt;\n&lt;/View&gt;\n</code></pre><p><strong>第三个例子，文字居中布局。</strong></p><p>曾经有一道经典的面试题，“父容器高度确定，使其子元素 Text 水平垂直方向居中”，不过自从有了 flex 后，这道题的难度降低了很多，问的频率也变低了。</p><p>我们通过 alignItems 和  justifyContent 的配合，很容易实现水平垂直方向的居中布局，示例代码如下：</p><pre><code class="language-plain">&lt;View\n    style={{\n      alignItems: \'center\',\n      justifyContent: \'center\',\n      // 高度确定\n      height: 60,\n      borderWidth: 1,\n    }}&gt;\n    &lt;Text\n      style={{\n        fontSize: 18,\n        // 文字默认内边距，会导致垂直居中偏下\n        includeFontPadding: false,\n        // 文字默认基于基线对齐，会导致垂直居中偏下\n        textAlignVertical: \'center\',\n      }}&gt;\n    我是文字1\n    &lt;/Text&gt;\n&lt;/View&gt;\n</code></pre><p>在这段代码中，你只需要给父容器设置<code>{justifyContent: \'center\',alignItems: \'center\'}</code>，使子元素分别在主轴（纵轴）和副轴（横轴）方向居中就可以了。这里有个小细节，Android 文字默认会有内边距且基于基线对齐，这会导致文字垂直居中时偏下。<strong>因此垂直居中时，最好把内边距关掉，并把文字放在中线而不是基线上。</strong></p><p>当然，文字水平垂直方向居中，除了 Flex 方案，还有行高方案，感兴趣的同学也可以自己研究一下，这里就不再介绍了。</p><p>讲完这三个例子后，你是否发现 React Native 与你所熟悉的其他平台，在 Flex 布局上的不同点了呢？你可以在心里对照一下，这样做能帮你学得更快。</p><h2>StyleSheet：分离、复用、性能好</h2><p>在前面的几个例子中，我们写样式用的都是内联的方式。内联样式就是直接在 JSX 的元素属性中写样式，这样写起来是很方便，但是却把 JSX 的元素结构和样式混在一起了。</p><p>既然样式属性可以内联，那事件属性也可以内联，甚至所有的属性都可以内联。而且现在 JSX 模板既要声明元素结构，又要写样式、事件、属性逻辑，整一个大杂烩。写起来是很爽，但维护起来就很“酸爽”了。</p><p>此外，内联样式还存在不能复用，性能损耗的问题。首先，即便两个文字组件的样式是一样的，内联样式也不能重复使用，必须在两个组件中各写一套。其次，每次执行自定义组件函数生成元素时，或实例化元素时，样式对象都要重复创建，这导致了性能损耗。你可以看看这段示例代码感受一下：</p><pre><code class="language-plain">// 各种内联，导致 JSX 结构不清楚。\n&lt;View\n      // 普通属性\n      hitSlop={\n      top: 10,\n      bottom: 10,\n      left: 0,\n      right: 0\n    }\n      // 事件属性\n      onLayout={() =&gt; {\n      // 事件逻辑\n      }}\n      // 样式属性\n    style={{\n      alignItems: \'center\',\n      justifyContent: \'center\',\n      height: 60,\n      borderWidth: 1,\n    }}&gt;\n    &lt;Text\n      style={{\n        fontSize: 18,\n        includeFontPadding: false,\n        textAlignVertical: \'center\',\n      }}&gt;\n    我是文字1\n    &lt;/Text&gt;\n    &lt;Text\n      style={{\n        fontSize: 18,\n        includeFontPadding: false,\n        textAlignVertical: \'center\',\n      }}&gt;\n    我是文字2\n    &lt;/Text&gt;\n&lt;/View&gt;\n</code></pre><p>所以，我推荐你使用样式表 StyleSheet 来写样式，而不是内联的方式。使用样式表 StyleSheet 有三个好处：</p><ul>\n<li>元素结构和样式分离，可维护性更好；</li>\n<li>样式对象可以复用，能减少重复代码；</li>\n<li>样式对象只创建一次，也减少性能的损耗。</li>\n</ul><p>比如，面对上面这种大杂烩的代码，你可以试着把内联样式等属性抽离出来，没有了冗余的样式和属性，我们一眼就能看出原本的 JSX 结构：</p><pre><code class="language-plain">// JSX 结构\n&lt;View\n      hitSlop={hitSlop}\n      onLayout={handleLayout}\n    style={styles.container}&gt;\n    &lt;Text style={styles.texts}&gt;我是文字1&lt;/Text&gt;\n    &lt;Text style={styles.texts}&gt;我是文字2&lt;/Text&gt;\n&lt;/View&gt;\n\n// 样式表\nconst styles = StyleSheet.create({\n  container: {\n    alignItems: \'center\',\n    justifyContent: \'center\',\n    height: 60,\n    borderWidth: 1,\n  },\n  texts: {\n    fontSize: 18,\n    includeFontPadding: false,\n    textAlignVertical: \'center\',\n  }\n});\n</code></pre><p>你看，这是一个容器组件 View 嵌套了两个文字组件 Text。样式结构分离后，逻辑也更加清晰，维护起来也会容易很多。</p><p>而且，在这段代码中，两个 Text 组件使用了同一个样式对象 <code>styles.texts</code>，也实现了复用。样式对象在代码初始化时就创建好了，每次执行就不用再创建了，这样减少了性能损耗。</p><h2>课程小结</h2><p>我们前面说了，样式决定了页面的“颜值”，关于样式你需要知道这三件事：</p><ol>\n<li>大部分框架提供的组件都有自己的样式属性 style，包括通用样式和“私有”样式。其中 View 组件样式可以看做通用样式，而 Text 组件、Image 组件各有各的“私有”样式；</li>\n<li>在所有样式中，最常用的是 Flex 布局，也是你的学习重点。React Native 的 Flex 布局和其他平台的 Flex 布局模型基本相同，如果你有过 Flex 的使用经验，只需结合示例掌握 React Native 中的那些不同点就能快学会；</li>\n<li>内联样式写 Demo 是没有问题的，但在实际的生产中我更加推荐你使用样式表 StyleSheet 来进行样式管理。</li>\n</ol><p>React Native 的样式大都是从 Web 中借鉴过来的，并且还进行了“CSS in JS”的改良，相信你学起来会非常快。</p><p>如果你问我学习样式还有什么技巧，那我会告诉你，无他，唯手熟尔。只要多多练习就能学好。学习样式不需要严格的推理逻辑，需要的只有勤加实践，当初我入门的时候，就是通过模仿国内电商的官网，把样式给打通关的，你也赶紧试试吧。</p><h2>补充材料</h2><p><strong>样式学习材料：</strong>React Native 的样式其实很简单，所有的核心样式在的源码中只有 1 份声明文件<a href="https://github.com/facebook/react-native/blob/8bd3edec88148d0ab1f225d2119435681fbbba33/Libraries/StyleSheet/StyleSheetTypes.js">StyleSheetTypes</a>。这一份声明文件对应的是官网的 6 篇文档：<a href="https://reactnative.dev/docs/view-style-props">View Style Props</a>、<a href="https://reactnative.dev/docs/text-style-props">Text Style Props</a>、<a href="https://reactnative.dev/docs/image-style-props">Image Style Props</a>、<a href="https://reactnative.dev/docs/layout-props">Layout Props</a>、<a href="https://reactnative.dev/docs/shadow-props">Shadow Props</a>、<a href="https://reactnative.dev/docs/transforms">Transforms</a>。</p><p><strong>Flex 学习材料</strong>：Yoga 官网提供了 Flex 弹性盒子布局的在线试用应用 <a href="https://yogalayout.com/playground">Playground</a>，你可以动手把玩一下。React Native 官网也为你提供了沙盒环境的相关 <a href="https://reactnative.dev/docs/flexbox">Demo</a>。</p><p><strong>样式管理资料</strong>：今天只介绍了<a href="https://reactnative.dev/docs/stylesheet">样式表 StyleSheet</a>这种最基础的样式管理方案。业内主流的方案还有<a href="https://styled-components.com/">带样式的组件 styledComponent</a> 和<a href="https://tailwindcss.com/">样式简写方案 tailwind</a>，它们虽然是源自浏览器的 CSS 管理方案，但也可以在 React Native 中使用。在推特上也有关于样式管理方案的<a href="https://twitter.com/mrousavy/status/1474135375555743750">讨论</a>，你可以看看大家的看法是什么。业务代码的样式管理没有银弹，选择适合你的就好了。</p><p><a href="https://github.com/jiangleo/react-native-classroom/tree/main/src/03_StyleSheet">今天的 Demo 在这里！</a></p><h2>作业</h2><ol>\n<li>请你使用 View、Text、Image 组件实现一个简易版的瀑布流布局，类似于京东、淘宝首页瀑布流列表，不要求能够无限滚动只要能实现左右等宽、不等高的布局即可。</li>\n</ol><p><img src="https://static001.geekbang.org/resource/image/36/88/361a7df40bc2a671336fcf44ca560388.png?wh=1170x1140" alt="图片"></p><ol start="2">\n<li>如果你要给 Text 组件设置全局的默认样式，比如字体，你会怎么设置？</li>\n</ol><p>欢迎在评论区写下你的想法。我是蒋宏伟，咱们下节课见。</p>',
        article_title: "03｜Style：关于样式你需要知道的三件事",
      },
      {
        title: "04｜State：如何让页面“动”起来？",
        id: 503115,
        content:
          '<p>你好，我是蒋宏伟。</p><p>那么这一讲，我们来讲搭建页面的第二步，让页面“动”起来，这里的“动”说的是在不同场景下，让页面展示出不同的内容。</p><p>怎么让页面“动”起来呢？这就要用到状态 State 了。</p><p>一个页面也好，一个应用也好，只有把状态设计清楚了，程序才能写得好。讲到状态，有些人可能会说，状态不就是页面中那些会“动”的数据吗？这很简单，还有什么好讲的。</p><p>这没错，状态确实是页面中会“动”的数据，但是要把状态用好不容易，有时候容易把状态设计复杂了，不仅代码要写得更多，还容易导致程序维护起来更麻烦。</p><p>这次，我会以搭建一个会“动”的简易购物车页面为例，和你分享下我在这方面的经验。简易购物车页面是这样的：</p><p><img src="https://static001.geekbang.org/resource/image/dd/9e/dd69765bb8fcb1f9dffyy2df4d2b789e.png?wh=1000x784" alt="图片"></p><p>它比上一讲的商品表单页多了一些交互，它的所有数据都是从网络请求过来的，这些数据包括商品名称、商品价格、商品数量，数据从网络请求回来后会展示在页面上。你可以点击页面中的加号或减号，来添加数量或减少商品数量，底部的结算总价会随着商品数量的变化而变化。</p><p>要实现这个简易购物车的静态很简单，它只包括两个组件，商品表单组件 ProductTable 和商品组件  ProductRow。完成静态页面的搭建后，接下来就<strong>要让页面“动”起来了</strong>，我把这个过程分成了 4 步来实现，状态初选、状态确定、状态声明、状态更新。</p><!-- [[[read_end]]] --><h2>第一步：状态初选</h2><p>状态初选说的是，先看看页面那些数据是会变化的，这些会变化的数据都可能是状态，我们先把它们找出来。</p><p>程序本身的事件和用户操作都有可能导致页面发生变化，因此我们从这两个方向来进行初选。</p><p>程序本身的事件，比如网络请求、 setTimeout，都可能导致页面发生变化。在购物车页面中，商品列表的数据是从服务端请求过来，在列表数据从服务端回来之前，页面是空白的，在请求过程中会有加载提示，请求成功后购物车页面就会展示出来，当然还要把请求失败的情况考虑进去。</p><p>所以，我圈选出来的第一条动态数据是请求过程，第二条是可能的请求失败情况；第三条是商品表单本身，第四条是所有商品的结算总价。</p><p>用户操作，比如点击、滑动、缩放，也可能导致页面发生变化。在购物车页面中，用户点击加号购物车中的商品数量会增加，点击减号数量会减少。反映商品数量的数据，就是第五条的动态数据。</p><p>现在，我已经把这 5 个初选的状态给你在图中标出来了：</p><p><img src="https://static001.geekbang.org/resource/image/43/f3/43bc848544fb40b449c097e6054ac0f3.png?wh=1920x1541" alt="图片"></p><h2>第二步：状态确定</h2><p>有些人完成状态初选这一步后，就直接写起代码来了，一口气声明了 5 个状态，然后想办法去操作这 5 个状态如何变化。</p><p>但我的经验是，状态初选完成后，不能急着写代码，要先确定一下这些初选状态中那些是真正的状态，把其中无用的状态剔除掉，然后再去写代码。这样代码写得少、写得快，代码逻辑也会更简单一些，也更难出 BUG 一些。</p><p>这些都是我们要在状态确定这一步要做的，我总结了三条经验：</p><p><strong>首先，一件事情一个状态。</strong>我发现有些同学写代码的时候，在定义请求状态时，喜欢用布尔值 isLoading 来表示空闲状态或请求中的状态，用 isError 来表示成功状态或失败状态，明明就是网络请求这一件事，却用了两个状态来表示，这就有点多余了，甚至在一些不好测试的边界条件下可能还会留坑。</p><p>这时其实只需要定义一个状态 ，代码示例如下：</p><pre><code class="language-plain">const requestStatus = {\n  IDLE : \'IDLE\',\n  PENDING : \'PENDING\',\n  SUCCESS : \'SUCCESS\',\n  ERROR : \'ERROR\',\n}\n</code></pre><p>这里，我定义的是一个枚举对象 requestStatus，用它来表示请求状态。这个对象有 4 个值，包括请求空闲IDLE、请求中PENDING、请求成功SUCCESS、请求失败ERROR。你看，用一个状态是不是比用两个状态更加贴合请求的实际情况呢？</p><p><strong>第二，重复状态不是状态。</strong>商品组件 ProductRow 中的这个商品数量确实是一个状态，但它却和从网络请求中回来的商品表单状态重复了。从代码层面上，我们确实有办法同时保留两个状态，但这样做就绕弯子了。</p><p>更好的做法是，把这两个在不同组件之间的重复状态进行合并，去掉底层组件的重复状态，只保留顶层组件中的商品数量作为唯一的状态。</p><p><strong>最后，可计算出来的状态不是状态。</strong>一个状态必须不能通过其他状态、属性或变量直接计算出来，能通过其他值计算出来的状态，都不是状态。比如，在购物车页面中，结算总价这个动态数据，是可以通过对所有商品的单价和数量的积进行求和得出来的，所以它不是状态。</p><pre><code class="language-plain">结算总价 = ∑(商品的单价 * 数量)\n</code></pre><p>初选的状态经过以上三步筛选之后，合并了①请求中和②请求失败，避免了重复数据③商品列表和⑤商品数量，根据已有状态推导出了④结算总价。初选状态一共 5 个，最终确定下来就只剩下网络请求状态和商品列表这两个状态了。</p><p>只有确定状态这一步做好了，你声明状态和改变状态，才会变得容易。</p><h2>第三步：状态声明</h2><p>React 提供了 useState 状态声明函数，你可以用它来管理函数组件的状态。</p><p>使用 useState 声明状态时，状态和组件是绑定的关系，useState 在哪个组件中使用，它生成的状态就属于那个组件。由于单向数据流的原因，React 把父组件的状态传给子组件只需要传一次，传给子子组件需要传递两次。</p><p>因此，你在定义状态的时候，一定要先考虑好把状态绑定到哪个组件上。我建议你用<strong>就近原则</strong>来绑定状态，就近原则的意思是哪个组件用上了状态，就优先考虑将状态绑定到该组件上，如果有多个组件使用了同一个状态，则将其绑定到最近的父组件上。这样做能让使用 props 传递状态的次数最少。</p><p>在我们的购物车案例里，你使用就近原则判断一下，<s>你</s>就可以确定购物车页面的两个状态，其实放在 ProductTable 组件中比较合适。</p><p>那接下来的问题是，状态声明代码应该如何写？</p><p>首先，我需要和你强调的是，在 React/React Native 中，所有使用 use 开头的函数，比如接下来要用到 useState 函数，它们都叫<strong>钩子函数（hook function）</strong>。和普通函数不同，你不能把钩子函数写在 if 条件判断中、事件循环中、嵌套的函数中，这些都会导致报错。</p><p>钩子函数类似于 JavaScript 的 <code>import</code> ，你最好在函数组件的顶部使用它们。</p><p>具体声明商品表单状态 products 和请求状态 requestStatus 代码是这样的：</p><pre><code class="language-plain">import React, {useState} from \'react\';\n\nexport default function ProductTable() {\n  const [products, setProducts] = useState([]);\n  const [requestStatus, setRequestStatus] = useState(\'IDLE\');\n  // ...\n}\n</code></pre><p>在文件的第一行代码中，我们从 React 中引入 useState 函数，然后在函数组件 ProductTable 的顶部使用了 useState 声明了两个状态。</p><p>useState 函数的入参是状态的默认值，函数的返回值是状态和更新该状态的函数。第一次调用 useState 函数后，就生成了默认值是空数组<code>[]</code> 的商品表单状态 <code>products</code> ，以及设置该状态的函数<code>setProducts</code>。第二次调用 useState 函数后生成了默认值是字符串<code>\'IDLE\'</code> 的请求状态 requestStatus ，以及设置该状态的函数叫做<code>setRequestStatus</code>。</p><p>如果在 if 中使用了任何的钩子函数，就会报错：</p><pre><code class="language-plain">import React, {useState, useEffect} from \'react\';\n\n// 错误\nexport default function ProductTable() {\n  const [requestStatus, setRequestStatus] = useState(\'IDLE\');\n  // ...\n  if(requestStatus === \'ERROR\') return &lt;Text&gt;网络出错了&lt;/Text&gt;\n\n  // 在 else 分支中，使用任何 use 开头的钩子函数，都会报错\n  const [products, setProducts] = useState([]);\n  useEffect(() =&gt; {})\n  \n  return &lt;Text&gt;购物车页面&lt;/Text&gt;\n}\n</code></pre><p>在这个错误示例中，我们先使用了 <code>if(requestStatus === \'ERROR\')</code> 判断了网络请求状态。如果请求失败，则提示用户“网络出错了”，否则就返回真正的购物车页面。但 <code>if return</code> 后面的代码，就相当于<code>else</code>分支，在分支中使用了钩子函数，比如 useState、useEffect，代码就会报错。</p><p>出现这种报错，是因为 if 破坏了 React 的 <a href="https://zh-hans.reactjs.org/docs/hooks-rules.html">Hook 规则</a>。在 React 的 Hook 机制中，是把 Hook 的调用顺序作为索引，用它把 React 框架内部 state 和其函数组件的 useState 返回值中的 state 给关联起来了。当你使用了 if 的时候，就容易破坏 Hook 的调用顺序，导致 React 不能正确地将框架内部 state 与函数组件 useState 的返回值关联起来，因此 React 在执行的时候就会报错。</p><p>有时候一个函数组件很长，写到后面了，前面的一些逻辑就记不那么清楚了，如果代码写到哪就在哪儿声明一个新状态，一不小心就可能会踩坑。因此，你应该把 use 开头的钩子函数都写在组件的顶部，把 JSX 都写在函数组件的最后面，并使用 <a href="https://www.npmjs.com/package/eslint-plugin-react-hooks">eslint-plugin-react-hooks</a> 插件来保障 Hook 规则的会被正确执行。</p><h2>第四步：状态更新</h2><p>现在，到了最后一步了。不过，这一步中涉及购物车页面业务实现逻辑的部分，我就不一一介绍了，具体实现代码我放到了附加材料中，这里我想重点和你强调的是如何更新对象类型的状态。</p><p>在 JavaScript 中的数据类型可以分为两类，对象数据类型（Objects）和原始数据类型（Primitive values），对象数据类型包括对象（Object）、数组（Array），原始数据类型有 7 种，比如数字（number）、字符串（string）等等。</p><p>在 React/React Native 中，使用这两类数据类型作为状态都是可以的，但是更新这两类状态的方法不一样，如果你没有理解清楚二者的区别，就容易出现一些低级的 BUG。</p><p>我们先来看原始数据类型的状态如何更新。</p><p>在购物车页面中，商品数量可以通过点击加号进行加一，通过点击减号减一。我们用原始数据类型数字来表示商品数量状态，其代码实现如下：</p><pre><code class="language-plain">export default function Count() {\n  const [count, setCount] = useState(0);\n\n  return (\n    &lt;View&gt;\n      &lt;Text&gt;{count}&lt;/Text&gt;\n      &lt;Button title="+" onPress={() =&gt; setCount(count + 1)} /&gt;\n      &lt;Button title="-" onPress={() =&gt; setCount(count - 1 &gt;=0? count - 1: 0)} /&gt;\n    &lt;/View&gt;\n)};\n</code></pre><p>你可以看到，我们使用 useState 声明了商品数量状态 count 和更新状态的函数 setCount。<br>\n组件初始化时，也就是组件函数第一次调用时，商品数量状态 count 的默认值是 0，页面展示的数字就是 0.</p><p>当你点击页面中的加号（“+”）时，就会触发加号（“+”）点按组件（Button）的点击事件（onPress），此时会调用 setCount 函数更新状态。</p><p>setCount 函数的入参是 count + 1，其中 count 取的是组件第一次调用的默认值 0，0 + 1 = 1，因此新状态就是 1，之后 React/ React Native 会再调用一次组件函数，这一次调用时 useState 声明的状态 count 的值就是新状态的值 1，此时 Text 组件收到的值也是 1，最后页面刷新展示新状态 1。</p><p>第二次点击加号时，也是先更新 React/ React Native 内部的<s>新</s>状态，将它更新到 2，然后再执行一次组件函数，将内部的新状态同步给 count，最后刷新页面展示新状态 2。</p><p>以此类推，<strong>对于原始数据类型而言，调用 setCount 更新原始数据类型状态的值，页面就会发生更新。</strong></p><p>那对象和数组类型的状态如何更新呢？</p><p>我们先声明一个对象状态和一个数组状态，代码如下：</p><pre><code class="language-plain">const [countObject, setCountObject] = useState({num: 0});\nconst [countArray, setCountArray] = useState([0]);\n</code></pre><p>这段代码中，调用了两次 useState，声明一个对象状态 countObject 和一个数组状态 countArray，以及对应的状态更新函数。</p><p>理论上，你可以直接改变对象状态或数组状态的值，再调用状态更新函数，代码如下：</p><pre><code class="language-plain">countObject.num++;\nsetCountObject(countObject)\n\ncountArray[0]++;\nsetCountArray(countArray)\n</code></pre><p>但是你试过后会发现，调用状态更新函数后，页面什么变化都没有，这是为什么呢？<br>\n弄清楚了对象数据类型（Objects）和原始数据类型的区别后，你就明白了。我给你举个例子：</p><pre><code class="language-plain">const countObject = {num: 0}\ncountObject.num++;\n\ncountObject.num === countObject.num // false\ncountObject === countObject // true\nsetCountObject(countObject) // 不更新\n</code></pre><p>你看，当你更新 countObject.num 时，countObject.num 确实更新了，但是 countObject 的引用并没有更新，所以调用 setCountObject 更新状态时，页面没有任何变化。</p><p>这是因为，对象它是一种复合数据类型，它内部的值是可变的（mutable），但它的引用是不可变了（immutable），你更新了对象的内部值后，它的引用并没有发生变化。</p><p>那状态是对象或数组时，应该怎么更新呢？</p><p>业内也有形似 mutable 的更新方案 useImmer，可以通过直接修改变量的值来更新状态。但其底层原理也是，新建一个对象或数组传给状态更新函数，让状态更新函数知道对象或数组确实发生了变化，这时 React/React Native 框架才会帮你更新页面。</p><p>这里，我用的也是直接新建对象、新建数组的方式，代码如下：</p><pre><code class="language-plain">setCountObject({...countObject, num: countObject.num+1});\n\nconst newCountArray = [...newCountArray]\nnewCountArray[0]++;\nsetCountArray(newCountArray)\n</code></pre><p>你可以看到，对于对象状态的更新我是这么处理的，我先创建了一个新对象<code>{}</code>，然后用<code>...</code>的解构的方式将老对象 countObject 的内部值重新赋值给了新对象<code>{}</code>，再指定<code>num</code>属性进行了复写。对于数组状态的更新也是类似的，你可以自己试试。</p><h2>总结</h2><p>这一讲，我们完成搭建页面的第二步：让页面“动”起来。让页面“动”起来，就要用到状态，我们这一讲的具体实现分为 4 个步骤，状态初选、状态确定、状态声明、状态更新。</p><ul>\n<li>状态初选，就是把设计稿中的那些会“动”的数据先选出来；</li>\n<li>状态确定，就是合并同类状态、删除无用状态和衍生状态；</li>\n<li>状态声明，在当前的初学阶段，只需要学会使用 useState 来声明组件状态即可；</li>\n<li>状态更新是最后一步。交互事件和程序事件会触发状态的更新，但状态更新函数并不会帮我们自动合并上一个状态，因此在处理对象状态和数组状态时，每次更新时必须新建一个完整的对象或数组。</li>\n</ul><p>行军作战是兵马未动粮草先行，讲究的是谋而后动。搭建页面、开发组件也是如此，我们也要<strong>代码未动构思先行</strong>，先把组件状态设计好了，简单即美，要是没想清楚弄复杂了，后面填坑成本会很高。</p><h2>附加材料</h2><ol>\n<li>再次强调，学习 React 最好的材料就是 React 新官网，我推荐你去读一读<a href="https://beta.reactjs.org/learn/reacting-to-input-with-state">《如何使用状态响应用户的输入时间》</a>、<a href="https://beta.reactjs.org/learn/updating-objects-in-state">《更新状态对象》</a>和<a href="https://beta.reactjs.org/learn/updating-arrays-in-state">《更新状态数组》</a>。</li>\n<li>实现购物车页面的完整代码，我放在了<a href="https://github.com/jiangleo/react-native-classroom/tree/main/src/04_State">GitHub</a>上。</li>\n</ol><h2>作业</h2><ol>\n<li>请你实现一个井字棋。井字棋的规则和五子棋类似，两人在 3 * 3 格子上进行连珠游戏，任意 3 个标记形成一条直线，则为获胜。在写之前，推荐你先玩一下这个井字棋，了解一下<a href="https://codepen.io/gaearon/pen/aWWQOG?editors=0010">井字棋的最终效果</a>。</li>\n<li>请你思考一下实现一个井字棋，最少需要声明几个状态？</li>\n</ol><p><img src="https://static001.geekbang.org/resource/image/59/e0/599257d6cc84ceda0fc5ebe8174af7e0.png?wh=474x347" alt="图片"></p><p>欢迎在留言区分享你的想法。下一节课我们将来讨论React Native中图片组件的用法和最佳实践，你可以做些准备。我是蒋宏伟，咱们下节课见。</p>',
        article_title: "04｜State：如何让页面“动”起来？",
      },
      {
        title: "05｜Image：选择适合你的图片加载方式",
        id: 503636,
        content:
          '<p>你好，我是蒋宏伟。</p><p>今天我们来讲解 React Native 框架中的 Image 组件。顾名思义，图片组件 Image 就是用来加载和展示图片的。</p><p>你可能会觉得，图片组件的基础用法非常简单呀，学起来也很容易上手，这有什么好讲的呢？没错，正因为它很简单，有时候，我们可能会忽视对这些基础知识的琢磨。在日常开发中，图片是影响用户体验的关键因素之一，它很常见，基本上哪里都有它。而且相对于文字，图片也更容易抓住用户的眼球。图片组件很重要，但要用好却不那么容易。</p><p>React Native 的 Image 组件一共支持 4 种加载图片的方法：</p><ul>\n<li>静态图片资源；</li>\n<li>网络图片；</li>\n<li>宿主应用图片；</li>\n<li>Base64 图片。</li>\n</ul><p>这4种方案给我们业务提供了更灵活的选择空间，但同时也让不少同学犯了选择困难症，不同情况下我该怎么选呢？今天，我们就来深度剖析这 4 种方案分别的适用场景是什么，并给你介绍一下我推荐的最佳实践。</p><h2>静态图片资源</h2><p>静态图片资源（Static Image Resources）是一种<strong>使用内置图片</strong>的方法。静态图片资源中的“静态”指的是每次访问时都不会变化的图片资源。站在用户的视角看，App 的 logo 图片就是不会变化的静态图片资源，而每次访问新闻网站的新闻配图就是动态变化的图片。</p><!-- [[[read_end]]] --><p>如果图片每次都不会变化，那么你就可以把这张图片作为静态图片资源，内置在 App 中。这样，用户在打开你的 App 时，图片是从本地直接读取的，直接读取图片的速度比走网络请求先下载再加载的速度要快上很多。一张网络图片从下载到展示的耗时通常需要 100ms 以上，而一张内置图片从读取到展示的耗时通常只有几 ms，甚至更低，二者耗时相差了两个数量级。</p><p>因此，在一些高性能场景下，你应该选择把这些不经常变动的静态图片资源内置到 App 中。当用户打开 App 时，这些图片就能够立刻展示出来了。</p><p>那我们具体是怎么使用静态图片资源的呢？这里我们可以分为 3 步。首先，把图片放到 React Native 的代码仓库中，然后通过 require 的方式引入图片，最后把图片的引用值传给 source 属性。Image.source 属性是用来设置图片加载来源的。</p><p>这里我们需要注意的是，require 函数的入参必须是字面常量，而不能是变量。你可以看下这段代码：</p><pre><code class="language-plain">// 方案一：正确\nconst dianxinIcon = require(\'./dianxin.jpg\')\n&lt;Image source={dianxinIcon}/&gt;\n\n// 方案二：错误\nconst path = \'./dianxin.jpg\'\nconst dianxinIcon = require(path)\n&lt;Image source={dianxinIcon}/&gt;\n</code></pre><p>在这段代码中，方案一是静态图片资源正确的使用方式，方案二是错误的。方案一用的是图片相对路径的字面常量，也就是<code>\'./dianxin.jpg\'</code>。而方案二，用的是图片相对路径的变量，也就是 <code>path</code> 。</p><p>你是不是很好奇，为什么使用 require 函数引入静态图片资源时，require 入参，也就是图片的相对路径，必须用字面常量表示，而不能用变量表示？静态图片资源的加载原理又是什么呢？我们接下来继续分析。</p><h3>静态图片资源的加载原理</h3><p>我们还是用加载点心图片（dianxin.jpg）为例，从编译时到运行时，剖析加载静态资源图片的全过程，一共分为三步。</p><p><strong>第一步编译</strong>：在编译过程中，图片资源本身是独立于代码文件之外的文件，图片资源本身是不能编译到代码中的，所以，我们需要把图片资源的路径、宽高、格式等信息记录到代码中，方便后面能从代码中读取到图片。</p><p>你可以选一张你喜欢吃的点心的图片，命名为 dianxin.jpg，并把点心图片和 index.js 文件放在同一层级目录下。然后在 index.js 中通过 require 方法把点心图片引入进来，交由 Image 组件使用。</p><p>我在这一讲末尾的补充材料中，为你留了示例代码，课后你可以参考示例代码，一步步地自己动手操作。现在，你应该把注意力放在理解静态图片资源的编译、构建和加载的流程上，具体的执行细节可以后续再了解。</p><p>在你引入静态图片资源完成后，可以先本地试试图片是否能正常展示。如果展示没有问题，直接运行<code>react-native bundle</code>的打包命令，开始打包编译：</p><pre><code class="language-plain">npx react-native bundle --entry-file index.tsx --dev false --minify false --bundle-output ./build/index.bundle --assets-dest ./build\n</code></pre><p>这段打包（bundle）命令的意思是，以根目录的 index.tsx 文件为入口（entry file），产出 release（dev=false）环境的包，这个包不用压缩（minify=false），并将这个包命名为 ./build/index.bundle，同时将静态资源编译产物放到 ./build 目录。这个 build 目录结构如下：</p><pre><code class="language-plain">./build\n├── assets\n│ &nbsp; └── src\n│ &nbsp; &nbsp; &nbsp; └── Lesson3Image\n│ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; └── dianxin.jpg\n└── index.bundle\n</code></pre><p>编译后的产物会都存在 build 目录中，这个目录需要你提前创建好，否则会有报错提示。编译完成后，你可以在 build 目录中找到 index.bundle 文件，它是编译后的 JavaScript 代码。另外， build 目录中还有一个 assets 目录，assets 目录放的是编译后的图片 dianxin.jpg。</p><p>然后我们再打开 index.bundle 文件，搜索 dianxin 关键字。我们可以找到一个和 dianxin 关键字相关的独立模块，这个模块的作用就是将静态图片资源的路径、宽高、格式等信息，注册到一个全局管理静态图片资源中心。这个独立模块的代码如下：</p><pre><code class="language-plain">  module.exports = _$$_REQUIRE(_dependencyMap[0]).registerAsset({\n    "__packager_asset": true,\n    "httpServerLocation": "/assets/src/Lesson3Image",\n    "width": 190,\n    "height": 190,\n    "scales": [1],\n    "hash": "0d4ac32eb69529cf90a7b248fee00592",\n    "name": "dianxin",\n    "type": "jpg"\n  });\n</code></pre><p>它主要包括该图片的注册函数 registerAsset 和其注册信息。其中图片的注册信息包括，目录信息（/assets/src/Lesson3Image）、宽高信息 （width 和 height）、图片哈希值（hash）、图片名字（dianxin）、图片格式（jpg）等等。</p><p>很明显，这个静态图片资源的注册函数和相关的图片信息代码，并不是你写的。那这段代码是怎么来的呢？它是由打包工具根据字面常量<code>\'./dianxin.jpg\'</code>，找到真正的点心静态图片资源后，读取图片信息自动生成的。</p><p>这里敲一下黑板，在使用 require 函数引入静态图片资源时，图片的相对路径必须用字面常量表示的原因是，<strong>字面常量</strong><code>\'./dianxin.jpg\'</code><strong>提供的是一个直接的明确的图片相对路径</strong>，打包工具很容易根据字面常量<code>\'./dianxin.jpg\'</code> 找到真正的图片，提取图片信息。而变量<code>path</code> 提供的是一个间接的可变化的图片路径，你光看<code>require(path)</code> 这段代码是不知道真正的图片放在哪的，打包工具也一样，更别提自动提取图片信息了。</p><p>这里还需要注意一下，我们第一步“编译时”生成的图片注册函数和其注册的信息，我们在后面的第三步“运行时”还会用到。</p><p><strong>第二步构建</strong>：编译后的 Bundle 和静态图片资源，会在构建时内置到 App 中。</p><p>如果你搭建的是 iOS 原生环境，那么你应该运行 <code>react-native run-ios</code> 构建 iOS 应用。如果你搭建的是 Android 原生环境，那么你应该运行  <code>react-native run-android</code> 构建 Android 应用。</p><p>不过，默认构建的是调试包，而我们想要的是正式包，因此我们还需要在命令后面加一行配置<code>--configuration Release</code>。这样就能在你的真机或者模拟器上，构建出一个 React Native 应用了，具体命令如下：</p><pre><code class="language-plain">$ npx react-native run-ios --configuration Release\n</code></pre><p>在这一步，编译后的 Bundle，包括 Bundle 中的静态图片资源信息，和真正的静态图片资源都已经内置到 App 中了。现在你可以关闭网络，然后打开 App试试，如果这时页面和图片依旧能正常展示，那就证明图片确实内置成功了。</p><p>实际上，上面的命令 <code>react-native run-ios</code> 既包括第一步的编译 <code>react-native bundle</code>又包括第二步的构建。在真正编译和构建内置时候，你只需要运行 <code>react-native run-ios</code>  即可。</p><p><strong>第三步运行</strong>：在运行时，require 引入的并不是静态图片资源本身，而是静态图片资源的信息。Image 元素要在获取到图片路径等信息后，才会按配置的规则加载和展示图片。</p><p>还记得吗？我们第一步“编译时”，生成了图片注册函数和其注册的信息，在第二步“构建时”，我们将真正图片内到了 App 中。那在第三步“运行时”，我们怎么拿到这些图片信息，并加载和展示真正的内置图片呢？</p><p>首先，你可以通过 Image.resolveAssetSource 方法来获取图片信息。具体的示例代码如下：</p><pre><code class="language-plain">const dianxinIcon = require(\'./dianxin.jpg\')\n\nalert(JSON.stringify(Image.resolveAssetSource(dianxinIcon)))\n\n// 弹出的信息如下：\n{\n    "__packager_asset": true,\n    "httpServerLocation": "/assets/src/Lesson3Image",\n    "width": 190,\n    "height": 190,\n    "scales": [1],\n    "hash": "0d4ac32eb69529cf90a7b248fee00592",\n    "name": "dianxin",\n    "type": "jpg"\n}\n</code></pre><p>这段代码很简单，关键代码只有两行，第一行是通过 require 引入点心图片，并将其赋值给变量 dianxinIcon。第二行是通过调用 Image.resolveAssetSource 方法，并传入点心图片变量 dianxinIcon，获取我们在编译时生成的图片信息。你可以通过 alert 字符串的方式，将它打印在屏幕上，现在你就可以在运行时，看到编译时自动生成的静态图片资源的信息了。</p><p>在 Image 组件底层，使用的就是 Image.resolveAssetSource 来获取图片信息的，包括图片目录（httpServerLocation）、宽高信息 （width 和 height）、图片哈希值（hash）、图片名字（dianxin）、图片格式（jpg），等等。然后，再根据这些图片信息，找到“构建时”内置在 App 中的静态图片资源，并将图片加载和显示的。这就是静态图片资源的加载原理。</p><p>正是因为静态图片资源加载方式，它在“编译时”提前获取了图片宽高等信息，在“构建时”内置了静态图片资源，因此在“运行时”，程序可以提前获取图片宽高和真正的图片资源。相对于我们后面要介绍的网络图片等加载方式，使用静态图片资源加载，即使不设置图片宽高，也有一个默认宽高来进行展示，而且加载速度更快。</p><h2>网络图片</h2><p>静态图片资源虽好，但它只适用于“静态不变的”图片资源，对于那些“动态变化的”和不方便内置的业务场景，那就要用到网络图片了。</p><p>网络图片（Network Images）指的是<strong>使用 http/https 网络请求</strong>加载远程图片的方式。</p><p>在使用网络图片时，我建议你<strong>将宽高属性作为一个必填项</strong>来处理。为什么呢？和前面介绍的静态图片资源不同的是，网络图片下载下来之前，React Native 是没法知道图片的宽高的，所以它只能用默认的 0 作为宽高。这个时候，如果你没有填写宽高属性，初始化默认宽高是 0，网络图片就展示不了。</p><p>具体的代码是这样：</p><pre><code class="language-plain">// 建议\n&lt;Image source={{uri: \'https://reactjs.org/logo-og.png\'}}\n       style={{width: 400, height: 400}} /&gt;\n\n// 不建议\n&lt;Image source={{uri: \'https://reactjs.org/logo-og.png\'}} /&gt;\n</code></pre><h3>缓存与预加载</h3><p>不过，网络图片虽然指的是走网络请求下载的图片，但也并不用每次都走网络下载，只要有缓存就能直接从本地加载。所以这里我们也简单介绍一下 React Native 的缓存和预加载机制。</p><p>React Native Android 用的是 Fresco 第三方图片加载组件的缓存机制，iOS 用的是 NSURLCache 系统提供的缓存机制。</p><p>Android 和 iOS 的缓存设置方式和实现原理虽然有所不同，但整体上采用了内存和磁盘的综合缓存机制。第一次访问时，网络图片是先加载到内存中，然后再落盘存在磁盘中的。后续如果我们需要再次访问，图片就会从缓存中直接加载，除非超出了最大缓存的大小限制。</p><p>例如，iOS 的 NSURLCache 遵循的是 HTTP 的 Cache-Control 缓存策略，同时当 CDN 图片默认都已经设置了 Cache-Control 时，iOS 图片就是有缓存的。</p><p>而 NSURLCache 的默认最大内存缓存为 512kb，最大磁盘缓存为 10MB，如果缓存图片的体积超出了最大缓存的大小限制，那么一些老的缓存图片就会被删除。</p><p>图片缓存机制有什么用呢？</p><p><strong>通过图片缓存机制和预加载机制的配合，我们可以合理地利用缓存来提高图片加载速度，这能进一步地提升用户体验。</strong></p><p>使用图片预加载机制，可以提前把网络图片缓存到本地。对于用户来说，提前缓存的图片是第一次看到的，但对于系统缓存来说图片是第二次加载，它的加载速度是毫秒级的甚至亚秒级的。这就是预加载机制，提升图片加载性能的原理。</p><p>举个例子，你打算买个机械键盘，打开了个购物 App，滑动手机翻页选购，键盘图片和介绍都能马上地呈现出来。你没有感受丝毫的等待和卡顿，你可能就会直接下单买了。相反，如果你选购的过程中图片加载很慢，翻页还要等待很久，你就可能会考虑换个购物 App。</p><p>在这种无限滚动的长列表场景中，图片预加载就非常适合了。React Native 也提供了非常方便的图片预加载接口 Image.prefetch：</p><pre><code class="language-plain">Image.prefetch(url);\n</code></pre><p>也就是说，函数 Image.prefetch 接收一个参数 url，也就是图片的远程地址，函数调用后，React Native 会帮你在后台进行下载和缓存图片。这样，你下拉加载的图片时，网络图片是从本地缓存中加载的，就感受不到网络加载的耗时过程了。</p><h2>宿主应用图片</h2><p>宿主应用图片（Images From Hybrid App’s Resources​）指的是 React Native 使用 <strong>Android/iOS 宿主应用的图片</strong>进行加载的方式。在 React Native 和 Android/iOS 混合应用中，也就是一部分是原生代码开发，一部分是 React Native 代码开发的情况下，你可能会用到这种加载方式。</p><p>使用 Android drawable 或 iOS asset 文件目录中的图片资源时，我们可以直接通过统一资源名称 URN（Uniform Resource Name）进行加载。不过，使用 Android asset 文件目录中图片资源时，我们需要在指定它的统一资源定位符 URL（Uniform Resource Locator）。</p><p>这里插个小知识，在 React Native 中，我们为什么要用 URI ，比如 <code>{ uri: \'app_icon\' }</code>  ，来代表图片，而不是用更常用的 URL，比如 <code>{ url: \'app_icon\' }</code> ， 代表图片呢？</p><p>这是因为，URI 代表的含义更广泛，它既包括 URN 这种用名称代表图片的方式，也包括用 URL 这种地址代表图片的方式。以 iOS 和 Android 宿主图片为例，代码如下：</p><pre><code class="language-plain">// Android drawable 文件目录\n// iOS asset 文件目录\n&lt;Image source={{ uri: \'app_icon\' }} /&gt;\n\n// Android asset 文件目录\n&lt;Image source={{ uri: \'asset:/app_icon.png\' }} /&gt;\n</code></pre><p>你可以看到，iOS 宿主图片用的是图片名称 app_icon，是 URN。而 Android 宿主图片用的是图片位置 asset:/app_icon.png，是 URL。而 URI 的所代表的含义更广，既包括图片名称 URN，又包括图片位置 URL ，所以 Image 组件的 source 属性中，代表图片名称或地址的键名是 URI。</p><p>在我们国内，绝大多数的 React Native 应用都是混合应用，都是把 React Native 当做一个支持动态更新的跨端框架来使用的。那这种情况下，我们在 React Native 中直接用宿主应用图片资源不是更好吗？</p><p>你看，React Native 静态图片资源也是内置，Android/iOS 自身图片也要内置，搞一套图片管理机制不更简单一些嘛？而且部分图片还可以跨 React Native 和 Android/iOS 两个技术栈复用，减少一些 App 体积，这听起来很不错啊。</p><p><strong>但在实际工作中，我不推荐你在 React Native 中使用宿主应用图片资源。</strong>首先，这种加载图片的方法没有任何的安全检查，一不小心就容易引起线上报错。第二，大多数 React Native 是动态更新的，最新代码是跨多个版本运行的，而 Native 应用是发版更新的，应用的最新代码只在最新版本运行，这就导致 React Native 需要确切知道 Native 图片到底内置在哪些版本中，才能安全地使用，这对图片管理要求太高了，实现起来太麻烦了。</p><p>最后，开发 React Native 的团队，和开发 Android/iOS 的团队很可能不是一个团队，甚至可能跨部门。复用的收益抵不上复用带来的安全风险、维护成本和沟通成本，因此我并不推荐你使用。</p><h2>Base64 图片</h2><p>最后一类常见的 React Native 图片加载方式是 Base64 图片。</p><p>Base64 指的是一种基于 64 个可见字符表示二进制数据的方式，Base64 图片指的是<strong>使用 Base64 编码</strong>加载图片的方法，它适用于那些图片体积小的场景。</p><p>Base64 图片的示例代码，如下：</p><pre><code class="language-plain">&lt;Image\n  source={{\n    uri: \'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADMAAAAzCAYAAAA6oTAqAAAAEXRFWHRTb2Z0d2FyZQBwbmdjcnVzaEB1SfMAAABQSURBVGje7dSxCQBACARB+2/ab8BEeQNhFi6WSYzYLYudDQYGBgYGBgYGBgYGBgYGBgZmcvDqYGBgmhivGQYGBgYGBgYGBgYGBgYGBgbmQw+P/eMrC5UTVAAAAABJRU5ErkJggg==\'\n  }}\n/&gt;\n</code></pre><p>你可以看到 Base64 图片并不是图片地址，而是以一大长串的以 data:image/png; base64 开头的文本。</p><p>通常我们看的图片资源 .jpg、.png 都是二进制格式的，二进制格式的图片是以独立文件存在的。而当二进制图片 Base64 化后，就变成了一段由字母、数字和符号组成的字符串。</p><p>通常我们看的图片资源 .jpg、.png 都是二进制格式的，二进制格式的图片是以独立文件存在的。而 Base64 图片并不是单独图片文件，而是以文本形式存在 .js 文件中的。</p><p>字符串是可以嵌套到 .js 文件中的，因此 Base64 图片也可以嵌入到 .js 文件中。在线上，Base64 图片是嵌套在 Bundle 文件中的，在加载 React Native 页面的同时，Base64 字符串也能很快地解析成真正的图片，并展示出来。</p><p><strong>由于 Base64 图片是嵌套在 Bundle 文件中的，所以 Base64 图片的优点是无需额外的网络请求展示快，缺点是它会增大 Bundle 的体积。</strong> 在动态更新的 React Native 应用中，Base64 图片展示快是以 React Native 页面整体加载慢为代价的。原因就是它会增加 Bundle 的体积，增加 Bundle 的下载耗时，从而导致 React Native 页面展示变慢。</p><p>即便是相同的图片，Base64 字符串的体积也要比二进制字节码的体积要大 1/3，这又进一步增加 Bundle 的大小。那为什么 Base64 转换后的体积，会比二进制的字节码的体积还要大 1/3呢？这就要看下 Base64 图片的转换原理了。</p><p>我这里放了一张二进制图片转 Base64 图片的原理示意图，我们根据这张原理示意图来解释图片 Base64 后体积增加的原因。</p><p><img src="https://static001.geekbang.org/resource/image/40/5d/40301519cfd873a7779953c7e1e2d65d.jpg?wh=2008x488" alt=""></p><p>首先，我们要树立两个基本认知。一是二进制图片不能直接以字符串形式存在 .js 文件中，因为直接用 ASCII （美国信息交换标准代码）表示的二进制字符串太大了。一个二进制 “00000000”，占 8 比特大小，也就是 1 个字节的大小。一个直接用 ASCII 表示的字符串 “00000000”，占 8*8 比特大小，也就是 8 个字节的大小，是二进制大小的 8 倍。</p><p>二是，二进制图片不能直接以 ASCII 的格式转换为字符串，这是因为ASCII 字符集不仅存在可见字符，还存在不可见字符。例如，二进制 “00000000” 对应的 ASCII 字符是“空字符（Null）”，空字符是不可见字符。</p><p>但是，二进制图片可以借助 Base64 进行转换。Base64 从 ASCII 256 个字符中选取了 64 个可见字符作为基础，这样就二进制就能以 Base64 的格式转换为 ASCII 字符串了。例如，二进制 00000000 对应的 Base64 字符是 A，是可见字符，可见字符 A 是可以存在在 .js 文件中的。</p><p>需要注意的是，ASCII 256 个字符需要 8 个比特来表示（2^8=256），Base64 的 64 个字符只需要 6 个比特位来表示（2^6=64）。但实际上，Base64 字符也是以 ASCII 码的形式存在，因此这里就有 2 个比特的浪费（8-6=2）。</p><p>你可以再仔细观察一下前面我提供的 Base64 转换的原理示意图，相信你一下就能明白其中原理。Base64 以 3 个字节作为一组，一共是 24 比特。将这 24 个比特分成 4 个单元，每个单元 6 个比特。每个单元前面加 2 个 0 作为补位，一共 8 个比特，凑整 1 个字符。转换后原来的 24 比特，就变成了 32 比特，因此转换后的体积就大了 1/3（ 1/3 = 1 - 24/32）。</p><p>鉴于这样的情况，我的建议是 <strong>Base64 图片只适合用在体积小的图片或关键的图片上。</strong></p><h2>最佳实践</h2><p>看到这里，想必现在你已经对 4 类图片的使用场景，有一定的了解了。但是在具体实践中，我们应该怎么用呢？</p><p>现在我给你分享一下我的最佳实践，这套方案我也是在实践中，摸索了很久才得出的。这套最佳实践，适用于那些<strong>将 React Native 当做一个动态更新框架来使用的应用</strong>中。</p><p>首先是静态图片资源。如果你使用的是自研的热更新平台，就需要注意图片资源一定要先于 bundle 或和 bundle 一起下发，因为在执行 bundle 时，图片资源是必须已经存在的。</p><p>接着是网络图片和 Base64 图片。这两类图片之所以放在一起说，是因为它们单独管理起来都不方便，一张张手动上传网络图片不方便，一张张手动把图片  Base64 化也不方便，所以我们需要一个自动化的工具来管理它们。</p><p>比如，你可以把需要上传到网络的图片放在代码仓库的 assets/network 目录，把需要 Base64 化的图片放在 assets/base64 目录。</p><p>你在本地开发的时候，可以通过使用 require 静态图片资源的形式，引入 assets/network 或 assets/base64 目录中的图片来进行本地调试。在代码编译打包的时候，通过工具将 assets/network 目录中的图片上传到 CDN 上，将 assets/base64 目录中的图片都 Base64 化，并将 require 形式的静态图片资源代码转换为网络图片或 Base64 图片的代码。使用自动化工具来管理图片，代替人工手动管理，可以提高你的开发效率。</p><p>最后是宿主应用图片，这种加载图片的方式我不建议你使用，具体的原因我们前面已经分析过了。</p><p>我把这节课讲的这四种图片的使用总结成了这张图，你可以看看，加深一下印象：</p><p><img src="https://static001.geekbang.org/resource/image/1e/2f/1ea50c116cf01334b75bc9a4cfd9162f.png?wh=1188x492" alt="图片"></p><h2>总结</h2><p>今天的课程到这里就结束了，这里我再给你总结一下。</p><p>今天我们学习 React Native 中的图片组件 Image，了解了 4 种图片加载的方式和其最佳实践。</p><p>首先，发版更新的 React Native 应用，使用内置图片的最佳方式是静态图片资源，但对于动态更新的 React Native 应用而言，需要注意静态图片资源并不是真正的“内置”，而是必须和 Bundle 执行文件“同步”的加载。</p><p>然后，我推荐你自研一个图片管理工具，把设计师给你的图片管理起来，并按照指定的配置规则转换为 Base64 图片或网络图片，这样可以提高你的开发效率。</p><p>不过，React Native 复用宿主应用图片的这种方式，不推荐你使用。它有加载失败的风险，而且有较高的维护成本和沟通成本。</p><h2>补充材料</h2><ol>\n<li>各类图片使用区别的 <a href="https://reactnative.cn/docs/0.63/images">React Native 中文网连接在这儿</a>，你可以点击查看一下。</li>\n<li>React Native 框架对图片的默认缓存处理并不是最优的方案，社区中提供了替代方案 <a href="https://github.com/DylanVann/react-native-fast-image">FastImage</a>，它是基于 SDWebImage (iOS) 和 Glide (Android) 实现的性能和效果会更好一些。</li>\n<li>这节课的示例代码，我放在了<a href="https://github.com/jiangleo/react-native-classroom/tree/main/src/05_Image"> GitHub </a>上，你可以参考一下。</li>\n</ol><h2>作业</h2><ol>\n<li>请你分别实现一下静态图片资源、网络图片和Base64 图片这三类图片。体会一下，是否有资源管理上改进空间？</li>\n<li>如果要你来实现图片管理工具，你会怎么实现？</li>\n</ol><p>欢迎在留言区分享你的想法。我是蒋宏伟，咱们下节课见。</p>',
        article_title: "05｜Image：选择适合你的图片加载方式",
      },
      {
        title: "06｜Pressable：如何实现一个体验好的点按组件？",
        id: 504527,
        content:
          '<p>你好，我是蒋宏伟。</p><p>点按组件的设计与我们的用户体验息息相关。有人会因为机械键盘的敲击感好，不买百来块的薄膜键盘，而花上贵十倍的价格去买 HHKB、Filco，也有人会因为某个应用的点按体验不好，而转投竞品应用。</p><p>如果你仔细观察过世界上那些流行的、口碑很好 App，比如微信，你会看到它们在点按组件的体验的细节上都做得特别好。</p><p>比如，微信的点按组件都是有交互反馈的，无论是背景颜色的加深，还是那些舒服的震动，又或者是动画。又比如，微信顶部右上角的加号按钮是很容易点击的，它的点击区域是比显示图标大上那么一丢丢，而且点到后，即使把手指挪开图标的位置再松开也是能触发点击的。</p><p>所有的这些设计都是“懂”用户的。担心你因为网络卡、机器卡不知道有没有自己点中，在你点完后给你视觉或触觉上的反馈；担心你走路的时候想点点不到，把事件的“可触发区域”、“可保留区域 ”设置得比视觉上的“可见区域”大上那么一些。</p><p>作为直接和用户打交道的工程师，<strong>我们也得“懂”用户，</strong>也得去优化我们负责的 App、页面的体验，<strong>还得在技术上搞懂点按组件使用方法和背后的原理，把这种最常用的人机交互体验给做到及格，做到优秀。</strong></p><p>所以，今天这节课，我会以三个问题为脉络进行讲解：</p><!-- [[[read_end]]] --><ul>\n<li>点按组件是要简单易用还是要功能丰富，如何取舍？</li>\n<li>点按组件是如何知道它是被点击了，还是被长按了？</li>\n<li>点按组件为什么还要支持用户中途取消点击？</li>\n</ul><p>通过这三个问题，你不仅能明白如何在 React Native 中实现一个体验好的点按组件，同时也能借助它背后的设计原理，更“懂”用户，提升产品的用户体验。</p><h2>要简单易用还是功能丰富？</h2><p>首先，点按组件是设计给你我这样的开发者来使用的，它功能越简单开发者用起来就越简单，它功能越复杂就能满足更多的需求场景。那是让开发者简单易用好，还是用丰富的功能去满足用户，有没有两全其美之计？</p><p>实际上，React Native 的点按组件经历了三个版本的迭代，才找到了两全其美的答案。等你了解了这个三个版本的迭代思路后，你就能很好明白优秀通用组件应该如何设计，才能同时在用户体验 UX 和开发者体验 DX 上找到平衡。</p><p>我先给你从第一代点按组件开始讲起。</p><h3>第一代 Touchable 组件</h3><p>第一代点按组件想要解决的核心问题是，<strong>提过多种反馈风格</strong>。</p><p>一个体验好的点按组件，需要在用户点按后进行实时地反馈，通过视觉变化等形式，告诉用户点到了什么，现在的点击状态又是什么。</p><p>但不同的原生平台，有不同的风格，反馈样式也不同。Android 按钮点击后会有涟漪，iOS 按钮点击后会降低透明度或者加深背景色。React Native 是跨平台的，那它应该如何支持多种平台的多种反馈风格呢？</p><p>第一代 Touchable 点按组件的设计思路是，提供多种原生平台的反馈风格给开发者自己选择。框架提供了 1 个基类和 4 个扩展类，它们分别是：</p><ul>\n<li>TouchableWithoutFeedback：用于响应用户的点按操作，但不给出任何点按反馈效果。反馈效果由 4 个扩展类实现；</li>\n<li>TouchableNativeFeedback：给出当前原生平台的点按反馈效果，在 Android 中是涟漪（ripple）效果，就是从点击处散开水波纹的效果；</li>\n<li>TouchableOpacity：短暂地改变组件的透明度；</li>\n<li>TouchableHighlight：短暂地加深组件的背景色；</li>\n<li>TouchableBounce：有 bounce 回弹动画的响应效果。</li>\n</ul><p>Touchable 点按组件提供了 5 个类，选择起来也很麻烦。有经验的开发者可能知道如何进行选择，但新手却要花上很长时间，去了解不同组件之间的区别。所以说，Touchable 点按组件在提供多样性的功能支持的同时，也带来了额外的学习成本。</p><p>为了降低学习成本，React Native 团队又开发了第二代点按组件，Button。</p><h3>第二代 Button 组件</h3><p>第二代 Button 组件的实质是<strong>对 Touchable 组件的封装。</strong>在 Android 上是 TouchableNativeFeedback 组件，在 iOS 上是 TouchableOpacity 组件。</p><p>Button 组件的设计思想就是，别让开发者纠结选啥组件了，框架已经选好了，点按反馈的样式就和原生平台的自身风格保持统一就好了。</p><p>但我的经验告诉我，要让大多数开发者都选择同一个默认的 UI 样式真是太难了，萝卜白菜各有所爱。另外，用户的审美也在慢慢地变化，涟漪风格也好，降低透明风格也好，背景高亮风格也好，或许几年后就不会再流行了。甚至连 Button 这个概念本身，都在慢慢地变化，现在的 App 中几乎只要是个图片或者文字都能点按，不再局限于只有四四方方的色块才能点按了。</p><p>Button 组件虽然降低了开发者选择成本，但是想在 UI 风格上让大家选择都原生平台自身的风格，这太难了。因此，React Native 团队又开发了第三代点按组件 Pressable。</p><h3>第三代 Pressable 组件</h3><p>第三代 Pressable 点按组件，不再是 Touchable 组件的封装，而是<strong>一个全新重构的点按组件，</strong>它的反馈效果可由开发者自行配置。</p><p>但是，点按组件通常是有点击和未点击两种状态的，这两种状态对应着两种点按样式，一种样式是未点击时的基础样式，一种是点按后的反馈样式。这两种样式怎么写？又该怎么切换？</p><p>Pressable 组件的 API 设计得很是巧妙，扩展起来非常方便。Pressable 的样式 style 属性同时支持固定样式，和函数返回的“动态样式”：</p><pre><code class="language-typescript">type PressableStyle = ViewStyle | (({ pressed: boolean }) =&gt; ViewStyle)\n</code></pre><p>其一，固定样式，也就是<code>type PressableStyle = ViewStyle</code> 的意思是，Pressable 组件的支持样式类型和 View 组件的支持样式类型是一样的，具体 <code>ViewStyle</code> 都包括那些“通用”样式和“私有”样式，我们在<a href="https://time.geekbang.org/column/article/501650">《Style》</a>中已经学过了，相信你能很快回想起来。</p><p>其二，动态样式，也就是<code>type PressableStyle = (({ pressed: boolean }) =&gt; ViewStyle)</code> 的意思是，在用户没有点击时 pressed 值为 false，在用户点击时 pressed 值为 true，你可以根据两种点按状态，为按钮定制不同的样式。</p><p>具体怎么实现呢？我们先来看固定样式。固定样式，顾名思义，就是按钮组件的样式是“固定”的，比如你可以看下这段代码：</p><pre><code class="language-plain">// 固定的基础样式\nconst baseStyle = { width: 50, height: 50, backgroundColor: \'red\'}\n\n&lt;Pressable\n  onPress={handlePress}\n  style={baseStyle} &gt;\n  &lt;Text&gt;按钮&lt;/Text&gt;\n&lt;/Pressable&gt;\n</code></pre><p>这段示例代码就是一个最简单的固定样式按钮的代码片段。我们在 Pressable 元素中嵌套了一个文字是“按钮”的 Text 元素，并给 Pressable 元素添加了一个固定的基础样式，宽高各位 50 像素，且背景颜色为红色。</p><p>那如果我们需要实现动态样式，应该怎么实现呢？比如，你想在所有平台都实现降低透明度的点击反馈，那你可以定义一个基础样式 baseStyle，然后通过点按状态 pressed ，管理透明度 opacity 的切换。具体的代码示例如下：</p><pre><code class="language-plain">// 固定的基础样式\nconst baseStyle = { width: 50, height: 50, backgroundColor: \'red\'}\n\n&lt;Pressable\n  onPress={handlePress}\n  style={({ pressed }) =&gt; [ /* 动态样式 */\n    baseStyle,\n    { opacity: pressed ? 0.5 : 1} \n  ]} &gt;\n  &lt;Text&gt;按钮&lt;/Text&gt;\n&lt;/Pressable&gt;\n</code></pre><p>这段示例代码用的就是 Pressable 的动态样式。首次渲染时，React Native 会先调用一次 Pressable 的 style 属性的回调函数，这时点按状态 pressed 是 false，透明度为 1。在你触碰到“按钮”时，就会触发点击事件 onPress，与此同时，React Native 会再调用一次 style 属性的回调函数，此时点按状态 pressed 是 true，透明度为 0.5。在你松开“按钮”后，透明度会重新变为 1。</p><p>你可以看到，使用动态样式来实现降低透明度的点击反馈是非常方便的。除了改变透明度，你还可以选择改变背景色，改变按钮的宽高，甚至还可以把“按钮”的文字改了。你看，动态样式是不是非常灵活？</p><p>除了这两点，你可能还会问，如果我想实现 Android 平台特有的涟漪效果，Pressable 组件也能实现吗？可以，你可以使用android_ripple和android_disableSound 属性进行配置。</p><ul>\n<li>android_ripple：用于配置 Android 特有的涟漪效果 <a href="https://reactnative.dev/docs/next/pressable#rippleconfig">RippleConfig</a> ；</li>\n<li>android_disableSound：禁用 Android 系统的点击音效，默认 false 不禁用。</li>\n</ul><p>其实，目前这三代点按组件是同时存在于 React Native 的官方组件库中的，那开发时我们该怎么选呢？我认为：</p><ul>\n<li>第一代点按组件 Touchable，功能丰富但学习成本太高；</li>\n<li>第二代点按组件 Button，简单易用但带了默认样式和反馈效果，通用性太差；</li>\n<li>第三代点按组件 Pressable，同时满足了简单易用和复杂效果可扩展的特性。</li>\n</ul><p>因此，在实现自定义的业务按钮组件时，我更加推荐你使用第三代点按组件 Pressable。而且，Pressable 组件的动态 style 的设计思路，也是非常值得我们学习的。</p><h2>如何知道是点击，还是长按？</h2><p>我们再来看第二个问题：点按组件 Pressable 是如何知道它是被点击了，还是被长按了？</p><p>整个点按事件的响应过程是硬件和软件相互配合的过程。 Pressable 组件响应的整体流程，是从触摸屏识别物理手势开始，到系统和框架 Native 部分把物理手势转换为 JavaScript 手势事件，再到框架 JavaScript 部分确定响应手势的组件，最后到 Pressable 组件确定是点击还是长按。</p><p>你看，一个 App 要识别是点击还是长按，并没有那么容易吧？庆幸的是，这些复杂的识别工作都由手机硬件、操作系统、React Native 框架帮我们实现了。作为开发者，大部分时候我们只需要知道怎么使用和了解基本原理就可以了。今天我们把焦点放在最后一步，Pressable 组件是怎么确定用户是点击还是长按的。</p><p>我们知道，开始响应事件和结束响应事件是两个最基础的手势事件，在 Android、iOS 或者 Web 中都有类似的事件。在 React Native 中它们是：</p><ul>\n<li>onResponderGrant：开始响应事件，用户手指接触屏幕，且该手势被当前组件锁定后触发；</li>\n<li>onResponderRelease：结束响应事件，用户手指离开屏幕时触发。</li>\n</ul><p>基于开始响应事件 onResponderGrant 和结束响应事件 onResponderRelease，Pressable 组件可以很容易地封装出开始点按事件 onPressIn 和结束点按事件 onPressOut。</p><p>你可以在 Pressable 组件中，使用 onPressIn 来响应开始点按事件，使用 onPressOut 来响应结束点按事件。示例代码如下：</p><pre><code class="language-plain">&lt;Pressable \n  onPressIn={handlePressIn}\n  onPressOut={handlePressOut}\n  &gt;\n  &lt;Text&gt;按钮&lt;/Text&gt;\n&lt;/Pressable&gt;\n</code></pre><p>当你触碰到“按钮”开始点按时，React Native 框架就会帮你调用 handlePressIn 处理函数，当你手指离开“按钮”结束点按时，就会调用 handlePressOut 处理函数。</p><p>基于开始点按事件 onPressIn 和结束点按事件 onPressOut，我们自己是否可以封装出“自定义”的点击事件 onPress 和长按事件 onLongPress呢？你可以短暂的按一下暂停键，思考一下如果要要你来实现你会怎么做，然后再去看 React Native 框架提供的答案。</p><p>这个方案也很简单，你只需要判断 onPressIn 事件和 onPressOut 事件之间触发间隔耗时就可以了：</p><ul>\n<li>如果间隔耗时 &lt; 500ms 属于点击。用户的点按动作会先触发 onPressIn，再触发 onPressOut，在 onPressOut 事件中可以触发我们 “自定义的”点击事件 onPress；</li>\n<li>如果间隔耗时 &gt;= 500ms 属于长按。用户的点按动作会先触发 onPressIn，这个时候你可以埋下一个定时器，并在第 500ms 时通过定时器触发我们 “自定义的” onLongPress，最后在用户松手的时候触发 onPressOut。</li>\n</ul><p>实际上，React Native 框架就是这么设计的。</p><p>在你同时监听了 onPress 和 onLongPress 两个事件时，如果点按耗时小于 500ms，在你松手时触发的是点击事件 onPress；如果点按耗时大于 500ms，大致会在第 500ms 先触发长按事件 onLongPress，那这时即使你再松手也不会触发 onPress 事件了。也就是说，<strong>点击事件 onPress 和长按事件 onLongPress 是互斥的，触发了一个就不会再触发另一个了</strong>。</p><p>关于 Pressable 组件的 4 个响应事件，onPressIn、onPressOut 、onPress 和 onLongPress的触发方式，我放了一张官方提供的示意图，相信你看后会有更深的理解：</p><p><img src="https://static001.geekbang.org/resource/image/5b/69/5b058a1a8ac8f14ff3b8f6b726a28669.png?wh=1920x1272" alt="图片"></p><h2>为什么支持中途取消？</h2><p>现在，你对 Pressable 组件的点按事件的工作原理已经有所了解了。讲到这里，我们开头提出的三个问题，只剩最后一个：点按组件为什么还要支持用户中途取消点击？</p><p>要讲清楚这个问题，我们需要深入到事件区域模型，也就是点按操作手势的可用范围的概念下进行讲解。</p><p>点按操作手势的可用范围包括盒模型区域、可触发区域 HitRect 和可保留区域 PressRect ，接下来我们一个个讲解。</p><h3>盒模型区域</h3><p>还记得吗？在我们介绍<a href="https://time.geekbang.org/column/article/501650">《Style》</a>的布局属性时，我们有提到过宽度 width、高度 height，这两个属性就决定了盒模型（Box Modal）中的内容 content 大小。除此之外，盒模型中还有内边距 padding、边框 border、外边距 margin。</p><p>这些内容、边框、边距之间关系是什么呢？其实，React Native 中的盒模型概念来自于 Web 领域的 W3C 规范，我把规范中的盒模型示意图放在了下面：</p><p><img src="https://static001.geekbang.org/resource/image/c2/7e/c2a39b421c9f21bfd34ff0def3494f7e.jpg?wh=455x340" alt=""></p><p>你可以看到，最里面的是内容 Content，然后再是 Padding 和 Border，最外面的才是 Margin。请你注意了，Content、Padding、Border 默认是不透明度的，但 Margin 是天生透明的，并且不可以设置透明度、设置颜色。</p><p>你猜，点按事件的默认触发区域是盒模型中的哪几部分？答案就是，盒模型中的默认不透明的部分。这些用户看得见的部分，包括 content、padding 和 border 部分。可以看得见才可以点击，这样的设计是非常合理的。</p><p>我给你贴出了点按事件的默认触发区域的测试代码，你也可以自己点一点、试一试，体会一下：</p><pre><code class="language-plain">&lt;Pressable style={{\n    margin: 10,\n    borderWidth: 10,\n    borderColor: \'red\',\n    padding: 10,\n    width: 100,\n    height: 100,\n    backgroundColor: \'orange\',\n  }}&gt;\n  &lt;Text&gt;点我&lt;/Text&gt;\n&lt;/Pressable&gt;\n</code></pre><p>在上面的示例代码中，我们特意给了 100 像素的宽高，这是很容易点中的，但在日常我们使用 App 时，并不会有这么大按钮。你也许遇到过类似的情景，单手把持手机的时候左上角的返回键老点不中，勾选用户同意事项的时候老勾不中，等等。人的手指并不是什么精密仪器，不能保证任何情况下都能正确地点按到指定区域。那这种情况该怎么处理呢？</p><p>我们可以直接修改宽高、边框、内边距的值，通过扩大盒模型的范围，提高点中的成功率。但是，修改盒模型成本较高，它可能会导致原有 UI 布局发生变化。</p><p><strong>更好的方案是，不修改影响布局的盒模型，直接修改可触发区域的范围，提高点中的成功率。</strong></p><h3>可触发区域 HitRect</h3><p>Pressable 组件有一个可触发区域 HitRect，默认情况下，可触发区域 HitRect 就是盒模型中的不透明的可见区域。你可以通过修改 hitSlop 的值，直接扩大可触发区域。</p><p>HitSlop 类型的定义如下：</p><pre><code class="language-typescript">type Rect = {\n    top?: number;\n    bottom?: number;\n    left?: number;\n    right?: number;\n}\n\ntype HitSlop = Rect | number\n</code></pre><p>HitSlop 接收两种类型的参数，一种是 number 类型，以原有盒模型中的 border 为边界，将可触发区域向外扩大一段距离。另一种是 Rect 类型，你可以更加精准地定义，要扩大的上下左右的距离。</p><p>在老点不中、老勾不中的场景中，你可以在不改变布局的前提下，设置 Pressable 组件的可触发区域 HitSlop，让可点击区域多个 10 像素、20 像素，让用户的更容易点中。</p><h3>可保留区域 PressRect</h3><p>前面我讲到，用户的手势可能会有一定误差。不仅如此，用户的行为本身就很复杂，用户的意愿也可能会在很短的时间内发生改变的。其实，这里也是在回答开头我们提出的最后一个问题，用户行为的复杂性，就导致了我们在设计点按组件需要有更多的思考。</p><p>比如，用户已经点到购买按钮了，突然犹豫，又不想买了，于是将手指从按钮区域移开了。这时你得让用户能够反悔，能够取消即将触发的点击操作。</p><p>这里我们就要引入一个新的概念：可保留区域 PressRect。点按事件可保留区域的偏移量（Press Retention Offset）默认是 0，也就是说默认情况下可见区域就是可保留区域。你可以通过设置 pressRetentionOffset 属性，来扩大可保留区域 PressRect。pressRetentionOffset 属性的类型如下：</p><pre><code class="language-typescript">type PressRetentionOffset  = Rect | number\n</code></pre><p>你可以看到，pressRetentionOffset 和 HitSlop 一样，接收两种类型的参数，一种是 number 类型，另一种是 Rect 类型。Rect类型设置后，会以原有可触发区域为基准，将可保留区域向外扩大一段距离。</p><p>在你后悔点下购买按钮的情况下，你可以把已经按下的手指从可保留区域挪开，然后再松手，这就不会再继续触发点击事件了。</p><p>当然，还有更复杂的情况，你已经点到购买按钮了，突然犹豫，开始进行心理博弈，想点又不想点。手指从按钮上挪开了，又挪了进去，然后又挪开了，如此反复。这时还要不要触发点击事件呢？要不要触发，其实是根据你手指松开的位置来判断的，如果你松手的位置在可保留区域内那就要触发，如果不是那就不触发。</p><p>我将盒模型区域的可见区域、可触发区域 HitRect 和可保留区域 PressRect 的关系画了一张图，你也可以打开文稿看看，加深一下理解：</p><p><img src="https://static001.geekbang.org/resource/image/a9/27/a916a2b7ba515895ce76097b04c73727.png?wh=1920x1102" alt="图片"></p><h2>课程小结</h2><p>以上就是我们这一讲的全部内容，现在我来给你总结一下今天这一讲的要点。如何实现一个体验好的点按组件呢？我建议你记住下面这三点：</p><p>首先，一个好的点按组件应该让先让开发者用来很方便。React Native 的点按组件经历了三次迭代，每次迭代都在开发者体验（DX）上有所进步，我更推荐你使用第三代点按组件 Pressable。</p><p>其次，一个好的点按组件应该要满足各种用户、各种场景的可扩展性。Pressable 组件支持四种基础点按事件，onPressIn、onPressOut、onPress、onLongPress。其中，点击事件 onPress 和长按事件 onLongPress 是互斥的，触发了一个就不会再触发另一个了。</p><p>最后，一个优秀的工程师应该要“懂”用户，要把自己负责的 App、页面的用户体验（UX）提上去。任何的物理按钮都是有点击反馈的，我们的虚拟按钮也得有，这是最基本体验要求。然后，要让用户想点能点得到，要理解盒模型区域、可触发区域 HitRect、可保留区域 PressRect 的区别，并且进行合理设置。</p><h2>补充材料</h2><p><strong>官方文档：</strong></p><ul>\n<li>TouchableHighlight：<a href="https://reactnative.dev/docs/next/touchablehighlight">https://reactnative.dev/docs/next/touchablehighlight</a></li>\n<li>Button：<a href="https://reactnative.dev/docs/next/button">https://reactnative.dev/docs/next/button</a></li>\n<li>Pressable：<a href="https://reactnative.dev/docs/next/pressable">https://reactnative.dev/docs/next/pressable</a></li>\n</ul><p><strong>源码阅读：</strong></p><ul>\n<li>要读懂点按组件 Pressable 的核心设计原理，首先要读懂 Pressable 设计者的设计思想，<a href="https://github.com/facebook/react-native/blob/8bd3edec88148d0ab1f225d2119435681fbbba33/Libraries/Pressability/Pressability.js#L322-L366">它放在了 Pressability.js  文件中。</a></li>\n<li>点按组件 Pressable 的 4 种基础响应事件是基于<a href="https://github.com/facebook/react-native/blob/8bd3edec88148d0ab1f225d2119435681fbbba33/Libraries/Pressability/Pressability.js#L444-L544">手势系统</a>实现的，其中 <a href="https://github.com/facebook/react-native/blob/8bd3edec88148d0ab1f225d2119435681fbbba33/Libraries/Pressability/Pressability.js#L692-L702">onPress 和 onLongPress 是互斥的。</a></li>\n</ul><h2>作业</h2><ol>\n<li>请你模仿实现一下微信顶部右上角的加号按钮。</li>\n<li>在较老版本的手机浏览器中，点击事件存在 350ms 延迟；在微信聊天框中，点击对方的微信头像比点击右上角三个点的更多按钮，打开页面的速度慢一些；双击事件是常见的点按事件之一，Pressable 组件却没有提供；这三个现象涉及到了 Web、Android、iOS 和 React Native 这四个技术领域，但这三个现象其实都指向同一个答案。欢迎你把你的答案分享给大家。</li>\n</ol><p>我是蒋宏伟，咱们下节课见。</p>',
        article_title: "06｜Pressable：如何实现一个体验好的点按组件？",
      },
      {
        title: "07｜TextInput：如何实现一个体验好的输入框？",
        id: 505780,
        content:
          '<p>你好，我是蒋宏伟。</p><p>上一讲，我们介绍了如何去打磨点按组件的体验细节，这一讲我们就开始介绍如何打磨一个文本输入组件 TextInput 的体验细节。</p><p>作为一个优秀工程师，要想优化页面的用户体验，只知道打磨点按组件是远远不够的，而且，相对于点按组件组件来说，要把文本输入组件 TextInput 的细节体验弄好，要更难一些。</p><p>这个难点主要有两方面。首先，TextInput 组件是自带状态的宿主组件。TextInput 输入框中的文字状态、光标状态、焦点状态在 React Native 的 JavaScript 框架层的框架层有一份，在 Native 的还有一份，有时候业务代码中还有一份。那多份状态到底以谁为主呢？这件事我们得搞清楚。</p><p>其次，TextInput 组件和键盘是联动的，在处理好 TextInput 组件的同时，我们还得关心一下键盘。当然键盘本身是有 <code>Keyboard</code> API 的，但是键盘类型是“普通键盘”还是“纯数字键盘”，或者键盘右下角的按钮文字是“确定”还是“搜索”，都是由 TextInput 组件控制的。</p><p>这一讲，我将以如何实现一个体验好的输入框为线索，和你介绍使用 TextInput 组件应该知道的三件事。</p><h2>输入框的文字</h2><p>第一件事，你得知道如何处理输入框的文字。</p><!-- [[[read_end]]] --><p>关于如何处理输入框的文字，网上有两种说法。有些人倾向于使用非受控组件来处理，他们认为“不应该使用 useState 去控制 TextInput 的文字状态”，因为 ref 方案更加简单；有些人倾向于使用受控组件来处理，这些人认为“直接使用 ref 去操作宿主组件这太黑科技了”。这两种说法是相互矛盾的，究竟哪种是正确的呢？</p><p>我们先从最简单的<strong>非受控（Uncontrolled）组件</strong>说起。</p><p>非受控的意思就是不使用 state，直接对从宿主组件上将文本的值同步到 JavaScript。一个非受控的 UncontrolledTextInput 组件示例如下：</p><pre><code class="language-plain">const UncontrolledTextInput = () =&gt; &lt;TextInput /&gt; \n</code></pre><p>只要这一行代码，用户就可以输入文字了。在 UncontrolledTextInput  组件中， TextInput 元素是不受 state 控制，但在 JavaScript 代码中却并不知道用户输入的是什么，因此还要一个变量来存储用户输入的值。</p><p>用什么变量呢？首先在组件中声明局部变量是不行的，我们知道 render 就是组件函数的执行，每次执行局部变量也会重新赋值，局部变量保存的值不能跨越两次 render。其次，用全局变量或文件作用域的变量也是不行的，组件销毁时这些全局变量是不会销毁的，有内存泄露的风险。再者，用 state 也是不行的，用了 state 就成了受控组件了。</p><p>对于非受控组件来说，存储跨域两次 render 的可行方案是 ref。<strong>ref 的值不会因为组件刷新而重新声明，它是专门用来存储组件级别的信息的。</strong><a href="https://beta.reactjs.org/learn/referencing-values-with-refs#when-to-use-refs">React 官方推荐</a>有三种场景我们可以用它：</p><ul>\n<li>存储 setTimeout/setInterval 的 ID；</li>\n<li>存储和操作宿主组件（在 Web 中是 DOM 元素）；</li>\n<li>存储其他不会参与 JSX 计算的对象。</li>\n</ul><p>我们使用 ref 保存非受控输入框的值，就属于第三种场景，示例代码如下：</p><pre><code class="language-plain">function UncontrolledTextInput2() {\n  const textRef = React.useRef(\'\');\n  return &lt;TextInput onChangeText={text =&gt; textRef.current = text}/&gt;\n}\n</code></pre><p>你看，首先我们使用 <code>useRef</code> 创建了一个用于保存用户输入的文字的对象 <code>textRef</code>。每当用户输入文字的时候，会触发 TextInput 的<code>onChangeText</code>事件，在该事件的回调中，我们将最新的<code>text</code>赋值给了<code>textRef.current</code>进行保存。这时，每次获取文字就都是最新的文字了。</p><p>非受控组件的原理是最简单的，用户输入的“文本原件”是存在宿主组件上的，JavaScript 中的只是用<code>textRef</code>复制了一份 “文本的副本”而已。</p><p>但正是因为非受控组件使用的是副本，一些复杂的操作是做不了的，比如将用户输入的字母由大写强制改为小写，等等。在新架构 Fabric 之前，React Native 还提供了直接修改宿主组件属性的<code>setNativeProps</code>方法，但是 Fabric 之后（包括 Fabric 预览版），<code>setNativeProps</code> 就不能用了。</p><p>因此我们要操作文本原件，必须得用<strong>受控（Controlled）组件</strong>。</p><p>受控的意思说的是使用 JavaScript 中的 state 去控制宿主组件中的值。一个受控的 ControlledTextInput 组件示例如下：</p><pre><code class="language-plain">function ControlledTextInput() {\n  const [text, setText] = React.useState(\'\');\n  return  &lt;TextInput value={text} onChangeText={setText} /&gt;\n}\n</code></pre><p>在这个示例中，我们先使用了 <code>useState</code> 创建了一个状态 <code>text</code> 和状态更新函数<code>setText</code>，并将状态<code>text</code>赋值给了 TextInput 的属性 <code>value</code>，<code>value</code> 是控制 TextInput 宿主组件展示的值用的。在用户输入文字后，会触发 onChangeText 事件，这时就会调用 <code>setText</code>，将状态 <code>text</code> 更新为用户最新输入的值。</p><p>那受控组件和非受控组件有什么区别呢？我把它们之间的实现原理画了一张图：</p><p><img src="https://static001.geekbang.org/resource/image/76/a9/7621791793d0d73030124e472f9117a9.png?wh=1920x672" alt="图片"></p><p>你看，对于非受控组件来说，用户输入文字和文字展示到屏幕的过程，全部都是在宿主应用层面进行的，JavaScript 业务代码是没有参与的。</p><p>然而，对于受控组件来说，用户输入文字和文字展示这两步，依旧是在宿主应用层面进行的。但后续 JavaScript 业务代码也参与进去了，业务代码依次执行了 onChangeText 函数、setText 函数、controlledTextInput 函数，并且再次更新了展示值。</p><p>也就是说，受控组件更新了两次展示的值，只是因为两次展示的值是一样的，用户看不出来而已。对于受控组件而言，即便存在系统或 Native 修改文本的情况，在 TextInput 的底层，也会将其强制更新为当前 TextInput 的 value 属性值。所以对于受控组件来说，输入框的文字始终是由 state 驱动的。</p><p>更新两次的好处在于，可以更加自由地控制输入的文本，比如语音输入文字、通过地图定位填写详细地址。这些复杂场景下，用户既可以自由输入文字，也可以引入程序参与进来。而非受控组件只适用于用户自由输入的场景。</p><p>不过，你可能会对更新两次有性能上的担忧。我也写了两个极限情况下的 demo，模拟了文字改变事件中需要处理 1s 任务，并且分别试了 onChangeText 的异步更新，和新架构提供的 unstable_onChangeSync 同步更新：</p><pre><code class="language-plain">&lt;TextInput\n  onChangeText={text =&gt; {\n    const time = Date.now();\n    while (Date.now() - time &lt;= 1000) {}\n    setText(text);\n  }}\n/&gt;\n&lt;TextInput\n  unstable_onChangeSync={event =&gt; {\n    const text = event.nativeEvent.text;\n    const time = Date.now();\n    while (Date.now() - time &lt;= 1000) {}\n    setText(text);\n  }}\n/&gt;\n</code></pre><p>异步更新情况下，JavaScript 线程和 UI 主线程是独立运行的，此时即便 JavaScript 线程卡了 1s，主线程依旧可以正常输入文字。但同步更新的情况下，从输入文字到展示文字会有 1s 的延迟， JavaScript 线程有 1s 的阻塞，UI 主线程也会卡死 1s。</p><p>当然，大多数情况下处理文字改变事件肯定用不了 1s，甚至用不了 1ms。模拟极限情况，只是为了说明新架构的同步和异步是可选的，如果你担心性能问题，用异步就好了。</p><p>现在如果要我给个处理输入框的文本建议，那我的建议就是<strong>使用受控组件，并且使用异步的文字改变事件</strong>，这也符合大部分人的代码习惯。</p><h2>输入框的焦点</h2><p>你需要关注的第二件事是，如何控制输入框的焦点。通常光标放置在哪个输入框上，那个输入框就是页面的唯一焦点。</p><p>有些场景下，输入框的焦点是程序自动控制的，无需开发者处理。比如用户点击手机屏幕上的输入框，此时焦点和光标都会移到输入框上。</p><p>有些场景下，是需要代码介入控制焦点的。比如你购物搜索商品，从首页跳到搜索页时，搜索页的焦点就是用代码控制的。或者你在填写收货地址时，为了让你少点几次输入框，当你按下键盘的下一项按钮时，焦点就会从当前输入框自动转移到下一个输入框。</p><p>我们先来看怎么实现自动“对焦”，以搜索页的搜索输入框自动对焦为例，示例代码如下：</p><pre><code class="language-plain">&lt;TextInput autoFocus/&gt;\n</code></pre><p>TextInput 的 autoFocus 属性，就是用于控制自动对焦用的，其默认值是 false。也就是说，所有的 TextInput 元素默认都不会自动的对焦，而我们将 TextInput 的 autoFocus 属性设置为 true 时，框架会在 TextInput 元素挂载后，自动帮我们进行对焦。</p><p>搜索页面只有一个搜索框的场景下 ，autoFocus 是好用的。但当一个页面有多个输入框时，autoFocus 就没法实现焦点的转移了。</p><p>比如，在购物 App 中填写收货地址时，你每完成一项填写，点击键盘中的下一项按钮，焦点就会自动转移一次，从姓名到电话再到地址。我们以前讲过，React/React Native 是声明式的，但是在操作自带状态的宿主属性时，比如焦点转移，声明式就不管用了，还得用给宿主组件下命令。</p><p>那怎么下命令呢？我们先从最简单的控制 TextInput 焦点讲起，示例代码如下：</p><pre><code class="language-plain">function AutoNextFocusTextInputs() {\n  const ref1 = React.useRef&lt;TextInput&gt;(null);\n\n  useEffect(()=&gt;{\n    ref1.current?.focus()\n  },[])\n\n  return  (\n    &lt;TextInput ref={ref1}  /&gt;\n    )\n}\n</code></pre><p>在这段代码中，先声明了一个 <code>ref1</code> 用于保存 TextInput 宿主组件。在该宿主组件上封装了 Native/C++ 层暴露给 JavaScript 的命令，比如对焦<code>focus()</code>、失焦<code>blur()</code>、控制选中文字的光标<code>setSelection</code>。</p><p><code>AutoNextFocusTextInputs</code>组件在挂载完成后，程序会调用<code>ref1.current.focus()</code>，将焦点对到 TextInput 元素上，这就是使用<code>focus()</code>实现对焦的原理。</p><p>使用 <code>focus()</code>命令对焦和使用<code>autoFocus</code>属性对焦，在原生应用层面的实现原理是一样的，只不过在 JavaScript 层面，前者是命令式的，后者是声明式的。对自带状态的宿主组件而言，命令式的方法能够进行更复杂的操作。</p><p>那要实现每点一次键盘的“下一项”按钮，将焦点对到下一个 TextInput 元素上，怎么实现呢？具体的示例代码如下：</p><pre><code class="language-plain">function AutoNextFocusTextInputs() {\n  const ref1 = React.useRef&lt;TextInput&gt;(null);\n  const ref2 = React.useRef&lt;TextInput&gt;(null);\n  const ref3 = React.useRef&lt;TextInput&gt;(null);\n\n  return (\n    &lt;&gt;\n      &lt;TextInput ref={ref1} onSubmitEditing={ref2.current?.focus} /&gt; // 姓名输入框\n      &lt;TextInput ref={ref2} onSubmitEditing={ref3.current?.focus} /&gt; // 电话输入框\n      &lt;TextInput ref={ref3} /&gt; // 地址输入框\n    &lt;/&gt;\n  );\n}\n</code></pre><p>首先，我们得声明 3 个 <code>ref</code> 用于保存 3 个 TextInput 元素。其次，实现这三个元素，它们依次是姓名输入框、电话输入框、地址输入框。最后，需要监听点击键盘完成按钮的提交事件<code>onSubmitEditing</code>，在<code>onSubmitEditing</code>的回调中，将焦点通过<code>ref.focus()</code>转移到下一个 TextInput 元素上。</p><p>这里再多说一句，为了简单起见，我们把三个 TextInput 元素都封装到了同一个组件中。在真实的项目中，这三个输入框往往不是封装成同一个组件中的，姓名输入框、电话输入框、地址输入框每个都是一个独立的组件，然后再有一个大的复合组件将它们组合在一起的。</p><p>那么这时，如何获取到 TextInput 元素 <code>ref</code> 呢？如果你遇到了这个问题，你可以查一下<a href="https://zh-hans.reactjs.org/docs/forwarding-refs.html">React 文档</a>中，关于使用 <code>React.forwardRef</code>转发 <code>ref</code>的具体用法，这里我就不展开了。</p><h2>联动键盘的体验</h2><p>你需要关注的第三件事是，输入键盘的体验细节。</p><p>我们前面提到过，输入框和键盘是联动的，键盘的很多属性都可以用 TextInput 组件来设置。因此，除了输入框的值、输入框的焦点，我们还需要关心如何控制键盘。我们一起来看看那些优秀的 App 都是怎么处理这个细节的。</p><p>先来看第一个体验细节，iOS 微信搜索框的键盘右下角按钮有一个<strong>“置灰置蓝”</strong>的功能。默认情况下，键盘右下角的按钮显示的是置灰的“搜索”二字，当你在搜索框输入文字后，置灰的“搜索”按钮会变成蓝色背景的“搜索”二字。</p><p>置灰的作用是提示用户，没有输入文字不能进行搜索，按钮变蓝提示的是有内容了，可以搜索了。</p><p>控制键盘右下角按钮置灰置蓝的，是 TextInput 的<code>enablesReturnKeyAutomatically</code>属性，这个属性是 iOS 独有的属性，默认是<code>false</code>，也就是任何使用键盘右下角的按钮，都可以点击。你也可以通过将其设置为 <code>true</code>，使其在输入框中没有文字时置灰。</p><p><img src="https://static001.geekbang.org/resource/image/de/58/de5c8eb7862fd38405b1caba07eaf258.png?wh=1018x222" alt="图片"></p><p>第二个体验细节是，键盘右下角按钮的文案是可以变化的，你可以根据不同的业务场景进行设置。</p><p>有两个属性可以设置这些文案，包括 iOS/Android 通用的<a href="https://reactnative.dev/docs/next/textinput#returnkeytype"> returnKeyType </a>和 Android 独有的 <a href="https://reactnative.dev/docs/next/textinput#returnkeylabel-android">returnKeyLabel</a>。全部的属性你可以查一下文档，我这里只说一下通用属性：</p><ul>\n<li><code>default</code>：显示的文案是换行；</li>\n<li><code>done</code>：显示的文案是“完成”，它适合作为最后一个输入框的提示文案；</li>\n<li><code>go</code>：显示的文案是“前往”，它适合作为浏览器网站输入框或页面跳出的提示文案；</li>\n<li><code>next</code>：显示的文案是“下一项”，它适合作为转移焦点的提示文案；</li>\n<li><code>search</code>：显示的文案是“搜索”，它适合作为搜索框的提示文案；</li>\n<li><code>send</code>：显示的文案是“发送”，它比较适合聊天输入框的提示文案。</li>\n</ul><p><img src="https://static001.geekbang.org/resource/image/dy/fd/dyyda94cdbb8d899c9852225d7e6f4fd.png?wh=1576x224" alt="图片"></p><p>比如，在用户填写收货地址表单的场景中，你可以在用户完成填写时，将键盘按钮文案设置成“下一项”，并在用户点击“下一项”时，把当前输入框的焦点聚焦到一下个输入框上。</p><p>第三个体验细节是，登录页面的自动填写账号密码功能。虽然现在有了二维码登录，但传统的账号密码登录场景还是非常多的。每次登录的时候，要输入一遍账号密码，就很麻烦了。</p><p>无论是 iOS 还是 Android，它们都有系统层面的记住账号密码的功能，帮助用户快速完成账号密码的填写。完成快速填写功能的 TextInput 属性，在 iOS 上叫做<code>textContentType</code>，在 Android 上叫做<code>autoComplete</code>。</p><p>你可以将账号输入框的快速填写属性设置为<code>username</code>，将密码输入框的快速填写属性设置为<code>password</code>，帮助用户节约一些时间，提高一下整体的成功率。除此之外，一些姓名、电话、地址信息也可以快速填写。</p><p><img src="https://static001.geekbang.org/resource/image/aa/6c/aa7378ddf3c2c193832f76b90323316c.png?wh=828x384" alt="图片"></p><p>还有一些键盘的体验细节，比如<code>keyboardType</code>可以控制键盘类型，可以让用户更方便地输入电话号码<code>phone-pad</code>、邮箱地址<code>email-address</code>等等。</p><p><img src="https://static001.geekbang.org/resource/image/6d/6f/6decc25dc3b45cc03e19ea533f15dc6f.png?wh=828x876" alt="图片"></p><p>当你知道这些键盘细节后，你就可以利用这些系统的特性，帮你的 App 体验变得更好。现在，我们回过头，再来改善一下，我们之前实现的自动聚焦组件 <code>AutoNextFocusTextInputs</code>吧。示例代码如下：</p><pre><code class="language-plain">function AutoNextFocusTextInputs() {\n  const ref1,ref2,ref3 ...\n\n  return (\n    &lt;&gt;\n      &lt;TextInput ref={ref1} placeholder="姓名" textContentType="name" returnKeyType="next" onSubmitEditing={ref2.current?.focus}/&gt;\n      &lt;TextInput ref={ref2} placeholder="电话"  keyboardType="phone-pad" returnKeyType="done" onSubmitEditing={ref3.current?.focus}\n      /&gt;\n      &lt;TextInput  ref={ref3}  placeholder="地址"  returnKeyType="done" /&gt;\n    &lt;/&gt;\n  );\n}\n</code></pre><p>在这段代码中，我们使用了<code>placeholder</code>来提醒用户该输入框应该输入什么，使用了 <code>textContentType="name"</code> 来辅助用户填写姓名，使用了 <code>keyboardType="phone-pad"</code> 来指定键盘只用于输入电话号码，使用<code>returnKeyType="next" 或 "done"</code>来提示用户当前操作的含义，当然还有<code>ref.current.focus()</code>的自动聚焦功能。</p><h2>总结</h2><p>这一讲，我们还是围绕着交互体验这个角度来讲组件，从交互体验这个角度看 TextInput 组件，我们需要注意三件事：</p><ol>\n<li>学会处理输入框的文字。有两种处理方式受控组件和非受控组件，受控组件更强大一些，也更符合大多数 React/React Native 开发者的习惯；</li>\n<li>学会处理输入框的焦点。处理焦点有两种方式：一种是声明式的<code>autoFocus</code>属性，另一种是命令式的<code>ref.current.focus()</code>方法，前者适用场景有限，后者适用场景更多；</li>\n<li>学会处理与输入框联动的键盘，包括键盘右下角的按钮、键盘提示文案、键盘类型等等。</li>\n</ol><p>日常工作中，用到 TextInput 输入框的场景非常多，有聊天框、搜索框、信息表单等等，相信学完这一讲后，你能更好地处理 TextInput 体验细节。</p><h2>附加材料</h2><ol>\n<li>iOS 模拟器上，点击 TextInput 元素并没有键盘弹窗，必须使用真机进行测试。iOS 如何在真机上进行打包请参考<a href="https://www.jianshu.com/p/f31116a76ea9">《iOS个人证书真机调试及报错》</a>。</li>\n<li>0.68 之后，新架构预览版已经能在本地跑起来了。如果你想跑 iOS RNTest App（Android 版哪位朋友帮忙提供一下？），也就是官方用于测试的 React Native App，你可以按照如下步骤进行操作：</li>\n</ol><pre><code class="language-plain">$ git clone https://github.com/facebook/react-native.git\n$ cd react-native\n$ yarn\n$ cd packages/react-native-codegen\n$ yarn build\n$ cd ../rn-tester\n$ yarn\n$ USE_CODEGEN_DISCOVERY=1  RCT_NEW_ARCH_ENABLE=1 pod install\n$ xed .\n\n=&gt; 打开 xcode 后，点击构建模拟器 App\n=&gt; 真机构建参考，附加材料 1\n=&gt; 真机构建遇到 Undefined symbol:folly 报错，试着注释掉 packages/rn-tester/Podfile 文件中的如下代码：\n  # if !USE_FRAMEWORKS\n  #   use_flipper!\n  # end\n</code></pre><p>3、今天的Demo我依然放在了<a href="https://github.com/jiangleo/react-native-classroom/tree/main/src/07_TextInput">GitHub</a>上，你可以自己动手试试。</p><h2>作业</h2><ol>\n<li>\n<p>请你实现一个如图所示的用于填写验证码的输入框组件：<br>\n<img src="https://static001.geekbang.org/resource/image/ce/96/ce50be3a09dcd4b531d14d9a733f1f96.png?wh=828x468" alt="图片"></p>\n</li>\n<li>\n<p>请你思考一下 TextInput 的异步 onChange 和同步 onChangeSync 的区别是什么？Fabric 的同步特性将给 React Native 带来什么变化？</p>\n</li>\n</ol><p>欢迎在评论区留言。我是蒋宏伟，咱们下节课见。</p>',
        article_title: "07｜TextInput：如何实现一个体验好的输入框？",
      },
      {
        title: "08｜List：如何实现高性能的无限列表？",
        id: 506825,
        content:
          '<p>你好，我是蒋宏伟。今天我们学习的重点是列表组件 RecyclerListView。</p><p>如果你熟悉 React Native ，那你可能会问了：“React Native 中的列表组件不是 FlatList 吗？”</p><p>没错。React Native 官方提供的列表组件确实是 FlatList，但是我推荐你优先使用开源社区提供的列表组件 RecyclerListView。因为，开源社区提供的 RecyclerListView 性能更好。</p><p>对于列表组件来说，我们最应该关心的就是性能。这里我给你分享下我的个人经历。2016~2018 年，我参与了一个用 React Native 搭建的信息流项目。信息流这种无限列表页是非常常见的业务场景，比如你使用的京东首页、抖音视频、微信朋友圈都属于信息流页面。你看完一页，还有下一页，看完下一页还有下下页，无穷无尽。这时就要用到我们马上要探讨的列表组件了，而且必须是高性能的列表组件，不能翻着翻着就卡起来了。</p><p>2016 年，没有 RecyclerListView，也没有 FlastList，我们用的是第一版的 ListView 组件。ListView 组件性能很差，没有内存回收机制，翻一页内存就涨一点，再翻一页内存又再涨一点。前 5 页滚动非常流畅，第 10 页开始就感觉到卡顿了，到 50 页的时候，基本就滑不动了。卡顿的原因就是无限列表太吃内存了。如果手机的可使用内存不够了，卡顿就会发生。这也是 React Native 刚出来时被吐槽得最多的地方。</p><!-- [[[read_end]]] --><p>2017 年，官方的第二代列表组件 FlatList 出来后，第一代列表组件 ListView 就被废弃了，这时候无限列表性能变得好一些了。虽然FlatList 在 iOS 端表现很好，但在 Android 低端机还是能感觉到卡顿。</p><p>2018 年，随着业务越来越复杂，FlatList 的性能表现变得更加糟糕了。经过调研，我们找到了性能更好的列表组件 RecyclerListView。通常评判列表卡顿的指标是 UI 线程的帧率和 JavaScript 线程的帧率。</p><p>但业内有人实验过，在已经渲染完成的页面中，通过死循环把 JavaScript 线程卡死，页面依旧能够滚动。这是因为滚动本身是在 UI 线程进行的，和 JavaScript 线程无关。但当用户下滑，需要渲染新的列表项时，就需要JavaScript 线程参与进来了。如果这时候 JavaScript 掉帧了，新的列表项就渲染不出来，即便能滚动，用户看到也是空白项，一样影响用户体验。</p><p>因此，我们当时是把 JavaScript 帧率作为客观指标，再加上团队同学主观体验，进行综合评估。采集 JavaScript 帧率用的手机是 OPPO R9，现在看来是妥妥的低端机了，结果显示，FlatList  JavaScript 帧率小于 20 帧的占比有 16%，而 RecyclerListView 占比只有 3%。主观体验上，团队同学拿自己的手机进行测试，使用暴力滑动的测试方法，测评了 20 来款机型。在低端机上 FlatList 多被标记为一般卡，而 RecyclerListView 大多标记是流畅，只有少量的轻微卡顿。</p><p><img src="https://static001.geekbang.org/resource/image/5e/bd/5ed5ba1e8a756d1065f1c70e14083abd.png?wh=1001x386" alt="图片"></p><p>即使现在新架构马上要出来了，在这个时间点上，我最推荐你用的还是 RecyclerListView。因为从原理上 RecyclerListView 比 FlatList 强上不少。</p><p>作为一个开发者，你总有需要手动优化的时候，不是所有场景都有现成的组件，都有自动化的解决方案。如果你现在没有遇到，兴许只是因为开发年头太少了，你可以问问你身边那些开发年头多的同学，他们在这方面应该是有很深的体会。学习 FlastList、RecyclerListView 的优化原理，对自己的动手优化是非常有帮助的。当你以后遇到列表性能问题时，你可以有现成的优化思路借鉴，不会毫无头绪。</p><p>那么，为什么开源社区的 RecyclerListView 比官方的 FlastList 性能更好？FlastList、RecyclerListView 的优化原理是什么？FlastList 和 RecyclerListView 的底层实现都是滚动组件 ScrollView，所以我们先从 ScrollView 聊起。</p><h2>ScrollView：渲染所有内容的滚动组件</h2><p>ScrollView 是一个支持横向或竖向的滚动组件，几乎所有页面都会用到。</p><p>ScrollView 组件类似于 Web 中的 <code>&lt;html/&gt;</code> 或 <code>&lt;body/&gt;</code> 标签，浏览器中的页面之所以能上下滚动，就是因为 html 或 body 标签默认有一个 overflow-y: scroll 的属性，如果你把标签的属性设置为 overflow-y: hidden，页面就不能滚动了。</p><p>React Native 的 ScrollView 组件在 Android 的底层实现用的是 ScrollView 和 HorizontalScrollView，在 iOS 的底层实现用的是 UIScrollView。</p><p>所谓的滚动，解决的是在有限高度的屏幕内浏览无限高度的内容的问题。有限高度的容器是 ScrollView，无限高度，或者说高度不确定的内容是 ScrollView 的 children。</p><p>使用 ScrollView 组件时，我们通常并不直接给 ScrollView 设置固定高度或宽度，而是给其父组件设置固定高度或宽度。</p><p>一般而言，我们会使用安全区域组件 SafeAreaView 组件作为 ScrollView 的父组件，并给 SafeAreaView 组件设置布局属性 flex:1，让内容自动撑高 SafeAreaView。使用 SafeAreaView 作为最外层组件的好处是，它可以帮我们适配 iPhone 的刘海屏，节约我们的适配成本，示例代码如下：</p><pre><code class="language-plain">&lt;SafeAreaView style={{flex: 1}}&gt;\n  &lt;ScrollView&gt;\n    &lt;Text&gt;1&lt;/Text&gt;\n  &lt;ScrollView/&gt;\n&lt;/SafeAreaView&gt;    \n</code></pre><p>了解完 ScrollView 组件的基本使用方法后，我们再来看下 ScrollView 的性能，看看如果使用 ScrollView 来实现无限列表会怎么样。</p><p>你可以看看下面这段代码：</p><pre><code class="language-plain">// 10 个 item 就能填满整个屏幕，渲染很快\n// 1000 个 item 相当于 100+ 个屏幕的高度，渲染很慢\nconst NUM_ITEMS = 1000; \n\nconst makeContent = (nItems: number, styles: any) =&gt; {\n  return Array(nItems)\n    .fill(1)\n    .map((_, i) =&gt; (\n      &lt;Pressable\n        key={i}\n        style={styles}&gt;\n        &lt;Text&gt;{\'Item \' + i}&lt;/Text&gt;\n      &lt;/Pressable&gt;\n    ));\n};\n\nconst App = () =&gt; {\n  return (\n    &lt;SafeAreaView style={{flex: 1}}&gt;\n      &lt;ScrollView&gt;{makeContent(NUM_ITEMS, styles.itemWrapper)}&lt;/ScrollView&gt;\n    &lt;/SafeAreaView&gt;\n  );\n};\n</code></pre><p>上面这段代码，说的就是使用 ScrollView 组件一次性直接渲染 1000 个子视图，这里没有做任何懒加载优化。</p><p>以信息流业务为例，用户进入页面后第一眼看到的只有屏幕中的信息，一般不超过 10 条。一次性渲染 10 条信息，其实很快，就是一眨眼的功夫。但如果是 1000 条呢？算力乘以 100，内存乘以 100，耗时也乘以 100，渲染速度就慢下来了。大量的计算和内存浪费在了用户看不到的地方。</p><p>使用 ScrollView 组件时，ScrollView 的所有内容都会在首次刷新时进行渲染。内容很少的情况下当然无所谓，内容多起来了，速度也就慢下来了。</p><p>那有什么优化方案吗？你肯定想到了一些优化方案，比如按需渲染。</p><p>我参加过一个使用 React Native 开发的、类似抖音的视频流页面，用的就是按需渲染。用户始终只会看到当前屏幕显示的视频、下一个视频和上一个视频，我们只需要用 ScrollView 渲染 3 个视频就能满足用户的所有操作。这样做，无论用户怎么翻页，内存中就只有 3 个视频，当然也不会卡了。</p><p>刚刚说的视频流按需加载，做起来是相对容易一些的，因为只用控制 3 个视频就可以了。但类似微信朋友圈、京东首页这种一屏有多条信息内容的复杂列表页，手动按需加载就麻烦很多。那有没有“自动"的按需加载方案呢？有。</p><h2>FlatList：按需渲染的列表组件</h2><p>FlatList 列表组件就是 “自动”按需渲染的。</p><p>FlatList 是 React Native 官方提供的第二代列表组件。FlatList 组件底层使用的是虚拟列表 VirtualizedList，VirtualizedList 底层组件使用的是 ScrollView 组件。因此 VirtualizedList 和  ScrollView 组件中的大部分属性，FlatList 组件也可以使用。关于 FlatList 更具体的使用方法，你可以查看<a href="https://reactnative.dev/docs/flatlist">官方文档</a>。现在，我们还是回到 FlatList 的原理，先从理论层面上理解 FlatList 为什么可以自动按需渲染。</p><p>我们要知道，列表组件和滚动组件的关键区别是，列表组件把其内部子组件看做由一个个列表项组成的集合，每一个列表项都可以单独渲染或者卸载。而滚动组件是把其内部子组件看做一个整体，只能整体渲染。而自动按需渲染的前提就是每个列表项可以独立渲染或卸载。</p><p>简单地讲，FlatList 性能比 ScrollView 好的原因是， FlatList 列表组件利用按需渲染机制减少了首次渲染的视图，利用空视图的占位机制回收了原有视图的内存，你可以对比一下二者的区别：</p><pre><code>// 从上到下滚动时的渲染方式\n// SrcollView 渲染方式：一次渲染所有视图\nSrcollView0_9  = [{👁},{ },{ },{ }]  // 浏览0~9条列表项\nSrcollView10_19 = [{ },{👁},{ },{ }] // 浏览10~19条列表项\nSrcollView20_29 = [{ },{ },{👁},{ }] // 浏览20~29条列表项\nSrcollView30_39 = [{ },{ },{ },{👁}] // 浏览30~39条列表项\n\n// FlatList 渲染方式：按需渲染，看不见的地方用 $empty 占位\nFlatList0_9  = [{👁},{ }]               // 浏览0~9条列表项\nFlatList10_19 = [{ },{👁},{ }]          // 浏览10~19条列表项\nFlatList20_29 = [$empty,{},{👁},{}]     // 浏览20~29条列表项\nFlatList30_39 = [$empty,$empty,{ },{👁}]// 浏览30~39条列表项\n</code></pre><p>在上面的示例中，同样是渲染 40 条列表。ScrollView 一次性渲染了 40 条列表，无论你滚动到哪儿，所有的列表项都是渲染好的。</p><p>但FlatList 在你浏览 0~9 条列表项时，只渲染了0~19条列表，剩余的20~39条列表项是没有渲染的。在你浏览滚动到第 10~19 条时，FlatList 把 20~29 条列表项提前加载出来了，这就是按需渲染加载机制.当你继续滚动到 20~29 条列表项时，FlatList 会把第 0~9 条列表项回收，用空元素 <span dollar="">$</span>empty 代替，当你再滚动到 30~39 条列表项时，同理 10~19 条列表项也会被空元素 <span dollar="">$</span>empty，这就是内存回收。</p><p>40 条列表只是一个假设的例子，实现 FlatList自动按需渲染的思路具体可以分为三步：</p><ol>\n<li>通过滚动事件的回调参数，计算需要按需渲染的区域；</li>\n<li>通过需要按需渲染的区域，计算需要按需渲染的列表项索引；</li>\n<li>只渲染需要按需渲染列表项，不需要渲染的列表项用空视图代替。</li>\n</ol><p>第一步，计算按需渲染区域。具体地说，每次你滚动页面，都会触发滚动组件 ScrollView 组件的一个“异步”回调 onScroll 事件。</p><p>在 onScroll 事件中，我们可以获取到当前滚动的偏移量 offset 等信息。以当前滚动的偏移量为基础，默认向上数 10 个屏幕的高度，向下数 10 个屏幕的高度，这一共 21 个屏幕的内容就是需要按需渲染的区域，其他区域都是无需渲染的区域。这样，即便是异步渲染，我们也不能保证所有 JavaScript 执行的渲染任务都实时地交由 UI 线程处理，立刻展示出来。但因为有这 10 个屏幕的内容作为缓冲，用户无论是向上滚动还是向下滚动，都不至于一滚动就看到白屏。</p><p>现在我们知道了按需渲染的区域，接着要计算的就是按需渲染列表项的索引。FlatList 内部实现就是通过 setState 改变按需渲染区域第一个索引和最后一个索引的值，来实现按需渲染的 。</p><p>怎么计算按需渲染列表项的索引呢？接着我们继续看第二步。这里我们分两种情况，第一种是列表项的高度是确定的情况，另外一种是列表项的高度是不确定的情况。</p><p>如果设计师给的列表项的高度是确定的，那么我们在写代码的时候，就可以通过获取列表项布局属性 getItemLayout 告诉 FlastList。在列表项高度确定，且知道按需渲染区域的情况下，“求按需渲染列表项的索引”就是一个简单的四则运算的问题，程序能够准确地计算出来。</p><p>如果设计师给的 UI 稿中是不定高的列表项，也就是高度是由渲染内容决定的。你就没有办法在写代码的时候把列表项的高度告诉 FlastList 了，那么 FlastList 就要先把列表项渲染出来才能获取高度。对于高度未知的情况，FlastList 会启用列表项的布局回调函数 onLayout，在 onLayout 中会有大量的动态测量高度的计算，包括每个列表项的准确高度和整体的平均高度。</p><p>在这种列表项高度不确定，而且给定按需渲染区域的情况下，我们可以通过列表项的平均高度，把按需渲染列表项的索引大致估算出来了。即便有误差，比如预计按需渲染区域为上下 10 个屏幕，实际渲染时只有上下 7、8 个屏幕也是能接受的，大部分情况下用户是感知不到的屏幕外内容渲染的。</p><p>但是，实际生产中，如果你不填 getItemLayout 属性，不把列表项的高度提前告诉 FlastList，让 FlastList 通过 onLayout 的布局回调动态计算，用户是可以感觉到滑动变卡的。因此，如果你使用 FlastList，又提前知道列表项的高度，我建议你把 getItemLayout 属性填上。</p><p>第三步，渲染需要按需渲染列表项。有了索引后，渲染列表项就变得很简单，用 setState 即可。</p><p>假设 1 个屏幕高度的内容由 10 个列表项组成。在首次渲染的时候，按需渲染的列表项索引是 0~110，这时会渲染 11 个屏幕高度的内容。当用户滑到第 11 个屏幕时，索引就是 0~210，这时再在后面渲染 10 个屏幕高度的内容。当用户滑到第 21 个屏幕时，索引是 100~310，又会再在后面渲染 10 个屏幕高度的内容，同时把前面 10 个屏幕高的内容用空视图代替。当然这个过程是顺滑的，列表项是一个个渲染的，而不是 1 个屏幕或 10 个屏幕渲染的。</p><h2>RecyclerListView：可复用的列表组件</h2><p>聊完 FlastList，我们再来看下 RecyclerListView。</p><p>RecyclerListView 是开源社区提供的列表组件，它的底层实现和 FlatList 一样也是 ScrollView，它也要求开发者必须将内容整体分割成一个个列表项。</p><p>在首次渲染时，RecyclerListView 只会渲染首屏内容和用户即将看到的内容，所以它的首次渲染速度很快。在滚动渲染时，只会渲染屏幕内的和屏幕附近 250 像素的内容，距离屏幕太远的内容是空的。</p><p>React Native 的 RecyclerListView 复用灵感来源于 Native 的可复用列表组件。</p><p>在 iOS 中，表单视图 UITableView，实际就是可以上下滚动、左右滚动的可复用列表组件。它可以通过复用唯一标识符 reuseIdentifier，标记表单中的复用单元 cell，实现单元 cell 的复用。</p><p>在 Android 上，动态列表 RecyclerView 在列表项视图滚出屏幕时，不会将其销毁，相反会把滚动到屏幕外的元素，复用到滚动到屏幕内的新的列表项上。这种复用方法可以显著提高性能，改善应用响应能力，并降低功耗。</p><p>如果你只开发过 Web，你可以这样理解复用：原来你要销毁一个浏览器中 DOM，再重新创建一个新的 DOM，现在你只改变了原有 DOM 的属性，并把原有的 DOM 挪到新的位置上。</p><p>RecyclerListView 的复用机制是这样的，你可以把列表比作数组 list，把列表项类比成数组的元素。用户移动 ScrollView 时，相当于往数组 list 后面 push 新的元素对象，而 RecyclerListView 相当于把 list 的第一项挪到了最后一项中。挪动对象位置用到的计算资源少，也不用在内存中开辟一个新的空间。而创建新的对象，占用计算资源多，同时占用新的内存空间。</p><p>简而言之，RecyclerListView 在滚动时复用了列表项，而不是创建新的列表项，因此性能好。</p><h2>从使用方式看底层原理</h2><p>接下来，我们从 RecyclerListView 使用方式的角度，进一步地剖析其底层原理。</p><p>RecyclerListView 有三个必填参数：</p><ul>\n<li>列表数据：dataProvider(dp)；</li>\n<li>列表项的布局方法：layoutProvider；</li>\n<li>列表项的渲染函数：rowRenderer。</li>\n</ul><p>先来看<strong>第一个必填参数列表数据 dataProvider（dp）</strong>。为了区分列表数据 dataProvider（第一个字母小写）和列表数据类 DataProvider（第一个字母大写），后面我会用缩写 dp 来代替列表数据，其使用方法如下：</p><pre><code class="language-plain">const listData = Array(300).fill(1).map( (_,i) =&gt; i)\n\nconst dp = new DataProvider((r1, r2) =&gt; {\n   return r1 !== r2;\n});\n\nthis.state = {\n    dataProvider: dp.cloneWithRows(listData),\n};\n\nthis.setState({\n  dataProvider: dp.cloneWithRows(newListData),\n})\n</code></pre><p>在上面代码中，我们首先通过 Array(300) 创建了一个长度为 300 的数组 listData，其内容是 0~299 的数字，我们通过它来模拟 300 条信息数据。</p><p>接着，dp 是列表数据类 DataProvider new 出来的对象，它是一个存放 listData 的数据容器。它有一个必填参数，就是对比函数。在列表项复用时，对比函数会频繁地调用，因此我们只推荐对更新数据进行 r1 !== r2 的浅对比，不推荐深对比。</p><p>第三部分代码，是我们调用 dp.cloneWithRow 方法，该方法接收 listData 数组作为参数，这时我们正式把 listData 装到了 dp 容器中。其返回值 dataProvider，就是 React 的列表状态。</p><p>第四部分代码，是我们调用 setState 方法，该方法接收 dp.cloneWithRows()  的返回的 dp 对象作为参数，dp 列表数据对象更新了，整个列表也就更新了。</p><p>接下来是<strong>第二个必填参数，列表项的布局方法 layoutProvider。</strong></p><pre><code class="language-plain">const _layoutProvider = new LayoutProvider(\n  index =&gt; {\n    if (index % 3 === 0) {\n      return ViewTypes.FULL;\n    } else {\n      return ViewTypes.HALF_RIGHT;\n    }\n  },\n  (type, dimension) =&gt; {\n    switch (type) {\n      case ViewTypes.HALF_RIGHT:\n        dimension.width = width / 2;\n        dimension.height = 160;\n        break;\n      case ViewTypes.FULL:\n        dimension.width = width;\n        dimension.height = 140;\n        break;\n    }\n  },\n);\n</code></pre><p>layoutProvider 类初始化时，有两个函数入参。第一个入参函数是通过索引 index 获取类型 type，对应的是类型可枚举。第二个入参函数是通过类型 type 和布局尺寸 dimension 获取每个类型的宽高 width 和 height，对应的是确定宽高。</p><p>用起来很简单，但这两个入参为什么要这么设计，它们有什么用？</p><p>使用列表组件 RecyclerListView 有两个前提：首先是列表项的宽高必须是确定的，或者是大致确定的；第二是列表项的类型必须是可枚举的。这两个前提，都体现在了列表项的布局方法 layoutProvider 中了。</p><p>先来看第一个前提，宽高必须确定。RecyclerListView 用的是 position:absolute 的绝对定位布局，所有的列表项的宽度 width、高度 height、顶部偏移量 top、左边偏移量 left 都得在布局之前计算出来。</p><p>但实际上布局方法 layoutProvider，只需要知道列表项的宽（width）、高（height）就可以了，偏移量 top、left 可以根据宽高推算出来。比如，第 N 个列表项的偏移量 top 值，实际等于前面 N - 1 个列表项的高度之和。</p><p>如果宽高不确定呢？分两种情况，一种就是不确定的，另一种是不确定但可以转换为大致确定的。对于就是不确定的情况，RecyclerListView 是无解的；对于大致确定的情况，我们可以开启 forceNonDeterministicRendering 小幅修正布局位置。</p><p>比如，信息流的标题文字少的时候是一行布局，文字多的时候是两行布局，一行两行的高度偏差不大，可以在渲染后让框架帮忙进行小幅修正。通常在用户看到之前，这种小幅修正就已经完成了，用户感知不到列表的偏移。</p><p>但如果是信息流的内容高度不确定，相差百来个像素，这种大幅修正可能会让用户察觉到，不适合使用 RecyclerListView 。</p><p>再来看第二个前提，类型可枚举。可枚举很好理解，两个列表项的底层 UI 视图必须一样或者大致相似，才能只改列表数据复用列表视图。如果每个列表项的 JSX 结构完全不一样，就不存在复用的可能性。一般来说，一个类型对应一个自定义组件。</p><p>理解了确定宽高和类型可枚举两个前提后，你再来看布局方法 layoutProvider 需要的两个函数入参，就能清楚它的原因了。</p><p>最后是<strong>第三个必填参数，列表项的渲染函数：rowRenderer。</strong></p><p>有了数据、布局，还得有组件进行承载。列表内容被分割成了一个个的列表项，每一个列表项展示都是独立的内容信息，而可枚举的列表项组件用于承载每条信息的载体。列表项的渲染函数 rowRenderer 的作用就是根据类型和数据，返回对应的自定义列表项组件。这块逻辑比较简单，我就不做过多讲解了。</p><p>rowRenderer 的对应代码，我也放在了这里，你可以对照查看：</p><pre><code class="language-plain">//Given type and data return the view component\n  _rowRenderer(type, data) {\n    //You can return any view here, CellContainer has no special significance\n    switch (type) {\n      case ViewTypes.HALF_RIGHT:\n        return (\n          &lt;CellContainer style={styles.containerGridRight}&gt;\n            &lt;Text&gt;Data: {data}&lt;/Text&gt;\n          &lt;/CellContainer&gt;\n        );\n      case ViewTypes.FULL:\n        return (\n          &lt;CellContainer style={styles.container}&gt;\n            &lt;Text&gt;Data: {data}&lt;/Text&gt;\n          &lt;/CellContainer&gt;\n        );\n      default:\n        return null;\n    }\n  }\n</code></pre><h2>PK：ScrollView、FlatList、RecyclerListView</h2><p>到这里，我相信你已经对 ScrollView、FlatList 和 RecyclerListView 底层原理有了一定的了解。现在，我们再横向对比一下这三个组件，帮你加深理解。</p><p>从底层原理看：</p><ul>\n<li>ScrollView 内容的布局方式是从上到下依次排列的，你给多少内容，ScrollView 就会渲染多少内容；</li>\n<li>FlatList 内容的布局方式还是从上到下依次排列的，它通过更新第一个和最后一个列表项的索引控制渲染区域，默认渲染当前屏幕和上下 10 屏幕高度的内容，其他地方用空白视图进行占位；</li>\n<li>RecyclerListView 性能最好，你应该优先使用它，但使用它的前提是列表项类型可枚举且高度确定或大致确定。</li>\n</ul><p>理解了底层原理，FlatList 和 RecyclerListView 孰强孰弱，相信你已经有了答案。</p><p>内存上，FlatList  要管理 21 个屏幕高度的内容，而 RecyclerListView 只要管理大概 1 个多点屏幕高度的内容，RecyclerListView 使用的内存肯定少。计算量上，FlatList  要实时地销毁新建 Native 的 UI 视图，RecyclerListView 只是改变 UI 视图的内容和位置，RecyclerListView 在 UI 主线程计算量肯定少。</p><p>你也可以自己实际的体验、看看性能指标或者 Debug 一下，来佐证你的结论。</p><p>理解了底层原理，ScrollView、FlatList 和 RecyclerListView 使用场景，估计你也能基本把握住了：</p><ul>\n<li>ScrollView 适合内容少的页面，只有几个屏幕高页面是适合的；</li>\n<li>FlatList 性能还过得去，但我不推荐你优先使用它，只有在你的列表项内容高度不能事先确定，或者不可枚举的情况下使用它；</li>\n<li>RecyclerListView 性能最好，你应该优先使用它，但使用它的前提是可枚举且高度确定或大致确定。</li>\n</ul><p>这里我也总结成了两张图表，你可以看看：</p><p><img src="https://static001.geekbang.org/resource/image/e9/71/e9572yy831332ba1fb8baf0a48bc7e71.png?wh=1920x1050" alt="图片"></p><p><img src="https://static001.geekbang.org/resource/image/e6/a0/e6cb77f6425810e752abbeb643dbb9a0.png?wh=1870x964" alt="图片"></p><h2>总结</h2><p>最后，我们总结一下今天这节课所讲的重点：</p><ol>\n<li>滚动组件 ScrollView 是列表组件 FlastList 和 RecyclerListView 的底层实现，ScrollView 的绝大部分属性在 FlastList 和 RecyclerListView 上都有；</li>\n<li>从按需渲染的可视区域的大小和对底层 UI 视图的操作方式上分析，RecyclerListView 比 FlastList 的内存更少，在 UI 线程的计算量也更少；</li>\n<li>为了让你的无限列表性能更好，我推荐你优先使用 RecyclerListView，然后才是 FlastList。</li>\n</ol><p>列表是一个很大的话题，牵涉到的性能优化细节和实践内容很多，这一讲可以算作列表的一个入门。</p><p>受限于手机性能，无限列表是经常出现性能问题的重灾区，我也参与和优化过一些非常复杂的无限列表场景，包括 Hybrid、小程序 和 React Native，有过非常多的实践。在后面的篇章中，我会基于这些入门知识，和你讲讲具体业务中的实践操作，还有一些新架构中无限列表的变化。</p><p>在这一讲中，我希望你能把基础打好，自己动手实践一下 ScrollView、FlastList 和 RecyclerListView。同样，今天我也给你留了补充材料和作业。</p><h2>补充材料</h2><h3>使用文档：</h3><ul>\n<li><a href="https://reactnative.dev/docs/scrollview">ScrollView</a> 和 <a href="https://reactnative.dev/docs/flatlist">FlatList</a> 你可以参考官方文档，进一步学习它们的具体使用。</li>\n<li>RecyclerListView 你可以在 Github 上找到它的<a href="https://github.com/Flipkart/recyclerlistview">文档</a>，在作者的博客<a href="https://medium.com/@naqvitalha/recyclerlistview-high-performance-listview-for-react-native-and-web-e368d6f0d7ef">《RecyclerListView: High performance ListView for React Native and Web》</a>了解它的诞生背景。</li>\n</ul><h3>实战指南：</h3><ul>\n<li>RecyclerListView 的内部状态是 renderStack 用于确定哪些视图应该渲染，<a href="https://github.com/Flipkart/recyclerlistview/blob/c80825fabe510a48ced722e2e6e9dc1b50e8e273/src/core/VirtualRenderer.ts#L213-L222">它的复用机制是通过列表项的类型 type 找到要被回收列表项 renderStack[key]，然后用新列表项索引 index 替换被回收的列表项索引 oldIndex</a>。</li>\n<li>RecyclerListView 是可以实现高度不确定的无限列表的。图片的高度可以通过服务端事先传过来，文字的高度可以按照我在<a href="https://mp.weixin.qq.com/s/kN4MxfEkvICq3JneUvM56w">《React Native 无限列表的优化与实践》</a>一文中提供的算法提前算出来，再开启高度动态修正。</li>\n<li>RecyclerListView 也是可以实现瀑布流布局的。RecyclerListView 其实就是绝对定位(x,y,width,height)，但不支持双列，你可以用 <a href="https://github.com/ds300/patch-package">patch-package</a> ，把底层计算 layout 用的 <a href="https://github.com/Flipkart/recyclerlistview/blob/782e6ebb0ed944a653e8c83eac9329cfa243410c/src/core/layoutmanager/LayoutManager.ts#L99-L105">“relayoutFromIndex” 和 “this._layouts” </a>改了。</li>\n<li>它们的 Demo 我放在了 <a href="https://github.com/jiangleo/react-native-classroom/tree/main/src/08_List">GitHub</a> 上，你可以动手把玩一下。</li>\n</ul><h2>作业</h2><ol>\n<li>请你使用 React Hook 的语法实现一个 RecyclerListView 无限列表。</li>\n<li>你遇到过那些列表性能问题又是怎么解决的，能不能和我们分享一下你的心得？</li>\n</ol><p>欢迎在留言区分享你的见解。我是蒋宏伟，咱们下节课见。</p>',
        article_title: "08｜List：如何实现高性能的无限列表？",
      },
      {
        title: "09｜Fast Refresh：提高 UI 调试效率神器",
        id: 507846,
        content:
          '<p>你好，我是蒋宏伟。今天我们来讲一讲提高 UI 调试效率的方法。</p><p>在开发 UI 时，大家一般都是一边看设计稿，一边写代码，一边调试，三种行为交替进行的。谁的大脑都不是一台编译机，也不能安装真正的 React Native 环境。即使已经思考得很完备了，我们也不能保写完的一段代码里面没有任何 Bug，每次写完的代码都能完美符合我们预期的设计。所以，我们离不开 UI 调试。</p><p>那UI 调试效率重要吗？非常重要。你可以回想一下，是不是我们大部分的业务开发都会涉及到 UI 的开发。而在 UI 开发的过程中，你是不是会花费很多时间在调试代码上，甚至调试时间可能比真正写代码的时间还要多？正是如此，我们才更应该花点时间学一下调试技巧，把 UI 开发整体效率给提上去。</p><p>今天这节课，我会先从 React Native 快速刷新的使用讲起，然后再深入核心原理，帮你理解如何更好地使用快速刷新，提高你的 UI 开发效率。</p><h2>使用快速刷新</h2><p>React Native <a href="https://reactnative.dev/blog/2019/09/18/version-0.61#fast-refresh">快速刷新（Fast Refresh）</a>是默认开启的，你不用做任何额外的配置，就能立刻体验到。</p><p>快速刷新提效的本质是<strong>及时反馈</strong>。也就是说，你写下代码后就能看到 UI，没有其他任何多余步骤。代码完成了，UI 就更新了，这就是及时反馈。</p><!-- [[[read_end]]] --><p>假设，你正在开发一个商品列表页面。UI 稿中图片左边距为 30px ，你在 Image 的样式中增加了一行 <code>marginLeft: 30</code> 的代码。当你按下快捷键<code>cmd + s</code>保存代码时，不到 1s 的时间，你就看到你屏幕右侧模拟器中，所有商品图片都移到正确的位置上了。</p><p>你能在心中快速验证一下，是对的，然后你又添加一行上下居中的代码，又是不到 1s 的时间，商品图片又位移了一下。嗯，完美居中。每一次的 UI 调试都是，所码即所见，无与伦比的开发体验，让你沉浸在这开发的心流中。</p><p>这实际上就是我日常使用 React Native 快速刷新能力开发 UI 界面的感受。</p><p>在使用快速刷新时，你应该知道一个提升开发效率的小技巧。我日常开发时习惯把模拟器放在代码编辑器右边，并且会把模拟器勾选<code>window =&gt; stay on top</code>选项，在把模拟器置顶在编辑器上方。</p><p>这样，我们就能在写代码和调试的同时，立刻看到模拟器中的效果。相比真机调试或者多屏来回切换，置顶模拟器可以减少手离开键盘和视野来回切换的次数，提高你的开发效率。</p><p><img src="https://static001.geekbang.org/resource/image/57/f4/57463070f313cb6e0e1425ee3930e8f4.png?wh=1825x1080" alt="图片"></p><p>看到这里，你是不是很好奇，快速刷新带来的“所码即所见”能力的原理究竟是什么样的？</p><h2>基础原理：模块热替换</h2><p>React Native 的快速刷新功能的最早期版本，叫做热重载 Hot Reload，是基于 Webpack 的模块热替换<a href="https://webpack.js.org/guides/hot-module-replacement">（Hot Module Replacement）</a>的原理开发的。我们写 React Native 之前，都会运行一个 <code>react-native start</code> 命令，启动一个 Metro 服务，而 Metro 服务就实现了模块热替换的功能。</p><p>Metro 服务会把更新的代码打包发送给 React Native 应用，让应用能够及时更新，那这个过程大概是怎么样的呢？</p><p>首先，Metro 服务会监听代码文件的变化，当你修改完代码（①），保存文件时（②），Metro 服务就会收到通知。在你保存好后，Metro 就会编译涉及到的更新文件（③），编译完成后再生成一个用于更新的 bundle。</p><p>而 Metro 的模块热替换服务和 React Native 应用中的模块热替换客户端（HMR Client），在启动时其实已经建立好了 socket 连接。</p><p>所以，当新 bundle 生成时，模块热替换服务会通过 socket 通知块热替换客户端，热替换客户端实际就是运行在 React Native 应用中的一段 JavaScript 代码，它一开始就执行了一个 socket 监听事件（④）。</p><p>React Native 收到通知后，就会向请求 bundle 服务发起请求。然后，bundle 服务会返回一个用于更新的 bundle（⑤），并使用 JavaScript 引擎，在原来 React Native 应用的 JavaScript 上下文中执行用于更新的 bundle。</p><p>这个bundle 是由多个模块组成的，你修改代码文件对应的模块及其依赖模块都是新模块，新模块会把原先的旧模块替换掉。⑥</p><p>这就是整个模块热替换的全部过程，这里我放了一张流程图，你可以参考一下：</p><p><img src="https://static001.geekbang.org/resource/image/2f/15/2fd3716c54b10fe645b9a3d4301cdb15.jpg?wh=1980x711" alt=""></p><p>但是这里会有一个问题，仅仅只是用新模块替换旧模块，会导致原生视图重新渲染，并且丢失原有状态。</p><p>这是因为，新模块的重新执行就意味着，每个新模块中的组件，无论是类组件或者函数组件，都会被重新创建。而 React 在判断是否要更新的时候，会判断更新前后的两个组件是否相等。这样一来，即便新旧组件的代码完全一样，React 也会认为你销毁了原有组件，又创建了一个新的组件。而组件所对应的原生视图，也会发生销毁和重建。</p><p>这就好比，你先创建了一个旧的空对象，然后又创建了一个新的空对象。虽然代码完全一样，都是空对象，但是你用全等去判断时，因为对象是引用类型，创建了一个新对象就创建了一个新的引用，新的引用又不等于旧的引用，所以新对象是不等于旧对象的：</p><pre><code class="language-plain">// 新的空对象 ≠ 旧的空对象\n{} !== {}\n</code></pre><p>同理，当你保存 List 组件时，即便你没有对 List 组件中的代码做任何修改，模块热替换后，React 也会认为，你保存之前的是旧组件，保存之后的是新组件。而新组件不等于旧组件，那它就会帮你销毁旧的原生视图，并重新创建新的原生视图。这个时候，原有组件状态 state 和原生列表的滚动位置都会丢失：</p><pre><code class="language-plain">// 保存前：oldList.js\nexport default function List {}\n// 保存后：newList.js\nexport default function List {}\n// 渲染的都是 List 组件\nrender(){ &lt;List /&gt; }\n// 但是，因为 newList ≠ oldList\nrequire(\'newList\').default !== require(\'oldList\').default\n// 所以，React 会销毁旧的 List 原生视图，创建新的 List 原生视图\n</code></pre><p>也就是说，基础的模块热替换功能只能实现组件级别的强制刷新，而组件状态的丢失，会导致开发效率的降低。</p><p>你想啊，当你要在商品列表页面中开发一个弹窗时，你修改了弹窗组件，一保存，弹窗组件强制刷新了，然后就消失了。你要又点开弹窗，重来一次。弹窗还稍微好点，如果是层级更新的组件，你要多次操作才能使用，如此反复操作，开发效率会变得很低。</p><h2>进阶能力：复用组件及其状态</h2><p>那么，React Native 的快速刷新功能，是如何实现组件状态不丢失，原生视图不重建的呢？</p><p>快速刷新功能复用组件和状态的原理分为两个步骤：</p><ol>\n<li>在编译时，修改组件的注册方式；</li>\n<li>在运行时，用“代理”的方式管理新旧组件的切换。</li>\n</ol><p>在编译时， 快速刷新的 babel 插件 <a href="https://github.com/facebook/react/blob/v17.0.2/packages/react-refresh/src/ReactFreshBabelPlugin.js">ReactFreshBabelPlugin</a> 修改你的代码，将你的组件转换成可被代理的组件。快速刷新 babel 插件和其他 babel 插件一样，它的功能都是对代码进行转换。正如你使用 babel 可以把 JSX 转换为 JavaScript 一样，快速刷新 babel 插件也可以在你组件源代码中插入一些代码，实现组件的“代理”。</p><p>打一个比方，如果我们要对一个自定义的 Counter 函数组件实现代理。那我们要怎么做呢？首先，在 metro 打包时，快速刷新 babel 插件，找到文件中要导出的 Counter 组件；然后，通过它的函数名、文件名生成一个全局唯一的 ID，例如 ‘Counter.js#Counter’ ；最后，生成一行注册代码。这行代码的作用是，将 ID 作为一个不变的对象标识，用这个不变的对象去“代理”，因模块热替换而变化 Counter 组件，具体你可以看下这里：</p><pre><code class="language-plain">// 源代码\nexport function Counter() {\n  const [count, setCount] = useState(0);\n  const handlePress = () =&gt; setCount(count + 1)\n  return &lt;Text onPress={handlePress}&gt;times:{count}&lt;/Text&gt;\n}\n\nconst __exports_default = Counter\nexport default __exports_default\n\n// 由快速刷新 babel 生成\n// 将组件注册到组件管理中心\nregister(\'Counter.js#Counter\', Counter)\n</code></pre><p>有了编译时插入的注册代码，在运行时，我们就可以用“代理”的方式，管理新旧组件的切换了。</p><p>无论是初次加载的 Count 组件，还是后续模块热替换不断新建的 Counter 组件，都会放在组件注册中心。而“代理”只会在 Count 组件初次加载时创建，创建之后就作为一个不变的对象放在“代理”注册中心。</p><p>在代码保存后，模块热替换会将新的组件代码运行，在新组件被创建的同时，新组件的注册函数就会被执行了。通过唯一的 ID，找到对应的不变“代理”，并将代理的 current 引用，切换到新组件上，完成新旧组件的切换。</p><pre><code>// ReactFreshRuntime.js\n// “代理”注册中心\nconst allFamiliesByID = {}\n\n// 组件注册中心\nconst allFamiliesByType = {}\n\nfunction register(id, componentType) {\n    let family = allFamiliesByID[id];\n\n    if (family === undefined) {\n      family = {current: componentType};\n      // 将不变的“代理”放入“代理”注册中心\n      allFamiliesByID[id] = family\n    } else {\n      // 用不变的“代理”，管理新旧组件的切换\n      const prevType = family.current;\n      family.current = componentType;\n    }\n    // 将所有组件都放入组件注册中心\n    allFamiliesByType[componentType] = family;\n}\n</code></pre><p>这就在保证组件不变的情况下，完成了新旧组件的切换。</p><p>因为代理组件是存在全局对象上的，所以当你保存代码引起模块系统更新时，代理组件的引用也不会发生改变。接着，页面开始更新，此时调用的是代理组件的 render 方法，然后代理组件调用的更新后的新模块组件的 render 方法。你每保存一次代码，模块系统都更新一次，代理组件实际 render 也会进行一次切换，但是只要你的代码没有变化，React 也不会重新创建原生视图。React Native 组件级别的快速刷新，就是通过<strong>代理组件</strong>实现的。</p><p>那究竟是如何实现复用组件及其状态的呢？</p><p>我们先来说状态复用。在我们前面的示例中，我们把 Counter 函数组件，放在了 Counter.js 的文件中，一个文件就是一个模块，如果里面只有一个函数组件的话，我们就可以把它叫做一个函数组件模块。模块代码是执行在该模块的上下文中的，上下文中有着各种变量，其中就包括状态。通过“代理”组件的方式，就可以实现在同一个组件模块的上下文中，执行不同的函数组件。无论是新函数组件，还是旧函数组件，用的都是相同的状态，这就是状态复用。</p><p>那么组件所代表的原始视图的复用又指的是什么呢？</p><p>我们同样打个比方，假设现在你改动的组件要开始渲染 render 了。我们前面提到过，render 时判断是否要重新创建原生视图，是通过浅对比算法 shallowCompare 实现的。如果新旧组件的类型相等就走 re-update 的逻辑不创建，如果新旧组件的类型相等就走 re-mount 的逻辑重新创建。现在，新旧组件的“代理”是就是同一个对象，状态也不会发生改变，浅对比算法判断肯定相等，所以原生视图不会重新创建，从而实现了原生视图的复用。</p><p><strong>简而言之，React Native 的快速刷新功能，就是通过“代理”组件的方式，实现了组件状态不丢失，原生视图不重建。</strong></p><p>这里我放了快速刷新 babel 编译后的复用模型，可以帮助你理解复用的实现原理：</p><p><img src="https://static001.geekbang.org/resource/image/6e/a9/6eb61b9eb4d62b0519aed1a2a23e22a9.jpg?wh=1980x711" alt=""></p><p><strong>当然，并不是所有情况都会复用状态和原生视图。</strong></p><p>这又从何说起呢？我从组件类型的角度来给你解释。组件有两种类型：函数组件和类组件。</p><p>对于函数组件来说，hooks 的顺序非常重要，相同的状态下，不同的顺序会有不同的结果。如果你修改了 hooks 的顺序，快速刷新时就会重新初始化状态。在其他情况下，函数组件的快速刷新都会为你保留状态。</p><p>对于类组件来说，只要是类组件的代码发生更新，组件的内部状态都要重新初始化。关于这点，快速刷新功能的作者 Dan 在博客中解释到，“（保留类组件的状态）热重载是非常不可靠的，最大原因就是类组件的方法是可以被动态替换的。是的，在实例原型链上替换它们很简单，但是根据我的经验，有太多边缘情况了，它根本没有办法可靠地工作”。</p><blockquote>\n<p><a href="https://overreacted.io/my-wishlist-for-hot-reloading">The simple answer is “replace them on the prototype” but even with Proxies, in my experience there are too many gnarly edge cases for this to work reliably.</a></p>\n</blockquote><p>所以，我给你的建议是，<strong>尽可能地拥抱函数组件，放弃类组件</strong>。这样你在 UI 调试的时候，就能更多的享受函数组件带来的状态保留好处。特别是一些入口很深的组件，需要多次操作后才能调试，一旦导航、蒙层、滚动之类的组件状态丢失了，整个操作就要重新再来一遍，才能重新进行调试。拥抱函数组件，你的调试效率才会更高。</p><p>当然，如果项目中已经用到了很多类组件，又要调试一些入口很深的组件，怎么办？方法也很简单，你应该把你要调试的组件，单独拎出来调试。如果拎出来的组件和其他组件有依赖关系，也可以通过 mock 数据的形式对其依赖进行解耦，实现快速调试。</p><p>想象你已经理解快速刷新的基本原理，接下来我们会站在一个更高的视角，看一下快速刷新的完整策略。</p><h2>整体策略：逐步降级</h2><p>在编程调试时，有各式各样的代码，有函数组件、类组件、工具函数和常量等等。那么，是什么样的策略，能让你尽可能地快看到调试结果呢？</p><p>快速刷新的整体策略就是<strong>逐步降级</strong>。如果颗粒度最小的更新不能使用，就换成颗粒度大一些的更新：</p><ul>\n<li>代码块：如果你只修改了函数组件中的一些代码块，并且没有改动 hooks 的顺序。快速刷新在复用状态和原生视图的同时，你对该文件的所有修改都会生效，包括样式、渲染逻辑、事件处理、甚至一些副作用；</li>\n<li>组件：如果你修改了类组件中的任意代码，快速刷新会使用新的类组件进行重新渲染，原来的状态和原生视图都会被销毁；</li>\n<li>模块：如果你修改的模块导出的东西不只是 React 组件，快速刷新将重新执行该模块以及所有依赖它的模块；</li>\n<li>React Native 应用：如果你修改的文件被 React 组件树之外的模块引用了，快速刷新将重新渲染整个 React Native 应用。</li>\n</ul><p>可以看到，快速刷新的逐步降级策略是，<strong>从更新颗粒度最小代码块开始的，然后是组件、模块，最后是大颗粒度的 React Native 应用</strong>。越小颗粒度的更新，为我们保留了越多原来的状态和环境，我们的开发调试效率也更高。</p><p><img src="https://static001.geekbang.org/resource/image/a3/05/a3a4d0e37df1a44e1b3fb74b491c3d05.jpg?wh=1222x1080" alt=""></p><p>在调试的过程中，还会有奇奇怪怪的报错发生，比如语法错误、运行时错误和错误边界，这些错误快速刷新都帮你捕获到了。因此，快速刷新还有很强的鲁棒性。</p><h2>总结</h2><p>现在，再回到我们最初的话题，如何提高 UI 调试效率？我相信现在你已经有了答案。</p><p>调试 UI 最重要的是即使反馈和所码即所见。React Native 的快速刷新能力，会把我们的代码修改，尽可能快地展示出来。</p><p>能够实现快速刷新原因是，快速刷新能够通过模块热替换的方式，用我们修改后的新模块替换原来的旧模块。如果，该模块导出的是组件，那么“代理”组件就会将引用从旧组件切到新组件上，实现组件级别的刷新。如果，函数组件且 hooks 顺序没有发生改变，快速刷新时原有的组件状态也会保留。快速刷新时，越小颗粒度的更新，速度越快，调试效率更高。</p><p>要用好快速刷新功能，还有三个小技巧：</p><ol>\n<li>同屏预览。将模拟器置顶在编辑器上方，减少你视野来回切换频率；</li>\n<li>拥抱函数组件。函数组件能保留原有组件状态，减少你操作交互的次数；</li>\n<li>单独拎出来调试。单独拎出来先开发独立组件再集成，可能会比在层层嵌套的代码结构中开发效率更高。</li>\n</ol><h2>思考题</h2><p>今天这一讲介绍的主要介绍的是理论知识，我就不给你留作业了，请你思考一下为什么快速刷新功能的作者 Dan 认为，保留类组件的热重载非常不可靠的，但函数组件却是可行的？</p><p>欢迎在留言区写下你的想法。我是蒋宏伟，咱们下节课见。</p>',
        article_title: "09｜Fast Refresh：提高 UI 调试效率神器",
      },
      {
        title: "10｜Debug：解决 BUG 思路有哪些？",
        id: 508776,
        content:
          '<p>你好，我是蒋宏伟。</p><p>传说中，比尔盖茨在飞机上顺手撸一个 BASIC  解释器，不 Debug 就能直接跑起来。虽然比尔盖茨是“传说级”的程序员，但他写代码也是需要调试的。我们可以在维基百科的 <a href="https://www.quora.com/Are-there-programmers-who-write-virtually-bug-free-code">Altair BASIC </a>词条看到：</p><blockquote>\n<p>盖茨和艾伦从波士顿的分时租赁服务中购买了电脑上机时间来完成 BASIC 程序的调试。</p>\n</blockquote><p>但现实中，我们大部分情况都很难做到不 Debug，不调试就能把代码顺利上线，更多情况下，我们都需要和 Bug 做一番搏斗。</p><p>从搭建环境时 Gitlab 拉下来的代码跑不起来，到开发过程修改一段代码逻辑总是报错，再到产品上线后也时不时地有产品、测试、老板找过来反馈线上问题。无论是已经存在的、还是潜在的 Bug，这些都需要我们去发现和解决。不是有调侃的话么？我们程序员“不是在解决 Bug 的路上，就是在写 Bug 的路上”。</p><p>这话虽然只是一句调侃，但是这也侧面印证了两点：一方面是，我们会遇到很多 Bug，也会花很多时间去解决 Bug；另一方面是，我们直接裸写的代码可能存在较多的潜藏 Bug，我们得花精力把这些潜藏的 Bug 给找出来。那面对这些 Bug，有没有什么通用的解决思路呢？</p><p>这正是今天我要和你介绍的，我把它概括为“1+2+3”，也就是一个模型，两个原则，三条思路。</p><!-- [[[read_end]]] --><h2>一个模型：发现问题、找到原因、修复 Bug</h2><p>那么，一个模型是什么呢？</p><p>一个模型指的是，<strong>发现问题</strong>、<strong>找到原因</strong>、<strong>修复 Bug</strong> 的三步模型。其实这就是我们日常解决 Bug 的常规步骤，我只不过把它划分归类了一下，接着你就会看到划分的好处了。</p><p>虽然我们遇到的 Bug 形形色色、各不相同，但当你把解决问题划分为三步之后，我们就可以针对不同的步骤给出不同的解题思路了。每个 Bug 都有每个 Bug 修复的思路，但大部分的 Bug 在发现问题和找到原因这两步，是可以找到一些通用方法的。而我接下来要讲的“两个原则”，说的就是发现问题这一步的两个原则，“三条思路”说的就是找到原因这一步的三个思路，这些原则和思路都是通用的。</p><p>在发现问题和找到原因这两步中，我们也离不开团队成员的相互协作，以及各种调试工具支持。因此，在讲原则和思路的过程中，我也会和你介绍流程该怎么走，工具该怎么用。</p><p>另外，这里还需要你注意，狭义和广义调试是有所不同的。狭义的调试，指的是代码运行时打日志、打断点；但广义的调试，指的是发现问题和解决问题的过程（Debugging is the process of finding and resolving bug）。</p><p>任何能够帮助我们发现和解决问题的工具，都可以归类为广义的调试工具，甚至上线流程也是可以为调试服务的。当你把视野打开之后，思路也变广一些，这可以让你可以更快地、更容易地发现问题和解决问题。</p><p>我给你画了一张调试的全貌示意图，把调试的三步模型、上线流程和广义上的调试工具都画上去了。你先停下来看一下，接下来我也会进行更详细的介绍。</p><p><img src="https://static001.geekbang.org/resource/image/83/c0/8326a0d730d4ac2fd526ec02dc7125c0.png?wh=1504x1504" alt="图片"></p><h2>两个原则：不带上线原则和本地复现原则</h2><p>我先和你介绍发现问题这一步的两个原则：不带上线原则和本地复现原则。</p><ol>\n<li>不带上线原则：要尽可能早地在本地开发时发现问题，提前发现问题是不带 Bug 上线的必要条件；</li>\n<li>本地复现原则：如果 Bug 已经被带上线了，我们要尽快发现它，还要尽可能多地收集线上信息，让它能更容易地在自己的手机或本地复现。</li>\n</ol><p>不带上线原则怎么实践呢？首先，我们要清楚，没有任何的线上 Bug 是不可能的，但我们可以减少带上线的风险，比如团队成员之间可以通过合作建立一套完善的上线流程，依靠流程和机制来减少风险。其次，在这套流程和机制下，我们自己可以选择合适的工具来减少风险。</p><p>那么，一个理想的上线流程和配套工具是什么样的呢？我认为 GitHub 社区其实已经为我们提供了一种答案。</p><p>GitHub 社区中那些流行的仓库都有一套完整的上线流程，比如 React、React Native 仓库，一般都有<strong>自动化的本地校验和线上校验，还有项目成员的 Code Review</strong>。这套流程经历了上千人的校验，我认为是非常有学习和实践价值的。</p><p>在本地开发时，需要针对开发的新增的模块写一个新的单元测试。在提交代码的时候，有 git hook 的自动脚本来执行我们的 Jest 单元测试，并校验 TypeScript、ESLint 是否通过，只有校验通过之后才能提交。在提交到远程仓库后，还有机器人再校验一次，并且只有在机器人校验和项目成员的 Code Review 通过后才能把代码合到主分支。</p><p>而理想上线流程的另一套答案，其实也是大部分团队都在实践的答案。</p><p>当我们把新功能推到的代码仓库的主分支中，我们还需要把主分支中的代码进行上线。在上线过程中，我们需要靠 UI 验收、靠 QA 测试、靠 PM 体验，靠团队的力量来尽早发现 Bug。必要的时候，还可以在上线平台上下功夫，比如只有 QA 拥有上线权限，又比如做 A/B 测试、灰度测试等。</p><p>但即便如此，也难免会将一些本地 Bug 带上线，因此我们还需要快速发现线上 Bug。</p><p>大部分时候，那些线上的、偶现的、没有报错信息的 Bug，比本地的、必现的、有报错信息的 Bug，更加缺乏有效信息，也更难发现。对于线上 Bug 而言，<strong>快速发现线上 Bug关键是对线上数据的收集，并通过收集的数据来进行分析，使其能在本地复现</strong>。线上 Bug 本地复现之后，剩下的修复思路就和本地 Bug 的修复思路是一样的了。</p><p>这个时候，我们有两种工具可以利用，一种是监控系统，另一种是用户反馈系统。</p><p>在技术层面接入一套监控系统，比如腾讯出品的常用于原生应用监控的 Bugly，或者开源领域的 Sentry，又或者是自研的监控平台，这些都是可以的。在产品层面上，我们需要有一套用户反馈机制，它们的核心作用是发现那些本地难以复现、又缺乏线上报错数据的 Bug。</p><p>实际上，每个团队、每个项目的情况都不一样，你可以根据自己项目的情况进行选择。</p><h2>三条思路：一推理、二分法、三问人</h2><p>发现问题之后，接着就要寻找问题的原因。寻找问题的原因有哪些思路呢？我有 三条思路供你参考：“一推理”、“二分法”、“三问人”。</p><p>所谓的“一推理”，它指的是，我们遇到问题首先要做的是<strong>冷静地思考、分析和推理</strong>，要搞清楚问题是什么，知道问题是什么了，能直接解决的就自己直接解决，不要一开始就去网上搜答案。网上答案很多，但搜索正确答案成本很高，而且别人的答案不一定能解决你的问题。</p><p>你不妨先从红屏报错中提炼有用信息，再检查代码逻辑是否有明显错误并得出初步判断，然后打日志、打断点，再重新跑一次代码，验证你的判断。如果遇到的是复杂代码，可以从代码模块的出口入口着手来判断，然后再分析代码内部细节。在分析阶段中，我们也离不开（狭义）调试工具的支持。</p><ul>\n<li><strong>红屏信息：</strong><br>\n对于那些本地的、必现的、有红屏报错的 Bug 而言，红屏信息有时候能帮你直接指出是你的代码哪里有问题。</li>\n</ul><p>即便是那些没有提供具体报错代码的红屏报错，也会提供一些有用信息，只是这些有用信息需要你想一下才能分析出来。有些人在遇到红屏报错时，只是稍微看了一眼红屏信息，并不会去仔细地研究红屏信息内容，就直接动手开始改起代码了。这就相当于，有一份地图你不用，就直接闯起了迷宫。</p><p><strong>当你遇到红屏时，应该先认真读一遍红屏中的报错信息，第一遍没读懂没关系再多读几遍</strong>，英文不熟也不要紧，可以翻译一下，看看有什么关键字，再仔细想一下。很多时候，当你真的这么做了就找到原因了，不用后面那些分析步骤了。</p><ul>\n<li>\n<p><strong>检查逻辑：</strong><br>\n有时候呢，我们可以根据红屏提供的执行结果，猜出大致的问题范围。这时候呢，你可以先在脑袋里面过一遍代码执行过程，先检查一下自己是不是有拼写错误、API 的使用方法对不对、一些边际条件有没有考虑到等等。检查一遍之后，即便没有找到原因，心里多多少少会有一些判断。</p>\n</li>\n<li>\n<p><strong>执行代码：</strong><br>\n在你有这些判断后，你就可以通过打日志、打断点等方式来验证你的判断，找到到底是哪个变量或者是哪段逻辑有问题了。</p>\n</li>\n</ul><p>这里需要和你强调的是，不要一上来毫无头绪就开始打日志、打断点，这样做效率很低。<strong>一定要先检查代码、先判断原因，再去打日志、打断点去验证你的判断，这样你的调试能力、逻辑能力才会慢慢变强，调试速度才能慢慢提高。</strong></p><ul>\n<li><strong>出口入口：</strong><br>\n有时候代码太复杂了，代码内部执行的步骤太多了，要寻找是具体是哪段逻辑有问题就太难了。这时候，你可以先对代码的入口或出口的数据进行分析。比如，函数组件可能有问题，你可以通过工具查看元素树的结构和具体元素属性；又比如，前后端交互的请求可能有问题，你可以抓包看请求内容；再比如，本地磁盘存储结果有问题，你可以去查看存储结果。</li>\n</ul><p>从出口和入口开始分析先得出结论，再打日志、打断点定位问题原因，有时候可能比直接分析复杂代码的内部逻辑得出结论，要更快一些。</p><ul>\n<li><strong>分析工具：</strong><br>\n在分析阶段，必不可少的就是（狭义）调试工具，像打日志、打断点、抓包请求、查看存储这些功能都需要调试工具的支持。我给你画了一张调试工具功能图，涵盖了各类调试工具的支持程度：</li>\n</ul><p><img src="https://static001.geekbang.org/resource/image/ca/5c/ca825d7cdyy4d0513f8244bac454c45c.png?wh=1724x810" alt="图片"></p><p>我们简单分析下这几个工具。首先是弹窗 alert，它的好处是依赖任何环境，但一个弹窗能展示的内容太少了，只有在线上环境我才会用到它。</p><p>接着是终端 Terminal，你在本地通过 Terminal 启动打包工具 Metro 的服务时，你的调试代码就和 Terminal 建立了连接，你通过 console.log 打印的日志，都会在 Terminal 显示。使用它时，你不必单独下载其他任何的调试工具。据我所知，很多人排查问题只靠 Terminal 打日志，但实际上还有其他更好用的工具。</p><p>比如 Facebook 出品的移动应用调试工具 Flipper 就不错，但你需要单独进行下载。它的功能很强大，打日志、打断点、查看元素树、抓包请求、查看存储它都支持，而且支持扩展插件。</p><p>比较流行的调试工具还有 React Native Debugger、Reactotron，如果涉及原生代码，你还可用  Android Studio、Xcode 进行调试。</p><p>这些工具你不必每个都要学会怎么使用，选择几个你顺手的即可。工具只是辅助，关键是分析本身，调试工具只要够用就行。我平时用得比较多的是 Terminal 和 Flipper。</p><p>看完第一招，我们再来看第二招：“二分法”。</p><p>在你遇到不知道是什么原因引起的 Bug 时，你可以试试这招。<strong>所谓的“二分法”，</strong>说的是在我们不能确定问题原因的时候，<strong>把所有潜在的问题都用类似“数组二分查找”的方式把代码遍历一遍，</strong>不断缩小问题的范围，最终找到问题原因。</p><p>“二分法”怎么分呢？一个排除疑难杂症的通用思路是这样的，我们的代码是运行在环境中的，代码本身也有多个版本的、同一个版本中代码也是分多个模块的。那我们就可以从环境、版本、模块入手排查。</p><p>我们先把环境和代码分开，先排查环境原因，如果别人的电脑、手机都没有问题，我的有问题，那就可以判断是我的电脑、手机的环境有问题，否则就是代码问题。</p><p>如果是代码问题，我们再排查上一个上线版本有没有问题，上一次 commit 的代码有没有问题，如果上一次也有问题就是历史遗留问题，否则就是新引入的问题。</p><p>如果是新引入的问题，再从根组件开始排查，一个 React Native 应用（或页面）只有一个 Root 组件，一个 Root 组件有若干个子组件，子组件又有自己的子子组件，这就组成了一个组件树，你只要顺着 Root 组件一步一步地进行二分判断，看哪一边的子树是有问题的，哪一边的子树是没有问题的，最终就能确定问题代码的范围了。</p><p>“二分法”的思路是从整体到局部，它还有一个变种就是“多分法”。比如首屏性能问题，用户从点击、到请求、再到渲染的过程是一个整体，你可以把这个整体中各个阶段中的关键节点都埋上性能统计埋点，找到那些优化收益率高的、做起来容易的地方去优化。只有从整体的视角出发，分析出每个局部的优化空间有多少，你才能判断各个技术方案的投入产出比（ROI），做出全局最优的决定。</p><p>如果前面两招用完，还解决不了问题呢？不用着急，我们还有<strong>第三招：三问人。</strong></p><p><strong>所谓的“三问人”，说的是我们借鉴别人的经验来解决自己的问题，别人可以是同事、朋友、微信群，也可以是搜索引擎。</strong></p><p>搜索引擎相信你也经常用，所以我只和你重点说一下我的使用技巧和经验。</p><p>首先，Google 搜到的资料更全一些有博客、论坛、GitHub、学习型网站，百度搜到的大多是国内开发者的博客。另一类就是专业的技术网站，比如 GitHub 和 Stack Overflow，这类专业技术提供的搜索引擎的搜索效率，有时候比 Google 还要更高一些。有时候我在 Google 搜索出的内容不是我想要的，我就会跑到 GitHub 的 React Native 仓库的 Issues 中和 Stack Overflow 上直接搜索，它们推荐的内容就会更加精准一些。</p><p>有些英语差的同学可以会觉得，使用 Google、GitHub 这类以英文为主的网站，语言是个门槛。我的建议是你多用翻译引擎，使用工具来打破这个语言门槛。你不着急的时候，英语文章可以一个词地一个词地慢慢看，这也能提升自己的英语水平，但工作中毕竟是以效率优先，我推荐你使用 DeepL 翻译引擎，在 DeepL 的宣传资料中，它的中英互译的准确性比 Google 等翻译引擎要强上 5 倍，我的实际使用感受也确实是准确很多。</p><h2>课程小结</h2><p>广义上讲，调试就是发现问题和解决问题。那如何调试呢？我有 “一个模型、两个原则、三条思路”和你分享。</p><ul>\n<li>一个模型：这个模型包括，调试的三个步骤发现问题、找到原因、修复 Bug，还包括配套的广义调试工具、团队上线流程。这个广义的调试模型，相对于狭义上的调试，它的意义在于能帮我们扩宽解决 Bug 的思路；</li>\n<li>两个原则：这两个原则是不带上线原则和本地复现原则。不带上线原则强调的是，调试不仅仅是解决问题，更是提前发现问题减少线上 Bug；本地复现原则强调的是，解决线上 Bug 的关键是能在本地复现问题，而复现问题很依赖监控系统和反馈系统；</li>\n<li>三条思路：你可以先用“一推理”，再用“二分法”、最后是“三问人”来解决具体 Bug 。</li>\n</ul><h2>补充材料</h2><p><strong>自带工具：</strong></p><ul>\n<li><a href="https://reactnative.dev/blog/2019/11/18/react-native-doctor">react-native doctor</a>：可以帮忙检查本地环境是否搭建是否有问题。</li>\n<li><a href="https://reactnative.dev/docs/debugging#performance-monitor">Perf Monitor</a>：调试情况下摇一摇手机，就会有一个弹窗，其中 Perf Monitor 功能可以帮你查看本地的 JavaScript FPS  和 Native FPS。</li>\n<li><a href="https://reactnative.dev/docs/debugging#inspecting-component-instances">Inspect</a>：摇一摇中的 Inspect 功能，可以帮我们查看组件树的结构。</li>\n</ul><p><strong>搜索工具：</strong></p><ul>\n<li>翻译：<a href="https://www.deepl.com/translator">DeepL</a>、谷歌翻译  百度翻译。DeepL 还有客户端，配合快捷键使用更方便。</li>\n<li>搜索：谷歌搜索、百度搜索</li>\n<li>专业网站：<a href="https://github.com/facebook/react-native/search?type=issues">React Native GitHub Issues</a>、<a href="https://stackoverflow.com/">Stack Overflow</a></li>\n</ul><p><strong>第三方工具：</strong></p><ul>\n<li><strong>（推荐）Facebook 推出的移动应用调试工具</strong><a href="https://fbflipper.com/">Flipper</a>；</li>\n<li>（不推荐）微软推出的 VSCode 插件 <a href="https://marketplace.visualstudio.com/items?itemName=msjsdiag.vscode-react-native">React Native Tools</a>；</li>\n<li>（不推荐）Infinitered 推出的 <a href="https://github.com/infinitered/reactotron">Reactotron</a>；</li>\n<li>（不推荐）<a href="https://github.com/jhen0409/react-native-debugger">React Native Debugger</a>。</li>\n</ul><h2>作业</h2><ul>\n<li>平时你用的调试工具是什么？你为什么选择它？</li>\n<li>结合这一讲提供的  “一个模型、两个原则、三条思路”，思考一下，你遇到过那些疑难杂症，最终你是怎么解决它的？</li>\n</ul><p>欢迎在评论区写下你的思考和想法。我是蒋宏伟，咱们下节课见。</p>',
        article_title: "10｜Debug：解决 BUG 思路有哪些？",
      },
      {
        title: "11｜组件实战：如何实现瀑布流？",
        id: 509753,
        content:
          '<p>你好，我是蒋宏伟。</p><p>现在，国内购物 App 的首页大都采用了双列瀑布流的布局，假如你的产品经理也想实现同样的瀑布流效果，你在网上找了很多的 React Native 列表组件，但都满足不了需求，你会怎么办？你会选择改让产品改方案，还是自己再研究研究？</p><p>大概是 2019 年的时候，我们的产品也提了同样的需求，使用 React Native 实现瀑布流效果。当时我们有个同事试了很多方案，比如双 List、多层嵌套 List，性能都很差效果不好，后来我们开会的时候提到了这个问题，我也参与了讨论。</p><p>当时我提出了一种思路：改 RecyclerListView 的源码。我说，RecyclerListView 的布局原理是绝对定位，每个 item 的 x、y 轴坐标是根据传入的 height、width 值算出来的，现在它的布局算法是单列的，我们只要把单列布局算法改成双列布局算法，这件事情应该能成。</p><p>后来我们团队的另一个大牛把它落地实现了，实现了一个 React Native 瀑布流页面。</p><p>在准备写实战案例的时候，我又想起了当初的这个事情。使用瀑布流的业务场景很多，却没有直接能用的开源方案，但它的实现原理其实并不复杂，应该是一个很好的实战案例。于是我就基于 RecyclerListView 最新的版本，又实现了一版。</p><!-- [[[read_end]]] --><p>我今天就和你讲讲，我是如何通过修改 RecyclerListView 组件的源码，实现瀑布流效果的。希望你能通过这次实战，把我们以前学的知识和技巧都用起来。也只有通过实战才能<strong>把知识变成能力</strong>，快和我一起动手试试吧。</p><h2>准备开发调试环境</h2><p>关于 RecyclerListView 的基础用法，我在《List》一讲中已经介绍，它主要是通过列表数据 dataProvider 来驱动列表项的渲染 rowRenderer，并且指定为列表项指定了布局方式 layoutProvider。</p><p>现在，你需要做的是准备开发调试环境。准备开发调试环境永远是第一步，而且现在我们要调试的是放在 node_modeuls 目录下的第三方组件 RecyclerListView，所以现在我们要准备<strong>第三方依赖包的开发调试环境</strong>，这怎么准备呢？</p><p>在 React Native 中，我们是通过 import 导入第三方模块 RecyclerListView 的：</p><pre><code class="language-plain">import {RecyclerListView, DataProvider, LayoutProvider} from \'recyclerlistview\';\n</code></pre><p>这段代码的意思是从<code>recyclerlistview</code>模块中导入 RecyclerListView 组件、DataProvider 列表数据类、LayoutProvider 布局方式类。</p><p>那<code>recyclerlistview</code>模块到底在哪呢？通常情况下，该模块是<code>node_modules/recyclerlistview</code>目录下的 <code>index.js</code>文件<code>export</code>导出的模块。不过第三方库，也可以通过<code>package.json</code>中的<code>main</code>字段进行配置。<code>recyclerlistview</code>采用的就是这种配置方法：</p><pre><code class="language-plain">// node_modules/recyclerlistview/package.json\n{\n  "name": "recyclerlistview",\n  "main": "dist/reactnative/index.js",\n  ...\n}\n</code></pre><p>你看，在<code>recyclerlistview</code>的<code>package.json</code>文件中，它通过<code>main</code>参数指定了模块路径<code>dist/reactnative/index.js</code>。</p><p>但你再看下 <code>recyclerlistview</code> 的目录：</p><pre><code class="language-plain">node_modules/recyclerlistview/\n├── dist\n│   └── reactnative\n│       ├── core\n│       └── index.js\n├── src\n│   ├── core\n│   └── index.ts\n└── package.json\n</code></pre><p>你会发现，<code>dist</code>目录下放的是编译后的 .js 文件。也就是说，如果我们直接跑项目，只能调试编译后的 .js 文件，不能调试放在 <code>src</code> 目录中的 .ts 源码。</p><p>那怎样才能调试 .ts 的源码文件呢？有一招很简单，修改 <code>recyclerlistview</code> 的导出模块的配置：</p><pre><code class="language-plain">// node_modules/recyclerlistview/package.json\n\n- "main": "dist/reactnative/index.js"\n+ "main": "src/index.ts"\n</code></pre><p>你只需把<code>recyclerlistview/package.json</code>的 <code>main</code>参数改为<code>src/index.ts</code>即可，React Native 会在编译时通过 babel 将 .ts、.tsx 文件编译为 .js 文件再执行。</p><p>改完之后，你再重新跑一次<code>yarn start</code> ，会遇到一个报错：</p><pre><code class="language-plain">error: node_modules/recyclerlistview/src/core/RecyclerListView.tsx: \n\n`import debounce = require(\'lodash.debounce\')` is not supported by @babel/plugin-transform-typescript\n\nPlease consider using `import debounce from \'lodash.debounce\';` alongside Typescript\'s --allowSyntheticDefaultImports option.\n\n&gt; 21 | import debounce = require(\'lodash.debounce\');\n     | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n</code></pre><p>现在我们来分析这个报错信息。你还记得解决具体 BUG 的顺序吗？“一推理”、“二分法”、“三问人”。</p><p>遇到报错先不用着急去网上搜，先看看红屏的报错提示。第一行报错，说的是<code>core/RecyclerListView.tsx</code>文件中有报错。第二行，说的是 <code>@babel/plugin-transform-typescript</code> 插件不支持 <code>import = require()</code> 的导入语法。第三行，直接把建议答案告诉你了，你可以用<code>import from</code>的语法进行导入。第四行，提示了具体是哪行代码报错了。</p><p>你看，这类报错信息都把答案都告诉我们了，我们只要认真读一下就行，我们的“一推理”刚刚开始，就把这个 BUG 解决了，都用不着后面的“二分法”和“三问人”。</p><p>在你把代码跑起来后，还需要准备一下调试工具 Flipper 和 React Native Tool。</p><p>Flipper 调试工具，你只需要下载一下就行，它的功能很强大：</p><p><img src="https://static001.geekbang.org/resource/image/e4/d1/e4e1f3a26e124dd4c582342ayy70b7d1.png?wh=1726x3472" alt="图片"></p><p>这张长截图显示了 Flipper 的功能，从上到下依次是打印日志 Logs、组件树 Components、性能火焰图 Profiler、宿主组件树和布局 Layout、网络请求 Network。它还有一个功能是支持 Hermes 引擎 Debugger，它和浏览器的 Debugger 类似，这里我没有进行截图了。</p><p>现在 RecyclerListView 源码已经跑起来了，调试环境也已经准备完成，接着下一步就是找到控制布局的关键源码。</p><h2>找到关键源码</h2><p>要找到关键源码，我们得先从整体上理解源码。很多人读源码没有方法，不知道从哪里入手，甚至有些程序员从来没有读过别人的源码。其实写代码和读代码，就像写文章和读文章的关系一样，<strong>没有大量的阅读积累，怎<strong><strong>么</strong></strong>能写出好的代码呢？</strong></p><p>理解 RecyclerListView 这类复合组件的源码，我有一个技巧，就是从复合组件 JSX 部分开始切入。</p><p>这时我们能直接观察到的是 UI 视图，以 UI 视图为锚点，去理解 JSX 文件就很容易了。在你了解  JSX 之后，再根据状态 <code>state</code> 和属性<code>props</code>去推断组件的内部逻辑 <code>f</code> ，会容易很多。一个页面，无非也就是由这几个部分组成：</p><pre><code class="language-plain">UI/JSX = f(state, props)\n</code></pre><p>了解了基本方法，现在我们开始分析RecyclerListView组件的源码，请你先<strong>在本地打开</strong> <a href="https://github.com/Flipkart/recyclerlistview/blob/master/src/core/RecyclerListView.tsx">RecyclerListView 的源码文件</a>。下面是我从 RecyclerListView 类组件摘出来的 3 个和 JSX 相关的方法：</p><pre><code class="language-plain">// node_modules/recyclerlistview/src/core/RecyclerListView.tsx\npublic renderCompat() { // 先调用 render 后调用它\n  return (\n    &lt;ScrollComponent&gt;\n      {this._generateRenderStack()}\n    &lt;/ScrollComponent&gt;\n  );    \n}\n\nprivate _generateRenderStack(){\n  for(const key in this.state.renderStack){\n    renderedItems.push(this._renderRowUsingMeta(this.state.renderStack[key]))      \n  }\n  return renderedItems\n}\n\nprivate _renderRowUsingMeta() {return &lt;ViewRenderer/&gt;}\n</code></pre><p>它们分别是：</p><ul>\n<li><code>renderCompat</code> 方法：实际就是类组件的 <code>render</code>方法，它最外层是一个滚动组件<code>ScrollComponent</code> ；</li>\n<li><code>_generateRenderStack</code>方法：循环了状态 <code>state.renderStack</code>，生成了若干个<code>renderedItems</code>；</li>\n<li><code>_renderRowUsingMeta</code> 方法：返回的是具体的<code>renderedItems</code> ，也就是<code>ViewRenderer</code>容器元素。</li>\n</ul><p>当你把 UI 视图和 JSX 部分联系在一起时你就明白了，RecyclerListView 渲染出的 UI 页面，是由一个滚动容器和若干个<code>ViewRenderer</code>容器组成的。</p><p>我们还是回到最基础的 UI 公式：</p><pre><code class="language-plain">UI/JSX = f(state, props)\n</code></pre><p>现在我们已知 <strong>JSX</strong> 是 ScrollView + View，已知 <strong>state</strong> 是用 <code>for...in</code>循环的对象 renderStack，还已知 RecyclerListView 的三个必传 <strong>props</strong>：列表数据 dataProvider(dp)、列表项的布局方法 layoutProvider、列表项的渲染函数 rowRenderer。</p><p>这时虽然你还不知道组件内部逻辑 <code>f</code> 具体是什么，但是你应该已经把握住了函数的“入口”和“出口”，你知道放进去的入参是什么，能够产出的 UI 又是什么。知道了“入口”“出口”的特点后，再从两端往中间推理，理解组件内部逻辑 <code>f</code>就会变得简单很多。</p><p>这时候，你可能会有一些关于内部逻辑<code>f</code>的问题，你或许想问<code>state.renderStack</code>和三个 props 是怎么控制 JSX 的？</p><p>那我们就要再仔细读一下<code>_renderRowUsingMeta</code>中的代码了：</p><pre><code class="language-plain">private _renderRowUsingMeta(itemMeta: RenderStackItem): JSX.Element | null {\n  const dataIndex = itemMeta.dataIndex;\n  const data = this.props.dataProvider.getDataForIndex(dataIndex);\n  const type = this.props.layoutProvider.getLayoutTypeForIndex(dataIndex);\n  return (\n    &lt;ViewRenderer\n      data={data}\n      layoutType={type}\n      index={dataIndex}\n      layoutProvider={this.props.layoutProvider}\n      childRenderer={this.props.rowRenderer}\n    /&gt;\n  );\n}\n</code></pre><p>在这段源码中，我只标记出了 state、props 和 ViewRenderer 三个部分，即便只有这些代码片段，你可以猜出它的大致逻辑。</p><p>状态 <code>state.renderStack[key]</code> 就是 <code>itemMeta</code>，每个 <code>itemMeta</code> 的 <code>dataIndex</code> 是不一样的，通过 <code>dataIndex</code> 从列表数据 dataProvider  和布局方法 layoutProvider 中，选取了对应项的数据 <code>data</code> 和布局类型 <code>type</code> ，并将这些值和列表项的渲染函数 rowRenderer 都赋值给了 <code>ViewRenderer</code>的<code>childRenderer</code>属性。</p><p>读完这段源码片段，你大概能够补全此段代码的内部逻辑<code>f</code>。<code>ViewRenderer</code> 是一个容器，内部装的是你传给它的渲染函数 rowRenderer 方法，并且按照你指定的数据<code>data</code>、类型<code>type</code> 进行渲染。</p><p>因为<code>ViewRenderer</code>是你指定的列表项<code>rowRenderer</code>的父容器，父容器的位置决定了你列表项的位置。这时候，你再读一遍<code>_renderRowUsingMeta</code>的源码：</p><pre><code class="language-plain">  private _renderRowUsingMeta(itemMeta: RenderStackItem): JSX.Element | null {\n    const dataSize = this.props.dataProvider.getSize();\n    const dataIndex = itemMeta.dataIndex;\n    const itemRect = (\n    this._virtualRenderer.getLayoutManager() as LayoutManager\n    ).getLayouts()[dataIndex];\n    return (\n      &lt;ViewRenderer\n        key={key}\n        data={data}\n        x={itemRect.x}\n        y={itemRect.y}\n        layoutType={type}\n        index={dataIndex}\n        layoutProvider={this.props.layoutProvider}\n        onSizeChanged={this._onViewContainerSizeChange}\n        childRenderer={this.props.rowRenderer}\n        height={itemRect.height}\n        width={itemRect.width}\n      /&gt;\n    );\n  }\n</code></pre><p>在这个源码片段中，这些由<code>LayoutManager</code>类的<code>getLayouts</code>方法生成的 x/y/width/height 属性，就是决定你列表项布局方式的关键源码。</p><p>但 <code>getLayouts</code> 到底是什么呢？请你打开 <code>LayoutManager</code> 类的源码：</p><pre><code class="language-plain">// node_modules/recyclerlistview/src/core/layoutmanager/LayoutManager.ts   \n   public getLayouts(): Layout[] {\n        return this._layouts;\n   }\n\n    public relayoutFromIndex(): void {\n        let startX = 0;\n        let startY = 0;\n        let maxBound = 0;\n\n        for () {\n            oldLayout = this._layouts[i];\n            if () {\n                itemDim.height = oldLayout.height;\n                itemDim.width = oldLayout.width;\n                maxBound = 0;\n            }\n            while () {\n                startX = 0;\n                startY += maxBound;\n            }\n\n            maxBound = Math.max(maxBound, itemDim.height);\n            this._layouts.push({ x: startX, y: startY, height: itemDim.height, width: itemDim.width, type: layoutType });\n\n        }\n    }\n</code></pre><p>上述的代码片段是 <code>getLayouts</code> 方法和设置<code>this._layouts</code>的<code>relayoutFromIndex</code>方法。大致扫一眼，你就能明白<code>relayoutFromIndex</code>方法通过一堆计算，计算出了实现单列布局的 x/y/height/width 值，然后把它们作为对象 push 到了 <code>this._layouts</code>。</p><p>而 ViewRenderer 根据 <code>this._layouts</code> 把你的列表项，渲染到了指定的位置上。因此，我们要想实现双列瀑布流布局，就得理解和修改 <code>relayoutFromIndex</code> 方法。</p><h2>修改源码</h2><p>在“找到关键源码”这一步，我们读源码其实只要有宏观上的理解就行了，但要“修改别人源码”就需要更微观上的理解了。</p><p>我说的宏观上理解源码，讲究的是速度，大致理解就行，细节上有点小偏差也不要紧。但微观上理解源码，讲究的是准确，我们要改别人的源码，理解要是不准确，改起来肯定容易出问题。</p><p>在提高理解的准确性上，我是这么做的。首先我会使用断点工具，一行一行地执行代码，并对上下文中的变量进行一些“终极拷问”：“变量从哪来”、“变量用到哪里去”、“变量的意义是什么”，再把自己的理解马上备注起来，不然容易忘。</p><p>在微观理解上，我们也要找到切入点。比如，在理解 <code>relayoutFromIndex</code> 方法时，我找的切入点就是设置列表项的 x/y。设置 x/y 的核心代码如下：</p><pre><code class="language-plain">  public relayoutFromIndex(itemCount: number): void {\n    // 新 item x y 坐标\n    let startX = 0;\n    let startY = 0;\n    // 记录当前一行最高元素的高度\n    let maxBound = 0;\n\n    for (let i = 0; i &lt; itemCount; i++) {\n\n      // 如果当前多个 item 宽度之和超过屏幕宽度就换行\n      while (!this._checkBounds(startX, startY, this._layouts[i])) {\n        // 将实际 x 坐标设置为 0\n        startX = 0;\n        // 将实际 y 坐标设置增加上一行最高 item 的高度\n        startY += maxBound;\n        maxBound = 0;\n      }\n\n      // 设置新的宽高\n      this._layouts.push({ x: startX, y: startY, height: itemDim.height, width: itemDim.width, type: layoutType });\n\n      // 记录当前一行最高 item 的高度\n      maxBound =  Math.max(maxBound, this._layouts[i].height);\n      // 默认情况下：下一个 item 的初始化的 x 坐标\n      startX += itemDim.width;\n    }\n  }\n  private _checkBounds(\n    itemX: number,\n    itemY: number,\n    itemDim: Dimension,\n  ): boolean {\n    return itemX + itemDim.width &lt;= this._window.width;\n  }\n</code></pre><p>虽然我已经把代码精简并写了备注，但理解起来可能还是有点难度，所以我还给你配了单列布局的原理示意图：</p><p><img src="https://static001.geekbang.org/resource/image/c0/a8/c03b10ea793948d7f280072a857964a8.png?wh=1920x556" alt="图片"></p><p>单列布局的原理是什么呢？</p><p>从代码层面看，它对你传入的列表项进行<code>for</code>循环遍历，并通过 <code>_checkBounds</code>方法来判断。如果当前遍历的列表项宽度和当前一列已有列表项的宽度之和，不超过屏幕宽度，也就是<code>itemX + itemDim.width &lt;= this._window.width</code>，那么就跳过 <code>while</code> 循环，直接使用同一行前几个列表项的宽度之和<code>startX += itemDim.width</code> ，作为当前列表项的 x(startX) 坐标。也就是情况一：<strong>宽度足够，放到同一行。</strong></p><p>如果<code>_checkBounds</code>判断，同一行剩余宽度不够了，那么就进入  <code>while</code> 循环，将当前列表项的 x(startX) 坐标设置为 0，y 坐标设置增加上一行最高 item 的高度<code>maxBound</code>。也就是情况二：<strong>宽度不够，放到下一行。</strong></p><p>我还在图中给你画了一个单列布局的例子。第一行 A、B 列表项宽度正好占满整个屏幕宽度，所以列表项 C 得再起一行，其 x 坐标为 0，其 y 坐标为 A 的 y 坐标和 B 的高度 height 之和。列表项 C 横向独占了一行，所以 D、E 就只能放到下一行了。整体上看，RecyclerListView 实现的还是一种单列布局，只不过同一行中可以放置多个列表项。</p><p>理解完 RecyclerListView 的单列布局源码后，接下来就要设计我们自己的双列瀑布流布局了。我给你画了一张瀑布流的示意图：</p><p><img src="https://static001.geekbang.org/resource/image/93/9c/938fbe382fc3438c4ee41ed01c8eab9c.png?wh=1920x548" alt="图片"></p><p>双列瀑布流布局只有两种情况，第一种情况是如果左边已有列表项的高度之和  <code>startLeftY</code> 大于右边已有列表项的高度之和 <code>startRightY</code>，那么下一个列表项就要放右边。第二种情况则刚好相反，我们需要把下一个列表项放在左边。简单来说就是，<strong>左高放右、右高放左。</strong></p><p>我同样给你举了一个例子，你可以对照双列瀑布流布局的图片看一下。起始时左右两边一样高，所以先是左 A，再是右 B。接下来，由于左边比右边高，所以再是右 C，最后是左 D。如果是单列布局，C 应该放在左边，D 应该放在右边，这就是双列瀑布流布局和单列布局不同之处。</p><p>双列瀑布流实现的核心代码如下：</p><pre><code class="language-plain">  public relayoutFromIndex(startIndex: number, itemCount: number): void {\n\n    // 假设: 每个 item 的宽度为 1/2*window.width 两种情况\n    const halfWindowWidth = this._window.width / 2;\n\n    let startLeftY = 0; // 左边所有 item 的高度之和\n    let startRightY = 0; // 右边所有 item 的高度之和\n\n    let startX = 0; // 新增 item 的 X\n    let startY = 0; // 新增 item 的 Y\n\n    for (let i = startIndex; i &lt; itemCount; i++) {\n      itemDim.height = oldLayout.height;\n      itemDim.width = halfWindowWidth;\n\n      // 保证一行中所有的 item 宽度之和不超过屏幕宽度，超过就换行\n      if (startLeftY &gt; startRightY) {\n        startX = halfWindowWidth;\n        startY = startRightY;\n        startRightY += itemDim.height;\n      } else {\n        startX = 0;\n        startY = startLeftY;\n        startLeftY += itemDim.height;\n      }\n\n      // 如果是 item 是新增的，在添加新的 layout\n      this._layouts.push({x: startX, y: startY, height: itemDim.height, width: itemDim.width, type: layoutType,});\n  }\n</code></pre><p>首先，双列瀑布流有一个假设，假设每个列表项的宽度为屏幕的一半。其次，我们还需要记录左边的高度之和<code>startLeftY</code>和右边的高度之和<code>startRightY</code>。在<code>for</code>遍历列表项时，如果左边高 <code>startLeftY &gt; startRightY</code>，那么当前列表项放右边<code>startX = halfWindowWidth</code>，否则当前列表项放左边<code>startX = 0</code>，同时记录最新的左边/右边高度之和。最后把当前列表项 push 到 <code>this._layouts</code> 中。</p><p>将单列布局改为双列瀑布流布局，改动的代码量很少，你可以现在就动手试一试。我也将我改动的代码前后对比图，放在了下面，你可以参考一下：</p><p><img src="https://static001.geekbang.org/resource/image/3b/b1/3b0cbcb54e6e06fd52b7fe0d5d1f35b1.png?wh=1920x3413" alt="图片"></p><h2>保存修改</h2><p>现在，我们来到了最后一步保存修改的源码。</p><p>在修改完 node_modules 中的源码后，如果不进行保存，很有可能就会丢失。并且，有时候我们需要和同事进行合作，同事也需要我们修改后的代码，又或者是在使用上线平台进行打包时，也需要将修改后的 node_modules 源码同步给上线平台一份。本地修改 node_modules 源码后，不保存、不同步肯定会出线上问题。</p><p>怎么把修改好的 node_modules 代码保存呢？有三种思路：</p><p>第一种<strong>直接复制源码</strong>。但复制源码后续想要升级 RecyclerListview 的版本会非常困难，每次升级可能面临的是一次重新改造。</p><p>第二种<strong>在运行时进行修改</strong>。这种方法对源码的侵入性小，但每次升级前我们还是需要手动检查一下的，不然相关代码逻辑有变化，我们的修改就会受到影响。</p><p>我在这次实战中，采用的就是在运行时进行修改的方案。我观察了一下 RecyclerListview 的代码，它的代码风格是面向对象的编程风格，几乎把所有的内部类都暴露出来了。</p><p>但由于它 LayoutManager 类的所有属性是私有属性，我没办法通过继承的方式读取到 LayoutManager 的私有属性。</p><p>因此我复制了 <code>LayoutManager</code> 和 <code>layoutProvider</code> 类，并将其重写为 <code>WaterfallLayoutManager</code> 和 <code>WaterfallLayoutProvider</code>。</p><p>当你的列表是单列布局时，就应该使用<code>layoutProvider</code>类 ，当你的列表是双列瀑布流布局时，就可以使用我创建的<code>WaterfallLayoutProvider</code>类。</p><p>第三种<strong>在编译时修改</strong>。这里利用的是 <code>patch-package</code> 即时修复第三方 npm 包的能力，它的原理是先对你的修改进行保存，然后在你每次安装 npm 包的时候把你原先的修改给注入进去，也就是 patch package。它是侵入式的修改方式，步骤如下：</p><p>在修改完 node_modules 目录下的 RecyclerListview 文件后，你直接运行如下命令：</p><pre><code class="language-plain">$ npx patch-package some-package\n</code></pre><p>这时你修改的代码就会以 patch 文件的形式进行保存，patch 文件的示例代码如下：</p><pre><code class="language-plain">diff --git a/node_modules/recyclerlistview/src/core/layoutmanager/LayoutManager.ts b/node_modules/recyclerlistview/src/core/layoutmanager/LayoutManager.ts\nindex e9454a4..3168330 100644\n\n--- a/node_modules/recyclerlistview/src/core/layoutmanager/LayoutManager.ts\n+++ b/node_modules/recyclerlistview/src/core/layoutmanager/LayoutManager.ts\n\n@@ -95,75 +95,113 @@ export class WrapGridLayoutManager extends LayoutManager {\n         }\n     }\n\n-    public relayoutFromIndex(startIndex: number, itemCount: number): void {\n\n+  // startIndex：从第几个 item 开始有了更新，从这个 item 开始算，目的是为了减少计算量。默认：0\n+  // itemCount: 一共多个 item。\n+  // 以下注释只考虑垂直滚动，水平滚动同理。\n+  public relayoutFromIndex(startIndex: number, itemCount: number): void {\n\n     private _pointDimensionsToRect(itemRect: Layout): void {\n         if (this._isHorizontal) {\n</code></pre><p>那如果别人想用你瀑布流版本的 RecyclerListview 怎么办呢？首先，你需要修改 package.json 文件：</p><pre><code class="language-plain"> // package.json\n "scripts": {\n+  "postinstall": "patch-package"\n }\n</code></pre><p>然后将修改后的 package.json 和前面自动生成的 patch 文件用 Gitlab/GitHub 保存起来。</p><p>这样，你同事下载最新代码，再执行 <code>npm install</code> 或 <code>yarn</code> 命令后，就会自动触发 <code>pathc-package</code> 命令。 <code>pathc-package</code> 命令会利用你生成的 patch 文件，将官方的 RecyclerListview 修改成你的瀑布流版本的 RecyclerListview。</p><p>一般来说，无论是快速修改第三方组件源码，还是修改 React Native 的 JavaScript 层的源码，我都不建议使用第一种直接复制源码的方式。我会<strong>优先考虑在运行时的修改方法</strong>，通常该方案改动最小、侵入性也最小。<strong>如果运行时方案改不了，我才会考虑有侵入性的编译时的</strong><code>pathc-package</code><strong>方案。</strong></p><h2>总结</h2><p>在前面的课程中，我讲的大多是概念性的知识，要消化这些概念性的知识就必须要有练习，所以我在每节课中都给你留了一道实操的练习题，目的就是帮你把知识内化为能力。这一讲中，我准备的实战案例也是为了让你把前几讲中学习到的知识灵活运用起来。</p><p>首先你需要提前准备好写代码时会用到调试工具 Flipper ，并灵活运行“一推理”、“二分法”、“三问人”的思路来解决过程中遇到的问题。</p><p>在理解别人的组件代码时，利用 <code>UI/JSX = f(state, props)</code> 这个最基本 React/React Native 原理，先找到实现 UI 的 JSX 部分，再找到 state、props，然后再理解逻辑 <code>f</code> 的部分。</p><p>在修改别人的逻辑代码时，先通过调试工具来理解各个变量上下文含义，理清楚别人的逻辑后，再根据自己目的进行修改。</p><p>最后要意识到，你修改的是别人的源码，你可以通过运行时、编译时两种方案把其保存下来。</p><h2>附加材料</h2><ol>\n<li><a href="https://github.com/ds300/patch-package">patch-package</a> 可以帮你保存对第三方模块的问题修复。</li>\n<li>本节课的源码，我放在了<a href="https://github.com/jiangleo/react-native-classroom/tree/main/src/11_Waterfall">GitHub</a>中。</li>\n</ol><h2>作业</h2><ol>\n<li>请你根据这节课的资料，实现一个三列瀑布流布局。</li>\n<li>你觉得阅读源码，有什么意义？</li>\n</ol><p>欢迎在评论区写下你的想法。我是蒋宏伟，咱们下节课见。</p>',
        article_title: "11｜组件实战：如何实现瀑布流？",
      },
      {
        title: "12｜页面实战：如何搭建一个电商首页？",
        id: 510659,
        content:
          '<p>你好，我是蒋宏伟。</p><p>今天这一讲就是基础篇中的最后一讲了，还记得我在基础篇的第一讲中和你说的吗？刚刚开始学习的时候，不要一头扎进技术的细节中去学习，应该拿起 React Native 的知识地图先看看，知道自己学习的方向并给自己树立一个学习目标。</p><p>现在，我们的基础篇一个月的学习已经接近尾声了，是时候给自己做一个阶段性的总结了！回头看看，自己当初的学习目标有没有达成，又有哪些知识掌握得好，还有哪些知识还需要补足。</p><p>俗话说，实践是检验真理的唯一标准。还记得我们在<a href="https://time.geekbang.org/column/article/499446">01讲</a>中制定的学习目标吗？当初我们的学习计划，就是能够使用 React Native 搭建一个简易的电商首页。因此，基础篇的大作业就是“搭建一个简易的电商首页”，希望你能够认真完成这次大作业，好好检查一下自己都学到了什么。</p><p>这一讲，我不会讲具体的代码实现，主要讲的是我在“搭建一个简易的电商首页”时的技术设计思路，希望我的思路能够对你的实现基础篇的大作业有所帮助。</p><p>建议你在学完这一讲后，先参考这一讲的思路自己实现一遍，然后再去看 <a href="https://github.com/jiangleo/react-native-classroom/tree/main/src/12_HomePage">GitHub</a> 上的参考答案。</p><h2>简易电商首页</h2><p>为了让开发这个简易电商首页显得更有意思一些，我先从产品角度给你讲讲它的背景。</p><p>故事是这样的，你的老板最近赶上了 NFT（非同质化代币，Non-Fungible Token）的风口，现在卖 JPG 也能赚大钱了，老板靠着这个点子融来了一笔钱，准备大干一场。你的老板让产品和 UI 同学参考业内的电商 App，做出了一个设计原型，接着就轮到你上场了。</p><!-- [[[read_end]]] --><p>你作为团队中的核心成员，分配到的任务是<strong>搭建 App 的首页</strong>，App 的其他部分由其他同事负责。考虑到要快速上线，你技术领导准备<strong>用 React Native 来实现</strong>，现在是你大展身手的时候了。</p><p>团队的设计同学，这时候把首页设计稿交付到你了，设计稿如下：</p><p><img src="https://static001.geekbang.org/resource/image/55/ec/55a408bf485f7c829c124880de81b5ec.png?wh=1568x2136" alt="图片"></p><p>你可以看到，App 首页的主要功能包括三个部分：顶栏、金刚位、瀑布流。</p><p>顶栏是固定在首页中的，它的主要功能是用于切换首页和关注页，其中关注页不是你负责，因此顶栏你只需要注意两点，第一能够支持点击切换，第二顶栏要始终保持在顶部，页面滚动的时候需要保持不动。</p><p>金刚位是其他功能页的核心入口，它横跨两个屏幕，每屏幕两行，每行 5 个图标。金刚位的特点是，它自身支持左右滑动切换，并且在页面滚动时金刚位也要跟随着一起滚动。</p><p>瀑布流是 JPG 的核心展示区，它由若干个高度不确定的卡片组成，每一批卡片 20 个，卡片数据是从后端请求过来的，并且需要支持无限滚动。</p><p>你可以先停下来，思考一下这个项目你会怎么设计，你会怎么写代码。好了，接下来我会把我的设计思路告诉你。</p><h2>项目结构</h2><p>我以前和你介绍过，搭建页面讲究的是代码未动构思先行。动手开发，我一般会从三个技术维度进行思考，<strong>项目维度、页面维度和单个组件维度</strong>，主要围绕技术选型、可行性、可扩展性、可维护性这些方向进行。</p><p>遇到大的需求，我还会专门先写技术文档，内容包括核心技术选型、组件拆分方式、组件之间的关系、状态的数据结构和流程图，等等。写文档的过程也就是把模糊的构思变成清晰的文字的过程，在这个过程中，我会找出一些以前没有思考到的要点，把风险提前暴露出来，同时写文档也能帮我把设计思路变得更有条理一些。</p><p>回到 NFT 电商项目，在项目维度我们先围绕技术选型、可行性、可扩展性、可维护性这些方面思考一下。</p><p>首先，在开发语言的选择上，后续这肯定是大型项目，直接选 TypeScript。说实话，在用习惯 TypeScript 之后，要我换回 JavaScript，我估计我自己的开发效率会变得更低，代码 BUG 也会更多。TypeScript 静态类型检查真的很好用，推荐给你，即使你现在不会，也请你把 TypeScript 列到你的必学清单中。</p><p>第二，在状态管理的技术选型上，页面级别的，我们使用 useState 就够了，只有大型应用中，我才会考虑使用  Redux，现在直接用 Redux 有点重了，后面再引进来也不迟。</p><p>接下来就是列表组件的技术选型，现在这个时间点，我还是会用 RecyclerListView。当然这有个难点，怎么实现金刚位和瀑布流的混合列表，以及怎么在瀑布流中实现不定高布局呢？这些实现细节我们可以后面再思考。可能有些人觉得这非常难，如果是工作中，就需要专门安排人进行技术攻关了，当然这也是可以的。</p><p>我认为在项目维度上，更值得和你探讨的问题是：<strong>项目目录应该如何设计，才能支撑后续项目变大的可扩展性和可维护性？</strong>从单个 NFT 首页本身来讲，我的设计思路是这样的，你可以参考一下：</p><pre><code class="language-plain">.\n├── api\n│   └── homeAPI.tsx\n├── components\n│   ├── Grid\n│   └── RecyclerListView\n├── utils\n├── features\n│   ├── Icons\n│   ├── List\n│   ├── TopBar\n│   └── WaterFallCard\n└── index.tsx\n</code></pre><p>整体设计思路是把通用代码放到最外面的 api、components、utils 目录，把纯业务相关的功能代码收拢在 features 目录中。这些目录的具体作用如下：</p><ul>\n<li>api：后端约定好的接口地址不容易变，因此我把请求后端接口的函数都放到了 homeAPI.tsx 的文件中了；</li>\n<li>components：开发页面中能够沉淀下来，后续可能复用的组件，我会放到 components 文件夹中。比如，金刚位中 2 * 5 的图标，它的布局方式就是网格布局，那就可以抽离一个通用的网格布局组件 Grid；</li>\n<li>utils：通用工具函数；</li>\n<li>features：业务组件和其后端接口数据的处理逻辑部分，它们是最容易变动的，而且关联性很强，因此我把它们看作一个功能，有时候代码行数不多我也会偷懒不拆，直接把这组件和组件的后端数据处理逻辑放到同一个文件中。按功能 feature 拆分而不是按组件本身进行拆分的思路，我是从 <a href="http://cn.redux.js.org/style-guide/style-guide#structure-files-as-feature-folders-with-single-file-logic">Redux 的最佳实践</a>中学来的。</li>\n</ul><blockquote>\n<p>“Structure Files as Feature Folders with Single-File Logic”，相同 feature 的文件，都放在同一个文件夹下。</p>\n</blockquote><ul>\n<li>index.tsx：页面的根组件，用 index.tsx 的原因是引用起来更加方便，可以少写一层引用路径。</li>\n</ul><p>这时你可能会问，这种项目的结构设计，可扩展性怎样？开发页面用这个项目结构是可以，但咱们不是要开发 NFT 的 App 嘛。</p><p>其实，这就是个套娃的过程了，当然里面也有一些技巧，如果你后续要开发一个完整的 App，我的扩展设计思路如下：</p><pre><code class="language-plain">.\n├── api\n├── components\n├── packages\n├── utils\n├── features\n├── screen\n│  ├── Home\n│  │    ├── api\n│  │  ├── components\n│  │  └── ...\n│  └── Follow\n└── index.tsx\n</code></pre><p>在上面的项目结构中，首页 Home 的页面结构也是 api、components、features、utils、index.tsx 的结构，只不过用 Home 目录包裹起来了，并将其放到了 screen 目录中。一个文件具体放哪儿一层，按照通用程度来划分：</p><ul>\n<li>页面级别的共享：我会放在 <code>./screen/Home/api</code>、<code>./screen/Home/components</code> 等目录下；</li>\n<li>应用级别的共享：一个应用中有多个页面，多个页面之间的共享我会放在 <code>./api</code>、<code>./components</code>等目录下；</li>\n<li>项目级别的共享：有时候项目和项目之间的代码也是会共用的，这部分代码我会放在 packages 目录下，并通过 npm 的方式进行分发。这个思路，我参考的是业内的  <a href="https://en.wikipedia.org/wiki/Monorepo">monorepo</a> 实践，我们团队内部也在用。</li>\n</ul><h2>页面拆分</h2><p>项目维度弄清楚后，接下来我重点思考的问题是如何“拆稿”，也就是把 UI 设计稿拆成组件，特别是要把组件状态确认好。</p><p>我拿到 UI 设计稿后，发现了两个我熟悉的通用组件，这些通用组件是我以前写代码时沉淀下来的一些应用级别的共享代码。虽然这些 UI 组件在每个 App 上都长得不一样，很难做成多项目通用、业内通用的组件，但自己做项目时直接拿过来改改，还是非常好用的。你看，<strong>以前通用组件、通用工具的积累，现在派上用场了吧</strong>。</p><p>这两个通用组件是网格布局组件 Grid，和瀑布流版的 RecyclerListView，我把它们放到了 components 目录下：</p><pre><code class="language-plain">├── components\n   ├── Grid\n   └── RecyclerListView\n</code></pre><p>有了上面两个通用组件后，我就只需要专注于页面的开发即可。Grid 组件对应金刚区图标的 2*5 的网格布局。不过，瀑布流版的 RecyclerListView，也不是拿来就能用的，比如金刚位和瀑布流的混合列表，我是上一讲的基础上改了改代码才实现的。</p><p>要开发页面，就要先把它拆成组件。在<a href="https://time.geekbang.org/column/article/500633">02</a><a href="https://time.geekbang.org/column/article/500633">讲</a>中，我提到过拆组件原则是单一职责原则，一个组件只做一件事，我还在<a href="https://time.geekbang.org/column/article/503115">04讲</a>说过，组件的状态根据就近原则进行放置，我们应该先考虑放在该组件上，再去考虑父组件。</p><p><strong>根据单一职责原则和就近原则</strong>，NFT 首页的设计稿我是这么拆的：</p><p><img src="https://static001.geekbang.org/resource/image/91/10/91535f384f06d19b9f016fc2d88a4f10.png?wh=1646x1898" alt="图片"></p><p>我们先来具体分析一下 TopBar 。</p><p>顶栏就是 TopBar 组件，咱们基础篇先不考虑动画、手势，因此 TopBar 组件使用最简单 View 和 Text 就能实现。其中有个麻烦的地方，页面切换的状态应该放在哪里？</p><p>我是这么思考的，根据就近原则我先把页面切换的状态放到了 TopBar 组件上面：</p><pre><code class="language-plain">- App(应用)\n  - Home(首页)\n     - TopBar(顶栏) &lt;- 页面切换的状态\n  - Follow(关注页)    \n</code></pre><p>但实际上，你可以看到页面切换的状态其实并不属于 TopBar 组件，也不属于它的 Home 父组件。它是 App 组件用来控制 Home 组件和 Follow 组件切换的状态，因此它应该属于 App 组件。而这次我负责开发的是首页，所以我先把暂时放在了 TopBar 组件上，后续我和负责 App 开发同学联调的时候，再把状态抽到 App 组件的全局状态上。</p><p>接着是List 的实现。无限列表  List，底层直接使用瀑布流版的 RecyclerListView 实现就可以了。</p><p>而且，无限列表的加载状态，我们也在<a href="https://time.geekbang.org/column/article/503115">04讲</a>中提到过，所有的 isLoading、isError、isSuccess 都可以合并成一个状态 ：</p><pre><code class="language-plain">enum RequestStatus {\n  IDLE = \'IDLE\',\n  PENDING = \'PENDING\',\n  SUCCESS = \'SUCCESS\',\n  ERROR = \'ERROR\',\n}\n</code></pre><p>除了 RequestStatus 这种枚举类型的方案外，当然还有更简单的方案，在单个组件的分析维度，我会再和你介绍。</p><p>再接着是 Icons。</p><p>金刚位 Icons，我用我自己开发的网格组件 Grid 和滚动组件 ScrollView 就能实现。ScrollView 组件我们也在<a href="https://time.geekbang.org/column/article/506825">08讲</a>中介绍过，我打算用它的横向滚动、分页能力和滚动结束事件，来实现金刚位的支持左右滑动切换、双屏切换的功能。</p><p>接下来我们还会用到这些 <a href="https://reactnative.dev/docs/next/scrollview">ScrollView</a> 属性：</p><pre><code class="language-plain">- horizontal\n- pagingEnabled\n- onMomentumScrollEnd\n- showsHorizontalScrollIndicator\n</code></pre><p>这里我们再简单解释下这几个属性：</p><ul>\n<li>horizontal 默认为 false，是竖向滚动的，将其设置为 true 时，即可开启横向滚动；</li>\n<li>pagingEnabled 默认为 false，是滚动交互是平滑的，将其设置为 true 时，每滚动一次就翻一页。horizontal  和 pagingEnabled 同时开启的效果类似轮播图；</li>\n<li>onMomentumScrollEnd 是滚动结束事件，当滚动停下来时会触发一次。金刚位的滑动翻页时，有一个长一点的小红条和一个短一点的小灰条，用来表示当前显示的那一屏。使用 onMomentumScrollEnd  就可以控制滑动切换状态了；</li>\n<li>showsHorizontalScrollIndicator 默认为 true，代表默认显示横向滚动条，金刚位的轮播图效果不需要滚动条，因此我准备把它关了。</li>\n</ul><p>金刚位有两个状态，滑动状态和图标内容状态。滑动状态我刚刚也提到过，只有 Icons 本身在用，因此我们直接放到 Icons 组件上即可。而图标内容状态，因为 RecyclerListView 不像 ScrollView，RecyclerListView 的 dataProvider 是统一维护的，所以我打算把图标内容状态移到 Icons 的父组件 List 上。</p><p>最后是 WaterFallCard 。</p><p>前面我们提到过 NFT 首页是由金刚位和瀑布流组成的混合列表，我们不能用 RecyclerListView  嵌套 RecyclerListView来实现混合列表。这里我敲一个重点，RecyclerListView 是继承自 ScrollView 的，同一个方向也就是垂直方向或水平方向，我们尽量只使用一个 ScrollView/RecyclerListView  组件来进行响应。</p><p>那为什么我选择只用一个 ScrollView/RecyclerListView 呢？</p><p>你这样想，同方向的双 ScrollView 有两种响应方式，同时响应或只响应一个。只响应一个的时候，双 ScrollView 和单 ScrollView 是一样的。第二种情况是双 ScrollView 同时手势响应，你可以想象一下，在你用鼠标往上滚动页面时，还有一个调皮的小朋友用你的键盘控制页面往上滚动。第二个 ScrollView 组件，就像那个调皮的小朋友，你在动的同时他也在响应你的手势，结果滚动速度就变成双份的了，格外奇怪。</p><p>而且，同方向的双 ScrollView 并不能实现金刚位和瀑布流的混合列表，因此我选择了采用改 RecyclerListView 的源码，让它同时支持单列布局和双列瀑布流布局，这就要一些技术攻坚了。怎么改第三方库的 JavaScript 源码，我们也在<a href="https://time.geekbang.org/column/article/509753">11讲</a>中学习过。</p><p>正是因为，瀑布流实际不是列表，它只是无限列表 List 组件中的卡片，因此我将其命名为 WaterFallCard。实现 WaterFallCard 组件，需要用到 View、Text、Image、Pressable 组件，此外还要用到 <a href="https://time.geekbang.org/column/article/501650">03讲 Style 样式</a>的知识，这一部分实现起来会比较简单。</p><h2>单个组件</h2><p>当我把 NFT 页面拆成 2 + 4 个组件后，我的实现思路就清晰很多了。两个通用组件，不需要什么改动，工作量很小，4 个业务组件只有列表 List 组件状态管理比较麻烦，这时候我就把重点放到了 List 组件上。如果你想了解 4 个业务组件的具体实现，也可以看下我放在 <a href="https://github.com/jiangleo/react-native-classroom">GitHub</a> 上的代码。</p><p>如果做过无限列表，你就知道，处理里面的逻辑还挺麻烦的，需要处理首次请求成功、首次请求失败、更多数据加载成功/失败、后端没有数据等等情况，如果考虑性能优化的话，还要做预加载、要管理数据缓存的逻辑，要写很多代码。</p><p>这时候，我想起了以前在技术群里有朋友推荐过的 React Query，说是处理请求状态非常简单，以前就简单看过一下 API，它的 Demo 代码如下：</p><pre><code class="language-plain"> import { QueryClient, QueryClientProvider, useQuery } from \'react-query\'\n\n const queryClient = new QueryClient()\n\n export default function App() {\n   return (\n     &lt;QueryClientProvider client={queryClient}&gt;\n       &lt;Example /&gt;\n     &lt;/QueryClientProvider&gt;\n   )\n }\n\n\n\nfunction Example() {\n   const { isLoading, error, data } = useQuery(\'repoData\', () =&gt;\n     fetch(\'https://api.github.com/repos/tannerlinsley/react-query\').then(res =&gt;\n       res.json()\n     )\n   )\n\n   if (isLoading) return \'Loading...\'\n\n   if (error) return \'An error has occurred: \' + error.message\n\n   return (\n     &lt;div&gt;\n       &lt;h1&gt;{data.name}&lt;/h1&gt;\n       &lt;p&gt;{data.description}&lt;/p&gt;\n       &lt;strong&gt;👀 {data.subscribers_count}&lt;/strong&gt;{\' \'}\n       &lt;strong&gt;✨ {data.stargazers_count}&lt;/strong&gt;{\' \'}\n       &lt;strong&gt;🍴 {data.forks_count}&lt;/strong&gt;\n     &lt;/div&gt;\n   )\n }\n</code></pre><p>代码行数不多，虽然是 Web 代码，但我相信你也能很容易看懂。QueryClient 和 QueryClientProvider 让我感觉和 Redux 状态管理库似曾相识，应该是管理全局状态用的。但 useQuery 这段代码非常简洁，把网络请求状态统一封装了，加载中是 isLoading，加载报错是 error，请求数据是 data ，能够省去很多模板代码。看完后，当时我心里就想，这代码抽象得真好。</p><p>这次写文章时，我又想起了 React Query，于是又去仔细研究了一下，第一个惊喜是它的竞品 SWR 的代码，竟然比 React Query 还要简单，你可以看下 SWR 提供的 demo：</p><pre><code class="language-plain">import useSWR from \'swr\'\n\nfunction Profile () {\n  const { data, error } = useSWR(\'/api/user/123\', fetcher)\n\n  if (error) return &lt;div&gt;failed to load&lt;/div&gt;\n  if (!data) return &lt;div&gt;loading...&lt;/div&gt;\n\n  // render data\n  return &lt;div&gt;hello {data.name}!&lt;/div&gt;\n}\n</code></pre><p>默认没有全局配置的 Client 和 Provider 的配置，只用了一行 useSWR，就把请求逻辑处理完成了，并且只提供了两个状态数据 data 和 error，isLoading 和 !data 是等价的，于是又把 isLoading 状态省掉了。作者真是高手，后来我一看是 Next.js 团队开发的，心里好感又增加了一些。</p><p>第二个惊喜是 React Query 和 SWR 竟然针对无限列表这种场景，做了通用的封装，这又能进一步把 List 组件的状态管理逻辑降低。以 React Query 为例，示例代码如下：</p><pre><code class="language-plain"> const {\n   fetchNextPage,\n   fetchPreviousPage,\n   hasNextPage,\n   hasPreviousPage,\n   isFetchingNextPage,\n   isFetchingPreviousPage,\n   ...result\n } = useInfiniteQuery(queryKey, ({ pageParam = 1 }) =&gt; fetchPage(pageParam), {\n   ...options,\n   getNextPageParam: (lastPage, allPages) =&gt; lastPage.nextCursor,\n   getPreviousPageParam: (firstPage, allPages) =&gt; firstPage.prevCursor,\n })\n</code></pre><p>不过，我这里要先和你坦个白，<a href="https://react-query.tanstack.com/reference/useInfiniteQuery">查文档</a>看这段代码的时候，我也没有看得太懂，状态太多了，还有个配置项，我其实是在真正用的时候，才用明白的。</p><p>我从文档中大概能够理解，useInfiniteQuery 是专门用来控制无限列表请求的状态的，里面状态很多，控制状态的函数也很多。fetchNextPage 从名字看是获取下一页，hasNextPage 是是否有下一页的意思，isFetchingNextPage 是是否正在请求下一页的意思，但 getNextPageParam 和 getPreviousPageParam 完全没有看懂，特别是 nextCursor 属性是什么、干什么用的，也没有搞明白。</p><p>同样，在 SWR 的中文文档中，处理无限数据列表的 useSWRInfinite 函数我也看了一遍，汉字都认识，代码单词都认识，就是不理解。</p><p>或许你曾经也遇到过和我类似的问题，看别人的文章、文档懂了个大概，但心里还是困惑很多。这个时候，抽象的文字要和能跑得起来的代码结合起来读，读完 useInfiniteQuery/useSWRInfinite  <a href="https://github.com/tannerlinsley/react-query/tree/master/examples/load-more-infinite-scroll">示例代码</a>后，我自己写了一个 React Native 的版本之后，我才真正算会用了。</p><p>但在当时，我要解决的核心问题不是怎么把 useInfiniteQuery/useSWRInfinite 学会，我的计划是在 1 天的周末时间把简易电商首页搭建出来，所以了解完 React Query 和 SWR 的核心功能后，我得快速决策 List 组件怎么技术选型。</p><p>在当时我是这么决策的，React Query 和 SWR 都支持 React Native，在 React Query 官方出的和 SWR 的<a href="https://react-query.tanstack.com/comparison#_top">对比分析文章中</a>，React Query 似乎更强大一些，但多出的功能我并不会用到，在功能方面二者打了个平手。</p><p>然后我又分析了一下文档，SWR 官方支持中文，React Query 只能找到英文文档，但 React Query 功能丰富度比 SWR 更强大一些，我又对比了一下 <a href="https://www.npmtrends.com/react-query-vs-swr">npm trends</a>，发现大家更喜欢 React Query 一些，从趋势图中你可以看出 React Query 在 2021 年的下载量反超了 SWR。</p><p><img src="https://static001.geekbang.org/resource/image/42/64/42168e6ddf025f6dc13ff194a57b6864.png?wh=1920x1086" alt="图片"></p><p>中文英文文档我没有什么偏好，但文档详细度、Demo 数量和 React Query 的下载量，实打实是 React Query 更优秀，因此我快速做出了决定，选 React Query。</p><h2>总结</h2><p>好了到现在为止，从项目维度、页面维度和单个组件维度，我把一些关键点都分析完了，排除难点有了思路后，接下来就是写代码了，都是体力活了。</p><p>代码如何写，细节是什么，我就不和你详细介绍了，因为写这篇文章的目的其实是为了让你通过搭建一个电商首页，检验自己学到了多少知识。老师教了多少不重要，你学到了多少才是最重要的。</p><p>这篇文章也是我对自己一次自我剖析，在这篇文章中，你也能看出我的整体思路，是把“如何搭建一个电商首页？”这个大问题，分解为“如何搭建项目”，又进而分解为“如何拆分页面”，最后分解为“如何攻克单个复杂的组件实现”，在不同思考层面宏观、中观、微观，利用自己的经验和从优秀开源库中学到的实践，来解决不同层面的问题。</p><p>但老师也有他的技术盲区，有些业内已经解决的问题，我以前都没有意识到这是个问题，还在用着我以前复杂的解决方案，比如 React Query 我真是今年才听过，这次写代码的时候才用上的。</p><p>但因为以前这种电商首页写过很多个，无限列表组件也封装过，看到 React Query 就明白它大致解决的问题是什么，能解决我以前的哪些问题，也就可以现学现卖了。</p><p>这也让我更加深刻地意识到，知识本身不重要，要把知识内化成自己的能力才重要。只有以前真正思考过、实践过才能在遇到类似问题时，遇到更好解决方案时，快速学习、决策和解决。</p><h2>作业</h2><p>这一讲的作业，就是搭建一个卖 JPG 的电商首页。</p><p>这次作业是对技术篇所学知识的一种巩固，技术篇中没有用到的技术，比如动画、页面跳转，你可以先忽略，后面我们还会继续完善这个电商 App。有些绕不开的技术，如果你以前不会，我也没有教过，你可以试着自己查查资料，一边看文档和代码案例，一边自己动手试试，相信你也能很快掌握。</p><p>这次没有搭建专门的后端服务，所有的数据、图片用的都是 mockapi.io 的假数据，这些假数据接口如下：</p><pre><code class="language-plain">const animalsUrl = \'https://61c48e65f1af4a0017d9966d.mockapi.io/animals\';\nconst catsUrl = \'https://61c48e65f1af4a0017d9966d.mockapi.io/cats\';\nconst iconsUrl = \'https://61c48e65f1af4a0017d9966d.mockapi.io/icons\';\n</code></pre><p>第一个 animalsUrl 是动物的图片数据，第二个 catsUrl 是猫猫的图片数据，你可以任选其一作为瀑布流的展示数据，第三个 iconsUrl 是金刚位的图标数据。</p><p>请你使用上面三个接口，实现如下 UI 设计稿：</p><p><img src="https://static001.geekbang.org/resource/image/55/ec/55a408bf485f7c829c124880de81b5ec.png?wh=1568x2136" alt="图片"></p><p>如果你在实现过程中遇到了问题，花了大量时间也没有想明白的时候，你可以参考一下我放在 <a href="https://github.com/jiangleo/react-native-classroom/tree/main/src/12_HomePage">GitHub</a> 上的代码，希望它能对你有所帮助。如果还有其他问题，也欢迎你给我留言。我是蒋宏伟，咱们下一讲见。</p>',
        article_title: "12｜页面实战：如何搭建一个电商首页？",
      },
      {
        title: "直播加餐｜七年，我的跨端实践和探索",
        id: 512075,
        content:
          '<blockquote>\n<p>小编说：<br>\n以下内容均来自蒋宏伟老师3月29日晚的直播，相关直播回放见<a href="https://www.bilibili.com/video/BV1XL4y177Nx?spm_id_from=333.999.0.0">bilibili极客时间频道</a>。</p>\n</blockquote><p>你好，我是蒋宏伟。今天我想和你分享一下我这七年的跨端实践和探索，希望我的过往经验和想法，能对你的工作有所帮助。</p><p>这七年大体上可以分为<strong>学习、实践和探索的三个阶段</strong>：</p><p><strong>第一个阶段是 2015～2016 年。</strong>2015 年，我转行开始做前端工程师，而且我大学学的也不是计算机相关的专业，技术底子很薄。因为刚刚入行，对很多东西都不懂，只能天天学习。幸好当时遇到了很好的 leader，入职了 58 同城。58 的培养机制还是很好的，有小师傅、有小组长，还有技术大牛，而且他们都很“乐于助我”。</p><p>那个时候，我主要负责的是 H5 和 React Native 的业务开发。在业务开发过程中，遇到简单的问题自己翻翻书、查查资料就能搞定了，遇到自己搞不定的事情，就去请教同事，技术成长也很快。</p><p><strong>第二个阶段是 2017~2019 年的时候。</strong>那个时候我参与了很多 58RN 基建的开发，并且在 18 年成为了 58RN 项目的负责人。但开发业务和做技术基础设施建设是不一样的，开发业务有产品提需求，有 PMO 把握进度。搞基建呢，你自己得有想法，你得会把业内方案和业务场景进行结合，你还得组织小伙伴，让小伙伴来支持你落地。</p><!-- [[[read_end]]] --><p>这几年，我看了大量的业内方案，也有了大量的落地实践，所以对很多技术原理层面东西有了更深的认知。</p><p><strong>第三个阶段是 2020 年到现在</strong>。2020 年，我开始负责一个 9 人的前端团队。带团队和单兵作战很不一样，单从技术层面讲，遇到技术难题你要能扛得住，定技术方向时你要对得起大家，别把大家带错路了，因此对前沿技术的探索也是团队leader的必修课。</p><p><img src="https://static001.geekbang.org/resource/image/04/62/044468e1a271048407e61a4bf563cb62.jpeg?wh=1920x1080" alt="图片"></p><p>这七年无论是 H5、React Native 还是小程序等等，我都在围绕着跨端这个方向，学习、探索和实践。接下来，我想通过几个小故事和你聊一下我的心路历程。</p><h2>过去：既做业务又做基建最幸福</h2><p>我要讲的第一个故事是《学以致用的故事》。</p><p>我刚入职前几年解决的就是些小问题。这是可以预见的，你刚刚工作一两年，没有太多的积累，公司不可能一上来就让你负责一个很牛逼的项目，人都是慢慢积累的。</p><p>因此我们要先学习，把那些常见的小问题给解决好，等大家认可你的技术能力的时候，你才会有更好的机会。</p><p>我举个例子，2015 年，我学 H5 的时候，从《移动 Web 手册》这本书上学到了一个很有用的、开发移动应用的小知识。它说的是我们用的 CSS 像素（px）并不是手机屏幕中物理像素。我们都知道，一个物理像素，就是屏幕上最小的发光点，那 CSS 像素究竟和设备的物理像素有什么关系呢？</p><p>揭开这个谜团之前，我们还要了解一个非常重要的概念，叫做 DPR（Device Pixel Ratio），也就是设备像素比。现在我们的手机都是视网膜屏，大部分手机的设备像素比都是 2 或 3。</p><p>如果设备像素比等于 2 的话，那么 1 个 CSS 像素点的宽度，就是两个物理像素的宽度。既然都是物理像素了，理论上我们拿一个精度很高的尺子，就能把这个物理像素的宽度度量出来。或者查一下、量一下手机宽度，再查一下它宽度上有多个像素，也能大致估算出来。</p><p><strong>这样一个非常抽象的 CSS 像素，就和现实世界中的毫米给挂钩上了。</strong></p><pre><code class="language-plain">单个物理像素宽度= 71.5 毫米/1170 物理像素 = 0.06 毫米（iPhone12）\n1CSS 像素 = 3DPR * 0.06 毫米 = 0.18 毫米\n</code></pre><p>这种把未知的抽象概念和已知具象概念挂钩的学习方案，我经常用，对提升学习效率有非常大的帮助。</p><p>但是你知道吗？你在写 React Native 的时候，React Native 的宽度 width 是没有单位的。</p><p>当时我就糊涂了，你传个数字 100 给 React Native，这个 100 到底是多宽？是 100 毫米？还是 100 的 CSS 像素的宽度？我没法把 React Native 中的单位，和我当时认知体系中的单位挂上钩。咱写代码总不能稀里糊涂写吧？总得这个最基本的概念给搞明白吧？</p><p>后来我就查资料，自己写代码验证，终于搞清楚了，原来 React Native 中的默认单位就是 Web 中的 CSS 像素。当时，我还了解到，在 Android 开发的眼中，他们把 CSS 像素叫做 dp。原来同一个东西，在不同开发者口中，还有不同的叫法，我当时也是大呼神奇。</p><p>但你要知道，<strong>你光知道 CSS 像素、dp 和毫米的关系是没有用的，你得学以致用。</strong></p><p>实际上，UI 稿也有自己的像素单位，那个时候我们 UI 稿的宽度是 640 像素，这个 UI 像素既不是 CSS 像素、也不是物理像素，你还得把 UI 像素和 CSS 像素挂上钩。</p><p>那个时候，前端很流行自适应布局，UI 给的设计稿等比缩小或放大到手机、平板上。于是，我就写了一个 uipxToDp 的函数，专门用来做这种转换：</p><pre><code class="language-plain">import {Dimensions} from \'react-native\';\n\n// 58 app 只有竖屏模式，所以可以只获取一次 width\nconst deviceWidthDp = Dimensions.get(\'window\').width;\n// UI 默认给图是 640 像素\nconst uiWidthPx = 640;\n\nfunction uiToDp(uiElementPx) {\n   return uiElementPx *  deviceWidthDp / uiWidthPx;\n}\n\nexport default uipxToDp;\n</code></pre><p>使用 uipxToDp，你可以直接使用 UI 给的像素单位先在手机上把布局弄好，然后在不同机型上 uipxToDp 函数会自动把 UI 像素转换成对应的 dp，这样就能等比例放到任意机型上了。</p><p>这就是我在刚刚入门的时候解决的一个小问题。</p><p><img src="https://static001.geekbang.org/resource/image/af/46/af19026bab3b75380a360e5d6b9ebc46.jpeg?wh=1920x1080" alt="图片"></p><p>我要讲的第二个故事是《理论指导实践的故事》。</p><p>我平时除了前端技术、跨端技术，也爱了解一些最前沿的技术。当时，因为机缘巧合，参与了一个由物理学家张首晟投资的项目的白皮书翻译，后来我又读到张首晟教授在国内的一篇演讲稿。这篇演讲稿给了我很大的震撼，对我影响很大。</p><p>其中有句话是这么说的：</p><blockquote>\n<p>张首晟教授 ：科学有两大方向，一是把各种形态的物质，分解到最基本的组成部分；二是用这些最基本的组成部分，构造出物质不同的态。</p>\n</blockquote><p>我是这么理解的，科学搞研究是先从上往下把事物分解，再从下往上构建出一个全新的物质出来。</p><p>那我们搞技术也可以沿用这个思路。后来，我看问题的时候，就喜欢先把问题拆解、拆解、再拆解，然后再想尽办法重组、重组、再重组。我给你举个例子，比如用户打开页面的时候，他眼中的页面加载就是白屏或者转圈。</p><p>但在我眼中页面加载，是先有版本请求、资源请求，把 JavaScript 静态资源请求回来，然后Native 的 React Native 代码要初始化，下一步才是执行 JavaScript。首次执行 JavaScript 代码的时候，渲染的是一个空页面，这时候我们要先发送业务请求，在业务数据回来之后，真正的业务页面才渲染完成。</p><p><strong>用户的眼中，页面加载只有一步，我眼中页面加载是六步，如果需要的话我还可以细分成更多步骤。</strong></p><p>拆分加载页面的过程有什么用呢？是告诉用户，我们页面加载这么慢是因为它有六个步骤，你要耐心等等吗？</p><p>当然不是，用户不需要关心你的加载页面的过程是什么，他关心的是页面为什么这么慢，我们程序员不就是“用户第一”嘛，用户说慢，怎么办？我们程序员就得想办法解决，而不是给老板、给用户讲道理。</p><p>我和我的小伙伴前前后后用了 2～3 年的时间，方案也是改了又改，做了好几个优化项目，才把我们的一个耗时 2s 多的页面，降低到了  1s 以内，首屏平均耗时一共降低了 57%。并且，这个方案也是一个通用方案，任何 58RN 业务都能用。</p><p>这里我们卖个关子，理论上一个 React Native 页面的首屏渲染耗时可以控制在 100ms 以内，也就是用户点击跳转的动画还没有完成，这个页面就能渲染出来，也就是页面直出。从 1s 降低到 100ms，这也是未来 2~3 年，我们要继续做的事情。</p><p>我在入职 58 的 3~5 年之间，很多基建工作都是围绕着性能优化来做的，这件事给我的启发就是干事情，<strong>不仅要向业内去学，还得有方法论，才能做出最贴合自己业务的方案。</strong></p><p>这就是我第二个《理论指导实践的故事》。</p><p><img src="https://static001.geekbang.org/resource/image/99/dc/9945457b5cc15956c1e19f3db58da1dc.jpeg?wh=1920x1080" alt="图片"></p><p>我要讲的第三个故事是《从技术深度到技术广度的故事》。我有个观点，就是“既做业务又做基建最幸福”，为什么呢？</p><p>因为你做业务的时候，你会用自己开发的产品、也能感受到产品中的问题，甚至你还能从用户、产品、老板那里收到类似反馈。这个时候，你是很容易发现业务中存在的问题的。</p><p>当初我在做 React Native 业务的时候，就花了很多时间来解决线上 BUG，有时候就是一个截图，连报错信息都没有，你说解决起来多痛苦。后来在做 58RN 基建的时候，我就在考虑要不要做一个 React Native 的监控系统。</p><p>2020 年的时候，正好有一个机会，我和我的 leader 提出要搞一个 React Native 的监控系统，他答应了。后来，我们决定先做 Web 监控，再做的 React Native 监控，因为 Web 的体量更大。</p><p>但是，当你做一个完整的大型项目的时候，“I 型”技术深度是远远不够的，你得在“I”上加一横，让你的技术能力由“I”型，变为“T”型。<strong>这一横，我认为就是产品能力和架构能力。</strong></p><p>在做这个监控系统的时候，我学起了 PM 的那套，做了各种调研，甚至我还掌握了写产品文档、画产品原型图这些技能。</p><p>产品文档、产品原型图实际就是个大体架子，架子分几层、用什么材料、搭建步骤又是什么，这些产品不会管。产品不管归谁管？架子的施工步骤归架构师管。</p><p>这时候，你还得去充当架构师的角色。你得写技术文档，画架构图，还得把这些产品、技术实现细节给小伙伴讲清楚。</p><p>后来当我参与搭建大前端监控系统的时候，就做了大量的产品和架构的活。做这些活的目的是把大家连接在一起，让大伙知道我们为什么要做，又怎么做，接着才能干好活。</p><p>当然，代码还是要写的，这一方面我重点负责的是 React Native 、ES/Duird、Node.js 部分。我记得当初完成大前端监控系统二期的时候，我还统计过一次 commit 的数量，当时我的 commit 的数量是第一的，那时候的成就感还是满满的。</p><p>搭建大前端监控系统这件事，让我从原来专精 React Native 方向的程序员，变成了一个产品、架构、前端、后端都懂一点点的全能战士。这种全能战士的能力，让我<strong>能站在对方角度思考问题，交流起来障碍就小，也更容易把人和人连接在一起，项目推进起来也会更有效率。</strong></p><p>这就是我《从技术深度到技术广度的故事》。</p><p><img src="https://static001.geekbang.org/resource/image/4a/b5/4a697180584552387b104090cf4143b5.jpeg?wh=1920x1080" alt="图片"></p><h2>现在：既要与时俱进也要接地气</h2><p>当然，过去的已经过去，人不能永远躺在过去的功劳簿上，还是得与时俱进跟上时代的步伐。因此，我来给你讲讲我这半年多做的探索，以及我对 React Native 新架构落地的思考，这一部分有点长，我慢慢给你展开。</p><p><strong>2022 年，对于 React Native 是一个大年，因为 React Native 团队官宣新架构会在今年正式发布。</strong></p><p>React Native 的新架构要出来了，你得升级吧？总不能让团队小伙伴，一直用老架构开发吧？我有过好几次升级经验，但每次升级牵涉面都很广，非常痛苦。</p><p>升级成本高的原因，是因为有些 React Native 业务，是同时运行在几个 App 上。只升级一个 App 还不行，需要把所有关联的 App 都同时升级，不然这些 React Native 业务要同时维护多个版本，成本也是很高的。</p><p>但 2022 年新架构出来后，即便成本很高，我也想把它升上去。因为我经过调研发现，新架构的潜在收益非常大，我认为新架构的收益是能够覆盖我们升级所付出的成本的，因此等今年新架构出来后，我会继续推进升级。</p><p>熟悉 React Native 的朋友肯定知道，2018 年之前 React Native 的核心能力是支持跨端、支持热更新，而且是背靠 JavaScript/TypeScript 生态的。</p><p>从 2018 年到现在，React Native 又推出了好几个非常吸引我的功能，主要是 2020 年 React Native 支持了 React Hooks，还有今年即将推出的 React Native 新架构。</p><p>现在 React Native 新架构的预览版已经出来了，我也第一时间进行了调研，主要有两个功能非常吸引我。<strong>第一个是新架构会默认使用的 Hermes 引擎，第二个是新架构的 Fabric 渲染流水线。</strong></p><p><img src="https://static001.geekbang.org/resource/image/df/10/dfe6e181a081a48d355077ba265b5c10.jpeg?wh=1920x1080" alt="图片"></p><p>先说说 Hermes 引擎为什么吸引我。<strong>简单地讲，就是新架构默认集成的 Hermes 引擎性能更好。</strong></p><p>性能好的核心原因是，相对于 React Native 老架构采用的 JavaScript Core 引擎，Hermes 引擎是专门为移动端打造的。</p><p>在 PC 时代，我们会说电脑的性能有点过剩，但移动端时代，因为手机体积有限，性能其实是吃紧的，这个问题在一些低端机上体现得更加明显。</p><p>现在虽然我们听说的 V8 引擎、JavaScriptCore 引擎都专门为移动端做了架构升级，但由于这些引擎早在 PC 时代就诞生了，考虑很多历史限制条件，也不可能为 React Native 做专门的定制。但 Hermes 没有这些历史包袱，可以专门为移动端来定制开发。</p><p>而React Native 的老架构默认用的是 JavaScriptCore。JavaScriptCore 也叫做 JSC，它采用的是 JIT 的即时编译方案。什么叫 JIT 即时编译呢？</p><p>我用一段最简单的代码给你举个例子：</p><pre><code class="language-plain">const a = 1;\nconsole.log(a);\n</code></pre><p>这里，你本地的 JavaScript 代码会先经过 Babel 的编译，把新语法编译为用户手机里 JavaScript 引擎支持的语法，然后下发到用户手机里去执行。</p><p>这里注意一下，<strong>我们使用 JSC 这类 JIT 即时编译引擎，下发的依旧是 JavaScript 代码</strong>。</p><p>但用户手机里的硬件只能执行由 0101 组成的机械码，硬件是不能直接执行 JavaScript 代码的，那怎么办呢？这时候，JSC 这类 JIT 即时编译引擎，现在主流的做法是先将 JavaScript 代码编译为字节码，然后再编译为机器码。</p><p>因为 JSC 引擎执行代码的过程是编译一段执行一段，再编译一段再执行一段，这种一边编译一边执行的方式就叫做 JIT 即时编译。</p><p>但是，在初始化时， JSC 引擎还需要把整个 JavaScript 代码都编译和执行一次。那你可能就想到了，是不是有办法先提前编译成机械码，然后把由 0101 组成的机械码下发到用户手机上，这样 JavaScript 引擎就不需要编译，只执行机器码就行了，这样 App 的初始化速度不就快了吗？</p><p>这个在本地提前把 JavaScript 代码编译为 0101 机器码的思路很好，但是由于 0101 的机械码体积很大，是 JavaScript 的 10 倍以上，那网络耗时就上去了。那么，既然提前编译为 0101 机械码不可行，我们能不能退一步编译为字节码呢？这样也能节约一部分编译时间啊。</p><p><strong>Hermes 引擎就是这个思路，它在本地先将 JavaScript 编译为字节码，然后再下发字节码。</strong></p><p>Hermes 引擎下发的字节码的体积和 JSC 引擎下发的 JavaScript 代码是一样大的，但 <strong>Hermes 引擎执行字节码的首屏性能，却是 JSC 引擎执行 JavaScript 首屏性能的 2 倍以上。</strong></p><p>这就是Hermes 引擎为什么这么吸引我的原因。</p><p><img src="https://static001.geekbang.org/resource/image/3c/ed/3cc9ecb857d4099cb7812e2688dc9fed.jpeg?wh=1920x1080" alt="图片"></p><p>React Native 新架构第二个吸引我的原因是 Fabric 渲染器。什么是 Fabric 渲染器呢？</p><p>Fabric 渲染器中的通信层，相信你肯定很熟悉，但是通信层只是 Fabric 渲染器的一部分。很多人以为老架构升级到新架构，就是改改 JavaScript 和 C++ 之间通信的 JSBridge 就行了，<strong>其实 JSBridge 这部分的优化在  0.62 版本，也就是 2020 年的版本中已经完成得差不多了。</strong></p><p>JSBridge 的作用是通过消息通知的形式，实现 JavaScript 和 C++ 之间的相互调用。消息通知形式中的消息，其实是一个字符串数组，这个字符串数组中包含了一系列的操作命令和操作参数。但字符串数组不能直接生成、也不能直接用，它有个序列化和反序列的过程，这个过程既浪费了时间、也浪费了内存。</p><p><strong>新架构中已经把 JSBridge 这种消息通知形式改为 JSI（JavaScript Interface）。</strong>有了 JSI 后，React Native 中的 JavaScript 就直接调用 C++了，就像 node.js 使用 addon 调用 C++ 、Flutter 用 FFI 调用 C++ ，以及 Java 使用 JNI 调用 C++ 一样。</p><p>但是，JSI 只是 Fabric 渲染器的一部分。如果你看过 React Native 新老版本源码的话，你会发现新架构在兼容老架构的基础上，几乎把整个底层全给重构了。</p><p>不知道你有没看过我翻译的 <a href="https://reactnative.cn/docs/architecture-overview">React Native 架构</a> ，我把这篇文章也放在了 React Native 中文网上，简单说有这几点：</p><ul>\n<li>它涉及上层 React 改动，包括 Fiber 节点、Concurrent 并发模型等等；</li>\n<li>上层 React Native 的 JavaScript 部分的改动，包括 nativeFabricUIManager 渲染管理器、ScrollView 组件等等的改动；</li>\n<li>在 C++ 层涉及 Shadow Tree、线程模型、视图拍平等的改动和优化；</li>\n<li>在 Java/OC 层面把绝大部分的 Native 组件都给重写了，而且为了兼容还保留了新老架构两套逻辑。</li>\n</ul><p>其中改动的细节，我们暂且不聊，我这里只想和你分享一下，Fabric 渲染器三个吸引我的点。</p><ul>\n<li>第一个点，我已经讲过了，Fabric 渲染器和新架构的 API 共用了通信层，<strong>在 JavaScript 和 C++ 通信这一层的性能也是提升了 3 倍左右。</strong></li>\n<li>第二个点是**更容易保持跨平台一致性，毕竟 C++ 这块代码都是公用的。**原来的 Shadow Tree、布局逻辑、视图拍平都是在各个平台单独实现的，现在新架构把这些用 Java/OC 代码实现的逻辑放到了 C++ 层。</li>\n<li>第三个点，是<strong>拥有优先处理紧急任务的能力。</strong>新架构会集成 React18 的 Concurrent 并发模型，有些同学可能对 React18 Concurrent 并发模型有所了解，并发模型可以让优先级更高的渲染任务先执行，优先级低的渲染任务可以中断或批量渲染。</li>\n</ul><p>这里我们简单讲讲 Concurrent 并发模型。这有点类似我们日常处理工作，同一时刻我们一般只能处理一件事，要是同时来了几件事情怎么办？工作中我们会把事情按重要性和紧急程度分级， Concurrent 并发模型就是把渲染任务按重要性和紧急程度分级处理的策略。</p><p>对于并发模型的优化效果，我们很难拿出个数据指标说优化了 10%、20%，但从原理上，我相信是可以提高用户交互的体验的。</p><p><img src="https://static001.geekbang.org/resource/image/63/58/630421a5d8faa52af0a1a7d505089b58.jpeg?wh=1920x1080" alt="图片"></p><p>看到新架构的 Hermes 引擎和 Fabric 渲染器性能确实好，你可能想赶紧用上，但别着急。</p><p><strong>React Native 新架构目前还是预览版，这也意味着新架构还没有经过大规模的应用，如果贸然用到业务中去，可能会有风险。</strong></p><p>我们这些搞技术的人，热爱前沿技术是一件好事，但用什么技术得根据自己业务的实际情况来。换句话说，我们既要与时俱进，也要接地气，不能飘着，这样才更容易推动技术落地。</p><p>技术要想落地至少分为三步，首先得确定收益，对业务没有收益的事情就不考虑了。其次是确定成本和风险，最关键的控制风险，新技术线上出了大规模故障我们是要担责任的。无论通过业务试点、灰度、降级，还是其他别的方案，我们要把风险控制好，新技术才能进入大规模应用阶段。</p><p>但任何技术内部的技术点都是存在生命周期的，这就像生物体内的细胞存在新陈代谢一样，新的技术点会慢慢地替代老的技术点，而老的技术点会被慢慢淘汰。</p><p>我在和用到 Hermes 的同学聊的时候，他们的反馈都很不错，告诉我线上很稳定，而且对低端机的长列表性能有提升。可以预见的是， Hermes 这个技术点，会慢慢把 JSC 淘汰掉。</p><p>而 Fabric 这个技术点，还处于技术生命周期中的预研期，目前看来收益不错，接下来就是想办法排除风险，然后大规模应用。</p><p>关于 React Native 新架构这件事情，<strong>我的判断是 React Native 新架构在未来 1~2 年会得到大规模应用。</strong>为什么要 1~2 年这么长的时间呢？一方面，现在新架构还是预览版，正式版可能会在今年下半年发；另外一方面，大规模应用要排除风险，排除风险也是需要一段时间的。</p><p>那这新架构普及的 1~2 年的时间差对个人的意义在哪呢？</p><p>我认为，一个技术人越是走在业内前面，你就越是能把握住技术红利，而这对于个人成长和职级晋升都是有好处的，因此这 1~2 年的时间就是你研究新架构的最好时间。</p><p><img src="https://static001.geekbang.org/resource/image/9a/3a/9abdc4115727645eaa46a75e037a323a.jpeg?wh=1920x1080" alt="图片"></p><h2>未来：前进，探索未知的新大陆</h2><p>像 React Native 新架构在 1~2 年内得到大规模应用这种事情还是比较好预测的，但我还想看到更远的未来。比如：</p><ul>\n<li>未来 2~3 年像 React Native 这类新架构会是怎么样的？</li>\n<li><strong>在更遥远的未来，比如 5~10 年后，手机没有性能问题了，H5 会不会替代跨端技术？</strong></li>\n<li>如果跨端技术未来都不存在了，那我死磕跨端技术是不是浪费了青春？</li>\n</ul><p>对待这些问题，我内心是恐惧又兴奋，恐惧的是未来的不确定性，兴奋的是我可能问到了跨端技术的本质，恐惧和兴奋同时驱使着我去寻找这些问题的答案。</p><p>我的解题思路是这样的：</p><ul>\n<li>未来是未知的，但过去是已知，我可以从历史经验中寻找答案；</li>\n<li>历史上的跨端技术的终局是什么样的？又是哪些因素导致了当前的跨端格局的形成？</li>\n<li>那未来这些因素还会不会继续存在？如果这些因素还会继续存在，那么跨端技术是不是会继续存在？如果不存在跨端技术又会被什么技术代替？</li>\n</ul><p>我们先来看历史。</p><p>我们当前所处的时代还是移动互联网时代，我们现在所聊的跨端技术，大都指的是跨 Android、iOS 两端。历史上对类似“跨端”的技术，有个更通用的叫法，叫做跨平台（Cross Platform）。</p><p><strong>任何跨平台、跨端软件的共性都是屏蔽底层差异，抽象统一接口，减少开发者的适配成本。</strong>而跨平台中的平台二字，通常指的是硬件平台和软件平台，软件平台又包括操作系统平台和软件程序环境。</p><p>硬件平台中最重要的是 CPU，你可能知道目前 CPU 分为两个派系，一个是 ARM 精简指令集，另一个是 X86 复杂指令集，而且每个派系之间还有不同的硬件生产商，有 Intel、AMD、高通、苹果、华为等等。</p><p>操作系统是跨硬件平台的。操作系统平台是运行在硬件平台之上，电脑上常用的操作系统包括，Windows、macOS、Linux，手机上就是 Android、iOS。操作系统中有一类特殊的程序，叫驱动程序，驱动程序是硬件厂商根据操作系统编写的配置文件，可以说，没有驱动程序，计算机中的硬件就无法工作。类似的还有苹果的 macOS 操作系统，它也通过 Rosetta 屏蔽了 ARM 和 X86 的差异。</p><p>无论是操作系统提供的驱动程序适配，还是类似 Rosetta 二进制编译器，都是操作系统为跨硬件平台所做的努力。</p><p>程序执行环境是跨操作系统平台的。在操作系统之上直接创建的应用，我们叫做原生应用。原生应用只能在一个平台运行，比如 Android 应用只能运行在 Android 操作系统上。但哪个开发者不想省事啊？历史上 Java 提过“Write once, Run anywhere”，还有服务端同学熟悉的 Docker 镜像，以及前端同学熟悉的 Chrome 浏览器，都是类似的思想。</p><p>Java、Docker、Chrome、跨端框架都是在操作系统之上的程序环境 ，它们会屏蔽不同操作系统之间的差异性，并向开发者提供了统一的抽象接口，让开发者可以只写一次代码，并运行在多个操作系统之上。</p><p><strong>历史的经验告诉我们，无论是硬件平台、操作系统平台、还是程序环境平台，没有哪个平台是一家独大、独霸整个市场的。同一个维度的平台之间，没有赢家通吃的垄断，只有少数几个寡头之间的竞争，寡头竞争的格局产生了跨平台的需求。</strong></p><p>从历史和行业视角来看，无论是能源、汽车、金融、软件和现在的互联网行业，都是从原子式的竞争格局走向寡头竞争的格局的。因此，我认为无论未来的商业格局怎么变化，未来的操作系统、未来的程序环境也不会一家独大。</p><p>所以跨端、跨平台的不是伪命题。只要还存在多个寡头并存的平台竞争格局，跨端的需求就会一直存在。认识到这点之后，我对跨端技术未来的担忧也就消失了。</p><p><img src="https://static001.geekbang.org/resource/image/2c/05/2c5f88f06d3ea1ddaa86750c3e3a5f05.jpeg?wh=1920x1080" alt="图片"></p><p>虽然跨端方向是一个很好的技术方向，但跨端的技术很多，有小程序、Flutter、React Native、H5/Hybrid，具体到每个技术上又有细分。一个人的精力是有限的，多嚼不烂，我应该选择那个方向重点研究呢？</p><p>目前我自己规划的重点研究方向是 React Native SSR。为什么我最终决定选择 React Native SSR 作为重点研究方向呢？有三个原因：</p><p><strong>1、“Native SSR” 的市场很大。</strong></p><p>目前绝大多数的 Native 应用采用的还是客户端渲染 CSR 方案，没有成熟的服务端渲染 SSR 方案。</p><p>不过我们也能看到，在 Native 应用中，大厂都有自研自己的<a href="https://juejin.cn/post/7046299455397560350">布局动态化、逻辑动态化</a>的方案，说明这块的需求还是很强的。Native 服务端渲染的 “SSR ” 方案主要的优势在于，业务可以随时上线、可减少包体积，还有跨端优势。</p><p>比如我们58同城推出的 Flutter 模板动态化方案 <a href="https://github.com/wuba/fair">Fair</a> 、字节跳动的 Android/iOS 跨端动态化方案 <a href="https://github.com/hxxft/lynx-native">Lynx</a> ，还有美团的 Flutter 跨端动态化方案 <a href="https://tech.meituan.com/2020/06/23/meituan-flutter-flap.html">Flap</a> ，Airbnb 的 <a href="https://medium.com/airbnb-engineering/whats-next-for-mobile-at-airbnb-5e71618576ab">Server-driven rendering</a> 方案等。</p><p>但是各家都是自造轮子，市面上并没有出现一个得到大规模应用的 SSR 框架，说明这类动态化技术方案还处于早期探索阶段。</p><p><strong>2、目前看来，“Native SSR” 要成还得依赖 JavaScript 生态。</strong></p><p>为什么这么说呢？因为目前的 Native 应用中用的大部分是 CSR 渲染。虽然也有服务端下发 DSL 渲染静态页面的解决方案，但处理复杂的业务逻辑上，DSL 完全不够。</p><p>DSL 是什么呢？比如 HTML、JSON 这种非图灵完备的语言就是 DSL，非图灵完备就决定了，它只能解决特定领域的问题，不能解决普适性的问题，复杂业务更是没法处理。</p><p>而且，由于苹果公司的政策，只有特定的 JavaScript 程序才能够动态更新，因此能够同时满足跨端、图灵完备和动态更新的特点的语言只有 JavaScript。</p><p>但现有的 “Native SSR” 也有采用 JavaScript 方案的呀，为什么没有大规模应用呢？因为现有的  “Native SSR” 还要解决第二个问题，也就是同构问题。</p><p>Web SSR 也是解决了同构问题之后才大规模铺开的，也就是一套代码既可以在本地跑起来，又可以在服务端跑起来。即使 SSR 方案在服务端扛不住了，还有 CSR 方案在客户端帮忙兜底，开发 SSR 的适配成本很低，这才能流行起来。</p><p>如果你要是让开发者，在Android 写一套代码，在iOS 写一套代码，SSR 写一套代码，CSR 又写另一套代码，开发者就会说，“你这方案再牛逼，我也不想用”，成本太高了。</p><p><strong>3、“Native SSR”  借助 React Native将有机会得到大规模应用。</strong></p><p>首先你可能会问，为什么 “Native SSR” 得借助 React Native 来实现呢？</p><p>在大规模应用 “Native SSR” 必须使用 JavaScript 方案和解决同构问题的双重前提下，目前我能想到的只有 React Native 了。但光有 React Native 还不够，还得有个 React Native 版的服务端渲染框架，类似于 Web 中 Next.js。</p><p>目前 Web SSR 的方案大致是，开发者先在本地实现一个 React 应用，然后把本地实现的 React 程序跑在 node.js 服务端上，要跑在服务端就得借助 Next.js 框架了。Next.js 把服务端渲染、路由方案都给配置好了，我们的 React 程序直接拿来用就行了。</p><p>然后 Next.js 框架执行 React 程序代码生成 HTML，HTML 下发到浏览器就能把 Web 页面首屏直接渲染出来了。</p><p>那同样的，React Native 要大规模实现 SSR，就得造一个 Next.js 的轮子。让 React Native 能同时在本地和服务端运行起来。首先开发者在本地，能通过 “类 Next.js” 的框架使用客户端渲染 CSR 的方式，开发 React Native 应用，然后在服务端能通过服务端渲染 SSR  的方式，执行 React Native 代码，输出一个序列化 Tree。这个序列化的 Tree 描述的就是 React Native 的静态布局结构。</p><p>接着服务端把序列化的 Tree 下发到 iOS/Android 应用上，Native 应用对 Tree 进行反序列化后，直接通过 C++ 层的 <a href="https://reactnative.cn/docs/render-pipeline">Fabric 渲染器</a> ，执行布局、提交和挂载操作，生成 Native 页面。</p><p>这就是借助 React Native 实现 “Native SSR”  的基本原理。</p><p><img src="https://static001.geekbang.org/resource/image/41/c9/41334efa780c78a08bfa776b8a1f8cc9.jpeg?wh=1920x1080" alt="图片"></p><p>有些小伙伴可能会问，原来的 React Native 不是有热更新吗？热更新不是也可以实现动态化吗？</p><p>那 React Native 的热更新和 React Native SSR 有什么区别呢？</p><p>React Native 热更新的本质还是客户端渲染 CSR 方案，首屏渲染速度要比服务端渲染 SSR 方案慢上不少。根据我的性能优化经验，一个复杂的 React Native 应用，采用热更新方案渲染耗时在 2000ms 左右，如果做到极限可能在 700ms 左右。当然，一般达不到极限，因为越是极限，要满足的条件越苛刻，业务的应用范围越小。</p><p>CSR 渲染的渲染步骤分为 6 步：</p><ol>\n<li>请求服务端获取最新的 Bundle 资源地址；</li>\n<li>通过返回的资源地址，下载 Bundle 资源，也就是 JavaScript 代码；</li>\n<li>初始化 JavaScript 引擎和 Native 模块；</li>\n<li>执行 JavaScript 代码，生成空页面；</li>\n<li>与此同时发起业务请求，请求最新的业务数据；</li>\n<li>业务数据回来后重新渲染，生成最终的页面。</li>\n</ol><p>SSR 渲染其实是对 CSR 渲染的步骤的重组，整体也是 6 步：</p><ol>\n<li>并行请求 Tree，和最新的 Bundle 资源地址；</li>\n<li>初始化 Native 模块，同时开启后台线程并行请求 Bundle 资源；</li>\n<li>使用 Tree 文件，通过 Fabric 渲染器渲染首屏页面。这里画个重点，此时用户已经可以看到业务页面了；</li>\n<li>然后再初始化 JavaScript 引擎，开始执行 JavaScript 代码；</li>\n<li>这一步有个专有名词叫做 Hyration。大致的意思原来通过 Tree 生成的页面是不可交互的“静态”页面，这时需要通过执行 JavaScript，生成一个有交互的“动态”页面，把原来的“静态”页面替换掉；</li>\n<li>替换后的页面，就是可以交互“动态”页面了。</li>\n</ol><p>使用 SSR 配合预请求，理论上实现 100ms 以内的首屏渲染是没有问题的。比如，美团就实现了 <a href="https://ppt.infoq.cn/slide/show?cid=94&pid=3696">React Native SSR </a>，据说页面渲染最快可以达到 50ms 。</p><p>当然，要大规模应用，一方面要依赖 React Native 团队提供更友好的接口，另一方面还得有类似 Next.js 的框架，来大幅降低开发者的适配成本。</p><p><img src="https://static001.geekbang.org/resource/image/20/28/20ca18b97ffa5116d1a497200yya3828.jpeg?wh=1920x1080" alt="图片"></p><p>好了，这就是我跨端的故事，希望我过往经验和观点能对你的工作有所帮助。</p>',
        article_title: "直播加餐｜七年，我的跨端实践和探索",
      },
    ],
  },
  {
    chapterTitle: "React Native 社区生态篇",
    children: [
      {
        title: "13｜生态：React Native Awesome",
        id: 512920,
        content:
          '<p>你好，我是蒋宏伟。</p><p>上一个模块我和你介绍的是 React Native 的基础知识，通过核心基础篇 12 讲的学习，你现在是否达成学习目标，可以搭建一个简单的 React Native 页面了呢？</p><p>接下来，在社区生态篇这个模块中，我们将要再进一步，学习搭建一个完整的 React Native 应用。但在搭建 React Native 应用的过程中，除了 React Native 本身的知识，我们还需要用到很多 React Native 生态中的知识和工具。</p><p>不过，React Native 生态是一个非常庞大的概念，我没有办法只用六讲，就把其中所有的知识点都讲透彻。但用更多的篇幅去讲，效果也不一定好，很多知识是用到的时候才需要去深入学习的，在此之前你只需要知道这些知识大概是干什么用的就可以了。真正用到的时候，一边实践一边学习的效果会更好。</p><p>因此，这一讲的目的不是告诉你，你还要学什么，而是告诉你，你可能会用到什么。只要在你需要的时候，你还能想到，还有这样一个技术能够解决你的问题，那今天这一讲的目的就达到了。</p><p>另外，我们这一讲采用的是 GitHub 社区 Awesome 的形式，为你推荐一些我精选的参考资料。参考资料中，有很多都是英文的，我知道你会觉得很难啃，但相信我，这些一手的英语资料能给你带来更大的帮助。</p><!-- [[[read_end]]] --><p>所有的推荐资料，我都帮你打上标签了，有入门类、实践类、课程类、开源库等等，你也可以把这一讲当作一个手册来用，这些标签能够方便你按需查找。</p><h2>语言和框架</h2><p>学习 React Native，我们首先需要建立起对 React Native 的整体认知，然后才是学习开发语言 JavaScript/Typescript ，以及开发框架 React。我们接下来就这个逻辑进行推荐。</p><p><strong>第一类：React Native 快速入门。</strong></p><p>首先，我们必须清楚这样一个事实，互联网行业的竞争非常激烈，技术迭代也很快，一篇技术博客发出来，你三四年后再回头看可能就过时了。我在给你挑选学习 React Native 类资料时，就面临这个问题，除了官网和一些收费网课外，能选择的太少。最后我选择了下面这几类：</p><ul>\n<li>&lt;入门-英文&gt; <a href="https://www.youtube.com/watch?v=0-S5a0eXPoc">React Native Tutorial for Beginners - Build a React Native App [2020]</a>：虽然这是两年前的资料了，但绝大部分内容直到现在也没有过时，而且视频的形式，也能带着新手一步一步操作学习，效率很高；</li>\n<li>&lt;网站-英文&gt;<a href="https://www.reactnative.express"> React Native Express </a>：适合想快速了解 React Native 中各种概念的新人；</li>\n<li>&lt;课程-英文&gt; <a href="https://www.udemy.com/course/the-complete-react-native-and-redux-course/">The Complete React Native + Hooks Course</a>：这是优达学院最受欢迎的 React Native 视频课程。它是基于 React Native 0.62 版本开发的付费课程，内容详细而且完整，包括入门、React、Hooks、样式、导航、状态、布局、请求，以及搭建一个简易 React Native 应用，也是非常适合新手的入门课程。</li>\n</ul><p><strong>分类二：学习 JavaScript。</strong></p><p>如果你以前从事的是客户端开发，没有 JavaScript 开发经验，你可以参考如下资料：</p><ul>\n<li>&lt;入门-中英&gt;<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/A_re-introduction_to_JavaScript">MDN JavaScript 教程</a>：MDN 是前端同学必备的网站，它的内容非常权威，如果你有编程基础，通过这一篇文章你就能快速掌握 JavaScript；</li>\n<li>&lt;电子书-中文&gt;<a href="https://es6.ruanyifeng.com/">ES6 入门教程</a>：ES6 相当于 JavaScript 的一个“版本号”。ECMAScript 规范每年都会更新一个版本，ES6 对应的是 ECMAScript 2015 的版本，今年的最新版本是 ECMAScript 2022。但由于 ES6 对于 JavaScript 有划时代的意义，所以也是最广为人知的版本，你既可以它当作入门书籍一步步学习，也可以把它当作手册进行查询；</li>\n<li>&lt;练习-英文&gt;<a href="https://learnjavascript.online/">Learn JavaScript 网站</a>：如果你觉得光看资料很难学好 JavaScript，你也可以用这个网站边学边练。它提供了学习 JavaScript 的思维导图，把 JavaScript 的知识分为了 13 个部分。其中的 DOM 部分虽说是浏览器的专属，但 React Native 新架构底层操作 Shadow Node 也是用的类似的 API，这一部分了解即可，不需要深入学习。你可以根据思维导图，看看自己还需要学习哪些部分。</li>\n</ul><p><img src="https://static001.geekbang.org/resource/image/94/2f/94641698af229e54db92584b1bd9452f.png?wh=1920x1780" alt="图片"></p><p><strong>分类三：学习 TypeScript。</strong></p><p>如果你真要写业务项目的话，无论这个项目是大是小，我都推荐你用 TypeScript 而不是 JavaScript。TypeScript 的静态类型检查功能，不仅能减少潜在的线上 Bug，还能提高项目的可维护性，这些对于业务都至关重要。这部分的资料我推荐：</p><ul>\n<li>&lt;入门-中文&gt;<a href="https://juejin.cn/post/6844904182843965453">1.2W字 | 了不起的 TypeScript 入门教程</a>：这是掘金最受欢迎的 TypeScript 入门课程，作者将 TypeScript 的入门知识分为了十四个知识点，一步步带你学习，同时作者还给了一个 TypeScript 思维导图，我把它放在了下面；</li>\n</ul><p><img src="https://static001.geekbang.org/resource/image/1f/54/1f411eac983d3c28b7028e565685b654.png?wh=1000x844" alt="图片"></p><ul>\n<li>&lt;练习-中英&gt;<a href="https://github.com/type-challenges/type-challenges">Type Challenges</a>：如果你觉得光看文字不过瘾，你可以结合 Type Challenges 和 TypeScript 官网提供在线编辑器一起练习；</li>\n<li>&lt;实用-英文&gt;<a href="https://github.com/typescript-cheatsheets/react">React+TypeScript Cheatsheets</a>：真正开发的时候，TypeScript 和 React 是结合起来一起用的，React 自定义了很多 Type 类型，使用这个小抄本能帮你快速掌握 TypeScript 和 React 结合使用的最佳实践。</li>\n</ul><p><strong>分类四：学习 React。</strong></p><p>对于 React 的学习，我唯一推荐的资料是 <a href="https://beta.reactjs.org/">React 新官方</a>，里面的每一篇文章我都认真读过，每一篇都是经典。可惜的是，它还是 Beta 版本，官方分为两部分：</p><ul>\n<li>&lt;教程-英语&gt;<a href="https://beta.reactjs.org/learn">Learn React</a>：这部分既有初学者入门的教程，也有深入学习的教程，同时还有配套的示例和练习材料。目前 Learn React 部分完成了 70%，但对于入门和进阶来说，已完成的 Learn React 部分已经完全够用了；</li>\n<li>&lt;手册-英语&gt; <a href="https://beta.reactjs.org/apis">API Reference</a>：这部分是 React 的 API 手册，目前这部分只完成了 5%，所以你要查询 API 只能到 <a href="https://zh-hans.reactjs.org/">React 老官网</a>上去查询了。</li>\n</ul><p>另外，我还为你附上了 React 核心知识的学习路径图，这张图来源于 <a href="https://roadmap.sh">roadmap.sh</a>，它是一个专门创建学习路线图的社区。因为你只需要学习 React 的基础知识和进阶知识，所以其中的Web 内容我去掉了，可以对照 React RoadMap 看下自己哪些已经掌握了，哪些还要进一步的学习：</p><p><img src="https://static001.geekbang.org/resource/image/40/2f/40f83f368e0f5b7e5b9fc159c9497f2f.png?wh=1920x1251" alt="图片"></p><h2>项目工程</h2><p>上一部分主要是打基础，接下来创建项目之前，我们还要考虑用项目中的技术选型，包括脚手架、包管理、状态管理、自动化测试，等等。</p><p><strong>第一部分：脚手架。</strong></p><p>在脚手架的选择上，每个团队都会有自己的偏好，创建项目的选择也不一样，你可以根据自己团队的情况四选一：</p><ul>\n<li>&lt;脚手架-中文&gt;<a href="https://reactnative.dev/docs/next/environment-setup">react-native init</a>：首先 React Native 官方提供了 react native init 命令，它属于脚手架的基础款；</li>\n<li>&lt;基础设施-英文&gt;<a href="https://docs.expo.dev/">Expo</a>：它帮你集成了一系列的原生工具和能力，还能帮你构建和部署，并同时支持 Android、iOS 和 Web。Expo 不仅仅是一个脚手架，更是一套 React Native 的基础设施。在国内，主要是出海的应用在用；</li>\n<li>&lt;功能模块-英文&gt;<a href="https://docs.expo.dev/bare/installing-expo-modules/">Expo modules</a>：如果你团队开发的应用，用户群主要在国内，而且需要用户自己独立构建和部署，Expo 提供的原生工具和能力也可以单独按需使用；</li>\n<li>&lt;脚手架-英文&gt;<a href="https://github.com/infinitered/ignite">Ignite</a>：这是由一群美国的开发人员和设计师组成的组织 Infinite Red 开发的，这个脚手架会帮你做包管理、状态管理、自动化测试等方面技术选型，所以你不需要做这些选型和配置工作了，开箱即用就行。</li>\n</ul><p><strong>第二部分：包管理。</strong></p><p>在第三方包的管理上，业内常见的方案有三种。它们之间的差别并不大，但根据我的经验，我更加推荐你用 yarn。它们主要的区别在这：</p><ul>\n<li>&lt;推荐-中文&gt;<a href="https://yarn.bootcss.com/">yarn</a>：yarn是 Meta 团队开源的包管理工具，在安装包的速度上和功能上，都比 npm 更强一些。需要注意的是，你用 Yarn 的 classic 版本就可以了，yarn 的 v2、v3 版本相对 classic 版本变化太大，用的人也较少；</li>\n<li>&lt;自带-中文&gt;<a href="https://www.npmjs.cn/">npm</a>：这是 node.js 自带的包管理工具，你在搭建 React Native 环境时就已经安装了 node.js，因此 npm 直接可以用；</li>\n<li>&lt;更快-中文&gt;<a href="https://www.pnpm.cn/">pnpm</a>：它是比 npm 和 yarn 速度更快的包管理工具，Ignite 脚手架就是在用 pnpm 管理包。但我在使用 pnpm 搭建 React Native 的 monorepo 项目时，碰到了和打包工具  metro 的兼容问题，后续就放弃使用了。</li>\n</ul><p><strong>第三部分：状态管理。</strong></p><p>状态管理是一个很复杂的话题，我们这里简单介绍一下，React/React Native 的状态管理可以分为四类：</p><ul>\n<li><strong>React 自带</strong>：包括 <a href="https://zh-hans.reactjs.org/docs/hooks-reference.html#usestate">useState</a>、<a href="https://zh-hans.reactjs.org/docs/hooks-reference.html#usereducer">useReducer</a> 和 <a href="https://zh-hans.reactjs.org/docs/hooks-reference.html#usecontext">useContext</a>。当你准备用 useContext 的时候，你可能就需要使用社区状态管理工具了，因为 useContext 需要大量的手动性能优化，不适合大规模使用；</li>\n<li><strong>第三方库</strong>：常用的方案有 <a href="https://redux-toolkit.js.org/">Redux + Redux Toolkit</a>、单独的 <a href="http://cn.redux.js.org/">Redux</a>、<a href="https://cn.mobx.js.org/">Mobx</a> 和 <a href="https://github.com/pmndrs/zustand">Zustand</a>，在我以前做的<a href="https://docs.qq.com/sheet/DQWdsZ0RORkpFQmVj?tab=BB08J2">《大家开发 RN 都用什么？》</a>调研报告中，我发现大家用的最多的还是 Redux，但是 Redux 单独使用起来成本高，因此我建议你配合 Redux Toolkit 一起使用；</li>\n<li><strong>hooks 工具</strong>：hook 是一种抽象和复用组件状态逻辑的机制，因此 hooks 类工具很多，常用的、能帮我们管理部分状态 hooks 工具主要是这几类。<a href="https://react-query.tanstack.com/">react query</a> 和 <a href="https://github.com/vercel/swr">SWR</a> 可以帮我们管理请求，<a href="https://github.com/react-hook-form/react-hook-form">react-hook-form</a> 和 <a href="https://github.com/jaredpalmer/formik">formik</a> 可以帮忙管理表单；</li>\n<li><strong>GraphQL</strong>：现在后端接口大多是采用(类) RESTful 架构，我们用的 GET、POST 请求就是这种架构。相对于 RESTful 架构，GraphQL 提供了一种更加灵活的请求后端接口的方案。GraphQL 是一种架构模式、是一种规范，业内有两种具体的实现，一种是开源社区常用的 <a href="https://apollographqlcn.github.io/react-docs-cn/">Appolo</a> 方案，另一种是 Meta 团队开源的 <a href="https://relay.dev/">Relay</a> 方案。</li>\n</ul><p>这四类状态管理工具，不同类别之间可以灵活搭配使用，我在下面的状态管理表单图中，用绿点给你标注了我的推荐，蓝框中的工具是同一类工具，二选一即可：</p><p><img src="https://static001.geekbang.org/resource/image/f0/a3/f05e2c114ffb27651cf98a967dee5ea3.png?wh=1920x996" alt="图片"></p><p><strong>第四部分：自动化测试。</strong></p><p>国内业务类的测试主要还是以 QA 测试为主，但一些由技术主导的通用组件和通用工具，有时候不一定有 QA 资源帮忙测试，这时候自动化测试就能派上用场了。我这里也给出了一些推荐：</p><ul>\n<li>&lt;单元测试-中文&gt;<a href="https://jestjs.io/zh-Hans/">Jest</a>：这是 Meta 团队开发的一款 JavaScript 单元测试框架，单元测试中的单元指的是最小可测试粒度的函数单元。</li>\n<li>&lt;组件测试-英文&gt;<a href="https://github.com/callstack/react-native-testing-library">react-native-testing-library</a>：这是专门用来测试 React Native 组件的。比如，它提供了 render 方法可以专门测试组件渲染是否正确，fireEvent 方法可以专门用来测试事件返回值是否正确；</li>\n<li><a href="https://github.com/wix/Detox">Detox</a>：它可以帮你在真机/模拟器运行测试代码，更符合真实环境。</li>\n</ul><h2>样式和组件</h2><p>脚手架搭建好之后，就到具体开发环节了。在这个环节中，最重要的就是组件和样式的学习。</p><h3>样式</h3><p>样式分为两类，一类是写样式的工具函数，另一类是自带风格样式的组件库，我们这里简单介绍一下，先来看看样式工具。</p><p>样式工具可以分为三小类：</p><ul>\n<li>第一类是 React Native 自带了 “CSS In JS” 的 <a href="https://reactnative.cn/docs/next/stylesheet">StyleSheet</a> 接口；</li>\n<li>第二类是 <a href="https://styled-components.com/">StyledComponent</a> 这种方案，如果你喜欢纯正的 CSS 语法，可以选用这种；</li>\n<li>第三类是 CSS 的“简拼”方案 <a href="https://www.tailwindcss.cn/">Tailwind</a>，它和 CSS 的区别类似我们打字时全拼和简拼区别，能让你敲击键盘的次数更少一些，但你需要记住它的“简拼”规则，而且还有一定的性能损耗。</li>\n</ul><p>我认为在 React Native 中使用 StyleSheet 方案就够了，StyledComponent 和 Tailwind 并不是我的菜。</p><p>然后我们再来看看组件库。类似于 Web 中最流行的 AntDesign 组件库，React Native 也有很多自带风格样式的组件库。</p><p>虽然，移动端的 toC 应用大多都有 UI 帮忙出设计稿，开发同学需要根据设计稿定制开发，所以toC 应用基本是不用组件库的。但移动应用也有很多 toB 应用，这些应用使用组件库开发，能够解决很大一部分的开发成本。</p><p>我最推荐的是近两年最活跃的组件库 <a href="https://nativebase.io/">Native Base</a>，你也可以根据你们团队的喜好选择其他风格的组件库，其他常用的还有 <a href="https://reactnativeelements.com/">React Native Elements</a>、<a href="https://reactnativepaper.com/">React Native Paper</a>、<a href="https://akveo.github.io/react-native-ui-kitten/">UI Kitten</a>。</p><h3>组件</h3><p>组件包括核心组件和一些我们国内常用的组件。所谓的核心组件是我们开发 React Native 应用时使用频率很高的组件，包括路由、手势、动画，这些组件我也会在生态篇进行更详细地介绍，今天你可以先简单了解一下。</p><p>我们先来看看路由这方面有什么解决方案。其实，React Native 本身并没有提供路由解决方案，但社区提供了一些解决方案，包括<a href="https://reactnavigation.org/">React Navigation</a>、<a href="https://wix.github.io/react-native-navigation/docs/before-you-start/">React Native Navigation</a>这两种。这两个库的名字很相似，也都是路由库，但你千万不要搞错了。目前业内主流的选择是 React Navigation，而不是 React Native Navigation，前者的下载量是后者的 20 倍之多，因此我推荐你直接使用 <a href="https://reactnavigation.org/">React Navigation</a> 方案就可以了。</p><p>那手势这边有啥呢？React Native 本身提供了手势事件 PanResponder。PanResponder 是模仿 Web 的手势事件开发的，是命令式的手势事件，它的替代方式是社区开发的 react-native-gesture-handler。react-native-gesture-handler 是声明式的组件，会更符合我们的开发习惯。</p><p>最后再来看看动画的解决方案。动画常用的方案有这三种：</p><ul>\n<li>第一种是 React Native 本身提供的 <a href="https://reactnative.cn/docs/animated">Animated</a> API；</li>\n<li>第二种是社区提供的 <a href="https://docs.swmansion.com/react-native-reanimated/">Reanimated</a> 组件；</li>\n<li>第三种是直接接入设计师使用的 AE 输出的 <a href="https://github.com/lottie-react-native/lottie-react-native">Lottie</a> 动画。</li>\n</ul><p>那这三个方案怎么来进行选择呢？你可以根据具体的业务情况来选择：如果是轻量级的动画，你不想多集成一个库，那你可以直接使用 Animated；如果你对性能要求高又要大规模使用， 那Reanimated 是你最好的选择；最后 <a href="https://github.com/lottie-react-native/lottie-react-native">Lottie</a> 的方案，适合那种没有人机交互的、由 UI 直接提供动画配置文件的动画形式。</p><p>除了前面说的核心组件之外，我们还得关注一些国内常用的组件。因为我们国内客户端生态和国外生态差别很大，很多国外的东西我们不能直接拿来用，而且国内社区的同学也封装了一些我们自己的解决方案。我把一些常用的都列出来了，你可以关注一下：</p><ul>\n<li>&lt;流媒体-中英&gt;<a href="https://github.com/AgoraIO-Community/react-native-agora/blob/master/README.zh.md">react-native-agora</a>：国内做语音、视频、直播很多用的都是<a href="https://www.agora.io/cn">声网</a>的解决方案，该组件是由声网官方维护的 React Native 组件库；</li>\n<li>&lt;HarmonyOS-英文&gt;<a href="https://github.com/HMS-Core/hms-react-native-plugin">hms-react-native-plugin</a>：华为HarmonyOS系统为 React Native 开发的插件，由华为HarmonyOS官方开发维护；</li>\n<li>&lt;推送-中文&gt;<a href="https://github.com/jpush/jpush-react-native">jpush-react-native</a>：JPush 也就是极光推送，是国内客户端的推送解决方案了；</li>\n<li>&lt;地图-中文&gt;<a href="https://github.com/lovebing/react-native-baidu-map">react-native-baidu-map</a>：是社区基于百度地图 Native SDK 封装的 React Native 组件，不过这个已经很久没有更新了，需要自己动手改改才能用。</li>\n</ul><h2>总结</h2><p>这一讲和往常的内容有点不一样，以前讲的内容是技术的深度，这一讲讲的是技术的广度。</p><p>知识输入决定技术输出，我推荐的技术资料大多都是英文资料，如果你放弃了英语类的技术资料，技术的深度和广度提升的速度都会比别人慢一些。这个道理是我从刘毅老师那里学来的，刘毅老师是中国的第一批 Java 程序员，现在是章鱼网络创始人，和刘毅老师交流和学习的时候，经常感叹他为什么对技术研究得这么深刻。</p><p>有一次我就问刘毅老师我说，“您在技术上这么厉害，最关键的原因是什么呢？”刘毅老师告诉我，是英语。他和我解释说最厉害那批程序员大多数都是用英语交流的，他经常去看这些论坛、博客，这样能接触到最前沿知识。</p><p>要想提高自己的技术广度，要想接触到最前沿的知识，这些英文资料肯定少不了。我再给你举个例子，比如 @reduxjs/toolkit 这个状态管理工具已经出来两年了，而且迭代速度很快，但是并没有中文官网。如果你只看中文资料，接触到可能是中文资料作者理解“二手”内容，或者是一年前写的、已经被淘汰的知识。</p><p>因此，在学习 React Native 生态时，我强烈建议你不要对“中文”、“英文”资料有语言偏好，只看中文资料，不看英文资料。我建议你要对“权威的”、“二手的”资料有偏好，并不是说“二手”资料没有价值，而是“权威”资料可以帮你建立一个正确的基准。有了这个基准后，你就有了分辨对错、分辨好坏的能力，再去读“二手”资料就能知道别人讲得好不好、对你有没有价值了，没有这个基准就容易被带偏。</p><p>所以你也能看到，我在给你推荐资料时，多推荐的是“权威”的资料，为的就是帮你建立一个基准认知。我们今天这一讲相当于一个介绍 React Native 生态的手册，目的就是帮你正确地提高技术广度，当你对其中某个内容感兴趣的时候，你可以点击我推荐给你的链接进行更详细地学习。遇到英文材料也不要害怕，你也借助翻译软件 DeepL，边学技术边提升英语能力。相信我，这样你的技术能力会突破得更快。</p><h2>思考题</h2><p>我这一讲中根据我的偏好做了一个精选推荐，你有哪些自己喜欢的学习资料、工具、组件、资源和大家推荐的呢？</p><p>欢迎在评论区和我们分享。我是蒋宏伟，咱们下节课见。</p>',
        article_title: "13｜生态：React Native Awesome",
      },
      {
        title: "14｜Reanimated：如何让动画变得更流畅？",
        id: 513844,
        content:
          '<p>你好，我是蒋宏伟。</p><p>今天我们来聊一聊React Native中动画的原理。在开始之前，我想请你思考一下：动画的本质到底是什么？</p><p>你可能知道，与真实世界中连续运动的事物不同，我们在手机、电脑、电影院的屏幕中看到的动画，实际是由一张张快速切换图片组成的。看动画时，我们的眼睛接收到的是一张张并不连续的静态图片，但我们的大脑把这些不连续的图片“想象”成了一系列连续事件，这就是动画的基本原理。</p><p>而手机动画要想流畅，一般而言需要保证每 1 秒渲染 60 帧的速度。这里的每一帧都是一张静态图片，也就是说 1 秒钟需要渲染出 60 个静态图片。这也意味着手机处理每一帧动画的耗时，需要保证在 16.6ms（=1000/60）以内，如果处理一帧的耗时超过 16.6ms ，就会掉帧。掉帧多了，我们的大脑就会感觉到动画中的不连续性，也就是常说的卡顿。</p><p>动画对渲染性能的要求很高。理论上，你可以使用 setInterval 每 16.6ms 执行一次 setState 改变状态，渲染新的视图，来实现动画。但实际上，setState 是一种耗时比较长的更新页面的方法，特别是在复杂页面、复杂交互的情况下，setInterval  + setState 的方案并不适合用来实现动画。</p><!-- [[[read_end]]] --><p>所以，为了保障动画的流畅性，在涉及动画的业务场景中，<strong>我们还需要引入动画库</strong>。</p><p>在上一讲中，我给你介绍了 React Native 中常用的三种动画工具，包括：适合轻量级动画场景使用的 React Native 自带的 <a href="https://reactnative.cn/docs/animated">Animated</a> 动画；适合无交互场景的、能找 UI 设计师帮忙自动生成的 <a href="https://github.com/lottie-react-native/lottie-react-native">Lottie</a> 动画；以及我今天重点要和你聊的、适用于可交互场景的 <a href="https://docs.swmansion.com/react-native-reanimated/">Reanimated</a> 动画。</p><h2>初学 Reanimated</h2><p>Reanimated 的名字来源于它的那句口号：</p><blockquote>\n<p>React Native’s Animated library reimplemented.</p>\n</blockquote><p>Reanimated 名字中的 Re 就是 Reimplemented 重新实现的意思，Animated 代表就是 React Native 自带的动画库 Animated，加起来就是重新实现的 Animated 动画库的意思。它的潜台词好像就是：如果你觉得 React Native 自带的 Animated 动画库不好用，就来试试我吧，我把 React Native 官方的动画库给重新实现了。</p><p>我们先用<strong>“切换宽度的动画”</strong>的例子，看看 Reanimated 到底应该如何使用。</p><p>这个例子是这样的：现在你有一个视图和一个按钮，视图的高度是固定的，视图的宽度可以用动画来控制，你每点一下切换宽度的文字，视图宽度都会随机改变。示意图如下：</p><p><img src="https://static001.geekbang.org/resource/image/05/69/05ae457ac9eba406300aafa246549069.png?wh=1920x886" alt="图片"></p><p>你可以看到，在页面中蓝色视图初始化的宽度是 10 像素，当你点击切换宽度的文字后，蓝色视图的宽度会在 0~350 像素之间随机变化。因为是动画，所以蓝色视图的宽度并不是一下就变宽的，而是连续改变的。在 1s 内，先增长几像素，然后再增长几像素，依次类推直到目标长度，因为刷新的帧率很快，因此人的肉眼看起来就是宽度就是连续变化的。</p><p>那我们怎么用Reanimated实现这个动画效果呢？</p><p>别急，为了帮你更好地吃透这个新知识，我们引入之前学过的State，对比着来学习。那么，使用 Reanimated 实现视图“动画”和使用 State 实现视图“变化”有什么相似之处呢？你可以看下它们的更新步骤的对比：</p><p><img src="https://static001.geekbang.org/resource/image/b4/7e/b4653520a9bd29e348671f19b439317e.png?wh=1920x970" alt="图片"></p><p>你可以看到，无论是用 State 更新页面，还是用 Reanimated 更新动画，都需要 4 步。具体它们有什么相似之处呢？我们直接来分析 Reanimated中的这4个概念：</p><p>第一个概念：共享值（SharedValue）。<strong>Reanimated中共享值这个概念类似于 React 中的状态 State</strong>，我们简单对比下它们各自的代码，先看看State的：</p><pre><code class="language-plain">// State 示例代码\nimport { useState } from \'react\';\nconst [randomWidth, setRandomWidth] = useState(10);\n// randomWidth === 10\n</code></pre><p>在 State 示例代码中，驱动视图变化的最初因子是状态。用于初始化状态的钩子函数 useState 是从 react 中引入的，然后在组件中使用 useState 创建出一个随机宽度状态 randomWidth，以及一个改变该状态的函数 setRandomWidth。其中，初始化出来的 randomWidth 是一个默认赋值数字10。</p><p>接着我们看看Reanimated的代码：</p><pre><code class="language-plain">// Reanimated 示例代码\nimport { useSharedValue} from \'react-native-reanimated\';\nconst randomWidth = useSharedValue(10);\n// randomWidth.value === 10\n</code></pre><p>在 Reanimated 的示例代码中，驱动动画的最初因子是共享值（ShareValue）。用于初始化共享值的钩子函数 useSharedValue 是从 react-native-reanimated 中引入的。然后使用 useSharedValue 创建出一个对象 randomWidth，randomWidth 的 value 属性是一个默认赋值数字 10。</p><p>第二个概念：衍生值（DerivedValue）。<strong>Reanimated 的衍生值（DerivedValue）这个概念类似于 React 中的状态衍生值</strong>。我们同样先来看State的示例代码：</p><pre><code class="language-plain">// State 示例代码\nconst style = {\n  width: randomWidth\n}\n</code></pre><p>在 State 示例代码中，你可以在组件函数中的任意位置直接使用状态 randomWidth，或者将状态 randomWidth 封装到样式对象 style 中。</p><p>然后是Reanimated的示例代码：</p><pre><code class="language-plain">// Reanimated 示例代码\nimport { useAnimatedStyle } from \'react-native-reanimated\';\n\n// 错误示范\nconst style = {\n  width: randomWidth.value\n}\n\n// 正确示范\nconst style = useAnimatedStyle(() =&gt; {\n  return {\n    width: randomWidth.value,\n  };\n});\n</code></pre><p>但在 Reanimated 示例代码中，如果你直接将  <code>const style = {width: randomWidth.value}</code> 组成的样式对象赋值给 JSX 元素，控制视图宽度改变的动画是不生效的。这是 Reanimated 驱动动画和 State 驱动视图的机制不一样导致的。</p><p>这时你需要从 react-native-reanimated 中引入钩子函数 useAnimatedStyle，这个钩子函数是专门用来处理动画样式的衍生值的，它的第一个入参函数的返回值就是动画组件的样式值。</p><p>第三个概念，动画组件（AnimatedComponent）。<strong>Reanimated 的动画组件和 React/React Native 中的组件（Component）概念是类似的</strong>。我们同样先看 State 示例代码：</p><pre><code class="language-plain">// State 示例代码\nimport { View } from \'react-native\';\n\n&lt;View style={[{ width: 100}, style]} /&gt;\n</code></pre><p>在 State 示例代码中，你要从 react-native 库中引入 View 组件，并将组件 View 实例化为 JSX 元素。</p><p>然后再看Reanimated的示例代码：</p><pre><code class="language-plain">// Reanimated 示例代码\nimport Animated from \'react-native-reanimated\';\n\n&lt;Animated.View style={[{ width: 100}, style]} /&gt;\n</code></pre><p>你可以看到，在 Reanimated 示例代码中，你需要从 react-native-reanimated 引入 Animated 对象，在该对象上挂了常用的 react-native 组件，比如示例代码中的 <code>Animated.View</code>，还有 <code>Animated.Text</code>、 <code>Animated.FlatList</code>等等。</p><p>这些由 Reanimated 包装好的动画组件，比如 <code>Animated.View</code> 等等，使用方式和 <code>View</code> 基本类似。不同的是共享值（ShareValue）和衍生值（DerivedValue）是专门给动画组件（AnimatedComponent）用的，普通组件（Component）用不了。</p><p>第四个概念，更新共享值。<strong>Reanimated 的更新共享值的方式和 React/React Native 更新状态的方式方式是不一样的。</strong></p><p>State的示例代码如下：</p><pre><code class="language-plain">// State 示例代码\nconst [randomWidth, setRandomWidth] = useState(10);\nsetRandomWidth(Math.random() * 350)\n</code></pre><p>在 State 示例代码中，你是通过钩子函数 useState 生成的状态更新函数 setRandomWidth 来更新状态的。</p><p>然后是Reanimated的示例代码：</p><pre><code class="language-plain">// Reanimated 示例代码\nconst randomWidth = useSharedValue(10);\n// 不带动画的更新\nrandomWidth.value = Math.random() * 350;\n// 带动画的更新\nrandomWidth.value = withTiming(Math.random() * 350);\n</code></pre><p>我们可以看到，在 Reanimated 示例代码中，没有共享值的更新函数，它只生成了一个共享值对象，其真正的值是挂在 value 属性下的。你可以直接通过等号 <code>=</code> 把最新的视图宽度 <code>Math.random() * 350</code> 赋值给<code>randomWidth.value</code>。</p><p>事实上，Reanimated 有两种更新方式，一种是不带动画曲线的更新方式，另一种是带<strong>动画曲线</strong>的更新方式。</p><p>你直接把视图宽度 <code>Math.random() * 350</code> 赋值给<code>randomWidth.value</code>，就是通过指定一个最终共享值的方式进行更新的，比如从 10 像素宽度直接变为 100 像素宽度。这种更新方式是一步到位的，没有动画曲线。</p><p>真正的动画是从 10 像素宽度，增长到 11 像素，然后增长到 12 像素，以此类推，通过连续的方式增长到 100 像素宽度的。具体地说，控制每一帧增长多少像素、减少多少像素，是通过类似 <code>withTiming</code> 的动画曲线实现的。<code>withTiming</code> 动画曲线的意思是，启动一个基于时间的动画，在每个单位时间内增长或减少的像素是相等的。</p><p>使用 <code>withTiming(100)</code> 更新共享值时，就会启动基于时间的动画曲线，其默认的持续时间是 300ms。理论上，在这 300ms 内，视图的宽度会从 10 像素开始，以每一帧增加一个固定的宽度的速度，增加到 100 像素。</p><p>切换宽度动画的完整示例代码如下：</p><pre><code class="language-plain">import Animated, {\n  useSharedValue,\n  withTiming,\n  useAnimatedStyle,\n  Easing,\n} from \'react-native-reanimated\';\nimport { View, Button } from \'react-native\';\nimport React from \'react\';\n\nfunction AnimatedStyleUpdateExample(): React.ReactElement {\n  const randomWidth = useSharedValue(10);\n\n  const style = useAnimatedStyle(() =&gt; {\n    console.log(\'==Animated==\')\n    return {\n      width: withTiming(randomWidth.value),\n    };\n  });\n\n  console.log(\'==render==\')\n\n  return (\n    &lt;View&gt;\n      &lt;Animated.View\n        style={[\n          { width: 100, height: 30, backgroundColor: \'cornflowerblue\'},\n          style,\n        ]}\n      /&gt;\n      &lt;Button\n        title="切换宽度"\n        onPress={() =&gt; {\n          randomWidth.value = Math.random() * 350;\n        }}\n      /&gt;\n    &lt;/View&gt;\n  );\n}\n</code></pre><p>从上面的代码你可以看出，使用 Reanimated 更新动画的方式和使用 State 更新页面的方式，有很多相似之处。</p><p>其中，还有一点是你需要注意的，就是 <strong>Reanimated 和 State 的更新机制并不一样</strong>。</p><p>在使用 Reanimated 改变共享值触发动画更新时，只会触发示例代码中 useAnimatedStyle 的入参函数的执行，而不会触发 AnimatedStyleUpdateExample 组件函数的执行。也就是说，动画更新是不会打印 “==render==” 日志的，只会打印“==Animated==”日志。</p><p>但整体上讲，二者都是通过数据来驱动视图变化。Reanimated 是专门用来处理动画形式的视图更新的，而 State 是专门用来处理组件、页面渲染的视图更新的。</p><h2>Reanimated 的原理</h2><p>关于 Reanimated 的入门概念，我们先介绍到这里，相信通过 Reanimated 和 State 的类比学习，你已经能把 Reanimated 用起来了。</p><p>但这种学习方式难免可能让你对概念掌握得不够准确，甚至出现一些理解偏差。所以接下来我们要再进一步，了解Reanimated 工作原理，把其中的基础概念弄扎实了，把一些理解有误的地方纠正回来。</p><p>在开发过程中，我们的动画代码和状态代码都是用 JavaScript 写在同一个文件中的，你可能会认为你写的动画部分的 JavaScript 和状态部分的 JavaScript 都是运行在同一个线程中的，但其实并不是这样的。</p><p>听到这个结论，你可能会很惊讶：<strong>为什么动画代码和状态代码都放在同一个JavaScript 文件中，但动画部分代码却由另一个线程来执行呢？</strong></p><p>答案就是：把动画代码放到 UI 主线程来执行性能会更好，动画不容易卡顿。</p><p>你可能知道， React Native 有两个常用的线程：一个是 React Native 的 JavaScript 线程，另一个是 UI 主线程。</p><p>一方面，JavaScript 线程和 UI 主线程是异步通信的，这也意味着，如果是由 JavaScript 线程发起动画的执行，UI 线程并不能同步地收到该命令并且立刻执行，UI 线程至少要处理完成当前一帧的渲染任务后，才会执行 JavaScript 线程的动画命令。也就是说异步通讯会导致动画至少延迟 1 帧。</p><p>另一方面，JavaScript 线程处理的事件很多，包括所有的业务逻辑、React Diff、事件响应等等，容易抢占动画的执行资源。</p><p><strong>正因为 JavaScript 线程非常繁忙，所以如果我们把动画代码交由 JavaScript 线程执行，它就会更加繁忙。</strong>前面我们也讲过，处理 1 帧动画的耗时需要控制在 16.6ms 以内，如果超过 16.6ms 就会导致动画掉帧，掉帧严重的时候，用户就会感觉到卡顿。</p><p>好，既然动画部分的 JavaScript 代码放在  JavaScript 线程中执行，存在至少1帧的延迟，并且容易导致卡顿。那我们的解决方案是什么呢？</p><p>有两种思路。</p><p><strong>第一种思路就是React Native 自带的 Animated 动画库用的思路</strong>。它是在组件初始化时，把动画的初始值、动画的形式、动画的结束值等配置都传给 UI 主线程。开发者有个开启 UI 主线程执行动画任务的开关 useNativeDriver，当开发者开启 useNativeDriver 这个开关后，动画就是在 UI 主线程执行了。</p><p>但是 Animated 动画库的缺陷也很明显，它传给 UI 主线程的是动画配置。配置只是单纯的数据，它不具备图灵完备的特性，不能配置复杂的逻辑。所以React Native 官方也指出了：Animated 不能用来改变元素宽度、高度等布局属性，不能处理除了 ScrollView 组件的 onScroll 事件外的其他手势事件。</p><p>换句话说，在保障性能的前提下，简单的动画、无交互的动画，我们可以用自带的 Animated 动画库来处理；如果是逻辑稍微复杂点的、带交互的动画，自带的 Animated 动画库就干不了了。</p><p>那 Reanimated 动画库能够处理复杂动画、有交互的动画吗？它是怎么做到的呢？</p><p>可以。Reanimated 动画库采用了另一种思路，它把动画相关的 JavaScript 函数及其上下文传给了 UI 主线程。不过，UI 主线程并没有能运行 JavaScript 函数的虚拟机，于是 Reanimated 又创建了一个 JavaScript 虚拟机来运行传过来的 JavaScript 函数。</p><p>换句话说，在使用 Reanimated 之前，React Native 只会在 JavaScript 线程创建一个 JavaScript 虚拟机，来运行 JavaScript 代码。而使用 Reanimated 之后，Reanimated 会在 UI 主线程中创建另一个 JavaScript 虚拟机来运行动画部分相关的代码。</p><p>我给你画了一张 Reanimated 的原理图，你可以看下，加深一下理解：</p><p><img src="https://static001.geekbang.org/resource/image/70/76/70de3bd8fa6af059a0abe3c7a1db2376.png?wh=1920x944" alt="图片"></p><p>在这张原理图中，你会看到有两个线程：JavaScript 线程和 UI 线程。</p><p>在 JavaScript 线程中包括了三个动画相关的函数或值，<a href="https://github.com/software-mansion/react-native-reanimated/blob/65a31e473b4e9fa4bee83de01e807039f71b7666/src/reanimated2/hook/useSharedValue.ts#L16">useSharedValue</a>（其底层会调用 <a href="https://github.com/software-mansion/react-native-reanimated/blob/65a31e473b4e9fa4bee83de01e807039f71b7666/src/reanimated2/animation/util.ts#L264-L268">cancelAnimation</a> ）、<a href="https://github.com/software-mansion/react-native-reanimated/blob/65a31e473b4e9fa4bee83de01e807039f71b7666/src/reanimated2/hook/useAnimatedStyle.ts#L456-L467">useAnimatedStyle</a> 和 <a href="https://github.com/software-mansion/react-native-reanimated/blob/65a31e473b4e9fa4bee83de01e807039f71b7666/src/reanimated2/hook/useAnimatedGestureHandler.ts#L54-L98">useAnimatedGestureHandler</a>。这三部分的代码会在其底层，将相关的回调函数标记为“worklet” ，被标记的“worklet” 函数或值会被放在一个由 Reanimated 创建的 JavaScript 虚拟机中执行。</p><p>而这个由 Reanimated 创建的 JavaScript 虚拟机，会在 UI 线程中执行传过来的“worklet” 函数，并且执行的函数还可以同步地操作 UI。</p><p><strong>那 JavaScript 线程和 UI主线程是怎么配合工作的呢？</strong></p><p>我们结合宽度切换动画的代码示例，来看下原理图中的各个部分是怎么运行的：</p><pre><code class="language-plain">const randomWidth = useSharedValue(10);\nconst style = useAnimatedStyle(()=&gt;({width: randomWidth.value});\n\n// 运行在 JS 线程的点击事件\nconst handlePress = () =&gt; {\n  randomWidth.value = Math.random() * 350;\n}\n</code></pre><p>在 JavaScript 代码初始化时，先执行的是 useSharedValue 函数，它会生成一个共享值对象 randomWidth。randomWidth 对象上挂了一个 value 属性。这个 value 属性既可以在 JavaScript 线程获取和修改，也可以在 UI 线程中的 JavaScript 虚拟机中获取和修改。</p><p>然后执行的是 useAnimatedStyle 函数。useAnimatedStyle 的入参也是一个函数，Reanimated 会将 useAnimatedStyle 的入参函数和与它相关的上下文都放到 UI 线程中的 JavaScript 虚拟机中。</p><p>最后就是处理点击事件了。但由于这一讲，我们还没有接触到手势 React Native Gesture Handler，所以我先用普通的事件处理函数 handlePress 来处理点击事件了。使用普通的事件处理函数有一个弊端：它是在 JavaScript 线程中触发的。所以，如果要生成的是某种对事件的响应速度有要求的动画，比如拖拽类的动画，就容易导致卡顿。</p><p>解决方案就是把处理点击事件的函数，也放到 UI 线程中，让独立的 JavaScript 虚拟机来执行。这时候，我们就需要用 useAnimatedGestureHandler 将其包装起来，示例代码如下：</p><pre><code class="language-plain">// 运行 UI 线程的点击事件\nconst handleAnimatedPress = useAnimatedGestureHandler({\n    onEnd: (_) =&gt; {\n      randomWidth.value = Math.random() * 350;\n    },\n})\n</code></pre><p>不过，代码中的动画手势处理函数 handleAnimatedPress，需要结合 React Native Gesture Handler 的手势组件一起使用，具体如何结合使用，我们下一讲再讲。</p><p>在这一讲，你只需要知道，我们使用 Reanimated 生成动画的时候，只有在 JavaScript 代码初始化时，相关的动画代码会在 JavaScript 线程执行。初始化完成后，useSharedValue 生成的共享值是在 JavaScript 线程和 UI 线程的 JavaScript 虚拟机中共享的。</p><p>并且，在初始化完成后，useAnimatedStyle 的样式入参函数和 useAnimatedGestureHandler 的手势函数，以及相关的上下文都会放到 UI 线程中的 JavaScript 虚拟机中去。</p><p>简而言之，Reanimated 动画性能好的原因就在于，React Native 的 JavaScript 线程是性能瓶颈点，而 UI 线程不是，<strong>在 Reanimated 真正执行动画时，你已经把所有与动画相关 JavaScript 函数都放到了 UI 线程中独立的 JavaScript 虚拟机中了，并不会和 JavaScript 线程抢占硬件资源，因此 Reanimated 执行动画的性能会更好。</strong></p><h2>附加材料</h2><ol>\n<li>官方的几个入门视频都是 1 个小时以上的，我为你选了一个 17 分钟入门的视频<a href="https://www.youtube.com/watch?v=yz9E10Dq8Bg">《Introduction to React Native Reanimated 2》</a>，可以帮你快速入门。</li>\n<li>入门之后，建议你再看看官方的文章，它会帮你更好的理解 Reanimated2 的 <a href="https://docs.swmansion.com/react-native-reanimated/docs/">原理</a>。</li>\n<li>除了 <a href="https://docs.swmansion.com/react-native-reanimated/docs/api/hooks/useAnimatedStyle">useAnimatedStyle</a> 、<a href="https://docs.swmansion.com/react-native-reanimated/docs/api/hooks/useAnimatedStyle">useAnimatedStyle</a> 和 <a href="https://docs.swmansion.com/react-native-reanimated/docs/api/hooks/useAnimatedGestureHandler">useAnimatedGestureHandler</a> 之外，还有一些钩子函数也可以把它的入参函数放到 UI 线程中执行，包括 <a href="https://docs.swmansion.com/react-native-reanimated/docs/api/hooks/useDerivedValue">useDerivedValue</a>、<a href="https://docs.swmansion.com/react-native-reanimated/docs/api/hooks/useAnimatedScrollHandler">useAnimatedScrollHandler</a>、<a href="https://docs.swmansion.com/react-native-reanimated/docs/api/hooks/useAnimatedReaction">useAnimatedReaction</a> 和 <a href="https://docs.swmansion.com/react-native-reanimated/docs/api/hooks/useAnimatedProps">useAnimatedProps</a>，当然你也可以通过把 <a href="https://docs.swmansion.com/react-native-reanimated/docs/fundamentals/worklets">“worklet”</a>  字面量放到函数顶部，这样  Reanimated 就会把该函数放到 UI 线程中执行了。</li>\n<li>常见的动画曲线有 <a href="https://docs.swmansion.com/react-native-reanimated/docs/api/animations/withTiming">withTiming</a>、<a href="https://docs.swmansion.com/react-native-reanimated/docs/api/animations/withSpring">withSpring</a>、<a href="https://docs.swmansion.com/react-native-reanimated/docs/api/animations/withDecay">withDecay</a> 和 <a href="https://docs.swmansion.com/react-native-reanimated/docs/api/animations/withDelay">withDelay</a>，甚至你还可以使用 <a href="https://docs.swmansion.com/react-native-reanimated/docs/2.2.0/animations/#timing">Easing.bezier</a> 自定义动画曲线。</li>\n<li>这节课中的 Demo，我也放到了 <a href="https://github.com/jiangleo/react-native-classroom/tree/main/src/14_Animated">GitHub</a> 上。</li>\n</ol><h2>总结</h2><p>对于交互类的动画，我们有两种选择，一种是 React Native 自带的 Animated 动画库，另一种是社区的 Reanimated 动画库。</p><p>为了实现流畅的动画效果，二者都把原本来 JavaScript 线程执行的动画任务，放到了 UI 线程中来执行。不同的是，官方动画库采用的是传递动画配置的形式，社区动画库采用的是传递 JavaScript 函数的形式，因此 Reanimated  动画库的应用场景更加广泛。</p><p>在今天这一讲中，我也帮你也搭起了两座知识的桥：一座桥是连接的是 Reanimated  和 State 两个知识点，这座桥的目的是帮你快速学习 Reanimated；另一座桥连接的是 Reanimated 和 React Native 架构，这座桥的目的是帮你弄清楚 Reanimated 的底层原理。</p><p>除了学习 Reanimated 本身知识外，我也希望你能掌握这种“搭桥修路”式的学习方法。你掌握的知识点越多，你搭的桥、修的路就越多，下次你碰到新的知识时，你学习的速度也就越快，进步也就越快。</p><h2>作业</h2><ol>\n<li>这节课，我们通过点击事件来设置视图的宽度。请你使用 <code>Animated.ScrollView</code> 和 <code>useAnimatedScrollHandler</code> 实现通过滚动控制视图大小的动画。</li>\n<li>能说说你在工作中的哪些场景中用到了动画吗？希望你能和我们分享一下你使用动画的心得。</li>\n</ol><p>欢迎在留言区写下你的想法。我是蒋宏伟，咱们下节课见。</p>',
        article_title: "14｜Reanimated：如何让动画变得更流畅？",
      },
    ],
  },
];
