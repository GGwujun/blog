exports.category = "test";
exports.title = "程序员的测试课";
exports.data = [
  {
    chapterTitle: "开篇词",
    children: [
      {
        title: "开篇词 | 为什么写测试是程序员的本职工作？",
        id: 404286,
        content:
          '<p>你好，我是郑晔！</p><p>看到开篇词的标题，你或许会疑惑，测试不是测试人员的本职工作吗？什么时候也成了程序员的本职工作了？</p><p>别急，让我换个问题来问问你。你说，程序员应该懂设计模式吗？大部分程序员都会说应该。而且很多人会说，这难道不是程序员的基本功吗？但你要知道，如果我们把时间往回拨，在 21 世纪初，程序员不懂设计模式才是常态，很多人会嘲笑设计模式让代码变得复杂了。</p><h2>时代在要求我们写测试</h2><p>之所以要说设计模式这个例子，主要是说<strong>程序员的职责范围是随着时间逐步变化的。</strong>这样的例子还有很多，迭代开发也好，开源项目也罢，这原本都不是程序员需要了解的。想当初，哪里有什么迭代开发，一个软件不开发个几年，怎么好意思出来见人。一个项目如果不是所有的代码都自己编写，怎么能有完全的掌控感，谁敢轻易使用别人开发的开源项目。而今天，哪个程序员不知道这些东西呢？</p><p><strong>之所以程序员的职责范围一点点在拓展，关键原因就是，软件开发正在变得越来越复杂。</strong>而加入到程序员职责范围内的这些新东西，正是帮助程序员对抗越来越复杂的软件开发。迭代开发，让我们有机会把精力集中在最重要的功能特性上；开源项目，让我们可以减少不必要的代码编写。</p><p>测试同样如此，它可以让我们在越来越复杂的软件开发中能够稳步前行。一方面，在编写新功能时，测试可以让我们的代码正确性得到验证，让我们拥有一个个稳定的模块。另一方面，测试可以帮助我们在长期的过程中不断回归，让每一步走得更稳。</p><!-- [[[read_end]]] --><p>程序员圈子流传着一个关于测试的段子：每个程序员在修改代码时都希望有测试，而在写代码时，都不想写测试。</p><p>希望有测试，是因为测试可以给我们带来安全感。不想写测试，一方面，很多人会觉得麻烦，另一方面，也是更重要的，团队并没有要求。为什么很多团队不要求程序员都写测试呢？这里有一个很可悲的答案，因为<strong>大部分程序员都不会写测试</strong>。</p><h2>大部分程序员不会写测试</h2><p>看到这个结论，可能你会说，测试有什么难的吗？不就是用 xUnit 之类的单元测试框架写代码吗？程序员每天都在写代码，写代码的事能难倒程序员，这不是开玩笑吗？</p><p>如果你把这个问题抛给一个想写测试的程序员，他会告诉你，为了学着写测试，他了解过 xUnit 的框架，甚至看过人家演示 TDD 如何去做。看别人做起来，他觉得写测试挺容易啊。</p><p>可当他有了跃跃欲试的冲动，看到了自己的代码库，所有的兴奋都烟消云散了，他还是不知道怎么写出一个测试。可能是他的代码库太复杂了，他不知道该从哪里下手；也可能是跟着别人写测试很容易，而到自己写测试的时候，他都不知道第一个测试应该从哪里开始。</p><p>有很多反对自动化测试的程序员，他会给你很多他认为自动化测试不重要的理由。但如果有机会和他深入地聊进去，你会发现，本质的答案是他不会写测试。如果你非要问他测试如何写，他只能给你一些很宏观的角度，比如从接口上去测试、按照需求去测试云云。你会发现，这些原则上正确无误的说法，其实并不能很好地指导你的工作。讨论那么多，能力不足是原罪。</p><h2>你的代码真的是高质量的吗？</h2><p>刚刚我们聊了程序员写测试是大势所趋，以及大部分程序员并不会写测试。可能这还不能够完全说服你来写测试。那么现在我们不妨花一分钟的时间，来仔细想想这样一个问题：你对你编写的代码有信心吗？你能拍着胸脯说这是高质量的代码吗？</p><p>等等，这不是《程序员的测试课》吗？为什么这里要说编写高质量的代码？我是走错片场了吗？相信我，你没走错。<strong>程序员写测试就是为了编写高质量的代码</strong>。这里所说的高质量代码分成两个部分，一方面自然是我们常规理解的：经过测试的代码，质量会更高。另一方面，要想写好测试，代码本身的质量也要高。</p><p><strong>对于今天的程序员来说，写测试就是程序员本职工作的一部分。</strong>毕竟，如果你连测试都做不好，那你对自己代码的信心从何而来呢？</p><p>给你讲个就发生在我身边的故事。有一次培训，我问了一个问题，作为一个程序员，在每次代码提交之前，你对自己编写的代码很有信心的请举手。有不少程序员骄傲地举起了手。我接着问，那你的信心是从哪来的呢？一个程序员回答说，我工作这么多年了，这点自信还是有的。嗯，不错。</p><p>你在提交之前，会验证一下吗？大部分程序员的手还是高高地举着。你是验证了这次编写的代码呢？还是验证所有的代码呢？很多人一脸茫然。一个程序员说，我能保证自己的代码没问题就行了，怎么能有时间验证所有的代码呢？那你怎么保证自己写的代码没有破坏已有的代码呢？不是还有测试同学吗？我顺便问了测试同学，你们会验证系统中所有的功能吗？一个测试同学说，我们也想，但功能太多了，验证不过来。</p><p>是的，这才是大多数团队在实际开发中的真相。大多数人对于编写代码只是有一种凭空的自信，我们并不知道每次提交的代码到底有多大的影响。所以，我们常常看到在生产环境中出了问题，定位半天居然是一个简单的错误。<strong>很多团队对于高质量代码的追求其实只是一种幻象。</strong></p><p>这一次，我们就来一起打破幻象，学习编写真正的高质量代码。</p><h2>学习写测试</h2><p>怎么样才能学会写测试呢？<strong>最好的办法是跟着会写测试的人一起写一段时间</strong>，但整体行业的环境决定能提供这样机会的公司少之又少。大部分人学习测试，还是要通过阅读书籍。所以，经常有人让我推荐关于测试的书，遗憾的是，我确实没什么可以推荐的。</p><p>这些关于测试的书，要么是告诉你一些框架工具怎么用，这种东西通常看文档就能解决；要么是讲实践，比如 TDD，但还是那个问题，作者解决问题很爽，但和你有什么关系呢？归根结底，缺少一根主线，把所有这些东西连起来，让测试的知识成为一个整体。</p><p>所以，这次我准备了《程序员的测试课》，尝试把“一个程序员在日常工作中如何编写自动化测试”的相关知识梳理一遍，从实战出发，解除你对测试的一些误解，教会你一些上手可用的方法。</p><p>我把这个专栏分成了三个部分。</p><p><strong>基础篇</strong>，为你讲解关于测试的基础知识。不同的是，在讲解具体的内容前，我会带你先从一个实例入手，让你看看怎么样用带测试的方式编写一段代码，告诉你一个新项目如何去做测试。当我们有了对于编写测试一个直观的认识之后，再来了解具体的测试知识，就可以有更深刻的体验了。</p><p><strong>应用篇</strong>，为你介绍在一个后端项目中可以怎样做测试。在这个部分，我们同样会以实战开始，主要讲解使用 Spring 框架如何做测试。之所以选择 Spring 框架，一方面，它的使用非常广泛；另一方面，它对测试提供了非常好的支持。</p><p><strong>扩展篇</strong>，为你介绍 TDD 和 BDD 两项开发实践。这两项实践离很多人的实际工作是有距离的，之所以大多数人不采用这样的工作方式，思维习惯是一方面，还有一方面就是欠缺测试的基础。当我们经过这个专栏的前面部分铺垫了测试的基础之后，再来看这些实践，你会有不一样的感受。</p><h2>写在最后</h2><p>最后，还是要做一个自我介绍。我叫郑晔，一个写代码超过二十年的程序员，做过与软件开发相关的各种工作：编代码、带团队、做咨询、写开源……</p><p>我已经在《极客时间》上写了三个专栏，把自己对于软件开发方方面面的思考总结在其中。所以，在这个专栏中，你常常会看到其他三个专栏的影子：</p><ul>\n<li>开发代码之前要做任务分解，这是<a href="https://time.geekbang.org/column/intro/100022301">《10x 程序员工作法》</a>讲过的工作原则；</li>\n<li>代码要可测，这是<a href="https://time.geekbang.org/column/intro/100052601">《软件设计之美》</a>讲过的衡量设计优劣的一个重要标准；</li>\n<li>代码要小巧，这是<a href="https://time.geekbang.org/column/intro/100068401">《代码之丑》</a>讲过的代码追求的目标；</li>\n<li>……</li>\n</ul><p>所以，如果你能把这几个专栏放在一起学习，一定会功力大增。另外，这个专栏中的实战部分，也算是给老同学们的一项福利，你们呼吁的实战环节，终于在这里成真了。</p><p>不过，即便你是新同学也无妨，从头到尾学习这个专栏，你就能收获到关于自动化测试的完整认知。为了不让有些同学失望，有一点我需要提前强调一下，这个课是给程序员的测试课，而非测试人员的测试课。所以，我们这个专栏的重点是如何做好自动化测试，而不是各种测试用例的设计方法。当然，如果有测试同学想深入到自动化测试，也欢迎你的加入。</p><p>准备好和我一起编写高质量的代码了吗？欢迎你加入我的专栏，让我们一起修炼，日益精进写代码的手艺！</p>',
        article_title: "开篇词 | 为什么写测试是程序员的本职工作？",
      },
    ],
  },
  {
    chapterTitle: "基础篇",
    children: [
      {
        title: "01 | 实战：实现一个 ToDo 的应用（上）",
        id: 404301,
        content:
          '<p>你好，我是郑晔。</p><p>这一讲是我们整个专栏的第一节课。我在开篇词里说过，很多程序员之所以不写测试，一个重要的原因是不会写测试。所以，我们不玩虚的，第一节课直接带你上手实战。</p><p>我们要实现的是一个 ToDo 的应用，选择一个新项目开始，我们没有历史负担，对于学习如何写测试来说，是最容易的。整个实战分为了上下两节课，在这节课里，我们先来实现业务的核心部分，下一节课，我们把完整的应用实现出来。</p><p>这个 ToDo 应用本身非常简单，实现功能并不是我们这两节课的重点。一方面，你会看到如何解决问题的过程，比如，如何分解任务、如何设计测试场景、如何把测试场景转换为一个测试用例等等；另一方面，你也会看到，我是如何运用这些解决问题的过程一点点把问题解决掉，在整个开发的过程中如何写测试、写代码。</p><p>当你在实际工作中面对更复杂的问题时，这里面的代码对你的帮助可能不大，但这些解决问题的思路却会在工作中实际帮助到你。如果你订阅过我的前几个专栏，这算是一个完整的实战练习。</p><h2>项目前的准备</h2><p>在正式开始之前，我们一块来看下这个 ToDo 应用都有哪些具体需求（注：接下来的代码我会用Java来写，如果你没有购买过我的其他课程也没有关系，极客时间有免费试读额度，欢迎你点击文章里的超链接进行学习）。</p><!-- [[[read_end]]] --><ul>\n<li>添加 Todo 项。</li>\n</ul><pre><code>todo add &lt;item&gt;  \n\n1. &lt;item&gt;  \nItem &lt;itemIndex&gt; added\n</code></pre><ul>\n<li>完成 Todo 项。</li>\n</ul><pre><code>todo done &lt;itemIndex&gt;  \nItem &lt;itemIndex&gt; done.\n</code></pre><ul>\n<li>查看 Todo 列表，缺省情况下，只列出未完成的 Todo 项。</li>\n</ul><pre><code>todo list  1. &lt;item1&gt; 2. &lt;item2&gt;  \nTotal: 2 items\n</code></pre><ul>\n<li>使用 all 参数，查看所有的 Todo 项。</li>\n</ul><pre><code>todo list --all  \n1. &lt;item1&gt; \n2. &lt;item2&gt; \n3. [Done] &lt;item3&gt;  \nTotal: 3 items, 1 item done\n</code></pre><p>如果你订阅过我的<a href="https://time.geekbang.org/column/intro/100068401">《代码之丑》</a>，你会发现，它就是我在《代码之丑》中给你布置的课堂练习作业的第一部分。如果你想对今天的内容有更深刻的理解，不妨先停下来，自己实现一遍这个需求，然后，再回过头看我是怎样解决这个问题的，对比一下实现方式的差异，记得要写测试哦！</p><p>为了厘清主线，不受细节的干扰，我在正文中只罗列了最关键的部分代码。如果你想看完整的代码，我在 GitHub 上为此专门建了<a href="https://github.com/dreamhead/geektime-todo">一个项目</a>，你可以去参考。</p><p>具体的需求有了，我们接下来怎么动手实现这个应用呢？我们先来做一些基础的准备工作：</p><ul>\n<li>一个项目自动化；</li>\n<li>对需求进行简单的设计。</li>\n</ul><p>为什么要先从这些东西做起呢？我在《10x 程序员工作法》中曾经介绍过<a href="https://time.geekbang.org/column/article/77294">迭代 0</a> 的概念，这是一个项目开始的基础准备，当然，因为我们这个是一个练习项目，所以，准备的内容相对来说，还比较少。</p><p>为什么要准备项目自动化呢？简单来说，就是防止自己犯一些低级错误。关于这个项目自动化中包含了哪些内容，我在《10x 程序员工作法》中也专门用了<a href="https://time.geekbang.org/column/article/86561">一讲</a>的篇幅介绍，你如果有兴趣不妨去了解一下。</p><p>接下来，我们就要进行一些简单的设计了。</p><h2>设计先行</h2><p>虽说这个部分的要求是一个命令行的应用，但我们要知道，一个系统的业务核心与它呈现的方式并不是耦合在一起的。也就是说，命令行只是这个 ToDo 应用的一种呈现形式。在专栏后面你会看到，我们也可以把它改造成一个 REST 服务。</p><p>所以，我们首先要做一个设计，<strong>把核心的业务部分和命令行呈现的部分分开</strong>。在我们的工程中，它们分别被放到了两个模块里，一个是 todo-core，用来放置核心的业务部分；一个是 todo-cli，用来放置命令行相关的处理。这一讲，我们主要先来解决核心的业务部分，至于命令行相关的处理，那会是我们下一讲的主题。</p><p>我们先来处理核心的业务部分。这里的核心业务是什么呢？根据前面的需求，就只有三个操作：</p><ul>\n<li>添加一个 Todo 项；</li>\n<li>完成一个 Todo 项；</li>\n<li>Todo 项列表。</li>\n</ul><p>接下来，我们可以用 DDD 战术设计的方法进行一下识别各个概念（如果你不了解战术设计的基本过程，可以去看看《软件设计之美》中的关于<a href="https://time.geekbang.org/column/article/267843">战术设计</a>的过程）。</p><p>首先是名词，这里我们的核心对象只有一个，就是 Todo 项。Todo 项的核心字段就是它的内容，也就是我们在命令行里写下的内容。</p><p>有了名词，我们就要识别动作了。我们先来看领域服务，这里我们可以有一个 Todo 项服务，对应着我们的操作，它应该包含三个方法：</p><ul>\n<li>addTodoItem，添加 Todo 项；</li>\n<li>markTodoItemDone，完成一个 Todo 项；</li>\n<li>list，列出所有的 Todo 项。</li>\n</ul><p>我们应用的需求比较简单，核心对象只有 Todo 项一个，也就不牵扯到多个对象的协同，所以我们这里就暂时不涉及到应用服务的设计。</p><p>服务只是操作，最终还要有一个地方把操作的结果存起来，在 DDD 中，这是 Repository 扮演的角色。所以，我们这里还需要一个 Todo 项的 Repository 用来处理与持久化相关的接口。</p><p>很多人一看到 Repository 这个概念，首先想到的是数据库，但正如你所见，这里并没有出现数据库。所以  Repository 并不是与数据库绑定在一起的，它只表示一种持久化的机制。在我们的这个版本实现里，这个 Repository 将会是一个文件的版本。</p><p>现在基本的设计有了，我们就要准备开始实现这个设计了。</p><h2>任务分解</h2><p>要从哪里开始实现呢？我们要<strong>从离我们需求最近的入口开始</strong>。通常来说，<strong>这个起点是应用服务</strong>，但是我们这里暂时没有应用服务，所以，我们可以从领域服务开始。</p><p>我们就按照需求的先后顺序，依次实现每个服务，首先是添加 Todo 项。</p><p>如果按照很多人通常的习惯，添加 Todo 项，就是创建一个 Todo 项，然后存在 Repository 里面。但这对我们的测试课来说是不够的，我们还得考虑一下这个行为要怎么测试。</p><p><strong>要想测试一个函数，一个函数最好是可测的。</strong>什么是可测的？就是通过函数的接口设计，我们给出特定的输入，它能给我们相应的输出。所以，一个函数最好是有返回值的。我们可以这样来设计添加 Todo 项的函数接口。</p><pre><code>TodoItem addTodoItem(final TodoParameter todoParameter);\n</code></pre><p>在这个函数签名中，TodoItem 表示一个 Todo 项，而 TodoParameter 表示创建一个 Todo 项所需的参数（很多人可能会选择字符串作为入口参数，我曾经在《代码之丑》中讲过，使用一个更有业务含义的名字，比直接使用基本类型会更清楚）。</p><p>有了这个函数签名，我知道你已经迫不及待地要开始写测试了。但请稍等一下，<strong>我们要先来考虑一下测试场景</strong>，因为很多人写代码只会考虑到正常的场景，趁着我们还没开始写代码，最好把能想到的各种场景都考虑一下。</p><p>首先想到的是添加一个正常的字符串，这是我们的正常情况，没有问题。但是，如果添加的字符串是一个空的，我们该怎么处理呢？</p><p>一般而言，处理空字符串的方式有两种。一种是返回一个空的 TodoItem，一种是抛出一个异常。到底使用哪种做法，我们要考虑一下二者语义的差别。返回一个空的 TodoItem，表示这是一个可以接受的场景。而抛出一个异常，表示这不是一个正常的场景，它是一个“异常”。</p><p>就我们这里的场景而言，我们要从业务思考一下，确实有人可能在调用我们的命令时给出的参数是空，但考虑到 <a href="https://time.geekbang.org/column/article/84374">Fail Fast 原则</a>，这种错误属于入口参数错误，应该在入口检测出来，不应该传到业务核心里面。</p><p>所以，我们可以将空传给业务核心部分视为“异常”。同时，我们也确立好了<strong>一条设计规范：对于输入参数的检测，由入口部分代码进行处理</strong>。</p><p>基于这条设计规范的考虑，如果是一个空的字符串，那么根本就不应该传到我们的领域服务中，应该直接在入口参数检测中就应该消灭掉。换言之，TodoParameter 就不会出现空字符串。所以空字符串这个事，我们就暂且不考虑了。</p><p>不过，这倒给我们提了一个醒，如果是 TodoParameter 为空呢？这种情况也不应该出现，所以我们可以把它当做异常来处理。</p><p>现在，我们这里就有了两个测试场景：</p><ul>\n<li>添加正常的参数对象，返回一个创建好的 Todo 项；</li>\n<li>添加空的参数对象，抛出异常。</li>\n</ul><p>也许你还会想到几个场景，比如如果字符串重复了怎么办？答案是从目前的业务要求来说，字符串重复是可以接受的，只是添加了一个新的 Todo 项。所以，不需要为它做什么特殊的处理。</p><p>再有，如果存储到 Repository 的过程中出现了问题，比如磁盘满了，这样的问题属于不可恢复的异常，我们在业务处理中也做不了什么特殊的处理，只能把它抛出去。</p><p>一般来说，这种异常可以由 Repository 直接抛出一个 Runtime 异常，我们在业务处理不需要做什么。所以我们这里可以确立另外<strong>一条设计规范：Repository 的问题以运行时异常的形式抛出，业务层不需要做任何处理。</strong></p><p>好，我们现在已经考虑了最主要的场景，下面就到了动手写代码环节了。</p><h2>编写测试</h2><p>我们从第一个测试场景开始，这个场景关注的是正常的参数对象。我们首先要做的是，<strong>把测试场景具象化成一个测试用例</strong>。</p><p>把测试场景具象成一个测试用例，也就是要把测试场景中空泛的描述变成一个个具体的参数。比如，添加正常的字符串。什么叫一个正常的字符串呢？在我们这个案例里面，它是相对于空字符串而言的，所以，我们这里需要给出一个非空的字符串。</p><p>如果有业务人员给我们一个具体的例子那是最好，如果没有，我会使用一些在测试中常用的词汇，比如：foo、bar 之类的。</p><p>到这里，我们就很容易写出一个测试的基本结构。</p><pre><code>@Test\npublic void should_add_todo_item() {\n    TodoItemRepository repository = ...\n    TodoItemService service = new TodoItemService(repository);\n    TodoItem item = service.addTodoItem(new TodoParameter(&quot;foo&quot;));\n    assertThat(item.getContent()).isEqualTo(&quot;foo&quot;);\n}\n</code></pre><p>你会发现这还是一段未完成的代码，原因就在于，我们还没有对 repository 这个变量进行处理。我们现在处理的重点是在领域服务上，而 TodoItemRepository 到底要怎么实现，我们还没有考虑。</p><p>我们现在对于 TodoItemRepository 的述求是它只要有一个 save 接口就好，至于它是数据库还是文件，根本不是我们现在关心的重点。</p><p>只有一个接口，我们该怎么用它呢？我们可以用 Mock 框架模拟出一个有这样行为的对象。Mock 框架就是根据预期的参数，给出相应的结果，这个结果可能是返回值，也可能是抛出异常。关于 Mock 框架更多的介绍，我们会在后面的部分专门讲解。</p><p>下面是增加了 repository 初始化的代码。</p><pre><code>@Test\npublic void should_add_todo_item() {\n    TodoItemRepository repository = mock(TodoItemRepository.class);\n    when(repository.save(any())).then(returnsFirstArg());\n    TodoItemService service = new TodoItemService(repository);\n    \n    TodoItem item = service.addTodoItem(new TodoParameter(&quot;foo&quot;));\n    \n    assertThat(item.getContent()).isEqualTo(&quot;foo&quot;);\n}\n</code></pre><p>这里我们用到的 Mock 框架是 Mockito，这里面有一句代码你或许会有点陌生。</p><pre><code>when(repository.save(any())).then(returnsFirstArg());\n</code></pre><p>这句代码表示当我用任意参数调用这个 repository 对象的 save 方法时，我预期它返回第一个参数作为返回值。对应到我们这里的语义，就是存进去什么对象，就返回什么对象。</p><p>另外，这里面用到的断言程序库是 <a href="https://joel-costigliola.github.io/assertj/">AssertJ</a>，它的 API 是流畅风格的 API（Fluent API），也就是连着的点点点。</p><p>有了这个测试，实现相应的代码就很容易了，相信你也很容易做到。</p><pre><code>public TodoItem addTodoItem(final TodoParameter todoParameter) {\n    final TodoItem item = new TodoItem(todoParameter.getContent());\n    return this.repository.save(item);\n}\n</code></pre><p>这里最核心的 TodoItem 目前只包括一个内容的字段。</p><pre><code>@Getter\npublic class TodoItem {\n    private final String content;\n    \n    public TodoItem(final String content) {\n        this.content = content;\n    }\n}\n</code></pre><p>接下来，我们再来实现下一个测试。有了第一个测试的基础，第二个测试的关注点是空对象，你也应该能够很容易得写出来。</p><pre><code>@Test\npublic void should_throw_exception_for_null_todo_item() {\n    assertThatExceptionOfType(IllegalArgumentException.class)\n            .isThrownBy(() -&gt; service.addTodoItem(null));\n}\n</code></pre><p>根据第二个测试，我们的 addTodoItem 方法就需要增加一条对于空对象的处理。</p><pre><code>public TodoItem addTodoItem(final TodoParameter todoParameter) {\n    if (todoParameter == null) {\n        throw new IllegalArgumentException(&quot;Null or empty content is not allowed&quot;);\n    }\n\n    final TodoItem item = new TodoItem(todoParameter.getContent());\n    return this.repository.save(item);\n}\n</code></pre><p>至此，添加 Todo 项的任务也算完成，我们可以运行一下命令做一下检查，看看我们是否有遗漏。</p><pre><code>./gradlew check\n</code></pre><p>这里的遗漏可能是由于编码风格，也可能是由于代码覆盖率导致，这也是我们为什么要把项目自动化放在最前面完成的原因。后面每完成一个任务，也应该运行一下这个命令，同样的事情，后面我就不再重复了。</p><p>到这里，关于如何添加测试编写代码的最基本思路，我们已经讲清楚了。接下来，我们来完成一个 Todo 项。完成 Todo 项的接口是这样的。</p><pre><code>TodoItem markTodoItemDone(TodoIndexParameter index);\n</code></pre><p>这里的入口参数是一个索引，只不过这里做了一次封装，封装出一个 TodoIndexParameter。</p><p>针对这个接口，我们考虑的测试场景包括：</p><ul>\n<li>对于一个已经存在的 Todo 项，将其标记已完成；</li>\n<li>如果索引超出现有的索引范围，则返回空。</li>\n</ul><p>对于一个索引，你可能也会想到索引为负的场景。但同之前一样，这个问题应该是属于在入口就检验出来的问题，所以我们封装一个 TodoIndexParameter，这样在业务层就不需要考虑索引为负的场景了。</p><p>对于最后一个场景，当索引超出索引范围，返回空。鉴于空指针总是一个容易引起问题的场景，所以，我们这里采用 Optional 替代直接返回对象（关于 Optional 使用的基本思路，我在《软件设计之美》中<a href="https://time.geekbang.org/column/article/258954">讲过</a>，如果你感兴趣可以去回顾一下）。</p><pre><code>Optional&lt;TodoItem&gt; markTodoItemDone(TodoIndexParameter index);\n</code></pre><p>我们先来编写这个接口的第一个测试。</p><pre><code>@BeforeEach\npublic void setUp() {\n    this.repository = mock(TodoItemRepository.class);\n    this.service = new TodoItemService(this.repository);\n}\n\n\n@Test\npublic void should_mark_todo_item_as_done() {\n    when(repository.findAll()).thenReturn(ImmutableList.of(new TodoItem(&quot;foo&quot;)));\n    when(repository.save(any())).then(returnsFirstArg());\n    \n    final Optional&lt;TodoItem&gt; todoItem = service.markTodoItemDone(TodoIndexParameter.of(1));\n    \n    assertThat(todoItem).isPresent();\n    final TodoItem actual = todoItem.get();\n    assertThat(actual.isDone()).isTrue();\n}\n</code></pre><p>因为 service 的初始化和 repository 这个模拟对象的初始化几乎所有正常路径都要用到，所以，我们把它挪到 setUp 方法中，以便每个测试之前都能够运行它。</p><p>这个版本的实现采用了最为粗暴的方案，把所有的 Todo 项都加载到内存中，然后根据索引进行筛选。所以，这里我们用到了 findAll 方法。</p><p>这个实现不难，重要的变化是 TodoItem 需要有一个字段标记它的完成，代码如下。</p><pre><code>@Getter\npublic class TodoItem {\n    private final String content;\n    private boolean done;\n    \n    public TodoItem(final String content) {\n        this.content = content;\n        this.done = false;\n    }\n    \n    public void markDone() {\n        this.done = true;\n    }\n}\n</code></pre><p>后面两个测试场景以及相应的实现代码，你可以参考开源项目中的代码，这里就不一一罗列了。</p><p>最后是 Todo 项列表，它的接口相对比较简单。</p><pre><code>List&lt;TodoItem&gt; list(final boolean all);\n</code></pre><p>其中，all 参数为 true 时，列出所有的 Todo 项；false 的时候，列出未完成的 Todo 项。</p><p>在需求中，缺省情况罗列的是未完成的 Todo 项，这是过滤掉已完成的 Todo 项的结果。但是，如果我们简单的采用按照列表的顺序作为索引，这就产生一个问题，每当有一个 Todo 项完成之后，剩余 Todo 项的列表顺序就会发生改变，这其实是不合适的。所以，我们最好把索引放到 Todo 项的实体中。</p><pre><code>@Getter\npublic class TodoItem {\n    private long index;\n    private final String content;\n    private boolean done;\n    \n    public TodoItem(final String content) {\n        this.content = content;\n        this.done = false;\n    }\n    \n    public void assignIndex(final long index) {\n        this.index = index;\n    }\n    \n    public void markDone() {\n        this.done = true;\n    }\n}\n</code></pre><p>这里我们把索引的赋值可以在服务中完成，也可以在 Repository 保存的过程中完成。从目前的情况看，这个索引的值与 Repository 现有的 Todo 项个数紧密相关，所以，我们可以把它放在 保存到 Repository 的过程中完成。也就是说，保存一个 Todo 项时，如果这个 Todo 项没有索引，就为它赋一个索引，如果有索引，就更新相应的 Todo 项。</p><p>针对这个接口，我们考虑的测试场景包括：</p><ul>\n<li>如果有 Todo 项，罗列 Todo 项时，列出所有的 Todo 项；</li>\n<li>如果没有 Todo 项，罗列 Todo 项时，列出 Todo 项为空；</li>\n<li>如果有未完成的 Todo 项，罗列未完成 Todo 项，列出所有未完成的 Todo 项；</li>\n<li>如果没有未完成的 Todo 项，罗列未完成 Todo 项，列出的 Todo 项为空。</li>\n</ul><p>具体的代码也不在这里罗列了，你可以参考开源项目中的代码。</p><p>有时你会发现，虽然我们列出了很多测试场景，但当我们有了一些基础的代码之后，一些测试刚写完就通过了。比如，如果我们先写了罗列 Todo 项和罗列未完成 Todo 项的代码，后面两个测试场景很可能自然地就通过了。</p><p>这种情况在写测试的时候是很常见的，这说明，我们前面的代码已经很好地处理了这些情况。这并不说明这些测试场景是无用的，因为不同的实现方式并不能保证这些测试都是通过的，所以，既然我们已经为它们写了测试，保留在那里就好了。</p><p>到这里，我们已经把最核心的业务代码写完了，当然，它还不能完整地运行，因为它没有命令行的输入，也没有实现 Repository 的存储。但有了一个稳定的核心，这些东西都好办。下一讲，我们就来把这些东西都连接起来。</p><h2>总结时刻</h2><p>在这一讲里，我们实现 ToDo 应用的核心业务部分，这里面的重点并不是把代码写出来，我相信你有能力去编写完成这段代码。我在这里的描述更多的是在一个项目启动的初期要关注哪些内容，以及如何去着手去编写测试。</p><p>项目刚开始时，我们要准备哪些内容：</p><ul>\n<li>项目的自动化；</li>\n<li>针对需求进行初步的设计。</li>\n</ul><p>着手编写代码时，我们要怎么做呢？</p><ul>\n<li>对要实现的需求进行任务分解；</li>\n<li>在一个具体的需求任务中，我们可以从需求入口开始入手；</li>\n<li>设计一个可测试的函数；</li>\n<li>针对具体的函数，考虑测试场景；</li>\n<li>针对具体的测试场景，将场景具象化成测试用例。</li>\n</ul><p>在梳理的过程中，我们还会针对一些统一的情况作出一些约定，成为项目整体的设计规范，比如，在这里我们约定：</p><ul>\n<li>对于输入参数的检测，由入口部分代码进行处理；</li>\n<li>Repository 的问题以运行时异常的形式抛出，业务层不需要做任何处理。</li>\n</ul><p>在编码的过程中，我们也看到了：</p><ul>\n<li>根据不断增加的需求，逐渐改动我们的设计，这就是演化式设计的基本做法；</li>\n<li>我们对待测试也像对待代码一样，会消除代码中存在的一些坏味道。</li>\n</ul><p>如果今天的内容你只能记住一句话，那么请记住，<strong>细化测试场景，编写可测试的代码。</strong></p><p><img src="https://static001.geekbang.org/resource/image/d8/23/d8yy713c1c76376c9e17a42917637523.jpg?wh=2000x1073" alt=""></p><h2>思考题</h2><p>今天我分享了从一个需求入手，如何一步一步地写出测试。你在实际工作中是怎么做测试呢？如果你如果不做的话，原因又是什么呢？欢迎在留言区分享你的所见所闻。</p><h2>参考资料</h2><p><a href="https://time.geekbang.org/column/article/77294">迭代0：启动开发之前，你应该准备什么？</a></p><p><a href="https://time.geekbang.org/column/article/86561">一个好的项目自动化应该是什么样子的？</a></p><p><a href="https://time.geekbang.org/column/article/267843">战术设计：如何像写故事一样找出模型？</a></p>',
        article_title: "01 | 实战：实现一个 ToDo 的应用（上）",
      },
      {
        title: "02 | 实战：实现一个 ToDo 的应用（下）",
        id: 404751,
        content:
          '<p>你好，我是郑晔！</p><p>在上一讲里，我们实现了一个 ToDo 应用的核心业务部分。虽然测试都通过了，但我相信你可能还是会有一种不真实的感觉，因为它还不是一个完整的应用，既不能有命令行的输入，也不能把 Todo 项的内容真正地存储起来。</p><p>这一讲，我们就继续实现这个 ToDo 应用，把欠缺的部分都补上。不过，在开始今天的内容之前，我仍需要强调一下，之所以我要先做核心业务部分，因为它在一个系统中是最重要的。很多人写代码的时候会急着把各个部分连接起来，但却忽视了核心业务部分的构建，这样做造成的结果就是严重的耦合，这也是很多后续问题产生的根源。</p><p>在上一讲里，我们已经有了一个业务内核，现在还欠缺输入输出的部分，也就是如何将Todo 项保存起来，以及如何接受命令行参数。</p><p>接下来，我们就分别来实现这两个部分。</p><h2>文件存储</h2><p>我们先来实现 Todo 项的存储。在上一讲中，我们已经预留好了存储的接口，也就是 Repository 这个接口。现在，我们只需要给这个接口提供一个相应的实现就好了。我们先来看看 Repository 接口现在是什么样子。</p><pre><code>public interface TodoItemRepository {\n    TodoItem save(TodoItem item);\n    Iterable&lt;TodoItem&gt; findAll();\n}\n</code></pre><p>出于简单的考虑，我们要实现一个基于文件的存储。也就是说，给这个接口提供一个基于文件的实现版本。</p><!-- [[[read_end]]] --><p>首先，我们要决定一下把这个实现放到哪里。还记得我们一开始就分了两个模块吗？这两个模块一个是 todo-core，用来存放核心业务的代码；一个是 todo-cli，用来存放与命令行相关的代码。</p><p>那么这个基于文件的实现应该算在哪里呢？</p><p>其实放在哪里都可以讲出一定的道理。放在 todo-core 中，它算核心业务提供的一个实现，供外围使用；放在 todo-cli 中，它就是一个与 CLI 实现相关的部分。</p><p>既然都可以，我更倾向于放在 todo-cli 这个模块里，原因是我们<strong>最好保持核心业务的小巧</strong>，等到以后有机会遇到它需要提供给其它模块使用时，我们再来考虑把它挪到 todo-core 中。</p><p>确定了它的模块归属之后，我们进入到具体的工作中，先来确定它的测试场景：</p><ul>\n<li>使用 findAll 查询空的 Repository ，返回一个空的列表；</li>\n<li>保存了 Todo 项之后，查询 Repository 返回保存了 Todo 项的列表；</li>\n<li>修改已保存的 Todo 项，保存之后，查询 Repository 得到的应该是修改过后的 Todo 项；</li>\n<li>保存空的 Todo 项，会抛出异常。</li>\n</ul><h3>临时文件</h3><p>与之前的测试完全可以在内存中执行不同，这回的测试要用到文件。<strong>为了保证测试是可以重复执行的，我们要确保所有的资源在执行之后要恢复原样。</strong>内存资源恢复原样是没有问题的，那文件怎么办呢？</p><p>文件是一个外部资源，如果用到的是一个普通文件，我们需要确定这个文件要存放在哪里、需要在保证测试执行之后把测试写入的内容清理掉……总之，有不少细节要考虑。所幸，在测试中使用文件是一种特别常见的需求，像 JUnit 这样成熟的框架已经给了我们一个标准答案，那就是临时文件。</p><p>更准确地说，JUnit 给出的方案是临时目录，在这个目录里，你怎么折腾都行。我们只要给一个变量标记上@TempDir，这个变量可以是作为一个测试函数的参数，也可以是一个测试类的字段。下面是我们的测试用例，在这里我们给类的一个字段标记上了@TempDir。</p><pre><code>class FileTodoItemRepositoryTest {\n    @TempDir\n    File tempDir;\n    private File tempFile;\n    private FileTodoItemRepository repository;\n    \n    @BeforeEach\n    void setUp() throws IOException {\n        this.tempFile = File.createTempFile(&quot;file&quot;, &quot;&quot;, tempDir);\n        this.repository = new FileTodoItemRepository(this.tempFile);\n    }\n    \n    @Test\n    public void should_find_nothing_for_empty_repository() throws IOException {\n        final Iterable&lt;TodoItem&gt; items = repository.findAll();\n        assertThat(items).hasSize(0);\n    }\n    ...\n}\n</code></pre><h3>文件编解码</h3><p>有了测试，我们还需要考虑实现的问题。存储到文件里，必须要考虑的一个问题就是编解码的问题，也就是用什么样的格式进行文件存储，这是我们要做的一个设计决策。出于简单的考虑，我准备采用 JSON 这种最常见的格式。因为 JSON 格式的编解码有很多现成的方式，我们就不需要专门的处理了。</p><p>处理 JSON 格式，我选择的程序库的是 <a href="https://github.com/FasterXML/jackson">Jackson</a>，这是行业中最主流的 JSON 处理程序库。就当前的情况来说，这个依赖只与 todo-cli 这个模块相关，所以，我们把 Jackson 的依赖添加到这个模块的构建脚本即可，也就是 todo-cli/build.gradle。</p><pre><code>dependencies {\n    implementation(&quot;com.fasterxml.jackson.core:jackson-databind:$jacksonVersion&quot;)\n}\n</code></pre><p>这里的 jacksonVersion 是一个变量，我们把它配置在整个项目的 gradle.properties 文件里，方便对于依赖的管理。</p><pre><code>jacksonVersion=2.12.3\n</code></pre><p>添加了新的依赖之后，我们需要重新生成一下 IDEA 的工程，依赖就更新了，随后我们就可以继续工作了。</p><pre><code>./gradlew idea\n</code></pre><h3>测试覆盖率</h3><p>有了这个基础，我们可以很容易地把代码实现出来，比如，findAll 的实现就是下面这样。</p><pre><code>@Override\npublic Iterable&lt;TodoItem&gt; findAll() {\n    if (this.file.length() == 0) {\n        return ImmutableList.of();\n    }\n    \n    try {\n        final CollectionType type = typeFactory.constructCollectionType(List.class, TodoItem.class);\n        return mapper.readValue(this.file, type);\n    } catch (IOException e) {\n        throw new TodoException(&quot;Fail to read todo items&quot;, e);\n    }\n}\n</code></pre><p>当通过了所有的测试，我们就要提交代码了。在此之前，我们需要运行提交脚本。</p><pre><code>./gradlew check\n</code></pre><p>当我们很快地解决大部分像代码风格之类的低级问题之后，有一个问题就会卡住我们：测试覆盖率。</p><p>测试覆盖率给了我们发现代码问题的机会。我在构建脚本设定的测试覆盖率是 100%，所以，只要有测试覆盖不到的地方就会被发现。打开测试覆盖率的报告（具体位置在 $buildDir/reports/jacoco/index.html），它就会提醒我们哪里没有覆盖到，就像下面这样。</p><p><img src="https://static001.geekbang.org/resource/image/c6/15/c6a1f28da836f806e3007b1a18416615.png?wh=1644x402" alt=""></p><p>对于一些简单的场景，我们可以通过增加或调整测试就可以提高测试覆盖率。但有些问题就不是简单调整能够解决的。比如这里的异常处理，就像上面覆盖率报告中的 IOException。遇到这种情况，你会怎么办？</p><p>最糟糕的做法是，有测试不好覆盖，就认为测试没有价值，然后彻底放弃测试。这显然不是我们的选项。如果我们坚持测试，要怎么通过这一关呢？</p><p>一种做法是不分青红皂白，统一降低对于测试覆盖率的要求，也就是修改构建脚本中的设置。虽然这种做法可以让我们临时通过这一关，但这却会留下后患：以后有其它本可以测试覆盖到的部分，由于测试覆盖率的降低也会被忽略。</p><p>再有一种做法，就是把这些异常造出来。如果你运气好，有些异常可以通过看接口来大概猜测是怎么产生出来的。像这里的这段代码，如果出现异常很可能就是 JSON 格式不合法造成的。但有时候，我们需要仔细研究这个程序库的源代码，才能知道这个异常是怎么产生的。</p><p>知道异常怎么产生的是第一步，接下来，还需要制造出这个异常。像不合法的 JSON 格式还好办，有些异常则是你很难造出来的。比如，如果我们用到反射，API 会抛出 ClassNotFoundException，但只要你这个类加载了，就不会抛出  ClassNotFoundException。</p><p>我们需要知道的一点是，<strong>我们测试的目标是我们的代码，而不是这个难以测试的程序库。</strong>除非这个异常对我们来说至关重要，否则，为了写测试，去研究另外一个程序库，显然有点本末倒置了。</p><p>这也不行，那也不行，我们还有办法吗？通常来说，这种没法屏蔽掉的异常来自另外一个程序库，而使用这个程序库对我们来说，都是一些实现细节，那么我们可以将这些细节给封装起来。比如在前面代码里，抛出异常的主要是 readValue 这一句，它实现的就是一个文件中读取对象，我们可以把它封装到一个 JSON 处理的类中。</p><pre><code>public final class Jsons {\n    private static final TypeFactory FACTORY = TypeFactory.defaultInstance();\n    private static final ObjectMapper MAPPER = new ObjectMapper();\n    \n    public static Iterable&lt;TodoItem&gt; toObjects(final File file) {\n        final CollectionType type = FACTORY.constructCollectionType(List.class, TodoItem.class);\n        try {\n            return MAPPER.readValue(file, type);\n        } catch (IOException e) {\n            throw new TodoException(&quot;Fail to read objects&quot;, e);\n        }\n    }\n    \n    ...\n}\n</code></pre><p>我们在这里将异常封装成我们内部的运行时异常，外面就可以不用捕获处理了。相应地，findAll 的处理就可以调用这个封装出来的代码。</p><pre><code>@Override\npublic Iterable&lt;TodoItem&gt; findAll() {\n    if (this.file.length() == 0) {\n        return ImmutableList.of();\n    }\n    \n    return Jsons.toObjects(this.file);\n}\n</code></pre><p>经过这个改造，FileTodoItemRepository 就可以由测试完全覆盖了。或许你还会担心那个新的 Jsons 类没有办法测试覆盖。对于这个类，我们的方案是忽略掉它，不去做覆盖。处理手法就是在构建脚本中将它排除在测试覆盖之外。</p><pre><code>coverage {\n    excludeClasses = [\n            ...\n            &quot;com.github.dreamhead.todo.util.Jsons&quot;\n    ]\n}\n</code></pre><p>为什么我们可以忽略它？一方面，这段代码很简单，几乎没有逻辑，因为它只是一个调用的封装。另外一方面，这里面主要的代码不是我们编写的，正如前面所说，我们测试的主要目的是测试我们自己写的代码，而不是别人的程序库。</p><p>这里小结一下，<strong>由于其它程序库造成难以测试的问题，我们可以做一层层薄薄的封装，然后，在覆盖率检查中忽略它。封装和忽略，缺一不可。</strong></p><p>至于其它部分更具体的代码，我就不在这里展示了，你可以到开源项目中去查看细节。到这里，我们已经有了可以存储 Todo 项的仓库。基础已经具备，接下来，我们就要把所有这些东西都连起来，给它一个入口。</p><h2>命令行入口</h2><p>编写命令行入口，我们要选择一个程序库，省得自己从头编写各种解析的细节。在这里，我选择的程序库是 <a href="https://picocli.info/">Picocli</a>。</p><p>这个程序库可能你对它不是那么熟悉。那么对于一个新程序库来说，你的关注点是什么呢？绝大多数人拿到一个新程序库，重点都是赶紧让它跑起来，只要程序能够运行，其它的就不在乎了，甚至用来测试程序库怎么用的代码，最终也成为了代码仓库的一部分。</p><p>请千万记住，用来试验的代码永远是用来试验的代码。<strong>一旦我们掌握了一个程序库的基本用法，接下来，我们应该抛弃掉试验代码，重新设计，按照它应有的样子来使用这个程序库。</strong></p><h3>接口的选择</h3><p>面对新的程序库，还有一个问题我们可能会忽略。有些程序库对同样一件事可以有多种不同的处理方式。比如就 Picocli 而言，同样是处理一个命令的参数，可以把它当做一个类的字段，像下面这样。</p><pre><code>class AddCommand ...\n    @Parameters(index = &quot;0&quot;)\n    private String item;\n    ...\n}\n</code></pre><p>也可以当做一个函数的参数。</p><pre><code>class AddCommand ...\n    public int add(@CommandLine.Parameters(index = &quot;0&quot;) final String item) {\n        ...\n    }\n}\n</code></pre><p>你会选择哪种做法呢？我的答案是<strong>选择可测试性好的</strong>。</p><p>就上面两种做法而言，同样是要做单元测试，第一种字段的方式，我需要通过反射的方式设置这个字段的值；而第二种参数的方式，我只要传参就好了。显然，第二种方式更简单。</p><p>或许你会好奇，既然第二种方式更简单，那为什么还会有第一种方式呢？因为如果你不考虑测试而只考虑写代码的话，第一种方式用起来更容易。</p><p>一个是容易写，一个是容易测，这就是两种不同编码哲学的取舍。</p><p>当然，这个讨论是在我们有选择的情况下进行的，有些程序库并没有给我们提供这些选择。很多程序库只有一种做法，而且通常是容易写的做法，这个时候单元测试就比较麻烦。不过通常来说，这种情况都出现在边缘的部分，我们可以考虑这个部分的测试是用单元测试，还是用集成测试。</p><h3>测试的选择</h3><p>做好了基础的准备，现在我们准备开始测试了。同样，我们也要准备测试场景。在命令行接口我们要测的是什么呢？其实，主要的业务逻辑已经在前面的测试中覆盖到了，命令行接口主要就是完成与用户输入相关的一些处理。</p><p>还记得前面我在讨论业务处理时遗留的内容吗？没错，用户输入相关的一些校验要放在这里来做，剩下的就是转给我们领域服务的代码，也就是 TodoItemService。</p><p>有了这个理解，我们来罗列一下测试场景：</p><ul>\n<li>添加一个正常的 Todo 项，该 Todo 项可以查询到；</li>\n<li>添加一个空的 Todo 项，提示参数错误；</li>\n<li>标记一个已有的 Todo 项为完成，该 Todo 项的状态为已完成；</li>\n<li>标记一个不存在的 Todo 项为完成，提示该项不存在；</li>\n<li>标记一个索引小于 0 的 Todo 项为完成，提示参数错误；</li>\n<li>列出所有 Todo 项，缺省为列出所有未完成的 Todo 项；</li>\n<li>用“-a”参数列出所有的 Todo 项，列出所有的 Todo 项。</li>\n</ul><p>如果你是跟着我一路走到了现在，怎么把这些测试写出来对你来说应该已经不是太大的问题了。但在编写代码之前，还有一个问题要考虑，我们准备写什么样的测试呢？</p><p>我们前面编写的测试都是单元测试，也就是针对一个单元进行的测试。如果按照单元测试的编写逻辑来写这段代码，最简单的做法是 mock 一个 TodoItemService 作为参数传给我们的命令类，这种做法本身是没有问题的。</p><p>虽然我们能够保证所有的单元正常运作，但这些单元配合在一起是否依然能够正常运作呢？这可不一定。因为<strong>除了要保证单元的正确，我们还要保证单元之间的协作也是正确的。</strong>你或许已经知道我要说什么了，没错，除了单元测试，我们还需要集成测试。</p><p>之所以要在这里讨论集成测试，因为我们前面已经把主要的业务逻辑已经完成了，最后的这部分代码实际上只是对业务逻辑做一个简单的封装，这会是非常薄的一层。所以，这层如果做单元测试，除了参数校验的部分，剩下的主要工作都是转发，将处理逻辑转发给服务层。所以，出于实用的考虑，我们不妨在这里就用集成测试代替单元测试，简化测试的编写。</p><p>如果我们在这里准备编写的是集成测试，与编写单元测试不同的一个关键点就是，<strong>这里采用的服务对象是真实的对象，而不是模拟对象。</strong>这就需要我们按照业务对象的组装规则将真实的对象组装起来。在我们这个例子里面，因为涉及的对象都比较简单，所以，我们暂且采用直接对象组装的方式。在很多项目里面，对象组装的工作是由 DI 容器完成的。</p><p>为了保证组装过程的一致，我们可以把组装过程单独拿出来，让最终的代码和测试代码复用同样的逻辑。</p><pre><code>public class ObjectFactory {\n    public CommandLine createCommandLine(final File repositoryFile) {\n        return new CommandLine(createTodoCommand(repositoryFile));\n    }\n    \n    private TodoCommand createTodoCommand(final File repositoryFile) {\n        final TodoItemService service = createService(repositoryFile);\n        return new TodoCommand(service);\n    }\n    \n    public TodoItemService createService(final File repositoryFile) {\n        final TodoItemRepository repository = new FileTodoItemRepository(repositoryFile);\n        return new TodoItemService(repository);\n    }\n}\n</code></pre><p>这个组装逻辑本身没有任何复杂的地方，不过，有一点是需要我们在写这段代码时要考虑清楚的，就是<strong>把组装的边界设置在哪里</strong>。换句话说就是把什么样的部分放在组装过程中，什么样的部分不放。因为放太多的话，测试可能会不方便；太少的话，会让集成本身变得意义不大。</p><p>在上面这段代码里，我们把边界设置在了文件接口，也就是 createService 这个函数的参数。这样处理的话，在产品的代码中，我们可以就用正式的文件；而在测试环境中，就可以采用临时文件。</p><pre><code>class TodoCommandTest {\n    @TempDir\n    File tempDir;\n    private TodoItemService service;\n    private CommandLine cli;\n    \n    @BeforeEach\n    void setUp() {\n        final ObjectFactory factory = new ObjectFactory();\n        final File repositoryFile = new File(tempDir, &quot;repository.json&quot;);\n        this.service = factory.createService(repositoryFile);\n        cli = factory.createCommandLine(repositoryFile);\n    }\n</code></pre><p>你会看到，在这里我们除了声明最外面的调用接口（也就是 cli ）之外，还声明了一个变量 service，它是做什么用的呢？我们不妨看一下下面这个测试。</p><pre><code>@Test\npublic void should_mark_as_done() {\n    service.addTodoItem(TodoParameter.of(&quot;foo&quot;));\n    \n    cli.execute(&quot;done&quot;, &quot;1&quot;);\n    \n    final List&lt;TodoItem&gt; items = service.list(true);\n    assertThat(items.get(0).isDone()).isTrue();\n}\n</code></pre><p>标记一个 Todo 项为已完成，但前提条件是要有一个 Todo 项供你去标记。那怎么把这个 Todo 项添加进去呢？一种做法是调用我们的命令行接口，但要知道，我们在这里测试的目标就是命令行接口，也就是 add，而我们这里测试的主要接口是 done。</p><p><strong>写测试要尽可能减少对于不稳定组件的依赖</strong>，done 接口已经是一个不稳定的了，再加上 add，测试出问题的概率就会进一步增大。</p><p>所以，这里我们用了另外一种做法。service 是我们之前已经测试好的组件，我们可以把它看成一个稳定的组件，所以，这里我们使用了 service 添加 Todo 项。</p><p>具体的代码你可以参考我的开源项目，这里就不再进一步罗列了。</p><h2>总结时刻</h2><p>今天我们在核心业务的基础上，补齐了输入输出的部分。不同于之前所有的代码都是在内存中执行的情况，一旦牵扯到输入输出，我们就要考虑更多的问题。这一讲我们遇到的很多问题，可能也是你在实际的测试工作中会遇到的。</p><p>如果你的系统需要与文件打交道：</p><ul>\n<li>通过调整设计，将文件注入到模型中；</li>\n<li>在测试中使用临时文件；</li>\n<li>如果采用的是 JUnit 5，可以使用@TempDir 在临时目录下创建临时文件。</li>\n</ul><p>如果通过测试覆盖发现了难以测试的第三方代码：</p><ul>\n<li>通过做一层薄薄的封装，将第三方代码与你的代码分离开，保证你的代码完全由测试覆盖；</li>\n<li>在测试覆盖率中，忽略这层封装。</li>\n</ul><p>当我们使用第三方框架时：</p><ul>\n<li>与框架紧密结合的代码只是做最简单的接口校验工作，把业务逻辑放在自己的代码里；</li>\n<li>如果有多种方式完成一个功能，选择可测试性较好的实现方式。</li>\n</ul><p>我们编写集成测试：</p><ul>\n<li>是为了保证组件之间协作的正确性；</li>\n<li>需要利用与产品代码相同的组件组装过程；</li>\n<li>可以把已经测试好的稳定组件当做基础。</li>\n</ul><p>如果今天的内容你只能记住一件事，那请记住：<strong>隔离变化，逐步编写稳定的代码</strong>。</p><p><img src="https://static001.geekbang.org/resource/image/39/e5/39a31a0bf517781672f9d72c0a7f52e5.jpg?wh=1976x1085" alt=""></p><h2>思考题</h2><p>一旦你开启了对测试的思考，我们就能发现更多的思考角度，比如：控制台输出应该怎么测试？这个问题就是今天留给你的思考题了。在这个现有的项目基础上，增加对于控台输出的测试，你会怎么做呢？欢迎在留言区分享你的做法。</p>',
        article_title: "02 | 实战：实现一个 ToDo 的应用（下）",
      },
      {
        title: "03 | 程序员的测试与测试人员的测试有什么不同？",
        id: 405774,
        content:
          '<p>你好，我是郑晔！</p><p>前面用了两讲的篇幅，我们一起一步一步地用带测试的方式完成了一个项目，现在相信你已经对如何在实际工作中编写测试有了一个初步的认识。有了实践的根基，我们还需要对如何编写测试有一个更全面地理解，以便日后能够更好地应对各种场景。</p><p>关于测试，许多程序员的第一个问题就是：测试不是测试人员的工作吗？如果我把测试写了，那是不是就抢了测试人员的工作呢？</p><p>不瞒你说，之所以我要把这个话题放在专栏前面讲，一个重要的原因就是我当年真的就这么想过。好，今天我们就来聊聊程序员的测试和测试人员的测试究竟有哪些不一样的地方。</p><h2>程序员的测试能否替代测试人员的测试？</h2><p>我给你讲一个我在职业生涯初期的故事。那时候，我刚刚踏上自己的程序员精进之路，我不断地寻找着各种能够更好地写程序的方式。当我意识到测试对于编程的重要性时，我就开始有意识地在写代码的时候编写测试，尽我所能把各种场景都考虑到。作为一个骄傲的程序员，我总是希望自己的代码是无懈可击的。</p><p>有一次，我写了一个协议的解析器，我把各种字段缺失或不正确的场景都处理了。结果交给测试同学后，他上来就发了一个空包，然后我的代码就崩溃了。我当时的第一反应是，你怎么能这么做？测试同学却反问，我为什么不能这么做？</p><!-- [[[read_end]]] --><p>是啊，为什么不能呢？测试同学只要能做到，他就可以这么做。而且，只要测试同学能做到，其他人也可能做到。</p><p>可以说，这件事彻底改变了我对测试人员的认识。相信很多人和从前的我一样有个偏见，认为测试同学不过是做一些简单的验证，或者只是因为自己时间不充足，有些细节没考虑到，让他们给抓住点小问题。作为程序员，只要自己认真了，其实就没测试什么事了。然而，这次的事告诉我，即便我全力以赴了，测试同学依然可以发现问题。</p><p>从此，我对测试人员的看法彻底转变了。在我随后的职业生涯中我发现，只要团队里有合格的测试人员，他总会以你想不到的角度，发现系统中意想不到的问题——即便团队已经写了很多的测试。</p><p>说到这，你就可以放心了，即便我们程序员把测试都写好了，测试人员也不会失业，他们总能找到问题。但下一个问题就随之而来了，测试人员的测试和程序员的测试到底有什么不一样，以至于即便是程序员已经很努力了，依然很难做到对测试场景全面的覆盖呢？</p><p>答案很简单，因为视角不同。</p><p><strong>程序员的出发点是实现，而测试人员的出发点是业务。</strong>把这话翻译成你更熟悉的测试术语，那就是程序员的关注点是白盒测试，而测试人员则是黑盒测试。</p><p>程序员关注到的测试是站在实现的角度，即便我们能够先去设计测试场景，即便我们有测试覆盖率帮我们查缺补漏，但我们所做的一切都是建立在一个共同的前提下：我们要把代码写出来。</p><p>而测试人员则不同，他们并不关心代码是怎么实现的，他们只是站在业务的视角在想问题，他们考虑更多的是这个系统可以怎么用。只要二者的出发点不同，对于同样的事物，总会看到不同的东西。不然的话，人类社会哪有那么多的争论。</p><p>你或许会想，那我也从业务的角度去想，是不是就能获得测试人员的视角呢？</p><p>我要说，<strong>从业务角度思考，确实是我们向测试人员学习的一个重要方向。</strong>但同样不要指望你换个角度思考一下就能把测试人员代替了。人的注意力是有限的，作为一个程序员，我们会把更多的时间放在关于技术实现的思考上，<strong>我们在发现问题上的训练强度是远远不够的。</strong>所以，人们常说，别用你的业余爱好去挑战别人吃饭的本事。</p><p>程序员做测试，测试人员也做测试，那是不是测试人员的工作量就小多了？实际上，只要你稍微和测试同学交流一下你就会发现，在实际的工作中，<strong>大部分测试同学根本没有机会使出全力。</strong></p><p>在测试的分类中，有一种测试叫探索性测试，也就是测试人员竭尽所能去对系统去做测试。不过，虽然有这么个分类，但大多数测试人员并没有机会去做这种测试。不是因为他们偷懒，而是由于大部分系统的基础质量不高，造成的结果就是，测试同学的大部分工作找到的都是极其简单的 bug。换言之，如果程序员能够把自己的测试做好，很多问题就应该被消灭在萌芽状态，根本不应该到测试同学这里。</p><p>如果程序员能够提交一个经过自己测试的系统，测试同学才有机会让自己从日常琐碎的工作摆脱出来，去竭尽全力地测试一个系统。<strong>不是测试同学不努力，实在是系统太差劲。</strong></p><p>在我工作过的测试做得比较好的团队，软件质量整体上来说，确实要好上很多。测试同学有机会进行各种探索性测试，因为基础的问题都会在程序员的测试中被覆盖了。</p><p>好，到这里，我们也就回答了一开头的那个问题：<strong>程序员的测试不能够替代测试人员的测试。</strong>我们也不用替测试人员担心他们的职业前景了。那反过来，既然在测试方面，测试人员还是有着自己的优势，那是不是我们可以从他们身上学到点什么呢？</p><h2>向测试人员学习</h2><p>首先，我要帮你纠正一个典型的误区。有一些人认为，测试做得好要依赖于工具。确实，今天的测试已经不像过去那么纯手工了，各种工具层出不穷，甚至很多项目为了测试要开发自己的测试工具。<strong>但无论是什么样的测试工具，都只是提升效率的一种手段。</strong>如果没有背后的测试思维支撑，再好的工具，也是没用的。</p><p>与其纠结于寻找更好的工具，更重要的是要向测试人员学习他们的思维方式。</p><p>前面我们已经提到了一点，测试人员拥有业务视角，这是最值得程序员去学习的。通常来说，测试人员对于业务的理解都会很深刻。在我之前的经历里，如果一个团队缺少业务分析师，有时候，我会让一个测试人员顶上去，而且效果往往还不错。</p><p>程序员对业务视角的忽略是一个普遍存在的问题，但这也是一个程序员必须要突破的关口。实际上，让程序员拥有业务视角不仅仅是测试的需求，同样也是写好代码的要求。现在流行的 DDD 设计方法的核心就是要让业务人员和开发团队使用一样的通用语言（Ubiquitous Language）。由此我们知道，<a href="https://time.geekbang.org/column/article/82581">写代码要尽可能用业务语言写代码</a>。</p><p>有了业务视角，再深入一步，我们要学会设计测试。</p><p>设计测试的一个关键点是找到更多的测试场景。这里面我们说的测试场景，你可以把它理解成一个大的分支条件。其实很多时候，程序员与测试人员的差距，从测试场景这一步已经开始显现出来了。</p><p>很多测试场景程序员压根就没想到，所以，就很难说进一步地去测试了。在前面我自己的经历里，我只想到了协议包不正确的各种情况。但空协议包这种场景在我的思考里压根就没有，所以，我发现不了其中的问题就再正常不过了。</p><p>针对测试场景，我们还需要考虑各种情况。在这里我们说的各种情况，你可以把它理解成在一个测试场景下的各种小分支。通常来说，正常情况大家都能想到怎么解决，程序员欠缺的往往是各种异常情况的处理。</p><p>举个例子，同样是注册的场景，程序员都会考虑到正常注册的情况。但如果注册的用户名里包含各种符号该怎么办，甚至有些测试人员会想到如果字符串超长的情况该怎么办（比如几 K 字节的字符串），这些都是对不同的异常情况的思考。</p><p>诚如前面所说，很难指望每个程序员都能把所有的情况考虑到，但<strong>程序员每多想到一点，软件质量就能多提高一点。</strong></p><p>在《10x 程序员工作法》中我曾经讲过，<a href="https://time.geekbang.org/column/article/75100">每个需求都应该有验收条件</a>。验收条件是很多测试人员设计测试的出发点，这也是我们可以向测试人员学习的最直接方式，当然，前提条件是你们的团队有验收条件。如果没有，那你需要赶紧去建立这项团队实践。</p><p>其实在实际工作中，程序员与测试人员如果能够工作在一个团队里，那就有一个更简单的做法来提升软件质量，就是测试人员设计好了测试用例之后在团队内部做一个分享，让相关的程序员能够有一个参考去编写自己的测试。</p><p>不过，请你放心，虽然他们已经把测试用例分享给你了，在测试过程中，他们还会发现更多新的测试用例。如果程序员有了编写测试的习惯，那测试人员在测试过程中发现的问题，也可以成为一个新的测试项，成为程序员编写测试的一部分，我们可以用代码把这个用例固化下来。</p><p><strong>测试人员把用例分享给程序员，程序员用代码固化新的测试用例</strong>，这样，测试人员和开发人员之间就形成了一个良好的互动，我们也就有机会让软件的质量越做越好。</p><h2>总结时刻</h2><p>今天，我们谈到可能是不写测试的程序员关于测试问得最多的一个问题：程序员写测试，那测试人员怎么办？</p><p>程序员和测试人员拥有不同的视角，程序员更关注实现，而测试人员更关注业务，所以，即便程序员编写测试，也很难覆盖所有的情况。实际上，即便是测试人员也不敢说自己能够覆盖所有的情况。</p><p>目前大多数团队的情况是，测试人员并没有得到充分的发挥。只有程序员做好了自己的测试，测试人员才能从日常琐碎的验证工作中解脱出来，去做更有价值的测试。</p><p>在测试问题上，程序员应该向测试人员学习，与工具相比，更重要的是思维方式。我们可以像测试人员一样从测试场景入手，多考虑各种情况，尤其是异常情况。需求的验收条件是一个很好的测试起始点。</p><p>在团队中，测试人员可以把自己的测试用例分享给程序员，而程序员可以把新的测试用例用代码的方式固化下来，二者就此可以形成良好的互动。</p><p>其实，具体确定测试用例的方法有很多，比如边界值分析、等价类划分等等，这都是测试同学会更深入了解的内容，如果这一讲的内容让你对测试产生一些兴趣，你不妨去找本书读读，比如《<a href="https://book.douban.com/subject/10549782/">软件测试的艺术</a>》，或者找个测试同学深入请教一番。</p><p>如果今天的内容你只能记住一件事，那请记住：<strong>测试从测试场景入手，多考虑各种情况，尤其是异常情况。</strong></p><h2>思考题</h2><p>今天我们讲了程序员和测试人员之间的关系，你在实际工作中，从测试同学身上学到了哪些东西呢？欢迎在留言区分享你的经历。</p>',
        article_title: "03 | 程序员的测试与测试人员的测试有什么不同？",
      },
      {
        title: "04 | 自动化测试：为什么程序员做测试其实是有优势的？",
        id: 406711,
        content:
          '<p>你好，我是郑晔！</p><p>在上一讲里，我们讨论了程序员做测试和测试人员做测试之间有什么不同，你现在应该不会担心因为程序员做测试就抢了测试人员的饭碗了。这一讲，我们来谈谈程序员做测试的优势所在。估计你已经想到了，没错，就是自动化测试。</p><p>其实，程序员的主要工作就是打造各种自动化工具，无论是为了业务的支撑，或者是对于开发过程本身的支持。自动化，一方面是为了提高效率，另一方面，也是将低效繁琐的工作交由机器去完成。（关于自动化的种种思考，我在《10x 程序员工作法》中有了<a href="https://time.geekbang.org/column/article/86210">一个模块</a>进行讲解，如果你有兴趣不妨去回顾一下。）</p><p>测试这种工作其实非常适合自动化，因为在整个软件的生命周期之内，新的需求总会不断出现，代码总会不断地调整。鉴于大部分软件常常都是牵一发动全身，所以，即便是只改动了一点代码，理论上来说也应该对软件的全部特性进行完整验证。如果只靠人工来做这个事情，这无疑是非常困难的。</p><p>很多团队只依赖于测试人员进行测试，而且测试以手工为主，结果就是大部分时间都是在进行低效地验证工作，而这些工作恰恰是最适合用自动化测试完成的。</p><h2>从自测到自动化测试框架</h2><p>你平时是怎么验证自己代码正确性的呢？最不负责任的做法是压根不验证，我曾见过最极端的做法是连编译都不通过的代码就直接提交了。不过，这是我职业生涯早期发生的事情。随着行业整体水平的提高，这种事情现在几乎看不到了。</p><!-- [[[read_end]]] --><p>现在很多人的做法是把整个系统启动起来，然后手工进行验证。当然，大多数人不会验证系统里面所有的内容，只会针对自己正在开发的部分进行验证。这种做法通常只能够保证自己刚刚编写的代码是正确的。结果常常是按下葫芦浮起瓢——这个功能是对了，但之前原本验证好的功能又不对了。</p><p>即便是一个再小的系统，其中的细节也多到没有人愿意每次去手工验证其中所有的细节。因为这样做既琐碎又重复，这显然是适合自动化发挥战斗力的地方。</p><p>最开始的自动化都是很简单的。通常来说，就是直接写一个 main 函数，直接调用代码中的模块。但每次要测试不同的代码时，程序员就要注释掉原来的测试代码，然后，再编写新的测试代码。</p><p>这种做法虽然可以去验证代码的正确性，但显然不适合反复验证。稍微优化点的做法就是把一个个测试用例放到不同的函数里。总的来说，这个阶段的自动化测试还处于草莽阶段。</p><p><strong>真正让自动化测试这件事登堂入室的，就是自动化测试框架了。</strong>最早的测试框架起源是 Smalltalk 社区。Smalltalk 是一门早期的面向对象程序设计语言，它有很多拥趸，很多今天流行的编程概念都来自于 Smalltalk 社区，自动化测试框架便是其中之一。</p><p>不过，真正让测试框架广泛流行起来，要归功于则另外的自动化测试框架 JUnit，它的作者是 Kent Beck 和 Erich Gamma。Kent Beck 是极限编程的创始人，在软件工程领域大名鼎鼎，而 Erich Gamma 则是著名的《设计模式》一书的作者，很多人熟悉的 Visual Studio Code 也有他的重大贡献。</p><p>有一次，Kent Beck 和 Erich Gamma一起从苏黎世飞往亚特兰大参加 OOPLSA（Object-Oriented Programming, Systems, Languages &amp; Applications）大会，在航班上两个人结对编程写出了 JUnit。从这个名字你不难看出，它的目标是打造一个单元测试框架。二人之所以能够在一路上就完成 JUnit 最初版本的开发，是因为他俩本身就在 Smalltalk 社区摸爬滚打了一段时间，对 Smalltalk 的单元测试框架有着很深刻的认识。</p><p>今天流行的自动化测试框架统称为 xUnit，因为它们都有一个共同的根基，也就是 JUnit。所以，只要了解了 JUnit 中的基本概念，你再去看其它测试框架，几乎都是差不多的。</p><h2>测试框架简介</h2><p>接下来，我们就来一次快速的自动化测试框架简介，如果你已经对自动化测试框架非常熟悉的话，可以当做一次轻松的复习。</p><p><strong>我们理解测试框架有两个关键点，一是要去理解测试组织的结构，一是要去理解断言。</strong>掌握了这两点，就足够应付日常的大多数情况了。</p><h3>测试结构</h3><p>我们先来看看组织测试的结构。首先，最核心的概念就是怎么表示一个测试用例。JUnit 怎么表示测试用例，我们在前面讲实战的时候已经见识过了，代码如下所示。</p><pre><code>@Test\npublic should_work() {\n  ...\n}\n</code></pre><p>我们前面说过，草莽阶段稍微优化一点的做法就是把测试用例放到一个个不同的函数里面，而测试框架就是把这种做法做了一个延伸，同样是用一个一个的函数表示一个一个的测试用例。不同的是，在草莽阶段，你每写一个函数就要在执行的部分注册一下这个函数。</p><p>使用测试框架的话，需要对表示测试用例的函数进行统一的标识，以便框架能够在运行时识别出来。在我们上面这个例子里面，用来识别测试用例的就是@Test。如果你用过 4.0 之前版本的 JUnit，它是约定以 test 开头的函数就是测试用例，所以，你会看到下面这样的写法。</p><pre><code>public test_should_work() {\n  ...\n}\n</code></pre><p><strong>两种不同的写法本质上是程序设计语言层面的差别</strong>，因为 Java 5 引入了 Annotation 这个语法，才有了基于@Test 进行标注的做法。<strong>很多的语法层面的改进都是为了提升语言的表达能力，而这一点在程序库的设计上体现得最为明显</strong>。如果你去看不同程序语言的测试框架时就会发现，做得比较差就是直接照搬 test 开头的做法，而做得比较好的则是会结合自己的语言特点。</p><p>了解了最基本的测试用例结构，其实写测试就够了。但是，测试也是代码，好的测试代码要兼具好代码的属性，最基本的要求就是消除重复。</p><p>比如，同样的初始化代码反复在写，由于测试的特殊性，这些初始化的代码需要在每个测试之前都去执行。为了解决这个问题，JUnit 引入了 setUp 去做初始化的工作。在 JUnit 4 之后，这个由函数名称进行定义的做法，改成了使用 @BeforeEach 进行定义的方式。我们在前面的实战中也提到过。</p><pre><code>@BeforeEach\nvoid setUp() {\n  ...\n}\n</code></pre><p>由于 @BeforeEach 的存在，setUp 这个名字在这里已经没有意义，只不过因为这是一个函数，需要有一个名字。从习惯上，我们还是称呼它为 setUp 函数。如果 JUnit 进一步将语法升级到 Java 8 的语法，这里完全可以使用 lambda，去掉对名字的依赖。</p><p>与 @BeforeEach 和 setUp 对应的是 @AfterEach 和 tearDown，它们处理的是要在每个测试之后执行的清理工作。相对来说，这一对用的就比较少了，除非是你用到了一些需要释放的资源。</p><p>知道了测试用例的写法，知道了 setUp/tearDown，你就基本上掌握了测试结构的核心了。如果你具体学习一个测试框架，还会有人告诉你 TestSuite、TestRunner 等等的概念，但它们现在基本上可以归入到实现层面了（也就是执行测试所需要了解的概念），而在编写代码的层面上，有前面说到的这几个概念就够了。</p><h3>断言</h3><p>我们接下来看理解测试框架的第二个关键点，断言。测试结构保证了测试用例能够按照预期的方式执行，而断言则保证了我们的测试需要有一个目标，也就是我们到底要测什么。</p><p>断言，说白了就是拿执行的结果和预期的结果进行比较。如果执行一个测试连预期都没有，那它到底要测什么？所以，我们可以说，<strong>没有断言的测试不是好测试。</strong></p><p>几乎每个测试框架都有自己内建的断言机制，比如下面这个。</p><pre><code>assertEquals(2, calculator.add(1, 1));\n</code></pre><p>这个 assertEquals 是最典型的一个断言，也几乎是使用最多的断言，很多其它语言的测试框架也把它原封不动地搬了过去。但这个断言有一个严重的问题，你如果不看 API，根本记不住哪个应该是预期值，哪个应该是你函数返回的实际值。这就是典型的 API 设计问题，让人很难用好。</p><p>所以，社区中涌现了大量的第三方断言程序库，比如，<a href="https://hamcrest.org/JavaHamcrest/">Hamcrest</a>、<a href="https://joel-costigliola.github.io/assertj/">AssertJ</a>、<a href="https://truth.dev/">Truth</a>。其中，Hamcrest 是一个函数组合风格的断言库，一度被内建到 JUnit 4 里面，但出于对社区竞争的鼓励，JUnit 5 又把它挪了出来，下面是一段使用了 Harmcrest 的代码。</p><pre><code>assertThat(calculator.subtract(4, 1), is(equalTo(3)));\n</code></pre><p>AssertJ 是一种流畅风格的程序库，扩展性也非常不错，它也是我们在前面实战部分选择的程序库，下面是一段使用了 AssertJ 的代码。</p><pre><code>assertThat(frodo.getName()).startsWith(&quot;Fro&quot;)\n                           .endsWith(&quot;do&quot;)\n                           .isEqualToIgnoringCase(&quot;frodo&quot;);\n</code></pre><p>Truth 是 Google 开源的一个断言库，和 AssertJ 很类似，它对 Android 程序支持得比较好，我也放了一段代码，风格上和 AssertJ 如出一辙。</p><pre><code>assertThat(projectsByTeam())\n    .valuesForKey(&quot;corelibs&quot;)\n    .containsExactly(&quot;guava&quot;, &quot;dagger&quot;, &quot;truth&quot;, &quot;auto&quot;, &quot;caliper&quot;);\n</code></pre><p>断言，不仅仅包括有返回值的处理，还包括其它的特殊情况，比如，抛出异常也可进行断言，这是 JUnit 5 内建的异常断言，你可以参考一下。</p><pre><code>Assertions.assertThrows(IllegalArgumentException.class, () -&gt; {\n  Integer.parseInt(&quot;One&quot;);\n});\n</code></pre><p>具体有哪些情况可以进行断言，你可以查阅所使用断言库的 API 文档。</p><p>最后，我还要讲一个不在这些断言库里的断言，那就是 Mock 框架提供的一种断言：verify。</p><p>关于 Mock 框架，后面我们还会讲到，这里只是简单地提一下，verify 的作用就是验证一个函数有没有得到调用。在某些测试里面，函数既没有返回值，也不会抛出异常。比如拿保存一个对象来说，我们唯一能够判断保存动作是否正确执行的办法，就是利用 verify 去验证保存的函数是否得到调用，就像下面这样。</p><pre><code>verify(repository).save(obj);\n</code></pre><p>虽然它不在断言库中，但它确确实实是一种断言，它判断的是一个动作是否得到正确的执行。所以，当我们说一个测试应该包含断言时，有 verify 的情况也算是有断言了。至于怎么用好 verify，我们后面讲到 Mock 框架时再说。</p><p>讲过测试结构和断言，我们已经把测试框架的核心内容说完了。但这些只是写测试的基础，要想写好测试，我们还需要对什么样的测试是好的测试有个基本的认识，这就是我们下一讲要讲的内容了。</p><h2>总结时刻</h2><p>这一讲，我们讲了程序员在测试上的优势所在，也就是自动化。软件开发本身就是一个不断迭代的过程，对每一次代码的改动来说，理论上就应该把整个系统从头到尾地测一遍。这种工作手工做是非常琐碎的，所以非常适合使用自动化。</p><p>验证程序的正确性是程序员的基本工作，不过，很多人的做法还是手工验证。为别人打造自动化工具的人，自己的开发过程还不够自动化，这是很多程序员面对的尴尬。实际上，还有一些人在探索自动化的做法，从最早的 main 函数，到后来的自动化测试框架，就是在这方面一点一点的进步。自动化测试框架的出现，让自动化测试从业余走向了专业。</p><p>理解自动化测试框架，主要包含两个部分：组织测试的结构以及断言。组织测试的结构最核心的就是测试用例如何写，以及 setUp 和 tearDown 函数。而断言则是保证了我们测试的目标。断言程序库有很多，你可以根据自己的喜好进行选择。除了断言程序库，Mock 框架的 verify 也是一种断言。</p><p>如果今天的内容你只能记住一件事，那请记住：<strong>没有断言的测试不是好测试。</strong></p><h2>思考题</h2><p>今天我们讲了自动化测试框架最核心的部分，但现在的测试框架都已经有了更多丰富的功能，希望你找一个你喜欢的测试框架，深入地了解一下它们新特性，挑一个让你印象深刻的特性和我们分享。期待在留言区看到你的想法。</p>',
        article_title: "04 | 自动化测试：为什么程序员做测试其实是有优势的？",
      },
      {
        title: "05 | 一个好的自动化测试长什么样？",
        id: 407452,
        content:
          '<p>你好，我是郑晔！</p><p>在上一讲里我们讲了测试的一个关键点是自动化测试，而自动化刚好是程序员的强项。自从有了自动化测试框架，自动化测试就从业余走向了专业，但这并不是说，有了测试框架你就能把测试写好了，我们来看几个典型的问题：</p><ul>\n<li>测试不够稳定，一次运行通过，下次就不能通过了；</li>\n<li>要测的东西很简单，但是为了测这个东西，光是周边配套的准备就要写很多的代码；</li>\n<li>一个测试必须在另一个测试之后运行；</li>\n<li>……</li>\n</ul><p>这是让很多团队在测试中挣扎的原因，也是很多人放弃测试的理由。之所以测试会出现这样那样的问题，一个重要的原因是这些测试不够好。这一讲，我们就来讲讲好的测试应该长什么样。</p><h2>测试的样子</h2><p>关于自动化测试，其实有一个关键的问题我们一直还没有讨论。我们用测试来保证代码的正确性，然而，测试的正确性如何保证呢？</p><p>这是一个会问懵很多人的问题：测试保证代码的正确性，那测试代码的正确性也用测试保证？但你见过有人给测试写测试吗？没有。因为这是一个循环的问题，你给测试写了测试，那新的测试怎么保证正确性呢？难不成要递归地写下去？是不是有种大脑要堆栈溢出的感觉了。</p><p>既然给测试写测试不是一个行得通的做法，那唯一可行的方案就是，<strong>把测试写简单，简单到一目了然，不需要证明它的正确性</strong>。由此，我们可以知道，一个复杂的测试肯定不是一个好的测试。</p><!-- [[[read_end]]] --><p>简单的测试应该长什么样呢？我们一起来看一个例子，这就是我们在实战环节中给出的第一个测试。</p><pre><code>@Test\npublic void should_add_todo_item() {\n  // 准备\n  TodoItemRepository repository = mock(TodoItemRepository.class);\n  when(repository.save(any())).then(returnsFirstArg());\n  TodoItemService service = new TodoItemService(repository);\n  \n  // 执行  \n  TodoItem item = service.addTodoItem(new TodoParameter(&quot;foo&quot;));\n  \n  // 断言  \n  assertThat(item.getContent()).isEqualTo(&quot;foo&quot;);\n  \n  // 清理(可选)\n  \n}\n</code></pre><p>我把这个测试分成了四段，分别是准备、执行、断言和清理，这也是一般测试都会具备的四个阶段，我们分别来看一下。</p><p><strong>准备。</strong>这个阶段是为了测试所做的一些准备，比如启动外部依赖的服务，存储一些预置的数据。在我们这个例子里面就是设置所需组件的行为，然后将这些组件组装了起来。</p><p><strong>执行。</strong>这个阶段是整个测试中最核心的部分，触发被测目标的行为。通常来说，它就是一个测试点，在大多数情况下，执行应该就是一个函数调用。如果是测试外部系统，就是发出一个请求。在我们这段代码里，它就是调用了一个函数。</p><p><strong>断言。</strong>断言是我们的预期，它负责验证执行的结果是否正确。比如，被测系统是否返回了正确的应答。在这个例子，我们验证的是 Todo 项的内容是否是我们添加进去的内容。</p><p><strong>清理。</strong>清理是一个可能会有的部分。如果在测试中使到了外部资源，在这个部分要及时地释放掉，保证测试环境被还原到一个最初的状态，就像什么都没发生过一样。比如，我们在测试过程中向数据库插入了数据，执行之后，要删除测试过程中插入的数据。一些测试框架对一些通用的情况已经提供支持，比如之前我们用到的临时文件。</p><p>如果准备和清理的部分是在几个测试用例间通用的，它们就有可能被放到 setUp 和 tearDown 里去完成，这一点我们在上一讲已经讲过了。</p><p>这四个阶段中，必须存在的是执行和断言。想想也是，<strong>不执行，目标都没有，还测什么？不断言，预期都没有，跑了也是白跑。</strong>如果不涉及到一些资源释放，清理部分很可能就没有了。而对一些简单的测试来说，也不需要做特别的准备。</p><p>从结构上来看，测试用例应该就是这么简单。你去看一下我们在实战中的代码，大部分测试都是可以这样划分的。</p><p>理解了测试的结构，有一些测试存在的问题你一眼就能看出来了。比如对于没有断言的测试来说，看上去测试从来不会出错，但这样的测试几乎是没有价值的。</p><p>再比如，一个测试里有多个执行目标，可能是需要在一个测试里要测多个不同的函数。这就是一个坏味道了。为什么说这是一个坏味道呢？因为测试的根基是简单，一旦复杂了，我们就很难保证测试本身的正确性。如果你有多个目标怎么办？分成多个测试就好了。</p><p>如果测试本身简单到令人发指的程度，出于节省代码篇幅的角度，你可以考虑在一个测试里面写。比如测试字符串为空的函数，我要分别传入空对象和空字符串，每种情况执行和断言一行代码就写完了，那我可能就在一个测试里面写了。</p><h2>一段旅程（A-TRIP）</h2><p>有了对测试结构的基本认知，我们再进一步，看看如何衡量一个测试有没有做好？有人把好测试的特点总结成一个说法：<strong>A-TRIP</strong>。这其实是五个单词的缩写，分别是：</p><ul>\n<li>Automatic，自动化；</li>\n<li>Thorough，全面的；</li>\n<li>Repeatable，可重复的；</li>\n<li>Independent，独立的；</li>\n<li>Professional，专业的。</li>\n</ul><p>这是什么意思呢？我们分别来解释一下。</p><p><strong>Automatic，自动化。</strong>经过上一讲的讲解，这一点你应该已经很容易理解了。自动化测试相比传统测试，核心增强就在自动化上。这也是为什么测试一定要有断言，因为只有在有断言的情况下，机器才能够帮我们判断测试是否成功。</p><p><strong>Thorough，全面的。</strong>这一点其实是测试的要求，应该尽可能用测试覆盖各种场景。不管什么样的自动化测试，它的本质还是测试，前面我们讲了向测试人员学习，关键点就在于这有助于我们写出更全面的测试。理解全面还有一个角度，就是测试覆盖率。我们在实战环节中已经见识了如何通过测试覆盖率工具，帮我们去发现代码中测试中没有覆盖到地方。</p><p><strong>Repeatable，可重复的。</strong>它要求测试能够反复运行，并且结果都应该是一样的。这是保证测试简单可靠的前提。如果一个测试不是可重复的，我们就没法相信它的运行结果，测试的价值也就荡然无存了。一旦测试报错，我们没法确定是我们程序出错了，还是其它什么地方出错了。</p><p>在内存中执行的测试一般都是可重复的。影响一个测试可重复性的主要因素是外部资源，常见的外部资源包括文件、数据库、中间件、第三方服务等等。如果在测试中遇到这些外部资源，我们就要想办法让这些资源在测试结束后，恢复原来的样子。你在实战中已经见识过如何处理文件，在后面的应用篇，我们还会讲到如何处理数据库。简单说就是在测试执行之后，能够把数据回滚掉。</p><p>如果你遇到中间件，最好有一个独立可控的中间件。而遇到第三方服务，则可以采用模拟服务，我的开源项目 Moco 主要就是为了解决这种外部依赖而生的。</p><p>理解可重复性还有一个角度，那就是一批测试也要可重复。这就需要测试之间彼此没有依赖，这也是我们接下来要讨论的测试的另外一个特点。</p><p><strong>Independent，独立的。</strong>测试和测试之间不应该有任何依赖。什么叫有依赖？就是一个测试要依赖于另外一个测试运行的结果。比如两个测试都要依赖于数据库，第一个测试运行时往数据库里写了一些数据，而第二个测试在执行时要用到这些数据。也就是说，第二个测试必须在第一个测试执行之后再执行，这就叫做有依赖。</p><p>我知道，有很多人有很多的理由让测试之间有依赖。比如说为了提高执行效率，但这种做法属于特定的优化。对于其他绝大多数情况而言，一旦你开始这么做了，测试就走上了歧途。比如，一些框架支持多个测试并行运行，一旦测试有依赖，测试就无法并行执行，因为这两个测试之间是有顺序的。再比如，一旦有人破坏了测试的独立性，紧接着就会有更多的人破坏独立性，这就像代码的坏味道一样，很容易传播。</p><p>可重复性和独立性关联非常紧密。因为我们通常认为，可重复是测试按照随机的顺序执行，其结果也是一样的，这就要依赖于测试是独立的。而一旦测试不独立，有了依赖，从单个测试上来看，它也违反了可重复性。</p><p><strong>Professional，专业的。</strong>这一点是很多人观念中缺失的，测试代码也是代码，也要按照代码的标准去维护。这就意味着你的测试代码也要写得清晰，比如良好的命名、把函数写小、要重构甚至要抽象出测试的基础库、测试的模式。在 Web 测试中常见的 <a href="https://martinfowler.com/bliki/PageObject.html">PageObject 模式</a>，就是这种理念的延伸。</p><p>有一点我准备多说几句，就是测试的命名。很多人写代码时，知道要取一个有意义的命名，但在测试上常常忽略这一点，我们经常可以看到 test1、test2这样的测试命名。那测试应该怎么命名呢？</p><p>我不知道你是否注意到了，我在实战中写的测试，其命名与传统的 Java 函数有着很大的区别。首先，我用了下划线区隔单词，而没有采用驼峰命名；其次，名字都很长；再有，所有的测试都是以 should 开头。</p><p>我为什么要这么写呢？其实，我是希望在测试名中把测试用例的场景给描述出来。换言之，这个测试名不是一个简单的名字，而是一句话，这样测试的名字就会很长。而一旦名字太长，用驼峰阅读起来就不那么舒服了，所以，我采用了下划线区隔。</p><p>我对测试的命名主要有两种：</p><ul>\n<li>should_测试场景；</li>\n<li>should_测试效果_while_测试条件。</li>\n</ul><p>第一种命名表示应该做成什么样子，比如，should_add_todo_item，一般来说，对于一个正常情况的测试用例，我会这么命名。第二种情况则表示在什么条件下，应该出现什么效果，比如，should_throw_exception_while_parameter_is_empty，可以用来描述各种异常的情况。你会看到这两种命名方法其实都是写了一句话，而之所以会用 should 开头，它表示这个测试“应该”是什么样的。</p><p>有一些测试框架在测试描述上做得更加进一步，看上去就更像一句话了，下面是一个例子。</p><pre><code>it.should(&quot;throw exception while parameter is empty&quot;, () -&gt; {\n  ...\n});\n</code></pre><p>经过这一讲的介绍，相信你对一个好的测试应该长成什么样已经有了一个初步的认识，但知道了好测试长什么样，只能帮助你发现测试中存在的问题。下一讲，我们接着来讨论一个影响写好测试的关键因素：软件设计。</p><h2>总结时刻</h2><p>这一讲，我们讨论了一个好的测试应该是什么样子的。一个好的测试首先应该是简单的，否则，我们无法保证测试的正确性。</p><p>我们还谈到了测试的基本结构：准备、执行、断言和清理。其中，核心的部分是执行和断言。一个测试既不能执行太多的东西，也不能没有断言。</p><p>怎么衡量测试是否做好了呢？有一个标准：A-TRIP，这是五个单词的缩写，分别是 Automatic（自动化）、Thorough（全面的）、Repeatable（可重复的）、Independent（独立的）和 Professional（专业的）。</p><p>如果今天的内容你只能记住一件事，那请记住：<strong>编写简单的测试</strong>。</p><p><img src="https://static001.geekbang.org/resource/image/77/f0/773b081cc5f73803bfd472be2bf57cf0.jpg?wh=2000x1193" alt=""></p><h2>思考题</h2><p>用今天讲到好测试的原则去对比一下你的测试，你会发现哪些问题呢？欢迎在留言区分享你的发现。</p>',
        article_title: "05 | 一个好的自动化测试长什么样？",
      },
      {
        title: "06 | 测试不好做，为什么会和设计有关系？",
        id: 408187,
        content:
          '<p>你好，我是郑晔！</p><p>在前面几讲里，我们讲了测试的一些基础，要有测试思维、要学会使用自动化测试框架、要按照好测试的样子去写测试……但是，懂了这些就能把测试写好吗？</p><p>答案显然是否定的。因为这些东西很多人都知道，但真正到了实际的项目中面对自己的代码，还是不会写测试。主要的问题就是不好测，这也是测试劝退了很多程序员的一个重要原因。</p><p>不好测实际上是一个结果。那造成这个结果的原因是什么呢？答案就是我们今天要讨论的话题：软件设计。</p><h2>可测试性</h2><p>为什么说不好测是由于软件设计不好造成的呢？其实，更准确的说法是绝大多数人写软件就没怎么考虑过设计。</p><p>软件设计是什么？软件设计就是在构建模型和规范。</p><p>然而，大多数人写软件的关注点是实现。我们学习写程序的过程，一定是从实现一个功能开始的。这一点在最开始是没有问题的，因为需求的复杂度不高。不过需求一旦累积到一定规模，复杂度就会开始大幅度升高，不懂软件设计的人就开始陷入泥潭。</p><p>即便一个人认识到软件设计的重要性，学习了软件设计，但在做设计的时候还是常常会对<strong>可测试性</strong>考虑不足。可测试性是一个软件/模块对测试的支持程度，也就是当我执行了一个动作之后，我得花多大力气知道我做得到底对不对。</p><p><strong>我们所说的代码不好测，其实就是可测试性不好。</strong>当我们添加了一个新功能时，如果必须把整个系统启动起来，然后给系统发消息，再到数据库里写 SQL 把查数据去做对比，这是非常麻烦的一件事。为了一个简单的功能兜这么大一圈，这无论如何都是可测试性很糟糕的表现。然而，这却是很多团队测试的真实状况。因为系统每个模块的可测试性不好，所以，最终只能把整个系统都集成起来进行系统测试。</p><!-- [[[read_end]]] --><p>如果建楼用的每块材料都不敢保证质量，你敢要求最终建出来的大楼质量很高吗？这就是很多团队面临的尴尬场景：每个模块都没有验证过，只知道系统集成起来能够工作。所以，一旦一个系统可以工作了，最好的办法就是不去动它。然而，还有一大堆新需求排在后面。</p><p>相应地，<strong>对一个可测试性好的系统而言，应该每个模块都可以进行独立的测试。</strong>在我们把每一个组件都测试稳定之后，再把这些组件组装起来进行验证，这样逐步构建起来的系统，我对它的质量是放心的。即便是要改动某些部分，有了相应的测试做保证，我才敢于放手去改。</p><p>可测试性很重要，但我要怎么让自己的代码有可测试性呢？</p><h2>编写可测试的代码</h2><p>编写可测试的代码，最简单的回答就是<strong>让自己的代码符合软件设计原则</strong>。在《软件设计之美》的专栏里，我专门讲了 SOLID 原则，这是目前软件设计中最成体系的一套设计原则。如果代码真的能做到符合 SOLID 原则，那它基本上就是可测的。</p><p>比如，符合单一职责原则的代码一般都不会特别长，也就没有那么多的分支路径，相对来说就比较容易测试。再比如，符合依赖倒置原则的代码，高层的逻辑就不会依赖于底层的实现，测试高层逻辑的部分也就可以用 Mock 框架去模拟底层的实现。</p><p>编写可测试的代码，如果只记住一个通用规则，那就是<strong>编写可组合的代码。</strong>什么叫可组合的代码？就是要能够像积木一样组装起来的代码。</p><p>既然要求代码是组装出来的，由此得出的<strong>第一个推论是不要在组件内部去创建对象。</strong>比如，我们在前面的实战中有一个 TodoItemService，它有一个 repository 字段。这个字段从哪来呢？直接创建一个实例理论上是可以的，但它会产生耦合。根据我们的推论，不要在组件内部创建对象，所以，我们考虑从构造函数把它作为参数传进来。</p><pre><code>public class TodoItemService {\n    private final TodoItemRepository repository;\n    \n    public TodoItemService(final TodoItemRepository repository) {\n        this.repository = repository;\n    }\n    ...\n}\n</code></pre><p>你或许会问了，如果不在内部创建对象，那谁来负责这个对象的创建呢？答案是组件的组装过程。组件组装在 Java 世界里已经有了一个标准答案，就是依赖注入。</p><p>不在内部创建，那就意味着把组件的组装过程外置了。既然是外置了，组装的活可以由产品代码完成，同样也可以由测试过程完成。</p><p>站在测试的角度看，如果我们需要测试 TodoItemService 就不需要依赖于 repository 的具体实现，完全可以使用模拟对象进行替代。</p><p>我们可以完全控制模拟对象的行为，这样，对 TodoItemService 的测试重点就全在 TodoItemService 本身，无需考虑 repository 的实现细节。在实战的过程中你也看到了，我们在实现了 TodoItemService 时，甚至还没有一个 repository 的具体实现。</p><p>现在你知道了，编写可组合的代码意味着，我们把组件之间的关联过程交了出去，组件本身并不会去主动获取其相关联组件的实现。由此，我们要得出<strong>第二个推论：不要编写 static 方法。</strong></p><p>我知道很多人喜欢 static 方法，因为它用起来很方便，但对测试来说却不是这样。使用 static 方法是一种主动获取的做法。一旦组件主动获取，测试就没有机会参与到其中，相应地，我们也就控制不了相应的行为，测试难度自然就增大了。所以，如果团队需要有一个统一约定，那就是不使用 static 方法。</p><p>如果非要说有什么特例，那就是编写一些基础库（比如字符串处理等），这种情况可以使用 static 方法。但基本上大部分程序员很少有机会去写基础库，所以，我们还是把不编写 static 方法作为统一的原则。</p><p>如果你能够摒弃掉 static 方法，<strong>还有两样东西你也就可以抛弃了，一个是全局状态，一个是 Singleton 模式。</strong></p><p>如果你的系统中有全局状态，那就会造成代码之间彼此的依赖：一段代码改了状态，另一端代码因为要使用这个状态而崩溃。</p><p>但如果我们抛弃了 static 方法，多半你也就没有机会使用全局状态了，因为直接访问的入口点没有了。如果需要确实有状态，那就可以由一个组件来完成，然后，把这个组件注入进来。</p><p>如果你能够理解 static 方法的问题，你也就能够理解 Singleton 模式存在的问题了。它也是一样没有办法去干涉对象的创建，而且它本身限制了继承，也没有办法去模拟。</p><p>你或许已经意识到了，之所以说编写可组合的代码是可测试性的关键，是因为我们在测试的过程中要参与到组件的组装过程中，我们可能会用模拟对象代替真实对象。模拟对象对我们来说是完全可控的，而真实对象则不一定那么方便，比如真实对象可能会牵扯到外部资源，带来的问题可能比解决的问题更多。</p><p>要使用模拟对象，就要保证接口可继承，函数可改写，这也是我们对于编写可测试代码的一个要求。所以，这又回到了设计上，要想保证代码的可测试性，我们就要保证代码是符合面向对象设计原则的，比如要基于行为进行封装等等。</p><h2>与第三方代码集成</h2><p>如果说前面讨论的内容更多的是面向自己写的代码，那在实际工作中，我们还会面临一个真实的问题，就是与第三方的代码集成。无论是用到开源的程序库，还是用到别人封装好的代码，总之，我们要面对一些自己不可控的代码，而这些代码往往也会成为你编写测试的阻碍。</p><p><strong>对于测试而言，第三方的代码难就难在不可控，要想让它们不再成为阻碍，就要让它们变得可控。</strong></p><p>如何让第三方代码可控呢？答案就是隔离，也就是将第三方代码和我们自己编写的业务代码分开。如何隔离呢？我们分成两种情况来讨论。</p><h3>调用程序库</h3><p>第一种情况是我们的代码直接去调用一个程序库。在实际工作中，这应该是最广泛的使用场景，可能是对一个协议解析，也可能调用一个服务发送通知。</p><p>在实战的例子中，我们也曾经调用 Jackson 去实现 JSON 的处理。那个例子就表现了一个典型的第三方代码不可控，它抛出的异常我们不好去模拟，所以，很难用测试去覆盖。不过，因为那个例子比较特殊，算是基础库的范畴，我们就直接封装成 static 方法了。</p><p>在大部分的情况下，<strong>我们做代码隔离，需要先定义接口，然后，用第三方代码去做一个相应的实现。</strong>比如，我们在实战中定义过一个 TodoItemRepository，当时给的实现是一个基于文件的实现。</p><pre><code>interface TodoItemRepository {\n  ...\n}\n\nclass FileTodoItemRepository implements TodoItemRepository {\n  ...\n}\n</code></pre><p>如果我们要把数据存到数据库里，那我们就可以给出一个数据的实现。</p><pre><code>class DbTodoItemRepository implements TodoItemRepository {\n  ...\n}\n</code></pre><p>而要存到云存储，就写一个云存储的实现。</p><pre><code>class S3TodoItemRepository implements TodoItemRepository {\n  ...\n}\n</code></pre><p>这里的关键点是定义一个接口，这个接口是高层的抽象，属于我们业务的一部分。但要使用的第三方代码则属于一个具体的实现，它是细节，而不是业务的一部分。如果熟悉软件设计原则，你已经发现了，这其实就是<a href="https://time.geekbang.org/column/article/264079">依赖倒置原则</a>。</p><p>有了这层隔离之后，我们就可以竭尽全力地把所有的业务代码用测试覆盖好，毕竟它才是我们的核心。</p><h3>由框架回调</h3><p>我们再来看与第三方代码集成的另外一种情况，由框架回调。比如，我们在实战里面用到了一个处理命令行的程序库 Picocli，它会负责替我们解析命令行，然后，调用我们的代码，这就是一个典型的由框架回调的过程。</p><p>这种情况在使用一些框架时非常常见，比如，使用 Spring Boot 的时候，我们写的 Controller 就是由框架回调的。使用 Flink 这样的大数据框架时，我们写的代码最终也是由框架回调的。</p><p>不同的框架使用起来轻重是不同的，比如在实战中，我们就直接触发了 Picocli，因为它本身比较轻量级；而像 Flink 这样的大数据框架想要在本地运行就需要做一些配置。</p><p>总而言之，要想测试使用了这些框架的程序，多半就是一种集成测试，而集成测试相对于单元测试来说，是比较重的，启动配置比较麻烦，运行时间比较长。</p><p>如果应用能在一个进程中启动起来，这还是好的情况。我还依然记得当年 Java 的主流开发方式是部署到应用服务器上，每次打包部署都是一个让人痛苦不堪的过程。像今天本地能够启动一个 Spring Boot 进程，这完全是需要感谢嵌入式 Web 服务器的发展。</p><p>面对这样的框架，我们有一个统一的原则：<strong>回调代码只做薄薄的一层，负责从框架代码转发到业务代码。</strong></p><p>我们在实战的代码中已经见到了，比如，下面这段代码是添加一个 Todo 项的实现。</p><pre><code>@CommandLine.Command(name = &quot;add&quot;)\npublic int add(@CommandLine.Parameters(index = &quot;0&quot;) final String item) {\n  if (Strings.isNullOrEmpty(item)) {\n    throw new CommandLine.ParameterException(spec.commandLine(), &quot;empty item is not allowed&quot;);\n  }\n  final TodoItem todoItem = this.service.addTodoItem(TodoParameter.of(item));\n  System.out.printf(&quot;%d. %s%n&quot;, todoItem.getIndex(), todoItem.getContent());\n  System.out.printf(&quot;Item &lt;%d&gt; added%n&quot;, todoItem.getIndex());\n  return 0;\n}\n</code></pre><p>这里面的核心代码就一句话，剩下的要么是做校验，要么是与框架的交互，几乎没有太多逻辑可言。</p><pre><code>this.service.addTodoItem(TodoParameter.of(item));\n</code></pre><p>正如你在实战过程中见到的那样，我会先编写自己的业务核心代码，而把与框架接口的部分放到了后面去编写。因为最容易出问题的地方往往不是在这个转发的过程，而是业务的部分。只有当你的业务代码质量提升了，整个系统的质量才会得到真正的提升。所以，如果你看到这一层写了很多的代码，那这段代码一定是有坏味道了。</p><p>或许你也发现了，这其实也是一种常见的模式：防腐层。是的，不仅仅是我们与第三方系统交互有防腐层，与外界的交互同样需要防腐层。</p><p>你也看到了无论是调用程序库还是由框架回调，说来说去，都会回到软件设计上。所以，一个可测试的系统，关键要有一个好的设计。<strong>想要写出高质量的代码，软件设计就是程序员必备的一项能力</strong>。</p><p>通过软件设计，我们将业务代码同一些实现细节分离开来。但如果我们在测试中使用同样的实现，结果必然是把复杂性又带回来了。那不用同样的实现该怎么测试呢？下一讲，我们就来说说，怎么在测试中给出一个可控的实现。</p><h2>总结时刻</h2><p>这一讲，我们讲了软件的可测试性，这是影响到一个系统好不好测的一个重要因素。可测试性好的软件，各个模块都可以独立测试。而可测试性不好的软件，只能做整体的测试，其复杂度和过程中花费的时间都是不可同日而语的。</p><p>提升软件的可测试性，关键是改善软件的设计，编写可测试的代码。关于如何编写可测试的代码，我给了一个路标：编写可组合的代码。从这个路标出发，我们得出了两个推论：</p><ul>\n<li>不要在组件内部创建对象；</li>\n<li>不要编写 static 方法。</li>\n</ul><p>由不编写 static 方法，我们可以推导出：</p><ul>\n<li>不要使用全局状态；</li>\n<li>不要使用 Singleton 模式。</li>\n</ul><p>在实际工作中，除了要编写业务代码，还会遇到第三方集成的情况：</p><ul>\n<li>对于调用程序库的情况，我们可以定义接口，然后给出调用第三方程序库的实现，以此实现代码隔离；</li>\n<li>如果我们的代码由框架调用，那么回调代码只做薄薄的一层，负责从框架代码转发到业务代码。</li>\n</ul><p>如果今天的内容你只能记住一件事，那请记住：<strong>编写可测试的代码。</strong></p><h2>思考题</h2><p>今天我们讲了代码中不好测的情况主要是由于软件设计不好造成的。在实际的工作中，你还有遇到过哪些不好测的情况呢？欢迎在留言区分享你的经验。</p>',
        article_title: "06 | 测试不好做，为什么会和设计有关系？",
      },
      {
        title: "07 | Mock 框架：怎么让测试变得可控？",
        id: 408762,
        content:
          '<p>你好，我是郑晔！</p><p>上一讲，我们谈到测试不好测，关键是软件设计问题。一个好的设计可以把很多实现细节从业务代码中隔离出去。</p><p>之所以要隔离出去，一个重要的原因就是这些实现细节不那么可控。比如，如果我们依赖了数据库，就需要保证这个数据库环境同时只有一个测试在用。理论上这样不是不可能，但成本会非常高。再比如，如果依赖了第三方服务，那么我们就没法控制它给我们返回预期的值。这样一来，很多出错的场景，我们可能都没法测试。</p><p>所以，在测试里，我们不能依赖于这些好不容易隔离出去的细节。否则，测试就会变得不稳定，这也是很多团队测试难做的重要原因。不依赖于这些细节，那我们的测试总需要有一个实现出现在所需组件的位置上吧？或许你已经想到答案了，没错，这就是我们这一讲要讲的 Mock 框架。</p><h2>从模式到框架</h2><p><strong>做测试，本质上就是在一个可控的环境下对被测系统/组件进行各种试探。</strong>拥有大量依赖于第三方代码，最大的问题就是不可控。</p><p>怎么把不可控变成可控？第一步自然是隔离，第二步就是用一个可控的组件代替不可控的组件。换言之，用一个假的组件代替真的组件。</p><p>这种用假组件代替真组件的做法，在测试中屡见不鲜，几乎成了标准的做法。但是，因为各种做法又有细微的差别，所以，如果你去了解这个具体做法会看到很多不同的名词，比如：Stub、Dummy、Fake、Spy、Mock 等等。实话说，你今天问我这些名词的差异，我也需要去查找相关的资料，不能给出一个立即的答复。它们之间确实存在差异，但差异几乎到了可以忽略不计的份上。</p><!-- [[[read_end]]] --><p>Gerard Meszaros 写过一本《<a href="https://book.douban.com/subject/1859393/">xUnit Test Patterns</a>》，他给这些名词起了一个统一的名字，形成了一个新的模式：<a href="https://martinfowler.com/bliki/TestDouble.html">Test Double（测试替身）</a>。其基本结构如下图所示。</p><p><img src="https://static001.geekbang.org/resource/image/0a/29/0a9ac08ddf1de69e90d917c36fe37929.jpg?wh=1188x721" alt=""></p><p>在这个图里，SUT 指的是被测系统（System Under Test），Test Double 就是与 SUT 进行交互的一个组件。有了我们之前的讲解，这个图应该不难看懂。</p><p>然而，这个名字也没有在业界得到足够广泛的传播，你更熟悉的说法应该是 Mock 对象。因为后来在这个模式广泛流行起来之前，Mock 框架先流行了起来。</p><h2>Mock 框架</h2><p>Mock 框架的基本逻辑很简单，创建一个模拟对象并设置它的行为，主要就是用什么样的参数调用时，给出怎样的反馈。虽然 Mock 框架本身的逻辑很简单，但前期也经过了很长一段时间的发展，什么东西可以 Mock  以及怎样去表现 Mock，不同的 Mock 框架给出了不同的答案。</p><p>今天我们的讨论就以 Mockito 这个框架作为我们讨论的基础，这也是目前 Java 社区最常用的 Mock 框架。</p><p>要学习 Mock 框架，必须要掌握它最核心的两个点：<strong>设置模拟对象</strong>与<strong>校验对象行为</strong>。</p><h3>设置 Mock 对象</h3><p>要设置一个模拟对象，首先要创建一个模拟对象。在实战中，我们已经见识过了。</p><pre><code>TodoItemRepository repository = mock(TodoItemRepository.class);\n</code></pre><p>接下来就是设置它的行为，下面是从实战中摘取的两个例子。</p><pre><code>when(repository.findAll()).thenReturn(of(new TodoItem(&quot;foo&quot;)));\nwhen(repository.save(any())).then(returnsFirstArg());\n</code></pre><p>一个好程序库其 API 要有很强的表达性，像前面这两段代码，即便我不解释，看语句本身也知道它做了些什么。</p><p><strong>模拟对象的设置核心就是两点：参数是什么样的以及对应的处理是什么样的。</strong></p><p>参数设置其实是一个参数匹配的过程，核心要回答的问题就是判断给出的实参是否满足这里设置的条件。像上面代码中，save 的写法表示任意参数都可以，我们也可以设置它是特定的值，比如像下面这样。</p><pre><code>when(repository.findByIndex(1)).thenReturn(new TodoItem(&quot;foo&quot;));\n</code></pre><p>其实它也是一个参数匹配的过程，只不过这里做了些省略，完整的写法应该是下面这样。</p><pre><code>when(repository.findByIndex(eq(1))).thenReturn(new TodoItem(&quot;foo&quot;));\n</code></pre><p>如果你有更复杂的参数匹配过程，甚至可以自己去实现一个匹配过程。但我强烈建议你不要这么做，因为测试应该是简单的。一般来说，<strong>相等和任意参数这两种用法在大多数情况下已经够用了。</strong></p><p>设置完参数，接下来，就是对应的处理。能够设置相应的处理，这是体现模拟对象可控的关键。前面的例子我们看到了如何设置相应的返回值，我们也可以抛出异常，模拟异常场景。</p><pre><code>when(repository.save(any())).thenThrow(IllegalArgumentException.class);\n</code></pre><p>同设置参数类似，相应的处理也可以写得很复杂，但我同样建议你不要这么做，原因也是一样的，测试要简单。<strong>知道怎样设置返回值，怎样抛出异常，已经足够大多数情况下使用了。</strong></p><h3>校验对象行为</h3><p>模拟对象的另外一个重要行为是校验对象行为，就是知道一个方法有没有按照预期的方式调用。比如，我们可以预期 save 函数在执行过程中得到了调用。</p><pre><code>verify(repository).save(any());\n</code></pre><p>这只是校验了 save 方法得到了调用，我们还可以校验这个方法调用了多少次。</p><pre><code>verify(repository, atLeast(3)).save(any());\n</code></pre><p>同样，校验也有很多可以设置的参数，但我同样不建议你把它用得太复杂了，<strong>就连verify 本身我都建议你不要用得太多</strong>。</p><p>verify 用起来会给人一种安全感，所以，会让人有一种多用的倾向，但这是一种错觉。我在讲测试框架时说过，verify 其实是一种断言。断言意味着这是一个函数应该具备的行为，是一种行为上的约定。</p><p>一旦设置了 verify，实际上也就约束了函数的实现。但 verify 约束的对象又是底层的组件，是一种实现细节。换言之，过度使用 verify 造成的结果就是把一个函数的实现细节约定死了。</p><p>过度使用 verify，在写代码的时候，你会有一种成就感。但是，一旦涉及代码修改，整个人就不好了。因为实现细节被 verify 锁定死，一旦修改代码，这些 verify 就很容易造成测试无法通过。</p><p><strong>测试应该测试的是接口行为，而不是内部实现</strong>。所以，verify 虽好，还是建议少用。如果有一些场景不用 verify 就没有什么可断言的了，那该用 verify 还是要用。</p><p>如果按照测试模式来说，设置 Mock 对象的行为应该算是 Stub，而校验对象行为的做法，才是 Mock。<strong>如果按照模式的说法，我们应该常用 Stub，少用 Mock。</strong></p><h2>Mock 框架的延伸</h2><p>Mock 框架的主要作用是模拟对象的行为，但作为一种软件设计思想，它却有着更大的影响。既然我们可以模拟对象行为，那本质上来说，我们也可以模拟其它东西。所以，后面也有一些基于这种模拟思想的框架，其中，目前行业中使用最为广泛的是模拟服务器。</p><p>模拟服务器顾名思义，它模拟的是服务器行为，现在在行业中广泛使用的模拟服务器主要是 HTTP 模拟服务器。HTTP 服务器的主要行为就是收到一个请求之后，给出一个应答，从行为上说，这与对象接受一系列参数，给出相应的处理如出一辙。</p><p>接下来我就以 Moco 为例，简单介绍一下模拟服务器。<a href="https://github.com/dreamhead/moco">Moco</a> 是我自己编写的一个开源模拟服务器程序库，曾在 2013 年获得 Oracle 的 Duke 选择奖。（在《软件设计之美》中讲到程序库的设计时，我讲过 <a href="https://time.geekbang.org/column/article/267856">Moco 整个设计的来龙去脉</a>。如果你有兴趣，可以去回顾一下。）</p><p>下面是一个使用了 Moco 的测试代码。</p><pre><code>public void should_return_expected_response() {\n  // 设置模拟服务器的信息\n  // 设置服务器访问的端口\n  HttpServer server = httpServer(12306);\n  // 访问/foo 这个 URI 时，返回 bar\n  server.request(by(uri(&quot;/foo&quot;))).response(&quot;bar&quot;); \n  \n  // 开始执行测试\n  running(server, () -&gt; {\n    // 这里用了 Apache HTTP库访问模拟服务器，实际上，可以使用你的真实项目\n    Content content = Request.Get(&quot;http://localhost:12306/foo&quot;)\n      .execute()\n      .returnContent();\n      \n    // 对结果进行断言\n    assertThat(content.asString(), is(&quot;bar&quot;));\n  });\n}\n</code></pre><p>在这段代码里，我们启动了一个 HTTP 服务器，当你访问 /foo 这个 URI 时，它会给你返回一个应答 bar。这其中最关键的一行代码就是设置请求应答的那行。</p><pre><code>server.request(by(uri(&quot;/foo&quot;))).response(&quot;bar&quot;); \n</code></pre><p>Moco 的 API 本身也有很强的表达性，通过代码本身你就能看到，这里就是设置了一个请求以及相应的应答。</p><p>Moco 的配置支持很多的 HTTP 元素，像下面这段代码，你可以同时匹配请求内容和 URI，也可以同时设置应答文本和 HTTP 的状态码。</p><pre><code>server\n  .request(and(by(&quot;foo&quot;), by(uri(&quot;/foo&quot;))))\n  .response(and(with(text(&quot;bar&quot;)), status(200)));\n</code></pre><p>在上面的例子里面，running 是负责模拟服务器启停的代码，里面包含的代码就是，通过自己真实的服务代码发出的真实请求。</p><p>Moco 还支持 verify，如果你想像 Mock 框架那样去校验服务器是否收到了相应的请求，就可以使用它。</p><pre><code>RequestHit hit = requestHit();\nfinal HttpServer server = httpServer(port(), hit);\nrunning(server, () -&gt; {\n  ...\n})\n\nhit.verify(by(uri(&quot;/foo&quot;)), times(1));\n</code></pre><p>虽然 Moco 支持这样的能力，但同使用 Mock 框架类似，我也建议你少用 verify。</p><p>Moco 最大的价值就是让原本不可控的第三方 HTTP 服务器，现在可以按照我们预期的方式执行。比如，在真实的集成过程，你很难要求第三方服务器给你一个错误的应答，或者一个超时的应答，但使用 Moco 你就可以让它模拟出这样的行为。</p><p>Moco 还有一个很大的价值，原本你要做集成，唯一的选项是把整个系统跑起来，基本上就到了系统集成的范畴。而现在使用 Moco，验证工作可以用集成测试的代码就可以完成。作为程序员我们很清楚，相比于系统测试，这种做法轻太多了，一旦出现问题，定位起来也容易很多。从开发效率上看，这简直是数量级的提升。</p><p>Moco 不仅仅支持模拟 HTTP 服务器，还做了进一步延伸，支持模拟 WebSocket 服务器。</p><pre><code>HttpServer server = httpServer(12306);\nwebSocketServer = server.websocket(&quot;/ws&quot;);\nwebSocketServer.request(by(&quot;foo&quot;)).response(&quot;bar&quot;);\n</code></pre><p>无论是模拟 HTTP 服务器，还是模拟 WebSocket 服务器，本质上来说，它都是模拟对象这一思想的延伸。而所有这一切的出发点都是，我们希望在测试中得到一个可控的环境。</p><h2>总结时刻</h2><p>今天我们主要讲了 Mock 框架。Mock 框架是源自 Test Double（测试替身）这种测试模式。我们希望自己有一个可控的环境对被测系统/组件进行测试，背后的思想就是用假的却可控的组件去代替真实不可控的组件。</p><p>现在 Mock 框架已经成为了测试的重要组成部分，理解一个Mock框架核心就是要理解如何设置对象行为以及如何校验对象行为。设置对象行为主要是设置相应的参数以及对应的处理，无论这个处理是给出返回值，还是抛出异常。校验对象行为是一种断言，是看对象是否按照预期方式执行。不过，我给你提了一个醒，verify 虽好，尽量少用。</p><p>最后，我们还以 Moco 为例讲到了 Mock 框架的延伸，也就是模拟服务器。Moco 主要是模拟 HTTP 服务器，其核心就是对什么样的请求，给出什么样的应答。</p><p>如果今天的内容你只能记住一件事，那请记住：<strong>使用 Mock 框架，少用 verify。</strong></p><h2>思考题</h2><p>今天我们讲了 Mock 框架，你在实际工作中用到过 Mock 框架吗？它解决了你怎样的问题，或是你在使用它的过程中遇到怎样的困难，欢迎在留言区分享你的经验。</p>',
        article_title: "07 | Mock 框架：怎么让测试变得可控？",
      },
      {
        title: "08 | 单元测试应该怎么写？",
        id: 409822,
        content:
          '<p>你好，我是郑晔！</p><p>经过前面的介绍，我们已经对测试的基础有了理解，已经会用自动化测试框架来写测试了。对于那些不可控的组件，我们也可以用 Mock 框架将其替换掉，让测试环境变得可控。其实，我们在前面介绍的这些东西都是为了让我们能够更好地编写单元测试。</p><p>单元测试是所有测试类型中最基础的，它的优点是运行速度快，可以尽早地发现问题。只有通过单元测试保证了每个组件的正确性，我们才拥有了构建系统的一块块稳定的基石。</p><p>按道理来说，我们应该尽可能多地编写单元测试，这可以帮助我们提高代码质量以及更准确地定位问题。但在实际的工作中，真正大面积编写单元测试的团队却并不多。前面我们已经提到了一部分原因（比如设计没有做好），也有团队虽然写了单元测试，但单元测试没有很好地起到保护网的作用，反而是在代码调整过程中成了阻碍。</p><p>这一讲，我们就把前面学到的知识串联起来，谈谈如何做好单元测试。</p><h2>单元测试什么时候写</h2><p>你是怎么编写单元测试的呢？很多人的做法是先把所有的功能代码都写完，然后，再针对写好的代码一点一点地补写测试。</p><p>在这种编写测试的做法中，单元测试扮演着非常不受人待见的角色。你的整个功能代码都写完了，再去写测试就成了一件为了应付差事不得不做的事情。更关键的一点是，你编写的这些代码可能是你几天的工作量，你已经很难记得在编写这堆代码时所有的细节了，这个时候补写的测试对提升代码质量的帮助已经不是很大了。</p><!-- [[[read_end]]] --><p>所以，想要写好单元测试，最后补测试的做法总是很糟糕的，仅仅比不写测试好一点。你要想写好单元测试的话，<strong>最好能够将代码和测试一起写</strong>。</p><p>你或许会说，我在功能写完后立即就补测试了，这不就是代码和测试一起写的吗？其中的差异在于，把所有的功能写完的这个粒度实在是太大了。为一个大任务编写测试，是一件难度非常大的事，这也是很多人觉得测试难写的重要因素。要想做好单元测试，关键就是工作的粒度要小。</p><p>如果你学过《10x 程序员工作法》，或许已经听出来了。没错，这里的关键点就是要做好任务分解，而任务分解的关键就是粒度要小。</p><blockquote>\n<p>I’m not a great programmer; I’m just a good programmer with great habits.<br>\n&nbsp;<br>\n我不是一个伟大的程序员，只是一个有着好习惯的优秀程序员。<br>\n&nbsp;<br>\n——  Kent Beck</p>\n</blockquote><p>任务分解是每个程序员都应该拥有的好习惯，即便你<strong>想写好单元测试也要从任务分解开始</strong>。所以，你需要把一个要完成的需求拆分成很多颗粒度很小的任务。粒度要小到可以在很短时间内完成，比如，半个小时就可以写完。只有能够把任务分解成微操作，我们才能够认清有足够的心力思考其中的每个细节。千万不要高估自己对于任务把控的粒度，<strong>一定要把任务分解到非常小，这是能够写好代码，写好测试的前提条件，甚至可以说是最关键的因素</strong>（如何具体分解一个需求，我曾经在《10x 程序员工作法》中专门用了<a href="https://time.geekbang.org/column/article/78542">一讲的篇幅</a>进行介绍，如果你有兴趣不妨去回顾一下）。</p><p>当我们把需求拆分成颗粒度很小的任务时，我们才开始进入到编码的状态。而从这里开始，我们进入到代码和测试一起写的状态。</p><h2>编写单元测试的过程</h2><p>对于一个具体的任务，我们首先要弄清楚的是，怎么样算是完成了。一个完整的需求我们需要知道其验收标准是什么。具体到一个任务，虽然没有业务人员给我们提供验收标准，我们自己也要有一个验收标准，我们要能够去衡量怎么样才算是这个代码写合格了。</p><p>经过我们这一系列关于测试的介绍，你应该已经知道我要说什么了：<strong>一个任务的代码要通过测试才算编码阶段的完成。</strong></p><p>但测试用例从哪来呢？这就需要我们设计了。不同于业务测试的测试用例，我们现在要写的是单元测试。而我们要测的单元现在还没有写，所以，没有人会给我们提供测试用例，单元测试的用例只能我们自己来。</p><p>还记得我们在实战里怎么做的添加 Todo 项吗？接下来，我们就结合这个部分来谈谈具体怎么做。</p><p>我们首先要确定的是待测单元的行为，也就是要实现的类里的一个函数，它的行为是什么样的。或许你已经发现了，这其实就是一个软件设计的过程。这里的设计指的是微观的设计，就是具体的一个函数准备写成什么样子。通常到了动手写代码这一步，大的设计已经在前面做完了。</p><p>因为我们现在不仅仅要写代码，还要写测试。所以，我们在设计这个函数接口时，还必须增加一点考量：它要怎么测。</p><p>在添加一个 Todo 项时，我们经过设计出来的函数接口就是下面这样。</p><pre><code>TodoItem addTodoItem(final TodoParameter todoParameter);\n</code></pre><p>有了一个具体的函数接口设计，我们就可以针对它进行更具体的测试用例设计，也就是设计测试用例来描述这个接口的行为。</p><p>是的，这里我们并没有着急写代码。对很多人来说，写代码的优先级很高，但是，如果不在这里停一下的话，你可能就不会去思考是否还有要考虑的问题，而是直奔代码细节去了。而当我们专注于细节时，有限的注意力就会让你忽略掉很多东西。所以，<strong>先设计测试用例，后写代码</strong>，这是一个编码习惯的问题。</p><p>有了添加 Todo 项接口之后，我们就准备了两个测试场景：</p><ul>\n<li>添加正常的参数对象，返回一个创建好的 Todo 项；</li>\n<li>添加空的参数对象，抛出异常。</li>\n</ul><p>有了测试场景，接下来把这些场景实例化出来，这个步骤相对来说就比较简单了。比如，对于添加正常的参数对象来说，那什么样的参数对象是正常的？我们就代入一个具体的正常参数（比如  foo）。有了这个实例化过的参数，我们就可以把具体的测试用例表现出来了。</p><pre><code>@Test\npublic void should_add_todo_item() {\n    TodoItemRepository repository = mock(TodoItemRepository.class);\n    when(repository.save(any())).then(returnsFirstArg());\n    TodoItemService service = new TodoItemService(repository);\n    \n    TodoItem item = service.addTodoItem(new TodoParameter(&quot;foo&quot;));\n    \n    assertThat(item.getContent()).isEqualTo(&quot;foo&quot;);\n}\n</code></pre><p>在实际的工作中，究竟是先写测试，还是先写实现代码，这是个人工作习惯的问题。当我们有了测试用例之后，其实就是把一个具体的任务进一步拆分成更小的子任务了。<strong>只要我们完成一个子任务，我们就可以做一次代码的提交，因为我们这个时候，既有测试代码又有实现代码，而且实现代码是通过了测试的。</strong></p><h2>测接口还是测实现？</h2><p>不知道你是否注意到了，在前面我一直在说，我们要测的是函数接口的行为。我一直说，单元测试是一种白盒测试。在一些人的理解中，白盒测试的关注点应该是内部实现。那单元测试到底应该关注接口，还是应该关注实现呢？</p><p>或许你还不清楚二者之间的区别，让我们把前面添加 Todo 项的例子拿过来。如果采用更加面向实现的做法，我们应该对 addTodoItem 这个函数的内部实现有进一步的约束，就像下面这样。</p><pre><code>@Test\npublic void should_add_todo_item() {\n    TodoItemRepository repository = mock(TodoItemRepository.class);\n    when(repository.save(any())).then(returnsFirstArg());\n    TodoItemService service = new TodoItemService(repository);\n    \n    TodoItem item = service.addTodoItem(new TodoParameter(&quot;foo&quot;));\n    \n    assertThat(item.getContent()).isEqualTo(&quot;foo&quot;);\n    verify(repository).save(any());\n}\n</code></pre><p>这段代码中核心的差别就是增加了一句 verify，这也就意味着，我规定在 addTodoItem 的实现中必须要调用 repository 的 save 函数。</p><p>你或许会好奇，repository 本来就要调用 save 方法，那我在这里校验它调用了 save 方法，似乎也没什么大不了的。</p><p>单独这么看确实看不出什么问题，但是，如果你有很多测试都是这么写，当你准备重构时，你就会发现问题了。很多团队代码一调整，测试就失败，一个重要的原因就是代码实现和测试之间紧紧地绑定在了一起。因为测试约束的是实现细节，而只要调整实现细节，测试当然就失败了。这也是很多团队抱怨单元测试问题很多的重要原因。</p><p>所以，<strong>在实际的项目中，我会更倾向于测试接口，尽可能减少对于实现细节的约束。</strong>其实，这个原则不仅仅是在接口层面上，在一些测试的细节上也可以这么约定，比如下面这行代码。</p><pre><code>when(repository.save(any())).then(returnsFirstArg());\n</code></pre><p>这其实是一种宽泛的写法，所以用了 any。如果严格限制的话，应该严格限定一个非常具体的参数。</p><pre><code>when(repository.save(new TodoItem(&quot;foo&quot;))).then(returnsFirstArg());\n</code></pre><p>同样，上一讲我们讲到了 Moco，我们设置模拟服务器可以设置得非常具体，像下面这样。</p><pre><code>server\n  .request(and(by(&quot;foo&quot;), by(uri(&quot;/foo&quot;))))\n  .response(and(with(text(&quot;bar&quot;)), status(200)));\n</code></pre><p>也可以设置得非常宽泛，像这样。</p><pre><code>server.request(by(uri(&quot;/foo&quot;))).response(&quot;bar&quot;); \n</code></pre><p>除非这个测试里面有多个类似的请求，必须要做区分，否则，我倾向于使用宽泛一些的约束。这在某种程度上会降低未来重构代码时带来的影响。</p><p>不过实话说，要想完全消除对于实现细节的依赖，有时候也是很难的。比如在我们前面的 TodoItemService 的例子里面，repository 本身也是 TodoItemService 的一种实现细节，一旦进行一些重构，把 repository 的依赖从 TodoItemService 中拿掉，很多测试代码也需要调整。所以，在实际的项目中，我们只能说尽可能减少对于实现细节的依赖。</p><p>其实，关于实现细节的测试也是一种重复，等于你用测试把代码又重新写了一遍。程序员的工作中有一种重要的原则：DRY（Don’t Repeat Yourself），这不仅仅是说代码中不要有重复，而且各种信息都不要重复（我在《软件设计之美》中讲过 <a href="https://time.geekbang.org/column/article/265128">DRY 原则</a>，有兴趣不妨回顾一下）。</p><p>我建议你在设计单元测试的时候不要面向实现细节。但反过来，有些时候测试确实会漏掉一些细节，尤其是一些实现代码中的分支。怎么样发现自己的代码中是否有遗漏呢？这就是我们下一讲要讲的内容：测试覆盖率。</p><h2>总结时刻</h2><p>今天我们讲了如何去写单元测试。很多团队由于多方面的原因（比如设计做得不好），导致单元测试写得少。但为了提高代码质量以及更准确地定位问题，我们应该多写单元测试。</p><p>单元测试最好是和实现代码一起写，以便减少后续补测试的痛苦。想写好测试，关键要做好任务分解，否则，面对一个巨大的需求，没有人知道如何去给它写单元测试。</p><p>编写单元测试的过程，实际上就是一个任务开发的过程。一个任务代码的完成，不仅仅是写了实现代码，还要通过相应的测试。一般而言，任务开发要先设计相应的接口，确定其行为，然后根据这个接口设计相应的测试用例，最后，把这些用例实例化成一个个具体的单元测试。</p><p>单元测试常见的一个问题是代码一重构，单元测试就崩溃。这很大程度上是由于测试对实现细节的依赖过于紧密。一般来说，单元测试最好是面向接口行为来设计，因为这是一个更宽泛的要求。其实，在测试中的很多细节也可以考虑设置得宽泛一些，比如模拟对象的设置、模拟服务器的设置等等。</p><p>如果今天的内容你只能记住一件事，那请记住：<strong>做好任务分解，写好单元测试。</strong></p><h2>思考题</h2><p>今天我们讨论了如何写好单元测试，你在实际项目中写过单元测试吗？你遇到了哪些问题，或者有哪些经验可以分享呢？欢迎在留言区分享你的观点。</p>',
        article_title: "08 | 单元测试应该怎么写？",
      },
      {
        title: "09 | 测试覆盖率：如何找出没有测试到的代码？",
        id: 410429,
        content:
          '<p>你好，我是郑晔！</p><p>经过前面内容的介绍，相信你现在已经知道如何去编写单元测试了。上一讲，我们说编写单元测试应该面向接口行为来编写，不过这样一来，就存在一种可能：我预期的行为都对了，但是因为我在实现里写了一些预期行为之外的东西（比如有一些分支判断），在代码实际执行的时候，可能就会出现预期之外的行为。</p><p>如何尽可能消除预期之外的行为，让代码尽在掌控之中呢？这一讲，我们就来讲讲如何查缺补漏，找到那些测试没有覆盖到的代码。我们要来讨论一下测试覆盖率。</p><h2>测试覆盖率</h2><p>测试覆盖率是一种度量指标，指的是在运行一个测试集合时，代码被执行的比例。它的一个主要作用就是告诉我们有多少代码测试到了。其实更严格地说，测试覆盖率应该叫代码覆盖率，只不过大多数情况它都是被用在测试的场景下，所以在很多人的讨论中，并不进行严格的区分。</p><p>既然测试覆盖率是度量指标，我们就需要知道有哪些具体的指标，常见的测试覆盖率指标有下面这几种：</p><ul>\n<li>函数覆盖率（Function coverage）：代码中定义的函数有多少得到了调用；</li>\n<li>语句覆盖率（Statement coverage）：代码中有多少语句得到了执行；</li>\n<li>分支覆盖率（Branches coverage）：控制结构中的分支有多少得到了执行（比如 if 语句中的条件）；</li>\n<li>条件覆盖率（Condition coverage）：每个布尔表达式的子表达式是否都检查过 true 和 false 的不同情况；</li>\n<li>行覆盖率（Line coverage）：代码中有多少行得到了测试。</li>\n</ul><!-- [[[read_end]]] --><p>以函数覆盖率为例，如果我们在代码中定义了 100 个函数，运行测试之后只执行 80 个，那它的函数覆盖率就是 80/100=0.8，也就是 80%。</p><p>这几个指标基本上看一眼就知道是怎么回事，唯一稍微复杂一点就是条件覆盖率，因为它要测试的是在一个布尔表达式中每个子表达式所有真假值的情况，我们来看看下面这个代码。</p><pre><code>if ((a || b) &amp;&amp; c) {\n  ...\n}\n</code></pre><p>就是这么一个看上去很简单的情况，因为它牵扯到 a、b、c 三个子表达式，又要把每个子表达式的真假值都要测试到，所以，就需要有 8 种情况。</p><p><img src="https://static001.geekbang.org/resource/image/05/c4/05d61b4eedb1d0fe5d1a04e6e4bf1fc4.jpg?wh=1568x961" alt=""></p><p>在这么一个条件比较简单的情况下，其实条件覆盖率已经是很复杂了。如果条件进一步增多，复杂度会进一步提升，想要在测试里对条件进行全覆盖也不是一件容易的事。这也给了我们一个编码上的提示：<strong>尽可能减少条件。</strong>事实上，在真实的项目中，很多条件都是不必要的复杂，可以通过提前返回将一些复杂的条件做一个拆分。</p><p>其实，测试覆盖率的指标还有一些，不过上面这些已经足够我们在日常工作中使用了。而且，具体能够使用哪个指标，还要看我们使用的工具具体支持哪些指标。</p><h2>JaCoCo：一个 Java 的测试覆盖率工具</h2><p>下面我就以 Jacoco 为例，讲讲如何实际地使用一个测试覆盖率工具。</p><p><a href="https://www.eclemma.org/jacoco/">JaCoCo</a> 是 Java 社区常用的一个测试覆盖率工具，这个名字一看就是 Java Code Coverage 的缩写。开发它的团队原本是开发一个叫 <a href="https://www.eclemma.org/">EclEmma</a> 的 Eclipse 插件，这个插件本身就是用来做测试覆盖率的。只不过，后来团队发现开源社区虽然有不少测试覆盖率的实现，但大多绑定在特定工具上，于是，他们决定启动 JaCoCo 这个项目，把它当做一个不绑定在特定工具上的独立实现，让它成为 JVM 环境中的标准技术。</p><p>我们已经知道了测试覆盖率有好多不同的指标，学习一个具体的测试覆盖率工具，主要就是把指标做一个对应，知道如何设置相应的指标。</p><p>在 JaCoCo 里，指标对应的概念是 counter。我们要在覆盖率中使用哪些指标，也就是要指定哪些不同的 counter。</p><p>每个 counter 提供了不同的配置，比如覆盖的数量（COVEREDCOUNT），没有覆盖的数量（MISSEDCOUNT）等等，但我们最关心的只有一件事：覆盖率（COVEREDRATIO）。</p><p>有了 counter，选定了配置，接下来，要确定的就是取值的范围，也就是最大值（maximum）和最小值（minimum）是多少。比如，我们这里关注的就是覆盖率的值应该是多少，一般就是配置它的最小值（minimum）是多少。</p><p>覆盖率是一个比例，所以，它的取值范围就是从 0 到 1。我们可以根据自己项目的需要来进行配置。根据上面的介绍，如果我们要求行覆盖率达到 80%，我们就可以这样配置。</p><pre><code>counter: &quot;LINE&quot;, value: &quot;COVEREDRATIO&quot;, minimum: &quot;0.8&quot;\n</code></pre><p>好，你现在已经有了对于 JaCoCo 的基本了解。但通常在项目中，我们很少会直接使用它，而是会把它与我们项目的自动化过程结合起来。</p><h2>在项目中使用测试覆盖率</h2><p>其实，我们在前面的实战中每次执行提交之前的检查命令时，都会运行到 JaCoCo。只不过在大多数情况下，只要测试写得好，这项检查很容易就通过了。不过，在<a href="https://time.geekbang.org/column/article/404301">第二讲</a>当我们处理到 Jackson 时，我们被测试覆盖率挡住了，当时是发现了异常处理的问题。</p><p>这就是自动化检查的价值。一般情况下，只要你工作做得好，它就默默地在下面工作，并不会影响到你，而一旦你因为一些疏忽忘记了一些事情，它就会跳出来提醒你。</p><p>无论是 <a href="https://www.jacoco.org/jacoco/trunk/doc/ant.html">Ant</a>，还是 <a href="https://www.jacoco.org/jacoco/trunk/doc/maven.html">Maven</a>，抑或是 <a href="https://docs.gradle.org/current/userguide/jacoco_plugin.html">Gradle</a>，Java 社区主流的自动化工具都提供了对于 JaCoCo 的支持，我们可以根据自己选用的工具进行配置。大部分情况下，配置一次，全团队的人就都可以使用了。</p><p>这里面的关键点在于，把测试覆盖率与提交过程联系起来。我们在实战中，提交之前要运行检查过程，测试覆盖率检查就在这个过程里。这样，就保证了它不是一个独立的存在，不仅在我们开发过程中起作用，更进一步，在持续集成的过程中也能够起到作用。</p><p>在日常开发中，真正与我们经常打交道的是测试覆盖率不通过的时候，比如，在我们的实战中，运行脚本对代码进行检查时，如果测试覆盖率不够，我们就会得到下面这样的提示。</p><pre><code>Rule violated for package com.github.dreamhead.todo.cli.file: lines covered ratio is 0.9, but expected minimum is 1.0\n</code></pre><p>这里会有哪些报错，取决于我们配置了多少个 counter。按照我通常的习惯，我会把所有的 counter 都配置上去，这样就可以发现更多的问题了。</p><p>不过，这个提示只是告诉我们测试覆盖率不够，但具体哪不够，我们还需要查看测试覆盖率的报告。一般来说，测试覆盖率的报告是我们在与工具集成的时候配置好的。JaCoCo 可以提供好多种报告类型：XML、CSV、HTML 等等。按照一般使用习惯来说，我会优选使用 HTML 的报告，这样就可以直接用浏览器打开看了。如果你有工具需要其它格式的报告，也可以配置不同的格式。</p><p>生成报告的位置也是可以配置的，我在实战项目中，把它配置在 $buildDir/reports/jacoco 这个目录下，这里的 $buildDir 指的是每个模块构建生成物的目录，一般来说，就是 build 目录。所以，每次当我看到因为测试覆盖率造成构建失败，就要就可以打开这个目录下的 index.html 文件，它会给你所有这个模块测试覆盖情况的总览。</p><p><img src="https://static001.geekbang.org/resource/image/95/66/9528510c53e924e554e33f4b446a4866.png?wh=2178x194" alt=""></p><p>在实战项目中，我们配置的覆盖率要求是 100%，所以，我们很容易就发现没有覆盖到的地方在哪里，就是那个有红色的地方。然后我们可以一路追踪进去，找到具体类，再找到具体的方法，最终定位到具体的语句，下面就是我们在实战中定位到的问题。</p><p><img src="https://static001.geekbang.org/resource/image/c6/15/c6a1f28da836f806e3007b1a18416615.png?wh=1644x402" alt=""></p><p>找到了具体的测试覆盖不足的地方，接下来，就是想办法提高测试率。一般来说，在简单的情况里通过增加或调整几个测试，就可以把这些场景覆盖到。但也有一些不是那么容易覆盖的，比如在实战中，我们看到 Jackson API 中抛出的 IOException。</p><p>不过，具体如何解决这个问题，对不同的同学来说，会有各自的解决方案。这个地方真正容易引起争议的地方是为什么测试覆盖率要设置成 100%。</p><p>在真实的项目中，很多不愿意写测试的人巴不得这个数字越低越好，但实际上我们也很清楚，这个数字设置得很低就没有任何意义了。</p><p>先不说一个既有的项目应该设成多少，如果是一个全新的项目，测试覆盖率应该设成多少呢？我在这里已经给出了我的答案是：100%。这不是我为了这个实战故意设置的值，而是我在真实的项目中就是这样要求的。估计有人看到这个数字已经有一种快要疯了的感觉，在真实的项目中，设置成 100%怎么可能达到吗？</p><p>预告一下，这就是下一讲的主题，我们来讨论为什么100%的测试覆盖率是可能的。</p><h2>总结时刻</h2><p>这一讲我们讲了测试覆盖率。测试覆盖率是帮我们发现在测试中没有覆盖到的代码，也就是帮助我们在测试之外查缺补漏。</p><p>测试覆盖率实际上是一组不同指标的组合，所谓覆盖率就是运行一组测试，执行到的元素和总的元素比例。大部分指标都比较好理解，只是条件覆盖率要求比较高，与其通过测试覆盖那么多的条件，不如把代码本身写简单，降低测试的难度。</p><p>我以 JaCoCo 为例，给你介绍了一个测试覆盖率工具，其中的 counter 对应着测试覆盖率的指标。在实际的项目中使用测试覆盖率工具，关键是要把它与自动化的过程结合起来，让它不是独立的存在。每次提交，每次 CI 过程都要进行测试覆盖率的检查。</p><p>最后我们还讲到了如何通过测试覆盖率的报告找到未覆盖的代码，定位到问题之后，补齐测试对于大多数程序员来说还是相对容易的。</p><p>如果今天的内容你只能记住一件事，那请记住：<strong>将测试覆盖率的检查加入到自动化过程之中。</strong></p><h2>思考题</h2><p>今天我们讲到了测试覆盖率，你的项目中用到了测试覆盖率吗？你对于测试覆盖率是怎样要求的呢？欢迎在留言区分享你的经验。</p>',
        article_title: "09 | 测试覆盖率：如何找出没有测试到的代码？",
      },
      {
        title: "10 | 为什么 100% 的测试覆盖率是可以做到的？",
        id: 411207,
        content:
          '<p>你好，我是郑晔！</p><p>上一讲我们谈到了测试覆盖率，讲了如何在实际的项目中利用测试覆盖率发现没有覆盖到的代码。最后，我们留下了一个问题：测试覆盖率应该设置成多少？我给出的答案是 100%，但这显然是一个令很多人崩溃的答案。别急，这一讲我们就来说说怎样向着 100%的测试覆盖率迈进。</p><p>很多人对测试覆盖率的反对几乎是本能的，核心原因就是测试覆盖率是一个数字。我在《10x 程序员工作法》中曾经说过，<a href="https://time.geekbang.org/column/article/76929">要尽可能地把自己的工作数字化</a>。本来这是一件好事，但是，很多管理者就会倾向于把它变成一个 KPI（Key Performance Indicator，关键绩效指标）。KPI 常常是上下级博弈的地方，上级希望高一点，下级希望低一点。所以，从本质上说，很多人对测试覆盖率的反对，首先是源于对 KPI 本能的恐惧。</p><p>抛开这种本能的恐惧，我们先来分析一下，如果我们想得到更高质量的代码，测试肯定是越多越好。那多到什么程度算最多呢？答案肯定是 100%。如果把测试覆盖率设置成 100%，就没有那么多扯皮的地方了。比如，你设成了 80%，肯定有人问为啥不设置成 85%；当你设置成 85%的时候，就会有人问为啥不是 90%，而且他们的理由肯定是一样的：测试覆盖率越高越好。那我设置成 100%，肯定不会有人再问为啥不设置成更高的。</p><!-- [[[read_end]]] --><p>现在你知道了，我们把覆盖率设置成 100% 这应该是极限的标准了。接下来，要回答的一个问题就是，怎么把覆盖率做成 100%。</p><h2>向 100% 迈进</h2><p>首先，我们需要明确的一点是，我们用测试覆盖的代码主要是我们自己编写的代码。为什么要强调这一点呢？因为很多时候，我们会涉及使用第三方程序库，而第三方程序库的功能不应该由我们来验证。比如  Jackson 将对象转换为 JSON 是否转得正确，其实我们是不关心的，这是 Jackson 这个程序库要来保证的。</p><p>之所以要先强调这一点，因为在很多人编写的代码中，自己编写的业务代码和第三方程序库的代码常常是混杂在一起的。我们工作的重点是，<strong>保证自己编写的代码 100% 测试覆盖。</strong>这意味着什么呢？</p><p><strong>首先，让自己可控的代码有完全的测试保证，其次，如果有第三方的代码影响到测试覆盖，我们应该把第三方的代码和我们的代码隔离开。</strong></p><p>我知道，很多人已经准备强调 100%的测试覆盖是如何困难了。其实，不知道你有没有注意，我们在实战环节中，已经完成了一次 100%的测试覆盖。你可以去看看实战环节的构建脚本，其中用到的测试覆盖率工具就是 JaCoCo，而覆盖率的要求就是 100%，也就是 1.0。问题是我们是怎么做到的呢？</p><p>我们不妨一起回想一下，在做好了整体的设计之后，我们每实现一个具体的功能，都考虑了测试的场景，测试用例和代码是同步在实现。最后通过测试覆盖率检查，找出没有覆盖到的代码。对于一些不方便测试的第三方程序库代码，我们进行了隔离，而且要求隔离是非常薄的一层。这样，就保证了我们所有编写业务代码都能够很好地得到测试覆盖。</p><p>说起来并不复杂，但你或许会说，这是因为我们只实现了基本的功能，代码复杂度比较低，如果是实现了更为复杂的功能，是不是就没办法覆盖了呢？</p><p>我们在前面的内容中说过，要想写好测试，一个关键点是要有良好的软件设计，而且代码本身要尽可能地消除坏味道。到这里你就清楚了，<strong>其实程序员写测试不单单是写测试，同时，也是在发现自己代码中的不足，无论是设计上，还是代码本身。</strong></p><p>所以说，即便是再复杂的功能，通过软件设计和良好的编码，也可以落实到一个一个小代码块上。这里的重点是小，代码能否写短小，这是一个程序员编码基本功的问题。</p><p>你让我给一个长达几百上千的代码去写测试，我也很难做到 100%覆盖，因为代码写得太复杂了，我们理解起来很吃力，为它写测试当然也很吃力。所以，我们会把讨论先集中在一个新项目该如何写测试上。如果一个程序员不能够在干干净净的代码库上写好代码，你就很难指望他在面对一个遗留代码库时能够写好代码。</p><p>不知道你注意到了没有，我们说在实战中达成 100%测试覆盖时，还有一个工作习惯，就是测试和代码同步写。为什么要这么做呢？因为没有人愿意补测试，无论这个代码是你写的还是别人写的。</p><p>这也就是为什么要把测试放在自动化过程中，这样，我们每完成一个任务，就要确保编写了相应的测试。而且，我前面也强调过，任务的关键是小，比如，小到半个小时就可以提交一次，这样，你写测试的负担相对来说是小的。小事相比大事更容易坚持，这是符合人性的做法。</p><p>你现在已经知道了，一个新项目想要达到 100%的测试覆盖，<strong>首先，要有可测试的设计，要能够编写整洁的代码；其次，测试和代码同步写。</strong></p><h2>测不到的代码</h2><p>关于 100%测试覆盖率，很多人有一个误区：100%覆盖了，是不是就意味着代码没问题了？答案是否定的。即便我们有了 100%的测试覆盖，还是会有你想不到的场景出现。100%的覆盖只是保证我们已经写的代码没有场景遗漏，不会有异常场景没有处理，不会有分支条件没有考虑到，仅此而已。</p><p>100%的测试覆盖只是程序员做好了本职工作，保证了在这个环节内没有出错。而软件整体质量是一个系统性的工程，首先要保证我们尽可能多地考虑到了各种测试场景，这是我们在<a href="https://time.geekbang.org/column/article/405774">第 3 讲</a>中讨论的内容。</p><p>对程序员来说，通过把测试覆盖率设置 100%，我们就有了一个查缺补漏的机会。一旦发现有些缺漏很难补上怎么办？就像我们在实战环节中见到的那样，模拟 Jackson 的异常成本过高，我们就会采用隔离的方式，将不好测试的地方隔离开来，形成一个封装层。实际上，我们是在用软件设计的方式在解决问题。</p><p>理解了达成 100%测试覆盖的基础之后，我还必须再强调一下。第一点是前面提到的封装层，这一层一定要非常薄。很多情况下，可能就是直接的方法调用。如果有复杂的逻辑，比如在防腐层代码中有对象之间的转换，我们都可以把转换的逻辑拿出来，单独地去写测试，因为这个转换逻辑多半是可以测试的。100%的测试覆盖率我们不是说说而已，而是要坚持做到能覆盖的尽量去覆盖。</p><p>另外还有一点，隔离出来的代码怎么办呢？我们要在测试覆盖的检查中将它们排除，具体的做法就是在构建文件中，把这个文件标记为不需要测试覆盖。</p><pre><code>coverage {\n  excludeClasses = [\n        &quot;com.github.dreamhead.todo.util.Jsons&quot;\n  ]\n}\n</code></pre><p>在我的项目中，我会要求这里只能有那个薄薄的封装层。有些初次接触项目的人，常常会把这里理解成项目中有我不想测的代码，却还要保证 100%测试覆盖，这里就是一种妥协。绝对不是这个意思！所以，一方面，我们要在团队中强调这个纪律，另一方面，我们也要经常性地做代码评审，保证这个用来隔离封装层的地方不会遭到滥用。</p><p>100%虽然要求很高，但要想做到，首先是理念上的认同，然后，我们就可以想各种办法去做到。在实际的项目中，<strong>很多人先从理念去否定，认为不可能做到，只要有一点困难就放弃，这其实才是 100%测试覆盖率难以达成的最主要原因。</strong></p><h2>总结时刻</h2><p>今天我们延续了上一讲测试覆盖率的话题，讨论了在一个新项目中，测试覆盖率应该设置成多少，我给出的答案就是 100%。</p><p>100%的测试覆盖率会遭到很多人的反对，但这种反对首先是对 KPI 行为的一种本能恐惧。在真实项目中，大家都认同的观点是测试覆盖率越高越好，最高的覆盖率肯定是 100%。</p><p>我们强调的 100%测试覆盖，主要指的是对自己编写的代码 100%测试覆盖。这就意味着，我们一方面要保证自己的代码完全可控，另一方面，对于影响到测试覆盖的第三方代码要进行隔离。要想做到100%的测试覆盖，技术上说，要有可测试的设计以及编写整洁的代码，实践上看，要测试和代码同步产出。</p><p>100%的测试覆盖并不是说代码没有问题了，而应该是程序员对自己编写代码的一种质量保证，它是一个帮助我们查缺补漏的过程。</p><p>对于无法测试到第三方代码，要用一个薄薄的隔离层将代码隔离出去，在构建脚本中将隔离层排除在外。有一点需要注意的是，排除脚本千万别被滥用了。</p><p>如果今天的内容你只能记住一件事，那请记住：<strong>100%的测试覆盖率是程序员编写高质量代码的保证。</strong></p><h2>思考题</h2><p>今天我们讲了如何达到 100%的测试覆盖，你在实际工作中遇到过哪些难以测试的情况呢？期待在留言区看到你的想法。</p>',
        article_title: "10 | 为什么 100% 的测试覆盖率是可以做到的？",
      },
      {
        title: "11 | 集成测试：单元测试可以解决所有问题吗？",
        id: 412079,
        content:
          '<p>你好，我是郑晔！</p><p>前面我们花了大量的篇幅在讲单元测试。单元测试是所有测试类型中，运行速度最快，整体覆盖面可以达到最大的测试。因为单元测试的存在，我们甚至可以把测试覆盖率拉高到 100%。测试覆盖率都已经 100%了，是不是我们用单元测试就可以解决所有的问题了？</p><p>正如我们在上一讲强调的那样，100%的测试覆盖率并不代表代码没有问题。同样，即便是 100% 的单元测试也不能解决所有的问题。有一个重要的原因在于，我们在编写每个单元时都会假设这些单元彼此之间能够很好地协同，但这个假设是不是一定成立呢？答案是不一定。</p><p>让一个个单元正常运行，我们靠的不是美好的预期，而是单元测试。同样，各个单元能够很好地协同，我们也不能靠预期，而是要靠集成测试。这一讲，我们就来讨论一下集成测试。</p><h2>代码的集成</h2><p>在具体讨论集成测试之前，我们澄清一下概念。集成测试到底测的是什么？答案很显然是集成。问题是，集成要集成什么呢？一种是代码之间的集成，一种是代码与外部组件的集成。说白了，集成测试就是把不同的组件组合到一起，看看它们是不是能够很好地配合到一起。</p><p>我们先来看代码的集成。代码之间的集成，主要看我们编写的各个单元能否很好地彼此协作。既然集成测试是为了测试单元之间的配合，那是不是只要有单元之间的协作，我们就要为它们编写一个集成测试呢？比如按照常规的架构分层，一个 REST 服务会有一个 Resource（或者叫 Controller），一个 Service，一个 Repository，那是不是要 Service 和 Repository 的集成要写一个集成测试，Resource 和 Service 的集成测一次，Resource、Service 和 Repository 的集成再测一次呢？</p><!-- [[[read_end]]] --><p>如果我们按照前面讨论的方式来编写了单元测试，其实，这就意味着我们每个组件都已经经过了测试。所以，集成测试的重点就不再是组件之间两两协同进行测试了。一般来说，在实践中，我们可以选择的测试方式是，<strong>选择一条任务执行的路径，把路径上用到的组件集成到一起进行测试。</strong>比如在前面提到的那种情况中，我们只要把 Resource、Service 和 Repository 都组装到一起就可以了。</p><p>如果所有的代码都是我们自己编写，那么我们就编写一个个的单元，然后组装到一起进行测试，这个很好理解。但是，现在很多人都在使用框架，比如我们在实战中处理命令行时使用了 Picocli 这个框架，所有的命令解析的过程都是由这个框架完成；再比如，很多人在开发后端服务时，使用了 Spring Boot，一些路由匹配，甚至参数检查都是由框架完成的。那么我们在集成测试中，要不要把这个部分集成进来呢？</p><p>我对此的答案是，<strong>取决于你是否能够把这个框架集成进来，如果能，最好是做一个完整的集成测试。</strong>在实战中，我们已经展示过如何去集成 Picocli，因为这个框架本身比较简单，很容易找到这个框架的外部入口，我们就把它集成起来，做了一个完整的测试。</p><p>有的框架可能就没有那么简单了，就像当年 Java EE 盛行时，我们编写的代码需要部署到一个 Java EE 的容器里面才能运行。在这种情况下，如果强行把 Java EE 容器也加到集成测试里，对于大多数人来说，这是非常有难度的一件事情。换言之，像这种有单独运行时的框架，做整体的集成难度很大，我们只能退而求其次，做大部分的代码集成。</p><p>现在的很多框架替我们做了很多的事情，有些甚至是业务验收标准上的事情，比如，Spring Boot 会替我们做参数检查，利用好 Spring Boot 给我们提供的机制，我们甚至不用写什么代码，只要给字段加上一些 Annotation 就够了。这些 Annotation 加的是否正确，我们其实是需要验证的，因为它是业务验收标准的一部分。</p><p>所以我希望尽可能地去集成，如果我们能够把整个框架集成起来，这些东西也就可以验证了。从代码上来看，这种测试只是针对一个单元在测试，在某种程度上说，这种集成测试其实是一种单元测试，只不过，它必须把系统集成起来才行，所以，它兼具单元测试和集成测试的特点。</p><p>小小预告一下，Spring Boot 在测试上的支持是真的很不错，让我们可以很容易地在测试里对框架处理过程进行集成，在后面的课程里你会看到如何使用 Spring Boot 提供的测试基础设施进行测试。</p><p>你也看到了，我们希望尽可能地把框架集成进来，但市面上的各种框架层出不穷，不是所有的框架都提供了对测试很好地支持。所以，<strong>一个框架设计得好坏与否，对测试的支持程度也是一个很重要的衡量标准，这能很好地体现出框架设计者的品味。</strong></p><p>能够方便测试的框架，通常来说都是很轻量级的，这样的框架对开发非常友好，我们能够在一个普通的 IDE 里很方便地进行调试，对于定位问题也是极其友好的。而各种有运行时需要部署的框架，相对来说，就是重量级的框架，对于开发非常不友好。如果你用过一些 IDE 支持的远程调试功能，你会发现这些功能跟本地调试相比，便捷程度完全不在一个档次上。</p><p>好消息是，我们还是能看到一些框架的进步，即便重如 Java EE 这样的框架，现在也有了嵌入式容器的概念。今天，我们之所以能够很方便地使用 Spring Boot 这样的框架，嵌入式容器给我们提供了非常好的基础。</p><h2>集成外部组件</h2><p>说完了代码的集成，我们再来看看与外部组件的集成。</p><p>在真实世界的开发中，我们经常会遇到与外部组件打交道的情形，最简单是数据要写到数据库里，还有发消息可能会用到消息队列，甚至还可能会涉及与第三方系统的集成。</p><p>理想情况下，我们当然希望把所有相关的组件都集成到一起，但是，一旦牵扯到外部组件，测试的难度立刻就增大了。比如在测试中添加了 Todo 项，如果我的断言写的是先判断数据库里 Todo 项表里有唯一的一条记录，执行之前，你因为其它操作在数据库里插入了数据，这个断言就失败了。即便没有人操作，这个测试执行第一次成功了，再执行一次，可能就失败了，因为第二次执行测试又插入了一条数据。</p><p>所以，<strong>与外部组件集成，难点就在于外部组件的状态如何控制。</strong></p><p>如果能够控制外部组件的状态，在系统里集成它是没有问题的。比如拿数据库集成来说，通常的做法是一方面，我们会建立单独的数据库，保证不与其他部分冲突。比如在 MySQL 里面，我们会建立一个测试用的数据库。</p><pre><code>CREATE DATABASE todo_test;\n</code></pre><p>另一方面，我们要保证它在每个测试之后，都能够恢复到之前的状态。一种做法就是使用数据库的回滚技术，每个测试完成之后就回滚掉，保证数据的干净。后面讲到 Spring Boot 测试的时候，我们会看到具体的做法。</p><p>相对来说，数据库在测试方面的实践已经算是比较成熟了。这也让我们可以去验证 Repository，也就是数据访问层的代码实现。不管使用什么样的框架，写了 SQL 之后，我们都需要验证其正确性。只不过，很多人的选择是把整个系统跑起来，人工去验证 SQL 的正确性，这种做法一方面有些小题大做了，另一方面还是不够自动化。</p><p>有了数据库在测试上的实践，我们就可以用自动化测试的方式进行测试了。其实，从某种意义上说，这也是一种单元测试，因为它的代码只涉及到了一个单元，只不过它需要集成数据库，所以，它还是集成测试</p><p>还有一些外部组件在这方面的支持相对来说，就不那么令人满意了。比如第三方系统。即便是服务做得很完善的第三方系统，也很少有专门为测试提供支持的。</p><p>遇到这种情况，我们就要分析一下，看看有没有什么替代方案。很多第三方系统对外提供服务的方式都是 REST API，对于这种情况，我们就可以用通用的模拟服务器来代替。模拟服务器的价值就在于能够替代这样的第三方服务。</p><p>在这种情况下，我们该怎么做呢？我们需要按照我们的使用场景去访问第三方服务，把整个访问的报文记录下来，作为设置模拟服务器的参考依据。我介绍过的 Moco 甚至提供了代理（proxy）功能，你可以让你的服务去连接 Moco，然后，用 Moco 连接第三方的服务，只要查看 Console 输出，所有的报文就清清楚楚地展现在你面前了。</p><p>如果外部组件没有现成的替代方案怎么办？有两个角度看待这个问题。一个角度是，这也许是一个做新项目的机会，我在《软件设计之美》中讲过 <a href="https://time.geekbang.org/column/article/267856">Moco</a> 的开发过程，其起始点就是一个没有很好解决的问题。</p><p>另一角度，估计是大多数人的选择，那就是既然这里测不了，我可以选择在集成测试里使用模拟对象，而不是真实的对象。在这样的情况下，我们的系统在测试方面其实有一个漏洞没有被测试很好地覆盖。也就是说，我们要把这个漏洞留到更上一层的测试。如果这个漏洞是一个简单的逻辑（比如一个消息队列发消息的接口），这样还好。如果里面有逻辑，我们必须把它作为一个重点的风险提示加以重视。不过，好在这种情况并不是很多，毕竟像 SQL 这种有复杂逻辑的东西，我们已经有了解决方案。</p><h2>总结时刻</h2><p>今天我们讲了集成测试，相对于单元测试只关注单元行为，集成测试关注的多个组件协同工作的表现。今天我们讨论了两类典型的集成问题，一种是代码之间的集成，一种是代码与外部组件的集成。</p><p>对代码之间的集成来说，一方面要考虑我们自己编写的各个单元如何协作；另一方面，在使用各种框架的情况下，要考虑与框架的集成。如果我们有了单元测试，这种集成主要是关心链路的通畅，所以一般来说我们只要沿着一条执行路径，把相关的代码组装到一起进行测试就可以了。</p><p>如果涉及框架，最好是能够把框架集成一起做了，设计得比较好的框架是对于测试的支持比较好的（比如像 Spring Boot），可以让我们很方便地进行测试。</p><p>对于外部组件的集成而言，难点在于如何控制外部组件的状态。数据库在这方面相对已经有比较成熟的解决方案：使用单独的数据库，以及在测试结束之后进行回滚。</p><p>但大部分系统没有这么好的解决方案，尤其是第三方的服务。这时候，我们就要看有没有合适的替代方案。对于大多数 REST API，我们可以采用模拟服务器对服务进行模拟。</p><p>通过今天的讨论你会发现，严格地说，有些代码由于基础设施的问题是不容易在自动化场景覆盖的，这也是我们为什么要强调与框架结合的代码一定要薄，让这种代码的影响尽可能少。这也是在减少用上层测试覆盖的工作量。</p><p>到这里，大部分的场景我们都已经可以用自动化测试进行覆盖了，我们对自己的系统已经有了更完整的理解。其实，测试的种类还有更多，比如系统测试，把整个系统集成起来测试；验收测试，交由业务人员或测试人员进行测试。但这些测试对于很多团队来说，已经到了测试人员的工作范畴了。作为程序员，我们能够把单元测试和集成测试做好，整个软件的质量已经是初步合格了。</p><p>如果今天的内容你只能记住一件事，那请记住：<strong>想办法将不同组件集成起来进行测试。</strong></p><h2>思考题</h2><p>今天我们讲了集成测试，你也看到了集成测试难点就在于如何集成。在实际工作中，你遇到过哪些难以在测试中集成的情况吗？欢迎在留言区分享你的经验。</p>',
        article_title: "11 | 集成测试：单元测试可以解决所有问题吗？",
      },
    ],
  },
  {
    chapterTitle: "应用篇",
    children: [
      {
        title: "12 | 实战：将 ToDo 应用扩展为一个 REST 服务",
        id: 412830,
        content:
          '<p>你好，我是郑晔！</p><p>经过了基础篇的介绍，相信你已经对在日常开发中测试应该做到什么程度有了一个初步的认识。有了基础固然好，但对于很多人来说，面对常见的场景还是不知道如何下手。在接下来的应用篇中，我们就用一些开发中常见的场景，给你具体介绍一下怎么样把我们学到的知识应用起来。</p><p>在后端开发中，最常见的一种情况就是开发一个 REST 服务，将数据写到数据库里面，也就是传说中的 CRUD 操作。这一讲，我们就把前面已经写好的 <a href="https://time.geekbang.org/column/article/404301">ToDo 应用</a>扩展一下，让它变成一个 REST 服务。</p><h2>扩展前的准备</h2><p>具体动手写任何代码之前，我们先要搞清楚我们要把这个应用改造成什么样子。把 ToDo 应用扩展为一个 REST 服务也就是说，原来本地的操作现在要以 REST 服务的方式提供了。另外，在这次改造里面，我们还会把原来基于文件的 Repository 改写成基于数据库的 Repository，这样，就和大多数人在实际的项目中遇到的情况是类似的了。</p><p>有人可能会想，既然是 REST 服务，那是不是要考虑多用户之类的场景。你可以暂时把它理解成一个本地运行的服务（也就是说只有你一个人在使用），所以我们可以不考虑多用户的情况。这样做可以让我们把注意力更多放在测试本身上，而增加更多的能力是需求实现的事情，你可以在后面拿这个项目练手时，做更多的尝试。</p><!-- [[[read_end]]] --><p>确定好了需求目标，接下来，我们就要进入到具体的实现过程里面了。RESTful API 不同于命令行应用，不应该把它的代码同命令行的代码混杂在一起，所以，我们可以建一个单独的模块来放置这些代码，我把这个模块叫 todo-api。至于具体采用的技术栈，我们就使用在 Java 社区最常用的 Spring Boot，Spring Boot 能够极大简化了 REST 服务的开发。</p><p>同之前一样，我们先实现 Repository 的部分，然后再来做接口。或许你会有一个疑问，难道不是要实现业务核心部分吗？别忘了，我们在<strong>之前的实现中特意将业务核心部分隔离了出来，让它不依赖于任何具体的外部实现。</strong>虽然我们是将一个命令行应用改成一个 RESTful API，但业务核心部分并没有发生任何改变，所以，我们也不需要重新编写一份。这就是软件设计的价值所在。</p><h2>数据访问</h2><p>前面说过，我们要把之前基于文件版本的 Repository 实现改成基于数据库的版本，所以我们要先来确定数据访问相关的技术。我选择 MySQL 这个大家最常用的数据库，访问数据库的程序库我选择的是 Spring Data JPA，因为它可以让我尽可能少编写代码。</p><h3>技术选型</h3><p>两种常见的访问数据库的方式分别是 MyBatis 和 JPA。MyBatis 倾向于让人手工编写 SQL 语句，而 JPA 则采用更加面向对象的角度，它访问数据库的 SQL 语句常常是由框架生成的。二者的差异主要是 MyBatis 更加面向具体的实现，而 JPA 则提供了更好的抽象能力。</p><p>目前国内的现状是很多团队会使用 MyBatis，他们给出的理由大多是自己写 SQL 比较好控制，尤其是对一些复杂场景来说更容易优化。不过，实际情况往往是，如果采用 JPA 的话，很多团队对于生成什么样的代码自己完全心里没有数，因为欠缺建模能力才用 MyBatis。而对于很多建模做得比较好的团队来说，使用 JPA  往往开发效率更高。</p><p>Spring Data JPA 在 JPA 上提供了进一步的封装，一些常见的数据访问甚至不需要去编写代码，因为访问数据库的 SQL 都是由框架生成的，是一个标准操作。因为不是我们编写的代码，我们也无需验证它的正确性，只要保证我们自己写的代码正确地表达了我们的意图即可。如果真的有一些比较复杂的 SQL 逻辑要实现，Spring Data JPA 也允许我们自己手写 SQL，这是框架留给我们的优化手段。</p><p>所以，我们这里选择 Spring Data JPA。下面我们就来开始我们的实现之旅。</p><h3>数据库迁移</h3><p>在开始编码测试工作之前，我们要先确定 Todo 项存储的结构。所以，我们要在数据库中创建一个表。</p><pre><code>CREATE TABLE todo_items (\n    `id` int auto_increment,\n    `content` varchar(255) not null,\n    `done` tinyint not null default 0,\n    primary key (`id`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\n</code></pre><p>我们已经在实战中看见过实体的样子了，所以，这里的表结构并不难理解。唯一需要稍微解释一下的就是在表里面我们用了 id，而在 Todo 项的实体中，它对应的是 index。其实，只要你稍微仔细地想一下就不难发现，在我们之前的设计中，index 就是起到了 id 的作用。对应的实体就是下面这样：</p><pre><code>@Entity\n@Table(name = &quot;todo_items&quot;)\npublic class TodoItem {\n  @Id\n  @Column(name = &quot;id&quot;)\n  @GeneratedValue(strategy = GenerationType.IDENTITY)\n  private long index;\n  \n  @Column\n  private String content;\n  \n  @Column\n  private boolean done;\n  ...\n}\n</code></pre><p>在项目自动化中，数据库迁移脚本我们采用了 <a href="https://flywaydb.org/">Flyway</a>，它可以很方便地将数据库的变更管理起来。我们只要在 $rootDir/gradle/config/migration 这个位置创建一个迁移脚本，把上面的 SQL 写进去就好，具体的细节你可以参考我们的开源项目。</p><p>有了迁移脚本，我们就可以执行命令将这个表创建出来。</p><pre><code>./gradlew flywayMigrate\n</code></pre><p>好，基础已经准备好了，我们准备要动手写测试了。</p><h3>编写测试</h3><p>我在上一讲说过，测试数据库相关的内容属于兼具集成测试和单元测试两种属性的测试，一方面，它要对数据库做集成，另一方面，它要测的内容本身属于验证一个单元代码是否编写正确的范畴。对于数据库相关的测试，Spring 提供了很好的支持，让我们可以更好地完成验证工作。</p><p>下面就是一个测试。如果你还记得之前文件版本 Repository 的测试，这个测试你可能会很眼熟。没错，这里的测试我几乎就是原封不动地把前面的测试搬了过来，因为 Repository 接口的行为几乎是一致的。这也是我这里并没有做测试场景分析的原因。</p><pre><code>@ExtendWith(SpringExtension.class)\n@DataJpaTest\n@AutoConfigureTestDatabase(replace = AutoConfigureTestDatabase.Replace.NONE)\n@TestPropertySource(&quot;classpath:test.properties&quot;)\npublic class TodoItemRepositoryTest {\n    @Autowired\n    private TodoItemRepository repository;\n    \n    @Test\n    public void should_find_nothing_for_empty_repository() {\n        final Iterable&lt;TodoItem&gt; items = repository.findAll();\n        assertThat(items).hasSize(0);\n    }\n    ...\n}\n</code></pre><p>看到 @Autowired，如果你熟悉 Spring 应该感到非常亲切，它表示这个字段由框架自动绑定的。那这个自动绑定为什么能起作用呢？这就要拜前面几个 Annotation 所赐了。</p><p>@ExtendWith(SpringExtension.class)，在这里面，@ExtendWith 是 JUnit 5 提供的扩展机制，让第三方有机会编写自己的代码。而 SpringExtension 就是 Spring 提供的扩展，用来做一些 Spring 自己需要的准备和清理之类的工作，比如依赖注入就是通过它完成的。</p><p>@DataJpaTest，表示这个测试采用 Spring Data JPA。有了这个 Annotation，Spring 框架会替我们把 Repository 的实例生成出来。因为使用 Spring Data JPA 的时候，我们只编写了接口。还记得 TodoItemRepository 这个接口吗？现在它变成了下面这个样子。</p><pre><code>public interface TodoItemRepository extends Repository&lt;TodoItem, Long&gt; {\n    TodoItem save(TodoItem item);\n\n    Iterable&lt;TodoItem&gt; findAll();\n}\n</code></pre><p>同之前相比，这里的方法没用任何变化，只是扩展了一个接口 Repository，这是一个标记接口，也就是意味着只有接口，没有方法。实现这个接口是 Spring Data JPA 的要求，它会在运行时为这个接口生成相应的实例，换言之，我们不需要为此编写具体的实现。</p><p>其实，Spring Data JPA的函数名是有一些约定的，在前面给 Repository 的函数命名的时候，我就是参考了 Spring Data JPA 的命名规则，所以，我们在这里可以无缝地与 Spring Data JPA 对接在一起。</p><p>按照 Spring Data JPA 的要求，我们要让 Spring 在启动的时候能够找到我们配置的实体和 Repository。因为我们这里的实体和 Repository 不在缺省的扫描路径上，所以这里需要单独配置一下。下面就是我们的配置，这是一个典型的 Spring Boot 的应用。</p><pre><code>@SpringBootApplication\n@EnableJpaRepositories({&quot;com.github.dreamhead.todo.core&quot;})\n@EntityScan({&quot;com.github.dreamhead.todo.core&quot;})\npublic class Bootstrap {\n  ...\n}\n</code></pre><p>万事俱备，我们现在可以运行测试了，如果一切顺利的话，测试会一次性运行通过。</p><p>这里其实有个实现的细节，测试并没有在数据库留下任何痕迹，正如我们在讲集成测试中说过的那样，这里的测试在运行之后回滚了在测试过程中插入的数据，这是 DataJpaTest 的缺省行为，大大简化了测试的难度。</p><p>你会发现，其实我们并没有写多少有逻辑的代码：表是 SQL 语句生成的，测试是从前面的测试搬过来的，主要的工作都是配置，而数据库访问的过程是框架生成的。减少自己编码的工作量，我们的测试压力也就小了很多。</p><h2>RESTful API</h2><p>有了 Repository，接下来，我们就要来设计实现 API 接口了。对于一个服务而言，对外提供哪些接口是很重要的。任何一个提供后端服务的团队都要仔细地设计其服务接口，确定它应该提供哪些能力，而不仅仅是围绕着前端需求去做。</p><h3>设计 RESTful API</h3><p>还记得我们的 ToDo 应用提供了哪些能力吗？我们回顾一下：</p><ul>\n<li>添加一个 Todo 项；</li>\n<li>完成一个 Todo 项；</li>\n<li>Todo 项列表。</li>\n</ul><p>接下来，我们就把它们设计成 API 接口。所有这三个能力都是围绕着 Todo 项进行的，所以，我们可以把它们设计在一个资源下，不妨就把它的 URI 设计成 /todo-items，一般来说，这里一般会使用复数，表示这有一堆资源。</p><p>有了最基础的资源，接下来，就是一个一个地按照 RESTful API 的方式设计出来。<strong>首先是添加一个 Todo 项。</strong>按照通常 RESTful API 接口的设计方式，相当于在服务端创建了一个新的资源，而创建的语义一般会用 POST 请求表示。创建一个 Todo 项，主要包含的就是 Todo 项的内容，其格式我们就采用 RESTful API 常用的 JSON 格式了。</p><pre><code>POST /todo-items\n\n{\n  &quot;content&quot;: &quot;foo&quot;\n}\n</code></pre><p><strong>有了创建 Todo 项的服务，接下来就是完成一个 Todo 项了。</strong>完成一个 Todo 项，按照 RESTful API 的设计方式，这个动作相当于对已有资源的修改，修改对应的 HTTP 动词是 PUT。不同于 POST，PUT 操作需要指定一个具体的资源，我们这里使用索引作为唯一标识，其对应的内容就是完成字段（done）置为 true。目前来说，我们也不支持其它的处理，所以严格地说，这里的内容其实意义不大。</p><pre><code>PUT /todo-items/{index}\n\n{\n  done: true\n}\n</code></pre><p><strong>最后是一个 Todo 项列表。</strong>列表操作实际上是一种查询，在 RESTful API 设计中，查询对应的 HTTP 动词是 GET。在我们的实战需求中，Todo 项列表还分为查询未完成的 Todo 项和查询所有，从查询的角度来看，就是查询的参数不同。我们这里设置查询参数为 all，缺省情况下  all 的值为 false，如果显示设置了这个值，则按照设置的值进行查询。</p><pre><code>GET /todo-items?all=true\n</code></pre><h3>测试 RESTful API</h3><p>做好了基本的设计工作，接下来我们就该进入代码编写的环节了。</p><p>同 Repository 部分一样，我们在这个部分的测试也准备从之前的测试中借鉴过来。所以，我们这里不把重点放在测试场景的分析上，而是来讨论如何编写测试。下面就是一个测试。</p><pre><code>@SpringBootTest\n@AutoConfigureMockMvc\n@Transactional\npublic class TodoItemResourceTest {\n    @Autowired\n    private MockMvc mockMvc;\n    @Autowired\n    private TodoItemRepository repository;\n    \n    ...\n    \n.    \n    @Test\n    public void should_add_item() throws Exception {\n        String todoItem = &quot;{ &quot; +\n                &quot;\\&quot;content\\&quot;: \\&quot;foo\\&quot;&quot; +\n                &quot;}&quot;;\n        mockMvc.perform(MockMvcRequestBuilders.post(&quot;/todo-items&quot;)\n                        .contentType(MediaType.APPLICATION_JSON)\n                        .content(todoItem))\n                .andExpect(status().isCreated());\n        assertThat(repository.findAll()).anyMatch(item -&gt; item.getContent().equals(&quot;foo&quot;));\n    }\n    \n    ...\n}\n</code></pre><p>从测试的名字便不难看出，这个测试是用来测试添加 Todo 项的。在这个类的开头有几个 Annotation：</p><ul>\n<li>@SpringBootTest，它告诉我们，接下来的测试是把所有组件都集成起来的集成测试。在前面的实战中，我说过最外面的接口很薄，所以我把集成测试和单元测试的工作量放到了一起。</li>\n<li>@AutoConfigureMockMvc，表示我们要使用的是模拟的网络环境，也就不是真实的网络环境，这样做可以让访问速度快一些。</li>\n<li>@Transactional，说明这个测试是事务性的，在缺省的测试事务中，执行完测试之后，数据是要回滚，也就是不对数据库造成实际的影响。这要单独标记，否则就会有数据写入到数据库里面。而之前的 @DataJpaTest 自身就包含了这个 Annotation，所以不用特别声明。</li>\n</ul><p>有了这些基础准备，我们就可以测试了。你可以认为，当我们执行测试时服务已经起好了，我们这里就像一个普通的客户端一样去访问一个服务，核心的部分就是下面这段代码。</p><pre><code>todoItem = &quot;{ &quot; +\n               &quot;\\&quot;content\\&quot;: \\&quot;foo\\&quot;&quot; +\n           &quot;}&quot;;\nmockMvc.perform(MockMvcRequestBuilders.post(&quot;/todo-items&quot;)\n                   .contentType(MediaType.APPLICATION_JSON)\n                   .content(todoItem))\n       .andExpect(status().isCreated());\n</code></pre><p>我们创建了一个请求，设置了这个请求的基本信息，用什么样的 HTTP 动词（POST） 访问哪个地址（/todo-items），具体的内容是什么等等。然后，预期返回的参数是什么（状态码是 201，也就是 CREATED）。</p><p>这里我们用的是 MockMVC，因为我们配置了@AutoConfigureMockMvc，它给我们创建了一个模拟的网络环境。这就是 Spring 在测试方面做得好的地方，作为框架的使用者，我们面对的都是编程的接口，支撑这些接口的实现在正常情况下是标准的网络环境，但 Spring 为我们提供了测试专用的实现，也就是不同的运行时，这就是做好了软件设计的结果。</p><p>不同于直接调用接口进行单元测试，这里的测试是集成测试，走的是完整的路径。所以，我们可以测试一些属于外部接口的行为，比如我们可以测试传入空的字符串该怎么办。</p><pre><code>@Test\npublic void should_fail_to_add_unknown_request() throws Exception {\n    String todoItem = &quot;&quot;;\n\n    mockMvc.perform(MockMvcRequestBuilders.post(&quot;/todo-items&quot;)\n                    .contentType(MediaType.APPLICATION_JSON)\n                    .content(todoItem))\n            .andExpect(status().is4xxClientError());\n}\n</code></pre><h3>编写 RESTful API</h3><p>有了测试，接下来就是实现相应的代码了。</p><pre><code>@RestController\n@RequestMapping(&quot;/todo-items&quot;)\npublic class TodoItemResource {\n    private TodoItemService service;\n\n    @Autowired\n    public TodoItemResource(final TodoItemService service) {\n        this.service = service;\n    }\n\n    @PostMapping\n    public ResponseEntity addTodoItem(@RequestBody final AddTodoItemRequest request) {\n        if (Strings.isNullOrEmpty(request.getContent())) {\n            return ResponseEntity.badRequest().build();\n        }\n\n        final TodoParameter parameter = TodoParameter.of(request.getContent());\n        final TodoItem todoItem = this.service.addTodoItem(parameter);\n\n        final URI uri = ServletUriComponentsBuilder\n                .fromCurrentRequest()\n                .path(&quot;/{id}&quot;)\n                .buildAndExpand(todoItem.getIndex())\n                .toUri();\n        return ResponseEntity.created(uri).build();\n    }\n    ...\n}`\n</code></pre><p>如果你熟悉 Spring Boot 的话，这段代码对你来说应该不难。即便你不熟悉，仅仅是通过阅读代码，也很容易理解这段代码的含义：</p><ul>\n<li>@RestController，告诉 Spring 这是一个 REST 服务的入口类。这个类的命名是 TodoItemResource，因为在 REST 服务中，资源是一个很重要的概念，而这里的 Controller，可以说是从历史遗留的产物。</li>\n<li>@RequestMapping(“/todo-items”)，说明服务入口的地址是 /todo-items，这是这个类里所有服务的根。</li>\n<li>每个具体的方法都会有自己相应的配置，对应着一个具体的服务，比如，在 addTodoItem 中是  @PostMapping，表示这个方法接收的是 POST 请求。</li>\n</ul><p>POST 服务一般都会有一个请求体，在这个方法中，我们使用 AddTodoItemRequest 的实例来接收这个请求体。在 HTTP 传输过程中传输的是文本，Spring 框架会替我们将文本转换成一个对象。只要我们把转换规则声明出来，Spring Boot 采用的 JSON 处理框架是 Jackson，所以，我们要在类的声明时采用 Jackson 的规则，就像下面这样。</p><pre><code>public class AddTodoItemRequest {\n    @Getter\n    private String content;\n\n    @JsonCreator\n    public AddTodoItemRequest(@JsonProperty(&quot;content&quot;) final String content) {\n        this.content = content;\n    }\n}\n</code></pre><p>在这里，@JsonCreator 表示这是一个 JSON 对象的构造方法，而@JsonProperty 则表示将对应属性的值赋值给这里的参数。</p><p>从软件设计的角度说，Resource 是一个防腐层，AddTodoItemRequest 是一个外部请求对象。把外部对象和内部对象分开，这是很重要的（我在《代码之丑》中<a href="https://time.geekbang.org/column/article/336166">分析过这种做法</a>的原因）。所以，在具体的函数中，我们首先要做就是把外部对象转换成内部对象。</p><pre><code>final TodoParameter parameter = TodoParameter.of(request.getContent());\n</code></pre><p>好，到这里，我们把这段代码中主要的设计考量都已经分析过了。这段代码完整的实现，你可以参考我们的开源项目。</p><h2>总结时刻</h2><p>这一讲，我们将原本的 ToDo 应用从一个命令行应用扩展为一个 REST 服务。因为我们已经构建好了业务核心，所以这里的工作同之前是一样的：要增加一个 Repository，要编写服务的入口。</p><p>在增加 Repository 方面，我们选择了 Spring Data JPA，目的是减少代码的编写。然后我们增加了相应的数据库迁移脚本，这里采用 Flyway 管理数据库迁移的工作。</p><p>因为选择了 Spring Data JPA，我们在测试里用@DataJpaTest，它会帮我们设置好 Repository，也会帮我们在测试运行之后回滚数据。</p><p>对外的接口我们采用 RESTful API 的设计。这里我们同样采用了集成测试代替单元测试的做法，集成测试是靠@SpringBootTest 把各种组件都集成起来。这里我们还用到了 MockMVC  让我们的测试不依赖于真实的环境，访问速度可以稍微快一点点。</p><p>接口层本身是一个典型的防腐层，所以一般来说这层会做得非常薄，会把外部请求与业务层分隔开来。</p><p>如果今天的内容你只能记住一句话，那么请记住，<strong>集成测试回滚数据，保证测试的可重复性。</strong></p><h2>思考题</h2><p>今天我们用 Spring 的基础设施演示了如何进行测试。你使用过 Spring 吗？有哪些测试特性让你印象深刻的？或者你用哪个框架给你提供了很好地测试支持呢？欢迎在留言区分享你的经验。</p>',
        article_title: "12 | 实战：将 ToDo 应用扩展为一个 REST 服务",
      },
      {
        title: "13 | 在 Spring 项目中如何进行单元测试？",
        id: 413708,
        content:
          '<p>你好，我是郑晔！</p><p>上一讲，我们将 ToDo 应用从命令行扩展为了 REST 服务。在这个应用里，我们用到了 Spring 这个在 Java 世界中广泛使用的框架。大多数人对于 Spring 这个框架的认知都停留在如何使用它完成各种功能特性上，而 Spring 更大的价值其实在对于开发效率的巨大提升上，其中就包含了对测试的支持。</p><p>在接下来的两讲，我们就把注意力从一个具体的项目上挪开，放到 Spring 框架本身，看看它对开发效率提升的支持。</p><h2>轻量级开发的 Spring</h2><p>很多人对于 Spring 的理解是从依赖注入容器开始的，但是，Spring 真正对行业的影响却是从它对原有开发模式的颠覆开始。</p><p>在 21 世纪初的时候，Java 世界的主流开发方式是 J2EE，也就是 Java 的企业版。在那个时候，企业版代表软件开发的最高水准。在这个企业版的构想中，所有的复杂都应该隐藏起来，写代码的程序员不需要知道各种细节，需要的东西拿过来用就好了。</p><p>这种想法本身是没有问题的，时至今日，很多平台和框架也是这么想的。到了具体的做法上，J2EE 提供了一个应用服务器，我把这些复杂性都放在这个应用服务器里实现，你写好的程序部署到这个应用服务器上就万事大吉了。但正是因为应用服务器的存在，使用 J2EE 进行开发变成了一件无比复杂的事情。</p><!-- [[[read_end]]] --><p>将程序打包部署这件事说起来很简单，但在实际的工作中，如果一个团队没有做好自动化，打包部署会非常麻烦。再者，除了自己的业务代码，所有相关的第三方 JAR 包都需要打到最终的发布包中，造成的结果就是发布包非常大。在那个网络带宽还不是特别大的年代，传输这个发布包也要花很长的时间。</p><p>更关键的是，一旦出了问题怎么去定位也是个令人头疼的问题。</p><p>程序员最熟悉定位问题的方式就是调试代码。之前所有的代码都是在本地，调试起来还比较容易，现在代码运行在应用服务器上，我们必须连接到远程应用服务器上进行调试，而要连接应用服务器进行调试，还需要一些配置，总之，这件事真的是非常麻烦。</p><p>对于麻烦的事情，人们倾向于少做或不做，但是  J2EE 让这件麻烦事成了必选项。所以，那个年代的 Java 程序员处于一种痛苦不堪的状态，开发效率极其低下。</p><p>就在整个 Java 社区饱受折磨之际，Spring 横空出世。对于 J2EE 提出的问题，Spring 是承认的，但对其给出的解决方案，它却是不认的。因为应用服务器太重了，Spring 给社区带来了轻量级开发。</p><p>Spring 的逻辑很简单，这些东西通过程序库的方式就可以完成，为什么非要弄一个应用服务器呢？采用程序库的方式，最大的优势就在于可以在本地开发环境中进行开发和调试，这就极大地降低开发的难度。于是，对于同样的问题，Spring 抛弃了 J2EE 中的大部分内容，给出了自己的程序库解决方案，应用服务器变得可有可无了。</p><p>事实证明，人们更喜爱简单的解决方案，即便 J2EE 有强大的官方背书，程序员们还是义无反顾地抛弃了它。Spring 从此成了 Java 社区的主流，也成了轻量级开发的代名词。</p><p>Spring 不仅是恰当地把握了时机，占据了 Java 世界中的关键位置，更重要的是，在随后的发展中，一直凭借对于轻量级开发的追求以及良好的品位，使得它在 Java 程序员心目中占据着无可替代的位置。即便中间有部分地方其它的程序库做得稍微好一些，它也能很快地学习过来。</p><p>前面我说过，虽然 Spring 抛弃了 J2EE 中的大部分内容，基于 Web 服务器的开发还是得到了保留。因为当时确实没有什么更好的选择，虽然大部分代码可以在本地测试，但很多时候我们还是要打成一个 WAR 包部署到像 Tomcat 这样的 Web 服务器上。不过，随着 Tomcat 和一众 Web 服务器提供了可嵌入的 API，打包部署这种 J2EE 残留方式就彻底成为了过去，也就诞生今天很多 Java 程序员熟悉的 Spring Boot，可以说 Spring Boot 是 Spring 多年努力的集大成者！</p><h2>Spring 的测试</h2><p>不过在 Spring Boot 出现之前，正是因为无法摆脱打包部署的这样的模式，基于这条路走下去开发难度依然不小，可以说并没有从根本上改变问题。但 Spring 的轻量级开发理念是支撑它一路向前的动力，既然那个时候  Web 服务器不能舍弃，索性 Spring 就选择了另外一条路：从测试支持入手。</p><p>所以  Spring 提供了一条测试之路，让我们在最终打包之前，能够让自己编写的代码在本地得到完整验证。你在实战环节中已经见识过如何使用 Spring 做测试了。简单来说就是<strong>使用单元测试构建稳定的业务核心，使用 Spring 提供的基础设施进行集成测试。</strong></p><p>严格地说，构建稳定的业务核心其实并不依赖于 Spring，但 Spring 提供了一个将组件组装到一起基础设施，也就是依赖注入（Dependency Injection，简称 DI）容器。通常我们会利用 DI 容器完成我们的工作，也正是因为 DI 容器用起来很容易，所以常常会造成 <strong>DI 容器的误用，反而会阻碍测试。</strong></p><p>在<a href="https://time.geekbang.org/column/article/408187">第6讲</a>中，我们讨论过要编写能够组合的代码。依赖注入的风格会引导我们编写能够组合的代码，也就是不要在类的内部创建组件，而是通过依赖注入的方式将组件注入到对象之中。</p><p>所以，在一个使用 Spring 项目进行单元测试的关键就是，<strong>保证代码可以组合的，也就是通过依赖注入的。</strong>你可能会说，我们都用了 Spring，那代码肯定是组合的。这还真不一定，有些错误的做法就会造成对依赖注入的破坏，进而造成单元测试的困难。</p><h3>不使用基于字段的注入</h3><p>有一种典型的错误就是基于字段的注入，比如像下面这样。</p><pre><code>@Service\npublic class TodoItemService {\n  @Autowired\n  private TodoItemRepository repository;\n\n}\n</code></pre><p>@Autowired 是一个很好用的特性，它会告诉 Spring 自动帮我们注入相应的组件。在字段上加Autowired 是一个容易写的代码，但它对单元测试却很不友好，因为你需要很繁琐地去设置这个字段的值，比如通过反射。</p><p>如果不使用基于字段的注入该怎么做呢？其实很简单，提供一个构造函数就好，把@Autowired 放在构造函数上，像下面这样子。</p><pre><code>@Service\npublic class TodoItemService {\n  private final TodoItemRepository repository;\n\n  @Autowired\n  public TodoItemService(final TodoItemRepository repository) {\n    this.repository = repository;\n  }\n  ...\n}\n</code></pre><p>这样一来，编写测试的时候我们只要像普通对象一样去测试就好了，具体的做法你要是记不清了，可以去回顾一下实战环节。</p><p>这种构造函数一般我们都可以利用 IDE 的快捷键生成，所以这段代码对我们来说也不是很重的负担。如果你还嫌弃这种代码的冗余，也可以用 Lombok（Lombok 是一个帮助我们生成代码的程序库）的 Annotation 来简化代码，像下面这样。</p><pre><code>@Service\n@RequiredArgsConstructor\npublic class TodoItemService {\n  private final TodoItemRepository repository;\n\n  ...\n}\n</code></pre><h3>不依赖于 ApplicationContext</h3><p>使用 Spring 还有一种典型的错误，就是通过 ApplicationContext 获取依赖的对象，比如像下面这样。</p><pre><code>@Service\npublic class TodoItemService {\n  @Autowired\n  private ApplicationContext context;\n  \n  private TodoItemRepository repository; \n  \n  public TodoItemService() {\n    this.repository = context.getBean(TodoItemRepository.class);\n  }\n  ...\n}\n</code></pre><p>我们可以把 ApplicationContext 理解成 DI 容器，原本使用 DI 容器的优点就是可以不知晓依赖是怎么产生的，而在这段代码里，却知晓了 DI 容器，这就完全打破了 DI 容器设计的初衷（关于 Spring 的设计初衷，我在《软件设计之美》中专门<a href="https://time.geekbang.org/column/article/241123">有一讲</a>分析过，如果你有兴趣可以去了解一下）。</p><p><strong>在业务核心代码中出现 ApplicationContext 是一种完全错误的做法。</strong>一方面，它打破了 DI 容器原本的设计，另一方面，还让业务核心代码对第三方代码（也就是 ApplicationContext）产生了依赖。</p><p>我们再从设计的角度看一下，AppliationContext 的出现使得我们在测试这段代码时，必须引入 ApplicationContext。要想在代码里获取到相应的组件，需要在测试中向 ApplicationContext 里添加相应的组件，这会让一个原本很简单的测试变得复杂起来。</p><p>你看，一个正常的测试是如此简单，但正是因为引入了 Spring，许多人反而会做错。Spring 最大的优点是可以在代码层面上不依赖于 Spring，而错误的做法反而是深深地依赖于 Spring。</p><p>我们前面讨论了这么多，其实并没有针对 Spring 对单元测试的支持进行讲解，但 Spring 其实还真提供了一个对单元测试的支持，也就是@MockBean，也就是帮我们进行 Mock 对象的初始化，像对于下面这行代码来说：</p><pre><code>@MockBean\nprivate TodoItemRepository repository;\n</code></pre><p>它就等同于下面这段。</p><pre><code>@BeforeEach\npublic void setUp() {\n  this.repository = mock(TodoItemRepository.class);\n  ...\n}\n</code></pre><p>但是我并不想特意强调这种做法。一方面，这种初始化的代码清晰且不复杂，另一方面，即便我们真的打算节省这两行的代码，更好的做法是根据你使用的 Mock 框架采用其对应的做法。比如使用 Mockito，我们可以像下面这么写。</p><pre><code>@ExtendWith(MockitoExtension.class)\npublic class TodoItemServiceTest {\n  @Mock\n  private TodoItemRepository repository;\n}\n</code></pre><p>不过@MockBean 并非一无是处，我们在集成测试中会用到它，让它参与到依赖注入的过程中去。下一讲，我们就来讨论一下如何使用 Spring 进行集成测试。</p><h2>总结时刻</h2><p>这一讲我们讲到了 Spring 这个 Java 世界使用最广泛的框架，它最大的贡献是对开发模式的颠覆：由原来 J2EE 依赖于部署的重量级开发模式，到可以在本地开发环境完成主要工作的轻量级开发方式。</p><p>轻量级的开发方式是 Spring 一以贯之的追求，采用 Spring 开发可以在部署到容器之前就完成所有代码的验证，其中对测试的支持是非常重要的一环。</p><p>虽然我们今天的主题是如何使用 Spring 进行单元测试，但实际上真正做好的业务测试和普通代码的测试是没有区别的，所以，我们更多地是在谈如何规避过度使用 Spring 框架犯下的错误。比如不要使用基于字段的注入，也不要依赖于 ApplicationContext 获取相应的依赖，这些做法都会让原本简单的测试变得复杂。</p><p>如果今天的内容你只能记住一件事，那请记住：<strong>业务代码不要过度依赖于框架。</strong></p><h2>思考题</h2><p>今天我们的重点是错误使用了框架，你在实际的工作中，遇到过度使用框架特性，反而让代码陷入难以调整的困境吗？欢迎在留言区分享你的经验。</p>',
        article_title: "13 | 在 Spring 项目中如何进行单元测试？",
      },
      {
        title: "14 | 在 Spring 项目如何进行集成测试？",
        id: 414448,
        content:
          "<p>你好，我是郑晔！</p><p>上一讲我们讲了 Spring 对轻量级开发的支持。不同于传统的开发方式，Spring 希望可以做到开发不依赖于应用服务器。为了达成这个目标，Spring 提供了各种支持，能够让你在部署到容器之前完成所有代码的基础验证工作。在核心业务部分，只要我们能够不过分依赖于 Spring 的种种特性，测试就和普通的单元测试差别不大。</p><p>不过在真实世界的软件开发中，我们总要与其它的外部组件集成。一旦牵扯到集成，测试的难度就上来了。不过正如前面所说，Spring 要尽可能让你在不依赖于容器的情况下进行测试。Spring 的做法就是提供一套自己的方案，替代掉对于容器的依赖。</p><p>这一讲，我们就来看看采用 Spring 的项目如何做集成测试。</p><h2>数据库的测试</h2><p>今天数据库几乎成了所有商业项目的标配，所以，Spring 也提供了对于数据库测试很好的支持。我们之前说过，一个好的测试要有可重复性，这句话放到数据库上就是要保证测试之前的数据库和测试之后的数据库是一样的。怎么做到这一点呢？</p><h3>测试配置</h3><p>通常有两种做法，一种是采用嵌入式内存数据库，也就是在测试执行之后，内存中的数据一次丢掉。另一种做法就是采用真实的数据库，为了保证测试前后数据库是一致的，我们会采用事务回滚的方式，并不把数据真正地提交进数据库里。</p><!-- [[[read_end]]] --><p>我们做测试的一个关键点就是不能随意修改代码，切记，<strong>不能为了测试的需要而修改代码。</strong>如果真的要修改，也许应该修改的是设计，而不仅仅是代码。</p><p>虽然不能修改代码，但我们可以提供不同的配置。只要我们给应用提供不同的数据库连接信息，它就会连到不同的数据库上。Spring 就给了我们一个提供不同配置的机会，只要我们在测试中声明一个不同的属性配置即可，下面就是一个例子。</p><pre><code>@ExtendWith(SpringExtension.class)\n@DataJpaTest\n@AutoConfigureTestDatabase(replace = AutoConfigureTestDatabase.Replace.NONE)\n@TestPropertySource(&quot;classpath:test.properties&quot;)\npublic class TodoItemRepositoryTest {\n  ...\n}\n</code></pre><p>在这段代码里，我们提供了一个测试用的配置，也就是 @TestPropertySource 给出的一个配置。这是在用 classpath 上的 test.properties 这个文件中的配置，去替换掉我们缺省的配置（也就是我们真实的数据库）。</p><h3>嵌入式内存数据库</h3><p>正如我们前面所说，我们要保证数据库的可重复性有两种做法：嵌入式内存数据库和事务回滚。要想使用嵌入式内存数据库，我们需要提供一个嵌入式内存数据库的配置。在 Java 世界中，常见的嵌入式内存数据库有 H2、HSQLDB、Apache 的 Derby 等。我们配置一个测试的依赖就好，以 H2 为例，像下面这样。</p><pre><code>testImplementation &quot;com.h2database:h2:$h2Version&quot;\n</code></pre><p>然后，再提供一个相应的配置，像下面这样。</p><pre><code>jdbc.driverClassName=org.h2.Driver\njdbc.url=jdbc:h2:mem:todo;DB_CLOSE_DELAY=-1\nhibernate.dialect=org.hibernate.dialect.H2Dialect\nhibernate.hbm2ddl.auto=create\n</code></pre><p>如果运气好的话，你的测试就可以顺利地运行了。是的，运气好的话。</p><p>之所以把软件开发这么严肃认真的事归结到运气，这就不得不说说使用嵌入式内存数据库的问题了。</p><p>严格地说，这不是嵌入式内存数据库的问题，这其实是只要运行在不同的数据库上都会有的问题，也就是 SQL 的不一致。虽然我们知道 SQL 有一个统一的标准，然而，几乎每个数据库引擎为了某些特点都有一些特殊的处理。造成的结果就是，虽然理论上说 SQL 可以运行在所有的数据库引擎上，然而真实情况却是总有一部分 SQL 只能运行在特定的引擎上。</p><p>如果你用的是 JPA 这种技术，因为 JPA 会根据数据库引擎替我们生成真实的 SQL，这个问题体现得还不是特别明显。但如果你用的 MyBatis 或者是其它需要手写 SQL 的技术，一旦发现了不能运行的 SQL，你就不得不在此权衡一下，如何去面对两个有差异的数据库。</p><p>所以，嵌入式内存数据库这种技术看上去很美，但我在实际的项目中用得并不多，我更多会采用事务回滚的方式。</p><h3>事务回滚</h3><p>在事务回滚的方式中，我们的配置几乎与标准的应用配置是一样的，下面是我们在实战中所采用的配置。</p><pre><code>spring.datasource.url=jdbc:mysql://localhost:3306/todo_test?useUnicode=true&amp;characterEncoding=utf-8&amp;useSSL=false&amp;allowPublicKeyRetrieval=true\nspring.datasource.username=todo\nspring.datasource.password=geektime\nspring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver\n</code></pre><p>通常来说，为了不让测试过程和开发过程造成数据冲突，我们会创建两个不同的数据库，在 MySQL 中，这就是两条 SQL 语句。</p><pre><code>create database todo_dev;\ncreate database todo_test;\n</code></pre><p>这样，一个用来做手工测试用，另外一个交由自动化测试使用，你从数据库后缀名上就可以看出二者的差异。顺便说一下，这种做法在业界的普遍流行是源自 Ruby on Rails（一个 Ruby 的 Web 开发框架），当年它在软件开发实践上给整个行业带来了极大的颠覆。</p><p>采用这种做法，我们的代码面对的是同样的数据库引擎，也就不必担心 SQL 不兼容的问题了。</p><p>我们所说的事务回滚体现在 @DataJpaTest 上，它把数据库回滚做成缺省的配置，所以我们什么都不用做，就可以获得这样的能力。</p><p>与大多数测试一样，测试与数据库的集成时，我们也要做一些准备。需要准备的往往是一些数据，提前插入到数据库里。我们可以使用 Spring 给我们准备的基础设施（TestEntityManager）向数据库中完成这个工作，下面是一个例子。</p><pre><code>@ExtendWith(SpringExtension.class)\n@DataJpaTest\npublic class ExampleRepositoryTests {\n  @Autowired\n  private TestEntityManager entityManager;\n\n  @Test\n  public void should_work() throws Exception {\n    this.entityManager.persist(new User(&quot;sboot&quot;, &quot;1234&quot;));\n    ...\n  }\n}\n</code></pre><p>如果你用的不是 JPA  而是其它的数据访问方式，Spring 也给我们提供了 @JdbcTest，这相当于是一个更基础的配置，因为只要有 DataSource， 它就可以很好地工作起来，这适用于绝大多数的测试情况。相应地，数据工作也更加地直接，采用 SQL 就可以，下面是一个例子。</p><pre><code>@JdbcTest\n@Sql({&quot;test-data.sql&quot;})\nclass EmployeeDAOIntegrationTest {\n  @Autowired\n  private DataSource dataSource;\n  \n  ...\n}\n</code></pre><h2>Web 接口测试</h2><p>除了数据库，另外一个几乎成了今天标配的就是 Web。Spring 对于 Web 测试也提供了非常好的支持。</p><p>如果按照我在实战中的方式工作，你会发现到了编写 Web 接口这步，我们基本上完成了几乎所有的工作，只差给外界一个接口让它和我们的系统连接起来。在前面的实战中，我们采用整体集成的方式对系统进行测试，这里的关键点就是@SpringBootTest，它把所有的组件都连接了起来。</p><pre><code>@SpringBootTest\n@AutoConfigureMockMvc\n@Transactional\npublic class TodoItemResourceTest {\n  ...\n}\n</code></pre><p>在讲集成测试的时候我曾经说过，集成测试分为两种，一种把所有代码都集成起来的测试，另外一种是针对外部组件的集成。从代码上来看，后一种测试只是针对一个单元在测试，所以它兼具单元测试和集成测试的特点。其实，测试 Web 接口也有一种类似于单元测试的集成方式，它采用的 @WebMvcTest。</p><pre><code>@WebMvcTest(TodoItemResource.class)\npublic class TodoItemResourceTest {\n  ...\n}\n</code></pre><p>正如你在这段代码中看见的那样，这里我们指定了要测试的组件  TodoItemResource。在这个测试里，它不会集成所有的组件，只会集成与 TodoItemResource 相关的部分，但整个 Web 处理过程是完整的。</p><p>如果把它视为单元测试，服务层后面的代码都是外部的，我们可以采用模拟对象把它控制在可控范围内，这个时候，上一讲遗漏的 MockBean 就开始发挥作用了。</p><pre><code>@WebMvcTest(TodoItemResource.class)\npublic class TodoItemResourceTest {\n  @MockBean\n  private TodoItemService service;\n  \n  @Test\n  public void should_add_item() throws Exception {\n    when(service.addTodoItem(TodoParameter.of(&quot;foo&quot;))).thenReturn(new TodoItem(&quot;foo&quot;));\n    ...\n  }\n}\n</code></pre><p>在这里，@MockBean 标记的 TodoItemService 模拟对象会参与到组件组装的过程中，成为 TodoItemResource 的组成部分，我们就可以设置它的行为。如果 Web 接口同服务层有比较复杂的交互，那这种做法就能够很好的处理。当然，正如我们一直在说的，我不建议这里做得过于复杂。</p><p>@WebMvcTest 这种偏向于单元测试的做法，执行速度相对于@SpringBootTest 这种集成了所有组件的做法而言要快一些。所以如果测试的量大起来，采用@WebMvcTest 会有一定的优势。</p><p>理解 Web 接口测试还有一个关键点。正如我在之前内容中说过，当年 Spring 摆脱了大部分对于应用服务器的依赖，但是  Web 却是它一直没有摆脱的。所以，怎么更好地不依赖于 Web 服务器进行测试，就是摆在 Spring 面前的问题。答案是 <strong>Spring 提供了模拟的 Web 环境。</strong></p><p>具体到我们的测试上，它就是 MockMvc 对象发挥的作用。我们用下面的代码回顾一下它的用法。</p><pre><code>@SpringBootTest\n@AutoConfigureMockMvc\n@Transactional\npublic class TodoItemResourceTest {\n    @Autowired\n    private MockMvc mockMvc;\n    ...\n\n    @Test\n    public void should_add_item() throws Exception {\n        String todoItem = &quot;{ &quot; +\n                &quot;\\&quot;content\\&quot;: \\&quot;foo\\&quot;&quot; +\n                &quot;}&quot;;\n        mockMvc.perform(MockMvcRequestBuilders.post(&quot;/todo-items&quot;)\n                        .contentType(MediaType.APPLICATION_JSON)\n                        .content(todoItem))\n                .andExpect(status().isCreated());\n        assertThat(repository.findAll()).anyMatch(item -&gt; item.getContent().equals(&quot;foo&quot;));\n    }\n}\n</code></pre><p>这里的关键是 @AutoConfigureMockMvc，它为我们配置好了 MockMvc，剩下的就是我们使用这个配置好的环境进行访问。</p><p>从程序库的角度看，MockMvc 可以理解成客户端的 Moco，同样是设置请求和应答。和 Moco 不同的点在于，它的请求是设置好的，而应答要匹配。</p><p>从实现的角度理解，它就是那个模拟的 Web 环境。所谓模拟的环境，是因为它根本没有启动真正的Web服务器，而是直接去调用了我们的代码，省略了请求在网络上走一遭的过程。但请求进到服务器之后的主要处理都在，所以相应的处理都在（无论是各种 Filter 的处理，还是从请求体到请求对象的转换）。现在你应该明白了，MockMvc 是 Spring 轻量级开发的一个重要的组成部分。</p><p>到这里，我给你介绍了 Spring 集成测试中最常用到的两种：数据库测试和 Web 接口测试。这里介绍的也是推荐你去使用的做法。还有一些细节的做法我在这里没有提到，比如可以取消数据的回滚，再比如使用真实的 Web 环境（走网络的那种），不提是因为它们并不是值得推荐的做法。</p><p>正如我在最近两讲一直说的那样，Spring 在支持轻量级开发上做了很大的努力，所以，在把整个系统集成起来之前，绝大部分内容我们都已经验证过了。我在这里介绍的只是其中最为典型的用法，Spring 的测试绝对是一个值得挖掘的宝藏，你可以阅读它的文档去发掘更多有趣的用法。</p><p>现在我们对怎样在真实项目中做好单元测试和集成测试已经有了一个基本的理解，但在实际的项目中，不同类型的测试该怎么配比呢？这就是我们下一讲要讨论的内容。</p><h2>总结时刻</h2><p>今天我们讨论了在 Spring 项目中怎么进行集成测试，主要讲解了如何做数据库和 Web 接口的集成测试。</p><p>做数据库测试，难点在于如何在测试之后恢复环境。有两种典型的做法：使用嵌入式内存数据库或是使用事务回滚的机制。无论是哪种做法，重点是给测试提供不同的配置，保证代码不变。</p><p>因为不同数据库引擎对 SQL 兼容程度不同，我更建议你使用事务回滚的做法。</p><p>Web接口测试通常是最外层的测试，可以做整体的集成测试（@SpingBootTest），或对一个单元进行测试的集成测试（@WebMvcTest）。</p><p>在Web接口测试中，一个关键点是采用模拟 Web 环境，这样可以在不启动 Web 服务器的前提下进行测试。这种做法不依赖于部署过程，测试速度可以大幅度提升。</p><p>如果今天的内容你只能记住一件事，那请记住：<strong>采用轻量级的测试手段，保证代码的正确性</strong>。</p><h2>思考题</h2><p>今天我们讲了 Spring 对于集成测试的支持，希望你可以通过阅读文档，了解它的更多特性。如果你在阅读文档的过程中发现了哪些有趣的特性，欢迎在留言区分享你的所得。</p>",
        article_title: "14 | 在 Spring 项目如何进行集成测试？",
      },
      {
        title: "15 | 测试应该怎么配比？",
        id: 415128,
        content:
          '<p>你好，我是郑晔！</p><p>经过前面内容的讲解，相信你对在实际项目中如何编写单元测试和集成测试已经有了一个基本的认识。无论你是经验丰富的老程序员还是初入职场的新程序员，如果只是单独写几个测试，相信你都可以手到擒来。但真实的项目中我们不是要编写几个测试，而是要大批量地编写测试。</p><p>一旦编写的测试增多，你脑海里必然会出现一个疑问：有一些内容用单元测试覆盖可以，用集成测试覆盖也可以，如果只写单元测试总有些不放心，如果同时用单元测试和集成测试去覆盖，工作量似乎又会增大，不同的测试应该怎样配比呢？这就是我们这一讲要讨论的内容。</p><h2>测试的特点</h2><p>在讨论如何配比测试之前，我们需要先了解各种类型测试的特点，毕竟正是因为它们有着不同的特点，我们才需要对不同的测试按照不同的比例进行配比。</p><p>首先来看<strong>单元测试</strong>。单元测试是针对一个单元的测试，因为涉及面很小，所以单元测试要进行的设置会比较少。单元测试不牵扯到外部组件，一般而言只在内存中执行，执行速度很快。所以谈及单元测试的特点我们一般会说，它成本低、速度快、单个测试的覆盖面小，但整体覆盖面大。</p><p>再来看<strong>集成测试</strong>。相比于单元测试来说，集成测试的涉及面要广一些，设置起来就比较麻烦。有的集成测试还会集成外部组件，这也就意味着设置起来要更麻烦，比如你在上一讲见识过的数据库测试，就要准备各种配置信息。同时，无论是组件多还是集成外部组件，这都意味着执行速度要比单元测试慢。所以相比于单元测试，集成测试成本要高一些、速度要慢一点；单个测试的覆盖面要大一些，但整体覆盖面要小一些。</p><!-- [[[read_end]]] --><p>虽然我们主要讨论的是单元测试和集成测试，但实际上，还有一种测试有的团队也会做，就是<strong>系统测试</strong>（把整个系统集成起来进行测试）。</p><p>系统测试的设置会更加复杂，比如，为了让各种组件配合到一起，要配置各种信息。而执行系统测试，先要把系统启动起来，然后要走完整的执行路径，执行时间会更长。所以，系统测试的特点就是成本高、速度慢，但单个测试覆盖面大，整体覆盖面小。</p><p>顺便说一下，在实际的项目中，有时候我会用系统测试去验证系统组装的过程，保证改了配置或者调整了代码之后，系统依然能够正常启动。</p><p>前面说到的一些特点都是非常容易想到的。其实，如果把测试放到软件开发的生命周期中，我们还会发现一些特点。比如，单个系统测试覆盖面大，反过来看，覆盖面中任何一点出了问题，或是有调整，这个测试都会受到影响，所以，相对来说系统测试是脆弱的。而低层一些的测试因为覆盖面小，只有它覆盖到的代码有变化时它才会受到影响，相对而言，稳定度就要高一些。</p><p>再比如，一旦测试出错，需要定位具体的问题。使用系统测试定位问题就如同大海捞针，难度系数很大，而单元测试因为只有一个单元，定位问题就要容易许多。我把刚刚讨论的内容整合成了一个表格，你可以对照着再复习一下。</p><p><img src="https://static001.geekbang.org/resource/image/6a/11/6ae19b91c63bb20ae0b16d5f0db3d411.jpg?wh=1948x641" alt=""></p><p>好，到这里，你已经对常见的测试特点有了一个了解，接下来，我们就来看看不同的测试配比模型。</p><h2>测试配比模型</h2><p>所谓不同的测试配比，其实就是什么样的测试多写一些。而决定什么样的测试多写一些，主要是不同人的不同出发点。有人认为一个测试应该尽可能覆盖面广一些，所以，要多写系统测试，有人认为测试应该考虑速度和成本，所以，要多写单元测试。</p><p>正是有不同的出发点，行业中有两种典型的测试配比模型，一种是冰淇淋蛋卷模型，一种是测试金字塔模型。</p><p>我们先来看冰淇淋蛋卷模型，如下图所示。</p><p><img src="https://static001.geekbang.org/resource/image/d8/a1/d869yy1b05c1dc626a928ca63ed2c6a1.jpg?wh=4055x2342" alt=""></p><p>在这个图里，单元测试在最下面，表示它是底层的；然后层次逐渐升高，系统测试，也就是图上的端到端测试就是高层测试，在最上面。所有自动化测试形成了蛋卷部分，而外面的冰淇淋部分则是手工的测试。</p><p>这里面每一层的宽窄表示了测试数量的多少。从图中我们不难看出，它对测试配比的预期：少量的单元测试，大量的系统测试。</p><p>冰淇淋蛋卷的出发点就是从单个测试的覆盖面考虑的，只要一些系统测试，就足以覆盖系统的大部分情况。当然，对于那些系统测试无法覆盖的场景就需要有低层的测试配合，比如，集成测试和单元测试。在冰淇淋蛋卷模型里，主力就是高层测试，低层测试只是作为高层测试的补充。</p><p>了解了冰淇淋蛋卷模型，我们再来看测试金字塔，下面这张图表示的就是测试金字塔。</p><p><img src="https://static001.geekbang.org/resource/image/5d/79/5d0b1895d6b9c61ea875d2a8e951a979.jpg?wh=4266x2082" alt=""></p><p>在表现形式上测试金字塔和冰淇淋蛋卷模型是一致的，都是下面表示低层测试，越往上测试的层次越高，而每一层的宽窄表示了测试数量的多少。</p><p>测试金字塔这个概念是 Mike Cohn 在自己的著作《<a href="https://book.douban.com/subject/5334585/">Succeeding with Agile</a>》中提出，但大多数人都是通过 Martin Fowler 的<a href="https://martinfowler.com/bliki/TestPyramid.html">文章</a>知道的这个概念。从图的整体形状我们不难看出，测试金字塔同冰淇淋蛋卷正相反，它的重点是多写单元测试，而上层的测试数量则逐层递减。</p><p>测试金字塔的出发点是低层测试成本低、速度快、整体覆盖面广，所以要多写。因为低层测试覆盖了几乎所有的情况，高层的测试就可以只做一些大面上的覆盖，保证不同组件之间的协作是没有问题的。在这个模型里，主力是单元测试，而高层的测试则是作为补充。</p><p>好，有了对于测试配比模型的理解，接下来我们要回答的问题就是<strong>怎样使用这两个模型</strong>。</p><p>从行业的最佳实践角度看，测试金字塔已经是行业中的最佳实践。测试金字塔以单元测试为基础，因为成本低、速度快等特点，单元测试可以让我们在开发过程中迅速得到反馈。对于一个想要编写测试的团队而言，测试金字塔模型也是更容易坚持做到的。</p><p>实际上，我们在实战环节中采用的就是测试金字塔模型，也就是以单元测试为主，附以少量的集成测试或系统测试。所以，如果你准备开始一个新项目，最好采用测试金字塔模型，而具体的做法我们在实战环节中已经见识过了，那就是一层一层地写测试。每完成一个功能，代码和测试总是同步写出来的，代码总是得到验证的，这样我们就可以稳步向前。</p><p>既然测试金字塔都成为了行业的最佳实践，那我们为什么还要了解冰淇淋蛋卷模型呢？因为不是所有项目都是新项目。</p><p>因为各种历史原因，很多遗留项目是没有测试的。当项目发展了一段时间之后，团队开始关注产品质量，于是大家开始补测试。</p><p>在这种情况下，补测试是希望能够快速地建立起安全网，那必然是从系统测试入手来得快。只要写上一些高层测试，就能够覆盖到系统的大部分功能，属于“投资少见效快”的做法。这也是很多人喜欢冰淇淋蛋卷模型的重要原因。</p><p>但是，我们必须知道一点，在补测试的情况下，这么做是没问题的。如果我们把它当作开发的常态，那就有问题了。这就像治病和健身的关系一样，虽然去医院能在短时间内快速解决一定问题，但你不能没事就去医院，只有日常多运动，才能减少去医院的次数。</p><p>所以，对于冰淇淋蛋卷模型，我的建议是，<strong>它是遗留项目写测试的起点。在有了一个安全网的底线之后，我们还是要向测试金字塔方向前进，以单元测试作为整体的基础</strong>。新写的代码都是要按照测试金字塔的方式来组织测试，这才是一个可以持续的方向。具体如何在遗留系统上写测试，这是我们下一讲要讨论的主题。</p><h2>总结时刻</h2><p>今天我们讨论了各种不同的测试在项目中应该如何配比，因为从实用的角度上看，我们不太可能用各种类型的测试做所有代码的覆盖，这是一种浪费。</p><p>在决定如何配比各种类型的测试前，你首先要了解各种测试的特点。比如，单元测试速度快成本低，但覆盖面小；集成测试和系统测试覆盖面大，但速度慢成本高。</p><p>行业中目前有两种典型的测试模型：冰淇淋蛋卷和测试金字塔。二者对于测试的配比要求刚好相反，冰淇淋蛋卷要求多写高层测试，而测试金字塔则希望多写低层测试。</p><p>行业中的最佳实践是测试金字塔，这是每个新项目都应该做到的。对于遗留项目，我们可以在一开始的时候，先采用冰淇淋蛋卷建立基础的安全网，在有了最低保障之后，开始向测试金字塔方向努力。</p><p>如果今天的内容你只能记住一件事，那请记住：<strong>新项目采用测试金字塔，遗留项目从冰淇淋蛋卷出发</strong>。</p><h2>思考题</h2><p>你的团队写哪种测试比较多呢？你们是怎样考虑的呢？欢迎在留言区分享你的思考。</p>',
        article_title: "15 | 测试应该怎么配比？",
      },
      {
        title: "16 | 怎么在遗留系统上写测试？",
        id: 415897,
        content:
          '<p>你好，我是郑晔！</p><p>迄今为止，我们讨论的话题主要是围绕着如何在一个新项目上写测试。但在真实世界中，很多人更有可能面对的是一个问题重重的遗留系统。相比于新项目，在一个遗留系统上，无论是写代码还是写测试，都是一件有难度的事。</p><p>在讨论如何在遗留系统上写测试前，我们首先要弄清楚一件事：什么样的系统算是遗留系统。在各种遗留系统的定义中，Michael Feathers 在《<a href="https://book.douban.com/subject/25904007/">修改代码的艺术</a>》（Working Effectively with Legacy Code）中给出的定义让我印象最为深刻——遗留系统就是没有测试的系统。</p><p>根据这个定义你会发现，即便是新写出来的系统，因为没有测试，它就是遗留系统。由此可见测试同遗留系统之间关系之密切。想要让一个遗留系统转变成为一个正常的系统，关键点就是写测试。</p><h2>给遗留系统写测试</h2><p>众所周知，给遗留系统写测试是一件很困难的事情。但你有没有想过，为什么给遗留系统写测试很困难呢？</p><p>如果代码都写得设计合理、结构清晰，即便是补测试也困难不到哪去。但大部分情况下，我们面对的遗留系统都是代码冗长、耦合紧密。你会不会一想到给遗留系统写测试就头皮发麻？因为实在是太麻烦了。由此我们知道，给遗留系统写测试，难点不在于测试，而在于它的代码。</p><!-- [[[read_end]]] --><p>如果不能了解到一个系统应该长成什么样子，我们即便努力做到了局部的一些改进，系统也会很快地退化成原来的样子。这也是为什么我们学习写测试要从一个新项目开始，因为我希望你对一个正常系统的样子有个认知，<strong>写测试不只是写测试的事，更是写代码的事</strong>。</p><p>在遗留系统上写测试，本质上就是一个系统走向正常的过程。对于一个系统来说，一旦能够正常运行，最好的办法就是不动它，即便是要给它写测试。但在真实世界中，一个有生命力的系统总会有一些让我们不得不去动它的理由，可能是增加新特性，可能是要修改一个 Bug，也可能是要做系统的优化。</p><p>我们不会一上来就给系统完整地添加测试，这也几乎是不可能完成的任务。所以，本着实用的态度，我们的做法是，<strong>动到哪里，给哪里写测试</strong>。</p><p>要动哪里，很大程度上就是取决于我们对既有代码库的理解。不过，既然是遗留代码，可能出现的问题是，你不一定理解你要修改的这段代码究竟是怎么起作用的。最有效的解决办法当然是找懂这段代码的人请教一番，但如果你的代码库生命周期够长，很有可能已经没有人知道这段代码是怎么来的了。在如今这个时代里，摸黑看代码时，我们可以使用 IDE 提供的重构能力，比如提取方法，将大方法进行拆分，这样有助于降低难度。</p><p>至于给哪里写测试，最直观的做法当然是编写最外层的系统测试。这种做法可行，但正如我们在上一讲所说，越是外层的测试，编写的成本越高，执行速度越慢。虽然覆盖面会广一些，但具体到我们这里要修改代码而言，存在一种可能就是控制得不够准确。换言之，很有可能我们写了一个测试，但是我们改不改代码，对这个测试影响不大。所以，只要有可能，我们还是要努力地降低测试的层次，更精准地写测试。也就是能写集成测试，就不写系统测试；能写单元测试，就不写集成测试。</p><p>或许你会说，我也知道能写单元测试很好，但通常遗留系统最大的问题就在于单元测试不好写。<strong>造成测试不好写的难点就是耦合</strong>，无论是代码与外部系统之间的耦合，还是代码与第三方程序库的耦合，抑或是因为代码写得不好，自己的代码就揉成了一团。所以，<strong>想在遗留系统中写好测试，一个关键点就是解耦</strong>。</p><h2>一个解耦的例子</h2><p>我们在专栏前面中讲过，测试的关键就在于构建一个可控的环境。对于编写单元测试来说，可控环境很关键的一步就是使用模拟对象，也就是基于 Mock 框架生成的对象。</p><p>同样，在遗留系统上如果想要编写单元测试，模拟对象也很关键。换言之，我们要给一个类编写单元测试，首先要把它周边的组件由模拟对象替换掉，让它有一个可控的环境。说起来很简单，但面对遗留系统时，想要用模拟对象替换掉真实对象就不是一件轻松的事。</p><p>下面我们就用一个例子看看如何在一个遗留系统上进行解耦，然后又是如何给代码写测试。我们有一个订单服务，完成了下单过程之后，要发出一个通知消息给到 Kafka，以便通知下游的服务。</p><pre><code>public class OrderService {\n  private KafkaProducer producer;\n  \n  public void placeOrder(final OrderParameter parameter) {\n    ...\n    this.producer.send(\n      new ProducerRecord&lt;String, String&gt;(&quot;order-topic&quot;, DEFAULT_PARTITION, Integer.toString(orderId.getId()))\n    );\n  } \n}\n</code></pre><p>很显然，这段代码我们直接依赖了 KafkaProducer，这是 Kafka 提供的 API，如果要想测试 OrderService 这个类，我们就需要把 Kafka 加到这个测试里，而我们的测试重点是下单的过程，这个过程本身同 Kafka 没有关系。要测试这个类，我们必须把 Kafka 从我们的代码中解耦开。</p><p>首先，我们用<strong>提取方法（Extract Method）</strong>这个重构手法把 Kafka 相关的代码调用封装起来，通过使用 IDE 的重构功能就可以完成。</p><pre><code>public class OrderService {\n  private KafkaProducer producer;\n  \n  public void placeOrder(final OrderParameter parameter) {\n    ...\n    send(orderId);\n  } \n  \n  private void send(final OrderId orderId) {\n    this.producer.send(\n      new ProducerRecord&lt;String, String&gt;(&quot;order-topic&quot;, DEFAULT_PARTITION, Integer.toString(orderId.getId()))\n    );\n  }\n}\n</code></pre><p>接下来，我们要把 KafkaProducer 与我们的业务代码分离开。正如我们在之前讨论的内容所说，我们需要有一个封装层，把对第三方程序库的访问封装进去。所以，我们在这里引入一个新的类承担这个封装层的作用。我们可以使用**提取委托（Extract Delegate）<strong>创建出一个新的类，提取的时候，我们还要选上</strong>生成访问器（Generate Accessors）**的选项，它会为我们生成对应的 Getter。</p><pre><code>public class KafkaSender {\n  private KafkaProducer producer;\n    \n  public KafkaProducer getProducer() {\n        return producer;\n  }\n    \n  ...\n}\n</code></pre><p>而 OrderService 的 send 方法就变成了下面的样子。</p><pre><code>class OrderService {\n  ...\n  private void send(final OrderId orderId) {\n    this.kafkaSender.getProducer().send(\n            new ProducerRecord&lt;String, String&gt;(&quot;order-topic&quot;, DEFAULT_PARTITION, Integer.toString(orderId.getId()))\n    );\n  }\n}\n</code></pre><p>很显然，从当前的实现看，它只与 KafkaSender 相关，接下来，我们可以使用<strong>搬移实例方法（Move Instance Method）</strong>把它搬移到 KafkaSender 中。</p><pre><code>class KafkaSender {\n  ...\n  \n  public void send(final OrderId orderId, OrderService orderService) {\n    getProducer().send(\n            new ProducerRecord&lt;String, String&gt;(&quot;order-topic&quot;, DEFAULT_PARTITION, Integer.toString(orderId.getId()))\n    );\n  }\n}\n\nclass OrderService {\n  ...\n  \n  public void placeOrder(final OrderParameter parameter) {\n    ...\n    kafkaSender.send(orderId, this);\n  }\n}\n</code></pre><p>从代码上我们可以看到，虽然 KafkaSender 的 send 方法有 OrderService 这个参数，但是我们并没有用它，可以安全地删除它（Safe Delete），这也是一个快捷键就可以完成的工作。还有，这里用到 getProducer 方法，因为我们在 KafkaSender 这个类里面了，所以，我们就不需要通过 Getter 访问了，可以通过<strong>内联方法（Inline Method）</strong>将它去掉。</p><pre><code>class KafkaSender {\n  ...\n  \n  public void send(final OrderId orderId) {\n    producer.send(\n            new ProducerRecord&lt;String, String&gt;(&quot;order-topic&quot;, DEFAULT_PARTITION, Integer.toString(orderId.getId()))\n    );\n  }\n}\n\nclass OrderService {\n  ...\n  \n  public void placeOrder(final OrderParameter parameter) {\n    ...\n    kafkaSender.send(orderId);\n  }\n}\n</code></pre><p>到这里，我们的业务代码（OrderService）已经不再依赖于 KafkaProducer 这个第三方的代码，而是依赖于我们自己的封装层，这已经是一个进步了。不过从软件设计上讲，KafkaSender 是一个具体的实现，它不应该出现在业务代码中。所以，我们还需要再进一步，提取出一个接口，让我们的业务类不依赖于具体的实现。回到代码上，我们可以在 KafkaSender 这个类上执行<strong>提取接口（Extract Interface）</strong>这个重构动作，创建出一个新的接口。</p><pre><code>public interface Sender {\n  void send(OrderId orderId);\n}\n\npublic class KafkaSender implements Sender {\n  @Override\n  public void send(final OrderId orderId) {\n    producer.send(\n            new ProducerRecord&lt;String, String&gt;(&quot;order-topic&quot;, DEFAULT_PARTITION, Integer.toString(orderId.getId()))\n    );\n  }\n}\n\npublic class OrderService {\n  private final Sender sender;\n  \n  public OrderService(Sender sender) {\n    this.sender = sender;\n  }\n  \n  ...  \n}\n</code></pre><p>经过这番改造，OrderService 这个业务类已经与具体的实现完全无关了。我们就可以用模拟对象模拟出 sender，用完全可控的方式给这个类添加测试了。</p><pre><code>class OrderServiceTest {\n  private OrderService service;\n  private Sender sender;\n  \n  @BeforeEach\n  public void setUp() {\n    this.sender = mock(Sender.class);\n    this.service = new OrderService(this.sender);\n  }\n  ...\n}\n</code></pre><p>到这里，你或许会有一个疑问，我在这里改动了这么多的代码，真的没问题吗？如果这些代码是我们手工修改，这确实是个问题。不过，现在借助 IDE 的重构功能，我们并没有手工修改任何代码，相比于过去，这也是今天做遗留系统调整的优势所在。由此可见，<strong>理解重构，尤其是借助 IDE 的重构功能，是我们更好地去做遗留系统调整的基础。</strong>否则，我们必须先构建更外层的测试，无论是系统测试还是人工测试。</p><p>现在我们来回顾一下前面做了些什么。首先，我们有一个大目标：为了能够有效地测试，我们需要把具体实现和业务解耦开。在前面的例子中，主要就是要把 KafkaProducer 从业务类中分开。</p><p>把具体实现的代码从业务实现中隔离开，我们采用的手法是提取方法，这一步是为了后面把具体实现从业务类中挪出去做准备。通过引入一个封装类（KafkaSender），我们将具体的实现（KafkaProducer）从业务类中挪了出去。</p><p>到这里，我们的业务类已经完全依赖自己编写的代码。不过，这个封装类还是特定于具体的实现，让业务依赖于一个具体实现在设计上也是不恰当的。所以，我们这里再进一步，提取出一个接口。</p><p>从软件设计的角度看，这个提取出来的接口就是这个设计中缺失的一个模型，所以，提取这个接口不是画蛇添足，而恰恰是补齐了之前在设计上的欠缺。</p><p>换个角度看，模拟对象模拟的是接口行为，而很多遗留代码只有具体的类，而没有接口。虽然有些具体类也是可以模拟的，但出于统一原则的考虑，我们应该<strong>针对所有具体类提取一个接口出来</strong>，而让原来的类成为实现这个接口的一个实现类。有了接口，我们也就可以使用模拟对象，做行为可控的测试了。</p><p>这一系列的做法非常有用，比如，业务代码中调用了static方法，它在测试中也不好模拟。我们也可以通过提取方法把它隔离出来，然后把它挪到一个封装类里面，引入一个新的接口，让一段无法模拟的代码变得可以模拟。如果你真的能够理解这种做法，已经可以消灭掉很多设计不好的代码了。</p><p>当然，这里没有涵盖在遗留系统上写测试的各种做法，但你已经掌握了最精髓的部分：<strong>先隔离，再分离</strong>。如果你有兴趣了解更多的做法，推荐一本书给你，就是前面提到的《<a href="https://book.douban.com/subject/25904007/">修改代码的艺术</a>》（Working Effectively with Legacy Code）。虽然它是一本介绍处理遗留代码的书，在我看来，它更是一本教人如何写测试的书。</p><h2>总结时刻</h2><p>今天我们谈到了在遗留系统上写测试。遗留系统就是那些没有测试的系统，给遗留系统写测试就是让一个系统恢复正常的过程。</p><p>在遗留系统上做改进，关键是要知道改进成什么样子。在一个遗留系统上写测试，不仅是写测试，还会牵扯到写代码。</p><p>完整地给一个遗留系统写测试是比较困难的。一个实用的改进策略是，动到哪里，改哪里。具体如何写测试，最好是测试的层次越低越好，但低层次的测试就会涉及代码耦合的问题，而这里就需要我们对代码进行解耦。</p><p>解耦，主要是把业务代码和具体实现分开。通过提取方法，把一段耦合紧密的代码隔离开，再创建一个新的封装类把它挪进去。如果代码里有很多具体类，我们还可以通过引入接口进行解耦。这里面的关键是利用 IDE 给我们提供的重构功能，减少手工改代码的操作。</p><p>如果今天的内容你只能记住一件事，那请记住：<strong>改造遗留系统的关键是解耦</strong>。</p><h2>思考题</h2><p>你有遗留系统改造的经验吗？你是怎么保证改造的正确性的呢？欢迎在留言区分享你的经验。</p>',
        article_title: "16 | 怎么在遗留系统上写测试？",
      },
    ],
  },
  {
    chapterTitle: "扩展篇",
    children: [
      {
        title: "17 | TDD 就是先写测试后写代码吗？",
        id: 416742,
        content:
          '<p>你好，我是郑晔！</p><p>到这里，我已经给你介绍了在真实项目中做好测试需要的基础知识。写测试远远不是用 xUnit 框架写代码就能做好的一件事，只有在工作方式、软件设计、编写代码、测试理念等方方面面都做好，我们才能做好测试。不过随之而来的是，我们有了一个强大的测试基础，这可以让我们放心大胆地不断向前，因为我们已经进入到编写高质量代码的正向循环之中。越写测试越安心，越安心也就越有时间编写高质量的代码。</p><p>有了这些基础，应对日常工作已经绰绰有余。不过在行业里总有人在探索着更好的做法，所以在最后的扩展篇，我将给你介绍 TDD 和 BDD 两项实践。在你学有余力的情况下，可以挑战一下，让自己再向前走一步。这一讲，我们先来说说 TDD，也就是测试驱动开发（Test Drvien Development）。</p><h2>TDD 的节奏</h2><p>或许你已经迫不及待地要举手了：“TDD 我知道，就是先写测试，后写代码。”但真的是这样吗？严格地说，“先写测试、后写代码”的做法叫测试先行开发（Test First Development），而不是测试驱动开发。</p><p>测试驱动开发不也是先写测试后写代码吗？二者之间有什么区别呢？</p><p>要回答这个问题，我们需要知道 TDD 的一个关键要素，<strong>TDD 的节奏：红-绿-重构</strong>。</p><!-- [[[read_end]]] --><p><img src="https://static001.geekbang.org/resource/image/09/7f/090e1fc6aff08b4aa66376f776c2337f.png?wh=1426x836" alt=""></p><p>红表示写了一个新的测试，测试还没有通过的状态；绿表示写了功能代码，测试通过的状态；而重构就是在完成基本功能之后，调整代码的过程。</p><p>这里说到的红和绿源自单元测试框架。因为在很多单元测试框架运行测试的过程中，测试不过时会用红色展示测试结果，而通过时则采用绿色进行展示，这已经成了单元测试框架约定俗成的规则。</p><p>在前面内容中我们说过，让单元测试框架流行起来的是 JUnit，其作者之一是 Kent Beck。TDD 走进大众视野则依赖于极限编程这个软件工程方法论的兴起，而极限编程的创始人也是 Kent Beck。Kent Beck 在 JUnit 和 TDD 两件事都有着重大贡献，也就不难理解为什么 TDD 的节奏叫“红-绿-重构”了。</p><p>先写测试，然后写代码完成功能，在第一步和第二步上，测试先行开发和测试驱动开发是一样的。二者的差别在于，测试驱动开发并没有就此打住，它还有一个更重要的环节：<strong>重构（refactoring）</strong>。</p><p>也就是说，在功能完成而且测试跑通之后，我们还会再次回到代码上，处理一下代码中写得不理想的地方，或是消除新增代码与旧有代码之间的重复。你或许会问，那为啥不在第二步“绿”的时候就把代码写好呢？因为“绿”的关注点只是让测试通过，把功能完成。</p><p>所以我们说，<strong>测试先行开发和测试驱动开发的差异就在重构上。</strong></p><p>很多人只记住了“先写测试，后写代码”，因为在很多人的印象中，写代码唯一重要的事就是完成功能。通过了测试，就是完成了功能，也就意味着万事大吉了。然而，这种想问题的方式会让人忽略新增代码可能带来的<strong>坏味道（Code Smell）</strong>，坏味道会让代码逐渐腐坏，这是一个工程问题，也就是会有长期影响的问题。</p><p>人的注意力是有限的，让人在一个阶段把所有事情都做好，很难。事实上我们会看到，很多团队代码变乱的一个重要原因就是把全部的注意力都放到完成功能上，根本无暇顾及代码本身的质量。从这个角度上看，TDD 是更符合人性的做法，它把完成功能和代码调整当成了两个阶段。</p><p>重构就是一个消除代码坏味道的过程。一旦你有了测试，你就可以大胆地重构了，因为任何修改错误，测试都会替你捕获到。</p><p>在测试驱动开发中，重构与测试是相辅相成的：没有测试，修改代码只能是提心吊胆；没有重构，代码的混乱程度会逐步增加，测试也会变得越来越不好写。</p><p>现在，你已经理解了测试驱动开发不只是“先写测试，后写代码”。但这只是破除了概念上的误区，我们还需要再进一步，知道测试怎么“驱动”开发。</p><h2>测试“驱动”开发</h2><p>不难理解，重构和测试相互配合，这个过程就会“驱动”着我们把代码写得越来越好。不过，这只是对“驱动”一词最粗浅的理解。</p><p>首先，我来问你一个问题，测试驱动开发，从哪里开始呢？很多人会说，测试驱动开发不是从测试开始的吗？这个答案非常直观，我们可以接着追问下去，写测试要从哪里开始呢？</p><p>对很多人来说，TDD 是一种难以接受的做法，抛开理念上的差异，更重要的原因是，写测试无从下手。学习过我们这个专栏你会发现，很多时候写不出测试，主要是面对的需求太大了。所以，真正动手做开发的第一步是任务分解，把一个规模很大的需求拆分成若干小任务。面对一个具体的小任务，我们才有动手写测试的基础。<strong>测试驱动开发要从任务分解开始。</strong></p><p>具体到了写测试的环节，即便面对的是一个小任务，对很多人来说，这依然不是一件容易完成的事。同样，我们在前面分析过，想要写出测试，需要有可测试的代码。这意味着，我们的代码需要有一个可测试的设计。如果不能写测试，我们就要调整代码，让代码变得可以测试，这是我们上一讲中谈遗留系统测试所讲的内容。</p><p>从这里你可以看出，从测试出发考虑问题的这种思考方式，会彻底颠覆掉我们原有的工作习惯，甚至是为了测试调整设计。但结果是我们得到了一个更好的设计，所以，很多懂 TDD 的人会<strong>把 TDD 解释为测试驱动设计（Test Driven Design）。</strong></p><p>现在你可以理解了，<strong>为了写测试，首先“驱动”着我们把需求分解成一个一个的任务，然后会“驱动”着我们给出一个可测试的设计，而在具体的写代码阶段，又会“驱动”着我们不断改进写出来的代码。把这些内容结合起来看，我们真的是在用测试“驱动”着开发。</strong></p><p>TDD 这么好，为什么行业里采用 TDD 这种工作方式的人并不多呢？首先，很多人本身对 TDD 的理解是错误的，这是我在前面分析过的；其次，TDD 看似简单的节奏中，其实需要很多前置的基础，比如任务分解、可测试的设计等等，而这些能力是很多人不具备的。换个角度看，TDD 只是冰山一角，露在海面之上的是 TDD 的节奏，而藏在海面下的是任务分解、软件设计这些需要一定时间积累的能力。</p><p>我们这个专栏介绍TDD的方式相比于传统介绍 TDD 的方式，还是挺不一样的。学过我们这个专栏之后，你其实已经具备了 TDD 的基础。因为在前面部分的介绍中，我已经把这些基础能力给你串讲过了。到了这里，你只需要知道 TDD 的节奏是怎样的，如果想尝试 TDD，那么按照 TDD 的节奏练习一段时间，你就知道 TDD 是怎么回事了。</p><p>最后，再给你补充一个知识点。前面说过  TDD 是来自极限编程，那极限编程为什么要叫极限编程呢？</p><p>极限编程之所以叫“极限”，它背后的理念就是把好的实践推向极限：</p><ul>\n<li>如果集成是好的，我们就尽早集成，推向极限就是每一次修改都集成，这就是持续集成。</li>\n<li>如果程序员写测试是好的，我们就尽早测试，推向极限就是先写测试，再根据测试调整代码，这就是测试驱动开发。</li>\n<li>如果代码评审是好的，我们就多做评审，推向极限就是随时随地代码评审，这就是结对编程。</li>\n<li>如果客户交流是好的，我们就和客户多交流，推向极限就是客户与开发团队时时刻刻在一起，这就是现场客户。</li>\n</ul><p>极限编程本身的实践值得我们好好学习，但极限编程背后这种理念其实也非常值得我们学习。我们在日常工作中也不妨多想想，<strong>有哪些做法是好的，如果把它推向极致会是什么样子。</strong>这种想问题的方式会在很大程度上拓宽你的思路。</p><h2>总结时刻</h2><p>今天我们讲了 TDD，也就是测试驱动开发。我们在专栏前面的内容中学习的是在代码层面上如何写测试，而 TDD 这种实践探索的是在开发过程中如何写测试。</p><p>测试驱动开发已经是行业中的优秀实践，学习测试驱动开发的第一步是记住测试驱动开发的节奏：红——绿——重构。</p><p>知道了 TDD 的节奏之后，我们还需要理解测试怎样驱动开发。在 TDD 的过程中，我们要先进行任务分解，把大需求拆成小任务，然后考虑代码的可测试性，编写出整洁的代码，这一切都是在“测试”驱动下产生的。</p><p>正是因为视角的转变，为了编写可测的代码，我们甚至要为此调整设计，所以，有人也把 TDD 称为测试驱动设计。</p><p>无论你是否采用 TDD 的实践，在动手写代码之前，从测试的角度进行思考都是非常有价值的一件事，这也是编写高质量代码的重要一环。</p><p>如果今天的内容你只能记住一件事，那请记住：<strong>从测试的视角出发看待代码。</strong></p><h2>思考题</h2><p>你尝试过 TDD 吗？如果没有，不妨试试，然后在留言区分享一下你采用 TDD 进行开发的感受。</p>',
        article_title: "17 | TDD 就是先写测试后写代码吗？",
      },
      {
        title: "18 | BDD 是什么东西？",
        id: 417462,
        content:
          '<p>你好，我是郑晔！</p><p>在扩展篇中，我们要讨论的是在不同方向上的写测试探索。在上一讲里，我给你介绍了 TDD。TDD 是在写测试的时机上进行了不同的探索。这一讲，我们再来讲另一个实践——BDD，它是在写测试的表达方式上进行的不同探索。</p><p>我们都知道，在软件开发中最重要的一个概念就是分层，也就是在一些模型的基础上，继续构建新的一些模型。程序员最耳熟能详的分层概念就是网络的七层模型，只要一层模型成熟了，就会有人基于这个模型做延伸的思考，这样的做法在测试上也不例外。</p><p>当 JUnit 带来的自动化测试框架风潮迅速席卷了整个开发者社区，成了行业的事实标准，就开始有人基于测试框架的模型进行延伸了。各种探索中，最有影响力的就是 BDD。</p><h2>行为驱动开发</h2><p>BDD 的全称是 Behavior Driven Development，也就是<strong>行为驱动开发</strong>。BDD 这个概念是2003年由 Dan North 提出来的。</p><p>单元测试框架写测试的方式更多的是面向具体的实现，这种做法的层次是很低的，BDD 希望把这个思考的层次拉高。拉到什么程度呢？软件变化的源动力在业务需求上，所以，最好是能够到业务上，而校验业务的正确与否的就是业务行为。这种想法很大程度上是受到当时刚刚兴起的领域驱动设计（Domain Driven Design）中通用语言的影响。在 BDD 的话语体系中，“测试”的概念就由“行为”所代替，所以，这种做法称之为行为驱动开发。</p><!-- [[[read_end]]] --><p>Dan North 不仅仅提出了概念，而且为了践行他的想法，他还创造了第一个 BDD 的框架：<a href="https://jbehave.org/">JBehave</a>。后来又改写出基于 <a href="https://www.ruby-lang.org/en/">Ruby</a> 的版本 <a href="https://dannorth.net/2007/06/17/introducing-rbehave/">RBehave</a>，这个项目后来被并到 <a href="http://rspec.info/">RSpec</a> 中。</p><p>好，了解了 BDD 的由来，接下来，我们就来看看采用 BDD 的方式进行开发，测试会写成什么样子。</p><p>今天最流行的 BDD 框架应该是 <a href="https://cucumber.io/">Cucumber</a>，它的作者就是 RSpec 的作者之一 Aslak Hellesøy。从最开始基于 Ruby 的 BDD 框架发展成今天，Cucumber 已经变成了支持很多不同程序设计语言的 BDD 测试框架，比如常见的 Java、JavaScript、PHP 等等。</p><p>下面是一个 BDD 的示例，其场景就是我们前面实战的内容。</p><pre><code>Scenario: List todo item\n  Given todo item &quot;foo&quot; is added\n  And todo item &quot;bar&quot; is added\n  When list todo items\n  Then todo item &quot;foo&quot; should be contained\n  And todo item &quot;bar&quot; should be contained\n</code></pre><p>从这个例子我们不难看出，<strong>BDD 的测试用例有很强的可读性</strong>。即便我们不熟悉技术，单凭这段文字，我们也能看出这个用例想表达的含义。这也就是我们前面说 BDD 测试用例更贴近业务的原因。它希望成为业务人员和技术团队之间沟通的桥梁，所以，它的表述方式更贴近于业务。</p><p>虽然这个表述已经很贴近业务了，但它并不是自然语言描述，而是有一种特定的格式，其实这是一门领域特定语言（Domain Specific Language，简称 DSL），称之为 Gherkin。</p><p>不要看到一门新的语言就被吓退，其实它非常简单。这里的核心点就是它的描述格式：“Given…When…Then”。<strong>Given 表示一个假设前提，When 表示具体的操作，Then 则对应着这个用例要验证的结果。</strong></p><p>我们在<a href="https://time.geekbang.org/column/article/407452">第 5 讲</a>谈到测试的结构时说过，测试一般包含四个阶段：准备、执行、断言和清理。把它对应到这里，Given 对应着准备，When 对应执行，而 Then 对应断言。至于清理，这个阶段会做一些资源释放的工作，不过这个工作属于实现层面的内容，在业务层面上意义不大，所以在以业务描述为主要目标的 BDD 中，这个阶段是不存在的。</p><p>了解了格式，我们再来关注具体的内容。首先，这里描述的行为都是站在业务的角度进行叙述的。其次，Given、When、Then 都是独立的，可以自由组合。这也就意味着，一旦基础框架搭好了，有人就可以使用这些基础语句来编写新的测试用例，甚至可以不需要技术人员参与。</p><p>从这里我们不难看出，Gherkin 语言本身有一个很好的目标，与其说它是为了技术人员设计的，不如说它是为了业务人员设计的。</p><p>Gherkin 语言这层只提供了业务描述，作为程序员我们很清楚，这层描述并不能直接发挥作用，必须要有一个具体的实现。那具体的实现要放在哪里呢？这就轮到<strong>胶水层</strong>（Glue）发挥作用了，这个将测试用例与实现联系起来的胶水层，在 Cucumber 的术语里，称之为步骤定义（Step Definition），下面就是一个步骤定义的示例。</p><pre><code>public class TodoItemStepDefinitions ... {\n  private RestTemplate restTemplate;\n  \n  public TodoItemStepDefinitions() {\n    ...\n    \n    Given(&quot;todo item {string} is added&quot;, (String content) -&gt;\n      addTodoItem(content)\n    );\n    \n    ...\n  }\n\n  private void addTodoItem(final String content) {\n    AddTodoItemRequest request = new AddTodoItemRequest(content);\n    final ResponseEntity&lt;String&gt; entity =\n            restTemplate.postForEntity(&quot;http://localhost:8080/todo-items&quot;, request, String.class);\n    ...\n  }\n}\n</code></pre><p>既然步骤定义是 Gherkin 文件与具体实现之间的胶水，所以，理解步骤定义的关键就是知道它是如何将二者关联起来的。在这段代码中，Given 就是这样的连接点。对比一下我们就会发现， Given 里面的参数就是我们在前面 Gherkin 文件中的描述，不同的点是，这里把其中的一部分变成了参数。由此我们可以知道，<strong>对于同样一个描述，可以根据用例的差异，采用不同的参数。</strong></p><p>如果说 Gherkin 语言部分几乎在各种 BDD 框架之间是通用的，那步骤定义部分则是框架强相关。这里我们采用 Cucumber Java 8 的方式进行了步骤定义，也就是采用 Given 方法进行定义，如果你去看其它的资料，也会看到基于 Annotation 的定义，这就是选择不同依赖程序库的结果。</p><p>到了具体的实现上，程序员就很有底气了。在这里我们根据业务动作进行相应的处理。在上面这段代码中，添加 Todo 项就是向自己编写的服务发出了一个 POST 请求。</p><p>这些东西理解起来都很容易，唯一需要稍微注意一点的是，给 Then 编写代码时，因为它是表示断言的，在这个部分我们一定要写出断言，比如像下面这样。</p><pre><code>Then(&quot;todo item {string} should be contained&quot;, (String content) -&gt; {\n    assertThat(Arrays.stream(responses)\n            .anyMatch(item -&gt; item.getContent().equals(content))).isTrue();\n});\n</code></pre><p>上面这段代码的更多细节实现，你可以去参考我们的<a href="https://github.com/dreamhead/geektime-todo">实战项目</a>。</p><h2>实战中的 BDD</h2><p>现在我们已经有了对 BDD 的初步了解，接下来，我们就来看看在实际的项目中可以怎样使用 BDD。</p><p>前面我们已经知道了，Gherkin 语言是面向业务人员的。不同于写代码我们只能用英文，Gherkin 在设计时就考虑到了业务人员的实际需要，所以它的设计本身是本地化的。我们甚至可以用中文编写测试用例，下面就是一个登录的测试用例。</p><pre><code>假定 张三是一个注册用户，其用户名密码是分别是 zhangsan 和 zspassword\n当 在用户名输入框里输入 zhangsan，在密码输入框里输入 zspassword\n并且 点击登录\n那么 张三将登录成功\n</code></pre><p>这个用例怎么样呢？或许你会说，这个用例写得挺好。如果你这么想，说明你是站在程序员的视角。我在前面已经说过了，BDD 需要站在业务的角度，而这个例子完全是站在实现的角度。如果登录方式有所调整，用户输完用户名密码自动登录，不需要点击，那这个用例是不是需要改呢？下面我换了一种方式描述，你再感受一下。</p><pre><code>假定 张三是一个注册用户，其用户名密码是分别是 zhangsan 和 zspassword\n当 用户以用户名 zhangsan 和密码 zspassword 登录\n那么 张三将登录成功\n</code></pre><p>这是一个站在业务视角的描述，除非做业务的调整，不用用户名密码登录了，否则这个用例不需要改变。即便实现的具体方式调整了，需要改变的也是具体的步骤定义。所以，<strong>想写好 BDD 的测试用例，关键点在用业务视角描述。</strong></p><p>既然 BDD 的用例更多偏向业务视角，所以在真实的项目中使用它时，我们更多偏向于把它当做验收测试的工具来用。这里就会有一个我们常常忽略的点：业务测试的模型。很多人的第一直觉是，一个测试要啥模型？</p><p>既然 BDD 更多的使用场景是复杂的验收场景，所以，相应地我们也要为测试场景进行建模。还记得我们讲好测试应该具备的属性吗？其中一点就是专业性。对于复杂场景而言，想要写好测试同写好代码是一样的，一个好的模型是不可或缺的。</p><p>这方面一个可以作为参考的例子是做 Web 测试常用的一个模型：<a href="https://martinfowler.com/bliki/PageObject.html">Page Object</a>。它把对页面的访问封装了起来，即便你在写的是步骤定义，你也不应该在代码中直接操作 HTML 元素，而是应该访问不同的页面对象。</p><p>以前面的登录为例，我们可能会定义这样的页面对象。</p><pre><code>public class LoginPage {\n    public boolean login(String name, String password) {\n      ...\n    }\n}\n</code></pre><p>如此一来，在步骤定义中，你就不必关心具体怎么定位到输入框会让代码的抽象程度得到提升。当然这只是一个参考，面对你自己的应用时，你要考虑构建自己的业务测试模型。</p><h2>BDD 的延伸</h2><p>最后，我们再来说说  BDD 的一些延伸。从上面的内容我们可以知道，BDD 的用例和普通测试的用例只是在表述方式上有所差异，从结构上看，二者几乎是完全等价的。所以，只要你想，完全可以采用 BDD 的方式进行从单元测试到系统测试所有类型的测试。</p><p>所以我们会看到，在行业里还有一些 BDD 风格的单元测试框架，其中最典型的就是 RSpec。我从 RSpec 的文档上截取了一段代码，你可以感受一下。</p><pre><code>RSpec.describe Order do\n  it &quot;sums the prices of its line items&quot; do\n    order = Order.new\n    order.add_entry(LineItem.new(:item =&gt; Item.new(\n      :price =&gt; Money.new(1.11, :USD)\n    )))\n    order.add_entry(LineItem.new(:item =&gt; Item.new(\n      :price =&gt; Money.new(2.22, :USD),\n      :quantity =&gt; 2\n    )))\n    expect(order.total).to eq(Money.new(5.55, :USD))\n  end\nend\n</code></pre><p>其实，它与前面的 Cucumber 用例还是有很大差异的，因为它属于单元测试的范畴，所以没有像 Gherkin 部分那种面向于业务人员的描述。但同时你也能看到，它同传统的 xUnit 框架有着很大的不同，主要是框架本身会引导你写出更具描述性的代码。</p><p>BDD 的另外一个延伸方向是对需求进行文档化的表述。既然 BDD 是在朝着业务方向靠近，争取让业务人员能够很好地理解这些测试用例，那从本质上来说，它就起到了文档的作用，这个文档和真实实现是紧密相关的，是一种“活”文档（Living Document）。活文档指的是持续更新的文档，这个概念本身不局限于技术领域。Cucumber 本身有对<a href="https://cucumber.io/living-documentation/">活文档的支持</a>，它可以与 JIRA 去集成，可以直接把 Cucumber 测试用例变成文档。</p><p>既然要写文档，那就不局限于是否采用 BDD 这样的格式，所以，还出现了像 <a href="https://concordion.org/">Concordion</a> 这样的工具，甚至可以让我们把验收用例写成一个完整的参考文档。最开始它支持用 HTML 的方式写文档，现在也支持<a href="https://concordion.org/tutorial/java/markdown/">用 Markdown 的方式</a>来编写文档。</p><p>无论是 BDD 也好，活文档也罢，它们背后还有一个概念，叫做<a href="https://en.wikipedia.org/wiki/Specification_by_example">实例化需求</a>（Specification by Example，SbE），也就是用实例的方式对需求进行阐述，你可以看到 BDD 和活文档就是通过这种方式在将需求表现出来。</p><p>总之，如果你对这个方向有兴趣，前面还是有很多东西可以探索。总的来说，它就是让技术团队不再局限于技术本身，更加贴近业务，这和整个行业的发展趋势是高度吻合的。</p><h2>总结时刻</h2><p>这一讲，我们讲了 BDD，也就是行为驱动开发。这种思想是站在 xUnit 的框架基础之上，让测试用例的表达更贴近业务行为。</p><p>我用 Cucumber 这个今天最为流行的 BDD 框架给你介绍了如何编写测试用例，你只要记住 “Given…When…Then” 的格式，就算抓住了 Gherkin 语言表述的核心。</p><p>在实际的项目中使用 BDD  我们可以采用本地化的表述方式，不过，重点是要让测试用例贴近业务而非实现细节。一般来说，BDD 多用于验收测试，所以相应地，我们在编写步骤定义时，对于复杂业务可以考虑构建业务测试模型，对实现细节进行封装。</p><p>最后，我们还谈到了 BDD 的延伸，无论是 BDD 风格的单元测试框架，还是活文档、实例化需求，这些都是你可以进一步探索的东西。</p><p>如果今天的内容你只能记住一件事，那请记住：<strong>技术团队要更加贴近业务。</strong></p><h2>思考题</h2><p>今天我们讨论的 BDD 更多是用在验收测试中的，你的团队是怎么做验收测试呢？欢迎在留言区分享你的经验。</p>',
        article_title: "18 | BDD 是什么东西？",
      },
    ],
  },
  {
    chapterTitle: "加餐",
    children: [
      {
        title: "答疑解惑 | 那些东西怎么测？",
        id: 418338,
        content:
          '<p>你好，我是郑晔！</p><p>到现在，《程序员的测试课》的正文内容我已经全部交付给你了。在专栏上线这段时间里，感谢你的一路相伴。有不少同学在专栏的问了一些非常典型的问题，引发了我的一些思考。所以，我准备了这期加餐，把我的这些延伸思考分享给你。</p><h2>实战项目</h2><p>这个专栏是我第一次用完整实战的方式给你演示如何做一个项目。秉承我写专栏一贯的特点，我写实战的重点是做事情的思路，而非具体的源码。</p><h3>程序设计语言</h3><p>不过，只要涉及具体的代码，就会有各种问题产生。最典型的问题就是，在实战中我采用了Java，有一些擅长其他语言的同学会问到我能不能提供其他语言的版本。</p><p>首先，我必须向这些同学说声抱歉，因为时间和能力有限，我没法提供各种程序设计语言的实现版本。这个ToDo 应用原本是《代码之丑》中的<a href="https://time.geekbang.org/column/article/325594">练习题</a>，在那一讲里，同学们给出了很多不同的实现，有各种语言的版本，如果你有兴趣不妨去看看留言区里其他同学是怎么实现的。</p><p>当然，这个问题本身并不复杂，最好是你自己实现一遍，然后再对比我的实现过程，看看有哪些有差异的地方。<strong>编程这件事，讲道理远远不如动手实践来得感受更深刻。</strong>至于我写的代码本身，重要性没有那么强，只是一个参考。</p><p>之所以采用 Java 语言，一方面是因为它受众极广，另一方面更重要的是，Java 语言在工程上的能力非常好。无论是各种工具和框架还是工程实践上，Java 社区往往是走在整个行业的前列。</p><!-- [[[read_end]]] --><p>写这个专栏的时候，我已经尝试尽量降低理解的难度，把解决问题的过程和使用的工具尽量做到通用，尤其是前两讲的中用到的。即便你用的是其他程序设计语言，也可以找到对应的解决方案，比如命令行解析的框架、覆盖率检查的工具、构建工具等等。<strong>我们学习任何一门语言，要学的内容都不应局限于语言本身，还应该学习这个语言相关的生态。</strong>所以，如果你使用的是其它语言，却不知道我提到的这些东西，不妨借着这个机会，给自己补充一下。</p><p>不过，像 Spring 这种框架不是每个语言都有的，严格地说，Spring 已经超过了框架的范畴，它已经是一个完整的生态了。</p><p><strong>关于程序设计语言，我一贯的建议就是多学几门，千万别局限在某一门语言里。</strong>所以，如果你擅长的是其它语言，可以借这个机会了解一下 Java 程序是怎么写的。</p><h3>程序库</h3><p>除了程序设计语言，还有一类问题是关于其它程序库的，也就是借着实战的项目做了一下延展，比如使用了某某程序库的程序该怎么测。</p><p>其实这个问题我在集成测试里已经说过了，首先要有一个单独的防腐层，将第三方代码隔离开，先保证逻辑的正确，再来看第三方程序库。与第三方程序库的集成，能测就尽量测，不能测就只能靠更高层的测试来覆盖了。</p><p>其实，现在很多的程序库或是中间件都有自己对于测试的支持，一种简单的方案就是用要集成的东西加上 Mock 作为关键字去搜索，比如  Mock Kafka、Mock Dubbo 等，如果你运气好的话，会得到相应的答案，剩下就是阅读文档的工作了。</p><p>有一些地方是我在写专栏的过程中没注意到的，可能会给你造成困扰。比如我用到 Lombok 这个程序库，它会替我们生成一些代码，节省编码的工作量，没用过 Lombok 的同学看到这样的代码可能会有些懵。</p><p>说到 Lombok，我再多补充一点。在测试的过程中，有一些典型的样板代码是让人很难受的，比如  getter、equals、hashCode、toString，这种代码不写，行为不对；写，就会有测试覆盖率的问题。给这些方法写测试是非常麻烦的一件事，这里的麻烦就是单纯的麻烦，实现细节是标准的，写的测试也几乎长一个模样。</p><p>所以在实际的项目中，我现在常常会采用 Lombok 这个程序库，它会替我生成这些标准的方法，就像下面这样。</p><pre><code>@EqualsAndHashCode\n@Getter\n@ToString\n@NoArgsConstructor(access = AccessLevel.PRIVATE)\npublic class TodoItem {\n  ...\n}\n</code></pre><p>我们只要在相应的位置加上 Annotation，在编译的过程中，Lombok 就会替我们生成相应的代码。所以，虽然我没有一行一行地把代码写出来，但我们依然可以在程序中使用相应的方法。这就是一个好的程序库价值所在，它可以极大地简化代码的编写。</p><p>这些方法是生成的，而不是我们手工编写的，所以，我们也没有必要去检查这些方法是否正确，在执行测试覆盖率检查时，我们可以忽略掉这些方法。Lombok 和 Jacoco 之间已经有了这种默契，所以，你会在 Lombok 的配置文件 lombok.config 看到下面这样一句。</p><pre><code>lombok.addLombokGeneratedAnnotation = true\n</code></pre><p>它会给生成的方法加上一个 Annotation，Jacoco 看到了这个 Annotation 就会知道它是一个生成的方法，进而在测试覆盖的统计中忽略掉它。</p><h2>那些东西怎么测？</h2><p>还有一类的问题相对来说就很宽泛了，比如有人问怎么测试大数据模型的正确性。要回答这个问题，我们要先看看自动化测试究竟能解决什么问题。</p><p>首先，我们需要明确一点，程序员在日常开发中写测试除了我们之前说过的种种原因之外，还有一点就是为我们的开发保驾护航，这些测试要能够时时刻刻起到警戒线的作用。这种测试写出来要常常跑的，而不是束之高阁。所以，它还有一个好搭档就是持续集成。多说一句，只有做好了自动化测试，持续集成才能发挥出它最大的价值。</p><p>有了前面的理解，我们再来看哪些东西能起到这样的作用：那些能够让人形成稳定预期的东西。我们前面写的各种测试，都是能够有稳定预期的，这也是我们说测试一定要有断言的重要原因。</p><p>回过头来看前面的问题。大数据模型这种东西，你能有稳定的预期吗？你或许会说，我希望得到一个好的结果，然而，这样说法一点都不具体，什么叫好的结果呢？这就像我希望身体健康一样，这只是美好的愿望，它并不会因为我们“希望”了，它就能够实现出来。对于这种你连用语言都无法描述的东西，就不要指望用测试描述了。</p><p><strong>其实，你真正关心的不是模型的正确性，而且它的效用</strong>，也就是说，它到底有什么用。</p><p>效用这种东西，我们没有办法对它形成稳定的预期。举个例子，你说 100 万多吗？对大部分普通人来说，这已经是很大一笔钱了，但对于世界首富来说，这笔钱就不算多了。所以，同样是得到 100 万，对不同的人来说，效用完全不同。即便是对同一个人，当他人生处于不同的阶段，这笔钱对他来说意义也是完全不同的。</p><p>效用甚至都很难达成共识，那就更别说预期了，所以，大数据模型不是靠自动化测试能解决的。类似的东西还有很多，比如用户界面好不好看、软件的体验好不好，这些东西都属于效用。</p><p>那效用的东西就不能测了吗？也能，只不过，不是自动化测试。严格地说，<strong>效用的好坏要依赖于反馈</strong>。数据模型的有效性要靠业务来反馈，软件的好用还是好看要靠用户来反馈。</p><p>在软件开发的实践中有一种实践叫用户测试，简单说就是让用户参与到软件开发的过程中。还有一种实践叫 A/B 测试，就是把不同的东西给不同的用户看，把用户行为当作下一步决策的基础。你会发现，无论是哪种做法都不是靠简单的自动化测试能够覆盖的，因为这个过程中要有人的参与，人会根据反馈回来的信息进行判断。</p><p>既然这些依赖于人的测试不好自动化，是不是技术类的就都可以了呢？比如有人问，性能测试能不能放到程序员的测试里？</p><p>性能测试是一种可以用技术覆盖的测试，现在有很多程序库支持我们进行性能测试，比如  <a href="https://github.com/openjdk/jmh">JMH</a>、<a href="https://gatling.io/">Gatling</a> 等等。大到系统，小到单元，都可以使用性能测试进行覆盖。也正是这些程序库的存在，让我们可以通过代码来写性能测试，也让性能测试用测试框架覆盖成为可能。</p><p>不过，有一点我必须提醒你，性能测试最难处理的是断言怎么写。你或许会说，不就是和其他测试一样写吗？不尽然。</p><p>有很多团队开发用的是 Windows 或者是 Mac，而实际的项目是在 Linux 运行。我们知道，性能这个东西在不同的机器上跑出来的结果差异很大。即便是同一台机器，因为负载的差异，跑出来的结果也会有很大差异。所以，我们很难写出一个放在所有环境上都可用的断言。</p><p>从实践的角度上看，我不会把性能测试归到程序员的测试范畴。当然，如果你愿意用单元测试框架去写一个自动化性能测试，也是可以的，但请把它同其他测试隔离开来，其他的测试要在持续集成的全过程中运行，而这种自动化性能测试只在单一的机器上运行，比如持续集成服务器，这样做至少可以保证前后运行的结果不会因为机器原因产生很大的差异。</p><p>测试固然有用，但它不是万能的。作为程序员，我们只有<strong>分辨清楚自己面对的究竟是什么问题，才能使用相应的工具去解决问题。</strong></p><h2>思考题</h2><p>关于程序员的测试，你还有哪些问题或者哪些经验可以分享吗？欢迎在留言区分享你的思考。</p>',
        article_title: "答疑解惑 | 那些东西怎么测？",
      },
    ],
  },
  {
    chapterTitle: "结束语",
    children: [
      {
        title: "结束语 | 对代码的信心要从测试里来",
        id: 419178,
        content:
          '<p>你好，我是郑晔！</p><p>《程序员的测试课》到这里已经接近尾声了，经过整个专栏的学习，相信你对“程序员该如何做测试”这件事已经有了一个更加完整的认识。这一讲我们不去深入技术细节，我想先从一本书和你聊起。</p><h2>无知之错和无能之错</h2><p>这本书叫《清单革命》，作者是阿图·葛文德，他是一名医生，曾是白宫最年轻的健康政策顾问。在书的开篇作者提到，人类的错误可以分为两大类型。第一类是“无知之错”，我们犯错是因为没有掌握相关知识。第二类是“无能之错”，我们犯错并非因为没有掌握相关知识，而是因为没有正确使用这些知识。无知之错，可以原谅，无能之错，不可原谅。</p><p>在作者看来，目前这个世界上还有很多疾病没有很好的治疗方案，这个算是无知之错。但在真实世界中，很多治疗的失败却是因为医疗团队没有做好该做的事，那就属于无能之错了。</p><p>这个分类方式给了我很大的震撼，让我一下子想明白很多事。<strong>有了分类，针对不同的错误，我们可以采用不同的修正方式。</strong>无知之错，因为欠缺的是知识，所以如果要修正这类错误，需要补充相关的知识。而无能之错并非知识的欠缺，所以，要修正这类错误，需要改进的是工作的方法和流程。</p><p>身为程序员，我们是幸运的，我们生活在一个对软件有巨大需求的时代。但实事求是地说，软件也是各种问题的高发地带，我们在其中不停犯着各种错误，很多甚至是低级错误。</p><!-- [[[read_end]]] --><p>这些错误应该归为哪种类型的错误呢？</p><p>在外人看来，软件开发团队就应该有做好软件的能力，没做好肯定就是各种疏忽造成，这种错误是一种无能之错，要解决无能之错，显然就应该从改进工作方法和流程入手。于是，我们看到很多公司一旦觉得自己的公司需要提升软件质量了，首先是引入一套新的流程，无论是拼命写文档，还是引入专人负责。然而结果是软件团队疲于应付各种流程，软件的实际质量却并未得到有效改善。虽然初衷是好的，但因为诊断错了病因，用错了药方，治不好病也就在所难免了。</p><p><strong>软件质量的病不在外部，而在内部。</strong>一个没有质量意识的团队只靠外部的推动很难做出高质量软件，这就像一个孩子如果仅仅靠家长的逼迫很难取得长期的好成绩一样。然而，软件质量靠流程却成了行业中的常态，不得不说，这是一个悲哀的结果。孩子想取得好成绩，归根结底是要有自己对学习的热爱，同样，软件质量要想得到真正的提升，要将做到内建质量（Build Quality In）。</p><h2>内建质量</h2><p><strong>内建质量，就是将质量的思考内建于软件开发的全生命周期中</strong>。</p><p>说起来很简单，然而，产品经理一拍脑袋，程序员拼命加班，把一个漏洞百出的软件送到了测试人员手里。然后，在业务强大的压力之下，测试人员闭着眼睛，把一个质量不彰的软件送上了线。每个环节都在放水，结果就是水漫金山。线上系统问题不断，新的需求接踵而来，团队疲惫不堪。然而，没有人真正地想问题到底出在哪里。这才是很多团队的真实情况。</p><p>在这样的团队中，质量只是测试人员的事，相当于把整个团队的责任压在了少数人的头上，线上出问题就是情理之中的事了。内建质量就是要把软件开发中的每一个环节都加入质量的考虑：</p><ul>\n<li>业务负责人不能只要求上线日期，也要给出需求验证的业务目标和业务的验收标准；</li>\n<li>产品经理不只是要给出产品说明，更要给出每个需求点的验收标准；</li>\n<li>程序员不只给出代码，还要给出覆盖每行代码的自动化测试。</li>\n</ul><p>所谓内建质量，本质上就是用任务分解的方式，让每个环节都交付满足一定质量标准的交付物。其实，现在软件行业已经懂得了用迭代交付替代瀑布式交付，把大的需求拆分为小需求的集合，逐步交付给市场，尽早收集反馈，避免走过多的弯路。而内建质量则是通过在每个环节中加入对质量的思考，在每一个环节都要验证交付物是否符合目标，尽早发现问题。这样才不至于让测试人员成为最后的防洪堤坝，才不至于把大招憋成内伤，才有可能拿出一个高质量的软件。</p><p>在软件研发的环节加入质量的思考，对很多人来说，是一件有难度的事。因为在他们看来，这么做是增加了工作量。比如很多程序员会说“写测试就是浪费时间”。然而，真的是这样吗？</p><p>一个内建质量的团队，可以在工作的诸多环节规避掉很多问题。从软件生命周期的角度看，规避了这些问题可以从整体上节省时间。虽然很多人学过软件工程的基本理论，但这种东西实在太反直觉，就像不相信 0.99… = 1，也有很多人不相信前期的投入会给团队带来长期的回报。</p><p>但这种不相信其实更多是一种不愿意相信，因为相信了就意味着要做出改变，而改变才是很多人真正惧怕的。是的，<strong>很多人真正的不愿意是“改变”这件事。</strong>正是因为有太多的人不愿意改变，才使得愿意改变的人很容易脱颖而出。</p><p>一旦你想明白了这一点，你就能理解<strong>软件研发中暴露的很多错误根本不是无能之错，而是无知之错</strong>。换言之，正是因为很多人只愿意墨守成规，所以，他们根本看不到自己其实是欠缺了一个质量的维度，而这个维度上也有着一张知识网。</p><p>把无知之错当做无能之错去解决，根本就是走错了方向，再多的流程改进也不会让人学会写测试。因为程序员欠缺的是写测试的知识，而很少有人会意识到原来很多程序员不会写测试。解决无知之错要从知识的补充入手，而前提条件是你愿意改变。</p><h2>简单的代码</h2><p>感谢你一路学到这里，我相信你是愿意改变的。现在你已经具备了改变所需的基础知识，相比于还在努力改变流程的人，你已经领先了很多。对你来说，接下来要做的是花更多的时间来练习，并在练习的过程中发现自己欠缺的知识，进行相应的补充。</p><p>《程序员的测试课》虽然给了你一个写好测试的知识结构，但估计你也发现了，其实写好测试要具备的知识储备并不小，就像我在形容 TDD 所说：</p><blockquote>\n<p>TDD 只是冰山一角，露在海面之上的是 TDD 的节奏，而藏在海面下的是任务分解、软件设计这些需要一定时间积累的能力。</p>\n</blockquote><p>同样，写出来的测试也是冰山一角，背后是那些需要时间积累的能力。但是，不要被这些东西吓到。其实，你在实战中已经见识过了，我写的代码很简单。有人会认为，这是一个演示的例子，所以写出来会很简单。但实际上，我在真实项目中也是这么写代码的，只不过业务逻辑更复杂一些。是的，<strong>业务逻辑复杂和代码复杂是两回事</strong>。不管业务逻辑多复杂，代码都可以写得清晰而简洁。只有那些写得不好的代码才是复杂的，会有着各种各样奇怪的写法。</p><p><strong>优秀的代码平平无奇，糟糕的代码千奇百怪。</strong></p><p>随着经验的丰富，我越能理解简单的价值，能坚持把代码写简单是一种能力。这需要我们不仅要有把代码写简单的意识，还要有把代码写简单的能力。好消息是，简单的代码也是容易写测试的代码，无论后续添加新功能还是修改已有的问题，难度都会下降很多，所以，它也是高质量的代码。</p><p>你只要不断地用测试作为一把尺子衡量你写的代码，你的代码质量就会越来越高。当你不知道该怎么办时，不妨回到专栏里，看看我们在专栏里是怎样解决问题的：把问题还原到简单的情形，再去想办法解决。<strong>化繁为简，是一个优秀程序员应该具备的品质。</strong></p><p>如果整个专栏你只能记住一件事，那请记住：<strong>写代码时问问自己，这段代码应该怎么测。</strong></p><p>在这篇结束语的末尾，我来讲个小八卦，跟你说说这个专栏是怎么来的。我在自己的公众号“郑大晔校”中写了一篇文章《<a href="https://mp.weixin.qq.com/s/pw3Be_1Zq4y65bkbww7J4g">为什么程序员大多不写测试？</a>》，说的就是程序员不会写测试这件事。在文章的最后，我说程序员没有太好的方式学习写测试。《极客时间》的主编看到这篇文章就说，既然没有，那你来写一个吧。于是，有了这个专栏，也算是我自己挖坑自己填了。</p><p>这个专栏从开始构思到上线只用了一个月的时间，创下了我写作专栏的记录。算起来，这已经是我在《极客时间》写的第四个专栏了，我能够梳理成体系的结构化思考都以专栏的形式呈现了。当然，如果你还对我零散思考有兴趣，不妨关注我的公众号“郑大晔校”。</p><p>这次的《程序员的测试课》之旅就暂告一段落了！如果以后有机会，我会再来与你分享我对软件开发的理解。</p><p>最后是我们的小福利环节，我给你留了一个有奖小问卷，希望你花两分钟来填写一下，你的反馈意见对我来说很重要，我会根据你的意见持续维护这个专栏。</p><p>再见！</p><p><a href="https://jinshuju.net/f/UUBFn8"><img src="https://static001.geekbang.org/resource/image/e0/05/e0d3e8a30b0a11ffee7d26c3e70b6505.jpg?wh=1142x801" alt=""></a></p>',
        article_title: "结束语 | 对代码的信心要从测试里来",
      },
    ],
  },
];
