exports.category = "frontend";
exports.title = "玩转Vue3全家桶";
exports.data = [
  {
    chapterTitle: "开篇词",
    children: [
      {
        title: "开篇词 | 如何借助Vue 3建构你的前端知识体系？",
        id: 427605,
        content:
          '<p>你好，我是盛鑫晶，网名大圣。</p><p>先简单介绍一下我自己，我曾经就职于百度和360，最近几年从前端架构师转型做IT教育，现在是一名自由职业者。我也喜欢混迹开源社区，同时也是Vue 3 的Contributor和组件库Element3的作者。</p><p>也许你和我一样，也不是计算机科班出身。我大学毕业那会在仓库做物流，偶然接触了编程，后来才转行。从小公司业务的增删改查，到百度地图和百度糯米的规模化项目，前端的交互越来越复杂。我也经历了从纯前端到大前端的发展，可以说是赶上了前端的黄金时代。</p><p>可以说，程序员从入门到进阶路上所有要做的事，我都亲身经历过，当然也走了不少弯路，全流程我大概花了4年多的时间（这段经历你可以围观我的B站：<a href="https://www.bilibili.com/video/BV1cV411Y77T/">非科班前端老司机从2K到40K之路</a>）。<strong>所以，我能深刻地意识到，现在很多前端工程师进阶困难的痛点就是，没有体系化的学习</strong>。</p><p>2021年的前端范畴已经今非昔比，从最早的做页面，到现在的工程化、监控、跨端，薪资水涨船高的同时，也对从业者提出了更高的要求：不能只会做页面，而是要全面地拥抱计算机知识体系，比如算法、设计模式、编译原理等计算机专业知识，这也是现在各大厂面试的主要考察点。</p><p>对于这些考察点，只有一小部分面试者有过系统的学习，大部分面试者都只是零散地学习过其中的某些内容，也就是说前端这个岗位的断层其实非常严重。由于大学计算机专业不教系统性的前端开发课程，所以大部分前端工程师都跟我一样，是由兴趣和爱好驱动。</p><!-- [[[read_end]]] --><p>但如果没有系统性的学习，那就像武侠小说里写的那样，你自己顿悟了很久，最后悟出一套少林长拳，结果最后发现大厂少林寺入门就教这个了。</p><p><strong>为了防止你的顿悟仅仅相当于别人的基础水平</strong>，我们需要体系化和系统化地探索前端开发这座冰山。这就意味着，我们学习的不仅仅是表面的增删改查，而是底层的工程化、框架，还有海底的计算机知识体系。</p><p>但是对于非科班的小老弟来说，专业教材过于晦涩和难懂，直接啃是一件很难的事情。我写这个专栏的目的，就是想通过Vue这个框架，让你以一个渐进的方式去进阶前端开发。</p><p>说白了，能坚持读完《算法导论》的人太少了，但是大部分人都可以很开心地玩王者荣耀。王者也是一个很复杂的游戏，但它给了玩家一个渐进式的学习机制。所以，这个专栏也会提供给你一条渐进式打怪升级的学习之路。</p><h2>为什么要学Vue 3</h2><p>在目前的前端开发中，流行的框架相信你并不陌生。它们的目标都是为了帮助开发者高效地开发Web应用，只不过走的路线略显不同，比如React注重数据不可变、虚拟DOM和运行时；而Svelte运行时都非常轻量级，侧重在于编译时的优化；Angular则在抽象这个维度又走向一个极致，生来就是为了复杂项目。</p><p>每个流行框架的内部，都有一大堆的最佳实践。而相比之下，Vue就简单多了，简单到大部分前端开发者都能学得会。Vue在每个维度之间，做了非常好的权衡和取舍，算是一个非常中庸且优雅的框架，兼顾响应式、虚拟DOM、运行时和编译优化。</p><p>而且Vue 3作为Vue框架最新的版本，有很多优秀的设计相信你会非常喜欢，例如Composition组合API、基于Proxy的响应式系统、自定义渲染器等。</p><p>这些设计可以让我们以很轻松的方式，从最熟悉的框架逐渐深入底层。学习Vue 3的同时，我们就可以去回顾Vue 1和Vue 2，直观地感受Vue框架发展的过程。<strong>在此基础上，我们再去横向对比Angular、React、Svelte等框架，最终是可以把学到的知识点串成一个网络的。这不仅是加强记忆那么简单，还能大大开阔你的前端视野</strong>。</p><p><img src="https://static001.geekbang.org/resource/image/0a/be/0acf4884eccd8266a016c555651a09be.jpg?wh=6000x3000" alt=""></p><h2>如何学习Vue 3</h2><p>既然我们已经锚定了Vue 3这个出发点，那么该如何学习它呢？</p><p>Vue 3已经是上手最简单的框架了，如果你没有Vue 2的经验，可以直接走Vite+Option先熟悉模板的语法，把官网的入门教程先走一遍，然后再去研究Vue 3的新特性。</p><p>不过，如果你没有Vue 2的经验，或者Vue基础比较薄弱，也不用害怕，你可以跟着我的脚步，往下学<a href="http://time.geekbang.org/column/article/428106">《上手：一个清单应用帮你入门Vue.js》</a>这一讲。在这里，即便你不熟悉Vue，也能先体验一把Vue。</p><p>而如果你已经是Vue 2的开发者，那么上手Vue 3就更简单了，直接去熟悉Composition API的新语法就可以了，我们专栏中的项目也会主要用Composition API来组织。</p><p>入门以后，我们就可以正式探索冰山了。但进阶之路还是要慢慢走，我们会逐步补齐要学习的下面这些版块的内容，从而帮你构建出一个完整的前端知识体系。</p><p><img src="https://static001.geekbang.org/resource/image/b8/95/b8fa99b00f432b7df6d3a292ec0a8095.jpg?wh=1624x1306" alt=""></p><h2>课程设计</h2><p>我希望这门课能帮助你从闷头的增删改查中走出来，去深入了解前端框架的设计原理、内部算法和设计模式，以及编译原理这些遥远的专业知识在前端的实际应用。</p><p>和上面给出的知识板块图类似，我们的课程也是按照这样的思路进行篇章划分。</p><p><strong>课程导读篇</strong></p><p>这一篇是整门课程的前置环节，我会从前端框架的发展史出发，和你聊聊为什么要学Vue 3；接着，我会带你体验一个上手 Vue 3 的小应用；之后，我会带你初步了解 Vue 3 的新特性，以及如何升级到 Vue 3。借助这些内容，希望能为你下面正式学习 Vue 3 做好铺垫。</p><p><strong>基础入门篇</strong></p><p>我们会通过⼀个实例开发，把Vue 3官⽹的核⼼内容和API实现⼀下，这章学完你就可以使用Vue 3来应对简单的项目开发需求了，同样这会为你打好后续实战和进阶 Vue 3的基础。</p><p><strong>全家桶实战篇</strong></p><p>我们将主要学习Vue 3的⽣态，包括Vue-cli、Vite、Vuex、Vue-router、Devtools等生态库，以及实战开发中需要的库，比如Vue 3中集成JSX、单元测试、服务端渲染SSR。这⼀模块学完，我们就能全副武装，应对复杂的项⽬开发也就不成问题了。</p><p><strong>Vue 3 进阶开发篇</strong></p><p>在Vue 3 进阶开发篇，我主要会去讲解我们在实际开发中会遇到的各种各样的问题该如何解决，比如：如何设计⼀个通用组件库、如何动态控制页面路由、如何做性能优化、如何发布和打包…… 这⼀模块学完，我们就能实现和发布自己的组件库了，进一步加深对Vue本身的理解，这也是我们迈向架构师所必备的技能。</p><p><strong>Vue 3 ⽣态源码篇</strong></p><p>在Vue 3 生态源码篇中，为了避免把源码做成⼋股⽂，首先我会带你回顾 Vue 的发展历程，让你了解为什么 Vue 是现在这个样⼦，中间还会参考React 和 Svelte的设计和及其原理。了解完设计思想和思路后，我们逐个拆分Vue的源码包，最终实现⼀个mini 版的Vue 。</p><p>另外，提示一点，本专栏会有很多代码实现，这里我鼓励你手敲，自己实现一遍才是这个专栏最好的学习方法。不过我也知道同学们平时都很忙，所以不妨现在就在评论区立个flag吧，我们先定个小目标。</p><p><strong>最后，我想说，对于未来的前端开发，我们现在用的所有框架都有可能会过时，但是框架沉淀下来的思想会继续指导着我们的前端开发</strong>。所以，大可不必自乱阵脚，打好基础才是王道。给自己两个月的时间，沉下心来学习，我相信最终我们都能以一个相对轻松的方式跨越前端进阶的门槛，迈出职业生涯的下一步。那么，我们山顶见！</p>',
        article_title: "开篇词 | 如何借助Vue 3建构你的前端知识体系？",
      },
    ],
  },
  {
    chapterTitle: "课程导读篇",
    children: [
      {
        title: "01 | 宏观视角：从前端框架发展史聊聊为什么要学Vue 3？",
        id: 427660,
        content:
          '<p>你好，我是大圣。</p><p>今天，我们来聊一聊前端框架的发展历史。在熟悉这段历史之后，相信你能把握到 Vue 在前端框架中的地位。这样，你就会对 Vue 有一个更精准的定位，从而能够知道我们为什么要选择 Vue 框架，以及Vue的优势和它的真正价值在哪里。</p><p>同时，前端框架的发展历史可能也会让你感触很多。因为每一个上网的人，或多或少都会感觉到前端网页在这些年发生了很多的变化，这是一种切身的、直观的体会。我们都能感觉到网页在设计模式、渲染等等地方的变化，而这种种变化的背后，其实都可以放到前端框架的演变历史中来解释。</p><h2>石器时代</h2><p>谈前端框架发展史之前，我们先来简单回顾一下前端的发展历史吧。</p><ul>\n<li>1990 年，第一个 Web 浏览器诞生了。这是前端这个技术的起点，代表这一年它出生了。后面的时间里，前端圈有很多里程碑事件。</li>\n<li>1994 年，网景公司发布第一个商业浏览器 Navigator。</li>\n<li>1995 年，网景工程师 Brendan Eich 用 10 天时间设计了 JavaScript，同年微软发布了 IE 浏览器，进而掀起了浏览器大战。</li>\n<li>2002年，IE在浏览器大战中赢得胜利，IE6占有率超过96% 。</li>\n</ul><p>而前端的发展历史，又非常直观地显示在你看到的前端网页的演变历史中。整个90年代，受限于网速，网页都是静态页，显示非常单一，前端的工作大部分都只是让美工来切切图和写写HTML+CSS。也因此，在90年代，前端还处在一种萌发期的状态，前端工程师这一工种也没有明确出现。</p><!-- [[[read_end]]] --><p>再后来，后端越来越复杂，开始分层。就像在小公司里，大家啥都干，但公司规模大了之后，就要分部门，职责明确，代码也从揉在一起发展到Model，View和Controller，分别负责不同的功能。</p><p><strong>这就是后端MVC模式的盛行，让我们可以在模板里写上要展现的数据。以前的代码都是所有内容写在一起，现在就会用Model负责数据。</strong></p><p>后端渲染页面之前，会把数据库的数据显示在前端。这个时候，除了写前端代码必备的HTML、CSS和简单的JavaScript动效，我们也开始用到了JSP和Smarty，我们会写出如下这种代码：</p><pre><code class="language-xml">&lt;!DOCTYPE html&gt;\n  &lt;html&gt;\n  &lt;head&gt;\n  &lt;meta charset="utf-8"&gt;\n  &lt;title&gt;smarty test1&lt;/title&gt;\n  &lt;/head&gt;\n  &lt;body&gt;\n  它的名字叫{$name}\n  &lt;/body&gt;\n  &lt;/html&gt;\n</code></pre><p>上述代码写出来的页面，就可以直接显示后端数据库里的数据了，这也就是所谓的动态网页。动态页面使得前端本身的丰富程度大大提升。这一下子迎来了整个互联网开发的繁荣时期，但这种模式下的任何数据更新，都需要刷新整个页面，并且在带宽不足的年代，这样做会耗费不少加载网页的时间。</p><p>所以这个时代的网页主要还是以显示数据和简单的特效为主，比如当时众多的门户网站，也都没有太多的用户交互，主要就是显示后端存储的新闻。</p><p>直到2004年，Google发布了Gmail，用户可以在不刷新页面的情况下进行复杂的交互，之后，Ajax逐渐成为网页开发的技术标准，也不断地被应用于各种网站。<strong>Ajax这个技术让我们可以异步的获取数据并且刷新页面，从此前端不再受限于后端的模板，这也宣告了Web2.0时代正式到来。</strong>至此，前端工程师也正式作为一个独立工种出现。</p><h2>铁器时代</h2><p>在Gmail诞生后，虽然依然有浏览器的混战和兼容性问题，比如绑定事件不同的浏览器就要写不同的代码，但大家意识到前端也可以做出复杂应用。而jQuery的出现迅速风靡全球，一个$走天下，学会jQuery就等同于学会了前端，算是前端车同轴的时代。在这之后，前端的具体开发不再被JavaScript的兼容性问题所困扰。</p><p>那个时候 jQuery+Bootstrap一把梭，成为了前端开发领域的主流技术，前端代码内嵌在后端的项目中，写完直接发布，通篇都是如下的代码：</p><pre><code class="language-xml">$(\'#alert-btn\').on(\'click\',function(){\n  $(\'#app .input\').val(\'hi\')\n})\n</code></pre><p>那个时候写代码，就是找到某个元素，进行DOM操作，特别像铁器时代的拼刺刀，随着前端项目规模的逐渐提升，前端也需要规模化的时候，在2009年AngularJS和Node.js的诞生，也宣告前端工业革命的到来。</p><h2>工业时代</h2><p>AngularJS的诞生，引领了前端MVVM模式的潮流；Node.js的诞生，让前端有了入侵后端的能力，也加速了前端工程化的诞生。现在前端三大框架Angular、React、Vue 的发展主线，也就是从这里开始的。</p><p>所谓MVVM，就是在前端的场景下，把Controller变成了View-Model层，作为Model和View的桥梁，Model数据层和View视图层交给View-Model来同步，第二讲我们会通过一个清单应用让你熟悉MVVM开发模式和传统jQuery的开发模式的区别，这里你先留个印象就好。</p><h3>前端三大框架</h3><p>在前端MVVM模式下，不同框架的目标都是一致的，就是利用数据驱动页面，但是怎么处理数据的变化，各个框架走出了不同的路线。</p><p><img src="https://static001.geekbang.org/resource/image/b0/93/b0402b9e1b4cb22877fcffb8b43d0193.jpg?wh=1208x678" alt=""></p><p>这些框架要回答的核心问题就是，数据发生变化后，我们怎么去通知页面更新。各大框架在这个步骤上，各显神通：</p><p>Angular 1就是最老套的脏检查。所谓的脏检查，指的是Angular 1在对数据变化的检查上，遵循每次用户交互时都检查一次数据是否变化，有变化就去更新DOM这一方法。这个方法看似简单粗暴，但算是数据驱动页面早期的实现，所以一经推出，就迅速占领了MVVM市场。</p><p>后面Angular团队自断双臂，完全抛弃Angular 1，搞了一个全新的框架还叫Angular，引入了TypeScript、RxJS等新内容，虽然这些设计很优秀，但是不支持向前兼容，抛弃了老用户。这样做也伤了一大批Angular 1用户的心，包括我。这也是Angular这个优秀的框架现在在国内没有大面积推广的原因。</p><p>而Vue 1的解决方案，就是使用响应式，初始化的时候，Watcher监听了数据的每个属性，这样数据发生变化的时候，我们就能精确地知道数据的哪个key变了，去针对性修改对应的DOM即可，这一过程可以按如下方式解构：</p><p><img src="https://static001.geekbang.org/resource/image/c8/0b/c8f234a40e63dbf86809f6885714b10b.jpg?wh=2540x1441" alt=""></p><p>在上图中，左边是实际的网页内容，我们在网页中使用{{}}渲染一个变量，Vue 1就会在内容里保存一个监听器监控这个变量，我们称之为Watcher，数据有变化，watcher会收到通知去更新网页。</p><p>通俗来说，如果把网页数据看成你管理的员工，普通数据就是那种每次你都需要找到他，告诉他要怎么做的人，响应式数据就是他本身有任何变化，都会主动给你发日报告诉你的积极员工。</p><p>此外，Facebook的React团队提出了不同于上面的Angular、Vue的的解决方案，他们设计了React框架，在页面初始化的时候，在浏览器DOM之上，搞了一个叫虚拟DOM的东西，也就是用一个JavaScript对象来描述整个DOM树。我们可以很方便的通过虚拟DOM计算出变化的数据，去进行精确的修改。</p><p>我们先看React中的一段代码：</p><pre><code class="language-xml">&lt;div id = "app"&gt;\n    &lt;p class = "item"&gt;Item1&lt;/p&gt;\n    &lt;div class = "item"&gt;Item2&lt;/div&gt;\n&lt;/div&gt;\n</code></pre><p>在React中，这样一段HTML会被映射成一个JavaScript的对象进行描述。这个对象就像数据和实际DOM的一个缓存层，通过管理这个对象的变化，来减少对实际DOM的操作。</p><p>这种形式不仅让性能有个很好的保障，我们还多了一个用JSON来描述网页的工具，并且让虚拟DOM这个技术脱离了Web的限制。因为积累了这么多优势，虚拟DOM在小程序，客户端等跨端领域大放异彩。</p><p>虚拟DOM在运行的时候就是这么一个对象：</p><pre><code class="language-xml">{\n  tag: "div",\n  attrs: {\n    id: "app"\n  },\n  children: [\n    {\n      tag: "p",\n      attrs: { className: "item" },\n      children: ["Item1"]\n    },\n    {\n      tag: "div",\n      attrs: { className: "item" },\n      children: ["Item2"]\n    }\n  ]\n}\n</code></pre><p>这个对象完整地描述了DOM的树形结构，这样数据有变化的时候，我们生成一份新的虚拟DOM数据，然后再对之前的虚拟DOM进行计算，算出需要修改的DOM，再去页面进行操作。</p><p>浏览器操作DOM一直都是性能杀手，而虚拟DOM的Diff的逻辑，又能够确保尽可能少的操作DOM，这也是虚拟DOM驱动的框架性能一直比较优秀的原因之一。</p><p><img src="https://static001.geekbang.org/resource/image/b2/b4/b262c52d5c353008715003fa263403b4.jpg?wh=1970x1445" alt=""></p><h3>Vue 与 React 框架的对比</h3><p>通过上面对前端三大框架的介绍，我们不难发现 Vue 和 React 在数据发生变化后，在通知页面更新的方式上有明显的不同，通俗的来说，就是：<strong>在 Vue 框架下，如果数据变了，那框架会主动告诉你修改了哪些数据；而React的数据变化后，我们只能通过新老数据的计算 Diff来得知数据的变化</strong>。</p><p>这两个解决方案都解决了数据变化后，如何通知页面更新的问题，并且迅速地获得了很高的占有率，但是他们都碰到了性能的瓶颈：</p><ul>\n<li>对于 Vue 来说，它的一个核心就是“响应式”，也就是数据变化后，会主动通知我们。响应式数据新建Watcher监听，本身就比较损耗性能，项目大了之后每个数据都有一个watcher会影响性能。</li>\n<li>对于React的虚拟DOM的Diff计算逻辑来说，如果虚拟DOM树过于庞大，使得计算时间大于16.6ms，那么就可能会造成性能的卡顿。</li>\n</ul><p>为了解决这种性能瓶颈， Vue 和 React 走了不同的道路。</p><p>React为了突破性能瓶颈，借鉴了操作系统时间分片的概念，引入了Fiber架构。通俗来说，就是把整个虚拟DOM树微观化，变成链表，然后我们利用浏览器的空闲时间计算Diff。一旦浏览器有需求，我们可以把没计算完的任务放在一旁，把主进程控制权还给浏览器，等待浏览器下次空闲。</p><p>这种架构虽然没有减少运算量，但是巧妙地利用空闲实现计算，解决了卡顿的问题。你可以看一下我画的图解：</p><p><img src="https://static001.geekbang.org/resource/image/27/23/27dbe22e81ccc1cec8b35b4ee0a06f23.jpg?wh=2796x1564" alt=""></p><p>在上图中，左侧是一个树形结构，树形结构的Diff很难中断；右侧是把树形结构改造成了链表，遍历严格地按照子元素-&gt;兄弟元素-&gt;父元素的逻辑，随时可以中断和恢复Diff 的计算过程。</p><p>为了方便你对计算Diff的理解，我们来看下面这张图：</p><p><img src="https://static001.geekbang.org/resource/image/22/6f/22b7606230e2920584387249a83db36f.jpg?wh=2358x806" alt=""></p><p>这个图里两个虚线之间是浏览器的一帧，高性能的动画要求是60fps，也就是1秒要渲染60次，每一帧的时间就是16.6毫秒，在这16.6毫秒里，浏览器自己的渲染更新任务执行后，会有一部分的空闲时间，这段时间我们就用来计算Diff。</p><p>等到下一帧任务来了，我们就把控制权还给浏览器，让它继续去更新和渲染，等待空闲时间再继续计算，这样就不会导致卡顿。</p><p>Vue 1 的问题在于响应式数据过多，这样会带来内存占用过多的问题。所以 Vue 2 大胆引入虚拟DOM来解决响应式数据过多的问题。</p><p>这个解决方案使用虚拟DOM解决了响应式数据过多的内存占用问题，又良好地规避了React中虚拟DOM的问题， 还通过虚拟DOM给 Vue 带来了跨端的能力。看到这个解决方案的时候，我真是一拍大腿，直呼“真牛！”。</p><p><strong>响应式数据是主动推送变化，虚拟DOM是被动计算数据的Diff，一个推一个拉，它们看起来是两个方向的技术，但被 Vue 2 很好地融合在一起，采用的方式就是组件级别的划分。</strong></p><p>对于 Vue 2 来说，组件之间的变化，可以通过响应式来通知更新。组件内部的数据变化，则通过虚拟DOM去更新页面。这样就把响应式的监听器，控制在了组件级别，而虚拟DOM的量级，也控制在了组件的大小。</p><p>这个方案也体现了 Vue 一直以来坚持的中庸的设计思想。</p><p>下图左边就是一个个的组件，组件内部是没有Watcher监听器的，而是通过虚拟DOM来更新，每个组件对应一个监听器，大大减小了监听器的数量。</p><p><img src="https://static001.geekbang.org/resource/image/22/51/2237975345b4cf039a6cd733cd5be451.jpg?wh=7731x6528" alt=""></p><p>除了响应式和虚拟DOM这个维度，Vue和React还有一些理念和路线的不同，在模板的书写上，也走出了template和JSX两个路线。</p><p><img src="https://static001.geekbang.org/resource/image/66/0f/669188c294d8e306072ef4273ec2630f.png?wh=1920x635" alt="图片"></p><p>React的世界里只有JSX，最终JSX都会在Compiler那一层，也就是工程化那里编译成JS来执行，所以React最终拥有了全部JS的动态性，这也导致了React 的API一直很少，只有state、hooks、Component几个概念，主要都是JavaScript本身的语法和特性。</p><p>而 Vue 的世界默认是template，也就是语法是限定死的，比如v-if 和 v-for等语法。有了这些写法的规矩后，我们可以在上线前做很多优化。Vue 3 很优秀的一个点，就是在虚拟DOM的静态标记上做到了极致，让静态的部分越过虚拟DOM的计算，真正做到了按需更新，很好的提高了性能。</p><p><img src="https://static001.geekbang.org/resource/image/64/f9/64e0e2fd877f2d54f4dd97e3dc0b1bf9.png?wh=1334x456" alt=""></p><p>在模板的书写上，除了 Vue 和 React 走出的template和JSX两个路线，还出现了 Svelte 这种框架，没有虚拟DOM的库，直接把模板编译成原生DOM，几乎没有Runtime，所有的逻辑都在Compiler层优化，算是另外一个极致。</p><p><img src="https://static001.geekbang.org/resource/image/ba/b9/bae38yye39eyy1609260caf90271cbb9.png?wh=1920x759" alt="图片"></p><h2>总结</h2><p>了解了前端MVVM框架发展的历史和方向后，相信你脑海里已经建立起了一个前端框架发展的地图，每个框架都在探索自己的路线。后面还会涌现出更多优秀的框架，我们到时候只需要把那个框架纳入到这个地图中去理解，这样你很快就明白这个框架做了什么，而这也是很多前端大神能够快速学习一个新框架的主要原因。</p><p>浏览器的诞生让我们可以方便地显示文本和图片的内容和样式；JavaScript的出现让网页动了起来；Gmail的发布，宣告前端也可以使用Ajax异步加载技术，来进行复杂网页的开发，前端工程师这个工种也正式出现了。</p><p>随着浏览器厂商的混战，各个浏览器都有自己的特色，jQuery框架的出现统一了写法，解决了那个时代最棘手的前端问题：兼容性，极大提高了开发者的效率。</p><p>随着Angular 1的诞生，我们多了一套开发模式，就是数据驱动页面。我们甚至不再需要使用jQuery去寻找DOM，而是只关注数据的来源和修改，这也就是现在我们所处的前端时代。我们所熟悉的Vue、React、Angular和Svelte等框架，都是在数据驱动页面这个场景下涌现的框架。</p><p>相信到这里，你已经大概明白前端的这些框架的风格和特点，以及 Vue 在这些框架中的地位，Vue 3 在Vue 2 的基础之上做了全面的升级，在性能、扩展性和包的大小上，Vue3都有质的飞跃。</p><p>我已经迫不及待地想聊聊 Vue 3 到底有哪些新特性，并且强烈推荐你来学习。</p><h2>思考题</h2><p>在你看来，Vue需不需要React的Fiber呢？</p><p>欢迎在留言区分享你的思考，畅所欲言。如果你觉得今天的内容有所帮助，也欢迎你分享给你身边的朋友，邀请他一起学习。</p>',
        article_title: "01 | 宏观视角：从前端框架发展史聊聊为什么要学Vue 3？",
      },
      {
        title: "02 | 上手：一个清单应用帮你入门Vue.js",
        id: 428106,
        content:
          '<p>你好，我是大圣，欢迎进入课程导读篇的第二讲。</p><p>在上一讲中，我带你了解了前端框架的基本发展历史。在为什么要学Vue框架这个问题上，相信你现在已经有了自己的答案。那么从今天开始，我们正式进入上手学Vue 的阶段。</p><p>我们的专栏课程会通过故事的形式展开。故事的主角小圣是一名刚入行的前端工程师，在校期间学了点HTML、CSS和JavaScript，但是不太懂框架。我是他的经理，会手把手教他在Vue.js这个框架里打怪升级。</p><p>小圣在学习Vue的过程中碰到的各种问题，同样也可能是你会碰到的问题。所以，在我带着你一起解决小圣面临的问题的同时，你的很多问题也会迎刃而解。</p><p>今天是小圣第一天入职，他只知道团队的项目是用Vue.js开发的，但并不熟悉Vue的具体技术细节，所以我决定带他先做一个清单应用，先在整体上熟悉这个框架。当然了，我在这里带小圣做的清单应用，更多的是一种模拟的场景，并不需要对号入座到真实的工作场景下。毕竟在真实的工作场景下，可能小圣一进公司就上实际的项目了。</p><p>如果你已经很熟悉Vue开发了，可以直接粗略地把本讲过一遍，直奔下一讲。在那里，我会带你梳理Vue 3的新特性，相信这些新特性会让你对Vue 3产生新的期待。</p><!-- [[[read_end]]] --><h2>环境准备</h2><p>小圣领完电脑后，首先要做的是安装编辑器和浏览器，这个不用多介绍，你也能轻松地搞定。我推荐给小圣写代码的编辑器是VS Code，调试页面的浏览器是Chrome。有了VS Code和Chrome，我们就可以开始后面的工作了。</p><h2>任务分解</h2><p>如下图所示，小圣要上手开发的应用大概长这个样子：它有一个输入框，供我们输入数据；下方有一个列表，显示着所有我们要做的事情。</p><p>在输入框输入内容后，敲下回车，下面就会新增一条数据。对于每个要做的事情，你还可以用复选框标记，标记后文字就会变灰，并带有一个删除的效果，表示这件事情已经做完了。</p><p><img src="https://static001.geekbang.org/resource/image/0c/01/0c58c5219ecb61394110ccb848829c01.png?wh=1526x884" alt="图片"></p><p>清单应用虽然看起来简单，不过麻雀虽小，五脏俱全。其实不管入门哪个框架，你都可以写一个清单，来上手体验一下。</p><p>不过，由于小圣只有简单的jQuery开发经验，他在学习Vue的时候，首先要做的就是思想的转变。为什么要这么说呢？下面我们来对比看看jQuery的开发思路和Vue.js的开发思路有什么不同，看完你就会明白，我为什么说小圣在学习Vue时，首先要做的是转变思路。</p><p>比如，我们想做一个输入框，里面输入的任何数据都会在页面上同步显示。</p><p>对于这样一个前端的功能，jQuery开发的思路是：</p><ol>\n<li>先找到输入框，给输入框绑定输入事件；</li>\n<li>输入的同时，我们获取输入的值；</li>\n<li>再找到对应的html标签，更新标签的内容。</li>\n</ol><p>对应代码大概是这样的：</p><pre><code class="language-plain">&lt;div&gt;\n    &lt;h2 id="app"&gt;&lt;/h2&gt;\n    &lt;input type="text" id="todo-input"&gt;\n&lt;/div&gt;\n&lt;script src="jquery.min.js"&gt;&lt;/script&gt;\n&lt;script&gt;\n    // 找到输入框，监听输入\n    $(\'#todo-input\').on(\'input\',function(){\n        let val = $(this).val() // 获取值\n        $(\'#app\').html(val) // 找到标签，修改内容\n    })\n&lt;/script&gt;\n</code></pre><p>在实现我们想要的输入框的功能时，上述jQuery代码需要先找到输入框，然后持续监听输入，之后一直等待到输入值被获取，最后找到标签所在的前端页面位置，进行内容的修改。</p><p>上述的jQuery代码，其实是jQuery时代的开发逻辑的一个缩影。<strong>而jQuery时代的开发逻辑，就是我们先要找到目标元素，然后再进行对应的修改</strong>。</p><p>学习Vue.js，首先就要进行思想的升级，也就是说，<strong>不要再思考页面的元素怎么操作，而是要思考数据是怎么变化的</strong>。这就意味着，我们只需要操作数据，至于数据和页面的同步问题，Vue会帮我们处理。实际上，Vue让前端开发者能够专注数据本身的操作，而数据和页面的同步问题，则交由Vue来负责。这种机制正是Vue当初受到开发者青睐的一个重要原因。</p><p>对于同样的输入框需求，Vue的开发思路是：我们需要一个数据，在输入框的代码和h2标签的代码内使用。我们只需要操作数据，然后交给Vue去管理数据和页面的同步就可以了。</p><p>在Vue框架下，如果你想要页面显示一个数据，就要先在代码的data里声明数据；在输入框的代码里，使用v-model来标记输入框和数据的同步；在HTML模板里，使用两个花括号标记，来显示数据，例如{{title}}。对应代码大概是这个样子：</p><pre><code class="language-xml">&lt;div id="app"&gt;\n  &lt;h2&gt;{{title}}&lt;/h2&gt;\n  &lt;input type="text" v-model="title"&gt;\n&lt;/div&gt;\n\n&lt;script src="https://unpkg.com/vue@next"&gt;&lt;/script&gt;\n&lt;script&gt;\nconst App = {\n  data() {\n    return {\n      title: "" // 定义一个数据\n    }\n  }\n}\n// 启动应用\nVue.createApp(App).mount(\'#app\')\n&lt;/script&gt;\n</code></pre><p>从这个例子中，你就可以看到Vue在开发思路上和jQuery的不同。而我们要做的，就是逐渐习惯Vue的这种开发模式。</p><h2>清单页面的渲染</h2><p>在前端页面，我们在输入框输入数据，然后输入框下方要有一个列表，显示我们所有输入的值。按照Vue的思考方式，如果我们想实现这个功能，那么我们需要一个数组，然后使用v-for这个语法来循环渲染。</p><p>先看代码：</p><pre><code class="language-xml">&lt;div id="app"&gt;\n  &lt;h2&gt;{{title}}&lt;/h2&gt;\n  &lt;input type="text" v-model="title"&gt;\n  &lt;ul&gt;\n    &lt;li v-for="todo in todos"&gt;{{todo}}&lt;/li&gt;\n  &lt;/ul&gt;\n&lt;/div&gt;\n\n&lt;script src="https://unpkg.com/vue@next"&gt;&lt;/script&gt;\n&lt;script&gt;\nconst App = {\n  data() {\n    return {\n      title: "", // 定义一个数据\n      todos:[\'吃饭\',\'睡觉\']\n    }\n  }\n}\n// 启动应用\nVue.createApp(App).mount(\'#app\')\n&lt;/script&gt;\n</code></pre><p>看上述代码，在data中，我们再定义一个数据todos，输入一个数组。为了方便调试，我们先放两个假数据，如果我们在标签里直接写{{todos}}，就会看到显示的是一个数组，但这个不是我们想要的，我们需要的是显示一个列表。</p><p>在Vue中，只要是渲染列表，我们都是用v-for这个语法，而具体到上述代码对v-for语法的使用，也即：</p><pre><code class="language-xml">&lt;li v-for="todo in todos"&gt;{{todo}}&lt;/li&gt;\n</code></pre><p>上面这行单独抽出来的代码的意思就是：我们循环遍历todos这个数据， 每一条遍历的结果叫todo，然后把这个数据渲染出来，这样页面就能显示一个列表了。</p><p><img src="https://static001.geekbang.org/resource/image/b2/28/b2436fe52fec4a2e0b4a13dba97f1728.png?wh=874x436" alt="图片"></p><h2>处理用户交互</h2><p>在上一步中，我们主要考虑的是：实现前端页面的一个输入框，以及能显示输入值的一个列表的功能。下一步，就是让用户敲回车的时候，能够让列表新增一条。采用Vue的思维，我们需要完成以下这几个步骤：</p><ol>\n<li>监听用户的输入。在监听中，如果判断到用户的输入是回车的时候，那就执行一个函数。</li>\n<li>在执行的这个函数内部把title追加到todos最后面的位置，并且清空title。</li>\n</ol><p>那么Vue如何实现这一功能呢？我们先看实现这一功能后的完整代码：</p><pre><code class="language-xml">&lt;div id="app"&gt;\n  &lt;input type="text" v-model="title" @keydown.enter="addTodo"&gt;\n  &lt;ul&gt;\n    &lt;li v-for="todo in todos"&gt;{{todo}}&lt;/li&gt;\n  &lt;/ul&gt;\n&lt;/div&gt;\n\n&lt;script src="https://unpkg.com/vue@next"&gt;&lt;/script&gt;\n&lt;script&gt;\nconst App = {\n  data() {\n    return {\n      title: "", // 定义一个数据\n      todos:[\'吃饭\',\'睡觉\']\n    }\n  },\n  methods:{\n    addTodo(){\n      this.todos.push(this.title)\n      this.title = ""\n    }\n  }\n}\n// 启动应用\nVue.createApp(App).mount(\'#app\')\n&lt;/script&gt;\n</code></pre><p>对照上述代码，我们来看一下在Vue中，监听用户交互的方法。在Vue中，我们使用@来标记用户的交互，@click是点击，@keydown是键盘敲下，所以就像上述代码展示的那样，如果只监听回车键，那么我们就用@keydown.enter=“addTodo” 。</p><p>监听到用户的输入后，对于要执行的函数，我们新增一个methods配置。在函数内部，我们可以在this上直接读到data里的的数据，所以我们不需要考虑怎么找到标签，只需要进行如下这行潇洒的代码，就能让列表自动新增了一条， 这就是数据驱动页面的魅力。</p><pre><code class="language-xml">this.todos.push(this.title)\n</code></pre><h2>额外信息的显示</h2><p>好了，我们现在既实现了一个输入框，以及输入数据后能够新增一条数据的列表的功能，也实现了用户在输入后的交互功能。</p><p>下一步，我们想实现标记清单中某一项是否完成的功能。但这却难住了小圣同学，因为从目前的代码设计上来看，我们的输入只能是字符串格式的内容。而我们想要实现的标记功能，却是把列表中的某一项，用灰色的字体背景和中划线来标记，以此表示这一条内容是已经完成的内容。</p><p>如果我们想实现这个功能，就需要对数据结构进行一下改造，把内容的数据类型，从简单的字符串类型改为对象。</p><p>那么数据结构要怎么改造呢？我们先直接看改造数据结构后的完整代码：</p><pre><code class="language-xml">  &lt;ul&gt;\n    &lt;li v-for="todo in todos"&gt;\n      &lt;input type="checkbox" v-model="todo.done"&gt;\n      &lt;span :class="{done:todo.done}"&gt; {{todo.title}}&lt;/span&gt;\n    &lt;/li&gt;\n  &lt;/ul&gt;\n\n&lt;script&gt;\nconst App = {\n  data() {\n    return {\n      title: "", // 定义一个数据\n      todos:[\n        {title:\'吃饭\',done:false},\n        {title:\'睡觉\',done:true}\n      ]\n    }\n  },\n  methods:{\n    addTodo(){\n      this.todos.push({\n        title:this.title,\n        done:false\n      })\n      this.title = ""\n    }\n  }\n}\n&lt;/script&gt;\n\n\n\n&lt;style&gt;\n  .done{\n    color:gray;\n    text-decoration: line-through;\n  }\n&lt;/style&gt;\n</code></pre><p>结合代码，我给你理理整个的改造思路。首先，对于todos数组，除了title，还要加上一个done字段，来标记列表中的某一项内容是否完成，并且渲染的时候使用todo.title。</p><p>在前面的步骤中，对于列表中每一项，我们是用无序列来表示的。但如果我们想要在列表中实现对某些选项的同时多选，那么就需要用到复选框。对于每条信息，我们都要加一个复选框，所以我们依然使用v-model来绑定这个done字段，从而实现数据里能记录用户操作的状态。</p><p>我们还需要根据done字段来显示某一行的样式。在Vue中，冒号":" 开头的属性是用来传递数据的，这里的写法的意思就是根据todo.done来决定是否有done这个class。最后，当加上".done"的样式后，下面的左图就是我们想要的效果，而下面的右图则是涉及到".done"的相关代码：</p><p><img src="https://static001.geekbang.org/resource/image/7f/b7/7f73769e14d67yy4104404b7442809b7.png?wh=1884x910" alt="图片"></p><h2>进一步优化</h2><p>完成前面的步骤以后，现在看起来一个清单应用最基本的功能模块、用户交互、复选框功能都已经实现了。但是为了进一步提升交互，小圣还想要增加两个功能，第一个功能是：在前端页面显示的列表的最下面，显示一下列表项目中没完成的项目的比例；第二个功能是：新增一个清理的按钮，用来删掉已经标记为完成的列表中的一条或多条数据。</p><p>那么，对于要增加的第一个功能，也即如何实现在前端页面的列表的最下方，显示一下列表项目中没有完成的项目的比例呢？小圣按照学到的知识，写出了下面的代码：</p><pre><code class="language-xml">  &lt;div&gt;\n    {{todos.filter(v=&gt;!v.done).length}} \n    /\n    {{todos.length}}\n  &lt;/div&gt;\n</code></pre><p>把这段代码增加到上一步最后的完整代码中，运行代码，从下图所示的前端页面运行时状态中，我们能看到，其中显示的未完成比例的数据也没问题。</p><p><img src="https://static001.geekbang.org/resource/image/d0/97/d02a1fc75d79063f48660f4yy13dd197.png?wh=988x416" alt="图片"></p><p>不过，从上述代码实现的方式上看，代码看起来很丑且性能不好，而且需要二次计算的数据，这在我们开发的需求中很常见。此外，在模板里面写JS，看起来代码也很乱。Vue针对这种情况，设计了一个功能，也就是<strong>计算属性</strong>。</p><p>我们看一下采用Vue的计算属性实现的，能够支持二次计算的上述功能的实现代码：</p><pre><code class="language-xml">  &lt;div&gt;\n    {{active}}  / {{all}}\n  &lt;/div&gt;\n  \n&lt;script&gt;\n  computed:{\n    active(){\n      return this.todos.filter(v=&gt;!v.done).length\n    },\n    all(){\n      return this.todos.length\n    }\n  }\n&lt;/script&gt;\n</code></pre><p>从上面的代码中能看到，和之前采用往模板里写JS的办法相比，我们新增了一个属性computed。computed属性的配置，也即active和all，都是函数。这两个函数返回的计算后的值，在模板里可以直接当做数据来用，这样把JavaScript的计算逻辑依然放在了JavaScript里，避免了过于臃肿的模板。</p><p>而且computed计算属性还内置了缓存功能，如果依赖数据没变化，多次使用计算属性会直接返回缓存结果，同我们直接写在模板里相比，性能也有了提升。</p><p>计算属性不仅可以用来返回数据，有些时候我们也需要修改计算属性，比如我让小圣新增一个全选的复选框，要求如下：</p><ol>\n<li>全选框在勾选与取消勾选两个状态之间的切换，会把所有清单内的数据都同步勾选。</li>\n<li>清单内的项目如果全部选中或者取消，也会修改全选框的状态。</li>\n</ol><p>对于新增全选框的功能，需要满足上面的两个要求，所以全选框这个计算属性就有了修改的需求。这时候computed的配置就不能是函数了，要变成一个对象，分别实现get和set函数，get就是之前的返回值，set就是修改计算属性要执行的函数。</p><p>我们来看一下computed修改后的代码：</p><pre><code class="language-xml">&lt;div&gt;\n  全选&lt;input type="checkbox" v-model="allDone"&gt;\n  &lt;span&gt; {{active}}  / {{all}} &lt;/span&gt;\n&lt;/div&gt;\n\n&lt;script&gt;\ncomputed:{\n  active(){\n    return this.todos.filter(v=&gt;!v.done).length\n  },\n  all(){\n    return this.todos.length\n  },\n  allDone: {\n      get: function () {\n        return this.active === 0\n      },\n      set: function (val) {\n        this.todos.forEach(todo=&gt;{\n          todo.done = val\n        });\n      }\n  }\n}\n&lt;/script&gt;\n</code></pre><p>和没有全选框时的computed属性的配置代码相比，上面的代码新增了一个allDone的计算属性，页面中直接使用checbox绑定。在allDone的get函数里，对于allDone会返回什么值，我们只需要判断计算属性active是不是0就可以。</p><p>而set函数做到的就是，我们在修改allDone，也就是前端页面切换全选框的时候，直接遍历todos，把里面的done字段直接和allDone同步即可。</p><p>实现新增一个全选的复选框后的效果是什么样呢？我们一起来看一下：</p><p><img src="https://static001.geekbang.org/resource/image/27/cf/273d37ca7e59a40ac0d5a537203f41cf.gif?wh=542x325" alt="图片"></p><h2>条件渲染</h2><p>在上面一部分，我们增加了在前端页面的底部显示未完成比例，和增加全选框这两个功能。除此之外，我们还需要新增一个“清理”的按钮，点击之后把已完成的数据删除，功能需求很简单，但是有一个额外的要求，就是列表中没有标记为完成的某一项列表数据时，这个按钮是不显示的。</p><p>这种在特定条件下才显示，或者隐藏的需求也很常见，我们称之为条件渲染。在Vue中，我们使用v-if 来实现条件渲染。</p><p>老规矩，我们还是先看代码：</p><pre><code class="language-xml">&lt;button v-if="active&lt;all" @click="clear"&gt;清理&lt;/button&gt;\n&lt;script&gt;\n  methods:{\n    clear(){\n      this.todos = this.todos.filter(v=&gt;!v.done)\n    }\n  }\n&lt;/script&gt;\n</code></pre><p>通过上述代码，我们实现了增加一个清理按钮的功能。当active小于all的时候，我们显示清理按钮，也就是说，v-if后面的值是true的时候，显示清理按钮，false的时候不显示。“@”符号的作用，我们在前面讲到监听用户交互时，已经拿@keydown为例说明过了，这里代码中的@click的作用是绑定点击事件。</p><p>我们还可以用v-else配合v-if，当todos是空的时候，显示一条“暂无数据”的信息，具体的实现代码如下：</p><pre><code class="language-xml">  &lt;ul v-if="todos.length"&gt;\n    &lt;li v-for="todo in todos"&gt;\n      &lt;input type="checkbox" v-model="todo.done"&gt;\n      &lt;span :class="{done:todo.done}"&gt; {{todo.title}}&lt;/span&gt;\n    &lt;/li&gt;\n  &lt;/ul&gt;\n  &lt;div v-else&gt;\n    暂无数据\n  &lt;/div&gt;\n</code></pre><p>当我们实现了清理按钮的功能，并且也实现了列表为空时，能够显示“暂无数据”的信息后，我们看下清单应用的最终效果。</p><p><img src="https://static001.geekbang.org/resource/image/3c/72/3c8ddf81d6b478069d6b1dec7b605572.gif?wh=542x325" alt="图片"></p><p>这个需求并没有考虑美观性，小圣没写太多CSS，主要专注在JS的交互逻辑上。小圣这个需求做完，晚上下班的时候跟我分享了一下学习Vue的心得，你也可以在评论区分享一下你对Vue的开发的心得，我们一起交流。</p><h2>总结</h2><p>我们来总结一下小圣今天都学到了什么吧。入职第一天，小圣首先扭转了之前使用jQuery时的开发思路，并且弄明白了jQuery和Vue开发思路的区别。从寻找DOM到数据驱动，这是前端开发的一次巨大的变革，也是小圣同学的第一个挑战。</p><p>其次就是对Vue的入门使用，我带你回顾一下今天做的这个清单应用：对于这个应用，首先我们要有输入框能输入文本，并且在输入框下方循环显示清单，我们用到了v-model，v-for这些功能。这些v-开头的属性都是Vue自带写法，我们通过{{}}包裹的形式显示数据。</p><p>然后我们想在用户输入完成后敲击回车新增一条数据，这就用到@开头的几个属性，@keyup和@click都是绑定对应的交互事件。最后，通过computed，我们能对页面数据的显示进行优化。我们所需要关心的，就是数据的变化，这种思维方式会贯穿小圣的整个打怪升级之路。</p><h2>思考题</h2><p>下班前我给小圣布置一个作业，现在所有的操作状态一刷新就都没了，这个问题怎么解决呢？</p><p>欢迎在评论区一起讨论，也欢迎你把这篇文章分享给其他人，我们下一讲见。</p>',
        article_title: "02 | 上手：一个清单应用帮你入门Vue.js",
      },
      {
        title: "03 | 新特性：初探Vue 3新特性",
        id: 428904,
        content:
          '<p>你好，我是大圣。</p><p>在上一讲我们跟着小圣，通过实现一个清单应用，扭转了思路，认识到jQuery的开发思路和 Vue开发思路的区别。想要用好 Vue，首先就是专注数据本身的操作。</p><p>而我们的主人公小圣并没有满足这些内容，他跑到社区逛了一圈，想知道自己从哪个版本开始学习Vue更合适。这就引出了今天的话题：相比 Vue 2，Vue 3 的优势是什么，以及 Vue 3 到底有哪些新特性值得我们学习。</p><h2>Vue 2 的核心模块和历史遗留问题</h2><p>先看一看Vue 2。从下图你能看到，Vue 2 是一个响应式驱动的、内置虚拟DOM、组件化、用在浏览器开发，并且有一个运行时把这些模块很好地管理起来的框架。</p><p><img src="https://static001.geekbang.org/resource/image/df/a2/df099da509445a941d129eb9696935a2.jpg?wh=1661x957" alt="图片"></p><p>Vue 2 能把上面所说的这些模块很好地管理起来，看起来已经足够好了。不过事实真的如此么？聪明的你估计已经猜到了，Vue 2 还是有缺陷的，所以后面才会升级迭代。</p><p>我在下面列举了一些Vue 2 常见的缺陷，你可以对照你的实际开发经验，看看是否也遇到过这些问题：</p><p>首先从开发维护的角度看，Vue 2 是使用Flow.js来做类型校验。但现在Flow.js已经停止维护了，整个社区都在全面使用TypeScript来构建基础库，Vue团队也不例外。</p><p>然后从社区的二次开发难度来说，Vue 2 内部运行时，是直接执行浏览器API的。但这样就会在Vue 2的跨端方案中带来问题，要么直接进入 Vue 源码中，和 Vue 一起维护，比如Vue 2 中你就能见到Weex的文件夹。</p><!-- [[[read_end]]] --><p>要么是要直接改为复制一份全部Vue的代码，把浏览器API换成客户端或者小程序的。比如mpvue就是这么做的，但是Vue后续的更新就很难享受到。</p><p>最后从我们普通开发者的角度来说，<strong>Vue 2响应式并不是真正意义上的代理，而是基于Object.defineProperty() 实现的</strong>。对于Object.defineProperty() 这个API的细节，我们在后面讲源码时会讲到，现在你只需要知道这个API并不是代理，而是对某个属性进行拦截，所以有很多缺陷，比如：删除数据就无法监听，需要 $delete 等 API 辅助才能监听到。</p><p><strong>并且，Option API在组织代码较多组件的时候不易维护。</strong>对于Option API 来说，所有的methods、computed都在一个对象里配置，这对小应用来说还好。但代码超过300行的时候，新增或者修改一个功能，就需要不停地在data，methods里跳转写代码，我称之为上下反复横跳。</p><h2>从七个方面了解Vue 3新特性</h2><p>前面这些问题并不是Vue 2 有意为之，大部分是发展的过程中碰见的。Vue 3 就是继承了 Vue 2 具有的响应式、虚拟DOM，组件化等所有优秀的特点，并且全部重新设计，解决了这些历史包袱的新框架，是一个拥抱未来的前端框架。</p><p>接下来我们就来具体看看 Vue 3 新特性，我将分成7个具体方面向你展开介绍。其中，响应式系统、Composition API组合语法、新的组件和Vite是你需要重视的；自定义渲染器这方面的知识，你想用Vue开发跨端应用时会用到；如果你想对Vue源码作出贡献，RFC机制你也需要好好研究，并且得对TypeScript重构有很好的经验。</p><h3>RFC机制</h3><p>Vue 3的第一个新特性和代码无关，而是Vue团队开发的工作方式。</p><p>关于 Vue 的新语法或者新功能的讨论，都会先在GitHub上公开征求意见，邀请社区所有的人一起讨论， 你随时可以打开这个项目，我把链接放在<a href="https://github.com/vuejs/rfcs">这里</a>。Vue 3 正在讨论中的新需求，任何人都可以围观、参与讨论和尝试实现。</p><p>这个改变让Vue社区更加有活力，不管是课程后面会提到的&lt;script setup&gt;，还是 Vue 3 引入的ref API，你都可以在这个项目中看到每个需求从诞生到最终被Vue采纳的来龙去脉，这能帮助我们更好地了解Vue的发展。</p><p>Vue很长一段时间都是尤雨溪一个人维护，感慨尤雨溪战斗力的同时，社区也有很多人对Vue的稳定性提出质疑。后来尤雨溪吸纳了社区的人，并成立了Core Team。Vue 3 在此基础之上更进一步，全面拥抱社区，任何对Vue感兴趣的人都可以参与新特性的讨论。</p><p><img src="https://static001.geekbang.org/resource/image/61/68/61bb976a8165ef2e2f177d9e51c8bd68.png?wh=1534x1094" alt="图片"></p><p>RFC的引入，让Vue生态更加开放，在开发方式的新特性之外，我们搞技术的还是要回归代码，下面我来说说Vue 3 在代码层面所做的具体优化。</p><h3>响应式系统</h3><p>Vue 2 的响应式机制是基于Object.defineProperty()这个API实现的，此外，Vue还使用了Proxy，这两者看起来都像是对数据的读写进行拦截，但是defineProperty是拦截具体某个属性，Proxy才是真正的“代理”。</p><p>怎么理解这两者的区别呢？我们首先看defineProperty这个API，defineProperty的使用，要明确地写在代码里，下面是示例代码：</p><pre><code class="language-xml">Object.defineProperty(obj, \'title\', {\n&nbsp; get() {},\n&nbsp; set() {},\n})\n</code></pre><p>当项目里“读取obj.title”和“修改obj.title”的时候被defineProperty拦截，但defineProperty对不存在的属性无法拦截，所以 Vue 2 中所有数据必须要在data里声明。</p><p>而且，如果title是一个数组的时候，对数组的操作，并不会改变obj.title的指向，虽然我们可以通过拦截.push等操作实现部分功能，但是对数组的长度的修改等操作还是无法实现拦截，所以还需要额外的$set等API。</p><p>而Proxy这个API就是真正的代理了，我们先看它的用法：</p><pre><code class="language-xml">new Proxy(obj, {\n  get() { },\n  set() { },\n})\n</code></pre><p>需要注意的是，虽然 Proxy 拦截obj这个数据，但obj具体是什么属性，Proxy则不关心，统一都拦截了。而且Proxy还可以监听更多的数据格式，比如Set、Map，这是 Vue 2 做不到的。</p><p>当然，Proxy存在一些兼容性问题，这也是为什么Vue 3 不兼容IE11以下的浏览器的原因，还好现在IE用的人不多了。</p><p><strong>更重要的是，我觉得Proxy代表一种方向，就是框架会越来越多的拥抱浏览器的新特性。</strong>在Proxy普及之前，我们是没有办法完整的监听一个JavaScript对象的变化，只能使用Object.defineProperty()去实现一部分功能。</p><p>前端框架利用浏览器的新特性来完善自己，才会让前端这个生态更繁荣，抛弃旧的浏览器是早晚的事。</p><p>这里你掌握Proxy的优势就可以了，具体的使用我们后面会自己手写一个，帮助你深入理解。</p><h3>自定义渲染器</h3><p>Vue 2 内部所有的模块都是揉在一起的，这样做会导致不好扩展的问题，刚才我也提到了这一点。Vue 3 是怎么解决这个问题的呢？那就是拆包，使用最近流行的monorepo管理方式，响应式、编译和运行时全部独立了，变成下图所示的模样：</p><p><img src="https://static001.geekbang.org/resource/image/95/0c/9573fb8b18cb694fe9959b82742ecb0c.jpg?wh=1444x824" alt="图片"></p><p><strong>我们能看到，在Vue 3 的组织架构中，响应式独立了出来。</strong>而Vue 2 的响应式只服务于Vue，Vue 3 的响应式就和Vue解耦了，你甚至可以在Node.js和React中使用响应式。</p><p>渲染的逻辑也拆成了<strong>平台无关渲染逻辑</strong>和<strong>浏览器渲染API</strong>两部分 。</p><p>在这个架构下，Node的一些库，甚至React都可以依赖响应式。在任何时候，如果你希望数据被修改了之后能通知你，你都可以单独依赖Vue 3 的响应式。</p><p>那么，在你想使用Vue 3 开发小程序、开发canvas小游戏以及开发客户端的时候，就不用全部fork Vue的代码，只需要实现平台的渲染逻辑就可以。</p><p><img src="https://static001.geekbang.org/resource/image/27/f6/2742614d6d43134084835a44079313f6.jpg?wh=1920x939" alt="图片"></p><p>就像动画片《战神金刚》，五个机器人可以独立执行任务，但关键时刻，高呼一声“我来组成头部”，就可以合体，从而发挥整体的作用。Vue 3 也是一样，响应式、编译和运行时几部分组合在一起就是运行在浏览器端的Vue 3，每个模块又都可以独立扩展出新的功能。</p><h3>全部模块使用TypeScript重构</h3><p>由于小圣之前只是用JavaScript来构建他的前端项目，而JavaScript是弱类型的语言。类型系统带来的好处以后我再跟他细说，现在只是笼统地告诉他，<strong>类型系统带来了更方便的提示，并且让我们的代码能够更健壮</strong>。</p><p>我们还是结合例子来看看，在下面这段代码中，我们首先定义了name这个变量，在定义的时候标记的是一个字符串，因而后面给它赋值时，赋值为数字就会报错。</p><p>之后，我们定义一个类型 Person，里面的变量name是字符串类型，变量age是数字类型。违反这个设置的数据就报错，这在多人协同和长期维护的项目里带来的收益是巨大的，因为这样可以使错误的代码在编译阶段就被发现，从而避免程序上线运行后，可能会发生的更大的异常错误。</p><pre><code class="language-xml">let name:string = \'我是个靓仔\'\nname = 1 // 报错\ninterface Person {\n    name: string;\n    age: number;\n}\nlet me:Person = {\n  name:\'靓仔圣\',\n  age:18\n}\n\nme.age = \'整条街\' // 报错\n</code></pre><p>所以大部分开源的框架都会引入类型系统，来对JavaScript进行限制。这样做的原因，就是我们前面提到的两点：<strong>第一点是，类型系统带来了更方便的提示；第二点是，类型系统让代码更健壮</strong>。</p><p>Vue 2 那个时代基本只有两个技术选型，Facebook家的Flow.js和微软家的TypeScript。Vue 2选Flow.js没问题，但是现在Flow.js被抛弃了。Vue 3 选择了TypeScript，TypeScript官方也对使用TypeScript开发Vue 3 项目的团队也更加友好。</p><h3>Composition API 组合语法</h3><p>Composition API 是Vue 3 中我最喜欢的一个特性，我们也叫它组合API。</p><p>先举个Vue 2 中的简单例子，一个累加器，并且还有一个计算属性显示累加器乘以2的结果。</p><pre><code class="language-xml">&lt;div id="app"&gt;\n\n  &lt;h1 @click="add"&gt;{{count}} * 2 = {{double}}&lt;/h1&gt;\n&lt;/div&gt;\n&lt;script src="https://unpkg.com/vue@next"&gt;&lt;/script&gt;\n&lt;script&gt;\nlet App = {\n  data(){\n    return {\n      count:1\n    }\n  },\n  methods:{\n    add(){\n      this.count++\n    }\n  },\n  computed:{\n    double(){\n      return this.count*2\n    }\n  }\n}\nVue.createApp(App).mount(\'#app\')\n&lt;/script&gt;\n</code></pre><p>在Vue 3 中，除了上面这种这个写法，我们还可以采用下方的写法，新增一个setup配置：</p><pre><code class="language-xml">&lt;div id="app"&gt;\n  &lt;h1 @click="add"&gt;{{state.count}} * 2 = {{double}}&lt;/h1&gt;\n&lt;/div&gt;\n&lt;script src="https://unpkg.com/vue@next"&gt;&lt;/script&gt;\n&lt;script&gt;\nconst {reactive,computed} = Vue\nlet App = {\n  setup(){\n    const state = reactive({\n      count:1\n    })\n    function add(){\n      state.count++\n    }\n    const double = computed(()=&gt;state.count*2)\n    return {state,add,double}\n  }\n}\nVue.createApp(App).mount(\'#app\')\n&lt;/script&gt;\n</code></pre><p>使用Composition API后，代码看起来很烦琐，没有Vue 2 中 Options API 的写法简单好懂，但Options API的写法也有几个很严重的问题：</p><ul>\n<li>由于所有数据都挂载在this之上，因而Options API 的写法对TypeScript的类型推导很不友好，并且这样也不好做Tree-shaking清理代码。</li>\n<li>新增功能基本都得修改data、method等配置，并且代码上300行之后，会经常上下反复横跳，开发很痛苦。</li>\n<li>代码不好复用，Vue 2 的组件很难抽离通用逻辑，只能使用mixin，还会带来命名冲突的问题。</li>\n</ul><p>我们使用Composition API 后，虽然看起来烦琐了一些，但是带来了诸多好处：</p><ul>\n<li>所有API都是import 引入的（现在我们的例子还没有工程化，后续会加入）。用到的功能都import进来，对Tree-shaking很友好，我的例子里没用到功能，打包的时候会被清理掉 ，减小包的大小。</li>\n<li>不再上下反复横跳，我们可以把一个功能模块的methods、data都放在一起书写，维护更轻松。</li>\n<li>代码方便复用，可以把一个功能所有的methods、data封装在一个独立的函数里，复用代码非常容易。</li>\n<li>Composotion API 新增的return等语句，在实际项目中使用&lt;script setup&gt;特性可以清除， 我们后续项目中都会用到这样的操作。</li>\n</ul><p><strong>Composition API对我们开发Vue项目起到了巨大的帮助。</strong>下面这个示例图很好地说明了问题：每一个功能模块的代码颜色一样，左边是Options API，一个功能的代码零散的分布在data，methods等配置内，维护起来很麻烦，而右边的Compositon API就不一样了，每个功能模块都在一起维护。</p><p><img src="https://static001.geekbang.org/resource/image/a0/5f/a0010538b40e48fc5fc68b0eed2b025f.jpg?wh=3220x2046" alt=""></p><p>其实还可以更进一步，如果每个颜色块代码，我们都拆分出去一个函数，我们就会写出类似上面右侧风格的代码，每个数据来源都清晰可见，而且每个功能函数都可以在各个地方复用。对于Vue 3 采用的这种代码风格，小圣同学直呼清爽。</p><h3>新的组件</h3><p>Vue 3 还内置了Fragment、Teleport 和 Suspense三个新组件。这个倒不难，项目中用到的时候会详细剖析，现在你只需要这仨是啥就行，以及它们的用途即可：</p><ul>\n<li>Fragment: Vue 3 组件不再要求有一个唯一的根节点，清除了很多无用的占位div。</li>\n<li>Teleport: 允许组件渲染在别的元素内，主要开发弹窗组件的时候特别有用。</li>\n<li>Suspense: 异步组件，更方便开发有异步请求的组件。</li>\n</ul><h3>新一代工程化工具Vite</h3><p>Vite不在Vue 3 的代码包内，和Vue也不是强绑定，Vite的竞品是Webpack，而且按照现在的趋势看，使用率超过Webpack也是早晚的事。</p><p>Vite主要提升的是开发的体验，Webpack等工程化工具的原理，就是根据你的import依赖逻辑，形成一个依赖图，然后调用对应的处理工具，把整个项目打包后，放在内存里再启动调试。</p><p>由于要预打包，所以复杂项目的开发，启动调试环境需要3分钟都很常见，Vite就是为了解决这个时间资源的消耗问题出现的。</p><p>你可能不知道，现代浏览器已经默认支持了ES6的import语法，Vite就是基于这个原理来实现的。具体来说，在调试环境下，我们不需要全部预打包，只是把你首页依赖的文件，依次通过网络请求去获取，整个开发体验得到巨大提升，做到了复杂项目的秒级调试和热更新。</p><p>下图展示了Webpack的工作原理，Webpack要把所有路由的依赖打包后，才能开始调试。</p><p><img src="https://static001.geekbang.org/resource/image/d4/ba/d471d1f14abeaf4b091ddf5fb83e3eba.jpg?wh=1920x913" alt="图片"></p><p>而下图所示的是Vite的工作原理，一开始就可以准备联调，然后根据首页的依赖模块，再去按需加载，这样启动调试所需要的资源会大大减少。</p><p><img src="https://static001.geekbang.org/resource/image/8b/4c/8b726d2b8a09b045874340504a04414c.jpg?wh=1920x960" alt="图片"></p><p>后面我交给小圣的项目也主要用Vite作为工程化工具，你之后会详细地在实战中了解，第四部分我还会带着小圣手写一个mini版Vite，让我们拭目以待吧！</p><h2>总结</h2><p>今天学习的重点是Vue 3 主要的新特性，我们再来对这些特征做一个回顾：</p><ul>\n<li>新的RFC机制也让我们所有人都可以参与Vue新语法的讨论。</li>\n<li>工程化工具Vite带来了更丝滑的调试体验。</li>\n<li>对于产品的最终效果来看，Vue 3 性能更高，体积更小。</li>\n<li>对于普通开发者来说，Composition API 组合语法带来了更好的组织代码的形式。全新的响应式系统基于Proxy，也可以独立使用。</li>\n<li>Vue 3 内置了新的Fragment、Teleport和Suspense等组件。</li>\n<li>对于Vue的二次开发来说，自定义渲染器让我们开发跨端应用时更加得心应手。</li>\n<li>对于Vue的源码维护者，全部的模块使用TypeScript重构，能够带来更好的可维护性。</li>\n</ul><p>简而言之，Vue 3 带给我们的就是更快、更强且更易于扩展的开发体验，我们也可以用下面这个图来做个总结：</p><p><img src="https://static001.geekbang.org/resource/image/cc/d0/cc47460b1f9441d843bff6d37777a8d0.jpg?wh=3059x1664" alt=""></p><h2>思考题</h2><p>你喜欢 Vue 3 的哪一个新特性呢？你可以谈谈你的看法。</p><p>欢迎你在留言区跟我互动讨论，也推荐你把这一讲分享给你自己的朋友、同事。</p>',
        article_title: "03 | 新特性：初探Vue 3新特性",
      },
      {
        title: "04 | 升级：Vue 2项目如何升级到Vue 3？",
        id: 429816,
        content:
          '<p>你好，我是大圣，欢迎进入课程导读篇的第四讲。</p><p>在上一讲，我带你了解了Vue 3 的新特性。对于Vue 3 相比于 Vue 2 有哪些优势这个问题，相信你已经了解得很清楚了。那么在这一讲，我来教你如何把Vue 2 的项目升级到Vue 3。</p><p>把Vue 2 的项目升级到Vue 3，也是小圣一直关心的问题，今天早晨小圣还问我，既然Vue 3 如此优秀，是不是应该赶紧把项目都升级到Vue 3？</p><p>首先不要着急，并不是所有项目都适合升级。就像苹果出了新款手机，哪怕新特性被人们说得天花乱坠，但是，是不是把老手机换掉，也需要斟酌，毕竟升级总是需要成本的。</p><h2>应不应该从Vue 2 升级到Vue 3</h2><p>应不应该升级？这个问题不能一概而论。</p><p>首先，如果你要开启一个新项目，那直接使用Vue 3 是最佳选择。后面课程里，我也会带你使用Vue 3 的新特性和新语法开发一个项目。</p><p>以前我独立使用Vue 2 开发应用的时候，不管我怎么去组织代码，我总是无法避免在data、template、methods中上下反复横跳，这种弊端在项目规模上来之后会更加明显。而且由于vue-cli是基于Webpack开发的，当项目规模上来后，每执行一下，调试环境就要1分钟时间，这也是大部分复杂项目的痛点之一。</p><!-- [[[read_end]]] --><p><strong>而 Vue 3 的Composition API带来的代码组织方式更利于封装代码，维护起来也不会上下横跳。</strong>Vite则带来了更丝滑的调试体验，一步步跟着专栏完成你的第一个 Vue 3 项目，你会感受到Vue 3 的魅力。</p><p>Vue 3 的正式版已经发布有一年了，无论是辅助工具，还是周边库都已经非常完善了，足以胜任大型的项目开发。并且，现在也有越来越多的公司正在尝试和体验Vue 3。所以新项目可以直接拥抱Vue 3 的生态，这也是现在很多团队在做的尝试。</p><p>而且对于Vue 2，官方还会再维护两年，但两年后的问题和需求，官方就不承诺修复和提供解答了，现在继续用 Vue 2 其实是有这个隐患的。</p><p><strong>Vue 3 也不是没有问题，由于新的响应式系统用了Proxy，会存在兼容性问题。</strong>也就是说，如果你的应用被要求兼容IE11，就应该选择Vue 2。而且，Vue团队也已经放弃 Vue 3 对IE11浏览器的支持。</p><p>其实，官方原来是有计划在 Vue 3 中支持IE11，但后来由于复杂度和优先级的问题，这个计划就搁置了下来。</p><p>不过，站在2021看待现在前端的世界，你能发现浏览器和JavaScript本身已经有了巨大的发展。大部分的前端项目都在直接使用现代的语言特性，而且微软本身也在抛弃IE，转而推广Edge。所以 Vue 官方在重新思考后，决定让 Vue 3 全面拥抱未来，把原来准备投入到Vue 3 上支持IE11的精力转投给Vue 2.7。</p><p>那么 Vue 2.7 会带来什么内容呢?</p><p>Vue 2.7 会移植Vue 3 的一些新特性，让你在Vue 2 的生态中，也能享受Vue 3 的部分新特性。在Vue 3 发布之前，Vue 2 项目中就可以基于@vue/composition-api插件，使用Composition API语法，Vue 2 会直接内置这个插件，在Vue 2 中默认也可以用Compositon来组合代码。</p><p>后面，我会带你学的&lt;script setup&gt;语法，也会在Vue 2中得到支持。当然，如果我们想用更精简的方式去组织代码，也是没问题的，因为Vite中也正式支持了Vue 2。</p><p>综上所述，我们用下图来回答这一讲开头的问题，要不要使用Vue 3，还是要“因地制宜”，在不同的场景下，我们选择合适的方式即可。</p><p><img src="https://static001.geekbang.org/resource/image/2d/1a/2d26cea2a48d9caec0yybe6862643e1a.jpg?wh=1921x1270" alt=""></p><h2>Vue 3 不兼容的那些写法</h2><p>通过前面的分析，在选择Vue 2 还是Vue 3 这个问题上，相信你现在已经有了自己的取舍。如果最后你依然决定要升级Vue 3，那我就先带你了解一下 Vue 3 不支持的那些写法、之后为你讲解它的生态现状，最后，我们再进入到实操升级的环节。</p><p>了解一下 Vue 3 不兼容的那些具体语法，除了可以帮你在升级项目后，避免写的代码无法使用，还会让你更好地适应Vue 3。详细的兼容性变更，官方有一个<a href="https://v3.cn.vuejs.org/guide/migration/introduction.html">迁移指南</a>，我在这里就不一一给出了。同样，也为了避免八股文的形式，我在这里介绍几个重要的变更，后面项目中用到一些写法的时候，我再详细地告诉你。即使现在说太多细节，可能你也记不住。</p><p>这一部分内容，主要是针对有Vue 2 开发经验的，希望更快地适应Vue 3 的同学。在全面实战Vue 3 之前，你不必完整阅读官方的指南，因为Vue 3 的大部分 API 都是对 Vue 2 兼容的。</p><p>首先，我们来看一下 Vue 2 和 Vue 3 在项目在启动上的不同之处。在 Vue 2 中，我们使用new Vue()来新建应用，有一些全局的配置我们会直接挂在 Vue 上，比如我们通过Vue.use来使用插件，通过Vue.component来注册全局组件，如下面代码所示：</p><pre><code class="language-xml">Vue.component(\'el-counter\', {\n  data(){\n    return {count: 1}\n  },\n  template: \'&lt;button @click="count++"&gt;Clicked {{ count }} times.&lt;/button&gt;\'\n})\n\nlet VueRouter = require(\'vue-router\')\nVue.use(VueRouter)\n</code></pre><p>在上面的代码里，我们注册了一个el-counter组件，这个组件是全局可用的，它直接渲染一个按钮，并且在点击按钮的时候，按钮内的数字会累加。</p><p>然后我们需要注册路由插件，这也是Vue 2 中我们使用vue-router的方式。这种形式虽然很直接，但是由于全局的Vue只有一个，所以当我们在一个页面的多个应用中独立使用Vue就会非常困难。</p><p>看下面这段代码，我们在Vue上先注册了一个组件el-counter，然后创建了两个Vue的实例。这两个实例都自动都拥有了el-couter这个组件，但这样做很容易造成混淆。</p><pre><code class="language-xml">Vue.component(\'el-counter\',...)\n\nnew Vue({el:\'#app1\'})\nnew Vue({el:\'#app2\'})\n</code></pre><p>为了解决这个问题，Vue 3 引入一个新的API ，createApp，来解决这个问题，也就是新增了App的概念。全局的组件、插件都独立地注册在这个App内部，很好的解决了上面提到的两个实例容易造成混淆的问题。下面的代码是使用 createApp 的简单示例：</p><pre><code class="language-xml">const { createApp } = Vue\nconst app = createApp({})\napp.component(...)\napp.use(...)\napp.mount(\'#app1\')\n\nconst app2 = createApp({})\napp2.mount(\'#app2\')\n</code></pre><p>createApp还移除了很多我们常见的写法，比如在createApp中，就不再支持filter、<span dollar="">$</span>on、<span dollar="">$</span>off、<span dollar="">$</span>set、<span dollar="">$</span>delete等API。不过这都不用担心，后面我会告诉你怎么去实现类似这些API的功能。</p><p>在 Vue 3 中，v-model 的用法也有更改。在后面讲到组件化，也就是我们需要深度使用v-model的时候，我会再细讲。 其实 Vue 3 还有很多小细节的更新，比如slot和slot-scope两者实现了合并，而directive注册指令的API等也有变化。你现在记不住这些也不要紧，我们会在后面的实战项目里逐渐掌握这些内容。</p><h2>Vue 3 生态现状介绍</h2><p>在 Vue 生态中，现在所有官方库的工具都全面支持 Vue 3 了，但仍然有一些生态库还处于候选或者刚发布的状态。<strong>所以，升级Vue 3 的过程中，除了 Vue 3 本身的语法变化，生态也要注意选择。</strong>有一些周边的生态库可能还存在不稳定的情况，开发项目的时候我们时刻关注项目的GitHub 即可。</p><p>Vue-cli4 已经提供内置选项，你当然可以选择它支持的 Vue 2。如果你对 Vite 不放心的话，Vue-cli4 也全面支持 Vue 3，这还是很贴心的。</p><p>vue-router 是复杂项目必不可少的路由库，它也包含一些写法上的变化，比如从 new Router变成 createRouter；使用方式上，也全面拥抱 Composition API 风格，提供了 useRouter 和useRoute 等方法。</p><p>Vuex 4.0 也支持 Vue 3，不过变化不大。有趣的是 Vue 官方成员还发布了一个 Pinia，Pinia 的 API 非常接近 Vuex5 的设计，并且对 Composition API 特别友好，更优雅一些。在课程后续的项目里，我们会使用更成熟的 Vuex4。</p><p>其他生态诸如 Nuxt、组件库Ant-design-vue、Element 等等，都有 Vue 3 的版本发布。我开发维护的 Element3 是一个教育项目，我们在组件化章节会详细介绍。除此之外，我们项目中也会使用 Element3 来作为组件库。并且在进阶开发篇，我们会自己设计一个类似风格的组件库。</p><h2>使用自动化升级工具进行Vue的升级</h2><p>小项目不用多说，从 Vue 2 升级到 Vue 3 之后，对于语法的改变之处，我们挨个替换写法就可以。<strong>但对于复杂项目，我们需要借助几个自动化工具来帮我们过渡。</strong></p><p>首先是在 Vue 3 的项目里，有一个 @vue/compat 的库，这是一个 Vue 3 的构建版本，提供了兼容 Vue 2 的行为。这个版本默认运行在 Vue 2 下，它的大部分 API 和 Vue 2 保持了一致。当使用那些在 Vue 3 中发生变化或者废弃的特性时，这个版本会提出警告，从而避免兼容性问题的发生，帮助你很好地迁移项目。并且通过升级的提示信息，@vue/compat还可以很好地帮助你学习版本之间的差异。</p><p>在下面的代码中，首先我们把项目依赖的 Vue 版本换成 Vue 3，并且引入了@vue/compat 。</p><pre><code class="language-diff">"dependencies": {\n-  "vue": "^2.6.12",\n+  "vue": "^3.2.19",\n+  "@vue/compat": "^3.2.19"\n   ...\n},\n"devDependencies": {\n-  "vue-template-compiler": "^2.6.12"\n+  "@vue/compiler-sfc": "^3.2.19"\n}\n</code></pre><p>然后给 vue 设置别名@vue/compat，也就是以 compat 作为入口，代码如下：</p><pre><code class="language-diff">// vue.config.js\nmodule.exports = {\n  chainWebpack: config =&gt; {\n    config.resolve.alias.set(\'vue\', \'@vue/compat\')\n    ......\n  }\n}\n</code></pre><p>这时你就会在控制台看到很多警告，以及很多优化的建议。我们参照建议，挨个去做优化就可以了。</p><p>在 @vue/compat 提供了很多建议后，我们自己还是要慢慢做修改。但从另一个角度看，“偷懒”是优秀程序员的标志，社区就有能够做自动化替换的工具，比较好用的就是“阿里妈妈”出品的 gogocode，<a href="https://gogocode.io/zh/docs/specification/vue2-to-vue3">官方文档</a>也写得很详细，就不在这里赘述了。</p><p><strong>自动化替换工具的原理很简单，和 Vue 的 Compiler 优化的原理是一样的，也就是利用编译原理做代码替换。</strong>如下图所示，我们利用 babel 分析左边 Vue 2 的源码，解析成 AST，然后根据Vue 3 的写法对 AST 进行转换，最后生成新的 Vue 3 代码。</p><p><img src="https://static001.geekbang.org/resource/image/e3/e0/e371fee0a7e75942151724yy58fbfee0.jpg?wh=1920x1040" alt="图片"></p><p>对于替换过程的中间编译成的 AST，你可以理解为用 JavaScript 的对象去描述这段代码，这和虚拟 DOM 的理念有一些相似，我们基于这个对象去做优化，最终映射生成新的Vue 3 代码。</p><p>关于AST的细节，在课程后面的 Vue 3 生态源码篇中，我会带你手写一个迷你版的 Vue 3 Compiler，那时你会对 AST 和它背后的编译原理有一个更深的认识。</p><h2>总结</h2><p>我们来总结一下你今天都学到了什么吧。<strong>首先，我带你明确了什么时候该升级 Vue 3，什么时候该继续使用 Vue 2的兼容版本。</strong>现在，Vue 3 的官方生态在整体都比较稳定，新的项目完全可以直接选择 Vue 3。并且，对于那些需要长期维护的项目，其实也很有必要进行升级。不过，Vue 2 很快会停止更新，如果你的项目需要兼容 IE11，那就需要继续使用 Vue 2.7。这样，在保持好项目的兼容性的前提下，还可以体验到 Composition API 带来的便利。</p><p><strong>然后，在升级Vue的过程中，我们可以利用官方和社区的工具，帮助我们高效地升级。</strong>我们可以使用compat来给出提醒，项目中设置@vue/compat作为 vue 的别名，这样内部就会把所有和 Vue 2 的语法相关的升级信息提示出来，逐个替换即可，或者直接使用 gogocode 进行自动化批量替换。</p><p>最后，我想说的是，<strong>全面拥抱 Vue 3 也算是一次离开舒适圈的挑战，这带来的不只是新框架的体验，同时也可能是更好的潜力与更好的待遇</strong>。课程导读篇也到此结束了，在课程的下一篇，我们会开始实战一个 Vue 3 的项目，与此同时，我也会手把手带你通过实战学会 Vue 3。</p><h2>思考题</h2><p>你可以分享一下，在你的项目里，有没有需要升级的地方？有的话，又在什么地方呢？</p><p>欢迎你在留言区跟我交流讨论，也推荐你把这一讲推荐给你自己的朋友、同事。我们下一讲见！</p>',
        article_title: "04 | 升级：Vue 2项目如何升级到Vue 3？",
      },
    ],
  },
  {
    chapterTitle: "基础入门篇",
    children: [
      {
        title: "05 | 项目启动：搭建Vue 3工程化项目第一步",
        id: 431359,
        content:
          '<p>你好，我是大圣，欢迎进入课程的第二部分——基础入门篇。</p><p>在课程导读篇，我们了解了Vue 3 的新特性以及从Vue 2升级到Vue 3 的方法。相信你现在已经和小圣同学一样，迫不及待地想做一个实际的项目。当然了，在实战中学习Vue 3也是最好并且最快的学习方式。</p><p>不过，你先别着急。在基础入门篇，我会用5讲的篇幅，带你学习Vue 3的核心功能，包括<strong>项目搭建、Composition API、响应式、组件化和动画</strong>。这5讲结束后，你就会对Vue 3的核心功能有一个整体的了解，为我们全家桶实战篇的学习打下坚实的基础。</p><p>实际开发中，除了Vue 3这个库，我们还需要Vue 3 的最新全家桶，也就是Vue 3的周边生态，这其实就和士兵需要武器装备是一样的。今天这次，我会手把手带你安装和构建Vue 3开发环境。</p><h2>环境准备</h2><p>在之前的语法演示中，我们直接使用script 引入Vue 3，从而在浏览器里实现了所有调试功能。但是在实际的项目中，我们会使用专门的调试工具。在项目上线之前，代码也需要打包压缩，并且考虑到研发效率和代码可维护性，所以在下面，我们需要建立一个工程化的项目来实现这些功能。</p><p>你能在下图中看到我们现在要用到的工具，VS Code写Vue 3的代码，直接在Chrome浏览器里展示，我们会在这个基础之上逐步添加新的工具。</p><!-- [[[read_end]]] --><p><img src="https://static001.geekbang.org/resource/image/f5/92/f51c213d4675b994b93224077a292992.jpg?wh=571x474" alt="图片"></p><p>对于Vue 2，官方推荐用Vue-cli创建项目；而对于Vue 3，我建议你使用Vite创建项目，因为vite能够提供更好更快的调试体验。在使用Vite之前，我们要先安装Node.js 。</p><p>下载安装Node.js的过程是傻瓜式的，直接去<a href="http://nodejs.cn/download/">Node.js官网</a>下载安装即可。下载的时候，我们可以选择LTS版本，也就是稳定版，进行下载和安装即可。安装完毕后，我们创建vuejs工作目录，然后在命令行窗口执行node -v 指令，如果看到如下界面就算安装成功啦。</p><p><img src="https://static001.geekbang.org/resource/image/1f/e3/1f2803761b19b82c6e9c7c37f6bb24e3.png?wh=898x146" alt="图片"></p><p>之后，我们就可以在VS Code里进行Vue项目的开发。不过，在正式开发之前，我推荐使用VS Code的官方扩展插件Volar，这个插件给Vue 3提供了全面的开发支持。我们访问Volar的<a href="https://marketplace.visualstudio.com/items?itemName=johnsoncodehk.volar">地址</a>，直接点击Install，就会启动VS Code并且安装。然后使用Chrome访问 Vue 3调试插件的<a href="https://chrome.google.com/webstore/detail/vuejs-devtools/ljjemllljcmogpfapbkkighbhhppjdbg?hl=en">地址</a> ，可以帮助我们在浏览器里高效的调试页面。</p><p>接下来，在命令行窗口里，我们对vuejs目录执行下面的命令，这样就可以创建一个Vite的初始化项目。</p><pre><code class="language-diff">npm init @vitejs/app\n</code></pre><p>之后，在Project name这一行，我们输入项目的名字，例如geek-admin；接着，在Select a framework这一行输入框架的名字，这里我们选择vue；再之后，在select a variant 这一行，因为在项目里，我们没有选择TS，所以这里我们依然选择vue即可。</p><p><img src="https://static001.geekbang.org/resource/image/bb/8f/bbb51e602ef82234ca930b81c349f78f.png?wh=1300x966" alt="图片"></p><p>我们看一下geek-admin下面的文件目录，这个目录就是我们项目启动的骨架了。目录中的index.html是项目的入口；package.json是管理项目依赖和配置的文件；public目录放置静态资源，比如logo等图片；vite.config.js就是和Vite相关所有工程化的配置；src就是工作的重点，我们大部分的代码都会在src目录下管理和书写，后面我们也会在src目录下细化项目规范。</p><pre><code class="language-diff">.\n├── README.md\n├── index.html           入口文件\n├── package.json\n├── public               资源文件\n│   └── favicon.ico\n├── src                  源码\n│   ├── App.vue          单文件组件\n│   ├── assets\n│   │   └── logo.png\n│   ├── components   \n│   │   └── HelloWorld.vue\n│   └── main.js          入口\n└── vite.config.js vite工程化配置文件\n</code></pre><p>在这之后，我们在geek-admin文件夹内执行npm install 命令，来进行依赖的安装，然后执行npm run dev 命令来启动项目，看到如下信息就算是启动成功了。</p><p><img src="https://static001.geekbang.org/resource/image/05/2b/052e1e7768a711d26738f885a9dcd62b.png?wh=750x318" alt="图片"></p><p>我们根据命令行中的提示，在Chrome里打开<a href="http://localhost:3000/">http://localhost:3000/</a>，看到如下图所示的页面时，我们第一步就完成了。</p><p><img src="https://static001.geekbang.org/resource/image/c6/15/c63206232ed1a27a73ff243a381e0215.png?wh=1206x1000" alt="图片"></p><p>完成了项目的初始化之后，下一步我们会细化src目录，搭建源码的骨架架构。我们去VS Code里打开项目，修改一下src目录下的App.vue 文件。例如，我们改动一下文件中的HelloWorld组件，把msg改成“你好，极客时间”，之后你会发现浏览器不需要我们去刷新，首页大标题就自动更新了，这种热更新的开发体验会伴随我们整个项目开发，极大提高我们的开发效率。</p><p><img src="https://static001.geekbang.org/resource/image/35/0a/351a33fa19ef1997cfd49e4bd4852d0a.png?wh=1514x1058" alt="图片"></p><p>现在，项目的架构是下图所示的这个样子，这样我们的项目就拥有了工程化的雏形。我们来从下往上看这个架构：<strong>我们所有工程化体系都是基于Node.js生态；我们使用VS Code+Volar编辑器+语法提示工具作为上层开发工具；使用Vite作为工程化工具；使用Chrome进行调试</strong>，这些都是Vue 3工程化体系的必备工具。</p><p><img src="https://static001.geekbang.org/resource/image/97/eb/973ea8e35c177d252e4180c5bbfcc6eb.jpg?wh=1418x819" alt="图片"></p><p>由于小圣还不熟悉TypeScript，这里我们就依然使用JavaScript来开发，方便学习。关于如何使用TypeScript开发Vue 3，我们会在课程的第十四讲中详细地讲到。</p><p>我们开发的项目是多页面的，所以vue-router和Vuex也成为了必选项，就像一个团队需要人员配比，Vue负责核心，Vuex负责管理数据，vue-router负责管理路由。我们在geek-admin目录中使用下面这段代码安装Vuex和vue-router。</p><pre><code class="language-diff">npm install vue-router@next vuex@next\n</code></pre><p>框架搭建完毕后，我们如何在项目的src目录下面组织我们的路由和其他代码呢？我们需要制定一些基本的规范，最常见的规范就是使用文件夹来做区分。对于如何做分区，下面的规范这一部分就会介绍到。</p><h2>规范</h2><p>无规矩不成方圆，团队项目中的规范尤其重要。我们先对几个文件夹的分层进行规定，便于管理，下面是src目录的组织结构。</p><pre><code class="language-diff">├── src\n│   ├── api            数据请求\n│   ├── assets         静态资源\n│   ├── components     组件\n│   ├── pages          页面\n│   ├── router         路由配置\n│   ├── store          vuex数据\n│   └── utils          工具函数\n</code></pre><p>我们的页面需要引入路由系统，我们进入到router文件夹中，新建index.js，写入下面的代码：</p><pre><code class="language-diff">import {\n    createRouter,\n    createWebHashHistory,\n  } from \'vue-router\'\n  import Home from \'../pages/home.vue\'\n  import About from \'../pages/about.vue\'\n  \n  const routes = [\n    {\n      path: \'/\',\n      name: \'Home\',\n      component: Home\n    },\n    {\n      path: \'/about\',\n      name: \'About\',\n      component: About\n    }\n  ]\n  \n  const router = createRouter({\n    history: createWebHashHistory(),\n    routes\n  })\n  \n  export default router\n  \n</code></pre><p>上面的代码中，我们首先引入了createRouter和createWebHashHistory两个函数。createRouter用来新建路由实例，createWebHashHistory用来配置我们内部使用hash模式的路由，也就是url上会通过 <code>#</code> 来区分。</p><p>之后在上面的代码里，我们引入两个组件about和home，根据不同的访问地址<code>/</code> 和<code>/home</code>  去渲染不同的组件，最后返回router即可。</p><p>现在页面就会报错，提示我们找不到about和home这两个组件，然后我们去pages下面新建两个文件，分别输入如下内容：</p><pre><code class="language-diff">&lt;template&gt;\n    &lt;h1&gt;这是关于页面&lt;/h1&gt;\n&lt;/template&gt;\n</code></pre><pre><code class="language-diff">&lt;template&gt;\n    &lt;h1&gt;这是首页&lt;/h1&gt;\n&lt;/template&gt;\n</code></pre><p>注意，这两个文件是以 <code>.vue</code> 作为后缀的，这是Vue中单文件组件的写法，我们可以在一个文件中通过template、script和style来维护Vue组件的HTML、JavaScript和CSS。然后我们在main.js中，加载router的配置：</p><pre><code class="language-diff">import { createApp } from \'vue\'\nimport App from \'./App.vue\'\n\nimport router from \'./router/index\'\ncreateApp(App)\n    .use(router)\n    .mount(\'#app\')\n\n</code></pre><p>然后去App.vue中，我们删掉template之前的代码，加入如下内容：</p><pre><code class="language-diff">&lt;template&gt;\n  &lt;div&gt;\n    &lt;router-link to="/"&gt;首页&lt;/router-link&gt; | \n    &lt;router-link to="/about"&gt;关于&lt;/router-link&gt;\n  &lt;/div&gt;\n  &lt;router-view&gt;&lt;/router-view&gt;\n&lt;/template&gt;\n</code></pre><p>代码中的router-link和router-view就是由vue-router注册的全局组件，router-link负责跳转不同的页面，相当于Vue世界中的超链接a标签； router-view负责渲染路由匹配的组件，我们可以通过把router-view放在不同的地方，实现复杂项目的页面布局。</p><p>我们在浏览器中打开<a href="http://localhost:3000/">http://localhost:3000/</a>，就会看到下图的页面，点击“关于”和“首页”都会有页面切换的效果。</p><p><img src="https://static001.geekbang.org/resource/image/53/65/53c75db712636df79415fa2e7455db65.png?wh=686x434" alt="图片"></p><p>我们打开Chrome的调试窗，这也是我们以后常用的调试页面，在Vue这个标签页中，能很清晰地看到组件的层级关系。</p><p><img src="https://static001.geekbang.org/resource/image/30/03/303d6e1c45b7bdd848ff76257b853603.png?wh=1370x536" alt="图片"></p><p>至此，一个多页面的Vue开发项目雏形就完成了，现在的页面架构变成了下面图示的这样：</p><p><img src="https://static001.geekbang.org/resource/image/46/0a/465ae36094c1549b5804621f33cd370a.jpg?wh=1160x674" alt="图片"></p><p>当然这样还不够，我们在实际项目开发中还会有各种工具的集成，比如写CSS代码时，我们需要预处理工具stylus或者sass；组件库开发中，我们需要Element3作为组件库；网络请求后端数据的时候，我们需要Axios。</p><p>对于团队维护的项目，工具集成完毕后，还要有严格的代码规范。我们需要Eslint和Prettier来规范代码的格式，Eslint和Prettier可以规范项目中JavaScript代码的可读性和一致性。</p><p>代码的管理还需要使用Git，我们默认使用GitHub来托管我们的代码。此外，我们还会使用commitizen来规范Git的日志信息。</p><p>对于我们项目的基础组件，我们还会提供单元测试来确保代码质量和可维护性，最后我们还会配置GitHub Action来实现自动化的部署。</p><p>最后这个项目的架构大概是下面这样，这就是一个足以应对复杂项目开发的架构了：</p><p><img src="https://static001.geekbang.org/resource/image/3c/2c/3c9c01bf8917b85c469d086d4d0eb52c.jpg?wh=1385x968" alt=""></p><p><strong>项目雏形搭建完毕后，后面用到哪一块就会把哪一块加上，也就是用一个循序渐进的方式学习。</strong>比如我们下一讲完成一个独立功能的时候，才会把Git规范加上。至此，项目搭建完毕，在下一讲中，我们开启下一步，也就是页面的主体代码编写。</p><h2>总结</h2><p>我们来总结一下今天学的知识点。首先在环境准备阶段，我们基于Vite 2和Vue 3搭建了我们项目的初始化框架，包含文件规范、工程化、路由和开发的基础配置，后面我们所有的代码都会在这个架构基础之上进行添加。你可以理解环境准备阶段是给Vue 3提供装备的过程，vue-router提供路由的管理、Vuex管理数据流、VS Code+Chrome+Vite则提供了极致的开发调试体验。</p><p>之后，在本讲内容的第二部分，我们制定了代码和文件夹规范。后续新增组件就要去src/components目录，新增数据请求就去src/api目录。并且main.js在项目入口对路由数据进行了注册，这样我们就能够通过执行 <code>npm run dev</code>启动这个项目。之后，我们就能看到首页和关于页面，这样项目的雏形我们就搭建完毕。</p><p>最后，在第二部分结尾，我还展示了一下整个项目架构的全景图，你能看到，从环境的准备到项目的初始化，再到搭建完成项目雏形，整个项目架构的全景图也在项目开发过程中逐渐完善。</p><h2><strong>思考题</strong></h2><p>当然，没有完美的项目结构，那么对于我们目前的项目来说，你觉得还需要新增什么插件和工具吗？</p><p>欢迎你在留言区分享你的想法，如果你对这个项目结构还有什么疑问和建议，我们也可以一起讨论。也推荐你把这一讲推荐给你自己的朋友和同事，我们下一讲见！</p>',
        article_title: "05 | 项目启动：搭建Vue 3工程化项目第一步",
      },
      {
        title:
          "06 | 新的代码组织方式：Composition API  script setup 到底好在哪里？",
        id: 431955,
        content:
          '<p>你好，我是大圣，欢迎进入课程的第六讲。</p><p>在上一讲中，我带你搭建了项目的雏形，这是后面项目开发的起点。从今天开始，我就带你在这个骨架结构的基础之上，开始项目的实战开发。首先我们要掌握的，就是 Vue 3 的Composition API + &lt;script setup&gt;这种最新的代码组织方式。</p><p><img src="https://static001.geekbang.org/resource/image/6f/0a/6fd86f3d33a0200d64c7423bc88e890a.png?wh=1222x432" alt=""></p><p>我们在前面的第三讲中，有详细地讲到过 Composition API ，相信你对这个API 的语法细节已经有所掌握了。那你肯定会很好奇，这个&lt;script setup&gt;又是什么？为什么尤雨溪要在微博上强推&lt;script setup&gt;呢？</p><p>别急，今天我就带你使用Composition API 和 &lt;script setup&gt; 去重构第二讲的清单应用。在重构的过程中，你能逐渐明白，<strong>Composition API 可以让我们更好地组织代码结构</strong>，而让你感到好奇的 &lt;script setup&gt;本质上是以一种更精简的方式来书写Composition API 。</p><h2>Composition API 和 &lt;script setup&gt; 上手</h2><p>首先我想提醒你，我们在这一讲中写代码的方式，就和前面的第二讲有很大的区别。</p><p>在第二讲中，我们开发清单应用时，是直接在浏览器里使用 Options API 的方式写代码；但在接下来的开发中，我们会直接用单文件组件——也就是 <code>.vue</code> 文件，的开发方式。这种文件格式允许我们把 Vue 组件的HTML、CSS和JavaScript写在单个文件内容中。下面我带你用单文件组件的方式，去重构第二讲做的清单应用。</p><!-- [[[read_end]]] --><p>我们现在已经搭建好了项目的骨架，以后在这个骨架之内会有很多页面和组件。从这里开始，我们就要逐步适应组件化的开发思路，新的功能会以组件的方式来组织。</p><p>按照上一讲制定的规范，首先，我们打开项目文件夹下面的src下的components目录，新建一个Todolist.vue ，并在这个文件里写出下面的代码：</p><pre><code class="language-xml">&lt;template&gt;\n  &lt;div&gt;\n    &lt;h1 @click="add"&gt;{{count}}&lt;/h1&gt;\n  &lt;/div&gt;\n&lt;/template&gt;\n\n&lt;script setup&gt;\nimport { ref } from "vue";\nlet count = ref(1)\nfunction add(){\n    count.value++\n}\n&lt;/script&gt;\n\n&lt;style&gt;\nh1 {\n  color: red;\n}\n&lt;/style&gt;\n</code></pre><p>在上述代码中，我们使用template标签放置模板、script 标签放置逻辑代码，并且用setup标记我们使用&lt;script setup&gt;的语法，style标签放置CSS样式。</p><p>从具体效果上看，这段代码实现了一个累加器。在 &lt;script setup&gt; 语法中，我们使用引入的ref函数包裹数字，返回的count变量就是响应式的数据，使用add函数实现数字的修改。需要注意的是，对于ref返回的响应式数据，我们需要修改 <code>.value</code> 才能生效，而在 &lt;script setup&gt; 标签内定义的变量和函数，都可以在模板中直接使用。</p><p>实现累加器以后，我们再回到src/pages/Home.vue 组件中，使用如下代码显示清单应用。在这段代码里，我们直接import TodoList.vue组件，然后&lt;script setup&gt;会自动把组件注册到当前组件，这样我们就可以直接在template中使用 <todolist> 来显示清单的功能。</todolist></p><pre><code class="language-xml">&lt;template&gt;\n    &lt;h1&gt;这是首页&lt;/h1&gt;\n    &lt;TodoList /&gt;    \n&lt;/template&gt;\n\n&lt;script setup&gt;\nimport TodoList from \'../components/TodoList.vue\'\n&lt;/script&gt;\n</code></pre><p>这个时候我们就把清单功能独立出来了，可以在任意你需要的地方复用。在课程的后续内容中，我会详细给你介绍基于组件去搭建应用的方式。<strong>通过这种方式，你可以实现对业务逻辑的复用。这样做的好处就是，如果有其他页面也需要用到这个功能，可以直接复用过去。</strong></p><p>然后，我们就可以基于新的语法实现之前的清单应用。下面的代码就是把之前的代码移植过来后，使用ref包裹的响应式数据。在你修改title和todos的时候，注意要修改响应式数据的value属性。</p><pre><code class="language-xml">&lt;template&gt;\n  &lt;div&gt;\n    &lt;input type="text" v-model="title" @keydown.enter="addTodo" /&gt;\n    &lt;ul v-if="todos.length"&gt;\n      &lt;li v-for="todo in todos"&gt;\n        &lt;input type="checkbox" v-model="todo.done" /&gt;\n        &lt;span :class="{ done: todo.done }"&gt; {{ todo.title }}&lt;/span&gt;\n      &lt;/li&gt;\n    &lt;/ul&gt;\n  &lt;/div&gt;\n&lt;/template&gt;\n\n&lt;script setup&gt;\nimport { ref } from "vue";\nlet title = ref("");\nlet todos = ref([{title:\'学习Vue\',done:false}])\n\nfunction addTodo() {\n  todos.value.push({\n    title: title.value,\n    done: false,\n  });\n  title.value = "";\n}\n&lt;/script&gt;\n</code></pre><h2>计算属性</h2><p>在第二讲开发的清单应用中，我们也用到了计算属性，在Composition API的语法中，计算属性和生命周期等功能，都可以脱离Vue的组件机制单独使用 。我们向TodoList.vue代码块中加入下面的代码：</p><pre><code class="language-xml">&lt;template&gt;\n  &lt;div&gt;\n    &lt;input type="text" v-model="title" @keydown.enter="addTodo" /&gt;\n    &lt;button v-if="active &lt; all" @click="clear"&gt;清理&lt;/button&gt;\n    &lt;ul v-if="todos.length"&gt;\n      &lt;li v-for="todo in todos"&gt;\n        &lt;input type="checkbox" v-model="todo.done" /&gt;\n        &lt;span :class="{ done: todo.done }"&gt; {{ todo.title }}&lt;/span&gt;\n      &lt;/li&gt;\n    &lt;/ul&gt;\n    &lt;div v-else&gt;暂无数据&lt;/div&gt;\n    &lt;div&gt;\n      全选&lt;input type="checkbox" v-model="allDone" /&gt;\n      &lt;span&gt; {{ active }} / {{ all }} &lt;/span&gt;\n    &lt;/div&gt;\n  &lt;/div&gt;\n&lt;/template&gt;\n\n&lt;script setup&gt;\nimport { ref,computed } from "vue";\nlet title = ref("");\nlet todos = ref([{title:\'学习Vue\',done:false}])\n\nfunction addTodo() {\n...\n}\nfunction clear() {\n  todos.value = todos.value.filter((v) =&gt; !v.done);\n}\nlet active = computed(() =&gt; {\n  return todos.value.filter((v) =&gt; !v.done).length;\n});\nlet all = computed(() =&gt; todos.value.length);\nlet allDone = computed({\n  get: function () {\n    return active.value === 0;\n  },\n  set: function (value) {\n    todos.value.forEach((todo) =&gt; {\n      todo.done = value;\n    });\n  },\n});\n&lt;/script&gt;\n</code></pre><p>在这这段代码中，具体的计算属性的逻辑和第二讲一样，区别仅在于computed的用法上。你能看到，第二讲的computed是组件的一个配置项，而这里的computed的用法是单独引入使用。</p><h2>Composition API 拆分代码</h2><p>讲到这里，可能你就会意识到，之前的累加器和清单，虽然功能都很简单，但也属于两个功能模块。如果在一个页面里有这两个功能，那就需要在data和methods里分别进行配置。但这样的话，数据和方法相关的代码会写在一起，在组件代码行数多了以后就不好维护。<strong>所以，我们需要使用Composition API 的逻辑来拆分代码，把一个功能相关的数据和方法都维护在一起。</strong></p><p>但是，所有功能代码都写在一起的话，也会带来一些问题：随着功能越来越复杂，script 内部的代码也会越来越多。因此，我们可以进一步对代码进行拆分，把功能独立的模块封装成一个独立的函数，真正做到按需拆分。</p><p>在下面，我们新建了一个函数 useTodos：</p><pre><code class="language-xml">function useTodos() {\n  let title = ref("");\n  let todos = ref([{ title: "学习Vue", done: false }]);\n  function addTodo() {\n    todos.value.push({\n      title: title.value,\n      done: false,\n    });\n    title.value = "";\n  }\n  function clear() {\n    todos.value = todos.value.filter((v) =&gt; !v.done);\n  }\n  let active = computed(() =&gt; {\n    return todos.value.filter((v) =&gt; !v.done).length;\n  });\n  let all = computed(() =&gt; todos.value.length);\n  let allDone = computed({\n    get: function () {\n      return active.value === 0;\n    },\n    set: function (value) {\n      todos.value.forEach((todo) =&gt; {\n        todo.done = value;\n      });\n    },\n  });\n  return { title, todos, addTodo, clear, active, all, allDone };\n}\n</code></pre><p>这个函数就是把那些和清单相关的所有数据和方法，都放在函数内部定义并且返回，这样这个函数就可以放在任意的地方来维护。</p><p>而我们的组件入口，也就是&lt;script setup&gt;中的代码，就可以变得非常简单和清爽了。在下面的代码中，我们只需要调用useTodos，并且获取所需要的变量即可，具体的实现逻辑可以去useTodos内部维护，代码可维护性大大增强。</p><pre><code class="language-xml">&lt;script setup&gt;\nimport { ref, computed } from "vue";\n\nlet count = ref(1)\nfunction add(){\n    count.value++\n}\n\nlet { title, todos, addTodo, clear, active, all, allDone } = useTodos();\n&lt;/script&gt;\n</code></pre><p>我们在使用Composition API 拆分功能时，也就是执行useTodos的时候，ref、computed等功能都是从 Vue 中单独引入，而不是依赖this上下文。其实你可以把组件内部的任何一段代码，从组件文件里抽离出一个独立的文件进行维护。</p><p>现在，我们引入追踪鼠标位置的需求进行讲解，比如我们项目中可能有很多地方需要显示鼠标的坐标位置，那我们就可以在项目的src/utils文件夹下面新建一个mouse.js。我们先从 Vue 中引入所需要的ref函数，然后暴露一个函数，函数内部和上面封装的useTodos类似，不过这次独立成了文件，放在utils文件下独立维护，提供给项目的所有组件使用。</p><pre><code class="language-xml">import {ref} from \'vue\'\n\nexport function useMouse(){\n\n    const x = ref(0)\n    const y = ref(0)\n\n    return {x, y}\n\n}\n</code></pre><p>想获取鼠标的位置，我们就需要监听mousemove事件。这需要在组件加载完毕后执行，在Composition API中，我们可以直接引入onMounted和onUnmounted来实现生命周期的功能。</p><p>看下面的代码，组件加载的时候，会触发onMounted生命周期，我们执行监听mousemove事件，从而去更新鼠标位置的x和y的值；组件卸载的时候，会触发onUnmounted生命周期，解除mousemove事件。</p><pre><code class="language-xml">\n\nimport {ref, onMounted,onUnmounted} from \'vue\'\n\nexport function useMouse(){\n    const x = ref(0)\n    const y = ref(0)\n    function update(e) {\n      x.value = e.pageX\n      y.value = e.pageY\n    }\n    onMounted(() =&gt; {\n      window.addEventListener(\'mousemove\', update)\n    })\n  \n    onUnmounted(() =&gt; {\n      window.removeEventListener(\'mousemove\', update)\n    })\n    return { x, y }\n}\n</code></pre><p>完成了上面的鼠标事件封装这一步之后，我们在组件的入口就可以和普通函数一样使用useMouse函数。在下面的代码中，上面的代码返回的x和y的值可以在模板任意地方使用，也会随着鼠标的移动而改变数值。</p><pre><code class="language-xml">import {useMouse} from \'../utils/mouse\'\n\nlet {x,y} = useMouse()\n</code></pre><p>相信到这里，你一定能体会到 Composition API 对代码组织方式的好处。简单来看，<strong>因为ref和computed等功能都可以从 Vue 中全局引入，所以我们就可以把组件进行任意颗粒度的拆分和组合</strong>，这样就大大提高了代码的可维护性和复用性。</p><h2>&lt;script setup&gt; 好用的功能</h2><p>Composition API 带来的好处你已经掌握了，而&lt;script setup&gt;是为了提高我们使用Composition API 的效率而存在的。我们还用累加器来举例，如果没有&lt;script setup&gt;，那么我们需要写出下面这样的代码来实现累加器。</p><pre><code class="language-xml">&lt;script &gt;\nimport { ref } from "vue";\nexport default {\n  setup() {\n    let count = ref(1)\n    function add() {\n      count.value++\n    }\n    return {\n      count,\n      add\n    }\n  }\n}\n&lt;/script&gt;\n</code></pre><p>在上面的代码中，我们要在&lt;script&gt;中导出一个对象。我们在setup配置函数中写代码时，和Options的写法比，也多了两层嵌套。并且，我们还要在setup函数中，返回所有需要在模板中使用的变量和方法。上面的代码中，setup函数就返回了count和add。</p><p><strong>使用 &lt;script setup&gt; 可以让代码变得更加精简，这也是现在开发 Vue 3 项目必备的写法</strong>。除了我们上面介绍的功能，&lt;script setup&gt;还有其它一些很好用的功能，比如能够使用顶层的await去请求后端的数据等等，我们会在后面的项目中看到这种使用方法。</p><h2>style样式的特性</h2><p>除了script相关的配置，我也有必要给你介绍一下style样式的配置。比如，在style标签上，当我们加上scoped这个属性的时候，我们定义的CSS就只会应用到当前组件的元素上，这样就很好地避免了一些样式冲突的问题。</p><p>我们项目中的样式也可以加上如下标签：</p><pre><code class="language-xml">&lt;style scoped&gt;\nh1 {\n  color: red;\n}\n&lt;/style&gt;&gt;\n</code></pre><p>这样，组件就会解析成下面代码的样子。标签和样式的属性上，新增了data-的前缀，确保只在当前组件生效。</p><pre><code class="language-xml">&lt;h1 data-v-3de47834=""&gt;1&lt;/h1&gt;\n&lt;style scoped&gt;\nh1[data-v-3de47834]&nbsp;{\n    color: red;\n}\n&lt;/style&gt;\n</code></pre><p>如果在scoped内部，你还想写全局的样式，那么你可以用:global来标记，这样能确保你可以很灵活地组合你的样式代码（后面项目中用到的话，我还会结合实战进行讲解）。而且我们甚至可以通过v-bind函数，直接在CSS中使用JavaScript中的变量。</p><p>在下面这段代码中, 我在script里定义了一个响应式的color变量，并且在累加的时候，将变量随机修改为红或者蓝。在style内部，我们使用v-bind函数绑定color的值，就可以动态地通过JavaScript的变量实现CSS的样式修改，点击累加器的时候文本颜色会随机切换为红或者蓝。</p><pre><code class="language-xml">&lt;template&gt;\n  &lt;div&gt;\n    &lt;h1 @click="add"&gt;{{ count }}&lt;/h1&gt;\n  &lt;/div&gt;\n&lt;/template&gt;\n\n&lt;script setup&gt;\nimport { ref } from "vue";\nlet count = ref(1)\nlet color = ref(\'red\')\nfunction add() {\n  count.value++\n  color.value = Math.random()&gt;0.5? "blue":"red"\n}\n&lt;/script&gt;\n\n&lt;style scoped&gt;\nh1 {\n  color:v-bind(color);\n}\n&lt;/style&gt;&gt;\n</code></pre><p>点击累加器时文本颜色的切换效果，如下图所示：</p><p><img src="https://static001.geekbang.org/resource/image/59/18/5974c0d7dbce32306bd2a207a6a37f18.gif?wh=343x105" alt="图片"></p><h2>总结</h2><p>我们来总结一下今天都学到了什么吧。今天的主要任务就是使用Composition API +&lt;script setup&gt;的语法复现第二讲的清单应用，我们首先通过累加器的例子介绍了ref这个函数的使用；之后我们讲到，在Composition API的语法中，所有的功能都是通过全局引入的方式使用的，并且通过&lt;script setup&gt;的功能，我们定义的变量、函数和引入的组件，都不需要额外的生命周期，就可以直接在模板中使用。</p><p>然后，我们通过把功能拆分成函数和文件的方式，掌握到Composition API组织代码的方式，我们可以任意拆分组件的功能，抽离出独立的工具函数，大大提高了代码的可维护性。</p><p>最后我们还学习了style标签的特殊属性，通过标记scoped可以让样式只在当前的组件内部生效，还可以通过v-bind函数来使用JavaScript中的变量去渲染样式，如果这个变量是响应式数据，就可以很方便地实现样式的切换。</p><p>相信学完今天这一讲，你一定会对我们为什么需要Composition API有更进一步的认识，而对于&lt;script setup&gt;来说，则可以帮助我们更好且更简洁的写Compostion的语法。在后面，我们的项目会全部使用Composition API + &lt;script setup&gt;来进行书写。</p><h2>思考题</h2><p>最后给你留一个思考题，Composition API 和 &lt;script setup&gt; 虽然能提高开发效率，但是带来的一些新的语法，比如ref返回的数据就需要修改 value属性；响应式和生命周期也需要import后才能使用等等，很多人也在社区批评这是 Vue 造的“方言” ，那你怎么看呢？</p><p>欢迎你在留言区分享你的想法，当然也推荐你把这一讲推荐给你自己的朋友、同事。我们下一讲见！</p>',
        article_title:
          "06 | 新的代码组织方式：Composition API  script setup 到底好在哪里？",
      },
      {
        title: "07 | 巧妙的响应式：深入理解Vue 3的响应式机制",
        id: 433968,
        content:
          '<p>你好，我是大圣。在上一讲中，我给你介绍了Composition API相比于Option API 的优点，以及&lt;script setup&gt;的语法，这些内容能够给我们后面的开发打下了坚实的基础。</p><p>今天我带你深入了解一下Vue 3的响应式机制，相信学完今天的内容，你会对响应式机制有更深地体会。我还会结合代码示例，帮你掌握响应式机制的进阶用法，让我们正式开始学习吧！</p><h2>什么是响应式</h2><p>响应式一直都是Vue的特色功能之一。与之相比，JavaScript里面的变量，是没有响应式这个概念的。你在学习JavaScript的时候首先被灌输的概念，就是代码是自上而下执行的。我们看下面的代码，代码在执行后，打印输出的两次double的结果也都是2。即使我们修改了代码中的count的值后，double的值也不会有任何改变。</p><pre><code class="language-xml">let count = 1\nlet double = count * 2\nconsole.log(double)\ncount = 2\nconsole.log(double)\n</code></pre><p>double的值是根据count的值乘以二计算而得到的，如果现在我们想让doube能够跟着count的变化而变化，那么我们就需要在每次count的值修改后，重新计算double。</p><!-- [[[read_end]]] --><p>比如，在下面的代码，我们先把计算doube的逻辑封装成函数，然后在修改完count之后，再执行一遍，你就会得到最新的double值。</p><pre><code class="language-xml">let count = 1\n// 计算过程封装成函数\nlet getDouble = n=&gt;n*2 //箭头函数\nlet double = getDouble(count)\nconsole.log(double)\n\ncount = 2\n// 重新计算double，这里我们不能自动执行对double的计算\ndouble = getDouble(count)\nconsole.log(double)\n</code></pre><p>实际开发中的计算逻辑会比计算doube复杂的多，但是都可以封装成一个函数去执行。下一步，我们要考虑的是，如何让double的值得到自动计算。</p><p>如果我们能让getDouble函数自动执行，也就是如下图所示，我们使用JavaScript的某种机制，把count包裹一层，每当对count进行修改时，就去同步更新double的值，那么就有一种double自动跟着count的变化而变化的感觉，这就算是响应式的雏形了。<br>\n<img src="https://static001.geekbang.org/resource/image/5c/97/5c9a7aa3468f19b7edf067b7b252ea97.jpg?wh=1090x970" alt=""></p><h2>响应式原理</h2><p>响应式原理是什么呢？Vue中用过三种响应式解决方案，分别是defineProperty、Proxy和value setter。我们首先来看Vue 2的defineProperty API，这个函数详细的API介绍你可以直接访问<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty">MDN介绍文档</a>来了解。</p><p>这里我结合一个例子来说明，在下面的代码中，我们定义个一个对象obj，使用defineProperty代理了count属性。这样我们就对obj对象的value属性实现了拦截，读取count属性的时候执行get函数，修改count属性的时候执行set函数，并在set函数内部重新计算了double。</p><pre><code class="language-xml">let getDouble = n=&gt;n*2\nlet obj = {}\nlet count = 1\nlet double = getDouble(count)\n\nObject.defineProperty(obj,\'count\',{\n    get(){\n        return count\n    },\n    set(val){\n        count = val\n        double = getDouble(val)\n    }\n})\nconsole.log(double)  // 打印2\nobj.count = 2\nconsole.log(double) // 打印4  有种自动变化的感觉\n</code></pre><p>这样我们就实现了简易的响应式功能，在课程的第四部分，我还会带着你写一个更完善的响应式系统。</p><p>但defineProperty API作为Vue 2实现响应式的原理，它的语法中也有一些缺陷。比如在下面代码中，我们删除obj.count 属性，set函数就不会执行，double还是之前的数值。这也是为什么在Vue 2中，我们需要$delete一个专门的函数去删除数据。</p><pre><code class="language-xml">delete obj.count\nconsole.log(double) // doube还是4\n</code></pre><p>Vue 3 的响应式机制是基于Proxy实现的。就Proxy这个名字来说，你也能看出来这是代理的意思，Proxy的重要意义在于它解决了Vue 2响应式的缺陷。我们看下面的代码，在其中我们通过new Proxy代理了obj这个对象，然后通过get、set和deleteProperty函数代理了对象的读取、修改和删除操作，从而实现了响应式的功能。</p><pre><code class="language-xml">let proxy = new Proxy(obj,{\n    get : function (target,prop) {\n        return target[prop]\n    },\n    set : function (target,prop,value) {\n        target[prop] = value;\n        if(prop===\'count\'){\n            double = getDouble(value)\n        }\n    },\n    deleteProperty(target,prop){\n        delete target[prop]\n        if(prop===\'count\'){\n            double = NaN\n        }\n    }\n})\nconsole.log(obj.count,double)\nproxy.count = 2\nconsole.log(obj.count,double) \ndelete proxy.count\n// 删除属性后，我们打印log时，输出的结果就会是 undefined NaN\nconsole.log(obj.count,double) \n</code></pre><p>我们从这里可以看出Proxy实现的功能和Vue 2 的definePropery类似，它们都能够在用户修改数据的时候触发set函数，从而实现自动更新double的功能。而且Proxy还完善了几个definePropery的缺陷，比如说可以监听到属性的删除。</p><p>Proxy是针对对象来监听，而不是针对某个具体属性，所以不仅可以代理那些定义时不存在的属性，还可以代理更丰富的数据结构，比如Map、Set等，并且我们也能通过deleteProperty实现对删除操作的代理。</p><p>当然，为了帮助你理解Proxy，我们还可以把double相关的代码都写在set和deleteProperty函数里进行实现，在课程的后半程我会带你做好更完善的封装。比如下面代码中，Vue 3 的reactive函数可以把一个对象变成响应式数据，而reactive就是基于Proxy实现的。我们还可以通过watchEffect，在obj.count修改之后，执行数据的打印。</p><pre><code class="language-xml">import {reactive,computed,watchEffect} from \'vue\'\n\nlet obj = reactive({\n    count:1\n})\nlet double = computed(()=&gt;obj.count*2)\nobj.count = 2\n\nwatchEffect(()=&gt;{\n    console.log(\'数据被修改了\',obj.count,double.value)\n})\n</code></pre><p>有了Proxy后，响应式机制就比较完备了。但是在Vue 3中还有另一个响应式实现的逻辑，就是利用对象的get和set函数来进行监听，这种响应式的实现方式，只能拦截某一个属性的修改，这也是Vue 3中ref这个API的实现。在下面的代码中，我们拦截了count的value属性，并且拦截了set操作，也能实现类似的功能。</p><pre><code class="language-xml">let getDouble = n =&gt; n * 2\nlet _value = 1\ndouble = getDouble(_value)\n\nlet count = {\n  get value() {\n    return _value\n  },\n  set value(val) {\n    _value = val\n    double = getDouble(_value)\n\n  }\n}\nconsole.log(count.value,double)\ncount.value = 2\nconsole.log(count.value,double)\n</code></pre><p>三种实现原理的对比表格如下，帮助你理解三种响应式的区别。</p><p><img src="https://static001.geekbang.org/resource/image/b5/11/b5344de85923a2ba8bea60283b491711.png?wh=1336x650" alt=""></p><h2>定制响应式数据</h2><p>简单入门响应式的原理后，接下来我们学习一下响应式数据在使用的时候的进阶方式。在前面第二讲做清单应用的时候，我给你留过一个思考题，就是让你想办法解决所有的操作状态在刷新后就都没了这个问题。</p><p>解决这个问题所需要的，就是让todolist和本地存储能够同步。我们首先可以选择的就是在代码中，显式地声明同步的逻辑，而watchEffect这个函数让我们在数据变化之后可以执行指定的函数。</p><p>我们看下使用 &lt;script setup&gt;重构之后的todolist的代码。这段代码使用watchEffect，数据变化之后会把数据同步到localStorage之上，这样我们就实现了todolist和本地存储的同步。</p><pre><code class="language-xml">import { ref, watchEffect, computed } from "vue";\n\nlet title = ref("");\nlet todos = ref(JSON.parse(localStorage.getItem(\'todos\')||\'[]\'));\nwatchEffect(()=&gt;{\n    localStorage.setItem(\'todos\',JSON.stringify(todos.value))\n})\nfunction addTodo() {\n  todos.value.push({\n    title: title.value,\n    done: false,\n  });\n  title.value = "";\n}\n</code></pre><p>更进一步，我们可以直接抽离一个useStorage函数，在响应式的基础之上，把任意数据响应式的变化同步到本地存储。我们先看下面的这段代码，ref从本地存储中获取数据，封装成响应式并且返回，watchEffect中做本地存储的同步，useStorage这个函数可以抽离成一个文件，放在工具函数文件夹中。</p><pre><code class="language-xml">function useStorage(name, value=[]){\n    let data = ref(JSON.parse(localStorage.getItem(name)|| value))\n    watchEffect(()=&gt;{\n        localStorage.setItem(name,JSON.stringify(data.value))\n    })\n    return data\n}\n</code></pre><p>在项目中我们使用下面代码的写法，把ref变成useStorage，这也是Composition API 最大的优点，也就是可以任意拆分出独立的功能。</p><pre><code class="language-xml">let todos = useStorage(\'todos\',[])\n\nfunction addTodo() {\n  ...code\n}\n</code></pre><p>现在，你应该已经学会了在Vue内部进阶地使用响应式机制，去封装独立的函数。社区也有非常优秀的Vueuse工具库，包含了大量类似useStorage的工具函数库。在后续的实战应用中，我们也会经常对通用功能进行封装。</p><p>如下图所示，我们可以把日常开发中用到的数据，无论是浏览器的本地存储，还是网络数据，都封装成响应式数据，统一使用响应式数据开发的模式。这样，我们开发项目的时候，只需要修改对应的数据就可以了。</p><p><img src="https://static001.geekbang.org/resource/image/5a/0e/5a5yy5dc6f6b25f1c1ff8f3a434cd10e.jpg?wh=2316x1829" alt=""></p><p>基于响应式的开发模式，我们还可以按照类似的原理，把我们需要修改的数据，都变成响应式。比如，我们可以在loading状态下，去修改浏览器的小图标favicon。和本地存储类似，修改favicon时，我们需要找到head中有icon属性的标签。</p><p>在下面的代码中，我们把对图标的对应修改的操作封装成了useFavicon函数，并且通过ref和watch的包裹，我们还把小图标变成了响应式数据。</p><pre><code class="language-xml">import {ref,watch} from \'vue\'\nexport default function useFavicon( newIcon ) {\n    const favicon = ref(newIcon)\n\n    const updateIcon = (icon) =&gt; {\n      document.head\n        .querySelectorAll(`link[rel*="icon"]`)\n        .forEach(el =&gt; el.href = `${icon}`)\n    }\n    const reset = ()=&gt;favicon.value = \'/favicon.ico\'\n\n    watch( favicon,\n      (i) =&gt; {\n        updateIcon(i)\n      }\n    )\n    return {favicon,reset}\n  } \n</code></pre><p>这样在组件中，我们就可以通过响应式的方式去修改和使用小图标，通过对faivcon.value的修改就可以随时更换网站小图标。下面的代码，就实现了在点击按钮之后，修改了网页的图标为geek.png的操作。</p><pre><code class="language-xml"> &lt;script setup&gt;\n import useFavicon from \'./utils/favicon\'\n let {favicon}  = useFavicon()\n function loading(){\n   favicon.value = \'/geek.png\'\n }\n&lt;/script&gt;\n\n&lt;template&gt;\n  &lt;button @click="loading"&gt;123&lt;/button&gt;\n&lt;/template&gt;\n</code></pre><h2>Vueuse工具包</h2><p>我们自己封装的useStorage，算是把localStorage简单地变成了响应式对象，实现数据的更新和localStorage的同步。同理，我们还可以封装更多的类似useStorage函数的其他use类型的函数，把实际开发中你用到的任何数据或者浏览器属性，都封装成响应式数据，这样就可以极大地提高我们的开发效率。</p><p>Vue 社区中其实已经有一个类似的工具集合，也就是VueUse，它把开发中常见的属性都封装成为响应式函数。</p><p>VueUse&nbsp;趁着这一波 Vue 3&nbsp;的更新，跟上了响应式API的潮流。VueUse的官方的介绍说这是一个 Composition API&nbsp;的工具集合，适用于Vue 2.x或者Vue 3.x，用起来和 React Hooks&nbsp;还挺像的。</p><p>在项目目录下打开命令行里，我们输入如下命令，来进行VueUse插件的安装：</p><pre><code class="language-xml">npm install @vueuse/core\n</code></pre><p>然后，我们就先来使用一下VueUse。在下面这段代码中，我们使用useFullscreen来返回全屏的状态和切换全屏的函数。这样，我们就不需要考虑浏览器全屏的API，而是直接使用VueUse响应式数据和函数就可以很轻松地在项目中实现全屏功能。</p><pre><code class="language-xml">&lt;template&gt;\n  &lt;h1 @click="toggle"&gt;click&lt;/h1&gt;\n&lt;/template&gt;\n&lt;script setup&gt;\nimport { useFullscreen } from \'@vueuse/core\'\nconst { isFullscreen, enter, exit, toggle } = useFullscreen()\n&lt;/script&gt;\n</code></pre><p>useFullscreen的封装逻辑和useStorage类似，都是屏蔽了浏览器的操作，把所有我们需要用到的状态和数据都用响应式的方式统一管理，VueUse中包含了很多我们常用的工具函数，我们可以把网络状态、异步请求的数据、动画和事件等功能，都看成是响应式的数据去管理。</p><h2>总结</h2><p>我们来总结一下今天学到的内容，首先我给你介绍了响应式的概念以及我们为什么需要响应式，具体Vue 3的响应式源码，我会在课程第四部分带你手写一个。</p><p>然后，通过对useStorage的封装，我为你讲解了响应式机制的进阶用法，那就是可以把一切项目中的状态和数据都封装成响应式的接口，屏蔽了浏览器的API，对外暴露的就是普通的数据，可以极大地提高我们的开发效率。</p><p>接着，我带你了解了VueUse这个工具包，这也是Vue官方团队成员的作品。VueUse提供了一大批工具函数，包括全屏、网络请求、动画等，都可以使用响应式风格的接口去使用，并且同时兼容 Vue 2 和 Vue 3，开箱即用。这门课程剩下的项目中会用到很多VueUse的函数，也推荐你去GitHub 关注 VueUse的动态和功能。</p><h2>思考题</h2><p>最后，留给你一道思考题：你的项目中有哪些数据可以封装成响应式数据呢？</p><p>欢迎在评论区留言，我会跟你一起探究Vue 3响应式的其他用法，也欢迎你把这篇文章分享给其他人，我们下一讲见！</p>',
        article_title: "07 | 巧妙的响应式：深入理解Vue 3的响应式机制",
      },
      {
        title: "08 | 组件化：如何像搭积木一样开发网页？",
        id: 435439,
        content:
          '<p>你好，我是大圣。</p><p>在上一讲中，我给你讲解了响应式的基本原理和进阶用法。除了响应式，组件相关的知识在Vue中也非常重要，所以今天我就跟你聊一下Vue的组件化机制。</p><p>在我们的项目中，组件无处不在，通过对组件功能的封装，可以像搭积木一样开发网页。而我们现在已经很难想象，没有组件的开发状态是什么样了。你可以看下面 Vue官方的示例图，它对组件化开发做了形象化的展示。图中的左边是一个网页，可以按照功能模块抽象成很多组件，这些组件就像积木一样拼接成网页。</p><p><img src="https://static001.geekbang.org/resource/image/0e/39/0e922d413eeeac4378233baa254dd039.png?wh=1406x544" alt="图片"></p><h2>什么是组件化开发</h2><p>谈组件化开发之前，我们先来看看什么是组件。举个通俗的例子，我们在页面的源码里写出的button标签，会在前端页面中显示出下面的样式：</p><p><img src="https://static001.geekbang.org/resource/image/eb/91/eb35f15db1cd10a804aebfe140da5991.png?wh=1866x958" alt="图片"></p><p>这个button其实就是一个组件，这样前端页面在显示上会加上边框和鼠标悬停的样式，还可以使用click事件触发函数等。只不过这是浏览器帮我们封装好的组件，我们在编辑代码的任何地方，只需要使用下面的代码，就可以让前端页面显示一个按钮。</p><pre><code class="language-xml">&lt;button&gt; 按钮 &lt;/button&gt;\n</code></pre><p>除了浏览器自带的组件外，Vue 还允许我们自定义组件，把一个功能的模板（template）封装在一个.vue文件中。例如在下图中，我们把每个组件的逻辑和样式，也就是把JavaScript 和CSS封装在一起，方便在项目中复用整个组件的代码。</p><!-- [[[read_end]]] --><p><img src="https://static001.geekbang.org/resource/image/43/06/439386a5f3f2463feb8d908a752ac406.jpg?wh=1920x1081" alt="图片"></p><p>我们实际开发的项目中有导航、侧边栏、表格、弹窗等组件，并且也会引入Element3这个组件库进行开发。此外，我们也会定制业务相关的组件，最终通过这些组件，搭积木式地把页面搭建起来。</p><p>Vue已经把组件化的机制实现得很好了，你只需要在这个基础之上，去掌握和学习组件化在使用上的设计理念。这样做的目的是实现高效的代码复用，在后续的项目开发中，我们会把组件分成两个类型，一个是通用型组件，一个是业务型组件。</p><p>通用型组件就是各大组件库的组件风格，包括按钮、表单、弹窗等通用功能。业务型组件包含业务的交互逻辑，包括购物车、登录注册等，会和我们不同的业务强绑定。</p><p>组件的开发由于要考虑代码的复用性，会比通常的业务开发要求更高，需要有更好的可维护性和稳定性的要求。为了帮助你理解设计组件的要点，我先选择一个简单的组件展开讲解。小圣在继续开发项目的时候，有一个评级的需求，简单来说，就是在前端页面上，能够让商品显示1到5的评分。我会借此教小圣在组件开发上的入门和应用，并依次讲解组件的设计思路。</p><h2>渲染评级分数</h2><p>其实，对于简单的评级需求，我们就可以使用组件。这样，只需要一行代码就可以实现评级需求。比如下面的代码，rate是1到5的整数，通过slice方法，我们直接渲染出对应数量的星星即可。</p><pre><code class="language-xml">"★★★★★☆☆☆☆☆".slice(5 - rate, 10 - rate)\n</code></pre><p>想要查看上面这行代码的效果，你只需要传入评分值rate。这行代码的运行效果如下图所示，其中的星星代表着评价的等级，由rate的值来决定。</p><p><img src="https://static001.geekbang.org/resource/image/ae/0f/aef45ab07edd11e6399b0029887bee0f.png?wh=501x548" alt="图片"></p><p>每个组件渲染的内容并不完全一样，这是我们写组件时首先要确认的内容。每个组件在项目中的不同地方，会渲染不同的内容。</p><p>我们在这里写的这个组件就是根据rate的值，来渲染出不同数量的星星。我们进入到src/components目录，新建Rate.vue，然后写出下面的代码。在下面的代码中，我们使用defineProps来规范传递数据的格式，这里规定了组件会接收外部传来的value属性，并且只能是数字，然后根据value的值计算出评分的星星。</p><pre><code class="language-xml">&lt;template&gt;\n    &lt;div&gt;\n        {{rate}}\n    &lt;/div&gt;\n&lt;/template&gt;\n\n&lt;script setup&gt;\nimport { defineProps,computed } from \'vue\';\nlet props = defineProps({\n    value: Number\n})\nlet rate = computed(()=&gt;"★★★★★☆☆☆☆☆".slice(5 - props.value, 10 - props.value))\n&lt;/script&gt;\n</code></pre><p>使用组件的方式就是使用:value的方式，通过属性把score传递给Rate组件，就能够在页面上根据score的值，显示出三颗实心的星星。下面的代码展示了如何使用Rate组件来显示3颗星星。</p><pre><code class="language-xml">&lt;template&gt;\n&lt;Rate :value="score"&gt;&lt;/Rate&gt;\n&lt;/template&gt;\n\n&lt;script setup&gt;\nimport {ref} from \'vue\'\nimport Rate from \'./components/Rate1.vue\'\nlet score = ref(3)\n&lt;/script&gt;\n</code></pre><p>根据传递的score值显示的不同的内容，我们也可以更进一步，回到Rate.vue代码里，加入如下的代码，比如在组件中内置一些主题颜色，加入CSS的内容。如下面代码，Rate组件新接收一个属性theme，默认值是orange。我们在Rate组件中内置了几个主题颜色，根据传递的theme计算出颜色，并且使用 :style 渲染。</p><pre><code class="language-xml">&lt;template&gt;\n    &lt;div :style="fontstyle"&gt;\n        {{rate}}\n    &lt;/div&gt;\n&lt;/template&gt;\n\n&lt;script setup&gt;\nimport { defineProps,computed, } from \'vue\';\nlet props = defineProps({\n    value: Number,\n    theme:{type:String,default:\'orange\'}\n})\nconsole.log(props)\nlet rate = computed(()=&gt;"★★★★★☆☆☆☆☆".slice(5 - props.value, 10 - props.value))\n\nconst themeObj = {\n  \'black\': \'#00\',\n  \'white\': \'#fff\',\n  \'red\': \'#f5222d\',\n  \'orange\': \'#fa541c\',\n  \'yellow\': \'#fadb14\',\n  \'green\': \'#73d13d\',\n  \'blue\': \'#40a9ff\',\n}\nconst fontstyle = computed(()=&gt; {\n    return `color:${themeObj[props.theme]};`\n})\n\n&lt;/script&gt;\n</code></pre><p>在完成了上面代码所示的这一过程，也就是通过theme渲染星星颜色这一步，我们就可以使用下面的代码，传递value和theme两个属性，并且可以很方便地复用组件。</p><pre><code class="language-xml">&lt;Rate :value="3" &gt;&lt;/Rate&gt;\n&lt;Rate :value="4" theme="red"&gt;&lt;/Rate&gt;\n&lt;Rate :value="1" theme="green"&gt;&lt;/Rate&gt;\n</code></pre><p>在下图中，也可以看到上面三个组件渲染的结果：</p><p><img src="https://static001.geekbang.org/resource/image/8c/84/8cf702e0842ba6307856108c1acaa784.jpg?wh=227x170" alt=""></p><h2>组件事件</h2><p>使用这个Rate组件后，虽然前端页面显示评级的需求是完成了，但是评级组件还需要具备修改评分的功能，所以我们需要让组件的星星可点击，并且让点击后的评分值能够传递到父组件。</p><p>在Vue中，我们使用emit来对外传递事件，这样父元素就可以监听Rate组件内部的变化。现在我们对Rate组件进行改造，首先由于我们的星星都是普通的文本，没有办法单独绑定click事件。所以我们要对模板进行改造，每个星星都用span包裹，并且我们可以用width属性控制宽度，支持小数的评分显示。</p><p>我们回到Rate.vue组件，添加下面的代码，我们把★和☆用span包裹，并绑定鼠标的mouseover事件。然后通过:style，我们可以设置实心五角星★的宽度，实现一样的评级效果。</p><pre><code class="language-xml">&lt;template&gt;\n&lt;div :style="fontstyle"&gt;\n    &lt;div class=\'rate\' @mouseout="mouseOut"&gt;\n      &lt;span @mouseover="mouseOver(num)"  v-for=\'num in 5\' :key="num"&gt;☆&lt;/span&gt;\n      &lt;span class=\'hollow\' :style="fontwidth"&gt;\n        &lt;span @mouseover="mouseOver(num)" v-for=\'num in 5\' :key="num"&gt;★&lt;/span&gt;\n      &lt;/span&gt;\n    &lt;/div&gt; \n&lt;/div&gt;\n&lt;/template&gt;\n&lt;script setup&gt;\n// ...其他代码\n// 评分宽度\nlet width = ref(props.value)\nfunction mouseOver(i){\n    width.value = i \n}\nfunction mouseOut(){\n    width.value = props.value\n}\nconst fontwidth = computed(()=&gt;`width:${width.value}em;`)\n\n&lt;/script&gt;\n\n&lt;style scoped&gt;\n.rate{\n  position:relative;\n  display: inline-block;\n}\n.rate &gt; span.hollow {\n  position:absolute;\n  display: inline-block;\n  top:0;\n  left:0;\n  width:0;\n  overflow:hidden;\n}\n&lt;/style&gt;\n</code></pre><p>因为现在是通过宽度显示星星，所以我们还可以支持3.5分的小数评级，并且支持鼠标滑过的时候选择不同的评分。用下面的代码，我们可以使用Rate组件。</p><pre><code class="language-xml">&lt;Rate :value="3.5" &gt;&lt;/Rate&gt;\n</code></pre><p>上面代码的显示效果如下图所示：</p><h1><img src="https://static001.geekbang.org/resource/image/9a/16/9ab95503a0f65fc69896e30e21de8816.gif?wh=522x185" alt="图片"></h1><p>然后我们需要做的，就是在点击五角星选择评分的时候，把当前评分传递给父组件即可。在Vue 3中，我们使用defineEmit来定义对外“发射”的数据，在点击评分的时候触发即可。下面的defineEmit代码就展示了点击评分后，向父元素“发射”评分数据num。</p><pre><code class="language-xml">&lt;template&gt;\n  省略代码\n   &lt;span @click="onRate(num)" @mouseover="mouseOver(num)" v-for=\'num in 5\' :key="num"&gt;★&lt;/span&gt;\n\n&lt;/template&gt;\n&lt;script setup&gt;\nimport { defineProps, defineEmits,computed, ref} from \'vue\';\n\nlet emits = defineEmits(\'update-rate\')\nfunction onRate(num){\n    emits(\'update-rate\',num)\n}\n&lt;/script&gt;\n</code></pre><p>在下面的代码中，我们使用@update-rate 接收Rate组件emit的数据，并且修改score的值，这样就完成了数据修改后的更新。</p><pre><code class="language-xml">&lt;template&gt;\n\n&lt;h1&gt;你的评分是 {{score}}&lt;/h1&gt;\n&lt;Rate :value="score" @update-rate="update"&gt;&lt;/Rate&gt;\n\n&lt;/template&gt;\n\n&lt;script setup&gt;\nimport {ref} from \'vue\'\nimport Rate from \'./components/Rate1.vue\'\nlet score = ref(3.5)\nfunction update(num){\n    score.value = num\n}\n\n&lt;/script&gt;\n\n</code></pre><p>现在组件的示意图如下，我们通过defineProps定义了传递数据的格式，通过defineEmits定义了监听的函数，最终实现了组件和外部数据之间的同步。</p><p><img src="https://static001.geekbang.org/resource/image/43/1b/43767ceb3324b4887271d0d20909a31b.jpg?wh=1904x1279" alt="图片"></p><h2>组件的v-model</h2><p>上面Rate组件中数据双向同步的需求在表单领域非常常见，例如<a href="https://time.geekbang.org/column/article/428106">第二讲</a>中，我们在input标签上使用v-model这个属性就实现了这个需求。在自定义组件上我们也可以用v-model，对于自定义组件来说，v-model是传递属性和接收组件事件两个写法的简写。</p><p>在下面的代码中，首先我们把属性名修改成modelValue，然后如果我们想在前端页面进行点击评级的操作，我们只需要通过update:modelValue这个emit事件发出通知即可。</p><pre><code class="language-xml">let props = defineProps({\n    modelValue: Number,\n    theme:{type:String,default:\'orange\'}\n})\nlet emits = defineEmits([\'update:modelValue\'])\n</code></pre><p>然后我们就可以按如下代码中的方式，使用Rate这个组件，也就是直接使用v-model绑定score变量。这样，就可以实现value和onRate两个属性的效果。</p><pre><code class="language-xml"> &lt;template&gt;\n\n&lt;h1&gt;你的评分是 {{score}}&lt;/h1&gt;\n&lt;Rate v-model="score"&gt;&lt;/Rate&gt;\n&lt;/template&gt;\n</code></pre><h2>插槽</h2><p>和HTML的标签使用类似，很多时候我们也需要给组件中传递内容。就像在下面的代码中click并不是button标签的属性，而是子元素，button标签会把子元素渲染在居中的位置。</p><pre><code class="language-xml">&lt;button&gt; click &lt;/button&gt;\n</code></pre><p>我们的Rate组件也是类似的，在Vue中直接使用slot组件来显示组件的子元素，也就是所谓的插槽。在下面的代码中，我们使用slot组件渲染Rate组件的子元素。</p><pre><code class="language-xml">&lt;template&gt;\n&lt;div :style="fontstyle"&gt;\n    &lt;slot&gt;&lt;/slot&gt;\n    &lt;div class=\'rate\' @mouseout="mouseOut"&gt;\n      &lt;span @mouseover="mouseOver(num)"  v-for=\'num in 5\' :key="num"&gt;☆&lt;/span&gt;\n      &lt;span class=\'hollow\' :style="fontwidth"&gt;\n        &lt;span @click="onRate(num)" @mouseover="mouseOver(num)" v-for=\'num in 5\' :key="num"&gt;★&lt;/span&gt;\n      &lt;/span&gt;\n    &lt;/div&gt; \n&lt;/div&gt;\n&lt;/template&gt;\n</code></pre><p>我们现在使用Rate组件的时候，组件的子元素都会放在评级组件之前。除了文本，也可以传递其他组件或者html标签 。下面代码显示的结果，第一个Rate组件显示课程评分 ，第二个Rate组件前面显示一个图片。</p><pre><code class="language-xml">&lt;Rate v-model="score"&gt;课程评分&lt;/Rate&gt;\n&lt;Rate v-model="score"&gt;\n    &lt;img width="14" src="/favicon.ico"&gt;\n&lt;/Rate&gt;\n</code></pre><h2>总结</h2><p>至此，我们设计了一个非常迷你的评级组件，我带你回顾一下今天都做了什么吧。</p><p>首先，我们用props属性传递的方式，通过传递的value属性去决定显示的星星数量，这也是设计组件的时候首先就要考虑的。一个组件库首先要实现的，就是通过props属性渲染内容，而在Rate组件里，我们可以根据value属性去渲染显示了几颗星星。</p><p>然后为了让用户可以点击评分，我们优化了显示的方式，每个★包裹一个span标签，并且绑定了mouseover和mouseout事件显示鼠标悬停的样式，最后在★标签的click事件上，对外通知事件，告知父组件数据的变化。</p><p><strong>对于这个通知机制，我们使用defineEmits定义的方式来实现，这也是Vue组件中重要的数据交换机制</strong>。emits配合props，这样我们在使用一个组件的时候，就实现了给组件传递数据，并且我们也能够监听组件内部数据的变化。最后我们通过规范props和emit的名字，实现了直接在自定义的组件之上使用v-model。</p><p>当然，这个组件开发到这里，依然是比较精简，但实际上我们要考虑的问题更多。比如在下一讲，我会给你讲解如何在Vue中加上一些简单的动画。字符★显示的效果可能也不符合你所在公司的设计规范，所以你可能就需要使用图片替换五角星样式等。</p><p>更加完备的Rate组件，你可以去看<a href="https://github.com/hug-sun/element3/blob/master/packages/element3/packages/rate/Rate.vue">Element3评级组件的实现</a>，在这里我们先初步感受一个组件的完整设计过程，它包含着交互的小细节，比如键盘事件、自定义icon等等。</p><p>Rate组件写完，Vue的组件化你就算入门了，在课程第三部分中，我们会对更多场景的组件化进行实战开发，在那里我会给你详细说说更多组件进阶和扩展的用法。</p><h2>思考题</h2><p>今天我带你从0设计了一个组件，相信你对Vue 3的组件设计也有了新的思考，那么关于这个Rate组件，你觉得还有哪些功能扩展的需求呢？</p><p>欢迎在评论区分享你的思考，也欢迎你把这一讲分享给其他人，我们下一讲见！</p>',
        article_title: "08 | 组件化：如何像搭积木一样开发网页？",
      },
      {
        title: "09 | 动画：Vue中如何实现动画效果？",
        id: 436783,
        content:
          '<p>你好，我是大圣。</p><p>在上一讲中，我给你讲解了组件化设计的思路，有了组件，我们就可以积木式地搭建网页了。领会组件设计的思路后，小圣继续丰富了清单组件的功能，在组件的功能实现完毕后，我给他提出了一个新的要求，希望能有一些动画效果的加入，让这个应用显得不再这么生硬。</p><p>小圣自己琢磨以后，又找过来咨询我Vue 3中实现动画的方式，所以今天我就来跟你聊一下Vue中应该如何实现常见的过渡和动效。在讲解过程中，我们会继续给之前那个清单应用添砖加瓦，给它添加更多酷炫的玩法，让我们正式开始今天的学习吧。</p><h2>前端过渡和动效</h2><p>在讲Vue中的动效和过渡之前，我想先跟你聊一下前端的过渡和动效的实现方式。举个例子，假设我现在有这样一个需求：在页面上要有一个div标签，以及一个按钮，点击页面的按钮后，能够让div标签的宽度得到增加。</p><p>在下面的代码中，我们可以实现上面所说的这个效果。这段代码里，首先是一个div标签，我们使用width控制宽度。我们想要的前端效果是，每次点击按钮的时候，div标签的宽度都增加100px。</p><pre><code class="language-xml">&lt;template&gt;\n\n  &lt;div class="box" :style="{width:width+\'px\'}"&gt;&lt;/div&gt;\n  &lt;button @click="change"&gt;click&lt;/button&gt;\n&lt;/template&gt;\n\n&lt;script setup&gt;\nimport {ref} from \'vue\'\nlet width= ref(100)\nfunction change(){\n  width.value += 100\n}\n&lt;/script&gt;\n\n&lt;style&gt;\n.box{\n  background:red;\n  height:100px;\n}\n&lt;/style&gt;\n</code></pre><!-- [[[read_end]]] --><p>这个功能实现的效果图如下，小圣虽然实现了需求中提到的功能，但是现在的显示效果很生硬，这点你从下面的动态效果图中也能看出来。</p><p><img src="https://static001.geekbang.org/resource/image/0a/ef/0a52318a2a136bebbe711a70e5b2f0ef.gif?wh=991x310" alt="图片"></p><p>为了优化显示的效果，首先我们可以通过一个CSS的属性transition来实现过渡，实现方式非常简单，直接在div的样式里加上一个transition配置就可以了。下面是具体的实现，其中我们给transition配置了三个参数，简单解释呢，就是div的width属性需要过渡，过渡时间是1秒，并且过渡方式是线性过渡。</p><pre><code class="language-xml">&lt;style&gt;\n.box{\n  background:#d88986;\n  height:100px;\n  transition: width 1s linear;\n}\n&lt;/style&gt;\n</code></pre><p>添加上述transition配置后，前端页面会显示如下的过渡效果，是不是流畅了一些呢？实际上，日常项目开发中类似的过渡效果是很常见的。</p><p><img src="https://static001.geekbang.org/resource/image/dd/e4/dd5bcf6e3dbcb4bd84f97093bc0a08e4.gif?wh=991x310" alt="图片"></p><p>现在你能看到，<strong>我们可以通过transition来控制一个元素的<strong><strong>属</strong></strong>性的值，缓慢地变成另外一个值，这种操作就称之为过渡</strong>。除了transition，我们还可以通过animation和keyframe的组合实现动画。</p><p>在下面的代码中，我们指定标签的antimation配置，给标签设置move动画，持续时间为两秒，线性变化并且无限循环。然后使用@keyframes 定制move动画，内部定义了动画0%、50%和100%的位置，最终实现了一个方块循环移动的效果。</p><pre><code class="language-xml">.box1{\n  width:30px;\n  height:30px;\n  position: relative;\n  background:#d88986;\n  animation: move 2s linear infinite;\n}\n@keyframes move {\n  0% {left:0px}\n  50% {left:200px}\n  100% {left:0}\n}\n</code></pre><p>上面代码的实现效果如下：</p><p><img src="https://static001.geekbang.org/resource/image/8c/20/8c070a460f13cb979cc393b55ac6a420.gif?wh=991x310" alt="图片"></p><p>这就是实现前端动画最简单的方式了，在网页应用开发的场景下，或多或少都会有过渡动画的使用需求。从最基本的颜色和位置的渐变，到页面切换都是动画的应用场景，这些动画在视觉和心理的体验上更加友好，比如等待时间的Loading加载提示，弹窗出现的显示动画等。</p><h2>Vue 3动画入门</h2><p>通常我们实现的动画，会给Web应用带来额外的价值。动画和过渡可以增加用户体验的舒适度，让变化更加自然，并且可以吸引用户的注意力，突出重点。transition和animation让我们可以用非常简单的方式实现动画。那么在Vue 3中，我们到底该如何使用动画呢？</p><p>Vue 3中提供了一些动画的封装，使用内置的transition组件来控制组件的动画。为了让你先有一个感性的认识，这里我们先来举一个最简单的例子：我们可以使用一个按钮控制标题文字的显示和隐藏，具体的代码如下，通过点击按钮，就可以控制h1标签的显示和隐藏。</p><pre><code class="language-xml">&lt;template&gt;\n\n  &lt;button @click="toggle"&gt;click&lt;/button&gt;\n  &lt;h1 v-if="showTitle"&gt;你好 Vue 3&lt;/h1&gt;\n&lt;/template&gt;\n\n&lt;script setup&gt;\nimport {ref} from \'vue\'\nlet showTitle = ref(true)\nfunction toggle(){\n  showTitle.value = !showTitle.value\n}\n&lt;/script&gt;\n</code></pre><p>在Vue中，如果我们想要在显示和隐藏标题文字的时候，加入动效进行过渡，那么我们直接使用transition组件包裹住需要动画的元素就可以了。</p><p>在下面代码中，我们使用transition包裹h1标签，并且设置了name为fade，Vue会在h1标签显示和隐藏的过程中去设置标签的class，我们可以根据这些class去实现想要的动效。</p><pre><code class="language-xml">  &lt;transition name="fade"&gt;\n    &lt;h1 v-if="showTitle"&gt;你好 Vue 3&lt;/h1&gt;\n  &lt;/transition&gt;\n</code></pre><p>具体class的名字，Vue 的官网有一个图给出了很好的解释，图里的v-enter-from中的v，就是我们设置的name属性。所以在我们现在这个案例中，标签在进入和离开的时候，会有fade-enter-active和fade-leave-active的class，进入的开始和结束会有fade-enter-from和face-enter-to两个class。</p><p><img src="https://static001.geekbang.org/resource/image/71/92/718a6019316ed75f6d040e4983957692.png?wh=1920x866" alt="图片"></p><p>根据上图所示的原理，我们在style标签中新增如下代码，通过fade-enter-active和fade-leave-active两个class，去控制动画全程的过渡属性。设置opacity有0.5秒的过渡时间，并且在元素进入前和离开后设置opacity为0。</p><pre><code class="language-xml">&lt;style&gt;\n.fade-enter-active,\n.fade-leave-active {\n  transition: opacity 0.5s linear;\n}\n\n.fade-enter-from,\n.fade-leave-to {\n  opacity: 0;\n}\n&lt;/style&gt;\n</code></pre><p>通过对元素进入和离开的过渡设置，我们可以实现如下动画：</p><p><img src="https://static001.geekbang.org/resource/image/af/e0/afeed23b2f92cac24de8b83fe3df80e0.gif?wh=460x290" alt="图片"></p><h2>清单应用优化</h2><p>现在，我们通过学到的动画原理，去优化一下第二讲的清单应用。我们先来了解一下操作的场景，在原先清单应用已有的交互下，有一个交互的优化，我们想对交互再增加一个优化项。具体来说，就是当输入框为空的时候，敲击回车需要弹出一个错误的提示。</p><p>小圣同学对Composition API已经非常熟悉了，很快速地写下了下面的代码。小圣在代码的template中新增了一个显示错误消息的div，设置为绝对定位，通过showModal变量控制显示和隐藏。并且在addTodo函数中，如果title.value为空，也就是用户输入为空的时候，就设置showModal为true。这时，如果用户敲击回车，就会显示弹窗，并且定时关闭。</p><pre><code class="language-xml">&lt;template&gt;\n...清单代码\n  &lt;div class="info-wrapper" v-if="showModal"&gt;\n    &lt;div class="info"&gt;\n      哥，你啥也没输入！\n    &lt;/div&gt;\n  &lt;/div&gt;\n&lt;/template&gt;\n\n&lt;script setup&gt;\n...清单功能代码\n  let showModal = ref(false)\n\n  function addTodo() {\n    if(!title.value){\n      showModal.value = true\n      setTimeout(()=&gt;{\n        showModal.value = false\n      },1500)\n      return \n    }\n    todos.value.push({\n      title: title.value,\n      done: false,\n    });\n    title.value = "";\n  }\n&lt;/script&gt;\n&lt;style&gt;\n.info-wrapper {\n  position: fixed;\n  top: 20px;\n  width:200px;\n}\n.info {\n  padding: 20px;\n  color: white;\n  background: #d88986;\n}\n&lt;/style&gt;\n</code></pre><p>新增交互后的前端显示效果如下，敲击回车后，如果输入为空，就会显示错误信息的弹窗。</p><p><img src="https://static001.geekbang.org/resource/image/60/47/60aea2a58ccb29ca0676189dfd3b9d47.gif?wh=646x463" alt="图片"></p><p>功能虽然实现了，但是我们想进一步提高弹窗的交互效果，也就是弹窗的显示需要新增动画。对于这个需求，我们在直接使用transition包裹弹窗之后，设置对应进入和离开的CSS样式就可以了。首先，我们给transition动画设置name为modal，在style中通过对model对应的CSS设置过渡效果后，就给弹窗增加了弹窗的效果。</p><pre><code class="language-xml">&lt;transition name="modal"&gt;\n  &lt;div class="info-wrapper" v-if="showModal"&gt;\n    &lt;div class="info"&gt;\n      哥，你啥也没输入！\n    &lt;/div&gt;\n   &lt;/div&gt;\n&lt;/transition&gt;\n\n\n\n&lt;style&gt;\n  .modal-enter-from {\n    opacity: 0;\n    transform: translateY(-60px);\n  }\n  .modal-enter-active {\n    transition: all 0.3s ease;\n  }\n  .modal-leave-to {\n    opacity: 0;\n    transform: translateY(-60px);\n  }\n  .modal-leave-active {\n    transition: all 0.3s ease;\n  }\n&lt;/style&gt;\n</code></pre><p>通过上面的代码，我们可以进行过渡效果的优化。优化后，前端页面的显示效果如下，可以看到弹窗有一个明显的滑入和划出的过渡效果。</p><p><img src="https://static001.geekbang.org/resource/image/1d/b4/1ddf1492ebddce584eac161e65d49bb4.gif?wh=646x463" alt="图片"></p><h2>列表动画</h2><p>学了transition组件后，小圣兴致勃勃地把清单应用的列表也做了动画显示，但是现在清单列表并不是一个单独的标签，而是v-for渲染的列表元素，所以小圣就来找我求助，问我怎么实现列表项依次动画出现的效果。</p><p>在Vue中，我们把这种需求称之为列表过渡。因为transition组件会把子元素作为一个整体同时去过渡，所以我们需要一个新的内置组件transition-group。在v-for渲染列表的场景之下，我们使用transition-group组件去包裹元素，通过tag属性去指定渲染一个元素。</p><p>此外，transition-group组件还有一个特殊之处，就是不仅可以进入和离开动画，还可以改变定位。就和之前的类名一样，这个功能新增了v-move类，在下面的代码中，使用transition-group包裹渲染的li元素，并且设置动画的name属性为flip-list。然后我们根据v-move的命名规范，设置 <code>.flip-list-move</code> 的过渡属性，就实现了列表依次出现的效果了。</p><pre><code class="language-xml">    &lt;ul v-if="todos.length"&gt;\n      &lt;transition-group name="flip-list" tag="ul"&gt;\n        &lt;li v-for="todo in todos" :key="todo.title"&gt;\n          &lt;input type="checkbox" v-model="todo.done" /&gt;\n          &lt;span :class="{ done: todo.done }"&gt; {{ todo.title }}&lt;/span&gt;\n        &lt;/li&gt;\n      &lt;/transition-group&gt;\n\n    &lt;/ul&gt;\n&lt;style&gt;\n.flip-list-move {\n  transition: transform 0.8s ease;\n}\n.flip-list-enter-active,\n.flip-list-leave-active {\n  transition: all 1s ease;\n}\n.flip-list-enter-from,\n.flip-list-leave-to {\n  opacity: 0;\n  transform: translateX(30px);\n}\n&lt;/style&gt;\n</code></pre><p>通过上面的代码，我们就可以得到如下的实现效果。你可以看到，在新增列表和显示错误信息的弹窗上，都设置了过渡和动画。</p><h2><img src="https://static001.geekbang.org/resource/image/0b/a7/0b68e2ec1b617461f198094bd643aea7.gif?wh=646x463" alt="图片"></h2><h2>页面切换动画</h2><p>对于一般的前端页面应用来说，还有一个常见的动画切换的场景，就是在页面切换这个场景时的动画。<strong>这个动画切换场景的核心原理和弹窗动画是一样的，都是通过transition标签控制页面进入和离开的class</strong>。</p><p>现在默认是在vue-router的模式下，我们使用router-view组件进行动态的组件渲染。在路由发生变化的时候，我们计算出对应匹配的组件去填充router-view。</p><p>如果要在路由组件上使用转场，并且对导航进行动画处理，你就需要使用v-slot API。我们来到src/App.vue组件中，因为之前router-view没有子元素，所以我们要对代码进行修改。</p><p>在下面的代码中，router-view通过v-slot获取渲染的组件并且赋值给Component，然后使用transition 包裹需要渲染的组件，并且通过内置组件component的is属性动态渲染组件。这里vue-router的动画切换效果算是抛砖引玉，关于vue-router进阶的适用内容，全家桶实战篇后面的几讲还会继续深入剖析。</p><pre><code class="language-xml">&lt;router-view v-slot="{ Component }"&gt;\n  &lt;transition  name="route" mode="out-in"&gt;\n    &lt;component :is="Component" /&gt;\n  &lt;/transition&gt;\n&lt;/router-view&gt;\n</code></pre><h2>JavaScript动画</h2><p>在前端的大部分交互场景中，动画的主要目的是提高交互体验，CSS动画足以应对大部分场景。但如果碰见比较复杂的动画场景，就需要用JavaScript来实现，比如购物车、地图等场景。</p><p>在下面的代码中，我们首先在清单应用中加上一个删除事项的功能，当点击删除图标来删除清单的时候，可以直接删除一行。</p><pre><code class="language-xml">&lt;template&gt;\n\n    ...清单应用其他代码\n    \n      &lt;transition-group name="flip-list" tag="ul"&gt;\n        &lt;li v-for="(todo,i) in todos" :key="todo.title"&gt;\n          &lt;input type="checkbox" v-model="todo.done" /&gt;\n          &lt;span :class="{ done: todo.done }"&gt; {{ todo.title }}&lt;/span&gt;\n          &lt;span class="remove-btn" @click="removeTodo($event,i)"&gt;\n            ❌\n          &lt;/span&gt;\n        &lt;/li&gt;\n      &lt;/transition-group&gt; \n&lt;/template&gt;\n&lt;script&gt;\n  function removeTodo(e,i){\n    todos.value.splice(i,1)\n  }\n&lt;/script&gt;\n</code></pre><p>通过上面的代码，我们能实现下面所示的效果：</p><p><img src="https://static001.geekbang.org/resource/image/5a/b2/5afba5a388f940995c39de50d04f7fb2.gif?wh=661x381" alt="图片"></p><p>如果我们想在删除的时候，实现一个图标飞到废纸篓的动画，那么在这个场景下，使用单纯的CSS动画就不好实现了，我们需要引入JavaScript来实现动画。实现的思路也很简单，我们放一个单独存在的动画元素并且藏起来，当点击删除图标的时候，我们把这个动画元素移动到鼠标的位置，再飞到废纸篓里藏起来就可以了。</p><p>具体怎么做呢？ 在Vue的transition组件里，我们可以分别设置before-enter，enter和after-enter三个函数来更精确地控制动画。</p><p>在下面的代码中，我们首先定义了animate响应式对象来控制动画元素的显示和隐藏，并且用transition标签包裹动画元素。在beforeEnter函数中，通过getBoundingClientRect函数获取鼠标的点击位置，让动画元素通过translate属性移动到鼠标所在位置；并且在enter钩子中，把动画元素移动到初始位置，在afterEnter中，也就是动画结束后，把动画元素再隐藏起来，这样就实现了类似购物车的飞入效果。</p><pre><code class="language-xml">&lt;template&gt;\n    &lt;span class="dustbin"&gt;\n      🗑\n    &lt;/span&gt;\n&lt;div class="animate-wrap"&gt;\n    &lt;transition @before-enter="beforeEnter" @enter="enter" @after-enter="afterEnter"&gt;\n        &lt;div class="animate" v-show="animate.show"&gt;\n            📋\n        &lt;/div&gt;\n    &lt;/transition&gt;\n&lt;/div&gt;\n&lt;/template&gt;\n\n&lt;script setup&gt;\n\nlet animate = reactive({\n  show:false,\n  el:null\n})\nfunction beforeEnter(el){\n      let dom = animate.el\n      let rect = dom.getBoundingClientRect()\n      let x = window.innerWidth - rect.left - 60\n      let y = rect.top - 10\n      el.style.transform = `translate(-${x}px, ${y}px)`\n}\nfunction enter(el,done){\n      document.body.offsetHeight\n      el.style.transform = `translate(0,0)`\n      el.addEventListener(\'transitionend\', done)\n}\nfunction afterEnter(el){\n      animate.show = false\n      el.style.display = \'none\'\n}\nfunction removeTodo(e,i){\n  animate.el = e.target\n  animate.show = true\n  todos.value.splice(i,1)\n}\n&lt;/script&gt;\n&lt;style&gt;\n.animate-wrap .animate{\n    position :fixed;\n    right :10px;\n    top :10px;\n    z-index: 100;\n    transition: all 0.5s linear;\n}\n&lt;/style&gt;\n</code></pre><p>上面代码的显示效果如下，我们点击删除后，除了列表本身的动画移出效果，还多了一个飞入废纸篓的效果。你能看到，在引入JavaScript后，我们可以实现更多定制的动画效果。</p><h2><img src="https://static001.geekbang.org/resource/image/0d/00/0da30b53ee409874259965d0a86d4400.gif?wh=661x381" alt="图片"></h2><h2>总结</h2><p>今天这一讲的主要内容讲完了，我们来简单复习一下今天学到的知识点。</p><p>首先我们学习了前端使用CSS实现简单动画的transition和animation两个配置；然后，我们了解到了通过Vue 3提供的transition组件，我们可以控制在Vue中动画元素进入和离开页面时候的class；通过制定的命名规范，在CSS中设置过渡和动画效果，从而很方便地实现过渡效果，并且丰富了清单应用的弹窗功能；在这之后，我们使用transition-group实现列表元素的动画；最后，我还带你了解了vue-router中页面切换动画的实现方式。</p><p>相信学完今天这一讲，你会对Vue 3中实现简单动画的方式有所领会。今天我们实现的动画功能其实是Vue中动画的入门实战，所以我特意带你体验了全套玩法。不过你需要注意的是，实际开发中动画也不是越多越好，动画的设计也需要设计师去系统地设计效果，不要用动画做出眼花缭乱的网页。</p><p>而且，实际开发中如果想实现更复杂的动画，比如常见电商中商品飞入购物车的效果，管理系统中丰富的动画效果等，只借助transition组件是很难实现的。你需要借助JavaScript和第三方库的支持，在beforeEnter、enter、afterEnter等函数中实现动画。</p><h2>思考题</h2><p>关于今天设计的弹窗动画，如果想实现一个振动的效果，该如何实现呢？</p><p>欢迎在留言区留言讨论，也欢迎你把这一讲推荐给你的朋友、同事。我们下一讲见！</p>',
        article_title: "09 | 动画：Vue中如何实现动画效果？",
      },
    ],
  },
  {
    chapterTitle: "全家桶实战篇",
    children: [
      {
        title: "10 | 数据流：如何使用Vuex设计你的数据流",
        id: 439588,
        content:
          '<p>你好，我是大圣，欢迎进入课程的第10讲。</p><p>前面的基础入门篇中的几讲，都是针对Vue本身的进阶内容。通过这几讲，我们巩固和进阶了Composition API、组件化和动画等关键知识，Vue本身的知识点已经掌握得差不多了。那么从这一讲开始，我们进入课程的全家桶实战篇。</p><p>在全家桶实战篇，我们将一同学习Vue 3的生态，包括Vuex、vue-router、Vue Devtools等生态库，以及实战开发中需要用到的库。这⼀模块学完，你就能全副武装，应对复杂的项目开发也会慢慢得心应手。</p><p>今天，我先来带你认识一下Vue全家桶必备的工具：Vuex，有了这个神兵利器，复杂项目设计也会变得条理更清晰。接下来，让我们先从Vuex解决了什么问题说起。</p><h2>前端数据管理</h2><p>首先，我们需要掌握前端的数据怎么管理，现代Web应用都是由三大件构成，分别是：组件、数据和路由。关于组件化开发，在前面的<a href="https://time.geekbang.org/column/article/435439">第8讲</a>中，已经有详细的讲解了。这一讲我们思考一个这样的场景，就是有一些数据组件之间需要共享的时候，应该如何实现？</p><p>解决这个问题的最常见的一种思路就是：专门定义一个全局变量，任何组件需要数据的时候都去这个全局变量中获取。一些通用的数据，比如用户登录信息，以及一个跨层级的组件通信都可以通过这个全局变量很好地实现。在下面的代码中我们使用_store这个全局变量存储数据。</p><!-- [[[read_end]]] --><pre><code class="language-xml">window._store = {}\n</code></pre><p>数据存储的结构图大致如下，任何组件内部都可以通过window._store获取数据并且修改。</p><p><img src="https://static001.geekbang.org/resource/image/4d/4b/4de32506d33f278704d2edd7b2d8914b.jpg?wh=1920x936" alt="图片"></p><p>但这样就会产生一个问题，window._store并不是响应式的，如果在Vue项目中直接使用，那么就无法自动更新页面。所以我们需要用ref和reactive去把数据包裹成响应式数据，并且提供统一的操作方法，这其实就是数据管理框架Vuex的雏形了。</p><h2>Vuex是什么</h2><p>你现在肯定跟小圣有同样的困惑，那就是感觉Vue已经够用了，这个Vuex又是做什么的？其实，Vuex存在的意义，就是管理我们项目的数据。</p><p>我们是使用组件化机制来搭建整个项目，每个组件内部有自己的数据和模板。但是总有些数据是需要共享的，比如当前登录的用户名、权限等数据，如果都在组件内部传递，会变得非常混乱。</p><p>如果把开发的项目比作公司的话，我们项目中的各种数据就非常像办公用品。很多小公司在初创时期不需要管理太多，大家随便拿办公用品就行。但是公司大了之后，就需要一个专门的办公用品申报的流程，对数据做统一地申请和发放，这样才能方便做资产管理。<strong>Vuex就相当于我们项目中的大管家，集中式存储管理应用的所有组件的状态</strong>。</p><p>下面，我们先来上手使用一下Vuex。我们项目结构中的src/store目录，就是专门留给Vuex的，在项目的目录下，我们执行下面这个命令，进行Vuex的安装工作。</p><pre><code>npm install vuex@next\n</code></pre><p>安装完成后，我们在src/store中先新建 index.js，在下面的代码中，我们使用createStore来创建一个数据存储，我们称之为store。</p><p>store内部除了数据，还需要一个mutation配置去修改数据，你可以把这个mutation理解为数据更新的申请单，mutation内部的函数会把state作为参数，我们直接操作state.count就可以完成数据的修改。</p><pre><code class="language-xml">import { createStore } from \'vuex\'\n\nconst store = createStore({\n  state () {\n    return {\n      count: 666\n    }\n  },\n  mutations: {\n    add (state) {\n      state.count++\n    }\n  }\n})\n</code></pre><p>现在你会发现，我们的代码里，在Vue的组件系统之外，多了一个数据源，里面只有一个变量count，并且有一个方法可以累加这个count。然后，我们在Vue中注册这个数据源，在项目入口文件src/main.js中，使用app.use(store)进行注册，这样Vue和Vuex就连接上了。</p><p>然后，我们使用 <code>.use</code> 就可以对路由进行注册，使用 <code>.mount</code> 就可以把 Vue 这个应用挂载到页面上，代码如下。</p><pre><code class="language-xml">const app = createApp(App)\napp.use(store)\n    .use(router)\n    .mount(\'#app\')\n</code></pre><p>之后，我们在src/components文件夹下新建一个Count.vue组件，在下面的代码中，template中的代码我们很熟悉了，就是一个div渲染了count变量，并且点击的时候触发add方法。在script中，我们使用useStore去获取数据源，初始化值和修改的函数有两个变化：</p><ul>\n<li>count不是使用ref直接定义，而是使用计算属性返回了store.state.count，也就是刚才在src/store/index.js中定义的count。</li>\n<li>add函数是用来修改数据，这里我们不能直接去操作 store.state.count +=1，因为这个数据属于Vuex统一管理，所以我们要使用store.commit(‘add’)去触发Vuex中的mutation去修改数据。</li>\n</ul><pre><code class="language-xml">&lt;template&gt;\n&lt;div @click="add"&gt;\n    {{count}}\n&lt;/div&gt;\n&lt;/template&gt;\n\n&lt;script setup&gt;\nimport { computed } from \'vue\'\nimport {useStore} from \'vuex\'\nlet store = useStore()\nlet count = computed(()=&gt;store.state.count)\n\nfunction add(){\n    store.commit(\'add\')\n}\n&lt;/script&gt;\n</code></pre><p>在浏览器中打开项目页面，我们就会有一个累加器的效果。相比起来之前用ref的方式，真的很简单，这时候小圣就问了我一个问题：什么时候的数据用Vuex管理，什么时候数据要放在组件内部使用ref管理呢？</p><p>答案就是，<strong>对于一个数据，如果只是组件内部使用就是用ref管理；如果我们需要跨组件，跨页面共享的时候，我们就需要把数据从Vue的组件内部抽离出来，放在Vuex中去管理</strong>。</p><p>我再结合例子具体说说：比如项目中的登录用户名，页面的右上角需要显示，有些信息弹窗也需要显示。这样的数据就需要放在Vuex中统一管理，每当需要抽离这样的数据的时候，我们都需要思考这个数据的初始化和更新逻辑。</p><p>就像下图中，项目初始化的时候没有登录状态，我们是在用户登录成功之后，才能获取用户名这个信息，去修改Vuex的数据，再通过Vuex派发到所有的组件中。</p><p><img src="https://static001.geekbang.org/resource/image/9f/b9/9fca00b12fb51d52bbb48277a3c4e2b9.jpg?wh=1920x1224" alt="图片"></p><h2>手写迷你Vuex</h2><p>知道了Vuex是什么，接下来我们不妨动手实现一个迷你的Vuex，这能让你看到Vuex的大致原理。</p><p>首先，我们需要创建一个变量store用来存储数据。下一步就是把这个store的数据包转成响应式的数据，并且提供给Vue组件使用。在Vue中有 <a href="https://v3.cn.vuejs.org/guide/component-provide-inject.html#%E5%A4%84%E7%90%86%E5%93%8D%E5%BA%94%E6%80%A7">provide/inject</a> 这两个函数专门用来做数据共享，provide注册了数据后，所有的子组件都可以通过inject获取数据，这两个函数官方文档介绍得比较详细，我在这里就不过多解释了。</p><p>完成刚才的数据转换之后，我们直接进入到src/store文件夹下，新建gvuex.js。下面的代码中，我们使用一个Store类来管理数据，类的内部使用_state存储数据，使用mutations来存储数据修改的函数，注意这里的state已经使用reactive包裹成响应式数据了。</p><pre><code class="language-xml">import { inject, reactive } from \'vue\'\n\nconst STORE_KEY = \'__store__\'\nfunction useStore() {\n  return inject(STORE_KEY)\n}\nfunction createStore(options) {\n  return new Store(options)\n}\nclass Store {\n  constructor(options) {\n    this._state = reactive({\n      data: options.state()\n    })\n    this._mutations = options.mutations\n  }\n}\nexport { createStore, useStore }\n</code></pre><p>上面的代码还暴露了createStore去创建Store的实例，并且可以在任意组件的setup函数内，使用useStore去获取store的实例。下一步我们回到src/store/index.js中，把vuex改成 ./gvuex。</p><p>下面的代码中，我们使用createStore创建了一个store实例，并且实例内部使用state定义了count变量和修改count值的add函数。</p><pre><code>// import { createStore } from \'vuex\'\nimport { createStore } from \'./gvuex\'\nconst store = ...\nexport default store\n</code></pre><p>最终我们使用store的方式，在项目入口文件src/main.js中使用app.use(store)注册。为了让useStore能正常工作，下面的代码中，我们需要给store新增一个install方法，这个方法会在app.use函数内部执行。我们通过app.provide函数注册store给全局的组件使用。</p><pre><code class="language-xml">class Store {\n  // main.js入口处app.use(store)的时候，会执行这个函数\n  install(app) {\n    app.provide(STORE_KEY, this)\n  }\n}\n</code></pre><p>下面的代码中，Store类内部变量_state存储响应式数据，读取state的时候直接获取响应式数据_state.data，并且提供了commit函数去执行用户配置好的mutations。</p><pre><code class="language-xml">import { inject, reactive } from \'vue\'\nconst STORE_KEY = \'__store__\'\nfunction useStore() {\n  return inject(STORE_KEY)\n}\nfunction createStore(options) {\n  return new Store(options)\n}\nclass Store {\n  constructor(options) {\n    this.$options = options\n    this._state = reactive({\n      data: options.state\n    })\n    this._mutations = options.mutations\n  }\n  get state() {\n    return this._state.data\n  }\n  commit = (type, payload) =&gt; {\n    const entry = this._mutations[type]\n    entry &amp;&amp; entry(this.state, payload)\n  }\n  install(app) {\n    app.provide(STORE_KEY, this)\n  }\n}\nexport { createStore, useStore }\n</code></pre><p>这样在组件内部，我们就可以使用这个迷你的Vuex去实现一个累加器了。下面的代码中，我们使用useStore获取store的实例，并且使用计算属性返回count，在修改count的时候使用store.commit(‘add’)来修改count的值。</p><pre><code class="language-xml">import {useStore} from \'../store/gvuex\'\nlet store =useStore()\nlet count = computed(()=&gt;store.state.count)\nfunction add(){\n    store.commit(\'add\')\n}\n\n</code></pre><p>恭喜你，这样借助vue的插件机制和reactive响应式功能，我们只用30行代码，就实现了一个最迷你的数据管理工具，也就是一个迷你的Vuex实现，下面我们再结合例子，正式介绍一下Vuex看一看Vuex具体怎么用？</p><h2>Vuex实战</h2><p>从上面的例子你可以立即看出，Vuex就是一个公用版本的ref，提供响应式数据给整个项目使用。现在的功能还比较简单，项目大部分情况都是像之前的清单应用一样，除了简单的数据修改，还会有一些异步任务的触发，这些场景Vuex都有专门的处理方式。</p><p>在Vuex中，你可以使用getters配置，来实现computed的功能，比如我们想显示累加器数字乘以2之后的值，那么我们就需要引入getters配置。</p><p>下面的代码中，我们实现了计算累加器数字乘以2以后的值。我们在Vuex中新增了getters配置，其实getters配置和Vue中的computed是一样的写法和功能。我们配置了doubule函数，用于显示count乘以2的计算结果。</p><pre><code class="language-xml">import { createStore } from \'vuex\'\nconst store = createStore({\n  state () {\n    return {\n      count: 666\n    }\n  },\n  getters:{\n    double(state){\n          return state.count*2\n      }\n  },\n  mutations: {\n    add (state) {\n      state.count++\n    }\n  }\n})\n\nexport default store\n</code></pre><p>然后，我们可以很方便地在组件中使用getters，把double处理和计算的逻辑交给Vuex。</p><pre><code class="language-xml">let double = computed(()=&gt;store.getters.double)\n</code></pre><p>实际项目开发中，有很多数据我们都是从网络请求中获取到的。在Vuex中，mutation的设计就是用来实现同步地修改数据。如果数据是异步修改的，我们需要一个新的配置action。现在我们模拟一个异步的场景，就是点击按钮之后的1秒，再去做数据的修改。</p><p>面对这种异步的修改需求，在Vuex中你需要新增action的配置，在action中你可以做任意的异步处理。这里我们使用setTimeout来模拟延时，然后在action内部调用mutation就可以了。</p><p>听起来是不是很绕？不过你不用担心，下面的代码就很清晰地演示了这个过程。</p><p>首先，我们在createStore的配置中，新增了actions配置，这个配置中所有的函数，可以通过解构获得commit函数。内部的异步任务完成后，就随时可以调用commit来执行mutations去更新数据。</p><pre><code class="language-xml">const store = createStore({\n  state () {\n    return {\n      count: 666\n    }\n  },\n  ...\n  actions:{\n      asyncAdd({commit}){\n          setTimeout(()=&gt;{\n            commit(\'add\')\n          },1000)\n      }\n  }\n})\n\n</code></pre><p><strong>action并不是直接修改数据，而是通过mutations去修改，这是我提醒你需要注意的</strong>。actions的调用方式是使用store.dispatch，在下面的代码中你可以看到这样的变化效果：页面中新增了一个asyncAdd的按钮，点击后会延迟一秒做累加。</p><pre><code class="language-xml">function asyncAdd(){\n    store.dispatch(\'asyncAdd\')\n}\n</code></pre><p>代码执行的效果如下：</p><p><img src="https://static001.geekbang.org/resource/image/d0/b4/d07df967ed262e3fd02751fdc55171b4.gif?wh=435x239" alt="图片"></p><p>Vuex在整体上的逻辑如下图所示，从宏观来说，Vue的组件负责渲染页面，组件中用到跨页面的数据，就是用state来存储，但是Vue不能直接修改state，而是要通过actions/mutations去做数据的修改。</p><p><img src="https://static001.geekbang.org/resource/image/85/28/851478d3f2b0393474de6e5b3b355a28.png?wh=1280x866" alt=""></p><p>下面这个图也是Vuex官方的结构图，很好地拆解了Vuex在Vue全家桶中的定位，我们项目中也会用Vuex来管理所有的跨组件的数据，并且我们也会在Vuex内部根据功能模块去做拆分，会把用户、权限等不同模块的组件分开去管理。</p><p><img src="https://static001.geekbang.org/resource/image/23/7a/237557819e2148ac022305eaf86c0b7a.png?wh=701x551" alt="图片"></p><p>由于Vuex所有的数据修改都是通过mutations来完成的，因而我们可以很方便地监控到数据的动态变化，后面我们可以借助官方的调试工具，非常方便地去调试项目中的数据变化。</p><p>回到正在做的这个项目中，有大量的数据交互需求、用户的登录状态、登录的有效期、布局的设置，不同用户还会有不同的菜单权限等。</p><p>不过面对眼花缭乱的交互需求，你不能自乱阵脚。总体来说，<strong>我们在决定一个数据是否用Vuex来管理的时候，核心就是要思考清楚，这个数据是否有共享给其他页面或者是其他组件的需要</strong>。如果需要，就放置在Vuex中管理；如果不需要，就应该放在组件内部使用ref或者reactive去管理。</p><h2>下一代Vuex</h2><p>Vuex由于在API的设计上，对TypeScript的类型推导的支持比较复杂，用起来很是痛苦。因为我们的项目一直用的都是JavaScript，你可能感触并不深，但对于使用TypeScript的用户来说，Vuex的这种问题是很明显的。</p><p>为了解决Vuex的这个问题，Vuex的作者最近发布了一个新的作品叫Pinia，并将其称之为下一代的Vuex。Pinia的API的设计非常接近Vuex5的提案，首先，Pinia不需要Vuex自定义复杂的类型去支持TypeScript，天生对类型推断就非常友好，并且对Vue Devtool的支持也非常好，是一个很有潜力的状态管理框架。</p><h2>总结</h2><p>今天的学习内容并不难，主要是引入了一个新的框架Vuex和数据管理的概念，让我们一起来回顾一下。</p><p>首先，我们从前端数据管理概念开始讲起。每个组件内部有自己的数据和模板，那共享的数据怎么科学管理呢？这就需要Vuex出马了。</p><p>简单来说，Vuex是一个状态和数据管理的框架，负责管理项目中多个组件和多个页面共享的数据。在开发项目的时候，我们就会把数据分成两个部分，一种数据是在某个组件内部使用，我们使用ref或者reactive定义即可，另外一种数据需要跨页面共享，就需要使用Vuex来进行管理。</p><p>之后，我们还讲到了Vuex带来了几个新的概念，我们使用state定义数据，使用mutation定义修改数据的逻辑，并且在组件中使用commit去调用mutations。在此基础之上，还可以用getters去实现Vuex世界的计算属性，使用action来去定义异步任务，并且在内部调用mutation去同步数据。</p><p>Vuex的出现，让我们整个项目中的数据流动变得非常自然。数据流向组件，但组件不能直接修改数据，而是要通过mutation提出申请，mutation去修改数据，形成了一个圆环。这种方式对于我们项目的开发、维护和调试都是有很大的帮助。之后，我们一起手写了一个迷你的Vuex，通过实战巩固前面的学习。</p><p>最后，我还简单介绍了一下Pinia这个框架，Pinia算是下一代的Vuex，感兴趣的同学可以去Pinia的官网学习一下。</p><h2>思考题</h2><p>相信今天的课程结束后，你对Vuex会有不一样的了解，那么你的项目里哪些数据要放在Vuex中呢？</p><p>欢迎在留言区分享你的答案，并和我一起交流讨论，我们下一讲见！</p>',
        article_title: "10 | 数据流：如何使用Vuex设计你的数据流",
      },
      {
        title: "11 | 路由：新一代vue-router带来什么变化",
        id: 440504,
        content:
          '<p>你好，我是大圣。</p><p>在上一讲中，我带你了解了Vuex这个数据管理框架的使用方法，以及Vue 3中数据管理框架的来源、实战细节和相关的原理。</p><p>其实项目中除了数据管理，路由系统也是非常核心的模块。所以在这一讲中，我会先带你了解一下前端开发方式的演变，让你明白前端路由因何而来，之后再讲解前端路由的实现原理。最后，我会再带你手写一个vue-router，并在这个过程中为你补充相关的实战要点，让你对如何用好vue-router有一个直观体验。</p><h2>前后端开发模式的演变</h2><p>在jQuery时代，对于大部分Web项目而言，前端都是不能控制路由的，而是需要依赖后端项目的路由系统。通常，前端项目也会部署在后端项目的模板里，整个项目执行的示意图如下：</p><p><img src="https://static001.geekbang.org/resource/image/26/2b/26ddd952f1f7d6dc3193af5be57e202b.jpg?wh=1569x462" alt="图片"></p><p>jQuery那个时代的前端工程师，都要学会在后端的模板，比如JSP，Smatry等里面写一些代码。但是在这个时代，前端工程师并不需要了解路由的概念。对于每次的页面跳转，都由后端开发人员来负责重新渲染模板。</p><p>前端依赖后端，并且前端不需要负责路由的这种开发方式，有很多的优点，比如开发速度会很快、后端也可以承担部分前端任务等，所以到现在还有很多公司的内部管理系统是这样的架构。当然，这种开发方式也有很多缺点，比如前后端项目无法分离、页面跳转由于需要重新刷新整个页面、等待时间较长等等，所以也会让交互体验下降。</p><!-- [[[read_end]]] --><p>为了提高页面的交互体验，很多前端工程师做了不同的尝试。在这个过程中，前端的开发模式发生了变化，项目的结构也发生了变化。下图所示的，是在目前的前端开发中，用户访问页面后代码执行的过程。</p><p><img src="https://static001.geekbang.org/resource/image/26/ec/2657d4eb129568d3c5b766e40eef60ec.jpg?wh=1920x435" alt="图片"></p><p>从上面的示意图中，我们可以看到：用户访问路由后，无论是什么URL地址，都直接渲染一个前端的入口文件index.html，然后就会在index.html文件中加载JS和CSS。之后，JavaScript获取当前的页面地址，以及当前路由匹配的组件，再去动态渲染当前页面即可。用户在页面上进行点击操作时，也不需要刷新页面，而是直接通过JS重新计算出匹配的路由渲染即可。</p><p>在前后两个示意图中，绿色的部分表示的就是前端负责的内容。而在后面这个架构下，前端获得了路由的控制权，在JavaScript中控制路由系统。也因此，页面跳转的时候就不需要刷新页面，网页的浏览体验也得到了提高。<strong>这种所有路由都渲染一个前端入口文件的方式，是单页面应用程序（SPA，single page application）应用的雏形。</strong></p><p>通过JavaScript动态控制数据去提高用户体验的方式并不新奇，Ajax让数据的获取不需要刷新页面，SPA应用让路由跳转也不需要刷新页面。这种开发的模式在jQuery时代就出来了，浏览器路由的变化可以通过pushState来操作，这种纯前端开发应用的方式，以前称之为Pjax （pushState+ Ajax）。之后，这种开发模式在MVVM框架的时代大放异彩，现在大部分使用Vue/React/Angular的应用都是这种架构。</p><p>SPA应用相比于模板的开发方式，对前端更加友好，比如：前端对项目的控制权更大了、交互体验也更加丝滑，更重要的是，前端项目终于可以独立出来单独部署了。</p><h2>前端路由的实现原理</h2><p>在讲完前端路由的执行逻辑之后，我们深入探索一下前端控制路由的实现原理。</p><p>现在，通过URL区分路由的机制上，有两种实现方式，一种是hash模式，通过URL中#后面的内容做区分，我们称之为hash-router；另外一个方式就是history模式，在这种方式下，路由看起来和正常的URL完全一致。</p><p>这两个不同的原理，在vue-router中对应两个函数，分别是createWebHashHistory和createWebHistory。</p><p><img src="https://static001.geekbang.org/resource/image/d0/d3/d07894f8b9df7c1afed10b730f8276d3.jpg?wh=1546x561" alt="图片"></p><h3>hash 模式</h3><p>单页应用在页面交互、页面跳转上都是无刷新的，这极大地提高了用户访问网页的体验。<strong>为了实现单页应用，前端路由<strong><strong>的需求也变得重要了起来</strong></strong>。</strong></p><p>类似于服务端路由，前端路由实现起来其实也很简单，就是匹配不同的 URL 路径，进行解析，然后动态地渲染出区域 HTML 内容。但是这样存在一个问题，就是 URL 每次变化的时候，都会造成页面的刷新。解决这一问题的思路便是在改变 URL 的情况下，保证页面的不刷新。</p><p>在 2014 年之前，大家是通过 hash 来实现前端路由，URL hash 中的 # 就是类似于下面代码中的这种 # ：</p><pre><code class="language-plain">http://www.xxx.com/#/login\n</code></pre><p>之后，在进行页面跳转的操作时，hash 值的变化并不会导致浏览器页面的刷新，只是会触发hashchange事件。在下面的代码中，通过对hashchange事件的监听，我们就可以在fn函数内部进行动态地页面切换。</p><pre><code class="language-javascript">window.addEventListener(\'hashchange\',fn)\n</code></pre><h3>history 模式</h3><p>2014年之后，因为HTML5标准发布，浏览器多了两个API：pushState 和 replaceState。通过这两个 API ，我们可以改变 URL 地址，并且浏览器不会向后端发送请求，我们就能用另外一种方式实现前端路由**。</p><p>在下面的代码中，我们监听了popstate事件，可以监听到通过pushState修改路由的变化。并且在fn函数中，我们实现了页面的更新操作。</p><pre><code class="language-plain">window.addEventListener(\'popstate\', fn)\n</code></pre><h2>手写迷你vue-router</h2><p>明白了前端路由实现原理还不够，接下来我们一起写代码直观感受一下。这里我们准备设计一个使用hash模式的迷你vue-router。</p><p>现在，我们在src/router目录下新建一个grouter文件夹，并且在grouter文件夹内部新建index.js。有了<a href="https://time.geekbang.org/column/article/439588">上一讲</a>手写Vuex的基础，我们就可以在index.js中写入下面的代码。</p><p>在代码中，我们首先实现了用Router类去管理路由，并且，我们使用createWebHashHistory来返回hash模式相关的监听代码，以及返回当前URL和监听hashchange事件的方法；然后，我们通过Router类的install方法注册了Router的实例，并对外暴露createRouter方法去创建Router实例；最后，我们还暴露了useRouter方法，去获取路由实例。</p><pre><code class="language-javascript">import {ref,inject} from \'vue\'\nconst ROUTER_KEY = \'__router__\'\n\nfunction createRouter(options){\n    return new Router(options)\n}\n\nfunction useRouter(){\n    return inject(ROUTER_KEY)\n}\nfunction createWebHashHistory(){\n    function bindEvents(fn){\n        window.addEventListener(\'hashchange\',fn)\n    }\n    return {\n        bindEvents,\n        url:window.location.hash.slice(1) || \'/\'\n    }\n}\nclass Router{\n    constructor(options){\n        this.history = options.history\n        this.routes = options.routes\n        this.current = ref(this.history.url)\n\n        this.history.bindEvents(()=&gt;{\n            this.current.value = window.location.hash.slice(1)\n        })\n    }\n    install(app){\n        app.provide(ROUTER_KEY,this)\n    }\n}\n\nexport {createRouter,createWebHashHistory,useRouter}\n</code></pre><p>有了上面这段代码，我们回到src/router/index.js中，可以看到下面代码的使用方式，我们使用createWebHashHistory作为history参数，使用routes作为页面的参数传递给createRouter函数。</p><pre><code class="language-javascript">import {\n    createRouter,\n    createWebHashHistory,\n} from \'./grouter/index\'\nconst router = createRouter({\n  history: createWebHashHistory(),\n  routes\n})\n</code></pre><p>下一步，我们需要注册两个内置组件router-view和router-link。在createRouter创建的Router实例上，current返回当前的路由地址，并且使用ref包裹成响应式的数据。router-view组件的功能，就是current发生变化的时候，去匹配current地址对应的组件，然后动态渲染到router-view就可以了。</p><p>我们在src/router/grouter下新建RouterView.vue，写出下面的代码。在代码中，我们首先使用useRouter获取当前路由的实例；然后通过当前的路由，也就是router.current.value的值，在用户路由配置route中计算出匹配的组件；最后通过计算属性返回comp变量，在template内部使用component组件动态渲染。</p><pre><code class="language-xml">&lt;template&gt;\n    &lt;component :is="comp"&gt;&lt;/component&gt;\n&lt;/template&gt;\n&lt;script setup&gt;\n\nimport {computed } from \'vue\'\nimport { useRouter } from \'../grouter/index\'\n\nlet router = useRouter()\n\nconst comp = computed(()=&gt;{\n    const route = router.routes.find(\n        (route) =&gt; route.path === router.current.value\n    )\n    return route?route.component : null\n})\n&lt;/script&gt;\n</code></pre><p>在上面的代码中，我们的目的是介绍vue-router的大致原理。之后，在课程的源码篇中，我们会在《前端路由原理：vue-router 源码剖析》这一讲完善这个函数的路由匹配逻辑，并让这个函数支持正则匹配。</p><p>有了RouterView组件后，我们再来实现router-link组件。我们在grouter下面新建文件RouterILink.vue，并写入下面的代码。代码中的template依然是渲染一个a标签，只是把a标签的href属性前面加了个一个#， 就实现了hash的修改。</p><pre><code class="language-xml">&lt;template&gt;\n    &lt;a :href="\'#\'+props.to"&gt;\n        &lt;slot /&gt;\n    &lt;/a&gt;\n&lt;/template&gt;\n\n&lt;script setup&gt;\nimport {defineProps} from \'vue\'\nlet props = defineProps({\n    to:{type:String,required:true}\n})\n\n&lt;/script&gt;\n</code></pre><p>然后，回到grouter/index.js中，我们注册router-link和router-view这两个组件, 这样hash模式的迷你vue-router就算实现了。这里我演示了支持hash模式迷你vue-router，那你不妨进一步思考一下，history模式又该如何实现。</p><pre><code class="language-javascript">import {ref,inject} from \'vue\'\nimport RouterLink from \'./RouterLink.vue\'\nimport RouterView from \'./RouterView.vue\'\nclass Router{\n    ....\n    install(app){\n        app.provide(ROUTER_KEY,this)\n        app.component("router-link",RouterLink)\n        app.component("router-view",RouterView)\n    }\n}\n</code></pre><p><strong>实际上，vue-router还需要处理很多额外的任务，比如路由懒加载、路由的正则匹配等等</strong>。在今天了解了vue-router原理之后，等到课程最后一部分剖析vue-router源码的那一讲时，你就可以真正感受到“玩具版”的router和实战开发中的router的区别。</p><h2>vue-router实战要点</h2><p>了解了vue-router的原理后，我们再来介绍一下vue-router在实战中的几个常见功能。</p><p>首先是在<strong>路由匹配的语法</strong>上，vue-router支持动态路由。例如我们有一个用户页面，这个页面使用的是User组件，但是每个用户的信息都不一样，需要给每一个用户配置单独的路由入口，这时就可以按下面代码中的样式来配置路由。</p><p>在下面的代码中，冒号开头的id就是路由的动态部分，会同时匹配/user/dasheng和/user/geektime， 这一部分的详细内容你可以参考<a href="https://next.router.vuejs.org/zh/guide/essentials/route-matching-syntax.html">官方文档的路由匹配语法部分</a>。</p><pre><code class="language-javascript">const routes = [\n  { path: \'/users/:id\', component: User },\n]\n</code></pre><p>然后是在实战中，对于有些页面来说，只有管理员才可以访问，普通用户访问时，会提示没有权限。这时就需要用到vue-router的<strong>导航守卫功能</strong>了，也就是在访问路由页面之前进行权限认证，这样可以做到对页面的控制，也就是只允许某些用户可以访问。</p><p>此外，在项目庞大之后，如果首屏加载文件太大，那么就可能会影响到性能。这个时候，我们可以使用vue-router的<strong>动态导入功能</strong>，把不常用的路由组件单独打包，当访问到这个路由的时候再进行加载，这也是vue项目中常见的优化方式。</p><p>关于vue-router实战中的种种优化和注意点，在课程后续的15-19讲，也就是实战痛点中，我会借助实战场景，挨个给你讲解。</p><h2>总结</h2><p>好，这一讲的主要内容就讲完了，我们来总结一下今天学到的内容。首先，我们回顾了前后端开发模式的演变，也即前端项目经历的从最初的嵌入到后端内部发布，再到现在的前后端分离的过程，而这一过程也见证了前端SPA应用的发展。</p><p>然后，我们讲到了前端路由实现的两种方式，也即通过监听不同的浏览器事件，来实现hash模式和history模式。之后，根据这个原理，我们手写了一个迷你的vue-router，通过createRouter创建路由实例，并在app.use函数内部执行router-link和router-view组件的注册，最后在router-view组件内部动态的渲染组件。</p><p>在这一讲的最后，我还给你简单说明了一下vue-router实战中常见的一些痛点。vue-router进一步实战的内容，比如权限认证、页面懒加载等功能，在课程后面的15-19讲中还会详细展开。相信今天这一讲结束后，你一定对vue-router有了更加新的理解。</p><h2>思考题</h2><p>最后给你留个思考题，今天我们只用了大概60行代码，就实现了hash模式的迷你vue-router，那你还可以思考一下，支持history模式的迷你vue-router又该如何实现呢？</p><p>欢迎在留言区分享你的答案，也欢迎你把这一讲分享给你的朋友们，我们下一讲见！</p>',
        article_title: "11 | 路由：新一代vue-router带来什么变化",
      },
      {
        title: "12 | 调试：提高开发效率必备的Vue Devtools",
        id: 442479,
        content:
          '<p>你好，我是大圣。</p><p>跟随我的脚步，通过对前面数讲内容的学习，相信你现在对Vue+Vuex+vue-router都已经比较熟悉了。在开启课程后续的复杂项目之前，学会如何调试项目也是我们必须要掌握的一个技能。</p><p>在项目开发中，我们会碰到各种各样的问题，有样式错误、有不符合预期的代码报错、有前后端联调失败等问题。也因此，一个能全盘帮我们监控项目的方方面面，甚至在监控时，能精确到源码每一行的运行状态的调试工具，就显得非常有必要了。</p><p>而Chrome的开发者工具Devtools，就是Vue的调试工具中最好的选择。由于Chrome也公开了Devtools开发的规范，因而各大框架比如Vue和React，都会在Chrome Devtools的基础之上，开发自己框架的调试插件，这样就可以更方便地调试框架内部的代码。Vue Devtools就是Vue官方开发的一个基于Chrome浏览器的插件，作为调试工具，它可以帮助我们更好地调试Vuejs代码。</p><p>这节课，我会先为你讲解如何借助Chrome和VS Code搭建高效的开发环境，然后再教你使用Vue 的官方调试插件 Vue Devtools 来进行项目调试工作。</p><h2>Chrome调试工具</h2><p>首先，我们来了解一下Chrome的调试工具，也就是Chrome的开发者工具Chrome DevTools。在Chrome浏览器中，我们打开任意一个页面，点击鼠标右键，再点击审查元素（检查），或者直接点击F12就可以看到调试窗口了。</p><!-- [[[read_end]]] --><p><img src="https://static001.geekbang.org/resource/image/e2/25/e2d00f93dcbb2c960720b41c45479125.png?wh=1714x210" alt="图片"></p><p>我们看下截图中的调试窗口，里面有几个页面是我们经常用到的：Elements页面可以帮助我们调试页面的HTML和CSS；Console页面是我们用得最多的页面，它可以帮助我们调试JavaScript；Source页面可以帮助我们调试开发中的源码；Application页面可以帮助我们调试本地存储和一些浏览器服务，比如Cookie、Localstorage、通知等等。</p><p>Network页面在我们开发前后端交互接口的时候，可以让我们看到每个网络请求的状态和参数；Performance页面则用来调试网页性能。Lighthouse是Google官方开发的插件，用来获取网页性能报告，今天我也会教你用lighthouse评测一下极客时间官网首页的性能。</p><p>以上说的这些调试窗口中的页面，都是Chrome的开发者工具中自带的选项，而调试窗口最后面的Vue页面就是需要额外安装的Vue Devtools，也就是调试Vue必备的工具。</p><p><img src="https://static001.geekbang.org/resource/image/e7/54/e756015dc2eb7a87d8825585115d4f54.png?wh=1920x1237" alt="图片"></p><p>上图所示的是项目开发中用到最多的页面，而在调试窗口右侧的工具栏中，你还可以选中More tools来开启更多自带的插件。如下图所示，More tools中的Animations用于调试动画，Security用于调试安全特性等等。</p><p><img src="https://static001.geekbang.org/resource/image/bf/93/bfc45abbf1e20fb639bd712463ef7893.png?wh=1822x1082" alt="图片"></p><p><strong>下面，我们重点介绍一下调试窗口中的Elements页面和Console页面。这两个页面用来调试页面中的HTML+CSS+JavaScript，是使用频率最高的两个页面。</strong></p><p>在Elements页面中，首先映入眼帘的是开发的Vue项目在浏览器里的状态。调试窗口的左侧是正在调试的前端页面的HTML结构，当我们把鼠标放到HTML代码的任何元素上时，在调试的前端页面上，对应元素在前端页面中所在的位置都会高亮起来。</p><p>当我们点击一个元素之后，调试窗口右侧就会显示出当前元素所有的CSS样式，这对于我们开发的页面布局和样式调整非常有帮助。并且，我们还可以在Elements页面左侧的代码中，任意修改页面的HTML和CSS代码。</p><p>比如，以我在这里给出的调试页面为例，我们可以选中调试页面（清单应用）的div标签，再点击调试页面右侧的element.style，这样就可以直接新增background和padding属性，也即会得到下图的效果。此外，有一些页面布局上的bug可以用这种方式，在网页里实时调整后，再去更新代码。</p><p><img src="https://static001.geekbang.org/resource/image/f6/0a/f6a378b2d723e92aaa1cea6cd0bc230a.png?wh=1920x1319" alt="图片"></p><p>然后，我们再来看一下在调试中用得最多的Console页面。在这个页面内，我们可以直接调试JavaScript，并且页面中也会显示JavaScript出现的报错信息。</p><p>举个小例子，我们来到项目里的src/main.js文件内，把createApp修改成createApp1，然后回到浏览器的Console调试页面，就会看到以下的报错内容，红色报错信息清晰地告诉我们代码执行出现错误的原因。</p><h2><img src="https://static001.geekbang.org/resource/image/d9/06/d91f1daa22cb0ac8063bccbbabb07606.png?wh=1920x298" alt="图片"></h2><p>我们点击报错信息的最右侧，还能精确地定位到项目中的文件以及代码的行数。尤其是对于新手程序员来说，精确的报错定位可以极大地提高我们的开发效率。国外甚至有程序员还直接在报错信息里加上stackoverflow搜索地址，也算是把Console玩出花样了。</p><p><img src="https://static001.geekbang.org/resource/image/36/0d/36fb0aed8ab2d3fe06f8f0ffac04b40d.png?wh=1208x1002" alt="图片"></p><p>参考我们提到的国外程序员的做法，我们在src/main.js里加入下面这段代码 ，这样就可以在日志信息中直接复制报错内容中的链接，去Stack Overflow中寻找答案。</p><pre><code class="language-javascript">window.onerror = function(e){\n    console.log([\'https://stackoverflow.com/search?q=[js]+\'+e])\n}\n</code></pre><p>其实Console页面的用法非常多，当我们在代码里使用cosole.log打印信息时，console页面里就会显示log传递的参数，这也是程序员用得最多的调试方法。</p><p>除了console.log，还有console.info、console.error等方法可以显示不同级别的报错信息。而在log之外，我们还可以使用console.table更便捷地打印数组消息。在MDN的<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Console">Console页面</a>中，有对Console的全部API的介绍，你也可以去参考一下。</p><p>关于Console，后续的课程中还会持续地用到，我在这里还可以分享一个我喜欢用的前端面试题，题目来自贺老的面试题。那就是我会把电脑给面试者，让他在Console页面里写代码，统计极客时间官网一共有多少种HTML标签。</p><p>你也可以上手体验一下，打开极客时间的官网，再打开调试窗口，在Console页面输入下面的代码，你就可以看到答案。这其实是一个比较考验应试者前端基础的一道题，你可以自己试一试。</p><pre><code class="language-javascript">new Set([...document.querySelectorAll(\'*\')].map(n=&gt;n.nodeName)).size\n</code></pre><h2>Vue Devtools</h2><p>然后，我们再来介绍一下调试窗口里最后面的Vue页面，这个页面其实就是我们在Chrome浏览器中安装的第三方的插件Vue Devtools。</p><p>首先我们要做的是安装一下Vue Devtools。Vue Devtools的官网上有详细的<a href="https://devtools.vuejs.org/">安装教程</a>，这里就不过多讲解了。安装完毕后，如果调试的前端页面中有Vue相关的代码，就会激活这个tab。进入到Vue这个调试页面后，你就会看到下面的示意图。</p><p><img src="https://static001.geekbang.org/resource/image/9f/74/9fa65477f34ae77d75732629e22da274.png?wh=1920x1328" alt="图片"></p><p>从上面的图中你可以看到，Vue Devtools可以算是一个Elements页面的Vue定制版本，调试页面左侧的显示内容并不是HTML，而是Vue的组件嵌套关系。我们可以从中清晰地看到整个项目中最外层的App组件，也能看到App组件内部的RouterView下面的Todo组件。</p><p>并且，在调试页面的左侧中，当我们点击组件的时候，我们所调试的前端页面中也会高亮清单组件的覆盖范围。调试页面的右侧则显示着todo组件内部所有的数据和方法。我们可以清晰地看到setup配置下，有todos、animate、active等诸多变量，并且这些变量也是和页面实时同步的数据，我们在页面中输入新的清单后，可以看到active和all的数据也随之发生了变化。</p><p>同时，我们也可以直接修改调试窗口里面的数据，这样，正在调试的前端页面也会同步数据的显示效果。有了Vue的调试页面，当我们碰到页面中的数据和标签不同步的情况时，就可以很轻松地定位出是哪里出现了问题。</p><p>然后在Component的下拉框那里，我们还可以选择Vuex和Router页面，分别用来调试Vuex和vue-router。</p><p><img src="https://static001.geekbang.org/resource/image/1f/f6/1f0d59f12fe3833148f92d4bee65cbf6.png?wh=1920x1024" alt="图片"></p><p>我们先来点击Vuex页面试一下，<strong>这个页面里的操作可以帮助我们把Vuex的执行过程从黑盒变成一个白盒</strong>。简单来说，我们可以在调试窗口的右侧看到Vuex内部所有的数据变化，包括state、getters等。</p><p><img src="https://static001.geekbang.org/resource/image/66/1b/66e771b822ffa8bf9a3549e88060c71b.png?wh=1920x988" alt="图片"></p><p>我们点击Vuex下拉框里的Routes页面，这个页面里显示了整个应用路由的配置、匹配状态、参数等，这里就不做过多的解释了。相信有了Vue Devtools后，你能够更快地调试Vue项目的内部运行状态，从而极大地提高开发效率。</p><p><img src="https://static001.geekbang.org/resource/image/fe/e6/fe8624dc482abff1257191c8a2a4e6e6.png?wh=1920x736" alt="图片"></p><p>这里还有一个小技巧，你可以了解一下：在Components页面下，你选中一个组件后，调试窗口的右侧就会出现4个小工具。</p><p>如下图所示，在我用红框标记的四个工具中，最右边的那个工具可以让你直接在编辑器里打开这个代码。这样，调试组件的时候就不用根据路径再去VS Code里搜索代码文件了，这算是一个非常好用的小功能。</p><p><img src="https://static001.geekbang.org/resource/image/53/46/53b82ec4499c08b0b8403a8471070946.png?wh=1920x807" alt="图片"></p><h2>断点调试</h2><p>正常情况下，我们用好Elements、Console和Vue这三个页面就可以处理大部分的调试结果了。不过太多的Console信息会让页面显得非常臃肿，所以还出现过专门去掉Console代码的webpack插件。</p><p>如果代码逻辑比较复杂，过多的Console信息也会让我们难以调试。这种情况就需要使用断点调试的功能，Chrome的调试窗口会识别代码中的debugger关键字，并中断代码的执行。</p><p>还是通过小例子直观感受一下。我们打开src/components目录下的todo.vue文件，下面是清单应用的代码，我们在addTodo函数内的第一行写上debugger。然后到前端的清单应用的页面中，我们输入任意一条信息，点击回车，你就会发现页面暂停了，并且调试窗口跳转到了source页面。</p><pre><code class="language-javascript">  function addTodo() {\n    debugger\n    if(!title.value){\n      showModal.value = true\n      setTimeout(()=&gt;{\n        showModal.value = false\n      },1500)\n      return \n    }\n    todos.value.push({\n      title: title.value,\n      done: false,\n    });\n    title.value = "";\n}    \n</code></pre><p>上面的代码在调试窗口中的效果如下图所示，点击图中用红框圈出的按钮，你就可以在debugger暂停的地方，逐行执行代码。并且鼠标放在任意变量上，都可以看到这个变量在代码执行的结果。对于复杂代码逻辑的调试来说，使用断点调试，可以让整个代码执行过程清晰可见。<strong>debugger也是高级程序员必备的断点调试法，你一定要掌握</strong>。</p><p><img src="https://static001.geekbang.org/resource/image/3f/74/3f3e7fb01d09468cbd48d4f6de27d174.png?wh=1920x993" alt="图片"></p><h2>性能相关的调试</h2><p>了解了页面代码的调试方法后，我们再来分享一下页面的性能调试方法。比如，在你遇到页面交互略有卡顿的时候，你可以在调试窗口中点击Performance页面中的录制按钮，然后重复你卡顿的操作后，点击结束，就可以清晰看到你在和页面进行交互操作时，浏览器中性能的变化。</p><p>以极客时间的官网页面作为具体的例子，我们在调试窗口中点击Performance页面中的录制按钮，然后进行刷新页面的操作，并点击首页轮播图，之后我们可以看到如下的效果：</p><p><img src="https://static001.geekbang.org/resource/image/34/6b/348d056766eaa0feba5ec5205f5e7e6b.png?wh=1920x1199" alt="图片"></p><p>我们可以滑动鼠标，这样就能很清晰地看到极客时间页面加载的过程。然后，我们重点看下首屏加载中的性能指标，通过下方的饼图，你可以看到整个刷新过程中耗时的比例，其中JS代码391ms，整体624ms。</p><p><img src="https://static001.geekbang.org/resource/image/1c/ba/1c2892c22c3d9bde8f28559e0d0d6cba.png?wh=1262x598" alt="图片"></p><p>在Performace页面中，我们还可以详细地看到每个函数的执行时间。我们录制一下清单应用新增清单的操作之后，就会显示下面的示意图，从中可以清晰地看到键盘keydown事件之后执行的函数，在图中可以找到我们写的addTodo方法，以及mountElement等Vue源码里的函数。关于Chrome性能页面更多的使用方法 ，你可以到<a href="https://developer.chrome.com/docs/devtools/evaluate-performance">Chrome官方文档</a>上去查看。</p><p><img src="https://static001.geekbang.org/resource/image/cd/cf/cd14d601a7801de54b8a88ef754c38cf.png?wh=1920x943" alt="图片"></p><p>如果你觉得上面手动录制页面的性能报告的方法过于繁琐，还可以直接使用lighthouse插件。我们进入到lighthouse页面，选择desktop桌面版后，点击生成报告。lighthouse在浏览器上模拟刷新的操作后，给出一个网页评分。这里我们可以看到，极客时间网站首页的评分是72分，在合格的标准线上。</p><p><img src="https://static001.geekbang.org/resource/image/3a/19/3ae311638a352a8e884764d6d3603e19.png?wh=1920x833" alt="图片"></p><p>此外，根据性能、可访问性、最佳实践、SEO和PWA五个维度的评分，我们可以看出，在前面四个维度中，极客时间都是及格的，第五个指标置灰，说明极客时间首页还没有支持PWA。</p><p>我们先看下性能指标，下图中详细地给出了FCP、TTI、LCP等常见性能指标，并且还很贴心地给出了建议，包括字体、图标宽高、DOM操作等等，其实我们按照这些建议依次修改，就可以实现对网页的性能优化了。并且网页优化后，性能分数的提升还可以很好地量化优化的结果。</p><p><img src="https://static001.geekbang.org/resource/image/5e/01/5ec97d6bff48ab8ed6e9549d71506a01.png?wh=1920x1668" alt="图片"></p><p>关于极客时间首页lighthouse其余几个指标，你可以点开<a href="https://pandafe.gitee.io/clock/time.geekbang.org.html">这个链接</a>查看结果，相信结合这个实例演示，你一定会对性能优化手段有所体会。</p><h2>总结</h2><p>好，今天这一讲的主要内容，也即调试Vue应用的方法，就讲完了，我们一起来回顾一下吧。</p><p>首先，我给你讲解了在Chrome浏览器中，进行项目调试的方法。除了最基本的Console，我们还可以借助Chrome提供的其他调试工具提高效率，例如元素面板、源码面板等等。每个面板都带来了透视Vue应用的方式，从样式到性能都是我们提高效率最高的工具。</p><p>Elements和Console页面可以完成页面的布局和JavaScript的调试工作，并且调试窗口还会识别代码中的debugger语句，可以让我们在Chrome中进行断点调试。Performance和lighthouse页面则提供了对页面做性能测试的方法，从而能帮助我们更好地查看页面中性能的指标。</p><p>然后，我们介绍了Vue团队开发的插件Vue Devtools，你可以把Vue Devtools理解为是对Chrome调试工具的一个扩展。<strong>在<strong><strong>Vue Devtools</strong></strong>中，我们可以很方便地调试Vue的应用，比如查看Vue的组件嵌套、查看Vue组件内部的data等属性</strong>。</p><p>此外，当我们遇见页面中的数据和渲染结果不一致的bug时，我们可以很方便地使用Vue Devtools精确地定位问题，从而极大地提高了开发效率。并且Vue Devtools还支持了Vue和vue-router的调试页面，这让整个页面的Vuex数据和路由都清晰可见。</p><p>相信今天这一讲结束后，当你在开发应用时再遇到了bug，你就能通过调试工具快速地定位问题，并借助今天我们讲到的内容，顺利地解决掉bug。</p><h2>思考题</h2><p>Vue的Devtools操作比较简单，进阶的知识并不算多。在讲Console页面时，我分享了一个与Vue Devtools相关的常见的手写面试题，而今天的思考题就是这个面试题的升级版：如何在Console页面写一段代码，来统计极客时间首页出现次数最多的3种HTML标签呢？</p><p>欢迎在留言区分享你的答案，我们可以一起探讨高效调试Vue的新方法。也欢迎你把这一讲的内容分享给你周围的朋友、同事，我们下一讲见！</p>',
        article_title: "12 | 调试：提高开发效率必备的Vue Devtools",
      },
      {
        title: "13 | JSX：如何利用JSX应对更灵活的开发场景？",
        id: 444283,
        content:
          '<p>你好，我是大圣。</p><p>在上一讲中，我给你介绍了如何使用Chrome和Vue Devtools来调试项目，相信你已经拥有了调试复杂项目的能力。今天，我们来聊一个相对独立的话题，就是Vue中的JSX。你肯定会有这样的疑惑，JSX不是React的知识点吗？怎么Vue里也有？</p><p>实际上，Vue中不仅有JSX，而且Vue还借助JSX发挥了Javascript动态化的优势。此外，Vue中的JSX在组件库、路由库这类开发场景中，也发挥着重要的作用。对你来说，学习JSX，可以让你实现更灵活的开发需求，这一讲我们重点关注一下Vue中的JSX。</p><h2>h函数</h2><p>在聊JSX之前，我需要先给你简单介绍一下h函数，因为理解了h函数之后，你才能更好地理解JSX是什么。下面，我会通过一个小圣要实现的需求作为引入，来给你讲一下h函数。</p><p>在Vue 3的项目开发中，template是Vue 3默认的写法。虽然template长得很像HTML，但Vue其实会把template解析为render函数，之后，组件运行的时候通过render函数去返回虚拟DOM，你可以在Vue Devtools中看到组件编译之后的结果。</p><p><img src="https://static001.geekbang.org/resource/image/75/af/75e3242df6e45538a6d43c5f0d39a1af.png?wh=1920x1140" alt="图片"></p><p>在上面的示意图中，调试窗口右侧代码中的_sfc_render_函数就是清单应用的template解析成JavaScript之后的结果。所以除了template之外，在某些场景下，我们可以直接写render函数来实现组件。</p><!-- [[[read_end]]] --><p>先举个小例子，我给小圣模拟了这样一个需求：我们需要通过一个值的范围在数字1到6之间的变量，去渲染标题组件 h1~h6，并根据传递的props去渲染标签名。对于这个需求，小圣有点拿不准了，不知道怎么实现会更合适，于是小圣按照之前学习的template语法，写了很多的v-if：</p><pre><code class="language-xml">  &lt;h1 v-if="num==1"&gt;{{title}}&lt;/h1&gt;\n  &lt;h2 v-if="num==2"&gt;{{title}}&lt;/h2&gt;\n  &lt;h3 v-if="num==3"&gt;{{title}}&lt;/h3&gt;\n  &lt;h4 v-if="num==4"&gt;{{title}}&lt;/h4&gt;\n  &lt;h5 v-if="num==5"&gt;{{title}}&lt;/h5&gt;\n  &lt;h6 v-if="num==6"&gt;{{title}}&lt;/h6&gt;\n</code></pre><p>从上面的代码中，你应该能感觉到，小圣这样的实现看起来太冗余。所以这里我教你一个新的实现方法，那就是Vue 3中的<a href="https://v3.cn.vuejs.org/api/global-api.html#h">h函数</a>。</p><p>由于render函数可以直接返回虚拟DOM，因而我们就不再需要template。我们在src/components目录下新建一个文件Heading.jsx ，要注意的是，这里Heading的结尾从.vue变成了jsx。</p><p>在下面的代码中, 我们使用defineComponent定义一个组件，组件内部配置了props和setup。这里的setup函数返回值是一个函数，就是我们所说的render函数。render函数返回h函数的执行结果，h函数的第一个参数就是标签名，我们可以很方便地使用字符串拼接的方式，实现和上面代码一样的需求。像这种连标签名都需要动态处理的场景，就需要通过手写h函数来实现<strong>。</strong></p><pre><code class="language-javascript">import { defineComponent, h } from \'vue\'\n\nexport default defineComponent({\n  props: {\n    level: {\n      type: Number,\n      required: true\n    }\n  },\n  setup(props, { slots }) {\n    return () =&gt; h(\n      \'h\' + props.level, // 标签名\n      {}, // prop 或 attribute\n      slots.default() // 子节点\n    )\n  }\n})\n</code></pre><p>然后，在文件src/About.vue中，我们使用下面代码中的import语法来引入Heading，之后使用level传递标签的级别。这样，之后在浏览器里访问  <a href="http://localhost:9094/#/about">http://localhost:9094/#/about</a> 时，就可以直接看到Heading组件渲染到浏览器之后的结果。</p><pre><code class="language-xml"> &lt;template&gt;\n  &lt;Heading :level="3"&gt;hello geekbang&lt;/Heading&gt;\n&lt;/template&gt;\n\n&lt;script setup&gt;\nimport Heading from \'./components/Head.jsx\'\n&lt;/script&gt;\n</code></pre><p>上面的代码经过渲染后的结果如下：</p><h2><img src="https://static001.geekbang.org/resource/image/7a/e8/7a4d4901c4cc483977d6a423aa4e29e8.png?wh=1120x440" alt="图片"></h2><p>手写的h函数，可以处理动态性更高的场景。<strong>但是如果是复杂的场景，h函数写起来就显得非常繁琐，需要自己把所有的属性都转变成对象</strong>。并且组件嵌套的时候，对象也会变得非常复杂。不过，因为h函数也是返回虚拟DOM的，所以有没有更方便的方式去写h函数呢？答案是肯定的，这个方式就是JSX。</p><h2>JSX是什么</h2><p>我们先来了解一下JSX是什么，JSX来源自React框架，下面这段代码就是JSX的语法，我们给变量title赋值了一个h1标签。</p><pre><code class="language-javascript">const element = &lt;h1 id="app"&gt;Hello, Geekbang!&lt;/h1&gt;\n</code></pre><p><strong>这种在JavaScript里面写HTML的语法，就叫做JSX</strong>，算是对JavaScript语法的一个扩展。上面的代码直接在JavaScript环境中运行时，会报错。JSX的本质就是下面代码的语法糖，h函数内部也是调用createVnode来返回虚拟DOM。在之后的课程中，对于那些创建虚拟DOM的函数，我们统一称为h函数。</p><pre><code class="language-javascript">const element = createVnode(\'h1\',{id:"app"}, \'hello Geekbakg\')\n</code></pre><p>在从JSX到createVNode函数的转化过程中，我们需要安装一个JSX插件。在项目的根目录下，打开命令行，执行下面的代码来安装插件：</p><pre><code class="language-bash">npm install @vitejs/plugin-vue-jsx -D\n</code></pre><p>插件安装完成后，我们进入根目录下，打开vite.config.js文件去修改vite配置。在vite.config.js文件中，我们加入下面的代码。这样，在加载JSX插件后 ，现在的页面中就可以支持JSX插件了。</p><pre><code class="language-javascript">import vue from \'@vitejs/plugin-vue\'\nimport vueJsx from \'@vitejs/plugin-vue-jsx\';\n\nexport default defineConfig({\n  plugins: [vue(),vueJsx()]\n})\n</code></pre><p>然后，我们进入src/componentns/Heading.jsx中，把setup函数的返回函数改成下面代码中所示的内容，这里我们使用变量tag计算出标签类型，直接使用<tag>渲染，使用一个大括号把默认插槽包起来就可以了。</tag></p><pre><code class="language-javascript">  setup(props, { slots }) {\n    const tag = \'h\'+props.level\n    return () =&gt; &lt;tag&gt;{slots.default()}&lt;/tag&gt;\n  }\n</code></pre><p>我们再来聊一下JSX的语法在实战中的要点，详细的要点其实在<a href="https://github.com/vuejs/jsx-next/blob/dev/packages/babel-plugin-jsx/README-zh_CN.md">GitHub文档</a>中也有全面的介绍，我在这里主要针对之前的清单应用讲解一下。</p><p>我们进入到src/components下面新建文件Todo.jsx，在下面的代码中，我们使用JSX实现了一个简单版本的清单应用。我们首先使用defineComponent的方式来定义组件，在setup返回的JSX中，使用vModel取代v-model，并且使用单个大括号包裹的形式传入变量title.value ，然后使用onClick取代@click。循环渲染清单的时候，使用.map映射取代v-for，使用三元表达式取代v-if。</p><pre><code class="language-javascript">import { defineComponent, ref } from \'vue\'\n\nexport default defineComponent({\n  setup(props) {\n    let title = ref(\'\')\n    let todos = ref([{ title: "学习 Vue 3", done: true },{ title: "睡觉", done: false }]);\n    function addTodo(){\n        todos.value.push({\n            title:title.value\n        })\n        title.value = \'\'\n    }\n    return () =&gt; &lt;div&gt;\n        &lt;input type="text" vModel={title.value} /&gt;\n        &lt;button onClick={addTodo}&gt;click&lt;/button&gt;\n        &lt;ul&gt;\n            {\n                todos.value.length ? todos.value.map(todo=&gt;{\n                    return &lt;li&gt;{todo.title}&lt;/li&gt;\n                }): &lt;li&gt;no data&lt;/li&gt;\n            }\n        &lt;/ul&gt;\n    &lt;/div&gt;\n  }\n})\n</code></pre><p>通过这个例子，你应该能够认识到，<strong>使用JSX的本质，还是在写JavaScript</strong>。在Element3组件库设计中，我们也有很多组件需要用到JSX，比如时间轴Timeline、分页Pagination、表格Table等等。</p><p>就像在TimeLine组件的<a href="https://github.com/hug-sun/element3/blob/master/packages/element3/packages/timeline/Timeline.vue#L35">源码</a>中，有一个reverse的属性来决定是否倒序渲染，我们在下面写出了类似的代码。代码中的Timeline是一个数组，数组中的两个元素都是JSX，我们可以通过数组的reverse方法直接进行数组反转，实现逆序渲染。类似这种动态性要求很高的场景，template是较难实现的。</p><pre><code class="language-javascript">export const Timeline = (props)=&gt;{\n    const timeline = [\n        &lt;div class="start"&gt;8.21 开始自由职业&lt;/div&gt;,\n        &lt;div class="online"&gt;10.18 专栏上线&lt;/div&gt;\n    ]\n    if(props.reverse){\n        timeline.reverse()\n    }\n    return &lt;div&gt;{timeline}&lt;/div&gt;\n}\n</code></pre><h2>JSX和Template</h2><p>看到这里，你一定会有一个疑惑：我们该怎么选择JSX和template呢？接下来，我就和你聊聊template和JSX的区别，这样你在加深对template的理解的同时，也能让你逐步了解到JSX的重要性。</p><p>先举个例子，我们在极客时间官网购买课程的时候，就如下图所示的样子，页面顶部有搜索框、页面左侧有课程的一些类别。我们按照极客时间对课程的分类，比如前端、后端、AI、运维等分类，可以很轻松地筛选出我们所需类别的课程。</p><p>试想一下，如果没有这些条件限制，而是直接显示课程列表，那你就需要自己在几百门的课程列表里搜索到自己需要的内容。也就是说，接受了固定分类的限制，就能降低选择课程的成本。<strong>这就告诉我们一个朴实无华的道理：我们接受一些操作上的限制，但同时也会获得一些系统优化的收益。</strong></p><p><img src="https://static001.geekbang.org/resource/image/44/a4/4470104541451a1084dd5f17d5fc7ca4.png?wh=1920x918" alt="图片"></p><p>在Vue的世界中也是如此，template的语法是固定的，只有v-if、v-for等等语法。<a href="https://v3.cn.vuejs.org/api/directives.html">Vue的官网中</a>也列举得很详细，也就是说，template遇见条件渲染就是要固定的选择用v-if。这就像极客时间官网上课程的分类是有限的，我们需要在某一个类别中选择课程一样。我们按照这种固定格式的语法书写，这样Vue在编译层面就可以很方便地去做静态标记的优化。</p><p>而JSX只是h函数的一个语法糖，本质就是JavaScript，想实现条件渲染可以用if else，也可以用三元表达式，还可以用任意合法的JavaScript语法。也就是说，<strong>JSX可以支持更动态的需求。而template则因为语法限制原因，不能够像JSX那样可以支持更动态的需求</strong>。这是JSX相比于template的一个优势。</p><p><strong>JSX相比于template还有一个优势，是可以在一个文件内返回多个组件</strong>，我们可以像下面的代码一样，在一个文件内返回Button、Input、Timeline等多个组件。</p><pre><code class="language-javascript">export const Button = (props,{slots})=&gt;&lt;button {...props}&gt;slots.default()&lt;/button&gt;\nexport const Input = (props)=&gt;&lt;input {...props} /&gt;\nexport const Timeline = (props)=&gt;{\n  ...\n}\n</code></pre><p>在上面，我们谈到了JSX相比于template的优势，那么template有什么优势呢？你可以先看下面的截图，这是使用Vue官方的template解析的<a href="https://vue-next-template-explorer.netlify.app/#%7B%22src%22%3A%22%3Cdiv%20id%3D%5C%22app%5C%22%3E%5Cn%20%20%20%20%3Cdiv%20%40click%3D%5C%22()%3D%3Econsole.log(xx)%5C%22%20%20name%3D%5C%22hello%5C%22%3E%7B%7Bname%7D%7D%3C%2Fdiv%3E%5Cn%20%20%20%20%3Ch1%20%3E%E6%8A%80%E6%9C%AF%E6%91%B8%E9%B1%BC%3C%2Fh1%3E%5Cn%20%20%20%20%3Cp%20%3Aid%3D%5C%22name%5C%22%20class%3D%5C%22app%5C%22%3E%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4%3C%2Fp%3E%5Cn%3C%2Fdiv%3E%5Cn%22%2C%22ssr%22%3Afalse%2C%22options%22%3A%7B%22mode%22%3A%22module%22%2C%22filename%22%3A%22Foo.vue%22%2C%22prefixIdentifiers%22%3Afalse%2C%22hoistStatic%22%3Atrue%2C%22cacheHandlers%22%3Atrue%2C%22scopeId%22%3Anull%2C%22inline%22%3Afalse%2C%22ssrCssVars%22%3A%22%7B%20color%20%7D%22%2C%22compatConfig%22%3A%7B%22MODE%22%3A3%7D%2C%22whitespace%22%3A%22condense%22%2C%22bindingMetadata%22%3A%7B%22TestComponent%22%3A%22setup-const%22%2C%22setupRef%22%3A%22setup-ref%22%2C%22setupConst%22%3A%22setup-const%22%2C%22setupLet%22%3A%22setup-let%22%2C%22setupMaybeRef%22%3A%22setup-maybe-ref%22%2C%22setupProp%22%3A%22props%22%2C%22vMySetupDir%22%3A%22setup-const%22%7D%2C%22optimizeBindings%22%3Afalse%7D%7D">一个demo</a>。</p><p><img src="https://static001.geekbang.org/resource/image/d5/c4/d57a43f06d47e740b17ba996df051ec4.png?wh=1920x769" alt="图片"></p><p>在demo页面左侧的template代码中，你可以看到代码中的三个标签。页面右侧是template代码编译的结果，我们可以看到，相比于我们自己去写h函数，在template解析的结果中，有以下几个性能优化的方面。</p><p>首先，静态的标签和属性会放在_hoisted变量中，并且放在render函数之外。这样，重复执行render的时候，代码里的h1这个纯静态的标签，就不需要进行额外地计算，并且静态标签在虚拟DOM计算的时候，会直接越过Diff过程。</p><p>然后是@click函数增加了一个cache缓存层，这样实现出来的效果也是和静态提升类似，尽可能高效地利用缓存。最后是，由于在下面代码中的属性里，那些带冒号的属性是动态属性，因而存在使用一个数字去标记标签的动态情况。</p><p>比如在p标签上，使用8这个数字标记当前标签时，只有props是动态的。而在虚拟DOM计算Diff的过程中，可以忽略掉class和文本的计算，这也是Vue 3的虚拟DOM能够比Vue 2快的一个重要原因。</p><pre><code class="language-javascript">import { toDisplayString as _toDisplayString, createElementVNode as _createElementVNode, openBlock as _openBlock, createElementBlock as _createElementBlock } from "vue"\n\nconst _hoisted_1 = { id: "app" }\nconst _hoisted_2 = /*#__PURE__*/_createElementVNode("h1", null, "技术摸鱼", -1 /* HOISTED */)\nconst _hoisted_3 = ["id"]\n\nexport function render(_ctx, _cache, $props, $setup, $data, $options) {\n  return (_openBlock(), _createElementBlock("div", _hoisted_1, [\n    _createElementVNode("div", {\n      onClick: _cache[0] || (_cache[0] = ()=&gt;_ctx.console.log(_ctx.xx)),\n      name: "hello"\n    }, _toDisplayString(_ctx.name), 1 /* TEXT */),\n    _hoisted_2,\n    _createElementVNode("p", {\n      id: _ctx.name,\n      class: "app"\n    }, "极客时间", 8 /* PROPS */, _hoisted_3)\n  ]))\n}\n\n// Check the console for the AST\n</code></pre><p>在template和JSX这两者的选择问题上，只是选择框架时角度不同而已。<strong>我们实现业务需求的时候，也是优先使用template，动态性要求较高的组件使用JSX实现</strong>，尽可能地利用Vue本身的性能优化。</p><p>在课程最后的生态源码篇中，我们还会聊到框架的设计思路，那时你就会发现除了template和JSX之外，一个框架的诞生还需要很多维度的考量，比如是重编译还是重运行时等等，学到那里的时候，你会对Vue有一个更加深刻的理解。</p><h2>总结</h2><p>好，今天这一讲的主要内容就讲完了，我们来简单总结一下今天学到了什么吧。今天我主要带你学习了Vue 3中的JSX。首先我们学习了h函数，简单来说，h函数内部执行createVNode，并返回虚拟DOM，而JSX最终也是解析为createVnode执行。而在一些动态性要求很高的场景下，很难用template优雅地实现，所以我们需要JSX实现。</p><p>因为render函数内部都是JavaScript代码，所以render函数相比于template会更加灵活，但是h函数手写起来非常的痛苦，有太多的配置，所以我们就需要JSX去方便快捷地书写render函数。</p><p>JSX的语法来源于React，在Vue 3中会直接解析成h函数执行，所以JSX就拥有了JS全部的动态性。</p><p>最后，我们对比了JSX和template的优缺点，template由于语法固定，可以在编译层面做的优化较多，比如静态标记就真正做到了按需更新；而JSX由于动态性太强，只能在有限的场景下做优化，虽然性能不如template好，但在某些动态性要求较高的场景下，JSX成了标配，这也是诸多组件库会使用JSX的主要原因。</p><h2>思考题</h2><p>在你现在实现的需求里，有哪些是需要JSX的呢？</p><p>欢迎在留言区分享你的看法，也欢迎你把这一讲推荐给你的同事和朋友们，我们下一讲再见。</p>',
        article_title: "13 | JSX：如何利用JSX应对更灵活的开发场景？",
      },
      {
        title: "14 | TypeScript：Vue 3中如何使用TypeScript？",
        id: 445880,
        content:
          '<p>你好，我是大圣。</p><p>在上一讲中，我为你介绍了Vue中的JSX，以及template和JSX各自的优缺点。就像在上一讲中我提到的template牺牲灵活性换来了静态标记的收益，你能看到：有些时候，我们需要放弃一些灵活性去换取项目的整体收益。那么在这一讲中，我会给你介绍一个可以在语言层面上，提高代码可维护性和调试效率的强类型语言——TypeScript。</p><p>在整体上，我们的课程还是以使用JavaScript为主。对于TypeScript的内容，我会在这一讲中先带着你入门。下面，我会先讲一下TypeScript的入门知识 ；然后作为巩固，我会带你在Vue 3里再实战一下TypeScript；最后，我会对TypeScript和JavaScript这两者做一个对比分析，让你明白如何在这两者之间做一个更好的平衡。</p><h2>什么是TypeScript</h2><p>TypeScript是微软开发的JavaScript的超集，这里说的超集，意思就是TypeScript在语法上完全包含JavaScript。TypeScript的主要作用是给JavaScript赋予强类型的语言环境。现在大部分的开源项目都是用TypeScript构建的，并且Vue 3本身TS的覆盖率也超过了95%。</p><!-- [[[read_end]]] --><p><img src="https://static001.geekbang.org/resource/image/77/78/77827e57090096f5d19a92d53f89ed78.png?wh=1920x1157" alt="图片"></p><p>下图展示了TypeScript和JavaScript的关系，<strong>TypeScript相当于在JavaScript外面包裹了一层类型系统，这样可以帮助我们开发更健壮的前端应用</strong>。</p><p><img src="https://static001.geekbang.org/resource/image/6b/23/6b367c26a1be5a2190c686c0a55f9223.jpg?wh=320x320" alt=""></p><p>接下来，我们看一下TypeScript带来的新语法：首先，TypeScript可以在JavaScript的变量之上限定数据类型。你可以打开这个TypeScript官方的<a href="https://www.typescriptlang.org/play?#code/FAGwpgLgBAxg9gVwE4GcwDkCGBbMAuFCJASwDsBzKAXigHJBK50Bt4gNQTAGZALRUDbtQNwtbQkKAAcSMfKQTYARmCTUoARgBMATkHRiKAPKkQZfNLhxwmUgqJtgwUcXELaACzAgQcKAHc4SEABMBQA">演示链接</a>，在线体验一下TypeScript的这种新语法。</p><p>上面TypeScript的官方演示链接，我用截图的方式放到了下面。你可以看到TypeScript和JavaScript的区别在于：TypeScript的变量后面有一个冒号用来设置好变量的数据类型，courseName变量的值只能是字符串，price只能是数字。</p><p>在第六行代码中，我们给price赋值了字符串，页面右边解析出来的JavaScript代码是没有任何问题的。但是我们点击右边的Errors时，就会看到一个报错信息，明确告诉你string类型的变量不能赋值给数字类型。</p><p><img src="https://static001.geekbang.org/resource/image/0e/b8/0e5d48ac1ca1ae8f027c34e437bfb7b8.png?wh=1920x707" alt="图片"></p><p>这段演示代码算是TypeScript中最简单的Demo了，你的脑子里肯定会提出一个问题：在TypeScript中，既然变量不能随便赋值，那这会带来什么好处吗？</p><p>我还是给你举个例子，在你去极客时间官网购买课程的时候，如果官网上对每个课程的类型都定义得非常详细，那么在课程列表页面，你就能知道《玩转Vue 3全家桶》这个课的受众、价格、难度等类型，所以你在购买之前就可以很轻松地过滤不需要的课程。用TypeScript来描述的话，就是下面的代码：</p><pre><code class="language-typescript">interface 极客时间课程 {\n    课程名字:string,\n    价格:number[],\n    受众:string,\n    讲师头像?:string|boolean,\n    获取口令():string\n}\n\nlet vueCourse: 极客时间课程 = {\n    课程名字:\'玩转Vue 3全家桶\',\n    价格:[59,129],\n    受众: \'前端小老弟\',\n    讲师头像:false,\n    获取口令(){\n        return 88\n    }\n}\n</code></pre><p>这就是TypeScript带来的好处，如果项目中的每个变量、每个接口都能在定义的时候定义好类型，那么很多错误在开发阶段就可以提前被TypeScript识别。在上面的代码中，我们使用interface去定义一个复杂的类型接口，也即极客时间课程。</p><p>这样，一个变量想要描述一个课程，就必须要按照这个格式去定义，也就是说：课程名必须是字符串、价格必须是一个数组，并且内部全部是数字、讲师头像可以是字符串或布尔这两个类型之一、获取口令必须是一个函数，并且返回一个字符串。</p><p>只要是不符合接口规定的类型的变量，就会直接在变量下方给出红色波浪线的报错提示。鼠标移到报错的变量那里，就会有提示信息弹出，直接通知你哪里出问题了。<strong>这也是为什么现在大部分前端开源项目都使用TypeScript构建的原因，因为每个函数的参数、返回值的类型和属性都清晰可见，这就可以极大地提高我们代码的可维护性和开发效率</strong>。</p><p><img src="https://static001.geekbang.org/resource/image/28/32/284fa7c40d13ee168c3abb2134307f32.png?wh=1920x859" alt="图片"></p><p>TypeScript能够智能地去报错和提示，也是Vue 3的代码阅读起来比较顺畅的主要原因。点击这里的Vue 3源码<a href="https://github.com/vuejs/vue-next/blob/master/packages/runtime-core/src/apiCreateApp.ts#L28">链接</a>，如下图所示，在这个源码文件内部的interface App中，定义好了Vue实例所需要的所有方法后，我们可以看到熟悉的use、component、mount等方法。并且每个方法的参数类型和返回值都已经定义好了，阅读和调试代码的难度也降低了很多。</p><p><img src="https://static001.geekbang.org/resource/image/89/b3/896b64a3929a530c0eba6f557a3506b3.png?wh=1904x1644" alt="图片"></p><p>接下来，我来跟你聊一下TypeScript中的一些进阶用法。很多时候，你看不懂开源库TypeScript的原因，也是出在对这些进阶用法的生疏上。</p><p>首先要讲到的进阶用法是泛型，泛型就是指有些函数的参数，你在定义的时候是不确定的类型，而返回值类型需要根据参数来确定。在下面的代码中，我们想规定test函数的返回类型和参数传递类型保持一致，这个时候就没有办法用number或者string预先定义好参数args的类型，为了解决这一问题，泛型机制就派上了用场。</p><p>我们在函数名的后面用尖括号包裹一个类型占位符，常见的写法是<t>，这里为了帮助你理解，我用&lt;某种类型&gt;替代<t>这种写法。调用方式可以直接使用test(1), 也可以使用test &lt;number&gt; (1) 。泛型让我们拥有了根据输入的类型去实现函数的能力，这里你也能感受到TypeScript类型可以进行动态设置。</t></t></p><pre><code class="language-typescript">function test&lt;某种类型&gt;(args:某种类型):某种类型{\n    return args\n}\n</code></pre><p>接下来，我再给你介绍一下TypeScript中泛型的使用方法。在下面的代码中，我们实现一个函数getProperty，它能够动态地返回对象的属性。函数的逻辑是很好实现的，那怎么使用TypeScript限制getProperty的类型呢？</p><pre><code class="language-javascript">getProperty(vueCourse， \'课程名字\') // 返回 [\'玩转Vue3全家桶\']\n</code></pre><p>因为getProperty的返回值是由输入类型决定的，所以一定会用到泛型。但是返回值是vueCourse的一个value值，那如何定义返回值的类型呢？首先我们要学习的是keyof关键字，下面代码中我们使用 <code>type 课程属性列表 = keyof 极客时间课程</code> ，就可以根据获取到的极客时间课程这个对象的属性列表，使用extends来限制属性只能从极客时间的课程里获取。</p><pre><code class="language-typescript">function getProperty&lt;某种类型, 某种属性 extends keyof 某种类型&gt;(o: 某种类型, name: 某种属性): 某种类型[某种属性] {\n    return o[name]\n}\nfunction getProperty&lt;T, K extends keyof T&gt;(o: T, name: K): T[K] {\n    return o[name]\n}\n</code></pre><p>对于上面给出的代码，你可以打开<a href="https://www.typescriptlang.org/play?#code/FAGwpgLgBAxg9gVwE4GcwDkCGBbMAuFCJASwDsBzKAXigHJBK50Bt4gNQTAGZALRUDbtQNwtbQkKAAcSMfKQTYARmCTUoARgBMATkHRiKAPKkQZfNLhxwmUgqJtg14GQhyAZpnFRAgeaAi7UBvpoBfUwH-RgaC8oAG9gKDCoAMBYFUB1bQIiMnIAGlDwwHe5QB4LPEkZOQBtAF1k8KhAdeVAdHk4kgoi8MAm6MAIPUAWTUB5hQB+SoSAHyMTMDMasMB24MA15UBj5UATuQAKAEoOimAAX2twaAA3NgBhRFR8Ny8-QJoQ4qjYhhY2KC4+WgGoDLxcgFZVRJVVQpSw8rw6QFklQD3XoB4HUAgAGAfH1bl8oA0WngnCA0HcRhMZsdiuEkJBkOZaAATTAoAAWYAoAA5SQJikslg4EKQYBBiHBzORIAAFJBwYRyCAATwAPIAF80As56Abx9ANHqiSgIsAejqAcgMoGAAB72Ui4lBQADWYF5cAc0rF4oAfJM4L8RRKpaQcLtZXLZgaJbk7flglDMRBsVA4Llrbh8otrKyIByuTzeZN1mAtshEbQAoByv0A1Eq0abAYOh7lIPmRzbbOOnVNAA">这个链接</a>体验一下，如果传递的name不是极客时间课程类型中的属性，就会有报错提示。</p><p><img src="https://static001.geekbang.org/resource/image/82/cc/824ceff75ccc74801764ac27d3cdc0cc.png?wh=1770x800" alt="图片"></p><p>上面只是TypeScript最简单的应用，关于TypeScript的更多类型的使用文档，你可以在<a href="https://www.tslang.cn/docs/handbook/basic-types.html">官网文档</a>上找到很详细的教程和介绍。而且TypeScript的类型其实是可以编程的，可以根据类型去组合推导新的类型，甚至可以使用extends去实现递归类型。</p><p>在Vue源码中也有一些地方用到了递归类型，可以书写更复杂的类型组合，这一部分你可以自己去官网学习。到这里，相信你应该大致能理解TypeScript给我们带来的好处了，那如何在Vue 3中使用TypeScript呢，这就是我们接下来要解决的问题。</p><h2>Vue 3中的TypeScript</h2><p>由于TypeScript中的每个变量都需要把类型定义好，因而对代码书写的要求也会提高。<strong>Vue 2中全部属性都挂载在this之上，而this可以说是一个黑盒子，我们完全没办法预先知道this上会有什么数据，这也是为什么Vue 2对TypeScript的支持一直不太好的原因</strong>。</p><p>Vue 3全面拥抱Composition API之后，没有了this这个黑盒，对TypeScript的支持也比Vue2要好很多。在下面的代码中，首先我们需要在script 标签上加一个配置 lang=“ts”，来标记当前组件使用了TypeScript，然后代码内部使用defineComponent定义组件即可。</p><pre><code class="language-xml">&lt;script lang="ts"&gt;\nimport { defineComponent } from \'vue\'\nexport default defineComponent({\n  // 已启用类型推断\n})\n&lt;/script&gt;\n</code></pre><p>在&lt;script setup&gt;的内部，需要调整写法的内容不多。下面的代码使用Composition API的过程中，可以针对ref或者reactive进行类型推导。如果ref包裹的是数字，那么在对count.value进行split函数操作的时候，TypeScript就可以预先判断count.value是一个数字，并且进行报错提示。</p><pre><code class="language-javascript">    const count = ref(1)\n    count.value.split(\'\') // =&gt; Property \'split\' does not exist on type \'number\'\n</code></pre><p>我们也可以显式地去规定ref、reactive和computed输入的属性，下面代码中我们分别演示了ref、reactive和computed限制类型的写法，每个函数都可以使用默认的参数推导，也可以显式地通过泛型去限制。</p><pre><code class="language-xml">&lt;script setup lang="ts"&gt;\nimport { computed, reactive, ref } from \'@vue/runtime-core\';\ninterface 极客时间课程 {\n    name:string,\n    price:number\n}\n\n\n\nconst msg = ref(\'\') //&nbsp; 根据输入参数推导字符串类型\nconst msg1 = ref&lt;string&gt;(\'\') //&nbsp; 可以通过范型显示约束\n\nconst obj = reactive({})\nconst course = reactive&lt;极客时间课程&gt;({name: \'玩转Vue3全家桶\', price: 129})\n\nconst msg2 = computed(() =&gt; \'\') // 默认参数推导\nconst course2 = computed&lt;极客时间课程&gt;(() =&gt; {\n&nbsp; return {name: \'玩转Vue3全家桶\', price: 129}\n})\n&lt;/script&gt;\n</code></pre><p>在Vue中，除了组件内部数据的类型限制，还需要对传递的属性Props声明类型。而在&lt;script setup&gt;语法中，只需要在defineProps和defineEmits声明参数类型就可以了。下面的代码中，我们声明了title属性必须是string，而value的可选属性是number类型。</p><pre><code class="language-typescript">const props = defineProps&lt;{\n  title: string\n  value?: number\n}&gt;()\nconst emit = defineEmits&lt;{ \n  (e: \'update\', value: number): void\n}&gt;()\n</code></pre><p>接下来，我们对清单应用做一个TypeScript代码的改造。首先清单本身就是一个类型，在下面的代码中，我们定义Todo这个接口，然后初始化todos的时候，Vue也暴露了Ref这个类型，todos是Ref包裹的数组。</p><pre><code class="language-typescript">import {ref, Ref} from \'vue\'\ninterface Todo{\n  title:string,\n  done:boolean\n}\nlet todos:Ref&lt;Todo[]&gt; = ref([{title:\'学习Vue\',done:false}])\n</code></pre><p>因为这里需要把todos的格式设置为Vue3的响应式类型，所以当你需要了解Composition API所有的类型设置的时候，你可以进入项目目录下面的node_modules/@vue/reactivity/dist/reactivity.d.ts中查看。</p><p>完成了上面的操作后，我们再来了解一下和vue-router的优化相关的工作。vue-router提供了Router和RouteRecordRaw这两个路由的类型。在下面的代码中，用户路由的配置使用RouteRecordRaw来定义，返回的router实例使用类型Router来定义，这两个类型都是vue-router内置的。通过查看这两个类型的定义，我们也可以很方便地学习和了解vue-router路由的写法。</p><pre><code class="language-typescript">import { createRouter, createWebHashHistory, Router, RouteRecordRaw } from \'vue-router\'\nconst routes: Array&lt;RouteRecordRaw&gt; = [\n  ...\n]\n\nconst router: Router = createRouter({\n  history: createWebHashHistory(),\n  routes\n})\n\nexport default router\n</code></pre><p>我们打开项目目录下的node_modules/vue-router/dist/vue-router.d.ts文件，下面的代码中你可以看到vue-router是一个组合类型，在这个类型的限制下，你在注册路由的时候，如果参数有漏写或者格式不对的情况，那就会在调试窗口里直接看到报错信息。如果没有TypeScript的话，我们需要先启动dev，之后在浏览器的调试页面里看到错误页面，回来之后才能定位问题。</p><pre><code class="language-typescript">export declare type RouteRecordRaw = RouteRecordSingleView | RouteRecordMultipleViews | RouteRecordRedirect;\n\ndeclare interface RouteRecordSingleView extends _RouteRecordBase {\n    /**\n     * Component to display when the URL matches this route.\n     */\n    component: RawRouteComponent;\n    components?: never;\n    /**\n     * Allow passing down params as props to the component rendered by `router-view`.\n     */\n    props?: _RouteRecordProps;\n}\n</code></pre><h2>TypeScript和JavaScript的平衡</h2><p>TypeScript引入的强类型系统带来了可维护性较好、调试较为方便的好处。并且TypeScript在社区的热度也越来越高，也有人开始提问：“到底是学TypeScript还是JavaScript？”</p><p>但是，这个提问忽略了这一点：<strong>TypeScript是JavaScript的一个超集，这两者并不是完全对立的关系</strong><strong>。</strong>所以，学习TypeScript和学习JavaScript不是二选一的关系，你需要做的，是打好坚实的JavaScript的基础，在维护复杂项目和基础库的时候选择TypeScript。</p><p>TypeScript能发展至今，得益于微软，而JavaScript的语法则是由TC39协会制定的。由于JavaScript的发展速度问题，有一些语法的实现细节在TC39协会还在讨论的时候，TypeScript就已经实现了。比较典型的就是装饰器Decorator的语法，因为TC39在Decorator的实现思路上，和Typescript不同，未来TypeScript的Decorator可能会和JavaScript的Decorator发生冲突。</p><p>TypeScript最终还是要编译成为JavaScript，并在浏览器里执行。对于浏览器厂商来说，引入类型系统的收益并不太高，毕竟编译需要时间。而过多的编译时间，会影响运行时的性能，所以未来TypeScript很难成为浏览器的语言标准。</p><p>所以我们的核心还是要掌握JavaScript，在这个基础之上，无论是框架，还是TypeScript类型系统，我们都将其作为额外的工具使用，才是我们最佳的选择。</p><h2>总结</h2><p>这一讲的主要内容就结束了，我们来复习一下今天学到的内容。首先，我们介绍了TypeScript是什么，以及该如何使用TypeScript带来的类型系统。我们可以限制变量的类型，包括string、number、boolean等。如果把数字类型的变量赋值给了字符串类型的变量，TypeScript就会在编译阶段提示类型出错的信息。</p><p>我们可以从代码编辑器的智能提示中及时发现错误，这对我们代码的开发效率是一个很大的提升。基于数字、字符串这种简单的变量类型，我们可以组装出接口类型、数组类型等，也就可以更精确地控制项目中的数据结构。</p><p>然后，我们学习了在Vue 3中如何去使用TypeScript，在我们使用的&lt;script setup&gt;环境下，Vue已经把对TypeScript的支持封装得很好了，这样ref 和reactive可以很好地实现类型推导，我们只需要定义好项目中使用变量的格式即可。然后vue-router和Vuex也提供了自己TypeScript类型系统，比如我们可以引入vue-router的RouterViewRecord类型去限制我们书写路由的格式。</p><p>最后，我们讨论了一下TypeScript和JavaScript的关系，这个问题在社区热度也一直不减，我也给出了我的想法，那就是JavaScript是前端这个行业的语法标准，而TypeScript是在此之上的类型系统。主流的浏览器短期也不会直接支持TypeScript，所以我们学习的重点还是要放在JavaScript之上。不过，要是你对TypeScript非常感兴趣的话，也可以在留言区留言，如果呼声很高，我也会考虑新增专门的TypeScript的加餐。</p><h2>思考题</h2><p>最后给你留一个思考题：了解了TypeScript的使用后，你可以回想一下Vue 2里有哪些写法是对TypeScript不友好的，以及我们应该怎么在Vue 3优化呢？</p><p>欢迎你在评论区留言分享，也欢迎你把这一讲的内容分享给你的同事和朋友。</p>',
        article_title: "14 | TypeScript：Vue 3中如何使用TypeScript？",
      },
      {
        title: "15 | 实战痛点1：复杂Vue项目的规范和基础库封装",
        id: 446747,
        content:
          '<p>你好，我是大圣，欢迎进入课程的第15讲。</p><p>在全家桶实战篇的前几讲里，我们学习了Vue 3本身的进阶内容。从今天开始，我们尝试着把这些技能都用在实际项目中，聊一下实战中常见的痛点。不过，既然是实际项目，那还是有很多库需要引入的，比如网络请求时用到的axios、时间处理时用到的Dayjs等等。今天我要跟你聊的，则是复杂 Vue 项目的规范和基础库的封装。</p><h2>组件库</h2><p>在项目开发中，我们首先需要一个组件库帮助我们快速搭建项目，组件库提供了各式各样的封装完备的组件。现在社区可选择的组件库有element-plus、antd-vue，Naive-UI、Element3等，我们选择Element3来搭建项目，首先我们来到项目目录下，执行下面的代码安装Element3。</p><pre><code class="language-bash">npm install element3 --save\n</code></pre><p>然后，我们在src/main.js中使用一下Element3。看下面的代码，我们在其中引入了Element3和主体对应的CSS，并使用use(Element3)加载组件库。</p><pre><code class="language-javascript">import { createApp } from \'vue\'\nimport Element3 from \'element3\'\nimport \'element3/lib/theme-chalk/index.css\'\nimport store from \'./store/index\'\nimport App from \'./App.vue\'\nimport router from \'./router/index\'\n\nconst app = createApp(App)\n\napp.use(store)\n    .use(router)\n    .use(Element3)\n    .mount(\'#app\')\n</code></pre><!-- [[[read_end]]] --><p>这样，项目的入口页面就注册好了Element3内置的组件。关于Element3的组件列表，你可以到<a href="https://e3.shengxinjing.cn/#/component/installation">Element3官网</a>查看。接下来，我们就可以使用组件库去搭建我们的页面了。</p><p>首先，我们打开项目目录下的src/App.vue文件，把之前的学习清单应用时的测试代码移除，然后新增下面的代码。你能看到，我们在代码中使用Element3的<a href="https://e3.shengxinjing.cn/#/component/container">Container布局组件</a>实现管理系统的整体布局。</p><pre><code class="language-xml">&lt;template&gt;\n\n&lt;el-container&gt;\n  &lt;el-header&gt;Header&lt;/el-header&gt;\n  &lt;el-container&gt;\n    &lt;el-aside width="200px"&gt;\n      &lt;div&gt;\n        &lt;router-link to="/"&gt; Home&lt;/router-link&gt; \n      &lt;/div&gt;\n      &lt;div&gt;\n        &lt;router-link to="/about"&gt;About&lt;/router-link&gt;\n      &lt;/div&gt;\n    &lt;/el-aside&gt;\n    &lt;el-container&gt;\n      &lt;el-main&gt;\n        &lt;router-view&gt;&lt;/router-view&gt;\n      &lt;/el-main&gt;\n    &lt;/el-container&gt;\n  &lt;/el-container&gt;\n&lt;/el-container&gt;\n&lt;/template&gt;\n\n&lt;script setup&gt;\n\n&lt;/script&gt;\n&lt;style&gt;\n  .el-header,\n  .el-footer {\n    background-color: #b3c0d1;\n    color: #333;\n    text-align: center;\n  }\n\n  .el-aside {\n    background-color: #d3dce6;\n    color: #333;\n  }\n\n  .el-main {\n    background-color: #e9eef3;\n    color: #333;\n  }\n\n  body &gt; .el-container {\n    margin-bottom: 40px;\n  }\n&lt;/style&gt;\n</code></pre><p>上面代码对应在前端的显示格局如下，代码上方的Header组件，承载着页面的头部信息，包括项目左上角的名字、右上角的用户信息、消息等等。代码中的aside对应了前端页面左侧的侧边栏，承载着页面主要的导航信息；main组件内部使用router-view渲染路由对应的组件，然后我们继续使用Element3逐渐丰富Header和导航信息。</p><h2><img src="https://static001.geekbang.org/resource/image/d2/2a/d237cyycfb6d9c10aa7a04dc5073852a.png?wh=1920x539" alt="图片"></h2><p>在Element3中，我们也可以很方便地找出我们需要的组件，就像Menu等等。在下面的代码中，我们使用el-menu组件渲染header组件，el-menu内部使用el-ment-item渲染导航组件。</p><pre><code class="language-xml">&lt;el-header&gt;\n&lt;el-menu\n  :default-active="1"\n  class="el-menu-demo"\n  mode="horizontal"\n  background-color="#545c64"\n  text-color="#fff"\n  active-text-color="#ffd04b"\n&gt;\n  &lt;el-menu-item index="1"&gt;处理中心&lt;/el-menu-item&gt;\n  &lt;el-submenu index="2"&gt;\n    &lt;template v-slot:title&gt;我的工作台&lt;/template&gt;\n    &lt;el-menu-item index="2-1"&gt;选项1&lt;/el-menu-item&gt;\n    &lt;el-menu-item index="2-2"&gt;选项2&lt;/el-menu-item&gt;\n    &lt;el-menu-item index="2-3"&gt;选项3&lt;/el-menu-item&gt;\n    &lt;el-submenu index="2-4"&gt;\n      &lt;template v-slot:title&gt;选项4&lt;/template&gt;\n      &lt;el-menu-item index="2-4-1"&gt;选项1&lt;/el-menu-item&gt;\n      &lt;el-menu-item index="2-4-2"&gt;选项2&lt;/el-menu-item&gt;\n      &lt;el-menu-item index="2-4-3"&gt;选项3&lt;/el-menu-item&gt;\n    &lt;/el-submenu&gt;\n  &lt;/el-submenu&gt;\n  &lt;el-menu-item index="3" disabled&gt;消息中心&lt;/el-menu-item&gt;\n  &lt;el-menu-item index="4"\n    &gt;&lt;a href="https://element3-ui.com" target="_blank"\n      &gt;订单管理&lt;/a\n    &gt;&lt;/el-menu-item\n  &gt;\n&lt;/el-menu&gt;\n\n  &lt;/el-header&gt;\n</code></pre><p>使用menu组件渲染header和aslide组件后，页面布局示意图如下，这样页面的基本结构就搭建完毕了。</p><h2><img src="https://static001.geekbang.org/resource/image/59/7a/59d3d065f3aec7b769341b10da49407a.png?wh=1816x752" alt="图片"></h2><h2>工具库</h2><p>完成页面基本结构的搭建后，在我们获取后端数据时，需要使用axios发起网络请求。在项目的根目录下，打开命令行，执行下面的命令，这样我们就可以安装axios了（axios 跟 Vue 版本没有直接关系，安装最新即可）。</p><pre><code class="language-bash">npm i axios --save\n</code></pre><p>axios作为现在最流行的网络请求库，可以直接使用axios.get或者axios.post去获取数据。但是在项目开发中，业务逻辑有很多配置需要进行统一设置，<strong>所以安装完axios之后，我们需要做的就是封装项目中的业务逻辑</strong>。</p><p>首先，在项目在登录成功之后，后端会返回一个token，用来存储用户的加密信息，我们把token放在每一次的http请求的header中，后端在收到请求之后，会对请求header中的token进行认证，然后解密出用户的信息，过期时间，并且查询用户的权限后，校验完毕才会返回对应的数据。</p><p>所以我们要对所有的http请求进行统一拦截，确保在请求发出之前，从本地存储中获取token，这样就不需要在每个发起请求的组件内去读取本地存储。后端数据如果出错的话，接口还要进行统一拦截，比如接口返回的错误是登录状态过期，那么就需要提示用户跳转到登录页面重新登录。</p><p>这样，我们就把网络接口中需要统一处理的内容都放在了拦截器中统一处理了。在下面的代码中，所有接口在请求发出之前，都会使用getToken获取token，然后放在header中。在接口返回报错信息的时候，会在调试窗口统一打印报错信息。在项目的组件中，我们只需要直接使用封装好的axios即可。</p><pre><code class="language-javascript">import axios from \'axios\'\nimport { useMsgbox, Message } from \'element3\'\nimport store from \'@/store\'\nimport { getToken } from \'@/utils/auth\'\n\nconst service = axios.create({\n  baseURL: process.env.VUE_APP_BASE_API, // url = base url + request url\n  timeout: 5000, // request timeout\n})\n\nservice.interceptors.request.use(\n  config =&gt; {\n    if (store.getters.token) {\n      config.headers[\'X-Token\'] = getToken()\n    }\n    return config\n  },\n  error =&gt; {\n    console.log(error) // for debug\n    return Promise.reject(error)\n  },\n)\n\nservice.interceptors.response.use(\n  response =&gt; {\n    const res = response.data\n    if (res.code !== 20000) {\n      console.log(\'接口信息报错\',res.message)\n      return Promise.reject(new Error(res.message || \'Error\'))\n    } else {\n      return res\n    }\n  },\n  error =&gt; {\n    console.log(\'接口信息报错\' + error) \n    return Promise.reject(error)\n  },\n)\n\nexport default service\n</code></pre><p>然后，我们在项目里集成CSS预编译器，CSS预编译器可以帮我们更快、更高效地管理和编写CSS代码。在这里，我们选择Sass作为CSS预处理语言，然后我们就进入项目根目录下执行下面代码安装Sass。</p><pre><code class="language-bash">npm install -D sass\n</code></pre><p>然后，我们进入src/components/Todolist.vue文件中。看下面的代码，我们直接在style标签上新增 lang=“scss”，这样就可以使用Sass的语法了。有了Sass之后，我们在CSS里使用了变量、嵌套、继承等逻辑，并定义了$padding和$white这两个变量。这样我们就可以嵌套书写CSS选择器，也就极大地提高我们写CSS的效率。</p><pre><code class="language-xml">&lt;style lang="scss" scoped&gt;\n$padding:10px;\n$white:#fff;\nul {\n  width:500px;\n  margin:0 auto;\n  padding: 0;\n  li {\n    &amp;:hover {\n      cursor: pointer;\n    }\n    list-style-type: none;\n    margin-bottom: $padding;\n    padding: $padding;\n    background: $white;\n    box-shadow: 1px 3px 5px rgba(0, 0, 0, 0.1);\n  }\n}\n&lt;/style&gt;\n</code></pre><p>Sass让我们在CSS的世界里也拥有了编程的概念，在实际项目中可以使用变量和函数等概念优化CSS代码，这个你在Element3组件库的实现中也能看到。</p><p>在Element3的<a href="https://github.com/hug-sun/element3/tree/master/packages/element3/packages/theme-chalk/src">GitHub项目</a>中，我们可以看到所有的Sass代码。以common/var.scss文件为例，在这个文件中，我们可以看到Element3中所有的变量，并且这个文件中的代码也对颜色、动画函数、边框，字体大小等等都做了统一的设置。</p><p>我们也可以修改这些变量，从而获得一个定制风格的Element3。所以项目在开始之初，我们就可以想一下整体设计风格，最好能够预先定义好整体的颜色，边框，字体大小等等，这能极大降低后续的css维护成本。</p><p>至此，一个基于 Vite + Vue 3 + Vue Router + Vuex + Element3 + Axios + Sass 的前端项目开发环境搭建完毕。下面，我们来打磨一下这个项目。<strong>简单来说，就是给项目增加代码规范约束、提交规范约束等，让其更完善、更健壮。</strong></p><h2>代码规范和提交规范</h2><p>由于个人习惯的不同，每个人写代码的风格也略有不同。比如在写JavaScript代码中，有些人习惯在每行代码之后都写分号，有些人习惯不写分号。但是团队产出的项目就需要有一致的风格，这样代码在团队之间阅读起来时，也会更加流畅。ESLint就是专门用来做规范团队代码的一个库。</p><p>首先我们安装ESLint，进入到项目文件夹，使用下面的命令，我们就可以在全局或者本地安装ESLint了。</p><pre><code class="language-bash">npm i eslint -D\n</code></pre><p>ESLint 安装成功后，在项目根目录下执行 npx eslint --init，然后按照终端操作的提示完成一系列设置来创建配置文件。你可以按照下图所示的选择来始化ESLint。</p><p><img src="https://static001.geekbang.org/resource/image/45/c0/457e448ee27c431f51ebb525ff1c87c0.png?wh=1258x422" alt="图片"></p><p>我们设置的是比较松散的校验规则，你可以根据团队风格去额外配置ESLint的插件。我们进入到项目目录下的eslintrc.json中，在rules中新增下面代码，也就是强制要求JavaScript的行尾不写分号。</p><pre><code class="language-json">    "rules": {\n        "semi": ["warn","never"]\n    }\n</code></pre><p>然后，我们在命令行中执行npx eslint src，接着你就会看到下图所示的报错信息，其中详细告诉你了哪里的代码不合规范。根据报错信息的提示，我们进入到router/index.js文件后，删掉第15行代码结束的分号就可以解除这个警告。</p><p><img src="https://static001.geekbang.org/resource/image/08/c0/087yyf6fce41ededfd59ed39883281c0.png?wh=1480x258" alt="图片"></p><p>前面我们已经统一了代码规范，并且在提交代码时进行强约束来保证仓库代码的质量。多人协作的项目中，在提交代码这个环节，也存在一种情况：不能保证每个人对提交信息的准确描述，因此会出现提交信息紊乱、风格不一致的情况。</p><p>对于这种情况，一种比较好的解决方案是，在执行git commit命令的时候，同时执行ESLint。我们使用husky管理git的钩子函数，在每次代码提交至git之前去执行ESLint，只有ESLint的校验通过，commit才能执行成功。后面的进阶开发篇中，单元测试也会放在git的钩子函数中执行，确保提交到git中的代码都是测试通过的。</p><p>项目代码符合规范后，我们就可以把代码提交到代码仓库中，git允许我们在每次提交时，附带一个提交信息作为说明。我们在项目根目录执行下面的命令，提交了一个附带信息是commit的代码。</p><pre><code class="language-bash">git add . \ngit commit -m \'init commit\'\n</code></pre><p><strong>然后我们需要再定义一下git的提交规范，描述信息精准的git提交日志，会让我们在后期维护和 处理Bug时有据可查</strong>。在项目开发周期内，我们还可以根据规范的提交信息，快速生成开发日志，从而方便我们追踪项目和把控进度。 如下图所示，我们可以看到Vue 3的代码提交日志。</p><p><img src="https://static001.geekbang.org/resource/image/44/5b/44cfecd1b31deb36b918bd7aa0c9a05b.png?wh=1920x1287" alt="图片"></p><p>看了Vue 3代码日志提交的格式，初次接触的你可能会觉得复杂。其实不然，Vue 3在代码日志中，使用的是【类别: 信息】的格式，我们可以通过类别清晰地知道这次提交是代码修复，还是功能开发feat。冒号后面的信息是用来解释此次提交的内容，在修复bug时，还会带上issue中的编号。在现在的项目开发中，我们也会强制要求使用和Vue 3一样的git 日志格式。</p><h2>总结</h2><p>今天这一讲的内容到这就结束了，我们来复习一下今天学到的内容。首先我们引入了Element3组件库，在项目入口注册Element3后，你可以在项目的任意地方直接使用<a href="https://e3.shengxinjing.cn/#/component/installation">Element3首页的组件列表</a>。</p><p>这样，我们就可以很方便地使用layout和container布局实现页面的搭建，然后引入axios作为网络请求库，并且对接口统一做了全局拦截。下一讲中，项目权限管理也是在axios拦截函数里实现的。</p><p>当然，复杂的Vue项目更需要良好的规范，毕竟没有规矩不成方圆，为此，我们进一步规范了代码格式，使用ESLint统一JavaScript的代码风格，husky管理git的钩子函数，并且规定了git的提交日志格式，确保代码的可维护性。</p><h2>思考题</h2><p>关于Element3组件库布局和导航组件的使用，你有什么其他布局的建议呢？</p><p>欢迎在留言区发表你的看法，也欢迎你把这一讲的内容推荐给你的同事和朋友们，我们下一讲再见。</p>',
        article_title: "15 | 实战痛点1：复杂Vue项目的规范和基础库封装",
      },
      {
        title: "16 | 实战痛点2：项目开发中的权限系统",
        id: 447579,
        content:
          "<p>你好，我是大圣。</p><p>在上一讲中，我们使用组件库完成了项目的搭建，并且引入了Element3和axios等基础库。基于Element3，我们可以很方便地使用组件搭建项目。而使用axios，可以很方便地获取后端数据。在项目中，权限系统的控制需要前后端配合完成，而且权限系统也是后端管理系统中常见的一个难点。不过，今天我们主要从前端的角度，来聊一下项目的权限系统。</p><p>下面，我们先从登录权限谈起，因为登录权限对于一个项目来说是必备的功能模块。完成了登录选项的设置后，下一步需要做的是管理项目中的页面权限，而角色权限在这一过程中则可以帮助我们精细化地去控制页面权限。</p><h2>登录权限</h2><p>继续上一讲我们搭建起来的项目，你可以看到现在所有的页面都可以直接访问了，通常来说管理系统的内部页面都需要登录之后才可以访问，比如个人中心、订单页面等等。首先，我们来设计一个这样的权限限制功能，它能保证某些页面在登录之后才能访问。</p><p>为了实现这个功能，我们首先需要模拟登录的接口和页面。我们先新增路由页面，进入到项目目录下，在router.js中新增路由配置。下面的代码中，routes数组新增/login路由访问。</p><pre><code class=\"language-javascript\">  import Login from '../components/Login.vue'\n  const routes = [\n  ...\n  {\n    path: '/login',\n    component: Login,\n    hidden: true,\n  }\n  ]\n</code></pre><!-- [[[read_end]]] --><p>然后，我们进入到src/components/Login.vue组件中，组件的代码如下所示。在代码中，我们能看到，用户在输入用户名和密码之后，把用户名和密码传递给后端，然后就可以实现登录认证。</p><pre><code class=\"language-javascript\">handleLogin() {\n  formRef.value.validate(async valid =&gt; {\n    if (valid) {\n      loading.value = true\n      const {code, message} = await useStore.login(loginForm)\n      loading.value = false\n      if(code===0){\n        router.replace( toPath || '/')\n      }else{\n        message({\n          message: '登录失败',\n          type: 'error'\n        })\n      }\n    } else {\n      console.log('error submit!!')\n      return false\n    }\n  })\n}\n</code></pre><p>由于我们的项目是一个前端项目，所以我们需要在Vite内部做数据结构的模拟。我们在src目录下面新建mock目录，用来放置假数据的结构。我们写死一个用户名dasheng，使用用户名dasheng登录成功之后，我们把用户名、过期日期等重要信息进行加密，生成一个token返回给前端。</p><p><strong>这个token就算是一个钥匙，<strong><strong>对于那些</strong></strong>需要权限<strong><strong>才能读取到</strong></strong>的页面数据，前端需要带上这个钥匙才能读取到数据，否则<strong><strong>访问那些页面的时候</strong></strong>就会显示没有权限</strong>。</p><pre><code class=\"language-javascript\">  {\n    url: '/geek-admin/user/login',\n    type: 'post',\n    response: config =&gt; {\n      const { username } = config.body\n      const token = tokens[username]\n\n      // mock error\n      if (user!=='dasheng') {\n        return {\n          code: 60204,\n          message: 'Account and password are incorrect.'\n        }\n      }\n\n      return {\n        code: 20000,\n        data: token\n      }\n    }\n  }\n</code></pre><p>我们回到前端页面，登录成功后，首先需要做的事情，就是把这个token存储在本地存储里面，留着后续发送数据。这一步的实现比较简单，直接把token存储到localStorage中就可以了。我们拿到这个token后，为了进行接口权限认证，要把token放在HTTP请求的header内部。</p><p>我们看下面的代码，在axios的请求发出之前，我们在配置中使用getToken从localStorage中读取token，放在请求的header里发送。由于我们使用了请求拦截的方式，所以所有的后端数据发送的时候，都会带上这个token，完成受限数据的请求。</p><pre><code class=\"language-javascript\">service.interceptors.request.use(\n  config =&gt; {\n    const token = getToken()\n    // do something before request is sent\n    if (token) {\n      config.headers.gtoken = token\n    }\n    return config\n  },\n  error =&gt; {\n    // do something with request error\n    console.log(error) // for debug\n    return Promise.reject(error)\n  }\n)\n</code></pre><p>通过上面的操作，我们完成了前端网络请求的token限制。但是还有一个需求没有实现，就是用户没有登录某个受限页面的时候，或者说没有token的时候，如果直接访问受限页面，比如个人中心，那么就需要让vue-router拦截这次页面的跳转。</p><p>与vue-router拦截页面的跳转，并显示无权限的报错信息相比，直接跳转登录页是现在更流行的交互方式。但这种方式需要在vue-router上加一层限制，这层限制就是说，在路由跳转的时候做权限认证，我们把vue-router的这个功能称作导航守卫。</p><p>关于导航守卫的API，你可以从Vue Router的官网看到很详细的<a href=\"https://next.router.vuejs.org/zh/guide/advanced/navigation-guards.html\">介绍</a>。这里我们实际应用下，下面的代码中，我们在router.beforeEach函数中设置一个全局的守卫。</p><p>每次页面跳转的时候，vue-router会自动执行守卫函数，如果函数返回false的话，页面跳转就会失败。不过，我们也可以手动地跳转到其他页面。现在我们设置的路由很简单，如果token不存在的话直接跳转登录页面，否则返回true，页面正常跳转。</p><pre><code class=\"language-javascript\">router.beforeEach(async (to, from,next) =&gt; {\n  // canUserAccess() 返回 `true` 或 `false`\n  let token = getToken()\n  if(!token){\n     next('/login')\n  }\n  return true\n})\n</code></pre><p>当然，在路由守卫的函数内，只要是页面跳转时想实现的操作，都可以放在这个函数内部实现，比如一些常见的交互效果，就像给项目的主页面顶部设置一个页面跳转的进度条、设置和修改页面标题等等。和我们现在对全部页面进行一次性的粗略拦截相比，后面还会在路由守卫那里进行更精确的路由拦截。</p><p>到这里你可能会有疑问：之前开发项目的时候，和登录注册相关的配置，不需要自己管理token，都是后端直接设置cookie。那么这里用到的token和之前项目开发时，交给后端设置的cookie到底有什么区别呢？</p><p>这是个非常好的问题，我们在第一讲聊前端发展史的时候，提到了jQuery时代的前端项目是作为后端项目的模块部署的。</p><p>那时候前后端不分家，整个应用的入口是后端控制模板的渲染。在模板渲染前，后端会直接判断路由的权限来决定是否跳转。登录的时候，后端只需要设置setCookie这个header，之后浏览器会自动把cookie写入到我们的浏览器存起来，然后当前域名在发送请求的时候都会自动带上这个cookie。</p><p>在Chrome浏览器中，我们先进入极客时间的官网，然后打开调试窗口页面，再选择Network页面。之后，我们在页面中点击Fetch/XHR，然后在Name这一栏中，我们可以任选一个接口点开。这样，我们就可以看到这个接口请求的所有细节了。</p><p>在下图中，我们点击list请求，也就是极客时间的推荐接口时，HTTP的Request Headers里就有Cookie这个数据，这是浏览器自动管理和发送的，也算是权限认证的最佳方案之一。</p><p><img src=\"https://static001.geekbang.org/resource/image/98/8e/98b1ce4137ecfb9ea01dc4ea0381e68e.png?wh=1920x1084\" alt=\"图片\"></p><p>但是，在现在这种前后端分离的场景下，通常前后端项目都会部署在不同的机器和服务器之上，Cookie在跨域上有诸多的限制。所以在这种场景下，我们更愿意手动地去管理权限，于是就诞生了现在流行的基于token的权限解决方案，你也可以把token理解为我们手动管理的cookie。</p><h2>角色权限</h2><p>实现登录权限验证之后，我们就可以针对项目中的页面进行登录的保护。但现在，我们只能通过登录状态去判断页面的显示与否，而这远远达不到我们实际开发的需求。</p><p>比如，在我们的管理系统开发中，订单页面是所有人都可以看到的，但是像账单的查询页面，以及其他一些权限更高的页面，我们需要管理员权限才能看到。这时候，我们就需要对系统内部的权限进行分级，每个级别都对应着可以访问的不同页面。</p><p>我们通常使用的权限解决方案就是RBAC权限管理机制。简单来说，就是在下图所示的这个模型里，除了用户和页面之外，<strong>我们需要一个新的概念，就是角色</strong><strong>。</strong>每个用户有不同的角色，每个角色对应不同的页面权限，这个数据结构的关系设计主要是由后端来实现。</p><p>根据下图这个结构，在用户登录完成之后我们会获取页面的权限数据，也就是说后端会返回给我们当前页面的动态权限部分。</p><p><img src=\"https://static001.geekbang.org/resource/image/e9/95/e93dd5a15c93b193debe462eb0349c95.jpg?wh=1347x697\" alt=\"图片\"></p><p>这样有一部分页面是写在代码的src/router/index.js中，另外一部分页面我们通过axios获取数据后，通过调用vue-router的addRoute方法动态添加进项目整体的路由配置中。</p><p>关于这部分动态路由的内容，官网的文档中有详细的<a href=\"https://next.router.vuejs.org/zh/guide/advanced/dynamic-routing.html\">API介绍</a>。在下面的代码中，我们在Vuex中注册addRoute这个action，通过后端返回的权限页面数据，调用router.addRoute新增路由。</p><pre><code class=\"language-javascript\">  addRoutes({ commit }, accessRoutes) {\n    // 添加动态路由，同时保存移除函数，将来如果需要重置路由可以用到它们\n    const removeRoutes = []\n    accessRoutes.forEach(route =&gt; {\n      const removeRoute = router.addRoute(route)\n      removeRoutes.push(removeRoute)\n    })\n    commit('SET_REMOVE_ROUTES', removeRoutes)\n  },\n</code></pre><p>与新增路由对应，在页面重新设置权限的时候，我们需要用router.removeRoute来删除注册的路由，这也是上面的代码中我们还有一个remoteRoutes来管理动态路由的原因。</p><p>然后，我们需要把动态路由的状态存储在本地存储里，否则刷新页面之后，动态的路由部分就会被清空，页面就会显示404报错。我们需要在localStorage中把静态路由和动态路由分开对待，在页面刷新的时候，通过src/router/index.js入口文件中的routes配置，从localStorage中获取完整的路由信息，并且新增到vue-router中，才能加载完整的路由。</p><p>权限系统中还有一个常见的问题，就是登录是有时间限制的。在常见的登录状态下，token有效期只能保持24小时或者72小时，过了这个期限，token会自动失效。即使我们依然存在token，刷新页面后也会跳转到登录页。所以，对token有效期的判断这个需求该如何实现呢？</p><p>首先，token的过期时间认证是由后端来实现和完成的。如果登录状态过期，那么会有一个单独的报错信息，我们需要在接口拦截函数中，统一对接口的响应结果进行拦截。如果报错信息显示的是登录过期，我们需要清理所有的token和页面权限数据，并且跳转到登录页面。</p><p>下面的代码中，50008和50012都代表着状态过期，我们可以直接使用Element3的messageBox组件显示一个错误信息，提示用户需要重新登录，然后直接跳转到登录页面就可以了。</p><pre><code class=\"language-javascript\">// 50008: Illegal token; 50012: Other clients logged in; 50014: Token expired;\nif (res.code === 50008 || res.code === 50012) {\n  // to re-login\n  Msgbox.confirm('You have been logged out, you can cancel to stay on this page, or log in again', 'Confirm logout', {\n    confirmButtonText: 'Re-Login',\n    cancelButtonText: 'Cancel',\n    type: 'warning',\n  }).then(() =&gt; {\n    store.dispatch('user/resetToken').then(() =&gt; {\n      location.reload()\n    })\n  })\n}\nreturn Promise.reject(new Error(res.message || 'Error'))\n</code></pre><h2>总结</h2><p>今天这一讲的内容就讲完了，我们来总结一下今天学到的重点吧。首先，在登录权限这一部分，我们模拟了登录的接口和页面，登录成功后的token存储在localStorage中，使用axios的拦截器管理所有接口的token信息。</p><p>然后，我们学习了路由守卫的概念，借助路由守卫，我们可以实现页面的权限保护，让指定页面需要登录之后才可以访问。我们使用的是token权限校验机制，在用户登录之后，后端会把用户信息加密成一个token返回给前端，然后前端把token存储在localStorage中。</p><p>在axios的全局拦截函数中，每个请求发出去之前都会获取token，然后放在HTTP请求的header之中，后端会读取这个token进行权限认证。除了后端接口的权限，vue-router也会做页面的权限拦截，这个功能也就是路由守卫，vue-router允许你在所有路由跳转之前执行钩子函数，这个函数内部我们做权限认证，如果符合要求就允许跳转，否则就跳转到404页面。</p><p>最后，我们还了解了更复杂一些的权限系统设计，在这种设计下，用户可以根据角色的划分，对应到不同的页面权限，一部分页面是登录后就可以访问，一部分页面是需要额外地获取后端接口，匹配到当前用户权限之后，才可以访问的页面，我们把这种权限设计称之为动态路由。vue-router提供的addRoute和removeRoute这两个函数，可以很好地帮助我们实现这一功能。</p><h2>思考题</h2><p>最后，是给你留的一个思考题，如果在任意一个页面里，我们想实现按钮级别的权限认证，那我们应该如何扩展我们的权限系统呢？</p><p>欢迎在留言区分享你的看法，也欢迎你把这一讲的内容分享给你的同事、朋友们，我们下一讲再见。</p>",
        article_title: "16 | 实战痛点2：项目开发中的权限系统",
      },
      {
        title: "17 | 实战痛点3：Vue 3 中如何集成第三方框架",
        id: 450611,
        content:
          "<p>你好，我是大圣。</p><p>在上一讲中，我给你介绍了如何在Vue 3中实现页面和接口的权限管理。我们把vue-router的动态路由、导航守卫、axios的接口拦截等功能配合到一起使用，实现了页面的权限控制，这也算是Vue中进阶使用vue-router和axios的一个方式。</p><p>今天，我们再来学习另一个进阶玩法，聊一下如何在Vue 3中使用和引入更多的框架。可别小看这里的门道，有的第三方工具框架跟Vue耦合性不高，而有的需要做适配，这一讲我就详细给你说说实操中的注意事项，帮助你在提高开发效率的同时少走弯路。</p><h2>独立的第三方库</h2><p>首先我们要介绍的第三方框架是axios，这是一个完全独立于Vue的框架，我们可以使用axios发送和获取网络接口数据。在Vue、React框架下，axios可以用来获取后端数据。甚至在Node.js环境下，也可以用axios去作为网络接口工具去实现爬虫。</p><p>axios这种相对独立的工具对于我们项目来说，引入的难度非常低。通常来说，使用这种独立的框架需要以下两步。</p><p>以页面进度条工具NProgress为例，第一步是，我们先进入到项目根目录下，使用下面的命令去安装NProgress。</p><pre><code class=\"language-bash\">npm install nprogress -D\n</code></pre><!-- [[[read_end]]] --><p>第二步，就是在需要使用NProgress的地方进行import的相关操作，比如在页面跳转的时候，我们就需要使用NProgress作为进度条。导入NProgress库之后，我们就不需要使用Vue3的插件机制进行注册，只需要通过router.beforeEach来显示进度条，通过afterEach来结束进度条就可以了。</p><pre><code class=\"language-javascript\">import NProgress from 'nprogress' // progress bar\nrouter.beforeEach(async (to, from, next) =&gt; {\n  // start progress bar\n  NProgress.start()\n})\n\nrouter.afterEach(() =&gt; {\n  // finish progress bar\n  NProgress.done()\n})\n</code></pre><p>在项目中，我们之后还会依赖很多和NProgress类似的库，比如处理Excel的xlsx库，处理剪切板的clipboard库等等。</p><h2>组件的封装</h2><p>下面我们以可视化组件为例，来分析复杂组件的封装。之所以选择可视化组件为示例，是因为管理系统中的统计数据、销售额数据等等，都喜欢用饼图或柱状图的方式来展示。</p><p>虽然可视化本身和Vue没有太大关系，但我们需要在页面中以组件的形式显示可视化图表。对此，我们的选择是用可视化框架ECharts去封装Vue的组件，来实现可视化组件。</p><p>我们再简单介绍一下可视化框架的使用方式，不管你选择用百度的ECharts，还是蚂蚁的G2等框架，在框架的使用方法上，都是类似的。首先，你需要完成图表库的配置，并且填入图表数据，然后把这个数据渲染在一个DOM上就可以了。</p><p>下面的代码展示了一个ECharts的入门案例，代码中我们首先使用echarts.init初始化一个DOM标签；然后在options中配置了图表的结构，包括标题、x轴等；并且我们还通过series配置了页面的销量数据；最后使用myChart.setOption的方式渲染图表就可以了。</p><pre><code class=\"language-html\">&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n  &lt;head&gt;\n    &lt;meta charset=\"utf-8\" /&gt;\n    &lt;title&gt;ECharts&lt;/title&gt;\n    &lt;!-- 引入刚刚下载的 ECharts 文件 --&gt;\n    &lt;script src=\"echarts.js\"&gt;&lt;/script&gt;\n  &lt;/head&gt;\n  &lt;body&gt;\n    &lt;!-- 为 ECharts 准备一个定义了宽高的 DOM --&gt;\n    &lt;div id=\"main\" style=\"width: 600px;height:400px;\"&gt;&lt;/div&gt;\n    &lt;script type=\"text/javascript\"&gt;\n      // 基于准备好的dom，初始化echarts实例\n      var myChart = echarts.init(document.getElementById('main'));\n      // 指定图表的配置项和数据\n      var option = {\n        title: {\n          text: 'ECharts 入门示例'\n        },\n        tooltip: {},\n        legend: {\n          data: ['销量']\n        },\n        xAxis: {\n          data: ['衬衫', '羊毛衫', '雪纺衫', '裤子', '高跟鞋', '袜子']\n        },\n        yAxis: {},\n        series: [\n          {\n            name: '销量',\n            type: 'bar',\n            data: [5, 20, 36, 10, 10, 20]\n          }\n        ]\n      };\n      // 使用刚指定的配置项和数据显示图表。\n      myChart.setOption(option);\n    &lt;/script&gt;\n  &lt;/body&gt;\n&lt;/html&gt;\n</code></pre><p>看上面的代码，我们先配置好图表需要的数据，然后使用setOption初始化图表，之后在浏览器中打开项目主页面，就可以看到下图所示的这种可视化结果。在你理解了ECharts的使用方法后，下一个要解决的问题是，我们该如何在Vue 3中集成这个框架呢？答案就是我们自己实现与ECharts对应的Vue组件即可。</p><p><img src=\"https://static001.geekbang.org/resource/image/4b/8c/4b0df7c9e10023fc216530c47c013d8c.png?wh=1662x868\" alt=\"图片\"></p><p>在Vue 3中集成ECharts的最简单的方式，就是封装一个Chart组件，把上面代码中的option配置以参数的形式传递给Chart组件，然后组件内部进行渲染即可。</p><p>我们还是结合代码直观体验一下。在下面的代码中，template设置了一个普通的div作为容器，通过mount和onUnmounted生命周期内部去初始化图表，实现ECharts框架中图表的渲染和清理，然后initChart内部使用echart的API进行渲染，这样就实现了图表的渲染。</p><pre><code class=\"language-html\">&lt;template&gt;\n  &lt;div ref=\"chartRef\" class=\"chart\"&gt;&lt;/div&gt;\n&lt;/template&gt;\n\n&lt;script setup&gt;\nimport * as echarts from 'echarts'\nimport {ref,onMounted,onUnmounted} from 'vue'\n// 通过ref获得DOM\nlet chartRef = ref()\nlet myChart \nonUnmounted(()=&gt;{\n  myChart.dispose()\n  myChart = null\n})\nonMounted(()=&gt;{\n    myChart = echarts.init(chartRef.value)\n     const option = {\n        tooltip: {\n            trigger: 'item'\n        },\n        color: ['#ffd666', '#ffa39e', '#409EFF'],\n        // 饼图数据配置\n        series: [\n            {\n                name: '前端课程',\n                type: 'pie',\n                radius: '70%',\n                data: [\n                    {value: 43340, name: '重学前端'},\n                    {value: 7003, name: 'Javascript核心原理解析'},\n                    {value: 4314, name: '玩转Vue3全家桶'}\n                ]\n            }\n        ]\n    }\n    myChart.setOption(option)\n})\n&lt;/script&gt;\n</code></pre><p>在上面，我们虽然实现了可视化组件的封装，但因为逻辑并不复杂，所以我们的实现还比较简略。</p><p>我们当然可以尝试去实现一下更详细的可视化组件封装，但因为ECharts是一个非常复杂的可视化框架，有饼图，地图等不同的图表类型，如果引入ECharts全部代码的话，项目的体积会变得非常臃肿。所以，如果我们能按照不同的图表类型按需引入ECharts，那么除了能够让组件使用起来更方便之外，整体项目的包的大小也会优化很多。</p><h2>指令的封装</h2><p>接下来，我们再介绍一下指令增强型组件的封装。</p><p>比如我们常见的图片懒加载的需求，这一需求的实现方式就是在img的标签之上，再加上一个v-lazy的属性。而图片懒加载和指令增强型组件的封装的关系在于，v-lazy指令的使用方式是在HTML标签上新增一个属性。Vue内置的指令我们已经很熟悉了，包括v-if、v-model等等。像图片懒加载这种库和DOM绑定，但是又没有单独的组件渲染逻辑的情况，通常在Vue中以指令的形式存在。</p><p>在Vue中注册指令和组件略有不同，下面的代码中我们注册实现了v-focus指令，然后在input标签中加上v-focus指令，在指令加载完毕后，鼠标会自动聚焦到输入框上，这个实现在登录注册窗口中很常见。</p><pre><code class=\"language-javascript\">// 注册一个全局自定义指令 `v-focus`\napp.directive('focus', {\n  // 当被绑定的元素挂载到 DOM 中时……\n  mounted(el) {\n    // 聚焦元素\n    el.focus()\n  }\n})\n</code></pre><p>指令的生命周期和组件类似，首先我们要让指令能够支持Vue的插件机制，所以我们需要在install函数内注册lazy指令。这种实现Vue插件的方式，在vuex和vue-router两讲中已经带你学习过了，这里的代码里我们使用install方法，在install方法的内部去注册lazy指令，并且实现了mounted、updated、unmounted三个钩子函数。</p><pre><code class=\"language-javascript\">const lazyPlugin = {\n  install (app, options) {\n    app.directive('lazy', {\n      mounted: ...,\n      updated: ...,\n      unmounted: ...\n    })\n  }\n}\n</code></pre><p>我们通过lazy指令获取到当前图片的标签，并且计算图片的位置信息，判断图片是否在首页显示。如果不在首页的话，图片就加载一个默认的占位符就可以了，并且在页面发生变化的时候，重新进行计算，这样就实现了页面图片的懒加载。</p><p>与懒加载类似的，还有我们组件库中常用的v-loading指令，它用来显示组件内部的加载状态，我们在Element3中。也有类似的指令效果，下面的代码中，我们注册了loadingDirective指令，并且注册了mounted、updated、unmounted三个钩子函数，通过v-loading的值来对显示效果进行切换，实现了组件内部的loading状态。</p><p>动态切换的Loading组件能够显示一个circle的div标签，通过v-loading指令的注册，在后续表格、表单等组件的提交状态中，加载状态就可以很方便地使用v-loading来实现。</p><pre><code class=\"language-javascript\">const loadingDirective = {\n  mounted: function (el, binding, vnode) {\n    const mask = createComponent(Loading, {\n      ...options,\n      onAfterLeave() {\n        el.domVisible = false\n        const target =\n          binding.modifiers.fullscreen || binding.modifiers.body\n            ? document.body\n            : el\n        removeClass(target, 'el-loading-parent--relative')\n        removeClass(target, 'el-loading-parent--hidden')\n      }\n    })\n    el.options = options\n    el.instance = mask.proxy\n    el.mask = mask.proxy.$el\n    el.maskStyle = {}\n\n    binding.value &amp;&amp; toggleLoading(el, binding)\n  },\n\n  updated: function (el, binding) {\n    el.instance.setText(el.getAttribute('element-loading-text'))\n    if (binding.oldValue !== binding.value) {\n      toggleLoading(el, binding)\n    }\n  },\n\n  unmounted: function () {\n    el.instance &amp;&amp; el.instance.close()\n  }\n}\n\nexport default {\n  install(app) {\n    // if (Vue.prototype.$isServer) return\n    app.directive('loading', loadingDirective)\n  }\n}\n</code></pre><h2>引入第三方库的注意事项</h2><p>我们封装第三方库的目的是实现第三方框架和Vue框架的融合，提高开发效率。这里我跟你聊几个和引入第三方库相关的注意事项。</p><p>首先，无论是引用第三方库还是你自己封装的底层库，在使用它们之初就要考虑到项目的长期可维护性；其次，尽可能不要因为排期等问题，一股脑地把第三方库堆在一起，虽然这样做可以让项目在早期研发进度上走得很快，但这样会导致项目中后期的维护成本远远大于重写一遍代码xxx的成本。</p><p>然后是Vue中的mixin，extends机制能不用就不用，这两个API算是从Vue 2时代继承下来的产物，都是扩展和丰富Vue 2中this关键字，在项目复杂了之后，mixin和extends隐式添加的API无从溯源，一旦多个mixin有了命名冲突，调试起来难度倍增。</p><p>项目中的全局属性也尽可能少用，全局变量是最原始的共享数据的方法，Vue 3中我们使用app.config.globalProperties.x注册全局变量，要少用它的主要原因也是项目中的全局变量会极大的提高维护成本。有些监控场景必须要用到，就要把所有注册的全局变量放在一个独立的文件去管理。</p><p>最后，我们引入第三方框架和库的时候一定要注意按需使用，比如我们只用到了ECharts中的某几种类型的图，也只用到了Element3中的部分组件。现在引入全部代码的方式会让项目体积越来越大，关于代码体积优化的内容，我们在18讲谈性能优化时也会详细介绍。</p><h2>总结</h2><p>今天的这一讲的内容就学完了，我们来复习一下今天学到的知识。首先，我们介绍了Vue中如何封装第三方工具框架，比如axios，NProgress等，这些框架和Vue耦合性不强，直接引入使用即可。然后，我讲到了Vue中封装可视化组件库的方式，也就是把第三方库放在Vue的组件内部执行。</p><p>就像对于ECharts、wangEditor等成熟的框架来说，对这些框架进行Vue 3框架的适配工作，主要适配的载体就是组件。你可以选择直接透传所有option配置来做一个很浅的封装，也可以针对需要用的组件类型逐个封装，比如ECharts可以封装Pie，Bar等不同类型的组件。</p><p>之后我们讲解了指令增强型组件的封装，这种库和DOM绑定，但是又没有单独的组件渲染逻辑，通常在Vue中以指令的形式存在，比较常见的就是图片懒加载指令以及loading指令，我们项目中也会用到这两个指令来增强组件。</p><p>最后，我也给你介绍了一些引入第三方库时，需要你注意的事项，例如<strong>从项目开始之初就要考虑到长期维护的成本，不要一股脑地堆砌代码，要学会全面使用Composition API 组织代码、少用全局变量，以及不要引入第三方库全部代码，这些都是很值得你注意的地方</strong>。</p><h2>思考题</h2><p>最后留一个思考题，你的项目中还有什么第三方框架需要引入呢？大家可以在评论区分享你的答案，也欢迎你把这一讲的内容分享给你的同事、朋友们。</p>",
        article_title: "17 | 实战痛点3：Vue 3 中如何集成第三方框架",
      },
      {
        title: "18 | 实战痛点4：Vue 3 项目中的性能优化",
        id: 455487,
        content:
          '<p>你好，我是大圣，欢迎进入课程的第18讲。</p><p>在上一讲中，我们聊了项目中的权限设计，相信你对Vue项目中如何设计，以及如何实现权限都有了自己的心得。今天，我们来聊一下Vue项目中的另外一个难点：性能优化。性能优化是一个老生常谈的话题，如果你是前端从业者，那么无论是求职的简历，还是晋升的PPT，性能优化相关的内容都是不可或缺的。</p><p>那么在Vue项目中，我们应该如何做性能优化呢？下面，我们会先从Vue项目在整体上的执行流程谈起，然后详细介绍性能优化的两个重要方面：<strong>网络请求优化和代码效率优化</strong>。不过，在性能优化之外，用户体验才是性能优化的目的，所以我也会简单谈一下用户体验方面的优化项。最后，我还会通过性能监测报告，为你指引出性能优化的方向。</p><h2>用户输入URL到页面显示的过程</h2><p>我们先来聊一个常见的面试题，那就是用户从输入URL，然后点击回车，到页面完全显示出来，这一过程中到底发生了什么？</p><p>通过下图，我们可以从前端的视角看到从输入URL到页面显示的大致过程：</p><p><img src="https://static001.geekbang.org/resource/image/95/5b/9550f050235a9bc0a91dc6e33f7e9e5b.jpg?wh=1920x923" alt="图片"></p><p>简单来说，就是用户在输入URL并且敲击回车之后，浏览器会去查询当前域名对应的IP地址。对于IP地址来说，它就相当于域名后面的服务器在互联网世界的门牌号。然后，浏览器会向服务器发起一个网络请求，服务器会把浏览器请求的HTML代码返回给浏览器。</p><!-- [[[read_end]]] --><p>之后，浏览器会解析这段HTML代码，并且加载HTML代码中需要加载的CSS和JavaScript，然后开始执行JavaScript代码。进入到项目的代码逻辑中，可以看到Vue中通过vue-router计算出当前路由匹配的组件，并且把这些组件显示到页面中，这样我们的页面就完全显示出来了。而我们性能优化的主要目的，就是让页面显示过程的时间再缩短一些。</p><h2>性能优化</h2><p>从用户输入URL到页面显示的过程这个问题，包含着项目页面的执行流程。这个问题之所以重要，是因为我们只有知道了在这个过程中，每一步都发生了什么，之后才能针对每一步去做网络请求的优化，这也是性能优化必备的基础知识。</p><h3>网络请求优化</h3><p>对于前端来说，可以优化的点，首先就是在首页的标签中，使用<link rel="dns-prefetch">标签去通知浏览器对页面中出现的其他域名去做DNS的预解析，比如页面中的图片通常都是放置在独立的CDN域名下，这样页面加载首页的时候就能预先解析域名并把结果缓存起来 。</p><p>因为极客时间首页没做这个优化，所以我们以淘宝网的首页为例进行分析。你可以在<a href="view-source:https://www.taobao.com">淘宝的首页源码</a>中看到下图所示的一列dns-prefetch标签，这样首页再出现img.alicdn.com这个域名请求的时候，浏览器就可以从缓存中直接获取对应的IP地址。</p><p><img src="https://static001.geekbang.org/resource/image/23/e6/23163cccae366e93afbe0125c77838e6.png?wh=1330x524" alt="图片"></p><p>项目在整体流程中，会通过HTTP请求加载很多的CSS、JavaScript，以及图片等静态资源。为了让这些文件在网络加载中更快，我们可以从后面这几方面入手进行优化。</p><p>首先，浏览器在获取网络文件时，需要通过HTTP请求，HTTP协议底层的TCP协议每次创建链接的时候，都需要三次握手，而三次握手会造成额外的网络损耗。如果浏览器需要获取的文件较多，那就会因为三次握手次数过多，而带来过多网络损耗的问题。</p><p>所以，首先我们需要的是让文件尽可能地少，这就诞生出一些常见的优化策略，比如先给文件打包，之后再上线；使用CSS雪碧图来进行图片打包等等。文件打包这条策略在HTTP2全面普及之前还是有效的，但是在HTTP2普及之后，多路复用可以优化三次握手带来的网络损耗。关于HTTP2的更多内容，你可以去搜索相关文章自行学习。</p><p>其次，<strong>除了让文件尽可能少，我们还可以想办法让这些文件尽可能地小一些</strong>，因为如果能减少文件的体积，那文件的加载速度自然也就会变快。这一环节也诞生出一些性能优化策略，比如CSS和JavaScript代码会在上线之前进行压缩；在图片格式的选择上，对于大部分图片来说，需要使用JPG格式，精细度要求高的图片才使用PNG格式；优先使用WebP等等。也就是说，尽可能在同等像素下，选择体积更小的图片格式。</p><p>在性能优化中，懒加载的方式也被广泛使用。图片懒加载的意思是，我们可以动态计算图片的位置，只需要正常加载首屏出现的图片，其他暂时没出现的图片只显示一个占位符，等到页面滚动到对应图片位置的时候，再去加载完整图片。</p><p>除了图片，项目中也会做路由懒加载，现在项目打包后，所有路由的代码都在首页一起加载。但是，我们也可以把不常用的路由单独打包，在用户访问到这个路由的时候再去加载代码。下面的代码中，vue-router也提供了懒加载的使用方式，只有用户访问了/course/:id这个页面后，对应页面的代码才会加载执行。</p><pre><code class="language-javascript">  {\n    path: \'/course/:id\',\n    component: () =&gt; import(\'../pages/courseInfo\'),\n  },\n</code></pre><p>在文件大小的问题上，Lighthouse已经给了我们比较详细的优化方法，比如控制图片大小、减少冗余代码等等，我们可以在项目打包的时候，使用可视化的插件来查看包大小的分布。</p><p>我们来到项目根目录下，通过执行npm install操作来安装插件rollup-plugin-visualizer。使用这个插件后，我们就可以获取到代码文件大小的报告了。之后，进入到vite.config.js这个文件中，新增下列代码，就可以在Vite中加载可视化分析插件。</p><pre><code class="language-javascript">import { visualizer } from \'rollup-plugin-visualizer\'\nexport default defineConfig({\n  plugins: [vue(),vueJsx(), visualizer()],\n})\n</code></pre><p>然后，我们在项目的根目录下执行 npm run build命令后，项目就把项目代码打包在根目录的dist目录下，并且根目录下多了一个文件stat.html。</p><p>我们用浏览器打开这个stat文件，就能看到下面的示意图。项目中的ECharts和Element3的体积远远大于项目代码的体积，这时候我们就需要用懒加载和按需加载的方式，去优化项目整体的体积。</p><p><img src="https://static001.geekbang.org/resource/image/de/89/de38f42fb62c74yy9eb964fd399f7d89.png?wh=1920x1109" alt="图片"></p><p>那么这些文件如何才能高效复用呢？<strong>我们需要<strong><strong>做的，就是</strong></strong>尽可能高效<strong><strong>地</strong></strong>利用浏览器的缓存机制，在文件内容没有发生变化的时候，做到一次加载多次使用</strong>，项目中如果成功复用一个几百KB的文件，对于性能优化来说是一个巨大的提升。</p><p>浏览器的缓存机制有好几个Headers可以实现，Expires、Cache-control，last-modify、etag这些缓存相关的Header可以让浏览器高效地利用文件缓存。我们需要做的是，只有当文件的内容修改了，我们才会重新加载文件。这也是为什么我们的项目执行npm run build命令之后，静态资源都会带上一串Hash值，因为这样确保了只有文件内容发生变化的时候，文件名才会发生变化，其他情况都会复用缓存。</p><h3>代码效率优化</h3><p>在浏览器加载网络请求结束后，页面开始执行JavaScript，因为Vue已经对项目做了很多内部的优化，所以在代码层面，我们需要做的优化并不多。很多Vue 2中的性能优化策略，在Vue 3时代已经不需要了，我们需要做的就是<strong>遵循Vue官方的最佳实践</strong>，其余的交给Vue自身来优化就可以了。</p><p>比如computed内置有缓存机制，比使用watch函数好一些；组件里也优先使用template去激活Vue内置的静态标记，也就是能够对代码执行效率进行优化；v-for循环渲染一定要有key，从而能够在虚拟DOM计算Diff的时候更高效复用标签等等。然后就是JavaScript本身的性能优化，或者说某些实现场景算法的选择了，这里需要具体问题具体分析，在通过性能监测工具发现代码运行的瓶颈后，我们依次对耗时过长的函数进行优化即可。</p><p>我们来到src/App.vue文件中，看下面的代码，我们实现了一个斐波那契数列，也就是说，在我们实现的这个数列中，每一个数的值是前面两个数的值之和。我们使用简单的递归算法实现斐波那契数列后，在页面显示计算结果。</p><pre><code class="language-javascript">function fib(n){\n  if(n&lt;=1) return 1\n  return fib(n-1)+fib(n-2)\n}\nlet count = ref(fib(38))\n</code></pre><p>上面的代码在功能上，虽然实现了斐波那契数列的要求，但是我们能够感觉到页面有些卡顿，所以我们来对页面的性能做一下检测。</p><p>我们打开调试窗口中的Performance面板，使用录制功能后，便可得到下面的火焰图。通过这个火焰图，我们可以清晰地定位出这个项目中，整体而言耗时最长的fib函数，并且我们能看到这个函数被递归执行了无数次。到这里，我们不难意识到这段代码有性能问题。不过，定位到问题出现的地方之后，代码性能的优化就变得方向明确了。</p><p><img src="https://static001.geekbang.org/resource/image/12/b9/12d7d30ea1f7bae6435fb6d5a21a80b9.png?wh=1920x1120" alt="图片"></p><p>下面的代码中，我们使用递推的方式优化了斐波那契数列的计算过程，页面也变得流畅起来，这样优化就算完成了。其实对于斐波那契数列的计算而言，得到最好性能的方式是使用数学公式+矩阵来计算。不过在项目瓶颈到来之前，我们采用下面的算法已经足够了，<strong>这也是性能优化另外一个重要原则，那就是不要过度优化</strong><strong>。</strong></p><pre><code class="language-javascript">function fib(n){\n  let arr = [1,1]\n  let i = 2\n  while(i&lt;=n){\n    arr[i] = arr[i-1]+arr[i-2]\n    i++\n  }\n  return arr[n]\n}\n</code></pre><h2>用户体验优化</h2><p>性能优化的主要目的，还是为了能让用户在浏览网页的时候感觉更舒服，所有有些场景我们不能只考虑单纯的性能指标，还要结合用户的交互体验进行设计，<strong>必要的时候，我们可以损失一些性能去换取交互体验的提升。</strong></p><p>比如用户加载大量图片的同时，如果本身图片清晰度较高，那直接加载的话，页面会有很多图一直是白框。所以我们也可以预先解析出图片的一个模糊版本，加载图片的时候，先加载这个模糊的图作为占位符，然后再去加载清晰的版本。虽然额外加载了图片文件，但是用户在体验上得到了提升。</p><p>类似的场景还有很多，比如用户上传文件的时候，如果文件过大，那么上传可能就会很耗时。而且一旦上传的过程中发生了网络中断，那上传就前功尽弃了。</p><p>为了提高用户的体验，我们可以选择断点续传，也就是把文件切分成小块后，挨个上传。这样即使中间上传中断，但下次再上传时，只上传缺失的那些部分就可以了。可以看到，断点上传虽然在性能上，会造成网络请求变多的问题，但也极大地提高了用户上传的体验。</p><p>还有很多组件库也会提供骨架图的组件，能够在页面还没有解析完成之前，先渲染一个页面的骨架和loading的状态，这样用户在页面加载的等待期就不至于一直白屏，下图所示就是antd-vue组件库骨架图渲染的结果。</p><p><img src="https://static001.geekbang.org/resource/image/26/dc/26b97a7c7ba894d18ac6311a7fd966dc.gif?wh=872x472" alt="图片"></p><h2>性能监测报告</h2><p>在<a href="https://time.geekbang.org/column/article/442479">第12讲</a>学习Vue Devtools的时候，我们已经使用Chrome的性能监测工具Lighthouse对极客时间的官网做了一次性能的评估，我们可以在这里看到<a href="https://pandafe.gitee.io/clock/time.geekbang.org.html">评测报告</a>。并且，我们也对如何在调试窗口的Performance页面中进行性能监控，给出了演示。为了方便你理解，我们在这里也解释一下FCP、TTI和LCP这几个关键指标的含义。</p><p>首先是First Contentful Paint，通常简写为FCP，它表示的是页面上呈现第一个DOM元素的时间。在此之前，页面都是白屏的状态；然后是Time to interactive，通常简写为TTI，也就是页面可以开始交互的时间；还有和用户体验相关的Largest Contentful Paint，通常简写为LCP，这是页面视口上最大的图片或者文本块渲染的时间，在这个时间，用户能看到渲染基本完成后的首页，这也是用户体验里非常重要的一个指标。</p><p>我们还可以通过代码中的performance对象去动态获取性能指标数据，并且统一发送给后端，实现网页性能的监控。性能监控也是大型项目必备的监控系统之一，可以获取到用户电脑上项目运行的状态。</p><p>下图展示了performance中所有的性能指标，我们可以通过这些指标计算出需要统计的性能结果。</p><p><img src="https://static001.geekbang.org/resource/image/71/f1/71a25ac4634b288911f17beb97b429f1.png?wh=912x555" alt="图片"></p><pre><code class="language-plain">let timing = window.performance &amp;&amp; window.performance.timing\nlet navigation = window.performance &amp;&amp; window.performance.navigation\n\nDNS 解析：\nlet dns = timing.domainLookupEnd - timing.domainLookupStart\n\n总体网络交互耗时：\nlet network = timing.responseEnd - timing.navigationStart\n\n渲染处理：\nlet processing = (timing.domComplete || timing.domLoading) - timing.domLoading\n\n可交互：\nlet active = timing.domInteractive - timing.navigationStart\n</code></pre><p>在上面的代码中，我们通过Performance API获取了DNS解析、网络、渲染和可交互的时间消耗。有了这些指标后，我们可以随时对用户端的性能进行检测，做到提前发现问题，提高项目的稳定性。</p><h2>总结</h2><p>今天的主要内容就聊完啦，我们来复习一下今天学到的内容吧。</p><p>首先我们了解了用户从输入URL到页面显示的这一过程发生了什么，这里面的每个流程都有值得优化的地方，比如网络请求、页面渲染等。在对这些流程优化后，网页运行时整体的性能都会得到提升。</p><p>之后，在网络请求优化这一部分，我们首先谈到，对于DNS，我们可以通过dns-prefetch预先获取，这对性能优化来说，会减少页面中其他域名请求的DNS解析时间；因为TCP协议每次链接时，都需要三次握手，而这会带来额外的网络消耗的问题，为了解决这一问题，我们的优化策略是让文件尽可能少一些，并且也小一些。</p><p>比如，我们可以通过文件打包的形式减少HTTP请求数量，这样对于文件的大小来说，可以减小文件体积。我们也可以压缩代码，以及选择更合适的图片格式，这些都可以让我们加载更小的文件。图片的懒加载和路由的懒加载可以让首页加载更少的文件，从而实现页面整体性能的优化。</p><p>在讲完网络请求优化后，我们又研究了代码效率优化这个问题，其实代码层面要做的优化并不多，主要还是遵守Vue 3最佳实践。我们还以斐波那契数列的计算为例，通过在Performance面板中进行性能监控，明确了代码优化的方向。在通过递归的方式优化斐波那契数列之后，我们能明白这样一点：<strong>性能优化的一个重要原则，是不要<strong><strong>过度</strong></strong>优化</strong>。</p><p>之后，在用户体验优化这一部分，我们的关注点是在交互体验的优化上。有些场景我们可以损失部分性能去换取体验的提升，比如通过骨架图，我们可以在页面加载之前，通过对图片预先加载出模糊版本，可以让用户获得更好的体验。</p><p>最后，在性能监测报告这一部分，我讲到选择合适的工具，可以帮助我们实时地监测项目的性能。我们通过Lighthouse性能报告和Performace监测工具，可以精确地定位到项目瓶颈所在，有针对地去进行性能优化。</p><h2>思考题</h2><p>最后，给你留一个思考题：通过今天的学习，想一想你负责的项目都有哪些可以优化的地方呢？</p><p>欢迎在留言区留言分享你的想法，也欢迎你把这一讲的内容推荐给你的朋友、同事们，我们下一讲见。</p>',
        article_title: "18 | 实战痛点4：Vue 3 项目中的性能优化",
      },
      {
        title: "加餐01｜什么是好的项目？",
        id: 460565,
        content:
          '<p>你好，我是大圣，全家桶实战篇已经快更新完了。今天我特意为你准备了一个加餐，目的是想跟你聊一下什么是好的项目，以及你该如何对项目做优化，从而让它能成为一个足够好的项目。</p><p>很多同学面试的时候都会被问到：你做过什么项目？看起来很简单的一个问题，却难住了无数面试者，<strong>因为面试官想听到的并不是你的项目流水账，而是你项目中的亮点</strong><strong>。</strong>这个过程其实和相亲很像，你心仪的女生问你有什么爱好，你会绞尽脑汁想突出自己的优点和亮点。然而，如果你想很好地回答项目中的亮点这个问题，需要日常工作中做出很多额外的修炼。</p><h2>足够好的项目</h2><p>你不用怀疑的一点是，我们在日常工作中的项目，都是足够好的项目。换句话说，这些项目至少能够完成你现在的老板、产品和用户的需求，能做好系统中的增删改查。</p><p>但是对于“足够好的项目”的标准，其实是相对而言的。为什么这么说呢？因为好项目的标准，根据你所在的工作环境和你的岗位级别不同，都会发生变化。下面，我们就来分情况讨论一下。</p><p>如果你本身就在大厂里，项目有大量的流量、效率的挑战，那只完成项目的基本功能是远远不够的。如果你还能再考虑提升一下项目运行的效率、发布部署的效率等等，那对你来说，这就是一个足够好的项目，并且已经亮点颇多了。<strong>这也是为什么我建议你有机会一定要去大厂待两年的原因</strong>。</p><!-- [[[read_end]]] --><p>如果你本身就在小公司里，那你可能就会稍微悲催一些，因为按要求去完成项目的基本功能，就算是足够好的项目了。但这样，你就会不停地被老板要求做增删改查，时间长了你就会认为这就是项目的全部。</p><p>这其实能引申出大部分前端开发者工作久了的一个困惑，也是之前很多人私聊问我的一个问题：“我都工作七年了，做过二十几个Vue和React的项目，为啥百度面不过呢？”。这就涉及项目中的亮点了，也就是你能否在增删改查之外，做更多的有亮点的工作。下面，我来跟你聊一下到底什么才算是有亮点的项目。</p><h2>项目中的亮点</h2><p>首先，我建议你今天上班的时候，在坐到工位上后，先环顾一下周围的同事，问自己一句：“我到底做了什么他们做不到的功能？”如果你面对这个问题，没啥思路的话，那恭喜你，这篇文章正是你需要的。</p><p>面对这一个问题，你可以从手里负责的项目开始考虑，所以我们可以从项目的结构说起。下面的示意图所展示的，是在开发过程中，我们常见的前端项目的基本结构。在这种结构下，我们对项目上线后的基本功能的要求，都能得到满足。</p><p>在开发的代码中，我们使用组件+数据+路由的方式实现了项目需求，然后项目打包后部署到服务器之上。用户访问到的都是线上的代码，有增删改查的操作就会调用后端的接口实现。对于大部分中小厂来说，项目的开发只是不停地堆积页面，没有太高的复杂度。</p><p><img src="https://static001.geekbang.org/resource/image/c3/e2/c37b3d74b2ff54a9973788dee02773e2.jpeg?wh=1920x1080" alt=""></p><p>对于项目功能的实现来说，这种结构没有问题，但这种结构是没有亮点的。当你开始考虑上图中每一个环节的优化项，当你开始思考左侧的组件如何能在多个项目复用？整体项目的性能如何优化？项目打包上线的过程如何更稳定？如何提前发现项目中的报错等等问题的时候，亮点也就随之诞生了。</p><p>我们能看到，对于一个项目来说，有很多值得优化的点。<strong>但是，这并不意味着你需要一个人去承包所有的待优化项，我们可以根据你在项目开发中的角色来分别做讨论。</strong></p><h2>给项目普通开发者的优化建议</h2><p>如果你现在是团队内的开发者之一，那你能做的，主要还是从开发者的角度去思考现在手里负责的需求如何能够更进一步做优化，首先是需求中的数据量比变大之后如何优化，我在这里给你举两个常见的场景，相信会带给你不少启发。</p><h3>文件上传的场景</h3><p>文件上传这个场景，是我很喜欢举的例子。像日常项目开发中的头像上传、用户简历上传、视频上传等等，都属于这类需求。我们直接使用axios.post就可以实现这个需求了，文件的体积就是这个场景下的数据量，那么文件变得很大之后，该如何处理呢？</p><p>比如，在我们上传一个2GB 大小的视频文件的时候，如果直接使用axios.post上传，那么中途一旦出现网络卡顿，就需要重新上传这个视频文件。这就会对用户的体验造成不好的影响，所以在这种数据量极大的场景下，我们需要采用断点续传的解决方案。</p><p>对照下面断点续传的示意图，你能看到，我们可以把文件切成数据块依次上传，如果上传的过程中，出现了网络错误，那么再次上传的时候，就会把已经存在的切片列表过滤掉，只上传其他的切片。</p><p><img src="https://static001.geekbang.org/resource/image/5f/5f/5f9bd4171e583230def657ffc6c9445f.jpeg?wh=1920x1080" alt=""></p><p>完成上述断点续传的功能之后，我们就完成了项目的初步优化，在文件上传之前，我们需要在前端计算出一个文件的Hash值作为唯一标识，用来向后端询问切片的列表。但是对于一个2GB 大小的文件来说，即使是使用MD5算法来计算Hash值，也会造成浏览器的卡顿。那怎么解决计算Hash值时，浏览器的卡顿的问题呢？</p><p>对于卡顿问题，我们可以通过web-workder去解决，这有点像孙悟空可以用猴毛变出一个分身，我们这里的hash.js，就相当于浏览器主进程的分身，用分身就可以去计算Hash值，不耽误主进程的任务。在下面的代码中，我们使用new Worker加载一个hash.js去计算文件的hash值。</p><pre><code class="language-javascript">&nbsp; &nbsp; async calculateHashWorker(chunks) {\n&nbsp; &nbsp; &nbsp; return new Promise(resolve =&gt; {\n&nbsp; &nbsp; &nbsp; &nbsp; // web-worker 防止卡顿主线程\n&nbsp; &nbsp; &nbsp; &nbsp; this.worker = new Worker("/hash.js")\n&nbsp; &nbsp; &nbsp; &nbsp; this.worker.postMessage({ chunks })\n&nbsp; &nbsp; &nbsp; &nbsp; this.worker.onmessage = e =&gt; {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; const { progress, hash } = e.data\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; this.hashProgress = Number(progress.toFixed(2))\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (hash) {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; resolve(hash)\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }\n&nbsp; &nbsp; &nbsp; &nbsp; };\n&nbsp; &nbsp; &nbsp; });\n&nbsp; &nbsp; },\n</code></pre><p>通过对性能瓶颈的分析，我们能看到，现在这个卡顿主要是由计算量过大导致的。在前端发展史<a href="https://time.geekbang.org/column/article/427660">那一讲</a>中，我们有讲到：在React框架下，当项目庞大之后，如果Diff的计算量过大，那么也会导致卡顿。所以我们可以借鉴React的Fiber解决方案，使用浏览器的空闲时间去计算Hash。</p><p>在下面的代码中，我们使用requestIdleCallback启动空闲时间的计算任务，能很好地解决这个问题。</p><pre><code class="language-javascript">let count = 0\nconst workLoop = async deadline =&gt; {\n&nbsp; // 计算，并且当前帧还没结束\n&nbsp; while (count &lt; chunks.length &amp;&amp; deadline.timeRemaining() &gt; 1) {\n&nbsp; &nbsp; await appendToSpark(chunks[count].file)\n&nbsp; &nbsp; count++\n&nbsp; &nbsp; // 没有了 计算完毕\n&nbsp; &nbsp; if (count &lt; chunks.length) {\n&nbsp; &nbsp; &nbsp; // 计算中\n&nbsp; &nbsp; &nbsp; this.hashProgress = Number(\n&nbsp; &nbsp; &nbsp; &nbsp; ((100 * count) / chunks.length).toFixed(2)\n&nbsp; &nbsp; &nbsp; )\n&nbsp; &nbsp; &nbsp; // console.log(this.hashProgress)\n&nbsp; &nbsp; } else {\n&nbsp; &nbsp; &nbsp; // 计算完毕\n&nbsp; &nbsp; &nbsp; this.hashProgress = 100\n&nbsp; &nbsp; &nbsp; resolve(spark.end())\n&nbsp; &nbsp; }\n&nbsp; }\n&nbsp; window.requestIdleCallback(workLoop)\n}\nwindow.requestIdleCallback(workLoop)\n</code></pre><p>这两段代码只是抛砖引玉，你还可以继续深挖这个需求，比如我们上传切片的时候，所有的文件切片一起使用Promise.all发起几十个HTTP请求，也会导致卡顿，所以我们就需要手动管理上传任务的并发数量。</p><p>由于切片上传速度跟当前网速相关，所以在对上传任务的并发数量进行管理时，我们需要确定切片的大小。那该如何确定切片的大小呢？我们可以借鉴TCP协议的慢启动逻辑，去让切片的大小和当前网速匹配，这样，我们就可以通过网速确定切片的大小。</p><p>当你顺着这个思路解决了大文件上传的需求之后，这就会成为你项目中的亮点。上述文件上传的演示代码，你可以点击<a href="https://github.com/shengxinjing/file-upload">这里的链接</a>，去我的GitHub里直接获取。</p><p>此外，还有一个典型的场景就是列表渲染，相信现在的你使用v-for就可以很快地实现这个需求。但是，你可以设想这样一个场景：列表的数据量不断增多，成千上万个数据的渲染让页面卡顿。按照我们优化需求的思路，需要你做的就是：使用虚拟列表来应对这个场景。</p><h3>列表渲染的场景</h3><p>使用虚拟列表就意味着，我们只需要渲染视图中可见的DOM元素，就可以实现性能优化了。看下面的示意图，我们只渲染窗口中的绿色元素，然后浏览器滚动的过程中我们维护这些DOM，就可以避免因为页面中DOM元素过多，而引起的卡顿问题。</p><p>这样，在列表渲染的需求上，你的项目也就有了亮点。虚拟列表我们会在之后实现组件库的那一讲中重点讲解，这里你了解这个优化思路即可。</p><p><img src="https://static001.geekbang.org/resource/image/13/92/130b5de1d8f4afa7244a813b7c6f7692.jpeg?wh=1920x1080" alt=""></p><h2>给项目骨干开发者的优化建议</h2><p>如果你现在已经是一个小团队的负责人了，那么这个项目对你来说，具体的某个需求优化，可能已经无法成为你这个角色的亮点了。对于你所处的团队负责人这个角色来说，你更需要从项目的整体出发，去思考如何提高项目的研发效率和稳定性。</p><p>首先你会发现，一旦团队项目里多个项目之间的配置或者规范不同步，那么每个项目的配置都需要手动修改，而这很浪费时间。所以，你可以发起了一个团队的脚手架项目，把项目中的代码规范、Vite配置，log等等都集成在脚手架内部，通过这样的方式，可以提高项目的启动效率，这算是一个亮点。</p><p>然后，很多时候，公司多个项目之间会有代码复用和组件复用的需求。这时，你就可以再发起一个基础组件库的项目，做出一个类似Element3的基础组件库，并且发布在公司的npm服务之上，提供给全公司前端使用。为了让大家用这个组件库的时候能放心，你可以给组件库实现完备的文档系统以及超过90%的单测覆盖率，这也能够作为你的亮点。</p><p>前端项目的上线需要和后端服务器打交道，为了提高发布和部署的效率，你可以发起了一个CI/CD的项目，利用GitHub的action机制，可以把整个发布过程自动化，并且还可以一键回滚。这样日常开发的需求变更是非常快的，每一个流程的自动化都能够提高团队整体的研发效率。而且这个CI/CD系统里还需要能够解决需求频繁变更的问题，以及版本迭代的需求，这些优化项的解决，都能够让整个项目更稳定地交付。</p><p>你还可以复盘你现在负责的业务类型，如果你负责营销组，那么面对繁多的营销页面时，你可以搭建一个Low Code系统，让运营同学和产品同学自己通过拖拽的方式配置出营销页面。在这个过程中，你需要解决搭建系统时的一系列问题，比如：如何设计物料系统、如何实现跨端搭建系统等等。</p><p>然后从项目运行性能和稳定性的角度来看，我们可以制定项目的性能指标，开发项目的性能监控系统，来实时监控客户端的性能，当页面有严重的性能问题或者报错的时候，能够及时通知我们。并且除了常见的性能优化策略之外，我们还可以分析用户访问日志，提前预测用户可能访问的页面，从而做路由级别的预加载等等。</p><p>作为项目负责人来说，你要能够在整体上推动项目向前，<strong>提高团队整体的研发效率就是你做的项目最大的亮点</strong>。</p><p>无论是做需求还是做项目整体的优化，你都可以在晋升和面试的时候去描述你在项目中做出的亮点。所以在这一讲加餐的最后，我想跟你再聊一下如何用STRA原则描述你做过的项目这个问题。</p><p>其实面试官问你做过什么项目，目的就是想通过你做的项目，挖掘出你的技术亮点，<strong>所以不要一句“我做过XXX项目”一闪而过，我们可以尝试使用STAR原则去描述项目</strong>。所谓STAR原则，即Situation（情景）、Task（任务）、Action（行动）和Result（结果）四个英文单词的首字母组合，也就是你在什么情景下、遇见了什么任务、做了什么动作，拿到了怎样的结果，结果中最好还能带上数字展示，这样你的项目的描述就会很饱满。</p><p>相信你在自己的简历和晋升PPT里，一定写过和下面例子类似的项目描述，这是现在大部分简历中描述项目的方式。但比较可惜的是，这样的项目描述无法吸引面试官和评委的注意力。</p><blockquote>\n<p>2020-2021 在极客时间负责官网开发和后台管理系统。对此，我们可以用STAR原则来对你的项目描述加以优化，对比之下不难发现，下面的描述明显比上面的描述更能突出你的技术特点和个人能力。<br>\n&nbsp;<br>\n2020-2021 在极客时间带领3个同事开发和维护极客时间官网的前端项目，作为核心开发者，参与了组件库的设计，XX个组件测试覆盖率达到80%，性能优化了XX%。<br>\n&nbsp;<br>\n2021年6月至今，在极客时间负责开发极客时间后台管理系统，作为团队负责人，负责代码开发和5人团队的搭建，项目由XX和XX核心模块构成，通过引入XX，提高了XX%的性能。</p>\n</blockquote><h2>总结</h2><p>今天这一讲的内容就结束了，我们来总结一下今天学习的内容。这次加餐主要想让你了解一下什么是有亮点的项目，简单来说大部分项目都只是能满足当前业务需求，当你开始思考项目的数据量、研发效率的时候，亮点就会在解决这些问题的同时诞生。</p><p>如果你还是普通开发者，那你可以从正在负责的具体需求入手，构造出一个数据量很大的场景，为了解决这个大数据量的场景，你就需要提出一些新的解决方案，比如文件上传的断点续传，列表渲染的虚拟列表等等。</p><p>如果你已经是一个项目的骨干力量，可以推动整个项目，你就可以从项目整体的运行效率和研发效率入手，我们可以推动和研发团队的脚手架、组件库、搭建系统、CI/CD等等项目，去整体提升项目的质量，这也是非常有亮点的项目。在这一讲的最后，我们聊了如何使用STAR原则去描述项目，什么情景、什么任务、什么动作、什么结果，这四个维度帮助我们更立体地展现项目的亮点。</p><h2>思考题</h2><p>最后，再给你留一个思考题吧，你可以说说你现在负责的项目有什么亮点可以做呢？</p><p>欢迎你在留言区进行分享，也期待你在留言区立下一个做出亮点的flag，我们下一讲再见！</p>',
        article_title: "加餐01｜什么是好的项目？",
      },
      {
        title: "19 | 实战痛点5：如何打包发布你的Vue 3应用？",
        id: 461718,
        content:
          '<p>你好，我是大圣。</p><p>在实战痛点4这一讲中，我们一起学习了Vue 3项目的性能优化策略。今天，我们来聊一下项目上线前的最后一步，就是如何把开发好的代码部署到线上。</p><p>对于这个问题，你可能脱口而出：“使用<code>npm run build</code>就好了呀”。这样做只是在本地把代码打包，如果想要在线上也可以访问这些代码，那么还需要加上部署的过程。所以在下面，我先给你介绍一下当前这个时代的前端代码在部署的时候，有哪些难点和问题需要处理。</p><h2>代码部署难点</h2><p>在jQuery时代之前，前端项目中所有的内容都是一些简单的静态资源。那个时候，网站还没有部署的概念，网站上线前，我们直接把开发完的项目打包发给运维，再由运维把代码直接上传到服务器的网站根目录下解压缩，这样就完成了项目的部署。</p><p>后来的jQuery时代，项目的入口页面被后端管理，模板部署到了后端，CSS、JavaScript和图片等静态资源依然是打包到后端之后，再解压处理。但现在，我们对前端的性能和稳定性的要求也越来越高，jQuery时代的那种简单的部署模式就不足以应对性能优化、持续部署等一系列的情境。</p><p>现在前端所处的时代，我们主要会面临后面这些代码部署难点：首先是，如何高效地利用项目中的文件缓存；然后是，如何能够让整个项目的上线部署过程自动化，尽可能避免人力的介入，从而提高上线的稳定性；最后，项目上线之后，如果发现有重大Bug，我们就要考虑如何尽快回滚代码。</p><!-- [[[read_end]]] --><p>当我们面对这些代码部署上的难点，特别是在团队协作的项目中遇到时，我们就可以考虑对项目进行自动化部署了，这样代码部署的速度和稳定性会给项目研发效率带来很好的提升。</p><h2>项目上线前的自动化部署</h2><p>下图所示的，是大部分团队部署项目时的逻辑 。实际上，大部分前端开发者都会认为，完成图示中的打包压缩这一步，也就是开发完项目之后，代码推送到GitHub后，就算完成任务了。但是，打包代码之后，把代码上传服务器也是这一步，对于前端开发者来说，是很少能接触到，但却是很重要的一步。</p><p><img src="https://static001.geekbang.org/resource/image/45/a9/4565abf4f599cc187d65d421d3cb8ba9.jpg?wh=1800x758" alt="图片"></p><p>所以，对于如何把打包好的代码上传到服务器这个问题，就值得我们去好好探究，琢磨出一个好的解决方案。</p><p>首先，我们需要一台独立的机器去进行打包和构建的操作，这台机器需要独立于所有开发环境，这样做是为了保证打包环境的稳定；之后，在部署任务启动的时候，我们需要拉取远程的代码，并且切换到需要部署的分支，然后锁定Node版本进行依赖安装、单元测试、ESLint等代码检查工作；最后，在这台机器上，执行经过编译产出的打包后的代码，并打包上传代码到CDN和静态服务器。当然了，完成这些操作之后，还要能通过脚本自动通过内部沟通软件通知团队项目构建的结果。</p><p>但是在项目部署的过程中，迎面而来的可能是下面这些问题：在什么操作系统环境中执行项目的构建？由谁触发构建？如何管理前面所述的把代码上传CDN时，CDN账户的权限？如何自动化执行部署的全过程，如果每次都由人工执行，就得消耗一个人力守着编译打包了，而且较为容易引发问题，比如测试的步骤遗漏或部署顺序出错。那么如何提升构建速率，就成了部署功能中需要解决的重要问题。</p><p>为了解决上面这些问题，业界提出了一些解决方案：比如，采用能保证环境一致性的Docker；自动化构建触发可以通过GitHub Actions；GitHub的actions功能相当于给我们提供了一个免费的服务器，可以很方便地监控代码的推送、安装依赖、代码编译自动上传到服务器。</p><p><img src="https://static001.geekbang.org/resource/image/a7/dc/a7b8b0005f6003e91d17eb18149b9ddc.jpg?wh=2251x1206" alt=""></p><p>上图所展示的，就是我们使用了GitHub Actions部署项目之后的项目开发流程。现在静态资源管理已经完成，也实现了自动化部署。提交代码之后，我们的项目就可以自动推送到服务器，这样，网站的第一次上线也就算成功了。</p><h2>项目上线后的自动化部署</h2><p>前端项目的自动化部署完成后，我们可以保证上线的稳定性，但是后续的持续上线怎么办？直接发到生产环境，会面临极大的风险。但如果不直接发布到生产环境，我们就不能在本地和测试的前端环境去连接生产环境的数据库。</p><p>所以我们需要一个<strong>预发布的（Pre）环境</strong>，这个环境只能让测试和开发人员访问，除了访问地址的环节不同，其他所有环节都和生产环境保持一致，从而提供最真实的回归测试环境。</p><p>这个时候，我们会遇见下面这些问题，首先，如果我们确定项目下个版本在下周一零点发布，那我们就只能晚上12点准时守在电脑前，等待结果吗？如果npm安装依赖失败，或者上线后发现了重大Bug，那就只能迎接用户的吐槽吗？</p><p>其次，<strong>随着node_modules的体积越来越大，构建时间会越来越长</strong>。如果每次构建都需要30分钟甚至更长时间的话，那么，即使Bug是在项目刚上线时就发现的，并且你也秒级响应，并修复了Bug，但在重新部署项目时，我们也需要等服务器慢慢编译。这个时候，时间就是金钱，如果你在修复Bug和重新部署项目上，耗费了过多的时间，那么就会导致项目故障时间过长的问题。</p><p>为了解决上面说到的这些问题，我们需要一种机制，能够让我们在发现问题之后，尽快地将版本进行回滚，并且在回滚的操作过程中，尽可能不需要人力的介入。所以，我们需要静态资源的版本管理，具体来说，就是让每个历史版本的资源都能保留下来，并且有一个唯一的版本号，如果发生了故障，能够瞬间切换版本。这个过程由具体的代码实现之后，我们只需要点击回滚的版本号，系统就会自动恢复到上线前的版本。</p><p>在这种机制下，如果你的业务流量特别大，每秒都有大量用户访问和使用，那么直接全量上线的操作就会被禁止。为了减少上线时，部署操作对用户造成的影响，我们需要先选择一部分用户去做灰度测试，也就是说，上线后的项目的访问权限，暂时只对这些用户开放。或者，你也可以做一些AB测试，比如给北京的同学推送Vue课，给上海的同学推荐React课等等。我们需要做的，就是把不同版本的代码分开打包，互不干涉。之后，我们再设计部署的机器和机房去适配不同的用户。</p><p>在Gtihub中，我们可以使用actions去配置打包的功能，下面的代码是actions的配置文件。在这个配置文件中，我们使用Ubuntu作为服务器的打包环境，然后拉取GitHub中最新的master分支代码，并且把Node版本固定为14.7.6，执行npm install安装代码所需依赖后，再执行npm run build进行代码打包压缩。在下面的代码中，我们就通过GitHub Actions自动化打包了一份准备上线的代码。</p><pre><code class="language-json">name: 打包应用的actions\non:\n&nbsp; push: # 监听代码时间\n&nbsp; &nbsp; branches:\n&nbsp; &nbsp; &nbsp; - master  # master分支代码推送的时候激活当前action\njobs:\n&nbsp; build:\n&nbsp; &nbsp; # runs-on 操作系统\n&nbsp; &nbsp; runs-on: ubuntu-latest\n&nbsp; &nbsp; steps:\n&nbsp; &nbsp; &nbsp; - name: 迁出代码\n&nbsp; &nbsp; &nbsp; &nbsp; uses: actions/checkout@master\n&nbsp; &nbsp; &nbsp; # 安装Node\n&nbsp; &nbsp; &nbsp; - name: 安装Node\n&nbsp; &nbsp; &nbsp; &nbsp; uses: actions/setup-node@v1\n&nbsp; &nbsp; &nbsp; &nbsp; with:\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; node-version: 14.7.6\n&nbsp; &nbsp; &nbsp; # 安装依赖\n&nbsp; &nbsp; &nbsp; - name: 安装依赖\n&nbsp; &nbsp; &nbsp; &nbsp; run: npm install\n&nbsp; &nbsp; &nbsp; # 打包\n&nbsp; &nbsp; &nbsp; - name: 打包\n&nbsp; &nbsp; &nbsp; &nbsp; run: npm run build\n\n</code></pre><p>然后，我们需要配置上线服务器和GitHub Actions服务器的信任关系，通过SSH密钥可以实现免登录直接部署。我们直接把build之后的代码打包压缩，通过SSH直接上传到服务器上，并且要进行代码文件版本的管理，就完成了代码的部署。</p><p>最后一步，就是部署成功后的结果通知了。现在办公软件钉钉和飞书都提供了相关的推送结果，我们可以随时通过群机器人接口把消息推送到群内，关于钉钉机器人的适用文档，你直接看官方的<a href="https://developers.dingtalk.com/document/robots/custom-robot-access?spm=ding_open_doc.document.0.0.7f875e59yR79vi#topic-2026027">开发文档</a>就可以了，我们需要做的是把版本号、部署日期、发起人等信息推送到对应接口，这样就完成了自动化部署的操作。</p><p>这一过程涉及服务器、钉钉开发文档、GitHub Actions，浏览器和本地代码环境多个场景的转换，这一讲我们先重点学习整体部署需要的思路和注意事项，实际的部署操作过程，你可以看这个视频的实操演示：</p><p><video poster="https://media001.geekbang.org/ed3b398d459c408fa94b201ea77df981/snapshots/dd5b06a466184dafbfd430c89ab80626-00005.jpg" preload="none" controls=""><source src="https://media001.geekbang.org/customerTrans/7e27d07d27d407ebcc195a0e78395f55/439b1827-17f2a7b67d9-0000-0000-01d-dbacd.mp4" type="video/mp4"><source src=" https://media001.geekbang.org/153349e6f74646e8a48a6d4c68ca71bb/db3f145c657346ad84ef883fe3ed191c-030f581fc35ef3d283ec34bfd950d657-sd.m3u8" type="application/x-mpegURL"></video></p><h2>总结</h2><p>今天的主要内容就讲完了，我们来总结一下今天学到的内容吧。首先，我们讲解了前端部署这一过程的难点，包括怎么处理缓存、怎么自动化部署等等。在部署上，我们需要尽可能减少人力的参与，做到整个过程都用代码可控。</p><p>之后，在前端自动化部署这一部分，我们着重讲到了代码的打包上传和项目的部署，其中需要你重点注意的是项目的部署。为了解决如何部署代码到线上这一问题，我们需要一个独立的部署系统，有了独立的部署系统之后，我们可以把整个部署上线的过程自动化。借助GitHub的Actions，我们可以很方便地使用actions自带的服务去进行发布环节的版本确认、依赖安装、代码打包和上传的工作。</p><h2>思考题</h2><p>最后留一个思考题吧，你现在负责的项目中，发布和部署这个流程里有哪些环节可以优化呢？欢迎在评论区留言讨论，我们下一讲再见！</p>',
        article_title: "19 | 实战痛点5：如何打包发布你的Vue 3应用？",
      },
      {
        title: "加餐02｜深入TypeScript",
        id: 462533,
        content:
          "<p>你好，我是大圣。</p><p>在讲组件化的进阶开发篇之前，我想在全家桶实战篇的最后，用一讲的篇幅，来专门聊一下TypeScript。希望你在学完这一讲之后，能对TypeScript有一个全面的认识。</p><p>另外，今天我会设置很多实战练习，一边阅读一边敲代码的话，学习效果更好。而且，这次加餐中的全部代码都是可以在线完成的，建议你打开<a href=\"https://www.typescriptlang.org/play?#code/FAehAJC+9Q66MA3lHnrQMhGGO5QgB6F+E9gnU0AByhZBKA\">这个链接</a>，把下面的每行代码都跟着敲一遍。</p><h2>TypeScript入门</h2><p>对于TypeScript，你首先要了解的是，TypeScript 可以在JavaScript的基础上，对变量的数据类型加以限制。TypeScript 中最基本的数据类型包括布尔、数字、字符串、null、undefined，这些都很好理解。</p><p>在下面的代码中，我们分别定义了这几个数据类型的变量，你能看到，当我们把number类型的变量price赋值字符串时，就会报错，当我们把数组 me 的第一个元素 me[0] 的值修改为数字时，也会报错。</p><pre><code class=\"language-typescript\">let courseName:string = '玩转Vue 3全家桶'\nlet price:number = 129\nprice = '89' //类型报错\nlet isOnline:boolean = true\nlet courseSales:undefined\nlet timer:null = null\nlet me:[string,number] = [\"大圣\",18]\nme[0] = 1 //类型报错\n</code></pre><!-- [[[read_end]]] --><p>当你不确定某个变量是什么类型时，你可以使用any作为这个变量的类型。你可以用any标记任何属性，可以修改任何数据，访问任何方法也不会报错。也就是说，在TypeScript中，当你把变量的类型标记为any后，这个变量的使用就和JavaScript没啥区别了，错误只会在浏览器里运行的时候才会提示。</p><pre><code class=\"language-typescript\">let anyThing\nlet anyCourse :any = 1\nanyCourse = 'xx'\nconsole.log(anyCourse.a.b.c)\n</code></pre><p>然后我们可以使用enum去定义枚举类型，这样可以把类型限制在指定的场景之内。下面的代码中我们可以把课程评分限制在好、非常好和嘎嘎好三个值之内。</p><pre><code class=\"language-typescript\">enum 课程评分 {好,非常好,嘎嘎好}\nconsole.log(课程评分['好']===0)\nconsole.log(课程评分[0]==='好')\nlet scores = [课程评分['好'], 课程评分['嘎嘎好'], 课程评分['非常好']]\n\n</code></pre><p>然后我们可以通过学到的这些基础类型，通过组合的方式组合出新的类型，最常见的组合方式就是使用 | 实现类型联合。下面的代码中我们定义course1变量的类型为字符串或者数字，赋值为这两个类型都不会报错，还可以用来限制变量只能赋值为几个字符串的一个，score的取值只能是代码中三个值之一。</p><pre><code class=\"language-typescript\">let course1 : string|number = '玩转vue 3'\ncourse1 = 1\ncourse1 = true // 报错\n\ntype courseScore = '好' | '非常好' | '嘎嘎好'\nlet score1 :courseScore = '好'\nlet score2 :courseScore = '一般好' // 报错\n</code></pre><p>通过interface接口可以定义对象的类型限制。下面代码中我们定义了极客时间课程的类型，课程名是字符串，价格使用number[] 语法定义类型为数字组成的数组，讲师头像是string或者boolean，并且通过 ?设置为可选属性，课程地址使用readonly设置为只读属性，如果对课程地址进行修改就会报错。</p><pre><code class=\"language-typescript\">interface 极客时间课程 {\n    课程名字:string,\n    价格:number[],\n    受众:string,\n    讲师头像?:string|boolean,\n    readonly 课程地址:string\n}\nlet vueCourse: 极客时间课程 = {\n    课程名字:'玩转Vue 3全家桶',\n    价格:[59,'139'],\n    讲师头像:false,\n    课程地址:\"time.geekbang.org\"\n}\nvueCourse.课程地址 = 'e3.shengxinjing.cn' // 报错\n</code></pre><p>然后我们学一下函数的类型限制。其实函数的定义，参数和返回值本质上也是变量的概念，都可以进行类型的定义。下面的代码中我们定义了参数x和y是数字，返回值也是数字的add函数，定义好参数和返回值类型，函数的类型自然也就确定了。</p><pre><code class=\"language-typescript\">function 函数名(参数:参数类型):返回值类型{} //大致语法\nfunction add(x: number, y: number): number {\n    return x + y;\n}\nadd(1, 2);\n \n</code></pre><p>我们也可以使用变量的方式去定义函数，直接使用(参数类型) =&gt;返回值类型的语法去定义add1的变量类型，但是这样写出来的代码可读性稍差一些，我更建议你使用type或者interface关键字去定义函数的类型。下面代码中的addType和addType1都是很好的定义函数类型的方式：</p><pre><code>let add1:(a:number,b:number)=&gt;number = function(x: number, y: number): number {\n    return x + y;\n}\ntype addType = (a:number,b:number)=&gt;number\nlet add2:addType  = function(x: number, y: number): number {\n    return x + y;\n}\n\ninterface addType1{\n    (a:number,b:number):number\n}\nlet add3:addType1  = function(x: number, y: number): number {\n    return x + y;\n}\n</code></pre><p>如果你的函数本来就支持多个类型的参数，下面的代码中reverse函数既支持数字也支持字符串。<strong>我们的要求是如果参数是数字，返回值也要是数字，参数是字符串返回值也只能是字符串</strong>，所以参数和返回值都用number|string就没法精确地限制这个需求。我们需要使用函数重载的方式，定义多个函数的输入值和返回值类型，更精确地限制函数的类型。我们可以在<a href=\"https://github.com/vuejs/vue-next/blob/master/packages/reactivity/src/ref.ts#L72\">Vue 3的源码</a>看到Vue 3中ref函数的重载写法：</p><pre><code class=\"language-typescript\">function reverse(x: number): number\nfunction reverse(x: string): string\nfunction reverse(x: number | string): number | string | void {\n    if (typeof x === 'number') {\n        return Number(x.toString().split('').reverse().join(''));\n    } else if (typeof x === 'string') {\n        return x.split('').reverse().join('');\n    }\n}\n</code></pre><p>这样TypeScript里如何限制一个变量和函数类型，我们就大致入门了。这时候你肯定还有个疑问，<strong>日常开发中有很多浏览器上的变量和属性，这些怎么限制类型呢？</strong></p><p>关于宿主环境里的类型，TypeScript全部都给我们提供了，我们可以直接在代码中书写：Window是window的类型，HTMLElement是dom元素类型，NodeList是节点列表类型，MouseEvent是鼠标点击事件的类型……关于更多TypeScript的内置类型，你可以在<a href=\"https://github.com/Microsoft/TypeScript/tree/main/src/lib\">TypeScript的源码</a>中看到：</p><pre><code class=\"language-typescript\">let w:Window = window\nlet ele:HTMLElement = document.createElement('div')\nlet allDiv: NodeList = document.querySelectorAll('div')\n\nele.addEventListener('click',function(e:MouseEvent){\n    const args:IArguments = arguments\n    w.alert(1)\n    console.log(args)\n},false)\n\n</code></pre><p>除了浏览器的API，我们还会用到很多第三方框架，比如Vue、Element3等等，这些框架现在都提供了完美的类型可以直接使用。在<a href=\"https://time.geekbang.org/column/article/445880\">第18讲</a>中我们使用下面的代码Vue导出的Ref来限定数据是ref包裹的响应式数据：</p><pre><code class=\"language-typescript\"> import { ref ,Ref} from 'vue'\n interface Todo{ \n     title:string,\n      done:boolean\n }\n let todos:Ref = ref([{title:'学习Vue',done:false}])\n \n\n</code></pre><h2>泛型</h2><p>那么聊完上面的内容，你就已经能使用TypeScript实现很多项目的开发，把所有变量和函数出现的地方都定义好类型，就可以在编译阶段提前规避出很多报错。然而TypeScript的能力可不止于此，<strong>TypeScript可以进行类型编程，这会极大提高TypeScript在复杂场景下的应用场景。</strong></p><p>然后我们来看一下TypeScript中的泛型，这也是很多同学觉得TypeScript很难的最大原因。</p><p>首先我们看下面的代码，我们定一个idientity0函数，这个函数逻辑非常简单，就是直接返回参数，那么<strong>我们怎么确定返回值的类型呢？ </strong></p><p>因为输入值可以是任意属性，所以我们只能写出identity0这个函数，参数和返回值类型都是any，但是明显不能满足我们的需求。我们需要返回值的类型和参数一致，所以我们在函数名之后使用&lt;&gt;定一个泛型T，你可以理解这个T的意思就是给函数参数定义了一个类型变量，会在后面使用，相当于【<strong>type T = arg的类型</strong>】，返回值使用T这个类型就完成了这个需求。</p><pre><code class=\"language-typescript\">function identity0(arg: any): any {\n    return arg\n}\n// 相当于type T = arg的类型\nfunction identity&lt;T&gt;(arg: T): T {\n    return arg\n}\nidentity&lt;string&gt;('玩转vue 3全家桶') // 这个T就是string，所以返回值必须得是string\nidentity&lt;number&gt;(1)\n</code></pre><p>有了泛型之后，我们就有了把函数参数定义成类型的功能，我们就可以实现类似高阶函数的类型函数。下面的代码中我们使用keyof语法获得已知类型VueCourse5的属性列表，相当于 ‘name’|‘price’：</p><pre><code class=\"language-typescript\">interface VueCourse5 {\n    name:string,\n    price:number\n}\ntype CourseProps = keyof VueCourse5 // 只能是name和price选一个\nlet k:CourseProps = 'name'\nlet k1:CourseProps = 'p' // 改成price\n</code></pre><p>keyof可以帮助我们拆解已有类型，下一步我们需要使用extends来实现类型系统中的条件判断。我们定义类型函数ExtendsType，接受泛型参数T后，通过判断T是不是布尔值来返回不同的类型字符串，我们就可以通过ExtendsType传入不同的参数去返回不同的类型。</p><pre><code class=\"language-typescript\">// T extends U ? X : Y 类型三元表达式\n\ntype ExtendsType&lt;T&gt; = T extends boolean ? \"重学前端\" : \"玩转Vue 3\"\ntype ExtendsType1 = ExtendsType&lt;boolean&gt; // type ExtendsType1='重学前端'\ntype ExtendsType2 = ExtendsType&lt;string&gt; // type ExtendsType2='玩转Vue 3'\n</code></pre><p>extends相当于TypeScript世界中的条件语句，然后in关键字可以理解为TypeScript世界中的遍历。下面的代码中我们通过 k in Courses语法，相当于遍历了Courses所有的类型作为CourseObj的属性，值的类型是number。</p><pre><code class=\"language-typescript\">type Courses = '玩转Vue 3'|'重学前端'\ntype CourseObj = {\n    [k in Courses]:number // 遍历Courses类型作为key\n}\n// 上面的代码等于下面的定义\n// type CourseObj = {\n//     玩转Vue 3: number;\n//     重学前端: number;\n// }\n\n</code></pre><p>学完上面的语法，你就能完全搞懂<a href=\"https://time.geekbang.org/column/article/455487\">第18讲</a>里的getProperty函数。限制函数第二个参数只能是第一个参数的属性，并且返回值的类型，最后我们传递不存在的属性时，TypeScript就会报错。</p><pre><code class=\"language-typescript\">// K extends keyof T限制K的类型必须是T的属性之一\n// T[K]是值得类型\nfunction getProperty&lt;T, K extends keyof T&gt;(o: T, name: K): T[K] {\n    return o[name]\n}\nconst coursePrice:CourseObj = {\n    \"玩转Vue 3\":129,\n    \"重学前端\":129\n}\ngetProperty(coursePrice,'玩转Vue 3')\ngetProperty(coursePrice,'不学前端') // 报错\n</code></pre><p>然后我再给你讲解最后一个关键字infer。&lt;T&gt;让我们拥有了给函数的参数定义类型变量的能力，infer则是可以在extends之后的变量设置类型变量，更加细致地控制类型。下面的代码中我们定义了ReturnType类型函数，目的是返回传入函数的返回值类型。infer P的意思就是泛型T是函数类型，并且这个函数类型的返回类型是P。</p><pre><code class=\"language-typescript\">type Foo = () =&gt; CourseObj\n\n// 如果T是一个函数，并且函数返回类型是P就返回P\ntype ReturnType1&lt;T&gt; = T extends ()=&gt;infer P ?P:never \ntype Foo1 = ReturnType1&lt;Foo&gt;\n</code></pre><h2>实战练习</h2><p>有了上面的基础后，我们来几个实战的练习。以下所有的练习都可以在代码最后找到答案，我建议你一定要自己实现一遍才能有最多的收获。</p><p>代码地址：<a href=\"https://www.typescriptlang.org/docs/handbook/utility-types.html\">https://www.typescriptlang.org/docs/handbook/utility-types.html</a></p><p>下面的代码中，我们首先定义类型Todo，有title、desc和done三个属性：</p><pre><code class=\"language-typescript\">interface Todo {\n  title: string\n  desc:string\n  done: boolean\n}\n\n</code></pre><p>首先第一题是，我们需要实现类型函数Partial1，返回的类型是Todo所有的属性都变成可选项。</p><pre><code class=\"language-typescript\">type partTodo = Partial1&lt;Todo&gt;\n// 和下面类型一致，鼠标移动到partTodo变量上也能看到\n// type partTodo = {\n//     title?: string | undefined;\n//     desc?: string | undefined;\n//     done?: boolean | undefined;\n// }\n</code></pre><p>这一题的答案见下面的代码，使用K in keyof T遍历所有T的属性后，使用 ?标记为可选属性。</p><pre><code class=\"language-typescript\">type Partial1&lt;T&gt; = {\n    [K in keyof T]?:T[K]\n}\n</code></pre><p>TypeScript中还有很多类似的函数，包括Pick、Omit、Diff等函数，你都可以自行实现一遍，更多工具类型函数你可以移步<a href=\"https://www.typescriptlang.org/docs/handbook/utility-types.html\">TypeScript官方文档</a>。你也可以结合下面的代码工具函数的实现，到留言区中讨论一下分别实现了什么功能。</p><pre><code class=\"language-typescript\">type Exclude1&lt;T, K&gt; = T extends K ? never : T\ntype Pick1&lt;T, K extends keyof T&gt; = {\n    [P in K]: T[P]\n}\ntype Concat1&lt;T extends any[], U extends any[]&gt; = [...T, ...U]\n</code></pre><p>最后我们再来一个实战的练习，在实际项目开发中除了JavaScript、浏览器和第三方框架的类型，还有一个很重要的场景就是后端返回的数据类型。我们需要根据开发文档去定义好每个请求的类型，在下面的代码中，request作为发送请求的函数，可以传递url是字符串。<strong>那我们该如何定义Interface API，使其能够限制request只能有buy和comment两个请求地址，并且comment请求的参数中message是必传项呢？</strong></p><pre><code class=\"language-typescript\">import axios from 'axios'\n\nfunction request(url:string,obj:any){\n    return axios.post(url,obj)\n}\ninterface Api{\n\n}\nrequest('/course/buy',{id:1})\nrequest('/course/comment',{id:1,message:'嘎嘎好看'})\nrequest('/course/comment',{id:1}) //如果message必传 怎么类型提醒缺少参数\nrequest('/course/404',{id:1}) //接口不存在 类型怎么需要报错\n\n</code></pre><p>记得要先尝试自己实现一下，答案就在下面的代码中。在API类型中，我们定义了buy和comment两个属性，分别设置了当前请求所需要的参数都是必选项。然后我们通过在request中使用泛型T限制url，通过Api[T] 限制传递的参数，这样我们就得到了下面的报错示意图，在编译阶段就能通知你缺少message属性，并且404请求不存在，这可以极大提高我们开发的体验和效率。</p><pre><code class=\"language-typescript\">import axios from 'axios'\ninterface Api{\n    '/course/buy':{\n        id:number\n    },\n    '/course/comment':{\n        id:number,\n        message:string\n    }\n}\n\nfunction request&lt;T extends keyof Api&gt;(url:T,obj:Api[T]){\n    return axios.post(url,obj)\n}\n\nrequest('/course/buy',{id:1})\nrequest('/course/comment',{id:1,message:'嘎嘎好看'})\nrequest('/course/comment',{id:1}) //如果message必传 怎么类型提醒缺少参数\nrequest('/course/404',{id:1}) //接口不存在 类型怎么需要报错\n\n</code></pre><p><img src=\"https://static001.geekbang.org/resource/image/0c/8e/0c52cee36238831a10e4004d6536f18e.png?wh=1420x612\" alt=\"图片\"></p><p>更多类型的练习，你可以访问<a href=\"https://github.com/type-challenges/type-challenges\">type-challenges</a> 这个项目自行尝试。现在你再去看项目或者框架源码中的TypeScript，是不是就没有那么晦涩了呢。</p><h2>总结</h2><p>今天想聊的TypeScript就结束啦，总结一下我们今天学到的内容吧。</p><p>首先我们学习了TypeScript的基本类型，包括数字字符串等等，然后我们可以通过这些基础类型组合出复杂的类型组合，并且可以通过type和interface关键字定义复杂对象的类型和函数的类型。</p><p>然后浏览器的相关变量和API类型TypeScript都已经内置了，包括HTMLElement、MouseEvent等等，第三方框架的类型我们可以直接导入使用，Vue中的Ref类型我们就会经常用来定义ref函数包裹的响应式数据。</p><p>接着我们学习了TypeScript进阶中最重要的概念：泛型。通过泛型我们可以在函数内部把类型变成变量使用，并且通过keyof、in、extends、infer等关键字组合出复杂的类型函数，可以更加精确地组合现有类型。</p><p>最后我们通过定义前后端的接口类型的案例，演示了在实战中我们如何通过类型系统提高联调和开发的体验。</p><p>有了这些TypeScript的知识储备，你才能更好地在Vue项目中使用TypeScript。由于JSX的本质就是JavaScript，所以TypeScript的诞生也给了JSX更好的类型推导，这是JSX相比于Template的另外一个优势。关于Vue和TypeScript开发组件的内容，我们下一讲开始全部使用TypeScript来实现。</p><h2>思考题</h2><p>最后，留一个思考题：我们实现的Partial1可以把类型的属性变成可选的，如果传递的类型是嵌套很多层的，如何实现Partial1的递归版本，才能把所有嵌套的属性都变成可选的呢？</p><p>欢迎你在评论区分享你的答案，也欢迎你把这一讲的内容分享给你的同事和朋友们，我们下一讲再见。</p>",
        article_title: "加餐02｜深入TypeScript",
      },
    ],
  },
  {
    chapterTitle: "Vue 3 进阶开发篇",
    children: [
      {
        title: "20｜组件库：如何设计你自己的通用组件库？",
        id: 464098,
        content:
          '<p>你好，我是大圣。上一讲TypeScript加餐学完，你是不是想赶紧巩固一下TypeScript在Vue中的使用呢？那么从今天开始，我们就重点攻克Vue中组件库的实现难点，我会用7讲的篇幅带你进入组件库的世界。</p><p>学习路径大致是这样的，首先我会给你拆解一下Element3组件库的代码，其次带你剖析组件库中一些经典的组件，比如表单、表格、弹窗等组件的实现细节，整体使用Vite+TypeScript+Sass的技术栈来实现。而业务中繁多的页面也是由一个个组件拼接而成的，所以我们可以先学习一下不同类型的组件是如何去设计的，借此举一反三。</p><h2>环境搭建</h2><p>下面我们直奔主题，开始搭建环境。这个章节的代码我已经推送到了<a href="https://github.com/shengxinjing/ailemente">Github</a> 上，由于组件库是模仿Element实现的，所以我为其取名为ailemente。</p><p>接下来我们就一步步实现这个组件库吧。首先和开发项目一样，我们要在命令行里使用下面的命令创建Vite项目，模板选择vue-ts，这样我们就拥有了一个Vite+TypeScript的开发环境。</p><pre><code class="language-bash">npm init vite@latest\n</code></pre><p><img src="https://static001.geekbang.org/resource/image/3a/9f/3a7862fc756674a61c2ed85965208b9f.png?wh=1106x444" alt="图片"></p><p>关于ESLint和Sass的相关配置，全家桶实战篇我们已经详细配置了，这里只补充一下husky的内容。husky这个库可以很方便地帮助我们设置Git的钩子函数，可以允许我们在代码提交之前进行代码质量的监测。</p><!-- [[[read_end]]] --><p>下面的代码中，我们首先安装和初始化了husky，然后我们使用 npx husky add\b命令新增了commit-msg钩子，husky会在我们执行git commit提交代码的时候执行 node scripts/verifyCommit命令来校验commit信息格式。</p><pre><code class="language-bash">npm install -D husky # 安装husky\nnpx husky install    # 初始化husky\n# 新增commit msg钩子\nnpx husky add .husky/commit-msg "node scripts/verifyCommit.js" \n</code></pre><p>然后我们来到项目目录下的verifyCommit文件。在下面的代码中，我们先去 .git/COMMIT_EDITMSG文件中读取了commit提交的信息，然后使用了正则去校验提交信息的格式。如果commit的信息不符合要求，会直接报错并且终止代码的提交。</p><pre><code class="language-typescript">\n\nconst msg = require(\'fs\')\n  .readFileSync(\'.git/COMMIT_EDITMSG\', \'utf-8\')\n  .trim()\n  \nconst commitRE = /^(revert: )?(feat|fix|docs|dx|style|refactor|perf|test|workflow|build|ci|chore|types|wip|release)(\\(.+\\))?: .{1,50}/\nconst mergeRe = /^(Merge pull request|Merge branch)/\nif (!commitRE.test(msg)) {\n  if(!mergeRe.test(msg)){\n    console.log(\'git commit信息校验不通过\')\n\n    console.error(`git commit的信息格式不对, 需要使用 title(scope): desc的格式\n      比如 fix: xxbug\n      feat(test): add new \n      具体校验逻辑看 scripts/verifyCommit.js\n    `)\n    process.exit(1)\n  }\n\n}else{\n  console.log(\'git commit信息校验通过\')\n}\n\n</code></pre><p>这样就确保在GitHub中的提交日志都符合\btype(scope): message 的格式。你可以看下Vue 3的<a href="https://github.com/vuejs/vue-next/commits/master">代码提交记录</a>，每个提交涉及的模块，类型和信息都清晰可见，能够很好地帮助我们管理版本日志，校验正则的逻辑。如下图，feat代表新功能，docs代表文档，perf代表性能。下面的提交日志就能告诉我们这次提交的是组件相关的新功能，代码中新增了Button.vue。</p><pre><code class="language-typescript">feat(component): \badd Button.vue\n</code></pre><h2><img src="https://static001.geekbang.org/resource/image/04/f4/04f18eaf3be849e31cd3629a91d4e3f4.png?wh=1920x1020" alt="图片"></h2><p>commit-msg是代码执行提交的时候执行的，我们还可以使用代码执行之前的钩子pre-commit去执行ESLint代码格式。这样我们在执行git commit的同时，就会首先进行ESLint校验，然后执行commit的log信息格式检查，全部通过后代码才能提交至Git，这也是现在业界通用的解决方案，学完你就快去优化一下手里的项目吧！</p><pre><code class="language-typescript">npx husky add .husky/pre-commit "npm run lint"\n</code></pre><h2>布局组件</h2><p>好，现在环境我们就搭建好了，接着看看怎么布局组件。</p><p>我们可以参考<a href="https://e3.shengxinjing.cn/#/component/installation">Element3组件列表页面</a>，这里的组件分成了基础组件、表单组件、数据组件、通知组件、导航组件和其他组件几个类型，这些类型基本覆盖了组件库的适用场景，项目中的业务组件也是由这些类型组件拼接而来的。</p><p>我们还可以参考项目模块的规范搭建组件库的模板，包括Sass、ESLint等，组件库会在这些规范之上加入单元测试来进一步确保代码的可维护性。</p><p><strong>接下来我们逐一讲解下各个组件的负责范围。</strong></p><p>首先我们需要设计基础的组件，也就是整个项目中都会用到的组件规范，包括布局、色彩，字体、图标等等。这些组件基本没有JavaScript的参与，实现起来也很简单，负责的就是项目整体的布局和色彩设计。</p><p>而表单组件则负责用户的输入数据管理，包括我们常见的输入框、滑块、评分等等，总结来说，<strong>需要用户输入的地方就是表单组件的应用场景</strong>，其中对用户的输入校验是比较重要的功能点。</p><p>数据组件负责显示后台的数据，最重要的就是表格和树形组件。</p><p>通知组件负责通知用户操作的状态，包括警告和弹窗，如何用函数动态渲染组件是警告组件的重要功能点。</p><p>接下来我们就动手设计一个基础的布局组件，这个组件相对是比较简单的。你可以访问<a href="https://e3.shengxinjing.cn/#/component/container">Element3布局容器页面</a>，这里一共有container、header、footer、aside、main五个组件，这个组合可以很方便地实现常见的页面布局。</p><ul>\n<li>el-container组件负责外层容器，当子元素中包含&nbsp;&lt;el-header&gt;&nbsp;或&nbsp;&lt;el-footer&gt;&nbsp;时，全部子元素会垂直上下排列，否则会水平左右排列。</li>\n<li>el-header、el-aside、el-main、el-footer 组件分别负责顶部和侧边栏，页面主体和底部容器组件。这个功能比较简单，只是渲染页面的布局。我们可以在src/components目录下新建文件夹container，新建Container.vue，布局组件没有交互逻辑，只需要通过flex布局就可以实现。</li>\n</ul><p>这几个组件只是提供了不同的class，这里就涉及到CSS的设计内容。在Element3中所有的样式前缀都是el开头，每次都重复书写维护太困难，所以我们设计之初就需要涉及Sass的Mixin来提高书写CSS的代码效率。</p><p>接着，我们在src/styles下面新建mixin.scss。在下面的代码中，我们定义了namespace变量为el，使用Mixin注册一个可以重复使用的模块b，\b可以通过传进来的block生成新的变量$B，并且变量会渲染在class上，并且注册了when可以新增class选择器，实现多个class的样式。</p><pre><code class="language-scss">// bem\n\n$namespace: \'el\';\n@mixin b($block) {\n  $B: $namespace + \'-\' + $block !global;\n  .#{$B} {\n    @content;\n  }\n}\n\n// 添加ben后缀啥的\n@mixin when($state) {\n  @at-root {\n    &amp;.#{$state-prefix + $state} {\n      @content;\n    }\n  }\n}\n</code></pre><p>代码看着有些抽象，不要急，我们再在 container.vue\b中写上下面的代码。使用@import导入mixin.scss后，就可以用include语法去使用Mixin注册的代码块。</p><pre><code class="language-xml">\b&lt;style lang="scss"&gt;\n@import \'../styles/mixin\';\n@include b(container) {\n  display: flex;\n  flex-direction: row;\n  flex: 1;\n  flex-basis: auto;\n  box-sizing: border-box;\n  min-width: 0;\n  @include when(vertical) {\n    flex-direction: column;\n  }\n}\n\n&lt;/style&gt;\n</code></pre><p>在上面的代码中，我们使用b(container)生成.el-container样式类，在内部使用when(vertical)\b\b生成.el-container.is-vertical样式类，去修改flex的布局方向。</p><pre><code class="language-scss">.el-container {\n&nbsp; display: flex;\n&nbsp; flex-direction: row;\n&nbsp; flex: 1;\n&nbsp; flex-basis: auto;\n&nbsp; box-sizing: border-box;\n&nbsp; min-width: 0;\n}\n.el-container.is-vertical {\n&nbsp; flex-direction: column;\n}\n</code></pre><p>container组件如果内部没有header或者footer组件，就是横向布局，否则就是垂直布局。根据上面的CSS代码，我们可以知道，只需要新增is-vertical这个class，就可以实现垂直布局。</p><p>我们在Container.vue中写下下面的代码，template中使用el-container容器包裹，通过:class\b来实现样式控制即可。然后你肯定会疑惑，为什么会有两个script标签？</p><p>因为开发组件库的时候，我们要确保每个组件都有自己的名字，script setup中没法返回组件的名字，所以我们需要一个单独的标签，使用options的语法设置组件的name属性。</p><p>然后在&lt;script setup&gt;标签中，添加lang="ts"来声明语言是TypeScript。Typescript实现组件的时候，我们只需要使用interface去定义传递的属性类型即可。使用defineProps<props>\b()\b实现参数类型校验后，我们再使用computed去判断container的方向是否为垂直，手动指定direction和子元素中有el-header或者el-footer的时候是垂直布局，其他情况是水平布局。</props></p><pre><code class="language-xml">&lt;template&gt;\n  &lt;section\n    class="el-container"\n    :class="{ \'is-vertical\': isVertical }"\n  &gt;\n    &lt;slot /&gt;\n  &lt;/section&gt; \n&lt;/template&gt;\n&lt;script lang="ts"&gt;\nexport default{\n  name:\'ElContainer\'\n}\n&lt;/script&gt;\n&lt;script setup lang="ts"&gt;\n\nimport {useSlots,computed,VNode,Component} from \'vue\'\n\ninterface Props {\n  direction?:string\n}\nconst props = defineProps&lt;Props&gt;()\n\nconst slots = useSlots()\n\nconst isVertical = computed(() =&gt; {\n  if (slots &amp;&amp; slots.default) {\n    return slots.default().some((vn:VNode) =&gt; {\n      const tag = (vn.type as Component).name\n      return tag === \'ElHeader\' || tag === \'ElFooter\'\n    })\n  } else {\n    return props.direction === \'vertical\'\n  }\n})\n&lt;/script&gt;\n</code></pre><p>这样我们的container组件就实现了，其他四个组件实现起来大同小异。我们以header组件举例，在container目录下新建Header.vue。</p><p>在下面的代码中，template中渲染el-header样式类，通过defineProps定义传入的属性height，并且通过withDefaults设置height的默认值为60px，通过b(header)的方式实现样式，用到的变量都在style/mixin中注册，方便多个组件之间的变量共享。</p><pre><code class="language-xml">&lt;template&gt;\n  &lt;header\n    class="el-header"\n    :style="{ height }"\n  &gt;\n    &lt;slot /&gt;\n  &lt;/header&gt;\n&lt;/template&gt;\n\n&lt;script lang="ts"&gt;\nexport default{\n  name:\'ElHeader\'\n}\n&lt;/script&gt;\n&lt;script setup lang="ts"&gt;\nimport {withDefaults} from \'vue\'\n\ninterface Props {\n  height?:string\n}\nwithDefaults(defineProps&lt;Props&gt;(),{\n  height:"60px"\n})\n\n&lt;/script&gt;\n\n&lt;style lang="scss"&gt;\n@import \'../styles/mixin\';\n@include b(header) {\n  padding: $--header-padding;\n  box-sizing: border-box;\n  flex-shrink: 0;\n}\n\n&lt;/style&gt;\n</code></pre><h2>组件注册</h2><p>aside、footer和main组件代码和header组件基本一致，你可以在<a href="https://github.com/shengxinjing/ailemente/commit/8902877cf3e7361da0c9aa78d6b6f4b0b344d431">这次提交中</a>看到组件的变更。</p><p>组件注册完毕之后，我们在src/App.vue中使用import语法导入后就可以直接使用了。但是这里有一个小问题，我们的组件库最后会有很多组件对外暴露，用户每次都import的话确实太辛苦了，所以我们还需要使用插件机制对外暴露安装的接口，我们在container目录下新建index.ts\b。在下面的代码中，我们对外暴露了一个对象，对象的install方法中，我们使用app.component注册这五个组件。</p><pre><code class="language-typescript">import {App} from \'vue\'\nimport ElContainer from \'./Container.vue\'\nimport ElHeader from \'./Header.vue\'\nimport ElFooter from \'./Footer.vue\'\nimport ElAside from \'./Aside.vue\'\nimport ElMain from \'./Main.vue\'\n\nexport default {\n  install(app:App){\n    app.component(ElContainer.name,ElContainer)\n    app.component(ElHeader.name,ElHeader)\n    app.component(ElFooter.name,ElFooter)\n    app.component(ElAside.name,ElAside)\n    app.component(ElMain.name,ElMain)\n  }\n}\n</code></pre><p>然后我们来到src/main.ts文件中，下面的代码中我们使用app.use(ElContainer)的方式注册全部布局组件，这样在项目内部就可以全局使用contain、header等五个组件。实际的组件库开发过程中，<a href="https://github.com/hug-sun/element3/blob/master/packages/element3/packages/container/index.js">每个组件都会提供一个install方法</a>，可以很方便地根据项目的需求按需加载。</p><pre><code class="language-typescript">import { createApp } from \'vue\'\nimport App from \'./App.vue\'\nimport ElContainer from \'./components/container\'\n\nconst app = createApp(App)\napp.use(ElContainer)\n  .use(ElButton)\n  .mount(\'#app\')\n\n</code></pre><h2>组件使用</h2><p>后面我会教你设计组件库的文档系统，这里我们就先用App.vue来演示一下组件效果。</p><p>在src/App.vue的代码中，我们使用组件嵌套的方式就可以实现下面的页面布局。</p><pre><code class="language-xml">&lt;template&gt;\n &lt;el-container&gt;\n  &lt;el-header&gt;Header&lt;/el-header&gt;\n  &lt;el-main&gt;Main&lt;/el-main&gt;\n  &lt;el-footer&gt;Footer&lt;/el-footer&gt;\n&lt;/el-container&gt;\n  &lt;hr&gt;\n\n&lt;el-container&gt;\n  &lt;el-header&gt;Header&lt;/el-header&gt;\n  &lt;el-container&gt;\n    &lt;el-aside width="200px"&gt;Aside&lt;/el-aside&gt;\n    &lt;el-main&gt;Main&lt;/el-main&gt;\n  &lt;/el-container&gt;\n&lt;/el-container&gt;\n  &lt;hr&gt;\n&lt;el-container&gt;\n  &lt;el-aside width="200px"&gt;Aside&lt;/el-aside&gt;\n  &lt;el-container&gt;\n    &lt;el-header&gt;Header&lt;/el-header&gt;\n    &lt;el-main&gt;Main&lt;/el-main&gt;\n    &lt;el-footer&gt;Footer&lt;/el-footer&gt;\n  &lt;/el-container&gt;\n&lt;/el-container&gt;\n&lt;/template&gt;\n&lt;script setup lang="ts"&gt;\n&lt;/script&gt;\n&lt;style&gt;\n\nbody{\n  width:1000px;\n  margin:10px auto;\n}\n.el-header,\n.el-footer {\n  ..设置额外的css样式\n}\n&lt;/style&gt;\n</code></pre><h2><img src="https://static001.geekbang.org/resource/image/50/8d/50fc754a942ae92f0362e1e9d62fb28d.png?wh=1920x1527" alt="图片"></h2><h2>总结</h2><p>今天的课程到这里就结束了，我们来总结一下今天学到的内容吧。</p><p>首先我们介绍了组件库中的组件分类，基础组件、表单组件、数据组件和通知组件，这些组件类型组合拼接，就可以开发出功能繁多的项目。其中，基础组件负责整体布局和色彩的显示，表单组件负责用户的输入，数据组件负责数据的显示，通知组件用于数据的反馈。</p><p>然后我们基于Vite和TypeScript搭建了组件库的代码环境，使用husky实现了代码提交之前的commit信息和ESLint格式校验，确保只有合格的代码能够提交成功。</p><p>最后我们使用TypeScript+Sass开发了布局相关的组件，container负责容器，header、footer、aside和main负责渲染不同模块。</p><p>这节课我们学会了如何使用Sass来提高管理CSS代码的效率，以及如何使用TypeScript来开发组件，现在相信你对Vue 3中如何使用TypeScript已经有了更进一步的认识。</p><h2>思考题</h2><p>最后我们留个思考题：你负责的业务里有什么组件适合放在组件库里维护呢？</p><p>欢迎在评论区分享你的答案，也欢迎你把这一讲分享给你的同事和朋友们，我们下一讲再见！</p>',
        article_title: "20｜组件库：如何设计你自己的通用组件库？",
      },
      {
        title: "21 | 单元测试：如何使用 TDD 开发一个组件？",
        id: 464910,
        content:
          '<p>你好，我是大圣。</p><p>上一讲我们学习了不少组件库里的经典组件，用TypeScript搭建起了TypeScript + Vite + Sass的组件库开发基础环境，并且实现了Container布局组件。</p><p>今天我们来聊另外一个大幅提升组件库代码可维护性的手段：单元测试。在理解单元测试来龙去脉的基础上，我还会给你演示，如何使用测试驱动开发的方式实现一个组件，也就是社区里很火的TDD开发模式。</p><h2>单元测试</h2><p>单元测试（Unit Testing），是指对软件中的最小可测试单元进行检查和验证，这是百度百科对单元测试的定义。而我的理解是，在我们日常代码开发中，会经常写Console来确认代码执行效果是否符合预期，这其实就算是测试的雏形了，我们把代码中的某个函数或者功能，传入参数后，校验输出是否符合预期。</p><p>下面的代码中我们实现了一个简单的add函数,  并且使用打印3和add(1,2)的结果来判断函数输出。</p><p>add函数虽然看起来很简单，但实际使用时可能会遇到很多情况。比如说x如果是字符串，或者对象等数据类型的时候，add结果是否还可以符合预期？而且add函数还有可能被你的同事不小心加了其他逻辑，这都会干扰add函数的行为。</p><pre><code class="language-javascript">function add(x,y){\n  return x+y\n}\n\nconsole.log(3 == add(1,2))\n</code></pre><!-- [[[read_end]]] --><p>为了让add函数的行为符合预期，你希望能添加很多Console的判断逻辑，并且让这些代码自动化执行。</p><p>我们来到src目录下，新建一个add.js。下面的代码中，我们定义了函数test执行测试函数，可以给每个测试起个名字，方便调试的时候查找，expect可以判断传入的值和预期是否相符。</p><pre><code class="language-javascript">function add(x,y){\n  return x+y\n}\n\nfunction expect(ret){\n  return {\n    toBe(arg){\n      if(ret!==arg){\n        throw Error(`预计和实际不符,预期是${arg}，实际是${ret}`)\n      }\n    }\n  }\n}\nfunction test(title, fn){\n  try{\n    fn()\n    console.log(title,\'测试通过\')\n  }catch(e){\n    console.log(e)\n    console.error(title,\'测试失败\')\n  }\n}\ntest(\'测试数字相加\',()=&gt;{\n  expect(add(1,2)).toBe(3)\n})\n</code></pre><p>命令行执行node add.js以后，我们就可以看到下面的结果。如果每次Git提交代码之前，我们都能执行一遍add.js去检查add函数的逻辑，add函数相当于有了个自动检查员，这样就可以很好地提高add函数的可维护性。</p><pre><code class="language-javascript">➜&nbsp; ailemente git:(main) ✗ node add.js\n测试数字相加 测试通过\n</code></pre><p>下一步，我们如果想让add函数支持更多的数据类型，比如我们想支持数字字符串的相加，又要怎么处理呢？我们可以先写好测试代码，在下面的代码中，我们希望数字1和字符串2也能以数字的形式相加。</p><pre><code class="language-javascript">test(\'测试数字和字符串数字相加\',()=&gt;{\n  expect(add(1,\'2\')).toBe(3)\n})\n</code></pre><p>我们在命令行里执行node add.js之后，就会提示下面的报错信息，这说明现在代码还没有符合新的需求，我们需要进一步丰富add函数的逻辑。<br>\n<img src="https://static001.geekbang.org/resource/image/63/f9/632ed2fdc46e4bf58083b0dc50cbaaf9.png?wh=1780x802" alt="图片"></p><p>我们把add函数改成下面的代码，再执行add.js后，就会提示你两个测试都通过了，这样我们就确保新增逻辑的时候，也没有影响到之前的代码逻辑。</p><pre><code class="language-javascript">function add(x,y){\n  if(Number(x)==x &amp;&amp; Number(y)==y){\n    return Number(x) + Number(y)\n  }\n  return x+y\n}\n\n</code></pre><p>这是一个非常简单的场景演示，但这个例子能够帮助你快速了解什么是单元测试。下一步，我们要在Vue中给我们的组件加上测试。</p><h2>组件库引入Jest</h2><p>我们选择Facebook出品的Jest作为我们组件库的测试代码，Jest是现在做测试的最佳选择了，因为它内置了断言、测试覆盖率等功能。</p><p>不过，因为我们组件库使用TypeScript开发，所以需要安装一些插件，通过命令行执行下面的命令，vue-jest和@vue/test-utils是测试Vue组件必备的库，然后安装babel相关的库，最后安装Jest适配TypeScript的库。代码如下：</p><pre><code class="language-javascript">npm install -D jest@26 vue-jest@next @vue/test-utils@next \nnpm install -D babel-jest@26 @babel/core @babel/preset-env \nnpm install -D ts-jest@26 @babel/preset-typescript @types/jest\n</code></pre><p>安装完毕后，我们要在根目录下新建.babel.config.js。下面的配置目的是让babel解析到Node和TypeScript环境下。</p><pre><code class="language-javascript">module.exports = {\n  presets: [\n    [\'@babel/preset-env\', { targets: { node: \'current\' } }],\n    \'@babel/preset-typescript\',\n  ],\n}\n\n</code></pre><p>然后，我们还需要新建jest.config.js，用来配置jest的测试行为。不同格式的文件需要使用不同命令来配置，对于.vue文件我们使用vue-jest，对于.js或者.jsx结果的文件，我们就要使用babel-jest，而对于.ts结尾的文件我们使用ts-jest，然后匹配文件名是xx.spect.js。这里请注意，<strong>Jest只会执行.spec.js结尾的文件</strong>。</p><pre><code class="language-javascript">module.exports = {\n  transform: {\n    // .vue文件用 vue-jest 处理\n    \'^.+\\\\.vue$\': \'vue-jest\',\n    // .js或者.jsx用 babel-jest处理\n    \'^.+\\\\.jsx?$\': \'babel-jest\', \n    //.ts文件用ts-jest处理\n    \'^.+\\\\.ts$\': \'ts-jest\'\n  },\n  testMatch: [\'**/?(*.)+(spec).[jt]s?(x)\']\n}\n\n</code></pre><p>然后配置package.json，在scrips配置下面新增test命令，即可启动Jest。</p><pre><code class="language-javascript">  "scripts": {\n    "dev": "vite",\n    "build": "vue-tsc --noEmit &amp;&amp; vite build",\n    "serve": "vite preview",\n    "lint": "eslint --fix --ext .js,vue src/",\n    "test": "jest",\n}\n</code></pre><p>完成上面的操作之后，配置工作就告一段落了，可以开始输入代码做测试了。</p><p>我们可以在src目录下新增test.spec.js，再输入下面代码来进行测试。在这段代码中，我们使用expect().toBe()来判断值是否相等，使用toHavaBeenCalled来判断函数是否执行。更多的断言函数你可以去<a href="https://www.jestjs.cn/docs/expect">官网</a>查看，这些函数可以覆盖我们测试场景的方方面面。</p><pre><code class="language-javascript">\n\n\n\nfunction sayHello(name,fn){\n  if(name==\'大圣\'){\n    fn()\n  }\n}\ntest(\'测试加法\',()=&gt;{\n  expect(1+2).toBe(3)\n})\ntest(\'测试函数\',()=&gt;{\n  const fn = jest.fn()\n  sayHello(\'大圣\',fn)\n  expect(fn).toHaveBeenCalled()\n})\n  \n</code></pre><h2>TDD开发组件</h2><p>好，通过之前的讲解，我们已经学会如何使用Jest去测试函数。下一步我们来测试Vue3的组件，其实，Vue的组件核心逻辑也是函数。</p><p>这里我们借助Vue官方推荐的<a href="https://next.vue-test-utils.vuejs.org">@vue/test-utils</a> 库来测试组件的渲染，我们新建src/components/button文件夹，新建Button.spec.ts。</p><p>参考 <a href="https://e3.shengxinjing.cn/#/component/button">Element3的button组件</a>，el-button组件可以通过传递size来配置按钮的大小。现在我们先根据需求去写测试代码，因为现在Button.vue还不存在，所以我们可以先根据Button的行为去书写测试案例。</p><pre><code class="language-javascript">import Button from \'./Button.vue\'\nimport { mount } from \'@vue/test-utils\'\ndescribe(\'按钮测试\', () =&gt; {\n  it(\'按钮能够显示文本\', () =&gt; {\n    const content = \'大圣小老弟\'\n    const wrapper = mount(Button, {\n      slots: {\n        default: content\n      }\n    })\n    expect(wrapper.text()).toBe(content)\n  })\n  it(\'通过size属性控制大小\', () =&gt; {\n    const size = \'small\'\n    const wrapper = mount(Button, {\n      props: {\n        size\n      }\n    })\n    // size内部通过class控制\n    expect(wrapper.classes()).toContain(\'el-button--small\')\n  })  \n\n})\n</code></pre><p>我们首先要从@vue/test-utils库中导入mount函数，这个函数可以在命令行里模拟Vue的组件渲染。在Button的slot传递了文本之后，wrapper.text()就能获取到文本内容，然后对Button渲染结果进行判断。之后，我们利用size参数，即可通过渲染不同的class来实现按钮的大小，这部分内容我们很熟悉了，在<a href="https://time.geekbang.org/column/article/464098">第20讲</a>里的Container组件中就已经实现过了。</p><p>然后我们在命令行执行npm run test来执行所有的测试代码。命令行终端上提示，我们期望button上含有el-button-small class，但是实际上button上并没有这个class，所以就会报错。具体报错信息你可以参考下图。</p><p><img src="https://static001.geekbang.org/resource/image/ac/43/acb02590c5a4390c89bc76a8e1769043.png?wh=1442x652" alt="图片"></p><p>之后，我们再通过实现Button组件的逻辑，去处理这个错误信息，这就是TDD测试驱动开发的方法。我们实现功能的过程就像小时候写作业，而测试代码就像批改作业的老师。</p><p>TDD的优势就相当于有一位老师，在我们旁边不停做批改，哪怕一开始所有题都做错了，只要我们不断写代码，把所有题都回答正确，也能最后确保全部功能的正确。</p><p>我们通过接收size去渲染button的class，我们来到button.vue中，通过下面的代码可以接收size参数，并且成功渲染出对应的class。</p><pre><code class="language-xml">&lt;template&gt;\n  &lt;button\n    class="el-button" \n    :class="[size ? `el-button--${size}` : \'\',]"\n  &gt;\n    &lt;slot /&gt;\n  &lt;/button&gt;\n&lt;/template&gt;\n&lt;script setup lang="ts"&gt;\n\nimport {computed, withDefaults} from \'vue\'\ninterface Props {\n  size?:""|\'small\'|\'medium\'|\'large\'\n}\nconst props = withDefaults(defineProps&lt;Props&gt;(),{\n  size:""\n})\n&lt;/script&gt;\n\n</code></pre><p>进行到这里还没有结束，class还要通过Sass去修改浏览器页面内的大小。<br>\n为了让你抓住重点，这里的Sass代码我放几个核心逻辑，完整代码你可以在项目的<a href="https://github.com/shengxinjing/ailemente/blob/main/src/components/button/Button.vue#L40">GitHub</a>里看到。</p><pre><code class="language-scss">@include b(button){\n  display: inline-block;\n  cursor: pointer;\n  background: $--button-default-background-color;\n  color: $--button-default-font-color;\n  @include button-size(\n    $--button-padding-vertical,\n    $--button-padding-horizontal,\n    $--button-font-size,\n    $--button-border-radius\n  );\n  @include m(small) {\n    @include button-size(\n      $--button-medium-padding-vertical,\n      $--button-medium-padding-horizontal,\n      $--button-medium-font-size,\n      $--button-medium-border-radius\n    );\n  }\n  @include m(large) {\n    @include button-size(\n      $--button-large-padding-vertical,\n      $--button-large-padding-horizontal,\n      $--button-large-font-size,\n      $--button-large-border-radius\n    );\n  }\n}\n</code></pre><p>前面的代码中通过b(button)渲染el-button的样式，内部使用变量都可以在mixin中找到。通过b和button-size的嵌套，就能实现按钮大小的控制。button渲染的结果，你可以参考下方的截图。</p><p><img src="https://static001.geekbang.org/resource/image/86/c2/86ee8a8f3fd337014857329324f4b1c2.png?wh=1920x557" alt="图片"></p><p>然后我们接着往下进行，想要设置按钮的大小，除了通过props传递，还可以通过全局配置的方式设置默认大小。我们进入到代码文件src/main.ts中，设置全局变量$AILEMENTE中的size为large，并且还可以通过type="primary"或者type="success"的方式，设置按钮的主体颜色，代码如下：</p><pre><code class="language-typescript">const app = createApp(App)\napp.config.globalProperties.$AILEMENTE = {\n  size:\'large\'\n}\napp.use(ElContainer)\n  .use(ElButton)\n  .mount(\'#app\')\n\n\n\n</code></pre><p>首先我们要支持全局的size配置，在src目录下新建util.ts，写入下面的代码。我们通过vue提供的getCurrentInstance获取当前的实例，然后返回全局配置的$AILEMENTE。这里请注意，由于很多组件都需要读取全局配置，所以我们封装了useGlobalConfig函数。</p><pre><code class="language-typescript">import { getCurrentInstance,ComponentInternalInstance } from \'vue\'\n\nexport function useGlobalConfig(){\n  const instance:ComponentInternalInstance|null =getCurrentInstance()\n  if(!instance){\n    console.log(\'useGlobalConfig 必须得在setup里面整\')\n    return\n  }\n  return instance.appContext.config.globalProperties.$AILEMENTE || {}\n  \n}\n</code></pre><p>这时我们再回到Button.vue中，通过computed返回计算后的按钮的size。如果props.size没传值，就使用全局的globalConfig.size；如果全局设置中也没有size配置，按钮就使用Sass中的默认大小。</p><pre><code class="language-xml">&lt;template&gt;\n  &lt;button\n    class="el-button" \n    :class="[\n      buttonSize ? `el-button--${buttonSize}` : \'\',\n      type ? `el-button--${type}` : \'\'\n    ]"\n  &gt;\n    &lt;slot /&gt;\n  &lt;/button&gt;\n&lt;/template&gt;\n\n&lt;script lang="ts"&gt;\nexport default{\n  name:\'ElButton\'\n}\n&lt;/script&gt;\n\n&lt;script setup lang="ts"&gt;\n\nimport {computed, withDefaults} from \'vue\'\nimport { useGlobalConfig } from \'../../util\';\n\ninterface Props {\n  size?:""|\'small\'|\'medium\'|\'large\',\n  type?:""|\'primary\'|\'success\'|\'danger\'\n}\nconst props = withDefaults(defineProps&lt;Props&gt;(),{\n  size:"",\n  type:""\n})\nconst globalConfig = useGlobalConfig()\nconst buttonSize = computed(()=&gt;{\n  return props.size||globalConfig.size\n})\n&lt;/script&gt;\n\n</code></pre><p>我们来到src/App.vue中，就可以直接使用el-button来显示不同样式的按钮了。</p><pre><code class="language-xml">  &lt;el-button type="primary"&gt;\n    按钮\n  &lt;/el-button&gt;\n  &lt;el-button type="success"&gt;\n    按钮\n  &lt;/el-button&gt;\n  &lt;el-button&gt;按钮&lt;/el-button&gt;\n  &lt;el-button size="small"&gt;\n    按钮\n  &lt;/el-button&gt;\n  \n</code></pre><p>不同按钮的显示效果如下所示：<br>\n<img src="https://static001.geekbang.org/resource/image/e1/20/e1bc7b41f95640cafaf4619f9df96720.jpg?wh=1920x508" alt="图片"></p><p>然后我们进入jest.config.js中，新增下面的配置，collectCoverage标记的意思是我们需要收集代码测试覆盖率。</p><pre><code class="language-typescript">module.exports = {\n  transform: {\n    //  用 `vue-jest` 处理 `*.vue` 文件\n    \'^.+\\\\.vue$\': \'vue-jest\', //vuejest 处理.vue\n    \'^.+\\\\.jsx?$\': \'babel-jest\',  // babel jest处理js or jsx\n    \'^.+\\\\.tsx?$\': \'ts-jest\', // ts-jest 处理.ts .tsx\n  },\n  testMatch: [\'**/?(*.)+(spec).[jt]s?(x)\'],\n  collectCoverage: true,\n  coverageReporters: ["json", "html"],\n}\n\n</code></pre><p>然后在执行npm run test后，项目的根目录下就会出现一个coverage目录。<br>\n我们打开下面的index.html后，就可以在浏览器中看到测试覆盖率的报告。对照下图我们可以看到，button组件的测试覆盖率100%，util下面有两行代码飘红，也就是没有测试的逻辑。</p><p>在一定程度上，测试覆盖率也能够体现出代码的可维护性，希望你可以用好这个指标。</p><p><img src="https://static001.geekbang.org/resource/image/b3/d0/b38eec8c9b286c4316cecfe39e3a67d0.png?wh=1868x288" alt="图片"></p><p><img src="https://static001.geekbang.org/resource/image/6b/be/6b4027a05761d323224df5b09c4beebe.png?wh=1568x690" alt="图片"></p><p><img src="https://static001.geekbang.org/resource/image/62/02/621bf3871a7b345bb6a08c451e0b3d02.png?wh=1870x506" alt="图片"></p><p>最后，我们进入.husky/pre-commit文件，新增npm run test命令，这么做的目的是，确保测试通过的代码才能进入git管理代码，这会进一步提高代码的规范和可维护性。</p><pre><code class="language-typescript">#!/bin/sh\n. "$(dirname "$0")/_/husky.sh"\n\nnpm run lint\nnpm run test\n</code></pre><h2>总结</h2><p>今天的内容就到此结束了，我们来回顾一下今天学到的东西吧。</p><p>首先，我们学习了什么是自动化测试，我们实现了test和expect函数，通过它们来测试add函数。</p><p>然后，我们通过jest框架配置了Vue的自动化测试环境。通过安装babel、@vue/test-utils、babel-vue、ts-babel等插件，我们配置了TypeScript环境下的Jest+Vue 3的单测环境，并且匹配项目中.spect结束的js和vue文件执行测试。</p><p>在Jest中，我们通过describe函数给测试分组，通过it执行测试，再利用expect语法去执行断言。我们还发现，借助@vue/test-utils库可以很方便地对Vue组件进行测试。</p><p>最后，我们一起体验了TDD测试驱动开发的开发模式。我们先根据功能需求，去写出测试案例，这个时候测试窗口就会报错，然后我们才开始实现功能，最终让测试代码全部通过，用这样的方式来检验开发的结果。<strong>TDD的优势就在于可以随时检验代码的逻辑，能极大提高代码的可维护性</strong>。</p><p>现在我们有了TypeScript，有了Jest，下一讲我们将实现一个比较复杂的表单组件，它会包含组件的通信、方法传递等难点，敬请期待。</p><h2>思考题</h2><p>最后留个思考题，我们的Button组件怎么通过传递circle属性来显示圆角按钮呢？</p><p>欢迎你在评论区留下你的答案，也欢迎你把这一讲分享给你的同事和朋友们，我们下一讲再见！</p>',
        article_title: "21 | 单元测试：如何使用 TDD 开发一个组件？",
      },
      {
        title: "22｜表单：如何设计一个表单组件？",
        id: 465677,
        content:
          '<p>你好，我是大圣。</p><p>上一讲我们详细讲解了如何使用Jest框架对组件库进行测试，TypeScript和Jest都为我们的代码质量和研发效率保驾护航。之前我们实现的Container和Button组件都是以渲染功能为主，可以根据不同的属性渲染不同的样式去实现布局和不同格式的按钮。</p><p>那么今天我再带你实现一个非常经典的表单组件，这个组件除了要渲染页面组件之外，还得支持很好的页面交互，下面我们先从Element3的表单组件开始讲解。</p><h2>表单组件</h2><p>在<a href="https://e3.shengxinjing.cn/#/component/form">Element表单组件</a>的页面里，我们能看到表单种类的组件类型有很多，我们常见的输入框、单选框和评分组件等都算是表单组件系列的。</p><p>下面这段代码是Element3官方演示表单的Template，整体表单页面分三层：</p><ul>\n<li>el-form组件负责最外层的表单容器；</li>\n<li>el-form-item组件负责每一个输入项的label和校验管理；</li>\n<li>内部的el-input或者el-switch负责具体的输入组件。</li>\n</ul><pre><code class="language-xml">&lt;el-form\n  :model="ruleForm"\n  :rules="rules"\n  ref="form"\n  label-width="100px"\n  class="demo-ruleForm"\n&gt;\n  &lt;el-form-item label="活动名称" prop="name"&gt;\n    &lt;el-input v-model="ruleForm.name"&gt;&lt;/el-input&gt;\n  &lt;/el-form-item&gt;\n  &lt;el-form-item label="活动区域" prop="region"&gt;\n    &lt;el-select v-model="ruleForm.region" placeholder="请选择活动区域"&gt;\n      &lt;el-option label="区域一" value="shanghai"&gt;&lt;/el-option&gt;\n      &lt;el-option label="区域二" value="beijing"&gt;&lt;/el-option&gt;\n    &lt;/el-select&gt;\n  &lt;/el-form-item&gt;\n  &lt;el-form-item label="即时配送" prop="delivery"&gt;\n    &lt;el-switch v-model="ruleForm.delivery"&gt;&lt;/el-switch&gt;\n  &lt;/el-form-item&gt;\n  &lt;el-form-item label="活动性质" prop="type"&gt;\n    &lt;el-checkbox-group v-model="ruleForm.type"&gt;\n      &lt;el-checkbox label="美食/餐厅线上活动" name="type"&gt;&lt;/el-checkbox&gt;\n      &lt;el-checkbox label="地推活动" name="type"&gt;&lt;/el-checkbox&gt;\n      &lt;el-checkbox label="线下主题活动" name="type"&gt;&lt;/el-checkbox&gt;\n      &lt;el-checkbox label="单纯品牌曝光" name="type"&gt;&lt;/el-checkbox&gt;\n    &lt;/el-checkbox-group&gt;\n  &lt;/el-form-item&gt;\n  &lt;el-form-item label="特殊资源" prop="resource"&gt;\n    &lt;el-radio-group v-model="ruleForm.resource"&gt;\n      &lt;el-radio label="线上品牌商赞助"&gt;&lt;/el-radio&gt;\n      &lt;el-radio label="线下场地免费"&gt;&lt;/el-radio&gt;\n    &lt;/el-radio-group&gt;\n  &lt;/el-form-item&gt;\n  &lt;el-form-item label="活动形式" prop="desc"&gt;\n    &lt;el-input type="textarea" v-model="ruleForm.desc"&gt;&lt;/el-input&gt;\n  &lt;/el-form-item&gt;\n  &lt;el-form-item&gt;\n    &lt;el-button type="primary" @click="submitForm(\'ruleForm\')"\n      &gt;立即创建&lt;/el-button\n    &gt;\n    &lt;el-button @click="resetForm(\'ruleForm\')"&gt;重置&lt;/el-button&gt;\n  &lt;/el-form-item&gt;\n&lt;/el-form&gt;\n</code></pre><!-- [[[read_end]]] --><p>现在我们把上面的代码简化为最简单的形式，只留下el-input作为输入项，就可以清晰地看到表单组件工作的模式：el-form组件使用:model提供数据绑定；使用rules提供输入校验规则，可以规范用户的输入内容；使用el-form-item作为输入项的容器，对输入进行校验，显示错误信息。</p><pre><code class="language-xml">  &lt;el-form :model="ruleForm" :rules="rules" ref="form"&gt;\n    &lt;el-form-item label="用户名" prop="username"&gt;\n      &lt;el-input v-model="ruleForm.username"&gt;&lt;/el-input&gt;\n      &lt;!-- &lt;el-input :model-value="" @update:model-value=""&gt;&lt;/el-input&gt; --&gt;\n    &lt;/el-form-item&gt;\n    &lt;el-form-item label="密码" prop="passwd"&gt;\n      &lt;el-input type="textarea" v-model="ruleForm.passwd"&gt;&lt;/el-input&gt;\n    &lt;/el-form-item&gt;\n    &lt;el-form-item&gt;\n      &lt;el-button type="primary" @click="submitForm()"&gt;登录&lt;/el-button&gt;\n    &lt;/el-form-item&gt;\n  &lt;/el-form&gt;\n</code></pre><p>然后我们看下rules和model是如何工作的。</p><p>这里使用reactive返回用户输入的数据，username和passwd输入项对应，然后rules使用reactive包裹用户输入项校验的配置。</p><p>具体的校验规则，现在主流组件库使用的都是async-validator这个库，详细的校验规则你可以访问 <a href="https://github.com/yiminghe/async-validator">async-validator的官网</a>查看。而表单Ref上我们额外新增了一个validate方法，这个方法会执行所有的校验逻辑来显示用户的报错信息，下图就是用户输入不符合rules配置后，页面的报错提示效果。</p><pre><code class="language-typescript">const ruleForm = reactive&lt;UserForm&gt;({\n  username:"",\n  passwd:""\n})\nconst rules = reactive({\n  rules: {\n    username: { required: true,min: 1, max: 20, message: \'长度在 1 到 20 个字符\', trigger: \'blur\' },\n    passwd: [{ required: true, message: \'密码\', trigger: \'blur\' }]\n  }\n})\nfunction submitForm() {\n  form.value.validate((valid) =&gt; {\n    if (valid) {\n      alert(\'submit!\')\n    } else {\n      console.log(\'error submit!!\')\n      return false\n    }\n  })\n}\n</code></pre><h2><img src="https://static001.geekbang.org/resource/image/41/52/41183d472a7b16f80ed846c58fe43852.png?wh=1688x1074" alt="图片"></h2><h2>表单组件实现</h2><p>那么接下来我们就要实现组件了。我们进入到src/components目录下新建Form.vue去实现el-form组件，该组件是整个表单组件的容器，负责管理每一个el-form-item组件的校验方法，并且自身还提供一个检查所有输入项的validate方法。</p><p>在下面的代码中，我们注册了传递的属性的格式，并且注册了validate方法使其对外暴露使用。</p><pre><code class="language-typescript">\ninterface Props {\n  label?: string\n  prop?: string\n}\nconst props = withDefaults(defineProps&lt;Props&gt;(), { \n  label: "", \n  prop: "" \n})\n\nconst formData = inject(key)\n\nconst o: FormItem = {\n  validate,\n}\n\ndefineExpose(o)\n</code></pre><p>那么在 el-form 组件中如何管理el-form-item组件呢？我们先要新建FormItem.vue文件，这个组件加载完毕之后去通知el-form组件自己加载完毕了，这样在el-form中我们就可以很方便地使用数组来管理所有内部的form-item组件。</p><pre><code class="language-typescript">import { emitter } from "../../emitter"\nconst items = ref&lt;FormItem[]&gt;([])\n\nemitter.on("addFormItem", (item) =&gt; {\n  items.value.push(item)\n})\n</code></pre><p>然后el-form-item还要负责管理内部的input输入标签，并且从form组件中获得配置的rules，通过rules的逻辑，来判断用户的输入值是否合法。另外，el-form还要管理当前输入框的label，看看输入状态是否报错，以及报错的信息显示，这是一个承上启下的组件。</p><pre><code class="language-typescript">onMounted(() =&gt; {\n  if (props.prop) {\n    emitter.on("validate", () =&gt; {\n      validate()\n    })\n    emitter.emit("addFormItem", o)\n  }\n})\nfunction validate() {\n  if (formData?.rules === undefined) {\n    return Promise.resolve({ result: true })\n  }\n  const rules = formData.rules[props.prop]\n  const value = formData.model[props.prop]\n  const schema = new Schema({ [props.prop]: rules })\n  return schema.validate({ [props.prop]: value }, (errors) =&gt; {\n    if (errors) {\n      error.value = errors[0].message || "校验错误"\n    } else {\n      error.value = ""\n    }\n  })\n}\n</code></pre><p>这里我们可以看到，form、form-item和input这三个组件之间是<strong>嵌套使用</strong>的关系：</p><ul>\n<li>form提供了所有的数据对象和配置规则；</li>\n<li>input负责具体的输入交互；</li>\n<li>form-item负责中间的数据和规则管理，以及显示具体的报错信息。<br>\n这就需要一个强有力的组件通信机制，在Vue中组件之间的通信机制有这么几种。</li>\n</ul><p>首先是父子组件通信，通过props和emits来通信。这个我们在全家桶实战篇和评级组件那一讲都有讲过，父元素通过props把需要的数据传递给子元素，子元素通过emits通知父元素内部的变化，并且还可以通过defineDepose的方式暴露给父元素方法，可以让父元素调用自己的方法。</p><p>那么form和input组件如何通信呢？这种祖先元素和后代元素，中间可能嵌套了很多层的关系，Vue则提供了provide和inject两个API来实现这个功能。</p><p>在组件中我们可以使用provide函数向所有子组件提供数据，子组件内部通过inject函数注入使用。注意这里provide提供的只是普通的数据，并没有做响应式的处理，如果子组件内部需要响应式的数据，那么需要在provide函数内部使用ref或者reative包裹才可以。</p><p>关于prvide和inject的类型系统，我们可以使用Vue提供的InjectiveKey来声明。我们在form目录下新建type.ts专门管理表单组件用到的相关类型，在下面的代码中，我们定义了表单form和表单管理form-item的上下文，并且通过InjectionKey管理提供的类型。</p><pre><code class="language-typescript">import { InjectionKey } from "vue"\nimport { Rules, Values } from "async-validator"\n\nexport type FormData = {\n  model: Record&lt;string, unknown&gt;\n  rules?: Rules\n}\n\nexport type FormItem = {\n  validate: () =&gt; Promise&lt;Values&gt;\n}\n\nexport type FormType = {\n  validate: (cb: (isValid: boolean) =&gt; void) =&gt; void\n}\n\nexport const key: InjectionKey&lt;FormData&gt; = Symbol("form-data")\n</code></pre><p>而下面的代码，我们则通过provide向所有子元素提供form组件的上下文。子组件内部通过inject获取，很多组件都是嵌套成对出现的，provide和inject这种通信机制后面我们还会不停地用到，做好准备。</p><pre><code class="language-typescript">provide(key, {\n  model: props.model,\n  rules?: props.rules,\n})\n\n# 子组件\nconst formData = inject(key)\n</code></pre><p>然后就是具体的input实现逻辑，在下面的代码中，input 的核心逻辑就是对v-model的支持，这个内容我们在评级组件那一讲已经实现过了。</p><p>v-mode其实是:mode-value="x"和@update:modelValute两个写法的简写，组件内部获取对应的属性和modelValue方法即可。这里需要关注的代码是我们输入完成之后的事件，输入的结果校验是由父组件el-form-item来实现的，我们只需要通过emit对外广播出去即可。</p><pre><code class="language-xml">&lt;template&gt;\n  &lt;div\n    class="el-form-item"\n  &gt;\n    &lt;label\n      v-if="label"\n    &gt;{{ label }}&lt;/label&gt;\n    &lt;slot /&gt;\n    &lt;p\n      v-if="error"\n      class="error"\n    &gt;\n      {{ error }}\n    &lt;/p&gt;\n  &lt;/div&gt;\n&lt;/template&gt;\n&lt;script lang="ts"&gt;\nexport default{\n  name:\'ElFormItem\'\n}\n&lt;/script&gt;\n\n&lt;script setup lang="ts"&gt;\nimport Schema from "async-validator"\nimport { onMounted, ref, inject } from "vue"\nimport { FormItem, key } from "./type"\nimport { emitter } from "../../emitter"\n\ninterface Props {\n  label?: string\n  prop?: string\n}\nconst props = withDefaults(defineProps&lt;Props&gt;(), { label: "", prop: "" })\n// 错误\nconst error = ref("")\n\nconst formData = inject(key)\n\nconst o: FormItem = {\n  validate,\n}\n\ndefineExpose(o)\n\nonMounted(() =&gt; {\n  if (props.prop) {\n    emitter.on("validate", () =&gt; {\n      validate()\n    })\n    emitter.emit("addFormItem", o)\n  }\n})\n\nfunction validate() {\n  if (formData?.rules === undefined) {\n    return Promise.resolve({ result: true })\n  }\n  const rules = formData.rules[props.prop]\n  const value = formData.model[props.prop]\n  const schema = new Schema({ [props.prop]: rules })\n  return schema.validate({ [props.prop]: value }, (errors) =&gt; {\n    if (errors) {\n      error.value = errors[0].message || "校验错误"\n    } else {\n      error.value = ""\n    }\n  })\n}\n&lt;/script&gt;\n\n&lt;style lang="scss"&gt;\n@import \'../styles/mixin\';\n@include b(form-item) {\n  margin-bottom: 22px;\n  label{\n    line-height:1.2;\n    margin-bottom:5px;\n    display: inline-block;\n  }\n  &amp; .el-form-item {\n    margin-bottom: 0;\n  }\n}\n.error{\n  color:red;\n}\n&lt;/style&gt;\n</code></pre><p>最后我们点击按钮的时候，在最外层的form标签内部会对所有的输入项进行校验。由于我们管理着所有的form-item，只需要遍历所有的form-item，依次执行即可。</p><p>下面的代码就是表单注册的validate方法，我们遍历全部的表单输入项，调用表单输入项的validate方法，有任何一个输入项有报错信息，整体的校验就会是失败状态。</p><pre><code class="language-typescript">\n\nfunction validate(cb: (isValid: boolean) =&gt; void) {\n  const tasks = items.value.map((item) =&gt; item.validate())\n  Promise.all(tasks)\n    .then(() =&gt; { cb(true) })\n    .catch(() =&gt; { cb(false) })\n}\n</code></pre><p>上面代码实际执行的是每个表单输入项内部的validate方法，这里我们使用的就是async-validate的校验函数。在validate函数内部，我们会获取表单所有的ruls，并且过滤出当前输入项匹配的输入校验规则，然后通过AsyncValidator对输入项进行校验，把所有的校验结果放在model对象中。如果errors[0].message非空，就说明校验失败，需要显示对应的错误消息，页面输入框显示红色状态。</p><pre><code class="language-javascript">import Schema from "async-validator"\n\nfunction validate() {\n  if (formData?.rules === undefined) {\n    return Promise.resolve({ result: true })\n  }\n  const rules = formData.rules[props.prop]\n  const value = formData.model[props.prop]\n  const schema = new Schema({ [props.prop]: rules })\n  return schema.validate({ [props.prop]: value }, (errors) =&gt; {\n    if (errors) {\n      error.value = errors[0].message || "校验错误"\n    } else {\n      error.value = ""\n    }\n  })\n}\n</code></pre><h2>总结</h2><p>今天的课程到这就结束了，我们来总结一下今天学到的内容吧。</p><p>今天我们设计和实现了一个比较复杂的组件类型——表单组件。表单组件在组件库中作用，就是收集和获取用户的输入值，并且提供用户的输入校验，比如输入的长度、邮箱格式等，符合校验规则后，就可以获取用户输入的内容，并提交给后端。</p><p>这一过程中我们要实现三类组件：</p><ul>\n<li>\n<p>el-form提供表单的容器组件，负责全局的输入对象model和校验规则rules的配置，并且在用户点击提交的时候，可以执行全部输入项的校验规则；</p>\n</li>\n<li>\n<p>其次是input类组件，我们日常输入内容的输入框、下拉框、滑块等都属于这一类组件，这类组件主要负责显示对应的交互组件，并且监听所有的输入项，用户在交互的同时通知执行校验；</p>\n</li>\n<li>\n<p>然后就是介于form和input中间的form-item组件，这个组件负责每一个具体输入的管理，从form组件中获取校验规则，从input中获取用户输入的内容，通过async-validator校验输入是否合法后显示对应的输入状态，并且还能把校验方法提供给form组件，form可以很方便地管理所有form-item。</p>\n</li>\n</ul><p>至此，form组件设计完毕，相信你对组件通信、输入类组件的实现已经得心应手了，并且对组件设计中如何使用TypeScript也有了自己的心得。<strong>组件设计我们需要考虑的就是内部交互的逻辑，对子组件提供什么数据，对父组件提供什么方法，需不需要通过provide或者inject来进行跨组件通信等等</strong>。相信实践过后，你会有更加深刻的理解和认识。</p><h2>思考题</h2><p>最后留一道思考题：今天的表单组件在设计上能否通过Vue 2时代流行的event-bus来实现呢？</p><p>期待在评论区看到你的思考，也欢迎你把这一讲分享给你的同事和朋友们，我们下一讲再见！</p>',
        article_title: "22｜表单：如何设计一个表单组件？",
      },
      {
        title: "23 | 弹窗：如何设计一个弹窗组件？",
        id: 466896,
        content:
          "<p>你好，我是大圣。</p><p>上一讲我们剖析了表单组件的实现模式，相信学完之后，你已经掌握了表单类型组件设计的细节，表单组件的主要功能就是在页面上获取用户的输入。</p><p>不过，用户在交互完成之后，还需要知道交互的结果状态，这就需要我们提供专门用来反馈操作状态的组件。这类组件根据反馈的级别不同，也分成了很多种类型，比如全屏灰色遮罩、居中显示的对话框Dialog，在交互按钮侧面显示、用来做简单提示的tooltip，以及右上角显示信息的通知组件Notification等，这类组件的交互体验你都可以在<a href=\"https://e3.shengxinjing.cn/#\">Element3官网</a>感受。</p><p>今天的代码也会用Element3的Dialog组件和Notification进行举例，在动手写代码实现之前，我们先从这个弹窗组件的需求开始说起。</p><h2>组件需求分析</h2><p>我们先来设计一下要做的组件，通过这部分内容，还可以帮你继续加深一下对单元测试Jest框架的使用熟练度。我建议你在设计一个新的组件的时候，也试试采用这种方式，先把组件所有的功能都罗列出来，分析清楚需求再具体实现，这样能够让你后面的工作事半功倍。</p><p>首先无论是对话框Dialog，还是消息弹窗Notification，它们都由一个弹窗的标题，以及具体的弹窗的内容组成的。我们希望弹窗有一个关闭的按钮，点击之后就可以关闭弹窗，弹窗关闭之后还可以设置回调函数。</p><!-- [[[read_end]]] --><p>下面这段代码演示了dialog组件的使用方法，通过title显示标题，通过slot显示文本内容和交互按钮，而通过v-model就能控制显示状态。</p><pre><code class=\"language-typescript\">&lt;el-dialog\n  title=\"提示\"\n  :visible.sync=\"dialogVisible\"\n  width=\"30%\"\n  v-model:visible=\"dialogVisible\"\n&gt;\n  &lt;span&gt;这是一段信息&lt;/span&gt;\n  &lt;template #footer&gt;\n    &lt;span class=\"dialog-footer\"&gt;\n      &lt;el-button @click=\"dialogVisible = false\"&gt;取 消&lt;/el-button&gt;\n      &lt;el-button type=\"primary\" @click=\"dialogVisible = false\"&gt;确 定&lt;/el-button&gt;\n    &lt;/span&gt;\n  &lt;/template&gt;\n&lt;/el-dialog&gt;\n</code></pre><p>这类组件实现起来和表单类组件区别不是特别大，我们首先需要做的就是<strong>控制好组件的数据传递</strong>，并且使用Teleport渲染到页面顶层的body标签。</p><p>像Dialog和Notification类的组件，我们只是单纯想显示一个提示或者报错信息，过几秒就删除，如果在每个组件内部都需要写一个&lt;Dialog v-if&gt;，并且使用v-if绑定变量的方式控制显示就会显得很冗余。</p><p>所以，这里就要用到一种调用Vue组件的新方式：我们可以使用JavaScript的API动态地创建和渲染Vue的组件。具体如何实现呢？我们以Notification组件为例一起看一下。</p><p>下面的代码是Element3的Notification演示代码。组件内部只有两个button，我们不需要书写额外的组件标签，只需要在&lt;script setup&gt;中使用Notification.success\b函数，就会在页面动态创建Notification组件，并且显示在页面右上角。</p><pre><code class=\"language-xml\">&lt;template&gt;\n  &lt;el-button plain @click=\"open1\"&gt; 成功 &lt;/el-button&gt;\n  &lt;el-button plain @click=\"open2\"&gt; 警告 &lt;/el-button&gt;\n&lt;/template&gt;\n&lt;script setup&gt;\n  import { Notification } from 'element3'\n\n  function open1() {\n    Notification.success({\n      title: '成功',\n      message: '这是一条成功的提示消息',\n      type: 'success'\n    })\n  }\n  function open2() {\n    Notification.warning({\n      title: '警告',\n      message: '这是一条警告的提示消息',\n      type: 'warning'\n    })\n  }\n\n\n&lt;/script&gt;\n</code></pre><h2>弹窗组件实现</h2><p>分析完需求之后，我们借助单元测试的方法来实现这个弹窗组件（单元测试的内容如果记不清了，你可以回顾<a href=\"https://time.geekbang.org/column/article/464098\">第20讲</a>）。</p><p>我们依次来分析Notification的代码，相比于写Demo逻辑的代码，这次我们体验一下实际的组件和演示组件的区别。我们来到element3下面的src/components/Notification/notifucation.vue代码中，下面的代码构成了组件的主体框架，我们不去直接写组件的逻辑，而是先从测试代码来梳理组件的功能。</p><pre><code class=\"language-xml\">&lt;template&gt;\n  &lt;div class=\"el-nofication\"&gt;\n    &lt;slot /&gt;\n  &lt;/div&gt;\n&lt;/template&gt;\n\n&lt;script&gt;\n\n&lt;/script&gt;\n\n&lt;style lang=\"scss\"&gt;\n@import '../styles/mixin';\n\n&lt;/style&gt;\n</code></pre><p>结合下面的代码可以看到，我们进入到了内部文件Notification.spec.js中。下面的测试代码中，我们期待Notification组件能够渲染el-notification\b样式类，并且内部能够通过属性title渲染标题；message属性用来渲染消息主体；position用来渲染组件的位置，让我们的弹窗组件可以显示在浏览器四个角。</p><pre><code class=\"language-xml\">import Notification from \"./Notification.vue\"\nimport { mount } from \"@vue/test-utils\"\n\ndescribe(\"Notification\", () =&gt; { \n  \n  it('渲染标题title', () =&gt; {\n    const title = 'this is a title'\n    const wrapper = mount(Notification, {\n      props: {\n        title\n      }\n    })\n    expect(wrapper.get('.el-notification__title').text()).toContain(title)\n  })\n\n  it('信息message渲染', () =&gt; {\n    const message = 'this is a message'\n    const wrapper = mount(Notification, {\n      props: {\n        message\n      }\n    })\n    expect(wrapper.get('.el-notification__content').text()).toContain(message)\n  })\n\n  it('位置渲染', () =&gt; {\n    const position = 'bottom-right'\n    const wrapper = mount(Notification, {\n      props: {\n        position\n      }\n    })\n    expect(wrapper.find('.el-notification').classes()).toContain('right')\n    expect(wrapper.vm.verticalProperty).toBe('bottom')\n    expect(wrapper.find('.el-notification').element.style.bottom).toBe('0px')\n  })\n\n  it('位置偏移', () =&gt; {\n    const verticalOffset = 50\n    const wrapper = mount(Notification, {\n      props: {\n        verticalOffset\n      }\n    })\n    expect(wrapper.vm.verticalProperty).toBe('top')\n    expect(wrapper.find('.el-notification').element.style.top).toBe(\n      `${verticalOffset}px`\n    )\n  })\n\n})\n\n</code></pre><p>这时候毫无疑问，测试窗口会报错。我们需要进入notificatin.vue中实现代码逻辑。<br>\n下面的代码中，我们在代码中接收title、message和position，使用notification__title和notification__message渲染标题和消息。</p><pre><code class=\"language-xml\">&lt;template&gt;\n  &lt;div class=\"el-notification\" :style=\"positionStyle\" @click=\"onClickHandler\"&gt;\n    &lt;div class=\"el-notification__title\"&gt;\n      {{ title }}\n    &lt;/div&gt;\n\n    &lt;div class=\"el-notification__message\"&gt;\n      {{ message }}\n    &lt;/div&gt;\n\n    &lt;button\n      v-if=\"showClose\"\n      class=\"el-notification__close-button\"\n      @click=\"onCloseHandler\"\n    &gt;&lt;/button&gt;\n  &lt;/div&gt;\n&lt;/template&gt;\n&lt;script setup&gt;\nconst instance = getCurrentInstance()\nconst visible = ref(true)\nconst verticalOffsetVal = ref(props.verticalOffset)\n\nconst typeClass = computed(() =&gt; {\n  return props.type ? `el-icon-${props.type}` : ''\n})\n\nconst horizontalClass = computed(() =&gt; {\n  return props.position.endsWith('right') ? 'right' : 'left'\n})\n\nconst verticalProperty = computed(() =&gt; {\n  return props.position.startsWith('top') ? 'top' : 'bottom'\n})\n\nconst positionStyle = computed(() =&gt; {\n  return {\n    [verticalProperty.value]: `${verticalOffsetVal.value}px`\n  }\n})\n&lt;/script&gt;\n\n&lt;style lang=\"scss\"&gt;\n.el-notification {\n  position: fixed;\n  right: 10px;\n  top: 50px;\n  width: 330px;\n  padding: 14px 26px 14px 13px;\n  border-radius: 8px;\n  border: 1px solid #ebeef5;\n  background-color: #fff;\n  box-shadow: 0 2px 12px 0 rgba(0, 0, 0, 0.1);\n  overflow: hidden;\n}\n&lt;/style&gt;\n</code></pre><p>然后我们新增测试代码，设置弹窗是否显示关闭按钮以及关闭弹窗之后的回调函数。我们希望点击关闭按钮之后，就能够正确执行传入的onClose函数。</p><pre><code class=\"language-javascript\">it('set the showClose ', () =&gt; {\n    const showClose = true\n    const wrapper = mount(Notification, {\n      props: {\n        showClose\n      }\n    })\n    expect(wrapper.find('.el-notification__closeBtn').exists()).toBe(true)\n    expect(wrapper.find('.el-icon-close').exists()).toBe(true)\n  })\n\n  it('点击关闭按钮', async () =&gt; {\n    const showClose = true\n    const wrapper = mount(Notification, {\n      props: {\n        showClose\n      }\n    })\n    const closeBtn = wrapper.get('.el-notification__closeBtn')\n    await closeBtn.trigger('click')\n    expect(wrapper.get('.el-notification').isVisible()).toBe(false)\n  })\n\n  it('持续时间之后自动管理', async () =&gt; {\n    jest.useFakeTimers()\n\n    const wrapper = mount(Notification, {\n      props: {\n        duration: 1000\n      }\n    })\n    jest.runTimersToTime(1000)\n    await flushPromises()\n    expect(wrapper.get('.el-notification').isVisible()).toBe(false)\n     })\n</code></pre><p>到这里，Notification组件测试的主体逻辑就实现完毕了，我们拥有了一个能够显示在右上角的组件，具体效果你可以参考后面这张截图。</p><p><img src=\"https://static001.geekbang.org/resource/image/aa/04/aa1506d30d0b4d641aa7175c2a4a5004.jpg?wh=1920x972\" alt=\"图片\"></p><p>进行到这里，距离完成整体设计我们还差两个步骤。</p><p>首先，弹窗类的组件都需要直接渲染在body标签下面，弹窗类组件由于布局都是绝对定位，如果在组件内部渲染，组件的css属性（比如Transform）会影响弹窗组件的渲染样式，为了避免这种问题重复出现，弹窗组件Dialog、Notification都需要渲染在body内部。</p><p>Dialog组件可以直接使用Vue3自带的Teleport，很方便地渲染到body之上。在下面的代码中, 我们用teleport组件把dialog组件包裹之后，通过to属性把dialog渲染到body标签内部。</p><pre><code class=\"language-javascript\">  &lt;teleport\n    :disabled=\"!appendToBody\"\n    to=\"body\"\n  &gt;\n    &lt;div class=\"el-dialog\"&gt;\n      &lt;div class=\"el-dialog__content\"&gt;\n        &lt;slot /&gt;\n      &lt;/div&gt;\n    &lt;/div&gt;\n  &lt;/teleport&gt;\n</code></pre><p>这时我们使用浏览器调试窗口，就可以看到Dialog标签已经从当前组件移动到了body标签内部，如下图所示。</p><p><img src=\"https://static001.geekbang.org/resource/image/d9/61/d9199199590871f811309f4c78963761.jpg?wh=1920x902\" alt=\"图片\"></p><p>但是Notification组件并不会在当前组件以组件的形式直接调用，我们需要像Element3一样，能够使用js函数动态创建Notification组件，<strong>给Vue的组件提供Javascript的动态渲染方法，这是弹窗类组件的特殊需求</strong>。</p><h2>组件渲染优化</h2><p>我们先把测试代码写好，具体如下。代码中分别测试函数创建组件，以及不同配置和样式的通知组件。</p><pre><code class=\"language-xml\">it('函数会创建组件', () =&gt; {\n  const instanceProxy = Notification('foo')\n  expect(instanceProxy.close).toBeTruthy()\n})\n\nit('默认配置 ', () =&gt; {\n  const instanceProxy = Notification('foo')\n\n  expect(instanceProxy.$props.position).toBe('top-right')\n  expect(instanceProxy.$props.message).toBe('foo')\n  expect(instanceProxy.$props.duration).toBe(4500)\n  expect(instanceProxy.$props.verticalOffset).toBe(16)\n})\ntest('字符串信息', () =&gt; {\n  const instanceProxy = Notification.info('foo')\n\n  expect(instanceProxy.$props.type).toBe('info')\n  expect(instanceProxy.$props.message).toBe('foo')\n})\ntest('成功信息', () =&gt; {\n  const instanceProxy = Notification.success('foo')\n\n  expect(instanceProxy.$props.type).toBe('success')\n  expect(instanceProxy.$props.message).toBe('foo')\n})\n</code></pre><p>现在测试写完后还是会报错，因为现在Notification函数还没有定义，我们要能通过Notification函数动态地创建Vue的组件，而不是在template中使用组件。</p><p>在<a href=\"https://time.geekbang.org/column/article/444283\">JSX那一讲</a>中我们讲过，template的本质就是使用h函数创建虚拟Dom，如果我们自己想动态创建组件时，使用相同的方式即可。</p><p>在下面的代码中我们使用Notification函数去执行createComponent函数，使用h函数动态创建组件，实现了动态组件的创建。</p><pre><code class=\"language-javascript\">function createComponent(Component, props, children) {\n  const vnode = h(Component, { ...props, ref: MOUNT_COMPONENT_REF }, children)\n  const container = document.createElement('div')\n  vnode[COMPONENT_CONTAINER_SYMBOL] = container\n  render(vnode, container)\n  return vnode.component\n}\nexport function Notification(options) {\n  return createNotification(mergeProps(options))\n}\n\nfunction createNotification(options) {\n  const instance = createNotificationByOpts(options)\n  setZIndex(instance)\n  addToBody(instance)\n  return instance.proxy\n}\n</code></pre><p>创建组件后，由于Notification组件同时可能会出现多个弹窗，所以我们需要使用数组来管理通知组件的每一个实例，每一个弹窗的实例都存储在数组中进行管理。</p><p>下面的代码里，我演示了怎样用数组管理弹窗的实例。Notification函数最终会暴露给用户使用，在Notification函数内部我们通过createComponent函数创建渲染的容器，然后通过createNotification创建弹窗组件的实例，并且维护在instanceList中。</p><pre><code class=\"language-javascript\">const instanceList = []\nfunction createNotification(options) {\n  ...\n  addInstance(instance)\n  return instance.proxy\n}  \nfunction addInstance(instance) {\n  instanceList.push(instance)\n}\n;['success', 'warning', 'info', 'error'].forEach((type) =&gt; {\n  Notification[type] = (options) =&gt; {\n    if (typeof options === 'string' || isVNode(options)) {\n      options = {\n        message: options\n      }\n    }\n    options.type = type\n    return Notification(options)\n  }\n})\n\n// 有了instanceList， 可以很方便的关闭所有信息弹窗\nNotification.closeAll = () =&gt; {\n  instanceList.forEach((instance) =&gt; {\n    instance.proxy.close()\n    removeInstance(instance)\n  })\n}\n</code></pre><p>最后，我带你简单回顾下我们都做了什么。在正式动手实现弹窗组件前，我们分析了弹窗类组件的风格。弹窗类组件主要负责用户交互的反馈。根据显示的级别不同，它可以划分成不同的种类：既有覆盖全屏的弹窗Dialog，也有负责提示消息的Notification。</p><p>这些组件除了负责渲染传递的数据和方法之外，还需要能够脱离当前组件进行渲染，<strong>防止当前组件的css样式影响布局</strong>。因此Notification组件需要渲染到body标签内部，而Vue提供了Teleport组件来完成这个任务，我们通过Teleport组件就能把内部的组件渲染到指定的dom标签。</p><p>之后，我们需要给组件提供JavaScript调用的方法。我们可以使用Notification()\b的方式动态创建组件，利用createNotification即可动态创建Vue组件的实例。</p><p>对于弹窗组件来说可以这样操作：首先通过createNotification函数创建弹窗的实例，并且给每个弹窗设置好唯一的id属性，然后存储在数组中进行管理。接着，我们通过对createNotification函数返回值的管理，即可实现弹窗动态的渲染、更新和删除功能。</p><h2>总结</h2><p>正文里已经详细讲解和演示了弹窗组件的设计，所以今天的总结我想变个花样，再给你说说TDD的事儿。</p><p>很多同学会觉得写测试代码要花一定成本，有畏难心理，觉得自己不太会写测试，这些“假想”给我们造成了“TDD很难实施”的错觉。实际上入门TDD并没有这么难。按照我的实践经验来看，先学会怎么写测试，再学习怎么重构，基本上就可以入门写TDD了。</p><p>就拿我们这讲的实践来说，我们再次应用了<strong>测试驱动开发</strong>这个方式来实现弹窗组件，把整体需求拆分成一个个子任务，逐个击破。根据设计的需求写好测试代码之后，测试代码就会检查我们的业务逻辑有没有实现，指导我们做相应的修改。</p><p>咱们的实践过程抽象出来，一共包括四个步骤：写测试 -&gt; 运行测试(报错) -&gt; 写代码让测试通过 -&gt; 重构的方式。这样的开发模式，今后你在设计组件库时也可以借鉴，不但有助于提高代码的质量和可维护性，还能让代码有比较高的代码测试覆盖率。</p><h2>思考题</h2><p>最后留一个思考题，现在我们设计的Notification组件的message只能支持文本消息，如果想支持传入其他组件，应该如何实现？</p><p>欢迎你在评论去分享你的答案，也欢迎你把这一讲的内容分享给你的同事和朋友们，我们下一讲再见。</p>",
        article_title: "23 | 弹窗：如何设计一个弹窗组件？",
      },
      {
        title: "24｜树：如何设计一个树形组件？",
        id: 468036,
        content:
          '<p>你好，我是大圣。</p><p>上一讲，我们一起学习了弹窗组件的设计与实现，这类组件的主要特点是需要渲染在最外层body标签之内，并且还需要支持JavaScript动态创建和调用组件。相信学完上一讲，你不但会对弹窗类组件的实现加深理解，也会对TDD模式更有心得。</p><p>除了弹窗组件，树形组件我们在前端开发中经常用到，所以今天我就跟你聊一下树形组件的设计思路跟实现细节。</p><h2>组件功能分析</h2><p>我们进入<a href="https://e3.shengxinjing.cn/#/component/tree">Element3的Tree组件文档页面</a>，现在我们对Vue的组件如何设计和实现已经很熟悉了，我重点挑跟之前组件设计不同的地方为你讲解。</p><p>在设计新组件的时候，我们需要重点考虑的就是树形组件和之前我们之前的Container、Button、Notification有什么区别。树形组件的主要特点是可以无限层级、这种需求在日常工作和生活中其实很常见，比如后台管理系统的菜单管理、文件夹管理、生物分类、思维导图等等。</p><p><img src="https://static001.geekbang.org/resource/image/0y/f6/0yy86b867a51890c7ea1ebbaf11f90f6.png?wh=1814x744" alt="图片"></p><p>根据上图所示，我们可以先拆解出树形组件的功能需求。</p><p>首先，树形组件的节点可以无限展开，父节点可以展开和收起节点，并且每一个节点有一个复选框，可以切换当前节点和所有子节点的选择状态。另外，同一级所有节点选中的时候，父节点也能自动选中。</p><!-- [[[read_end]]] --><p>下面的代码是Element3的Tree组件使用方式，所有的节点配置都是一个data对象实现的。每个节点里的label用来显示文本；expaned显示是否展开；checked用来决定复选框选中列表，data数据内部的children属性用来配置子节点数组，子节点的数据结构和父节点相同，可以递归实现。</p><pre><code class="language-javascript">&lt;el-tree\n  :data="data"\n  show-checkbox\n  v-model:expanded="expandedList"\n  v-model:checked="checkedList"\n  :defaultNodeKey="defaultNodeKey"\n&gt;\n&lt;/el-tree&gt;\n&lt;script&gt;\n  export default {\n    data() {\n      return {\n        expandedList: [4, 5],\n        checkedList: [5],\n        data: [\n          {\n            id: 1,\n            label: \'一级 1\',\n            children: [\n              {\n                id: 4,\n                label: \'二级 1-1\',\n                children: [\n                  {\n                    id: 9,\n                    label: \'三级 1-1-1\'\n                  },\n                  {\n                    id: 10,\n                    label: \'三级 1-1-2\'\n                  }\n                ]\n              }\n            ]\n          },\n          {\n            id: 2,\n            label: \'一级 2\',\n            children: [\n              {\n                id: 5,\n                label: \'二级 2-1\'\n              },\n              {\n                id: 6,\n                label: \'二级 2-2\'\n              }\n            ]\n          }\n        ],\n        defaultNodeKey: {\n          childNodes: \'children\',\n          label: \'label\'\n        }\n      }\n    }\n  }\n  \n&lt;/script&gt;\n\n</code></pre><h2>递归组件</h2><p>这里父节点和子节点的样式操作完全一致，并且可以无限嵌套，这种需求需要组件递归来实现，也就是组件内部渲染自己渲染自己。</p><p>想要搞定递归组件，我们需要先明确什么是递归，递归的概念也是我们前端进阶过程中必须要掌握的知识点。</p><p>前端的场景中，树这个数据结构出现的频率非常高，浏览器渲染的页面是Dom树，我们内部管理的是虚拟Dom树，<strong>树形结构是一种天然适合递归的数据结构</strong>。</p><p>我们先来做一个算法题感受一下，我们来到<a href="https://leetcode-cn.com/problems/invert-binary-tree">leetcode第226题反转二叉树</a>，题目的描述很简单，就是把属性结构反转，下面是题目的描述：</p><blockquote>\n<p>每一个节点的val属性代表显示的数字，left指向左节点，right指向右节点，如何实现invertTree去反转这一个二叉树，也就是所有节点的left和right互换位置呢？</p>\n</blockquote><pre><code class="language-javascript">\n输入     \n     4\n   /   \\\n  2     7\n / \\   / \\\n1   3 6   9\n输出\n     4\n   /   \\\n  7     2\n / \\   / \\\n9   6 3   1\n节点的构造函数\n/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n</code></pre><p>输入的左右位置正好相反，而且每个节点的结构都相同，这就是非常适合递归的场景。递归的时候，我们首先需要思考递归的核心逻辑如何实现，这里就是两个节点如何交换，然后就是递归的终止条件，否则递归函数就会进入死循环。</p><p>下面的代码中，设置invertTree函数的终止条件是root是null的时候，也就是如果节点不存在的时候不需要反转。这里我们只用了一行解构赋值的代码就实现了，值得注意的是右边的代码中我们递归调用了inverTree去递归执行，最终实现了整棵树的反转。</p><pre><code class="language-javascript">var invertTree = function(root) {\n  // 递归 终止条件\n  if(root==null) {\n    return root\n  }\n  // 递归的逻辑\n  [root.left, root.right] = [invertTree(root.right), invertTree(root.left)]\n  return root\n}\n</code></pre><p>树形组件的数据结构内部的children可以无限嵌套，处理这种数据结构，就需要使用递归的算法思想。有了上面这个算法题的基础后，我们后面再学习树形组件如何实现就能更加顺畅了。</p><h2>组件实现</h2><p>首先我们进入到Element3的tree文件夹内部，然后找到tree.vue文件。tree.vue 是组件的入口容器，用于接收和处理数据，并将数据传递给 TreeNode.vue；TreeNode.vue 负责渲染树形组件的选择框、标题和递归渲染子元素。</p><p>在下面的代码中，我们提供了el-tree的容器，还导入了el-tree-node进行渲染。tree.vue通过provide向所有子元素提供tree的数据，通过useExpand判断树形结构的展开状态，并且用到了watchEffect去向组件外部通知update:expanded事件。</p><pre><code class="language-javascript">&lt;template&gt;\n  &lt;div class="el-tree"&gt;\n    &lt;el-tree-node v-for="child in tree.root.childNodes" :node="child" :key="child.id"&gt;&lt;/el-tree-node&gt;\n  &lt;/div&gt;\n&lt;/template&gt;\n\n&lt;script&gt;\nimport ElTreeNode from \'./TreeNode.vue\'\nconst instance = getCurrentInstance()\nconst tree = new Tree(props.data, props.defaultNodeKey, {\n  asyncLoadFn: props.asyncLoadFn,\n  isAsync: props.async\n})\nconst state = reactive({\n  tree\n})\nprovide(\'elTree\', instance)\nuseTab()\nuseExpand(props, state)\n\nfunction useExpand(props, state) {\n  const instance = getCurrentInstance()\n  const { emit } = instance\n\n  if (props.defaultExpandAll) {\n    state.tree.expandAll()\n  }\n\n  watchEffect(() =&gt; {\n    emit(\'update:expanded\', state.tree.expanded)\n  })\n\n  watchEffect(() =&gt; {\n    state.tree.setExpandedByIdList(props.expanded, true)\n  })\n\n  onMounted(() =&gt; {\n    state.tree.root.expand(true)\n  })\n}\n  \n\n&lt;/script&gt;\n</code></pre><p>然后我们进入到Tree.Node.vue文件中，tree-node组件是树组件的核心，一个TreeNode组件包含四个部分：展开按钮、文本的多选框、每个节点的标题和递归的children子节点。</p><p>我们先来看 TreeNode.vue 的模板基本结构，可以把下面的div标签分成四个部分：el-tree-node__content负责每个树节点的渲染，第一个span就是渲染展开符；el-checkbox组件负责显示复选框，并且绑定了node.isChecked属性；el-node__contentn负责渲染树节点的标题；el-tree__children负责递归渲染el-tree-node节点，组件内部渲染自己，这就是组件递归的写法。</p><pre><code class="language-xml">&lt;div\n    v-show="node.isVisable"\n    class="el-tree-node"\n    :class="{\n      \'is-expanded\': node.isExpanded,\n      \'is-current\': elTree.proxy.dragState.current === node,\n      \'is-checked\': node.isChecked,\n    }"\n    role="TreeNode"\n    ref="TreeNode"\n    :id="\'TreeNode\' + node.id"\n    @click.stop="onClickNode"\n  &gt;\n    &lt;div class="el-tree-node__content"&gt; \n      &lt;span\n        :class="[\n          { expanded: node.isExpanded, \'is-leaf\': node.isLeaf },\n          \'el-tree-node__expand-icon\',\n          elTree.props.iconClass\n        ]"\n        @click.stop="\n          node.isLeaf ||\n            (elTree.props.accordion ? node.collapse() : node.expand())\n        "&gt;\n      &lt;/span&gt;\n      &lt;el-checkbox\n        v-if="elTree.props.showCheckbox"\n        :modelValue="node.isChecked"\n        @update:modelValue="onChangeCheckbox"\n        @click="elTree.emit(\'check\', node, node.isChecked, $event)"\n      &gt;\n      &lt;/el-checkbox&gt;\n      &lt;el-node-content\n        class="el-tree-node__label"\n        :node="node"\n      &gt;&lt;/el-node-content&gt;\n    &lt;/div&gt;\n      &lt;div\n        class="el-tree-node__children"\n        v-show="node.isExpanded"\n        v-if="!elTree.props.renderAfterExpand || node.isRendered"\n        role="group"\n        :aria-expanded="node.isExpanded"\n      &gt;\n        &lt;el-tree-node\n          v-for="child in node.childNodes"\n          :key="child.id"\n          :node="child"\n        &gt;\n        &lt;/el-tree-node&gt;\n      &lt;/div&gt;\n  &lt;/div&gt;\n</code></pre><p>然后我们看下tree-node中我们需要处理的数据有哪些。下面的代码中，我们先通过inject注入tree组件最完成的配置。然后在点击节点的时候，通过判断elTree的全局配置，去决定点击之后的切换功能，并且在展开和checkbox切换的同时，通过emit对父组件触发事件。</p><pre><code class="language-javascript">const elTree = inject(\'elTree\')\nconst onClickNode = (e) =&gt; {\n  !elTree.props.expandOnClickNode ||\n    props.node.isLeaf ||\n    (elTree.props.accordion ? props.node.collapse() : props.node.expand())\n\n  !elTree.props.checkOnClickNode ||\n    props.node.setChecked(undefined, elTree.props.checkStrictly)\n\n  elTree.emit(\'node-click\', props.node, e)\n  elTree.emit(\'current-change\', props.node, e)\n  props.node.isExpanded\n    ? elTree.emit(\'node-expand\', props.node, e)\n    : elTree.emit(\'node-collapse\', props.node, e)\n}\n\nconst onChangeCheckbox = (e) =&gt; {\n  props.node.setChecked(undefined, elTree.props.checkStrictly)\n  elTree.emit(\'check-change\', props.node, e)\n}\n</code></pre><p>\b<br>\n到这里，树结构的渲染其实就结束了。</p><p>但是有些场景我们需要对树节点的渲染内容进行自定。比如后面这段代码，我们在节点的右侧加上append和delete操作按钮，这种需求在菜单树的管理中很常见。</p><p>这个时候我们节点需要支持内容的自定义，然后我们注册了el-node-content组件。这个组件使用起来非常简单，由于我们还需要支持节点的自定义渲染，所以要把这部分抽离成组件。当slots.default为函数的时候，返回函数的执行内容；或者传递的renderContent是函数的话，也要返回函数执行的结果。</p><pre><code class="language-javascript">import { TreeNode } from \'./entity/TreeNode\'\nimport { inject, h } from \'vue\'\n\nrender(ctx) {\n  const elTree = inject(\'elTree\')\n  if (typeof elTree.slots.default === \'function\') {\n    return elTree.slots.default({ node: ctx.node, data: ctx.node.data.raw })\n  } else if (typeof elTree.props.renderContent === \'function\') {\n    return elTree.props.renderContent({\n      node: ctx.node,\n      data: ctx.node.data.raw\n    })\n  }\n\n  return h(\'span\', ctx.node.label)\n}\n</code></pre><p>这样，用户就可以利用render-content属性传递一个函数的方式，去实现内容的自定义渲染。</p><p>我们还是结合代码例子做理解，下面的代码中用了render-content的方式返回树形结构的渲染结果，render-content传递的函数内部会根据node和data数据，返回对应的标题，并且新增了两个el-button组件。</p><pre><code class="language-xml">&lt;div class="custom-tree-container"&gt;\n  &lt;div class="block"&gt;\n    &lt;p&gt;使用 render-content&lt;/p&gt;\n    &lt;el-tree\n      :data="data1"\n      show-checkbox\n      default-expand-all\n      :expand-on-click-node="false"\n      :render-content="renderContent"\n    &gt;\n    &lt;/el-tree&gt;\n  &lt;/div&gt;\n&lt;/div&gt;\n&lt;script&gt;\nfunction renderContent({ node, data }) {\n  return (\n    &lt;span class="custom-tree-node"&gt;\n      &lt;span&gt;{data.label}&lt;/span&gt;\n      &lt;span&gt;\n        &lt;el-button\n          size="mini"\n          type="text"\n          onClick={() =&gt; this.append(node, data)}\n        &gt;\n          Append\n        &lt;/el-button&gt;\n        &lt;el-button\n          size="mini"\n          type="text"\n          onClick={() =&gt; this.remove(node, data)}\n        &gt;\n          Delete\n        &lt;/el-button&gt;\n      &lt;/span&gt;\n    &lt;/span&gt;\n  )\n}\n&lt;/script&gt;\n</code></pre><p>上面的代码会渲染出下面的示意图的效果。<br>\n<img src="https://static001.geekbang.org/resource/image/ce/59/cef8cb4d740cfcc0984e546761e33b59.png?wh=1800x940" alt="图片"></p><p>最后，我们还可以对树实现更多操作方式的支持。</p><p>比如我们可以支持树形结构的拖拽修改、可以把任何任意节点拖拽到其他树形内部、修改整个树形结构的内容。想要实现这些功能，我们就需要监听节点的drag-over、drag-leave等拖拽事件，在drop事件执行的时候，把拖拽的节点数据，复制给拖拽的节点中完成修改即可。这部分代码，同学们可以自行去Element3拓展学习。</p><h2>总结</h2><p>今天的主要内容就讲完啦，我们来总结一下今天学到的内容吧。</p><p>首先我们分析了树形组件的设计需求、我们需要递归组件的形式去实现树形节点的无限嵌套，然后我们通过算法题的形式掌握了递归的概念，这个概念在Vue组件中也是一样的，每个组件返回name后，可以通过这个name在组件内部来调用自己，这样就可以很轻松地实现Tree组件。</p><p>tree组件具体要分成三个组件进行实现。最外层的tree组件负责整个树组件的容器，内部会通过provide方法为子元素提供全局的配置和操作方法。每个tree的配置中的title、expanded、checked树形作为树组件显示的主体内容。children是一个深层嵌套的数组，我们需要用递归组件的方式渲染出完成的树，tree内部的tree-node组件就负责递归渲染出完成的树形结构。</p><p>最后，我们想支持树节点的自定义渲染，这就需要在teree-node内部定制tree-node-content组件，用来渲染用户传递的render-content或者默认的插槽函数。</p><p>树形数据在我们日常开发项目中也很常见，菜单、城市选择、权限等数据都很适合树形结构，学会树形结构的处理，能很好地帮助我们在日常开发中应对更复杂的需求。</p><h2>思考题</h2><p>最后留一个思考题吧。我们的树形组件现在是全部节点的渲染，如果我们有1000个节点要渲染，如何对这个树形节点做性能优化呢？</p><p>欢迎你在评论区分享你的答案，也欢迎你把这一讲的内容分享给你的同事和朋友们，我们下一讲再见。</p>',
        article_title: "24｜树：如何设计一个树形组件？",
      },
      {
        title: "25｜表格：如何设计一个表格组件？",
        id: 468917,
        content:
          '<p>你好，我是大圣。</p><p>上一讲我们实现了树形组件，树形组件的主要难点就是对无限嵌套数据的处理。今天我们来介绍组件库中最复杂的表格组件，表格组件在项目中负责列表数据的展示，尤其是在管理系统中，比如用户信息、课程订单信息的展示，都需要使用表格组件进行渲染。</p><p>关于表单的具体交互形式和复杂程度，你可以访问<a href="https://element-plus.gitee.io/zh-CN/component/table.html">ElementPlus</a>、<a href="https://www.naiveui.com/zh-CN/os-theme/components/data-table">NaiveUi</a>、 <a href="https://www.antdv.com/components/table-cn">AntDesignVue</a>这三个主流组件库中的表格组件去体验，并且社区还提供了单独的<a href="https://surely.cool">复杂表格组件</a>，这一讲我就给你详细说说一个复杂表格组件如何去实现。</p><h2>表格组件</h2><p>大部分组件库都会内置表格组件，这是总后台最常用的组件之一，用于展示大量的结构化的数据。html也提供了内置的表格标签，由&nbsp;&lt;table&gt; 、&lt;thead&gt; 、&lt;tbody&gt; 、&lt;tr&gt; 、&lt;th&gt; 、&lt;td&gt;&nbsp;这些标签来组成一个最简单的表格标签。</p><p>我们先研究一下html的table标签。下面的代码中，table 标签负责表格的容器，thead负责表头信息的容器，tbody负责表格的主体，tr标签负责表格的每一行，th和td分别负责表头和主体的单元格。</p><p>其实标准的表格系列标签，跟 div+css 实现是有很大区别的。比如表格在做单元格合并时，要提供原生属性，这时候用 div 就很麻烦了。另外，它们的渲染原理上也有一定的区别，每一列的宽度会保持一致。</p><!-- [[[read_end]]] --><pre><code class="language-xml">&lt;table&gt;\n  &lt;thead&gt;\n    &lt;tr&gt;\n      &lt;th&gt;课程&lt;/th&gt;\n      &lt;th&gt;价格&lt;/th&gt;\n    &lt;/tr&gt;\n  &lt;/thead&gt;\n  &lt;tbody&gt;\n    &lt;tr&gt;\n      &lt;td&gt;重学前端&lt;/td&gt;\n      &lt;td&gt;129&lt;/td&gt;\n    &lt;/tr&gt;\n    &lt;tr&gt;\n      &lt;td&gt;玩转Vue3全家桶&lt;/td&gt;\n      &lt;td&gt;129&lt;/td&gt;\n    &lt;/tr&gt;\n  &lt;/tbody&gt;\n&lt;/table&gt;\n</code></pre><p>简单的表格数据渲染并不需要组件，我们直接使用标准的 table 系列标签就可以。但有的时候，除了呈现数据，也会带有一些额外的功能要求，比如嵌套列、性能优化等。这时候组件的好处就很明显了，它能帮我们省去这些基础的工作。</p><p>表格组件的使用风格，从设计上说也分为了两个方向。一个方向是完全由数据驱动，这里我们可以参考Naive Ui的使用方式，n-data-table标签负责容器，直接通过data属性传递数据，通过columns传递表格的表头配置。</p><p>下面的代码中，我们在colums中去配置每行需要显示的属性，通过render函数可以返回定制化的结果，再使用h函数返回Button，渲染出对应的按钮。</p><pre><code class="language-xml">&lt;template&gt;\n  &lt;n-data-table :columns="columns" :data="data" :pagination="pagination" /&gt;\n&lt;/template&gt;\n&lt;script&gt;\nimport { h, defineComponent } from \'vue\'\nimport { NTag, NButton, useMessage } from \'naive-ui\'\nconst createColumns = ({ sendMail }) =&gt; {\n  return [\n    {\n      title: \'Name\',\n      key: \'name\',\n      align: \'center\'\n    },\n    {\n      title: \'Age\',\n      key: \'age\'\n    },\n    {\n      title: \'Action\',\n      key: \'actions\',\n      render (row) {\n        return h(\n          NButton,\n          {\n            size: \'small\',\n            onClick: () =&gt; sendMail(row)\n          },\n          { default: () =&gt; \'Send Email\' }\n        )\n      }\n    }\n  ]\n}\nconst createData = () =&gt; [\n  {\n    key: 0,\n    name: \'John Brown\',\n    age: 32,\n    tags: [\'nice\', \'developer\']\n  },\n  {\n    key: 1,\n    name: \'Jim Green\',\n    age: 42,\n  },\n  {\n    key: 2,\n    name: \'Joe Black\',\n    age: 32\n  }\n]\nexport default defineComponent({\n  setup () {\n    const message = useMessage()\n    return {\n      data: createData(),\n      columns: createColumns({\n        sendMail (rowData) {\n          message.info(\'send mail to \' + rowData.name)\n        }\n      }),\n      pagination: {\n        pageSize: 10\n      }\n    }\n  }\n})\n&lt;/script&gt;\n\n</code></pre><p>还有一种是Element3现在使用的风格，配置数据之后，具体数据的展现形式交给子元素来决定，把columns当成组件去使用，我们仍然通过例子来加深理解。</p><p>下面的代码中，我们配置完data后，使用el-table-colum组件去渲染组件的每一列，通过slot的方式去实现定制化的渲染。这两种风格各有优缺点，我们后面还会结合Elemnt3的源码进行讲解.</p><pre><code class="language-xml">&lt;el-table :data="tableData" border style="width: 100%"&gt;\n  &lt;el-table-column fixed prop="date" label="日期" width="150"&gt;\n  &lt;/el-table-column&gt;\n  &lt;el-table-column prop="name" label="姓名" width="120"&gt; &lt;/el-table-column&gt;\n  &lt;el-table-column prop="province" label="省份" width="120"&gt; &lt;/el-table-column&gt;\n  &lt;el-table-column prop="city" label="市区" width="120"&gt; &lt;/el-table-column&gt;\n  &lt;el-table-column prop="address" label="地址" width="300"&gt; &lt;/el-table-column&gt;\n  &lt;el-table-column prop="zip" label="邮编" width="120"&gt; &lt;/el-table-column&gt;\n  &lt;el-table-column fixed="right" label="操作" width="100"&gt;\n    &lt;template v-slot="scope"&gt;\n      &lt;el-button @click="handleClick(scope.row)" type="text" size="small"\n        &gt;查看&lt;/el-button\n      &gt;\n      &lt;el-button type="text" size="small"&gt;编辑&lt;/el-button&gt;\n    &lt;/template&gt;\n  &lt;/el-table-column&gt;\n&lt;/el-table&gt;\n&lt;script&gt;\n  export default {\n    methods: {\n      handleClick(row) {\n        console.log(row)\n      }\n    },\n    data() {\n      return {\n        tableData: [\n          {\n            date: \'2016-05-02\',\n            name: \'王小虎\',\n            province: \'上海\',\n            city: \'普陀区\',\n            address: \'上海市普陀区金沙江路 1518 弄\',\n            zip: 200333\n          },\n          {\n            date: \'2016-05-04\',\n            name: \'王小虎\',\n            province: \'上海\',\n            city: \'普陀区\',\n            address: \'上海市普陀区金沙江路 1517 弄\',\n            zip: 200333\n          },\n          {\n            date: \'2016-05-01\',\n            name: \'王小虎\',\n            province: \'上海\',\n            city: \'普陀区\',\n            address: \'上海市普陀区金沙江路 1519 弄\',\n            zip: 200333\n          },\n          {\n            date: \'2016-05-03\',\n            name: \'王小虎\',\n            province: \'上海\',\n            city: \'普陀区\',\n            address: \'上海市普陀区金沙江路 1516 弄\',\n            zip: 200333\n          }\n        ]\n      }\n    }\n  }\n&lt;/script&gt;\n</code></pre><h2>表格组件的扩展</h2><p>复杂的表格组件需要对表格的显示和操作进行扩展。</p><p>首先是从表格的显示上扩展，我们可以支持表头或者某一列的锁定，在滚动的时候锁定列不受影响。一个table标签很难实现这个效果，这时候我们就需要分为table-head和table-body两个组件进行维护，通过colgroup组件限制每一列的宽度实现表格的效果，而且表头还需要支持表头嵌套。</p><p>下面的示意图中，表头就是被分组显示的。</p><p><img src="https://static001.geekbang.org/resource/image/f6/4a/f60dac2bf267c10d5f230e8cb03b744a.png?wh=1764x1282" alt="图片"></p><p>我们还是先分析一下需求。对于表格的操作来说，首先要和树组件一样，每一样支持复选框进行选中，方便进行批量的操作。另外，表头还需要支持点击事件，点击后对当前这一列实现排序的效果，同时每一列还可能会有详情数据的展开，甚至表格内部还会有树形组件的嵌套、底部的数据显示等等。</p><p>把这些需求组合在一起，表格就成了组件库中最复杂的组件。我们需要先分解需求，把组件内部拆分成table、table-column、table-body、table-header组件，我们挨个来看一下。</p><p>首先，在table组件的内部，我们使用table-body和table-header构成组件。table提供了整个表格的标签容器；hidden-columns负责隐藏列的显示，并且通过table-store进行表格内部的状态管理。每当table中的table-store被修改后，table-header、table-body都需要重新渲染。</p><pre><code class="language-xml">&lt;template&gt;\n  &lt;div class="el-table"&gt;\n    &lt;div class="hidden-columns" ref="hiddenColumns"&gt;\n      &lt;slot&gt;&lt;/slot&gt;\n    &lt;/div&gt;\n    &lt;div class="el-table__header-wrapper"\n         ref="headerWrapper"&gt;\n      &lt;table-header ref="tableHeader"\n                    :store="store"&gt;\n      &lt;/table-header&gt;\n    &lt;/div&gt;\n    &lt;div class="el-table__body-wrapper"\n         ref="bodyWrapper"&gt;\n      &lt;table-body :context="context"\n                  :store="store"&gt;                  \n      &lt;/table-body&gt;\n    &lt;/div&gt;\n  &lt;/div&gt;\n&lt;/template&gt;\n</code></pre><p>然后在table组件的初始化过程中，我们首先使用createStore创建表格的store数据管理，并且通过TableLayout创建表格的布局，然后把store通过属性的方式传递给table-header和table-body。</p><pre><code class="language-xml">let table = getCurrentInstance()\n    const store = createStore(table, {\n      rowKey: props.rowKey,\n      defaultExpandAll: props.defaultExpandAll,\n      selectOnIndeterminate: props.selectOnIndeterminate,\n      // TreeTable 的相关配置\n      indent: props.indent,\n      lazy: props.lazy,\n      lazyColumnIdentifier: props.treeProps.hasChildren || \'hasChildren\',\n      childrenColumnName: props.treeProps.children || \'children\',\n      data: props.data\n    })\n    table.store = store\n    const layout = new TableLayout({\n      store: table.store,\n      table,\n      fit: props.fit,\n      showHeader: props.showHeader\n    })\n    table.layout = layout\n\n</code></pre><p>再接着，table-header组件内部会接收传递的store，并且提供监听的事件，包括click，mousedown等鼠标操作后，计算出当前表头的宽高等数据进行显示。</p><pre><code class="language-xml">const instance = getCurrentInstance()\n    const parent = instance.parent\n    const storeData = parent.store.states\n    const filterPanels = ref({})\n    const {\n      tableLayout,\n      onColumnsChange,\n      onScrollableChange\n    } = useLayoutObserver(parent)\n    const hasGutter = computed(() =&gt; {\n      return !props.fixed &amp;&amp; tableLayout.gutterWidth\n    })\n    onMounted(() =&gt; {\n      nextTick(() =&gt; {\n        const { prop, order } = props.defaultSort\n        const init = true\n        parent.store.commit(\'sort\', { prop, order, init })\n      })\n    })\n    const {\n      handleHeaderClick,\n      handleHeaderContextMenu,\n      handleMouseDown,\n      handleMouseMove,\n      handleMouseOut,\n      handleSortClick,\n      handleFilterClick\n    } = useEvent(props, emit)\n    const {\n      getHeaderRowStyle,\n      getHeaderRowClass,\n      getHeaderCellStyle,\n      getHeaderCellClass\n    } = useStyle(props)\n    const { isGroup, toggleAllSelection, columnRows } = useUtils(props)\n\n    instance.state = {\n      onColumnsChange,\n      onScrollableChange\n    }\n    // eslint-disable-next-line\n    instance.filterPanels = filterPanels\n\n</code></pre><p>在table-body中，也是类似的实现方式和效果。不过table-body和table-header中的定制需求较多，我们需要用render函数来实现定制化的需求。</p><p>下面的代码中，我们利用h函数返回el-table__body的渲染，通过state中读取的columns数据依次进行数据的显示。</p><pre><code class="language-xml">render() {\n\n    return h(\n      \'table\',\n      {\n        class: \'el-table__body\',\n        cellspacing: \'0\',\n        cellpadding: \'0\',\n        border: \'0\'\n      },\n      [\n        hColgroup(this.store.states.columns.value),\n        h(\'tbody\', {}, [\n          data.reduce((acc, row) =&gt; {\n            return acc.concat(this.wrappedRowRender(row, acc.length))\n          }, []),\n          h(\n            ElTooltip,\n            {\n              modelValue: this.tooltipVisible,\n              content: this.tooltipContent,\n              manual: true,\n              effect: this.$parent.tooltipEffect,\n              placement: \'top\'\n            },\n            {\n              default: () =&gt; this.tooltipTrigger\n            }\n          )\n        ])\n      ]\n    )\n  }\n  \n</code></pre><p>整体表格组件的渲染逻辑和过程比较复杂。为了帮你抽丝剥茧，这节课我重点给你说说Element3中table标签的渲染过程，至于具体的表格实现代码，你可以课后参考Element3的源码。</p><p>表格组件除了显示的效果非常复杂、交互非常复杂之外，还有一个非常棘手的性能问题。由于表格是二维渲染，而且表格组件如果想支持表头或者某一列锁定的定制效果，内部需要渲染不止一个table标签。一旦数据量庞大之后，表格就成了最容易导致性能瓶颈的组件，那这种场景如何去做优化呢？</p><p>这里我们要快速回顾一下性能优化那一讲的思路：性能优化主要的思路就是如何能够减少计算量。比如我们的表格如果有1000行要显示，但是我们浏览器最多只能显示100条，其他的需要通过滚动条的方式进行滚动显示，屏幕之外，成千上万个dom元素就成了性能消耗的主要原因。</p><p>针对这种情况，我们可以考虑类似图片懒加载的方案，对屏幕之外的dom元素做懒渲染，也就是非常常见的<strong>虚拟列表解决方案</strong>。</p><p>在虚拟列表解决方案中，我们首先要获取窗口的高度、元素的高度以及当前滚动的距离，通过这些数据计算出当前屏幕显示出来的数据。然后创建这些元素标签，设置元素的transform属性模拟滚动效果。这样表面看是1000条数据在表格里显示，实际只渲染了屏幕中间的这100行数据，当我们滚动鼠标的同时，去维护这100个数据列表，这样就完成了标签过多的性能问题。</p><p>如果表格内部每一行的高度不同的话，我们就需要对每一个元素的高度进行估计。具体操作时，先进行渲染，然后等待渲染完毕之后获取高度并且缓存下来，即可实现虚拟列表元素高度的自适应。</p><h2>总结</h2><p>今天要我们学习了表格组件如何实现，我给你做个总结吧。</p><p>表格组件是组件库中最复杂的组件，核心的难点除了<strong>数据的嵌套渲染</strong>和<strong>复杂的交互</strong>之外，<strong>复杂的dom节点</strong>也是表格的特点之一。我们通过对table-header、table-body和table-footer的组件分析，掌握了表格组件设计思路的实现细节。</p><p>除此之外，表格也是最容易导致页面卡顿的组件，所以我们除了数据驱动渲染之外，还需要考虑通过虚拟滚动的方式进行渲染的优化，这也是列表数据常见的优化策略，属于懒渲染的解决方案。</p><p>无论数据有多少行，我们只渲染用户可视窗口之内的，控制top的属性来模拟滚动效果，通过computed计算出需要渲染的数据。最后，我还想提醒你注意，虚拟滚动也是面试的热门解决方案，你一定要手敲一遍才能加深理解。</p><h2>思考题</h2><p>最后留个思考题吧，你现在基础的复杂项目或者组件库中，有哪些组件适合用虚拟滚动做性能优化呢？欢迎你在评论区分享你的答案，也欢迎你把这一讲分享给你的同事和朋友们，我们下一讲再见</p>',
        article_title: "25｜表格：如何设计一个表格组件？",
      },
      {
        title: "26｜文档：如何给你的组件库设计一个可交互式文档？",
        id: 468885,
        content:
          '<p>你好，我是大圣。</p><p>在我们实现了组件库核心的组件内容之后，我们就需要提供一个可交互的组件文档给用户使用和学习了。这个文档页面主要包含组件的描述，组件Demo示例的展示、描述和代码，并且每个组件都应该有详细的参数文档。</p><p>现在，我们从上述文档页包含的信息来梳理一下我们的需求。我们需要用最简洁的语法来写页面，还需要用最简洁的语法来展示 Demo + 源代码 + 示例描述。那么从语法上来说，首选就是 Markdown 无疑了，因为它既简洁又强大。</p><p>那在我们正式开始设计文档之前，我们还需要对齐一下。如果要展示 Demo 和源码的话，为了能更高效且低成本的维护，我们会把一个示例的 Demo + 源码 + 示例描述放到一个文件里，尽量多的去复用，这样可以减少需要维护的代码。而做示例展示的话，本质上可以说是跟 Markdown 的转译一致，都是 Markdown -&gt; HTML，只是转译的规则我们需要拓展一下。接下来我们就正式开始了。</p><h2>VuePress</h2><p>首先我们需要一个能基于Markdown构建文档的工具，我推荐VuePress。它是Vue官网团队维护的在线技术文档工具，样式和Vue的官方文档保持一致。</p><p>VuePress内置了Markdown的扩展，写文档的时候就是用Markdown语法进行渲染的。最让人省心的是，它可以直接在Markdown里面使用Vue组件，这就意味着我们可以直接在Markdown中写上一个个的组件库的使用代码，就可以直接展示运行效果了。</p><!-- [[[read_end]]] --><p>我们可以在项目中执行下面的代码安装VuePress的最新版本：</p><pre><code class="language-bash">yarn add -D vuepress@next\n</code></pre><p>然后我们新建docs目录作为文档目录，新建docs/README.md文件作为文档的首页。除了Markdown之外，我们可以直接使用VuePress的语法扩展对组件进行渲染。</p><pre><code class="language-yaml">\n---\nhome: true\nheroImage: /theme.png\ntitle: 网站快速成型工具\ntagline: 一套为开发者、设计师和产品经理准备的基于 Vue 3 的桌面端组件库\nheroText: 网站快速成型工具\nactions:\n  - text: 快速上手\n    link: /install\n    type: primary\n  - text: 项目简介\n    link: /button\n    type: secondary\nfeatures:\n  - title: 简洁至上\n    details: 以 Markdown 为中心的项目结构，以最少的配置帮助你专注于写作。\n  - title: Vue 驱动\n    details: 享受 Vue 的开发体验，可以在 Markdown 中使用 Vue 组件，又可以使用 Vue 来开发自定义主题。\n  - title: 高性能\n    details: VuePress 会为每个页面预渲染生成静态的 HTML，同时，每个页面被加载的时候，将作为 SPA 运行。\nfooter: powdered by vuepress and me\n---\n# 额外的信息\n\n\n\n</code></pre><p>我们在README.md中输入上面的内容，通过title配置网站的标题、actions配置快捷链接、features配置详情介绍，这样我们就拥有了下面的首页样式：</p><p><img src="https://static001.geekbang.org/resource/image/d8/ba/d8cd69f08b0932a670c74c80ef6699ba.png?wh=1920x1785" alt="图片"></p><p>然后我们进入docs/.vuepress/目录下，新建文件config.js，这是这个网站的配置页面。下面的代码我们配置了logo和导航navbar，页面顶部右侧就会有首页和安装两个导航。</p><pre><code class="language-javascript">module.exports = {\n  themeConfig:{\n    title:"Element3",\n    description:"vuepress搭建的Element3文档",\n    logo:"/element3.svg",\n    navbar:[\n      {\n        link:"/",\n        text:"首页"\n      },{\n        link:"/install",\n        text:"安装"\n      },\n    ]\n\n  }\n}\n</code></pre><p>然后我们创建docs/install.md文件，点击顶部导航之后，就会显示install.md的信息。我们在文稿中就可以直接写上介绍Element3如何安装的文档了，下面的文稿就是Element3的安装使用说明。</p><pre><code class="language-markdown">## 安装\n### npm 安装\n推荐使用 npm 的方式安装，它能更好地和 [webpack](https://webpack.js.org/) 打包工具配合使用。\n```shell\nnpm i element3 -S\n```\n### CDN\n目前可以通过 [unpkg.com/element3](https://unpkg.com/element3) 获取到最新版本的资源，在页面上引入 js 和 css 文件即可开始使用。\n```html\n&lt;!-- 引入样式 --&gt;\n&lt;link\n  rel="stylesheet"\n  href="https://unpkg.com/element3/lib/theme-chalk/index.css"\n/&gt;\n&lt;!-- 引入组件库 --&gt;\n&lt;script src="https://unpkg.com/element3"&gt;&lt;/script&gt;\n```\n:::tip\n我们建议使用 CDN 引入 Element3 的用户在链接地址上锁定版本，以免将来 Element3 升级时受到非兼容性更新的影响。锁定版本的方法请查看 [unpkg.com](https://unpkg.com)。\n:::\n### Hello world\n\n通过 CDN 的方式我们可以很容易地使用 Element3 写出一个 Hello world 页面。[在线演示](https://codepen.io/imjustaman/pen/abZajYg)\n\n&lt;iframe height="265" style="width: 100%;" scrolling="no" title="Element3 Demo" src="https://codepen.io/imjustaman/embed/abZajYg?height=265&amp;theme-id=light&amp;default-tab=html,result" frameborder="no" loading="lazy" allowtransparency="true" allowfullscreen="true"&gt;\n  See the Pen &lt;a href=\'https://codepen.io/imjustaman/pen/abZajYg\'&gt;Element3 Demo&lt;/a&gt; by ImJustAMan\n  (&lt;a href=\'https://codepen.io/imjustaman\'&gt;@imjustaman&lt;/a&gt;) on &lt;a href=\'https://codepen.io\'&gt;CodePen&lt;/a&gt;.\n&lt;/iframe&gt;\n如果是通过 npm 安装，并希望配合 webpack 使用，请阅读下一节：[快速上手](/#/zh-CN/component/quickstart)。\n\n</code></pre><p>然后我们在浏览器里点击安装后，就会看到下图的页面显示。Markdown已经成功渲染为在线文档了，并且代码也自带了高亮显示。</p><p><img src="https://static001.geekbang.org/resource/image/09/c3/09d16ddc1080b4d8d4b04b934bdyy3c3.png?wh=1920x1655" alt="图片"></p><p>然后我们需要在这个文档系统中支持Element3，首先执行下面的代码安装Element3：</p><pre><code class="language-bash">npm i element3 -D\n</code></pre><p>然后在项目根目录下的docs/.vuepress文件夹中新建文件clientAppEnhance.js，这是VuerPress的客户端扩展文件。我们导入了defineClientAppEnhance来返回客户端的扩展配置。这个函数中会传递Vue的实例App以及路由配置Router，我们使用app.use来全局注册Element3组件，就可以直接在Markdown中使用Element3的组件了。</p><pre><code class="language-javascript">\nimport { defineClientAppEnhance } from \'@vuepress/client\'\n\nimport element3 from \'element3\'\n\nexport default defineClientAppEnhance(({ app, router, siteData }) =&gt; {\n  app.use(element3)\n})\n</code></pre><p>这样VuePress就内置了Element3。我们在docs下面新建button.md文件，可以直接在Markdown中使用Element3的组件进行演示。下面的文稿中我们直接使用了el-button组件演示效果。</p><pre><code class="language-markdown">## Button 按钮\n\n常用的操作按钮。\n### 基础用法\n基础的按钮用法。\n\n&lt;el-button type="primary"&gt;\n按钮\n&lt;/el-button&gt;\n\n```html\n&lt;el-button type="primary"&gt;\n按钮\n&lt;/el-button&gt;\n```\n</code></pre><p>然后进入docs/.vuepress/config.js中，新增侧边栏sidebar的配置之后，就可以看到下图的效果了。</p><pre><code class="language-javascript">    sidebar:[\n      {\n        text:\'安装\',\n        link:\'/install\'\n      },\n      {\n        text:\'按钮\',\n        link:\'/button\'\n      },\n    ]\n</code></pre><p><img src="https://static001.geekbang.org/resource/image/d2/6d/d267f5d33cc9652c145d737f8f4dc96d.png?wh=1920x846" alt="图片"></p><p>这样我们就基于VuePress支持了Element3组件库的文档功能，剩下的就是给每个组件写好文档即可。</p><p>但是这样的话，el-button的源码就写了两次，如果我们想更好地定制组件库文档，就需要自己解析Markdown文件，在内部支持Vue组件的效果显示和源码展示，也就相当于定制了一个自己的VuePress。</p><pre><code class="language-markdown">:::demo 使用`type`、`plain`、`round`和`circle`属性来定义 Button 的样式。\n\n```html\n&lt;template&gt;\n  &lt;el-row&gt;\n    &lt;el-button&gt;默认按钮&lt;/el-button&gt;\n    &lt;el-button type="primary"&gt;主要按钮&lt;/el-button&gt;\n    &lt;el-button type="success"&gt;成功按钮&lt;/el-button&gt;\n    &lt;el-button type="info"&gt;信息按钮&lt;/el-button&gt;\n    &lt;el-button type="warning"&gt;警告按钮&lt;/el-button&gt;\n    &lt;el-button type="danger"&gt;危险按钮&lt;/el-button&gt;\n  &lt;/el-row&gt;\n&lt;/template&gt;\n```\n\n:::\n</code></pre><p>它能直接使用下面的:::demo语法，在标记内部代码的同时，显示渲染效果和源码，也就是下图Element3官网的渲染效果。</p><p><img src="https://static001.geekbang.org/resource/image/85/c6/85c611ff85c7d69773e41c546f4eb3c6.png?wh=1920x1462" alt="图片"></p><p>那么接下来我们就看看如何定制，具体操作一下。</p><h2>解析Markdown</h2><p>我们需要自己实现一个Markdown-loader，对Markdown语法进行扩展。</p><p>Element3中使用Markdown-it进行Markdown语法的解析和扩展。Markdown-it导出一个函数，这个函数可以把Markdown语法解析为HTML标签。这里我们需要做的就是解析出Markdown中的demo语法，渲染其中的Vue组件，并且同时能把源码也显示在组件下方，这样就完成了扩展任务。</p><p>Element3中对Markdown的扩展源码都可以在<a href="https://github.com/hug-sun/element3/tree/master/packages/md-loader/src">GitHub</a>上看到。</p><p>下面的代码就是全部解析的逻辑：首先我们使用md.render把Markdown渲染成为HTML，并且获取内部demo子组件；在获取了demo组件内部的代码之后，调用genInlineComponentText，把组件通过Vue的compiler解析成待执行的代码，这一步就是模拟了Vue组件解析的过程；然后使用script标签包裹编译之后的Vue组件；最后再把组件的源码放在后面，demo组件的解析就完成了。</p><pre><code class="language-javascript">const { stripScript, stripTemplate, genInlineComponentText } = require(\'./util\')\n\tconst md = require(\'./config\')\n\t\n\tmodule.exports = function (source) {\n\t  const content = md.render(source)\n\t\n\t  const startTag = \'&lt;!--element-demo:\'\n\t  const startTagLen = startTag.length\n\t  const endTag = \':element-demo--&gt;\'\n\t  const endTagLen = endTag.length\n\t\n\t  let componenetsString = \'\'\n\t  let id = 0 // demo 的 id\n\t  const output = [] // 输出的内容\n\t  let start = 0 // 字符串开始位置\n\t\n\t  let commentStart = content.indexOf(startTag)\n\t  let commentEnd = content.indexOf(endTag, commentStart + startTagLen)\n\t  while (commentStart !== -1 &amp;&amp; commentEnd !== -1) {\n\t    output.push(content.slice(start, commentStart))\n\t\n\t    const commentContent = content.slice(commentStart + startTagLen, commentEnd)\n\t    const html = stripTemplate(commentContent)\n\t    const script = stripScript(commentContent)\n\t\n\t    const demoComponentContent = genInlineComponentText(html, script)\n\t\n\t    const demoComponentName = `element-demo${id}`\n\t    output.push(`&lt;template #source&gt;&lt;${demoComponentName} /&gt;&lt;/template&gt;`)\n\t    componenetsString += `${JSON.stringify(\n\t      demoComponentName\n\t    )}: ${demoComponentContent},`\n\t\n\t    // 重新计算下一次的位置\n\t    id++\n\t    start = commentEnd + endTagLen\n\t    commentStart = content.indexOf(startTag, start)\n\t    commentEnd = content.indexOf(endTag, commentStart + startTagLen)\n\t  }\n\t\n\t  // 仅允许在 demo 不存在时，才可以在 Markdown 中写 script 标签\n\t  // todo: 优化这段逻辑\n\t  let pageScript = \'\'\n\t  if (componenetsString) {\n\t    pageScript = `&lt;script&gt;\n\t      import hljs from \'highlight.js\'\n\t      import * as Vue from "vue"\n\t      export default {\n\t        name: \'component-doc\',\n\t        components: {\n\t          ${componenetsString}\n\t        }\n\t      }\n\t    &lt;/script&gt;`\n\t  } else if (content.indexOf(\'&lt;script&gt;\') === 0) {\n\t    // 硬编码，有待改善\n\t    start = content.indexOf(\'&lt;/script&gt;\') + \'&lt;/script&gt;\'.length\n\t    pageScript = content.slice(0, start)\n\t  }\n\t\n\t  output.push(content.slice(start))\n\t  return `\n\t    &lt;template&gt;\n\t      &lt;section class="content element-doc"&gt;\n\t        ${output.join(\'\')}\n\t      &lt;/section&gt;\n\t    &lt;/template&gt;\n\t    ${pageScript}\n\t  `\n\t}\n</code></pre><p>然后我们还要把渲染出来的Vue组件整体封装成为demo-block组件。在下面的代码中，我们使用扩展Markdown的render函数，内部使用demo-block组件，把Markdown渲染的结果渲染在浏览器上。</p><pre><code class="language-javascript">const mdContainer = require(\'markdown-it-container\')\n\nmodule.exports = (md) =&gt; {\n  md.use(mdContainer, \'demo\', {\n    validate(params) {\n      return params.trim().match(/^demo\\s*(.*)$/)\n    },\n    render(tokens, idx) {\n      const m = tokens[idx].info.trim().match(/^demo\\s*(.*)$/)\n      if (tokens[idx].nesting === 1) {\n        const description = m &amp;&amp; m.length &gt; 1 ? m[1] : \'\'\n        const content =\n          tokens[idx + 1].type === \'fence\' ? tokens[idx + 1].content : \'\'\n        return `&lt;demo-block&gt;\n        ${description ? `&lt;div&gt;${md.render(description)}&lt;/div&gt;` : \'\'}\n        &lt;!--element-demo: ${content}:element-demo--&gt;\n        `\n      }\n      return \'&lt;/demo-block&gt;\'\n    }\n  })\n\n  md.use(mdContainer, \'tip\')\n  md.use(mdContainer, \'warning\')\n}\n\n</code></pre><p>然后我们就实现了demo-block组件。接下来我们新建DemoBlock.vue，在下面的代码中我们通过slot实现了组件的渲染结果和源码高亮的效果，至此我们就成功了实现了Markdown中源码演示的效果。</p><pre><code class="language-javascript">&lt;!-- DemoBlock.vue --&gt;\n&lt;template&gt;\n&nbsp; &lt;div class="demo-block"&gt;\n&nbsp; &nbsp; &lt;div class="source"&gt;\n&nbsp; &nbsp; &nbsp; &lt;slot name="source"&gt;&lt;/slot&gt;\n&nbsp; &nbsp; &lt;/div&gt;\n&nbsp; &nbsp; &lt;div class="meta" ref="meta"&gt;\n&nbsp; &nbsp; &nbsp; &lt;div class="description" v-if="$slots.default"&gt;\n&nbsp; &nbsp; &nbsp; &nbsp; &lt;slot&gt;&lt;/slot&gt;\n&nbsp; &nbsp; &nbsp; &lt;/div&gt;\n&nbsp; &nbsp; &nbsp; &lt;div class="highlight"&gt;\n&nbsp; &nbsp; &nbsp; &nbsp; &lt;slot name="highlight"&gt;&lt;/slot&gt;\n&nbsp; &nbsp; &nbsp; &lt;/div&gt;\n&nbsp; &nbsp; &lt;/div&gt;\n&nbsp; &nbsp; &lt;div\n&nbsp; &nbsp; &nbsp; class="demo-block-control"\n&nbsp; &nbsp; &nbsp; ref="control"\n&nbsp; &nbsp; &nbsp; @click="isExpanded = !isExpanded"\n&nbsp; &nbsp; &gt;\n&nbsp; &nbsp; &nbsp; &lt;span&gt;{{ controlText }}&lt;/span&gt;\n&nbsp; &nbsp; &lt;/div&gt;\n&nbsp; &lt;/div&gt;\n&lt;/template&gt;\n\n&lt;script&gt;\nimport { ref, computed, watchEffect, onMounted } from \'vue\'\nexport default {\n&nbsp; setup() {\n&nbsp; &nbsp; const meta = ref(null)\n&nbsp; &nbsp; const isExpanded = ref(false)\n&nbsp; &nbsp; const controlText = computed(() =&gt;\n&nbsp; &nbsp; &nbsp; isExpanded.value ? \'隐藏代码\' : \'显示代码\'\n&nbsp; &nbsp; )\n&nbsp; &nbsp; const codeAreaHeight = computed(() =&gt;\n&nbsp; &nbsp; &nbsp; [...meta.value.children].reduce((t, i) =&gt; i.offsetHeight + t, 56)\n&nbsp; &nbsp; )\n&nbsp; &nbsp; onMounted(() =&gt; {\n&nbsp; &nbsp; &nbsp; watchEffect(() =&gt; {\n&nbsp; &nbsp; &nbsp; &nbsp; meta.value.style.height = isExpanded.value\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ? `${codeAreaHeight.value}px`\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; : \'0\'\n&nbsp; &nbsp; &nbsp; })\n&nbsp; &nbsp; })\n\n&nbsp; &nbsp; return {\n&nbsp; &nbsp; &nbsp; meta,\n&nbsp; &nbsp; &nbsp; isExpanded,\n&nbsp; &nbsp; &nbsp; controlText\n&nbsp; &nbsp; }\n&nbsp; }\n}\n&lt;/script&gt;\n</code></pre><h2>总结</h2><p>我们来总结一下今天学到的内容。</p><p>首先我们使用Vue官网文档的构建工具VuePress来搭建组件库文档，VuePress提供了很好的上手体验，Markdown中可以直接注册使用Vue组件，我们在.vuepress中可以扩展对Element3的支持。</p><p>如果我们定制需求更多一些，就需要自己解析Markdown并且实现对Vue组件的支持了，我们可以使用Markdown-it插件解析，支持Vue组件和代码高亮，这也是现在Element3文档的渲染方式。</p><h2>思考题</h2><p>最后留给你一道思考题：现在很多组件库开始尝试使用Storybook来搭建组件库的文档，那么这个Storybook相比于我们实现的文档有什么特色呢？</p><p>欢迎你在评论区分享你的看法，也欢迎你把这节课的内容分享给你的同事和朋友们，我们下一讲再见！</p>',
        article_title: "26｜文档：如何给你的组件库设计一个可交互式文档？",
      },
      {
        title: "27｜自定义渲染器：如何实现Vue的跨端渲染 ？",
        id: 470087,
        content:
          '<p>你好，我是大圣。</p><p>上一讲我们讲完了组件库的核心知识点，这一讲我们来学习一个叫Vue 3的进阶知识点：自定义渲染器，这个功能可以自定义Vue渲染的逻辑。</p><p>在给你讲清楚原理之后，我还会带你一起实现一个Canvas的渲染器实际上手体验一下。</p><h2>什么是渲染器</h2><p>我们都知道，Vue内部的组件是以虚拟dom形式存在的。下面的代码就是一个很常见的虚拟Dom，用对象的方式去描述一个项目。相比dom标签相比，这种形式可以让整个Vue项目脱离浏览器的限制，更方便地实现Vuejs的跨端。</p><pre><code class="language-javascript">{\n  tag: \'div\',\n  props: {\n    id: \'app\'\n  },\n  chidren: [\n    {\n      tag: Container,\n      props: {\n        className: \'el-container\'\n      },\n      chidren: [\n        \'哈喽小老弟!!!\'\n      ]\n    }\n  ]\n}\n</code></pre><p>渲染器是围绕虚拟Dom存在的。在浏览器中，我们把虚拟Dom渲染成真实的Dom对象，Vue源码内部把一个框架里所有和平台相关的操作，抽离成了独立的方法。所以，我们只需要实现下面这些方法，就可以实现Vue 3在一个平台的渲染。</p><p>首先用createElement创建标签，还有用createText创建文本。创建之后就需要用insert新增元素，通过remote删除元素，通过setText更新文本和patchProps修改属性。然后再实现parentNode、nextSibling等方法实现节点的查找关系。完成这些工作，理论上就可以在一个平台内实现一个应用了。</p><!-- [[[read_end]]] --><p>在Vue 3中的runtime-core模块，就对外暴露了这些接口，runtime-core内部基于这些函数实现了整个Vue内部的所有操作，然后在runtime-dom中传入以上所有方法。</p><p>下面的代码就是Vue代码提供浏览器端操作的函数，这些DOM编程接口完成了浏览器端增加、添加和删除操作，这些API都是浏览器端独有的，如果一个框架强依赖于这些函数，那就只能在浏览器端运行。</p><pre><code class="language-javascript">export const nodeOps: Omit&lt;RendererOptions&lt;Node, Element&gt;, \'patchProp\'&gt; = {\n  //插入元素\n  insert: (child, parent, anchor) =&gt; {\n    parent.insertBefore(child, anchor || null)\n  },\n  // 删除元素\n  remove: child =&gt; {\n    const parent = child.parentNode\n    if (parent) {\n      parent.removeChild(child)\n    }\n  },\n  // 创建元素\n  createElement: (tag, isSVG, is, props): Element =&gt; {\n    const el = isSVG\n      ? doc.createElementNS(svgNS, tag)\n      : doc.createElement(tag, is ? { is } : undefined)\n\n    if (tag === \'select\' &amp;&amp; props &amp;&amp; props.multiple != null) {\n      ;(el as HTMLSelectElement).setAttribute(\'multiple\', props.multiple)\n    }\n\n    return el\n  }\n  //...其他操作函数\n}\n</code></pre><p>如果一个框架想要实现实现跨端的功能，那么渲染器本身不能依赖任何平台下特有的接口。</p><p>在后面的代码中，我们通过createRenderer函数区创建了一个渲染器。通过参数options获取增删改查所有的函数以后，在内部的render、mount、patch等函数中，需要去渲染一个元素的时候，就可以通过option.createElement和option.insert来实现。</p><p>这段代码给你展现的是核心逻辑，完整版本你可以看一下<a href="https://github.com/vuejs/vue-next/blob/master/packages/runtime-core/src/renderer.ts#L334">Vue 3的源码</a>。</p><pre><code class="language-javascript">export default function createRenderer(options) {\n  const {\n\t    insert: hostInsert,\n\t    remove: hostRemove,\n\t    patchProp: hostPatchProp,\n\t    createElement: hostCreateElement,\n\t    createText: hostCreateText,\n\t    createComment: hostCreateComment,\n\t    setText: hostSetText,\n\t    setElementText: hostSetElementText,\n\t    parentNode: hostParentNode,\n\t    nextSibling: hostNextSibling,\n\t    setScopeId: hostSetScopeId = NOOP,\n\t    cloneNode: hostCloneNode,\n\t    insertStaticContent: hostInsertStaticContent\n   } = options\n\n&nbsp; function render(vnode, container) {  }\n\n&nbsp; function mount(vnode, container, isSVG, refNode) {  }\n\n&nbsp; function mountElement(vnode, container, isSVG, refNode) {  }\n\n&nbsp; function mountText(vnode, container) {  }\n\n&nbsp; function patch(prevVNode, nextVNode, container) {  }\n\n&nbsp; function replaceVNode(prevVNode, nextVNode, container) {  }\n&nbsp; function patchElement(prevVNode, nextVNode, container) {  }\n&nbsp; function patchChildren(\n&nbsp; &nbsp; prevChildFlags,\n&nbsp; &nbsp; nextChildFlags,\n&nbsp; &nbsp; prevChildren,\n&nbsp; &nbsp; nextChildren,\n&nbsp; &nbsp; container\n&nbsp; ) {  }\n\n&nbsp; function patchText(prevVNode, nextVNode) {  }\n&nbsp; function patchComponent(prevVNode, nextVNode, container) {  }\n\n&nbsp; return { render }\n}\n</code></pre><p>在每个函数实现的内部，比如mountElemnt，我们之前的实现方式是调用浏览器的API创建。</p><pre><code class="language-javascript">function mountElement(vnode, container, isSVG, refNode) {\n&nbsp; const el = isSVG\n&nbsp; &nbsp; ? document.createElementNS(....)\n&nbsp; &nbsp; : document.createElement(vnode.tag)\n}\n\n</code></pre><p>对比一下，经过渲染器抽离之后，内部的mountElmenet就会把所有document的操作全部换成options传递进来的hostCreate函数。</p><pre><code class="language-javascript">function mountElement(vnode, container, isSVG, refNode) {\n&nbsp; const el = hostCreateElement(vnode.tag, isSVG)\n}\n</code></pre><p>然后，我们使用后面的代码创建一个具体平台的渲染器，这也是Vue 3中的runtime-dom包主要做的事。了解了Vue中自定义渲染器的实现方式后，我们还可以基于Vue 3的runtime-core包封装其他平台的渲染器，让其他平台也能使用Vue内部的响应式和组件化等优秀的特性。</p><pre><code class="language-javascript">const { render } = createRenderer({\n&nbsp; nodeOps: {\n&nbsp; &nbsp; createElement() {   },\n&nbsp; &nbsp; createText() {   }\n&nbsp; &nbsp; // more...\n&nbsp; },\n&nbsp; patchData\n})\n\n</code></pre><h2>自定义渲染</h2><p>说完了渲染器创建，我们再来看看自定义渲染。</p><p>自定义渲染器让Vue脱离了浏览器的限制，我们只需要实现平台内部的增删改查函数后，就可以直接对接Vue 3。比方说，我们可以把Vue渲染到小程序平台，实现Vue 3-minipp；也可以渲染到Canvas，实现vue 3-canvas，把虚拟dom渲染成Canvas；甚至还可以尝试把Vue 3渲染到threee.js中，在3D世界使用响应式开发。</p><p>接下来，我们一起尝试实现一个Canvas的渲染器。具体操作是这样的，我们在项目的src目录下新建renderer.js，通过这个文件实现一个简易的Canvas渲染逻辑。Canvas平台中操作的方式相对简单，没有太多节点的概念，我们可以把整个Canvas维护成一个对象，每次操作的时候直接把Canvas重绘一下就可以了。</p><pre><code class="language-javascript">import { createRenderer } from \'@vue/runtime-core\'\nconst { createApp: originCa } = createRenderer({\n  insert: (child, parent, anchor) =&gt; {\n  },\n  createElement(type, isSVG, isCustom) {\n  },\n  setElementText(node, text) {\n  },\n  patchProp(el, key, prev, next) {\n  },\n});\n</code></pre><p>下面的代码中我们实现了draw函数，这里我们就是用Canvas的操作方法<strong>递归</strong>地把Canvas对象渲染到Canvas标签内部。</p><pre><code class="language-javascript">let ctx\nfunction draw(ele, isChild) {\n  if (!isChild) {\n    ctx.clearRect(0, 0, 500, 500)\n  }\n\n  ctx.fillStyle = ele.fill || \'white\'\n  ctx.fillRect(...ele.pos)\n  if (ele.text) {\n    ctx.fillStyle = ele.color || \'white\'\n    ele.fontSize = ele.type == "h1" ? 20 : 12\n    ctx.font = (ele.fontSize || 18) + \'px serif\'\n    ctx.fillText(ele.text, ele.pos[0] + 10, ele.pos[1] + ele.fontSize)\n  }\n  ele.child &amp;&amp; ele.child.forEach(c =&gt; {\n    console.log(\'child:::\', c)\n    draw(c, true)\n  })\n\n}\n</code></pre><p>由于我们主体需要维护的逻辑就是对于对象的操作，所以创建和更新操作直接操作对象即可。新增insert需要维护parent和child元素。另外，插入的时候也需要调用draw函数，并且需要监听onclick事件。</p><pre><code class="language-javascript">const { createApp: originCa } = createRenderer({\n  insert: (child, parent, anchor) =&gt; {\n    if (typeof child == \'string\') {\n      parent.text = child\n    } else {\n      child.parent = parent\n      if (!parent.child) {\n        parent.child = [child]\n      } else {\n        parent.child.push(child)\n      }\n    }\n    if (parent.nodeName) {\n      draw(child)\n      if (child.onClick) {\n        ctx.canvas.addEventListener(\'click\', () =&gt; {\n          child.onClick()\n          setTimeout(() =&gt; {\n            draw(child)\n          })\n        }, false)\n      }\n    }\n  },\n  createElement(type, isSVG, isCustom) {\n    return {\n      type\n    }\n  },\n  setElementText(node, text) {\n    node.text = text\n  },\n  patchProp(el, key, prev, next) {\n    el[key] = next\n  },\n\n});\n</code></pre><p>现在我们来到src/main.js中，这时候就不能直接从vue中引入createApp了，而是需要从runtime-core中导入createRenderer。</p><p>接下来，通过createRenderer用我们自已定义的renderer去创建createApp，并且重写mount函数。在Canvas的mount中，我们需要创建Canvas标签并且挂载到App上。</p><pre><code class="language-javascript">import { createRenderer } from \'@vue/runtime-core\'\nconst { createApp: originCa } = createRenderer({\n\n}）\nfunction createApp(...args) {\n  const app = originCa(...args)\n  return {\n    mount(selector) {\n      const canvas = document.createElement(\'canvas\')\n      canvas.width = window.innerWidth\n      canvas.height = window.innerHeight\n      document.querySelector(selector).appendChild(canvas)\n      ctx = canvas.getContext(\'2d\')\n      app.mount(canvas)\n    }\n  }\n}\n</code></pre><p>下一步进入src/App.vue中，我们就可以在Vue组件中使用ref等响应式的写法了。我们实现了通过ref返回的响应式对象，渲染Canvas内部的文字和高度，并且点击的时候还可以修改文字。完成上面的操作，我们就实现了Canvas平台的基本渲染。</p><pre><code class="language-xml">&lt;template&gt;\n&lt;div @click="setName(\'vue3真棒\')" :pos="[10,10,300,300]" fill="#eee"&gt;\n    &lt;h1 :pos="[20,20,200,100]" fill="red" color="#000"&gt;累加器{{count}}&lt;/h1&gt;\n    &lt;span :pos="pos" fill="black" &gt;哈喽{{name}}&lt;/span&gt;\n&lt;/div&gt;\n\n\n\n&lt;/template&gt;\n\n&lt;script setup&gt;\n\nimport {ref} from \'vue\'\nconst name = ref(\'vue3入门\')\nconst pos = ref([20,120,200,100])\nconst count = ref(1)\nconst setName = (n)=&gt;{\n&nbsp; name.value = n\n&nbsp; pos.value[1]+=20\n&nbsp; count.value+=2\n}\n&lt;/script&gt;\n</code></pre><p>上面的代码在浏览器里就会有下图的显示效果。我们点击Canvas后，文案就会显示为“哈喽vue3真棒”，并且黑色方块和红色方块的距离也会变大。<br>\n<img src="https://static001.geekbang.org/resource/image/b4/7b/b466ca102ef94ebce2d05c865ca4637b.png?wh=1920x992" alt="图片"></p><p>基于这个原理，我们其实可以做很多有意思的尝试，社区也也有越来越多开源的Vue 3的自定义渲染器，比如小程序跨端框架uni-app，Vugel可以使用Vue渲染Webgl等，你也可以动手多多体验。</p><p>比如下面的代码中，我们对three.js进行一个渲染的尝试。它的实现逻辑和Canvas比较类似，通过对于对象的维护和draw函数实现最终的绘制。在draw函数内部，我们调用three.js的操作方法去创建camera，sence，geometry等概念，最后对外暴露three.js的createApp函数。</p><pre><code class="language-xml">import { createRenderer } from \'@vue/runtime-core\'\nimport * as THREE from \'three\'\nimport {nextTick} from \'@vue/runtime-core\'\n\nlet renderer\n\nfunction draw(obj) {\n    const {camera,cameraPos, scene, geometry,geometryArg,material,mesh,meshY,meshX} = obj\n    if([camera,cameraPos, scene, geometry,geometryArg,material,mesh,meshY,meshX].filter(v=&gt;v).length&lt;9){\n        return \n    }\n    let cameraObj = new THREE[camera]( 40, window.innerWidth / window.innerHeight, 0.1, 10 )\n    Object.assign(cameraObj.position,cameraPos)\n\n    let sceneObj = new THREE[scene]()\n\n    let geometryObj = new THREE[geometry]( ...geometryArg)\n    let materialObj = new THREE[material]()\n\n    let meshObj = new THREE[mesh]( geometryObj, materialObj )\n    meshObj.rotation.x = meshX\n    meshObj.rotation.y = meshY\n    sceneObj.add( meshObj )\n    renderer.render( sceneObj, cameraObj );\n\n}\n\nconst { createApp: originCa } = createRenderer({\n  insert: (child, parent, anchor) =&gt; {\n    if(parent.domElement){\n        draw(child)\n    }\n  },\n  createElement(type, isSVG, isCustom) {\n    return {\n      type\n    }\n  },\n  setElementText(node, text) {\n  },\n  patchProp(el, key, prev, next) {\n    el[key] = next\n    draw(el)\n  },\n  parentNode: node =&gt; node,\n  nextSibling: node =&gt; node,\n  createText: text =&gt; text,\n  remove:node=&gt;node\n\n});\nfunction createApp(...args) {\n  const app = originCa(...args)\n  return {\n    mount(selector) {\n        renderer = new THREE.WebGLRenderer( { antialias: true } );\n        renderer.setSize( window.innerWidth, window.innerHeight );\n        document.body.appendChild( renderer.domElement );\n        app.mount(renderer)\n    }\n  }\n}\nexport { createApp }\n\n\n\n</code></pre><p>然后我们在App.vue中，使用下面的代码渲染出一个立方体，并且通过ref响应式对象控制立方体偏移的监督，再通过setInterval实现立方体的动画，实现下图的反转效果。</p><pre><code class="language-xml">&lt;template&gt;\n&nbsp; &nbsp; &lt;div\n&nbsp; &nbsp; &nbsp; &nbsp; camera="PerspectiveCamera"\n&nbsp; &nbsp; &nbsp; &nbsp; :cameraPos={z:1}\n&nbsp; &nbsp; &nbsp; &nbsp; scene="Scene"\n&nbsp; &nbsp; &nbsp; &nbsp; geometry="BoxGeometry"\n&nbsp; &nbsp; &nbsp; &nbsp; :geometryArg="[0.2,0.2,0.2]"\n&nbsp; &nbsp; &nbsp; &nbsp; material="MeshNormalMaterial"\n&nbsp; &nbsp; &nbsp; &nbsp; mesh="Mesh"\n&nbsp; &nbsp; &nbsp; &nbsp; :meshY="y"\n&nbsp; &nbsp; &nbsp; &nbsp; :meshX="x"\n&nbsp; &nbsp; &gt;\n&nbsp; &nbsp; &lt;/div&gt;\n\n&lt;/template&gt;\n\n&lt;script&gt;\nimport {ref} from \'vue\'\nexport default {\n&nbsp; &nbsp; setup(){\n&nbsp; &nbsp; &nbsp; &nbsp; const y = ref(0.3)\n&nbsp; &nbsp; &nbsp; &nbsp; const x = ref(0.3)\n&nbsp; &nbsp; &nbsp; &nbsp; setInterval(()=&gt;{\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; y.value+=0.3\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; x.value+=0.5\n&nbsp; &nbsp; &nbsp; &nbsp; },100)\n&nbsp; &nbsp; &nbsp; &nbsp; return {y,x}\n&nbsp; &nbsp; }\n}\n&lt;/script&gt;\n</code></pre><p>反转效果演示如下：<br>\n<img src="https://static001.geekbang.org/resource/image/b0/4f/b0b20b2a314bcf650b8b56256bdf804f.gif?wh=1182x761" alt="图片"></p><p>我们还可以在Canvas的封装上更进一步，并且实现对一些Canvas已有框架Pixi.js的封装，这样就可以通过Vue 3的响应式的开发方式，快速开发一个小游戏。</p><p>下面的代码中就是针对Pixi.js实现的封装函数，你可以看一下。</p><pre><code class="language-xml"> import {Graphics} from "PIXI.js";\n\nexport const getNodeOps = (app) =&gt; {\n  return {\n    insert: (child, parent, anchor) =&gt; {\n      parent.addChild(child);\n    },\n\n    remove: (child) =&gt; {\n      const parent = child.parentNode;\n      if (parent) {\n        parent.removeChild(child);\n      }\n    },\n\n    createElement: (tag, isSVG, is) =&gt; {\n      let element;\n      if (tag === "Rectangle") {\n        // 创建一个矩形\n        element = new window.PIXI.Graphics();\n        element.lineStyle(4, 0xff3300, 1);\n        element.beginFill(0x66ccff);\n        element.drawRect(0, 0, 64, 64);\n        element.endFill();\n        element.x = 0;\n        element.y = 0;\n        // Opt-in to interactivity\n        element.interactive = true;\n\n        // Shows hand cursor\n        element.buttonMode = true;\n      } else if (tag === "Sprite") {\n        element = new window.PIXI.Sprite();\n        element.x = 0;\n        element.y = 0;\n      } else if (tag === "Container") {\n        element = new window.PIXI.Container();\n        element.x = 0;\n        element.y = 0;\n      }\n\n      return element;\n    },\n\n    createText: (text) =&gt; doc.createTextNode(text),\n\n    createComment: (text) =&gt; {\n    //   console.log(text);\n    },\n\n    setText: (node, text) =&gt; {\n      node.nodeValue = text;\n    },\n\n    setElementText: (el, text) =&gt; {\n      el.textContent = text;\n    },\n\n    parentNode: (node) =&gt; node.parentNode,\n\n    nextSibling: (node) =&gt; node.nextSibling,\n\n    querySelector: (selector) =&gt; doc.querySelector(selector),\n\n    setScopeId(el, id) {\n      el.setAttribute(id, "");\n    },\n\n    cloneNode(el) {\n      return el.cloneNode(true);\n    },\n  };\n};\n</code></pre><p>Pixi中的属性修改可以使用下面的代码，判断x、y、width和on属性不同的操作，就是用响应式包裹了Pixi的对象。关于Vue 3和Pixi实现的代码效果，你可以在<a href="https://github.dev/shengxinjing/vue3-vs-vue2/blob/0911af848941c2eeb2783c32c1907fd286134be1/vue3-runtime-canvas/index.js">GitHub</a>看到全部的源码。</p><pre><code class="language-xml">export const patchProp = (\n  el,\n  key,\n  prevValue,\n  nextValue,\n  isSVG = false,\n) =&gt; {\n  switch (key) {\n    case "x":\n    case "y":\n    case "width":\n    case "height":\n        el[key] = nextValue;\n        break;\n    case "on":\n      Object.keys(nextValue).forEach((eventName) =&gt; {\n        const callback = nextValue[eventName];\n        el.on(eventName, callback);\n      });\n      break;\n    case "texture":\n        let texture = PIXI.Texture.from(nextValue);\n        el.texture = texture;\n        break;\n  }\n};\n\n</code></pre><h2>总结</h2><p>今天聊的内容到此就结束了，我们来总结一下今天学到的知识点。</p><p>首先我们了解了自定义渲染器的原理，就是<strong>把所有的增删改查操作暴露出去，使用的时候不需要知道内部的实现细节，我们只需要针对每个平台使用不同的API即可</strong>。</p><p>你可以这样理解，就像武侠小说中高手可以通过给你传输内力的方式控制你进行比武。我们打出去的每招每式都是来源于背后的高手，只不过自己做了简单的适配。在Vue渲染器的设计中就把document所有的操作都抽离成了nodeOps，并且通过调用Vue的createRenderer函数创建平台的渲染器。</p><p>这样一来，只要我们实现了Canvas平台的增删改查，就可以在Canvas的世界中使用Vue的响应式语法控制绘图和做游戏，Vue生态中对小程序和原生app的支持原理也是基于自定义渲染器实现的。</p><p>其实，自定义渲染器也代表着适配器设计模式的一个实践。除了自定义渲染器 API 的学习，我们也要反思一下自己现在负责的项目中，有哪些地方为了不同的接口或者平台写了太多的判断代码，是否也可以使用类似自定义渲染器的逻辑和模式，把多个组件、平台、接口之间不同的操作方式封装成一个核心模块，去进行单独函数的扩展。</p><h2>思考题</h2><p>最后留个思考题给你，Vue如何在node环境中渲染呢？欢迎在评论区分享你的答案，我们下一讲再见！</p>',
        article_title: "27｜自定义渲染器：如何实现Vue的跨端渲染 ？",
      },
    ],
  },
  {
    chapterTitle: "Vue 3 生态源码篇",
    children: [
      {
        title: "28｜响应式：万能的面试题，怎么手写响应式系统",
        id: 470089,
        content:
          "<p>你好，我是大圣。</p><p>经过前面课程的学习，相信你对Vue3的实战和组件有了新的认识，也掌握了很多实战秘籍，从今天开始，我将带你进入Vue框架的内部世界，探究一下Vue框架的原理，让你能知其然，也知其所以然。</p><p>我们将手写一个迷你的Vue框架，实现Vue3的主要渲染和更新逻辑，项目就叫weiyouyi，你可以在 <a href=\"https://github.com/shengxinjing/weiyouyi\">GitHub上</a>看到所有的核心代码。</p><h2>响应式</h2><p>在第三讲的Vue3新特性中，我们剖析了Vue3的功能结构，就是下图所示的Vue核心模块，可以看到，Vue3的组件之间是通过响应式机制来通知的，响应式机制可以自动收集系统中数据的依赖，并且在修改数据之后自动执行更新，极大提高开发的效率。</p><p>我们今天就要自己做一个迷你的响应式原型，希望你能通过自己手写，搞清楚响应式的实现原理。</p><p><img src=\"https://static001.geekbang.org/resource/image/7e/9e/7e68a41ef94a39eda9cf211ed479e39e.png?wh=1920x939\" alt=\"图片\"></p><p>根据响应式组件通知效果可以知道，<strong>响应式机制的主要功能就是，可以把普通的JavaScript对象封装成为响应式对象，拦截数据的获取和修改操作，实现依赖数据的自动化更新</strong>。</p><p>所以，一个最简单的响应式模型，我们可以通过reactive或者ref函数，把数据包裹成响应式对象，并且通过effect函数注册回调函数，然后在数据修改之后，响应式地通知effect去执行回调函数即可。</p><!-- [[[read_end]]] --><p>整个流程这么概括地说，你估计不太理解，我们先通过一个简单的小例子直观感受一下响应式的效果。</p><p>Vue的响应式是可以独立在其他平台使用的。比如你可以新建test.js，使用下面的代码在node环境中使用Vue响应。以reactive为例，我们使用reactive包裹JavaScript对象之后，每一次对响应式对象counter的修改，都会执行effect内部注册的函数：</p><pre><code class=\"language-javascript\">const {effect, reactive} = require('@vue/reactivity')\n\nlet dummy\nconst counter = reactive({ num1: 1, num2: 2 })\neffect(() =&gt; {\n  dummy = counter.num1 + counter.num2\n  console.log(dummy)// 每次counter.num1修改都会打印日志\n})\nsetInterval(()=&gt;{\n  counter.num1++\n},1000)\n</code></pre><p>执行node test.js之后，你就可以看到effect内部的函数会一直调用，每次count.value修改之后都会执行。<br>\n看到这个API估计你有点疑惑，effect内部的函数式如何知道count已经变化了呢？</p><p>我们先来看一下响应式整体的流程图，上面的代码中我们使用reactive把普通的JavaScript对象包裹成响应式数据了。</p><p>所以，在effect中获取counter.num1和counter.num2的时候，就会触发counter的get拦截函数；<strong>get函数，会把当前的effect函数注册到一个全局的依赖地图中去</strong>。这样counter.num1在修改的时候，<strong>就会触发set拦截函数，去依赖地图中找到注册的effect函数，然后执行</strong>。</p><p><img src=\"https://static001.geekbang.org/resource/image/0a/d0/0a3f06629751988996e1f863e0973cd0.jpg?wh=2012x796\" alt=\"\"><br>\n具体是怎么实现的呢？我们从第一步把数据包裹成响应式对象开始。先看reactive的实现。</p><h2>reactive</h2><p>我们进入到src/reactivity目录中，新建reactive.spec.js，使用下面代码测试reactive的功能，能够在响应式数据ret更新之后，执行effect中注册的函数：</p><pre><code class=\"language-javascript\">import { effect } from '../effect'\nimport { reactive } from '../reactive'\n\ndescribe('测试响应式', () =&gt; {\n  test('reactive基本使用', () =&gt; {\n    const ret = reactive({ num: 0 })\n    let val\n    effect(() =&gt; {\n      val = ret.num\n    })\n    expect(val).toBe(0)\n    ret.num++\n    expect(val).toBe(1)\n    ret.num = 10\n    expect(val).toBe(10)\n  })\n})\n</code></pre><p>之前讲过在Vue3中，reactive是通过ES6中的Proxy特性实现的属性拦截，所以，在reactive函数中我们直接返回newProxy即可：</p><pre><code class=\"language-javascript\">export function reactive(target) {\n  if (typeof target!=='object') {\n    console.warn(`reactive  ${target} 必须是一个对象`);\n    return target\n  }\n\n  return new Proxy(target, mutableHandlers);\n}\n</code></pre><p>可以看到，<strong>下一步我们需要实现的就是Proxy中的处理方法mutableHandles</strong>。</p><p>这里会把Proxy的代理配置抽离出来单独维护，是因为，其实Vue3中除了reactive还有很多别的函数需要实现，比如只读的响应式数据、浅层代理的响应式数据等，并且reactive中针对ES6的代理也需要单独的处理。</p><p>这里我们只处理js中对象的代理设置：</p><pre><code class=\"language-javascript\">  const proxy = new Proxy(target, mutableHandlers)\n</code></pre><h3>mutableHandles</h3><p>好，看回来，我们剖析mutableHandles。它要做的事就是配置Proxy的拦截函数，这里我们只拦截get和set操作，进入到baseHandlers.js文件中。</p><p>我们使用createGetter和createSetters来创建set和get函数，mutableHandles就是配置了set和get的对象返回。</p><ul>\n<li>get中直接返回读取的数据，这里的Reflect.get和target[key]实现的结果是一致的；并且返回值是对象的话，还会嵌套执行reactive，并且调用track函数收集依赖。</li>\n<li>set中调用trigger函数，执行track收集的依赖。</li>\n</ul><pre><code class=\"language-javascript\">const get = createGetter();\nconst set = createSetter();\n\nfunction createGetter(shallow = false) {\n  return function get(target, key, receiver) {\n    const res = Reflect.get(target, key, receiver)\n    track(target, \"get\", key)\n    if (isObject(res)) {\n      // 值也是对象的话，需要嵌套调用reactive\n      // res就是target[key]\n      // 浅层代理，不需要嵌套\n      return shallow ? res : reactive(res)\n    }\n    return res\n  }\n}\n\nfunction createSetter() {\n  return function set(target, key, value, receiver) {\n    const result = Reflect.set(target, key, value, receiver)\n    // 在触发 set 的时候进行触发依赖\n    trigger(target, \"set\", key)\n    return result\n  }\n}\nexport const mutableHandles = {\n  get,\n  set,\n};\n</code></pre><p>我们先看get的关键部分，track函数是怎么完成依赖收集的。</p><h3>track</h3><p>具体写代码之前，把依赖收集和执行的原理我们梳理清楚，看下面的示意图：</p><p><img src=\"https://static001.geekbang.org/resource/image/83/a9/836a798f28824fcf54c0fc280b8afca9.jpg?wh=1945x1500\" alt=\"\"></p><p>在track函数中，我们可以使用一个巨大的tragetMap去存储依赖关系。<strong>map的key是我们要代理的target对象，值还是一个depsMap</strong>，存储这每一个key依赖的函数，每一个key都可以依赖多个effect。上面的代码执行完成，depsMap中就有了num1和num2两个依赖。</p><p>而依赖地图的格式，用代码描述如下：</p><pre><code class=\"language-javascript\">targetMap = {\n target： {\n   key1: [回调函数1，回调函数2],\n   key2: [回调函数3，回调函数4],\n }  ,\n  target1： {\n   key3: [回调函数5]\n }  \n\n}\n</code></pre><p>好，有了大的设计思路，我们来进行具体的实现，在reactive下新建effect.js。</p><p>由于target是对象，所以必须得用map才可以把target作为key来管理数据，每次操作之前需要做非空的判断。最终把activeEffect存储在集合之中：</p><pre><code class=\"language-javascript\">const targetMap = new WeakMap()\n\nexport function track(target, type, key) {\n\n  // console.log(`触发 track -&gt; target: ${target} type:${type} key:${key}`)\n\n  // 1. 先基于 target 找到对应的 dep\n  // 如果是第一次的话，那么就需要初始化\n  // {\n  //   target1: {//depsmap\n  //     key:[effect1,effect2]\n  //   }\n  // }\n  let depsMap = targetMap.get(target)\n  if (!depsMap) {\n    // 初始化 depsMap 的逻辑\n    // depsMap = new Map()\n    // targetMap.set(target, depsMap)\n    // 上面两行可以简写成下面的\n    targetMap.set(target, (depsMap = new Map()))\n  }\n  let deps = depsMap.get(key)\n  if (!deps) {\n    deps = new Set()\n  }\n  if (!deps.has(activeEffect) &amp;&amp; activeEffect) {\n    // 防止重复注册\n    deps.add(activeEffect)\n  }\n  depsMap.set(key, deps)\n}\n</code></pre><p>get中关键的收集依赖的track函数我们已经讲完了，继续看set中关键的trigger函数。</p><h3>trigger</h3><p>有了上面targetMap的实现机制，<strong>trigger函数实现的思路就是从targetMap中，根据target和key找到对应的依赖函数集合deps，然后遍历deps执行依赖函数</strong>。</p><p>看实现的代码：</p><pre><code>export function trigger(target, type, key) {\n  // console.log(`触发 trigger -&gt; target:  type:${type} key:${key}`)\n  // 从targetMap中找到触发的函数，执行他\n  const depsMap = targetMap.get(target)\n  if (!depsMap) {\n    // 没找到依赖\n    return\n  }\n  const deps = depsMap.get(key)\n  if (!deps) {\n    return\n  }\n  deps.forEach((effectFn) =&gt; {\n\n    if (effectFn.scheduler) {\n      effectFn.scheduler()\n    } else {\n      effectFn()\n    }\n  })\n  \n}\n</code></pre><p>可以看到执行的是effect的scheduler或者run函数，这是因为我们需要在effect函数中把依赖函数进行包装，并对依赖函数的执行时机进行控制，这是一个小的设计点。</p><h3>effect</h3><p>然后我们来实现effect函数。</p><p>下面的代码中，我们把传递进来的fn函数通过effectFn函数包裹执行，在effectFn函数内部，把函数赋值给全局变量activeEffect；然后执行fn()的时候，就会触发响应式对象的get函数，get函数内部就会把activeEffect存储到依赖地图中，完成依赖的收集：</p><pre><code class=\"language-javascript\">export function effect(fn, options = {}) {\n  // effect嵌套，通过队列管理\n  const effectFn = () =&gt; {\n    try {\n      activeEffect = effectFn\n      //fn执行的时候，内部读取响应式数据的时候，就能在get配置里读取到activeEffect\n      return fn()\n    } finally {\n      activeEffect = null\n    }\n  }\n  if (!options.lazy) {\n    //没有配置lazy 直接执行\n    effectFn()\n  }\n  effectFn.scheduler = options.scheduler // 调度时机 watchEffect回用到\n  return effectFn\n  \n}\n</code></pre><p>effect传递的函数，比如可以通过传递lazy和scheduler来控制函数执行的时机，默认是同步执行。</p><p>scheduler存在的意义就是我们可以手动控制函数执行的时机，方便应对一些性能优化的场景，比如数据在一次交互中可能会被修改很多次，我们不想每次修改都重新执行依次effect函数，而是合并最终的状态之后，最后统一修改一次。</p><p>scheduler怎么用你可以看下面的代码，我们使用数组管理传递的执行任务，最后使用Promise.resolve只执行最后一次，这也是Vue中watchEffect函数的大致原理。</p><pre><code class=\"language-javascript\">const obj = reactive({ count: 1 })\neffect(() =&gt; {\n  console.log(obj.count)\n}, {\n  // 指定调度器为 queueJob\n  scheduler: queueJob\n})\n// 调度器实现\nconst queue: Function[] = []\nlet isFlushing = false\nfunction queueJob(job: () =&gt; void) {\n  if (!isFlushing) {\n    isFlushing = true\n    Promise.resolve().then(() =&gt; {\n      let fn\n      while(fn = queue.shift()) {\n        fn()\n      }\n    })\n  }\n}\n</code></pre><p>好了，绕了这么一大圈终于执行完了函数，估计你也看出来了封装了很多层。</p><p><strong>之所以封装这么多层就是因为，Vue的响应式本身有很多的横向扩展</strong>，除了响应式的封装，还有只读的拦截、浅层数据的拦截等等，这样，响应式系统本身也变得更加灵活和易于扩展，我们自己在设计公用函数的时候也可以借鉴类似的思路。</p><h2>另一个选择ref函数</h2><p>有了track和trigger的逻辑之后，我们用ref函数实现就变得非常简单了。</p><p>ref的执行逻辑要比reactive要简单一些，不需要使用Proxy代理语法，直接使用对象语法的getter和setter配置，监听value属性即可。</p><p>看下面的实现，在ref函数返回的对象中，对象的get value方法，使用track函数去收集依赖，set value方法中使用trigger函数去触发函数的执行。</p><pre><code class=\"language-javascript\">export function ref(val) {\n  if (isRef(val)) {\n    return val\n  }\n  return new RefImpl(val)\n}\nexport function isRef(val) {\n  return !!(val &amp;&amp; val.__isRef)\n}\n\n// ref就是利用面向对象的getter和setters进行track和trigget\nclass RefImpl {\n  constructor(val) {\n    this.__isRef = true\n    this._val = convert(val)\n  }\n  get value() {\n    track(this, 'value')\n    return this._val\n  }\n\n  set value(val) {\n    if (val !== this._val) {\n      this._val = convert(val)\n      trigger(this, 'value')\n    }\n  }\n}\n\n// ref也可以支持复杂数据结构\nfunction convert(val) {\n  return isObject(val) ? reactive(val) : val\n}\n</code></pre><p>你能很直观地看到，ref函数实现的相对简单很多，只是利用面向对象的getter和setter拦截了value属性的读写，这也是为什么我们需要操作ref对象的value属性的原因。</p><p><strong>值得一提的是，ref也可以包裹复杂的数据结构，内部会直接调用reactive来实现</strong>，这也解决了大部分同学对ref和reactive使用时机的疑惑，现在你可以全部都用ref函数，ref内部会帮你调用reactive。</p><h2>computed</h2><p>Vue中的computed计算属性也是一种特殊的effect函数，我们可以新建computed.spec.js来测试computed函数的功能，<strong>computed可以传递一个函数或者对象，实现计算属性的读取和修改</strong>。比如说可以这么用：</p><pre><code class=\"language-javascript\">mport {  ref } from '../ref'\nimport {  reactive } from '../reactive'\nimport { computed } from '../computed'\n\n\n\ndescribe('computed测试',()=&gt;{\n  it('computed基本使用',()=&gt;{\n    const ret = reactive({ count: 1 })\n    const num = ref(2)\n    const sum = computed(() =&gt; num.value + ret.count)\n    expect(sum.value).toBe(3)\n\n    ret.count++\n    expect(sum.value).toBe(4)\n    num.value = 10\n    expect(sum.value).toBe(12)\n  })\n  it('computed属性修改',()=&gt;{\n    const author = ref('大圣')\n    const course = ref('玩转Vue3')\n    const title = computed({\n      get(){\n        return author.value+\":\"+course.value\n      },\n      set(val){\n        [author.value,course.value] = val.split(':')\n      }\n    })\n    expect(title.value).toBe('大圣:玩转Vue3')\n\n    author.value=\"winter\"\n    course.value=\"重学前端\"\n    expect(title.value).toBe('winter:重学前端')\n    //计算属性赋值\n    title.value = '王争:数据结构与算法之美'\n    expect(author.value).toBe('王争')\n    expect(course.value).toBe('数据结构与算法之美')\n\n  })\n})\n</code></pre><p>怎么实现呢？我们新建computed函数，看下面的代码，我们拦截computed的value属性，并且定制了effect的lazy和scheduler配置，computed注册的函数就不会直接执行，而是要通过scheduler函数中对_dirty属性决定是否执行。</p><pre><code class=\"language-javascript\">export function computed(getterOrOptions) {\n  // getterOrOptions可以是函数，也可以是一个对象，支持get和set\n  // 还记得清单应用里的全选checkbox就是一个对象配置的computed\n  let getter, setter\n  if (typeof getterOrOptions === 'function') {\n    getter = getterOrOptions\n    setter = () =&gt; {\n      console.warn('计算属性不能修改')\n    }\n  } else {\n    getter = getterOrOptions.get\n    setter = getterOrOptions.set\n  }\n  return new ComputedRefImpl(getter, setter)\n}\nclass ComputedRefImpl {\n  constructor(getter, setter) {\n    this._setter = setter\n    this._val = undefined\n    this._dirty = true\n    // computed就是一个特殊的effect，设置lazy和执行时机\n    this.effect = effect(getter, {\n      lazy: true,\n      scheduler: () =&gt; {\n        if (!this._dirty) {\n          this._dirty = true\n          trigger(this, 'value')\n        }\n      },\n    })\n  }\n  get value() {\n    track(this, 'value')\n    if (this._dirty) {\n      this._dirty = false\n      this._val = this.effect()\n    }\n    return this._val\n  }\n  set value(val) {\n    this._setter(val)\n  }\n}\n</code></pre><h2>总结</h2><p>最后我们来回顾一下今天学到的内容。通过手写迷你的响应式原型，我们学习了Vue中响应式的地位和架构。</p><p>响应式的主要功能就是可以把普通的JavaScript对象封装成为响应式对象，<strong>在读取数据的时候通过track收集函数的依赖关系，把整个对象和effect注册函数的依赖关系全部存储在一个依赖图中</strong>。</p><p>定义的dependsMap是一个巨大的Map数据，effect函数内部读取的数据都会存储在dependsMap中，数据在修改的时候，通过查询dependsMap，获得需要执行的函数，再去执行即可。</p><p>dependsMap中存储的也不是直接存储effect中传递的函数，而是包装了一层对象对这个函数的执行实际进行管理，内部可以通过active管理执行状态，还可以通过全局变量shouldTrack控制监听状态，并且执行的方式也是判断scheduler和run方法，实现了对性能的提升。</p><p>我们在日常项目开发中也可以<strong>借鉴响应式的处理思路，使用通知的机制，来调用具体数据的操作和更新逻辑</strong>，灵活使用effect、ref、reactive等函数把常见的操作全部变成响应式数据处理，会极大的提高我们开发的体验和效率。</p><h2>思考题</h2><p>最后留一个思考题，Vue3.2对响应式有一个性能的进一步提升，你都了解到有哪些呢？欢迎你在评论区分享自己的思考，我们下一讲再见。</p>",
        article_title: "28｜响应式：万能的面试题，怎么手写响应式系统",
      },
      {
        title: "29｜运行时：Vue在浏览器里是怎么跑起来的？",
        id: 471006,
        content:
          '<p>你好，我是大圣。</p><p>上一讲我们学习了Vue响应式的大致原理，响应式就是可以把普通的JavaScript对象包裹成响应式对象，这样，我们对对象做的修改，响应式都能够监听到，并且执行effect内部注册的函数来执行数据修改之后的效果。</p><p>那今天我就跟你聊一下Vue在浏览器里是如何运行的，照例我们还是对着Vue 3的源码来学习，不过源码复杂，为了帮助你理解主要逻辑，我会直接把源码简化再演示，当然怎么简化源码的一些小技巧也会顺便分享给你。</p><p>好了废话不多说，我们马上开始。前端框架需要处理的最核心的两个流程，就是首次渲染和数据更新后的渲染。先来看首次渲染的源码。演示代码会用Vue 3的实际代码，你也可以在 <a href="https://github.com/shengxinjing/weiyouyi/blob/main/src/runtime-core/apiCreateApp.js#L4">weiyouyi</a> 项目中看到我们课程的mini版本代码。</p><h2>首次渲染</h2><p>我们知道，想要启动一个Vue项目，只需要从Vue中引入createApp，传入App组件，并且调用createApp返回的App实例的mount方法，就实现了项目的启动。这个时候Vue也完成了首次渲染，代码逻辑如下：</p><p><img src="https://static001.geekbang.org/resource/image/39/7c/3974d85351462f5190363869a39b1f7c.png?wh=1622x786" alt=""></p><p>所以createApp就是项目的初始化渲染入口。</p><p>但是这段简单的代码是怎么完成初始化渲染的呢？我们可以在Vue中的runtime-dom中看到createApp的定义，你可以打开 <a href="https://github.com/vuejs/vue-next/blob/master/packages/runtime-dom/src/index.ts#L66">GitHub链接</a>查看。</p><!-- [[[read_end]]] --><p>这里就有一个看代码的小技巧，分享给你，我们首次查看源码的时候，可以先把一些无用的信息删除，方便自己梳理主体的逻辑。看Vue代码，和今天主题无关的无用信息有哪些，__COMPAT__代码是用来兼容Vue 2的，__DEV__代码是用来调试的，我们可以把这些代码删除之后，得到下面的简化版createApp源码。</p><p>再看思路就比较清晰了。我们使用ensureRenderer返回的对象去创建app，并且重写了app.mount方法；在mount方法内部，我们查找mount传递的DOM元素，并且调用ensureRenderer返回的mount方法，进行初始化渲染。如下图所示：</p><p><img src="https://static001.geekbang.org/resource/image/70/82/7073e9c5b18e105a499e30208bd0c582.jpg?wh=2440x896" alt=""></p><p>之前我们讲过要会TypeScript，这时你就能感受到TypeScript的好处了，现在即使我们不知道app.mount是什么逻辑，也能知道这个函数的参数只能是Element、ShadowRoot或者string三者之一，也就很好理解内部的normalizeContainer就是把你传递的参数统一变为浏览器的DOM元素，Typescript类型带来的好处，我们在读源码的时候会一直感受得到。</p><pre><code class="language-javascript">export const createApp = ((...args) =&gt; {\n  const app = ensureRenderer().createApp(...args)\n  const { mount } = app\n  // 重写mount\n  app.mount = (containerOrSelector: Element | ShadowRoot | string): any =&gt; {\n    const container = normalizeContainer(containerOrSelector)\n    if (!container) return\n\n    const component = app._component\n    if (!isFunction(component) &amp;&amp; !component.render &amp;&amp; !component.template) {\n      component.template = container.innerHTML\n    }\n    container.innerHTML = \'\'\n    const proxy = mount(container, false, container instanceof SVGElement)\n    if (container instanceof Element) {\n      container.removeAttribute(\'v-cloak\')\n      container.setAttribute(\'data-v-app\', \'\')\n    }\n    return proxy\n  }\n  return app\n}) \nfunction normalizeContainer(container){\n  if (isString(container)) {\n    const res = document.querySelector(container)\n  }\n  return container\n}\n</code></pre><p>我们继续深入了解ensureRenderer方法，以及ensureRenderer方法返回的createApp方法。</p><p><strong>这里ensureRenderer函数，内部通过createRenderer函数，创建了一个浏览器的渲染器，并且缓存了渲染器renderer</strong>，这种使用闭包做缓存的方式，你在日常开发中也可以借鉴这种思路。</p><p>createRenderer函数，我们在自定义渲染器那一讲里学到过，传递的rendererOptions就是浏览器里面标签的增删改查API：</p><pre><code class="language-javascript">// 浏览器dom操作\nimport { nodeOps } from \'./nodeOps\'\n// 浏览器dom属性更新\nimport { patchProp } from \'./patchProp\'\nimport { createRenderer } from \'@vue/runtime-core\'\nconst rendererOptions = extend({ patchProp }, nodeOps)\n\nlet renderer: Renderer&lt;Element | ShadowRoot&gt; | HydrationRenderer\n\nfunction ensureRenderer() {\n  return (\n    renderer ||\n    (renderer = createRenderer&lt;Node, Element | ShadowRoot&gt;(rendererOptions))\n  )\n}  \n</code></pre><p>可以看到，createRenderer函数传递的参数是nodeOps和patchProp的合并对象。</p><p>我们继续进入nodeOps和pathProp也可以看到下面的代码，写了很多方法。通过ensureRenderer存储这些操作方法后，createApp内部就可以脱离具体的渲染平台了，这也是Vue 3实现跨端的核心逻辑：</p><pre><code class="language-javascript">export const nodeOps: Omit&lt;RendererOptions&lt;Node, Element&gt;, \'patchProp\'&gt; = {\n  insert: (child, parent, anchor) =&gt; {\n    parent.insertBefore(child, anchor || null)\n  },\n  remove: child =&gt; {\n    const parent = child.parentNode\n    if (parent) {\n      parent.removeChild(child)\n    }\n  },\n  createElement: (tag, isSVG, is, props): Element =&gt; {\n    const el = isSVG\n      ? doc.createElementNS(svgNS, tag)\n      : doc.createElement(tag, is ? { is } : undefined)\n\n    if (tag === \'select\' &amp;&amp; props &amp;&amp; props.multiple != null) {\n      ;(el as HTMLSelectElement).setAttribute(\'multiple\', props.multiple)\n    }\n    return el\n  },\n\n  createText: text =&gt; doc.createTextNode(text),\n\n  createComment: text =&gt; doc.createComment(text),\n\n  setText: (node, text) =&gt; {\n    node.nodeValue = text\n  },\n\n  setElementText: (el, text) =&gt; {\n    el.textContent = text\n  },\n  parentNode: node =&gt; node.parentNode as Element | null,\n  nextSibling: node =&gt; node.nextSibling,\n  querySelector: selector =&gt; doc.querySelector(selector),\n... \n}\n</code></pre><p>然后我们就需要进入到rumtime-core模块去看下createRenderer是如何工作的。你可以在这个<a href="https://github.com/vuejs/vue-next/blob/master/packages/runtime-core/src/renderer.ts#L290">GitHub链接</a>内看到createRenderer的代码逻辑。当然源码比较复杂，我们照样需要简化一下。</p><p>createRenderer是调用baseCreateRenderer创建的，baseCreateRenderer函数内部有十几个函数，代码行数合计2000行左右，这也是我们学习Vue源码最复杂的一个函数了。按前面简化源码的思路，先把工具函数的实现折叠起来，精简之后代码主要逻辑其实很简单。</p><p>我们一起来看。</p><p>首先获取了平台上所有的insert、remove函数，这些函数都是nodeOps传递进来的，然后定义了一些列patch、mount、unmount函数，通过名字我们不难猜出，这就是Vue中更新、渲染组件的工具函数，比如mountElement就是渲染DOM元素、mountComponent就是渲染组件updateComponent就是更新组件。这部分的简化代码，你也可以在<a href="https://github.com/shengxinjing/weiyouyi/blob/main/src/runtime-core/renderer.js">weiyouyi</a>项目中查看。</p><pre><code class="language-javascript">export function createRenderer&lt;\n  HostNode = RendererNode,\n  HostElement = RendererElement\n&gt;(options: RendererOptions&lt;HostNode, HostElement&gt;) {\n  return baseCreateRenderer&lt;HostNode, HostElement&gt;(options)\n}\n\nfunction baseCreateRenderer(){\n    const {\n    insert: hostInsert,\n    remove: hostRemove,\n    patchProp: hostPatchProp,\n    createElement: hostCreateElement,\n    createText: hostCreateText,\n    createComment: hostCreateComment,\n    setText: hostSetText,\n    setElementText: hostSetElementText,\n    parentNode: hostParentNode,\n    nextSibling: hostNextSibling,\n    setScopeId: hostSetScopeId = NOOP,\n    cloneNode: hostCloneNode,\n    insertStaticContent: hostInsertStaticContent\n  } = options\n  const patch = ()=&gt;... //一个函数\n  const processText = ()=&gt;...\n  const processCommentNode = ()=&gt;...\n  const processElement = ()=&gt;...\n  const mountElement = ()=&gt;...\n  const mountChildren = ()=&gt;...\n  const patchElement = ()=&gt;...\n  const patchBlockChildren = ()=&gt;...\n  const patchProps = ()=&gt;...\n  const processComponent = ()=&gt;...\n  const mountComponent = ()=&gt;...\n  const updateComponent = ()=&gt;...\n  const setupRenderEffect = ()=&gt;...\n  const patchChildren = ()=&gt;...\n  const patchKeyedChildren = ()=&gt;...\n  const unmount = ()=&gt;...\n  const unmountComponent = ()=&gt;...\n  const unmountComponent = ()=&gt;...\n  const unmountComponent = ()=&gt;...\n  const unmountComponent = ()=&gt;...\n  const render: RootRenderFunction = (vnode, container, isSVG) =&gt; {\n    if (vnode == null) {\n      if (container._vnode) {\n        unmount(container._vnode, null, null, true)\n      }\n    } else {\n      patch(container._vnode || null, vnode, container, null, null, null, isSVG)\n    }\n    flushPostFlushCbs()\n    container._vnode = vnode\n  }\n  return {\n    render,\n    hydrate,\n    createApp: createAppAPI(render, hydrate)\n  }\n}\n</code></pre><p>整个createApp函数的执行逻辑如下图所示：</p><p><img src="https://static001.geekbang.org/resource/image/cf/7b/cfcbf6cd3f3195518f9e0e407338a37b.jpg?wh=2526x2208" alt=""></p><p>最后返回的createApp方法，实际上是createAPI的返回值，并且给createAPI传递了render方法。render方法内部很简单，就是判断container容器上有没有_vnode属性，如果有的话就执行unmout方法，没有的话就执行patch方法，最后把vnode信息存储在container._vnode上。</p><p>那createAppAPI又做了什么呢？我们继续进入createAppAPI源码，看下面的代码。内部创建了一个app对象，app上注册了我们熟悉的use、component和mount等方法：</p><pre><code class="language-javascript">export function createAppAPI&lt;HostElement&gt;(\n  render: RootRenderFunction,\n  hydrate?: RootHydrateFunction\n): CreateAppFunction&lt;HostElement&gt; {\n  return function createApp(rootComponent, rootProps = null) {\n    const context = createAppContext()\n    let isMounted = false\n\n    const app: App = (context.app = {\n      _context: context,\n      _instance: null,\n      use(plugin: Plugin, ...options: any[]) ,\n      component(name: string, component?: Component): any {\n        if (!component) {\n          return context.components[name]\n        }\n        context.components[name] = component\n        return app\n      },\n      directive(name: string, directive?: Directive)\n      mount(\n        rootContainer: HostElement,\n        isHydrate?: boolean,\n        isSVG?: boolean\n      ): any {\n        if (!isMounted) {\n          const vnode = createVNode(\n            rootComponent as ConcreteComponent,\n            rootProps\n          )\n          vnode.appContext = context\n          // 核心的逻辑\n          if (isHydrate &amp;&amp; hydrate) {\n            hydrate(vnode as VNode&lt;Node, Element&gt;, rootContainer as any)\n          } else {\n            render(vnode, rootContainer, isSVG)\n          }\n          return getExposeProxy(vnode.component!) || vnode.component!.proxy\n        } \n      },\n\n      provide(key, value) {\n        context.provides[key as string] = value\n        return app\n      }\n    })\n\n    return app\n  }\n}\n</code></pre><p>可以看到mount内部执行的是传递进来的render方法，也就是上面的render方法。container 就是我们app.mount中传递的DOM元素，对DOM元素进行处理之后，执行patch函数实现整个应用的加载。</p><p>所以我们的下一个任务就是需要搞清楚patch函数的执行逻辑。</p><h3>patch 函数</h3><p>patch传递的是container._vnode，也就是上一次渲染缓存的vnode、本次渲染组件的vnode，以及容器container。</p><p>下面就是patch函数的代码，核心代码我添加了注释。其中n1是上次渲染的虚拟DOM，n2是下次要渲染的虚拟DOM。</p><p>首先可以把n1和n2做一次判断，如果虚拟DOM的节点类型不同，就直接unmount之前的节点。因为比如之前是Button组件，现在要渲染Container组件，就没有计算diff的必要，直接把Button组件销毁再渲染Container即可。</p><p>如果n1和n2类型相同，比如都是Button组件或者都是div标签，我们需要判断具体的类型再去执行不同的函数，比如processText、processFragment、processElement以及processComponent等函数。</p><p>看第55行，这里的ShapeFlags用到了位运算的知识，我们后面会通过刷算法题的方式介绍，暂时我们只需要知道，ShapeFlags可以帮助我们快速判断需要操作的类型就可以了。</p><pre><code class="language-javascript">  const patch: PatchFn = (\n    n1,\n    n2,\n    container,\n    anchor = null,\n    parentComponent = null,\n    parentSuspense = null,\n    isSVG = false,\n    slotScopeIds = null,\n    optimized = __DEV__ &amp;&amp; isHmrUpdating ? false : !!n2.dynamicChildren\n  ) =&gt; {\n    // 两次虚拟dom完全一样 啥也不用干\n    if (n1 === n2) {\n      return\n    }\n    // 虚拟dom节点类型不一样， unmount老的虚拟dom，并且n1赋值null\n    if (n1 &amp;&amp; !isSameVNodeType(n1, n2)) {\n      anchor = getNextHostNode(n1)\n      unmount(n1, parentComponent, parentSuspense, true)\n      n1 = null\n    }\n    // n2是要渲染的虚拟dom，我们获取type，ref和shapeFlag\n    const { type, ref, shapeFlag } = n2\n    switch (type) {\n      case Text:\n        // 文本\n        processText(n1, n2, container, anchor)\n        break\n      case Comment:\n        // 注释\n        processCommentNode(n1, n2, container, anchor)\n        break\n      case Static:\n        // 静态节点\n        if (n1 == null) {\n          mountStaticNode(n2, container, anchor, isSVG)\n        } else if (__DEV__) {\n          patchStaticNode(n1, n2, container, isSVG)\n        }\n        break\n      case Fragment:\n        processFragment(\n          n1,\n          n2,\n          container,\n          anchor,\n          parentComponent,\n          parentSuspense,\n          isSVG,\n          slotScopeIds,\n          optimized\n        )\n        break\n      default:\n        // 运运算判断操作类型\n        if (shapeFlag &amp; ShapeFlags.ELEMENT) {\n          // html标签\n          processElement(\n            n1,\n            n2,\n            container,\n            anchor,\n            parentComponent,\n            parentSuspense,\n            isSVG,\n            slotScopeIds,\n            optimized\n          )\n        } else if (shapeFlag &amp; ShapeFlags.COMPONENT) {\n          // 组件\n          processComponent(\n            n1,\n            n2,\n            container,\n            anchor,\n            parentComponent,\n            parentSuspense,\n            isSVG,\n            slotScopeIds,\n            optimized\n          )\n        } else if (shapeFlag &amp; ShapeFlags.TELEPORT) {\n          ;(type as typeof TeleportImpl).process(\n            n1 as TeleportVNode,\n            n2 as TeleportVNode,\n            container,\n            anchor,\n            parentComponent,\n            parentSuspense,\n            isSVG,\n            slotScopeIds,\n            optimized,\n            internals\n          )\n        } else if (__FEATURE_SUSPENSE__ &amp;&amp; shapeFlag &amp; ShapeFlags.SUSPENSE) {\n          ;(type as typeof SuspenseImpl).process(\n            n1,\n            n2,\n            container,\n            anchor,\n            parentComponent,\n            parentSuspense,\n            isSVG,\n            slotScopeIds,\n            optimized,\n            internals\n          )\n        } else if (__DEV__) {\n          warn(\'Invalid VNode type:\', type, `(${typeof type})`)\n        }\n    }\n\n    // set ref\n    if (ref != null &amp;&amp; parentComponent) {\n      setRef(ref, n1 &amp;&amp; n1.ref, parentSuspense, n2 || n1, !n2)\n    }\n  }\n</code></pre><p>代码的整体执行逻辑如下图所示：<img src="https://static001.geekbang.org/resource/image/c5/a8/c5c55f140c4573b698265c99bc9cf8a8.jpg?wh=1699x778" alt=""></p><p>我们首次渲染的App是一个组件，所以要执行的就是processComponent方法。</p><h3>processComponent方法</h3><p>那我们继续进入到processComponent代码内部，看下面的代码。首次渲染的时候，n1就是null，所以会执行mountComponent；如果是更新组件的时候，n1就是上次渲染的vdom，需要执行updateComponent。</p><pre><code class="language-javascript">  const processComponent = (\n    n1: VNode | null,\n    n2: VNode,\n    container: RendererElement,\n    anchor: RendererNode | null,\n    parentComponent: ComponentInternalInstance | null,\n    parentSuspense: SuspenseBoundary | null,\n    isSVG: boolean,\n    slotScopeIds: string[] | null,\n    optimized: boolean\n  ) =&gt; {\n    n2.slotScopeIds = slotScopeIds\n    if (n1 == null) {\n      if (n2.shapeFlag &amp; ShapeFlags.COMPONENT_KEPT_ALIVE) {\n        ;(parentComponent!.ctx as KeepAliveContext).activate(\n          n2,\n          container,\n          anchor,\n          isSVG,\n          optimized\n        )\n      } else {\n        mountComponent(\n          n2,\n          container,\n          anchor,\n          parentComponent,\n          parentSuspense,\n          isSVG,\n          optimized\n        )\n      }\n    } else {\n      updateComponent(n1, n2, optimized)\n    }\n  }\n</code></pre><p>updateComponent是虚拟DOM的逻辑，我们会在下一讲详细剖析，这一讲主要讲首次渲染的过程。</p><p>所以我们进入mountComponent函数中，可以看到mountComponent函数内部会对组件的类型进行一系列的判断，还有一些对Vue 2的兼容代码，核心的渲染逻辑就是setupComponent函数和setupRenderEffect函数。</p><pre><code class="language-javascript">import {setupComponent} from \'./component\'\n  const mountComponent: MountComponentFn = (\n  ) =&gt; {\n    // 2.x compat may pre-creaate the component instance before actually\n    // mounting\n    const compatMountInstance =\n      __COMPAT__ &amp;&amp; initialVNode.isCompatRoot &amp;&amp; initialVNode.component\n    const instance: ComponentInternalInstance =\n      compatMountInstance ||\n      (initialVNode.component = createComponentInstance(\n        initialVNode,\n        parentComponent,\n        parentSuspense\n      ))\n\n    // resolve props and slots for setup context\n    if (!(__COMPAT__ &amp;&amp; compatMountInstance)) {\n\n      setupComponent(instance)\n\n    }\n     (\n      instance,\n      initialVNode,\n      container,\n      anchor,\n      parentSuspense,\n      isSVG,\n      optimized\n    )\n\n    if (__DEV__) {\n      popWarningContext()\n      endMeasure(instance, `mount`)\n    }\n  }\n</code></pre><p>setupComponent和setupRenderEffect，它俩又做了点什么呢？可以参考下面的示意图这两个实现组件首次渲染的函数：<br>\n<img src="https://static001.geekbang.org/resource/image/d4/51/d4b431396eb7ef90e9ab0e1021f46051.jpg?wh=3213x1529" alt=""></p><h3>setupComponent</h3><p>首先看setupComponent，要完成的就是执行我们写的setup函数。</p><p>可以看到，内部先初始化了props和slots，并且执行setupStatefulComponent创建组件，而这个函数内部从component中获取setup属性，也就是script setup内部实现的函数，就进入到我们组件内部的reactive、ref等函数实现的逻辑了。</p><pre><code class="language-javascript">export function setupComponent(\n  instance: ComponentInternalInstance,\n  isSSR = false\n) {\n  isInSSRComponentSetup = isSSR\n\n  const { props, children } = instance.vnode\n  const isStateful = isStatefulComponent(instance)\n  initProps(instance, props, isStateful, isSSR)\n  initSlots(instance, children)\n\n  const setupResult = isStateful\n    ? setupStatefulComponent(instance, isSSR)\n    : undefined\n  isInSSRComponentSetup = false\n  return setupResult\n}\n\nfunction setupStatefulComponent(\n  instance: ComponentInternalInstance,\n  isSSR: boolean\n) {\n  const Component = instance.type as ComponentOptions\n  // 执行setup\n  const { setup } = Component\n  if (setup) {\n    const setupContext = (instance.setupContext =\n      setup.length &gt; 1 ? createSetupContext(instance) : null)\n\n    setCurrentInstance(instance)\n    pauseTracking()\n    const setupResult = callWithErrorHandling(\n      setup,\n      instance,\n      ErrorCodes.SETUP_FUNCTION,\n      [instance.props, setupContext]\n    )\n    if (isPromise(setupResult)) {\n      setupResult.then(unsetCurrentInstance, unsetCurrentInstance)\n    } else {\n      handleSetupResult(instance, setupResult, isSSR)\n    }\n  } else {\n    finishComponentSetup(instance, isSSR)\n  }\n}\n\nexport function callWithErrorHandling(\n  fn: Function,\n  instance: ComponentInternalInstance | null,\n  type: ErrorTypes,\n  args?: unknown[]\n) {\n  let res\n  try {\n    res = args ? fn(...args) : fn()\n  } catch (err) {\n    handleError(err, instance, type)\n  }\n  return res\n}\n</code></pre><h3>setupRenderEffect</h3><p>另一个setupRenderEffect函数，就是为了后续数据修改注册的函数，我们先梳理一下核心的实现逻辑。</p><p>组件首次加载会调用patch函数去初始化子组件，注意setupRenderEffect本身就是在patch函数内部执行的，所以这里就会递归整个虚拟DOM树，然后触发生命周期mounted，完成这个组件的初始化。</p><p>页面首次更新结束后，setupRenderEffect不仅实现了组件的递归渲染，还注册了组件的更新机制。</p><p>在下面的核心代码中，我们通过ReactiveEffect创建了effect函数，这个概念上一讲我们手写过，然后执行instance.update赋值为effect.run方法，这样结合setup内部的ref和reactive绑定的数据，数据修改之后，就会触发update方法的执行，内部就会componentUpdateFn，内部进行递归的patch调用执行每个组件内部的update方法实现组件的更新。</p><pre><code class="language-javascript">    if (!instance.isMounted) {\n         patch(\n            null,\n            subTree,\n            container,\n            anchor,\n            instance,\n            parentSuspense,\n            isSVG\n          )\n    }else{\n      // updateComponent\n    }\n    // create reactive effect for rendering\n    const effect = new ReactiveEffect(\n      componentUpdateFn,\n      () =&gt; queueJob(instance.update),\n      instance.scope // track it in component\'s effect scope\n    )\n\n    const update = (instance.update = effect.run.bind(effect) as SchedulerJob)\n    update.id = instance.uid\n\n    update()\n</code></pre><p>这样我们就实现了整个Vue的渲染和更新流程。</p><h2>总结</h2><p>今天要学的内容就聊完了，我们来总结一下学到的内容吧，今天我们分析了Vue 3在浏览器中执行的全流程，你可以配合Vue在浏览器中执行的流程图来复习。<br>\n<img src="https://static001.geekbang.org/resource/image/5f/f7/5f2527dd6eb75120bc3644cdfa5636f7.jpg?wh=6962x3378" alt=""></p><p>Vue通过createApp创建应用，并且执行返回的mount方法实现在浏览器中的挂载，在createApp中，通过传递浏览器平台的操作方法nodeOps创建了浏览器的渲染器renderer。</p><p>首次执行Vue项目的时候，通过patch实现组件的渲染，patch函数内部根据节点的不同类型，去分别执行processElement、processComponent、processText等方法去递归处理不同类型的节点，最终通过setupComponent执行组件的setup函数，setupRenderEffect中使用响应式的effect函数监听数据的变化。</p><p>你可以先看我们实现的迷你版本项目weiyouyi，然后再去看Vue 3中实际的代码，可以学习代码中很多优秀的设计思路，比如createRenderer中使用闭包作为缓存、使用位运算来提高组件类型的判断效率等。学习优秀框架中的代码设计，这对我们日常开发项目的代码质量也有很好的提高作用。</p><h2>思考题</h2><p>最后留一个思考题，mount函数中除了render函数，还有一个hydrate的函数调用，这个函数式干什么用的呢？欢迎在评论区分享你的答案，我们下一讲再见。</p>',
        article_title: "29｜运行时：Vue在浏览器里是怎么跑起来的？",
      },
      {
        title: "30｜虚拟DOM（上）：如何通过虚拟DOM更新页面？",
        id: 471011,
        content:
          '<p>你好，我是大圣。</p><p>上一讲我们主要介绍了Vue项目的首次渲染流程，在mountComponent中注册了effect函数，这样，在组件数据有更新的时候，就会通知到组件的update方法进行更新。</p><p>Vue中组件更新的方式也是使用了响应式+虚拟DOM的方式，这个我们在第一讲中有介绍过Vue 1、Vue 2和Vue 3中更新方式的变化，今天我们就来详细剖析一下Vue组件内部如何通过虚拟DOM更新页面的代码细节。</p><h2>Vue虚拟DOM执行流程</h2><p>我们从虚拟DOM在Vue的执行流程开始讲起。在Vue中，我们使用虚拟DOM来描述页面的组件，比如下面的template虽然格式和HTML很像，但是在Vue的内部会解析成JavaScript函数，这个函数就是用来返回虚拟DOM：</p><pre><code class="language-javascript">&lt;div id="app"&gt;\n  &lt;p&gt;hello world&lt;/p&gt;\n  &lt;Rate :value="4"&gt;&lt;/Rate&gt;\n&lt;/div&gt;\n</code></pre><p>上面的template会解析成下面的函数，最终返回一个JavaScript的对象能够描述这段HTML：</p><pre><code class="language-javascript">function render(){\n  return h(\'div\',{id:"app"},children:[\n    h(\'p\',{},\'hello world\'),\n    h(Rate,{value:4}),\n  ])\n}\n</code></pre><!-- [[[read_end]]] --><p>知道虚拟DOM是什么之后，那么它是怎么创建的呢？</p><h3>DOM的创建</h3><p>我们简单回忆上一讲介绍的<a href="https://github.com/vuejs/vue-next/blob/master/packages/runtime-core/src/apiCreateApp.ts#L283">mount函数</a>，在代码中，我们使用createVNode函数创建项目的虚拟DOM，可以看到<strong>Vue内部的虚拟DOM，也就是vnode，就是一个对象，通过type、props、children等属性描述整个节点</strong>：</p><pre><code class="language-javascript">const vnode = createVNode(    \n  rootComponent as ConcreteComponent,\n  rootProps\n)\nfunction _createVNode() {\n\n  // 处理属性和\bclass\n  if (props) {\n    ...\n  }\n\n  // 标记vnode信息\n  const shapeFlag = isString(type)\n    ? ShapeFlags.ELEMENT\n    : __FEATURE_SUSPENSE__ &amp;&amp; isSuspense(type)\n    ? ShapeFlags.SUSPENSE\n    : isTeleport(type)\n    ? ShapeFlags.TELEPORT\n    : isObject(type)\n    ? ShapeFlags.STATEFUL_COMPONENT\n    : isFunction(type)\n    ? ShapeFlags.FUNCTIONAL_COMPONENT\n    : 0\n\n  return createBaseVNode(\n    type,\n    props,\n    children,\n    patchFlag,\n    dynamicProps,\n    shapeFlag,\n    isBlockNode,\n    true\n  )\n}\n\nfunction createBaseVNode(type,props,children,...){\n    const vnode = {\n    type,\n    props,\n    key: props &amp;&amp; normalizeKey(props),\n    ref: props &amp;&amp; normalizeRef(props),\n    children,\n    shapeFlag,\n    patchFlag,\n    dynamicProps,\n     ...\n  } as VNode\n  // 标准化子节点\n  if (needFullChildrenNormalization) {\n    normalizeChildren(vnode, children)\n  } else if (children) {\n    vnode.shapeFlag |= isString(children)\n      ? ShapeFlags.TEXT_CHILDREN\n      : ShapeFlags.ARRAY_CHILDREN\n  }\n  return vnode\n}componentUpdateFn\n</code></pre><p>createVNode负责创建Vue中的虚拟DOM，而上一讲中我们讲过mount函数的核心逻辑就是使用setupComponent执行我们写的&lt;script setup&gt;，使用setupRenderEffect监听组件的数据变化。所以我们来到setupRenderEffect\b函数中，去完整地剖析Vue中虚拟DOM的更新逻辑。</p><p>我们给组件注册了update方法，这个方法使用effect包裹后，当组件内的ref、reactive包裹的响应式数据变化的时候就会执行update方法，触发组件内部的更新机制。</p><p>看下面的代码，在setupRenderEffect内部的componentUpdateFn中，updateComponentPreRenderer更新了属性和slots，并且调用renderComponentRoot函数创建新的子树对象nextTree，然后内部依然是调用patch函数。</p><p>可以看到，<strong>Vue源码中的实现首次渲染和更新的逻辑都写在一起，我们在递归的时候如果对一个标签实现更新和渲染，就可以用一个函数实现</strong>。</p><pre><code class="language-javascript">const componentUpdateFn = ()=&gt;{\n  if (!instance.isMounted) {\n      //首次渲染\n      instance,\n        parentSuspense,\n        isSVG\n      )\n      。。。\n  }else{\n    let { next, bu, u, parent, vnode } = instance\n    if (next) {\n      next.el = vnode.el\n      updateComponentPreRender(instance, next, optimized)\n    } else {\n      next = vnode\n    }\n    const nextTree = renderComponentRoot(instance)\n      patch(\n        prevTree,\n        nextTree,\n        // parent may have changed if it\'s in a teleport\n        hostParentNode(prevTree.el!)!,\n        // anchor may have changed if it\'s in a fragment\n        getNextHostNode(prevTree),\n        instance,\n        parentSuspense,\n        isSVG\n      )\n    }\n}\n\n// 注册effect函数\nconst effect = new ReactiveEffect(\n  componentUpdateFn,\n  () =&gt; queueJob(instance.update),\n  instance.scope // track it in component\'s effect scope\n)\nconst update = (instance.update = effect.run.bind(effect) as S      chedulerJob)\nupdate()\n\n  const updateComponentPreRender = (\n    instance: ComponentInternalInstance,\n    nextVNode: VNode,\n    optimized: boolean\n  ) =&gt; {\n    nextVNode.component = instance\n    const prevProps = instance.vnode.props\n    instance.vnode = nextVNode\n    instance.next = null\n    updateProps(instance, nextVNode.props, prevProps, optimized)\n    updateSlots(instance, nextVNode.children, optimized)\n\n    pauseTracking()\n    // props update may have triggered pre-flush watchers.\n    // flush them before the render update.\n    flushPreFlushCbs(undefined, instance.update)\n    resetTracking()\n  }\n</code></pre><p>比较关键的就是上面代码中32-39行的<strong>effect函数，负责注册组件，这个函数也是Vue组件更新的入口函数。</strong></p><h2>patch函数</h2><p>数据更新之后就会执行patch函数，下图就是patch函数执行的逻辑图：</p><p><img src="https://static001.geekbang.org/resource/image/22/57/22ba20304eef70af5c5a50bb9b601057.jpeg?wh=3308x1786" alt=""></p><p>在patch函数中，会针对不同的组件类型执行不同的函数，组件我们会执行processComponent，HTML标签我们会执行processElement：</p><pre><code class="language-javascript">  function path(n1, n2, container){\n    const { type, shapeFlag } = n2\n    switch (type) {\n      case Text:\n        processText(n1, n2, container)\n        break\n      // 还有注释，fragment之类的可以处理，这里忽略\n      default:\n        // 通过shapeFlag判断类型\n        if (shapeFlag &amp; ShapeFlags.ELEMENT) {\n          processElement(n1, n2, container, anchor)\n        } else if (shapeFlag &amp; ShapeFlags.STATEFUL_COMPONENT) {\n          processComponent(n1, n2, container)\n        }\n    }\n    \n  }\n\n  function processComponent(n1, n2, container) {\n    // 老规矩，么有n1就是mount\n    if (!n1) {\n      // 初始化 component\n      mountComponent(n2, container)\n    } else {\n      updateComponent(n1, n2, container)\n    }\n  }\n</code></pre><p>由于更新之后不是首次渲染了，patch函数内部会执行updateComponent，看下面的updateComponent函数内部，shouldUpdateComponent会判断组件是否需要更新，实际执行的是instance.update：</p><pre><code class="language-javascript">const instance = (n2.component = n1.component)!\nif (shouldUpdateComponent(n1, n2, optimized)) {\n\n  // normal update\n  instance.next = n2\n  // in case the child component is also queued, remove it to avoid\n  // double updating the same child component in the same flush.\n  invalidateJob(instance.update)\n  // instance.update is the reactive effect.\n  instance.update()\n  \n} else {\n  // no update needed. just copy over properties\n  n2.component = n1.component\n  n2.el = n1.el\n  instance.vnode = n2\n}\n</code></pre><p>组件的子元素是由HTML标签和组件构成，组件内部的递归处理最终也是对HTML标签的处理，所以，最后组件的更新都会进入到processElement内部的patchElement函数中。</p><h3>patchElement函数</h3><p>在函数patchElement中我们主要就做两件事，更新节点自己的属性和更新子元素。</p><h3>节点自身属性的更新</h3><p>先看自身属性的更新，这里就能体现出<strong>Vue 3中性能优化的思想，通过patchFlag可以做到按需更新</strong>：</p><ul>\n<li>如果标记了FULL_PROPS，就直接调用patchProps。</li>\n<li>如果标记了CLASS，说明节点只有class属性是动态的，其他的style等属性都不需要进行判断和DOM操作。</li>\n</ul><p>这样就极大的优化了属性操作的性能。</p><p>内部执行hostPatchProp进行实际的DOM操作，你还记得上一讲中hostPatchProp是从nodeOps中定义的吗，其他动态属性STYLE、TEXT等等也都是一样的逻辑。Vue 3的虚拟DOM真正做到了按需更新，这也是相比于React的一个优势。</p><pre><code class="language-javascript">  const patchElement = (\n    n1: VNode,\n    n2: VNode,\n    parentComponent: ComponentInternalInstance | null,\n    parentSuspense: SuspenseBoundary | null,\n    isSVG: boolean,\n    slotScopeIds: string[] | null,\n    optimized: boolean\n  ) =&gt; {\n    const el = (n2.el = n1.el!)\n    let { patchFlag, dynamicChildren, dirs } = n2\n    patchFlag |= n1.patchFlag &amp; PatchFlags.FULL_PROPS\n\n    const oldProps = n1.props || EMPTY_OBJ\n    const newProps = n2.props || EMPTY_OBJ\n\n    // full diff\n    patchChildren(\n      n1,\n      n2,\n      el,\n      null,\n      parentComponent,\n      parentSuspense,\n      areChildrenSVG,\n      slotScopeIds,\n      false\n    )\n\n    if (patchFlag &gt; 0) {\n\n      if (patchFlag &amp; PatchFlags.FULL_PROPS) {\n        patchProps(\n          el,\n          n2,\n          oldProps,\n          newProps,\n          parentComponent,\n          parentSuspense,\n          isSVG\n        )\n      } else {\n        // class是动态的\n        if (patchFlag &amp; PatchFlags.CLASS) {\n          if (oldProps.class !== newProps.class) {\n            hostPatchProp(el, \'class\', null, newProps.class, isSVG)\n          }\n        }\n\n        // style样式是动态的\n        if (patchFlag &amp; PatchFlags.STYLE) {\n          hostPatchProp(el, \'style\', oldProps.style, newProps.style, isSVG)\n        }\n\n        // 属性需要diff\n        if (patchFlag &amp; PatchFlags.PROPS) {\n          // \n          const propsToUpdate = n2.dynamicProps!\n          for (let i = 0; i &lt; propsToUpdate.length; i++) {\n            const key = propsToUpdate[i]\n            const prev = oldProps[key]\n            const next = newProps[key]\n            // #1471 force patch value\n            if (next !== prev || key === \'value\') {\n              hostPatchProp(\n                el,\n                key,\n                prev,\n                next,\n                isSVG,\n                n1.children as VNode[],\n                parentComponent,\n                parentSuspense,\n                unmountChildren\n              )\n            }\n          }\n        }\n      }\n      //文本是动态的\n      if (patchFlag &amp; PatchFlags.TEXT) {\n        if (n1.children !== n2.children) {\n          hostSetElementText(el, n2.children as string)\n        }\n      }\n    } \n  }\n</code></pre><h3>子元素的更新</h3><p>而子元素的更新是patchChildren 函数负责的，这个函数也是虚拟DOM中难度最高的一个函数，搞懂它还需要我们下一讲中介绍的算法知识，今天我们就先理解它主要的实现思路。</p><p><strong>首先我们把子元素分成了文本、数组和空三个状态，新老子元素分别是这三种状态的一个，构成了不同的执行逻辑</strong>。这样patchChildren内部大致有五种情况需要处理：</p><ul>\n<li>如果新的子元素是空， 老的子元素不为空，直接卸载unmount即可。</li>\n<li>如果新的子元素不为空，老的子元素是空，直接创建加载即可。</li>\n<li>如果新的子元素是文本，老的子元素如果是数组就需要全部unmount，是文本的话就需要执行hostSetElementText。</li>\n<li>如果新的子元素是数组，比如是使用v-for渲染出来的列表，老的子元素如果是空或者文本，直接unmout后，渲染新的数组即可。</li>\n</ul><p>最复杂的情况就是新的子元素和老的子元素都是数组。</p><p>最朴实无华的思路就是把老的子元素全部unmount，新的子元素全部mount，这样虽然可以实现功能，但是没法复用已经存在的DOM元素，比如我们只是在数组中间新增了一个数据，全部DOM都销毁就有点太可惜了。</p><p><strong>所以，我们需要判断出可以复用的DOM元素，如果一个虚拟DOM没有改动或者属性变了，不需要完全销毁重建，而是更新一下属性，最大化减少DOM的操作</strong>，这个任务就会交给patchKeyedChildren函数去完成。</p><p>patchKeyedChildren函数，做的事情就是尽可能高效地把老的子元素更新成新的子元素，如何高效复用老的子元素中的DOM元素是patchKeyedChildren函数的难点：</p><pre><code class="language-javascript">  const patchChildren: PatchChildrenFn = (\n    n1,\n    n2,\n    container,\n    anchor,\n    parentComponent,\n    parentSuspense,\n    isSVG,\n    slotScopeIds,\n    optimized = false\n  ) =&gt; {\n    const c1 = n1 &amp;&amp; n1.children\n    const prevShapeFlag = n1 ? n1.shapeFlag : 0\n    const c2 = n2.children\n\n    const { patchFlag, shapeFlag } = n2\n    // fast path\n    if (patchFlag &gt; 0) {\n      if (patchFlag &amp; PatchFlags.KEYED_FRAGMENT) {\n        // this could be either fully-keyed or mixed (some keyed some not)\n        // presence of patchFlag means children are guaranteed to be arrays\n        patchKeyedChildren(\n          c1 as VNode[],\n          c2 as VNodeArrayChildren,\n          container,\n          anchor,\n          parentComponent,\n          parentSuspense,\n          isSVG,\n          slotScopeIds,\n          optimized\n        )\n        return\n      } else if (patchFlag &amp; PatchFlags.UNKEYED_FRAGMENT) {\n        // unkeyed\n        patchUnkeyedChildren(\n          c1 as VNode[],\n          c2 as VNodeArrayChildren,\n          container,\n          anchor,\n          parentComponent,\n          parentSuspense,\n          isSVG,\n          slotScopeIds,\n          optimized\n        )\n        return\n      }\n    }\n\n    // children has 3 possibilities: text, array or no children.\n    if (shapeFlag &amp; ShapeFlags.TEXT_CHILDREN) {\n      // text children fast path\n      if (prevShapeFlag &amp; ShapeFlags.ARRAY_CHILDREN) {\n        unmountChildren(c1 as VNode[], parentComponent, parentSuspense)\n      }\n      if (c2 !== c1) {\n        hostSetElementText(container, c2 as string)\n      }\n    } else {\n      if (prevShapeFlag &amp; ShapeFlags.ARRAY_CHILDREN) {\n        // prev children was array\n        if (shapeFlag &amp; ShapeFlags.ARRAY_CHILDREN) {\n          // two arrays, cannot assume anything, do full diff\n          patchKeyedChildren(\n            c1 as VNode[],\n            c2 as VNodeArrayChildren,\n            container,\n            anchor,\n            parentComponent,\n            parentSuspense,\n            isSVG,\n            slotScopeIds,\n            optimized\n          )\n        } else {\n          // no new children, just unmount old\n          unmountChildren(c1 as VNode[], parentComponent, parentSuspense, true)\n        }\n      } else {\n        // prev children was text OR null\n        // new children is array OR null\n        if (prevShapeFlag &amp; ShapeFlags.TEXT_CHILDREN) {\n          hostSetElementText(container, \'\')\n        }\n        // mount new if array\n        if (shapeFlag &amp; ShapeFlags.ARRAY_CHILDREN) {\n          mountChildren(\n            c2 as VNodeArrayChildren,\n            container,\n            anchor,\n            parentComponent,\n            parentSuspense,\n            isSVG,\n            slotScopeIds,\n            optimized\n          )\n        }\n      }\n    }\n  }\n</code></pre><p>上面的代码执行逻辑如下图所示，根据flags判断子元素的类型后，执行不同的操作函数：<br>\n<img src="https://static001.geekbang.org/resource/image/91/dd/916797a1c1c4b375bf41b2a6321239dd.jpeg?wh=2246x1926" alt=""></p><h3>patchChildren</h3><p>最后就剩下patchChildren的实现了，这也是各类虚拟DOM框架中最难实现的函数，我们需要实现<strong>一个高效的更新算法，能够使用尽可能少的更新次数，来实现从老的子元素到新的子元素的更新</strong>。</p><p>举个例子，类似体育课站队的时候，大家一开始站一排，但是顺序是乱的，我们需要尽快把队伍按照个头左低右高排列。</p><p>在React中，这种场景的处理逻辑是先进行循环，使用的是单侧插入的算法，我们在排队的时候挨个对比，如果你站我右边，并且个头比我高一点，说明咱俩的相对位置和最终队伍的位置是一致的，暂时不需要变化，如果你比我个头矮，就需要去我左边找到一个正确的位置插队进去。</p><p>由于都只向单侧插入，最后我们就会把所有的节点移动到正确的位置之上，这就是React15框架内虚拟节点diff的逻辑，初步实现了DOM的复用；而Vue 2借鉴了snabbdom的算法，在此基础上做了第一层双端对比的优化。</p><p>首先Web场景之下对一个数组元素的操作，很少有直接全部替换的，<strong>比如我们操作一个表格，大概率是更关心表格某一行的一个字段、新增一行、删除一行，或者是对表格某个字段进行排序，所以我们可以从纯算法的场景之中加入实际应用的场景</strong>。</p><p>如果我们只是在表格里新增一行，那么可以不要一开始就开始循环，而是可以先进行节点的预判。</p><p>比如，在下面的例子中，新的节点就是在老的节点中新增和删除了几个元素，我们在循环之前，先进行头部元素的判断。在这个例子里，可以预判出头部元素的a、b、c、d是一样的节点，说明节点不需要重新创建，我们只需要进行属性的更新，然后进行队尾元素的预判，可以判断出g和元素也是一样的：</p><pre><code class="language-javascript">a b c d e f g h\na b c d i f j g h \n</code></pre><p>这样我们虚拟DOM diff的逻辑就变成了下面的结构, 现在只需要比较ef和ifg的区别：</p><pre><code class="language-javascript">(a b c d) e f (g h)\n(a b c) d) i f j (g h) \n</code></pre><p>相比于之前的对比场景，我们需要遍历的运算量就大大减小了。</p><p>而且，有很多场景比如新增一行或者删除一行的简单场景，预判完毕之后，新老元素有一个处于没有元素的状态，我们就可以直接执行mount或者unmout完成对比的全过程，不需要再进行复杂的遍历：</p><pre><code class="language-javascript">(a b c d)\n(a b c d) e\n\n(a b c) d\n(a b c\n</code></pre><p>双端对比的原理大致就是这样。最后双端对比之后的执行逻辑这一部分需要一些算法知识，我们下一讲会详细介绍，这里你只需要掌握大概的思路。</p><p>想让一个队伍尽快按照个头排好序，如果能够计算出，在队伍中，个头从低到高依次递增的最多的队列，让这些人站在原地不动，其余人穿插到他们中间，就可以最大化减少人员的移动，这就是一个最长底层子序列的算法问题，我们下一讲详细剖析。</p><h2>总结</h2><p>今天的内容就讲完了，来总结一下吧，我们学习了Vue中的更新逻辑。现在Vue执行逻辑全景图变成了下面的样子，新增了组件更新的逻辑：</p><p><img src="https://static001.geekbang.org/resource/image/65/5f/654ab0a0e9834ab72e16bee6bb79b95f.jpeg?wh=6926x4089" alt=""></p><p>Vue响应式驱动了组件之间的数据通信机制，数据更新之后，组件会执行intance.update方法，update方法内部执行patch方法进行新老子树的diff计算。</p><p>在更新函数中，主要做了两件事，pathProps更新节点自身的属性，这里面使用了pathFlags做到了按需更新；patchChildren执行子元素的更新。其中patch函数内部会只对节点内部的动态属性做更新，这种按需更新的机制是Vue性能优秀的一个原因。</p><p>函数内部针对新老子元素不同的状态，执行不同的逻辑。根据子元素是否为空或者数组，以及新元素是否为空或者数组，分别执行对应的删除或者mount逻辑，其中最复杂的就是新的子元素和老的子元素都是数组。</p><p>为了最大化减少DOM操作，patchKeyedChildren使用了最长递增子序列来实现，并且相比于React的虚拟DOM diff，新增了双端的预先判断+最长递增子序列算法来实现，这也是Vue性能比较优秀的另外一个原因。</p><h2>思考题</h2><p>最后再留一个思考题，从虚拟DOM更新的角度，为什么我们在写v-for循环的时候，都要建议使用key属性呢？欢迎在评论区留下你的答案，也欢迎你把这一讲分享给你的同事和朋友们，我们下一讲再见。</p>',
        article_title: "30｜虚拟DOM（上）：如何通过虚拟DOM更新页面？",
      },
      {
        title: "31｜虚拟DOM（下）：想看懂虚拟DOM算法，先刷个算法题",
        id: 471017,
        content:
          '<p>你好，我是大圣。上一讲我们仔细分析了Vue中虚拟DOM如何执行的，整体流程就是树形结构的diff计算，但是在diff的计算过程中，如何高效计算虚拟DOM属性的变化，以及如何更新数组的子元素，需要一些算法知识的补充。</p><p>给你提前划个重点，今天我们将讲到如何使用位运算来实现Vue中的按需更新，让静态的节点可以越过虚拟DOM的计算逻辑，并且使用计算最长递增子序列的方式，来实现队伍的高效排序。我们会剖析Vue框架源码，结合对应的LeetCode题，帮助你掌握算法的核心原理和实现。</p><h2>位运算</h2><p>前面也复习了，在执行diff之前，要根据需要判断每个虚拟DOM节点有哪些属性需要计算，因为无论响应式数据怎么变化，静态的属性和节点都不会发生变化。</p><p>所以我们看每个节点diff的时候会做什么，在renderer.ts代码文件中就可以看到代码，主要就是通过虚拟DOM节点的patchFlag树形判断是否需要更新节点。</p><p><strong>方法就是使用&amp;操作符来判断操作的类型</strong>，比如patchFlag &amp; PatchFlags.CLASS来判断当前元素的class是否需要计算diff；shapeFlag &amp; ShapeFlags.ELEMENT来判断当前虚拟DOM是HTML元素还是Component组件。这个“&amp;”其实就是位运算的按位与。</p><!-- [[[read_end]]] --><pre><code class="language-javascript">// class\n// this flag is matched when the element has dynamic class bindings.\nif (patchFlag &amp; PatchFlags.CLASS) {\n  if (oldProps.class !== newProps.class) {\n    hostPatchProp(el, \'class\', null, newProps.class, isSVG)\n  }\n}\n\n// style\n// this flag is matched when the element has dynamic style bindings\nif (patchFlag &amp; PatchFlags.STYLE) {\n  hostPatchProp(el, \'style\', oldProps.style, newProps.style, isSVG)\n}\nif (shapeFlag &amp; ShapeFlags.ELEMENT) {\n  processElement(\n    n1,\n    n2,\n    container,\n    anchor,\n    parentComponent,\n    parentSuspense,\n    isSVG,\n    slotScopeIds,\n    optimized\n  )\n} else if (shapeFlag &amp; ShapeFlags.COMPONENT) {\n  processComponent(\n    n1,\n    n2,\n    container,\n    anchor,\n    parentComponent,\n    parentSuspense,\n    isSVG,\n    slotScopeIds,\n    optimized\n  )\n}\n</code></pre><p>上面的代码中 &amp; 就是按位与的操作符，这其实是二进制上的计算符号，所以我们首先要了解一下什么是二进制。</p><p>我们日常使用的数字都是十进制数字，比如数字13就是 1*10+3 的运算结果，每个位置都是代表10的n次方。13也可以使用二进制表达，因为二进制每个位置只能是0和1两个数字，每个位置代表的是2的n次方，13在二进制里是1101，就是1*8+1*4+0*2+1*1。</p><p>而在JavaScript中我们可以很方便地使用toString(2)的方式，把十进制数字转换成二进制。运算的概念很简单，就是在二进制上的“与”和“或”运算：</p><pre><code class="language-javascript">(13).toString(2) // 1101\n\n0 &amp; 0  // 0\n0 &amp; 1  // 0\n1 &amp; 0  // 0\n1 &amp; 1  // 1\n\n0 | 0  // 0\n0 | 1  // 1\n1 | 0  // 1\n1 | 1  // 1 \n\n1 &lt;&lt; 2 // 1左移动两位，就是100  就是1*2平方 = 4\n</code></pre><p>二进制中，我们每个位置只能是0或者1这两个值，&amp;和 | 的概念和JavaScript中的&amp;&amp;和 || 保持一致。两个二进制的&amp;运算就是只有两个二进制位置都是1的时候，结果是1，其余情况运算结果都是0；| 是按位置进行“或”运算，只有两个二进制位置都是0的时候，结果是0，其余情况运算结果都是1；并且，还可以通过左移&lt;&lt; 和右移&gt;&gt;操作符，实现乘以2和除以2的效果。</p><p>由于<strong>这些都是在二进制上的计算，运算的性能通常会比字符串和数字的计算性能要好</strong>，这也是很多框架内部使用位运算的原因。</p><p>这么说估计你不是很理解，我们结合一个LeetCode题看看为什么说二进制的位运算性能更好。</p><h3>为什么位运算性能更好</h3><p>我们来做一下LeetCode231题，题目描述很简单，判断数字n是不是2的幂次方，也就是说，判断数字n是不是2的整次方，比如2、4、8。我们可以很轻松地写出JavaScript的解答，n一直除以2，如果有余数就是false，否则就是true：</p><pre><code class="language-javascript">var isPowerOfTwo = function(n) {\n    if(n === 1) return true\n    while( n &gt; 2 ){\n        n = n / 2\n        if(n % 2 !== 0) return false\n    }\n    return n===2\n\n};\n</code></pre><p>不过上面的解答我们可以用位运算来优化。</p><p>先来分析一下2的幂次方的特点。</p><p>2的幂次方就是数字1左移动若干次，其余位置全部都是0，所以n-1就是最高位变成0，其余位置都变成1，就像十进制里的10000-1 = 9999。这样，<strong>n和n-1每个二进制位的数字都不一样，我们可以很轻松地用按位“与”来判断这个题的答案</strong>，如果n&amp;n-1是0的话，数字n就符合2的整次幂的特点：</p><pre><code class="language-javascript">16\n10000\n16-1 = 15\n01111\n16&amp;15 == 0\n\nvar isPowerOfTwo = function(n) {\n    return n&gt;0 &amp;&amp; (n &amp; (n - 1)) === 0\n};\n</code></pre><p>所以我们使用位运算提高了代码的整体性能。</p><h3>如何运用位运算</h3><p>好，搞清楚为什么用位运算，我们回来看diff判断，如何根据位运算的特点，设计出权限的组合认证方案。</p><p>比如Vue中的动态属性，有文本、class、style、props几个属性，我们可以使用二进制中的一个位置来表示权限，看下面的代码，<strong>我们使用左移的方式分别在四个二进制上标记了1，代表四种不同的权限，使用按位或的方式去实现权限授予</strong>。</p><p>比如，一个节点如果TEXT和STYLE都需要修改，我们只需要使用 | 运算符就可以得到flag1的权限表示，这就是为什么Vue 3 中针对虚拟DOM类型以及虚拟DOM需要动态计算diff的树形都做了标记，你可以在<a href="https://github.com/vuejs/vue-next/blob/master/packages/shared/src/patchFlags.ts#L28">Vue 3的源码</a>中看到下面的配置：</p><pre><code class="language-javascript">const PatchFlags = {\n  TEXT:1,      // 0001\n  CLASS: 1&lt;&lt;1, // 0010\n  STYLE:1&lt;&lt;2,  // 0100 \n  PROPS:1&lt;&lt;3   // 1000\n}\n\nconst flag1 = PatchFlags.TEXT | PatchFlags.STYLE // 0101\n\n// 权限校验\n\nflag1 &amp; PatchFlags.TEXT  // 有权限，结果大于1\nflag1 &amp; PatchFlags.CLASS //没有权限 是0\n</code></pre><h2>最长递增子系列</h2><p>然后就到了今天的重点：我们虚拟DOM计算diff中的算法了。</p><p>上一讲我们详细介绍了在虚拟diff计算中，如果新老子元素都是数组的时候，需要先做首尾的预判，如果新的子元素和老的子元素在预判完毕后，未处理的元素依然是数组，那么就需要对两个数组计算diff，最终找到最短的操作路径，能够让老的子元素通过尽可能少的操作，更新成为新的子元素。</p><p>Vue 3借鉴了infero的算法逻辑，就像操场上需要按照个头从低到高站好一样，我们采用的思路是先寻找一个现有队列中由低到高的队列，让这个队列尽可能的长，它们的相对位置不需要变化，而其他元素进行插入和移动位置，这样就可以做到尽可能少的操作DOM。</p><p>所以如何寻找这个最长递增的序列呢？这就是今天的重点算法知识了，我们看<a href="https://leetcode-cn.com/problems/longest-increasing-subsequence">LeetCode第300题</a>，题目描述如下, 需要在数组中找到最长底层的自序列长度：</p><pre><code class="language-plain">给你一个整数数组 nums，找到其中最长严格递增子序列的长度。\n\n子序列是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。\n例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。\n\n=\n输入：nums = [10,9,2,5,3,7,101,18]\n输出：4\n解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 。\n</code></pre><p>首先我们可以使用动态规划的思路，通过每一步的递推，使用dp数组，记录出每一步操作的最优解，最后得到全局最优解。</p><p>在这个例子中，我们可以把dp[i]定义成nums[0]到nums[i]这个区间内，数组的最长递增子序列的长度，并且dp数组的初始值设为1。</p><p>从左边向右递推，如果nums[i+1]&gt;nums[i]，dp[i+1]就等于dp[i]+1；如果nums[i+1]&lt;nums[i]，就什么都不需要干，这样我们在遍历的过程中，就能根据数组当前位置之前的最长递增子序列长度推导出i+1位置的最长递增子序列长度。</p><p>所以可以得到如下解法：</p><pre><code class="language-javascript">/**\n * @param {number[]} nums\n * @return {number}\n */\nconst lengthOfLIS = function(nums) {\n    let n = nums.length;\n    if (n == 0) {\n        return 0;\n    }\n    let dp = new Array(n).fill(1);\n    for (let i = 0; i &lt; n; i++) {\n        for (let j = 0; j &lt; i; j++) {\n            if (nums[j] &lt; nums[i]) {\n                dp[i] = Math.max(dp[i], dp[j] + 1);\n            }\n        }\n    }\n    return Math.max(...dp) \n}\n</code></pre><p>由于我们需要两层循环，所以这个解法的时间复杂度是n的平方，这个解法其实已经不错了，但是还有更优秀的解法，也就是Vue 3中用到的算法：贪心+二分。</p><h3>贪心+二分</h3><p>我们再看一下这个题，贪心的思路就是在寻找最长递增的序列，所以，[1,3]要比[1,5]好，也就是说，在这个上升的序列中，我们要让上升速度尽可能变得慢，这样才有可能让后面的元素尽可能也递增。</p><p>我们可以创建一个arr数组，用来保存这种策略下的最长递增子序列。</p><p>如果当前遍历的nums[i]大于arr的最后一个元素，也就是大于arr的最大值时，我们把nums[i]追加到后面即可，否则我们就在arr中<strong>寻找一个第一个大于num[i]的数字并替换它</strong>。因为是arr是递增的数列，所以在寻找插入位置的时候，我们可以使用二分查找的方式，把整个算法的复杂度变成O(nlgn)。</p><p>下面的代码就是贪心+二分的解法，我们可以得到正确的最长递增子序列的长度：</p><pre><code class="language-javascript">/**\n * @param {number[]} nums\n * @return {number}\n */\nconst lengthOfLIS = function(nums) {\n    let len = nums.length\n    if (len &lt;= 1) {\n        return len\n    }\n    let arr = [nums[0]]\n    for (let i = 0; i &lt; len; i++) {\n        // nums[i] 大于 arr 尾元素时，直接追加到后面，递增序列长度+1\n        if (nums[i] &gt; arr[arr.length - 1]) {\n            arr.push(nums[i])\n        } else {\n            // 否则，查找递增子序列中第一个大于numsp[i]的元素 替换它\n            // 递增序列，可以使用二分查找\n            let left = 0\n            let right = arr.length - 1\n            while (left &lt; right) {\n                let mid = (left + right) &gt;&gt; 1\n                if (arr[mid] &lt; nums[i]) {\n                    left = mid + 1\n                } else {\n                    right = mid\n                }\n            }\n            arr[left] = nums[i]\n        }\n    }\n    return arr.length\n};\n</code></pre><p>但是贪心+二分的这种解法，现在只能得到最长递增子序列的长度，但是最后得到的arr并不一定是最长递增子序列，因为我们移动的num[i]位置可能会不正确，只是得到的数组长度是正确的，所以我们需要对这个算法改造一下，把整个数组复制一份之后，最后也能得到正确的最长递增子序列。</p><p>具体代码怎么写呢？我们来到Vue 3的renderer.ts文件中，函数<a href="https://github.com/vuejs/vue-next/blob/master/packages/runtime-core/src/renderer.ts#L1952">getSquenece</a>就是用来生成最长递增子序列，看下面的代码：</p><pre><code class="language-typescript">// https://en.wikipedia.org/wiki/Longest_increasing_subsequence\n\tfunction getSequence(arr: number[]): number[] {\n\t  const p = arr.slice() //赋值一份arr\n\t  const result = [0]\n\t  let i, j, u, v, c\n\t  const len = arr.length\n\t  for (i = 0; i &lt; len; i++) {\n\t    const arrI = arr[i]\n\t    if (arrI !== 0) {\n\t      j = result[result.length - 1]\n\t      if (arr[j] &lt; arrI) {\n\t        p[i] = j  // 存储在result最后一个索引的值\n\t        result.push(i)\n\t        continue\n\t      }\n\t      u = 0\n\t      v = result.length - 1\n          // 二分查找，查找比arrI小的节点，更新result的值\n\t      while (u &lt; v) {\n\t        c = (u + v) &gt;&gt; 1\n\t        if (arr[result[c]] &lt; arrI) {\n\t          u = c + 1\n\t        } else {\n\t          v = c\n\t        }\n\t      }\n\t      if (arrI &lt; arr[result[u]]) {\n\t        if (u &gt; 0) {\n\t          p[i] = result[u - 1]\n\t        }\n\t        result[u] = i\n\t      }\n\t    }\n\t  }\n\t  u = result.length\n\t  v = result[u - 1]\n      // 查找数组p 找到最终的索引\n\t  while (u-- &gt; 0) {\n\t    result[u] = v\n\t    v = p[v]\n\t  }\n\t  return result\n\t}\n</code></pre><p>这段代码就是Vue 3里的实现，result存储的就是长度是i的递增子序列最小末位置的索引，最后计算出最长递增子序列。</p><p>我们得到increasingNewIndexSequence队列后，再去遍历数组进行patch操作就可以实现完整的diff流程了：</p><pre><code class="language-typescript">      for (i = toBePatched - 1; i &gt;= 0; i--) {\n        const nextIndex = s2 + i\n        const nextChild = c2[nextIndex] as VNode\n        const anchor =\n          nextIndex + 1 &lt; l2 ? (c2[nextIndex + 1] as VNode).el : parentAnchor\n        if (newIndexToOldIndexMap[i] === 0) {\n          // mount new\n          patch(\n            null,\n            nextChild,\n            container,\n            anchor,\n            parentComponent,\n            parentSuspense,\n            isSVG,\n            slotScopeIds,\n            optimized\n          )\n        } else if (moved) {\n          // move if:\n          // There is no stable subsequence (e.g. a reverse)\n          // OR current node is not among the stable sequence\n          if (j &lt; 0 || i !== increasingNewIndexSequence[j]) {\n            move(nextChild, container, anchor, MoveType.REORDER)\n          } else {\n            j--\n          }\n        }\n      }\n</code></pre><p>上面代码的思路，我们用下图演示。做完双端对比之后，a和g已经计算出可以直接复用DOM，剩下的队列中我们需要把hbfdc更新成abdef。</p><p>首先我们需要<strong>使用keyToNewIndexMap存储新节点中每个key对应的索引</strong>，比如下图中key是c的元素的索引就是2；<strong>然后计算出newIndexOldIndexMap存储这个key在老的子元素中的位置</strong>，我们可以根据c的索引是2，在newIndexOldIndexMap中查询到在老的子元素的位置是6， 关于newIndexOldIndexMap的具体逻辑你可以在上面的代码中看到：<br>\n<img src="https://static001.geekbang.org/resource/image/e0/b0/e0d90b18c0a5d1f0cac0348dda6bcbb0.jpeg?wh=1715x1467" alt=""></p><h2>总结</h2><p>今天的内容到这就结束了，对照着Vue执行全景图，我们回顾一下讲到的知识点。<br>\n<img src="https://static001.geekbang.org/resource/image/a3/3c/a34bc1a4ef7216948b519d1a6e62a83c.jpeg?wh=8026x4418" alt=""></p><p>首先我们分析了Vue 3中虚拟DOM diff中的静态标记功能，标记后通过位运算，可以快速判断出一个节点的类型是HTML标签还是Vue组件，然后去执行不同的操作方法；在节点更新的流程中，也可以通过位运算的方式确定需要更新的范围。</p><p>位运算就是通过二进制上的与和或运算，能够高效地进行权限的判断，我们在工作中如果涉及权限的判断，也可以借鉴类似的思路，Linux中的读写权限也是通过位运算的方式来实现的。</p><p>然后我们剖析了Vue的虚拟DOM中最为复杂的最长递增子序列算法，通过对LeetCode第300的题分析掌握了动态规划和贪心+二分的解法。</p><p>掌握算法思想之后，我们再回到Vue3的源码中分析代码的实现逻辑，patchKeyedChildren的核心逻辑就是在进行双端对比后，对无法预判的序列计算出最长递增子序列之后，我们通过编译数组，对其余的元素进行patch或者move的操作，完整实现了虚拟DOM 的diff。</p><p>学到这里相信你已经完全搞懂了虚拟DOM的执行，以及关键的diff操作思路，可以体会到Vue中极致的优化理念，使用位运算对Vue中的动态属性和节点进行标记，实现高效判断；对于两个数组的diff计算使用了最长递增子序列算法实现，优化了diff的时间复杂度。这也是为什么我一直建议刚入行的前端工程师要好好学习算法的主要原因。</p><h2>思考题</h2><p>最后给你留个思考题，你现在的项目中有哪些地方能用到位运算的地方呢？欢迎在评论去留言分享你的想法，我们下一讲再见。</p>',
        article_title: "31｜虚拟DOM（下）：想看懂虚拟DOM算法，先刷个算法题",
      },
      {
        title: "32｜编译原理（上）：手写一个迷你Vue 3 Compiler的入门原理",
        id: 472927,
        content:
          '<p>你好，我是大圣。</p><p>前面我们用了四讲，学习了Vue在浏览器中是如何执行的，你可以参考上一讲结尾的Vue执行全景图来回顾一下。在Vue中，组件都是以虚拟DOM的形式存在，加载完毕之后注册effect函数。这样组件内部的数据变化之后，用Vue的响应式机制做到了通知组件更新，内部则使用patch函数实现了虚拟DOM的更新，中间我们也学习了位运算、最长递增子序列等算法。</p><p>这时候你肯定还有一个疑问，那就是虚拟DOM是从哪来的？我们明明写的是template和JSX，这也是吃透Vue源码最后一个难点：Vue中的Compiler。</p><p>下图就是Vue核心模块依赖关系图，reactivity和runtime我们已经剖析完毕，迷你版本的代码你可以在<a href="https://github.com/shengxinjing/weiyouyi">GitHub</a>中看到。今天开始我将用三讲的内容，给你详细讲解一下Vue在编译的过程中做了什么。</p><p><img src="https://static001.geekbang.org/resource/image/59/15/59f10ba0b6a6ed5fb956ca05016fde15.jpg?wh=1888x982" alt="图片"></p><p>编译原理也属于计算机中的一个重要学科，Vue的compiler是在Vue场景下的实现，目的就是实现template到render函数的转变。</p><p>我们第一步需要先掌握编译原理的基本概念。Vue官方提供了模板编译的<a href="https://vue-next-template-explorer.netlify.app/#%7B%22src%22%3A%22%3Cdiv%20id%3D%5C%22app%5C%22%3E%5Cn%20%20%20%20%3Cdiv%20%40click%3D%5C%22()%3D%3Econsole.log(xx)%5C%22%20%3Aid%3D%5C%22name%5C%22%3E%7B%7Bname%7D%7D%3C%2Fdiv%3E%5Cn%20%20%20%20%3Ch1%20%3Aname%3D%5C%22title%5C%22%3E%E7%8E%A9%E8%BD%ACvue3%3C%2Fh1%3E%5Cn%20%20%20%20%3Cp%20%3E%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%3C%2Fp%3E%5Cn%3C%2Fdiv%3E%5Cn%22%2C%22ssr%22%3Afalse%2C%22options%22%3A%7B%22mode%22%3A%22module%22%2C%22filename%22%3A%22Foo.vue%22%2C%22prefixIdentifiers%22%3Afalse%2C%22hoistStatic%22%3Atrue%2C%22cacheHandlers%22%3Atrue%2C%22scopeId%22%3Anull%2C%22inline%22%3Afalse%2C%22ssrCssVars%22%3A%22%7B%20color%20%7D%22%2C%22compatConfig%22%3A%7B%22MODE%22%3A3%7D%2C%22whitespace%22%3A%22condense%22%2C%22bindingMetadata%22%3A%7B%22TestComponent%22%3A%22setup-const%22%2C%22setupRef%22%3A%22setup-ref%22%2C%22setupConst%22%3A%22setup-const%22%2C%22setupLet%22%3A%22setup-let%22%2C%22setupMaybeRef%22%3A%22setup-maybe-ref%22%2C%22setupProp%22%3A%22props%22%2C%22vMySetupDir%22%3A%22setup-const%22%7D%2C%22optimizeBindings%22%3Afalse%7D%7D">在线演示</a>。下图左侧代码是我们写的template，右侧代码就是compiler模块解析城的render函数，我们今天的任务就是能够实现一个迷你的compiler。</p><!-- [[[read_end]]] --><p><img src="https://static001.geekbang.org/resource/image/33/23/3326bd4f65d0714c4920e6d37e1be923.png?wh=1920x608" alt="图片"></p><h2>整体流程</h2><p>上述转化的过程可以分为下面的示意图几步来实现。</p><p>首先，代码会被解析成一个对象，这个对象有点像虚拟DOM的概念，用来描述template的代码关系，这个对象就是抽象语法树（简称AST，后面我们细讲）。然后通过transform模块对代码进行优化，比如识别Vue中的语法，静态标记、最后通过generate模块生成最终的render函数。</p><p><img src="https://static001.geekbang.org/resource/image/9a/6d/9aaa7b24f6b9ff0cef5f70151ddd926d.jpg?wh=1920x1747" alt="图片"></p><p>理清了流程，我们动手完成具体代码实现。用下面的代码就能实现上述的流程图里的内容。其中parse函数负责生成抽象语法树AST，transform函数负责语义转换，generate函数负责最终的代码生成。</p><pre><code class="language-javascript">\nfunction compiler(template) {\n  const ast = parse(template);\n  transform(ast)\n  const code = generate(ast)\n  return code\n}\n\nlet template = `&lt;div id="app"&gt;\n  &lt;div @click="()=&gt;console.log(xx)" :id="name"&gt;{{name}}&lt;/div&gt;\n  &lt;h1 :name="title"&gt;玩转vue3&lt;/h1&gt;\n  &lt;p &gt;编译原理&lt;/p&gt;\n&lt;/div&gt;\n`\n\nconst renderFunction = compiler(template)\nconsole.log(renderFunction)\n</code></pre><p>我们先来看下parse函数如何实现。template转成render函数是两种语法的转换，这种代码转换的需求其实计算机的世界中非常常见。比如我们常用的Babel，就是把ES6的语法转成低版本浏览器可以执行的代码。</p><h2>tokenizer的迷你实现</h2><p>首先，我们要对template进行词法分析，把模板中的&lt;div&gt;,  @click, {{}}等语法识别出来，转换成一个个的token。你可以理解为把template的语法进行了分类，这一步我们叫tokenizer。</p><p>下面的代码就是tokenizer的迷你实现。我们使用tokens数组存储解析的结果，然后对模板字符串进行循环，在template中，&lt; &gt; / 和空格都是关键的分隔符，如果碰见&lt;字符，我们需要判断下一个字符的状态。如果是字符串我们就标记tagstart；如果是/，我们就知道是结束标签，标记为tagend，最终通过push方法把分割之后的token存储在数组tokens中返回。</p><pre><code class="language-javascript">function tokenizer(input) {\n  let tokens = []\n  let type = \'\'\n  let val = \'\'\n  // 粗暴循环\n  for (let i = 0; i &lt; input.length; i++) {\n    let ch = input[i]\n    if (ch === \'&lt;\') {\n      push()\n      if (input[i + 1] === \'/\') {\n        type = \'tagend\'\n      } else {\n        type = \'tagstart\'\n      }\n    } if (ch === \'&gt;\') {\n      if(input[i-1]==\'=\'){\n        //箭头函数\n      }else{\n        push()\n        type = "text"\n        continue\n      }\n    } else if (/[\\s]/.test(ch)) { // 碰见空格截断一下\n      push()\n      type = \'props\'\n      continue\n    }\n    val += ch\n  }\n  return tokens\n\n  function push() {\n    if (val) {\n      if (type === "tagstart") val = val.slice(1) // &lt;div =&gt; div\n      if (type === "tagend") val = val.slice(2)   //  &lt;/div  =&gt; div\n      tokens.push({\n        type,\n        val\n      })\n      val = \'\'\n    }\n  }\n}\n</code></pre><p>实现了上面的代码，我们就得到了解析之后的token数组。</p><h2>生成抽象语法树</h2><p>下面的数组中，我们分别用tagstart、props tagend和text标记，用它们标记了全部内容。然后下一步我们需要把这个数组按照标签的嵌套关系转换成树形结构，这样才能完整地描述template标签的关系。</p><pre><code class="language-javascript">[\n&nbsp; { type: \'tagstart\', val: \'div\' },\n&nbsp; { type: \'props\', val: \'id="app"\' },\n&nbsp; { type: \'tagstart\', val: \'div\' },\n&nbsp; { type: \'props\', val: \'@click="()=console.log(xx)"\' },\n&nbsp; { type: \'props\', val: \':id="name"\' },\n&nbsp; { type: \'text\', val: \'{{name}}\' },\n&nbsp; { type: \'tagend\', val: \'div\' },\n&nbsp; { type: \'tagstart\', val: \'h1\' },\n&nbsp; { type: \'props\', val: \':name="title"\' },\n&nbsp; { type: \'text\', val: \'玩转vue3\' },\n&nbsp; { type: \'tagend\', val: \'h1\' },\n&nbsp; { type: \'tagstart\', val: \'p\' },\n&nbsp; { type: \'text\', val: \'编译原理\' },\n&nbsp; { type: \'tagend\', val: \'p\' },\n&nbsp; { type: \'tagend\', val: \'div\' }\n</code></pre><p>然后我们分析token数组，看看它是如何转化成一个体现语法规则的树形结构的。<br>\n就像我们用虚拟DOM描述页面DOM结构一样，我们使用树形结构描述template的语法，这个树我们称之为抽象语法树，简称AST。</p><p>下面的代码中我们用parse函数实现AST的解析。过程是这样的，首先我们使用一个AST对象作为根节点。然后通过walk函数遍历整个tokens数组，根据token的类型不同，生成不同的node对象。最后根据tagend的状态来决定walk的递归逻辑，最终实现了整棵树的构建。</p><pre><code class="language-javascript">function parse(template) {\n  const tokens = tokenizer(template)\n  let cur = 0\n  let ast = {\n    type: \'root\',\n    props:[],\n    children: []\n  }\n  while (cur &lt; tokens.length) {\n    ast.children.push(walk())\n  }\n  return ast\n\n  function walk() {\n    let token = tokens[cur]\n    if (token.type == \'tagstart\') {\n      let node = {\n        type: \'element\',\n        tag: token.val,\n        props: [],\n        children: []\n      }\n      token = tokens[++cur]\n      while (token.type !== \'tagend\') {\n        if (token.type == \'props\') {\n          node.props.push(walk())\n        } else {\n          node.children.push(walk())\n        }\n        token = tokens[cur]\n      }\n      cur++\n      return node\n    }\n    if (token.type === \'tagend\') {\n      cur++\n      // return token\n    }\n    if (token.type == "text") {\n      cur++\n      return token\n    }\n    if (token.type === "props") {\n      cur++\n      const [key, val] = token.val.replace(\'=\',\'~\').split(\'~\')\n      return {\n        key,\n        val\n      }\n    }\n  }\n}\n</code></pre><p>上面的代码会生成抽象语法树AST，这个树的结构如下面代码所示，通过type和children描述整个template的结构。</p><pre><code class="language-javascript">{\n&nbsp; "type": "root",\n&nbsp; "props": [],\n&nbsp; "children": [\n&nbsp; &nbsp; {\n&nbsp; &nbsp; &nbsp; "type": "element",\n&nbsp; &nbsp; &nbsp; "tag": "div",\n&nbsp; &nbsp; &nbsp; "props": [\n&nbsp; &nbsp; &nbsp; &nbsp; {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; "key": "id",\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; "val": "\\"app\\""\n&nbsp; &nbsp; &nbsp; &nbsp; }\n&nbsp; &nbsp; &nbsp; ],\n&nbsp; &nbsp; &nbsp; "children": [\n&nbsp; &nbsp; &nbsp; &nbsp; {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; "type": "element",\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; "tag": "div",\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; "props": [\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; "key": "@click",\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; "val": "\\"()"\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; },\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; "key": ":id",\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; "val": "\\"name\\""\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ],\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; "children": [\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; "type": "text",\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; "val": "{{name}}"\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ]\n&nbsp; &nbsp; &nbsp; &nbsp; },\n&nbsp; &nbsp; &nbsp; &nbsp; {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; "type": "element",\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; "tag": "h1",\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; "props": [\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; "key": ":name",\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; "val": "\\"title\\""\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ],\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; "children": [\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; "type": "text",\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; "val": "玩转vue3"\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ]\n&nbsp; &nbsp; &nbsp; &nbsp; },\n&nbsp; &nbsp; &nbsp; &nbsp; {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; "type": "element",\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; "tag": "p",\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; "props": [],\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; "children": [\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; "type": "text",\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; "val": "编译原理"\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ]\n&nbsp; &nbsp; &nbsp; &nbsp; }\n&nbsp; &nbsp; &nbsp; ]\n&nbsp; &nbsp; }\n&nbsp; ]\n}\n</code></pre><h2>语义分析和优化</h2><p>有了抽象语法树之后，我们还要进行语义的分析和优化，也就是说，我们要在这个阶段理解语句要做的事。咱们结合例子来理解会更容易。</p><p>在template这个场景下，两个大括号包裹的字符串就是变量，@click就是事件监听。</p><p>下面的代码中我们使用transform函数实现这个功能，这一步主要是理解template中Vue的语法，并且为最后生成的代码做准备。我们使用context对象存储AST所需要的上下文，如果我们用到了变量{{}}，就需要引入toDisplayString函数，上下文中的helpers存储的就是我们用到的工具函数。</p><pre><code class="language-javascript">function transform(ast) {\n  // 优化一下ast\n  let context = {\n    // import { toDisplayString , createVNode , openBlock , createBlock } from "vue"\n    helpers:new Set([\'openBlock\',\'createVnode\']), // 用到的工具函数 \n  }\n  traverse(ast, context)\n  ast.helpers = context.helpers\n}\n</code></pre><p>然后我们使用traverse函数递归整个AST，去优化AST的结构，并且在这一步实现简单的静态标记。</p><p>当节点标记为element的时候，我们递归调用整个AST，内部挨个遍历AST所有的属性，我们默认使用ast.flag标记节点的动态状态。如果属性是@开头的，我们就认为它是Vue中的事件绑定，使用arg.flag|= PatchFlags.EVENT 标记当前节点的事件是动态的，需要计算diff，这部分位运算的知识点我们在上一讲已经学习过了。</p><p>然后冒号开头的就是动态的属性传递，并且把class和style标记了不同的flag。如果都没有命中的话，就使用static:true，标记当前节点位是静态节点。</p><pre><code class="language-javascript">function traverse(ast, context){\n  switch(ast.type){\n    case "root":\n      context.helpers.add(\'createBlock\')\n      // log(ast)\n    case "element":\n      ast.children.forEach(node=&gt;{\n        traverse(node,context)\n      })\n      ast.flag = 0\n      ast.props = ast.props.map(prop=&gt;{\n        const {key,val} = prop\n        if(key[0]==\'@\'){\n          ast.flag |= PatchFlags.EVENT // 标记event需要更新\n          return {\n            key:\'on\'+key[1].toUpperCase()+key.slice(2),\n            val\n          }\n        }\n        if(key[0]==\':\'){\n          const k = key.slice(1)\n          if(k=="class"){\n            ast.flag |= PatchFlags.CLASS // 标记class需要更新\n\n          }else if(k==\'style\'){\n            ast.flag |= PatchFlags.STYLE // 标记style需要更新\n          }else{\n            ast.flag |= PatchFlags.PROPS // 标记props需要更新\n          }\n          return{\n            key:key.slice(1),\n            val\n          }\n        }\n        if(key.startsWith(\'v-\')){\n          // pass such as v-model \n        }\n        //标记static是true 静态节点\n        return {...prop,static:true} \n      })\n      break\n    case "text":\n      // trnsformText\n      let re = /\\{\\{(.*)\\}\\}/g\n      if(re.test(ast.val)){\n        //有{{\n          ast.flag |= PatchFlags.TEXT // 标记props需要更新\n          context.helpers.add(\'toDisplayString\')\n          ast.val = ast.val.replace(/\\{\\{(.*)\\}\\}/g,function(s0,s1){\n            return s1\n          })\n      }else{\n        ast.static = true\n      }\n  }\n}  \n\n</code></pre><p>经过上面的代码标记优化之后，项目在数据更新之后，浏览器计算虚拟dom diff运算的时候，就会执行类似下面的代码逻辑。</p><p><strong>我们通过在compiler阶段的标记，让template产出的虚拟DOM有了更精确的状态，可以越过大部分的虚拟DOM的diff计算，极大提高Vue的运行时效率，这个思想我们日常开发中也可以借鉴学习。</strong></p><pre><code class="language-javascript">if(vnode.static){\n  return \n}\nif(vnode.flag &amp; patchFlag.CLASS){\n  遍历class 计算diff  \n}else if(vnode.flag &amp; patchFlag.STYLE){\n  计算style的diff\n}else if(vnode.flag &amp; patchFlag.TEXT){\n  计算文本的diff\n}\n</code></pre><p>接下来，我们基于优化之后的AST生成目标代码，也就是generate函数要做的事：遍历整个AST，拼接成最后要执行的函数字符串。</p><p>下面的代码中，我们首先把helpers拼接成import语句，并且使用walk函数遍历整个AST，在遍历的过程中收集helper集合的依赖。最后，在createVnode的最后一个参数带上ast.flag进行状态的标记。</p><pre><code class="language-javascript">function generate(ast) {\n  const {helpers} = ast \n\n  let code = `\nimport {${[...helpers].map(v=&gt;v+\' as _\'+v).join(\',\')}} from \'vue\'\\n\nexport function render(_ctx, _cache, $props){\n  return(_openBlock(), ${ast.children.map(node=&gt;walk(node))})}`\n\n  function walk(node){\n    switch(node.type){\n      case \'element\':\n        let {flag} = node // 编译的标记\n        let props = \'{\'+node.props.reduce((ret,p)=&gt;{\n          if(flag.props){\n            //动态属性\n            ret.push(p.key +\':_ctx.\'+p.val.replace(/[\'"]/g,\'\') )\n          }else{\n            ret.push(p.key +\':\'+p.val )\n          }\n\n          return ret\n        },[]).join(\',\')+\'}\'\n        return `_createVnode("${node.tag}",${props}),[\n          ${node.children.map(n=&gt;walk(n))}\n        ],${JSON.stringify(flag)}`\n        break\n      case \'text\':\n        if(node.static){\n          return \'"\'+node.val+\'"\'\n        }else{\n          return `_toDisplayString(_ctx.${node.val})`\n        }\n        break\n    }\n  }\n  return code\n}\n</code></pre><h2>最终实现效果</h2><p>最后我们执行一下代码，看下效果输出的代码。可以看到，它已经和Vue输出的代码很接近了，到此为止，我们也实现了一个非常迷你的Vue compiler，这个产出的render函数最终会和组件的setup函数一起组成运行时的组件对象。</p><pre><code class="language-javascript">function compiler(template) {\n  const ast = parse(template);\n  transform(ast)\n\n  const code = generate(ast)\n  return code\n}\n\nlet template = `&lt;div id="app"&gt;\n  &lt;div @click="()=&gt;console.log(xx)" :id="name"&gt;{{name}}&lt;/div&gt;\n  &lt;h1 :name="title"&gt;玩转vue3&lt;/h1&gt;\n  &lt;p &gt;编译原理&lt;/p&gt;\n&lt;/div&gt;\n`\n\nconst renderFunction = compiler(template)\nconsole.log(renderFunction)\n\n// 下面是输出结果\nimport { openBlock as _openBlock, createVnode as _createVnode, createBlock as _createBlock, toDisplayString as _toDisplayString } from \'vue\'\n\nexport function render(_ctx, _cache, $props) {\n  return (_openBlock(), _createVnode("div", { id: "app" }), [\n    _createVnode("div", { onClick: "()=&gt;console.log(xx)", id: "name" }), [\n      _toDisplayString(_ctx.name)\n    ], 24, _createVnode("h1", { name: "title" }), [\n      "玩转vue3"\n    ], 8, _createVnode("p", {}), [\n      "编译原理"\n    ], 0\n  ], 0)\n}\n\n</code></pre><h2>总结</h2><p>我们总结一下今天所学的内容。今天，我带你手写了一个非常迷你的Vue compiler，这也是我们学习框架源码的时候一个比较正确的思路：在去看实际的源码之前，先通过迷你版本的实现，熟悉整个Vue compiler工作的主体流程。</p><p><img src="https://static001.geekbang.org/resource/image/ce/0d/ce5d04ae043d4247b4yy03e91353620d.jpg?wh=1920x453" alt="图片"></p><p>通过这个迷你的compiler，我们学习了编译原理的入门知识：包括parser的实现、AST是什么，AST的语义化优化和代码生成generate模块，这给我们下一讲弄清楚Vue的compiler的核心逻辑打下了良好的理论基础。</p><p>我想提醒你注意一个优化方法，我们实现的迷你compiler也实现了属性的静态标记，通过在编译期间的标记方式，让虚拟DOM在运行时有更多的状态，从而能够精确地控制更新。这种编译时的优化也能够对我们项目开发有很多指引作用，我会在剖析完Vue的compiler之后，在第34讲那里跟你分享一下实战中如何使用编译优化的思想。</p><h2>思考题</h2><p>最后留一个思考题吧，Vue的compiler输出的代码会有几个hoisted开头的变量，这几个变量有什么用处呢？欢迎在评论区分享你的答案，也欢迎你把这一讲分享给你的同事和朋友们，我们下一讲再见！</p>',
        article_title:
          "32｜编译原理（上）：手写一个迷你Vue 3 Compiler的入门原理",
      },
      {
        title: "33 | 编译原理（中）：Vue Compiler模块全解析",
        id: 473181,
        content:
          "<p>你好，我是大圣。</p><p>上一讲我带你手写了一个迷你的Vue compiler，还学习了编译原理的基础知识。通过实现这个迷你Vue compiler，我们知道了tokenizer可以用来做语句分析，而parse负责生成抽象语法树AST。然后我们一起分析AST中的Vue语法，最后通过generate函数生成最终的代码。</p><p>今天我就带你深入Vue的compiler源码之中，看看Vue内部到底是怎么实现的。有了上一讲编译原理的入门基础，你会对Compiler执行全流程有更深的理解。</p><h2>Vue compiler入口分析</h2><p>Vue 3内部有4个和compiler相关的包。compiler-dom和compiler-core负责实现浏览器端的编译，这两个包是我们需要深入研究的，compiler-ssr负责服务器端渲染，我们后面讲ssr的时候再研究，compiler-sfc是编译.vue单文件组件的，有兴趣的同学可以自行探索。</p><p>首先我们进入到vue-next/packages/compiler-dom/index.ts文件下，在<a href=\"https://github.com/vuejs/vue-next/blob/master/packages/compiler-dom/src/index.ts#L40\">GitHub</a>上你可以找到下面这段代码。</p><p>compiler函数有两个参数，第一个参数template，它是我们项目中的模板字符串；第二个参数options是编译的配置，内部调用了baseCompile函数。我们可以看到，这里的调用关系和runtime-dom、runtime-core的关系类似，compiler-dom负责传入浏览器Dom相关的API，实际编译的baseCompile是由compiler-core提供的。</p><!-- [[[read_end]]] --><pre><code class=\"language-javascript\">export function compile(\n  template: string,\n  options: CompilerOptions = {}\n): CodegenResult {\n  return baseCompile(\n    template,\n    extend({}, parserOptions, options, {\n      nodeTransforms: [\n        // ignore &lt;script&gt; and &lt;tag&gt;\n        // this is not put inside DOMNodeTransforms because that list is used\n        // by compiler-ssr to generate vnode fallback branches\n        ignoreSideEffectTags,\n        ...DOMNodeTransforms,\n        ...(options.nodeTransforms || [])\n      ],\n      directiveTransforms: extend(\n        {},\n        DOMDirectiveTransforms,\n        options.directiveTransforms || {}\n      ),\n      transformHoist: __BROWSER__ ? null : stringifyStatic\n    })\n  )\n}\n</code></pre><p>我们先来看看compiler-dom做了哪些额外的配置。</p><p>首先，parserOption传入了parse的配置，通过parserOption传递的isNativeTag来区分element和component。这里的实现也非常简单，把所有html的标签名存储在一个对象中，然后就可以很轻松地判断出div是浏览器自带的element。</p><p>baseCompile传递的其他参数nodeTransforms和directiveTransforms，它们做的也是和上面代码类似的事。</p><pre><code class=\"language-javascript\">\nexport const parserOptions: ParserOptions = {\n  isVoidTag,\n  isNativeTag: tag =&gt; isHTMLTag(tag) || isSVGTag(tag),\n  isPreTag: tag =&gt; tag === 'pre',\n  decodeEntities: __BROWSER__ ? decodeHtmlBrowser : decodeHtml,\n\n  isBuiltInComponent: (tag: string): symbol | undefined =&gt; {\n    if (isBuiltInType(tag, `Transition`)) {\n      return TRANSITION\n    } else if (isBuiltInType(tag, `TransitionGroup`)) {\n      return TRANSITION_GROUP\n    }\n  },\n  ...\n}\nconst HTML_TAGS =\n  'html,body,base,head,link,meta,style,title,address,article,aside,footer,' +\n  'header,h1,h2,h3,h4,h5,h6,nav,section,div,dd,dl,dt,figcaption,' +\n  'figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,' +\n  'data,dfn,em,i,kbd,mark,q,rp,rt,ruby,s,samp,small,span,strong,sub,sup,' +\n  'time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,' +\n  'canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,' +\n  'th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,' +\n  'option,output,progress,select,textarea,details,dialog,menu,' +\n  'summary,template,blockquote,iframe,tfoot'\nexport const isHTMLTag = /*#__PURE__*/ makeMap(HTML_TAGS)\n</code></pre><h2>Vue浏览器端编译的核心流程</h2><p>然后，我们进入到baseCompile函数中，这就是Vue浏览器端编译的核心流程。</p><p>下面的代码中可以很清楚地看到，我们先通过baseParse把传递的template解析成AST，然后通过transform函数对AST进行语义化分析，最后通过generate函数生成代码。</p><p>这个主要逻辑和我们写的迷你compiler基本一致，这些函数大概要做的事你也心中有数了。这里你也能体验到，亲手实现一个迷你版本对我们阅读源码很有帮助。</p><p>接下来，我们就进入到这几个函数之中去，看一下跟迷你compiler里的实现相比，我们到底做了哪些优化。</p><pre><code class=\"language-javascript\">export function baseCompile(\n  template: string | RootNode,\n  options: CompilerOptions = {}\n): CodegenResult {\n  const ast = isString(template) ? baseParse(template, options) : template\n  const [nodeTransforms, directiveTransforms] =\n    getBaseTransformPreset(prefixIdentifiers)\n\n  transform(\n    ast,\n    extend({}, options, {\n      prefixIdentifiers,\n      nodeTransforms: [\n        ...nodeTransforms,\n        ...(options.nodeTransforms || []) // user transforms\n      ],\n      directiveTransforms: extend(\n        {},\n        directiveTransforms,\n        options.directiveTransforms || {} // user transforms\n      )\n    })\n  )\n  return generate(\n    ast,\n    extend({}, options, {\n      prefixIdentifiers\n    })\n  )\n}\n\n</code></pre><p>上一讲中我们体验了Vue的在线模板编译环境，可以在console中看到Vue解析得到的AST。</p><p>如下图所示，可以看到这个AST比迷你版多了很多额外的属性。<strong>loc用来描述节点对应代码的信息，component和directive用来记录代码中出现的组件和指令等等</strong>。</p><p><img src=\"https://static001.geekbang.org/resource/image/0e/3f/0e264bc3ffcfa67babec3b1cf8047d3f.png?wh=1920x982\" alt=\"图片\"></p><p>然后我们进入到baseParse函数中, 这里的createParserContext和createRoot用来生成上下文，其实就是创建了一个对象，保存当前parse函数中需要共享的数据和变量，最后调用parseChildren。</p><p>children内部开始判断&lt;开头的标识符，判断开始还是闭合标签后，接着会生成一个nodes数组。其中，advanceBy函数负责更新context中的source用来向前遍历代码，最终对不同的场景执行不同的函数。</p><pre><code class=\"language-javascript\">export function baseParse(\n  content: string,\n  options: ParserOptions = {}\n): RootNode {\n  const context = createParserContext(content, options)\n  const start = getCursor(context)\n  return createRoot(\n    parseChildren(context, TextModes.DATA, []),\n    getSelection(context, start)\n  )\n}\nfunction parseChildren(\n  context: ParserContext,\n  mode: TextModes,\n  ancestors: ElementNode[]\n): TemplateChildNode[] {\n  const parent = last(ancestors)\n  // 依次生成node\n  const nodes: TemplateChildNode[] = []\n  // 如果遍历没结束\n  while (!isEnd(context, mode, ancestors)) {\n\n    const s = context.source\n    let node: TemplateChildNode | TemplateChildNode[] | undefined = undefined\n    \n    if (mode === TextModes.DATA || mode === TextModes.RCDATA) {\n      if (!context.inVPre &amp;&amp; startsWith(s, context.options.delimiters[0])) {\n        // 处理vue的变量标识符，两个大括号 '{{'\n        node = parseInterpolation(context, mode)\n      } else if (mode === TextModes.DATA &amp;&amp; s[0] === '&lt;') {\n        // 处理&lt;开头的代码，可能是&lt;div&gt;也有可能是&lt;/div&gt; 或者&lt;!的注释\n        if (s.length === 1) {\n          // 长度是1，只有一个&lt; 有问题 报错\n          emitError(context, ErrorCodes.EOF_BEFORE_TAG_NAME, 1)\n        } else if (s[1] === '!') {\n          // html注释\n          if (startsWith(s, '&lt;!--')) {\n            node = parseComment(context)\n          } else if (startsWith(s, '&lt;!DOCTYPE')) {\n              \n            // DOCTYPE\n            node = parseBogusComment(context)\n          }\n        } else if (s[1] === '/') {\n           //&lt;/ 开头的标签，结束标签\n          // https://html.spec.whatwg.org/multipage/parsing.html#end-tag-open-state\n          if (/[a-z]/i.test(s[2])) {\n            emitError(context, ErrorCodes.X_INVALID_END_TAG)\n            parseTag(context, TagType.End, parent)\n            continue\n          } \n        } else if (/[a-z]/i.test(s[1])) {\n          // 解析节点\n          node = parseElement(context, ancestors)\n          // 2.x &lt;template&gt; with no directive compat\n          node = node.children\n          }\n        }\n      }\n    }\n    if (!node) {\n      // 文本\n      node = parseText(context, mode)\n    }\n    // node树数组，遍历puish\n    if (isArray(node)) {\n      for (let i = 0; i &lt; node.length; i++) {\n        pushNode(nodes, node[i])\n      }\n    } else {\n      pushNode(nodes, node)\n    }\n  }\n\n  return removedWhitespace ? nodes.filter(Boolean) : nodes\n}\n</code></pre><p>parseInterpolation和parseText函数的逻辑比较简单。parseInterpolation负责识别变量的分隔符 {{ 和}} ，然后通过parseTextData获取变量的值，并且通过innerStart和innerEnd去记录插值的位置；parseText负责处理模板中的普通文本，主要是把文本包裹成AST对象。</p><p>接着我们看看处理节点的parseElement函数都做了什么。首先要判断pre和v-pre标签，然后通过isVoidTag判断标签是否是自闭合标签，这个函数是从compiler-dom中传来的，之后会递归调用parseChildren，接着再解析开始标签、解析子节点，最后解析结束标签。</p><pre><code class=\"language-javascript\">const VOID_TAGS =\n  'area,base,br,col,embed,hr,img,input,link,meta,param,source,track,wbr'\n\nexport const isVoidTag = /*#__PURE__*/ makeMap(VOID_TAGS)\nfunction parseElement(\n  context: ParserContext,\n  ancestors: ElementNode[]\n): ElementNode | undefined {\n  // Start tag.\n  // 是不是pre标签和v-pre标签\n  const wasInPre = context.inPre\n  const wasInVPre = context.inVPre\n  const parent = last(ancestors)\n  // 解析标签节点\n  const element = parseTag(context, TagType.Start, parent)\n  const isPreBoundary = context.inPre &amp;&amp; !wasInPre\n  const isVPreBoundary = context.inVPre &amp;&amp; !wasInVPre\n\n  if (element.isSelfClosing || context.options.isVoidTag(element.tag)) {\n    // #4030 self-closing &lt;pre&gt; tag\n    if (isPreBoundary) {\n      context.inPre = false\n    }\n    if (isVPreBoundary) {\n      context.inVPre = false\n    }\n    return element\n  }\n\n  // Children.\n  ancestors.push(element)\n  const mode = context.options.getTextMode(element, parent)\n  const children = parseChildren(context, mode, ancestors)\n  ancestors.pop()\n  element.children = children\n\n  // End tag.\n  if (startsWithEndTagOpen(context.source, element.tag)) {\n    parseTag(context, TagType.End, parent)\n  } else {\n    emitError(context, ErrorCodes.X_MISSING_END_TAG, 0, element.loc.start)\n    if (context.source.length === 0 &amp;&amp; element.tag.toLowerCase() === 'script') {\n      const first = children[0]\n      if (first &amp;&amp; startsWith(first.loc.source, '&lt;!--')) {\n        emitError(context, ErrorCodes.EOF_IN_SCRIPT_HTML_COMMENT_LIKE_TEXT)\n      }\n    }\n  }\n\n  element.loc = getSelection(context, element.loc.start)\n\n  if (isPreBoundary) {\n    context.inPre = false\n  }\n  if (isVPreBoundary) {\n    context.inVPre = false\n  }\n  return element\n}\n</code></pre><p>最后，我们来看下解析节点的parseTag函数的逻辑，匹配文本标签结束的位置后，先通过parseAttributes函数处理属性，然后对pre和v-pre标签进行检查，最后通过isComponent函数判断是否为组件。</p><p>isComponent内部会通过compiler-dom传递的isNativeTag来辅助判断结果，最终返回一个描述节点的对象，包含当前节点所有解析之后的信息，tag表示标签名，children表示子节点的数组，具体代码我放在了后面。</p><pre><code class=\"language-javascript\">function parseTag(\n  context: ParserContext,\n  type: TagType,\n  parent: ElementNode | undefined\n): ElementNode | undefined {\n\n  // Tag open. \n  const start = getCursor(context)\n  //匹配标签结束的位置\n  const match = /^&lt;\\/?([a-z][^\\t\\r\\n\\f /&gt;]*)/i.exec(context.source)!\n  const tag = match[1]\n  const ns = context.options.getNamespace(tag, parent)\n  // 向前遍历代码\n  advanceBy(context, match[0].length)\n  advanceSpaces(context)\n\n  // save current state in case we need to re-parse attributes with v-pre\n  const cursor = getCursor(context)\n  const currentSource = context.source\n\n  // check &lt;pre&gt; tag \n  if (context.options.isPreTag(tag)) {\n    context.inPre = true\n  }\n  // Attributes.\n  // 解析属性\n  let props = parseAttributes(context, type)\n  // check v-pre\n  if (){...}\n  // Tag close.\n  let isSelfClosing = false\n  if (type === TagType.End) {\n    return\n  }\n\n  let tagType = ElementTypes.ELEMENT\n  if (!context.inVPre) {\n    if (tag === 'slot') {\n      tagType = ElementTypes.SLOT\n    } else if (tag === 'template') {\n      if (\n        props.some(\n          p =&gt;\n            p.type === NodeTypes.DIRECTIVE &amp;&amp; isSpecialTemplateDirective(p.name)\n        )\n      ) {\n        tagType = ElementTypes.TEMPLATE\n      }\n    } else if (isComponent(tag, props, context)) {\n      tagType = ElementTypes.COMPONENT\n    }\n  }\n\n  return {\n    type: NodeTypes.ELEMENT,\n    ns,\n    tag,\n    tagType,\n    props,\n    isSelfClosing,\n    children: [],\n    loc: getSelection(context, start),\n    codegenNode: undefined // to be created during transform phase\n  }\n}\n\n</code></pre><p>parse函数生成AST之后，我们就有了一个完整描述template的对象，它包含了template中所有的信息。</p><h2>AST的语义化分析</h2><p>下一步我们要对AST进行语义化的分析。transform函数的执行流程分支很多，<strong>核心的逻辑就是识别一个个的Vue的语法，并且进行编译器的优化，我们经常提到的静态标记就是这一步完成的</strong>。</p><p>我们进入到transform函数中，可以看到，内部通过createTransformContext创建上下文对象，这个对象包含当前分析的属性配置，包括是否ssr，是否静态提升还有工具函数等等，这个对象的属性你可以在 <a href=\"https://github.com/vuejs/vue-next/blob/0dc521b9e15ce4aa3d5229e90d2173644529e92b/packages/compiler-core/src/transforms/transformElement.ts\">GitHub</a>上看到。</p><pre><code class=\"language-javascript\">\n\nexport function transform(root: RootNode, options: TransformOptions) {\n  const context = createTransformContext(root, options)\n  traverseNode(root, context)\n  if (options.hoistStatic) {\n    hoistStatic(root, context)\n  }\n  if (!options.ssr) {\n    createRootCodegen(root, context)\n  }\n  // finalize meta information\n  root.helpers = [...context.helpers.keys()]\n  root.components = [...context.components]\n  root.directives = [...context.directives]\n  root.imports = context.imports\n  root.hoists = context.hoists\n  root.temps = context.temps\n  root.cached = context.cached\n\n  if (__COMPAT__) {\n    root.filters = [...context.filters!]\n  }\n}\n\n</code></pre><p>然后通过traverseNode即可编译AST所有的节点。核心的转换流程是在遍历中实现，内部使用switch判断node.type执行不同的处理逻辑。比如如果是Interpolation，就需要在helper中导入toDisplayString工具函数，这个迷你版本中我们也实现过。</p><pre><code class=\"language-javascript\">\nexport function traverseNode(\n  node: RootNode | TemplateChildNode,\n  context: TransformContext\n) {\n  context.currentNode = node\n  // apply transform plugins\n  const { nodeTransforms } = context\n  const exitFns = []\n  for (let i = 0; i &lt; nodeTransforms.length; i++) {\n    // 处理exitFns\n  }\n  swtch (node.type) {\n    case NodeTypes.COMMENT:\n      if (!context.ssr) {\n        context.helper(CREATE_COMMENT)\n      }\n      break\n    case NodeTypes.INTERPOLATION:\n      if (!context.ssr) {\n        context.helper(TO_DISPLAY_STRING)\n      }\n      break\n    case NodeTypes.IF:\n      for (let i = 0; i &lt; node.branches.length; i++) {\n        traverseNode(node.branches[i], context)\n      }\n      break\n    case NodeTypes.IF_BRANCH:\n    case NodeTypes.FOR:\n    case NodeTypes.ELEMENT:\n    case NodeTypes.ROOT:\n      traverseChildren(node, context)\n      break\n  }\n\n  // exit transforms\n  context.currentNode = node\n  let i = exitFns.length\n  while (i--) {\n    exitFns[i]()\n  }\n}\n\n</code></pre><p>transform中还会调用transformElement来转换节点，用来处理props和children的静态标记，transformText用来转换文本，这里的代码比较简单， 你可以自行在<a href=\"https://github.com/vuejs/vue-next/blob/0dc521b9e15ce4aa3d5229e90d2173644529e92b/packages/compiler-core/src/transforms/transformElement.ts\">Github</a>上查阅。<br>\ntransform函数参数中的nodeTransforms和directiveTransforms传递了Vue中template语法的配置，这个两个函数由getBaseTransformPreset返回。</p><p>下面的代码中，transformIf和transformFor函数式解析Vue中v-if和v-for的语法转换，transformOn和transformModel是解析v-on和v-model的语法解析，这里我们只关注v-开头的语法。</p><pre><code class=\"language-javascript\">\n\nexport function getBaseTransformPreset(\n  prefixIdentifiers?: boolean\n): TransformPreset {\n  return [\n    [\n      transformOnce,\n      transformIf,\n      transformMemo,\n      transformFor,\n      ...(__COMPAT__ ? [transformFilter] : []),\n      ...(!__BROWSER__ &amp;&amp; prefixIdentifiers\n        ? [\n            // order is important\n            trackVForSlotScopes,\n            transformExpression\n          ]\n        : __BROWSER__ &amp;&amp; __DEV__\n        ? [transformExpression]\n        : []),\n      transformSlotOutlet,\n      transformElement,\n      trackSlotScopes,\n      transformText\n    ],\n    {\n      on: transformOn,\n      bind: transformBind,\n      model: transformModel\n    }\n  ]\n}\n\n</code></pre><p>然后我们再来看看transformIf的函数实现。首先判断v-if、v-else和v-else-if属性，内部通过createCodegenNodeForBranch来创建条件分支，在AST中标记当前v-if的处理逻辑。这段逻辑标记结束后，在generate中就会把v-if标签和后面的v-else标签解析成三元表达式。</p><pre><code class=\"language-javascript\">export const transformIf = createStructuralDirectiveTransform(\n  /^(if|else|else-if)$/,\n  (node, dir, context) =&gt; {\n    return processIf(node, dir, context, (ifNode, branch, isRoot) =&gt; {\n      const siblings = context.parent!.children\n      let i = siblings.indexOf(ifNode)\n      let key = 0\n      while (i-- &gt;= 0) {\n        const sibling = siblings[i]\n        if (sibling &amp;&amp; sibling.type === NodeTypes.IF) {\n          key += sibling.branches.length\n        }\n      }\n      return () =&gt; {\n        if (isRoot) {\n          ifNode.codegenNode = createCodegenNodeForBranch(\n            branch,\n            key,\n            context\n          ) as IfConditionalExpression\n        } else {\n          // attach this branch's codegen node to the v-if root.\n          const parentCondition = getParentCondition(ifNode.codegenNode!)\n          parentCondition.alternate = createCodegenNodeForBranch(\n            branch,\n            key + ifNode.branches.length - 1,\n            context\n          )\n        }\n      }\n    })\n  }\n)\n</code></pre><p>transform对AST分析结束之后，我们就得到了一个优化后的AST对象，最后我们需要调用generate函数最终生成render函数。</p><h2>template到render函数的转化</h2><p>结合下面的代码我们可以看到，generate首先通过createCodegenContext创建上下文对象，然后通过genModulePreamble生成预先定义好的代码模板，然后生成render函数，最后生成创建虚拟DOM的表达式。</p><pre><code class=\"language-javascript\">export function generate(\n  ast,\n  options\n): CodegenResult {\n  const context = createCodegenContext(ast, options)\n  const {\n    mode,\n    push,\n    prefixIdentifiers,\n    indent,\n    deindent,\n    newline,\n    scopeId,\n    ssr\n  } = context\n\n  if (!__BROWSER__ &amp;&amp; mode === 'module') {\n    // 预设代码，module风格 就是import语句\n    genModulePreamble(ast, preambleContext, genScopeId, isSetupInlined)\n  } else {\n    // 预设代码，函数风格 就是import语句\n    genFunctionPreamble(ast, preambleContext)\n  }\n  // render还是ssrRender\n  const functionName = ssr ? `ssrRender` : `render`\n  const args = ssr ? ['_ctx', '_push', '_parent', '_attrs'] : ['_ctx', '_cache']\n  if (!__BROWSER__ &amp;&amp; options.bindingMetadata &amp;&amp; !options.inline) {\n    // binding optimization args\n    args.push('$props', '$setup', '$data', '$options')\n  }\n  const signature =\n    !__BROWSER__ &amp;&amp; options.isTS\n      ? args.map(arg =&gt; `${arg}: any`).join(',')\n      : args.join(', ')\n\n  if (isSetupInlined) {\n    push(`(${signature}) =&gt; {`)\n  } else {\n    push(`function ${functionName}(${signature}) {`)\n  }\n  indent()\n\n  // 组件，指令声明代码\n  if (ast.components.length) {\n    genAssets(ast.components, 'component', context)\n    if (ast.directives.length || ast.temps &gt; 0) {\n      newline()\n    }\n  }\n  if (ast.components.length || ast.directives.length || ast.temps) {\n    push(`\\n`)\n    newline()\n  }\n\n  if (ast.codegenNode) {\n    genNode(ast.codegenNode, context)\n  } else {\n    push(`null`)\n  }\n\n  if (useWithBlock) {\n    deindent()\n    push(`}`)\n  }\n\n  deindent()\n  push(`}`)\n\n  return {\n    ast,\n    code: context.code,\n    preamble: isSetupInlined ? preambleContext.code : ``,\n    // SourceMapGenerator does have toJSON() method but it's not in the types\n    map: context.map ? (context.map as any).toJSON() : undefined\n  }\n}\n\n</code></pre><p>我们来看下关键的步骤，genModulePreamble函数生成import风格的代码，这也是我们迷你版本中的功能：通过遍历helpers，生成import字符串，这对应了代码的第二行。</p><pre><code class=\"language-javascript\">// 生成这个 \n// import { toDisplayString as _toDisplayString, createElementVNode as _createElementVNode, openBlock as _openBlock, createElementBlock as _createElementBlock } from \"vue\"\n\nfunction genModulePreamble(\n  ast: RootNode,\n  context: CodegenContext,\n  genScopeId: boolean,\n  inline?: boolean\n) {\n\n  if (genScopeId &amp;&amp; ast.hoists.length) {\n    ast.helpers.push(PUSH_SCOPE_ID, POP_SCOPE_ID)\n  }\n  // generate import statements for helpers\n  if (ast.helpers.length) {\n      push(\n        `import { ${ast.helpers\n          .map(s =&gt; `${helperNameMap[s]} as _${helperNameMap[s]}`)\n          .join(', ')} } from ${JSON.stringify(runtimeModuleName)}\\n`\n      )\n    }\n  }\n  ...\n}\n\n</code></pre><p>接下来的步骤就是生成渲染函数render和component的代码，最后通过genNode生成创建虚拟的代码，执行switch语句生成不同的代码，一共有十几种情况，这里就不一一赘述了。我们可以回顾上一讲中迷你代码的逻辑，总之针对变量，标签，v-if和v-for都有不同的代码生成逻辑，最终才实现了template到render函数的转化。</p><pre><code class=\"language-javascript\">function genNode(node: CodegenNode | symbol | string, context: CodegenContext) {\n  if (isString(node)) {\n    context.push(node)\n    return\n  }\n  if (isSymbol(node)) {\n    context.push(context.helper(node))\n    return\n  }\n  switch (node.type) {\n    case NodeTypes.ELEMENT:\n    case NodeTypes.IF:\n    case NodeTypes.FOR:\n      genNode(node.codegenNode!, context)\n      break\n    case NodeTypes.TEXT:\n      genText(node, context)\n      break\n    case NodeTypes.SIMPLE_EXPRESSION:\n      genExpression(node, context)\n      break\n    case NodeTypes.INTERPOLATION:\n      genInterpolation(node, context)\n      break\n    case NodeTypes.TEXT_CALL:\n      genNode(node.codegenNode, context)\n      break\n    case NodeTypes.COMPOUND_EXPRESSION:\n      genCompoundExpression(node, context)\n      break\n    case NodeTypes.COMMENT:\n      genComment(node, context)\n      break\n    case NodeTypes.VNODE_CALL:\n      genVNodeCall(node, context)\n      break\n\n    case NodeTypes.JS_CALL_EXPRESSION:\n      genCallExpression(node, context)\n      break\n    case NodeTypes.JS_OBJECT_EXPRESSION:\n      genObjectExpression(node, context)\n      break\n    case NodeTypes.JS_ARRAY_EXPRESSION:\n      genArrayExpression(node, context)\n      break\n    case NodeTypes.JS_FUNCTION_EXPRESSION:\n      genFunctionExpression(node, context)\n      break\n    case NodeTypes.JS_CONDITIONAL_EXPRESSION:\n      genConditionalExpression(node, context)\n      break\n    case NodeTypes.JS_CACHE_EXPRESSION:\n      genCacheExpression(node, context)\n      break\n    case NodeTypes.JS_BLOCK_STATEMENT:\n      genNodeList(node.body, context, true, false)\n      break\n\n    /* istanbul ignore next */\n    case NodeTypes.IF_BRANCH:\n      // noop\n      break\n\n  }\n}\n</code></pre><h2></h2><h2>总结</h2><p>今天的内容到这就讲完了，我给你总结一下今天讲到的内容吧。</p><p>今天我们一起分析了Vue中的compiler执行全流程，有了上一讲编译入门知识的基础之后，今天的parse，transform和generate模块就是在上一讲的基础之上，更加全面地实现代码的编译和转化。</p><p><img src=\"https://static001.geekbang.org/resource/image/a9/1e/a995298a4422d287a57e342dc105471e.jpg?wh=3510x1214\" alt=\"\"></p><p>上面的流程图中，我们代码中的template是通过compiler函数进行编译转换，compiler内部调用了compiler-core中的baseCompile函数，并且传递了浏览器平台的转换逻辑。</p><p>比如isNativeTag等函数，baseCompie函数中首先通过baseParse函数把template处理成为AST，并且由transform函数进行标记优化，transfom内部的transformIf，transformOn等函数会对Vue中的语法进行标记，这样在generate函数中就可以使用优化后的AST去生成最终的render函数。</p><p>最终，render函数会和我们写的setup函数一起组成组件对象，交给页面进行渲染。后面我特意为你绘制了一幅Vue全流程的架构图，你可以保存下来随时查阅。</p><p><img src=\"https://static001.geekbang.org/resource/image/3b/97/3b266af3c5f43d235a8ec0e687bc4c97.jpg?wh=8312x4611\" alt=\"\"></p><p>Vue源码中的编译优化也是Vue框架的亮点之一，我们自己也要思考编译器优化的机制，可以提高浏览器运行时的性能，我们项目中该如何借鉴这种思路呢？下一讲我会详细剖析编译原理在实战里的应用，敬请期待。</p><h2>思考题</h2><p>最后留一个思考题，transform函数中针对Vue中的语法有很多的函数处理，比如transformIf会把v-if指令编译成为一个三元表达式，请你从其余的函数选一个在评论区分享transform处理的结果吧。欢迎在评论区分享你的答案，我们下一讲再见！</p>",
        article_title: "33 | 编译原理（中）：Vue Compiler模块全解析",
      },
      {
        title: "34 | 编译原理（下）：编译原理给我们带来了什么？",
        id: 473193,
        content:
          "<p>你好，我是大圣。</p><p>上一讲我们深入研究了 Vue 里的 compiler-dom 和 compiler-core 的流程，相信学完之后，你已经对编译原理的基础知识很熟悉了。</p><p>这时候你肯定会有一个疑问，AST、transform、generate这些概念以前工作中也没遇见过，难道学了这个就只能面试用吗？ 当然不是，编译原理作为计算机世界的一个重要的学科，除了探究原理和源码之外，我们工作中也有很多地方可以用到。</p><p>从宏观视角来看，编译原理实现的功能就是代码之间的转换。哪怕我们只是掌握了入门知识，也能可以实现Vue中 template到render函数转化这样的功能。</p><p>现在的前端发展，很大程度上离不开编译原理在前端圈的落地实践，只要是我们想做自动化代码转化的地方，都可以看到编译的身影。</p><p>举个例子，Babel把ES6中的新语法转换成低版本浏览器支持的语法，我们才能在项目中愉快地使用箭头函数等特性，把浏览器的兼容性交给Babel来处理，甚至现在社区内还出现了gogocode这种把Vue 2代码转换成Vue 3代码的工具。</p><p>在工作中我们可以借助Babel和vite提供给我们的能力，parse，transform，generate等代码都不需要我们自己实现，只需要考虑代码转换的逻辑就可以了，下面我给你举几个小例子。</p><!-- [[[read_end]]] --><h2>vite 插件</h2><p>首先我们在项目中使用了script setup来组织我们的代码，虽然组件引入之后有了自动注册的功能，但是每一个组件内部都肯定要用到ref、computed等Vue提供的API。我们还想要多一步，项目大了只引入ref的语句就写了几百行，就会非常地繁琐，这时候就可以使用编译的思想来解决这个问题。</p><p>首先ref、computed、watch等Vue提供的API，我们在后面的代码调用可以通过正则匹配的方式，完全可以分析出来当前组件依赖的API有哪些。这样，我们就可以在组件执行之前自动导入这些API。</p><p>我们在weiyouyi项目中使用vite插件的形式来完成这个工作。社区内已经有可用的 <a href=\"https://github.com/antfu/unplugin-auto-import\">auto-imput</a> 插件了，不过这里为了加深对技术的理解，咱们还是自己来实现一个。</p><p>首先我们进入到根目录下的vite.config.js文件中，导入autoPlugin插件后，配置在vite的plugins插件中。</p><pre><code class=\"language-javascript\">import vue from '@vitejs/plugin-vue'\nimport autoPlgin from './src/auto-import'\nexport default defineConfig({\n  plugins: [vue(),autoPlgin()]\n})\n\n</code></pre><p>然后我们来实现autoPlugin函数，vite的插件开发文档你可以在<a href=\"https://cn.vitejs.dev/guide/api-plugin.html\">官网中</a>查询，这里就不赘述了。</p><p>我们直接看代码，我们先定义了Vue 3提供的API数组，有ref、computed等等。然后，autoImportPlugin函数对外导出一个对象，transform函数就是核心要实现的逻辑。</p><p>这里的helper和我们在32讲中的工具函数实现逻辑一致，通过new Regexp创建每个函数匹配的正则。如果匹配到对应的API，就把API的名字加入到helper集合中，最后在script setup的最上方加入一行import语句。</p><pre><code class=\"language-javascript\">\nconst vue3 = [\n  'ref',\n  'computed',\n  'reactive',\n  'onMounted',\n  'watchEffect',\n  'watch'\n] // 还有很多....\n\nexport default function autoImportPlugin() {\n  return {\n    name: 'vite-plugin-auto-import', // 必须的，将会在 warning 和 error 中显示\n    enforce:'pre',\n    transform(code,id){\n      vueReg = /\\.vue$/\n      if(vueReg.test(id)){\n        const helpers = new Set()\n        vue3.forEach(api=&gt;{\n          const reg = new RegExp(api+\"(.*)\")\n          if(reg.test(code)){\n            helpers.add(api)\n          }\n        })\n        return code.replace('&lt;script setup&gt;',`&lt;script setup&gt;\n\nimport {${[...helpers].join(',')}} from 'vue' //俺是自动导入的        \n`)\n      }\n      return code\n    }\n  }\n}\n</code></pre><p>接着，我们在项目的src目录下新建App.vue。下面的代码实现了一个简易的累加器，并且还会在onMount之后打印一条信息，这里的ref、computed和onMounted都是没有导入的。我们在浏览器就能看到页面可以正常显示，这时我们在浏览器调试窗口的sources页面中，就可以看到App.vue的代码已经自动加上了import语句。</p><pre><code class=\"language-javascript\">&lt;template&gt;\n  &lt;div @click=\"add\"&gt;\n    {{num}} * 2 = {{double}}\n  &lt;/div&gt;\n&lt;/template&gt;\n\n&lt;script setup&gt;\nlet num = ref(1)\nlet double = computed(()=&gt;num.value*2)\n\nfunction add(){\n  num.value++\n}\nonMounted(()=&gt;{\n  console.log('mounted')\n})\n\n&lt;/script&gt;\n</code></pre><h2><img src=\"https://static001.geekbang.org/resource/image/77/fd/77db83e745d7345a146f03364d93cbfd.png?wh=1662x790\" alt=\"图片\"></h2><p>这里的代码都是硬编码实现的，逻辑也比较简单。不过，实际场景中判断ref等API调用的正则和导入import的方式，都不会这么简单。如果我们自己每次都写一个parse模块比较麻烦，所以我们实际开发中会借助现有的工具对代码进行解析，而代码转换的场景下最成熟的工具就是Babel。</p><h2>Babel</h2><p>我们在项目中异步的任务有很多，经常使用async+ await的语法执行异步任务，比如网络数据的获取。但<strong> await是异步任务</strong>，如果报错，我们需要使用try catch语句进行错误处理，每个catch语句都是一个打印语句会让代码变得冗余，但我们有了代码转化的思路后，这一步就能用编译的思路自动来完成。</p><p>首先我们在根目录的src/main.js中新增下面代码，我们使用delyError函数模拟异步的任务报错，在代码中使用await来模拟异步任务。</p><p>这里我们希望每个await都能跟着一个try代码，在catch中能够打印错误消息提示的同时，还能够使用调用错误监控的函数，把当前错误信息发给后端服务器进行报警，当然也可以打印一个自动去stackoverflow查询的链接。</p><pre><code class=\"language-javascript\">function delyError(message){\n  return new Promise((resolve,reject)=&gt;{\n    setTimeout(()=&gt;{\n      reject({message})\n    },1000)\n  })\n}\nasync function test(){\n    await delyError('ref is not defined')\n}\n// 我们期望的代码\nasync function test(){\n  try{\n        await delyError('ref is not defined')\n  }catche(e){\n    console.error(e.message)\n    _errorTrack(e.message,location.pathname)\n     console.log('https://stackoverflow.com/search?q=[js]+'+encodeURI(e.message))\n  }\n\n}\ntest()\n</code></pre><p>页面中await语句变多了之后，手动替换的成本就比较高，我们可以继续使用vite的插件来实现。这次我们就是用Babel提供好的代码解析能力对代码进行转换。Babel都提供了哪些API，你可以在<a href=\"https://babel.docschina.org/docs/en/babel-parser\">Babel的官网</a>进行深入学习。</p><p>Babel提供了完整的编译代码的功能后函数，包括AST的解析、语义分析、代码生成等，我们可以通过下面的函数去实现自己的插件。</p><ul>\n<li>@babel/parser提供了代码解析的能力，能够把js代码解析成AST，代码就从字符串变成了树形结构，方便我们进行操作；</li>\n<li>@babel/traverse提供了遍历AST的能力，我们可以从travser中获取每一个节点的信息后去修改它；</li>\n<li>@babe/types提供了类型判断的函数，我们可以很方便的判断每个节点的类型；</li>\n<li>@babel/core提供了代码转化的能力。</li>\n</ul><p>下面的代码中我们实现了vite-plugin-auto-try插件，由babel/parer解析成为AST，通过travser遍历整个AST节点，配置的AwaitExpression会识别出AST中的await调用语句，再用isTryStatement判断await外层是否已经包裹了try语句。如果没有try语句的话，就使用tryStatement函数生成新的AST节点。</p><p>这个AST包裹当前的节点，并且我们在内部加上了stackoverflow链接的打印。最后，使用babel/core提供的transformFromAstSync函数，把优化后的AST生成新的JavaScript代码，自动新增try代码的插件就实现了。</p><pre><code class=\"language-javascript\">\n\nimport { parse } from '@babel/parser'\nimport traverse from '@babel/traverse'\nimport {\n  isTryStatement,\n  tryStatement,\n  isBlockStatement,\n  catchClause,\n  identifier,\n  blockStatement,\n} from '@babel/types'\nimport { transformFromAstSync } from '@babel/core'\n\nconst catchStatement = parse(`\n  console.error(err)\n  console.log('https://stackoverflow.com/search?q=[js]+'+encodeURI(err.message))\n`).program.body\n\nexport default function autoImportPlugin() {\n  return {\n    name: 'vite-plugin-auto-try', // 必须的，将会在 warning 和 error 中显示\n    enforce:'pre',\n    transform(code,id){\n        fileReg = /\\.js$/\n        if(fileReg.test(id)){\n        const ast = parse(code, {\n          sourceType: 'module'\n        })\n        traverse(ast, {\n          AwaitExpression(path){\n            console.log(path)\n            if (path.findParent((path) =&gt; isTryStatement(path.node))) {\n              // 已经有try了\n              return \n            }\n            // isBlockStatement 是否函数体\n            const blockParentPath = path.findParent((path) =&gt; isBlockStatement(path.node))\n            const tryCatchAst  = tryStatement(\n              blockParentPath.node,\n              // ast中新增try的ast\n              catchClause(\n                identifier('err'),\n                blockStatement(catchStatement),\n              )\n            )\n            // 使用有try的ast替换之前的ast\n            blockParentPath.replaceWithMultiple([tryCatchAst])\n\n          }\n        })\n        // 生成代码，generate\n        code = transformFromAstSync(ast,\"\",{\n          configFile:false\n        }).code\n\n        return code\n      }\n      return code\n    }\n  }\n}\n</code></pre><p>然后，我们在根目录下的src/main.js中写入下面的代码。两个await语句一个使用try包裹，一个没有使用try包裹。</p><p>接着我们启动项目后，就来到了浏览器的调试窗口中的source页面，可以看到下图中解析后的main.js代码，现在没有try的await语句已经自动加上了try语句。</p><p>你看，<strong>这次我们基于babel来实现，就省去了我们写正则的开发成本</strong>。Babel提供了一整套关于JavaScirpt中语句的转化函数，有兴趣的同学可以去Babel官网了解。</p><pre><code class=\"language-javascript\">import { createApp } from \"vue\";\nimport App from './App.vue'\n\ncreateApp(App)\n  .mount('#app')\n\nasync function test(){\n  await delyError('ref is not defined')\n}\n\nasync function test2(){\n  try{\n    await delyError('reactive is not defined')\n  }catch(e){\n    console.error(e)\n  }\n}\ntest()\nfunction delyError(message){\n  return new Promise((resolve,reject)=&gt;{\n    setTimeout(()=&gt;{\n      reject({message})\n    },1000)\n  })\n}\n\n</code></pre><h2><img src=\"https://static001.geekbang.org/resource/image/0a/f9/0a00c01yyfdf020eec114fc5a70344f9.png?wh=1920x1056\" alt=\"图片\"></h2><p>有了Babel提供的能力之后，我们可以只关注于代码中需要转换的逻辑，比如我们可以使用Babel实现国际化，把每种语言在编译的时候自动替换语言，打包成独立的项目；也可以实现页面的自动化监控，在一些操作函数里面加入监控的代码逻辑。你可以自行发挥想象力，使用编译的思想来提高日常的开发效率。</p><p>最后我们回顾一下Vue中的compiler。Vue中的compiler-dom提供了compile函数，具体的compile逻辑我们在上一讲中已经详细学习了。其实我们也可以手动导入compiler-dom包之后，自己实现对vue template的解析。另外，Vue中还提供了@vue/compiler-sfc包，用来实现单文件组件.vue的解析，还有@vue/compiler-ssr包，它实现了服务端渲染的解析。</p><p>下一讲我们一起来手写vite的代码内容，我们就需要在nodejs中实现对Vue单文件组件的解析工作，实现浏览器中直接导入单文件组件的功能，敬请期待。</p><h2>总结</h2><p>最后我们总结一下今天学到的内容。</p><p>我们把Vue内部的compiler原理融会贯通之后，今天尝试把template到render转化过程的思想应用到实际项目中。Vue中的compiler在转化的过程中还做了静态标记的优化，我们在实际开发中可以借鉴编译的思路，提高开发的效率。</p><p>我们一起回顾一下代码自动导入的操作思路。首先我们可以实现页面中ref、computed的API的自动化导入，在vite插件的transform函数中获取到待转换的代码，通过对代码的内容进行正则匹配，实现如果出现了ref，computed等函数的调用，我们可以把这些依赖的函数收集在helper中。最终在script setup标签之前新增import语句来导入依赖的API，最终就可以实现代码的自动导入。</p><p><strong>实际开发中，我们可以把使用到的组件库Element3，工具函数vueuse等框架都进行语法的解析，实现函数和组件的自动化导入和按需加载。这样能在提高开发效率的同时，也提高我们书写vite插件的能力</strong>。</p><h2>思考题</h2><p>最后留一个思考题吧，你觉得在工作项目中有哪里需要用到代码转化的思路呢？欢迎在评论区分享你的答案，也欢迎你把这一讲的内容分享给你的同事和朋友们，我们下一讲再见！</p>",
        article_title: "34 | 编译原理（下）：编译原理给我们带来了什么？",
      },
      {
        title: "35｜Vite原理：写一个迷你的Vite",
        id: 476156,
        content:
          "<p>你好，我是大圣。</p><p>上一讲学完了Vue的编译原理后，我们就把Vue的整体流程梳理完毕了，但是我们在使用Vue的时候，还会用到很多Vue生态的库。所以从今天开始，我会带你了解几个Vue生态中重要成员的原理和源码，今天我先带你剖析一下我们项目中用的工程化工具Vite的原理。</p><h2>现在工程化的痛点</h2><p>现在前端开发项目的时候，工程化工具已经成为了标准配置，webpack是现在使用率最高的工程化框架，它可以很好地帮助我们完成从代码调试到打包的全过程，但是随着项目规模的爆炸式增长，<strong>webpack也带来了一些痛点问题</strong>。</p><p>最早webpack可以帮助我们在JavaScript文件中使用require导入其他JavaScript、CSS、image等文件，并且提供了dev-server启动测试服务器，极大地提高了我们开发项目的效率。</p><p>webpack的核心原理就是通过分析JavaScript中的require语句，分析出当前JavaScript文件所有的依赖文件，然后递归分析之后，就得到了整个项目的一个依赖图。对图中不同格式的文件执行不同的loader，比如会把CSS文件解析成加载CSS标签的JavaScript代码，最后基于这个依赖图获取所有的文件。</p><!-- [[[read_end]]] --><p>进行打包处理之后，放在内存中提供给浏览器使用，然后dev-server会启动一个测试服务器打开页面，并且在代码文件修改之后可以通过WebSocket通知前端自动更新页面，<strong>也就是我们熟悉的热更新功能</strong>。</p><p>由于webpack在项目调试之前，要把所有文件的依赖关系收集完，打包处理后才能启动测试，很多大项目我们执行调试命令后需要等1分钟以上才能开始调试。这对于开发者来说，这段时间除了摸鱼什么都干不了，而且热更新也需要等几秒钟才能生效，极大地影响了我们开发的效率。所以针对webpack这种打包bundle的思路，社区就诞生了bundless的框架，Vite就是其中的佼佼者。</p><p>前端的项目之所以需要webpack打包，是因为<strong>浏览器里的JavaScript没有很好的方式去引入其他文件</strong>。webpack提供的打包功能可以帮助我们更好地组织开发代码，但是现在大部分浏览器都支持了ES6的module功能，我们在浏览器内使用type=\"module\"标记一个script后，在src/main.js中就可以直接使用import语法去引入一个新的JavaScript文件。这样我们其实可以不依赖webpack的打包功能，利用浏览器的module功能就可以重新组织我们的代码。</p><pre><code class=\"language-javascript\">    &lt;script type=\"module\" src=\"/src/main.js\"&gt;&lt;/script&gt;\n</code></pre><h2>Vite原理</h2><p>了解了script的使用方式之后，我们来实现一个<strong>迷你的 Vite</strong>来讲解其大致的原理。</p><p>首先，浏览器的module功能有一些限制需要额外处理。浏览器识别出JavaScript中的import语句后，会发起一个新的网络请求去获取新的文件，所以只支持/\b、./和…/开头的路径。</p><p>而在下面的Vue项目启动代码中，首先浏览器并不知道Vue是从哪来，我们第一个要做的，就是分析文件中的import语句。如果路径不是一个相对路径或者绝对路径，那就说明这个模块是来自node_modules，我们需要去node_modules查找这个文件的入口文件后返回浏览器。然后 ./App.vue是相对路径，可以找到文件，但是浏览器不支持 .vue文件的解析，并且index.css也不是一个合法的JavaScript文件。</p><p><strong>我们需要解决以上三个问题，才能让Vue项目很好地在浏览器里跑起来。</strong></p><pre><code class=\"language-javascript\">import { createApp } from 'vue'\nimport App from './App.vue'\nimport './index.css'\n\nconst app = createApp(App)\napp.mount('#app')\n\n</code></pre><p>怎么做呢？首先我们需要使用Koa搭建一个server，用来拦截浏览器发出的所有网络请求，才能实现上述功能。在下面代码中，我们使用Koa启动了一个服务器，并且访问首页内容读取index.html的内容。</p><pre><code class=\"language-javascript\">const fs = require('fs')\nconst path = require('path')\nconst Koa = require('koa')\nconst app = new Koa()\n\napp.use(async ctx=&gt;{\n  const {request:{url,query} } = ctx\nif(url=='/'){\n    ctx.type=\"text/html\"\n    let content = fs.readFileSync('./index.html','utf-8')\n    \n    ctx.body = content\n  }\n})\napp.listen(24678, ()=&gt;{\n  console.log('快来快来数一数，端口24678')\n})\n</code></pre><p>下面就是首页index.html的内容，一个div作为Vue启动的容器，并且通过script引入src.main.js。我们访问首页之后，就会看到浏览器内显示的geektime文本，并且发起了一个main.js的HTTP请求，<strong>然后我们来解决页面中的报错问题</strong>。</p><pre><code class=\"language-javascript\">&lt;!DOCTYPE html&gt;\n&lt;html lang=\"en\"&gt;\n&lt;head&gt;\n  &lt;meta charset=\"UTF-8\"&gt;\n  &lt;link rel=\"icon\" href=\"/favicon.ico\" /&gt;\n  &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt;\n  &lt;title&gt;Vite App&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n  &lt;h1&gt;geek time&lt;/h1&gt;\n  &lt;div id=\"app\"&gt;&lt;/div&gt;\n  &lt;script type=\"module\" src=\"/src/main.js\"&gt;&lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n\n</code></pre><p>首先import {createApp} from Vue这一步由于浏览器无法识别Vue的路径，就会直接抛出错误，所以我们要在Koa中把Vue的路径重写。为了方便演示，我们可以直接使用replace语句，把Vue改成/@modules/vue，使用@module开头的地址来告诉Koa这是一个需要去node_modules查询的模块。</p><p>在下面的代码中，我们判断如果请求地址是js结尾，就去读取对应的文件内容，使用rewriteImport函数处理后再返回文件内容。在rewriteImport中我们实现了路径的替换，把Vue变成了 @modules/vue， 现在浏览器就会发起一个<a href=\"http://localhost:24678/@modules/vue\">http://localhost:24678/@modules/vue</a> 的请求，下一步我们要在Koa中拦截这个请求，并且返回Vue的代码内容。</p><pre><code class=\"language-javascript\">const fs = require('fs')\nconst path = require('path')\nconst Koa = require('koa')\nconst app = new Koa()\n\nfunction rewriteImport(content){\n  return content.replace(/ from ['|\"]([^'\"]+)['|\"]/g, function(s0,s1){\n    // . ../ /开头的，都是相对路径\n    if(s1[0]!=='.'&amp;&amp; s1[1]!=='/'){\n      return ` from '/@modules/${s1}'`\n    }else{\n      return s0\n    }\n  })\n}\n\napp.use(async ctx=&gt;{\n  const {request:{url,query} } = ctx\n  if(url=='/'){\n      ctx.type=\"text/html\"\n      let content = fs.readFileSync('./index.html','utf-8')\n      \n      ctx.body = content\n  }else if(url.endsWith('.js')){\n    // js文件\n    const p = path.resolve(__dirname,url.slice(1))\n    ctx.type = 'application/javascript'\n    const content = fs.readFileSync(p,'utf-8')\n    ctx.body = rewriteImport(content)\n  }\n})\napp.listen(24678, ()=&gt;{\n  console.log('快来快来说一书，端口24678')\n})\n\n</code></pre><p><img src=\"https://static001.geekbang.org/resource/image/c3/62/c39f700e37b638345ae4cbd0228fd762.png?wh=1125x387\" alt=\"图片\"></p><p>然后我们在Koa中判断请求地址，如果是@module的地址，就把后面的Vue解析出来，去node_modules中查询。然后拼接出目标路径 ./node_modules/vue/package.json去读取Vue项目中package.json的module字段，这个字段的地址就是 ES6 规范的入口文件。在我们读取到文件后，再使用rewriteImport处理后返回即可。</p><p>这里还要使用rewriteImport的原因是，Vue文件内部也会使用import的语法去加载其他模块。然后我们就可以看到浏览器网络请求列表中多了好几个Vue的请求。</p><pre><code class=\"language-javascript\">else if(url.startsWith('/@modules/')){\n    // 这是一个node_module里的东西\n    const prefix = path.resolve(__dirname,'node_modules',url.replace('/@modules/',''))\n    const module = require(prefix+'/package.json').module\n    const p = path.resolve(prefix,module)\n    const ret = fs.readFileSync(p,'utf-8')\n    ctx.type = 'application/javascript'\n    ctx.body = rewriteImport(ret)\n}\n</code></pre><p><img src=\"https://static001.geekbang.org/resource/image/7f/fb/7fb5564ac59ffba085d9c7fd24f8f9fb.png?wh=1681x512\" alt=\"图片\"></p><p><strong>这样我们就实现了node_modules模块的解析，然后我们来处理浏览器无法识别 .vue文件的错误。</strong></p><p>.vue文件是Vue中特有的文件格式，我们上一节课提过Vue内部通过@vue/compiler-sfc来解析单文件组件，把组件分成template、style、script三个部分，我们要做的就是在Node环境下，把template的内容解析成render函数，并且和script的内容组成组件对象，再返回即可。</p><p>其中，compiler-dom解析template的流程我们学习过，今天我们来看下如何使用。</p><p>在下面的代码中，我们判断 .vue的文件请求后，通过compilerSFC.parse方法解析Vue组件，通过返回的descriptor.script获取JavaScript代码，并且发起一个type=template的方法去获取render函数。在query.type是template的时候，调用compilerDom.compile解析template内容，直接返回render函数。</p><pre><code class=\"language-javascript\">const compilerSfc = require('@vue/compiler-sfc') // .vue\nconst compilerDom = require('@vue/compiler-dom') // 模板\n\n\n\n\n\nif(url.indexOf('.vue')&gt;-1){\n    // vue单文件组件\n    const p = path.resolve(__dirname, url.split('?')[0].slice(1))\n    const {descriptor} = compilerSfc.parse(fs.readFileSync(p,'utf-8'))\n\n    if(!query.type){\n      ctx.type = 'application/javascript'\n      // 借用vue自导的compile框架 解析单文件组件，其实相当于vue-loader做的事情\n      ctx.body = `\n  ${rewriteImport(descriptor.script.content.replace('export default ','const __script = '))}\n  import { render as __render } from \"${url}?type=template\"\n  __script.render = __render\n  export default __script\n      `\n    }else if(query.type==='template'){\n      // 模板内容\n      const template = descriptor.template\n      // 要在server端吧compiler做了\n      const render = compilerDom.compile(template.content, {mode:\"module\"}).code\n      ctx.type = 'application/javascript'\n\n      ctx.body = rewriteImport(render)\n    }\n    \n</code></pre><p>上面的代码实现之后，我们就可以在浏览器中看到App.vue组件解析的结果。App.vue会额外发起一个App.vue?type=template的请求，最终完成了整个App组件的解析。</p><p><img src=\"https://static001.geekbang.org/resource/image/f9/90/f986571970188eac47bb4fac1af37d90.png?wh=1920x552\" alt=\"图片\"><img src=\"https://static001.geekbang.org/resource/image/cc/46/cc696c23a2a6d4e9eacf401375320146.png?wh=1920x384\" alt=\"图片\"></p><p><strong>接下来我们再来实现对CSS文件的支持。</strong>下面的代码中，如果url是CSS结尾，我们就返回一段JavaScript代码。这段JavaScript代码会在浏览器里创建一个style标签，标签内部放入我们读取的CSS文件代码。这种对CSS文件的处理方式，让CSS以JavaScript的形式返回，这样我们就实现了在Node中对Vue组件的渲染。</p><pre><code class=\"language-javascript\">if(url.endsWith('.css')){\n    const p = path.resolve(__dirname,url.slice(1))\n    const file = fs.readFileSync(p,'utf-8')\n    const content = `\n    const css = \"${file.replace(/\\n/g,'')}\"\n    let link = document.createElement('style')\n    link.setAttribute('type', 'text/css')\n    document.head.appendChild(link)\n    link.innerHTML = css\n    export default css\n    `\n    ctx.type = 'application/javascript'\n    ctx.body = content\n  }\n</code></pre><p><img src=\"https://static001.geekbang.org/resource/image/9f/f7/9f50c5ca0d9b74b680e41963055c99f7.png?wh=1920x628\" alt=\"图片\"></p><h2>Vite的热更新</h2><p>最后我们再来看一下热更新如何实现。热更新的目的就是在我们修改代码之后，<strong>浏览器能够自动渲染更新的内容</strong>，所以我们要在客户端注入一个额外的JavaScript文件，这个文件用来和后端实现WebSocket通信。然后后端启动WebSocket服务，通过chokidar库监听文件夹的变化后，再通过WebSocket去通知浏览器即可。</p><p>下面的代码中，我们通过chokidar.watch实现了文件夹变更的监听，并且通过handleHMRUpdate通知客户端文件更新的类型。</p><pre><code class=\"language-javascript\">\nexport function watch() {\n  const watcher = chokidar.watch(appRoot, {\n    ignored: ['**/node_modules/**', '**/.git/**'],\n    ignoreInitial: true,\n    ignorePermissionErrors: true,\n    disableGlobbing: true,\n  });\n  watcher;\n\n  return watcher;\n}\nexport function handleHMRUpdate(opts: { file: string; ws: any }) {\n  const { file, ws } = opts;\n  const shortFile = getShortName(file, appRoot);\n  const timestamp = Date.now();\n\n  console.log(`[file change] ${chalk.dim(shortFile)}`);\n  let updates;\n  if (shortFile.endsWith('.css')) {\n    updates = [\n      {\n        type: 'js-update',\n        timestamp,\n        path: `/${shortFile}`,\n        acceptedPath: `/${shortFile}`,\n      },\n    ];\n  }\n\n  ws.send({\n    type: 'update',\n    updates,\n  });\n}\n\n</code></pre><p>然后客户端注入一段额外的JavaScript代码，判断后端传递的类型是js-update还是css-update去执行不同的函数即可。</p><pre><code class=\"language-javascript\">async function handleMessage(payload: any) {\n  switch (payload.type) {\n    case 'connected':\n      console.log(`[vite] connected.`);\n\n      setInterval(() =&gt; socket.send('ping'), 30000);\n      break;\n\n    case 'update':\n      payload.updates.forEach((update: Update) =&gt; {\n        if (update.type === 'js-update') {\n          fetchUpdate(update);\n        } \n      });\n      break;\n  }\n}\n\n</code></pre><h2>总结</h2><p>以上就是今天的主要内容，我们来总结一下吧！</p><p>首先，我们通过了解webpack的大致原理，知道了现在webpack在开发体验上的痛点。除了用户体验UX之外，开发者的体验DX也是项目质量的重要因素。</p><p>webpack启动服务器之前需要进行项目的打包，而Vite则是可以直接启动服务，通过浏览器运行时的请求拦截，实现首页文件的按需加载，这样开发服务器启动的时间就和整个项目的复杂度解耦。任何时候我们启动Vite的调试服务器，基本都可以在一秒以内响应，这极大地提升了开发者的体验，这也是Vite的使用率越来越高的原因。</p><p>并且我们可以看到，Vite的主要目的就是提供一个调试服务器。Vite也可以和Vue解耦，实现对任何框架的支持，如果使用Vite支持React，只需要解析React中的JSX就可以实现。这也是Vite项目的现状，我们只需要使用框架对应的Vite插件就可以支持任意框架。</p><p>Vite能够做到这么快的原因，还有一部分是因为使用了esbuild去解析JavaScript文件。esbuild是一个用Go语言实现的JavaScript打包器，支持JavaScript和TypeScript语法，现在前端工程化领域的工具也越来越多地使用Go和Rust等更高效的语言书写，这也是性能优化的一个方向。</p><h2>思考题</h2><p>最后留一个思考题吧。如果一个模块文件是分散的，导致Vite首页一下子要加载1000个JavaScript文件造成卡顿，我们该如何处理这种情况呢？</p><p>欢迎在评论区分享你的答案，我们下一讲再见！</p>",
        article_title: "35｜Vite原理：写一个迷你的Vite",
      },
      {
        title: "36｜数据流原理：Vuex & Pinia源码剖析",
        id: 476214,
        content:
          "<p>你好，我是大圣。</p><p>上一讲我们分析了Vite原理，今天我们来剖析Vuex的原理。其实在之前的课程中，我们已经实现过一个迷你的Vuex，整体代码逻辑比较简单，基于Vue提供的响应式函数reactive和computed的能力，我们封装了一个独立的共享数据的store，并且对外暴露了commit和dispatch方法修改和更新数据，这些原理就不赘述了。</p><p>今天我们探讨一下下一代Vuex5的提案，并且看一下实际的代码是如何实现的，你学完之后可以对比之前gvuex mini版本，感受一下两者的区别。</p><h2>Vuex5提案</h2><p>由于Vuex有模块化namespace的功能，所以模块user中的mutation add方法，我们需要使用 <code>commit('user/add')</code> 来触发。这样虽然可以让Vuex支持更复杂的项目，但是<strong>这种字符串类型的拼接功能，在TypeScript4之前的类型推导中就很难实现</strong>。然后就有了Vuex5相关提案的讨论，整个讨论过程都是在GitHub的issue里推进的，你可以访问<a href=\"https://github.com/vuejs/rfcs/pull/271\">GitHub链接</a>去围观。</p><p>Vuex5的提案相比Vuex4有很大的改进，解决了一些Vuex4中的缺点。Vuex5能够同时支持Composition API和Option API，并且去掉了namespace模式，使用组合store的方式更好地支持了TypeScript的类型推导，还去掉了容易混淆的Mutation和Action概念，只保留了Action，并且<strong>支持自动的代码分割</strong>。</p><!-- [[[read_end]]] --><p>我们也可以通过对这个提案的研究，来体验一下在一个框架中如何讨论新的语法设计和实现，以及如何通过API的设计去解决开发方式的痛点。你可以在Github的提案RFCs中看到<a href=\"https://github.com/vuejs/rfcs/blob/34a8b0d541a361a37d05de8d67cb44a7b6f6fd12/active-rfcs/0000-vuex-5.md\">Vuex5的设计文稿</a>，而Pinia正是基于Vuex5设计的框架。</p><p>现在Pinia已经正式合并到Vue组织下，成为了Vue的官方项目，尤雨溪也在多次分享中表示<strong>Pinia就是未来的Vuex</strong>，接下来我们就好好学习一下Pinia的使用方式和实现的原理。</p><h2>Pinia</h2><p>下图是Pinia官网的介绍，可以看到类型安全、Vue 的Devtools支持、易扩展、只有1KB的体积等优点。快来看下Pinia如何使用吧。</p><p><img src=\"https://static001.geekbang.org/resource/image/41/6c/41f8301ee6610c3892f6530f6061ff6c.png?wh=1941x736\" alt=\"\"></p><p>首先我们在项目根目录下执行下面的命令去<strong>安装Pinia的最新版本</strong>。</p><pre><code class=\"language-javascript\">npm install pinia@next\n</code></pre><p>然后在src/main.js中，我们导入createPinia方法，通过createPinia方法创建Pinia的实例后，再通过app.use方法注册Pinia。</p><pre><code class=\"language-javascript\">import { createApp } from 'vue'\nimport { createPinia } from 'pinia'\nimport App from './App.vue'\nconst pinia = createPinia()\nconst app = createApp(App)\napp.use(pinia).mount('#app')\n\n</code></pre><p>然后我们可以在store文件夹中创建一个count.js。下面的代码中我们通过Pinia的defineStore方法定义了一个store，store内部通过state返回一个对象，并且通过Actions配置修改数据的方法add。这里使用的语法和Vuex比较类似，只是删除了Mutation的概念，<strong>统一使用Actions来配置</strong>。</p><pre><code class=\"language-javascript\">\n\nimport { defineStore } from 'pinia'\n\nexport const useCounterStore = defineStore('count', {\n  id:'count',\n&nbsp; state: () =&gt; {\n&nbsp; &nbsp; return { count: 1 }\n&nbsp; },\n&nbsp; actions: {\n&nbsp; &nbsp; add() {\n&nbsp; &nbsp; &nbsp; this.count++\n&nbsp; &nbsp; },\n&nbsp; },\n})\n\n</code></pre><p>然后我们可以使用Composition的方式在代码中使用store。注意上面的store返回的其实就是一个Composition风格的函数，使用useCounterStore返回count后，可以在add方法中直接使用count.add触发Actions，实现数据的修改。</p><pre><code class=\"language-javascript\">import { useCounterStore } from '../stores/count'\n\nconst count = useCounterStore()\nfunction add(){\n  count.add()\n}\n\n    \n</code></pre><p><strong>我们也可以使用Composition风格的语法，去创建一个store。</strong>使用ref或者reactive包裹后，通过defineStore返回，这样store就非常接近我们自己分装的Composition语法了，也去除了很多Vuex中特有的概念，学习起来更加简单。</p><pre><code class=\"language-javascript\">export const useCounterStore = defineStore('count', () =&gt; {\n&nbsp; const count = ref(0)\n&nbsp; function increment() {\n&nbsp; &nbsp; count.value++\n&nbsp; }\n\n&nbsp; return { count, increment }\n})\n\n</code></pre><h2>Pinna源码</h2><p>然后我们通过阅读Pinia的源码，来看下Pinia是如何实现的。</p><p>首先我们进入到Pinia的GitHub中，我们可以在packages/pinia/src/createPinia.ts中看到createPinia函数的实现。</p><p>下面的代码中，我们通过effectScope创建一个作用域对象，并且通过ref创建了响应式的数据对象state。然后通过install方法支持了app.use的注册，内部通过provide的语法和全局的$pinia变量配置Pinia对象，并且通过use方法和toBeInstalled数组实现了Pinia的插件机制。<strong>最后还通过pinia.use(devtoolsPlugin) 实现了对VueDevtools的支持。</strong></p><pre><code class=\"language-javascript\">export function createPinia(): Pinia {\n  const scope = effectScope(true)\n  // NOTE: here we could check the window object for a state and directly set it\n  // if there is anything like it with Vue 3 SSR\n  const state = scope.run(() =&gt; ref&lt;Record&lt;string, StateTree&gt;&gt;({}))!\n\n  let _p: Pinia['_p'] = []\n  // plugins added before calling app.use(pinia)\n  let toBeInstalled: PiniaPlugin[] = []\n\n  const pinia: Pinia = markRaw({\n    install(app: App) {\n      // this allows calling useStore() outside of a component setup after\n      // installing pinia's plugin\n      setActivePinia(pinia)\n      if (!isVue2) {\n        pinia._a = app\n        app.provide(piniaSymbol, pinia)\n        app.config.globalProperties.$pinia = pinia\n        toBeInstalled.forEach((plugin) =&gt; _p.push(plugin))\n        toBeInstalled = []\n      }\n    },\n\n    use(plugin) {\n      if (!this._a &amp;&amp; !isVue2) {\n        toBeInstalled.push(plugin)\n      } else {\n        _p.push(plugin)\n      }\n      return this\n    },\n\n    _p,\n    _a: null,\n    _e: scope,\n    _s: new Map&lt;string, StoreGeneric&gt;(),\n    state,\n  })\n  if (__DEV__ &amp;&amp; IS_CLIENT) {\n    pinia.use(devtoolsPlugin)\n  }\n\n  return pinia\n}\n\n</code></pre><p>通过上面的代码，我们可以看到Pinia实例就是 ref({}) 包裹的响应式对象，项目中用到的state都会挂载到Pinia这个响应式对象内部。</p><p>然后我们去看下创建store的defineStore方法,  defineStore内部通过useStore方法去定义store，并且每个store都会标记唯一的ID。</p><p>首先通过getCurrentInstance获取当前组件的实例，如果useStore参数没有Pinia的话，就使用inject去获取Pinia实例，<strong>这里inject的数据就是createPinia函数中install方法提供的</strong>。</p><p>然后设置activePinia，项目中可能会存在很多Pinia的实例，设置activePinia就是设置当前活跃的Pinia实例。这个函数的实现方式和Vue中的componentInstance很像，每次创建组件的时候都设置当前的组件实例，这样就可以在组件的内部通过getCurrentInstance获取，最后通过createSetupStore或者createOptionsStore创建组件。</p><p>这就是上面代码中我们使用Composition和Option两种语法创建store的不同执行逻辑，最后通过pinia._s缓存创建后的store，_s就是在createPinia的时候创建的一个Map对象，防止store多次重复创建。<strong>到这store创建流程就结束了。</strong></p><pre><code class=\"language-javascript\">export function defineStore(\n  // TODO: add proper types from above\n  idOrOptions: any,\n  setup?: any,\n  setupOptions?: any\n): StoreDefinition {\n  let id: string\n  let options:...\n  const isSetupStore = typeof setup === 'function'\n  if (typeof idOrOptions === 'string') {\n    id = idOrOptions\n    // the option store setup will contain the actual options in this case\n    options = isSetupStore ? setupOptions : setup\n  } else {\n    options = idOrOptions\n    id = idOrOptions.id\n  }\n\n  function useStore(pinia?: Pinia | null, hot?: StoreGeneric): StoreGeneric {\n    const currentInstance = getCurrentInstance()\n    pinia =\n      // in test mode, ignore the argument provided as we can always retrieve a\n      // pinia instance with getActivePinia()\n      (__TEST__ &amp;&amp; activePinia &amp;&amp; activePinia._testing ? null : pinia) ||\n      (currentInstance &amp;&amp; inject(piniaSymbol))\n    if (pinia) setActivePinia(pinia)\n\n    pinia = activePinia!\n\n    if (!pinia._s.has(id)) {\n      // creating the store registers it in `pinia._s`\n      if (isSetupStore) {\n        createSetupStore(id, setup, options, pinia)\n      } else {\n        createOptionsStore(id, options as any, pinia)\n      }\n\n      /* istanbul ignore else */\n      if (__DEV__) {\n        // @ts-expect-error: not the right inferred type\n        useStore._pinia = pinia\n      }\n    }\n\n    const store: StoreGeneric = pinia._s.get(id)!\n\n    // save stores in instances to access them devtools\n    if (\n      __DEV__ &amp;&amp;\n      IS_CLIENT &amp;&amp;\n      currentInstance &amp;&amp;\n      currentInstance.proxy &amp;&amp;\n      // avoid adding stores that are just built for hot module replacement\n      !hot\n    ) {\n      const vm = currentInstance.proxy\n      const cache = '_pStores' in vm ? vm._pStores! : (vm._pStores = {})\n      cache[id] = store\n    }\n\n    // StoreGeneric cannot be casted towards Store\n    return store as any\n  }\n\n  useStore.$id = id\n\n  return useStore\n}\n\n</code></pre><p>在Pinia中createOptionsStore内部也是调用了createSetupStore来创建store对象。下面的代码中，我们通过assign方法实现了setup函数，这里可以看到computed的实现，内部就是通过pinia._s缓存获取store对象，调用store的getters方法来模拟，最后依然通过createSetupStore创建。</p><pre><code class=\"language-javascript\">function createOptionsStore&lt;\n  Id extends string,\n  S extends StateTree,\n  G extends _GettersTree&lt;S&gt;,\n  A extends _ActionsTree\n&gt;(\n  id: Id,\n  options: DefineStoreOptions&lt;Id, S, G, A&gt;,\n  pinia: Pinia,\n  hot?: boolean\n): Store&lt;Id, S, G, A&gt; {\n  const { state, actions, getters } = options\n\n  const initialState: StateTree | undefined = pinia.state.value[id]\n\n  let store: Store&lt;Id, S, G, A&gt;\n\n  function setup() {\n\n    pinia.state.value[id] = state ? state() : {}\n    return assign(\n      localState,\n      actions,\n      Object.keys(getters || {}).reduce((computedGetters, name) =&gt; {\n        computedGetters[name] = markRaw(\n          computed(() =&gt; {\n            setActivePinia(pinia)\n            // it was created just before\n            const store = pinia._s.get(id)!\n            return getters![name].call(store, store)\n          })\n        )\n        return computedGetters\n      }, {} as Record&lt;string, ComputedRef&gt;)\n    )\n  }\n\n  store = createSetupStore(id, setup, options, pinia, hot)\n\n  return store as any\n}\n</code></pre><p>最后我们来看一下createSetupStore函数的实现。这个函数也是Pinia中最复杂的函数实现，内部的$patch函数可以实现数据的更新。如果传递的参数partialStateOrMutator是函数，则直接执行，否则就通过mergeReactiveObjects方法合并到state中，最后生成subscriptionMutation对象，<strong>通过triggerSubscriptions方法触发数据的更新</strong>。</p><pre><code class=\"language-javascript\">  function $patch(\n    partialStateOrMutator:\n      | _DeepPartial&lt;UnwrapRef&lt;S&gt;&gt;\n      | ((state: UnwrapRef&lt;S&gt;) =&gt; void)\n  ): void {\n    let subscriptionMutation: SubscriptionCallbackMutation&lt;S&gt;\n    isListening = isSyncListening = false\n    // reset the debugger events since patches are sync\n    /* istanbul ignore else */\n    if (__DEV__) {\n      debuggerEvents = []\n    }\n    if (typeof partialStateOrMutator === 'function') {\n      partialStateOrMutator(pinia.state.value[$id] as UnwrapRef&lt;S&gt;)\n      subscriptionMutation = {\n        type: MutationType.patchFunction,\n        storeId: $id,\n        events: debuggerEvents as DebuggerEvent[],\n      }\n    } else {\n      mergeReactiveObjects(pinia.state.value[$id], partialStateOrMutator)\n      subscriptionMutation = {\n        type: MutationType.patchObject,\n        payload: partialStateOrMutator,\n        storeId: $id,\n        events: debuggerEvents as DebuggerEvent[],\n      }\n    }\n    nextTick().then(() =&gt; {\n      isListening = true\n    })\n    isSyncListening = true\n    // because we paused the watcher, we need to manually call the subscriptions\n    triggerSubscriptions(\n      subscriptions,\n      subscriptionMutation,\n      pinia.state.value[$id] as UnwrapRef&lt;S&gt;\n    )\n  }\n\n</code></pre><p>然后定义partialStore对象去存储ID、$patch、Pinia实例，并且新增了subscribe方法。再调用reactive函数把partialStore包裹成响应式对象，通过pinia._s.set的方法实现store的挂载。</p><p>最后我们通过pinia._s.get获取的就是partialStore对象，defineStore返回的方法useStore就可以通过useStore去获取缓存的Pinia对象，实现对数据的更新和读取。</p><p>这里我们也可以看到，除了直接执行Action方法，还可以通过调用内部的 <code>count.$patch({count:count+1})</code> 的方式来实现数字的累加。</p><pre><code class=\"language-javascript\">  const partialStore = {\n    _p: pinia,\n    // _s: scope,\n    $id,\n    $onAction: addSubscription.bind(null, actionSubscriptions),\n    $patch,\n    $reset,\n    $subscribe(callback, options = {}) {\n      const removeSubscription = addSubscription(\n        subscriptions,\n        callback,\n        options.detached,\n        () =&gt; stopWatcher()\n      )\n      const stopWatcher = scope.run(() =&gt;\n        watch(\n          () =&gt; pinia.state.value[$id] as UnwrapRef&lt;S&gt;,\n          (state) =&gt; {\n            if (options.flush === 'sync' ? isSyncListening : isListening) {\n              callback(\n                {\n                  storeId: $id,\n                  type: MutationType.direct,\n                  events: debuggerEvents as DebuggerEvent,\n                },\n                state\n              )\n            }\n          },\n          assign({}, $subscribeOptions, options)\n        )\n      )!\n\n      return removeSubscription\n    }\n    \n\n  const store: Store&lt;Id, S, G, A&gt; = reactive(\n    assign({}， partialStore )\n  )\n\n  // store the partial store now so the setup of stores can instantiate each other before they are finished without\n  // creating infinite loops.\n  pinia._s.set($id, store)\n\n\n\n</code></pre><p><strong>我们可以看出一个简单的store功能，真正需要支持生产环境的时候，也需要很多逻辑的封装。</strong></p><p>代码内部除了__dev__调试环境中对Devtools支持的语法，还有很多适配Vue 2的语法，并且同时支持Optipn风格和Composition风格去创建store。createSetupStore等方法内部也会通过Map的方式实现缓存，并且setActivePinia方法可以在多个Pinia实例的时候获取当前的实例。</p><p>这些思路在Vue、vue-router源码中都能看到类似的实现方式，这种性能优化的思路和手段也值得我们学习，在项目开发中也可以借鉴。</p><h2>总结</h2><p>最后我们总结一下今天学到的内容吧。由于课程之前的内容已经手写了一个迷你的Vuex，这一讲我们就越过Vuex4，直接去研究了Vuex5的提案。</p><p>Vuex5针对Vuex4中的几个痛点，去掉了容易混淆的概念Mutation，并且去掉了对TypeScript不友好的namespace功能，使用组合store的方式让Vuex对TypeScript更加友好。</p><p>Pinia就是Vuex5提案产出的框架，现在已经是Vue官方的框架了，也就是Vuex5的实现。在Pinia的代码中，我们通过createPinia创建Pinia实例，并且可以通过Option和Composition两种风格的API去创建store，返回 useStore 函数获取Pinia的实例后，就可以进行数据的修改和读取。</p><h2>思考</h2><p>最后留一个思考题吧。对于数据共享语法，还有provide/inject和自己定义的Composition，什么时候需要使用Pinia呢？</p><p>欢迎到评论区分享你的想法，也欢迎你把这一讲的内容分享给你的朋友们，我们下一讲再见！</p>",
        article_title: "36｜数据流原理：Vuex & Pinia源码剖析",
      },
      {
        title: "37｜前端路由原理：vue-router源码剖析",
        id: 476717,
        content:
          "<p>你好，我是大圣。</p><p>上一讲我们学习了下一代Vuex框架Pinia的原理，今天我来带你分析Vue生态中另外一个重要的框架vue-router的源码。</p><p>课程中我们也实现过一个迷你的router，我们通过监听路由的变化，把路由数据包裹成响应式对象后，一旦路由发生变化，我们就去定义好的路由数据中查询当前路由对应的组件，在router-view中渲染即可。今天我们就进入到vue-router源码的内部，看一下实际的vue-router和我们实现的迷你版本有什么区别。</p><h2>vue-router入口分析</h2><p>vue-router提供了createRouter方法来创建路由配置，我们传入每个路由地址对应的组件后，使用app.use在Vue中加载vue-router插件，并且给Vue注册了两个内置组件，router-view负责渲染当前路由匹配的组件，router-link负责页面的跳转。</p><p><strong>我们先来看下createRouter如何实现</strong>，完整的代码你可以在<a href=\"https://github.com/vuejs/vue-router-next/blob/master/src/router.ts#L355\">GitHub</a>上看到。这个函数比较长，还好我们有TypeScript，我们先看下createRouter的参数。</p><p>在下面的代码中，参数RouterOptions是规范我们配置的路由对象，主要包含history、routes等数据。routes就是我们需要配置的路由对象，类型是RouteRecordRaw组成的数组，并且RouteRecordRaw的类型是三个类型的合并。然后返回值的类型Router就是包含了addRoute、push、beforeEnter、install方法的一个对象，<strong>并且维护了currentRoute和options两个属性</strong>。</p><!-- [[[read_end]]] --><p>并且每个类型方法还有详细的注释，这也极大降低了阅读源码的门槛，可以帮助我们在看到函数的类型时就知道函数大概的功能。我们知道Vue中app.use实际上执行的就是router对象内部的install方法，我们先进入到install方法看下是如何安装的。</p><pre><code class=\"language-javascript\">// createRouter传递参数的类型\nexport interface RouterOptions extends PathParserOptions {\n  history: RouterHistory\n  routes: RouteRecordRaw[]\n  scrollBehavior?: RouterScrollBehavior\n  ...\n}\n// 每个路由配置的类型\nexport type RouteRecordRaw =\n  | RouteRecordSingleView\n  | RouteRecordMultipleViews\n  | RouteRecordRedirect\n\n//... other config\n// Router接口的全部方法和属性\nexport interface Router {\n  readonly currentRoute: Ref&lt;RouteLocationNormalizedLoaded&gt;\n  readonly options: RouterOptions\n\n  addRoute(parentName: RouteRecordName, route: RouteRecordRaw): () =&gt; void\n  addRoute(route: RouteRecordRaw): () =&gt; void\n  Route(name: RouteRecordName): void\n  hasRoute(name: RouteRecordName): boolean\n\n  getRoutes(): RouteRecord[]\n  resolve(\n    to: RouteLocationRaw,\n    currentLocation?: RouteLocationNormalizedLoaded\n  ): RouteLocation &amp; { href: string }\n  push(to: RouteLocationRaw): Promise&lt;NavigationFailure | void | undefined&gt;\n  replace(to: RouteLocationRaw): Promise&lt;NavigationFailure | void | undefined&gt;\n  back(): ReturnType&lt;Router['go']&gt;\n  forward(): ReturnType&lt;Router['go']&gt;\n  go(delta: number): void\n  beforeEach(guard: NavigationGuardWithThis&lt;undefined&gt;): () =&gt; void\n  beforeResolve(guard: NavigationGuardWithThis&lt;undefined&gt;): () =&gt; void\n  afterEach(guard: NavigationHookAfter): () =&gt; void\n  onError(handler: _ErrorHandler): () =&gt; void\n  isReady(): Promise&lt;void&gt;\n  install(app: App): void\n}\n\n\n\n\n\nexport function createRouter(options: RouterOptions): Router {\n\n\n\n}\n</code></pre><h2>路由安装</h2><p>从下面的代码中我们可以看到，在createRouter的最后，创建了包含addRoute、push等方法的对象，并且install方法内部注册了RouterLink和RouterView两个组件。所以我们可以在任何组件内部直接使用&lt;router-view&gt;和&lt;router-link&gt;组件，然后注册全局变量$router和$route，其中$router就是我们通过createRouter返回的路由对象，包含addRoute、push等方法，$route使用defineProperty的形式返回currentRoute的值，可以做到和currentRoute值同步。</p><p>然后使用computed把路由变成响应式对象，存储在reactiveRoute对象中，再通过app.provide给全局注册了route和reactive包裹后的reactiveRoute对象。我们之前介绍provide函数的时候也介绍了，provide提供的数据并没有做响应式的封装，<strong>需要响应式的时候需要自己使用ref或者reactive封装为响应式对象</strong>，最后注册unmount方法实现vue-router的安装。</p><pre><code class=\"language-javascript\">export function createRouter(options: RouterOptions): Router {\n....\n  let started: boolean | undefined\n  const installedApps = new Set&lt;App&gt;()\n  // 路由对象\n  const router: Router = {\n    currentRoute,\n\n    addRoute,\n    removeRoute,\n    hasRoute,\n    getRoutes,\n    resolve,\n    options,\n\n    push,\n    replace,\n    go,\n    back: () =&gt; go(-1),\n    forward: () =&gt; go(1),\n\n    beforeEach: beforeGuards.add,\n    beforeResolve: beforeResolveGuards.add,\n    afterEach: afterGuards.add,\n\n    onError: errorHandlers.add,\n    isReady,\n    // 插件按章\n    install(app: App) {\n      const router = this\n      // 注册全局组件 router-link和router-view\n      app.component('RouterLink', RouterLink)\n      app.component('RouterView', RouterView)\n\n      app.config.globalProperties.$router = router\n      Object.defineProperty(app.config.globalProperties, '$route', {\n        enumerable: true,\n        get: () =&gt; unref(currentRoute),\n      })\n      if (\n        isBrowser &amp;&amp;\n        !started &amp;&amp;\n        currentRoute.value === START_LOCATION_NORMALIZED\n      ) {\n        // see above\n        started = true\n        push(routerHistory.location).catch(err =&gt; {\n          if (__DEV__) warn('Unexpected error when starting the router:', err)\n        })\n      }\n\n      const reactiveRoute = {} as {\n        [k in keyof RouteLocationNormalizedLoaded]: ComputedRef&lt;\n          RouteLocationNormalizedLoaded[k]\n        &gt;\n      }\n      for (const key in START_LOCATION_NORMALIZED) {\n        // @ts-expect-error: the key matches\n        reactiveRoute[key] = computed(() =&gt; currentRoute.value[key])\n      }\n      // 提供全局配置\n      app.provide(routerKey, router)\n      app.provide(routeLocationKey, reactive(reactiveRoute))\n      app.provide(routerViewLocationKey, currentRoute)\n\n      const unmountApp = app.unmount\n      installedApps.add(app)\n      app.unmount = function () {\n        installedApps.delete(app)\n        // ...\n        unmountApp()\n      }\n\n      if ((__DEV__ || __FEATURE_PROD_DEVTOOLS__) &amp;&amp; isBrowser) {\n        addDevtools(app, router, matcher)\n      }\n    },\n  }\n\n  return router\n}\n</code></pre><p>路由对象创建和安装之后，我们<strong>下一步需要了解的就是router-link和router-view两个组件的实现方式</strong>。</p><p>通过下面的代码我们可以看到，RouterView的setup函数返回了一个函数，这个函数就是RouterView组件的render函数。大部分我们使用的方式就是一个&lt;router-view /&gt;组件，没有slot情况下返回的就是component变量。component使用h函数返回ViewComponent的虚拟DOM，而ViewComponent是根据matchedRoute.components[props.name]计算而来。</p><p>matchedRoute依赖的matchedRouteRef的计算逻辑在如下代码的第12～15行，数据来源injectedRoute就是上面我们注入的currentRoute对象。</p><pre><code class=\"language-javascript\">export const RouterViewImpl = /*#__PURE__*/ defineComponent({\n  name: 'RouterView',\n  props: {\n    name: {\n      type: String as PropType&lt;string&gt;,\n      default: 'default',\n    },\n    route: Object as PropType&lt;RouteLocationNormalizedLoaded&gt;,\n  },\n  // router-view组件源码\n  setup(props, { attrs, slots }) {\n    // 全局的reactiveRoute对象注入\n    const injectedRoute = inject(routerViewLocationKey)!\n    \n    const routeToDisplay = computed(() =&gt; props.route || injectedRoute.value)\n    const depth = inject(viewDepthKey, 0)\n    const matchedRouteRef = computed&lt;RouteLocationMatched | undefined&gt;(\n      () =&gt; routeToDisplay.value.matched[depth]\n    )\n    // 嵌套层级\n    provide(viewDepthKey, depth + 1)\n    // 匹配的router对象\n    provide(matchedRouteKey, matchedRouteRef)\n    provide(routerViewLocationKey, routeToDisplay)\n\n    const viewRef = ref&lt;ComponentPublicInstance&gt;()\n    // 返回的render函数\n    return () =&gt; {\n      const route = routeToDisplay.value\n      const matchedRoute = matchedRouteRef.value\n      const ViewComponent = matchedRoute &amp;&amp; matchedRoute.components[props.name]\n      const currentName = props.name\n\n      if (!ViewComponent) {\n        return normalizeSlot(slots.default, { Component: ViewComponent, route })\n      }\n\n      // props from route configuration\n      const routePropsOption = matchedRoute!.props[props.name]\n      const routeProps = routePropsOption\n        ? routePropsOption === true\n          ? route.params\n          : typeof routePropsOption === 'function'\n          ? routePropsOption(route)\n          : routePropsOption\n        : null\n\n      const onVnodeUnmounted: VNodeProps['onVnodeUnmounted'] = vnode =&gt; {\n        // remove the instance reference to prevent leak\n        if (vnode.component!.isUnmounted) {\n          matchedRoute!.instances[currentName] = null\n        }\n      }\n      // 创建需要渲染组件的虚拟dom\n      const component = h(\n        ViewComponent,\n        assign({}, routeProps, attrs, {\n          onVnodeUnmounted,\n          ref: viewRef,\n        })\n      )\n  \n      return (\n        // pass the vnode to the slot as a prop.\n        // h and &lt;component :is=\"...\"&gt; both accept vnodes\n        normalizeSlot(slots.default, { Component: component, route }) ||\n        component\n      )\n    }\n  },\n})\n</code></pre><h2>路由更新</h2><p>到这我们可以看出，RouterView渲染的组件是由当前匹配的路由变量matchedRoute决定的。接下来我们回到createRouter函数中，可以看到matcher对象是由createRouterMatcher创建，createRouterMatcher函数传入routes配置的路由数组，并且返回创建的RouterMatcher对象，内部遍历routes数组，通过addRoute挨个处理路由配置。</p><pre><code class=\"language-javascript\">export function createRouter(options: RouterOptions): Router {\n  const matcher = createRouterMatcher(options.routes, options)\n  ///....\n}\nexport function createRouterMatcher(\n  routes: RouteRecordRaw[],\n  globalOptions: PathParserOptions\n): RouterMatcher {\n  // matchers数组\n  const matchers: RouteRecordMatcher[] = []\n  // matcher对象\n  const matcherMap = new Map&lt;RouteRecordName, RouteRecordMatcher&gt;()\n  globalOptions = mergeOptions(\n    { strict: false, end: true, sensitive: false } as PathParserOptions,\n    globalOptions\n  )\n  function addRoute(){}\n  function remoteRoute(){}\n  function getRoutes(){\n    return matchers\n  }  \n  function insertMatcher(){}\n  function resolve(){}\n  // add initial routes\n  routes.forEach(route =&gt; addRoute(route))\n\n  return { addRoute, resolve, removeRoute, getRoutes, getRecordMatcher }\n}\n</code></pre><p>在下面的代码中我们可以看到，addRoute函数内部通过createRouteRecordMatcher创建扩展之后的matcher对象，包括了record、parent、children等树形，可以很好地描述路由之间的嵌套父子关系。这样整个路由对象就已经创建完毕，那我们如何在路由切换的时候寻找到正确的路由对象呢？</p><pre><code class=\"language-javascript\">function addRoute(    \n  record: RouteRecordRaw,\n  parent?: RouteRecordMatcher,\n  originalRecord?: RouteRecordMatcher\n){\n  if ('alias' in record) {\n    // 标准化alias\n  }\n  for (const normalizedRecord of normalizedRecords) {\n    // ...\n    matcher = createRouteRecordMatcher(normalizedRecord, parent, options)\n    insertMatcher(matcher)\n      \n  }\n  return originalMatcher\n    ? () =&gt; {\n        // since other matchers are aliases, they should be removed by the original matcher\n        removeRoute(originalMatcher!)\n      }\n    : noop\n\n}\n\nexport function createRouteRecordMatcher(\n  record: Readonly&lt;RouteRecord&gt;,\n  parent: RouteRecordMatcher | undefined,\n  options?: PathParserOptions\n): RouteRecordMatcher {\n  const parser = tokensToParser(tokenizePath(record.path), options)\n  const matcher: RouteRecordMatcher = assign(parser, {\n    record,\n    parent,\n    // these needs to be populated by the parent\n    children: [],\n    alias: [],\n  })\n\n  if (parent) {\n    if (!matcher.record.aliasOf === !parent.record.aliasOf)\n      parent.children.push(matcher)\n  }\n\n  return matcher\n}\n\n</code></pre><p>在vue-router中，路由更新可以通过router-link渲染的链接实现，也可以使用router对象的push等方法实现。下面的代码中，router-link组件内部也是渲染一个a标签，并且注册了a标签的onClick函数，内部也是通过router.replace或者router.push来实现。</p><pre><code class=\"language-javascript\">\nexport const RouterLinkImpl = /*#__PURE__*/ defineComponent({\n  name: 'RouterLink',\n  props: {\n    to: {\n      type: [String, Object] as PropType&lt;RouteLocationRaw&gt;,\n      required: true,\n    },\n      ...\n  },\n  // router-link源码\n  setup(props, { slots }) {\n    const link = reactive(useLink(props))\n    const { options } = inject(routerKey)!\n\n    const elClass = computed(() =&gt; ({\n      ...\n    }))\n\n    return () =&gt; {\n      const children = slots.default &amp;&amp; slots.default(link)\n      return props.custom\n        ? children\n        : h(\n            'a',\n            {\n              href: link.href,\n              onClick: link.navigate,\n              class: elClass.value,\n            },\n            children\n          )\n    }\n  },\n})\n//  跳转\n  function navigate(\n    e: MouseEvent = {} as MouseEvent\n  ): Promise&lt;void | NavigationFailure&gt; {\n    if (guardEvent(e)) {\n      return router[unref(props.replace) ? 'replace' : 'push'](\n        unref(props.to)\n        // avoid uncaught errors are they are logged anyway\n      ).catch(noop)\n    }\n    return Promise.resolve()\n  }\n\n</code></pre><p>现在我们回到createRouter函数中，可以看到push函数直接调用了pushWithRedirect函数来实现，内部通过resolve(to)生成targetLocation变量。这个变量会赋值给toLocation，然后执行navigate(toLocation)函数。而<strong>这个函数内部会执行一系列的导航守卫函数</strong>，最后会执行finalizeNavigation函数完成导航。</p><pre><code class=\"language-javascript\">function push(to: RouteLocationRaw | RouteLocation) {\n  return pushWithRedirect(to)\n}\n\nfunction replace(to: RouteLocationRaw | RouteLocationNormalized) {\n  return push(assign(locationAsObject(to), { replace: true }))\n}\n// 路由跳转函数\nfunction pushWithRedirect(\n  to: RouteLocationRaw | RouteLocation,\n  redirectedFrom?: RouteLocation\n): Promise&lt;NavigationFailure | void | undefined&gt; {\n  const targetLocation: RouteLocation = (pendingLocation = resolve(to))\n  const from = currentRoute.value\n  const data: HistoryState | undefined = (to as RouteLocationOptions).state\n  const force: boolean | undefined = (to as RouteLocationOptions).force\n  // to could be a string where `replace` is a function\n  const replace = (to as RouteLocationOptions).replace === true\n\n\n\n  const toLocation = targetLocation as RouteLocationNormalized\n\n  \n  return (failure ? Promise.resolve(failure) : navigate(toLocation, from))\n    .catch((error: NavigationFailure | NavigationRedirectError) =&gt;\n      isNavigationFailure(error)\n        ? error\n        : // reject any unknown error\n          triggerError(error, toLocation, from)\n    )\n    .then((failure: NavigationFailure | NavigationRedirectError | void) =&gt; {\n\n        failure = finalizeNavigation(\n          toLocation as RouteLocationNormalizedLoaded,\n          from,\n          true,\n          replace,\n          data\n        )\n\n      triggerAfterEach(\n        toLocation as RouteLocationNormalizedLoaded,\n        from,\n        failure\n      )\n      return failure\n    })\n}\n</code></pre><p>在下面的代码中我们可以看到，finalizeNavigation函数内部通过routerHistory.push或者replace实现路由跳转，并且更新currentRoute.value。</p><p>currentRoute就是我们在install方法中注册的全局变量$route，每次页面跳转currentRoute都会更新为toLocation，在任意组件中都可以通过$route变量来获取当前路由的数据，<strong>最后在handleScroll设置滚动行为</strong>。</p><p>routerHistory在createRouter中通过option.history获取，就是我们创建vue-router应用时通过createWebHistory或者createWebHashHistory创建的对象。createWebHistory返回的是HTML5的history模式路由对象，createWebHashHistory是Hash模式的路由对象。</p><pre><code class=\"language-javascript\">  function finalizeNavigation(\n    toLocation: RouteLocationNormalizedLoaded,\n    from: RouteLocationNormalizedLoaded,\n    isPush: boolean,\n    replace?: boolean,\n    data?: HistoryState\n  ): NavigationFailure | void {\n\n\n\n    const isFirstNavigation = from === START_LOCATION_NORMALIZED\n    const state = !isBrowser ? {} : history.state\n\n    if (isPush) {\n\n      if (replace || isFirstNavigation)\n        routerHistory.replace(\n          toLocation.fullPath\n        )\n      else routerHistory.push(toLocation.fullPath, data)\n    }\n\n    // accept current navigation\n    currentRoute.value = toLocation\n    handleScroll(toLocation, from, isPush, isFirstNavigation)\n\n    markAsReady()\n  }\n  \n  function markAsReady(err?: any): void {\n    if (ready) return\n    ready = true\n    setupListeners()\n    readyHandlers\n      .list()\n      .forEach(([resolve, reject]) =&gt; (err ? reject(err) : resolve()))\n    readyHandlers.reset()\n  }\n</code></pre><p>下面的代码中我们可以看到，createWebHashHistory和createWebHistory的实现，内部都是通过useHistoryListeners实现路由的监听，通过useHistoryStateNavigation实现路由的切换。useHistoryStateNavigation会返回push或者replace方法来更新路由，这两个函数你可以在<a href=\"https://github.com/vuejs/vue-router-next/blob/master/src/history/html5.ts#L57\">GitHub</a>上自行学习。</p><pre><code class=\"language-javascript\">export function createWebHashHistory(base?: string): RouterHistory {\n  base = location.host ? base || location.pathname + location.search : ''\n  // allow the user to provide a `#` in the middle: `/base/#/app`\n  if (!base.includes('#')) base += '#'\n  return createWebHistory(base)\n}\n\n\n\nexport function createWebHistory(base?: string): RouterHistory {\n  base = normalizeBase(base)\n\n  const historyNavigation = useHistoryStateNavigation(base)\n  const historyListeners = useHistoryListeners(\n    base,\n    historyNavigation.state,\n    historyNavigation.location,\n    historyNavigation.replace\n  )\n  function go(delta: number, triggerListeners = true) {\n    if (!triggerListeners) historyListeners.pauseListeners()\n    history.go(delta)\n  }\n\n  const routerHistory: RouterHistory = assign(\n    {\n      // it's overridden right after\n      location: '',\n      base,\n      go,\n      createHref: createHref.bind(null, base),\n    },\n\n    historyNavigation,\n    historyListeners\n  )\n\n  Object.defineProperty(routerHistory, 'location', {\n    enumerable: true,\n    get: () =&gt; historyNavigation.location.value,\n  })\n\n  Object.defineProperty(routerHistory, 'state', {\n    enumerable: true,\n    get: () =&gt; historyNavigation.state.value,\n  })\n\n  return routerHistory\n}\n\n</code></pre><h2>总结</h2><p>以上就是今天的主要内容，我们来总结一下。</p><p>这节课我们进入到vue-router的源码中分析了vue-router内部的执行逻辑，其实我们之前课上已经实现了迷你的vue-router，在掌握了前端路由实现的原理后，再来看实际的vue-router源码难度会下降不少。</p><p>首先我们分析了createRouter函数入口函数，createRouter函数返回了router对象，router对象提供了addRoute、push等方法，并且在install方法中实现了路由，注册了组件router-link和router-view。</p><p>然后通过createRouterMatcher创建路由匹配对象，并且在路由变化的时候维护currentRoute，让你可以在每个组件内部$router和$route获取路由匹配的数据，并且动态渲染当前路由匹配的组件到router-view组件内部，实现了前端的路由系统。</p><p>这一讲我们也能感受到，一个玩具的router和实际的vue-router的距离，也能体会到TypeScript在我们阅读代码时的好处。我们阅读源码的目的之一，就是要学习和模仿优秀框架内部的设计思路，然后去优化自己项目中的代码，学会模仿也是一个优秀程序员的优秀品质。</p><h2>思考</h2><p>最后留给你一个思考题，navigate函数负责执行路由守卫的功能，你知道它的内部是如何实现的吗？</p><p>欢迎在评论区分享你的答案，我们下一讲再见！</p>",
        article_title: "37｜前端路由原理：vue-router源码剖析",
      },
      {
        title: "38｜服务端渲染原理：Vue 3中的SSR是如何实现的？",
        id: 476719,
        content:
          '<p>你好，我是大圣，上一讲我们学完vue-router源码，Vue全家桶的生态就基本介绍完了，包括Vue的响应式、运行时、编译器，以及全家桶的vuex和vue-router。</p><p>今天我来给你介绍Vue中优化的一个进阶知识点：SSR（Server Side Rendering），也就是服务端渲染。</p><h2>SSR是什么</h2><p>要想搞清楚SSR是什么？我们需要先理解这个方案是为解决什么问题而产生的。</p><p>在现在MVVM盛行的时代，无论是Vue还是React的全家桶，都有路由框架的身影，所以，页面的渲染流程也全部都是浏览器加载完JavaScript文件后，由JavaScript获取当前的路由地址，再决定渲染哪个页面。</p><p>这种架构下，<strong>所有的路由和页面都是在客户端进行解析和渲染的，我们称之为Client Side Rendering，简写为CSR，也就是客户端渲染</strong>。</p><p>交互体验确实提升了，但同时也带来了两个小问题。</p><p>首先，如果采用CSR，我们在ailemente项目中执行<code>npm run build</code>命令后，可以在项目根目录下看到多了一个dist文件夹，打开其中的index.html文件，看到下面的代码：</p><pre><code class="language-xml">&lt;!DOCTYPE html&gt;\n&lt;html lang="en"&gt;\n  &lt;head&gt;\n    &lt;meta charset="UTF-8" /&gt;\n    &lt;link rel="icon" href="/favicon.ico" /&gt;\n    &lt;meta name="viewport" content="width=device-width, initial-scale=1.0" /&gt;\n    &lt;title&gt;Vite App&lt;/title&gt;\n    &lt;script type="module" crossorigin src="/assets/index.c305634d.js"&gt;&lt;/script&gt;\n    &lt;link rel="modulepreload" href="/assets/vendor.9419ee42.js"&gt;\n    &lt;link rel="stylesheet" href="/assets/index.1826a359.css"&gt;\n  &lt;/head&gt;\n  &lt;body&gt;\n    &lt;div id="app"&gt;&lt;/div&gt;\n    \n  &lt;/body&gt;\n&lt;/html&gt;\n\n</code></pre><!-- [[[read_end]]] --><p>这就是项目部署上线之后的入口文件，body内部就是一个空的div标签，用户访问这个页面后，页面的首屏需要等待JavaScript加载和执行完毕才能看到，这样白屏时间肯定比body内部写页面标签的要长一些，尤其在客户端网络环境差的情况下，等待JavaScript下载和执行的白屏时间是很伤害用户体验的。</p><p>其次，搜索引擎的爬虫抓取到你的页面数据后，发现body是空的，也会认为你这个页面是空的，这对于SEO是很不利的。即使现在基于Google的搜索引擎爬虫已经能够支持JavaScript的执行，但是爬虫不会等待页面的网络数据请求，何况国内主要的搜索引擎还是百度。</p><p>所以如果你的项目对白屏时间和搜索引擎有要求，<strong>我们就需要在用户访问页面的时候，能够把首屏渲染的HTML内容写入到body内部，也就是说我们需要在服务器端实现组件的渲染</strong>，这就是SSR的用武之地。</p><h2>怎么做SSR</h2><p>那怎么在服务器端实现组件渲染呢？Vue提供了@vue/server-renderer这个专门做服务端解析的库，我们来尝试使用一下。</p><p>首先创建一个新的文件夹vue-ssr，执行下面命令来安装server-renderer、vue和express：</p><pre><code class="language-xml">npm init -y \nnpm install @vue/server-renderer vue@next express --save\n</code></pre><p>然后新建server.js，核心就是要实现在服务器端解析Vue的组件，直接把渲染结果返回给浏览器。</p><p>下面的代码中我们使用express启动了一个服务器，监听9093端口，在用户访问首页的时候，通过createSSRApp创建一个Vue的实例，并且通过@vue/compiler-ssr对模板的template进行编译，返回的函数配置在vueapp的ssrRender属性上，最后通过@vue/server-renderer的renderToString方法渲染Vue的实例，把renderToString返回的字符串通过res.send返回给客户端。</p><pre><code class="language-javascript">// 引入express\nconst express = require(\'express\') \nconst app = express()\nconst Vue = require(\'vue\') // vue@next\nconst renderer3 = require(\'@vue/server-renderer\')\nconst vue3Compile= require(\'@vue/compiler-ssr\')\n\n// 一个vue的组件\nconst vueapp = {\n  template: `&lt;div&gt;\n    &lt;h1 @click="add"&gt;{{num}}&lt;/h1&gt;\n    &lt;ul &gt;\n      &lt;li v-for="(todo,n) in todos" &gt;{{n+1}}--{{todo}}&lt;/li&gt;\n    &lt;/ul&gt;\n  &lt;/div&gt;`,\n  data(){\n    return {\n      num:1,\n      todos:[\'吃饭\',\'睡觉\',\'学习Vue\']\n    }\n  },\n  methods:{\n    add(){\n      this.num++\n    }\n  } \n}\n// 使用@vue/compiler-ssr解析template\nvueapp.ssrRender = new Function(\'require\',vue3Compile.compile(vueapp.template).code)(require)\n// 路由首页返回结果\napp.get(\'/\',async function(req,res){\n    let vapp = Vue.createSSRApp(vueapp)\n    let html = await renderer3.renderToString(vapp)\n    const title = "Vue SSR"\n    let ret = `\n&lt;!DOCTYPE html&gt;\n&lt;html lang="en"&gt;\n  &lt;head&gt;\n    &lt;meta charset="UTF-8" /&gt;\n    &lt;link rel="icon" href="/favicon.ico" /&gt;\n    &lt;meta name="viewport" content="width=device-width, initial-scale=1.0" /&gt;\n    &lt;title&gt;${title}&lt;/title&gt;\n  &lt;/head&gt;\n  &lt;body&gt;\n    &lt;div id="app"&gt;\n      ${html}\n    &lt;/div&gt;\n  &lt;/body&gt;\n&lt;/html&gt;`    \n    res.send(ret)\n})\n\napp.listen(9093,()=&gt;{\n    console.log(\'listen 9093\')\n}) \n</code></pre><p>现在我们访问页面后，点击右键查看网页源代码，会出现下图所示的页面：<br>\n<img src="https://static001.geekbang.org/resource/image/7a/d2/7a345e1b518259e0b2fd7bb0d6c7f6d2.png?wh=1920x582" alt="图片"></p><p>可以看到，首屏的body标签内部就出现了vue组件中v-for渲染后的标签结果，我们的第一步就完成了。</p><p>但具体SSR是怎么实现的呢？我们一起来看源码。</p><h2>Vue SSR源码剖析</h2><p>在CSR环境下，template解析的render函数用来返回组件的虚拟DOM，而SSR环境下template解析的ssrRender函数，函数内部是通过_push对字符串进行拼接，最终生成组件渲染的结果的。你可以在官方的<a href="https://vue-next-template-explorer.netlify.app/#%7B%22src%22%3A%22%3Cdiv%3E%5Cn%20%20%20%20%3Cul%20%3E%5Cn%20%20%20%20%20%20%3Cli%20v-for%3D%5C%22(todo%2Cn)%20in%20todos%5C%22%20%3E%7B%7Bn%2B1%7D%7D--%7B%7Btodo%7D%7D%3C%2Fli%3E%5Cn%20%20%20%20%3C%2Ful%3E%5Cn%20%20%3C%2Fdiv%3E%22%2C%22ssr%22%3Atrue%2C%22options%22%3A%7B%22mode%22%3A%22function%22%2C%22filename%22%3A%22Foo.vue%22%2C%22prefixIdentifiers%22%3Afalse%2C%22hoistStatic%22%3Atrue%2C%22cacheHandlers%22%3Atrue%2C%22scopeId%22%3Anull%2C%22inline%22%3Afalse%2C%22ssrCssVars%22%3A%22%7B%20color%20%7D%22%2C%22compatConfig%22%3A%7B%22MODE%22%3A3%7D%2C%22whitespace%22%3A%22condense%22%2C%22bindingMetadata%22%3A%7B%22TestComponent%22%3A%22setup-const%22%2C%22setupRef%22%3A%22setup-ref%22%2C%22setupConst%22%3A%22setup-const%22%2C%22setupLet%22%3A%22setup-let%22%2C%22setupMaybeRef%22%3A%22setup-maybe-ref%22%2C%22setupProp%22%3A%22props%22%2C%22vMySetupDir%22%3A%22setup-const%22%7D%2C%22optimizeBindings%22%3Afalse%7D%7D">模板渲染演示页面</a>选择ssr设置后，看到渲染的结果：</p><pre><code class="language-javascript">const { mergeProps: _mergeProps } = require("vue")\nconst { ssrRenderAttrs: _ssrRenderAttrs, ssrInterpolate: _ssrInterpolate, ssrRenderList: _ssrRenderList } = require("vue/server-renderer")\n\nreturn function ssrRender(_ctx, _push, _parent, _attrs, $props, $setup, $data, $options) {\n  const _cssVars = { style: { color: _ctx.color }}\n  _push(`&lt;div${_ssrRenderAttrs(_mergeProps(_attrs, _cssVars))}&gt;&lt;ul&gt;&lt;!--[--&gt;`)\n  _ssrRenderList(_ctx.todos, (todo, n) =&gt; {\n    _push(`&lt;li&gt;${\n      _ssrInterpolate(n+1)\n    }--${\n      _ssrInterpolate(todo)\n    }&lt;/li&gt;`)\n  })\n  _push(`&lt;!--]--&gt;&lt;/ul&gt;&lt;/div&gt;`)\n}\n</code></pre><p>可以看到ssrRender函数内部通过传递的_push函数拼接组件渲染的结果后，直接返回renderToString函数的执行结果。</p><p>那renderToString是如何工作的呢？</p><p>现在你已经拥有了源码阅读的技巧，我们进入到vue-next/packages/server-renderer文件中，打开<strong>renderToString文件</strong>：</p><pre><code class="language-javascript">export async function renderToString(\n  input: App | VNode,\n  context: SSRContext = {}\n): Promise&lt;string&gt; {\n  if (isVNode(input)) {\n    // raw vnode, wrap with app (for context)\n    return renderToString(createApp({ render: () =&gt; input }), context)\n  }\n  const vnode = createVNode(input._component, input._props)\n  vnode.appContext = input._context\n  // provide the ssr context to the tree\n  input.provide(ssrContextKey, context)\n  const buffer = await renderComponentVNode(vnode)\n\n  await resolveTeleports(context)\n\n  return unrollBuffer(buffer as SSRBuffer)\n}\n</code></pre><p>这段代码可以看到，我们通过renderComponentVNode函数对创建的Vnode进行渲染，生成一个buffer变量，最后通过unrollBuffer返回字符串。</p><p>我们先继续看<strong>renderComponentVNode函数</strong>，它内部通过renderComponentSubTree进行虚拟DOM的子树渲染，而renderComponentSubTree内部调用组件内部的ssrRender函数，这个函数就是我们代码中通过@vue/compiler-ssr解析之后的ssrRender函数，传递的push参数是通过createBuffer传递的：</p><pre><code class="language-javascript">export function renderComponentVNode(\n  vnode: VNode,\n  parentComponent: ComponentInternalInstance | null = null,\n  slotScopeId?: string\n): SSRBuffer | Promise&lt;SSRBuffer&gt; {\n  const instance = createComponentInstance(vnode, parentComponent, null)\n  const res = setupComponent(instance, true /* isSSR */)\n  if (hasAsyncSetup || prefetches) {\n    ....\n    return p.then(() =&gt; renderComponentSubTree(instance, slotScopeId))\n  } else {\n    return renderComponentSubTree(instance, slotScopeId)\n  }\n}\nfunction renderComponentSubTree(instance,slotScopeId){\n  const { getBuffer, push } = createBuffer()\n  const ssrRender = instance.ssrRender || comp.ssrRender\n  if (ssrRender) {\n      ssrRender(\n        instance.proxy,\n        push,\n        instance,\n        attrs,\n        // compiler-optimized bindings\n        instance.props,\n        instance.setupState,\n        instance.data,\n        instance.ctx\n      )\n  }\n}\n</code></pre><p><strong>createBuffer的实现</strong>也很简单，buffer是一个数组，push函数就是不停地在数组最后新增数据，如果item是字符串，就在数组最后一个数据上直接拼接字符串，否则就在数组尾部新增一个元素，这种提前合并字符串的做法，也算是一个小优化。</p><pre><code class="language-javascript">export function createBuffer() {\n  let appendable = false\n  const buffer: SSRBuffer = []\n  return {\n    getBuffer(): SSRBuffer {\n      // Return static buffer and await on items during unroll stage\n      return buffer\n    },\n    push(item: SSRBufferItem) {\n      const isStringItem = isString(item)\n      if (appendable &amp;&amp; isStringItem) {\n        buffer[buffer.length - 1] += item as string\n      } else {\n        buffer.push(item)\n      }\n      appendable = isStringItem\n      if (isPromise(item) || (isArray(item) &amp;&amp; item.hasAsync)) {\n        // promise, or child buffer with async, mark as async.\n        // this allows skipping unnecessary await ticks during unroll stage\n        buffer.hasAsync = true\n      }\n    }\n  }\n}\n</code></pre><p>最后我们看下返回字符串的<strong>unrollBuffer函数</strong>，由于buffer数组中可能会有异步的组件，服务器返回渲染内容之前，我们要把组件依赖的异步任务使用await，等待执行完毕后，进行字符串的拼接，最后返回给浏览器。</p><pre><code class="language-javascript">async function unrollBuffer(buffer: SSRBuffer): Promise&lt;string&gt; {\n  if (buffer.hasAsync) {\n    let ret = \'\'\n    for (let i = 0; i &lt; buffer.length; i++) {\n      let item = buffer[i]\n      if (isPromise(item)) {\n        item = await item\n      }\n      if (isString(item)) {\n        ret += item\n      } else {\n        ret += await unrollBuffer(item)\n      }\n    }\n    return ret\n  } else {\n    // sync buffer can be more efficiently unrolled without unnecessary await\n    // ticks\n    return unrollBufferSync(buffer)\n  }\n}\n</code></pre><p>至此我们就把Vue中SSR的渲染流程梳理完毕了，通过compiler-ssr模块把template解析成ssrRender函数后，整个组件通过renderToString把组件渲染成字符串返回给浏览器。</p><p>SSR最终实现了通过服务器端解析Vue组件的方式，提高首屏的响应时间和页面的SEO友好度。</p><h2>同构应用和其他渲染方式</h2><p>现在服务器渲染SSR的逻辑我们已经掌握了，但是现在页面中没有JavaScript的加入，我们既需要提供服务器渲染的首屏内容，又需要CSR带来的优秀交互体验，这个时候我们就需要使用同构的方式来构建Vue的应用。</p><p>什么是同构应用呢？看来自于Vue官网的同构应用的经典架构图：</p><p><img src="https://static001.geekbang.org/resource/image/13/6b/13ba7725eb1e2aaf07920ae5cbb9d26b.png?wh=1920x880" alt="图片"></p><p>左边是我们的源码，无论项目有多么复杂，都可以拆分为component + store + router三大模块。这一部分的源码，设置了两个入口，分别是客户端入口 client entry 和服务器端入口 server entry。打包的过程中也有两个打包的配置文件，分别客户端的配置和服务器端的配置。</p><p>最终在服务端实现用户首次访问页面的时候通过服务器端入口进入，显示服务器渲染的结果，然后用户在后续的操作中由客户端接管，通过vue-router来提高页面跳转的交互体验，这就是<strong>同构应用</strong>的概念。</p><h3>SSR+同构的问题</h3><p>当然，没有任何一个技术架构是完美的，SSR和同构带来了很好的首屏速度和SEO友好度，但是也让我们的项目多了一个Node服务器模块。</p><p>首先，我们部署的难度会提高。之前的静态资源直接上传到服务器的Nginx目录下，做好版本管理即可，现在还需要在服务器上部署一个Node环境，额外带来了部署和监控的成本，工作量提升了。</p><p>其次，SSR和同构的架构，实际上，是把客户端渲染组件的计算逻辑移到了服务器端执行，在并发量大的场景中，会加大服务器的负载。所以，所有的同构应用下还需要有降级渲染的逻辑，在服务器负载过高或者服务器有异常报错的情况下，让页面恢复为客户端渲染。</p><p>总的来说，同构解决问题的同时，也带来了额外的系统复杂度。<strong>每个技术架构的出现都是为了解决一些特定的问题，但是它们的出现也必然会带来新的问题</strong>。</p><p>针对同构出现的问题目前也有一些解决方案来应对。</p><h3>解决方案</h3><p>针对SSR架构的问题，我们也可以使用<strong>静态网站生成（Static Site Generation，SSG）</strong>的方式来解决，针对页面中变动频率不高的页面，直接渲染成静态页面来展示。</p><p>比如极客时间的首页变化频率比较高，每次我们都需要对每个课程的销量和评分进行排序，这部分的每次访问都需要从后端读取数据；但是每个课程内部的页面，比如文章详情页，变化频率其实是很低的，虽然课程的文本是存储在数据库里，但是每次上线前，我们可以把课程详情页生成静态的HTML页面再上线。</p><p>Vue的SSR框架nuxt就提供了很好的SSG功能，由于这一部分页面变化频率低，我们静态化之后还可以通过部署到CDN来进行页面加速，每次新文章发布或者修改的时候，重新生成一遍即可。</p><p>当然SSG也不是完全没有问题，比如极客时间如果有一万门课了，每门课几十篇文章，每次部署都全量静态生成一遍，耗时是非常惊人的，所以也不断有新的解决方案出现。</p><p>如果你的页面是内嵌在客户端内部的，可以借助客户端的运算能力，把SSR的逻辑移动到客户端进行，使用<strong>客户端渲染（Native Side Rendering，NSR）</strong>的方式降低服务端的负载，同时也能提高首屏的响应时间。</p><p>针对SSG全量生成的性能问题，我们可以采用<strong>增量渲染（Incremental Site&nbsp;Rendering，ISR）</strong>的方式，每次只生成核心重点的页面，比如每个课程的开篇词，其他的页面访问的时候先通过CSR的方式渲染，然后把渲染结果存储在CDN中。</p><p>现在还有解决方案<strong>边缘渲染（Edge Side Rendering，ESR）</strong>，把静态内容和动态的内容都以流的方式返回给用户，在CDN节点上返回给用户缓存静态资源，同时在CDN上负责发起动态内容的请求。</p><p>今年还出现了在浏览器里跑node的<a href="https://blog.stackblitz.com/posts/introducing-webcontainers">webcontainer</a>技术，如果这个技术成熟后，我们甚至可以把Express、Egg.js等后端应用也部署到CDN节点上，在浏览器端实现服务器应用的ESR，一起期待webcontainer技术的发展。</p><h2>总结</h2><p>我们要聊的内容就讲完了，来回顾一下。</p><p>今天我们学习了Vue中服务器渲染的原理，Vue通过@vue/compiler-ssr库把template解析成ssrRender函数，并且用@vue/server-renderer库提供了在服务器端渲染组件的能力，让用户访问首屏页面的时候，能够有更快的首屏渲染结果，并且对SEO也是友好的，server-renderer通过提供renderToString函数，内部通过管理buffer数组实现组件的渲染。</p><p>然后我们学习了SSR之后的同构、静态网站生成SSG、增量渲染ISR和边缘渲染ESR等内容，Vue中的最成熟的SSR框架就是nuxt了，最新的nuxt3还没有正式发版，内部对于SSG和ESR都支持，等nuxt3发版后你可以自行学习。</p><p>每一个技术选型都是为了解决问题存在的，无论学习什么技术，我们都不要单纯地把它当做八股文，这样才能真正掌握好一个技术。</p><h2>思考题</h2><p>最后留个思考题，你现在负责的项目，是出于什么目的考虑使用SSR的呢？欢迎在评论区分享你的思考，我们下一讲再见。</p>',
        article_title: "38｜服务端渲染原理：Vue 3中的SSR是如何实现的？",
      },
    ],
  },
  {
    chapterTitle: "结束语",
    children: [
      {
        title: "结束语｜Vue 3生态源码到底给我们带来了什么？",
        id: 476730,
        content:
          '<p>你好，我是大圣。</p><p>这是课程的最后一讲了，感谢你一路相伴。技术之路还很长，Vue 3专栏的结束，也是你另外一个新起点的开始。今天我们就不讲知识点了，来聊一聊作为前端工程师的你我，面对前端新技术不断涌现旧技术飞速过期的现状，该如何修炼才能走得更远、走得更稳。</p><h2>构建你自己的知识体系</h2><p>Vue 3这个专栏从入门到Vue实战，从组件化到Vue生态源码都有涉及，设计之初就是想通过学习Vue这个框架，让你能逐步进阶前端开发，不止是掌握具体的知识点，更希望能帮助你深入了解前端框架的设计原理、内部用到的算法和设计模式，帮你构建出一个完整的前端知识体系。</p><p>我真正想传达的理念是，<strong>任何框架，我们都可以通过深入底层，在理解框架底层用到的计算机世界最佳实践的基础上，去构建自己的知识体系</strong>。如果只是浮于表层，只是追求框架的使用层面，是无法构建自己核心竞争力的。</p><p>如果说编程是一个武侠世界的话，框架和最佳实践是武功和招式，算法和数据结构、设计模式和网络协议等底层知识就是内力，如果我们只沉迷于武功和招式，注定很难成为高手，真正的高手需要不断地修炼内力和不断地实战。</p><p>因为每个前端框架最终都会过时，未来的某一天Vue也一定会过时，那个时候所有的语法都会成为过去，但是我们深入底层研究的Vue内蕴含的组件化、响应式等理念，源码中的算法、数据结构等思想，会内化成我们编程的内力，在未来继续支撑我们在前端这条编程的路上走得更远。</p><!-- [[[read_end]]] --><p>深入底层构建知识体系是我们学习任何框架的方向，那面对一个新框架，我们怎么尽可能地快速掌握呢？</p><p>毕竟现在新框架层出不穷，从最早的HTML、CSS、JavaScript三兄弟构建网页，2009年Angular1和Node.js的诞生让前端框架正式起舞，然后前端的复杂度越来越高。</p><p>你只需要记住一点就能以不变应万变：所有框架，都是为了提供更快更好的开发者体验和用户体验。</p><p>我们要在脑子里存着一个前端知识体系的全景图。有任何新技术出现的时候，不盲目地追热点，要先看新技术的特点和解决的问题，把新出现的这个框架和图里的某个框架联系起来，结合你自己的全景图，把你学到的前端知识从独立的知识点变成相互有联系的网状结构，这也是很多高手学习速度非常快的一个原因。</p><p><img src="https://static001.geekbang.org/resource/image/c0/9f/c0dec6954byy36cfdd1c296f4327aa9f.jpeg?wh=3411x2416" alt=""></p><p>这里是我画的一个前端框架的全景图分享给你。当然就我自己来说，还有一些其他的实用学习方法，今天也分享给你。</p><h2>一些方法</h2><p>如果你是新手，可能会出现迷茫、不知道怎么更快速地提升自己的问题。</p><p>我刚开始也很迷茫。2011年的时候，毕业进入到北京南六环的一个仓库里实习做物流，仓库里的工作让人找不到方向，但是那时的我除了一腔热血，啥都不会。</p><p>于是每周末，我都坐很久的地铁去中关村一个叫车库咖啡的咖啡厅，那里都是创业的人，15块钱一杯咖啡可以听他们吹一天，当时墙上还有一个招聘黑板，上面全是找PHP程序员的。那会我感觉编程是个好东西，这么多人都需要，得学起来，于是每天下班后就在线学编程，后来开启了个人生涯的新方向。这段经历让我明白，<strong>当自己开始迷茫的时候，一定要多出去看看这个社会在发生什么变化，多和别人交流一下，就会找到新的方向。</strong></p><p>然后我找了一个小公司做程序员，小公司的技术栈什么都有，写了几个月PHP和Python后，我开始专注写前端，工资虽然很低，但是我的运气比较好，当时的老大要求我每个月必须要看一本技术书然后给他讲，《JavaScript权威指南》、《锋利的jQuery》、《Sea.js源码》都是那个时候被迫看的。不过至今我依然保持着这个习惯，这应该也是我从0基础到进百度只花了一年半的主要原因。</p><p>所以如果你现在苦于进不了大厂，先从<strong>一个月看一本书</strong>开始吧。不过记得，在看完书之后最好你能够用自己的方式去转述一下学习的心得，可以写博客、可以B站录视频等等。通过输出来检验学习成果，是费曼学习法的精髓所在。</p><p>由于入行遇见的经理就给我指明了正确的学习方向，在后面的职业生涯中，我也一直会在社区里给自己找一个职场的大牛作为导师。毕竟现在勤奋是我们所有人都具备的属性，<strong>但有时候高手给自己指一个方向，比我们自己摸索几个月效率还要高</strong>。</p><p>大牛会告诉你效率最高的学习方法，放弃该放弃的技术方向，你只需要脸皮够厚加到他的微信，没事吃个羊腿泡个澡，就可以获得定制化的建议。这也是我技术生涯少走弯路的秘诀。</p><h2>2022学习路线</h2><p>现在我成为了一个自由职业者，致力于培养更多的前端迈过进阶的门槛，最后我也推荐几个2022年的学习路线供你参考：</p><ul>\n<li>TypeScript的重要性会在2022年进一步体现，如果你现在对TypeScript还不熟悉的话，现在就要努力学习啦；</li>\n<li>熟练掌握Vue后，可以在React、Angular、Svelte和Solid.js中选一个也去学一下，主要学习这些框架和Vue框架的易同，使用对比的方式学习，会让你拥有更高的前端视野；</li>\n<li>专栏中我们通过Vue源码感受了算法的魅力，你也可以把LeetCode刷200题作为2022年的flag之一；</li>\n<li>Vue的新文档也在编写之中，2022年你也可以尝试一下只读英文文档去巩固英语基础。</li>\n</ul><p>有什么让你感觉痛苦的，新的一年就大胆去战胜它，相信完成这个目标之后你会发现，之前进阶路上的拦路虎只是一个纸老虎。</p><p>最后限于我个人的水平所限，专栏难免有不足的地方，欢迎你随时留言。</p><p>祝你能够找到适合自己的方式，构建自己核心的知识体系；愿你能够继续怀揣对Web前端技术的热忱，去拥抱Vue和React，拥抱TypeScript，拥抱这个更好的前端时代，以及，所有那些值得去追求的美好事物。</p><p>编程进阶的路很长，山底太挤，我们山顶见！</p>',
        article_title: "结束语｜Vue 3生态源码到底给我们带来了什么？",
      },
      {
        title: "期末测试｜来赴一场满分之约！",
        id: 476736,
        content:
          '<p>你好，我是大圣。</p><p>专栏《玩转 Vue 3 全家桶》已经结课了。非常感谢你一直以来的认真学习和支持！</p><p>为了帮你检验自己的学习效果，我特意给你准备了一套结课测试题（可以重复答题）。这套测试题一共有 20 道多选，考点都来自我们前面讲到的重要知识。点击下面按钮开始测试吧！</p><p><a href="http://time.geekbang.org/quiz/intro?act_id=1448&exam_id=3657"><img src="https://static001.geekbang.org/resource/image/28/a4/28d1be62669b4f3cc01c36466bf811a4.png?wh=1142*201" alt=""></a></p><p>最后，我还给你准备了一个<a href="https://jinshuju.net/f/magvVx">调查问卷</a>。题目不多，大概两分钟就可以填完，主要是想听一下你对这门课的看法和建议。期待你的反馈！</p><!-- [[[read_end]]] -->',
        article_title: "期末测试｜来赴一场满分之约！",
      },
    ],
  },
];
