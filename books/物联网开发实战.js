exports.category = "other";
exports.title = "物联网开发实战";
exports.data = [
    {
        "chapterTitle": "2022特别加更",
        "children": [
            {
                "title": "引子｜RISC-V：物联网领域值得关注的芯片趋势是什么？",
                "id": 506337,
                "content": "<p>你好，我是郭朝斌。</p><p>时隔一年多，我选择再次更新我们的物联网专栏，这里有两个因素在驱动我。</p><p>一是，当初在创作这个专栏时，我就希望把它作为一个与你交流的窗口，能够围绕物联网行业持续分享所知所想，为推动行业的发展尽自己的一点绵薄之力。</p><p>二是，最近我关注到芯片领域的一些新变化，例如英伟达收购 ARM 以失败告终，例如英特尔以最高级别会员的身份加入 RISC-V 基金会。而芯片是物联网设备层的关键组件，<strong>芯片领域的任何发展和变化都会深刻影响到物联网行业。</strong></p><p>那么，我们的更新就从芯片领域的具体变化开始说起吧。</p><h2>RISC-V 正在快速崛起</h2><p>芯片领域的变化具体是什么呢？</p><p>正是 RISC-V 架构在快速崛起，并且大有与 X86架构（包括X86和X86-64）、ARM 架构形成三足鼎立格局的势头。</p><p>X86、ARM你应该比较熟悉，一个是借助“Wintel联盟”（指微软和英特尔两家公司）在PC电脑行业称霸的CPU芯片架构，背后是以英特尔、AMD为首的少数几家公司；另一个是移动智能手机上主处理芯片的内核架构，背后是提供ARM架构的芯片内核IP的ARM公司，和像高通、三星这样通过授权使用ARM内核IP设计开发SoC（System on Chip）芯片的芯片厂商。</p><!-- [[[read_end]]] --><p>那 RISC-V 又是什么来历呢？我们一起来了解一下。</p><h3>RISC-V的历史</h3><p>RISC-V是一套开放、开源的通用指令集架构（Instruction Set Architecture，缩写ISA）。其开始于2010年加州大学伯克利分校，当时，并行计算实验室的 Krste Asanovic 教授及其团队需要选择一种指令集架构来使用，但是考虑到商用授权费用太高，后期修改扩展不方便等问题，他们重新设计了一套基于精简指令集计算（RISC）的 ISA，取名 RISC-V。</p><p><span class=\"reference\">小提示：这里的 V 是数字5的拉丁文表示，因此读作 five。隔壁邵巍老师的<a href=\"https://time.geekbang.org/column/intro/100079201\">《说透芯片》</a>专栏中也有RISC-V的相关介绍，你也可以扩展阅读一下。</span></p><p>RISC-V ISA 真正获得快速发展始于2015年。那一年，三位RISC-V发明者，Krste教授和他的两位学生创办了SiFive芯片公司。同时，SiFive公司联合以谷歌为首的几家公司，创立了RISC-V基金会。</p><p><a href=\"http://www.sifive.com/technology/risc-v\"><img src=\"https://static001.geekbang.org/resource/image/08/02/080817b972d281520ec979f5e778e602.png?wh=1220x701\" alt=\"\" title=\"RISC-V 和 SiFive 创始人[br]点击图片跳转至SiFive官网\"></a></p><h3>渐趋完善的 RISC-V 生态</h3><p>不得不说，这种以基金会形式来推动 RISC-V 发展的方式，是充分地借鉴了 Android 的发展路线的。现在，已经有70多个国家的2400多个组织加入了基金会。其中，既有芯片 IP 设计公司，又有芯片制造工厂；既有各种应用领域的芯片供应商，又有开发工具链等软件企业。</p><p>这些组织已经形成一个围绕着 RISC-V 的、完整而强大的生态。而正是这样的生态，推动着RISC-V不断向前发展。那么，为什么产业生态对于 RISC-V 这么重要呢？</p><p>其实，产业生态对任何芯片指令集架构都很重要。以X86的发展为例，我们可以先看一下<strong>整机和配件厂家对硬件技术提升的推动。</strong></p><p>在上世纪70年代，个人计算机发展的初期，CPU 的指令集架构种类是多种多样的，占据领先地位的是 Commodore 和苹果等公司的产品。到80年代，随着 IBM 公开基于英特尔X86芯片设计的 IBM PC 的整个技术资料，各种兼容机开始出现，而IBM PC成为事实上的行业标准。上世纪90年代初，个人计算机市场上仅剩下了 IBM PC兼容机和苹果的Macintosh电脑两个主要系列，而 IBM PC兼容机处于绝对的市场主导地位。到2005年，乔布斯宣布将Macintosh电脑的中央处理器也切换到英特尔提供的X86芯片。</p><p><img src=\"https://static001.geekbang.org/resource/image/56/f8/567587c68f6ef2df2f42bcdd8ae11ff8.jpg?wh=2284x1811\" alt=\"\" title=\"X86发展历程\"></p><p>在这个过程中，英特尔凭借着80286、80386、80486和奔腾（Pentium）等一系列产品，成为了 PC 计算机中中央处理器（CPU）的绝对标准。同时，它也逐渐开始替代 IBM 主导 PC 硬件的迭代升级。</p><p>你会发现，正是这些整机和配件厂家，它们一起推动了X86的迭代发展，成就了 PC 行业的繁荣。客观上，它们也保证英特尔赚取了PC硬件的大部分利润。</p><p><strong>同时，硬件的技术提升和创新更是离不开软件的支持。</strong>英特尔与微软的密切合作形成的强大的协同效应，也促成了被称为“Wintel联盟”的 PC 行业“双寡头垄断”的格局。还有MMX、SSE这些旨在增强图形图像和音视频处理性能的新增指令，如果没有编译器的支持，没有2D/3D算法库、音视频算法库的适配，没有游戏等应用软件的使用，这些指令集就无法发挥作用，也就不能形成产品的竞争力。</p><p>回到我们在开始讲到的RISC-V生态，你会发现，在整个生态的共同努力下，RISC-V 已经不仅仅是高校实验室或者研究机构的教学、实验工具，而且在产业界也获得了越来越大的影响力。</p><h3>RISC-V 的实际成绩</h3><p>对于开发者来说，工具链是使用芯片必不可少的基础，而且因为每种指令集的具体编码和编程模型并不相同，每种指令集都需要一套适配自己的工具链。目前，开源软件，如编译工具GCC、LLVM，调试工具GDB、OpenOCD，模拟器QEMU，还有商用软件，如嵌入式领域流行的集成开发环境 IAR ，调试器 SEGGER、Lauterbach（劳特巴赫）等都已经支持 RISC-V。</p><p>其他软件生态方面，如主流高级开发语言C、C++、Golang，操作系统Linux，各种嵌入式系统常用的RTOS系统内核也都适配RISC-V芯片架构。</p><p>或者，我们也可以具体到芯片产品来看RISC-V的影响力。例如，国内的阿里平头哥是一家RISC-V芯片IP设计公司，目前已经有超过百家使用授权公司。最近，其<a href=\"https://www.icspec.com/news/article-details/1734929?type=prefecture\">宣布</a>截至2021年10月，RISC-V内核的芯片出货量已经达到25亿颗。除此之外，中国台湾的晶心科技（Andes Technology）是中国台湾一家提倡自主芯片设计的公司。<a href=\"https://cn.design-reuse.com/news/51560/andes-10-billion-cumulative-shipments.html\">据报道</a>，它从2017年全面投入RISC-V架构以来，芯片出货量年化增长率有50%，截止2021年底已经有100亿颗的 RISC-V IP 出货量。</p><p>据 Semico Research 研究机构测算，到2025年，RISC-V内核芯片将达近800亿颗，成为一股继X86和ARM架构之后，不可小觑的指令集架构。</p><p><a href=\"http://riscv.or.jp/wp-content/uploads/rvdv_01_RISC-V-Open-Era-01-04-2022.pdf\"><img src=\"https://static001.geekbang.org/resource/image/90/b2/907cd8edcbe641118d25645794f3cfb2.png?wh=1080x518\" alt=\"\" title=\"Semico Research 机构预测 RISC-V 趋势[br]点击图片跳转，获取“趋势预测PDF”\"></a></p><p>其实，这也是英特尔在2022年2月宣布加入RISC-V基金会的行业背景。</p><p>随着移动智能手机的发展，英特尔承受着来自 ARM 巨大的竞争压力。所以，英特尔希望扶持 RISC-V 的发展，一方面可以通过 RISC-V 的应用扩展，与ARM竞争，抢占ARM的应用领域和市场份额，另一方面可以在 RISC-V 的发展过程中，主导发展路线，推动自己的芯片代工业务的发展。这就像三国魏蜀吴相争，诸葛亮倡导的联吴抗魏策略一样。当然，这也充分说明了RISC-V的行业地位和发展前景。</p><h2>为什么是 RISC-V ?</h2><p>到这里，你应该已经了解RISC-V的崛起过程和预期前景了。但是，“打铁还需自身硬”，RISC-V是不是担得起大家给它的这份期待呢？我从技术角度给你分析一下。</p><h3>新生代没有历史包袱</h3><p>RISC-V 指令集项目发起于2010年，相比于 X86 和 ARM 架构，它绝对算是新生代。</p><p>借助于后发优势，RISC-V 在设计上吸收了历史上各种指令集的经验，规避了很多前人踩过的坑。它没有X86 和 ARM那样沉重的历史包袱，具有的是初生的生命力和活力。一个直观的对比就是<a href=\"https://riscv.org/technical/specifications\">指令集文档</a>，RISC-V 最新发布的<a href=\"https://github.com/riscv/riscv-isa-manual/releases/download/Ratified-IMAFDQC/riscv-spec-20191213.pdf\">指令集文档</a>篇幅只是238页，另一个<a href=\"https://github.com/riscv/riscv-isa-manual/releases/download/Priv-v1.12/riscv-privileged-20211203.pdf\">特权架构文档</a>仅有155页，作为对比 ARM 指令集文档有数千页。</p><p>当然，这带来的不仅是<strong>芯片设计人员的学习成本降低</strong>，RISC-V在指令集上的简洁设计也<strong>降低了芯片的设计复杂度和芯片尺寸，进而压缩了研发和生产成本。</strong>这迎合了物联网行业在设备端、边缘侧场景中对于低成本、低能耗的需求。</p><h3>模块化迎合芯片DSA发展趋势</h3><p>另一方面，我整理了一份最新的 RISC-V 指令集架构模块信息，如下面表格所示。</p><p><img src=\"https://static001.geekbang.org/resource/image/90/b6/90b5b1c20165e3dcbe04041ec67d2fb6.jpg?wh=2284x2201\" alt=\"\" title=\"RISC-V指令集说明\"></p><p>你可以很直观地看到， RISC-V 指令集是使用模块化的方式定义的。因此，芯片设计人员可以根据具体场景来选择组合。除了基本的整数指令子集要求强制实现外，其他模块都可以自由选择。</p><p>其中，根据不同的地址空间位数和寄存器个数，基本的整数指令子集有 4 种选择。芯片设计人员一般会根据性能、功耗和成本等因素来决策。比如，字母E表示 RISC-V专门为嵌入式提供的指令集架构（见表格内第三行数据）。这个架构对指令进行了精简，以减少芯片的面积和功耗，这对于嵌入式应用场景非常必要。</p><p>可以说，随着AI、IoT等新计算场景出现，现在的算力需求有向多样化、定制化（DSA，Domain-Specific Architectures的缩写）发展的趋势，而RISC-V指令集的模块化特点正好可以适应物联网、MCU、边缘计算、AI加速器等领域的芯片需求。</p><h3>开源模式优势</h3><p>最后不得不提的是，X86架构是一种完全封闭的指令架构，而 ARM 架构虽然开放，但是芯片设计公司需要支付昂贵的 IP 授权费用。至于RISC-V指令集架构，则从一开始就采用了开源的模式。</p><p><img src=\"https://static001.geekbang.org/resource/image/fc/e9/fcb2af2a5bf2d795e0c095aa4294bbe9.png?wh=2284x869\" alt=\"\" title=\"RISC-V和x86和ARM对比\"></p><p>这样，任何企业、研究机构和个人都可以围绕RISC-V来研究开发，丰富 RISC-V 的软硬件生态，并且推动架构的不断进化。</p><h3>中立开放</h3><p>除了技术上的优势，RISC-V 的成功也有产业发展、国际竞争格局等因素的助推。</p><p>RISC-V虽然起源于美国的加州大学伯克利分校，但是RISC-V基金会一直倡导构建开源、开放计算生态的理念。随着国际形势的发展，RISC-V基金会甚至把总部转移到了国际上传统的中立国——瑞士，来避免国际政治的影响。</p><p>这为美国以外的，渴望掌握芯片自主权的国家提供了信心和机会。欧洲、日本、印度等国家都在推动RISC-V在本国、本地区的发展。印度甚至将其作为国家指令集架构。</p><p>不管公司还是国家，基于不同的需求，都共同选择了 RISC-V，推动了 RISC-V 的快速崛起。我相信，未来基于 RISC-V 架构的MCU等芯片将会越来越多，作为物联网行业从业者，你我如果可以尽早接触 RISC-V 生态，熟悉相关工具链，了解各种代码库，“踩足够多的坑”，那对于将来的工作和发展都会大有裨益。</p><h2>你可以学到什么？</h2><p>正是基于RISC-V这样的发展背景，接下来，我会基于平头哥的 RVB2601开发板，把之前“实战篇”中的<a href=\"http://time.geekbang.org/column/article/322528\">智能灯</a>、<a href=\"http://time.geekbang.org/column/article/326153\">自动浇花器</a>实验重新做一遍。</p><p>为什么我会选择RVB2601开发板呢？</p><p>一是，因为平头哥提供了相对完善的 RISC-V 工具链，这样便于你顺利地上手实验。二是，平头哥有多种技术支持渠道可以选择。除了访问<a href=\"https://occ.t-head.cn\">平头哥开发者社区</a>，你还可以加入社区交流钉钉群，通过提交在线工单或者直接交流获取帮助。三是，RVB2601开发板兼容 Arduino 的扩展接口，你可以复用前期实验中的传感器、继电器等外围器件。</p><h3>RISC-V 实验课程安排</h3><p>那么，我们接下来具体的更新课程安排是什么呢？</p><blockquote>\n<p>首先，我会带你熟悉RISC-V开发环境，并使用C语言开发智能电灯。<br>\n接着，我会讲解通过MQTT协议实现联网控制。<br>\n然后，我会讲解RVB2601开发板的蓝牙开发，实现光照传感器。<br>\n最后，我会讲解RVB2601开发板的 OLED 屏幕开发，实现带屏幕显示的浇花器。</p>\n</blockquote><p>整体的课程分为4节，你会发现，它们仍然是遵循“实战篇”的内容节奏一步步展开的。不过，我们将会基于 RISC-V 芯片架构的 RVB2601 开发板和 C 语言来完成动手实践。</p><p>在这个过程中，你可以获得：</p><ol>\n<li>\n<p>熟悉 RISC-V 通用指令集架构。</p>\n</li>\n<li>\n<p>掌握一种 RISC-V 工具链。虽然我们使用IDE集成开发环境，但是背后其实是一套交叉编译和调试程序，你可以在掌握 IDE使用的基础上，去了解学习编译工具 GCC+LLVM 等。</p>\n</li>\n<li>\n<p>学习基于 C 语言的嵌入式开发。之前的课程是基于Python，当时我是为了降低上手门槛，现在使用 C 语言更加符合实际工作中主流的嵌入式开发方式，实践编写代码、交叉编译、烧录固件和调试的全流程。</p>\n</li>\n<li>\n<p>对比 C 语言和 Python 语言开发的不同。有人说过，掌握一门外语才能更好地理解母语。编程语言的学习也是这样，只有通过不同语言的对比，你才能更好地掌握编程开发。</p>\n</li>\n</ol><p>最后，这次的加餐会以一周一次的频率更新，和今天一样，在每周三的零点准时和你相见。希望这样的慢节奏更新，能够让你有更充裕的时间来动手实践，来交流碰撞。看过听过不是我们学习的目的，真正把知识掌握好才是最终的目标。</p><h2>写在最后</h2><p>今天，我讲到了RISC-V架构的发展趋势，还有RISC-V的技术优势。</p><p>考虑到RISC-V对物联网行业的影响，我规划了这次扩展内容，希望对你的实际工作有一定的帮助。你也可以在评论区谈谈你对这次扩展内容的看法，或者分享一下曾经与 RISC-V 相关的工作经历。</p><p>期待在下一讲与你再次交流，我将带你完成基于 RISC-V 芯片的智能灯开发。</p>",
                "article_title": "引子｜RISC-V：物联网领域值得关注的芯片趋势是什么？"
            },
            {
                "title": "实战一｜嵌入式开发：如何使用C语言开发智能电灯？",
                "id": 509508,
                "content": "<p>你好，我是郭朝斌。</p><p>作为RISC-V开发板动手实践的第一讲，我们从智能灯的嵌入式开发开始吧。</p><p>智能灯硬件最重要的功能是控制LED灯的颜色和开关，这就涉及到PWM信号的生成和继电器的控制。之前我们是使用Python语言在NodeMCU开发板上实现的。那么，这些功能如何在RISC-V芯片上，使用C语言实现呢？</p><p>别着急，我来一步一步地讲解一下。</p><h2>开发板介绍</h2><p><a href=\"https://time.geekbang.org/column/article/506337\">上一讲</a>已经提到，我们使用的开发板是平头哥（T-Head）公司设计开发的RVB2601 开发板。主控芯片代号是CH2601，它基于平头哥开源的玄铁E906处理器内核IP设计开发，具体的指令集架构是RV32IMACX。</p><p>根据上节学到的RISC-V指令集知识，你可以知道这代表它采用 RISC-V 32bit 基本整数指令子集，并且包含整数乘法与除法指令子集，不可中断指令（也称作存储器原子操作指令）子集，压缩指令子集，这些标准扩展指令集。</p><p>其中，压缩指令子集对于嵌入式芯片非常重要，它可用于提高代码密度，节省存储成本。最后的代号\"X\"表示玄铁E906自定义的一些扩展指令集，这也是RISC-V指令集架构可扩展性的体现。</p><p>说了这么多，我们来看一下RVB2601开发板的实物图。</p><!-- [[[read_end]]] --><p><img src=\"https://static001.geekbang.org/resource/image/d2/54/d29e903c981408b36f8785da9a3acf54.jpg?wh=1144x605\" alt=\"\"></p><p>作为一款嵌入式系统开发板，RVB2601在用户交互体验上下了一番功夫，提供了一块OLED屏幕，两个MIC输入，一个扬声器，一个三色LED灯，还有两个实体按键。基于这些器件，你可以直接动手实验很多有趣的应用。</p><p>更重要的是，这些外围器件都是通过跳线帽与主控芯片CH2601的I/O接口相连的，这就是说我们可以把跳线帽去掉，将我们自己的传感器、继电器等器件与芯片的I/O接口连接，开发我们的特定的应用。</p><p>当然，在这之前，我们需要先了解一下 RVB2601 开发板的I/O接口分布及功能。我绘制了一张I/O接口功能图，供你参考。<a href=\"https://occ.t-head.cn/vendor/detail/index?id=3886757103532519424&key=download&module=4&vendorId=3706716635429273600\">官方文档</a>中也有相关的描述，你也可以参考，但是介绍比较分散，你可能经常需要查看文档的多个位置来确认一个接口的功能。</p><p><img src=\"https://static001.geekbang.org/resource/image/78/d8/788e31d927eea0a781d496c0d760ccd8.png?wh=1080x1440\" alt=\"\"></p><h2>开发环境初体验</h2><p>了解完硬件的基本情况，我们来看一下软件的开发工具和流程。</p><h3>第一步 安装集成开发环境</h3><p>平头哥提供了一个集成开发环境，名称是剑池CDK。在这个软件开发环境里，图形化的操作界面更利于我们使用。</p><p>不过，CDK只支持 Windows操作系统，如果你使用Mac电脑的话，可以像我一样使用 <a href=\"https://www.virtualbox.org/wiki/Downloads\">VirtualBox</a> 虚拟机软件，在Mac电脑上运行一个Windows虚拟机。VirtualBox是完全免费的，当然其他商用的虚拟机软件也可以使用。</p><h3>第二步 程序开发</h3><p>安装好IDE（集成开发环境）后，我们来创建一个工程项目。为了简便、快速地帮你理解，我们直接基于 IDE 提供的模版工程创建一个示例程序。</p><p>在IDE的欢迎页面中，点击右上角的“新建工程”<br>\n<img src=\"https://static001.geekbang.org/resource/image/4d/fd/4d83e3a12d9604750b8a582c69e003fd.png?wh=2458x110\" alt=\"\"></p><p>接着，你可以在新页面中找到顶部的搜索框，然后输入\"ch2601\"。</p><p>如果IDE没有显示欢迎页面，你可以点击工具栏右侧的平头哥Logo图标，重新打开欢迎页面。</p><p><img src=\"https://static001.geekbang.org/resource/image/08/0f/08yy844c38f63afed903289305cff40f.png?wh=376x83\" alt=\"\"></p><p>点击搜索，你可以看到所有关于芯片CH2601的工程项目。</p><p><img src=\"https://static001.geekbang.org/resource/image/81/df/81b4629c289e6c785d98d207f685a5df.png?wh=2478x1122\" alt=\"\"></p><p>我们选择与智能灯最接近的跑马灯项目作为模板。点击“ch2601_marquee_demo”条目右侧的“创建工程”。在弹出的“新建工程”窗口中，输入一个工程名称，比如“Led”，然后点击“确认”。</p><p><img src=\"https://static001.geekbang.org/resource/image/30/06/30bdbc036c5ef4bc05f871c330d1be06.png?wh=444x324\" alt=\"\"></p><p>在IDE左侧，我们可以看到新建工程“Led”的工程结构：</p><ul>\n<li>“app”目录中的文件是工程的应用代码。</li>\n<li>“.gdbinit”文件是GDB调试程序的初始化参数。</li>\n<li>“SConstruct”文件是<a href=\"https://scons.org\">Scons</a>软件构建工具的配置文件。</li>\n<li>“sdk_chip_ch2601”节点中是YOC平台相关的基础库。</li>\n</ul><h3>第三步 编译</h3><p>现在我们新建的Led工程中是跑马灯应用的完整代码。我们先不做任何修改，直接编译、运行一下。你可以点击工具栏中的编译图标，启动工程编译。</p><p><img src=\"https://static001.geekbang.org/resource/image/93/76/93b5284be8646c42b6c93419fac6a376.png?wh=235x85\" alt=\"\"></p><p>或者从“Project”菜单中选择“Build Active Project”。</p><p><img src=\"https://static001.geekbang.org/resource/image/ae/e8/aeda012d7f0c46d5ac66444e2f66f7e8.png?wh=486x486\" alt=\"\"></p><p>从这里我们也可以看出C语言和Python语言的不同，<strong>C语言开发的代码在运行之前必须先进行编译，生成机器指令，而在这个过程中，编译器可以提前发现语法错误等。</strong></p><h3>第四步 烧录</h3><p>接着，我们需要将编译生成的固件文件烧录到开发板中。RVB开发板是通过JTAG接口来完成固件烧录的。你需要使用USB连接线把电脑与开发板的JTAG接口相连，然后点击工具栏中的烧录图标。</p><p><img src=\"https://static001.geekbang.org/resource/image/99/55/9989201a40eb9db047bea7803080e155.png?wh=372x136\" alt=\"\"></p><h3>第五步 运行</h3><p>烧录完成后，你需要按一下开发板上的RST按键，重置RVB2601开发板。这时就可以看到开发板上的LED灯开始三种颜色交替点亮、熄灭。</p><p>这里提醒一下，如果LED灯的闪烁不正确，你需要查看一下开发板上PA7、PA25和PA4的跳线帽安装位置是否正确。我收到的开发板上，PA7一开始没有安装跳线帽，就导致了LED灯的红色状态不工作。</p><h2>智能灯的开发</h2><p>接下来，我们开始智能灯的开发。</p><p>LED模块和继电器仍然使用我们之前实验中使用的器件。如果你是第一次接触这个实验，或者之前的器件已经不知道跑到哪里去了，也可以参考<a href=\"https://shimo.im/sheets/D3VVPdwcYRhhQRXh/MODOC\">这份文档</a>自行采购相关硬件。</p><p>至于电路连接图，你可以参考下图。</p><p><img src=\"https://static001.geekbang.org/resource/image/4d/1f/4d9d6cb1004d2b262efae194901ae11f.png?wh=1920x1080\" alt=\"\"></p><p>这里需要注意的是，最初，开发板上的J1扩展接口的15和16位、J3扩展接口的3和4位、J3扩展接口的5和6位、J3扩展接口的7和8位，还有J4扩展接口的15和16位是安装着跳线帽的，你在接线时需要把这些跳线帽去掉。</p><h3>PWM信号生成</h3><p>在本实验中，LED模块的发光原理依然是PWM，忘记的同学可以回去<a href=\"https://time.geekbang.org/column/article/322528\">第17节</a>复习一下。LED灯的代码如下，供你参考。</p><pre><code class=\"language-c++\">\n/*********************\n&nbsp;*&nbsp; &nbsp; &nbsp; INCLUDES\n&nbsp;*********************/\n#define _DEFAULT_SOURCE /* needed for usleep() */\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;unistd.h&gt;\n#include &lt;time.h&gt;\n#include &lt;aos/aos.h&gt;\n#include \"app_config.h\"\n#include \"app_init.h\"\n#include \"csi_config.h\"\n#include \"hw_config.h\"\n\n#include \"board_config.h\"\n#include \"drv/gpio_pin.h\"\n#include &lt;drv/pin.h&gt;\n#include &lt;drv/pwm.h&gt;\n\n#ifdef CONFIG_PWM_MODE\n\nstatic uint32_t g_ctr = 0;\nstatic csi_pwm_t&nbsp; r;\n\nvoid led_pinmux_init()\n{\n&nbsp; &nbsp; &nbsp; &nbsp; //7\n&nbsp; &nbsp; csi_error_t ret;\n&nbsp; &nbsp; csi_pin_set_mux(PA7, PA7_PWM_CH7);\n&nbsp; &nbsp; csi_pin_set_mux(PA25, PA25_PWM_CH2);\n&nbsp; &nbsp; csi_pin_set_mux(PA4, PA4_PWM_CH4);\n\n&nbsp; &nbsp; ret = csi_pwm_init(&amp;r, 0);\n&nbsp; &nbsp; if (ret != CSI_OK) {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; printf(\"===%s, %d\\n\", __FUNCTION__, __LINE__);\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return ;\n&nbsp; &nbsp; }\n}\n\nvoid rgb_light(uint32_t red, uint32_t green, uint32_t blue)\n{\n\tcsi_error_t ret;\n\tret = csi_pwm_out_config(&amp;r, 7 / 2, 300, red*300/255, PWM_POLARITY_HIGH);\n&nbsp; &nbsp; if (ret != CSI_OK) {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; printf(\"===%s, %d\\n\", __FUNCTION__, __LINE__);\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return ;\n&nbsp; &nbsp; }\n&nbsp; &nbsp; ret = csi_pwm_out_start(&amp;r, 7 / 2);\n&nbsp; &nbsp; if (ret != CSI_OK) {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; printf(\"===%s, %d\\n\", __FUNCTION__, __LINE__);\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return ;\n&nbsp; &nbsp; }\n&nbsp; &nbsp; &nbsp; &nbsp; //25\n&nbsp; &nbsp; ret = csi_pwm_out_config(&amp;r, 2 / 2, 300, green*300/255, PWM_POLARITY_HIGH);\n&nbsp; &nbsp; if (ret != CSI_OK) {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; printf(\"===%s, %d\\n\", __FUNCTION__, __LINE__);\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return ;\n&nbsp; &nbsp; }\n&nbsp; &nbsp; ret = csi_pwm_out_start(&amp;r, 2 / 2);\n&nbsp; &nbsp; if (ret != CSI_OK) {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; printf(\"===%s, %d\\n\", __FUNCTION__, __LINE__);\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return ;\n&nbsp; &nbsp; }\n&nbsp; &nbsp; &nbsp; &nbsp; //4\n&nbsp; &nbsp; ret = csi_pwm_out_config(&amp;r, 4 / 2, 300, blue*300/255, PWM_POLARITY_HIGH);\n&nbsp; &nbsp; if (ret != CSI_OK) {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; printf(\"===%s, %d\\n\", __FUNCTION__, __LINE__);\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return ;\n&nbsp; &nbsp; }\n&nbsp; &nbsp; ret = csi_pwm_out_start(&amp;r, 4 / 2);\n&nbsp; &nbsp; if (ret != CSI_OK) {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; printf(\"===%s, %d\\n\", __FUNCTION__, __LINE__);\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return ;\n&nbsp; &nbsp; }\n}\n#endif&nbsp;\n\n#ifdef CONFIG_GPIO_MODE\nstatic uint32_t g_ctr = 0;\nstatic csi_gpio_pin_t r;\nstatic csi_gpio_pin_t g;\nstatic csi_gpio_pin_t b;\nvoid led_pinmux_init()\n{\n&nbsp; &nbsp; csi_pin_set_mux(PA7, PIN_FUNC_GPIO);\n&nbsp; &nbsp; csi_pin_set_mux(PA25, PIN_FUNC_GPIO);\n&nbsp; &nbsp; csi_pin_set_mux(PA4, PIN_FUNC_GPIO);\n&nbsp; &nbsp; csi_gpio_pin_init(&amp;r, PA7);\n&nbsp; &nbsp; csi_gpio_pin_dir(&amp;r, GPIO_DIRECTION_OUTPUT);\n\tcsi_gpio_pin_mode(&amp;r, GPIO_MODE_PUSH_PULL);\n&nbsp; &nbsp; csi_gpio_pin_init(&amp;g, PA25);\n&nbsp; &nbsp; csi_gpio_pin_dir(&amp;g, GPIO_DIRECTION_OUTPUT);\n\tcsi_gpio_pin_mode(&amp;g, GPIO_MODE_PUSH_PULL);\n&nbsp; &nbsp; csi_gpio_pin_init(&amp;b, PA4);\n&nbsp; &nbsp; csi_gpio_pin_dir(&amp;b, GPIO_DIRECTION_OUTPUT);\n\tcsi_gpio_pin_mode(&amp;b, GPIO_MODE_PUSH_PULL);\n&nbsp; &nbsp; g_ctr = 0;\n}\n\n//fake rgb, because of only high or low state of gpio\nvoid rgb_light(uint32_t red, uint32_t green, uint32_t blue)\n{\n\t(red &lt; 50)?csi_gpio_pin_write(&amp;r, GPIO_PIN_LOW):csi_gpio_pin_write(&amp;r, GPIO_PIN_HIGH);\n\t(green &lt; 50)?csi_gpio_pin_write(&amp;r, GPIO_PIN_LOW):csi_gpio_pin_write(&amp;g, GPIO_PIN_HIGH);\n\t(blue &lt; 50)?csi_gpio_pin_write(&amp;r, GPIO_PIN_LOW):csi_gpio_pin_write(&amp;b, GPIO_PIN_HIGH);\n}\n#endif\n</code></pre><p>在代码中，我们主要使用了 CSI 接口规范中的相关接口函数，你可以参考<a href=\"https://yoc.docs.t-head.cn/yocbook/Chapter3-AliOS/CSI%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E6%8E%A5%E5%8F%A3/CSI2/PWM.html\">接口规范文档</a>进一步了解具体细节。</p><p>比对规范文档，你可能会有一个疑问：接口PA7、PA25和PA4对应的PWM输出接口编号分别是CH7、CH2和CH4，为什么接口函数csi_pwm_out_config和csi_pwm_out_start的channel（通道号）入参中填写的是编号除以2的得数取整，而不是编号本身呢？</p><p>这涉及到CH2601芯片对于PWM的内部具体设计。</p><p>CH2601芯片内部有6个PWM发生器，对应着编号0～5的通道。每个PWM发生器对应2个输出接口，这两个接口的PWM信号波形是完全一致的。通道编号与输出接口的具体关系如下表。</p><p><img src=\"https://static001.geekbang.org/resource/image/f8/de/f87bfc6865170163f964c9740937c2de.jpg?wh=1280x534\" alt=\"\"></p><p>从表格中，你可以直观地看到PWM输出接口编号数字需要除以2，并取整，才可以得到PWM的通道编号。这就是上面代码处理方式的来源。</p><p>另外，在上面表格中，我还列出了PWM通道对应的GPIO接口。这是为了方便你在以后的应用中选择合适的PWM接口。比如，在本实验的智能灯应用中，我们需要三个独立的PWM通道来控制LED模块的R、G、B接口，那么我们就不能选择表格里面同一格的多个GPIO接口。显然，我们选择的PA7、PA25和PA4是满足这个原则的。</p><p>同时，我也使用GPIO的高低电平模式实现了LED模块的控制逻辑，便于你对比两种方式的异同。</p><h3>继电器的控制</h3><p>接下来我们看继电器控制的部分是怎么实现的。继电器的驱动同样是通过GPIO口，通过输出高低电平，实现它的通断控制。代码如下。</p><pre><code class=\"language-c++\">/*********************\n&nbsp;*&nbsp; &nbsp; &nbsp; INCLUDES\n&nbsp;*********************/\n#define _DEFAULT_SOURCE /* needed for usleep() */\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;unistd.h&gt;\n#include &lt;time.h&gt;\n#include &lt;aos/aos.h&gt;\n#include \"app_config.h\"\n#include \"app_init.h\"\n#include \"csi_config.h\"\n#include \"hw_config.h\"\n\n#include \"board_config.h\"\n#include \"drv/gpio_pin.h\"\n#include &lt;drv/pin.h&gt;\n\nstatic csi_gpio_pin_t relay;\n\nvoid relay_pinmux_init()&nbsp;\n{\n\tcsi_error_t ret;\n\tcsi_pin_set_mux(PA26, PIN_FUNC_GPIO);\n\tcsi_gpio_pin_init(&amp;relay, PA26);\n&nbsp; &nbsp; csi_gpio_pin_dir(&amp;relay, GPIO_DIRECTION_OUTPUT);\n}\n\nvoid relay_toggle(bool on)\n{\n\tif(on)\n\t{\n\t\tcsi_gpio_pin_write(&amp;relay, GPIO_PIN_HIGH);\n\t}&nbsp;\n\telse&nbsp;\n\t{\n\t\tcsi_gpio_pin_write(&amp;relay, GPIO_PIN_LOW);\n\t}\n}\n</code></pre><h3>主逻辑编写</h3><p>最后是程序的主逻辑。我们需要先初始化LED模块和继电器使用的I/O接口，然后调用LED代码的接口，点亮LED灯。在主循环中，我们周期性地打开、关闭继电器，实现LED灯闪烁的效果。</p><p><span class=\"reference\">注：其中lv和oled开头的函数，是显示屏相关的代码。你暂时不需要关心它们，我会在后面的实验中详细讲解。</span></p><pre><code class=\"language-c++\">\n/*********************\n&nbsp;*&nbsp; &nbsp; &nbsp; INCLUDES\n&nbsp;*********************/\n#define _DEFAULT_SOURCE /* needed for usleep() */\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;unistd.h&gt;\n#include &lt;time.h&gt;\n#include &lt;aos/aos.h&gt;\n#include \"aos/cli.h\"\n\n#include \"app_config.h\"\n#include \"app_init.h\"\n#include \"csi_config.h\"\n#include \"hw_config.h\"\n#include \"lvgl.h\"\n#include \"lv_label.h\"\n#include \"oled.h\"\n\n#include \"board_config.h\"\n#include \"drv/gpio_pin.h\"\n#include &lt;drv/pin.h&gt;\n#include &lt;drv/pwm.h&gt;\n\n/*********************\n&nbsp;*&nbsp; &nbsp; &nbsp; DEFINES\n&nbsp;*********************/\n#define TAG \"app\"\n\n/**********************\n&nbsp;*&nbsp; &nbsp; &nbsp; TYPEDEFS\n&nbsp;**********************/\n\n/**********************\n&nbsp;*&nbsp; STATIC PROTOTYPES\n&nbsp;**********************/\nstatic void led_task(void *arg);\n\n/**********************\n&nbsp;*&nbsp; STATIC VARIABLES\n&nbsp;**********************/\n\n/**********************\n&nbsp;*&nbsp; &nbsp; &nbsp; MACROS\n&nbsp;**********************/\n\n/**********************\n&nbsp;*&nbsp; &nbsp;GLOBAL FUNCTIONS\n&nbsp;**********************/\n\nvolatile uint32_t g_debug = 0;\nvolatile uint32_t g_debug_v = 0;\n\n#include \"csi_core.h\"\n/**\n&nbsp;* main\n&nbsp;*/\nint main(void)\n{\n&nbsp; &nbsp; board_yoc_init();\n\n&nbsp; &nbsp; printf(\"===%s, %d\\n\", __FUNCTION__, __LINE__);\n&nbsp; &nbsp; printf(\"===%s, %d\\n\", __FUNCTION__, __LINE__);\n&nbsp; &nbsp; aos_task_new(\"demo\", led_task, NULL, 10 * 1024);\n&nbsp; &nbsp; return 0;\n}\n\nstatic void lable_test(void)\n{\n&nbsp; &nbsp; lv_obj_t *p = lv_label_create(lv_scr_act(), NULL);\n&nbsp; &nbsp; lv_label_set_long_mode(p, LV_LABEL_LONG_BREAK);\n&nbsp; &nbsp; lv_label_set_align(p, LV_LABEL_ALIGN_CENTER);\n&nbsp; &nbsp; lv_obj_set_pos(p, 0, 4);\n&nbsp; &nbsp; lv_obj_set_size(p, 128, 60);\n&nbsp; &nbsp; lv_label_set_text(p, \"THEAD\\nMARQUEE\\nDEMO\");\n}\n\nstatic void led_task(void *arg)\n{\n&nbsp; &nbsp; lv_init();\n&nbsp; &nbsp; oled_init();\n&nbsp; &nbsp; lable_test();\n&nbsp; &nbsp; led_pinmux_init();\n\trelay_pinmux_init();\n\trgb_light(255,255,0);\n\n&nbsp; &nbsp; while (1)\n&nbsp; &nbsp; {\n\t\trelay_toggle(true);\n&nbsp; &nbsp; &nbsp; &nbsp; lv_task_handler();\n&nbsp; &nbsp; &nbsp; &nbsp; udelay(1000 * 1000);\n&nbsp; &nbsp; &nbsp; &nbsp; lv_tick_inc(1);\n&nbsp; &nbsp; &nbsp; &nbsp; relay_toggle(false);\n\t\tudelay(1000 * 1000);\n&nbsp; &nbsp; }\n}\n\n</code></pre><h2>云上实验室</h2><p>如果你暂时没有RVB2601开发板，是不是就只能干看了呢？我发现有一个备选方案可以让你体验一下RVB2601开发板，甚至其他型号的RISC-V芯片的开发板：你可以访问平头哥开发者社区提供的<a href=\"https://occ.t-head.cn/community/cloudlab/home\">“云上实验室”</a>服务。</p><p>具体怎么做呢？</p><p>首先，在云上实验室页面的筛选条件区域中，直接选择“开发板型号”为 RVB2601，如图所示，你可以看到可供申请的所有开发板。然后点击“申请评估”，可以看到这个开发板可供选择的空闲日期。你可以根据自己的需求，选择一个合适的时间区间进行申请。</p><p><img src=\"https://static001.geekbang.org/resource/image/95/33/9575a76093f380d38620b290dd878233.png?wh=2448x1246\" alt=\"\"></p><p>当申请通过后，你会收到一条短信提醒。这时，打开云上实验室页面中“我的设备”标签，就可以看到可以使用的开发板了。</p><p><img src=\"https://static001.geekbang.org/resource/image/f0/fb/f0199d684b8a89e371472df0c2a9f6fb.png?wh=834x636\" alt=\"\"></p><p>点击“进入云评估”，你会进入评估控制台，页面中有详细的使用介绍。</p><p>除了体验平台提供的几个demo程序，我们也可以尝试修改一下代码来运行。比如在ch2601_gui_demo 的程序，尝试修改一下屏幕显示的文字。命令可参考图片。</p><p><img src=\"https://static001.geekbang.org/resource/image/41/a2/41f6294796420f35aee97455f4f354a2.png?wh=1614x96\" alt=\"\"></p><p>我改为了下图的内容：</p><p><img src=\"https://static001.geekbang.org/resource/image/ea/96/ea1523b3e3319d6f64d3b4224b0b3f96.png?wh=1376x1084\" alt=\"\"></p><p>然后，在 Host Terminal 命令行输入 make all 编译固件。</p><p><img src=\"https://static001.geekbang.org/resource/image/6f/d3/6fd2c9188f1842yy5b1d1637d76dbcd3.png?wh=1620x56\" alt=\"\"></p><p>接着，输入 make flashall 烧录固件文件到开发板中。</p><p><img src=\"https://static001.geekbang.org/resource/image/c7/a2/c7ed4ea4e8e470d1ac8d84016e70b6a2.png?wh=1690x54\" alt=\"\"></p><p>最终的运行情况，我们可以通过摄像头来查看。</p><p><img src=\"https://static001.geekbang.org/resource/image/c3/c5/c34a27b31d1277fbbbc0d2b55f2e38c5.png?wh=1006x792\" alt=\"\"></p><h2>小结</h2><p>到这里，我们已经熟悉了RVB2601开发板的开发环境，并且完成了智能灯的硬件搭建和嵌入式软件开发。</p><p>你可以看到，当面对一个新的芯片和新的开发板时，我们需要根据GPIO接口的功能来选择合适的接口，比如选择具备PWM功能的接口连接LED模块的R、G、B通道。</p><p>针对RVB2601开发板，PWM输出接口的选择还需要注意一个点——通道（Channel）的选择。CH0/CH1、CH2/CH3、CH4/CH5、CH6/CH7、CH8/CH9和CH10/CH11分别对应编号0～5的6个PWM通道。</p><p>另外，因为现在的实验使用C语言，嵌入式系统应用的开发步骤与之前使用Python语言是不同的，包括下图所示的步骤。</p><p><img src=\"https://static001.geekbang.org/resource/image/50/01/50a9822f97e0ec7a92078bd27yy5f501.png?wh=2046x286\" alt=\"\"></p><p>如果你暂时没有开发板，可以申请体验一下云上实验室。除了可以像我上面提到的那样修改代码来运行，我还推荐你来动手实践一下Linux环境下的开发工具<a href=\"https://yoc.docs.t-head.cn/yocbook/Chapter2-%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B%E6%8C%87%E5%BC%95/YocTools.html\">YocTools</a>的使用方法。</p><h2>思考题</h2><p>最后，我想提出一个挑战，当你完成本节的实验后，是否可以为开发板上自带的用户按键开发代码，实现按键控制继电器通断的功能呢？</p><p>欢迎你在评论区分享自己的挑战成果。基于你完成的智能灯，下一节中，我将介绍一下连接物联网平台，并实现联网控制的方法。同时，也欢迎你把今天的内容分享给你的朋友，一起来“极客”一把。</p>",
                "article_title": "实战一｜嵌入式开发：如何使用C语言开发智能电灯？"
            },
            {
                "title": "实战二｜MQTT开发：如何实现联网控制？",
                "id": 511795,
                "content": "<p>你好，我是郭朝斌。</p><p>在上一节中，我们基于平头哥RVB2601开发板完成了智能电灯硬件的搭建和嵌入式应用的开发，但是打造一款物联网设备，我们还需要将硬件接入物联网平台。接下来，我就来讲解一下RVB2601开发板通过MQTT协议接入阿里云生活物联网平台的流程及方法。</p><p>在开始本节内容的阅读之前，你可以重新打开<a href=\"https://time.geekbang.org/column/article/322528\">第17讲</a>，了解一下Python语言的实现代码。对比着本节的C语言代码，你将会对程序开发有更深入的理解。</p><h2>生活物联网平台的准备工作</h2><p>阿里云生活物联网平台，又称为飞燕平台，是面向消费级产品的物联网开放平台。它具备完整的、面向家居物联网场景的功能定义，可以非常方便地完成智能设备的物联网接入工作。</p><p>接下来，我们就在这个平台上完成智能灯的联网控制实验。</p><h3>创建项目和产品</h3><p>首先，登录<a href=\"https://living.aliyun.com\">生活物联网平台</a>，我们进行第一个项目的创建。项目的名称，我们可以填写“智能电灯”。对于项目类型，你可以根据产品需求来决定，因为我们不计划接入天猫精灵生态，所以这里选择“自有品牌项目”。</p><p><img src=\"https://static001.geekbang.org/resource/image/e8/1c/e8c304c43ed2yyd0ac86c8b1ca50ff1c.png?wh=1014x754\" alt=\"\"></p><p>接着，我们为这个“智能电灯”项目创建一个新产品“Led_1”。</p><p><img src=\"https://static001.geekbang.org/resource/image/15/be/15fac49fc02321208fc2c7e7f08d13be.png?wh=1858x554\" alt=\"\"></p><p>产品的参数可以这样设置：</p><ul>\n<li>所属品类，选择“电工照明”–&gt;“灯”。</li>\n<li>节点设备，选择“设备”。是否接入网关，选择“否”。</li>\n<li>连网方式，选择“WiFi”。</li>\n<li>数据格式，选择“ICA标准数据格式（Alink JSON）”。</li>\n</ul><!-- [[[read_end]]] --><p><img src=\"https://static001.geekbang.org/resource/image/3b/72/3b07a69c927e1044ac15c4fd9fb02c72.png?wh=1220x1062\" alt=\"\"><br>\n<img src=\"https://static001.geekbang.org/resource/image/25/4b/25275157ebd091863bb2f6f79063a04b.png?wh=1220x892\" alt=\"\"></p><h3>产品功能定义</h3><p>创建完产品，我们进入产品的研发流程。物联网平台把流程分为4个阶段，分别是：功能定义、人机交互、设备调试和批量投产。</p><p>首先，我们来完成功能定义的部分，也就是物联网设备的物模型定义。</p><p>基于创建产品时我们选择的产品类型和数据格式，平台已经为智能电灯自动生成了一个标准的物模型。针对你开发的智能灯的功能需求，你可以对各项功能进行编辑、删除，或者新增标准模版没有的功能。比如像我这里展示的一样，保留“开关”、“亮度”和“色温”，删除其他功能项，同时增加“RGB调色”功能。“RGB调色”功能项，对应了我们智能灯的三色LED模块。</p><p><img src=\"https://static001.geekbang.org/resource/image/9c/87/9cc88d1efafd17b3df580c9beb9b9e87.png?wh=1752x968\" alt=\"\"></p><h3>人机交互设计</h3><p>完成功能定义后，我们进入下一步，人机交互。在人机交互中，我们主要完成配网方式和手机App相关界面的设计。</p><p>首先，我们选择使用公版App控制产品。这样可以省掉我们开发独立App的工作。</p><p><img src=\"https://static001.geekbang.org/resource/image/84/d1/840a382b8cd04459fc6d7b1e5ab57bd1.png?wh=2462x454\" alt=\"\"></p><p>在“产品展示”标签页中，设置一下产品名称。</p><p><img src=\"https://static001.geekbang.org/resource/image/f2/25/f277da06b5c5d5e7c4210f22cfe50725.png?wh=2458x896\" alt=\"\"></p><p>在“设备面板”中，你可以点击进入“选择面板”页面，选择一个智能灯在App上的展示和操作界面。因为默认面板中没有适配“RGB调色”的面板，所以，你需要编辑一下“灯泡冷暖灯”模版来替代使用。否则，平台会显示错误信息，提示面板与物模型的属性定义不一致。</p><p><img src=\"https://static001.geekbang.org/resource/image/27/67/274cd8dd412dd288b03d78568e221467.png?wh=1820x1284\" alt=\"\"></p><p>配网方式，我们保持默认设置即可。在“自动化与定时”标签页中，我们要勾选“开关”的“作为执行”选项。这样，在自动化场景的创建中，智能电灯的开关就可以作为执行动作起到控制的效果了。</p><h3>设备调试设置</h3><p>在设备调试页面中，我们需要先选择产品使用的芯片或者模组。对于我们的实验项目，这里直接选择列表最后一项——未知芯片即可。</p><p>然后，我们新建一个测试设备。因为我们需要获得一个设备证书，也就是智能灯连接物联网平台的五元组信息。</p><p>点击“新建测试设备”，你需要为测试设备输入一个名称，比如，可以是“RVB2601HoloLed1”。然后，点击“确定”，页面就会新增一个设备条目。</p><p><img src=\"https://static001.geekbang.org/resource/image/65/64/652c6d5cd03a189fe9f81ab7d9aa6164.png?wh=1172x630\" alt=\"\"></p><p>在新增设备条目中，点击“设备证书”，你就可以看到设备五元组信息。这里要记得复制、保存这些字符串，因为我们在后面的应用代码中需要用到。</p><p><img src=\"https://static001.geekbang.org/resource/image/f3/27/f31999ae09b207dbfedc5244ceb7c027.png?wh=1176x756\" alt=\"\"></p><p>你可以看到，这个新增测试设备的状态显示“未激活”。因为只有当设备通过MQTT协议第一次连接到物联网平台后，这个测试设备才会被激活，并且可以发送消息进行在线调试。</p><h2>智能灯如何接入物联网</h2><p>那么，智能灯如何接入物联网平台实现后续的调试、使用呢？下面，我们来开发一下智能灯的联网控制功能。</p><h3>联网功能开发</h3><p>RVB2601开发板中的W800模组提供了Wi-Fi和BLE通信能力，而且模组还集成了连接阿里云生活物联网平台（飞燕）的功能。主控芯片CH2601通过SPI接口与W800模组通信，它只需要发送/接收W800定义的AT指令，就可以实现相应的功能。</p><p>W800模组的AT指令集可以参考<a href=\"https://occ-oss-prod.oss-cn-hangzhou.aliyuncs.com/userFiles/3717897501090217984/resource/3717897501090217984XBSRZBtccb.pdf\">官方文档</a>。我们就基于文档中飞燕平台的相关AT指令来实现与平台的通信。它的底层实现依然是MQTT协议，不过封装成了AT指令的接口形式。</p><p>这里，我们就需要修改W800的驱动代码，增加联网接口函数，其中具体包括：</p><ul>\n<li>设置设备五元组接口</li>\n<li>建立MQTT连接接口</li>\n<li>物模型属性设置回调注册接口</li>\n<li>物模型属性上报接口</li>\n</ul><p>具体要怎么做呢？</p><p>我们需要在项目中引入W800的驱动模块drv_wifi_at_w800。在CDK中，点击右键打开“Packages for Led”，在模块窗口左侧找到drv_wifi_at_w800模块，点击箭头导入右侧列表中。</p><p><img src=\"https://static001.geekbang.org/resource/image/6f/2f/6fd57acd5c77daa65d1484fde6a3652f.png?wh=620x458\" alt=\"\"><br>\n<img src=\"https://static001.geekbang.org/resource/image/ca/6f/ca8410036690753cd7fa27ceaa87c76f.png?wh=1247x846\" alt=\"\"></p><p>在W800的驱动模块drv_wifi_at_w800中，打开w800_api.h文件，增加函数接口定义。</p><pre><code class=\"language-c++\">int w800_living_idmau(const char *mykey,const char *myname,const char *mysecret,const char *mypsecret);\nint w800_living_idmcon(void);\nvoid w800_living_recv_callback_register(const char *cmd, void *callback, void *context);\nint w800_living_send_attribute(const char *dev_id, const char *msg);\n</code></pre><p>在w800_api.c文件中，增加函数接口的实现代码。</p><pre><code class=\"language-c++\">int w800_living_idmau(const char *mykey,const char *myname,const char *mysecret,const char *mypsecret)\n{\n\tint ret = -1;\n\t\n\taos_mutex_lock(&amp;g_cmd_mutex,AOS_WAIT_FOREVER);\n\t\n\tatparser_clr_buf(g_atparser_uservice_t);\n\t\n\tif (atparser_send(g_atparser_uservice_t,\n\t\t\"AT+IDMAU=\\\"%s\\\",\\\"%s\\\",\\\"%s\\\",\\\"%s\\\"\", mykey, myname, mysecret, mypsecret) == 0) {\n\t\tif (atparser_recv(g_atparser_uservice_t, \"OK\\n\") == 0) {\n\t\t\tret = 0;\n\t\t}\n\t\telse {\n\t\t\tprintf(\"Destination Host Unreachable!\\r\\n\");\n\t\t}\n\t}\n\t\n\tatparser_cmd_exit(g_atparser_uservice_t);\n\t\n\tif (ret == 0) {\n\t\tprintf(\"key = %s name = %s secret = %s psecret = %s!\\r\\n\", mykey, myname, mysecret, mypsecret);\n\t}\n\t\n\taos_mutex_unlock(&amp;g_cmd_mutex);\n\treturn ret;\n}\n\nint w800_living_idmcon(void)\n{\n\tint ret = -1;\n\t\n\taos_mutex_lock(&amp;g_cmd_mutex,AOS_WAIT_FOREVER);\n\t\n\tatparser_clr_buf(g_atparser_uservice_t);\n\t\n\tif (atparser_send(g_atparser_uservice_t, \"AT+IDMCON\") == 0) {\n\t\tif (atparser_recv(g_atparser_uservice_t, \"OK\\n\") == 0) {\n\t\t\tret = 0;\n\t\t} else {\n\t\t\tprintf(\"Destination Host Unreachable!\\r\\n\");\n\t\t}\n\t}\n\t\n\tatparser_cmd_exit(g_atparser_uservice_t);\n\t\n\tif (ret == 0) {\n\t\tprintf(\"AT+IDMCON \\r\\n\");\n\t}\n\t\n\taos_mutex_unlock(&amp;g_cmd_mutex);\n\treturn ret;\n}\n\nvoid w800_living_recv_callback_register(const char *cmd, void *callback, void *context)\n{\n&nbsp; &nbsp; atparser_oob_create(g_atparser_uservice_t, cmd, callback, context);\n}\n\nint w800_living_send_attribute(const char *dev_id, const char *msg)\n{\n&nbsp; &nbsp; int ret = -1;\n&nbsp; &nbsp;&nbsp;\n&nbsp; &nbsp; if (!dev_id || !msg) {\n&nbsp; &nbsp; &nbsp; &nbsp; return ret;\n&nbsp; &nbsp; }\n\t\n&nbsp; &nbsp; aos_mutex_lock(&amp;g_cmd_mutex, AOS_WAIT_FOREVER);\n\t\n&nbsp; &nbsp; atparser_clr_buf(g_atparser_uservice_t);\n\t\n&nbsp; &nbsp; printf(\"Send msg: %s\\r\\n\", msg);\n&nbsp; &nbsp; if (atparser_send(g_atparser_uservice_t, \"AT+IDMPP=0,\\\"%s\\\"\", msg) == 0) {\n&nbsp; &nbsp; &nbsp; &nbsp; if (atparser_recv(g_atparser_uservice_t, \"OK\\n\") == 0) {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ret = 0;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; printf(\"Send at cmd ok\\n\");\n&nbsp; &nbsp; &nbsp; &nbsp; }\n&nbsp; &nbsp; } else {\n&nbsp; &nbsp; &nbsp; &nbsp; printf(\"Send at cmd err\\n\");\n&nbsp; &nbsp; }\n\t\n&nbsp; &nbsp; atparser_cmd_exit(g_atparser_uservice_t);\n\t\n&nbsp; &nbsp; aos_mutex_unlock(&amp;g_cmd_mutex);\n\n&nbsp; &nbsp; return ret;\n}\n</code></pre><p>这里，物模型属性设置回调注册接口的实现采用了非侵入的方式，以尽量减少对原代码的修改。所以，这就需要接口调用者，在应用代码中明确地指定AT指令的代码。通常来说，更好的实现方式是通过消息机制来实现，但是这需要定义唯一的、不冲突的消息编号，并且在w800_module_init函数体中增加回调注册代码，侵入性太大，所以并没有选择这样的实现方式。</p><h3>智能灯平台交互的封装</h3><p>对于智能灯与平台之间的交互逻辑，我们可以新建代码来封装实现。在C语言中，为方便接口函数的调用，我们需要先新建一个头文件—— app_living.h 。</p><pre><code class=\"language-c++\">#ifndef __APP_LIVING_H__\n#define __APP_LIVING_H__\n\n#include &lt;uservice/eventid.h&gt;\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n#define EVENT_LIVING_ATTR_POWER&nbsp; &nbsp; &nbsp; &nbsp;(EVENT_USER + 1)\n#define EVENT_LIVING_ATTR_BRIGHTNESS&nbsp; (EVENT_USER + 2)\n#define EVENT_LIVING_ATTR_COLOR&nbsp; &nbsp; &nbsp; &nbsp;(EVENT_USER + 3)\n\ntypedef struct RgbColor\n{\n&nbsp; &nbsp; unsigned char r;\n&nbsp; &nbsp; unsigned char g;\n&nbsp; &nbsp; unsigned char b;\n} RgbColor;\n\nvoid update_attr(uint8_t powerstate, uint8_t bright, RgbColor rgb);\n\nint connect_iot_demo(void);\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif /* __APP_LIVING_H__ */\n</code></pre><p>然后，新建app_living.c源文件来实现代码逻辑。为了解析从平台发送的JSON格式消息，我们引入了cJSON模块。</p><pre><code class=\"language-c++\">#include &lt;stdlib.h&gt;\n#include &lt;string.h&gt;\n#include &lt;aos/debug.h&gt;\n#include &lt;devices/w800.h&gt;\n#include &lt;yoc/atparser.h&gt;\n#include \"cJSON.h\"\n#include \"app_living.h\"\n\n#define TAG \"app_living\"\n\nextern int w800_living_idmau(const char *mykey,const char *myname,const char *mysecret,const char *mypsecretconst);\nextern int w800_living_idmcon(void);\nextern void w800_living_recv_callback_register(const char *cmd, void *callback, void *context);\nextern int w800_living_send_attribute(const char *dev_id, const char *msg);\n\nvoid update_attr(uint8_t powerstate, uint8_t bright, RgbColor rgb)\n{\n\tprintf(\"enter update \\n\");\n\tconst char *dev_id = \"0\";\n\tchar msg[128] = {0};\n\tconst char *msg_format = \"{\\\\\\\"powerstate\\\\\\\":%d,\\\\\\\"brightness\\\\\\\":%d,\\\\\\\"RGBColor\\\\\\\":{\\\\\\\"Red\\\\\\\":%d,\\\\\\\"Green\\\\\\\":%d,\\\\\\\"Blue\\\\\\\":%d}}\";\n\t\n\tsprintf(msg, msg_format, powerstate, bright, rgb.r,rgb.g,rgb.b);\n\t\n\tw800_living_send_attribute(dev_id, msg);\n}\n\nstatic int parse_living_msg(const char *msg)\n{\n&nbsp; &nbsp; cJSON *root = NULL;\n\n&nbsp; &nbsp; /* Parse Root */\n&nbsp; &nbsp; root = cJSON_Parse(msg);\n&nbsp; &nbsp; if (root == NULL || !cJSON_IsObject(root)) {\n&nbsp; &nbsp; &nbsp; &nbsp; printf(\"JSON Parse Error\\n\");\n&nbsp; &nbsp; &nbsp; &nbsp; return -1;\n&nbsp; &nbsp; }\n&nbsp; &nbsp; cJSON *item = cJSON_GetObjectItem(root, \"powerstate\");\n\tstatic uint8_t power_on;\n&nbsp; &nbsp; if (item &amp;&amp; cJSON_IsNumber(item)) {\n&nbsp; &nbsp; &nbsp; &nbsp; if (item-&gt;valueint) {\n\t\t\tpower_on = 1;\n&nbsp; &nbsp; &nbsp; &nbsp; } else {\n\t\t\tpower_on = 0;\n&nbsp; &nbsp; &nbsp; &nbsp; }\n\t\tevent_publish(EVENT_LIVING_ATTR_POWER, &amp;power_on);\n&nbsp; &nbsp; }\n\n&nbsp; &nbsp; item = cJSON_GetObjectItem(root, \"brightness\");\n\tstatic uint8_t bright;\n&nbsp; &nbsp; if (item &amp;&amp; cJSON_IsNumber(item)) {\n\t\tbright = item-&gt;valueint;\n\t\tevent_publish(EVENT_LIVING_ATTR_BRIGHTNESS, &amp;bright);\n&nbsp; &nbsp; }\n\t\n\titem = cJSON_GetObjectItem(root, \"RGBColor\");\n\tstatic RgbColor rgb;\n\tif (item &amp;&amp; cJSON_IsObject(item)) {\n\t\tcJSON *sub_item = cJSON_GetObjectItem(item, \"Red\");\n\t\tif (sub_item &amp;&amp; cJSON_IsNumber(sub_item)) {\n\t\t\trgb.r = sub_item-&gt;valueint;\n\t\t}\n\t\tsub_item = cJSON_GetObjectItem(item, \"Green\");\n\t\tif (sub_item &amp;&amp; cJSON_IsNumber(sub_item)) {\n\t\t\trgb.g = sub_item-&gt;valueint;\n\t\t}\n\t\tsub_item = cJSON_GetObjectItem(item, \"Blue\");\n\t\tif (sub_item &amp;&amp; cJSON_IsNumber(sub_item)) {\n\t\t\trgb.b = sub_item-&gt;valueint;\n\t\t}\n\t\tevent_publish(EVENT_LIVING_ATTR_COLOR, &amp;rgb);\n\t}\n\n&nbsp; &nbsp; cJSON_Delete(root);\n\n&nbsp; &nbsp; return 0;\n}\n\nstatic int living_set_attr_callback(atparser_uservice_t *at, void *priv, oob_data_t *oob_data)\n{\n\tint did = 0;\n\tint len = 0;\n\tchar msg[128] = {0};\n\tchar *str = strchr(oob_data-&gt;buf, ':');\n\tif (str != NULL) {\n\t\tsscanf(oob_data-&gt;buf, \"%d,%d,%s\\r\\n\", &amp;did, &amp;len, msg);\n\t\tLOGD(TAG,\"==&gt;recv data %d(%d):%s\\r\\n\",did, len, msg);\n\t\tparse_living_msg(msg);\n\t\toob_data-&gt;used_len = len;\n\t}\n\n&nbsp; &nbsp; return 0;\n}\n\nint connect_iot_demo(void)\n{\n\tchar *my_key = \"a1AMULi68xV\";//ProductKey\n\tchar *my_name = \"RVB2601GeekHoloLed1\";//DeviceName\n\tchar *my_secret = \"fcdf55e206b907d649e2249aed8c948a\";//DeviceSecret\n\tchar *my_p_secret = \"BReZtzPVrLcdY1H4\";//Product Secret\n\n\tint ret2 = -1;\n\tint ret3 = -1;\n\n\tw800_living_recv_callback_register(\"+IDMPS:\", living_set_attr_callback, NULL);\n\n\tret2 = w800_living_idmau(my_key,my_name,my_secret,my_p_secret);\n\t\n\tif (ret2 == 0){\n\t\tprintf(\"AT+IDMAU:OK!\\n\");\n\t} else {\n\t\tprintf(\"AT+IDMAU:ERROR!\\n\");\n\t}\n\t\n\tret3 = w800_living_idmcon();\n\tif (ret3 == 0){\n\t\tprintf(\"AT+IDMCON:OK!\\n\");\n\t} else {\n\t\tprintf(\"AT+IDMCON:ERROR!\\n\");\n\t}\n\t\n\tif(ret2 == 0 &amp;&amp; ret3 == 0){\n\t\treturn 0;\n\t}else{\n\t\treturn -1;\n\t}\n}\n</code></pre><blockquote>\n<p>注意替换上面代码中connect_iot_demo函数使用的设备五元组信息。</p>\n</blockquote><h3>LED颜色控制实现</h3><p>为了控制亮度，我们也需要对上一节中的LED控制代码进行改造，具体代码如下。</p><pre><code class=\"language-c++\">\n/*********************\n&nbsp;*&nbsp; &nbsp; &nbsp; INCLUDES\n&nbsp;*********************/\n#define _DEFAULT_SOURCE /* needed for usleep() */\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;unistd.h&gt;\n#include &lt;time.h&gt;\n#include &lt;aos/aos.h&gt;\n#include \"app_config.h\"\n#include \"app_main.h\"\n#include \"csi_config.h\"\n\n#include \"board_config.h\"\n#include \"drv/gpio_pin.h\"\n#include &lt;drv/pin.h&gt;\n#include &lt;drv/pwm.h&gt;\n\n#ifdef CONFIG_PWM_MODE\n\nstatic csi_pwm_t&nbsp; r;\n\nvoid led_pinmux_init()\n{\n&nbsp; &nbsp; &nbsp; &nbsp; //7\n&nbsp; &nbsp; csi_error_t ret;\n&nbsp; &nbsp; csi_pin_set_mux(PA7, PA7_PWM_CH7);\n&nbsp; &nbsp; csi_pin_set_mux(PA25, PA25_PWM_CH2);\n&nbsp; &nbsp; csi_pin_set_mux(PA4, PA4_PWM_CH4);\n\n&nbsp; &nbsp; ret = csi_pwm_init(&amp;r, 0);\n&nbsp; &nbsp; if (ret != CSI_OK) {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; printf(\"===%s, %d\\n\", __FUNCTION__, __LINE__);\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return ;\n&nbsp; &nbsp; }\n}\n\nvoid rgb_light(uint32_t red, uint32_t green, uint32_t blue, uint8_t brightness)\n{\n\tcsi_error_t ret;\n\tret = csi_pwm_out_config(&amp;r, 7 / 2, 300, red*300*brightness/100/255, PWM_POLARITY_HIGH);\n&nbsp; &nbsp; if (ret != CSI_OK) {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; printf(\"===%s, %d\\n\", __FUNCTION__, __LINE__);\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return ;\n&nbsp; &nbsp; }\n&nbsp; &nbsp; ret = csi_pwm_out_start(&amp;r, 7 / 2);\n&nbsp; &nbsp; if (ret != CSI_OK) {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; printf(\"===%s, %d\\n\", __FUNCTION__, __LINE__);\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return ;\n&nbsp; &nbsp; }\n&nbsp; &nbsp; &nbsp; &nbsp; //25\n&nbsp; &nbsp; ret = csi_pwm_out_config(&amp;r, 2 / 2, 300, green*300*brightness/100/255, PWM_POLARITY_HIGH);\n&nbsp; &nbsp; if (ret != CSI_OK) {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; printf(\"===%s, %d\\n\", __FUNCTION__, __LINE__);\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return ;\n&nbsp; &nbsp; }\n&nbsp; &nbsp; ret = csi_pwm_out_start(&amp;r, 2 / 2);\n&nbsp; &nbsp; if (ret != CSI_OK) {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; printf(\"===%s, %d\\n\", __FUNCTION__, __LINE__);\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return ;\n&nbsp; &nbsp; }\n&nbsp; &nbsp; &nbsp; &nbsp; //4\n&nbsp; &nbsp; ret = csi_pwm_out_config(&amp;r, 4 / 2, 300, blue*300*brightness/100/255, PWM_POLARITY_HIGH);\n&nbsp; &nbsp; if (ret != CSI_OK) {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; printf(\"===%s, %d\\n\", __FUNCTION__, __LINE__);\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return ;\n&nbsp; &nbsp; }\n&nbsp; &nbsp; ret = csi_pwm_out_start(&amp;r, 4 / 2);\n&nbsp; &nbsp; if (ret != CSI_OK) {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; printf(\"===%s, %d\\n\", __FUNCTION__, __LINE__);\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return ;\n&nbsp; &nbsp; }\n}\n#endif&nbsp;\n\n#ifdef CONFIG_GPIO_MODE\nstatic uint32_t g_ctr = 0;\nstatic csi_gpio_pin_t r;\nstatic csi_gpio_pin_t g;\nstatic csi_gpio_pin_t b;\nvoid led_pinmux_init()\n{\n&nbsp; &nbsp; csi_pin_set_mux(PA7, PIN_FUNC_GPIO);\n&nbsp; &nbsp; csi_pin_set_mux(PA25, PIN_FUNC_GPIO);\n&nbsp; &nbsp; csi_pin_set_mux(PA4, PIN_FUNC_GPIO);\n&nbsp; &nbsp; csi_gpio_pin_init(&amp;r, PA7);\n&nbsp; &nbsp; csi_gpio_pin_dir(&amp;r, GPIO_DIRECTION_OUTPUT);\n\tcsi_gpio_pin_mode(&amp;r, GPIO_MODE_PUSH_PULL);\n&nbsp; &nbsp; csi_gpio_pin_init(&amp;g, PA25);\n&nbsp; &nbsp; csi_gpio_pin_dir(&amp;g, GPIO_DIRECTION_OUTPUT);\n\tcsi_gpio_pin_mode(&amp;g, GPIO_MODE_PUSH_PULL);\n&nbsp; &nbsp; csi_gpio_pin_init(&amp;b, PA4);\n&nbsp; &nbsp; csi_gpio_pin_dir(&amp;b, GPIO_DIRECTION_OUTPUT);\n\tcsi_gpio_pin_mode(&amp;b, GPIO_MODE_PUSH_PULL);\n&nbsp; &nbsp; g_ctr = 0;\n}\n\n//fake rgb, because of only high or low state of gpio\nvoid rgb_light(uint32_t red, uint32_t green, uint32_t blue)\n{\n\t(red &lt; 50)?csi_gpio_pin_write(&amp;r, GPIO_PIN_LOW):csi_gpio_pin_write(&amp;r, GPIO_PIN_HIGH);\n\t(green &lt; 50)?csi_gpio_pin_write(&amp;r, GPIO_PIN_LOW):csi_gpio_pin_write(&amp;g, GPIO_PIN_HIGH);\n\t(blue &lt; 50)?csi_gpio_pin_write(&amp;r, GPIO_PIN_LOW):csi_gpio_pin_write(&amp;b, GPIO_PIN_HIGH);\n}\n#endif\n\n</code></pre><h3>继电器状态获取实现</h3><p>为了获取继电器状态，也就是LED灯的开关状态，我们同样需要对继电器代码进行改造。具体代码如下。</p><pre><code class=\"language-c++\">/*********************\n&nbsp;*&nbsp; &nbsp; &nbsp; INCLUDES\n&nbsp;*********************/\n#define _DEFAULT_SOURCE /* needed for usleep() */\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;unistd.h&gt;\n#include &lt;time.h&gt;\n#include &lt;aos/aos.h&gt;\n#include \"app_config.h\"\n#include \"csi_config.h\"\n#include \"app_main.h\"\n\n#include \"board_config.h\"\n#include \"drv/gpio_pin.h\"\n#include &lt;drv/pin.h&gt;\n\nstatic csi_gpio_pin_t relay;\n\nunsigned char get_state()\n{\n\treturn csi_gpio_pin_read(&amp;relay);\n}&nbsp;\n\nvoid relay_pinmux_init()&nbsp;\n{\n\tcsi_pin_set_mux(PA26, PIN_FUNC_GPIO);\n\tcsi_gpio_pin_init(&amp;relay, PA26);\n&nbsp; &nbsp; csi_gpio_pin_dir(&amp;relay, GPIO_DIRECTION_OUTPUT);\n}\n\nvoid relay_toggle(bool on)\n{\n\tif(on)\n\t{\n\t\tcsi_gpio_pin_write(&amp;relay, GPIO_PIN_HIGH);\n\t}&nbsp;\n\telse&nbsp;\n\t{\n\t\tcsi_gpio_pin_write(&amp;relay, GPIO_PIN_LOW);\n\t}\n}\n\n</code></pre><h3>网络初始化实现</h3><p>在编写应用的主逻辑之前，我们需要先对RVB2601开发板进行初始化。其中，网络初始化是我们为实现联网新增的代码逻辑。</p><p>网络初始化分为两步。第一步是初始化W800模块：在设置好GPIO口、波特率和缓冲大小后，通过调用wifi_w800_register函数初始化；第二步是配置网络管理器（netmgr）模块：这里你需要将netmgr_config_wifi函数中的入参替换成自己的Wi-Fi网络SSID和密码，并且注意修改入参中的数字为SSID字符串和密码字符串的长度。</p><pre><code class=\"language-c++\">#include &lt;stdbool.h&gt;\n#include &lt;aos/kv.h&gt;\n#include &lt;yoc/partition.h&gt;\n#include &lt;yoc/init.h&gt;\n#include &lt;drv/pin.h&gt;\n#include &lt;yoc/at_port.h&gt;\n#include &lt;devices/w800.h&gt;\n#include &lt;devices/drv_snd_alkaid.h&gt;\n\n#include \"app_main.h\"\n#include \"board.h\"\n\n#define TAG \"init\"\n\nnetmgr_hdl_t app_netmgr_hdl;\nextern at_channel_t spi_channel;\n\nstatic void network_init()\n{\n&nbsp; &nbsp; w800_wifi_param_t w800_param;\n&nbsp; &nbsp; /* init wifi driver and network */\n&nbsp; &nbsp; w800_param.reset_pin&nbsp; &nbsp; &nbsp; = PA21;\n&nbsp; &nbsp; w800_param.baud&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 1*1000000;\n&nbsp; &nbsp; w800_param.cs_pin&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= PA15;\n&nbsp; &nbsp; w800_param.wakeup_pin&nbsp; &nbsp; &nbsp;= PA25;\n&nbsp; &nbsp; w800_param.int_pin&nbsp; &nbsp; &nbsp; &nbsp; = PA22;\n&nbsp; &nbsp; w800_param.channel_id&nbsp; &nbsp; &nbsp;= 0;\n&nbsp; &nbsp; w800_param.buffer_size&nbsp; &nbsp; = 4*1024;\n\n&nbsp; &nbsp; wifi_w800_register(NULL, &amp;w800_param);\n&nbsp; &nbsp; app_netmgr_hdl = netmgr_dev_wifi_init();\n\n&nbsp; &nbsp; if (app_netmgr_hdl) {\n&nbsp; &nbsp; &nbsp; &nbsp; utask_t *task = utask_new(\"netmgr\", 2 * 1024, QUEUE_MSG_COUNT, AOS_DEFAULT_APP_PRI);\n&nbsp; &nbsp; &nbsp; &nbsp; netmgr_service_init(task);\n&nbsp; &nbsp; &nbsp; &nbsp; netmgr_config_wifi(app_netmgr_hdl, \"你的wifi SSID\", 11, \"你的wifi AP密码\", 11);\n&nbsp; &nbsp; &nbsp; &nbsp; netmgr_start(app_netmgr_hdl);\n&nbsp; &nbsp; }\n}\n\nvoid board_yoc_init(void)\n{\n&nbsp; &nbsp; board_init();\n&nbsp; &nbsp; event_service_init(NULL);\n&nbsp; &nbsp; console_init(CONSOLE_UART_IDX, 115200, 512);\n&nbsp; &nbsp; ulog_init();\n&nbsp; &nbsp; aos_set_log_level(AOS_LL_DEBUG);\n\n&nbsp; &nbsp; int ret = partition_init();\n&nbsp; &nbsp; if (ret &lt;= 0) {\n&nbsp; &nbsp; &nbsp; &nbsp; LOGE(TAG, \"partition init failed\");\n&nbsp; &nbsp; } else {\n&nbsp; &nbsp; &nbsp; &nbsp; LOGI(TAG, \"find %d partitions\", ret);\n&nbsp; &nbsp; }\n\n&nbsp; &nbsp; aos_kv_init(\"kv\");\n\n&nbsp; &nbsp; network_init();\n\n&nbsp; &nbsp; board_cli_init();\n}\n\n</code></pre><h3>智能灯主逻辑实现</h3><p>在完成了W800驱动程序的增补、平台交互功能的封装以及LED模块、继电器代码的改造等一系列准备之后，我们就可以编写智能灯的主逻辑了。智能灯的主逻辑在app_main.c文件中实现。</p><p>主逻辑包含几个模块：首先是初始化开发板、LED灯和继电器模块；然后是注册网络管理器事件的回调函数，和注册我们在平台交互模块中定义的属性设置事件的回调函数；最后，就是在while循环中建立物联网平台连接，并定期上报智能灯状态。</p><p>我们看一下具体的代码：</p><pre><code class=\"language-c++\">#include &lt;stdlib.h&gt;\n#include &lt;string.h&gt;\n#include &lt;aos/list.h&gt;\n#include &lt;aos/debug.h&gt;\n#include &lt;uservice/uservice.h&gt;\n#include &lt;uservice/eventid.h&gt;\n#include &lt;yoc/sysinfo.h&gt;\n#include &lt;board.h&gt;\n#include \"drv/gpio_pin.h\"\n#include &lt;drv/pin.h&gt;\n#include &lt;drv/pwm.h&gt;\n#include \"app_living.h\"\n#include \"app_main.h\"\n\n#define TAG \"APP\"\n\nstatic bool g_wifi_ok;\nstatic uint8_t led_brightness;\nstatic RgbColor led_color;\n\nstatic void led_control(uint8_t power) {\n\trelay_toggle(power);\n}\n\nstatic void led_set_brightness(uint8_t bright) {\n\tled_brightness = bright;\n\trgb_light(led_color.r, led_color.g, led_color.b, bright);\n}\n\nstatic void led_set_color(RgbColor color) {\n\tled_color.r = color.r;\n\tled_color.g = color.g;\n\tled_color.b = color.b;\n\trgb_light(color.r, color.g, color.b, led_brightness);\n}\n\nstatic void living_event(uint32_t event_id, const void *param, void *context)\n{\n\tswitch(event_id) {\n&nbsp; &nbsp; case EVENT_LIVING_ATTR_POWER:\n&nbsp; &nbsp; &nbsp; &nbsp; printf(\"set attr power:%d\\n\", *(uint8_t *)param);\n\t\tled_control(*(uint8_t *)param);\n&nbsp; &nbsp; &nbsp; &nbsp; break;\n&nbsp; &nbsp; case EVENT_LIVING_ATTR_BRIGHTNESS:\n&nbsp; &nbsp; &nbsp; &nbsp; printf(\"set attr bright:%d\\n\", *(uint8_t *)param);\n\t\tled_set_brightness(*(uint8_t *)param);\n&nbsp; &nbsp; &nbsp; &nbsp; break;\n\tcase EVENT_LIVING_ATTR_COLOR:\n\t\tprintf(\"set attr color\\n\");\n\t\tled_set_color(*(RgbColor *)param);\n\t\tbreak;\n&nbsp; &nbsp;}\n&nbsp; &nbsp; /*do exception process */\n&nbsp; &nbsp; app_exception_event(event_id);\n}\n\nstatic void network_event(uint32_t event_id, const void *param, void *context)\n{\n&nbsp; &nbsp; switch(event_id) {\n&nbsp; &nbsp; case EVENT_NETMGR_GOT_IP:\n&nbsp; &nbsp; &nbsp; &nbsp; LOGD(TAG, \"net got ip\");\n\t\tg_wifi_ok = true;\n&nbsp; &nbsp; &nbsp; &nbsp; break;\n&nbsp; &nbsp; case EVENT_NETMGR_NET_DISCON:\n&nbsp; &nbsp; &nbsp; &nbsp; LOGD(TAG, \"net disconnect\");\n&nbsp; &nbsp; &nbsp; &nbsp; break;\n&nbsp; &nbsp;}\n&nbsp; &nbsp; /*do exception process */\n&nbsp; &nbsp; app_exception_event(event_id);\n}\n\nint main(void)\n{\n\tuint32_t time_cnt = 0;\n\tbool mqtt_conn = false;\n&nbsp; &nbsp; board_yoc_init();\n\t\n\tled_pinmux_init();\n\trelay_pinmux_init();\n\t\n\tled_color.r = 255;\n\tled_color.g = 255;\n\tled_color.b = 0;\n\tled_brightness = 100;\n\trgb_light(led_color.r, led_color.g, led_color.b, led_brightness);\n\trelay_toggle(true);\n\n&nbsp; &nbsp; /* Subscribe */\n&nbsp; &nbsp; event_subscribe(EVENT_NETMGR_GOT_IP, network_event, NULL);\n&nbsp; &nbsp; event_subscribe(EVENT_NETMGR_NET_DISCON, network_event, NULL);\n\tevent_subscribe(EVENT_LIVING_ATTR_POWER, living_event, NULL);\n\tevent_subscribe(EVENT_LIVING_ATTR_BRIGHTNESS, living_event, NULL);\n\tevent_subscribe(EVENT_LIVING_ATTR_COLOR, living_event, NULL);\n\t\n\twhile(1){\n\t\tif (g_wifi_ok) {\n\t\t\tint ret = connect_iot_demo();\n\t\t\tif (ret == 0){\n\t\t\t\tprintf(\"connerct iot success\");\n\t\t\t\tmqtt_conn = true;\n\t\t\t}else{\n\t\t\t\tprintf(\"connerct iot error\");\n\t\t\t}\n\t\t\tg_wifi_ok = false;\n\t\t}\n\t\t\n\t\tif (mqtt_conn &amp;&amp; time_cnt &gt;= 10) {\n\t\t\tupdate_attr(get_state(), led_brightness, led_color);\n\t\t\ttime_cnt = 0;\n\t\t}\n\t\t\n\t\ttime_cnt += 1;\n\t\taos_msleep(500);\n\t}\n&nbsp;\n}\n\n</code></pre><p>最后，主逻辑app_main.c的头文件内容如下，供你参考。其中包含了硬件初始化接口函数，和LED模块、继电器功能接口函数的声明，以便源代码引用。</p><pre><code class=\"language-c++\">/*\n&nbsp;* Copyright (C) 2019-2020 Alibaba Group Holding Limited\n&nbsp;*/\n#ifndef _APP_MAIN_H_\n#define _APP_MAIN_H_\n\n#include &lt;uservice/uservice.h&gt;\n#include &lt;yoc/netmgr_service.h&gt;\n\nvoid board_cli_init();\n\n#include &lt;stdint.h&gt;\nextern netmgr_hdl_t app_netmgr_hdl;\n\nvoid app_exception_event(uint32_t event_id);\nvoid board_yoc_init(void);\nvoid led_pinmux_init();\nvoid rgb_light(uint32_t red, uint32_t green, uint32_t blue, uint8_t brightness);\nvoid relay_pinmux_init();\nvoid relay_toggle(bool on);\nunsigned char get_state();\n\n#endif\n</code></pre><h2>设备调试</h2><p>在完成代码编写后，我们依然按照上一节中步骤，编译——烧录——运行，让智能灯开始工作，并接入物联网平台。</p><p>这时，我们就可以对智能灯进行在线调试了。打开阿里云生活物联网平台的设备调试页面后，我们点击测试设备条目中的“调试”操作，就会进入在线调试页面。</p><p>在调试页面中，我们可以选择调试功能“开关”，方法选择“设置”。下面的消息框中会自动根据物模型准备好JSON格式的消息体。</p><p><img src=\"https://static001.geekbang.org/resource/image/df/7d/df6yy6b7f1d09657cda991e58d1b507d.png?wh=1076x1300\" alt=\"\"></p><p>点击“发送指令”后，这个属性设置消息就会发送到智能灯，实现对智能灯的控制。当然，你也可以选择其他的属性进行设备测试。</p><p>另外，我们还可以在公版云智能App中测试、使用已接入平台的智能灯。这里要怎么实现公版云智能App的控制呢？你需要进入“批量投产”页面，然后点击“配网+App下载二维码”，根据提示下载云智能App到手机。接着，点击“产品发布”完成产品上线。</p><p><img src=\"https://static001.geekbang.org/resource/image/39/49/395747e61c1ebf089810764b9b2bdd49.png?wh=2036x1154\" alt=\"\"></p><p>完成这些准备工作后，你就可以在云智能App中添加我们的测试设备了。这里需要注意的是，要保证App和智能灯设备都连接到同一个Wi-Fi网络中，否则，云智能App是不能发现智能灯设备的。</p><p>App上的具体展示内容如下：</p><p><img src=\"https://static001.geekbang.org/resource/image/06/0d/063f63945f3174f047815bde4c22490d.jpg?wh=1142x795\" alt=\"\"></p><h2>小结</h2><p>到这里，我们就完成了智能灯的联网控制开发任务。</p><p>在实验中，我们使用的物联网平台是阿里云生活物联网平台，整体的创建流程与第17讲的平台类似。重点是物模型的定义和人机交互界面的设计。</p><p>在智能灯的联网控制开发中，我们使用W800模组提供的AT指令来实现平台的交互。AT指令是通信领域常用的控制协议，在嵌入式领域也有广泛的应用，你可以基于本实验对它进行扩展学习。在连接Wi-Fi网络时，我们会使用到YoC嵌入式系统平台提供的网络管理器模块。关于YoC是什么，和模块的关系又是什么，我会在下一节详细讲解。</p><h2>思考题</h2><p>最后，我给你留一个思考题。你可能注意到源代码中有些函数的前面有static关键字，有些函数前面没有这个关键字。比如函数parse_living_msg前面有static，这是为什么呢？欢迎你在评论区写一下自己的理解，也欢迎你将这一节分享给你的朋友，大家一起交流学习。</p>",
                "article_title": "实战二｜MQTT开发：如何实现联网控制？"
            },
            {
                "title": "假期快乐｜这是一份暂时停更的声明",
                "id": 514226,
                "content": "<p>你好，我是晓蕾，这次《物联网开发实战》加更部分的编辑。</p><p>不知道你在这段假期里休息得怎么样，先祝你五一假期快乐！希望你能在这个假期里好好放松，不论是出游还是休息，都做好健康防护。</p><p>很遗憾的是，因为各种不可控因素的影响，朝斌老师的实验和写作计划被打乱了。为了给大家带来更精细的实验讲解以及更完美的实验效果，我们决定延后蓝牙开发这节课的实验更新。</p><p>在目录里你可以看到，我们的更新内容都是以原“实战篇”的实验为基础，在RVB2601开发板上进行的。当然，朝斌老师也希望你能在完成一个个带给自己成就感实验的同时，对C和Python两种语言有更深刻的认知和更系统的比较。准备这样综合的内容的确需要不少时间，我们也希望最终交付出来的内容是值得被更多读者看到的。</p><p>在最近的这段时间里，你也可以顺着上面提到的课程思路，尝试在新的开发板上完成更多自己希望实现的物联网设备功能。当然，如果还没有拿到新的开发板，利用<a href=\"https://occ.t-head.cn/community/cloudlab/home\">云上实验室</a>也是个不错的选择。如果有任何的进展或者疑问，也千万不要忘了咱们的<a href=\"https://jinshuju.net/f/ZQG5ox\">课程交流群</a>哦。</p><p>希望在《实战三｜蓝牙开发：怎样打造无线光照传感器？》中再次见面的时候，我们同样能带给你流畅的实验过程和操作体验。</p><p>最后，再次祝你假期快乐！期待我们的再次见面。</p><!-- [[[read_end]]] -->",
                "article_title": "假期快乐｜这是一份暂时停更的声明"
            }
        ]
    },
    {
        "chapterTitle": "开篇词",
        "children": [
            {
                "title": "开篇词 | 物联网这个趋势，你不应该错过",
                "id": 305523,
                "content": "<p>你好，我是郭朝斌。</p><p>很高兴能有机会和你聊聊物联网，因为我觉得，这是未来的一个趋势，即使你不在这个行业，了解一下也可能会对自己有用。</p><p>可能你已经感受到了，我们身边越来越多的硬件设备正在被嵌入芯片、注入软件，从而实现各种各样的新应用、新功能，比如智能门锁。</p><p>以前我们出门的时候，经常说要带好四样东西，“伸手要钱”，也就是身份证、手机、钥匙和钱包。随着智能手机的发展，我们现在出门已经不需要带钱包了，拿着手机扫二维码，就可以买东西。而智能门锁则让我们省去了带钥匙的麻烦，你输入密码或者指纹就可以开门，甚至还可以远程生成临时密码给别人开门。</p><p>比方说你在外面休假，然后你的亲戚临时要到你家里取东西，你完全可以生成一个临时密码发给他，这样他就可以进去了。</p><p>这些东西，一开始的时候我们都感到很新奇，但是一段时间之后就觉得很自然、很平常了，甚至还会觉得如果离开它们，生活反而会出现问题。</p><p>这一切，正是物联网这一技术趋势的体现。</p><h2>下一个技术风口</h2><p>所谓物联网，其实就是借助互联网的力量，实现万物互联。</p><p>互联网本质上已经实现了人与人、人与信息的连接。那么接下来，人体自身，比如你的各项生理指标；人使用的各种物品，比如水杯、桌子和椅子；甚至人所处的周围环境，例如卧室的温度、湿度和甲醛含量，都会被接入互联网，实现人与物、物与物的连接。</p><!-- [[[read_end]]] --><p>所以说，<strong>物联网是互联网发展的必然趋势。</strong></p><p>这种万物互联的愿景和趋势，无疑会深刻改变我们的生活，重塑农业、制造业、交通、物流、零售和家居等各个领域。</p><p>Gartner 是一个美国的技术咨询公司，每年都会发布一些技术趋势分析报告。它有一个工具叫<a href=\"https://www.gartner.com/en/documents/3947474/hype-cycle-for-the-internet-of-things-2019\">技术成熟度曲线</a>。这个工具会把每一个技术发展的过程分成5个阶段：</p><ul>\n<li>一开始，技术处于<strong>萌芽期</strong>；</li>\n<li>然后，它会迅速到达一个最高点，也就是<strong>期望膨胀期</strong>；</li>\n<li>紧接着，这种技术就会进入<strong>泡沫破裂低谷期</strong>，有些技术在这个阶段已经被验证为不符合实际需求，就淘汰掉了；</li>\n<li>但是还有一些技术，会进入到<strong>稳步爬升恢复期</strong>；</li>\n<li>最后，技术进入到<strong>生产成熟期</strong>。</li>\n</ul><p>现在我们来看一下物联网。Gartner 曾经在 2015 年发布过一个报告，说物联网处于期望膨胀的巅峰；到了2019年，我们再找到它新发布的报告，就会看到智能家居、工业物联网和智能楼宇这些细分的领域，正在从恢复期走向成熟期。我在这里放了一张图，你可以去参考。</p><p><img src=\"https://static001.geekbang.org/resource/image/d4/5f/d4a7f7b2779d821327316b06bd16fa5f.jpg\" alt=\"\" title=\"Gartner 2019年物联网技术成熟曲线（改自Gartner官网）\"></p><p>大公司向来对于技术趋势非常敏感，一方面它们要保持领先，另一方面它们要防止出现颠覆者。我们看看国内的一线技术公司：硬件厂商，如华为、小米；云计算企业和互联网巨头，比如阿里云、腾讯云等，已经纷纷投入大量的人力、资金布局物联网行业。</p><p>面对技术的潮起潮落，吴军博士曾说：<strong>“我们所能做的就是尽量把握每一次技术大潮。”</strong></p><p>公司如此，作为技术人也是这样，顺应技术趋势发展，才能成为时代的弄潮儿。记得在移动互联网刚起步的阶段，大概2013年，我还在诺基亚从事手机相关的开发工作。我有一位同事在那个时候就选择离开诺基亚，加入了 Uber成为中国总部早期成员，后来又去了另一家打车软件公司担任部门总监，实现了能力和职位的火箭式提升。</p><p>也许你也可以像我的这位前同事一样，抓住一个行业的机会，实现自身价值的提升。因为我很看好物联网这个技术趋势，在我看来，物联网就是这样一个机会。它的影响力正在变得越来越大，现在很火热的<strong>新基建</strong>和<strong>数字化转型</strong>都离不开它，所以它将让很多人进入职业发展的快车道。</p><h2>物联网为什么不好懂？</h2><p>如果你主动了解过物联网相关的知识，很可能觉得它们不太好掌握。而且你也会发现，网络上的很多相关资料，大多数内容不成体系，学起来往往不得要领。</p><p>这是为什么呢？因为<strong>物联网涉及的知识非常庞杂</strong>，包括通信技术、嵌入式开发、互联网系统、大数据、人工智能等等，甚至还有相关应用领域的专业知识。比如，你做交通物流方面的应用开发，就得了解交通物流的知识。</p><p>这些知识可以说是“盘根错节”地交织在一起，要求我们得先<strong>具备抽丝剥茧、理清思路的能力</strong>，去看清楚这些技术的作用和相互之间的关系。只有这样，我们才能在物联网这个领域获得快速的成长。</p><p><img src=\"https://static001.geekbang.org/resource/image/71/d7/71c5376c5848f7b2cba2b27eaa16d9d7.png\" alt=\"\"></p><p>因此，在这门课中，我会为你梳理清楚物联网领域庞杂的专业知识，将“庞杂”转变为“条理”，并深入剖析其中的核心技术，最终帮你建立起一个完整的知识体系。</p><p>这个完整的知识体系，可以确保你在任何时候都不会迷路。这样，你对工作中的很多问题就会看得更加清楚，能够逐渐建立架构师的思维能力，为职场中的提升做好“内功”的准备。</p><h2>为什么我能为你讲清楚？</h2><p>你可能想问，既然物联网知识这么难掌握，为什么我可以讲清楚呢？</p><p>其实我也一直有这样的疑惑：我常常觉得自己对于物联网有天然的熟悉感，但是不知道为什么。直到有一次整理简历，我发现这跟我的经历有很大的关系。</p><p>我非常喜欢机器人，研究生时期主要做的研究，就是国自然（国家自然科学基金）资助的机器人相关的课题。我们几个同学还与清华的一位同学组队，代表清华大学参加了RoboCup 机器人竞赛，之后我们又代表自己的学校参加了 FIRA 机器人竞赛，并且获得了几个奖项。</p><p>参加工作后，我在诺基亚做过移动通信、蓝牙等通信技术的相关开发；研究过手机操作系统的底层架构；移植、开发过FireFoxOS这类理念非常超前的手机操作系统；做过比 Apple Watch 还要早的智能手表项目；并且多次参加 Hackathon 比赛。</p><p>后来，创业过程中，我不但做过小米生态的智能硬件（那是小米平台上少有的医药器械设备）；而且还从 0 开始设计、搭建过一个完整的物联网系统，并投入到了几个大型企业的生产环境中。</p><p>正是因为从大学到工作的这些经历，我对<strong>硬件</strong>、<strong>软件</strong>、<strong>通信技术</strong>、<strong>前端</strong>和<strong>后台</strong>都有比较好的掌握，而这正好契合物联网的多种技术融合的特点。所以，我对物联网的整个知识体系非常清楚，并对相关技术有深入研究。</p><h2>怎样高效入门物联网？</h2><p>物联网从整个体系结构来看，可以分为三个层面。</p><p>第一是<strong>设备层</strong>，也就是各种硬件设备。</p><p>设备组件有传感器，比如测量温度、湿度、光照强度等参数的设备；也有执行器，比如控制电路通断的继电器、实现物体移动的马达等。</p><p>物联网设备，不仅涉及传统嵌入式系统的开发，而且也需要考虑通信技术，比如 Wi-Fi、蓝牙和蜂窝网络等。你只有熟悉它们的特点，才能在实践中做出正确的选择。</p><p>第二是<strong>网络层</strong>，主要关注的是设备与物联网平台的通信协议。</p><p>物联网的网络通信仍然是基于互联网的，所以底层还是 TCP/IP 协议。应用中你更多需要了解、掌握的是具体的网络协议，比如 HTTP、MQTT 和 AMQP 等。在做物联网系统设计的时候，你得搞清楚这些协议的适用场景。</p><p>第三是<strong>应用层</strong>，也就是实现具体业务逻辑的地方。</p><p>除了像普通互联网后台一样，要面对服务器框架、数据库系统、消息队列等问题外，物联网系统首先需要处理的就是海量的数据。这又可以分为三个方面：</p><ol>\n<li>数据存储，比如 NoSQL 数据库和时序数据库的选择。</li>\n<li>数据处理，比如 Spark、Flink 等大数据处理框架的不同特点，批处理和流处理的适用场景等。</li>\n<li>数据分析，如各类机器学习算法，甚至 AI 的应用。</li>\n</ol><p>设备层、网络层和应用层这三个层面的知识，都是你在设计和实施一个物联网系统的过程中需要掌握的。另外，现在<strong>数据隐私</strong>和<strong>系统安全</strong>越来越重要，它们贯穿系统的整个生命周期，也是需要你通盘考虑的事情。我提供了一个知识体系图，供你随时查看。</p><p><img src=\"https://static001.geekbang.org/resource/image/a3/64/a324a38ab7d0236bbef0a567288a2264.jpg\" alt=\"\" title=\"物联网知识体系图\"></p><h2>这门课是怎样设计的？</h2><p>我们应该如何高效地学习呢？在这门课里，我将通过三个循序渐进的模块，理论结合动手实践，来帮你构建物联网的知识体系。</p><p>在基础篇，我会带你<strong>快速认识物联网</strong>。</p><p>我将按照设备接入网络、与平台对话、传输数据和利用数据产生价值的路径，介绍物联网系统的基本框架，让你对设备层、网络层和应用层这三大层面留下初步的印象；然后通过智能家居场景的简易IoT系统设计，让你对物联网建立更直观的认知。</p><p>在进阶篇，我会带你掌握<strong>物联网的关键技术</strong>。</p><p>我将结合简易智能家居项目，为你深度剖析物联网三大层面的核心知识点，并对开源生态、用户隐私、系统安全的实践注意事项做针对性的补充。这些知识能帮你做好充足的准备迎接工作实践。</p><p>在实战篇，我会手把手带你<strong>从0开始完成自己的智能家居项目作品</strong>。</p><p>网上虽然已经有一些 DIY 硬件设备的资料，但是大多没有放在物联网的技术背景下去做，只是单机版本的。而这个实战项目，是我为你量身定制的。我将围绕智能家居的简易物联网系统，一步一步讲解实现步骤和注意事项。为了降低难度，我还专门做了两件事：</p><ol>\n<li>我采用了 Python 语言来进行嵌入式系统的开发。就算你是 0 基础，也可以做出自己的小作品。</li>\n<li>我设计了一个<strong>硬件套装</strong>，如有需要，你可以根据<a href=\"https://shimo.im/sheets/D3VVPdwcYRhhQRXh/MODOC\">这份文档</a>自行采购相关硬件。</li>\n</ol><p>你在跟着我动手操作的过程中，肯定会对物联网的核心技术有更深刻的理解。工程项目跟游泳一样，我从来没有见过哪个人是通过看书学会游泳的。你必须不断地在实践中锻炼、提高自己的技能。</p><p>最后，我也特别希望，你能在部落里晒出自己的实战作品，跟其他同学一起学习交流。</p><p>在这三个模块之外，我还会时不时为你加个餐，介绍一下物联网的<strong>未来发展趋势</strong>和<strong>重点实践领域</strong>，比如 5G 等新型通信技术的应用。</p><p>期待能通过这门课程帮助你在物联网领域实现自己的成就，在职场获得更大的提升。让我们一起做<strong>万物互联时代的懂行者</strong>吧！</p><p>欢迎你把课程分享给同样对物联网感兴趣的朋友，一起进步；也请你多多给我留言，说说自己对这门课的期待，或者目前遇到的困惑，我一定会认真答复。</p><p>我是郭朝斌，我们下一讲见！</p>",
                "article_title": "开篇词 | 物联网这个趋势，你不应该错过"
            }
        ]
    },
    {
        "chapterTitle": "基础篇",
        "children": [
            {
                "title": "01 | 入门介绍：如何定义物联网？",
                "id": 305545,
                "content": "<p>你好，我是郭朝斌。</p><p>在课程的第一讲，我想跟你讨论一个入门级的问题：怎么定义物联网呢？</p><p>看到这个问题，你肯定希望我直接给你一个一针见血的定义，帮你打通认识物联网的任督二脉。</p><p>但是我跟你说实话，定义物联网真的不是一件容易的事情。因为物联网行业是一个新兴行业，它的内涵和外延都在发展变化的过程当中。今天是智能家居、智慧城市，明天是车联网、边缘计算，未来还会有更多……新的应用和新的理念还在源源不断地出现。</p><p>那么，我们还有办法讲清楚物联网这个概念吗？别着急，我想请你先思考一个问题，说到物联网，你会想到哪些关键词呢？是不是包括这些：<strong>互联网，传感器，5G，云计算，MQTT，大数据，人工智能，智能家居</strong>……</p><p>其实，只要你搞清楚它们跟物联网的关系，也就知道物联网到底是怎么一回事儿了。</p><h2>1. 物联网和互联网有什么关系？</h2><p>我先来说说物联网和互联网的关系，因为很多人都对这两个概念“傻傻分不清楚”。</p><p>有人说，物联网和互联网没有区别，手机也是一个物品，所以移动互联网就是一个物联网。</p><p>这种说法并不准确，因为他没有看到手机的本质。</p><p>手机本质上是一个移动化的电脑设备：</p><ul>\n<li>电脑的鼠标点击，变成了手机的手指触摸；</li>\n<li>电脑的实体键盘，变成了手机上的虚拟按键；</li>\n<li>电脑联网要用Wi-Fi或网线，手机也可以用Wi-Fi，但舍弃了网线，支持移动蜂窝网络；</li>\n<li>电脑的摄像头、音箱、麦克风，集成到手机上时都进行了小型化……</li>\n</ul><!-- [[[read_end]]] --><p>这也是为什么主导手机行业发展的企业，和主导电脑行业发展的企业一样，仍然是操作系统厂商和芯片厂商。谷歌就相当于微软，高通就相当于英特尔。 当然，还有同时控制操作系统和芯片的苹果公司，它在手机和电脑行业都很有分量。</p><p>所以手机和电脑一样，仍然是<strong>围绕人的需求来设计的设备</strong>。</p><p>人是信息的“生产者”，手机为人生产信息提供各种工具。这些信息可能是一篇微信公众号文章，一条语音消息，或者一段抖音短视频。</p><p>同时，人也是信息的“消费者”。这些信息的各种媒体形式都是给人浏览、收听和观看的。</p><p>所以我说，互联网是连接人，连接人与信息。人和信息的关系就像下面这张图所展示的：</p><p><img src=\"https://static001.geekbang.org/resource/image/9b/11/9b599f91e0c233d04907f175dbd6bc11.jpg\" alt=\"\" title=\"传统互联网中人和信息的关系\"></p><p>那么，物联网和互联网相比，最本质的区别是什么呢？答案就是，<strong>设备（物）</strong>成了另一个重要的参与主体。设备跟人一样，也是信息的生产者和消费者。</p><p>怎么理解呢？我举一个例子。在智能家居的安防设计中，有一种磁力传感器，它可以监测你家窗户的开关状态。比如，当它发现窗户被打开时，这个信息将传送到云端服务器，然后服务器就会下放指令给监控摄像头，让摄像头拍摄照片、录制视频，并且推送给你。</p><p>这个过程中，磁力传感器“生产”了窗户打开这个信息，而监控摄像头和人“消费”了这个信息。这个安防系统就是在你家时刻待命的“电子保安”，跟真人保安有类似的功能。这种情况下，人、信息和设备的关系可以参见下图：</p><p><img src=\"https://static001.geekbang.org/resource/image/e9/5d/e98f15af3abc831ddf781beafc241c5d.jpg\" alt=\"\" title=\"物联网中人、信息和设备的关系\"></p><p>看到这里，可能你会说，物联网和互联网确实是两个不同的事物。</p><p>其实，这个理解也不够准确。在刚才提到的智能家居场景中，我们可以发现，设备产生的数据，仍然是通过互联网的网络传输到互联网的云服务器上的，而且人仍然是物联网中信息的重要参与者。</p><p>所以，物联网和互联网并不是完全割裂的，<strong>物联网是互联网的发展和延伸</strong>。而且，因为接入设备在供电情况、网络环境、功能和数量上的差异，物联网也会出现很多跟传统互联网不一样的技术需求和特性。</p><h2>2.物联网和传感器有什么关系？</h2><p>在智能家居安防设计的例子中，我们提到了一个很重要的技术，<strong>传感器</strong>。</p><p>有人说，物联网就是一个传感器网络，把各种传感器设备接入互联网，就组成了物联网。</p><p>这曾经是很流行的想法，有些物联网的书籍，甚至直接把物联网的设备层称为“感知层”。这可能是因为，在物联网发展的初期，传感数据的远程收集是主要的应用领域。比如 MQTT 协议，就是 IBM 在20世纪90年代，为了监测偏远地区的石油和天然气管道而开发的。</p><p>但是物联网早就不只是通过传感器设备监测数据那么简单了，而是已经发展到了基于信息实现设备联动控制的阶段。比如，我在下班的路上就可以通过手机，提前打开电饭煲开始熬粥；打开热水器，进门前为我准备好热水。</p><p>不过有一点不得不说，因为传感器设备一般是计算资源少、网络环境差、电池供电的资源受限设备，所以传感器网络技术，尤其是<strong>无线传感器网络</strong>（WSN，Wireless Sensor Networking）技术，极大地推动了物联网的发展。</p><h2>3.物联网和5G有什么关系？</h2><p>除了刚才说的无线传感器网络技术，还有一种网络通信技术也对物联网的发展有非常重要的意义，那就是 <strong>5G</strong>。</p><p>你可能经常在媒体上看到这样的言论：“5G时代，物联网才会真正落地。”真的是这样吗？现在用于物联网的通信技术只是过渡方案吗？</p><p>我先不着急回答这个问题，因为我想先谈谈5G技术本身。</p><p>提到5G，你可能首先想到的是网速快，其实这只是一方面。实际上，5G 被分为3个主要应用场景，分别对应 eMBB、uRLLC 和 mMTC 3个标准：</p><ol>\n<li><strong>eMBB</strong> 用于我们日常的手机移动通信，网络传输速率高主要就是指这个标准。</li>\n<li><strong>uRLLC</strong> 应用的场景是无人驾驶、远程手术等，所以强调的是极低时延，而且是稳定的时延和速率，这不难理解，如果远程做手术，那肯定不能出现卡顿和忽长忽短的时延。</li>\n<li><strong>mMTC</strong> 可以支持大规模设备的连接上网，适合智能门锁、烟感传感器、路灯等低速率、低成本、低功耗的物联网设备。</li>\n</ol><p>为物联网场景提供新的想象空间的，其实是 uRLLC 和 mMTC ，但是这两个标准还没有正式发布，真正部署的时间更是不确定。</p><p>不过，这并没有影响物联网的落地，原因主要有两个：</p><ol>\n<li>像智能门锁等场景可以选择 NB-IoT、LTE-Cat1等已经成熟的蜂窝网络技术；</li>\n<li>物联网的场景非常多样，Wi-Fi、BLE、LoRa等非蜂窝技术一样有用武之地。</li>\n</ol><p>这些通信技术我会在下一讲为你介绍。</p><p>现在我们可以回答刚才的问题了：5G 时代，物联网才会真正落地吗？并不是这样。虽然 5G 中的 uRLLC 和 mMTC 将推动物联网在更多的场景落地，但也有很多场景不需要等到 5G 时代就可以走进现实。</p><h2>4.物联网和云计算有什么关系？</h2><p>除了5G，还有一个经常被提到的概念，那就是<strong>云计算</strong>。</p><p>云计算厂商都有各自的物联网平台，而且不遗余力地推动着物联网设备厂商和解决方案企业作为合作伙伴加入它们自己的平台。</p><p>于是很多人开始担心，云计算厂商会不会主导物联网标准的建立？</p><p>实际上，这种担心是多余的。因为云计算厂商可以把控的地方主要是物联网设备的平台接入，还有数据的存储和处理。</p><p>平台接入会涉及到网络协议的选择，目前他们主要支持 <strong>MQTT</strong> 等协议。而这些网络协议都是开放的标准，他们很难控制。</p><p>对于数据的存储和处理，云计算厂商会提供基于分布式系统的高性能、可伸缩的<strong>大数据</strong>存储产品，还有各种数据处理产品，甚至<strong>人工智能</strong>算法平台等等。虽然这的确会导致设备厂商对云计算厂商有一定的依赖性，但是产品主要还是基于社区主导的开源软件来开发的。</p><p>因此，在设备厂商、技术标准组织、开源社区、云计算厂商和网络运营商等多方参与的物联网中，云计算厂商很难主导物联网标准的建立和发展。</p><h2>5.物联网和智能家居有什么关系？</h2><p>随着云计算的发展，平台对海量数据的处理能力大幅提升。也许你在生活中最直接的感受就是，<strong>智能家居</strong>设备的功能越来越多，响应速度也越来越快。</p><p>的确，从日常感知的角度来看，很多人认为，物联网的火热似乎主要体现在智能家居领域。尤其当看到很多知名公司的宣传时，这种感觉会更强烈。</p><p>其实，我们想一想那些知名家电品牌，比如西门子、海尔、格力等等，就知道家电向来是个大产业，所以很容易想到智能家居的未来充满前景。</p><p>而手机厂商、互联网巨头和创业公司当然也看到了这个机会，因此一拥而上，使智能家居成为物联网中发展迅猛的行业。这样一来，一个正常价格在500元左右的智能音箱，在互联网流行的补贴大战下，只需要一两百元也不奇怪。</p><p>那么，智能家居就是物联网的主要应用场景吗？</p><p>其实，物联网不只有智能家居这一个主流应用。我经常以智能家居举例，也只是因为它贴近生活，你可能更容易理解。</p><p>除了智能家居，工业制造中的工业物联网应用因为可以直接提高效率、降低人工成本，市场规模逐年增长。尤其大热的<strong>工业4.0</strong>，更是推动了整个产业的发展。另外，还有农业，基于物联网技术，农业正在改变劳动力密集、靠经验等缺点，从而提高产量、解放人力。</p><h2>小结</h2><p>讨论完上面这些问题，物联网的样子，我们已经看得越来越清楚了：</p><ol>\n<li>物联网是互联网的发展和延伸，是设备和人一起作为主体组建的互联网。</li>\n<li>物联网不只是通过传感器设备监测数据那么简单，而是已经发展到了基于信息实现设备联动控制的阶段。</li>\n<li>5G 通信技术可以推动物联网在更多的场景落地，但对很多场景来说， 5G 不是必需的。</li>\n<li>云计算平台提供的标准网络协议接口，还有海量数据存储、处理能力，这些都是物联网的重要基础设施。不过，物联网行业的发展一定是多方共同推进的。</li>\n<li>物联网应用不止是智能家居，大家看到了智能家居的前景，但是工业、农业、交通、物流等各个领域同样是物联网的大舞台。</li>\n</ol><p>如果你对我在开篇词提到的物联网三大层面还有印象的话，不难发现：</p><p>这里讨论的传感器和通信技术（5G），对应了<strong>设备层</strong>；与平台接入有关的MQTT协议，对应了<strong>网络层</strong>；云计算的大数据存储、处理，以及智能家居等领域的应用，对应了<strong>应用层</strong>。</p><p>正是这三大层面技术的发展，推动了整个物联网的发展，并改变着我们生产和生活的各个领域。</p><p>在基础篇接下来的几讲中，我将沿着信息数据流转的路径，依次带你初步了解设备层、网络层和应用层三层相关的一些技术，然后通过智能家居场景的简易物联网系统设计，带你建立对物联网基本框架的认知。</p><h2>思考题</h2><p>最后，给你留一个思考题。许多互联网巨头都已经看到了智能家居的发展前景，但是它们主要发力的细分市场可能有所不同。在未来的智能家居市场争夺战中，你觉得关键的突破口会是什么呢？智能音箱是你心目中的答案吗？</p><p>欢迎你在评论区留言和我交流，也欢迎你将这一讲分享给对物联网感兴趣的朋友，大家一起交流学习。</p>",
                "article_title": "01 | 入门介绍：如何定义物联网？"
            },
            {
                "title": "02 | 通信技术：设备接入网络的方式有哪些？",
                "id": 306976,
                "content": "<p>你好，我是郭朝斌。</p><p>在上一讲的讨论中，我们得到一个结论，物联网是互联网的发展和延伸，是由设备和人作为主体共同组成的互联网。而在设备、人和信息之间搭建联系的物联网，可以分为设备层、网络层和应用层三个层面。</p><p>今天这一讲，我们先来看看物联网数据流的第一站，设备层。</p><p>物联网设备和单机设备最大的区别在哪儿呢？就在于它们<strong>接入了网络</strong>，所以这些设备才能将传感器采集的数据（生产信息）上传到云平台，然后根据平台对数据的分析做出反应（消费信息）。</p><p>因此，接入网络的技术，也就是通信技术，是你在做物联网设备设计时需要重点关注的。</p><p>想一想你的手机，刷票进地铁站会用到<strong>NFC</strong>，追剧会用到<strong>Wi-Fi</strong>或者<strong>4G</strong>，连无线耳机听音乐会用到<strong>蓝牙</strong>。正是因为集成了这么多的通信技术，它才可以满足你不同使用场景下的使用需求。</p><p>那么在物联网领域，我们有哪些通信技术可以选择呢？手机上使用的这些技术，可以用于其他物联网设备吗？</p><p>当然可以。除了刚才提到的这些，智能手机上已经不流行的2G、3G网络技术，在某些不需要高速率的物联网场景仍会使用到。另外，物联网行业也有一些自己专有的通信技术，比如<a href=\"https://www.semtech.com/lora/what-is-lora\">LoRa</a> 和 <a href=\"https://build.sigfox.com/sigfox\">SigFox</a>。</p><p>当然，设备接入网络不仅可以通过无线通信技术，还可以通过有线通信的方式，比如工厂中广泛应用的 <strong>PLC</strong> （Power Line Communication，电力载波通信）接入技术。但是，无线通信无疑是物联网应用的主流。</p><!-- [[[read_end]]] --><p>这一方面是因为有线技术的部署成本很高；另一方面，物联网是亿级数量设备的接入，如果每个设备都需要像古老的座机电话一样，连线接入，那么就对便利性构成了挑战，对网络中继设备来说更是灾难。</p><p>在这一讲中，我会介绍几种最重要的无线通信技术的特性。在后面的实战中，我们将基于这些特性来设计产品的通信方式。同时，我也会说一说在实践中需要关注的一些知识点。</p><h2>无线通信技术的4个重要参数</h2><p>在学习具体的无线通信技术之前，我们得先熟悉无线通信技术的4个重要参数：</p><ol>\n<li>频段</li>\n<li>信道</li>\n<li>信道带宽</li>\n<li>传输速率</li>\n</ol><p>你可以把它们作为了解和分析其他通信技术的工具，指导日后的实践。</p><h3>频段</h3><p>我们先来看频段。无线通信当然用的是电磁波，在实际应用中，电磁波是按照频段来使用的。</p><p>频段是指电磁波频率的一个范围，对应到频谱中就像是一段一段切割开。你看“频段”这个名词，是不是很形象？</p><p><img src=\"https://static001.geekbang.org/resource/image/0a/c0/0af3db9580eaf20523783fa0262067c0.png\" alt=\"\" title=\"整个频谱的频段分布（图片引自光通信百科）\"></p><p>上面这张图展示了整个<a href=\"http://news.moore.ren/industry/113320.htm\">频谱</a>的<a href=\"http://www.c-fol.net/baike/content/3/1712.html\">频段分布</a>。图中的分段基于电磁波不同的特性，而通信技术则需要考虑不同的使用需求和管理，对无线电波做更进一步的分段。</p><p>在这个频谱图中，Wi-Fi 的频段是2.412GHz-2.484GHz。这是一个<strong>非授权频段</strong>，其他的通信技术也可以使用，所以在后面你会看到蓝牙技术也基本是这个频率范围。理解了这一点，也许你就能明白，为什么Wi-Fi 路由器和蓝牙耳机、键鼠，在某些情况下会相互干扰了。</p><p>有没有什么办法能解决通信干扰呢？答案是肯定的，其中一种有效的方法是基于信道的跳频技术。</p><h3>信道</h3><p>说到这，你可能会问：信道是什么？</p><p>它是信息通过无线电波传送的具体通道介质。每种通信技术的频段会被划分、规划成多个<a href=\"https://en.wikipedia.org/wiki/List_of_WLAN_channels\">信道</a>来使用。</p><p>比如，Wi-Fi 的频段被分为14个信道（中国可用的是13个信道，信道14排除在外）。这里需要注意的是，相邻信道的频段是存在重叠的。比如，Wi-Fi 的信道 1 频段是2.401GHz～2.423GHz，信道 2 频段是2.406GHz～2.428GHz。</p><h3>信道带宽</h3><p>信道频段的最大值和最小值之差，就是信道覆盖的范围大小，也叫信道带宽。比如，Wi-Fi  信道1 的带宽是22MHz，它是由2.423GHz减去2.401GHz得到的。</p><p>需要注意的是，22MHz是信道1的实际带宽，而它的有效带宽只有20MHz，因为其中有2MHz是<strong>隔离频带</strong>。隔离频带主要是起保护作用的，就像高速公路上的隔离带。</p><h3>传输速率</h3><p>上高速公路的时候，我们会注意当前路段对车速的要求。而在选择通信技术的时候，传输速率就是我们需要关注的重要指标。它是指数据传输的快慢，单位是比特/秒（bit per second，简记为bps）。</p><p>不同的传输速率可以支撑不同的应用场景。比如，5G 峰值 20Gbps 的传输速率为移动 VR/AR 应用提供了技术可能。在4G时代，这种应用就会受到限制，我们只能在室内拖根线来感受 VR/AR 的魅力。</p><p>传输速率受很多因素的影响，比如信道带宽和频率。一般来说，带宽越大，传输速率就越大，就像路面越宽可以承载的通行车辆越多一样；频率比较高时，电磁环境相对比较干净、干扰少，传输速率会更高，就像道路更平坦自然可以通行更多车辆一样。</p><p>另外，为了提高传输速率，越来越多的提高频段利用率的技术也被开发出来并投入使用，比如<strong>正交频分复用</strong>。也许你对这个技术比较陌生，我再举一个更为人熟知的例子好了，<strong>MIMO</strong>（Multiple-Input Multiple-Output）技术，你可能在Wi-Fi路由器上或者手机宣传资料中见到过它，它是通过使用多重天线收发信号来提高传输速率的。</p><p>好了，频段、信道、信道带宽和传输速率，这4个无线通信技术的关键概念，咱们就讲完了。我再用一张图来表现它们的关系，帮你加深一下印象。</p><p><img src=\"https://static001.geekbang.org/resource/image/98/d1/9868d9f1c42a880d09c06053d437bdd1.jpg\" alt=\"\" title=\"无线通信技术的4个概念\"></p><p>针对图中的信道个数，我补充说明一下，这里的 12 个信道只是举例。实际应用中，不同的通信技术有不同的信道个数；同一种技术，不同的版本也会对信道做不同的划分。</p><p>接下来，我们继续学习几种无线通信技术，包括Wi-Fi、BLE、2G（GPRS）、LTE-Cat1&amp;NB-IoT。因为目前家庭和办公空间等局域网中，应用最广泛的无线通信技术就是 Wi-Fi ，所以咱们就从Wi-Fi学起吧。</p><h2>Wi-Fi</h2><p>Wi-Fi 是 IEEE 802.11 无线网络标准的商品名。所以，支持 Wi-Fi 功能的设备上，都会标注 “兼容 IEEE 802.11b/g/n 2.4GHz” 之类的说明。其中，802.11b、802.11g、802.11n 就是 Wi-Fi 的不同版本。</p><p>这种版本命名方式当然不够直观，所以 Wi-Fi 联盟从2018年开始推进数字版本号，比如，Wi-Fi 5、Wi-Fi 6。我在这里放了一张<a href=\"https://en.wikipedia.org/wiki/Wi-Fi#Versions\">表格</a>，展示了新旧版本号的对应关系。</p><p><img src=\"https://static001.geekbang.org/resource/image/9f/a6/9fcae5d803478e968f9afbdd4586b5a6.jpg\" alt=\"\"></p><p>没错，你可能也发现了，蓝牙早就这样定义版本号了。数字版本号的好处是，可以让开发人员避免使用错误版本的模组或者芯片，也方便了他们与用户沟通使用中的问题。</p><p>Wi-Fi 网络分布广泛，在家里、在办公场所，包括很多公共区域都有覆盖。所以，它自然也成了很多智能设备的选择，尤其是连接电源线、不需要关心功耗的设备，往往优先考虑 Wi-Fi。</p><p>不过，实践中有一个事情需要注意，那就是 <strong>Wi-Fi 的配网</strong>。</p><p>配网失败，是Wi-Fi 智能硬件被用户投诉和退货的非常重要的原因。据我了解，有厂家使用2016年的微信硬件AirKiss2.0配网，退货率达到了15%，是不是非常吓人？</p><p>之所以需要“Wi-Fi 配网绑定”这个操作流程，根本原因是，物联网设备不像手机、电脑，没有便利的信息输入手段，也没有完备的信息显示器件。因此，我们无法像在手机上一样，帮设备搜索、连接上 Wi-Fi 热点。相反，我们需要借助其他手段来完成两件事情：</p><ol>\n<li>Wi-Fi 设备需要连接上路由器（Wi-Fi热点或者AP）实现数据上传和远程控制，即获取到 Wi-Fi 热点的名称（称为 SSID）和密码。</li>\n<li>获取到 Wi-Fi 设备的 MAC 地址，或者设备生产时预存的信息，并与用户账号一起上传服务器完成绑定。</li>\n</ol><p>完成这两步之后，设备才可以联网使用。</p><h3>一键配网技术</h3><p>万事开头难，当你拿到一个 Wi-Fi 智能设备时，第一件麻烦的事情就是 Wi-Fi 配网绑定，所以很多物联网平台、模组厂家就推出了<strong>一键配网技术</strong>（SmartConfig）。</p><p>顾名思义，一键配网技术就是你只要在手机 App 上按一个按键，就可以自动完成配网的一系列操作。</p><p>然而愿望很美好，现实却很打脸。一度覆盖市面上90% 以上 Wi-Fi 设备的一键配网技术，竟然成了导致配网失败率高的罪魁祸首。这又是为什么呢？</p><p>原来，一键配网技术的工作原理，是通过手机或 Wi-Fi 路由器发送 UDP 广播包的形式，将 Wi-Fi 的 SSID 和密码广播出去。Wi-Fi 设备在进入配网模式后，会将接收到的广播包进行解析，从而获取到 Wi-Fi 的 SSID 和密码，然后连接上路由器。同样地，Wi-Fi 设备连接上路由器后，也会广播自己的 MAC 地址，这样手机 App 就可以接收到设备的 MAC 地址完成绑定。</p><p>这个原理看着不复杂，但却有几个容易出错的地方：</p><ol>\n<li>很多路由器不支持 UDP 广播，例如 Wi-Fi 放大器或者关闭 UDP 广播的路由器，会导致在发广播包这步就失败了。</li>\n<li>目前很多路由器已经支持 2.4GHz 和 5GHz 两个频段（Wi-Fi 4之后），这两个频段的网络是相互隔离的。手机很可能连接的是 5GHz 频段，那包含 SSID 和密码的广播包也在 5GHz 频段，而目前所有 Wi-Fi 智能设备都只支持 2.4GHz 频段，这就导致无法收到广播包。</li>\n<li>2018年之前的 Wi-Fi 产品（比如微信 AirKiss 2.0）存在广播包解析错误的问题，很可能发生解析的密码不正确的情况，导致无法连接路由器。</li>\n<li>路由器不支持局域网通信（比如路由器的访客网络），或者空间中有几个 SSID 相同的 Wi-Fi 热点，手机和 Wi-Fi 设备分别在不同的路由器下面，会导致设备即使连接上了路由器，但是手机无法获取设备信息的广播包的情况。</li>\n</ol><p>用户路由器或者设备的 Wi-Fi 模组引起的问题很难改变。遇到这类问题时，你可以让用户把手机热点打开，并且把热点的 SSID 和密码设置成与配网的 Wi-Fi 路由器一样的，然后拿到离路由器很远的地方，使用手机的 Wi-Fi 网络配置成功后，再回到路由器的环境下使用。</p><p>如果是 2.4GHz 和 5GHz 两个频段的问题，那么可以切换手机的 Wi-Fi 连接到 2.4GHz 的频段后再配置网络。</p><p>当然，这些操作的要求不低，很多用户很难独立完成，所以选择其他配网方式或者为一键配网的设备预备其他配网技术是一定要考虑的。小米米家的物联网平台的设备热点配网技术，就是一个值得借鉴的方式。它可以在不增加成本的情况下，保证基本 100% 的成功率。</p><p><strong>设备热点配网技术</strong>是让 Wi-Fi 设备先进入 Wi-Fi AP的模式，也就是说，由设备创建出一个 Wi-Fi 热点，然后让手机连接到这个热点，接着把路由器 Wi-Fi 的SSID 和密码发送给 Wi-Fi 设备，同时手机也可以直接获取到设备的 MAC 地址。</p><p>这种方式的麻烦之处在于，你需要手动输入路由器 Wi-Fi 的密码。在苹果手机上，你还需要进入设置界面，手动选择连接智能设备的 Wi-Fi 热点。</p><p>其他 Wi-Fi 配网技术还有零配置配网、蓝牙配网、手机热点配网和路由器配网等技术方式，有兴趣的话，你可以单独再查询了解一下。<a href=\"https://help.aliyun.com/document_detail/97570.html\">下图</a>展示了各种配网技术中角色之间的关系，供你参考。</p><p><img src=\"https://static001.geekbang.org/resource/image/de/08/de36ca9d86a5c962d0f84c4e1dd11308.png\" alt=\"\" title=\"各种配网技术中角色之间的关系（图片引自阿里云）\"></p><h2>BLE</h2><p>刚才我提到，连接电源线、不需要关心功耗的设备往往优先考虑Wi-Fi，那么功耗要求严格的设备要怎么办呢？</p><p>BLE是一个不错的选择。它的频段是非授权的2.400GHz-2.4835GHz，采用40个带宽2MHz的通道。</p><p>听到BLE，你也许会觉得有些陌生。其实它是<strong>Bluetooth Low Energy</strong>的缩写，也叫<strong>低功耗蓝牙</strong>，是对 Bluetooth 4.0 / 4.1 / 4.2 的统称。现在它已经成为低功耗物联网设备的首选，仅仅依靠一颗纽扣电池供电就可以工作数年。</p><p>而蓝牙 5 更是针对物联网增加了很多特性，比如 Mesh 组网、更远的通信距离、更快传输速率（BLE 4.2 的2倍）和更大数据承载量的广播包（BLE 4.2 的8倍），此外还有厘米级精度的定位功能。</p><p>除了这些，蓝牙技术还有一个优势，那就是应用实践非常广泛，是智能手机等设备的标配。因此，无论是从芯片模组的价格考虑，还是从生态的丰富度考虑，它都是电池供电的智能设备的理想选择。</p><p>虽然蓝牙 5 有许多很好的特性，但是它还在普及中，目前 BLE 仍然是主流，所以我们的目光还是先回到 BLE 身上吧。</p><p>BLE 的数据通信主要基于<strong>广播包</strong>和 <strong>GATT 协议</strong>。如果你对它们还不是很了解，在从事开发工作之前，最好先补充一下这方面的基础知识。我在这里提供了一份<a href=\"https://learn.adafruit.com/introduction-to-bluetooth-low-energy/gatt\">资料</a>给你参考。</p><p>连接参数的调节对于 BLE 设备的扫描和连接等影响很大。这些参数包括广播间隔、最大连接间隔、最小连接间隔和连接监听时间等，它们都可以在设备的固件开发中进行调整。比如广播间隔会影响扫描的响应速度，也会对设备的功耗有影响，所以需要平衡功耗和响应速度的不同需求，选择一个合适的值。</p><p>如果扫描连接体验需要非常流畅迅速，你可以选择20ms的间隔，但是这会增加设备的功耗，减少待机时间；如果你能够容忍一定的扫描等待时间，那么可以选择 1-2 秒的广播间隔来降低功耗。</p><p>另外，如果你在 Android 手机上开发 BLE 相关的应用，还有两点是我想提醒你的。</p><p>一是不同品牌 Android 手机的芯片解决方案往往是不同的，它们的蓝牙协议栈实现也存在很大的差异。所以开发者需要针对不同的手机进行充分的测试，保证开发的应用在不同的手机上都可以正常运行。</p><p>二是因为基于 BLE 可以进行地理位置定位，所以从 Android 6.0 开始，进行 BLE 开发时需要请求位置权限。这一点经常被忽略，也是需要注意的。</p><h2>2G</h2><p>在Wi-Fi流行之前，智能手机进行数据通信的主要方式是<strong>蜂窝通信技术</strong>，也就是我们常说的<strong>“ x G”</strong>。</p><p>2G是相对早期的蜂窝通信技术，你可能觉得这个词听起来都已经有些年代感了。不过，在一些传输数据量不大的场景中，采用 2G 技术的联网设备还有不少，比如路灯控制器、冷链运输监测设备等。</p><p>但是，你在新产品的设计中要尽量避免使用 2G 模组，因为 2G 的退网已经不可避免。</p><p>联通已经率先推进，移动也开始逐步实施，腾出的频段会用于发展 5G 网络通信。如果新产品仍然采用 2G 模组，未来无网可用时会非常麻烦，甚至在那之前你就会遇到很多因网络引起的产品体验问题。</p><h2>LTE-Cat1 &amp; NB-IoT</h2><p>那么，2G 的替代选择是什么呢？从目前国内通信产业的发展看，<a href=\"http://www.gov.cn/zhengce/zhengceku/2020-05/08/content_5509672.htm\">LTE-Cat1 和 NB-IoT</a> 是你值得关注的选项。NB-IoT 模组的价格已经和 2G 模组基本持平；LTE-Cat1 的模组相比要贵一些，但是也要远低于 4G 模组的价格。</p><p>LTE-Cat1 有一个独特优势是网络覆盖，它属于 4G 网络的低速类别，可以直接使用我们国家完善的 4G 的网络设施。而NB-IoT 虽然已经发展多年，但是目前网络覆盖仍然不够理想，这也限制了这些年 NB-IoT 的广泛应用。</p><p>不过，NB-IoT 大概率会成为 5G 的重要组成部分。随着 5G 产业的发展，我相信 NB-IoT 仍然会广泛应用在低速率、广域网络的场景中。</p><p>那么，LTE-Cat1 和 NB-IoT 分别适合哪些应用场景呢？我们可以根据它们各自的特性来分析。</p><p>LTE-Cat1 的带宽是 20MHz，上行速率 5Mbps，下行速率 10Mbps。它有良好的移动特性，功耗比 NB-IoT 大些，但是低于传统的 2G/3G 设备。所以它适合可穿戴设备、ATM机、自助售货机和无人机等场景。这些场景对数据传输速率有一定要求，但是又不需要达到 4G 的水平。</p><p>NB-IoT 的带宽是 180KHz，上行速率 16.9Kbps，下行速率是 26Kbps，功耗很低。所以它不适合移动环境，但却很适合智能抄表、智能灯杆和烟感报警器等低数据速率的场景。</p><p><img src=\"https://static001.geekbang.org/resource/image/9f/99/9feab317fdb5yy2048dbbeeb978b0599.jpg\" alt=\"\"></p><p>我想，说到蜂窝网络，你最感兴趣的肯定是5G。不过，关于5G，值得说的东西太多了。所以今天我们先学到这里，我会在后续的加餐中跟你详细聊聊5G这个话题。</p><p>如果你对前面提到的 LoRa 和 SigFox 技术同样感兴趣，我也很乐意在加餐中跟你分享。</p><h2>小结</h2><p>现在，我们总结、回顾一下对这一讲的重点内容。</p><ol>\n<li>无线通信技术有 4 个重要的参数：频段、信道、带宽和传输速率。当遇到新的无线技术时，你可以把它们作为了解、分析的一个角度，进而更好地指导实践。</li>\n<li>Wi-Fi 和 BLE 在移动互联网时代应用广泛，未来仍是理想的技术选择。连接电源线、不怎么关心功耗的设备往往优先考虑Wi-Fi，而依靠电池供电、比较关心功耗的设备则更加适合BLE。</li>\n<li>对于Wi-Fi 智能设备来说，Wi-Fi 配网绑定是比较麻烦的事情，所以很多物联网平台和模组厂家推出了一键配网技术。但是因为其不能保证100%的成功率，设备热点配网技术可以作为备选方案一起提供，甚至也可以作为主选方案。</li>\n<li>2G 的退网已是趋势，在实践中可以考虑 LTE-Cat1 和 NB-IoT 两种蜂窝通信技术。对于非移动的、传输数据量很小的设备可以选择 NB-IoT；传输数据量更大，又不需要达到 4G 能力的设备可以考虑模组越来越成熟的 LTE-Cat1 技术。</li>\n</ol><p>总之，物联网场景丰富，设备的工作环境和传输的数据量差别很大，你在应用中要合理地评估和选择通信技术。我画了一张对比图，供你参考。</p><p>当然，关于物联网的设备层，你需要了解的远远不止这些。更多核心技术，比如组网技术，等我们到了进阶篇再逐一剖析吧。</p><p><img src=\"https://static001.geekbang.org/resource/image/a0/19/a074bb163611636443dbdf916281f919.jpg\" alt=\"\"></p><h2>思考题</h2><p>最后，我再给你留一个思考题。</p><p>5G 技术已经逐渐走到我们的生活中，而且围绕它的应用场景，行业讨论热烈。除了高速率，我也提到过 5G 还有两个重要的特性，你还记得是什么吗？这些特性的实现原理你了解多少呢？</p><p>欢迎在留言区写下你的思考，我们一起交流学习；也欢迎你把这一讲分享给更多的朋友，一起阅读讨论。</p>",
                "article_title": "02 | 通信技术：设备接入网络的方式有哪些？"
            },
            {
                "title": "03 | 网络协议：设备使用什么语言与互联网对话？",
                "id": 307518,
                "content": "<p>你好，我是郭朝斌。</p><p>在上一讲中，我为你介绍了物联网设备常用的几种无线通信技术。通过这些技术联网之后，物联网设备就可以向云平台上报数据了吗？还不可以。</p><p>成功传输数据的前提是，通信双方必须使用<strong>同一种“语言”</strong>。这就像，你拨通了比尔·盖茨的电话，如果说“喂，你好”，他大概会一头雾水；但如果说“Hello!”，他一下就能听懂了。</p><p>而物联网设备间沟通的语言，就是<strong>网络协议</strong>。说起网络协议，你可能马上就想到了 HTTP 协议。是的，在日常的Web开发中，我们总是需要跟它打交道，因为 HTTP  协议是互联网的主流网络协议。</p><p>类似地，应用在互联网中的网络协议，还有收发电子邮件的POP3 、SMTP 和 IMAP 协议，以及用于区块链中的 P2P 协议。</p><p>那你马上会问了，物联网设备之间的通信，可以直接使用这些协议吗？</p><h2>物联网通信的特点</h2><p>想要回答这个问题，我们得先来分析一下物联网的网络通信特点。</p><ol>\n<li>物联网设备很大可能工作在<strong>不可靠、高延迟的网络环境</strong>中。</li>\n</ol><p>比如共享单车，使用 NB-IoT 这样的通信技术，本身的通信速率就只有不到几十Kbps；要是被人停在城市的角落里，信号可能很不稳定。</p><p>假设你使用 HTTP  协议，就需要单车先发出连接请求，然后等待服务器的响应（下发开锁指令）。这样一来，受网络通信质量的影响，很可能连接经常中断，而需要单车与服务器交互多次，那用户可能就要等很长时间。</p><!-- [[[read_end]]] --><p>对于这种场景来说，不只是HTTP，其他跟HTTP一样单向的、同步的网络协议，都不是理想的技术方案。</p><ol start=\"2\">\n<li>物联网系统中，<strong>设备数量多，<strong><strong>而且</strong></strong>交互非常复杂</strong>。</li>\n</ol><p>比如你家里的环境监测，温度、湿度、光照、二氧化碳、甲醛含量……这些都需要不同的设备测量，而且每个房间用到的设备也不同。</p><p>如果你让云平台的服务对每个设备分别做权限控制和数据阈值设置，这会非常麻烦。因为当数据的“生产者”和“消费者”直接交互时，要是没有中间角色基于共同的目标协调，双方的耦合度会很大，导致系统很难实现。</p><p>这时候，你需要把你家作为一个整体来处理，交互逻辑就会变得简单多了。</p><ol start=\"3\">\n<li>设备经常需要<strong>根据实际使用环境做增加、减少等调整</strong>。</li>\n</ol><p>比如你用一个设备测量房间的温度，现在这个设备损坏了，你要换一个。你肯定不希望因为设备 ID 这么一个小小的变化，就要去修改判断房屋温度的逻辑代码，这太麻烦了，也不符合软件开发的开闭原则。</p><p>这要求系统必须具备可伸缩性（或者说可扩展性），设备的增减不会导致系统逻辑的调整。</p><p>正是因为这些特点，物联网系统在选择网络通信的协议时，一般采用<strong>发布-订阅</strong>的通信模式。为什么说发布-订阅模式适合呢？我来解释一下它的设计，你就明白了。</p><h2>发布-订阅模式</h2><p>发布-订阅模式包含三个角色，分别是发布者（Publisher）、经纪人（Broker）和订阅者（Subscriber），它们的关系如下图所示。</p><p><img src=\"https://static001.geekbang.org/resource/image/b5/22/b597dfbda6f748c9858d021770be7a22.jpg\" alt=\"\"></p><p>三个角色之间的消息传递，基于一个重要的概念——主题。主题用于消息的过滤（或者说路由），它确定了消息的不同类别。消息传递的过程可以分为三步：</p><ol>\n<li><strong>发布者</strong>负责生产数据。发布者发送某个主题的数据给经纪人，发布者不知道订阅者。</li>\n<li><strong>订阅者</strong>订阅经纪人管理的某个或者某几个主题。</li>\n<li>当<strong>经纪人</strong>接收到某个主题的数据时，将数据发送给这个主题的所有订阅者。</li>\n</ol><p>我们举个例子你就理解了。到中午了，你有点饿。今天吃什么呢？你想了想，拿出手机打开外卖App，选择了牛二楠家的咖喱牛肉盖饭，外加双份肥宅快乐水加冰。</p><p>当你发布牛二楠家的订单给外卖订单中心服务器时，隔壁的产品经理小王也在点外卖，他点了猪三排家的红烧排骨盖饭。</p><p>外卖订单中心收到这两个订单之后，会把你的订单发送给牛二楠家，把小王的订单发送给猪三排家。</p><p><img src=\"https://static001.geekbang.org/resource/image/91/b7/91aff5a163b4944bf3481f30102e40b7.jpg\" alt=\"\"></p><p>相信你也看出来了，你和小王都是“发布者”，牛二楠家和猪三排家就是“订阅者”，而外卖订单中心就是“经纪人”。</p><p>当然，你内心可能在祈祷外卖订单中心出个错，把小王那个订单（猪三排家的红烧排骨盖饭）发送到做卤煮的猪三下水家那里，给他的午饭增加一点难忘的体验。</p><p>为什么我说发布-订阅模式适合物联网系统呢？因为在物联网场景中，一个传感器数据需要<strong>触发多个服务或者终端执行动作</strong>。</p><p>比如红外传感器，当它检测到有人体靠近时，就需要触发一系列动作：通知摄像头拍照，声光报警器执行报警，推送消息给主人的手机等。</p><p>怎么满足这种需求呢？我们最好让摄像头、声光报警器和手机都订阅“人体靠近”这个主题消息。当红外传感器被触发时，它发送人体靠近的消息，然后这些设备就能同时收到这个消息，接着完成系统定义的那些动作。这就是发布-订阅模式的工作方式。</p><p>另外，发布-订阅模式减少了发布者与订阅者之间的耦合度，所以网络不稳定导致的临时离线就不会影响彼此的工作。它的拓扑结构也使系统更容易扩展，更容易满足动态变化的需求。这些优点都使得发布-订阅模式在物联网应用协议中非常流行。</p><p>那么，具体有什么网络协议采用的是发布-订阅通信模式呢？MQTT 协议就是其中的佼佼者。</p><h3>MQTT</h3><p><a href=\"https://mcxiaoke.gitbooks.io/mqtt-cn/content/\">MQTT</a>（MQ Telemetry Transport）协议，是 IBM 公司在 1999 年开发的轻量级网络协议，它有三个主要特点：</p><ol>\n<li><strong>采用二进制的消息内容编码格式</strong>，所以二进制数据、JSON和图片等负载内容都可以方便传输。</li>\n<li><strong>协议头很紧凑，协议交互也简单</strong>，保证了网络传输流量很小。</li>\n<li><strong>支持3种 QoS</strong><strong>（Quality of Service，服务质量）</strong><strong>级别</strong>，便于应用根据不同的场景需求灵活选择。</li>\n</ol><p>这里我解释一下什么是QoS。它是指通信双方关于消息传送可靠程度的协商。QoS 0，消息只发送一次，消息可能丢失；QoS 1呢，发送方会接收反馈，保证消息的送达，但是可能消息会重复。QoS 2级别，通过发送方和接收方的多次交互，保证消息有且只有一次。</p><p>现在我们说回MQTT。刚才提到的这三个特点，让 MQTT 协议非常适合计算能力有限、网络带宽低、信号不稳定的远程设备，所以它成为了物联网系统事实上的网络协议标准。关于 MQTT 协议的详细内容，我还会在进阶篇第8讲为你进一步剖析。</p><h3>AMQP</h3><p>除了 MQTT 协议以外，也有其他采用发布-订阅模式的网络协议，比如 AMQP 协议。</p><p>虽然 AMQP 协议拥有庞大的特性集，比较重，不适合计算资源有限、对功耗要求严苛的物联网设备，但是它可以满足后台系统对于<strong>可靠性</strong>和<strong>可扩展性</strong>的要求。因此，它在物联网的平台系统中应用广泛。比如，在分布式系统中应用广泛的 RabbitMQ 消息中间件软件，就是基于 AMQP 实现的。</p><p>AMQP 和 MQTT 一样，也是基于 TCP 协议，采用二进制消息格式，也支持3个 QoS 级别。</p><p>顺带说一句，现在被广泛使用AMQP 1.0 和 AMQP 0.9.1 这两个版本，在设计上有很大的差异。你在查询资料或者应用这两个版本的AMQP协议时，一定要注意看版本，避免用错。</p><h2>请求-响应模式</h2><p>刚才我介绍了发布-订阅模式的很多好处，但是凡事都有例外，也有一些物联网应用场景，并不适合使用这种模式。</p><p>比如，现在小区里面都有智能快递柜，当你输入取件码后，服务器会向对应的柜门发送开门指令。</p><p>在发布-订阅模式下，服务器知道指令发送成功了，但是它无法知道柜门是否真的打开了。这时，你就需要让柜门能够向服务器反馈一下命令的执行结果。</p><p>当然，你也可以让服务器订阅一个“柜门关闭”的主题消息，然后等待柜门发布这个消息。但是这样的话就非常繁琐、不够直接。</p><p>在这种场景下，另一种通信模式就能派上用场了，那就是<strong>请求-响应</strong>模式。</p><p>请求-响应模式有两个角色，一个是客户端（Client），另一个是服务器（Server）。</p><p><strong>客户端</strong>是请求数据或者服务的一方。<strong>服务器</strong>则用来接收客户端的请求，并提供相应的数据或者服务。服务器在收到请求后，会获取数据，对资源数据（比如数据库）进行加工处理，准备好响应，然后返回给客户端。</p><p>请求-响应模式是无状态的通信方式，每个完整的请求-响应都是相互独立的。进一步细分的话，它还可以分为同步和异步两种。你可以看下这张图片。</p><p><img src=\"https://static001.geekbang.org/resource/image/6d/5d/6d3131d39d271c12aee82ddcf4a58a5d.jpg\" alt=\"\"></p><p>我们还是以外卖来举例。当你拿出手机点好外卖后，牛二楠家的服务员会收到外卖订单，然后通知厨师准备盖饭，同时另一个服务员已经熟练地打好了快乐水。</p><p>半个小时后，外卖小哥拿着装有你心仪午餐的袋子出现在公司门口，然后交到你的手里。他满脸笑容地说，闯了2个红绿灯才这么快送到，希望你给个好评。</p><p>这就是请求-响应模式。你是“客户端”，牛二楠家是“服务器”，你发出“请求”后，等待一段时间，然后外卖小哥将“响应”给到你。流程如下面的图片所示：</p><p><img src=\"https://static001.geekbang.org/resource/image/16/ab/16aecc7c73a3bee6yyf3aae5897b8bab.jpg\" alt=\"\"></p><h3>HTTP</h3><p>有哪些网络协议采用了请求-响应模式呢？HTTP 就是典型的代表。HTTP/2 协议还引入了异步请求-响应模式，客户端可以对请求设置不同的优先级，服务器可以根据优先级决定先响应哪个请求。</p><p>虽然 HTTP 协议的报文格式非常重，光是报文头就能达到 KB 大小，不太适合资源有限的嵌入式设备。但在一些计算资源和网络资源都比较充足的物联网设备上，HTTP协议仍然是一个可选项。而且它和现有的 <strong>Web 系统</strong>兼容，可以利用已有的 Web 服务器资源。</p><h3>CoAP</h3><p>那么有没有跟 HTTP 协议类似，但是设计轻量，可以用于资源受限的物联网设备的协议呢？</p><p>有的，那就是 CoAP（Constrained Application Protocol）协议。</p><p>跟HTTP协议一样，CoAP 协议同样有 GET、POST、PUT、DELETE 等方法和响应状态码，同样使用 URI 而不是 Topic 来标识资源。</p><p>比如我们需要访问服务器 iotdemo.com 下面的 bedroom/temp 这个资源，那完整的资源地址是：</p><pre><code>coap://iotdemo.com:5683/bedroom/temp \n</code></pre><p>CoAP 的消息采用二进制格式，支持可确认消息和不可确认消息两种QoS级别。可确认消息（Confirmable Message）与 MQTT 协议的QoS 1类似，不可确认消息（Non-confirmable Message）对应MQTT协议的 QoS 0级别。</p><p>另外，CoAP 协议基于的传输层协议是 UDP，而不是 HTTP 、 MQTT 协议的 TCP协议，所以对于设备的<strong>计算资源要求更低</strong>。传感器设备一般只需要上传数据，不用随时接收服务器的控制命令，这都说明 CoAP 协议适合电池供电的传感器设备。</p><h3>LwM2M</h3><p>说完 CoAP，我再介绍一下跟它有关 LwM2M（Lightweight M2M）协议。</p><p>LwM2M 协议定义在 CoAP 协议之上，不过它在消息传输的基础上更进一步。因为它基于 IPSO （IP-base Smart Object）对设备模型进行了标准化，提供了一组轻量级设备管理和交互接口协议。</p><p>LwM2M 协议目前主要的实现是 C 语言的 Wakaama 和 Java 语言的 Leshan，相对来说应用还比较少。CoAP协议的应用场景同样适合 LwM2M协议，如果你希望在CoAP 协议的基础上更方便地实现<strong>设备的管理</strong>，可以考虑LwM2M协议。</p><h2>通信模式的共存</h2><p>到这里呢，我就讲完了“发布-订阅模式”和“请求-响应模式”的各自特点，以及相应的网络协议。那你可能会问，有没有网络协议可以同时拥有这两种通信模式呢？有这种想法，说明你非常善于独立思考。确实，这样也更能满足实际场景的需求，而且从原理上看，也完全可以实现共存。</p><p>现在行业内也意识到了这一点，所以一些网络协议已经纷纷做出了尝试。比如 MQTT 5.0中增加了请求-响应模式的新特性；AMQP 1.0版本也定义了请求-响应模式。而 CoAP协议呢，在新的初稿版本（Draft）中也增加了发布-订阅模式特性。</p><p>这种网络协议中的通信模式的共存，相比单一模式的设计都大大方便了具体场景中的应用，代表了一种网络协议的发展方向。</p><h2>小结</h2><p>在这一讲中，我对比了“发布-订阅”和“请求-响应”这两种主流的通信模式，并简单介绍了两种通信模式下的网络协议。</p><p>物联网应用是一个复杂的综合性系统，这要求你了解不同网络协议的功能特性和局限，并且为系统的不同部分做出合适的选择。这些选择原则，我总结为下面三点：</p><ol>\n<li>物联网设备通常需要运行在网络不太可靠的环境中，而且在功耗、体积和计算资源方面也有诸多限制，所以我们在设备的开发中可以考虑使用MQTT和CoAP协议。</li>\n<li>云平台各服务之间需要快速、可靠地进行消息转发，这种情况可以选择 AMQP 协议。</li>\n<li>一些应用需要兼容 Web 系统的 RESTful 架构，比如通过 REST 开放物联网中的资源能力，供其他应用调用，这时 HTTP 和 CoAP 协议是合适的选择。</li>\n</ol><p>我在这里再提供一个网络协议的思维导图，供你参考。</p><p><img src=\"https://static001.geekbang.org/resource/image/ff/81/ff230bbc7d6yy2c7c10e986f7dbe4581.jpg\" alt=\"\"></p><h2>思考题</h2><p>最后，我想给你留个问题。你还知道有哪些协议，适合用在物联网系统中吗？它们又是采用了哪种通信模式呢？</p><p>欢迎你在留言区写下你的答案，和我交流一下，也欢迎你将这一课分享给你的朋友，共同交流学习。</p>",
                "article_title": "03 | 网络协议：设备使用什么语言与互联网对话？"
            },
            {
                "title": "04 | 数据分析：数据的价值有哪些？",
                "id": 308366,
                "content": "<p>你好，我是郭朝斌。</p><p>在前两讲，我们了解了物联网设备层的通信技术和网络层的网络协议。设备借助通信技术，能接入网络；而统一的网络协议，保证了云平台能够“看懂”这些上报的数据。</p><p>但是，如果只是单纯地采集和存储的话，那么数据就只是数据库中的 0 和 1 ，很难谈得上有什么价值。某种程度上说，物联网系统的价值其实就在于<strong>数据的价值</strong>，而数据的价值则来源于我们对数据的分析和应用。</p><p>所以这一讲，我们来到了物联网数据流的第三站，应用层。开始下面的学习之前，你可以假设一下，如果你是物联网平台开发人员，你会怎么有效地分析和应用数据呢？</p><h2>从数据的角度审视物联网</h2><p>回答这个问题之前，我想先从数据的角度，带你对物联网体系结构再做一次梳理。</p><p>你可能有疑惑了，之前我们整理的物联网三大层面，不是也跟数据流向有关吗？是的，但是那三个层面是基于各部分的特性划分的，包含的技术内容更广。</p><p>而今天这一讲，我只专注数据这一个维度，对数据从“生产”到“消费”的过程做一个更细化的拆分和整理，得出一个技术体系。通过这个体系，你就能够对数据相关的技术有一个更加清晰的认识，而且学习过程中心里时刻有个宏观视角，不会“迷失”在各种技术的琐碎细节里面。</p><p>我先给出这张物联网数据分析的技术体系示意图，然后我会结合这张图片，从下往上分别讲解其中的每一步：</p><!-- [[[read_end]]] --><p><img src=\"https://static001.geekbang.org/resource/image/c2/3f/c2dd869e58fe025e8e9faa727bd7c83f.jpg\" alt=\"\"></p><h3>第一步：数据源数据采集</h3><p>数据源数据采集，就是通过各种物联网设备，实现各种数据数字化的任务，同时也可能需要将数据临时存储起来，准备好数据的上传工作。</p><p>因为数据类型多种多样，比如我们常说的温度、湿度、甲醛含量，另外还有图像、声音、震动等等，所以采集这些数据的设备也具有明显的<strong>多样性</strong>。</p><p>除了传统的<strong>嵌入式系统</strong>涉及的软件和硬件开发外，<strong>传感器</strong>是这一部分需要重点关注的关键元器件。随着物联网的发展，新的应用在不断涌现，比如监测人体心率和血氧饱和度的可穿戴设备，以及在智慧农业中用来测量土壤反射率和植物颜色的光学传感器等等。</p><p>传感器是一个具有技术门槛的行业，高度依赖<strong>材料技术</strong>的进步。除了半导体和光纤这些相对传统的材料，现在一些纳米和生物材料的应用也发展很快。</p><p>采集完数据后，你就要利用网络将数据传输到云服务器。</p><h3>第二步：数据传输</h3><p>数据传输，就是把采集的数据快速地、可靠地上报到云平台。</p><p>这里的技术难点是实现<strong>高并发</strong>。因为物联网设备的数量巨大，而且它们在时刻不断地产生数据，所以海量的数据对云平台的性能构成了挑战。云平台只有具备高并发的能力，才能有效地、可靠地实现数据的传输。</p><p>高并发的实现，需要借助<strong>分布式</strong>的架构设计，同时使用<strong>负载均衡</strong>、<strong>消息队列</strong>和<strong>缓存</strong>等相关技术。我将在进阶篇针对这个话题再展开讲一讲。</p><h3>第三步：数据存储</h3><p>数据传输完成之后，你要面对问题是<strong>海量数据的存储</strong>。</p><p>比如，一辆共享单车一天会产生 1MB 的数据，如果按照2000万辆的保有量计算，每天就会产生 20TB 的新增数据。而在智慧城市的系统中，一个800万像素的摄像头，一个小时就能产生3.6GB 的数据。那么一座城市，光是摄像头，一个月的数据量就可以达到数百 PB。</p><p>除了数据量大，数据的种类也很丰富，它们大体上可以分为3类，分别需要有不同的存储手段：</p><ol>\n<li><strong>结构化数据</strong>，比如用户和设备的关系，用户信息、设备参数等。这类数据还是适合<strong>关系型数据库</strong>，那为了应对海量数据，你可以采用<strong>分布式数据库</strong>。另外，物联网中的传感器设备，随时间不断产生新数据。要存储这类数据，你可以选择<strong>时序数据库</strong>，来获得更高的读写和查询性能。</li>\n<li><strong>半结构化数据</strong>，比如JSON结构的数据，日志记录等。这些数据的存储一般采用 <strong>NoSQL 数据库</strong>产品。</li>\n<li><strong>非结构化数据</strong>，比如视频、音频等数据。它们一般采用文件的形式存储，Hadoop 体系中应用广泛的<strong>分布式文件系统 HDFS</strong> 是常用的选项。</li>\n</ol><p>关于数据存储的详细内容，我会在进阶篇为你进行剖析。</p><p>只有当实现了海量数据的存储，我们也才能为数据的处理打好基础。</p><h3>第四步：数据处理</h3><p>数据处理阶段，非常考验你对海量数据的处理能力，你需要用到<strong>大数据计算引擎</strong>。大数据的处理，从应用场景划分的话，可以分成两个大类：</p><ol>\n<li>\n<p><strong>批处理</strong>，顾名思义，它是对批量的数据进行统一处理的方法。比如我们需要知道一个月里，共享单车的总骑行时长和距离，骑行距离最远的单车等信息，就需要对所有单车的数据做汇总的计算，得出想要的结果。批处理的计算过程可能耗时较长，几分钟、几个小时，甚至几天都有可能。</p>\n</li>\n<li>\n<p><strong>流处理</strong>，它是对数据流做及时的处理计算。相比批处理，它具有低延时的特点，一般可以达到毫秒甚至微秒的级别。这样可以满足海量数据对于大吞吐量的处理能力的需求。比如温度、湿度数据基于高、低阈值的实时判断，就需要采用流处理的方式。</p>\n</li>\n</ol><p>这里要说明一下，批处理延时高的主要原因，是大量数据需要从低速的磁盘中进行存取。它追求的目标和流处理一样，还是高效地处理和尽量简单地计算任务开发工作。</p><p>关于批处理和流处理的具体应用，我还会在进阶篇中为你进行讲解。</p><h3>第五步：数据应用</h3><p>数据应用处于整个体系的最顶端，是物联网系统的最终目的。我们关注的核心点是通过数据创造<strong>价值</strong>，而实现的基础是各种<strong>算法</strong>。</p><p>接下来，我就围绕价值和算法来讲解一下数据应用。</p><h2>数据如何产生价值呢？</h2><p>数据产生价值的方法，概况来说，可以分为4种：</p><ol>\n<li>可视化</li>\n<li>挖掘</li>\n<li>预测</li>\n<li>控制决策</li>\n</ol><p>最直接的方法是<strong>可视化</strong>，也可以称为<strong>图表分析</strong>。</p><p>可视化可以非常直观地向人们展示数据的含义。比如共享单车的地理位置，如果给用户一个经纬度坐标，那无异于没有给这个信息；而在地图上以光标的方式显示出来，那用户就可以马上知道这个单车相对于自己的方位和距离。</p><p>类似的还有以曲线、柱状图表示数据变化趋势，以饼状图表示百分比数据，用网络图表示的事物关系等等。它们都可以为原始数据，和分析结果数据提供理想的展示手段。</p><p>比如我们可以查询共享单车近一年的开锁数据，然后基于这个数据，绘制一张开锁量的趋势曲线图。</p><p><img src=\"https://static001.geekbang.org/resource/image/6d/01/6df89150f6347ba7aa76ac227eacea01.jpg\" alt=\"\"></p><p>另外，可视化的各种图表也可以作为我们<strong>人工分析数据</strong>的工具。</p><p>首先你需要从数据库或者 HDFS （Hadoop的数据存储格式）中，把数据提取到 Excel 表格（或者 CSV 文件）里面；然后你可以在 Excel 软件中，使用数值计算函数得到总和、平均值等统计数值，或者使用数据透视表等功能得到新的统计表格。</p><p>除了 Excel，我们也可以利用其它图表软件来进行分析，比如 <a href=\"https://en.wikipedia.org/wiki/Gephi\">Gephi</a> 和 <a href=\"https://en.wikipedia.org/wiki/NetMiner\">NetMiner</a>。</p><p>比图表分析更进一步的方法是<strong>挖掘分析</strong>。</p><p>我们可以基于各类算法来分析数据的规律和关联关系等。这种方法基于各种现成的模型，或者自定义的模型，可以从数据中提取出人工分析无法看出来的、隐藏着的规律和联系。</p><p>比如那个经常被提到的啤酒和尿布的例子，美国沃尔玛超市通过分析销售数据发现啤酒和尿布经常被一起购买，所以调整货架，将啤酒和尿布放在一起来促进销量（有说法认为，这是由于美国年轻的爸爸出门买尿布的时候，经常顺便买几瓶啤酒犒劳自己）。如果不是挖掘出这个隐藏的联系，我们很难凭直觉得出这个结论，这也体现了挖掘分析的价值。</p><p>还有一种进阶的方法是<strong>预测分析</strong>。</p><p>随着积累的数据和经验越来越多，我们可以用算法来构建预测模型。当新收集的数据输入给模型时，我们就可以预测出未来的状况。</p><p>还是以共享单车做例子，当单车连接到网络平台之后，共享单车出现了。走在路上，掏出兜里的手机，你就可以打开一辆单车的锁，自由骑行；到达目的地后，锁上单车，计费马上完成；你还可以在手机上查看这次骑行的花费时间和骑行速度，甚至计算出你“燃烧的卡路里”。</p><p>为什么大部分时候，共享单车可以恰巧出现在你需要它的地方呢？</p><p>因为共享单车的系统平台有充足的信息，可以分析出城市的热点区域在哪里，并且预测出第二天每个区域的单车需求量。运营人员正是基于这些数据，提前确定在什么时候、什么地点、投放多少辆车。</p><p>最后一种方法是<strong>控制决策</strong>。</p><p>物联网设备可能具备<strong>执行器</strong>，物联网系统可以基于业务目标控制这些执行器。而控制决策是采集的数据基于算法计算得到的。</p><p>比如在农业中，有经验的种植能手会观察日照、土壤等条件，然后确定施肥、灌溉的节奏。那智慧农业呢，就需要在系统中把这种经验转化为<strong>专家系统</strong>。只要获得光照强度、水分、土壤成分等数据，你就可以根据专家系统的计算结果，控制水泵和卷帘等设备。</p><h2>数据分析可以使用的算法有哪些？</h2><p>挖掘分析、预测分析和控制决策要用到统计分析、机器学习，包括人工智能的各种算法。这些算法分为监督学习和非监督学习两类。</p><ol>\n<li><strong>监督学习算法</strong>需要我们像尽心尽责的父母，明确告诉它“什么是正确的”，“什么是错误的”。</li>\n<li><strong>非监督学习算法</strong>面对的是“放羊式”父母，需要自己将数据中的“异常值”区分出来。</li>\n</ol><p>常见的监督学习算法有<strong>决策树</strong>和 <strong>SVM</strong>（支持向量机）算法等。决策树类似我上面描述的专家系统；SVM 算法是一种分类算法，也可以用于线性和非线性回归问题，比如基于骑行习惯构建用户的画像。</p><p>非监督学习算法有<strong>K-means 算法</strong>等。K-means 算法是聚类算法，比如，基于共享单车的使用次数和时间段，我们可以区分出故障车和正常单车。</p><p>这里，我没有提到<strong>强化学习</strong>、<strong>半监督学习</strong>等概念，毕竟它们不是这一讲的重点，简单的两句介绍可能让你增加更多疑惑。总之，使用算法的一个原则是，你先要分析数据的<strong>特征</strong>，掌握大体的<strong>倾向</strong>，然后结合你要实现的<strong>目标</strong>，再选择合适的算法。</p><h2>小结</h2><p>总结一下，这一讲里，我展开介绍了数据应用涉及的分析方法和相关算法。</p><ol>\n<li>数据的分析方法可以分为：可视化、挖掘分析、预测分析和控制决策；</li>\n<li>具体的分析中会用到统计分析、机器学习和人工智能的各种算法，这些算法大体可以分为监督学习和非监督学习两类。</li>\n<li>算法选择的一个重要原则是，先使用一些可视化的工具分析数据的特征，掌握数据的大体倾向，然后结合业务目标或者控制目标，选择合适的算法。</li>\n</ol><p>数据分析和应用是物联网系统中数据流的最后一站。通过数据分析，海量的数据为用户带来了巨大的价值。</p><p>数据的价值，首先当然是商业价值，比如超市中的电子价签，取代之前的纸质价签，超市的店面运营减少了很大的人力投入，而且提高了促销活动的效率，降低了价格标错的可能。但这不是全部，物联网数据的有效利用还会带来巨大的社会效益。</p><p>为了讲清楚数据分析应用的方法，我还从数据的角度，对物联网系统再次做了一个梳理，整理出了物联网系统中数据的技术体系。它可以分为5个部分，分别是数据源数据采集、数据传输、数据存储、数据处理和数据应用。</p><p>可能你也发现了，物联网的数据技术体系和大数据的体系有很多相似的地方。确实是这样，物联网的数据系统本身也是一个大数据系统，必然会用到很多传统的大数据技术，比如数据存储、数据处理相关的技术。</p><p>但是物联网系统也有自身的特点，所以在数据采集上会涉及嵌入式系统和传感器的技术；在数据传输中会用到特殊的网络协议；在数据应用中需要关注控制决策相关的技术。这些是你需要注意区分的地方。</p><p>总之，在物联网中，海量的数据将会远远超过当前互联网的数据规模。这必然对数据的存储、读取、分析处理技术提出新的挑战。相关的技术呢，我会在进阶篇中继续做深入的剖析。</p><p>这里，我再提供一个物联网数据技术的思维导图，供你参考。</p><p><img src=\"https://static001.geekbang.org/resource/image/64/93/64a2cba411d24e66e7aeb655aac0f993.jpg\" alt=\"\"></p><h2>思考题</h2><p>最后，给你留个思考题吧。</p><p>在这一讲中，我提到了数据处理可分为批处理和流处理，并简单介绍了它们各自的特点。除了课程中的例子，你认为它们还适合哪些场景呢？</p><p>欢迎在留言区写一写你的想法，和我交流一下。也欢迎你将这节课分享给你的朋友一起学习。</p>",
                "article_title": "04 | 数据分析：数据的价值有哪些？"
            },
            {
                "title": "05 | 系统实例：怎样设计一个简易物联网系统？",
                "id": 309786,
                "content": "<p>你好，我是郭朝斌。</p><p>通过前几讲的学习，你应该已经熟悉了物联网系统的基本框架，并且知道设备层、网络层和应用层大概是怎么回事儿。不过你现在的理解，可能还停留在盲人摸象的阶段，虽然已经可以说出某些局部的特点，但是还没法儿准确地画出整头大象的样子。</p><p>假如现在老板给你布置一个任务，让你设计一个物联网系统，你是胸有成竹，还是手足无措呢？为了让你能够拍着胸脯说“保证完成任务”，今天这一讲，我会教你怎么设计一个简易的物联网系统。</p><p>那么，我们拿什么项目来练手呢？我想，还是智能家居比较合适。一方面是因为它跟你的生活关系比较密切，你对它的感知比较强；另一方面，你正好可以在这个基础上完成实战训练。</p><p>这也是受到扎克伯格的启发。他在2016年时计划自己动手打造一个 Jarvis 系统（《钢铁侠》中的智能助手贾维斯），能够通过语音/文字控制家里的电器。经过近一年的努力，到年底时他基本完成了这个系统，并且写<a href=\"https://www.facebook.com/notes/mark-zuckerberg/building-jarvis/10154361492931634\">文章</a>描述了具体的工作（如果你打不开，可以看<a href=\"https://www.pingwest.com/a/96883\">这篇</a>）。</p><p>课程学完之后，你再邀请朋友来家里玩，就可以展示自己亲自动手完成的一套智能家居设备，而且新的奇思妙想也能够随时动手实现出来。</p><p>想象一下，到时候你的房间也可以是一座“未来科技城”，你也可以在朋友圈“晒出”像扎克伯格一样的科技作品，这是不是很酷呢？</p><!-- [[[read_end]]] --><p><img src=\"https://static001.geekbang.org/resource/image/59/02/59ac9a929823a69eeb7ccf80231a4a02.jpg\" alt=\"\"></p><h2>智能家居的发展阶段</h2><p>要实现一个酷炫的智能家居项目，你就得知道智能家居现在发展到了什么阶段。如果场景设计太超前了，好高骛远，那么最后根本实现不了；而如果场景设计太落后了，都是人家早就玩剩下的，那么也就不酷了。</p><p>从自动化程度的角度分析，智能家居的发展可以分为遥控、场景联动和智能化三个阶段。这是一个智能设备和家居控制系统越来越自主，而人的参与越来越少的过程。</p><ol>\n<li><strong>遥控</strong></li>\n</ol><p>你可能马上就想到了电视和空调的遥控器。不过，通过 Wi-Fi、BLE 和 ZigBee 等技术手段联网的设备，还可以有多种多样的遥控方式。智能手机上的 App 和手机系统的语音助手，甚至智能音箱，说到底都是遥控的方式。</p><p>相信你也注意到了，在遥控阶段，<strong>每次跟设备的交互都需要人的参与</strong>。比如扎克伯格的智能电灯，就需要他通过<a href=\"https://www.pingwest.com/a/96883\">语音</a>来控制开关。</p><p><img src=\"https://static001.geekbang.org/resource/image/c7/de/c7364b92e92e6569728cc1ee6ab6d7de.gif\" alt=\"\" title=\"扎克伯格语音控制电灯开关（引自光谱的报道）\"></p><ol start=\"2\">\n<li><strong>场景联动</strong></li>\n</ol><p>在场景联动阶段，<strong>人只需要参与一次跟设备的交互就行了</strong>。你只要设置好联动的逻辑，包括触发条件和执行动作，后续的多个联网设备就会根据这个逻辑依次运行，实现一定程度的自动化。</p><p>扎克伯格在<a href=\"https://www.thesun.co.uk/news/2449965/watch-mark-zuckerbergs-incredible-ai-slave-voiced-by-morgan-freeman-can-shoot-his-outfit-from-a-cannon-and-make-his-family-toast-for-breakfast/\">介绍</a>中提到，他家的系统可以识别门口摄像头捕捉的人脸图片，然后根据日程和访客列表判断要不要开门，并且通知他本人。这就是控制系统、摄像头、门锁和线上日程系统的联动所实现的功能。</p><p><img src=\"https://static001.geekbang.org/resource/image/82/b8/820d51b8cf79c328b5d46c442yy512b8.png\" alt=\"\" title=\"扎克伯格的智能家居系统识别访客（引自Margi Murphy的报道）\"></p><ol start=\"3\">\n<li><strong>智能化</strong></li>\n</ol><p>随着智能家居接入的设备越来越多，它们产生的各类数据越来越多，智能家居自然会发展到智能化的阶段。这时候，<strong>人已经<strong><strong>不需要</strong></strong>再跟设备<strong><strong>频繁</strong></strong>交互了</strong>。家居系统会从你之前的交互中和其他设备收集的数据中学习你的行为模式和喜好，然后控制设备自动处理很多事情，包括提供决策建议。</p><p>我还是以扎克伯格的智能家居系统为例。如果他去国会参加听证会那天，他的 <a href=\"https://www.thesun.co.uk/news/2449965/watch-mark-zuckerbergs-incredible-ai-slave-voiced-by-morgan-freeman-can-shoot-his-outfit-from-a-cannon-and-make-his-family-toast-for-breakfast/\">T 恤加农炮</a>不是射出一件灰色 T 恤衫，而是提醒他“今天适合穿西装打领带出席会议”，那就达到智能化水平了。不过，现在的智能水平还做不到这一点。</p><p><img src=\"https://static001.geekbang.org/resource/image/90/3d/90a8999992fb26787ec5c79037e4e03d.png\" alt=\"\" title=\"扎克伯格的“T恤加农炮”（引自Margi Murphy的报道）\"></p><p>所以现在智能家居正处在场景联动阶段，我们已经可以把一些智能产品组合起来，实现一些生活场景的自动化。如果你有兴趣，可以看看<a href=\"https://m.bilibili.com/video/av48582377/\">这个视频</a>，它比较好地体现了智能家居的发展现状。</p><h2>智能家居产品的设计原则</h2><p>那么，在目前这个场景联动的阶段，我们要怎么围绕生活场景来设计智能家居产品呢？你只要遵守3个原则就行了：</p><ol>\n<li>\n<p><strong>专注单一领域，解决一个问题。</strong>这样问题容易定义，解决方案涉及的技术也就比较少。比如智能照明，解决电灯的联网和开闭功能就可以了。</p>\n</li>\n<li>\n<p><strong>闭环</strong>，也就是<strong>同时包含传感器、执行器和控制器</strong>。这样设备自身就可以实现一定程度的自动化。比如根据光照自动调节灯光就是一个完整的闭环。</p>\n</li>\n<li>\n<p><strong>可以实现</strong>。产品不要包含很难实现的需求或者还没有经过验证的技术，不然要么计划很容易搁浅，要么做到最后发现白白浪费了巨大的资源。</p>\n</li>\n</ol><p>所以，我建议你做这 4 个产品场景：可以手机控制的智能电灯、可以基于光线自动调节的智能电灯、可以语音控制的智能音箱和可以基于环境温湿度和土壤湿度自动浇水的浇花器。它们在市场上都有成熟的产品代表，证明需求是真实存在且可以实现的。</p><h2>智能家居场景的简易物联网系统</h2><p>确定了要做的产品场景，你离物联网系统的设计又进了一步。现在你需要对这些场景进行拆解，看看它们包含的具体组件是什么，以及这些组件分别属于物联网系统的什么部分。</p><p>我以智能电灯为例，给你做一个拆解。</p><ol>\n<li><strong>传感器</strong></li>\n</ol><p>为了实现基于光线强度自动调节电灯打开、关闭和亮度的智能电灯，我们需要使用<strong>光照传感器</strong>。</p><p>传感器是物联网中的设备感知环境和自身状态的重要组件。在智能家居中，传感器还用于感知温度、湿度、声音、图像、气体等很多信息。比如，智能音箱中的麦克风是一种声音传感器。</p><ol start=\"2\">\n<li><strong>执行器</strong></li>\n</ol><p>我们要实现电灯的打开和关闭，也就是控制电路的通断，这时我们需要<strong>继电器</strong>。</p><p>继电器这类执行具体控制动作的组件，被称为执行器。除了电气的开闭，执行器也可以完成机械的动作和加热、制冷等功能。比如扎克伯格的系统中，空调系统、面包机和 T 恤加农炮都是执行器的范畴。</p><ol start=\"3\">\n<li><strong>控制器</strong></li>\n</ol><p>那给执行器控制命令的组件呢，就是控制器。在智能电灯中，我们使用<strong>NodeMCU 开发板</strong>来作为控制器。</p><p>控制器是执行具体应用逻辑的单元。简单理解的话，可以认为控制器基于传感器的数据，执行应用逻辑，然后驱动执行器做出反应。控制器是一个抽象概念，它可能在网关或者边缘计算设备实现，也可能在云端的应用服务器实现。有些复杂的控制逻辑可能会涉及到大数据处理技术或者机器学习算法。</p><ol start=\"4\">\n<li><strong>家庭网关</strong></li>\n</ol><p>光照传感器为了省电，我们采用<strong>BLE</strong>（低功耗蓝牙）技术。不过 BLE 设备需要借助桥接设备才能接入互联网，这个桥接设备被称为<strong>家庭网关</strong>。顺便提一句，一般ZigBee设备也需要网关来接入物联网。（需要说明的是，在实践中家庭网关的功能有可能是其他设备来承担，比如电视、台灯等。在我们的设计中，可以使用智能音箱来兼做家庭网关。）</p><ol start=\"5\">\n<li><strong>用户界面</strong></li>\n</ol><p>为了控制智能电灯的亮度和开关，我们需要使用<strong>智能手机</strong>或者<strong>智能音箱</strong>来输入执行的命令，同时通过它们来查看电灯的状态信息、设置联动场景。</p><p>这些人与设备，或者人与智能家居系统的交互手段就是用户界面。类似的还有电视屏幕、控制面板等。在未来，可能不会有特定的设备作为用户界面，用户界面将无处不在，就像《钢铁侠》里面的场景，你随时可以说话，显示信息悬浮在空中。目前主要的方式还是使用手机，基于语音或者文字来交互。</p><p>当我们按照同样的方法，拆解完这4个场景的基本构成组件，智能家居系统的架构图也就清晰了。</p><p><img src=\"https://static001.geekbang.org/resource/image/e0/0f/e02597f22048a440f208c64cfb49bd0f.jpg\" alt=\"\"></p><p>你可以看到我们最终将会打造 6 个硬件设备，它们分别是：智能电灯、光照传感器、环境温湿度传感器、土壤湿度传感器、自动浇花器和智能音箱。其中，智能音箱也承担家庭网关的功能。</p><p>我把这6个硬件需要的元器件整理到下面的表格中，供你参考。（如有需要，你可以根据<a href=\"https://shimo.im/sheets/D3VVPdwcYRhhQRXh/MODOC\">这份文档</a>自行采购。）</p><p><img src=\"https://static001.geekbang.org/resource/image/25/77/252bbccb32byyd03a040501275ee5477.jpg\" alt=\"\"></p><h2>简易物联网系统的技术架构图</h2><p>现在，我们把上面设计的智能家居系统的架构，代入到物联网的三层体系结构中，就得到了它的技术架构图。</p><p><img src=\"https://static001.geekbang.org/resource/image/77/1b/771fc288a1be173c034cdb4e9cfd8a1b.jpg\" alt=\"\"></p><ol>\n<li><strong>设备层</strong></li>\n</ol><p>传感器、执行器和控制器三个组件相互配合，构成完整的设备功能。而在智能家居中，通信技术的主流选择是Wi-Fi、BLE（低功耗蓝牙）等。Wi-Fi适合带电设备，BLE适合电池供电的低功耗设备。</p><ol start=\"2\">\n<li><strong>网络层</strong></li>\n</ol><p>家庭网关可以让使用BLE技术的设备接入物联网。然后，网关通过 MQTT 协议连接云平台，让这些设备可以和云平台通信。</p><p>在智能家居应用中，为了自动发现设备和服务，UPnP 协议和 mDNS协议也经常被使用。在进阶篇第7讲，我会详细讲解组网相关协议。</p><ol start=\"3\">\n<li><strong>应用层</strong></li>\n</ol><p>之前的课程中，我提到过云平台是数据存储和数据分析处理的支撑平台。同时，云平台也可以为你的App提供 API 接口，让你可以借助手机远程操控联网设备。</p><p>在实战篇，我们将在云平台中，通过 MQTT Broker 来接收温度、湿度等数据，并且开发 Web 服务，通过页面来展示相关数据。</p><h2>小结</h2><p>接下来，我总结一下这一讲的主要内容。</p><ol>\n<li>从自动化程度看，智能家居系统分为遥控、联动控制和智能化三个阶段。目前的智能家居系统已经可以达到场景联动的阶段，而未来需要关注的发展趋势是智能化。</li>\n<li>围绕着遥控和联动控制的功能实现，我们设计了4 个产品场景，它们分别是：可以手机控制的智能电灯、可以基于光线自动调节的智能电灯、可以语音控制的智能音箱和可以基于环境温湿度和土壤湿度自动浇水的浇花器。</li>\n<li>在4个产品场景的实现过程中，你需要打造6个硬件设备，它们分别是：智能电灯、光照传感器、环境温湿度传感器、土壤湿度传感器、自动浇花器和智能音箱（兼做家庭网关）。</li>\n<li>通过梳理整个简易智能家居系统，我们可以发现智能家居包括传感器、执行器、控制器、家庭网关和用户界面这几个构成部分，你可以结合我们设计的简易系统来了解各部分的功能。</li>\n</ol><p>从简易智能家居系统的设计过程，你应该也可以总结出物联网系统设计的一般过程。<br>\n首先，我们需要调查、分析具体领域的知识和发展趋势；<br>\n接着，确定我们要试图提供解决方案的应用场景；<br>\n然后，设计应用场景中的具体产品，包括产品的功能、使用的通信技术和网络协议等；<br>\n最后，我们可以总结解决方案的各个部分，并且与物联网三层体系结构做对应，检视解决方案是否完整、是否合理。</p><p>除了以上这些，我还想跟你说，这一讲提到的树莓派（Raspberry Pi）开发板、NodeMCU 开发板都是主流的开源硬件。开源硬件的流行对智能硬件的发展有着巨大的推进作用。如果你是一个电子发烧友（DIY），那么现在你很容易就可以基于开源硬件组合出一套简易的联网设备，也许你已经做了类似的尝试。</p><p>所以我觉得，如果只是单纯指导你一步步地实现这套系统，那么意义还不够大，也不是我的出发点。我会在后面的章节中结合物联网的具体场景（智能家居）来把物联网的相关技术和体系结构讲解清楚。</p><p>我很欣赏一句话，叫<strong>“知行合一”</strong>。当你学习一个新东西的时候，如果只是看别人做、听别人说，那都是输入，并不会很好地内化为自己的东西。所以第一步输入之后，第二步要认真思考，最后你要做输出，把你学习到的东西讲给别人就是一种输出。</p><p>而且编程和物联网开发最好的输出方式还是要动手实践。在动手的过程中你可以真正把底层原理和核心知识理解透彻，内化成你自己的知识，从而在工作中更加得心应手。这就是我们要在实战篇达到的目的。</p><h2>思考题</h2><p>最后，我给你留一个思考题吧。</p><p>在简易物联网系统中，我们设计了智能电灯和自动浇花器等应用场景。扎克伯格的实践中也有一些很酷的应用。你还可以为自己的家居环境想到什么场景和应用呢？另外，在本讲中，我拆解了智能电灯的构成组件，你可以使用同样的方法，拆解一下自动浇花器的组件吗？</p><p>欢迎在留言区写一写你的奇思妙想，和我一起交流一下。也欢迎你将这个课程分享给你的朋友一起交流学习。</p>",
                "article_title": "05 | 系统实例：怎样设计一个简易物联网系统？"
            }
        ]
    },
    {
        "chapterTitle": "进阶篇",
        "children": [
            {
                "title": "06 | 物模型：如何定义智能电灯？",
                "id": 310441,
                "content": "<p>你好，我是郭朝斌。</p><p>在基础篇最后一讲的智能家居项目里，我们设计了几个小场景，其中就包括智能电灯。如果你只是想自娱自乐，做一个可以用手机 App 控制的电灯，那么只要通过代码实现控制功能就足够了。至于是怎么控制的，电灯有什么状态上报，你自己知道就行了。</p><p>但是，如果你想让智能电灯真正成为物联网系统的一部分，那就不仅仅是在封闭的、确定的场景下写几行代码的事儿了。在物联网平台上，可能有其他人开发的应用需要显示你的智能电灯的状态；也可能有别的设备，比如光照传感器、智能音箱，在场景联动中要控制灯的状态。</p><p>所以，你需要把控制电灯打开和关闭的方法，告诉这些应用和产品的开发人员。同时，这些开发人员也需要了解，智能电灯的状态信息如何获取和解析。那么，你面临的第一个问题就是，<strong>用什么方式提供这些接口信息呢？</strong></p><p>另外，市面上不止一款智能电灯，如果要一一适配，那工作量肯定很大，而且扩展起来会很困难。那么，你面临的第二个问题就是，<strong>平台应用如何避免针对每款智能灯进行定制开发呢？</strong></p><p>计算机领域的软件体系结构采用的是一种<strong>层</strong>的结构，所以有人说过这么一句名言：<strong>“计算机科学领域的任何问题，都可以通过增加一个间接的中间层来解决。”</strong></p><p>按照这个思路，我们就可以在智能电灯实体和平台之间，增加一层标准规范来解决这些问题。就像，你使用不同的浏览器访问极客时间的网站，都可以看到课程的文本、音频、视频等内容，因为这些内容都是基于 <strong>HTML</strong> （HyperText Markup Language，超文本标记语言）等规范组织的。</p><!-- [[[read_end]]] --><p>物联网中的这层规范就是 Thing Specification Language，简称 <strong>TSL</strong>。使用 TSL 描述的物联网中的实体模型，就是<strong>“物模型”</strong>，或者叫做“产品模型”，也有叫“数据模板”的。不过，我认为“物模型”更有物联网专属的感觉，所以在咱们这门课里我都会用“物模型”这个叫法。</p><h2>物模型和设备的关系是什么？</h2><p>物模型是物理世界的实体东西的一个抽象，是进行数字化描述后，用于数字世界的数字模型。这么说可能有点绕，更直接一点说就是，物模型是使用计算机可以理解的语言，说清楚这个产品<strong>是什么</strong>、<strong>能做什么事情</strong>，以及<strong>可以提供哪些信息</strong>。</p><p>而抽象就是要提取出产品的共同特征，形成模型。以智能灯为例，不同的灯，尽管规格不同，但它们的属性是相似，比如都有开关状态的属性，功能逻辑也相仿。我们可以将这些特征标准化，形成智能灯的物模型。</p><p>反过来，物模型也规约了设备的功能。新增加的设备，如果是同一类型的，在设计、研发中，会遵循相同的功能定义，有相同的特征，实现相同的服务。比如，灯都应该有“开”和“关”两种状态。</p><p><img src=\"https://static001.geekbang.org/resource/image/dd/d7/dd2054abb168001194e69873d9f7bbd7.jpg\" alt=\"\"></p><h2>为什么要使用物模型？</h2><p>基于共同的抽象特征，物模型可以让应用程序不再针对一个个的产品设备，而是同一类设备采用相同的处理逻辑。这实际上是<strong>应用开发的基础</strong>。当烟感传感器的数值触发报警时，即使是不同品牌的烟感产品，应用程序也可以对数值做相同的处理和判断，否则只能分别进行数值分析。</p><p>另外，物模型中，设备的功能是明确定义的，可以方便地实现场景联动。比如，光线传感器可以基于光照强度，向智能电灯发送亮度的控制命令，或者开和关的命令。</p><h2>如何定义物模型？</h2><p>那么，如何定义智能电灯的物模型呢？这里我想告诉你结论，我们一般是通过属性、事件和动作这三种功能元素来定义。接下来，我就一一和你介绍。</p><p>我们知道，智能电灯的状态，要么是打开，要么是关闭；当进行控制时，这两种状态还会相互转换。此外，有些灯还可以根据需求设置不同的亮度、颜色和色温等。</p><p>它们的共同点就是，都描述了产品设备运行时的某种状态，我们用<strong>属性（Property）</strong>来表示。</p><p>属性的特点是可读可写。也就是说，应用程序可以读取属性，也可以设置设备的属性。我们还可以看到类似的例子，比如环境监测设备的温度、湿度这两个属性等。</p><p>如果智能电灯在运行过程中，出现了低电压的情况，或者发生了硬件故障，那么联网的设备可以将这些信息发送出去，通知你来及时作出处理。</p><p>这类由产品设备在运行过程中产生的信息、告警和故障等，就是<strong>事件（Event）</strong>。</p><p>一个事件可以包含多个输出参数。事件不同于属性，事件是设备上报的，不能由应用来设置。类似的例子，还有某任务完成时的消息，环境传感器检测到污染物的告警等。</p><p>我们再看生活中关于灯的一个使用场景：第一次约会的时候，你希望灯能够烘托出浪漫的气氛，就要调节灯的颜色、亮度和色温。如果分别设置属性，将会非常繁琐，这时你会想到要为灯增加一个场景模式的功能，一个命令就可以设置到浪漫模式。</p><p>这种设备可以被调用的能力或者方法，就是<strong>动作（Action）</strong>，也被称作<strong>服务（Service）</strong>。</p><p>动作由应用下发给设备，设备可以返回结果给应用。从执行的流程看，动作还可以进一步分为同步和异步。这取决于动作是否是个耗时的操作，以及其他应用逻辑对于动作执行结果的依赖关系。</p><p>你可能想，设置属性也可以改变设备的状态，那它们的区别是什么呢？相比于属性，动作是应用下发到设备的控制命令；动作可通过一条指令实现更复杂的业务逻辑，比如，调低温度 5 度，旋转摄像头 30°等。</p><p><img src=\"https://static001.geekbang.org/resource/image/fc/e7/fc9a7eef37e61930d6f8fd761c5f97e7.jpg\" alt=\"\"></p><p>到这里，我们定义了属性、事件和动作这三类功能，也就完成了物模型的定义。</p><p>接下来，我们要做的是通过数据来描述它们。和编程语言一样，作为一种模型语言，物模型的数据也有不同的数据类型。它们主要包括六种：</p><ol>\n<li><strong>布尔型</strong>（Bool）：非真即假的二值型变量。例如，开关功能只有开、关两种状态。</li>\n<li><strong>整数型</strong>（Int）：可用于线性调节的整数变量。例如，电灯的亮度是一个整数范围。</li>\n<li><strong>字符<strong><strong>串</strong></strong>型</strong>（String）：以字符串形式表达的功能点。例如，灯的位置。</li>\n<li><strong>浮点型</strong>（Float）：精度为浮点型的功能点。例如，电压值的范围是0.0 - 24.0。</li>\n<li><strong>枚举型</strong>（Enum）：自定义的有限集合值。例如，灯的颜色有白色、红色、黄色等。</li>\n<li><strong>时间型</strong>（Timestamp）：String 类型的 UTC 时间戳。</li>\n</ol><p>对于整数型、浮点型的数值，它们的单位可以是百分比、电压、米等。</p><p>物模型一般是用 <strong>JSON 格式</strong>来表述模型元素。JSON 是 Web 开发中，经常使用的数据格式，相比于 XML，它更加简洁、清晰，也更轻量级。</p><p>在实践中，你手动写完 JSON 格式的物模型后，可以使用检测工具来验证语法是否正确，比如，在线检测工具 <a href=\"https://jsonschemalint.com/\">JSON Schema Lint</a>。</p><p>接下来，我们就按照属性、事件、动作/服务这三个要素，一起看看如何用JSON格式来定义智能电灯的物模型吧。</p><h2>定义智能电灯的物模型</h2><p>智能电灯的开关属性是布尔类型，是必须有的属性。它可以通过 JSON 表述如下：</p><pre><code>{\n      &quot;id&quot;: &quot;power_switch&quot;,   //属性的唯一标识\n      &quot;name&quot;: &quot;电灯开关&quot;,      //名称\n      &quot;desc&quot;: &quot;控制电灯开灭&quot;,   //属性的详细描述\n      &quot;required&quot;: true,       //表示此属性是否必需包含，是\n      &quot;mode&quot;: &quot;rw&quot;,           //属性的模式，r代表读，w代表写\n      &quot;define&quot;: {             //属性的数值定义\n        &quot;type&quot;: &quot;bool&quot;,       //数值的类型，布尔\n        &quot;mapping&quot;: {          //具体数值的含义\n          &quot;0&quot;: &quot;关&quot;,           //0表示灯关闭\n          &quot;1&quot;: &quot;开&quot;            //1表示灯打开\n        }\n      }\n    }\n</code></pre><p>智能电灯的电压是需要监控的数值，当电压低时，可以上报这个事件。这个事件有一个参数，即电压值，数据类型是浮点类型。JSON 格式的描述如下：</p><pre><code>{\n      &quot;id&quot;: &quot;low_voltage&quot;,      //事件唯一标识\n      &quot;name&quot;: &quot;LowVoltage&quot;,      //事件名称\n      &quot;desc&quot;: &quot;Alert for device voltage is low&quot;,  //事件的描述\n      &quot;type&quot;: &quot;alert&quot;,          //事件的类型，告警\n      &quot;required&quot;: false,        //表示此属性是否必需包含，否\n      &quot;params&quot;: [                //事件的参数\n        {\n          &quot;id&quot;: &quot;voltage&quot;,        //事件参数的唯一标识\n          &quot;name&quot;: &quot;Voltage&quot;,      //事件参数的名称\n          &quot;desc&quot;: &quot;Current voltage&quot;,  //参数的描述\n          &quot;define&quot;: {                 //参数的数值定义\n            &quot;type&quot;: &quot;float&quot;,          //数值类型，浮点数\n            &quot;unit&quot;: &quot;V&quot;,              //数值的单位，伏\n            &quot;step&quot;: &quot;1&quot;,              //数值变化的步长，1\n            &quot;min&quot;: &quot;0.0&quot;,              //数值的最小值\n            &quot;max&quot;: &quot;24.0&quot;,             //数值的最大值\n            &quot;start&quot;: &quot;1&quot;                //事件的起始值\n          }\n        }\n      ]\n    }\n</code></pre><p>动作的定义，和属性、事件的定义过程类似，这里我就不再单独解释了。我们直接将所有属性、事件和动作合并，就得到了智能电灯物模型的完整JSON格式：</p><pre><code>{\n  &quot;version&quot;: &quot;1.0&quot;,            //模型版本\n  &quot;properties&quot;: [              //属性列表\n    {\n      &quot;id&quot;: &quot;power_switch&quot;,    //电灯开关属性\n      &quot;name&quot;: &quot;电灯开关&quot;,\n      &quot;desc&quot;: &quot;控制电灯开灭&quot;,\n      &quot;required&quot;: true,\n      &quot;mode&quot;: &quot;rw&quot;,\n      &quot;define&quot;: {\n        &quot;type&quot;: &quot;bool&quot;,\n        &quot;mapping&quot;: {\n          &quot;0&quot;: &quot;关&quot;,\n          &quot;1&quot;: &quot;开&quot;\n        }\n      }\n    },\n    {\n      &quot;id&quot;: &quot;brightness&quot;,        //亮度属性\n      &quot;name&quot;: &quot;亮度&quot;,\n      &quot;desc&quot;: &quot;灯光亮度&quot;,\n      &quot;mode&quot;: &quot;rw&quot;,\n      &quot;define&quot;: {\n        &quot;type&quot;: &quot;int&quot;,\n        &quot;unit&quot;: &quot;%&quot;,\n        &quot;step&quot;: &quot;1&quot;,\n        &quot;min&quot;: &quot;0&quot;,\n        &quot;max&quot;: &quot;100&quot;,\n        &quot;start&quot;: &quot;1&quot;\n      }\n    },\n    {\n      &quot;id&quot;: &quot;color&quot;,            //电灯颜色属性\n      &quot;name&quot;: &quot;颜色&quot;,\n      &quot;desc&quot;: &quot;灯光颜色&quot;,\n      &quot;mode&quot;: &quot;rw&quot;,\n      &quot;define&quot;: {\n        &quot;type&quot;: &quot;enum&quot;,\n        &quot;mapping&quot;: {\n          &quot;0&quot;: &quot;Red&quot;,\n          &quot;1&quot;: &quot;Green&quot;,\n          &quot;2&quot;: &quot;Blue&quot;\n        }\n      }\n    },\n    {\n      &quot;id&quot;: &quot;color_temp&quot;,        //色温属性\n      &quot;name&quot;: &quot;色温&quot;,\n      &quot;desc&quot;: &quot;灯光冷暖&quot;,\n      &quot;mode&quot;: &quot;rw&quot;,\n      &quot;define&quot;: {\n        &quot;type&quot;: &quot;int&quot;,\n        &quot;min&quot;: &quot;0&quot;,\n        &quot;max&quot;: &quot;100&quot;,\n        &quot;start&quot;: &quot;0&quot;,\n        &quot;step&quot;: &quot;10&quot;,\n        &quot;unit&quot;: &quot;%&quot;\n      }\n    }\n  ],\n  &quot;events&quot;: [                        //事件列表\n    {\n      &quot;id&quot;: &quot;status_report&quot;,          //运行状态报告\n      &quot;name&quot;: &quot;DeviceStatus&quot;,\n      &quot;desc&quot;: &quot;Report the device status&quot;,\n      &quot;type&quot;: &quot;info&quot;,\n      &quot;required&quot;: false,\n      &quot;params&quot;: [                      //事件参数列表\n        {\n          &quot;id&quot;: &quot;status&quot;,\n          &quot;name&quot;: &quot;running_state&quot;,\n          &quot;desc&quot;: &quot;Report current device running state&quot;,\n          &quot;define&quot;: {\n            &quot;type&quot;: &quot;bool&quot;,\n            &quot;mapping&quot;: {\n              &quot;0&quot;: &quot;normal&quot;,\n              &quot;1&quot;: &quot;fault&quot;\n            }\n          }\n        },\n        {\n          &quot;id&quot;: &quot;message&quot;,\n          &quot;name&quot;: &quot;Message&quot;,\n          &quot;desc&quot;: &quot;Some extra message&quot;,\n          &quot;define&quot;: {\n            &quot;type&quot;: &quot;string&quot;,\n            &quot;min&quot;: &quot;0&quot;,\n            &quot;max&quot;: &quot;64&quot;\n          }\n        }\n      ]\n    },\n    {\n      &quot;id&quot;: &quot;low_voltage&quot;,            //低电压告警事件\n      &quot;name&quot;: &quot;LowVoltage&quot;,\n      &quot;desc&quot;: &quot;Alert for device voltage is low&quot;,\n      &quot;type&quot;: &quot;alert&quot;,\n      &quot;required&quot;: false,\n      &quot;params&quot;: [\n        {\n          &quot;id&quot;: &quot;voltage&quot;,\n          &quot;name&quot;: &quot;Voltage&quot;,\n          &quot;desc&quot;: &quot;Current voltage&quot;,\n          &quot;define&quot;: {\n            &quot;type&quot;: &quot;float&quot;,\n            &quot;unit&quot;: &quot;V&quot;,\n            &quot;step&quot;: &quot;1&quot;,\n            &quot;min&quot;: &quot;0.0&quot;,\n            &quot;max&quot;: &quot;24.0&quot;,\n            &quot;start&quot;: &quot;1&quot;\n          }\n        }\n      ]\n    },\n    {\n      &quot;id&quot;: &quot;hardware_fault&quot;,            //硬件错误事件\n      &quot;name&quot;: &quot;Hardware_fault&quot;,\n      &quot;desc&quot;: &quot;Report hardware fault&quot;,\n      &quot;type&quot;: &quot;fault&quot;,\n      &quot;required&quot;: false,\n      &quot;params&quot;: [\n        {\n          &quot;id&quot;: &quot;name&quot;,\n          &quot;name&quot;: &quot;Name&quot;,\n          &quot;desc&quot;: &quot;Name like: memory,tf card, censors ...&quot;,\n          &quot;define&quot;: {\n            &quot;type&quot;: &quot;string&quot;,\n            &quot;min&quot;: &quot;0&quot;,\n            &quot;max&quot;: &quot;64&quot;\n          }\n        },\n        {\n          &quot;id&quot;: &quot;error_code&quot;,\n          &quot;name&quot;: &quot;Error_Code&quot;,\n          &quot;desc&quot;: &quot;Error code for fault&quot;,\n          &quot;define&quot;: {\n            &quot;type&quot;: &quot;int&quot;,\n            &quot;unit&quot;: &quot;&quot;,\n            &quot;step&quot;: &quot;1&quot;,\n            &quot;min&quot;: &quot;0&quot;,\n            &quot;max&quot;: &quot;2000&quot;,\n            &quot;start&quot;: &quot;1&quot;\n          }\n        }\n      ]\n    }\n  ],\n  &quot;actions&quot;: [],                  //动作列表\n  &quot;profile&quot;: {                    //产品参数\n    &quot;ProductId&quot;: &quot;8D1GQLE4VA&quot;,    //产品ID\n    &quot;CategoryId&quot;: &quot;141&quot;            //产品分类编号\n  }\n}\n</code></pre><h2>每个模型都要从头定义吗？</h2><p>那我们在创建自己的新模型时，是不是每次都需要从头定义这些属性、事件和动作呢？有没有更简便的方式呢？答案当然是有的。</p><p>创建模型的时候，有拷贝和继承两种模式，这两种创建模式的不同主要体现在<strong>模型关系</strong>上。</p><p><strong>“拷贝”模式</strong>类似于编程语言中的值拷贝，新建模型与被拷贝模型有完全相同的三元素，两个模型相互独立，模型变更互不影响。</p><p><strong>“继承”模式</strong>就是面向对象编程中的继承概念，新建模型被定义为“子模型”，被继承的模型定义为“父模型”。</p><p>继承的具体特征是：</p><ol>\n<li>子模型继承父模型的所有要素，且继承的元素无法被修改。</li>\n<li>子模型可以再被继承，支持多层的继承关系。</li>\n<li>子模型可以创建独立的要素，但子模型中新增的要素不可以和所有上级父模型中的元素重名。</li>\n<li>当父模型中的元素发生变更时，子模型中继承自父模型的元素同步变更，保持与父模型一致。</li>\n</ol><p>以我们刚刚定义的智能电灯的物模型为例，如果要增加安装位置的属性，可以继承已有的模型，然后再增加安装位置的属性。（注意：下面的 JSON 表述省略了与父模型重复的内容。）</p><pre><code>{\n...\n{\n      &quot;id&quot;: &quot;name&quot;,                  //灯位置属性\n      &quot;name&quot;: &quot;灯位置名称&quot;,\n      &quot;desc&quot;: &quot;灯位置名称：书房、客厅等&quot;,\n      &quot;mode&quot;: &quot;rw&quot;,\n      &quot;required&quot;: false,\n      &quot;define&quot;: {\n        &quot;type&quot;: &quot;string&quot;,\n        &quot;min&quot;: &quot;0&quot;,\n        &quot;max&quot;: &quot;64&quot;\n      }\n    }\n...\n}\n</code></pre><p>到这里，我们已经了解了物模型，并且完整实践了一遍物模型的创建。接下来，我给你延伸一下，讲两个和物模型相关的概念。</p><h2>物模型的拓展应用</h2><p>你也许听到过“设备影子”和“数字孪生”这两个概念，它们和我们这里说的“物模型”是什么关系呢？</p><h3>设备影子</h3><p>设备影子用于<strong>缓存设备状态</strong>。应用程序可以通过设备影子直接获取设备最后一次更新的属性值，而无需每次都访问设备。设备在线时，可以直接获取应用指令；设备离线后，再次上线可以主动拉取应用指令。</p><p>我们可以再想象一个场景。如果设备网络稳定，很多应用程序请求获取设备状态，设备需要根据请求响应多次，即使响应的结果是一样的。但是可能设备本身处理能力有限，其实无法负载被请求多次的情况。</p><p>使用设备影子机制，设备只需要主动同步状态给设备影子一次，多个应用程序请求设备影子获取设备状态，即可获取设备最新状态，做到应用程序和设备的解耦。</p><p>再比如，智能电灯的开关状态这个属性，手机 App 可以远程控制，你也可以在本地通过物理开关改变。如果网络不稳定，那么平台上存储的状态，和电灯设备的真实状态可能会不一致，导致后续操作逻辑错误。</p><p>设备影子可以通过双向的同步，实现服务器端和设备端属性的一致，从而解决这个问题。</p><h3>数字孪生（Digital Twin）</h3><p>物模型是物理实体的数字化模型，但主要针对的是物联网中应用的开发和设备的互操作。</p><p>这个模型如果更进一步，集成了物理实体的各类数据，那就是物理实体的<strong>忠实映射</strong>。同时，在物理实体的整个生命周期中，它会和实体一起进化，积累各种信息和知识，并且促进物理实体的优化。这样的模型就是物理实体的数字孪生。</p><p>在工业物联网领域，这个概念已经有了很多的探讨和应用。</p><p>比如，特斯拉公司为其生产的每一辆电动汽车都建立了数字孪生模型，相关的模型数据保存在公司的数据库中，以便在测试中排查故障，为用户提供更好的服务。</p><h2>小结</h2><p>总结一下，在这一讲中，我通过智能电灯的例子讲解了物模型。</p><ol>\n<li>物模型是物理世界中产品设备的数字化模型，它对设备的共同特征进行了抽象，同时规约了设备的设计。</li>\n<li>物模型一般是使用 TSL 描述的 JSON 格式文件。</li>\n<li>物模型包括属性、事件和动作三个功能元素。其中，属性可读可写；事件可以包括多个参数；动作包括应用下发的命令，和设备返回的响应信息</li>\n</ol><p>在实践中，定义物模型时，你需要注意物模型三个功能元素的区别，尤其要了解属性和动作的联系和不同。不好的定义会给功能实现带来困难，比如，将智能电灯的“开”和“关”，定义为两个不同的动作。</p><p>物模型在物联网系统开发中，作用重大，它为应用开发提供了统一的数据模板，方便了场景联动的实现，同时，为平台上实现设备影子提供了基础。</p><p>类似地，数字孪生也正是建立在物理实体的数字模型之上的重要技术方向。这里作为一个引子，有兴趣的话，你可以深入了解一下，也许对你在工作中做系统设计有帮助。</p><h2>思考题</h2><p>最后，我还是给你留个思考题作为结尾。</p><p>物模型是实战开发的基础，咱们最后再通过一个练习来强化下学习效果吧。请你定义一个环境温湿度传感器的物模型。你可以从属性、事件、动作三个元素的角度思考一下，而且一定要动手写一写。</p><p>欢迎在留言区写出你的答案，和我一起交流一下。在后面的实战中，我们也会涉及到温湿度传感器的物模型。如果你的朋友对物联网有兴趣，也欢迎你将这个课程分享给他们一起学习进步。</p>",
                "article_title": "06 | 物模型：如何定义智能电灯？"
            },
            {
                "title": "07 | 零配置组网：设备如何发现彼此？",
                "id": 311616,
                "content": "<p>你好，我是郭朝斌。</p><p>不知道你还记不记得，在基础篇的<a href=\"https://time.geekbang.org/column/article/306976\">第2讲</a>中，我介绍了 Wi-Fi 设备的配网方式，比如一键配网技术（Smart Config）和设备热点配网技术。这些技术已经可以实现<strong>一定程度的自动化</strong>，让设备比较方便地连接上Wi-Fi 热点。</p><p>同时，我也提到了零配置配网方式，它试图通过已连接上Wi-Fi热点的设备，来实现可信任设备<strong>完全自动化</strong>的配网。</p><p>但是，你可不要把<strong>零配置配网</strong>（Zero Configuration Provisioning）和我们这一讲要谈的<strong>零配置组网</strong>（Zero Configuration Networking ，ZEROCONF）混淆了。配网只是第一步，因为物联网设备无法方便地输入信息，所以相比手机或电脑，我们引入了这个额外的操作步骤。</p><p>配网成功之后，我们还需要组网，也就是让设备获得一个<strong>自己的IP地址</strong>，同时也知道局域网内的<strong>路由器</strong>（Router）的IP地址和<strong>DNS</strong>（Domain Name System）的IP地址等信息。设备自己的IP地址是它在TCP/IP 网络中的唯一标识；路由器可以把设备的数据包正确地转发出去；而DNS服务器可以帮忙解析出数据包中需要设置的目的地 IP 地址。</p><blockquote>\n<p>温馨提示：如果你对IP地址和DNS这样的基本概念还不是很熟，可以学习<a href=\"https://time.geekbang.org/column/intro/100007101\">《趣谈网络协议》</a>等课程临时恶补一下。因为这一讲还会涉及不少网络基础知识，对它们有一定了解的话，你的学习效果会更好。</p>\n</blockquote><!-- [[[read_end]]] --><p>零配置组网就是把这些工作自动化，不需要用户手动去操作，甚至可以让这个设备与网络内的其他设备配合工作。</p><p>比如，你要为自己的智能家居系统加一个投屏设备（它可以外接普通电视或者显示器，让你可以将手机或者电脑的屏幕在大屏上显示出来）。你希望这个投屏设备接入Wi-Fi热点之后，你就可以在手机上直接发现它，并且马上开始投屏，看自己想看的电影。</p><p>这个想法非常美，但是你知道要怎么实现吗？其实并不难，你只要掌握我在这一讲介绍的零配置组网就可以了。</p><h3>设备如何获取 IP 地址？</h3><p>零配置组网的第一步，就是自动分配IP地址。</p><p>不知道你以前有没有这样的经验，在学校宿舍或者公司，当你的电脑通过网线连接网络时（现在用网线连网的方式已经不那么常见了），有时电脑桌面右下角会弹出气泡，提示“ IP 地址冲突”。</p><p>这是因为你的电脑的IP地址，被网络内其他电脑占用了。所以你就需要打开网络配置的界面，手动填写一个不同的 IP 地址。对于非专业人士来说，这并不是一个很简单的事情；而且对于特殊的<strong>子网掩码</strong>（比如不像“255.255.25<strong>5</strong>.0”这样整齐，而是“255.255.25<strong>3</strong>.0”这种），即使有经验的用户，可能也很难确定<strong>子网号</strong>和<strong>主机号</strong>分别是什么。</p><p>现在随着Wi-Fi的普及，我们连网的时候基本上不会再碰到这种情况了。这一方面是因为每一个 Wi-Fi 热点接入的设备数量是有限的，另一方面则是因为 Wi-Fi 路由器提供了完善的 <strong>IP 地址自动分配功能</strong>。</p><h4>DHCP 协议</h4><p>这个自动分配功能是基于 <strong>DHCP 协议</strong>（Dynamic Host Configuration Protocol，动态主机配置协议）实现的。DHCP 协议的前身是 <strong>BOOTP 协议</strong>（Bootstrap Protocol），从“Bootstrap”这个名字你就可以看出来，它解决的正是一个设备接入 IP 网络后，需要完成的第一件事——获取 IP 地址。</p><p>在网络发展的初期，接入网络的设备很少，所以，网络地址的分配和设置都是管理员手动来完成的。你可能想象不到，最初整个互联网的 DNS 数据库都是手动维护和更新的。</p><p>但是随着接入网络的设备越来越多，而且设备更加便携，经常移动来移动去，手动的方式就跟不上时代发展了。DHCP 协议正是在这种背景下出现的。</p><p>也许你对DHCP的名字很熟悉，但我还是想在这里稍微展开一下，带你了解它背后的工作原理，这样你就能在开发中更好地使用它。</p><p>DHCP 使用了服务器-客户端的架构模型。</p><ul>\n<li>当一个设备（你的手机）接入网络时，它自己就会作为DHCP 客户端，请求网络地址。</li>\n<li>然后DHCP 服务器（家里的Wi-Fi路由器）会从地址池中挑选一个IP地址，分配给这个设备。</li>\n<li>当设备不再使用这个 IP 时（你带着手机出门/睡觉飞行模式），DHCP 服务器会进行回收，之后再分配给其他有需要的设备（你新买的平板）使用。</li>\n</ul><p>DHCP 服务器与设备之间的通信是通过 <strong>UDP 传输协议</strong>完成的。因为 UDP 有一个优势，那就是不需要提前建立连接关系。DHCP 服务器的端口号是 67，设备的端口号是 68，它们一般的交互过程是这样的：</p><p><img src=\"https://static001.geekbang.org/resource/image/5a/aa/5a1b86b9a70504521010262148e761aa.jpg\" alt=\"\"></p><ol>\n<li><strong>Discover</strong>：设备以广播的方式发送 DHCP Discover 消息，表示需要获取 IP 地址。</li>\n<li><strong>Offer</strong>：DHCP 服务器收到这个消息后，会发出 DHCP Offer 消息，作为回应。消息中带有 DHCP 服务器为设备分配的 IP 地址，也会包含其自身的 IP 地址。</li>\n<li><strong>Request</strong>：设备收到 DHCP Offer 消息后，将会广播一条 DHCP Request 消息，正式向 DHCP 服务器请求这个 IP 地址。</li>\n<li><strong>ACK</strong>：DHCP 服务器收到 DHCP Request 消息后，会判断服务器 IP 是否和自己的地址一致。如果一致，马上向设备回复 DHCP ACK 消息，并指定好 IP 地址和它的租用期限。</li>\n<li><strong>Decline</strong>：设备收到 DHCP ACK 消息后，还会验证一下 IP 地址是否可用。如果地址冲突，就说明不可用，它会发出 DHCP Decline 消息；如果地址不冲突，就可用的，设备将会按照租期使用这个 IP 地址。</li>\n<li><strong>Release</strong>：当设备不使用这个 IP 地址时，设备可以通过发送 DHCP Release 消息，来释放它。这样 DHCP 服务器可以重新分配这个 IP 地址。</li>\n</ol><h3>如何让手机自动发现投影仪呢？</h3><p>借助DHCP协议，当你的投屏设备接入Wi-Fi热点后，就可以自动获得一个自己的IP地址，比如“192.168.1.100”，同时还会自动得到路由器（Router）的IP地址，并且完成DNS的IP地址的自动设置。</p><p>那接下来，怎么让手机自动发现它，然后直接使用呢？</p><p>不知道你留意过没有，如果你新买了一台打印机，当这台打印机连上家里的 Wi-Fi 之后，你在电脑上打印文件时，它会自动显示出来供你选择。这是怎么实现的呢？</p><p>分析一下，一定是电脑通过某种方式知道有这台设备，并且知道它就是打印机，可以提供打印服务。打印机被电脑自动识别的这个过程，就是借助UPnP协议完成的。</p><h4>UPnP 协议</h4><p>UPnP 是 Universal Plug and Play 的简称，它要实现的目标就是网络设备的即插即用。</p><p>UPnP 由设备寻址、设备发现、设备描述、设备控制、事件通知和基于 HTML 的描述界面六部分构成。其中设备寻址同样是基于我刚介绍过的 DHCP 实现，如果网络内没有DHCP服务器，UPnP会基于自己的AutoIP方法指定一个IP地址。</p><p>从整体看，UPnP 是一个<strong>多层协议构成的框架体系</strong>，每一层都以相邻的下层为基础，同时又是相邻上层的基础，直至达到应用层为止。你可以参考下面的图片。</p><p><img src=\"https://static001.geekbang.org/resource/image/99/a6/99edd1ea26dcd96eb73c6bb4acde4da6.jpg\" alt=\"\"></p><p>这里我重点介绍一下第三层（从下往上数），它基于 HTTP、HTTPU、HTTPMU协议，属于传送协议层。传送的内容都是经过“封装”之后，存放在特定的XML文件中的。用于<strong>设备和服务发现</strong>的SSDP（Simple Service Discovery Protocol，简单服务发现协议）协议就是基于XML 传送数据的。</p><p>你不要被SSDP协议的名字迷惑了，其实它既提供了服务发现的功能，也提供了设备发现的功能。我们可以基于 SSDP中的M-SEARCH方法来查询设备，然后基于设备的响应，获得设备的服务能力的描述信息。同时设备可以通过NOTIFY 方法向网络通知自己的服务能力。</p><p>借助UPnP协议，你的设备就可以自动被发现和使用了。这个自动化的过程，我们通常用一个专有名词来概括，也就是零配置组网。梳理一下，零配置组网包括三个方面的技术内核：</p><ol>\n<li>为网络设备自动分配 IP 地址，一般涉及DHCP协议和AutoIP方法；</li>\n<li>自动发现和解析设备，主要是基于SSDP协议；</li>\n<li>自动传播和发现各网络设备提供的服务，主要也是基于SSDP协议。</li>\n</ol><p>这里我贴一下我家里小米电视盒子的一个 UPnP 的组播包的内容。它每3秒就有一包，这样用户体验更好，手机或者电脑投屏时更容易发现它。</p><pre><code>NOTIFY * HTTP/1.1\nHOST: 239.255.255.250:1900\nCACHE-CONTROL: max-age=66\nLOCATION: http://192.168.31.188:49152/description.xml\nNT: urn:schemas-upnp-org:service:ConnectionManager:1\nNTS: ssdp:alive\nSERVER: Linux/3.14.29, UPnP/1.0, Portable SDK for UPnP devices/1.6.13\nUSN: uuid:F7CA5454-3F48-4390-8009-483842e84c17::urn:schemas-upnp-org:service:ConnectionManager:1 \n</code></pre><p>你可以发现，它是基于HTTP1.1版本，准确地说，是 HTTPMU协议；同时你可以看到组播地址，端口号是1900。</p><p>那为了实现UPnP协议，你可以使用哪些开源的代码实现呢？</p><p>比较流行的开源库是 <a href=\"https://pupnp.sourceforge.io/\">libupnp</a>，小米电视盒子使用的就是这个开源库。另外还有一个选择是<a href=\"https://wiki.gnome.org/Projects/GUPnP\">GUPnP项目</a>，它包括几个不同的子项目，比如实现SSDP协议的<a href=\"https://gitlab.gnome.org/GNOME/gssdp/\">GSSDP项目</a>。</p><p>Android平台上有一个开源库<a href=\"https://github.com/4thline/cling\">Cling</a>，它是<a href=\"http://fourthline.org/\">4th Line组织</a>开发的，你可以参考。现在也只能说“参考”，使用的话，需要谨慎评估，因为它已经不再被维护。</p><h4>mDNS 和 DNS-SD</h4><p>除了 UPnP 协议，零配置组网还可以使用别的协议标准，比如 mDNS 和 DNS-SD 协议。</p><p>说起这两个协议，你可能比较陌生，不过苹果设备的 <strong>AirDrop功能</strong>你可能比较熟悉。AirDrop 是通过 <strong>Bonjour 服务</strong>来发现网络上的其他苹果设备的。这个 Bonjour 服务就是 mDNS 协议和 DNS-SD 协议的具体实现。</p><p><strong>mDNS</strong> （Multicast DNS）协议允许设备在本地的 DNS 名字空间，设置一个本地的域名。之后被询问的时候，它就通过 UDP 把 IP 地址广播出来，这样其它的设备就可以找到它。你可以简单地把 mDNS 理解为 <strong>DNS 的本地网络版本</strong>。</p><p>比如，主机 A 是 FTP 服务，它接入网络，并开启了 mDNS 服务，就会向 mDNS 服务注册服务信息：</p><p>我提供 FTP 服务，我的IP是 192.168.1.101，端口是 21。</p><p>当主机 B 接入相同的网络时，如果它向主机 B 的 mDNS 服务请求，需要找局域网内 FTP 服务器，主机 B 的 mDNS 就会在局域网内向其他设备的 mDNS 询问。然后，它就会找到主机 A 的 IP 地址和端口号。</p><p><strong>DNS-SD</strong>（DNS Service Discovery）  协议，一般是和 mDNS 一起使用的。它使用三种 DNS 协议的记录类型来定义协议内容，三个记录分别是：PTR 记录、SRV 记录和 TXT 记录。它提供了服务发现的功能，作用类似于上面讲到的 SSDP 协议。</p><h3>小结</h3><p>总结一下，在这一讲中，我介绍了零配置组网的相关技术。零配置组网是一个技术组合，它要实现的目的是自动化网络设备的初始配置过程，让用户不需要额外的手动操作。</p><ol>\n<li>零配置组网的第一步是为网络设备自动分配 IP 地址。DHCP 协议是实现设备寻址的标准技术。它是工作在 UDP 协议之上的应用层协议，提供了完善的 IP 地址请求、IP地址分配和租期管理等功能。如果网络内没有DHCP服务器，在UPnP中定义了AutoIP方法，设备可以自己分配IP地址。在最新的UPnP规范中 AutoIP 切换到了 Link-Local Addressing规范。这类IP地址一般是“<strong>169.254</strong>.0.0/16”范围的地址。</li>\n<li>第二步是自动发现和解析设备的名称。在UPnP中一般是基于SSDP协议，另一种替代的方案是 mDNS 协议。</li>\n<li>第三步是自动传播和发现各网络设备提供的服务，一种选择是采用SSDP协议；另一种方案是基于mDNS的DNS-SD协议。</li>\n</ol><p>UPnP协议整合了DHCP、AutoIP和SSDP等协议规范，提供了一个完整的组网协议框架。UPnP 协议实现的功能非常完善，比如，基于SOAP 提供了设备控制的能力，但是也引来了很多安全隐患，这个在后面我还会介绍到。</p><p>我在这一讲介绍的方法主要关于Wi-Fi设备的。你可能想问，那蓝牙和 ZigBee 设备怎么办呢？其实关于蓝牙和ZigBee这类设备，智能家居厂家一般都会制定自己的私有协议，比如小米有<strong>Mibeacon协议</strong>，我会在实战篇再为你介绍。</p><p>除了这些私有协议，行业内也有一些标准组织主导的开放协议，比如 <strong>AllJoyn 协议</strong>。它为蓝牙和ZigBee设备提供了设备发现和控制的解决方案。现在，AllJoyn 已经和 IoTivity 合并。这个合并是为了在物联网场景下，让零配置组网技术进一步发展。</p><p>具体来说，因为物联网设备用了很多不同的通信技术，所以AllJoyn提供了一个抽象层。它为底层网络协议栈定义了统一的接口，使得软件工程师可以相对容易地添加和安装新的网络。</p><p>AllJoyn 还采用了一种易于理解的对象模型和远程方法调用（RMI）机制，并且它重新实现了总线协议，基于D-BUS规范和扩展D-BUS协议，用来支持分布式设备。</p><p>因为相对来说，AllJoyn协议的行业应用还处于早期，我就不展开介绍了，有这方面需求或者兴趣的话，推荐你可以到它的<a href=\"https://openconnectivity.org/technology/reference-implementation/alljoyn/\">官网</a>详细了解。</p><p>我这里总结了一个思维导图，供你参考。</p><p><img src=\"https://static001.geekbang.org/resource/image/6e/7b/6e34893e226d5de8e5a5aa6d5059437b.jpg\" alt=\"\"></p><h3>思考题</h3><p>最后，我还是给你留一个思考题吧。</p><p>在 DHCP 协议的流程介绍中，我提到当设备收到 DHCP 服务器响应的 DHCP ACK 消息后，并不会立即使用这个 IP 地址，而是要先检测一下 IP 地址是否有效。那设备是通过什么方式检测 IP 地址的有效性的呢？</p><p>你可以在留言区和我交流你的思考。同时，也欢迎你将这一讲分享给你的朋友一起交流学习。</p>",
                "article_title": "07 | 零配置组网：设备如何发现彼此？"
            },
            {
                "title": "08 | MQTT：在实践中掌握一个通信协议",
                "id": 312691,
                "content": "<p>你好，我是郭朝斌。</p><p>在基础篇的<a href=\"https://time.geekbang.org/column/article/307518\">第 3 讲</a>中，我介绍了几种物联网系统中常用的网络协议。它们是物联网设备之间沟通的“语言”，使用同一种语言，双方才能通信成功。</p><p>那么，在这么多网络协议当中，最流行的是哪一种呢？毫无疑问，是MQTT协议，它甚至已经成为物联网系统事实上的网络协议标准。如果你想从事物联网开发，就一定要掌握MQTT。</p><p>所以这一讲，我就会带你了解MQTT，在实践中熟悉它的特性。</p><h2>体验MQTT</h2><p>为了让你对MQTT有一个直观的印象，我先带你体验一下它的通信过程，</p><p>第一步是安装 hbmqtt，它是一个开源的基于Python语言的 MQTT Broker  软件，正好包括我们需要使用一些工具。跟其他选择相比，这个软件安装起来非常方便，因为它在 Python 的 PYPI 软件仓库中就有，所以你通过 pip 命令就可以安装。这也是选择使用它的主要原因。</p><p>不过要注意的是，hbmqtt 是基于Python3实现的，因此这里使用的是 pip3 工具。</p><pre><code>pip3 install hbmqtt\n</code></pre><p>安装完成后，我们就可以使用 hbmqtt 中提供的  hbmqtt_sub 和 hbmqtt_pub 这两个命令行工具了。通过名字，你应该也可以看出 hbmqtt_sub 可以充当<strong>订阅者</strong>的角色；hbmqtt_pub 可以作为消息的<strong>发布者</strong>。</p><!-- [[[read_end]]] --><p>至于订阅者和发布者之间的经纪人，也就是 MQTT Broker，我们使用  Eclipse 免费开放的在线 <a href=\"https://mosquitto.org/\">Broker 服务</a>。打开链接，你可以看到关于端口的介绍信息，加密和非加密方式都支持，而且还有基于 Websocket 的实现，这对基于前端网页的应用来说是非常有利的。</p><p>我们先使用 1883端口的非加密方式，然后为消息传输确定一个主题（Topic）。主题确定了消息的类别，用于消息过滤。比如我们待会儿要测试的消息，属于极客时间平台的物联网课程，所以主题可以设为“/geektime/iot”。</p><pre><code>/geektime/iot\n</code></pre><p>接着，我们在电脑的终端界面输入下面的命令，就可以订阅这个主题消息：</p><pre><code>hbmqtt_sub --url mqtt://mqtt.eclipse.org:1883 -t /geektime/iot\n</code></pre><p>如果你想了解一些命令的执行细节，可以在上面的命令中加上 “-d” 参数。</p><p>现在，我们启动另外一个终端界面，通过 hbmqtt_pub 发布一个 “/geektime/iot” 主题的消息：</p><pre><code>hbmqtt_pub --url mqtt://mqtt.eclipse.org:1883 -t /geektime/iot -m Hello,World!\n</code></pre><p>通过 Eclipse 的开放 Broker 作为“经纪人”，消息被传输到了我们通过 hbmqtt_sub 运行的订阅者那里。下图是我的终端界面上运行的结果，一个完整的消息传输过程就这样完成了。</p><p><img src=\"https://static001.geekbang.org/resource/image/9a/ef/9a4fe3966ac303d5defde1bd8b7yy4ef.png?wh=1544*214\" alt=\"\"></p><h2>MQTT 的生态很完善</h2><p>初步体验之后，不知道你是不是有这样的感觉：原来使用MQTT也没有那么难啊？</p><p>确实不难，甚至可以说很简单，这主要得益于MQTT 协议出现的时间很久远。当然，时间久远本身不是优势，能力强才是。这些长期的使用和积淀使得 MQTT 的生态非常完善，而生态是技术标准能够主导行业的关键。所以你在使用MQTT的时候会觉得很方便，可供挑选的方案有很多。</p><p>比如在上面的体验中，你要安装 MQTT，可以直接找到 <a href=\"https://github.com/beerfactory/hbmqtt\">hbmqtt</a> 这样的项目拿来用。它的背后有 Eclipse 基金会的支持。</p><p>类似的 MQTT Broker  软件，你还可以选择基于C语言的<a href=\"http://mosquitto.org/\">Mosquitto</a>，基于Erlang语言的<a href=\"https://vernemq.com/\">VerneMQ</a>等。</p><p>至于 MQTT 的客户端（Client）实现，也有成熟的 Python、C、Java 和 JavaScript 等各种编程语言的开源实现，供你参考、使用，比如<a href=\"http://www.eclipse.org/paho/\">Eclipse Paho项目</a>。</p><p>而且，还有很多商业公司在持续运营功能更丰富、支持更完备的商业版 Broker 实现，比如提供高并发能力的集群特性、方便拓展的插件机制等。这些会大大提高我们技术开发者的工作效率。比如中国一个团队开发、维护的 <a href=\"https://www.emqx.io/\">EMQ X</a>，它已经完整地支持 MQTT5.0协议。</p><p>另外，生态完善还有一个好处，那就是作为开发者，当你遇到难题时，可以很方便地找到很多相关的资料；就算资料解决不了问题，你还可以去社区中提问，寻求高手的帮助。这在实际工作中非常有用。顺便提一下，除了老牌的Stack Overflow，你还可以关注一下 GitHub 的 Issues 模块，因为在那里可以找到很多专家。</p><h2>MQTT自身的“基因”很强大</h2><p>当然，阿里云、华为云、腾讯云和微软 Azure 这些大厂，之所以不约而同地选择 MQTT 协议作为物联网设备的“第一语言”，不仅是因为MQTT的生态完善，MQTT协议本身的优秀设计也是重要的因素。</p><p>它在设计上的优点体现在哪呢？我想主要有五个方面：</p><ol>\n<li>契合物联网大部分应用场景的<strong>发布-订阅模式</strong>。</li>\n<li>能够满足物联网中资源受限设备需要的<strong>轻量级特性</strong>。</li>\n<li>时刻关注物联网设备<strong>低功耗需求的优化设计</strong>。</li>\n<li>针对物联网中多变的网络环境提供的<strong>多种服务质量等级</strong>。</li>\n<li>支持在物联网应用中越来越被重视的<strong>数据安全</strong>。</li>\n</ol><p>接下来，我分别为你剖析一下。</p><h3>发布-订阅模式</h3><p>刚才我们体验的通信过程，是一个发布者和一个订阅者的情况。在这之后，你可以再打开一个终端界面，重复和之前一样的命令，再启动一个订阅者。</p><pre><code>hbmqtt_sub --url mqtt://mqtt.eclipse.org:1883 -t /geektime/iot\n</code></pre><p>现在，这两个订阅者都订阅了“/geektime/iot” 主题的消息。</p><p>然后，你再次使用 hbmqtt_pub 发送消息，就可以看到两个订阅者都收到了同样的消息，这是<strong>发布-订阅模式</strong>的典型特征。</p><p>因为采用了发布-订阅模式，MQTT协议具有很多优点，比如能让一个传感器数据触发一系列动作；网络不稳定造成的临时离线不会影响工作；方便根据需求动态调整系统规模等。这使得它能满足绝大部分物联网场景的需求。</p><h3>轻量级协议：减少传输数据量</h3><p>MQTT 是一个<strong>轻量级</strong>的网络协议，这一点也是它在物联网系统中流行的重要原因。毕竟物联网中大量的都是计算资源有限、网络带宽低的设备。</p><p>这种“轻量级”体现在两个方面。一方面，MQTT 消息采用<strong>二进制的编码格式</strong>，而不是 HTTP 协议那样的文本的表述方式。</p><p>这有什么好处呢？那就是可以充分利用字节位，协议头可以很紧凑，从而尽量<strong>减少需要通过网络传输的数据量</strong>。</p><p>比如，我们分析 HTTP 的一个请求抓包，它的消息内容是下面这样的（注意：空格和回车、换行符都是消息的组成部分）：</p><pre><code>GET /account HTTP/1.1    &lt;--注释：HTTP请求行\nHost: time.geekbang.com  &lt;--注释：以下为HTTP请求头部\nUpgrade-Insecure-Requests: 1\nUser-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:81.0) Gecko/20100101 Firefox/81.0\nAccept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8\nAccept-Encoding: gzip, deflate, sdch\nAccept-Language: zh-CN,zh;q=0.8,en;q=0.6\n                         &lt;--注释：这个空行是必须的，即使下面的请求体是空的\n</code></pre><p>在HTTP协议传输的这段文本中，每个字符都要占用  1 个字节。而如果使用MQTT协议，一个字节就可以表示很多内容。下面的图片展示了 MQTT 的固定头的格式，这个固定头只有2个字节：</p><p><img src=\"https://static001.geekbang.org/resource/image/e0/03/e03f1b94406b4cf33d55c9361925e203.jpg?wh=2700*582\" alt=\"\"></p><p>你可以看到，第一个字节分成了高 4 位（4～7）和低 4 位（0～3）；低  4  位是数据包标识位，其中的每一比特位又可以表示不同的含义；高4位是不同数据包类型的标识位。</p><p>第二个字节表示数据包头部和消息体的字节共个数，其中最高位表示有没有第三字节存在，来和第二个字节一起表示字节共个数。</p><p>如果有第三个字节，那它的最高位表示是否有第四个字节，来和第二个字节、第三个字节一起表示字节总个数。依此类推，还可能有第四个字节、第五个字节，不过这个表示可变头部和消息体的字节个数的部分，最多也只能到第五个字节，所以可以表示的最大数据包长度有256MB。</p><p>比如，一个请求建立连接的 CONNECT 类型数据包，头部需要14个字节；发布消息的 PUBLISH 类型数据包头部只有2～4个字节。</p><p>轻量级的另一方面，体现在消息的具体<strong>交互流程设计非常简单</strong>，所以MQTT的交互消息类型也非常少。为了方便后面的讲解，我在这里整理了一个表格，总结了 MQTT 不同的数据包类型的功能和发消息的流向。</p><p>从表格可以看出，MQTT 3.1.1 版本一共定义了14种数据包的类型，在第一个字节的高 4 位中分别对应从 1 到 14 的数值。</p><p><img src=\"https://static001.geekbang.org/resource/image/5d/e4/5d22e10c5b00a10177d76055db93f3e4.jpg?wh=2700*1519\" alt=\"\"></p><h3>低功耗优化：节约电量和网络资源</h3><p>除了让协议足够轻量，MQTT协议还很注重<strong>低功耗</strong>的优化设计，这主要体现在对能耗和通信次数的优化。</p><p>比如，MQTT 协议有一个 <strong>Keepalive 机制</strong>。它的作用是，在 Client 和 Broker 的连接中断时，让双方能及时发现，并重新建立 MQTT 连接，保证主题消息的可靠传输。</p><p>这个机制工作的原理是：Client 和 Broker 都基于 Keepalive 确定的时间长度，来判断一段时间内是否有消息在双方之间传输。这个  Keepalive 时间长度是在Client建立连接时设置的，如果超出这个时间长度，双方没有收到新的数据包，那么就判定连接断开。</p><p>虽然Keepalive要求一段时间内必须有数据包传输，但实际情况是，Client 和 Broker 不可能时时刻刻都在传输主题消息，这要怎么办呢？</p><p>MQTT 协议的解决方案是，定义了 PINGREQ 和 PINGRESP 这两种消息类型。它们都没有可变头部和消息体，也就是说都只有  2  个字节大小。Client 和 Broker 通过分别发送 PINGREQ 和 PINGRESP 消息，就能够满足 Keepalive 机制的要求。</p><p>我猜你也想到了，如果要一直这样“傻傻地”定期发送消息，那也太浪费电量和网络资源了。所以，如果在 Keepalive 时间长度内，Client 和 Broker 之间有数据传输，那么 Keepalive 机制也会将其计算在内，这样就不需要再通过发送 PINGREQ 和 PINGRESP 消息来判断了。</p><p>除了 Keepalive 机制，MQTT 5.0 中的<strong>重复主题特性</strong>也能帮助我们节省网络资源。</p><p>Client 在重复发送一个主题的消息时，可以从第二次开始，将主题名长度设置为 0，这样 Broker  会自动按照上次的主题来处理消息。这种情况对传感器设备来说十分常见，所以这个特性在工作中很有实际意义。</p><h3>3种QoS级别：可靠通信</h3><p>除了计算资源有限、网络带宽低，物联网设备还经常遇到网络环境不稳定的问题，尤其是在移动通信、卫星通信这样的场景下。比如共享单车，如果用户已经锁车的这个消息，不能可靠地上传到服务器，那么计费就会出现错误，结果引起用户的抱怨。这样怎么应对呢？</p><p>这个问题产生的背景就是不稳定的通信条件，所以 MQTT 协议设计了  3 种不同的 QoS  （Quality of Service，服务质量）级别。你可以根据场景灵活选择，在不同环境下保证通信是可靠的。</p><p>这 3 种级别分别是：</p><ol>\n<li>QoS 0，表示消息<strong>最多</strong>收到一次，即消息可能丢失，但是不会重复。</li>\n<li>QoS 1，表示消息<strong>至少</strong>收到一次，即消息保证送达，但是可能重复。</li>\n<li>QoS 2，表示消息<strong>只会</strong>收到一次，即消息有且只有一次。</li>\n</ol><p><img src=\"https://static001.geekbang.org/resource/image/63/d1/63ced1e04d756yy9ae89c3c81c8ac9d1.jpg?wh=2700*1375\" alt=\"\"></p><p>我用一张图展示了它们各自的特点。可以看到，QoS 0 和 QoS 1 的流程相对比较简单；而 QoS 2 为了保证有且只有一次的可靠传输，流程相对复杂些。</p><p>正常情况下，QoS 2有PUBLISH、PUBREC、PUBREL 和 PUBCOMP 4 次交互。</p><p>至于“不正常的情况”，发送方就需要重复发送消息。比如一段时间内没有收到 PUBREC 消息，就需要再次发送PUBLISH消息。不过要注意，这时要把消息中的 “重复”标识设置为1，以便接收方能正确处理。同样地，如果没有收到 PUBCOMP 消息，发送方就需要再次发送PUBREL消息。</p><p>剖析到这里，MQTT协议本身的主要特性我就介绍完了，我们已经为在实战篇编写 MQTT 的相关通信代码做好了准备。但是，我还想跟你补充一个跟生产环境有关的知识点，那就是<strong>数据安全传输</strong>。</p><h3>安全传输</h3><p>说到安全传输，首先我们需要验证Client是否有权限接入MQTT Broker。为了控制Client的接入，MQTT 提供了<strong>用户名/密码</strong>的机制。在建立连接过程中，它可以通过判断用户名和密码的正确性，来筛选有效连接请求。</p><p>但是光靠这个机制，还不能保证网络通信过程中的数据安全。因为在明文传输的方式下，不止设备数据，甚至用户名和密码都可能被其他人从网络上截获而导致泄漏，于是其他人就可以伪装成合法的设备发送数据。所以，我们还需要通信加密技术的支持。</p><p>MQTT 协议支持 <strong>SSL/TLS</strong> 加密通信方式。采用SSL/TLS加密之后，MQTT将转换为 MQTTS。这有点类似于 HTTP 和 HTTPS 的关系。</p><p>我们只要将前面测试的命令修改一下，将 “mqtt://” 改为 “mqtts://”，端口改为 8883，就可以用SSL/TLS 加密通信方式连接到 Eclipse 提供的开放 Broker。但是我最近发现，它的SSL证书已经过期了，因此连接会失败。（你在学习这一讲的时候，可以再试试，万一又更新了呢？）</p><p>所以，我再提供另一个方式，供你测试使用。</p><p>我们输入“mqtts://test.mosquitto.org:8883”，把开放 Broker 切换到<a href=\"https://test.mosquitto.org/\">这个链接</a>，从链接中下载一个<a href=\"https://test.mosquitto.org/ssl/mosquitto.org.crt\">客户端证书</a>，然后通过下面的命令订阅主题消息：</p><pre><code>hbmqtt_sub --url mqtts://test.mosquitto.org:8883 -t /geektime/iot --ca-file ~/Downloads/mosquitto.org.crt\n</code></pre><p>接着，我们再通过下面的命令测试发布消息：</p><pre><code>hbmqtt_pub --url mqtts://test.mosquitto.org:8883 -t /geektime/iot -m Hello,World! --ca-file ~/Downloads/mosquitto.org.crt\n</code></pre><p>最后在运行hbmqtt_sub命令的终端，就可以看到 Hello,World! 的消息：</p><p><img src=\"https://static001.geekbang.org/resource/image/b0/30/b04f873277f9dba5bfb7e9ff85d17630.png?wh=1400*262\" alt=\"\"></p><h2>小结</h2><p>总结一下，在这一讲中，我带你体验了使用MQTT协议的通信过程，同时也为你介绍了 MQTT 协议的几个特点。</p><ol>\n<li>MQTT协议的生态很好。比如，MQTT 协议的代码实现非常丰富，C 语言的有 Mosquitto，Python 语言有 Eclipse hbmqtt，而且有商业公司在运营相关软件解决方案。这表明 MQTT 协议很成熟。</li>\n<li>MQTT协议采用了适合物联网应用场景的发布-订阅模式。当然，我也提到了MQTT 5.0  中同样增加了请求-响应模式，便于部分场景中的开发使用。</li>\n<li>MQTT 协议采用二进制的消息内容编码格式，协议很精简，协议交互也简单，这些特点保证了网络传输流量很小。所以客户端（包括发布者和订阅者角色）的代码实现可以短小精悍，比如 C 语言的实现大概只占30KB 的存储空间，Java 语言也只需要 100KB 左右大小的代码体积。</li>\n<li>MQTT 协议在设计上考虑了很多物联网设备的低功耗需求，比如Keepalive机制中精简的PINGREQ 和 PINGRESP 这两种消息类型，还有 MQTT 5.0  中新增加的重复主题特性。这也再次印证了MQTT的定位非常明确，那就是专注于物联网场景。</li>\n<li>MQTT 在消息的可靠传输和安全性上，也有完整的支持，可以说“简约而不简单”。</li>\n</ol><p>因此，在你为物联网系统选择网络协议时，MQTT可以作为重点考察对象。在实战篇的动手实验中，我们将使用MQTT协议传输设备数据，相信你已经做好了准备。</p><h2>思考题</h2><p>最后，我想给你留一个实践作业和一道思考题。</p><p>在介绍 QoS 等级的时候，我没有结合网络抓包来说明消息的交互过程。所以，我想请你在课后使用 Wireshark 工具，实际分析一下各个 QoS 级别的数据包类型。</p><p>同时，也请你思考一下，如果Client 发布消息时选择的 QoS 等级是1 ，而订阅者在订阅这个主题消息时选择的QoS等级是2 ，这种情况下 Broker会怎么处理呢？</p><p>欢迎你在留言区写一写你的实践和思考的结果，也欢迎你将这一讲分享给你的朋友一起交流学习。</p>",
                "article_title": "08 | MQTT：在实践中掌握一个通信协议"
            },
            {
                "title": "09 | 边缘中心：物联网网关有多重要？",
                "id": 313631,
                "content": "<p>你好，我是郭朝斌。</p><p>在进阶篇的前几讲，我剖析了物联网中跟设备有关的几个技术点，包括物模型、设备的零配置组网、设备进行网络通信要用到的MQTT协议等。</p><p>但是，并不是所有的设备都能<strong>直接</strong>接入互联网，直接跟云平台通信。比如智能家居中的一些传感器，它们使用的通信技术是 BLE 或者 ZigBee，本身连 IP 地址都没有。那么，这样的设备要怎么联网呢？</p><h2>物联网网关：设备和云平台之间的桥梁</h2><p>这个时候，我们就需要借助<strong>物联网网关</strong>的能力了。举个例子，我主持设计过一个冷库温湿度监测系统，它是基于 LoRa 通信技术的。</p><p>我们知道，冷库的环境是非常复杂的。首先，库房内部的<strong>蜂窝网络信号一般都很差</strong>，一方面是因为要增强保温性能，所以墙壁做得比普通的墙体要厚；另一方面是因为库房位置通常位于城市的郊区，比较偏远，所以经常是完全没有网络信号。其次，库房的<strong>信号环境是千变万化的</strong>，因为会出现满仓、空仓等多种情况。</p><p>所以，在冷库内部部署的监测设备，如果直接连接蜂窝网络的话，完全不能实现可靠和稳定的通信。</p><p>这种情况下，我选择的解决方案就是，在有稳定网络信号的地方部署物联网网关，让冷库里面的监测设备，通过 LoRa 这种穿透能力强、空旷环境通信范围可以达到几公里的技术跟网关通信，从而<strong>间接</strong>地实现设备的联网。</p><!-- [[[read_end]]] --><p><img src=\"https://static001.geekbang.org/resource/image/d6/2b/d6c122e2b43b2c8c9ee860a2945d222b.jpg\" alt=\"\"></p><p>我们可以看到，物联网网关正在成为整个物联网体系中不可或缺的角色。它作为物联网设备与云平台之间的桥梁，变得越来越重要。</p><h2>协议转换：搭建桥梁的关键</h2><p>那么，物联网网关凭什么能搭建这座桥梁呢？奥秘就在于<strong>协议转换</strong>。其实，刚才智能家居和冷库的例子，就已经体现了这个功能。</p><p>BLE 、ZigBee 和 LoRa 设备在跟网关通信的时候，需要网关基于开放的或者内部私有的协议，解析出数据；然后网关再使用跟云平台的连接协议来组织数据，完成数据传输。</p><p>这个过程自然就要求网关设备能够支持不同的通信技术。我在下面给出了一张网关通信接口的结构示意图。</p><p><img src=\"https://static001.geekbang.org/resource/image/46/1c/46ec62221a9667baab1bb03e42ed691c.jpg\" alt=\"\"></p><p>看这张图跟看地图一样，上北下南，上半部分叫“北向接口”，下半部分叫“南向接口”。这可不是我在生造概念，而是行业内约定俗成的说法。</p><p><strong>北向接口</strong>需要接入互联网，所以通常的选择有 RJ45 以太网口、光纤接口、Wi-Fi 和 4G、NB-IoT等蜂窝网络模组等。</p><p><strong>南向接口</strong>用来连接物联网设备，除了刚说的 BLE、ZigBee、LoRa、Wi-Fi这些无线技术的接口，常见的还有用在<strong>工控机</strong>（Industrial Personal Computer，工业控制计算机）上的 RJ45以太网口、RS232、RS485等有线接口。</p><p>这里需要注意的是，每个网关设备的接口类型和个数不是固定的，因为网关产品一般会根据应用场景确定几个不同的规格型号。不同型号的网关需要支持不同类型的协议，以及不同个数协议的转换，所以网关的协议转换功能一般采用插件的软件架构方式。</p><p><strong>插件机制</strong>这种二次开发能力非常重要。一方面，它让我们可以根据接口的情况，动态、灵活地配置协议转换功能；另一方面，它也可以方便我们开发私有协议的解析功能。</p><p>比如通过 BLE、ZigBee 或 LoRa 技术跟网关通信的设备，它们通常采用的是私有的应用层协议，这就需要我们基于设备架构设计时定义的私有协议，专门编写解析代码。</p><p>至于使用 RJ45网口或 Wi-Fi 跟网关连接的物联网设备，除了采用基于 TCP或者UDP的私有协议之外，也可能采用我们之前讲过的 MQTT 或者 CoAP这样标准的协议。这时，我们就需要按照这些协议的格式来处理。</p><p>另外，工控机 和 <strong>PLC</strong> （Programmable Logic Controller，可编程逻辑控制器）中经常使用的标准协议有 Modbus、ProfiBus、OPC UA 和 BACnet 等。如果你在相关行业，可能对它们有一定了解。这些协议也是需要进行转换的，因为它们一般只应用于工业领域。这里我就不展开介绍了，如果感兴趣的话，你可以在 Wikipedia 上查询到详细的资料。</p><h2>网关的其他功能</h2><p>经过协议转换，网关就得到了通用格式的数据。对于这些数据，网关还需要进行持久化，把数据临时存储起来。</p><p>网关的<strong>存储功能</strong>可以防止因网络临时故障等原因，导致设备数据的丢失。另外，网关和设备的配置信息也需要存储在网关中，以便设备运行过程中快速读取。</p><p>同时，数据的<strong>安全性</strong>也非常重要，物联网网关需要做好这几个方面的事情：</p><ol>\n<li>完善的<strong>本地身份认证</strong>。这样可以防止网关设备被随意修改软件或者数据。</li>\n<li>网关保证<strong>数据的加密传输</strong>。因为很多物联网设备的计算能力非常弱，不具备进行数据加密的能力，这时就需要借助网关来保证数据或者控制命令的加密和解密。</li>\n<li>网关能够支持<strong>运营商专网接入</strong>，或者支持<strong>VPN</strong>（Virtual Private Network，虚拟专用网络）技术。这里我补充说明一下，VPN技术的好处是基于互联网网络建立加密通道。这样既保证了数据传输的安全可靠，又比建立专线成本要低。常用的VPN协议有 IPsec、OpenVPN等。</li>\n</ol><p>除了我刚才讲到的协议转换、存储功能和安全管理，物联网网关一般还有<strong>设备管理</strong>、<strong>网关配置</strong>、<strong>空中升级</strong>这些功能模块。它们比较容易理解，我就不在这一讲展开介绍了。</p><p>到这里呢，我就把<strong>传统</strong>物联网网关的功能都讲解了。看到“传统”两个字，你可能疑惑了：还有现代网关吗？是的，现在有一个趋势就是越来越强调物联网网关的<strong>数据分析处理</strong>能力。</p><p>我在第4讲介绍过数据的分析处理。我们知道，云计算平台凭借着强大的处理能力、存储能力和极高的性价比，已经成为物联网系统的有力支撑。现在的物联网应用系统，主要就是基于云平台实现数据分析处理任务的。</p><h2>在网关上做数据分析</h2><p>既然如此，那为什么我们还要在网关上运行这些计算的任务呢？这是因为随着物联网的发展，海量的设备接入网络，随之而来的，是更加海量的数据源源不断的产生，并上传到云平台。</p><p>这就给云平台提出了很大的挑战。一方面是极大地消耗有限的网络带宽资源；另一方面，网络的不确定因素很多，有可能导致不可控的延时，从而对业务应用造成不可接受的影响。</p><p>而且物联网数据通常<strong>与物理实体关系密切</strong>。比如家庭监控摄像头中，家庭成员的肖像等视频信息是非常敏感的；而在工业场景中，很多数据是机密的。如果这些信息全部上传到云平台，会给用户带来很大的安全风险。</p><p>所以，现在行业内已经开始尝试将云平台上的部分计算服务，下沉到靠近数据发生地的“边缘设备”上进行，这就是<strong>边缘计算</strong>的由来，而物联网网关是边缘计算中<strong>最轻量级</strong>的解决方案的关键。</p><h2>边缘计算的好处</h2><p>怎么理解这种技术架构上的进化呢？你可以想一想，人体是如何处理各种感知信息的，是不是所有的信息都需要大脑来处理呢？</p><p>其实人体神经系统的信号是<strong>分层级</strong>传递和处理的。我们中学上生物课时都做过类似的试验，如果手指放到蜡烛上，手是下意识地快速移开，然后大脑才意识到发生了什么。这是四肢的一种非条件反射，它是由大脑皮层之下的低级别神经系统，如脑干、脊髓，直接控制完成的。它们距离四肢更近，可以保证在危险的情况下，更加快速地做出反应。</p><p><img src=\"https://static001.geekbang.org/resource/image/40/45/4051144174eb30fa69a92f3b205f3f45.jpg\" alt=\"\"></p><p>边缘计算的设计，与人体的这个构造类似。边缘设备，比如物联网网关，完成<strong>初步</strong>的数据处理，和<strong>需要及时响应</strong>的计算任务；而云平台负责需要<strong>大规模数据</strong>和<strong>复杂计算</strong>的数据分析工作，以及完成<strong>整体的协调和控制</strong>。</p><p>具体来说，云平台将原有的云计算模型的部分计算任务迁移到网络边缘设备上来；网络边缘设备（比如路由器、移动网络基站等），在数据源附近执行数据处理和数据分析任务。这样一来，就降低了云计算中心的计算负载，减轻了物联网对于网络带宽的压力，提高了数据处理的效率。</p><p>我将边缘计算模型的好处，总结为四个方面：</p><ol>\n<li><strong>延迟低。</strong>数据只需要从产生设备传输到边缘设备，传输距离短，数据不需要通过其他网络，网络延迟低。</li>\n<li><strong>节约了主干网带宽。</strong>缓解大量数据传输所造成的网络拥堵想象。尤其像一些银行的专有网络，本身带宽非常有限，只能用于传输关键性的数据。</li>\n<li><strong>计算可用性好。</strong>数据在网络中的路径长度显著变短，因网络波动引起的计算服务不可用情况将有所减少。</li>\n<li><strong>隐私性更好。</strong>由于边缘设备距离用户近，用户的隐私数据不再需要上传到云平台，因此，在边缘计算场景下，用户的隐私也可以得到更好的保护。</li>\n</ol><h2>边缘计算对网关的影响</h2><p>技术架构的变化，一般也会对系统提出新的需求。边缘计算对网关的影响，主要体现在三个方面。</p><p>首先，为了更好地在网关中运行边缘计算任务，网关需要支持<strong>虚拟化技术</strong>，这在目前的实践中通常是采用<strong>容器技术</strong>实现。容器天然具有轻量和可移植的优点，非常适合开发人员快速测试应用程序，也方便维护人员在网关上大规模部署和更新应用程序。另外，容器技术也更利于网关使用容器自动运维平台技术，比如 Kubernetes，来实现应用程序的编排等功能。</p><p>其次，因为网络环境的不确定性，网关需要具备一定的<strong>自治能力</strong>。当网关与云平台的通信中断时，这种情况不应该影响网关处理数据的计算任务，和对物联网设备的管理。</p><p>最后，因为边缘计算的引入，我们需要在网关侧实现数据分析处理的任务。而网关的硬件资源非常多样，业务需求也千差万别，所以网关上提供统一的<strong>开发框架</strong>变得更加重要。开发框架可以为开发人员提供一致的API 和组件的互操作能力。这样开发人员可以更加高效地实现业务功能，也更容易和其他厂商协作。</p><p>这里我把加入边缘计算能力后的网关架构图放在下面，供你参考。</p><p><img src=\"https://static001.geekbang.org/resource/image/df/08/dfff704f684838dc0d5d35732d156208.jpg\" alt=\"\"></p><h2>怎样实现边缘计算？</h2><p>我知道，你现在最可能提出的问题就是：有什么开源软件可以助力网关实现边缘计算呢？</p><p>我简单介绍一下开源的生态，也方便你更好地理解网关的相关技术。</p><p>首先说一下<strong>标准化组织</strong>。目前，在推进边缘计算的标准组织主要有三个，分别是：</p><ol>\n<li>Linux 基金会下的 <a href=\"https://www.lfedge.org/about/mission/\">LF Edge</a> （Linux Foundation Edge）和致力于推进Cloud Native的 <a href=\"https://www.cncf.io/\">CNCF</a>（Cloud Native Computing Foundation）</li>\n<li>Eclipse 基金会下面的 <a href=\"https://iot.eclipse.org/\">Eclipse IoT</a> 项目</li>\n<li>OpenStack基金会</li>\n</ol><p>至于<strong>容器技术</strong>方面的开源项目，主要有 <a href=\"https://kubeedge.io/en/\">KubeEdge</a> 项目，它的主要思路是将Kubernetes从云端扩展到边缘设备，方便应用程序在边缘网关上的编排和调度，同时实现云端和边缘设备的协同数据处理。</p><p>关于<strong>开发框架</strong>，比较知名的是 <a href=\"https://www.edgexfoundry.org/\">EdgeX Foundry</a> 项目，定位是为工业物联网提供通用的边缘计算框架。为此，它适配了很多协议，提供出标准的API接口。</p><p>专门针对<strong>智能家居领域</strong>的项目有 <a href=\"https://www.lfedge.org/projects/homeedge/\">Home Edge</a> ，它是三星贡献的一个开源项目，用于加速智能家居设备的边缘部署。</p><h2>小结</h2><p>总结一下，随着物联网应用场景越来越多，物联网网关正在成为“边缘中心”。它成为物联网的<strong>“云、边、端”架构</strong>（即云平台、边缘、终端三部分）中非常重要的组成部分。你在做物联网网关的架构设计和功能开发中，需要重点关注的内容有：</p><ol>\n<li>物联网网关是设备与云平台之间的桥梁，网关的南向接口和北向接口都非常多样。因此协议转换功能是必须包含的功能。它保证了物联网设备数据的可靠上传，和云平台控制命令的有效执行。</li>\n<li>关注网关基础功能的实现。这些功能包括存储功能、安全管理、设备管理、网关配置和空中升级这些功能模块。它们既保证了数据的安全和可靠传输，也为远程维护提供了支持。</li>\n<li>你需要根据业务场景，决定网关对于边缘计算的支持能力。边缘计算对于物联网网关的架构有3个方面的影响：<br>\n（1） 容器技术。容器技术的应用利于开发人员快速开发、测试应用程序，也方便维护人员在网关上大规模部署、更新应用程序。同时，基于容器自动运维平台技术可以实现应用程序的编排等功能。<br>\n（2）自治能力。它可以保证网络环境不稳定时，网关的数据分析处理任务的正常执行。<br>\n（3）开发框架。开发框架利于开发人员的开发工作，也有益于各部分组件的协同互操作。</li>\n</ol><h2>思考题</h2><p>最后，我还是给你留一个思考题。</p><p>边缘计算已经成为物联网的必要组成部分，行业内云计算企业、网关设备商、运营商都积极参与推进技术体系的发展。那你有使用这些边缘计算产品吗？应用在什么业务场景呢？</p><p>欢迎你在留言区和我交流，也欢迎你将这一讲分享给你的朋友一起讨论学习。</p>",
                "article_title": "09 | 边缘中心：物联网网关有多重要？"
            },
            {
                "title": "10 | 数据处理框架：批处理还是流处理？",
                "id": 314631,
                "content": "<p>你好，我是郭朝斌。</p><p>在<a href=\"https://time.geekbang.org/column/article/308366\">第4讲</a>中，我分析了物联网系统的数据技术体系。它包括  5  个部分：数据源数据采集、数据传输、数据存储、数据处理和数据应用。</p><p>不过，这还只是一个整体的认识框架。数据技术体系涉及的内容很多，虽然我在第4讲已经介绍了<strong>数据应用</strong>中用到的分析方法和算法，但是你还需要在这个框架的基础上，继续了解其他几个部分的知识。</p><p>所以我会从今天开始，用连续3讲的篇幅，分别讲一讲数据处理、数据存储和数据传输涉及的技术。每一讲分别专注其中一个主题，把它们都剖析透。至于数据源的数据采集，它跟具体的行业应用有关，不同的行业差别很大，所以我们这门课就不展开讲了。</p><p><img src=\"https://static001.geekbang.org/resource/image/6c/38/6c871e4476c3aa93f37c9c3e030e1c38.jpg\" alt=\"\"></p><h2>处理海量数据时的难题</h2><p>我们知道，数据分析需要用到很多算法，比如支持向量机和K-means。那么在物联网系统的应用中，我们要怎么使用这些算法呢？</p><p>你可能会想：这算什么问题？从文件中或者数据库中读取数据，然后使用一个算法工具，比如  Python 语言的机器学习框架 <strong>Sklearn</strong>（也称为 Scikit-Learn），不就可以快速应用算法处理数据了吗？</p><p>其实没有这么简单，因为这种方式一般只适合用来学习和做研究。在真实的物联网场景中，你面临的是海量的数据。当我们面对海量数据的处理时，一切就不是这么直接和简单了。先不说高效地处理，首先你面临的挑战就是，如何把高达几GB甚至数TB的数据直接读取到内存中计算，显然直接加载到内存是不现实。</p><!-- [[[read_end]]] --><p>所以，对于海量数据，我们要借助大数据处理技术。</p><h2>经典思路：MapReduce的分而治之</h2><p>那么，大数据处理技术是采用什么思路解决海量数据的处理任务的呢？</p><p>为了让你更好地理解，在解答这个问题之前，我想先跟你讲一个故事。</p><p>记得上大学的时候，为了提前体验一下工作招聘的流程，我参加过一些公司的笔试。笔试题目中有很多是关于<strong>大文件处理</strong>的，比如给你一个或者几个很大的文件，问你怎么找出其中出现频次  Top  100  的词。搜索引擎公司尤其爱出这种题。</p><p>对于这种问题，如果我们要提高处理的效率，就需要考虑<strong>“分而治之”</strong>的策略了：把数据分成几份，分配给几台计算机同时处理；每台计算机统计它负责的文件块中每个词出现频次，然后再将所有计算机统计的结果进行汇总，最终得到所有数据中最高频的100个词。</p><p>虽然这只是一道笔试题，但是它来源于搜索引擎公司真实的业务需求。搜索引擎需要对海量的网页内容进行处理，建立索引，计算权重。为此，工程师们要做很多事：</p><ul>\n<li>数据切分：把大文件分成小文件</li>\n<li>数据传输：把文件分发给可用的计算机</li>\n<li>结果汇总：把每台计算机的计算结果做汇总处理，得到最终结果</li>\n<li>容错处理：解决多台计算机协作过程中出现的机器故障</li>\n<li>灵活扩展：根据计算机临时的增加，随时调整计算任务的分配和汇总</li>\n</ul><p>显然，这不是一项轻松的工作，还涉及到很多分布式系统的技术。如果每次有不同需求的时候，我们都得重新走一遍这个过程，就要投入大量的时间和精力，太不划算了。</p><p>怎么解决这个问题呢？方法当然有很多。在大数据技术的早期，应用最广泛的方法是 MapReduce ，流行的原因很简单，就是分享和开源。</p><p>首先，<strong>谷歌</strong>（Google）基于公司内部的实践，在2004年发表了<strong>分布式计算框架</strong>的<a href=\"https://users.soe.ucsc.edu/~sbrandt/221/Papers/DataManagement/dean-osdi04.pdf\">论文</a>。这篇论文提出了 <strong>MapReduce</strong> 计算框架的设计思想，主要用于解决海量网页的索引生成问题。</p><p>接着，开源搜索引擎项目 <strong>Nutch</strong> 的开发人员，基于这个设计思想开发出了开源的  <a href=\"https://hadoop.apache.org/docs/r1.2.1/mapred_tutorial.html\"><strong>Hadoop MapReduce</strong></a>  实现。</p><p>MapReduce 是怎么设计的呢？其实他们的想法跟刚才那道笔试题的解法一样，也是分而治之。</p><p>具体来说，就是把数据分成相同大小的多份，然后相应地创建多个任务，并行地处理这些数据分片，这个的过程被定义为<strong>Map</strong>过程；接着，再将Map过程中生成的计算结果进行最终的汇总，生成输出结果，这个过程被定义为<strong>Reduce</strong>过程。</p><p>这两个过程合起来就是MapReduce了。</p><p>这个设计思路本身，还不是最关键的地方。更重要的是，它提供了一个<strong>框架</strong>，把与计算机硬件相关的容错和扩展功能都实现了。同时，它也提供了统一的开发接口，我们只需要基于业务目标，定制 Map 和 Reduce 的具体计算任务就行了。这就大大降低了我们分析海量数据的难度。</p><p>当出现一个好用的工具时，人们就会试图用它来解决一切问题。随着 MapReduce的流行，人们开始把它应用在各种场景中，而不仅仅是计算索引，比如执行 Hive  中的 HQL 查询（这是一种 SQL样式的交互式计算）。</p><p>这个时候，MapReduce就显得越来越“力不从心”了，原因主要有两个方面。</p><p>一方面，MapReduce的计算模型非常简单，只有Map和Reduce两种类型。就连对数据进行排序和分组这样简单且常见的任务时，都需要转换成Map和Reduce来进行；而像上面说到的  HQL 查询，更是需要使用多个 Map 和 Reduce过程才能实现。</p><p>这有点像函数调用。我们使用C、Java和Python这些高级语言的时候，直接引用函数名，填上函数参数就可以了。但是如果我们使用的是汇编语言，就需要自己写代码实现函数入参的压栈、返回地址压栈、跳转到函数代码的地址、执行完成后的出栈和返回等操作。</p><p>这非常不直观，也容易出错。</p><p>另一方面，MapReduce  是基于分布式文件系统  HDFS 来实现数据存取的。注意，不只是读取源数据和写入计算结果，包括中间的计算结果的存储和数据交换也是基于HDFS的。</p><p>HDFS  是磁盘上的文件系统，读写的效率要远远低于内存。HDFS之所以选择磁盘作为存储介质，是因为它出现的时代计算机内存还是很昂贵的。</p><p>这就导致 MapReduce的效率不高。</p><h2>高效率开源框架：以“快如闪电”为目标的Spark</h2><p>高效是工程师们一直追求的，不管是开发还是处理，我们都希望越快越好。为了实现高效，新的设计思想和数据处理框架开始出现，其中的翘楚是 Spark 项目。</p><p>那么，Spark是如何打造高效率框架的呢？</p><p>首先，在计算模型上，Spark 抛弃了MapReduce的两个过程模型，采用了<strong>DAG</strong>（Directed Acyclic Graph，有向无环图）模型。为什么采用DAG呢？我给你挖掘一下这背后的本质。</p><p>下面这张图展示了 MapReduce 处理数据时的数据流：</p><p><img src=\"https://static001.geekbang.org/resource/image/8f/da/8f34418d89dfa6318024444596206cda.jpg\" alt=\"\"></p><p>学过数据结构和算法的你，一定知道这就是<strong>有向无环图</strong>。所以，采用DAG来描述数据处理的过程，应该说是反映了数据处理过程的本质。这样一方面开发人员可以更容易地描述复杂的计算逻辑，另一方面计算框架也能更方便地自动优化整个数据流，比如避免重复计算。</p><p>其次，Spark 的数据存取充分地利用了<strong>内存</strong>。</p><p>它的数据分片被称为<strong>Partition</strong>。然后它基于Partition，提出了<strong>RDD</strong>（Resilient Distributed Datasets，弹性分布式数据集）的概念。</p><p>所谓的<strong>“弹性”</strong>就是指，数据既可以存储在磁盘中，也可以存储在内存中，而且可以根据内存的使用情况动态调整存储位置。这就提高了计算的效率。</p><h2>另一种思路：为实时计算而生的流处理</h2><p>到这里，你可以想要问：怎么还没有说到批处理和流处理呢？</p><p>其实我刚才介绍的MapReduce就是批处理的经典思路和框架，而Spark就是目前更高效、更流行的数据批处理开源框架。</p><p>之所以没有在一开始的时候就提出来，是因为“批处理”这个概念一定是相对于其他处理方式来说的，比如流处理。如果后来没有流处理模式，我们也只会说“大数据处理”或者“分布式数据处理”，而不会专门定义一个批处理出来。</p><p>那流处理为什么会出现呢？当然是因为业务需求。随着社交网络的出现，产品中的个人<strong>信息流</strong>（Feeds）需要基于好友关系和好友的发布动态，快速地计算和显示出和本人有关系的信息。类似的需求还有个性化的广告和消息推送服务。</p><p>而在物联网中，当采集的数据传输到系统后，我们可能需要对数据进行一些预处理，处理之后再存储起来。</p><p>这些需求在现在的应用中很常见。它们的共同特点是，数据像流水一样流入系统，然后被处理，而数据的快速处理，也就是实时计算，是这个过程中的关键点。这就是流处理出现的背景。</p><p>那怎么实现呢？考虑到数据输入的速度和数据处理的速度不一定一致，我们可以按照一定的分配策略，将数据输入多个消息队列中缓存数据，每个消息队列由一个进程或者线程处理数据。</p><p>但是和我一开始提到的计算词语出现频次的例子一样，这种基于消息队列自己开发的系统，同样会遇到拓展性、容错性的问题；另外，还要保证消息队列中消息的可靠传输。</p><p>所以一些流处理框架开始出现，一方面解决这些问题，另一方面也给开发人员提供统一的开发接口，从而方便流处理的任务的开发和实现。</p><h2>流处理开源框架：Storm、Spark Streaming 和 Flink</h2><p>这其中最早的代表就是社交网络公司Twitter开发的<strong>Storm</strong>框架。</p><p>Storm的一个重要概念就是<strong>数据流</strong>（Stream）。相对于批处理针对数据块的处理方式，所谓的流处理，就是针对数据流的处理方式。Storm把Stream描述成是<strong>元组</strong>（Tuple）构成的一个无限的序列，如下图所示：</p><p><img src=\"https://static001.geekbang.org/resource/image/84/40/840228bf5b3ffc00af6a890f10e31040.jpg\" alt=\"\"></p><p>Stream 从<strong>水龙头</strong>（Spout）中产生，也就是说，Spout把需要处理的数据转换为由Tuple构成的Stream。然后Stream经过<strong>转接头</strong>（Bolt）的处理，输出新的Stream。其中，Bolt的处理可以是过滤、函数操作、Join等任何操作。你可以参见下面的流程图示例：</p><p><img src=\"https://static001.geekbang.org/resource/image/4c/9a/4c251b0abc56d4f8438fd832ab94229a.jpg\" alt=\"\"></p><p>图片中的Spout、Bolt 和Stream共同构成了Storm中另一个重要概念，<strong>拓扑</strong>（Topology）。</p><p>你应该可以看出来Topology是一个DAG（有向无环图）。Storm框架中运行的正是一个个Topology，而且因为是流处理，它会一直运行直到被手动终止。</p><p>基本上和Storm同时出现的流处理开源框架是Spark Streaming。看到Spark Streaming，你可能疑惑，Spark的计算引擎不是基于RDD数据集，也就是<strong>数据块</strong>来处理数据的吗？它要怎么处理<strong>数据流</strong>呢？</p><p>其实无论是数据块还是数据流，都只是数据的不同使用和处理方式，它们之间是可以相互转换的。</p><p>这就像在一些编程语言标准库中的<strong>File</strong>操作接口，File本身在磁盘中是按照块存储的，但是File操作的接口可以按照流（Stream）的方式读写文件。同样地，用户键盘输入的Stream，或者通过网络连接Socket接收的数据流，也可以先缓存起来，然后作为整块的数据统一处理。</p><p>Spark Streaming 正是将数据流转换成一小段一小段的<strong>RDD</strong>。这些小段的RDD构成一个流式的RDD 序列，称为<strong>DStream</strong>，所以它的流处理被称为<strong>“微批处理”</strong>。</p><p><img src=\"https://static001.geekbang.org/resource/image/71/95/71yyf920db9b1619ee4ee700108fd995.jpg\" alt=\"\"></p><p>显然，它的实时性取决于每小段RDD的大小，实时性不如Storm框架；不过，这种方式也使它的吞吐能力要大于 Storm。</p><p>整体来看，你可以认为Spark（包括Spark Streaming）基于数据块的数据模型，同时提供了批处理和流处理的能力。</p><p>那么既然数据块和数据流可以相互转换，是否存在基于数据流的数据模型，然后同时支持批处理和流处理的开源框架呢？毕竟数据输入系统的本来方式就是数据流，这样理论上可以获得更好的实时性。</p><p>答案是有的，比如<strong>Flink</strong>。Flink将数据块作为一种特殊的数据流，通过从文件等持久存储系统中按照Stream（流）的方式读入和处理，来提供批处理的能力。在这个基础之上，Flink提供了统一的批处理和流处理框架，也就是所谓的<strong>“流批一体”</strong>的数据处理框架。</p><p>Flink虽然出现的时间不长，但凭借着优秀的设计，性能非常强，延迟可以低到微秒级别，是对实时计算性能要求的高的场景的理想选择。行业内，阿里云和腾讯云对于 Flink 的支持都非常好；很多企业也在实践中逐渐尝试使用Flink来替代Storm框架。</p><h2>小结</h2><p>总结一下，在这一讲中，我介绍了物联网系统的两类数据处理框架，顺便讲了很多大数据处理技术的起源和设计思想。这不是我想啰嗦，而是因为学习一个东西的时候，最有效的方式就是搞清楚它的底层原理，把握它的发展脉络。只有这样，每个知识点才能各归其位，遇到问题时你就可以顺藤摸瓜地去分析、去解决。</p><p>今天的重点，这里我再概括一下：</p><ol>\n<li>批处理适合海量静态数据的非实时处理，延迟比较高，也叫离线计算，主要用于离线报表、历史数据汇总等场景。</li>\n<li>流处理适合动态输入的流式数据的实时处理，延迟低，也叫实时计算，主要用于实时监控、趋势预测、实时推荐等场景。</li>\n<li>批处理可以选择的开源框架有Spark和Flink。至于Hadoop MapReduce，你了解一下基本原理就可以了，它在应用中应该已经被放弃了。当然，如果你有遗留系统仍然使用MapReduce，那就只能维护着，或者找机会迁移到新的框架。</li>\n<li>流处理的开源框架可以选择 Storm、 Spark Streaming和Flink等。</li>\n</ol><p>另外，我还做了一张思维导图，供你在使用中参考。</p><p><img src=\"https://static001.geekbang.org/resource/image/74/5c/74c223220482f0151a023fee44a8125c.jpg\" alt=\"\"></p><p>技术的发展是需求推动的。随着互联网上网页数量的增多，从搜索引擎开始，大数据处理相关的技术经历了萌芽到成熟的快速发展过程，已经在电商推荐系统、广告营销、金融科技等领域得到广泛的应用。</p><p>未来随着物联网的发展，智能家居、智慧城市、工业物联网的领域应用越来越多，数据量更是极速膨胀。这一定会对大数据技术提出新的挑战和需求，新的计算框架也许也会出现，因此这是一个非常活跃的技术分支。不过，你在了解、学习新的框架时，都可以回到我这里讲的数据处理的本质来思考。</p><h2>思考题</h2><p>最后，给你留一个思考题吧。</p><p>这一讲我们讨论了很多批处理和流处理的内容，我们知道一个完整的业务系统，一般既需要批处理，也需要流处理，那这些不同的数据处理框架在系统中应该如何配合呢？或者说数据处理系统的架构应该是怎样的呢？</p><p>欢迎你在留言区谈一下自己的看法，或者分享一下你工作中应用的架构方式。如果你有朋友对物联网感兴趣，也欢迎你将本课程分享给他们，一起交流学习。</p>",
                "article_title": "10 | 数据处理框架：批处理还是流处理？"
            },
            {
                "title": "11 | 数据存储：物联网中的数据库有哪些？",
                "id": 316274,
                "content": "<p>你好，我是郭朝斌。</p><p>上一讲，我讲解了物联网系统进行数据处理的思路和常用的开源框架。那么，这些数据要从哪里读取呢？还有，数据处理完成的结果要写入到哪里呢？这就涉及到数据存储方案。</p><p>跟灵活多变的数据处理框架比起来，数据存储方案要固定得多。</p><p>为什么这么说呢？因为确定了数据存储方案，其实也就确定了用来存储数据的具体软件。当系统开发出来并投入使用后，数据就会源源不断地流入软件存储起来。</p><p>当你因为存储软件的读写性能无法满足需求，希望重新做软件选型的时候，就会发现把数据从一种软件迁移到另一种软件是一件费时费力还容易出错的事情。它就像给飞行中的飞机换引擎，难度可想而知。</p><p>更何况数据是一种重要的<strong>数字资产</strong>，之前的数据公司是不能轻易丢弃的。</p><p>所以一旦确定存储软件，一般很难切换。这就要求我们做软件选型的时候，必须非常谨慎。因为一旦做出错误的决策，将来可能追悔莫及。</p><p>那么，怎么正确地选型呢？基本的原则还是我在第4讲中提到的，根据数据类型来选择。</p><p>数据大体上可以分为3类：</p><ol>\n<li>结构化数据（Structured data）</li>\n<li>半结构化数据（Semi-structured data）</li>\n<li>非结构化数据（Unstructured data）</li>\n</ol><p>这一讲，我会一类一类地为你介绍选型经验。</p><!-- [[[read_end]]] --><h2>结构化数据：关系型数据库</h2><p>我们先来看看<strong>结构化数据</strong>。</p><p>结构化数据是指具有<strong>明确的</strong>、<strong>固定的</strong>结构关系的数据。</p><p>怎么理解呢？你可以回想一下班级通讯录的Excel表格，表头有姓名、性别、生日、家庭住址、手机，然后下面是一行一行的数据。正因为表头有明确和固定的结构，所以每一行的数据的结构都是一样的。这种用二维的表结构就可以表示的数据，就是结构化数据。</p><p><img src=\"https://static001.geekbang.org/resource/image/16/69/1634466byya14757dfc4115yyb5ed769.jpg\" alt=\"\"></p><p>这个表结构和关系型数据库中的表结构非常一致，所以结构化数据适合使用<strong>关系型数据库</strong>来存储。基于关系型数据库，我们可以很容易地实现数据的“增删改查”，而且可以方便地实现事务操作，保证数据操作满足ACID特性（也就是原子性Atomic，一致性Consistency，隔离性Isolation和持久性Durability）。</p><p>举例来说，共享单车中用户的个人信息、骑行记录和支付信息等这类属性明确，而且对于一致性要求很高的数据，一般就采用关系型数据库来存储和操作。</p><p>不过随着业务的发展，当物联网系统面临海量数据时，单机数据库的计算和读写性能会受到影响。这时，我们已经不能简单地通过提高计算机的硬件性能（垂直扩展）来解决了。</p><h3>分布式关系型数据库</h3><p>为了应对大数据对计算和读写性能的挑战，数据库系统需要借助分布式架构的威力（横向扩展）。</p><p>这就像为了解决“灭霸”这个难题，我们当然希望出现一个更加强大的超能力者。但是即使是钢铁侠和绿巨人，也是有能力瓶颈的，所以就需要各种超级英雄组成联盟才能达成目的。</p><p>那么怎么用分布式架构来解决大数据的问题呢？行业内一开始的实践是对数据库进行<strong>分库分表</strong>，然后借助<strong>数据库中间件</strong>实现关联查询、主键避免重复、分页查询和事务一致性等功能。</p><p>但是这种方式有很多弊端，比如分库分表需要根据业务数据的特点仔细设计，而且这种分库分表操作一定会涉及非常麻烦的数据迁移工作；通过中间件执行SQL的效率不高；事务一致性很难保证，往往需要在应用中实现“最终的一致性”。</p><p>为了解决这些问题，<strong>分布式关系型数据库</strong>出现了。它也经常被称为<strong>NewSQL数据库</strong>。它的优势主要体现以下3个方面。</p><ol>\n<li><strong>高扩展性</strong>。NewSQL天生支持数据<strong>分片</strong>，支持动态增加节点，不需要进行麻烦的数据迁移工作，所以能够轻松地满足数据不断增大时的存储需求。</li>\n<li><strong>高并发性</strong>。相比于单机关系型数据库基于<strong>磁盘</strong>的设计，NewSQL在设计上更好地利用了<strong>内存</strong>，所以SQL执行效率很高。在事务的支持上，NewSQL有着高效的分布式事务特性。所以它可以实现海量数据的读取和写入，以及大量用户的查询和更新等操作。</li>\n<li><strong>高可用性</strong>。NewSQL采用Paxos或者Raft协议来实现<strong>多副本</strong>的存储，而且还支持自动选择主节点，保证了数据库的故障切换时间很短。</li>\n</ol><p>所以，对于需要<strong>强一致性</strong>事务的场景（比如共享单车物联网系统中的支付交易），以及需要基于关系模型进行<strong>复杂查询</strong>的场景（比如共享单车中涉及用户信息表、单车信息表和骑行记录表的丢失单车查询），当单机关系型数据库已经无法满足大数据需求时，可以考虑分布式关系型数据库。</p><p>尤其是当之前的业务已经基于关系型数据库开发完成，并且在实际服务环境中运行的时候，分布式关系型数据库简直是业务开发人员的福音。因为这种情况下想改用其他类型的数据库，如果数据库不支持SQL语言，业务代码就需要进行大量的修改和调整。</p><p>在实践中，分布式数据库的开源选择有TiDB、CockroachDB等，也有商业化的产品，比如阿里巴巴的OceanBase等。</p><h3>时序数据库</h3><p>分布式关系型数据库这个方案，是从<strong>增加能力</strong>的角度得到的。那么，我们能不能从<strong>简化问题</strong>的角度出发，找到其他解决方案呢？</p><p>从原理上看是可行的。这就像假如把灭霸的手套去掉，也许作为高中生的蜘蛛侠也可以对付他。</p><p>物联网中传感器的应用系统就是这样的场景，比如监控冷库中温度和湿度条件的传感器。这些传感器会按照一定的周期不断地上报数据（比如每1分钟上报1次）。这样的数据按照时间顺序排列，形成了一系列的数据点，所以被称为<strong>时间序列数据</strong>（Time Series Data），简称<strong>时序数据</strong>。</p><p>时序数据在读写、存储和分析处理方面有下面这些特点：</p><ol>\n<li>时序数据是持续地写入，一般是采用固定的频率，没有写入量忽大忽小的明显变化。数量非常大，而且并发写入的需求也很高。但是数据很少做更新，旧数据除了特殊情况下的修改，基本是不需要更新的写入操作。</li>\n<li>时序数据的读取很少，相比写入的高并发和高频率，读取的需求主要是进行数据分析的应用，而分析应用的并发访问量是比较少的。</li>\n<li>时序数据时效性很强，一般是越新的数据价值就越大，旧数据会迅速失去价值。</li>\n<li>时序数据的数据分析主要关心的是新数据，旧数据被查询和分析的概率不高。旧数据一般是粗颗粒度的读取分析。而且在被分析时，一般是基于时间范围读取分析，读取某一条记录的几率很小。</li>\n</ol><p>基于时序数据结构和应用上的特点，人们开发出了<strong>时序数据库</strong>，它在近些年随着物联网的应用变得非常流行。</p><p>时序数据库简化了关系型数据库很多不必要的功能，比如采用读取性能不高的LSM 树代替 B+树的存储结构。它专注于支持<strong>高并发的数据写入</strong>，采用更高压缩比的压缩算法来支持海量数据的存储，降低存储的成本，同时，通过预处理等方法来支持海量数据的高效分组聚合计算。</p><p>那么，时序数据库的具体产品有哪些呢？</p><p>首先是开源软件，你可以选择InfluxDB，KairosDB和OpenTSDB等产品。</p><p>另外，云服务企业一般都开发了自己的时序数据库，比如阿里巴巴的TSDB和亚马逊的AWS Timestream等。其中，TSDB还扩展支持了空间信息，以便处理地理围栏和空间轨迹等需求。</p><h2>半结构化数据：非关系型数据库</h2><p>接下来，我们再看看<strong>半结构化数据</strong>。</p><p>半结构化数据包含相关标记，用来分隔语义元素，以及对记录和字段进行分层。比如，JSON格式的数据，我们在<a href=\"https://time.geekbang.org/column/article/310441\">第6讲</a>的物模型中应用过，它就是一种半结构化数据。JSON中大括号“{}”，中括号\"[]\"，冒号\":\"，逗号\",\"就是<strong>分隔语义元素</strong>，每个冒号前面的内容是<strong>字段</strong>，后面的是<strong>记录</strong>。</p><p>我拿共享单车的运行轨迹数据作为例子，展示了一条JSON数据，你可以参考。</p><p><img src=\"https://static001.geekbang.org/resource/image/21/c3/21f1216223d58619df0c561d7e41d9c3.jpg\" alt=\"\"></p><p>半结构化数据的特点是，它的结构并不固定，属于同一类实体可以有不同的属性，这表明它有很好的可扩展性。另外，即使它们被组合在一起，这些属性的顺序并不重要。这些特点决定了我们很难按照关系型数据库的数据模型来建立半结构数据的结构和相互之间的关联。</p><p>除了JSON，常见的半结构数据还有XML等。在应用系统中呢，日志文件就是典型的半结构化数据。</p><p>为了更有效地存储半结构化数据，我们可以选择<strong>NoSQL数据库</strong>。它以键值对存储，且结构不固定，每一个元组可以有不一样的字段。每个元组可以根据需要增加一些自己的键值对，这样数据库就不会局限于固定的结构，可以减少一些时间和空间的开销。</p><p>比如，在共享单车系统中，我们有一款新型单车，它除了可以基于蜂窝网基站定位外，还可以基于GPS进行精度更高的定位。那新、老单车的运行轨迹数据就会有区别。你可以参考下面的一张对比图。</p><p><img src=\"https://static001.geekbang.org/resource/image/1a/06/1a62124025840c32ddee7b3d3d435f06.jpg\" alt=\"\"></p><p><img src=\"https://static001.geekbang.org/resource/image/75/95/751fa86f285443c0a3403bfb1a261f95.jpg\" alt=\"\"></p><p>也就是说，你可以根据需求去添加自己需要的字段。比如在获取用户的不同信息时，你不需要像关系型数据库那样，对多表进行关联查询，而是只需要根据id取出相应的value，就可以完成查询。</p><p>其实，我们知道SQL只是一种操作数据库数据的接口，所以NoSQL中的“No”真正表达的意思是 No Relational，专业的叫法应该是<strong>非关系型数据库</strong>。</p><p>非关系型数据库由于不再强调数据的一致性，不支持事务操作，也不再关注复杂的关联表查询，所以它对海量数据的处理性能更好，而且存储的数据格式比较丰富，易于扩展。有些非关系型数据库会使用内存来存储数据，以便支持更快的查询速度。</p><p>非关系型数据库也有很多的开源产品，比如CouchDB、Redis、HBase、Cassandra等，你可以根据熟悉程度和生态支持选择。商业化的选择也有MongoDB和Oracle NoSQL等产品。</p><h2>非结构化数据：分布式文件系统</h2><p>虽然半结构化数据的结构会根据需求变化，但多少还保留了一些结构化的描述信息。可是有一类数据却完全不能按照结构化的方法来描述，这就是<strong>非结构<strong><strong>化</strong></strong>数据</strong>。典型的例子有监控系统中的视频、图片和音频等信息。</p><p>非结构化数据没有预定义的数据模型，无法简单地用数据库二维表结构来表现。它的格式非常多样，标准也不是统一的。对于这一类数据的大规模存储，我们只能使用<strong>分布式文件系统</strong>。</p><p>其中最有名的当然就是 Hadoop  实现的一个分布式文件系统（Hadoop Distributed File System），简称HDFS。因为拥有Hadoop的大数据生态，所以它是分布式文件系统的最理想的选择之一。其他的分布式文件系统还有FastDFS和Ceph等。</p><h2>小结</h2><p>总结一下，在这一讲中我主要讲解了关于数据存储方案的选择。重要的事情说三遍：</p><p>选型一定要慎重！</p><p>选型一定要慎重！</p><p>选型一定要慎重！</p><p>错误的决策不仅会影响系统的性能，还会增加成本投入。</p><p>基于不同数据类型的特点，选择方案的原则如下：</p><ol>\n<li><strong>结构化数据</strong>，比如用户和设备的关系，用户信息、设备参数等，还是适合<strong>关系型数据库</strong>。为了应对海量数据，你可以采用<strong>分布式数据库</strong>，有TiDB、CockroachDB等，也有商业化的产品，比如阿里巴巴的OceanBase等。另外，物联网中的传感器设备，随时间不断产生新数据。要存储这类数据，你可以选择<strong>时序数据库</strong>，来获得更高的读写和查询性能。</li>\n<li><strong>半结构化数据</strong>，比如JSON结构的数据，日志记录等，一般采用 <strong>NoSQL 数据库</strong>产品。常见的开源选择有MongoDB、CouchDB、Redis、HBase和Cassandra等，商业化的选择有MongoDB和Oracle NoSQL等产品。</li>\n<li><strong>非结构化数据</strong>，比如视频和音频，一般采用分布式文件系统。Hadoop 体系中应用广泛的 <strong>HDFS</strong> 是非常理想的产品。除此之外，FastDFS和Ceph也可以作为选择。</li>\n</ol><p>我整理了一个数据存储方案相关的思维导图，供你参考。</p><p><img src=\"https://static001.geekbang.org/resource/image/da/82/da7262dd01754e0cac5e2e76a5b8fb82.jpg\" alt=\"\"></p><h2>延伸：数据迁移工具</h2><p>在这一讲一开始的时候我就说过，数据的迁移工作比较麻烦，需要在设计阶段就尽量避免。但是，有些数据迁移的需求可能是你避免不了的。比如你要把已运行系统中MySQL数据库里的数据，导入到NoSQL数据库HBase中，以便使用大数据技术进行分析处理。</p><p>对于这样的需求，我们就得借助工具来完成，比较有名的工具就是<strong>Sqoop</strong>项目。它在 Hadoop 大数据存储系统和关系型数据库等系统之间架起了桥梁，借助Sqoop，你就可以很方便地把MySQL数据导入到HBase中。</p><p>另外，Sqoop采用了被称为<strong>Connector</strong>的插件架构，不同的Connector还可以对接不同的数据源，而且你也可以根据自己的需求定制专属的Connector 来完成一些特殊的迁移工作。所以，Sqoop也可以完成NoSQL数据库（比如CouchDB）和文件存储系统（比如FTP）之间的迁移任务。</p><p><img src=\"https://static001.geekbang.org/resource/image/8f/13/8ffd33446f04d3d1c0f497964c2aa513.jpg\" alt=\"\"></p><p>当然，Sqoop也有一个缺点，那就是不太适合<strong>增量的数据更新</strong>，又叫<strong>CDC</strong>（Change Data Capture）。如果基于Sqoop采用定时扫描整张表的方法，那么执行会比较低效，延时也比较严重。</p><p>这时，你可以考虑LinkedIn开源的Databus项目，或者阿里巴巴的Canal，它们都是基于分析数据库日志文件来高效地实现数据的增量更新。</p><h2>思考题</h2><p>最后，给你留个思考题。</p><p>除了从数据类型上考虑，在选择数据库时，我们还要结合业务的需求来判断，因为我们的最终目的是高效地、低成本地解决业务问题，比如时序数据库可以更高效、更低成本地解决传感器监控应用的数据存储需求。你能从处理性能和成本的角度，分析一下NewSQL数据库、NoSQL数据库和分布式文件系统针对的业务分别有什么特点吗？</p><p>欢迎在留言区谈谈你的思考，也欢迎你将这节课分享给你的朋友一起学习。</p>",
                "article_title": "11 | 数据存储：物联网中的数据库有哪些？"
            },
            {
                "title": "12 | IoT Hub：面对海量设备如何打造高性能设备接入层？",
                "id": 317071,
                "content": "<p>你好，我是郭朝斌。</p><p>前面两讲，我们一直在谈物联网云平台针对海量数据的处理和存储技术。顺着物联网的数据技术体系继续往下探索，我们自然就会面临一个问题：物联网云平台的服务器需要管理海量设备的接入，并且接收来自设备的海量数据的输入，那么服务器要怎么应对这样的挑战呢？</p><p>我们来分析一下这个问题。物联网设备是通过某种通信协议接入云平台的，比如常用的MQTT协议，那么设备接入的服务器就是MQTT Broker服务器。</p><p>从架构设计来说，负责设备接入的这一部分一般叫作<strong>设备接入层</strong>，也被称为<strong>IoT Hub</strong>。设备接入层之后，才是和互联网系统类似的<strong>业务层</strong>。具体的系统架构图可能是下面这样的：</p><p><img src=\"https://static001.geekbang.org/resource/image/fd/5b/fdb74fcd872c299459bbb2f28383325b.jpg\" alt=\"\"></p><p>不过，估计你也发现问题了，这样的架构根本无法支撑物联网场景中海量设备的接入和海量数据的输入。单台MQTT Broker服务器很容易面临性能瓶颈。所以前面提到的“服务器怎么应对挑战”的问题就变成了：怎么打造高性能的设备接入层？</p><p>我们再继续深入分析，把关键点定位得更具体一点。打造<strong>高性能</strong>的设备接入层，最重要的技术难点是，如何实现接入层的<strong>高并发</strong>。因为只有具备高并发的能力，才能有效地、可靠地实现数据的传输。</p><p>所以，现在问题又变成了：物联网云平台中，怎么实现高并发的设备接入层？</p><!-- [[[read_end]]] --><p>接下来，我就带你一步一步地设计一个高并发的设备接入层。在这个过程中，我会为你详细地讲解我们需要用到的重要技术，让你为物联网平台的搭建做好技术储备。</p><h2>负载均衡：让多台服务器更好地协作</h2><p><a href=\"https://time.geekbang.org/column/article/316274\">上一讲</a>曾经我提到，为了解决灭霸这个难题，要让超级英雄们组成联盟。同样地，面对性能瓶颈，我们可以集合多个服务器的力量来解决问题，也就是说，可以通过增加多台MQTT Broker服务器来满足海量设备的连接请求。</p><p>但是服务器数量变多之后，它们具体要怎么协作呢？比如一个MQTT请求过来了，它应该被分配给哪台服务器处理呢？更进一步地说，怎么保证每台服务器的负担和压力都基本平衡呢？</p><p>这就要用到负载均衡技术。<strong>负载均衡</strong>（Load Balancer）这个名字非常形象，我们可以分成“负载”和“均衡”两个词来理解。</p><ul>\n<li><strong>负载</strong>是指服务器面对的网络连接和服务请求的<strong>压力</strong>，也就是  “困难”。</li>\n<li><strong>均衡</strong>是针对服务器压力的解决办法，多个服务器一起来处理任务，并且这几个服务器的压力要达到<strong>平衡</strong>的状态，也就是“分担”。</li>\n</ul><p><img src=\"https://static001.geekbang.org/resource/image/1e/32/1e6b6eeff26f3ed5c15debfc3df2fe32.jpg\" alt=\"\"></p><p>这种平衡状态要怎么实现呢？我们需要设计一种任务<strong>分配策略</strong>。</p><p>最简单、直接的办法就是<strong>平均分配</strong>。</p><p>比如有3个服务器都在等待分配。当一个服务请求到来时，负载均衡服务器先将它给服务器1处理；接着第二个请求到来时，给服务器2处理，以此类推。</p><p>当第四个服务请求需要处理时，负载均衡转回来，再次指定给服务器1，循环轮转。所以这种策略也叫<strong>轮询策略</strong>（Round Robin Scheduling）。</p><p>如果用公式来表达这个服务器序号的计算方法，那就是：</p><p>$$i = (i+1)mod(n)$$</p><p>其中 i 是服务器的序号，从0开始计数；n表示服务器个数，这里n等于3。</p><p>当然，在现实环境中，各个服务器的配置并不是完全一样的，有的任务处理能力强，有的能力弱些。这就像在复仇者联盟中，每位英雄的强度也各有不同。</p><p>我们自然希望能力强的服务器多负担一些任务，所以对于轮询策略，我们可以引入<strong>权重系数</strong>。</p><p>比如服务器1的权重是2，服务器2的是4，服务器3的是1，那么负载均衡服务器就可以给服务器2多分配任务，而给服务器3分配最少的工作。</p><p>这个改良版的策略就是<strong>加权轮询策略</strong>（Weighted Round Robin Scheduling）。</p><p>不管是轮询策略，还是加权轮询策略，它们具有简单实用的优点。但是通常情况下，服务器处理每个任务的时间是不同。尤其是在物联网场景中，设备可能会跟服务器保持长连接。可能有的服务器被分配的设备比较少，但是保持连接的设备却很多。这种情况下，如果我们仍然使用轮询策略，那么各服务器的负载就很难达到平衡状态。</p><p>所以我们需要一种<strong>动态调度</strong>的策略，能够基于各服务器的网络连接数情况，优先将新的任务分配给保持连接的设备数最少的服务器。这种基于连接数的策略就是<strong>最小连接数策略</strong>（Least Connection Scheduling）。</p><p>我们也可以为最小连接数策略引入权重系数，给不同能力的服务器分配不同的权重，更好地平衡服务器的负载，这就是<strong>加权最小连接数策略</strong>（Weighted Least Connection Scheduling）。</p><p>这个策略是怎么计算的呢？假设服务器的权重分别是$W_1$、$W_2$和$W_3$，服务器的连接数分别是$C_1$、$C_2$和$C_3$，那么计算的表达式是这样的：</p><p>$$Min(C_1/W_1, C_2/W_2, C_3/W_3)$$</p><p>负载均衡服务器会选择计算结果是最小的那台服务器。</p><p>如果有2台或者3台服务器的计算结果同时最小呢？这时，我们还可以在这几台服务器中采用轮询策略。所以说，分配策略不是相互排斥的，在实践中我们需要综合使用不同的策略。</p><p>考虑到这个原因，我需要给你再讲一种常用的分配策略，那就是<strong>源地址哈希值策略</strong>（Source Hashing Scheduling）。</p><p>所谓源地址，一般就是指网络连接的<strong>源IP地址</strong>。负载均衡服务器通过计算源IP地址的哈希值来确定对应的服务器。因为相同IP地址的哈希值是不变的，这就保证了相同的设备可以连接到固定的服务器上。</p><p>在实践中，我们可以通过开源软件来搭建负载均衡服务器。比如 <strong>HAProxy 软件</strong>，它支持<a href=\"https://en.wikipedia.org/wiki/OSI_model\">OSI网络七层模型</a>中第4层和第7层的负载均衡，性能可以跟商用解决方案媲美。同时，我建议搭配<strong>Keepalived</strong>软件使用，实现高可用的热备方案，这样就可以避免单机故障导致系统瘫痪了。</p><h2>消息队列：避免耗时的等待</h2><p>当负载均衡服务器将物联网设备的网络请求分配到 MQTT Broker 服务器后，MQTT Broker服务器就可以与设备建立连接，并且收到设备上传的数据了。然后，数据就会传输给数据流处理服务器或者写入数据库中。</p><p>但是，数据流处理和把数据写入数据库都是花时间的操作，它们和数据传入的速度并不一致。为了可以让MQTT Broker服务器高效地完成数据的传输，同时保证数据流处理和写入数据库的操作可靠执行，我们需要在MQTT Broker服务器和数据流处理服务器之间加入<strong>异步处理</strong>机制。</p><p>那么，异步处理机制要怎么实现呢？行业内一般通过<strong>消息队列</strong>来实现。你可以把消息队列想象成双十一购物节后的快递公司，它收到商家大量的运单，然后快递公司按照一定的节奏完成这些运单的递送任务。</p><p>在我们的系统中，MQTT Broker 服务器将数据给到消息队列，就完成了数据传输的工作。在这之后，数据流处理和写入数据库的操作只要按照自己的节奏，消费消息队列内的数据就行了。</p><p><img src=\"https://static001.geekbang.org/resource/image/86/b9/86cf475dda27dcc25758b976e4d935b9.jpg\" alt=\"\"></p><p>另外，消息队列还提供了额外的两个好处：</p><ol>\n<li>实现了 MQTT Broker 服务器和数据流处理服务器之间的解耦，双方没有直接的依赖，所以维护更新会更加方便。</li>\n<li>可以平衡输入数据量的大小变化，所以数据流处理服务器不会因为骤增的压力而崩溃。</li>\n</ol><p>既然消息队列这么重要，你肯定也想知道，在实践中有没有开源的软件可以选择呢？答案是有的。最常见的选择有<strong>Kafka</strong>和<strong>RabbitMQ</strong>等。</p><p>Kafka真是一个神奇的软件，凭借着优秀的设计成为消息队列系统的主流选择。而且在这个成功的基础上，它还在不断改进，新增了分布式流处理和分布式存储等功能。虽然这些新功能不一定比专门的流处理和存储软件更强大，但对于中小型的业务来说完全够用了，关键是非常方便，部署也简单。</p><h2>缓存系统：让数据读写更快速</h2><p>从架构图中我们可以看出来，数据流处理服务器处理完数据后，这些数据会存储到数据库中，提供给批处理或者业务服务器使用；而且它在进行数据处理时，也需要从数据存储中获取一些信息。</p><p>但是数据库的读写数据是一个速度比较慢的操作，尤其是基于磁盘介质存储的数据库。为了提高性能，我们需要比数据库，甚至分布式文件系统更快的数据存取方式，这就需要用到<strong>缓存系统</strong>了。</p><p>缓存是一个常见的概念。比如浏览器会使用缓存来避免重复从网络获取网页数据，从而更加快速地响应用户的请求。</p><p>在我们的系统中，引入缓存系统当然是为了避免直接从磁盘中读取数据，或者直接向磁盘中写入数据。</p><p>缓存系统一般会将数据暂时存储在内存中，这样数据流处理应用就不需要直接与低速的磁盘打交道了。而且，如果我们读取的是经常用到的热点数据时，这些数据全都不需要重复从磁盘读取。这样既减轻了数据库的压力，又提高了数据处理速度，一举两得。</p><p>缓存系统的常用开源选择有<strong>Redis</strong>和<strong>Memcached</strong>等。其中Redis更是在数据持久机制和主从节点复制的高可用特性上做了很多工作，不但功能强大，而且效率也很高。</p><p>加入缓存系统之后，设备接入层的整体系统架构就完成了，你可以参考下面这张图。</p><p><img src=\"https://static001.geekbang.org/resource/image/11/88/11ef8db8026f1d9578d9c974a3af8b88.jpg\" alt=\"\"></p><h2>小结</h2><p>总结一下，物联网云平台的服务器为了应对海量设备接入和海量数据输入的挑战，需要打造高并发的设备接入层。所以在这一讲中，我带你设计并完善了设备接入层的整体架构，并讲解了需要用到的<strong>负载均衡</strong>、<strong>消息队列</strong>和<strong>缓存系统</strong>等技术。</p><ol>\n<li>负载均衡用来协调多台服务器来共同应对网络连接和请求的压力，服务器任务分配策略主要有三大类，分别是平等分配的轮询策略，考虑连接设备数的最小连接策略，以及保证相同的源地址访问同一台服务器的源地址哈希值策略。</li>\n<li>这些策略可以搭配使用，还可以通过引入加权系数来改进。在实际应用中，我们需要根据场景灵活选择，常用的开源方案有HAProxy 软件和 Nginx软件，部署时可以搭配Keepalived提高可用性。</li>\n<li>消息队列可以在不同的系统之间搭建桥梁，保证数据和服务请求的高效可靠处理。常用的开源软件有Kafka和RabbitMQ等。</li>\n<li>缓存系统可以减轻数据库的压力，提高系统响应速度。常用的开源软件有Redis和Memcached等。</li>\n</ol><h2>思考题</h2><p>最后，我想请你思考一个问题。</p><p>在这一讲中，我们通过负载均衡来分担服务器的压力。这里设备是使用MQTT协议与接入层服务器，也就是MQTT Broker服务器通信的，所以不同的设备发送的相同 Topic 的消息就会发送到不同的服务器上。</p><p>如果有订阅者订阅这个 Topic 消息，那么应该怎么保证订阅者可以接收到所有的设备发送的此Topic的消息呢？</p><p>欢迎你在留言区写一下自己的思考，同时也欢迎你将本讲分享给对高并发感兴趣的朋友一起讨论学习。</p>",
                "article_title": "12 | IoT Hub：面对海量设备如何打造高性能设备接入层？"
            },
            {
                "title": "13 | 隐私：在实践中如何保护用户隐私？",
                "id": 317861,
                "content": "<p>你好，我是郭朝斌。</p><p>在前三讲中，我带你完善了对物联网系统的<strong>数据技术体系</strong>的认知，包括处理框架、存储方式和设备接入等。</p><p>这些内容涉及到很多<strong>大数据技术</strong>，比如基于数据分析结果，提前调度共享单车的位置；还有基于你的搜索记录和购买历史，向你推荐商品。</p><p>在<strong>大数据时代</strong>，还有一个话题也是我们非常关心的，那就是这一讲要说的<strong>数据隐私</strong>。这个话题涉及的技术知识点不多，所以你学起来会相对轻松一些。</p><h2>为什么要了解隐私？</h2><p>不过，你可能还是要问了：在这个技术类的课程中，为什么要讲这个跟技术关系没那么大的内容呢？作为开发人员，有必要了解这些吗？</p><p>其实这样安排有三个原因。</p><p><strong>第一，面对产品的需求和设计时，我们最好能做到“知其所以然”。</strong></p><p>因为只有这样，才能更好地审视需求，在完成工作的同时，也能提升对业务的理解。</p><p>比如，你在手机上新安装了一个应用，打开之后很可能会看到一个隐私条款的弹框。你可以参见下面的图片：</p><p><img src=\"https://static001.geekbang.org/resource/image/45/dc/454908729ee318405621a9a3f2b32cdc.png\" alt=\"\"></p><p>当产品经理向你提出需求，让在你开发的产品中增加这个弹框的时候，你可能会想：为什么要多此一举，设计一个只能同意的隐私条款弹框呢？难道产品同学今天没休息好，怎么关于用户体验的经验还不如你？但是学完这一讲，你就会知道，其实这是隐私法律的要求。</p><p><strong>第二，正因为相关的法律法规已经施行，我们需要了解和遵守法律法规，保护用户的隐私数据。</strong></p><!-- [[[read_end]]] --><p>一方面，这要求你在系统开发中采取必要的措施保证数据的安全，比如对数据进行脱敏处理；另一方面，虽然你可能接触到非常多的用户数据，但一定不能随便泄露数据，因为这是违法的。</p><p>类似的情况还有金融圈的P2P网贷。当初很多开发人员不懂法，网贷公司跑路之后，他们却糊里糊涂地遭受了牢狱之苦，连之前的工资收入也被没收。</p><p>近几年，也已经有很多人因为隐私案件而遭遇类似的经历。比如某公司通过违规收集简历，进行个人数据的违法利用，当公安进行查处时，公司所有员工都被牵扯进来。</p><p>另外，如果你的产品要出海，那么国外重要市场的隐私政策也得处理好。因为有些国家的法律法规比较成熟，仅仅是数据防护不力就会导致巨额的罚款。</p><p><strong>第三，物联网的应用领域（比如智能家居）可能是一个大生态系统，我们也要满足对接平台的政策要求。</strong></p><p>我们开发的产品可能要对接到小米等平台上。这些平台一般都有严格的隐私政策（这些政策可能比法律法规的要求更严格），隐私方面的合规检查是产品上架流程的重要一环。这就要求我们对相关政策要求做到心中有数，在产品开发过程中，能够提前做好隐私数据的规划。</p><h2>什么是隐私数据？</h2><p>现在你可能要问了：要求这么多，是不是数据相关的功能和应用都不能做了呢？可是为什么我在电商平台上，还是可以看到很多商品推荐信息呢？</p><p>这就涉及到对<strong>隐私数据</strong>的定义了。到底什么是隐私数据，什么不属于？在实际的工作中，如何把握这个度呢？只有搞清楚这个关键问题，你才能更好地把握隐私法规，做好数据应用工作。</p><p>我先举个例子，你来判断一下。比如，一些平台会收集你的历史消费信息、生活的城市和使用的手机品牌等数据，构建你的“用户画像”，然后给你贴一些标签。</p><p>你要是被贴上了“一线城市”“高收入”和“消费频繁”等标签，它们就会觉得你对价格的敏感度低，对平台的粘性高，最后把同样的商品以更贵的价格卖给你。</p><p>请问这触犯了隐私法规吗？当然，这其实就是所谓的<strong>“大数据杀熟”</strong>。2018年，它甚至被评为年度社会生活十大流行语，引起了人们的广泛关注，你我可能都是受害者。</p><p>大数据杀熟和商品推荐系统一样，都利用了<strong>用户画像</strong>。但是商品推荐系统是不违法的，在实践中有很多应用，而“大数据杀熟”却被明确禁止，这是为什么呢？</p><p>它们的区别主要在于，“大数据杀熟”针对的是<strong>特定的个人</strong>。当个人被区别定价、达成交易时，这就是对特定个人的<strong>数据滥用</strong>。</p><p><strong>个人信息</strong>（或者说个人数据，不同国家的叫法不同）可以分为<strong>个人隐私信息</strong>和<strong>个人一般信息</strong>，隐私法律法规主要关注的是个人隐私信息，包括身份证件号码、个人生物识别信息、银行账户、通信记录和内容、财产信息、征信信息、行踪轨迹、住宿信息、健康生理信息、交易信息以及14 岁以下(含)儿童的个人信息等。</p><p>另外，通过个人一般信息和其他信息的加工处理形成的信息，一旦泄露、非法提供或滥用，可能危害人身和财产安全，或者导致个人名誉等其他损失的，<strong>也属于个人隐私信息</strong>。比如，有人通过一个明星在微博上发布的图片，推测出明星的住址。</p><p>而在万物互联的物联网时代，隐私泄露的风险更大。因为各种设备收集的数据都会上传到云平台，数据的维度和数量都比互联网应用更加丰富，比如你身体的各项生理指标、汽车的行驶记录和家里智能摄像头的影像等等。</p><p>同时，现在大数据处理技术、挖掘算法，更是可以基于这些对你来说非常敏感的信息，得出其他的敏感信息。比如你的驾驶习惯好不好，经常开车去什么地方，什么时间出入停车场，汽车保险公司肯定非常想知道。</p><p>面对这样的趋势，谁也不希望成为隐私泄露的受害者，变成一只“待宰的羔羊”。所以用户自然也会更加注重数据安全，甚至把这一点作为选择物联网产品的关键决策因素。我们国家也在加强隐私相关法规的完善，规范企业在个人信息利用中的行为。</p><p>于是，隐私保护的诉求给物联网的产品和服务提出了更高的要求。那么作为产品的设计者和开发者，你在实践过程中应该怎么保护用户的隐私呢？</p><p>目前，你在工作实践中，首先要做到的就是隐私合规，也就是满足各个国家和地区的相关法律法规的要求。因为这是硬性要求，是第一步，只有这样，你的产品才可以顺利地销售或者提供服务，否则就要面临下架和罚款等处罚措施。</p><h2>国内隐私法律法规</h2><p>我们先关注一下国内的隐私法规情况。</p><p>这一讲开头提到的隐私条款弹框，其实就是《信息安全技术 个人信息安全规范》的要求。它是对《网络安全法》的补充，是国内第一个关于个人信息的实践标准。</p><p>有法可依之后，公安网安部门已经针对App等网络服务进行了多次个人信息违法问题的<a href=\"https://www.aqniu.com/industry/67527.html\">整治行动</a>，其中就有像联网汽车App这样与物联网有关的案例出现。</p><p>另外，我国也在积极推进个人信息保护法的制定。在2020年10月13日，《个人信息保护法》草案已经提交到人大常委会讨论。也许在不久的将来，就会有正式的法律落地。</p><p><img src=\"https://static001.geekbang.org/resource/image/45/15/45a16b98db6ef32c6348c9d27cfb5915.jpg\" alt=\"\"></p><h2>出海要注意什么？</h2><p>看完国内的法律法规，我再来介绍一下国外的情况。</p><p>国内企业的出海是越来越明显的趋势，尤其物联网行业里面的智能硬件企业，他们借助我国完整的产业链，具有得天独厚的优势。</p><p>在出海过程中，关注国外的隐私法律就成为必须做的事。在实践中，你需要重点关注的是几个主要市场的要求。</p><h3>欧盟：GDPR</h3><p>我们先看一下欧盟。欧盟的<a href=\"https://stripe.com/zh-cn-us/guides/general-data-protection-regulation\">GDPR</a>（General Data Protection Regulation，通用数据保护条例）知名度非常高，全世界都在关注。它对个人数据进行了全生命周期的保护，被称为<strong>全球最严苛</strong>的隐私政策。</p><p>在2018年GDPR生效之后，欧盟马上就依据<strong>数据跨境传输</strong>等原因，给以Google为代表的美国企业开出了5000万欧元的罚单。GDPR不仅适用于当地公司，而是对所有在欧盟提供的产品和服务的公司都提出了限制。它要求个人数据必须落地在欧洲的服务器存储，不能随意传输到其他地区。</p><h3>美国：《加州消费者隐私法》等法案</h3><p>接着我们再看看美国的情况。美国比较特殊，它是海洋法系，系统法律条文不多，主要靠援引之前判例，而且每个州的自主权也比较大。所以整体来说，美国隐私相关的法律法规是散落在各个州，或者金融、保险、医疗和电信等领域的各种法案当中。</p><p>其中，信息产业发达的加州在2018年6月生效了《加州消费者隐私法》（California Consumer Privacy Act），这是目前美国最全面、最严苛的隐私法规。</p><p>另外，美国也有人在推动全国范围隐私法规的建立。比如苹果的库克就建议制定完整的联邦隐私法，当然，这对于Google和Facebook这些企业是不利的，因为这些企业的服务更依赖个人信息。</p><h3>出海需要重点关注的法律法规</h3><p>总体来说，每个国家和地区都有自己的法律体系和发展节奏，而且法律工作本身是一件非常专业的事情。所以你在出海过程中，最好找<strong>靠谱的、有经验的咨询机构</strong>合作，保障产品在法律上不出问题，避免不必要的经济损失。</p><p>我整理了一个表格，列举了在个人信息方面，你需要关注的主要国家和地区的法律法规，供你参考。注意，这里“个人信息”“个人数据”和“隐私”三个名词意思差不多，只是不同地方的表述习惯不一样。</p><p><img src=\"https://static001.geekbang.org/resource/image/6e/84/6eb8a7d0244e27ce0ded9b554bc5dc84.jpg\" alt=\"\"></p><h2>怎么把握繁多的法律法规？</h2><p>法律法规的内容非常多，作为行业从业人员，我们也不可能把所有条文都背得滚瓜烂熟。那么，有什么简单的办法来指导日常工作吗？我想，你在实践中可以把握下面这4个基本原则。</p><p><strong>第一，保证用户有知情权和选择权。</strong></p><p>如果需要收集用户的个人信息，我们需要告知用户，征求用户的授权，而且要用显著的、容易懂的方式说明信息的使用方式、使用范围和目的。</p><p>比如我刚才提到的隐私信息弹窗就是一个例子。而且，用户还要能够决定是否同意授权，以及授权之后再取消授权。你在做智能硬件配套的App时，可以留意这方面的要求。</p><p><strong>第二，收集、使用信息时要采用最小必要原则。</strong></p><p>这个比较好理解。我们收集使用的信息应该尽量少，只要能够满足产品和服务的功能需求就足够了。比如智能台灯，我们只需要接收的房间信息就可以实现语音控制和交互，并不需要收集准确的GPS定位。</p><p><strong>第三，保证用户有信息控制自主权。</strong></p><p>我们收集的信息的主体仍然是用户，也就是说，用户随时可以查看自己的数据，可以修改、甚至删除它们。你可以在App或者网页中提供这样的入口。</p><p><strong>第四，确保个人信息存储和使用的安全。</strong></p><p>收集了用户的个人信息，我们就需要保证个人信息的数据安全，从内部人员的管理和数据的使用流程上把控风险，比如将数据中的个人指向性内容去掉。同时，我们也要做好系统的安全防护工作，防止被攻击导致数据泄露。在下一讲中，我还会讨论更多关于系统安全的内容。</p><p>从这些原则出发，你就可以更好地理解和满足相关法律法规的要求，做好产品和服务的合规工作。</p><h2>从用户的角度出发的设计</h2><p>以上内容主要是从法律角度来讨论这个问题。但是从根本上说，你还是需要从用户的角度出发，在为用户创造价值和解决问题的同时，保护好用户的隐私。</p><p>法律永远是滞后的，法律也总有漏洞，各种利用个人隐私信息获利的新方法会不断出现。但是用户会“用脚投票”，选择隐私保护更好，更值得信赖的产品和服务。从这个角度考虑，隐私保护虽然需要企业投入成本，但是它也可以成为企业独特的竞争优势。</p><p>比如，国外有一个搜索引擎公司DuckDuckGo，在棱镜门事件后，日均使用量一年就翻了一倍，近几年用户量也是稳步增长，2020年8月用户量就达到了6500万。它吸引用户的一个关键点正是强调用户隐私，不追踪用户，也就是<strong>匿名性</strong>。这和Google这样的搜索引擎恰恰相反。</p><p>除了匿名，你还可以像苹果公司一样采用“<strong>差别隐私</strong>”的方法，通过在数据中增加“噪音”，或者修改数据隐私信息，来保护用户的个人信息泄露。</p><p>我再举一个互联网应用的例子，因为你日常中接触得更多。</p><p>当你在微信中分享照片，无论通过聊天界面还是朋友圈，微信一般都会对照片进行压缩。有时候你可能还会抱怨微信把照片处理得不够清晰，所以专门选择发送原图。</p><p>其实微信在压缩照片的同时，都会修改照片的<strong>EXIF信息</strong>，它包含拍摄时间、地点等隐私信息。如果你的照片被“有心人”利用，他们可能通过数据分析，直接精确地定位到你家小区，是不是很可怕？</p><p>其实微信还有很多类似的从用户角度出发的设计。比如微信朋友圈中的“给谁看”“不给谁看”“仅自己可见”等，就是<strong>给用户控制数据可见范围的选项</strong>。这样用户会更有控制感。</p><p>另外，可以<strong>减少信息的展示时间，甚至避免信息的永久存储</strong>。最知名的就是聊天软件上的“阅后即焚”功能。还有微信中聊天记录不会被云端永久保存，朋友圈中的“三天可见”“半年可见”，也是同样的设计思路。这种设计可以让用户更放心地分享内容，提高用户体验的同时，也增强了产品的粘性。</p><p>那基于同样的思路，在硬件上我们也可以多采取类似的产品设计方法和角度，提高用户的信任感。</p><p>比如，智能手表设备会收集很多用户的个人生理指标数据，而且一般在设备上有数据的存储功能。这种存储当然出发点是为了缓存数据，保证数据在手机或者云端的可靠获取，但是它也存在泄漏的风险。</p><p>那我们就可以增加一个功能，让用户可以随时通过手表本身，不用借助手机等其他设备就可以永久删除存储的历史数据。这样的设计会让用户更加放心地使用产品。</p><h2>小结</h2><p>总结一下，在这一讲中，我分析了学习隐私知识的必要性，重点讲解了隐私数据的概念，并介绍了国内、国外关于用户隐私的法律法规和把握这些法规的基本原则。</p><p>除了法律法规，我也谈了从用户角度出发，做好隐私保护工作的思路和方法。了解了这些，你才能在物联网行业从业过程中做好合规工作，并且设计出让用户真正感到满意和放心的功能。</p><ol>\n<li>从懂业务、懂法律和懂生态的角度，我们作为开发人员都需要掌握隐私的相关知识。</li>\n<li>在隐私法规上，个人信息可以分为个人隐私信息和个人一般信息。我们需要重点关注个人隐私信息的保护。</li>\n<li>在隐私保护方面，我国已经生效的法律有《网络安全法》和《个人信息安全规范》。另外，《个人信息保护法》的草案已经提交人大常委会讨论，在不久的将来应该也会正式发布。企业出海时，需要关注当地的法律，比如欧盟的GDPR，以及美国各个州和各个领域的相关法案。为了保证出海工作的顺利进行，我们最好还是找专业的咨询机构合作。</li>\n<li>作为物联网行业的从业者，在实践中要把握4条基本原则：第一，保证用户有知情权和选择权；第二，收集、使用信息时要采用最小必要原则；第三，保证用户有信息控制自主权；第四，确保个人信息存储和使用的安全。</li>\n<li>让产品和服务符合法律法规的要求只是第一步。在产品理念，或者说底层价值观上，我们要从用户角度出发，重视对用户隐私的保护。具体的方法有增加匿名性，采取差别隐私，让用户可以控制数据可见范围和减少信息的展示时间甚至避免永久的存储。</li>\n</ol><p>我整理了一张思维导图，供你参考。</p><p><img src=\"https://static001.geekbang.org/resource/image/dy/a5/dyycc0473f2c1d8bc70fecef547dafa5.jpg\" alt=\"\"></p><p>隐私政策在近几年备受关注，这背后的本质原因，也许是科技的发展、数字化深入生活的必然趋势。用户只有让渡一些个人信息才能获得更好的服务，或者更有利于需求的解决；但是任何时候，用户的个人信息都不应该被滥用、被泄露、被非法提供进行交易。</p><p>正如张小龙说的那样：“<strong>善良比聪明更重要，AI比我们更聪明、更懂套路，但我们可以比他更善良。</strong>”只有这样用户才会信任你，你也才能拥有一个长久的、有生命力的产品和服务。</p><p>而如果作为消费者，我们也需要了解这些法律法规的基本信息，保护好个人的隐私数据，并且遇到问题时，把它们作为维护自己权益的工具。</p><h2>思考题</h2><p>最后，我给你留一个思考题吧。</p><p>智能家居中，用于安全监控的摄像头有很多的价值，但是很多人担心它的安全性，害怕隐私数据的泄露。如果你来设计摄像头产品，从用户的角度出发，会做哪些设计来增加产品的认可度呢？</p><p>欢迎你在留言区写一写自己的思考，也欢迎你将这一讲分享给对隐私保护感兴趣的朋友一起学习。</p>",
                "article_title": "13 | 隐私：在实践中如何保护用户隐私？"
            },
            {
                "title": "14 | 安全：物联网平台如何应对安全风险？",
                "id": 319440,
                "content": "<p>你好，我是郭朝斌。</p><p>在<a href=\"https://time.geekbang.org/column/article/317861\">第13讲</a>的思考题中，我提到了用户对于摄像头泄露隐私的担忧。这样的顾虑并不是杞人忧天。在现实生活中，物联网设备确实面临很多安全问题，而且这些安全问题已经对个人信息安全构成威胁。</p><p>比如2019年12月，在美国非常流行的家庭安防产品<a href=\"https://www.wired.com/story/ring-hacks-exemplify-iot-security-crisis/\">Ring 爆出安全漏洞</a>。黑客不但可以远程查看Ring的监控视频，还获取到了家庭Wi-Fi的密码，甚至可以把收集的用户音频数据分享到开放的播客节目中。</p><p>作为物联网开发人员或者安全技术负责人，我们肯定不想看到自己负责的产品和服务上负面新闻。为了跟用户建立信任，我们必须切实做好安全工作，打造可靠的产品和服务，保护数据不被泄露。</p><p>你可能已经对于互联网的安全工作有一些了解，甚至有一定实践经验。不过在物联网领域有很多新的变化，所以我们需要重新思考安全工作该怎么开展。</p><p>在物联网设备上，安全的实践并不像在电脑上那么成熟。虽然现在的公司也越来越重视设备的安全问题，但是还是经常出现失误。</p><p>更何况，很多设备都是创业公司或者外包团队研发生产的。它们本身的盈利能力还比较弱，没有足够多的资源投入到安全方面，所以这些设备面临的安全问题往往更加严重。</p><p>总的来说，安全问题主要反映在两个方面：第一，公司没有针对物联网的特点建立起完善的安全管理流程和制度；第二，在具体的技术实践中，没有考虑物联网面临的新的安全问题。</p><!-- [[[read_end]]] --><p>所以在这一讲中，我就从管理和技术两个方面出发，跟你分享一些物联网的安全实践经验。</p><h2>安全管理规范</h2><p>首先，你需要建立一个<strong>安全管理规范</strong>，从机制和组织上保障安全，不能因为各方面资源的限制而放松要求。</p><p>从实践的角度出发，我把安全管理分为<strong>开发</strong>、<strong>生产</strong>、<strong>部署</strong>和<strong>运营</strong>4个方面。</p><h3>1. 开发：基于安全开发生命周期建立流程</h3><p>开发是产品和服务的基础，是最关键的地方，所以我先说说开发。</p><p>在开发过程中，怎么保证安全，满足合规性的要求呢？你可以基于<a href=\"https://dzone.com/articles/how-to-approach-security-development-lifecycle-sdl\"><strong>安全开发生命周期</strong></a>（SDL，Security Development Lifecycle）来建立企业的安全开发流程。SDL早已是保证开发安全的公认方法论。它能够减少安全漏洞的数量、降低安全漏洞的危害，从而帮助你做出更安全的产品和服务。</p><p>SDL的整个周期由六个过程组成，我总结在了下面这张图片里。</p><p><img src=\"https://static001.geekbang.org/resource/image/9f/18/9f7a824790ff0c5783bf89b1426a1c18.jpg\" alt=\"\"></p><h3>2. 生产：降低由工厂带来的安全风险</h3><p>跟纯软件产品不同，物联网设备还需要在工厂生产。那么，在生产中你要注意什么安全问题呢？注意，这里的“安全”不是指<strong>人身安全（Safety）</strong>，而是指<strong>出厂设备的安全（Security）</strong>。</p><p>首先，你在选择合作工厂的时候，要确保对方具备一定的<strong>质量体系流程</strong>，最好有第三方的质量体系认证。这样可以一定程度上保证工厂在流程上的安全工作。</p><p>其次，你在设计产品的时候，一定尽量<strong>减少在工厂进行涉及安全的操作</strong>，比如设置安全秘钥等。这样可以最大限度地减少工厂操作失误和数据泄露带来的问题。</p><p>最后，还有一些有安全风险的操作是必须在工厂进行的，比如设备固件烧录和硬件电路板组装等。对于这些操作，你要和工厂一起确定好流程，做好固件版本和硬件批次的控制，同时在<strong>成品质量检测</strong>中增加软、硬件版本的检查项目。</p><h3>3. 部署：从软件和硬件两方面考虑</h3><p>在物联网产品和服务投入正式使用之前，我们还需要进行软件和硬件的部署工作。为了保证系统的安全，你需要采取哪些措施呢？</p><p>一方面，你要做好<strong>软件</strong>的安全部署。</p><p>在服务器上部署软件的时候，你要检查防火墙的配置，保证不必要的端口都是关闭的。另外，软件的各种安全设置都要打开，不能让安全设计沦为摆设。</p><p>另一方面，你也要做好现场的<strong>硬件</strong>安全部署。</p><p>在现场部署硬件设备的时候，你需要考虑设备被随意获取、暴力拆解和分析的情况。因为拿到设备进行研究，往往是对物联网设备进行安全攻击的第一步。尤其是那些不能从商场买到的，或者部署在室外的非普通消费品，比如智能电表，还有无人值守停车场部署的计费设备等。</p><p>所以你得采取一定的<strong>物理防护措施</strong>，比如安装监控摄像头或者额外的防护装置（比如外壳等），让攻击者不能轻易地获取到设备。</p><p>另外，在设备初次入网或者重新入网的时候，你要保证<strong>操作人员的可信度</strong>，并做好<strong>安全引导工作</strong>。同时，你必须要求操作人员把设备的一些控制接口关闭，或者修改初始默认密码。比如对于网关设备，你可以关闭本地管理界面功能，或者修改初始的密码，这样可以避免被攻击者轻易地破坏。</p><h3>4. 运营：把安全融入持续的运营过程中</h3><p>最后，在产品和服务运营的过程中，我们还需要做好监控、运维和应急响应组织建设这3个方面的安全事项。</p><p><strong>监控</strong>可以保证及时发现问题，是非常重要的运营手段。</p><p>比如，你可以通过系统实现<strong>对设备和平台系统的日志进行自动化监控和分析</strong>。这可以帮助你从一些记录中（比如系统尝试提权和认证异常等）及时发现异常行为。</p><p>还有一些监控发现的事件，是需要及时通知用户的。比如异常登录，系统要及时通过短信或者邮件告知用户风险。</p><p><strong>运维</strong>是确保服务和设备安全状态的重要工作。</p><p>除了做好云平台服务器的运维工作之外，你还可以在系统中<strong>增加设备资产的管理功能</strong>，这有利于跟踪设备状态和固件更新等工作。</p><p>另外，很多物联网设备中存储有秘钥、证书等敏感信息。所以对于所有被淘汰的物联网设备，你都要做好<strong>退役期处理</strong>，把关键信息从设备上擦除掉，同时在云平台上对设备做归档、标记等处理。</p><p><strong>应急响应中心</strong>是互联网公司在长期的安全实践中做出的非常好的创新。</p><p>在互联网发展的初期，一些“白帽子”黑客就算发现问题，也很难流畅地反馈给企业处理，甚至会被认为是勒索。但目前主流的公司基本上都会设置安全应急响应中心，甚至鼓励在一定的范围内<strong>跟白帽子合作</strong>，来提高系统的安全性。这是你在实践中值得借鉴的方法。</p><h2>安全技术保障</h2><p>刚才说的安全管理规范，只是从制度上来减少安全漏洞和安全事故，并对安全事件进行及时响应和处理。但是实际工作中，你还需要从技术上来保障安全。</p><p>怎么做好技术保障呢？我们知道物联网从架构上可以分为三层，设备层、网络层和应用层，你可以从这三个层面入手来做好安全工作。</p><p>现在我以共享单车为例做一个讲解。</p><h3>第一步：分析安全需求</h3><p>共享单车，你我都很熟悉，我们很容易就能分析出它的安全需求：</p><ol>\n<li>保证单车资产的安全</li>\n<li>确保开锁、计费等关键功能和数据的完整性</li>\n<li>保证个人信息、轨迹信息等敏感信息的保密性</li>\n<li>确保云平台、App等整体系统的可用性</li>\n</ol><p>接着，我们细化这些需求，列出明确的指标，然后跟公司的安全基线对比，看是否符合安全基线的要求，对于不符合的部分是否可以放行。</p><p>公司的安全基线是从哪里来的呢？一是公司自己的实践经验，二是最佳安全实践指导文件。</p><p>这些指导文件来自安全公司或者安全组织，比如国内的绿盟，国外的CSA（Cloud Security Alliance，云安全联盟）、IIC（Industrial Internet Consortium，工业互联网联盟）和 IoTSF（IoT Security Foundation，物联网安全基金会）等。</p><p>另外，还有一些行业相关规范涉及的安全内容，包括我在<a href=\"https://time.geekbang.org/column/article/317861\">第13讲</a>介绍的隐私相关法律法规对于安全防护的要求，这也是公司安全基线的一个来源。</p><h3>第二步：构建威胁模型</h3><p>明确了安全需求之后，下一步就是构建共享单车系统的威胁模型。建模可以帮助我们全面地了解共享单车系统中各个角色、接口和数据流，然后分析清楚系统面临的攻击面和信任边界。基于攻击面和信任边界，我们就可以更好地识别系统的潜在威胁。</p><p>至于建模的具体方法，我们可以使用OWASP提出的<a href=\"https://cheatsheetseries.owasp.org/cheatsheets/Threat_Modeling_Cheat_Sheet.html\">威胁建模备忘清单</a>。它的好处是有一个开源的工具可以使用，名称是<a href=\"https://github.com/OWASP/threat-dragon-desktop/releases\">Threat Dragon</a>。除了这个，我们还可以选择<a href=\"https://www.microsoft.com/en-us/securityengineering/sdl/threatmodeling\">微软的威胁建模工具</a>，它也是免费的。</p><p>首先，我们基于共享单车系统的组成绘制出数据流图。下图是我使用 Threat Dragon 工具创建的共享单车系统的数据流图。（注意，这里只是举例，现实中的单车系统可能与此不同。）</p><p><img src=\"https://static001.geekbang.org/resource/image/54/d4/546590e6e763afaba28e53f28bfe3fd4.png\" alt=\"\" title=\"共享单车数据流图\"></p><p>基于数据流图，我们就可以做威胁识别了。你可以借助微软的<a href=\"https://www.ockam.io/learn/blog/introduction_to_STRIDE_security_model\">STRIDE模型</a>来完成，这也是Threat Dragon支持的威胁定义方法。</p><p>STRIDE模型将威胁分为六种不同的类型：欺骗、篡改、否认、信息泄露、拒绝服务和权限提升，它们在下面的威胁识别表格中都有体现。</p><p><img src=\"https://static001.geekbang.org/resource/image/eb/4f/eb7968cf5d06d721a6bca36bde7f004f.jpg\" alt=\"\" title=\"共享单车威胁识别表\"></p><p>识别完威胁以后，我们需要归档，然后根据发生概率和可能的危害程度，对它们进行评估。评估可以使用微软的<a href=\"https://en.wikipedia.org/wiki/DREAD_(risk_assessment_model)\">DREAD模型</a>来完成。它按照5个维度对一个威胁进行风险等级打分（分值范围1～10），然后计算出平均值作为威胁的最后分数，分数越大风险越高。</p><p>对破坏车体二维码的威胁进行DREAD风险评分，可以得到表格所示的结果。</p><p><img src=\"https://static001.geekbang.org/resource/image/7f/ed/7f910286987061973ec31c7632d4c9ed.jpg\" alt=\"\" title=\"破坏车体二维码的威胁风险评分表\"></p><p>基于威胁评估的结果，我们可以对威胁的安全控制措施进行优先级排序，形成安全设计文档。然后我们把安全设计文档中的控制措施加入到产品的需求列表中进行跟踪，有计划地实施。</p><p>下面是我得到的共享单车系统的威胁矩阵，我按照物联网的三层架构进行了分组。</p><p><img src=\"https://static001.geekbang.org/resource/image/a2/de/a2867817b97ffa287dddde2c71f8c2de.jpg\" alt=\"\" title=\"共享单车威胁矩阵表\"></p><p>接下来，我就分别讲解一下三层的安全控制措施。</p><h3>第三步：逐层技术防护</h3><h4>设备层安全：业务目标的关键</h4><p>首先是设备层。由于共享单车大多处于无人监控且恶劣的环境中，设备层的安全风险较为突出。</p><p>对于谎报电子锁故障，我们一方面可以在App中增加证据上报功能，比如图片、视频等，来增加谎报的难度；另一方面可以在电子锁上增加更准确和可靠的状态检测传感器，并且将这些信息上报服务器，这样就可以实现攻击识别的自动化，让攻击者不敢轻易尝试。</p><p>针对固件的攻击行为，实施成本较高，但对于专业人员来说也不是太大的难题，所以我们需要做好以下几个方面的防护措施：</p><ol>\n<li>采取物理防护措施，加大拆除电子锁和拆解锁体的难度，让攻击者无法轻易获取到电子锁。</li>\n<li>采取篡改检测机制，通过传感器（比如压电薄膜）来检测破坏行为，然后声音报警，并且上报事件到云平台。</li>\n<li>在可能的情况下，尽量不启用芯片的调试接口（比如JTAG和串口），从而防止攻击者获取固件文件和控制接口。</li>\n<li>避免将敏感信息（比如加密私钥）硬编码到固件中，以防攻击者从硬件中获取到。</li>\n</ol><p>对于刚才提到的破坏二维码行为，最直接的方法当然是增加攻击难度，比如在车体多处增加二维码信息，采用更坚固的材料保护二维码。</p><p>不过，根本的办法还是寻找其他技术方案来替代二维码，或者作为二维码的备用方案，比如NFC和蓝牙技术。</p><h4>网络层安全：加密通信是根本</h4><p>然后是网络层。网络层面临的是不可控的传输网络，和未正确使用的通信技术，所以在物联网上传输的数据包如果没有加密和签名，很容易发生被窃听、篡改、伪造以及发送者抵赖等问题。</p><p>在2017年的<a href=\"https://m.sohu.com/n/494029756/\">GeekPwn大会</a>上，就有安全人员通过截获Wi-Fi网络上的数据包，轻松地获取了别人在4款共享单车App上的账号权限。他们靠这些权限，不但可以开锁，还能掌握用户的GPS轨迹等信息。这跟上面表格提到的，通过手机App获取账号和伪造电子锁发送关锁信息，属于类似的实现方式。</p><p>所以我们需要对网络通信进行加密，采用<strong>SSL/TLS</strong>的方法进行安全通信。在App上，可以采用 SSL Pinning的模式进行双向认证，保证通信双方传输交换安全；电子锁设备的通信也要加密，可以采用MQTT支持的SSL/TLS方式。</p><p>另外，蓝牙协议本身就支持很多安全机制，能够实现配对安全、数据防篡改和设备认证等特性。现在很多共享单车除了支持服务器下发命令开锁以外，还支持采用蓝牙协议来开锁。这时候一定要记得使用蓝牙的数据加密机制，保证开锁命令不会被攻击者轻易获取。</p><h4>应用层安全：保证可用性和数据安全</h4><p>最后是应用层。它作为物联网业务服务平台，向用户提供相关业务及应用。同时，在这个过程中，它还会采集、存储和处理大量的敏感数据。所以，我们必须保证服务的可用性和安全性。</p><p><strong>DDoS攻击</strong>可以说是目前最难防御的攻击之一，还没有特别完美的解决方案。我们可以采取多种方案组合，结合攻击的实际情况灵活应对，达到减少损失的目的即可。常用的手段有增加带宽，通过防火墙清洗，过滤异常流量，以及与专业的提供抗DDoS服务的公司合作。</p><p>对于上面威胁矩阵中提到的防范恶意植入和SQL注入，我们需要做好下面几件事：</p><ol>\n<li>及时更新服务器操作系统和其他软件，尤其是出现严重漏洞的软件，不给攻击者可乘之机。</li>\n<li>设置防火墙，同时关闭不需要的服务和网络端口。暴露越少，被攻击的可能性就越小。</li>\n<li>定时对服务器和数据库做好备份，避免重要数据丢失或者服务不能及时恢复的情况。</li>\n<li>做好系统安全监控，及时发现异常的攻击行为，为进一步的安全防护做好准备。</li>\n</ol><p>另外，服务器对外提供的开放接口也可能导致的SQL注入等安全问题，同样需要注意。对于这些问题，我们可以通过定期做渗透测试来防范。</p><h2>小结</h2><p>总结一下，在这一讲中，我从安全管理规范和安全技术保障两个角度，讲解了我们在安全上需要关注的地方。</p><p>首先，我们要建立安全管理规范，从机制和组织上保障产品和服务的安全，主要分为四个方面：</p><ol>\n<li>开发方面，我们可以基于SDL来建立企业的安全开发流程，保证开发符合安全规范。</li>\n<li>生产方面，通过质量体系、安全检查等保证出厂产品的合规。</li>\n<li>部署方面，既要注意软件的安全配置，也要保证硬件现场部署的安全措施落地。</li>\n<li>运营方面，我们需要做好监控、运维、应急响应组织建设这三个方面的安全事项。</li>\n</ol><p>其次，实际工作中，我们还需要从技术上来保障安全。具体步骤是先分析安全需求，再构建威胁模型，然后基于威胁建模的输出，在物联网三层架构中分别做好技术防护措施：</p><ol>\n<li>在设备层中，做好固件、硬件接口上的防护工作。</li>\n<li>在网络层中，重点关注通信技术、通信协议的风险，保证网络通信采用SSL/TLS 加密方式。</li>\n<li>在应用层中，做好DDoS攻击、SQL注入等安全防护，及时处理安全漏洞。</li>\n</ol><p>我整理了一张思维导图，供你参考。</p><p><img src=\"https://static001.geekbang.org/resource/image/b8/3c/b84128760779b4a245075e5e47008d3c.jpg\" alt=\"\"></p><p>从用户的角度看，安全和隐私可以说是密切相关。用户担心产品的安全问题，主要关注点也是害怕个人信息的被泄漏和滥用。作为从业人员，我们只有做好安全工作，才能落实好个人信息的保护，从而打造出安全可靠、用户信任的产品和服务。</p><h2>思考题</h2><p>最后，我给你留一个思考题吧。</p><p>我在<a href=\"https://time.geekbang.org/column/article/311616\">第7讲</a>介绍零配置组网时提到了UPnP协议。它为我们日常使用设备提供了便利，但也被称为“安全重灾区”。你知道UPnP协议存在哪些安全风险吗？</p><p>欢迎在留言区写下你的答案和我交流，也欢迎你将这一讲分享给对物联网安全感兴趣的朋友，大家一起讨论学习。</p>",
                "article_title": "14 | 安全：物联网平台如何应对安全风险？"
            },
            {
                "title": "15 | 平台：智能家居开源平台的生态是怎样的？",
                "id": 320675,
                "content": "<p>你好，我是郭朝斌。</p><p>在学完了这门课程的前十几讲之后，你已经对物联网有了一个从整体到细节的全面了解。我想，你现在应该迫不及待地想要动手实践了吧？</p><p>在正式进入实战篇之前，我想以智能家居领域为例，带你了解一下开源平台。</p><h2>智能家居：生态开放</h2><p>为什么选择智能家居这个领域呢？最重要的原因当然是因为实战篇的动手项目是智能家居领域的。而另一个原因是，智能家居的生态环境比较开放，很有活力，而且也更贴近我们的日常生活。</p><p>在<a href=\"https://time.geekbang.org/column/article/313631\">第9讲</a>，我提到过和工业物联网相关的一些开源项目。相比之下，工业物联网领域更加封闭，如果不是行业从业人员，你很难理解它的功能需求。</p><p>那么，什么是平台，平台有什么用呢？就拿智能家居平台来说好了，它给各种智能家居产品提供了一个<strong>统一的接入系统</strong>，让用户可以<strong>管理</strong>和<strong>控制</strong>产品，同时也为各种智能家居产品之间的<strong>联动</strong>提供了条件。</p><p>如果没有智能家居平台，那么各种智能家居产品就是一个个孤立的单品，既不能远程控制，也不能实现联动功能。</p><p>如果你买过小米的智能产品，应该接触过小米的米家平台，它就是一个典型的智能家居平台。国内类似的还有阿里巴巴的天猫精灵、京东微联和海尔U+等。国外知名的智能家居平台有苹果的Apple HomeKit、亚马逊的Amazon Echo和谷歌的Google Home等。</p><!-- [[[read_end]]] --><h2>开源平台：方便定制</h2><p>不过，刚才提到的这些都是商业公司运营的平台，它们使用的技术和通信协议都是公司制定的，能够选择的产品也只能是已经接入平台的产品。作为开发实践者，我们可以定制的部分非常少。</p><p>所以在这一讲，我想介绍一下智能家居的开源平台生态。</p><p>一方面，开源平台能为你提供一个现成的基础，你可以在这个基础上快速地搭建出自己的智能家居系统。而且这些平台不但可以提供丰富的特性，一般也会提供各种定制能力，方便你基于自己的需求灵活地调整。</p><p>另一方面，就算你在工作中不直接使用这些开源平台，你也可以从它们的架构设计和实现逻辑中汲取灵感。</p><p>在介绍完智能家居的开源生态之后，我还会选择其中一个开源平台，带你在树莓派开发板上运行起来，这样你也可以初步体验一下智能家居软件。</p><h2>热度比较高的开源平台</h2><p>那么你觉得智能家居的开源平台多吗？我告诉你，其实非常多。这也从侧面反映出智能家居是一个非常被看好的领域。</p><p>在这一讲中，把所有的开源项目都讲一遍是不现实的，所以我精心挑选了5个热度比较高的项目介绍，供你参考。</p><ol>\n<li>\n<h4>Home Assistant</h4>\n</li>\n</ol><p>首先要说的就是<a href=\"https://www.home-assistant.io/\">Home Assistant</a>。由于支持丰富的硬件和软件组件，能够实现自由灵活的配置和定制开发，所以它是现在热度最高的开源平台。大量极客用户组成了庞大而活跃的社群，他们贡献了很多基于Home Assistant的开源组件和丰富的使用资料。</p><p>这些组件要怎么配置呢？在Home Assistant中，你需要通过configuration.yaml配置文件来定义你需要使用的组件以及组件之间的联动方式等。</p><p>从文件的扩展名你应该可以看出，它的配置文件使用的是<a href=\"https://yaml.org/\">YAML语言</a>。这种语言是专门为配置文件设计的，写起来比JSON要简单得多。</p><p>另外，Home Assistant是基于Python 3语言实现的，理论上支持在任何有Python 3的系统环境中运行，当然也包括树莓派。它对于树莓派的支持非常好。</p><p>虽然是开源软件，但是我们也需要注意开源许可协议。Home Assistant的代码采用的是<a href=\"https://github.com/home-assistant/core/blob/master/LICENSE.md\">Apache License 2.0</a>协议。</p><ol start=\"2\">\n<li>\n<h4>Domoticz</h4>\n</li>\n</ol><p>第2个要讲的是<a href=\"https://www.domoticz.com/\">Domoticz</a>，它是一个开源的家居自动化平台，可以帮你实现对智能家居设备和传感器的控制和监测等目的。除了它原生支持的设备，你还可以使用很多开源插件。当然，你也可以选择用Python语言开发自己的插件，从而支持自己特有的设备。</p><p>Domoticz主要是通过Web界面来进行自定义和配置。它还同时提供了iOS和Android两大系统的App供你查看和控制设备。</p><p>Domoticz是基于C++语言开发的。跟Python语言开发的软件不同，它还需要编译不同的安装包，这显然不够方便。不过，Domoticz官方已经为Windows和Linux系统准备了二进制安装包，包括使用ARM架构芯片的树莓派，也已经有了编译好的可执行文件。</p><p>Domoticz代码采用的是<a href=\"https://github.com/domoticz/domoticz/blob/master/License.txt\">GNU General Public License v3.0</a>（GPLv3）开源协议。</p><ol start=\"3\">\n<li>\n<h4>openHAB</h4>\n</li>\n</ol><p>第3个要讲的是openHAB。它的出发点是提供一个家庭自动化的总线，所以在设计上尽量抽象而模糊设备本身，便于你根据需求添加设备和插件。在openHAB中，插件是通过Bindings来实现设备和openHAB内核的交换信息的。</p><p>交互界面方面，openHAB也提供了丰富的选择，包括原生的iOS和Android平台的App以及Web页面和Windows 10应用程序等。</p><p>openHAB是基于Java语言开发的。除了常见的电脑平台，它还支持用Docker镜像的方式安装使用。另外，它还专门提供了openHABian系统的镜像文件，所以在树莓派上使用openHAB软件是非常方便的。</p><p>openHAB代码采用的是<a href=\"https://github.com/openhab/openhab-core/blob/master/LICENSE\">Eclipse Public License 2.0</a>开源协议。</p><ol start=\"4\">\n<li>\n<h4>Gladys Assistant</h4>\n</li>\n</ol><p>第4个要讲的是<a href=\"https://gladysassistant.com/en/\">Gladys Assistant</a>。它是一个刚刚重新设计和开发的智能家居平台。它原生支持Z-Wave、MQTT和小米等设备接口，并且在平台中嵌入了自己的 NLP（自然语言处理）对话引擎。你可以在平台上定义复杂的场景模式。</p><p>Gladys Assistant的主要交互界面是Web页面。不过这些Web界面在手机上的体验也非常好，因为它是基于PWA（Progressive Web App）实现的。PWA技术使Web应用在手机的体验基本和原生App一致。</p><p>Gladys Assistant使用JavaScript语言实现的。它对于树莓派的支持非常不错，提供了基于Raspbian的系统镜像。另外，通过Docker的方式对MacOS和Windows系统也提供了支持。</p><p>Gladys Assistant代码采用的是 <a href=\"https://github.com/GladysAssistant/Gladys/blob/master/LICENSE\">Apache License 2.0</a>开源协议。</p><ol start=\"5\">\n<li>\n<h4>WebThingsIO</h4>\n</li>\n</ol><p>不知道你是否还记得，我在加餐的书单推荐中提到过<a href=\"https://www.w3.org/WoT/\">WoT</a>标准。这里我要介绍的<a href=\"https://iot.mozilla.org/\">WebThingsIO</a>项目正是Mozilla在领导开发的一个基于WoT理念的开源实现。</p><p>其中，WebThings Gateway是一个智能家居网关软件（也就是控制中心）实现，你可以使用它提供的Web界面来实现对设备的查看和控制。它也支持定义联动的规则，还提供了用插件方式来扩展对其他设备的支持。</p><p>WebThings Gateway主要是使用JavaScript语言实现的。它为树莓派专门制作了系统镜像文件，你可以直接烧录使用。对于常用的Linux系统，也可以直接通过软件包管理器安装使用。</p><p>WebThings Framework是一个软件组件集合，你可以基于这些组件来开发支持<a href=\"https://iot.mozilla.org/wot/\">Web Thing API</a>的硬件设备。它有不同的编程语言实现，包括Node.js、Python（包括MicroPython）、Java、Rust、C++（Arduino实现）。</p><p>WebThingsIO的代码采用的是<a href=\"https://github.com/WebThingsIO/gateway/blob/master/LICENSE\">Mozilla Public License 2.0</a>开源协议。</p><p>这里，我把这5个开源的智能家居平台的特性总结为一个表格，方便你随时参考。</p><p><img src=\"https://static001.geekbang.org/resource/image/3f/6a/3f957676a982afacb7619925ed19986a.jpg\" alt=\"\"></p><h2>Gladys Assistant具体使用：动手实践</h2><p>这5个比较有代表性的智能家居开源平台，对于树莓派的支持都不错的。现在，我们就开始动手，在树莓派上安装一个开源平台，体验一下通过智能家居系统监测设备数值的过程。</p><p>使用哪个平台呢？我们就选择Gladys Assistant吧。它的优势是Web页面在手机上体验不错，不需要你去搜索或者编译手机上的App了。</p><p>其他几个开源平台的安装和使用方法都差不多。你掌握了一个，那么利用镜像文件安装其他几个也不成问题。</p><h3>第一步：准备器材</h3><p>首先我介绍一下需要准备的器材有哪些：</p><ol>\n<li><strong>树莓派Raspberry Pi 4B</strong>，要求内存2GB以上，但是8GB内存版本要谨慎选择，因为有些开源平台软件对Arm 64bit芯片支持不够好。</li>\n<li><strong>供电电源</strong>，要求支持3A以上电流。</li>\n<li><strong>Micro SD卡</strong>，也叫TF卡，存储容量最好在16GB以上。在选择的时候，你要关注读写速度等级，比如U3表示最低写入速度是30MB/s。同时你也要关注<a href=\"https://www.sdcard.org/chs/developers/overview/application/index.html\">应用性能等级</a>，它定义了Micro SD卡进行随机读写的性能，最好是选择Application Performance Class 2（卡面上标识A2图标）。在卡上存储应用程序和应用程序数据时，这个性能指标非常重要。</li>\n</ol><p><img src=\"https://static001.geekbang.org/resource/image/f4/66/f4928d8a87bde8b4e235b8cdf057d266.jpg\" alt=\"\"></p><ol start=\"4\">\n<li><strong>Micro SD卡读卡器</strong>。有些电脑自带这个接口，如果没有的话，你可以买一个便宜的使用。</li>\n<li><strong>普通网线</strong>。如果你希望以有线的方式使用树莓派，可以准备一根。同时，我也会介绍树莓派接入Wi-Fi的方式。</li>\n</ol><h3>第二步：烧录系统镜像</h3><p>树莓派板子在启动的时候，会从SD卡读取操作系统镜像文件，完成操作系统的引导启动工作。所以我们接下来要在SD卡上烧录系统镜像。</p><p>具体怎么烧录呢？我们可以使用一个免费的烧录工具，<strong>Etcher</strong>。它支持MacOS、Windows和Linux三种主流的电脑系统，你可以从<a href=\"https://etcher.io/\">官方网站</a>上下载和安装。也可以点击<a href=\"https://github.com/balena-io/etcher/releases\">这个链接</a>下载最新版。</p><p>然后，下载树莓派的系统镜像文件。树莓派有官方的操作系统镜像 Raspbian可以选择，但是为了避免手动在 Raspbian系统中安装 Gladys Assistant 软件的麻烦，我们直接选择官方提供的已经配置好Gladys Assistant的Raspbian镜像文件。</p><p>从<a href=\"https://cdn.elephantcdn.com/gh/gladysassistant/gladys/releases/download/v4.0.0/gladys-4.0.0-rev3.img.zip\">这个链接</a>中下载好镜像文件，并且解压缩得到\"img\"扩展名的文件。然后把Micro SD卡插入读卡器，或者直接插入你的电脑接口中。运行Etcher软件，按照步骤把镜像文件烧录到存储卡中。</p><p><img src=\"https://static001.geekbang.org/resource/image/1b/73/1bcbb300760c8febe63898a0174c3273.png\" alt=\"\"></p><p>树莓派支持网线接口，不过，如果你希望树莓派接入家里的Wi-Fi热点，而不是使用网线访问网络，那么就需要在Micro SD卡中增加一个配置文件。</p><p>这个配置文件的文件名必须是wpa_supplicant.conf。你可以在电脑上使用自己熟悉的文本编辑器创建这个文件，并且在文件中输入下面的内容：</p><pre><code>ctrl_interface=DIR=/var/run/wpa_supplicant GROUP=netdev\nupdate_config=1\ncountry=CN\n\n\nnetwork={\n ssid=&quot;你的Wi-Fi热点SSID名称&quot;\n psk=&quot;你的Wi-Fi热点密码&quot;\n key_mgmt=WPA-PSK\n}\n</code></pre><p>注意，将Wi-Fi热点的SSID和密码替换为你家里的Wi-Fi路由器的真实情况。</p><p>然后将这个文件拷贝到Micro SD卡的根目录。这时，你就可以把Micro SD卡插入树莓派开发板了。</p><h3>第三步：启动系统</h3><p>烧录好镜像文件，准备好Micro SD卡后，你可以把Micro SD卡从读卡器取出，插入树莓派的对应接口中。</p><p>接着，接上电源线（如果你使用网线方式，记得也将网线接入树莓派板的网口上）。这时树莓派将自动启动运行，需要等待一段时间。</p><p>过一会儿之后，在你的电脑上，打开浏览器，输入 \"<a href=\"http://gladys.local\">http://gladys.local</a>\" 来访问树莓派上的Gladys Assistant系统，如下图所示。</p><p>如果你使用的电脑系统是比较老的Windows版本，可能无法通过这种方式访问树莓派，而是需要将“gladys.local”替换为树莓派的IP地址。</p><p>怎么获取到树莓派的IP地址呢？你可以使用一些网络分析软件，比如Android手机上安装Network Scanner，iOS手机上安装iNet来扫描网络。</p><p><img src=\"https://static001.geekbang.org/resource/image/60/cf/600490ac2f908cb13ce81b379a8fdacf.png\" alt=\"\"></p><p>那么，为什么不给树莓派接一个显示器，而要通过你的电脑上的浏览器来访问呢？这是因为Gladys Assistant 为了简化镜像，没有提供可视化的桌面环境。其实你只要熟悉了操作方法，就会发现这样的设计是非常方便的，因为你不需要为树莓派再准备个显示器了。</p><h3>第四步：在Gladys Assistant上添加设备</h3><p>因为我们是第一次配置Gladys Assistant，所以要在上面的页面中选择“Create local account with your Email”，来创建一个本地账号。</p><p>创建完账号后，其他的步骤不是必填项，你根据喜好填写就行了。房屋配置部分，你可以创建一个名称为bedroom的房间，后面会用到。最后，你应该可以看到这个Dashboard页面。</p><p><img src=\"https://static001.geekbang.org/resource/image/14/3a/14de681771577c2b8d56fc3590f12d3a.png\" alt=\"\"></p><p>接下来，我们来添加一个设备，来体验一下Gladys Assistant的功能。</p><p>那么，添加什么设备呢？我们还没有讲到实战篇的具体项目呢。不过，我们可以用电脑来模拟一个设备。你还记得第8讲介绍的MQTT协议吗？Gladys Assistant系统支持MQTT通信协议的设备。所以，我们可以通过电脑终端的命令行来模拟一个设备，发送MQTT消息给Gladys Assistant，让Gladys Assistant来展示这个设备。</p><p>首先，我们在Gladys Assistant上准备MQTT Broker。选择Dashboard 上部的标签页“Integrations”，点击MQTT标签。</p><p><img src=\"https://static001.geekbang.org/resource/image/a2/ab/a2f23d7ce6f2e95d557dce9c93481dab.png\" alt=\"\"></p><p>进入MQTT设置界面后，你现在需要点击左边的Setup，开始安装MQTT Broker。我们通过默认选项，即使用Docker的方式来完成。</p><p><img src=\"https://static001.geekbang.org/resource/image/ce/1a/ce2016b8d4ee5ed95e91856a04f44d1a.png\" alt=\"\"></p><p>这个过程需要几分钟时间。完成后，你就可以看到MQTT Broker的用户名和密码。我将密码改成了geektimetest，为了便于记忆，你也可以选择一个自己的密码。同时，你需要将用户名和密码记录下来，因为后面模拟设备发送MQTT消息时会用到。</p><p><img src=\"https://static001.geekbang.org/resource/image/52/89/52d0ccc87753ea79c670d8d5b798dd89.png\" alt=\"\"></p><p>接着，我们点击左边的Device，切换到MQTT设备页面。点击右上角的New打开创建页面。设备名称我们可以选择Temperature Sensor，External ID填写mqtt:bedroom:temperature-sensor。字符串中bedroom是和下一项房间填写的信息一致的。</p><p><img src=\"https://static001.geekbang.org/resource/image/55/d6/554e038f3a7a7f8e2bbd3c14632269d6.png\" alt=\"\"></p><p>然后，我们为设备添加特性（Features）。这里，我们选择Temperature 类型。</p><p><img src=\"https://static001.geekbang.org/resource/image/e8/db/e8f806569bf36852abe3712c6fed5fdb.png\" alt=\"\"></p><p>选择完类型后，我们点击Add feature，开始设置具体的特性参数。你可以按照下图的内容来设置自己的参数。其中，external ID填写mqtt:bedroom:temperature-sensor:temperature字符串。最下面的MQTT Topic，你需要记录下来，后面发送消息时需要用到。</p><p><img src=\"https://static001.geekbang.org/resource/image/a0/ae/a03735551ee3e3124131169c1b4d60ae.png\" alt=\"\"></p><p>点击下部的保存（Save）和返回（Back），然后我们可以看到创建完成的MQTT设备。</p><p><img src=\"https://static001.geekbang.org/resource/image/cc/e2/cc37b26e8d548465a4c3aa1dba87a1e2.png\" alt=\"\"></p><p>在模拟发送MQTT消息之前，我们还需要编辑一下Dashboard界面。你需要点击左上角切换回Home标签页，然后点击右上角的Edit按键。在编辑界面的Column 1 选择Devices in room类别。然后依次选择bedroom和我们刚创建的设备Temperature Sensor传感器。</p><p><img src=\"https://static001.geekbang.org/resource/image/2e/9e/2e2bd7fyyaa7ba7b7eb79026db90f89e.png\" alt=\"\"></p><p>点击页面右下角的Save，保存Dashboard的编辑界面。</p><p><img src=\"https://static001.geekbang.org/resource/image/16/07/16ca1f18eb80eb0fd2efd37d04a49c07.png\" alt=\"\"></p><p>当然，现在传感器没有数值显示。</p><h3>第五步：模拟MQTT设备</h3><p>接下来，我们打开一个终端命令窗口，输入下面的命令：</p><pre><code>hbmqtt_pub -d --url mqtt://gladys:geektimetest@gladys.local:1883 -t gladys/master/device/mqtt:bedroom:temperature-sensor/feature/mqtt:bedroom:temperature-sensor:temperature/state -m 25.2\n</code></pre><p>其中，gladys:geektimetest是用户名和密码，它们以分号相连。gladys.local是树莓派的域名。-t后面的消息主题就是你刚才记录的MQTT Topic字符串。-m后面是温度数值。</p><p>执行这个命令后，你再打开Gladys Assistant的Dashboard界面，这时你就可以看到设备卡片显示出来了刚才发送的温度数值。</p><p><img src=\"https://static001.geekbang.org/resource/image/c9/4d/c931174c7c4dd9cafde673ee795bf24d.png\" alt=\"\"></p><h2>小结</h2><p>总结一下，在这一讲中，我介绍了智能家居开源平台的生态，并且带你动手在树莓派上安装了Gladys Assistant，然后体验了一下使用过程。</p><ol>\n<li>智能家居平台为各种智能家居产品提供了一个统一的接入系统，让用户可以管理和控制产品，同时也为各种智能家居产品之间的联动提供了条件。</li>\n<li>了解开源的智能家居平台有两大好处，一是你可以基于它们快速地搭建智能家居系统，另一个是你可以在工作中借鉴它们的设计思想和架构。</li>\n<li>开源的智能家居平台有很多，热度比较高的平台有5个，分别是Home Assistant、Domoticz、openHAB、Gladys Assistant 和WebThingsIO。</li>\n<li>利用开源平台，在树莓派开发板上搭建智能家居系统的一般步骤包括：准备器材，烧录系统镜像，启动系统，添加设备，接收和显示设备信息等。</li>\n</ol><p>在实战篇，等你掌握了开发智能硬件的基本方法，可以将这一讲中的模拟设备替换为真实的温度传感器设备。期待你的动手实践。</p><p>而且之后，等你熟悉树莓派开发板的使用方法，你也可以在树莓派上尝试一下其它几个开源平台。它们的基本功能都比较接近，你可以根据自己喜好，或者熟悉的编程语言选择。</p><h2>思考题</h2><p>最后，我给你留一个思考题吧。</p><p>在这一讲的动手实验环节，我们是通过访问<a href=\"http://gladys.local\">http://gladys.local</a> 来查看Gladys Assistant的Dashboard等Web应用界面的。为什么我们可以通过gladys.local 域名来访问树莓派开发板呢？为什么有的老版本电脑系统不支持呢？这是使用了什么网络协议？</p><p>欢迎你在留言区写一写自己的答案，也欢迎你将这一讲分享给对智能家居 DIY感兴趣的朋友，大家一起交流学习。</p>",
                "article_title": "15 | 平台：智能家居开源平台的生态是怎样的？"
            }
        ]
    },
    {
        "chapterTitle": "实战篇",
        "children": [
            {
                "title": "16 | 实战准备：如何搭建硬件开发环境？",
                "id": 321652,
                "content": "<p>你好，我是郭朝斌。</p><p>从今天开始，我们就进入了课程的实战篇，我会手把手带你从0开始完成自己的智能家居项目。</p><p>这个项目具体包括哪些产品呢？在<a href=\"https://time.geekbang.org/column/article/309786\">第5讲</a>中，我们根据智能家居产品的设计原则，已经设计好了 4 个产品场景，分别是：</p><ol>\n<li>可以手机控制的智能电灯</li>\n<li>可以基于光线自动调节的智能电灯</li>\n<li>可以语音控制的智能音箱</li>\n<li>可以基于环境温湿度和土壤湿度自动浇水的浇花器</li>\n</ol><p>它们分别对应了实战篇的第17～21讲的内容（如有需要，你可以根据<a href=\"https://shimo.im/sheets/D3VVPdwcYRhhQRXh/MODOC\">这份文档</a>自行采购相关硬件）。</p><p>不过，在打造这些产品场景之前，我们还需要先搭建好<strong>硬件开发环境</strong>。在这一讲，我就以智能电灯为例，带你完成这个准备工作。</p><h2>通信技术：Wi-Fi</h2><p>为了能让手机控制电灯，我们首先要让电灯接入网络。在<a href=\"https://time.geekbang.org/column/article/306976\">第2讲</a>中，我们介绍了很多种通信技术，智能家居场景下常用的有 Wi-Fi、BLE 和 ZigBee 等。那么智能电灯应该选择哪种技术呢？</p><p>从<strong>通信速率</strong>来看，智能电灯传输的数据，包括控制命令和几种状态的数值，数据量都非常小，这几种通信技术都可以满足要求。</p><p>从<strong>功耗</strong>来看，智能电灯是直接连接电线的，不需要电池供电，所以低功耗的 BLE 和 ZigBee 技术不是必须的选择，功耗相对较高的 Wi-Fi 也可以考虑。</p><p>从<strong>普及度</strong>和<strong>易用性</strong>的角度分析，如果使用BLE，设备与手机的交互确实会非常方便。但是BLE和ZigBee 的设备都有一个缺点，就是需要<strong>搭配专有的网关</strong>才能连接互联网，这在部署和使用的时候都比较麻烦。所以，我们选择 <strong>Wi-Fi</strong> 作为智能电灯的通信方式。</p><!-- [[[read_end]]] --><h2>开发板：NodeMCU</h2><p>确定使用 Wi-Fi 之后，我们又该怎么选开发板呢？（你可能也关心选择哪一款芯片。不过，为了方便讲解和动手实践，这里我们还是围绕开发板来展开。关于芯片的选型，我们可以另外找机会交流。）</p><p>我推荐选择开源硬件的开发板，有两个原因。第一，硬件、软件的各种技术实现是公开的，方便分析问题，也方便后期转化为量产的产品；第二，有社区氛围，使用的人比较多，大家可以针对具体的问题进行交流。</p><p>比如说 <a href=\"https://nodemcu.readthedocs.io/en/release/\">NodeMCU</a>  就是一个不错的选择。基于 ESP8266 芯片的版本，Flash 空间有4MB，自带 Wi-Fi 功能，而且价格便宜，在国内外都非常流行。（这里顺带说一句，ESP8266 是国内企业的芯片产品，国内企业在 Wi-Fi 和 BLE 芯片上的优势真的是越来越明显。）</p><p><img src=\"https://static001.geekbang.org/resource/image/14/c5/14d143cfbaa113yy185726a4a23002c5.jpg\" alt=\"\"></p><h2>开发语言：Python</h2><p>那么，开发语言用哪一种比较好呢？我计划使用<strong>Python</strong>。</p><p>你可能会觉得奇怪：嗯？为什么不用<strong>C语言</strong>？</p><p>主要原因是，我不希望开发语言成为实战项目的障碍。先不说C语言本身的难度，光是它需要交叉编译的特性和不够便捷的调试方式，就已经很影响效率了。</p><p>相比之下，使用比较简单的 Python 语言，开发和调试都会非常方便。当然，选择 Python 还有别的好处，你在后面的实战过程中可以逐渐感受到。</p><p>如果你是嵌入式开发的高手，对C语言了然于胸，可以信手拈来，那你也可以基于我介绍的步骤，用C语言，甚至其他的语言来实践项目的编程（期待你的分享）。语言是一个工具，我们完全可以拿来灵活应用，实现我们的工作任务，而不应该成为一种羁绊。</p><p>当然，我也建议你不要排斥这次使用 Python 的机会。一方面，这次尝试可以拓展你的技术视野；另一方面，掌握 Python 对你写后台、做数据分析和写脚本也非常有帮助，可以在很多方面提高你的效率。</p><p>不过，你可能还是不放心：嵌入式硬件的计算资源都非常有限，在开发板上面运行 Python 代码可行吗？</p><p>这确实是一个挑战，好在 <a href=\"https://docs.micropython.org/\">MicroPython</a> 项目已经提供了解决方案。</p><p><strong>MicroPython</strong> 是专门为<strong>嵌入式系统</strong>打造的 Python 实现。它完整实现了 Python3.4 的语言特性，部分支持 Python3.5 的特性。在标准库方面，MicroPython 实现了 Python 语言的一个子集，另外还增加了与底层硬件交互的库模块。</p><h2>搭建 MicroPython 开发环境</h2><p>接下来，我们就来把 MicroPython 部署到 NodeMCU 开发板上，准备好开发环境。</p><h3>第一步：准备固件文件</h3><p>首先，我们需要为 NodeMCU 准备好 MicroPython  <strong>固件文件</strong>。MicroPython 官方已经为 ESP8266 芯片准备了<a href=\"https://micropython.org/download/esp8266/\">现成的固件</a>，省去了交叉编译的工作。否则，我们还需要在电脑上使用专门的编译软件，为 ESP8266 芯片编译 MicroPython 源代码。</p><p>MicroPython 的固件分为 2M、1M 和 512K 三个不同的版本，针对不同大小的 Flash 存储空间。我们下载最新的 <strong>2M 稳定版本</strong>（带 stable 的）就行，因为 NodeMCU 开发板的 Flash 空间是足够的。</p><h3>第二步：安装<strong>烧录工具</strong></h3><p>然后，我们使用一根 USB 数据线，将 NodeMCU 开发板和电脑连接起来。</p><p>接着，我们在电脑终端运行下面的命令，安装用来烧录的工具 <strong>esptool</strong> ：</p><pre><code>pip install esptool\n</code></pre><p>esptool 安装完成后，你可以运行 esptool.py read_mac 命令，确认 NodeMCU 板子是否连接成功。连接成功后的屏幕显示是这样的：</p><p><img src=\"https://static001.geekbang.org/resource/image/52/1b/525ec8069d036df1dae19d4ba184a21b.png\" alt=\"\"></p><p>如果连接不成功，或者没有正确识别设备，屏幕上则会出现下面的结果：</p><p><img src=\"https://static001.geekbang.org/resource/image/41/82/410cb9a3d4d9c149abe1ff0dba606182.png\" alt=\"\"></p><p>这时候怎么办呢？</p><p>首先，检查一下你使用的 USB 线能否传输数据。不是说笑，我就犯过这个低级错误。现在很多电子产品会随带 USB 充电线，但是为了节约成本，有些 USB 线内部实际上并没有集成两根数据信号线。你如果使用了这种线，就只能充电，而电脑是识别不出设备的。</p><p>另外，注意我们使用的数据线，一头是 USB-A 接口，另一头是 Micro-USB 接口。USB 的接口规格繁多，我在这里放了<a href=\"https://getprostorage.com/blog/usb-c-thunderbolt-3-rundown/\">一张图</a>，方便你区分。</p><p><img src=\"https://static001.geekbang.org/resource/image/d0/58/d0f2e713f2ae451bcdbc0fd794005358.png\" alt=\"\" title=\"不同的USB接口（图片来源：ProStorage）\"></p><p>如果USB线没有问题，那可能是电脑没有正确识别开发板，我们需要检查一下驱动文件有没有安装好。</p><p>如果你跟我一样，用的是 macOS 系统，可以在电脑的终端上输入 <code>ls /dev/cu*</code> 命令，查看是否有类似 /dev/cu.wchusbserialxxxxx 名字的设备文件。</p><p>如果你使用 Windows 系统，那么需要查看一下“设备管理器”，看看“端口（COM 和 LPT）”下面，有没有 COM* 结尾的设备。</p><p>如果没有，你可以参考<a href=\"https://learn.sparkfun.com/tutorials/how-to-install-ch340-drivers/all#mac-osx\">这篇文章</a>，下载相应的驱动文件安装。（注意，我的 NodeMCU 开发板使用的是 CH340 这款 USB 转串口芯片。如果是 CP2102 芯片，可以参考<a href=\"https://learn.sparkfun.com/tutorials/cp2102-usb-to-serial-converter-hook-up-guide\">这篇文章</a>。）</p><p>当你在终端看到类似下面的结果，或者在 Windows 的设备管理器中看到 COM* 设备时，就说明开发板已经成功识别。</p><p><img src=\"https://static001.geekbang.org/resource/image/09/40/09a332dcdd12cc43ed7ce69babeeec40.png\" alt=\"\"></p><p>如果仍然无法正确识别，你可以到一些论坛去交流，比如<a href=\"http://bbs.ai-thinker.com/forum.php\">安信可的官方论坛</a>。</p><h3>第三步：烧录固件</h3><p>接下来我们烧录固件。在这之前，我们需要先输入下面命令，擦除 Flash 芯片：</p><pre><code># 注意设备名称替换为你电脑上的名称\nesptool.py --port /dev/cu.wchusbserial14230 erase_flash\n</code></pre><p><img src=\"https://static001.geekbang.org/resource/image/d2/7a/d20d91566a5e3ebbd05bbae25472447a.png\" alt=\"\"></p><p>擦除成功后，我们进入存储前面下载固件的目录中，运行下面的命令，将固件文件烧录到开发板的 Flash 中：</p><pre><code># 注意设备名称替换为你电脑上的名称，固件文件名称做类似修改\nesptool.py --port /dev/cu.wchusbserial14230 --baud 460800 write_flash --flash_size=detect 0 esp8266-20200911-v1.13.bin\n</code></pre><p><img src=\"https://static001.geekbang.org/resource/image/78/de/78ab58569f82386852b942aabfe992de.png\" alt=\"\"></p><p>烧录成功后，MicroPython 已经在你的开发板上运行起来了。</p><h3>第四步：确认运行状态</h3><p>但是开发板跟电脑不一样，是没有显示屏的，我们要怎么确认它的运行状态呢？</p><p>有一种非常简便的方法，你可以用电脑或者手机搜索一下周围的 Wi-Fi 热点，如果看到类似 “MicroPython-xxxxxx” 名称的热点（xxxxxx是开发板 MAC 地址后半部分），说明你的 NodeMCU 工作正常。比如我的开发板MAC地址是“40:f5:20:07:3b:52”，现在我看到了“MicroPython-073b52”这个热点，就说明开发板在正常运行。</p><p>当然，对于 Python 来说，更方便的交互方式还是REPL （交互式解释器），这个 MicroPython 也提供了。我们可以通过 REPL 来检验开发板的运行。</p><p>我们还是使用烧录时用到的 USB 线连接开发板和电脑。在 MacOS 电脑上，重新连接开发板的时候，串口设备名称可能会改变，所以为保险起见，再次运行命令：</p><pre><code>ls /dev/cu*\n</code></pre><p>获得串口设备名称之后，我们可以使用终端模拟器软件，比如 <a href=\"https://www.vandyke.com/cgi-bin/releases.php?product=securecrt\">SecureCRT</a>，通过串口协议连接上开发板，进行交互。</p><p>需要注意的是，波特率（Baud rate）设置为 115200，这与前面烧录时选择的值不同。</p><p><img src=\"https://static001.geekbang.org/resource/image/cc/c7/cc80630cc1fe808e75ee01e6a85b19c7.png\" alt=\"\"></p><p>如果你使用 Windows 操作系统，那么 <a href=\"https://www.chiark.greenend.org.uk/~sgtatham/putty/latest.html\">PuTTY</a> 更加流行。当然，建立连接的参数设置都是类似的。</p><p>成功连接后，SecureCRT 的窗口会输出类似下面的结果：</p><p><img src=\"https://static001.geekbang.org/resource/image/33/bc/3304c75a8fb57068073c4d6aac4fc6bc.png\" alt=\"\"></p><p>看到熟悉的符号 “&gt;&gt;&gt;”，我们就知道，可以真正进行交互了。</p><h3>第五步：体验交互</h3><p>先用“Hello World”来个经典的打招呼吧。</p><p>接着，我们体验一下 MicroPython 控制 LED 灯。因为开发板 NodeMCU 12F的 GPIO2 管脚接有一个 LED 灯，你可以输入下面的代码，控制它的点亮和熄灭。</p><pre><code>&gt;&gt;&gt; print(&quot;Hello World from MicroPython!&quot;)\nHello World from MicroPython!\n&gt;&gt;&gt; import machine\n&gt;&gt;&gt; pin = machine.Pin(2, machine.Pin.OUT)\n&gt;&gt;&gt; pin.off()\n&gt;&gt;&gt; pin.on()\n</code></pre><p>需要注意的是，不同的板子上，这个管脚的高低电平的设计可能不同，所以 <code>pin.on()</code> 可能是熄灭 LED 灯；<code>pin.off()</code> 反而是点亮 LED 灯。</p><h2>部署代码到开发板</h2><p>那么，能不能运行一个 Python 代码文件呢？比如，基于在 REPL 中尝试的点亮 LED 操作。</p><p>我们写一个代码段：</p><pre><code>import machine\nimport time\n\n# 指明 GPIO2 管脚\npin = machine.Pin(2, machine.Pin.OUT)\n\n# 循环执行\nwhile True:\n    time.sleep(2)   # 等待 2 秒\n    pin.on()        # 控制 LED 状态\n    time.sleep(2)   # 等待 2 秒\n    pin.off()       # 切换 LED 状\n</code></pre><p>这段代码实现的功能是，控制 LED 灯以 2 秒的间隔，不断点亮、熄灭。</p><p>为了在电路板上运行这个 Python 代码，我们需要做两件事情：</p><ol>\n<li>将代码段保存到一个文件中，这个文件的名字必须是 main.py。</li>\n<li>将代码文件 main.py 放到开发板的文件系统中，而且是根目录。</li>\n</ol><p>这样，当开发板启动或者重启的时候，就会自动执行 main.py 文件中的代码。</p><p>第一点我们可以很容易做到。但是，怎么把代码文件上传到开发板上呢？</p><p>MicroPython 的官方提供了一个工具<a href=\"https://docs.micropython.org/en/latest/reference/pyboard.py.html\">pyboard.py</a>，它也是基于串口连接与开发板通信的。你可以使用它操作开发板上的文件系统，比如常用的拷贝文件、创建文件夹、删除等功能，甚至可以将电脑上的代码文件加载到内存中，直接运行。这非常便于你在开发过程中，进行代码的调试。</p><p>下载 pyboard.py 的源文件到电脑后，你可以运行下面的命令，将 main.py 文件部署到你的开发板：</p><pre><code># 设置环境变量，指明串口设备\nexport PYBOARD_DEVICE=/dev/cu.wchusbserial14220\n\n\n#拷贝当前目录下的 main.py 到开发板\n./pyboard.py cp main.py :\n</code></pre><p>不过，pyboard.py 在 MacOS 系统上运行有问题。比如，在电脑终端，尝试运行下面的命令，就会收到 “could not enter raw repl” 这个错误信息。</p><pre><code>./pyboard.py -f ls /\n</code></pre><p>这可能是 MacOS 上的串口芯片 CH340 的驱动的问题，它会在建立串口连接时，重置 NodeMCU ，导致 enter_raw_repl 函数无法正常执行。如果你只能在 MacOS上开发，怎么办呢？</p><p>我试用过几种类似的工具，这里推荐你使用 <a href=\"https://learn.adafruit.com/micropython-basics-load-files-and-run-code/install-ampy\">AdaFruit MicroPython tool —— ampy</a>。安装过程可以打开链接了解，我就不展开了。一般情况下，你可以用下面的命令完成安装：</p><pre><code>pip install adafruit-ampy\n# ---或者---\npip3 install adafruit-ampy\n</code></pre><p>ampy 是通过增加延时的方法，来规避 MacOS 系统上的问题的。所以在使用的时候，我们需要先设置一个环境变量 —— AMPY_DELAY。延时的推荐值是 0.5，不过，具体实践时，你需要根据自己的开发板的试验情况，灵活调整这个数值。</p><pre><code>export AMPY_DELAY=0.5\n</code></pre><p>我们可以在终端中输入上面的指令，也可以将它加入到 .bashrc 或 .zshrc 等配置文件中，避免每次都要重复输入。</p><p>使用 ampy 的过程中，常用的环境变量还有下面两个，可以根据具体情况设置：</p><pre><code>#设备名称请根据你的情况修改\nexport AMPY_PORT=/dev/cu.wchusbserial14220\n\n#串口通信的波特率   \nexport AMPY_BAUD=115200\n</code></pre><p>然后，输入下面的命令，就把代码部署到开发板上了。</p><pre><code>ampy put main.py\n</code></pre><h2>小结</h2><p>在这一讲中，我带你搭建了智能电灯的硬件开发环境。</p><ol>\n<li>在通信技术方面，我从通信速率、功耗、普及度和易用性等角度考虑，最终选择了Wi-Fi。在实际工作中，你也可以通过同样的思路来选择其他产品的通信技术。</li>\n<li>在开发板上面，推荐选择开源硬件的开发板，因为使用和交流都更方便。实战项目选择的是NodeMCU ESP8266，它在Flash空间、通信技术和价格方面有一定优势。</li>\n<li>为了降低动手实践的难度，我们选择了Python开发语言。而MicroPython为我们提供了在NodeMCU上使用Python语言的条件。</li>\n<li>在搭建MicroPython开发环境的过程中，我们需要使用esptool工具。通过USB线连接NodeMCU，你可以将固件烧录到开发板的Flash中。</li>\n</ol><p>这个选择思路和搭建过程不仅适用于智能电灯，也适用于自动浇花器，它们的开发环境是一样的。至于智能音箱，使用的开发板是树莓派，我在第15讲已经介绍过使用方法了，所以你也不需要担心。</p><h2>思考题</h2><p>这一讲是实战篇的第一讲，所以最后我想给你留一个需要动手的问题。</p><p>MicroPython 是专门为嵌入式开发设计、实现的 Python 语言开发环境。在这一讲中，我们通过 GPIO 的<strong>输出</strong>，实现了 LED 灯的控制。你能否实现一个 GPIO 的<strong>输入</strong>功能，并且通过这个输入信号，控制 LED 灯的点亮和熄灭？</p><p>希望你能留言区和我交流，也欢迎你将本讲分享给你的朋友一起学习讨论。<br>\n<img src=\"https://static001.geekbang.org/resource/image/30/4c/30e17yy335dbf8f251cc181b0cd9414c.jpg\" alt=\"\"></p>",
                "article_title": "16 | 实战准备：如何搭建硬件开发环境？"
            },
            {
                "title": "17 | 远程控制：怎样打造联网的智能电灯？",
                "id": 322528,
                "content": "<p>你好，我是郭朝斌。</p><p>在上一讲，我们把智能电灯开发的实验环境搭好了。今天，我们就一起去完成智能电灯的开发工作，并且连接到腾讯云的<a href=\"https://console.cloud.tencent.com/iotexplorer\">物联网平台</a>吧（如有需要，你可以根据<a href=\"https://shimo.im/sheets/D3VVPdwcYRhhQRXh/MODOC\">这份文档</a>自行采购相关硬件）。</p><p>那为什么一定要连接到一个物联网平台呢？这是因为物联网平台提供了基本的设备管理功能，可以帮助我们更快速地实现设备的远程控制功能。比如说，我们可以通过“腾讯连连”小程序，来控制电灯的状态，而不用自己花费时间和精力去写相应的代码等工作。</p><h2>物联网平台上需要做什么准备？</h2><p>那为什么要选择腾讯云的物联网平台呢？</p><p>主要是两个原因。一方面是，它的平台是开放注册的，我们普通的用户也可以注册来使用，不像很多平台那样需要企业用户才能注册。另一方面是，腾讯云提供的交互方式非常方便，不需要编译，或者下载其他App，在微信上用小程序就可以进行。</p><h3>注册与登录</h3><p>确定了要接入腾讯云的物联网平台以后，我们就需要先在这个平台上做一些准备工作了。准备工作的第一步，当然就是你得先注册个账号并且登录。注册和登录的流程非常简单，你打开<a href=\"https://console.cloud.tencent.com/iotexplorer\">这个链接</a>，一眼就能看明白。</p><p><img src=\"https://static001.geekbang.org/resource/image/a8/4f/a8a8c11d4be7c1e1c6fd69b2febed24f.png\" alt=\"\"></p><h3>创建项目和产品</h3><p>登录之后，我们直接进入准备工作的第二步，创建项目和产品。我们先在物联网开发平台创建一个新项目“智能家居”。</p><!-- [[[read_end]]] --><p><img src=\"https://static001.geekbang.org/resource/image/bc/81/bc6d5d04e08bae0939c3a783775fd281.png\" alt=\"\"></p><p>然后，进入这个“智能家居”项目，创建一个新产品“智能电灯”。到这里，我们需要简单设置几个参数：</p><ul>\n<li>产品品类，直接选择“智能生活”--&gt;“电工照明”--&gt;“灯”。</li>\n<li>认证方式选择密钥认证，这个比较简单，而且适合我们的开发板NodeMCU。</li>\n<li>通信方式，选择Wi-Fi。</li>\n<li>数据协议选择“数据模板”，也就是基于物模型来解析数据。</li>\n</ul><p><img src=\"https://static001.geekbang.org/resource/image/cd/f0/cdac3c2b897e53917e9afd6aa28ca7f0.png\" alt=\"\"></p><p>设置完成后，我们就可以点击进入智能电灯这个产品了，然后开始定义物模型。</p><h3>物模型在哪里使用？</h3><p>点击进入产品，我们可以看到“数据模板”界面中列出了“电灯开关”“亮度”“颜色”和“色温”等属性和事件。这些都是平台根据上一步选择的产品品类，自动生成的。</p><p>当然了，我们也可以通过“导入 JSON”的方式，把我们在<a href=\"https://time.geekbang.org/column/article/310441\">第6讲</a>编写的 JSON 文本导入，完成产品功能的定义。</p><p><img src=\"https://static001.geekbang.org/resource/image/15/22/153908e6522de593d07d46346e879722.png\" alt=\"\"></p><p>定义好物模型之后，我们就完成了“设备开发”的工作，需要继续完成“交互开发”配置了。</p><h3>交互界面如何定义？</h3><p>在“交互开发”界面中，我们需要关注两个配置项：“使用官方小程序控制产品”的选项要保持打开，因为我们后面要通过小程序来控制智能电灯；在“扫一扫产品介绍”配置项中，设置产品图片和备注信息。</p><p><img src=\"https://static001.geekbang.org/resource/image/62/27/62a990cf4a6ea288f9770445134a1f27.png\" alt=\"\"></p><p>其他项目，比如“配置引导”“面板配置”和“快捷入口配置”，我们保持默认配置就行，当然你也可以根据自己的喜好进行调整。</p><p>这些都配置好之后，我们就可以开始准备“调试设备”的配置了。</p><h3>为调试设备做准备</h3><p>在“设备调试”界面中，我们创建一个测试设备。点击“新建设备”，输入设备名称“Led_1”。</p><p><img src=\"https://static001.geekbang.org/resource/image/75/54/759caa00ed7f5ebd1c001b18f4808054.png\" alt=\"\"></p><p>创建成功后，在测试设备列表中，点击“Led_1”，进入设备的详情页面：</p><p><img src=\"https://static001.geekbang.org/resource/image/9d/e9/9db3727e33082f821c8f21c6b642c1e9.png\" alt=\"\"></p><p>在这个“设备信息”标签页，我们可以看到“设备名称”“设备秘钥”和“产品ID”的信息。我们需要把这些信息记录下来，因为在后面设备的开发中需要用到。</p><p>这里有一点我们要注意下。<strong>设备名称（DeviceName）、设备秘钥（SecretKey）和产品ID（ProductID）也经常被称为设备三元组</strong>。它完整地标识了一个设备。在调试阶段，设备名称可以手动命名，不过在正式应用中，为了保证设备名称的唯一性，平台会帮你自动生成设备名称。</p><p>另外，在“设备调试”标签页，你需要点击下图中“二维码”，获取这个设备的二维码，并保存好。因为在后面的步骤中，你需要使用“腾讯连连”小程序扫描这个二维码，将设备添加到小程序中。</p><p><img src=\"https://static001.geekbang.org/resource/image/97/a6/9721c6f1f394c14ca03e72dfe0c55ea6.png\" alt=\"\"></p><p>这是我在这个配置界面中定义的产品的二维码。</p><p><img src=\"https://static001.geekbang.org/resource/image/b5/ff/b515137b43f769c249df48b7f6f550ff.png\" alt=\"\"></p><p>这个二维码的信息内容，如下所示：</p><pre><code>{&quot;DeviceName&quot;:&quot;Led_1&quot;,&quot;ProductId&quot;:&quot;XNXP231VQA&quot;,&quot;Signature&quot;:&quot;2aa86e4e826b49b2a93949955f50761&quot;}\n</code></pre><p>可以看到，这个链接中主要包含了产品ID的信息。每个产品 ID 是唯一的，所以你的产品 ID 与这个不同。</p><p>到这里，我们就完成了腾讯云的物联网开发平台的准备工作。接下来，我们就要实打实地在开发板上，实现一个功能更加完善的智能电灯产品了。</p><h2>如何打造智能电灯设备？</h2><p>在上一讲，我们用代码实现了开发板上LED的控制。不过那个功能非常简单，为了让我们的智能电灯功能更完善，效果更酷炫，我们可以开发更多的功能，主要包括控制LED灯的颜色、开关，并能够实现远程控制。</p><p>我们先看看如何控制灯的颜色。</p><h3>如何控制 LED 灯的颜色？</h3><p>我们使用的 RGB LED 灯模块，是使用 <a href=\"https://en.wikipedia.org/wiki/Pulse-width_modulation\">PWM</a> （Pulse Width Modulation，脉冲宽度调制）来实现控制 LED 的颜色和亮度的。PWM的原理是，通过芯片的数字管脚（GPIO）来获得模拟电路信号的输出，它会控制芯片管脚在高电平和低电平之间进行快速切换。</p><p>那如何产生不同的 PWM 信号呢？这涉及到 2 个 PWM 信号的参数：<strong>频率和占空比</strong>。PWM 信号是一个方波信号，如下图的样子：</p><p><img src=\"https://static001.geekbang.org/resource/image/63/y4/633d089ea84047198dd53f560488fyy4.jpg\" alt=\"\"></p><p>频率，是指1秒内方波的周期个数，一个周期包含一个完整的高、低电平变化。比如一个周期是 20 ms（毫秒），那么通过计算：</p><p>1000毫秒/20毫秒 = 50Hz</p><p>我们可以知道方波的频率是50 Hz（赫兹）。</p><p>那PWM输出的方波信号的频率不同，会对我们有什么影响呢？</p><p>如果频率小于 100 Hz的话，我们的肉眼就会感受到灯的闪烁，甚至产生生理上的不适，比如视觉疲劳、偏头痛等。因此，对于 LED 灯，PWM 的频率必须大于 100Hz，最好在 200Hz以上。对于我们选择的NodeMCU 开发板来说，可以选择它支持的最大值，也就是1000Hz。</p><p>在PWM的信号图中，我们还可以看到一个叫做“脉宽时间”的标识，它代表的是一个周期里高电平的占用时间。而所谓的占空比，就是脉宽时间占整个周期时间的比例。比如，脉宽时间是10ms，那占空比的计算公式就是：</p><p>10/20 = 50%</p><p>占空比等于 50%。关于占空比参数，我需要提前说明一下：在 <a href=\"https://docs.micropython.org/en/latest/esp8266/tutorial/pwm.html\">MicroPython 代码</a>中，占空比 Duty 不是使用百分比数值来表示的，而是 0 到 1023 之间的数值。0 代表占空比为 0%，1023 代表占空比为 100%。</p><p>在代码中，当你设置了不同的占空比参数时，对应管脚输出的方波信号也会不同。下图展示了占空比分别为 0%、25%、50%、75% 和 100% 的方波信号，它们的平均电压（下图右侧）逐渐增大。我们正是通过平均电压的变化，达到了控制 LED 颜色和亮度等效果的目的。</p><p><img src=\"https://static001.geekbang.org/resource/image/66/31/66f9943cc758b8d42e165caa47ed7c31.jpg\" alt=\"\"></p><p>关于PWM信号，我们了解这些就够了。接下来，我们解决的问题，就是通过上一讲选定的开发板NodeMCU上的GPIO管脚来控制LED等的颜色了。NodeMCU的<a href=\"https://github.com/nodemcu/nodemcu-devkit-v1.0\">管脚图</a>如下所示：</p><p><img src=\"https://static001.geekbang.org/resource/image/d5/ae/d53af13yy9320eaa90b8ff6cf3c565ae.png\" alt=\"\" title=\"图片来自GitHub\"></p><p>一下子看到这么多管脚，你不要担心，因为只要关注带浅黄色背景的“GPIO”的几个管脚就够了。</p><p>我们先考虑一个问题，NodeMCU 开发板中的所有 GPIO 管脚都可以连接 RGB LED 模块吗？</p><p>答案是不可以。因为不是所有的 GPIO 管脚都可以输出 PWM 信号。NodeMCU 开发板是基于 ESP8266 芯片的，管脚GPIO0、GPIO2、GPIO4、GPIO5、GPIO12、GPIO13、GPIO14 和 GPIO15 具备 PWM 的输出能力，它们分别对应 NodeMCU 开发板的 D3、D4、D2、D1、D6、D7、D5 和 D8 接口。</p><p>因此，我们选择 D1、D2和D3这三个接口，分别连接 RGB LED 模组的红色、绿色和蓝色通道。</p><p>这里，我提供一下我创建的LED类文件，供你参考：</p><pre><code>from machine import PWM\nfrom machine import Pin\n\nclass Led():\n    &quot;&quot;&quot;\n    创建LED类\n    &quot;&quot;&quot;\n    def __init__(self, rpin, gpin, bpin, freq=1000):\n        &quot;&quot;&quot;\n        构造函数\n        :param pin: 接LED的管脚，必须支持PWM\n        :param freq: PWM的默认频率是1000\n        &quot;&quot;&quot;\n        self.pin_red = Pin(rpin)\n        self.pin_green = Pin(gpin)\n        self.pin_blue = Pin(bpin)\n\n        self.led_red = PWM(self.pin_red, freq = freq)\n        self.led_green = PWM(self.pin_green, freq = freq)\n        self.led_blue = PWM(self.pin_blue, freq = freq)\n\n    def rgb_light(self, red, green, blue, brightness):\n        if red in range(256) and \\\n            green in range(256) and \\\n            blue in range(256) and \\\n            0.0 &lt;= brightness and \\\n            brightness &lt;=1.0:\n            self.led_red.duty(int(red/255*brightness*1023))\n            self.led_green.duty(int(green/255*brightness*1023))\n            self.led_blue.duty(int(blue/255*brightness*1023))\n        else:\n            print(&quot;red green blue must between 0 and 255, and brightness from 0.0 to 1.0&quot;)\n        \n    def deinit(self):\n        &quot;&quot;&quot;\n        析构函数\n        &quot;&quot;&quot;\n        self.led_red.deinit()\n        self.led_green.deinit()\n        self.led_blue.deinit()\n</code></pre><h3>如何控制电灯的开关？</h3><p>智能电灯的“开”和“关”控制，我们使用继电器来实现。</p><p>继电器分为弱电（小电流、低电压）和强电（大电流、高电压）两个部分。其中，弱电的部分可以接微处理芯片；强电部分可以连接交流电设备，比如电风扇、冰箱和灯泡等。继电器其实就像是我们现实生活中“中间人”的角色，它通过电磁器件、或者光耦单元将弱电和强电联系起来，以完成微处理芯片对强电设备的控制。</p><p>在这次的实验中，我使用的一款基于 SRD-05VDC-SL-C 型号的电磁继电器。使用中，模块的控制接口，需要连接 NodeMCU 开发板的 GPIO 管脚。我们通过设置这个 GPIO 的输出电平高、低状态，实现控制继电器强电部分电路的“通”和“断”。</p><p>需要注意的是：在我们这一讲的实战中，继电器强电部分连接的 LED 灯，属于低电压设备，电压不超过 5V，这是对人体没有危害的电压；我们实战的目的是学习知识，在这个基础上，我们基于安全考虑，不建议把继电器的强电部分，连接220V交流电供电的电灯。</p><p>如果你有一定的交流电实践经验，那么在实践时也要注意两点：</p><ol>\n<li>注意自身和周围人的安全，比如强电部分不要有裸露的电线，一定用绝缘胶带包扎好；</li>\n<li>弱电部分的供电，不要使用电脑的 USB 接口；为了电脑设备安全，建议使用独立的电源为开发板供电。</li>\n</ol><p>我同样把我创建的Relay类文件放在这里，供你参考：</p><pre><code>from machine import ADC\nfrom machine import Pin\n\nclass Relay():\n\n    def __init__(self, pin):\n        self.relaypin = Pin(pin, Pin.OUT)\n        self.last_status = 1\n\n    def set_state(self, state):\n        self.relaypin.value(state)\n        self.last_status = state\n</code></pre><h3>智能电灯的整体电路如何搭建？</h3><p>确定了LED的技术方案和继电器后，我们就可以搭建出智能电灯的电路。我简单画了一下电路中各模块的连线情况，你在连接电路的时候按照这个连线来就行。</p><p><img src=\"https://static001.geekbang.org/resource/image/dd/61/dde075941211c591c44ea46cf4673861.png\" alt=\"\"></p><p>电路搭建完成后，你可以运行下面的代码测试一下：</p><pre><code>from machine import PWM, Pin\nimport time \n\n#设置对应红、绿、蓝的三个GPIO管脚\nled_red = PWM(Pin(5), freq = 1000)  \nled_green = PWM(Pin(4), freq = 1000)\nled_blue = PWM(Pin(0), freq = 1000)\n\n#继电器的GPIO管脚\nrelaypin = Pin(16, Pin.OUT)#\n\n#通过PWM的占空比设置颜色\ndef rgb_light(red, green, blue, brightness):\n    pwm_red = led_red.duty(int(red/255*brightness*1023))\n    pwm_green = led_green.duty(int(green/255*brightness*1023))\n    pwm_blue = led_blue.duty(int(blue/255*brightness*1023))\n\nrgb_light(255, 255, 0, 1.0)\n\n#周期点亮、熄灭\nwhile True:\n    relaypin.on()\n    time.sleep(2)\n    relaypin.off()\n    time.sleep(2)\n</code></pre><h3>远程控制如何实现？</h3><p>准备好了智能电灯设备后，要实现远程控制，我们还需要让智能电灯连接到物联网平台。那智能电灯如何与物联网平台通信交互呢？这里就要用到MQTT通信协议了。</p><p>首先，你需要在NodeMCU开发板上安装一个 MQTT 客户端代码库 <a href=\"https://github.com/micropython/micropython-lib/tree/master/umqtt.simple\">umqtt.simple 库</a>。它来自MicroPython官方维护的非内核标准库 <a href=\"https://github.com/micropython/micropython-lib\">micropython-lib</a>，你可以使用upip包管理器来安装。在串口 REPL 中运行下面的命令，就可以完成安装：</p><pre><code>&gt;&gt;&gt; import upip\n&gt;&gt;&gt; upip.install('micropython-umqtt.simple')\n</code></pre><p>安装命令是不是很简单？但是这里有一个前提要求，就是NodeMCU需要连接到Wi-Fi路由器上，也就是能够访问网络，因为这个安装过程是从网络下载安装文件。</p><p>怎么让NodeMCU连接到Wi-Fi路由器呢？你仍然可以通过串口 REPL 来完成。你可以在REPL中依次输入下面的命令来接入网络：</p><pre><code>&gt;&gt;&gt; import network\n&gt;&gt;&gt; wifi = network.WLAN(network.STA_IF)\n&gt;&gt;&gt; wifi.active(True) \n&gt;&gt;&gt; wifi.scan() \n&gt;&gt;&gt; wifi.isconnected() \n&gt;&gt;&gt; wifi.connect('你家中Wi-Fi的SSID', '你家中Wi-Fi密码') \n&gt;&gt;&gt; wifi.isconnected() \n</code></pre><p><strong>安装好 umqtt.simple 库之后，我们需要再设置一下物联网平台的MQTT协议交互的 Topic和具体的连接参数。</strong></p><p>我们用到的MQTT Topic主要有两个：一个用于发布消息，即消息流向是从设备到物联网平台；另一个用于接收订阅消息，即消息流向是从物联网平台到设备。</p><pre><code>#发布消息\n$thing/up/property/ProductID/DeviceName\n\n#接收订阅消息\n$thing/down/property/ProductID/DeviceName\n</code></pre><p>需要注意的是，ProductID和DeviceName需要替换为我们在上面创建设备的具体值。</p><p>设备与物联网平台建立MQTT连接，涉及Broker 服务器地址、端口号、设备ID（ClientID）、用户名（UserName）和密码（Password）。我把这些参数整理到了一张表里，供你参考。</p><p><img src=\"https://static001.geekbang.org/resource/image/12/46/12623e989f7c3d29a7efc1a3e1d86246.jpg\" alt=\"\"></p><p>用户名和密码不太好手动生成，我们可以借助一个<a href=\"https://iot-exp-individual-1258344699.cos.ap-guangzhou.myqcloud.com/password%E7%94%9F%E6%88%90%E5%B7%A5%E5%85%B7.zip\">网页工具</a>来生成。下载完成后，你可以解压缩，得到一些网页原文件，双击打开sign.html，然后在页面输入设备三元组，点击“Generate”即可生成用户名和密码。</p><p><img src=\"https://static001.geekbang.org/resource/image/72/96/72db80e852a9d87a073c78f8d5272e96.png\" alt=\"\"></p><p>有了这些信息，我们就可以开始为智能电灯设备编写MQTT代码了：</p><pre><code>from LED import Led\nfrom Button import Button\nfrom Relay import Relay\n\nimport time \nimport uasyncio\nimport network\nimport ujson\nfrom umqtt.simple import MQTTClient\n\n&quot;&quot;&quot;\nWi-Fi Gateway : SSID and Password\n&quot;&quot;&quot;\nWIFI_AP_SSID = &quot;你家的Wi-Fi SSID&quot;\nWIFI_AP_PSW = &quot;你家的Wi-Fi密码&quot;\n\n&quot;&quot;&quot;\nQCloud Device Info\n&quot;&quot;&quot;\nDEVICE_NAME = &quot;你的设备名称&quot;\nPRODUCT_ID = &quot;你的产品ID&quot;\nDEVICE_KEY = &quot;你的设备密钥&quot;\n\n&quot;&quot;&quot;\nMQTT topic\n&quot;&quot;&quot;\nMQTT_CONTROL_TOPIC = &quot;$thing/down/property/&quot;+PRODUCT_ID+&quot;/&quot;+DEVICE_NAME\nMQTT_CONTROL_REPLY_TOPIC = &quot;$thing/up/property/&quot;+PRODUCT_ID+&quot;/&quot;+DEVICE_NAME\n\nled = Led(5, 4, 0)\nrelay = Relay(16)\nbutton = Button(14)\n\nmqtt_client = None\ncolor = 0   #enum 0=red, 1=green, 2=blue\nname= &quot;&quot;    #light name. it is optional\nbrightness = 100  # 0%~100%\nlight_changed = False\n\nasync def wifi_connect(ssid, pwd):\n    sta = network.WLAN(network.STA_IF)\n    sta.active(True)\n    sta.connect(ssid, pwd)\n\n    while not sta.isconnected():\n        print(&quot;Wi-Fi Connecting...&quot;)\n        time.sleep_ms(500)\n\ndef mqtt_callback(topic, msg):\n    global led, relay, button\n    global color, name, brightness, light_changed\n\n    print((topic, msg))\n    msg_json = ujson.loads(msg)\n    if msg_json['method'] == 'control':\n        params = msg_json['params']\n\n        power_switch_tmp = params.get('power_switch')\n        if power_switch_tmp is not None:\n            power_switch = power_switch_tmp\n            relay.set_state(power_switch)\n        \n        brightness_tmp = params.get('brightness')\n        if brightness_tmp is not None:\n            brightness = brightness_tmp\n\n        color_tmp = params.get('color')\n        if color_tmp is not None:\n            color = color_tmp\n        \n        name_tmp = params.get('name')\n        if name_tmp is not None:\n            name = name_tmp\n        \n        if brightness_tmp is not None or color_tmp is not None:\n            light_changed = True\n\nasync def mqtt_connect():\n    global mqtt_client\n\n    MQTT_SERVER = PRODUCT_ID + &quot;.iotcloud.tencentdevices.com&quot;\n    MQTT_PORT = 1883\n    MQTT_CLIENT_ID = PRODUCT_ID+DEVICE_NAME\n    MQTT_USER_NAME = &quot;你的用户名&quot;\n    MQTTT_PASSWORD = &quot;你的密码&quot;\n\n    mqtt_client = MQTTClient(MQTT_CLIENT_ID, MQTT_SERVER, MQTT_PORT,MQTT_USER_NAME, MQTTT_PASSWORD, 60)\n    mqtt_client.set_callback(mqtt_callback)\n    mqtt_client.connect()\n\ndef mqtt_report(client, color, name, switch, brightness):\n\n    msg = {\n        &quot;method&quot;: &quot;report&quot;,\n        &quot;clientToken&quot;: &quot;clientToken-2444532211&quot;,\n        &quot;params&quot;: {\n            &quot;color&quot;: color,\n            &quot;color_temp&quot;: 0,\n            &quot;name&quot;: name,\n            &quot;power_switch&quot;: switch,\n            &quot;brightness&quot;: brightness\n        }   \n    }\n\n    client.publish(MQTT_CONTROL_REPLY_TOPIC.encode(), ujson.dumps(msg).encode())\n\nasync def light_loop():\n    global led, relay, button\n    global color, name, brightness, light_changed\n\n    switch_status_last = 1\n    LED_status = 1  \n\n    color = 2   #blue\n    brightness = 100    #here 100% == 1\n    led.rgb_light(0, 0, 255, brightness/100.0)\n\n    time_cnt = 0\n\n    mqtt_client.subscribe(MQTT_CONTROL_TOPIC.encode())\n\n    while True:\n        mqtt_client.check_msg()\n\n        switch_status = button.state()\n        LED_status = relay.state()\n        if switch_status != switch_status_last:\n            if switch_status == 0 and switch_status_last == 1:\n                LED_status = 0 if LED_status else 1\n            relay.set_state(LED_status)\n            switch_status_last = switch_status\n        \n        if light_changed:\n            light_changed = False\n            led.rgb_light(255 if color==0 else 0, 255 if color==1 else 0, 255 if color==2 else 0, brightness/100.0)\n\n        if time_cnt &gt;= 20:\n            mqtt_report(mqtt_client, color, name, LED_status, brightness)\n            time_cnt = 0\n        time_cnt = time_cnt+1\n        uasyncio.sleep_ms(50)\n\nasync def main():\n    global mqtt_client\n\n    # Wi-Fi connection\n    try:\n        await uasyncio.wait_for(wifi_connect(WIFI_AP_SSID, WIFI_AP_PSW), 20)\n    except uasyncio.TimeoutError:\n        print(&quot;wifi connected timeout!&quot;)\n    \n    # MQTT connection\n    try:\n        await uasyncio.wait_for(mqtt_connect(), 20)\n    except uasyncio.TimeoutError:\n        print(&quot;mqtt connected timeout!&quot;)\n\n    await uasyncio.gather(light_loop())\n\nuasyncio.run(main())\n</code></pre><h2>如何通过手机远程控制？</h2><p>在完成代码后，我们通过ampy工具或者pyboard.py工具，将这些源代码上传到NodeMCU开发板中。程序开始自动执行，智能电灯自动接入物联网平台。打开物联网平台的设备调试页面，我们就可以看到设备显示“在线”。</p><p>点击“调试”，通过调试界面发送MQTT消息来控制智能电灯。</p><p><img src=\"https://static001.geekbang.org/resource/image/5d/28/5d03e52c440c12f7d0e00c972223dd28.png\" alt=\"\"></p><p>点击“发送”，物联网平台会向设备发送下面这样的消息内容：</p><pre><code>{\n  &quot;method&quot;: &quot;control&quot;,\n  &quot;clientToken&quot;: &quot;clientToken-e9d920ea-a1f4-4a53-aada-a1d36fbbdd20&quot;,\n  &quot;params&quot;: {\n    &quot;power_switch&quot;: 1,\n    &quot;brightness&quot;: 50,\n    &quot;color&quot;: 0,\n    &quot;color_temp&quot;: 0,\n    &quot;name&quot;: &quot;&quot;\n  }\n}\n</code></pre><p>那怎么通过手机小程序控制电灯呢？这也很好实现，我们只需要在小程序上添加设备，就可以使用小程序界面控制了。</p><p>打开“腾讯连连”小程序，点击“+”按钮，扫描我们在“设备调试”界面保存的二维码，就完成添加动作了。</p><p><img src=\"https://static001.geekbang.org/resource/image/1d/7f/1d7b56914e783d7f5bfe18a633af2e7f.png\" alt=\"\"></p><p>然后，点击设备卡片，进入设备交互界面，就可以进行远程控制了。</p><p><img src=\"https://static001.geekbang.org/resource/image/40/5c/40969abc41cafa86910c231046099d5c.png\" alt=\"\"></p><p>到这里，我们就可以用手机来远程控制智能电灯的开关状态和颜色了。</p><h2>小结</h2><p>在这一讲中，我们边实战边学习了智能电灯的电路组成、程序代码，以及与腾讯云物联网平台进行MQTT通信的相关知识。我再来帮你总结下需要记住的几个核心知识点。</p><ol>\n<li>基于物联网平台开发产品，我们一般需要完成三件事，分别是物理网平台的创建和设置、智能设备的功能开发（每个产品最重要的部分），以及用户交互界面的开发。</li>\n<li>物模型是在物联网平台上定义设备的重要概念，你可以将<a href=\"https://time.geekbang.org/column/article/310441\">第6讲</a>的物模型直接导入来创建设备。</li>\n<li>PWM 是照明控制中非常重要的一种技术手段，了解了频率和占空比的概念，也就掌握了它的工作原理。</li>\n<li>智能电灯通过MQTT通信协议与物联网平台交互。在NodeMCU开发板上可以安装一个 MQTT 客户端代码库 <a href=\"https://github.com/micropython/micropython-lib/tree/master/umqtt.simple\">umqtt.simple 库</a>，来开发MQTT客户端代码。</li>\n</ol><p>其实今天我们控制的 RGB LED 灯只是一颗灯珠，但是在实际产品中，我们很可能要控制多颗 LED。这时候，我们面临的首要问题，就是微控制芯片（MCU）的管脚不够用了。那怎么办呢？</p><p>关于这个问题，行业里已经有很多解决方案了。其中，<a href=\"https://learn.adafruit.com/adafruit-neopixel-uberguide\">NeoPixel</a> 是开源硬件方案，你可以在网上搜索、了解一下，当然也可以和我多多交流。</p><h2>思考题</h2><p>最后，我给你留一道思考题吧。</p><p>在物联网平台的设备调试界面，我们可以发送MQTT 消息来控制设备，而且我还给出了具体的消息内容。你可以和我说说，这个消息的主题（Topic）是什么吗？</p><p>另外，在智能电灯的功能实现中，我们通过继电器实现了电路通断的控制，通过LED灯实现了颜色的调节。你可以实现一下按钮的功能吗？这样就可以通过设备本身来控制电灯的打开和熄灭了。这也更符合现实中灯的样式。</p><p>欢迎你在留言区和我分享你的思考，如果在实战今天的智能电灯控制时遇到了什么问题，也可以和我进一步交流。同时，也欢迎你把今天的内容分享给你的朋友，一起动手实现一个酷炫的智能电灯控制系统吧。</p>",
                "article_title": "17 | 远程控制：怎样打造联网的智能电灯？"
            },
            {
                "title": "18 | 场景联动：智能电灯如何感知光线？（上）",
                "id": 323428,
                "content": "<p>你好，我是郭朝斌。</p><p>在上一讲，我们打造了自己的联网智能电灯，你可以通过手机小程序来控制它的打开和关闭，也就是实现远程控制。</p><p>其实，我们还可以进一步提高体验，让智能电灯可以基于环境的明暗来自动地打开和关闭。要做到这一点并不难，可以分为两个阶段，第一阶段是打造传感器设备来感知光照的强弱，判断出环境的明暗状态，第二阶段是创建一个场景联动，根据传感器的数值来控制智能电灯的状态。</p><p>这一讲，我先带你一步一步地实现第一阶段的工作（如有需要，你可以根据<a href=\"https://shimo.im/sheets/D3VVPdwcYRhhQRXh/MODOC\">这份文档</a>自行采购相关硬件）。</p><h2>第一步：通信技术</h2><p>首先，我们为光照传感器设备选择通信技术。</p><p>因为光照传感器设备的部署位置比较灵活，不太可能像智能电灯一样连接房间里的电源线，所以我们要用一种比Wi-Fi功耗更低的通信技术。这样的话，就算使用电池供电，也可以长时间（一年以上）持续工作。</p><p>经过对比，我建议选择 BLE 低功耗蓝牙技术（关于通信技术的选择策略，你可以参考<a href=\"https://time.geekbang.org/column/article/306976\">第2讲</a>）。随着智能手机的发展，蓝牙早已成为手机标配的通信技术，蓝牙芯片和协议栈的成熟度非常高，而且在设备的供应链方面，蓝牙芯片可以选择的供应商也非常多。</p><p>不过在正式开发之前，我还得为你补充说明一些BLE的相关知识。</p><p>BLE设备可以在4种模式下工作：</p><!-- [[[read_end]]] --><ol>\n<li><strong>广播模式</strong>（Broadcaster），这里特指单纯的广播模式。这种模式下设备不可以被连接，只能够以一定的时间间隔把数据广播出来，供其他设备使用，比如手机扫描处理。蓝牙Beacon设备就是工作在这种模式。</li>\n<li><strong>从机模式</strong>（Peripheral），这种模式下设备仍然可以广播数据，同时也可以被连接。建立连接后，双方可以进行双向通信。比如你用手机连接一个具有蓝牙功能的体温计，这时体温计就是从机（Peripheral）。</li>\n<li><strong>主机模式</strong>（Central），这种模式下设备不进行广播，但是可以扫描周围的蓝牙广播包，发现其他设备，然后主动对这些设备发起连接。还是刚才那个例子，主动连接蓝牙体温计的手机就是主机（Central）角色。</li>\n<li><strong>观察者模式</strong>（Observer），这种模式下设备像主机模式一样，也不进行广播，而是扫描周围的蓝牙广播包，但是不同的地方是，它不会与从机设备建立连接。一般收集蓝牙设备广播包的网关就是在这种模式下工作的，它会将收集的广播数据通过网线、Wi-Fi或者4G等蜂窝网络上传到云平台。</li>\n</ol><p>在这一讲中，我们打造的光照传感器只需要提供光照强度数据就行了，并不需要进行双向通信，所以我们可以定义设备在广播模式下工作。</p><h2>第二步：选择开发板</h2><p>那么光照传感器设备要选择什么开发板呢？</p><p>我们在上一讲打造的联网智能电灯中使用的NodeMCU是基于<strong>ESP8266芯片</strong>的，相信你也注意到了，这款芯片并不支持低功耗蓝牙。</p><p>好在市场上还有一款基于<strong>ESP32芯片</strong>的NodeMCU开发板。<a href=\"https://www.espressif.com/zh-hans/products/socs/esp32/overview\">ESP32</a>是乐鑫科技出品的另一款性能优良且满足低功耗的物联网芯片，它同时支持Wi-Fi和低功率蓝牙通信技术，还有丰富的ADC接口。</p><p>更重要的是，MicroPython也支持ESP32芯片，这样我们就可以继续使用Python语言来开发了。</p><h2>第三步：准备MicroPython环境</h2><p>接下来，我们就在NodeMCU（ESP32）上安装MicroPython固件，准备Python程序的运行环境。</p><p>MicroPython官网已经为我们准备了编译好的固件文件，这省掉了我们在电脑上进行交叉编译的工作。你可以从<a href=\"http://micropython.org/download/esp32/\">这个链接</a> 中选择“Firmware with ESP-IDF v3.x”下面的“GENERIC”类别，直接下载最新版本的固件文件到电脑中。</p><p>然后，我们使用一根 USB 数据线，将 NodeMCU 开发板和电脑连接起来。USB数据线仍然选择一头是 USB-A 接口、另一头是 Micro-USB 接口，并且支持数据传输的完整线缆。具体细节，你可以再回顾<a href=\"https://time.geekbang.org/column/article/321652\">第16讲</a>中的相关内容。</p><p>我们使用esptool工具把这个固件烧录到NodeMCU开发板上。先在电脑终端上输入下面的命令，清空一下NodeMCU的Flash存储芯片。</p><pre><code>esptool.py --chip esp32 --port /dev/cu.usbserial-0001 erase_flash\n</code></pre><p>你可以从命令里看到，和之前智能电灯用的命令相比，这里增加了芯片信息“esp32”。另外，“--port”后面的串口设备名称，需要你替换为自己电脑上对应的名称。</p><p>成功擦除Flash之后，就执行下面的命令，将固件写入Flash芯片。</p><pre><code>esptool.py --chip esp32 --port /dev/cu.usbserial-0001 --baud 460800 write_flash -z 0x1000 esp32-idf3-20200902-v1.13.bin\n</code></pre><p>这时，我们使用电脑上的终端模拟器软件，比如 SecureCRT，通过串口协议连接上开发板，注意波特率（Baud rate）设置为 115200。</p><p>然后你应该就能看到下图所示的内容，并且可以进行交互。</p><p><img src=\"https://static001.geekbang.org/resource/image/e2/8b/e2a9a62bc472a7f41ddca0e5b6ca678b.png\" alt=\"\"></p><h2>第四步：搭建光照传感器硬件电路</h2><p>现在，我们开始基于NodeMCU搭建光照传感器的硬件电路。</p><p>首先，我们要准备好实验的材料：</p><ol>\n<li>NodeMCU（ESP32）开发板一个。注意区分芯片的具体型号。</li>\n<li>光照传感器模块一个</li>\n<li>杜邦线/跳线若干个</li>\n<li>面包板一个</li>\n</ol><p>然后，你可以按照我画的连线图来搭建出自己的电路。跟联网智能电灯的电路比起来，这个还是非常简单的。</p><p><img src=\"https://static001.geekbang.org/resource/image/ff/ab/ffcd6bb49b89e3d079fc1ca5c2dd18ab.png\" alt=\"\"></p><p>这里说明一下，在我的电路图中，光照传感器模块从左到右，管脚分别是光强度模拟信号输出管脚、电源地GND和电源正VCC管脚。你需要根据自己的传感器模块调整具体的连线。</p><p>我选择的是基于PT550环保型光敏二极管的光照传感器元器件，它的灵敏度更高，测量范围是0Lux～6000Lux。</p><p>Lux（勒克斯）是光照强度的单位，它和另一个概念Lumens（流明）是不同的。Lumens是指一个光源（比如电灯、投影仪）发出的光能力的总量，而Lux是指空间内一个位置接收到的光照的强度。</p><p>这个元器件通过信号管脚输出模拟量，我们读取NodeMCU ESP32的ADC模数转换器（ADC0，对应GPIO36）的数值，就可以得到光照强度。这个数值越大，表示光照强度越大。</p><p>因为ADC支持的最大位数是12bit，所以这个数值范围是0~4095之间。这里我们粗略地按照线性关系做一个转换。具体计算过程，你可以参考下面的代码：</p><pre><code>from machine import ADC\nfrom machine import Pin\n\nclass LightSensor():\n\n    def __init__(self, pin):\n        self.light = ADC(Pin(pin))\n\n    def value(self):\n        value = self.light.read()\n        print(&quot;Light ADC value:&quot;,value)\n        return int(value/4095*6000)\n</code></pre><h2>第五步：编写蓝牙程序</h2><p>NodeMCU ESP32的固件已经集成了BLE的功能，我们可以直接在这个基础上进行软件的开发。这里我们需要给广播包数据定义一定的格式，让其他设备可以顺利地解析使用扫描到的数据。</p><p>那么怎么定义蓝牙广播包的格式呢？我们可以使用小米制定的<a href=\"https://iot.mi.com/new/doc/embedded-development/ble/ble-mibeacon.html\">MiBeacon</a>蓝牙协议。</p><p><strong>MiBeacon蓝牙协议</strong>的广播包格式是基于BLE的GAP（Generic Access Profile）制定的。GAP控制了蓝牙的广播和连接，也就是控制了设备如何被发现，以及如何交互。</p><p>具体来说，GAP定义了两种方式来让设备广播数据：</p><p>一个是广播数据（Advertising Data payload），这个是必须的，数据长度是31个字节；</p><p>另一个是扫描回复数据（Scan Response payload），它基于蓝牙主机设备（比如手机）发出的扫描请求（Scan Request）来回复一些额外的信息。数据长度和广播数据一样。</p><p>（注意，蓝牙5.0中有扩展的广播数据，数据长度等特性与此不同，但这里不涉及，所以不再介绍。）</p><p>所以，只要含有以下指定信息的广播报文，就可以认为是符合MiBeacon蓝牙协议的。</p><ol>\n<li>Advertising Data中 Service Data (0x16) 含有Mi Service UUID的广播包，UUID是0xFE95。</li>\n<li>Scan Response中 Manufacturer Specific Data (0xFF)含有小米公司识别码的广播包，识别码ID是0x038F。</li>\n</ol><p>其中，无论是在Advertising Data中，还是Scan Response中，均采用统一格式定义。</p><p>具体的广播报文格式定义，你可以参考下面的表格。</p><p><img src=\"https://static001.geekbang.org/resource/image/23/aa/23a2b5245717b21c4ce766bc13d69faa.jpg\" alt=\"\"></p><p>因为我们要为光照传感器增加广播光照强度数据的能力，所以主要关注<a href=\"https://iot.mi.com/new/doc/embedded-development/ble/object-definition\">Object的定义</a>。Object分为属性和事件两种，具体定义了设备数据的含义，比如体温计的温度、土壤的湿度等，数据格式如下表所示：</p><p><img src=\"https://static001.geekbang.org/resource/image/a7/4e/a79e59c00b0ba726923910c8768f674e.jpg\" alt=\"\"></p><p>按照MiBeacon的定义，光照传感器的Object ID是0x1007，数据长度3个字节，数值范围是0~120000之间。</p><p>我将代码贴在下面，供你参考。</p><pre><code>#File：ble_lightsensor.py\nimport bluetooth\nimport struct\nimport time\nfrom ble_advertising import advertising_payload\n\nfrom micropython import const\n\n_IRQ_CENTRAL_CONNECT = const(1)\n_IRQ_CENTRAL_DISCONNECT = const(2)\n_IRQ_GATTS_INDICATE_DONE = const(20)\n\n_FLAG_READ = const(0x0002)\n_FLAG_NOTIFY = const(0x0010)\n\n_ADV_SERVICE_DATA_UUID = 0xFE95\n_SERVICE_UUID_ENV_SENSE = 0x181A\n_CHAR_UUID_AMBIENT_LIGHT = 'FEC66B35-937E-4938-9F8D-6E44BBD533EE'\n\n# Service environmental sensing\n_ENV_SENSE_UUID = bluetooth.UUID(_SERVICE_UUID_ENV_SENSE)\n# Characteristic ambient light density\n_AMBIENT_LIGHT_CHAR = (\n    bluetooth.UUID(_CHAR_UUID_AMBIENT_LIGHT),\n    _FLAG_READ | _FLAG_NOTIFY ,\n)\n_ENV_SENSE_SERVICE = (\n    _ENV_SENSE_UUID,\n    (_AMBIENT_LIGHT_CHAR,),\n)\n\n# https://specificationrefs.bluetooth.com/assigned-values/Appearance%20Values.pdf\n_ADV_APPEARANCE_GENERIC_AMBIENT_LIGHT = const(1344)\n\nclass BLELightSensor:\n    def __init__(self, ble, name='Nodemcu'):\n        self._ble = ble\n        self._ble.active(True)\n        self._ble.irq(self._irq)\n        ((self._handle,),) = self._ble.gatts_register_services((_ENV_SENSE_SERVICE,))\n        self._connections = set()\n        time.sleep_ms(500)\n        self._payload = advertising_payload(\n            name=name, services=[_ENV_SENSE_UUID], appearance=_ADV_APPEARANCE_GENERIC_AMBIENT_LIGHT\n        )\n        self._sd_adv = None\n        self._advertise()\n\n    def _irq(self, event, data):\n        # Track connections so we can send notifications.\n        if event == _IRQ_CENTRAL_CONNECT:\n            conn_handle, _, _ = data\n            self._connections.add(conn_handle)\n        elif event == _IRQ_CENTRAL_DISCONNECT:\n            conn_handle, _, _ = data\n            self._connections.remove(conn_handle)\n            # Start advertising again to allow a new connection.\n            self._advertise()\n        elif event == _IRQ_GATTS_INDICATE_DONE:\n            conn_handle, value_handle, status = data\n\n    def set_light(self, light_den, notify=False):\n        self._ble.gatts_write(self._handle, struct.pack(&quot;!h&quot;, int(light_den)))\n        self._sd_adv = self.build_mi_sdadv(light_den)\n        self._advertise()\n        if notify:\n            for conn_handle in self._connections:\n                if notify:\n                    # Notify connected centrals.\n                    self._ble.gatts_notify(conn_handle, self._handle)\n\n    def build_mi_sdadv(self, density):\n        \n        uuid = 0xFE95\n        fc = 0x0010\n        pid = 0x0002\n        fcnt = 0x01\n        mac = self._ble.config('mac')\n        objid = 0x1007\n        objlen = 0x03\n        objval = density\n\n        service_data = struct.pack(&quot;&lt;3HB&quot;,uuid,fc,pid,fcnt)+mac+struct.pack(&quot;&lt;H2BH&quot;,objid,objlen,0,objval)\n        print(&quot;Service Data:&quot;,service_data)\n        \n        return advertising_payload(service_data=service_data)\n        \n    def _advertise(self, interval_us=500000):\n        self._ble.gap_advertise(interval_us, adv_data=self._payload)\n        time.sleep_ms(100)\n\n        print(&quot;sd_adv&quot;,self._sd_adv)\n        if self._sd_adv is not None:\n            print(&quot;sdddd_adv&quot;,self._sd_adv)\n            self._ble.gap_advertise(interval_us, adv_data=self._sd_adv)\n</code></pre><pre><code>#File: main.py\nfrom ble_lightsensor import BLELightSensor\nfrom lightsensor import LightSensor\nimport time\nimport bluetooth\n\ndef main():\n    ble = bluetooth.BLE()\n    ble.active(True)\n    ble_light = BLELightSensor(ble)\n\n    light = LightSensor(36)\n    light_density = light.value()\n    i = 0\n\n    while True:\n        # Write every second, notify every 10 seconds.\n        i = (i + 1) % 10\n        ble_light.set_light(light_density, notify=i == 0)\n        print(&quot;Light Lux:&quot;, light_density)\n\n        light_density = light.value()\n        time.sleep_ms(1000)\n\nif __name__ == &quot;__main__&quot;:\n    main()\n</code></pre><h2>第六步：验证光照传感器</h2><p>到这里，我们已经完成了光照传感器设备的开发工作。那么怎么验证设备有没有正常工作呢？</p><p>我们可以通过手机上的蓝牙调试软件来扫描周围蓝牙设备，查看设备有没有蓝牙广播包输出，能不能跟手机正常交互。常用的软件有LightBlue、nRFConnect 和 BLEScanner，选择其中一个就行了。</p><p>比如我选择的是nRF Connect，打开之后，它会自动扫描周围的蓝牙广播包，将发现的设备以列表的形式展示。</p><p>如果周围蓝牙设备很多的话，为了方便发现自己的开发板，你可以点击列表上方的“No Filter”，选择将“Max.RSSI”打开。拖动其中的滑竿到合适的值，比如-50dBm，就可以过滤掉蓝牙信号强度比较弱（一般也是比较远）的设备。</p><p><img src=\"https://static001.geekbang.org/resource/image/fb/54/fbe2863b3968e69e36c4f880714fba54.png\" alt=\"\"></p><p>下面是我的手机扫描到的基于NodeMCU开发板的蓝牙设备。</p><p><img src=\"https://static001.geekbang.org/resource/image/90/fc/90569129dbf544c3a9da37f1e2fd84fc.png\" alt=\"\"></p><p>其中名称Nodemcu下面的就是广播包的具体数据。</p><p>到这里，我们就完成了光照传感器设备的开发工作。</p><h2>小结</h2><p>总结一下，在这一讲中，我介绍了光照传感器的开发过程，并且补充了低功耗蓝牙技术的相关知识。下面，我们回顾以下重点：</p><ol>\n<li>对于无法连接电源线、需要灵活放置甚至经常移动的设备，低功耗蓝牙技术是合适的通信技术选择。</li>\n<li>MiBeacon协议的广播包定义是基于BLE的GAP（Generic Access Profile）制定的，主要有广播数据（Advertising Data）和扫描回复数据（Scan Response）两种。其中广播数据中Service Data的UUID是0xFE95，扫描回复数据中Manufacturer Specific Data的厂家识别码是0x038F。</li>\n<li>在日常的蓝牙设备开发工作中，我们经常需要调试、测试蓝牙功能，这时你可以使用手机上的蓝牙调试软件来验证，比如LightBlue、nRFConnect 和 BLEScanner等。</li>\n</ol><p>不过，准备好光照传感器设备只是第一步，为了实现光照传感器和智能电灯的联动，我们还需要将光照传感器接入网络。这就需要借助蓝牙网关设备了，在下一讲中，我将基于树莓派讲解网关设备的开发过程。</p><h2>思考题</h2><p>最后，给你留一个思考题吧。</p><p>在这一讲的开头，我提到蓝牙设备除了广播数据的能力，还可以连接进行交互。在我提供的代码中其实也包含了一个可供连接获取数据的Service和Characteristic，你发现了吗？你知道这些是基于低功耗蓝牙中的什么Profile协议吗？</p><p>欢迎你在留言区写下自己的答案和我交流一下，也欢迎你将这一讲分享给你的朋友，一起讨论学习。</p>",
                "article_title": "18 | 场景联动：智能电灯如何感知光线？（上）"
            },
            {
                "title": "19 | 场景联动：智能电灯如何感知光线？（下）",
                "id": 324155,
                "content": "<p>你好，我是郭朝斌。</p><p>在上一讲，我们基于NodeMCU ESP32开发板，开发了一款光照传感器。考虑到低功耗的需求，它是基于低功耗蓝牙技术来实现的。但是蓝牙设备本身无法直接联网上报数据，那么我们要怎么根据光照强度数据来联动控制智能电灯呢？</p><p>不知道你还记不记得<a href=\"https://time.geekbang.org/column/article/313631\">第9讲</a>的内容？对于蓝牙设备，我们需要借助<strong>网关</strong>来实现联网的目的。所以在这一讲中，我会带你用树莓派打造蓝牙网关，最终实现光照传感器和智能电灯的场景联动（如有需要，你可以根据<a href=\"https://shimo.im/sheets/D3VVPdwcYRhhQRXh/MODOC\">这份文档</a>自行采购相关硬件）。</p><h2>网关系统架构</h2><p>首先，我们先看一下网关的系统架构。</p><p>网关的主要功能是<strong>协议转换</strong>，一方面它需要接收低功耗蓝牙技术的光照传感器的广播数据，另一方面，它需要把解析的数据上传到云平台。</p><p>具体的架构图如下所示。</p><p><img src=\"https://static001.geekbang.org/resource/image/e4/44/e44a8bfe765e535f320568f57a3cfa44.jpg?wh=2700*1335\" alt=\"19.01\"></p><h2>南向蓝牙通信</h2><p>在树莓派上进行蓝牙开发，你可以使用<a href=\"https://github.com/IanHarvey/bluepy\">bluepy</a>软件包。它提供了一个Python语言版本的低功耗蓝牙API接口，而且对树莓派的适配非常好。</p><h3>通过终端登录树莓派</h3><p>在学习<a href=\"https://time.geekbang.org/column/article/320675\">第15讲</a>的时候，你应该已经在树莓派上部署好了包含Gladys Assistant系统的Raspbian操作系统，现在你可以直接使用这个系统。安装软件包之前，我们在电脑终端上输入下面的命令，通过SSH协议登录到树莓派系统中。</p><!-- [[[read_end]]] --><pre><code>$ ssh pi@gladys.local\n</code></pre><p>其中，pi就是默认的登录用户名，gladys.local是树莓派开发板的本地域名。</p><p>当提示输入密码时，我们输入默认密码raspberry，然后回车，就登录到了树莓派系统中。</p><p><img src=\"https://static001.geekbang.org/resource/image/91/81/9171ef2f8a94c6ee8d1869d571677781.png?wh=1266*540\" alt=\"19.02\"></p><h3>通过图形化窗口软件登录树莓派</h3><p>当然，你也可以使用提供图形化窗口的软件来登录树莓派，比如<strong>SecureCRT</strong>，它除了支持串口协议，同时也支持SSH协议。你只需要新建一个连接会话，按照下图所示的内容填写就行了：</p><p><img src=\"https://static001.geekbang.org/resource/image/f3/57/f39028873bb6ce7d99f411881f4a3357.png?wh=980*878\" alt=\"19.03\"></p><p>第一次登录时，SecureCRT会弹窗提示我们查看“Host Key”，这时点击“Accept Once”即可。</p><p><img src=\"https://static001.geekbang.org/resource/image/78/59/786bd55b06ea8c11d3171fb57ddec459.png?wh=2480*478\" alt=\"19.04\"></p><p>然后我们输入密码“raspberry”，同时勾选“Save password”，省去以后重复输入密码的麻烦。点击“OK”后，就进入树莓派系统了。</p><p><img src=\"https://static001.geekbang.org/resource/image/4a/ee/4af7047e2d3yy7a2dfa511628708a1ee.png?wh=684*310\" alt=\"19.05\"></p><h3>在树莓派开发蓝牙程序</h3><p>我们在树莓派的终端上输入下面命令，就可以完成bluepy的安装：</p><pre><code>$ sudo apt-get install python3-pip libglib2.0-dev\n$ sudo pip3 install bluepy\n</code></pre><p>另外，我们还需要安装interruptingcow软件包。它主要是便于编写定时任务。它的安装命令是：</p><pre><code>$ sudo pip3 install interruptingcow\n</code></pre><p>具体代码如下，供参考：</p><pre><code>#File: blescan.py\nimport time\nfrom threading import Thread\nfrom interruptingcow import timeout\n\nfrom bluepy.btle import DefaultDelegate, Peripheral, Scanner, UUID, capitaliseName, BTLEInternalError\nfrom bluepy.btle import BTLEDisconnectError, BTLEManagementError, BTLEGattError\n\nclass LightScanner():\n    SCAN_TIMEOUT = 5\n\n    def __init__(self, name):\n        self._name = name\n    \n    def status_update(self):\n        results = self._get_data()\n\n        # messages = [\n        #     MqttMessage(\n        #         topic=self.format_topic(&quot;property/light&quot;),\n        #         payload=results.lightlevel,\n        #     )\n        # ]\n\n        return results\n\n    def _get_data(self):\n\n        scan_processor = ScanProcessor(self._name)\n        scanner = Scanner().withDelegate(scan_processor)\n        scanner.scan(self.SCAN_TIMEOUT, passive=True)\n\n        with timeout(\n            self.SCAN_TIMEOUT,\n            exception=Exception(\n                &quot;Retrieving data from {} device {} timed out after {} seconds&quot;.format(\n                    repr(self), self._name, self.SCAN_TIMEOUT\n                )\n            ),\n        ):\n            while not scan_processor.ready:\n                time.sleep(1)\n            return scan_processor.results\n\n        return scan_processor.results\n\nclass ScanProcessor:\n\n    ADV_TYPE_SERVICE_DATA = 0x16\n    def __init__(self, name):\n        self._ready = False\n        self._name = name\n        self._results = MiBeaconData()\n\n    def handleDiscovery(self, dev, isNewDev, _):\n        is_nodemcu = False\n        if isNewDev:\n            for (adtype, desc, value) in dev.getScanData():\n                #Service Data UUID == 0xFE95 according to MiBeacon\n                if adtype == self.ADV_TYPE_SERVICE_DATA and value.startswith(&quot;95fe&quot;):\n                    print(&quot;FOUND service Data:&quot;,adtype, desc, value)\n                    #Object ID == 0x1007 according to MiBeacon\n                    if len(value) == 38 and value[26:30] == '0710':\n                        light_den = int((value[-2:] + value[-4:-2]), 16)\n                        mac = value[14:26]\n\n                        self._results.lightlevel = light_den\n                        self._results.mac = mac\n\n                        self.ready = True\n\n    @property\n    def mac(self):\n        return self._mac\n\n    @property\n    def ready(self):\n        return self._ready\n\n    @ready.setter\n    def ready(self, var):\n        self._ready = var\n\n    @property\n    def results(self):\n        return self._results\n\nclass MiBeaconData:\n    def __init__(self):\n        self._lightlevel = None\n        self._mac = None\n\n    @property\n    def lightlevel(self):\n        return self._lightlevel\n\n    @lightlevel.setter\n    def lightlevel(self, var):\n        self._lightlevel = var\n\n    @property\n    def mac(self):\n        return self._mac\n\n    @mac.setter\n    def mac(self, var):\n        self._mac = var\n</code></pre><h2>北向MQTT对接云平台</h2><p>接下来，我们要实现网关和云平台的对接。</p><h3>MQTT开发环境准备</h3><ol>\n<li><strong>安装软件包</strong></li>\n</ol><p>蓝牙网关与云平台交互的通信协议也是使用MQTT协议，所以我们需要安装MQTT的软件包。</p><p>使用哪个软件包呢？在<a href=\"https://time.geekbang.org/column/article/312691\">第8讲</a>中我介绍过几个常用的MQTT软件包，这里我们选择支持Python语言开发的<a href=\"http://www.eclipse.org/paho/\">Eclipse Paho</a>软件包。我们在树莓派的终端上输入下面的命令来安装。</p><pre><code>$ sudo pip3 install paho-mqtt\n</code></pre><p>安装成功后，我们可以写一个demo程序测试一下。下面是我测试的代码，你可以参考。和第8讲一样，这段代码仍然会连接到 test.mosquitto.org，并且订阅“/geektime/iot”的主题消息。</p><pre><code>#File: mqttdemo.py \nimport paho.mqtt.client as mqtt\n\ndef on_connect(client, userdata, flags, rc):\n    print(&quot;Connected with result code &quot;+str(rc))\n\n    client.subscribe(&quot;/geektime/iot&quot;)\n\ndef on_message(client, userdata, msg):\n    print(msg.topic+&quot; &quot;+str(msg.payload))\n\nclient = mqtt.Client()\nclient.on_connect = on_connect\nclient.on_message = on_message\n\n#Still connect to mqtt.eclipse.org\nclient.connect(&quot;test.mosquitto.org&quot;, 1883, 60)\n\nclient.loop_forever()\n</code></pre><ol start=\"2\">\n<li><strong>部署文件到树莓派</strong></li>\n</ol><p>现在，我们把测试文件 mqttdemo.py 上传到树莓派上。</p><p>你可以在电脑终端上，运行下面的命令。（注意，你需要先在树莓派上创建 pi-gateway 这个目录。）</p><pre><code>$ scp mqttdemo.py pi@gladys.local:/home/pi/pi-gateway/\n</code></pre><p>其中这个scp命令是基于SSH协议实现的安全文档传输功能。</p><p>当然，你也可能更习惯图形化的软件，所以我再介绍一个能实现scp功能的软件 <a href=\"https://filezilla-project.org/download.php?type=client\">FileZilla</a>。它支持MacOS、Windows和Linux操作系统，操作界面也非常直观。</p><p>打开“站点管理器”，创建“新站点”。你可以按照下图设置具体配置参数，然后点击“连接”，登录到树莓派系统。为了方便之后的使用，你可以勾选“保存密码”选项。</p><p><img src=\"https://static001.geekbang.org/resource/image/29/90/29db1ea1b71c06b0845b82bbefc72190.png?wh=1628*926\" alt=\"19.06\"></p><p>在软件界面的左半部分是你的电脑上的文件目录，右半部分是树莓派上的目录。你只需要双击左边的某个文件，就可以将文件传输到树莓派上。当然你也可以双击右边树莓派上的文件，将它传输到你的电脑。</p><p><img src=\"https://static001.geekbang.org/resource/image/aa/69/aa1b5c0538b4f62f33ce6ed22c77a469.png?wh=1408*1094\" alt=\"19.07\"></p><p>把文件传输到树莓派之后，我们就可以在树莓派的终端上输入下面的命令，运行上面的demo程序。</p><pre><code>$ sudo python3 mqttdemo.py\n</code></pre><p>这时我们把<a href=\"https://time.geekbang.org/column/article/312691\">第8讲</a>中的发布消息命令再执行一次，如果一切顺利执行，那么就可以在树莓派的终端上看到这个消息。</p><pre><code>hbmqtt_pub --url mqtt://test.mosquitto.org:1883 -t /geektime/iot -m Hello,World!\n</code></pre><p><img src=\"https://static001.geekbang.org/resource/image/16/b7/16e0b2312275956965643dc825ff17b7.png?wh=942*132\" alt=\"19.08\"></p><h3>云平台创建光照传感器设备</h3><p>现在，我们已经做好了对接云平台的准备工作。在树莓派上开发与云平台的通信代码之前，我们还需要在腾讯云平台上创建对应的光照传感器设备。</p><p>创建的过程与第17讲智能电灯的过程类似。我快速介绍一下，你重点关注不同的地方就可以了。</p><p>在“新建产品”中，产品类别选择“智慧生活”--&gt;“安防报警”--&gt;“光照度传感器”。数据协议仍然选择“数据模板”，其他的保持默认值即可。</p><p><img src=\"https://static001.geekbang.org/resource/image/a1/37/a15fc960131a83818be3f979044b0037.png?wh=1272*1172\" alt=\"19.09\"></p><p>创建成功后，我们点击进入数据模板的设置界面。为了尽量简单，我只定义了一个属性“光照度”，而且是只读类型。你可以直接导入下面的JSON文件完成数据模板的设置。</p><pre><code>{\n  &quot;version&quot;: &quot;1.0&quot;,\n  &quot;profile&quot;: {\n    &quot;ProductId&quot;: &quot;你的ProductID&quot;,\n    &quot;CategoryId&quot;: &quot;112&quot;\n  },\n  &quot;properties&quot;: [\n    {\n      &quot;id&quot;: &quot;Illuminance&quot;,\n      &quot;name&quot;: &quot;光照度&quot;,\n      &quot;desc&quot;: &quot;光照度检测&quot;,\n      &quot;mode&quot;: &quot;r&quot;,\n      &quot;define&quot;: {\n        &quot;type&quot;: &quot;float&quot;,\n        &quot;min&quot;: &quot;0&quot;,\n        &quot;max&quot;: &quot;6000&quot;,\n        &quot;start&quot;: &quot;0&quot;,\n        &quot;step&quot;: &quot;1&quot;,\n        &quot;unit&quot;: &quot;Lux&quot;\n      }\n    }\n  ],\n  &quot;events&quot;: [],\n  &quot;actions&quot;: []\n}\n</code></pre><p><img src=\"https://static001.geekbang.org/resource/image/77/da/779d9d3f3c5f35a1490bbe91f2f4b7da.png?wh=1864*738\" alt=\"19.10\"></p><p>在“交互开发”标签页中，和智能电灯一样，我们仍然保持“使用官方小程序控制产品”选项是打开状态。另外，还有一个配置项需要关注，那就是“智能联动配置”，因为后面我们要为光照传感器设置联动场景。</p><p><img src=\"https://static001.geekbang.org/resource/image/76/7a/76c20e82ae392b96e52a0467381fbc7a.png?wh=1840*1256\" alt=\"19.11\"></p><p>我们点击“配置”，在设置页面中，就可以看到“光照度”这个属性，因为它是只读属性，所以只能作为联动的触发条件。我们勾选“作为条件”的选项，完成配置。</p><p><img src=\"https://static001.geekbang.org/resource/image/39/77/395790a876a9e616dafc107dcf872177.png?wh=1960*710\" alt=\"19.12\"></p><p>下一步，在“设备调试”界面中，我们创建一个测试设备。点击“新建设备”，输入设备名称“Lightsensor_1”。</p><p><img src=\"https://static001.geekbang.org/resource/image/ff/2a/ff73e5da081e581cb8cb1229e08e302a.png?wh=1864*518\" alt=\"19.13\"></p><p>创建成功后，在测试设备列表中，点击“Lightsensor_1”，进入设备的详情页面，我们可以看到设备三元组的信息。你需要将这些信息记录下来，因为后面的开发中需要使用。</p><p>在测试设备列表中，我们点击“二维码”操作，获取测试设备的二维码，以便在小程序“腾讯连连”中添加这个设备。</p><p>到这里，腾讯云平台上的产品创建工作就完成了。</p><h3>产品联网开发</h3><p>在腾讯云平台准备好产品的配置工作之后，我们继续在树莓派上完成北向的通信交互的开发工作。</p><p>在<a href=\"https://time.geekbang.org/column/article/322528\">第17讲</a>中，我们已经了解了MQTT通信的主题 Topic ，以及 Broker 服务器地址、端口号、设备ID（ClientID）、用户名（UserName）和密码（Password）等连接参数的知识。</p><p>我们还是可以使用<strong>sign.html</strong>这个网页工具生产用户名和密码，然后就能得到所有的参数。这时，把这些参数替换到下面这段代码的对应位置就可以了。</p><pre><code>#File: gateway.py\nfrom blescan import LightScanner, MiBeaconData\n\nimport time \nimport asyncio\nimport json\nimport uuid\nimport paho.mqtt.client as MQTTClient\n\n&quot;&quot;&quot;\nQCloud Device Info\n&quot;&quot;&quot;\nDEVICE_NAME = &quot;Lightsensor_1&quot;\nPRODUCT_ID = &quot;MAO3SVUCFO&quot;\nDEVICE_KEY = &quot;TYjuKNc2GpDykXUv4MWBOA==&quot;\n\n&quot;&quot;&quot;\nMQTT topic\n&quot;&quot;&quot;\nMQTT_CONTROL_TOPIC = &quot;$thing/down/property/&quot;+PRODUCT_ID+&quot;/&quot;+DEVICE_NAME\nMQTT_CONTROL_REPLY_TOPIC = &quot;$thing/up/property/&quot;+PRODUCT_ID+&quot;/&quot;+DEVICE_NAME\n\ndef mqtt_callback(client, userdata, msg):\n    # Callback\n    print(f&quot;Received `{msg.payload.decode()}` from `{msg.topic}` topic&quot;)\n\nasync def mqtt_connect():\n    #connect callback\n    def on_connect(client, userdata, flags, rc):\n        if rc == 0:\n            print(&quot;Connected to MQTT Broker!&quot;)\n        else:\n            print(&quot;Failed to connect, return code %d\\n&quot;, rc)\n\n    mqtt_client = None\n    MQTT_SERVER = PRODUCT_ID + &quot;.iotcloud.tencentdevices.com&quot;\n    MQTT_PORT = 1883\n    MQTT_CLIENT_ID = PRODUCT_ID+DEVICE_NAME\n    MQTT_USER_NAME = &quot;MAO3SVUCFOLightsensor_1;12010126;2OYA5;1609057368&quot;\n    MQTTT_PASSWORD = &quot;8f79b7f1b0bef9cde7fd9652383b6ff8bfeb8003cc994c64f3c8e069c11fd4c7;hmacsha256&quot;\n\n    mqtt_client = MQTTClient.Client(MQTT_CLIENT_ID)\n    mqtt_client.username_pw_set(MQTT_USER_NAME, MQTTT_PASSWORD)\n    mqtt_client.on_connect = on_connect\n    \n    mqtt_client.connect(MQTT_SERVER, MQTT_PORT, 60)\n\n    return mqtt_client\n\ndef mqtt_report(client, light_level):\n    client_token = &quot;clientToken-&quot; + str(uuid.uuid4())\n\n    msg = {\n        &quot;method&quot;: &quot;report&quot;,\n        &quot;clientToken&quot;: client_token,\n        &quot;params&quot;: {\n            &quot;Illuminance&quot;: light_level\n        }\n    }\n\n    client.publish(MQTT_CONTROL_REPLY_TOPIC, json.dumps(msg))\n\nasync def light_loop(mclient):\n\n    bles = LightScanner('Nodemcu')\n\n    mclient.subscribe(MQTT_CONTROL_TOPIC)\n    mclient.on_message = mqtt_callback\n\n    mclient.loop_start()\n\n    while True:\n        try:\n            data = bles.status_update()\n        except Exception as e:\n            print(&quot;BLE SCAN error:&quot;, e)\n            continue\n        \n        print(&quot;Light Level:&quot;, data.lightlevel)\n\n        mqtt_report(mclient, data.lightlevel)\n        \n        time.sleep(0.1)\n\nasync def main():\n    mqtt_client = None\n    # MQTT connection\n    try:\n        mqtt_client = await asyncio.wait_for(mqtt_connect(), 20)\n    except asyncio.TimeoutError:\n        print(&quot;mqtt connected timeout!&quot;)\n\n    if mqtt_client is not None:\n        await asyncio.gather(light_loop(mqtt_client))\n\nasyncio.run(main())\n</code></pre><h3>在树莓派上部署软件</h3><p>接下来，我们把代码文件gateway.py 和 blescan.py 两个文件也上传到树莓派的/home/pi/pi-gateway目录中。</p><p>同时，为了让程序作为后台服务运行，并且能够开机自启动，我们来做一个Pi Gateway Service。</p><p>首先，你需要新建一个service.sh脚本文件，内容如下：</p><pre><code>#!/bin/sh\nset -e\nSCRIPT_DIR=$( cd &quot;$( dirname &quot;$0&quot; )&quot; &gt;/dev/null 2&gt;&amp;1 &amp;&amp; pwd )\n\ncd &quot;$SCRIPT_DIR&quot;\nsudo python3 ./gateway.py &quot;$@&quot;\n</code></pre><p>然后，创建我们service的配置文件，内容如下：</p><pre><code>[Unit]\nDescription=Pi Gateway\nDocumentation=https://time.geekbang.org/column/intro/100063601\nAfter=network.target\n\n[Service]\nType=simple\nWorkingDirectory=/home/pi/pi-gateway\nExecStart=/home/pi/pi-gateway/service.sh\nRestart=always\n\n[Install]\nWantedBy=multi-user.target\n</code></pre><p>接着，把这两个文件上传到树莓派系统的/home/pi/pi-gateway目录中，并且运行下面命令，修改文件的属性。</p><pre><code>$ sudo chmod a+x service.sh \n$ sudo chmod a+x pi-gateway.service\n</code></pre><p>最后，执行下面的几条命令，为树莓派系统增添上 Pi Gateway 这个服务。</p><pre><code>$ sudo cp /home/pi/pi-gateway/pi-gateway.service /etc/systemd/system/\n$ sudo systemctl daemon-reload\n$ sudo systemctl start pi-gateway\n$ sudo systemctl status pi-gateway\n$ sudo systemctl enable pi-gateway\n</code></pre><p>到这里，网关程序已经在树莓派上运行起来。我们在腾讯云物联网平台上可以看到，光照传感器变为“在线”状态。</p><h2>设置场景联动</h2><p>在第17讲和第18讲的实战中，我们分别完成了智能电灯和光照传感器的开发，现在终于可以为它们设置场景联动了。</p><h3>场景联动任务分解</h3><p>我们希望实现的联动场景是，基于环境的光照强度自动控制电灯的开和关。具体来说，这个目标可以拆解为3个自动触发任务：</p><ol>\n<li>当光照强度大于1024Lux时，关闭电灯。</li>\n<li>当光照强度小于1024Lux时，打开电灯。</li>\n<li>至于光照强度等于1024Lux时，也打开电灯。</li>\n</ol><p>注意，这里的1024Lux是我自己选择的一个值，你可以根据房屋情况自己调整。</p><h3>联动设备准备</h3><p>如果你还没有在小程序中添加光照传感器设备，这时可以打开微信中的腾讯连连小程序，扫描上面云平台“设备调试”中保存的那个二维码，添加光照传感器测试设备“Lightsensor_1”。</p><p>现在你的小程序里面已经有了两个设备，如下图所示。</p><p><img src=\"https://static001.geekbang.org/resource/image/6c/a2/6c9d5793b7b42e26151315bfc4865ea2.png?wh=1125*2436\" alt=\"19.14\"></p><p>刚才我们已经在腾讯云物联网平台上，为光照传感器设置了“智能联动配置”。现在，我们来为智能电灯配置智能联动能力。</p><p>我们进入智能电灯的“交互开发”页面，打开下面的“智能联动配置”页面，然后，像下图显示的那样，把“电灯开关”的“作为任务”条件勾选上。</p><p><img src=\"https://static001.geekbang.org/resource/image/0e/2e/0ef30835ec3fa62c4968117c3f81372e.png?wh=1924*988\" alt=\"19.15\"></p><h3>联动任务创建</h3><p>然后，我们进入腾讯连连小程序，点击下面的“+”，选择“添加智能”，开始配置工作。</p><p><img src=\"https://static001.geekbang.org/resource/image/96/89/965f2898374796898f59bd8ff4774b89.png?wh=1125*2436\" alt=\"19.16\"></p><p>我们从弹框里选择“自动智能”，可以看到下图的配置界面：</p><p><img src=\"https://static001.geekbang.org/resource/image/41/9f/4112709af28b0a9a20f340035f85a09f.png?wh=1125*2436\" alt=\"19.17\"></p><p>首先，我们添加条件，选择光照传感器设备，然后就会看到光照度属性。我们先设置大于1024Lux的条件。</p><p><img src=\"https://static001.geekbang.org/resource/image/f2/4e/f23b76ed4df0352295754d09845a384e.png?wh=1125*2436\" alt=\"19.18\"></p><p>然后，我们添加任务，选择智能电灯设备后，可以看到电灯开关的属性，选择“关”，点击保存。</p><p><img src=\"https://static001.geekbang.org/resource/image/6b/eb/6bd677fe4e4d404ce547d47446c3f4eb.png?wh=1125*2436\" alt=\"19.19\"></p><p>这时，我们可以看到这个智能联动的条件和任务已经配置完成。腾讯连连小程序还支持配置“生效时间段”，可以限定智能联动在选定的时间段内运行。</p><p><img src=\"https://static001.geekbang.org/resource/image/9c/b5/9cdc8bb22865540b5148572a1698d0b5.png?wh=1125*2436\" alt=\"19.20\"></p><p>接下来，我们还可以设置一个主题图片和名称，这个根据喜好来就行了。</p><p><img src=\"https://static001.geekbang.org/resource/image/85/9d/856b5cc93cf8c90c22be43e5986ca69d.png?wh=1125*2436\" alt=\"\"></p><p>按照相同的方法，我们可以设置其他两个条件，如下图所示：</p><p><img src=\"https://static001.geekbang.org/resource/image/fa/97/fa1649f112046da7d44f0c5f5ede0c97.png?wh=1486*1456\" alt=\"\"></p><p>最终的智能联动，包括了刚才提到的3个不同的触发条件。</p><p><img src=\"https://static001.geekbang.org/resource/image/e3/9d/e35a3byybe3148926bfe228e200f759d.png?wh=1125*2436\" alt=\"\"></p><p>现在，你可以通过控制光照传感器的光照明暗（比如用手遮挡光敏元器件然后再把手拿开），来观察智能电灯的打开和关闭，检验功能是否正常。</p><h2>小结</h2><p>总结一下，在这一讲中，我介绍了利用树莓派打造网关，让光照传感器接入物联网平台的办法，并且带你实现了光照传感器和智能电灯的场景联动。你需要重点关注的内容有：</p><ol>\n<li>为了实现协议转换，树莓派的南向接口，也就是蓝牙功能，你可以基于bluepy软件包开发。这里实现的功能是扫描光照传感器的广播包，并按照MiBeacon蓝牙协议解析出光照强度的数值。</li>\n<li>北向接口要实现对接云平台的功能，这是基于MQTT协议实现的。你可以基于Eclipse paho的Python语言版本来开发MQTT Client的功能。</li>\n<li>场景联动一般由条件和任务组成。其中，条件和任务是从我们的设备中定义的智能联动配置中选择的。</li>\n</ol><p>为了避免光照的短暂变化，导致智能电灯的忽明忽暗，我将光照传感器的数据上报间隔设置得比较长。如果你有特殊的需求，可以修改光照传感器和网关程序中的参数来实现。</p><p>下一讲，我将讲解智能音箱的实现，并通过智能音箱控制智能电灯的开关。</p><h2>思考题</h2><p>最后，我给你留一个动手实践题。</p><p>在这一讲的场景联动中，我们实现了光照强度对电灯打开和关闭的自动控制。你可以通过光照强度的不同数值实现对智能电灯亮度，或者颜色的控制吗？</p><p>你可以动手设置一下，并且在留言区和我分享你的成果，同时，也欢迎你将这一讲分享给你的朋友，大家一起讨论学习。</p>",
                "article_title": "19 | 场景联动：智能电灯如何感知光线？（下）"
            },
            {
                "title": "20 | 智能语音：好玩的语音控制是怎么实现的？",
                "id": 325192,
                "content": "<p>你好，我是郭朝斌。</p><p>实战篇的前几讲，我们打造了联网智能电灯，并实现了跟光照传感器的场景联动。今天我们来玩一个更酷的，智能音箱。</p><p>智能音箱为我们提供了一种更加自然的交互方式，所以亚马逊的Echo产品一经问世，就迅速流行起来。与智能家居结合之后，它更是引起了行业巨头的注意，被认为是很有发展潜力的用户入口和平台级产品。</p><p>我们先不论智能音箱最终到底能不能发展成智能家居的平台级产品，至少这波热潮已经极大地推动了相关技术的发展，而且用户覆盖率也有了很大的提升。</p><p>这一讲我就为你介绍一下智能音箱的语音控制是怎么实现的，并且带你动手完成开发过程（如有需要，你可以根据<a href=\"https://shimo.im/sheets/D3VVPdwcYRhhQRXh/MODOC\">这份文档</a>自行采购相关硬件）。</p><h2>智能音箱的技术架构</h2><p>智能音箱主要涉及<strong>拾音</strong>、<strong>前端信号处理</strong>、<strong>语音识别</strong>、<strong>自然语言处理</strong>和<strong>语音合成</strong>等技术，现在一些产品甚至提供了声纹识别技术。</p><p>当然，智能音箱最重要的是提供各种功能，完成一些任务，比如控制电灯的开和关，这被称为<strong>技能</strong>。</p><p>整体的技术架构如下图所示：</p><p><img src=\"https://static001.geekbang.org/resource/image/2a/f5/2a01c24619120c4c464d975bb0e8e4f5.jpg\" alt=\"\"></p><p>接下来，我会逐个讲解这些技术组成。</p><h3>拾音</h3><p>拾音，就是通过<strong>麦克风</strong>获取你的语音。</p><p>我们都用微信发送过语音消息，手机就是通过麦克风来获取你说的话的，这么说起来，拾音好像很简单。但是，智能音箱应对的环境要更复杂，因为用户可能在比较远的地方下达语音指令。</p><!-- [[[read_end]]] --><p>因此，智能音箱上一般采用<strong>麦克风阵列</strong>（Mic Array），也就是按照一定规则排列的多个麦克风，比如下图展示的就是<a href=\"https://zh.ifixit.com/Teardown/Amazon+Echo+Teardown/33953\">Amazon Echo</a>由7个麦克风组成的阵列（绿色圆圈部分）。</p><p><img src=\"https://static001.geekbang.org/resource/image/83/f0/831c5e67ddb3cbdeda86c496317b8df0.jpg\" alt=\"\"></p><h3>前端语音信号处理</h3><p>在收集到声音信号后，还需要进行前端语音信号处理。只有经过处理，智能音箱才能获取到相对干净的语音信号，也才能提高后面的语音识别的准确率。</p><p>这些处理技术包括回声消除（Acoustic Echo Cancellaction, AEC）、噪音抑制（Noise Suppression，NS）、语音检测（Voice Activity Detection，VAD）、声源定位（Direction of Arrival estimation，DOA）、波束成型（Beamforming）和混响消除（Speech Dereverberation）等。</p><p><img src=\"https://static001.geekbang.org/resource/image/aa/71/aaffc6862eab6a9af9cb27ec6dacd971.jpg\" alt=\"\"></p><h3>语音唤醒</h3><p>语音唤醒（Keyword Spotting，KWS），就是通过特定的<strong>唤醒词</strong>来激活智能音箱，以便进行后续的语音交互任务。这样做一方面可以保护用户的隐私，因为只有唤醒后，音箱才收集和识别用户的语音信息，另一方面也可以简化语音的识别和理解，比如小米智能音箱的“小爱同学”就是这样的唤醒词。</p><h3>语音识别</h3><p>语音识别（Automatic Speech Recognition，ASR），主要完成的任务是将语音转换成文本，所以也被称为STT（Speech to Text）。</p><h3>自然语言理解</h3><p>自然语言理解（Natural Language Understanding，NLU），是对语音识别生成的文本进行处理，识别用户的意图，并生产结构化的数据。</p><p>当然，以现在的人工智能发展水平来看，自然语言理解还有很长的路要走。这也是我们常发现智能音箱不够“智能”的原因。</p><h3>技能</h3><p>技能（Skills）一般要借助后端云平台的强大能力，云平台可以提供知识图谱、家居设备远程控制和音乐等音频资源等能力。</p><h3>自然语言生成</h3><p>自然语言生成（Natural Language Generation，NLG），就是将各种技能的响应结果组织成文本语言。比如当你询问天气时，根据获取的天气状况和温度等信息生成“北京今天晴，最高温度5°，最低温度-6°”这样的语句。自然语言生成和自然语言理解都属于<strong>自然语言处理</strong>（Natural Language Processing，NLP）的范畴。</p><h3>语音合成</h3><p>语音合成（Speech Synthesis），就是将自然语言生成的文本转换为语音的形式，提供给智能音箱播放出来，给人的感觉就像和音箱在对话。因此，这个过程也叫做TTS（Text to Speech）。</p><h2>智能音箱的开发</h2><p>了解完智能音箱的基本技术构成，下面我们就基于树莓派开发一个自己的简易智能音箱吧。</p><p>首先，我需要说明一下树莓派的系统。为什么呢？因为在<a href=\"https://time.geekbang.org/column/article/320675\">第15讲</a>中，我们安装了Gladys Assistant系统镜像，而这个系统Raspbian是基于Debian buster版本的，一些语音识别开源库对于buster的支持并不够好。</p><p>所以，如果你的树莓派是Raspberry Pi 3系列，强烈建议你把系统镜像切换成<strong>Debian stretch</strong>版本。通过<a href=\"https://downloads.raspberrypi.org/raspbian/images/raspbian-2019-04-09/\">这个链接</a>就可以下载基于Debian stretch版本的Raspbian镜像文件压缩包，安装还是使用Etcher工具，你可以回头看一下第15讲的介绍。</p><p>至于树莓派Raspberry Pi 4系列，因为官方系统Raspbian只有buster版本支持，所以我们还是继续基于第15讲的系统开发。</p><h3>麦克风阵列</h3><p>麦克风阵列我使用的是<strong>ReSpeaker 2-Mics Pi HAT</strong>，它的2个麦克风分布在模组的两边。我们现在来配置一下，让它可以在树莓派上正常工作。</p><p>你可以通过下面的命令安装它的驱动程序。首先，你最好切换一下树莓派的软件安装源，将它切换到国内的腾讯云安装源，这样下载安装的速度比较快。运行下面的命令修改配置文件：</p><pre><code>$ sudo vim /etc/apt/sources.list\n</code></pre><p>将文件修改为下面的内容：</p><pre><code>deb https://mirrors.cloud.tencent.com/raspbian/raspbian/ buster main contrib non-free rpi\n# Uncomment line below then 'apt-get update' to enable 'apt-get source'\ndeb-src https://mirrors.cloud.tencent.com/raspbian/raspbian/ buster main contrib non-free rpi\n</code></pre><p>修改另一个软件安装源的配置文件，命令如下所示：</p><pre><code>$ sudo vim /etc/apt/sources.list.d/raspi.list \n</code></pre><p>修改后的文件内容如下：</p><pre><code>deb https://mirrors.cloud.tencent.com/raspberrypi/ buster main\n# Uncomment line below then 'apt-get update' to enable 'apt-get source'\ndeb-src https://mirrors.cloud.tencent.com/raspberrypi/ buster main\n</code></pre><p>然后，你需要运行下面的命令更新安装源：</p><pre><code>$ sudo apt-get clean all\n$ sudo apt-get update\n</code></pre><p>现在，你可以运行下面命令安装麦克风阵列的驱动程序。因为这个驱动依赖的wm8960 编解码器没有包含在树莓派系统的内核里面，需要重新加载内核，编译驱动，所以整个过程比较久。在等待的过程中，你可以先阅读这一讲的其他部分。</p><pre><code>$ sudo apt-get install git\n$ git clone --depth=1 https://github.com/respeaker/seeed-voicecard\n$ cd seeed-voicecard\n$ sudo ./install.sh\n$ sudo reboot\n</code></pre><p>树莓派重启之后，你可以在树莓派终端输入下面的命令，查看音频的输入和输出设备是否正常工作。</p><pre><code>$ arecord -l\n$ aplay -l\n</code></pre><p><img src=\"https://static001.geekbang.org/resource/image/ef/54/ef1645e03ef2ba2e2c78edf6a9804e54.png\" alt=\"\"></p><p>如果一切正常，我们就可以测试录音和播放功能了。在ReSpeaker 2-Mics Pi HAT的耳机插口上插入耳机或者扬声器，运行下面的命令，并说几句话。</p><pre><code>$ arecord -d 5 test.wav\n$ aplay test.wav \n</code></pre><p>另外，你也可以通过软件<strong>AlsaMixer</strong>（命令alsamixer）来配置声音设置和调整音量，左、右箭头键用于选择通道或设备，向上、向下箭头控制当前所选设备的音量。退出程序使用ALT + Q，或者按Esc键。</p><p>为了简化开发，也考虑到麦克风硬件的限制，我们这里就先不关注前端语音信号处理的相关开发了。接下来，我们直接来到实现语音唤醒的环节。</p><h3>语音唤醒</h3><p>为了实现语音唤醒，我们需要选择一个轻量级的、可以在树莓派上运行的唤醒词监测器软件。</p><p>你可能首先想到的是<strong>Snowboy</strong>，没错，它确实是一个非常流行的工具。不过，Snowboy团队在2020年初的时候宣布，2020年12月31日会停止提供服务，所以我们只能寻找替代方案。</p><p>我选择的是<a href=\"https://github.com/MycroftAI/mycroft-precise\">Mycroft Precise</a>，它是一个基于RNN神经网络的语音唤醒工具。</p><p>接下来，我们在树莓派安装Mycroft Precise。因为需要训练唤醒词模型，我们需要基于源代码来编译、安装。</p><p>首先，我们通过git命令把Mycroft Precise的源代码下载到树莓派的/home/pi目录：</p><pre><code>$ cd ~\n$ git clone https://github.com/mycroftai/mycroft-precise\n$ cd mycroft-precise\n</code></pre><p>在安装之前，把pypi的安装源修改到清华数据源，可以获得更快的下载速度。我们打开目录中的setup.sh文件：</p><pre><code>$ vim setup.sh\n</code></pre><p>将文件中的这行内容：</p><pre><code>extra-index-url=https://www.piwheels.org/simple\n</code></pre><p>替换成下面的内容：</p><pre><code>index-url=https://pypi.tuna.tsinghua.edu.cn/simple\nextra-index-url=https://www.piwheels.org/simple\n</code></pre><p>然后，我们运行它自带的安装脚本，开始编译和安装。中间如果执行中断，可以重新执行这个命令，继续安装过程。（提示：有些ARM平台的库只有piwheels上有，所以这些库安装时速度还是很慢。这种情况下，可以电脑上使用下载工具获取这个模块的安装文件，然后上传到树莓派上，手动安装。）</p><pre><code>$ ./setup.sh\n</code></pre><p>安装完成后，我们开始使用Mycroft Precise来训练一个唤醒词模型，唤醒词可以根据喜好来选择，比如“极客时间”。</p><p>我们需要先激活Python的虚拟环境，因为Mycroft Precise在安装过程中创建了这个虚拟环境。</p><pre><code>$ source .venv/bin/activate\n</code></pre><p>接下来，我们通过工具precise-collect来收集语音模型训练的声音素材，运行后，根据提示录制12段声音。</p><pre><code>$ precise-collect\nAudio name (Ex. recording-##): geektime.##\n\nPress space to record (esc to exit)...\nRecording...\nSaved as geektime-00.wav\nPress space to record (esc to exit)...\n</code></pre><p>然后，我们需要将这些声音随机分为两份，一份是训练样本，包括8个声音文件，另一份是测试样本，包括4个声音文件，并且把这两份样本分别放到geektime/wake-word/和/geektime/test/wake-word/这两个目录下面。</p><p>接着，我们执行下面的命令，生成神经网络模型geektime.net：</p><pre><code>$ precise-train -e 60 geektime.net geektime/\n</code></pre><p>最后，我们还需要将geektime.net的模型格式做一下转换，将它从Keras模型格式改为TensorFlow模型格式，因为TensorFlow模型更加通用。</p><pre><code>$ precise-convert geektime.net\n</code></pre><p>执行完成之后，我们会得到两个文件：</p><ol>\n<li>geektime.pb，TensorFlow模型文件</li>\n<li>geektime.pb.params，包含Mycroft Precise在处理音频时需要的一些参数信息。</li>\n</ol><p>当然，为了提高模型的准确性，我们还可以使用precise-train-incremental工具来增加负样本，重新训练刚才的模型。如果环境复杂的话，你可以尝试一下。</p><p>然后，我们可以运行一段代码来测试这个唤醒词模型。不过，因为portaudio这个库在树莓派上运行有问题，我们需要先修复一下portaudio库。你可以运行下面的命令：</p><pre><code>$ sudo apt-get remove libportaudio2\n$ sudo apt-get install libasound2-dev\n$ git clone -b alsapatch https://github.com/gglockner/portaudio\n$ cd portaudio\n$ ./configure &amp;&amp; make\n$ sudo make install\n$ sudo ldconfig\n</code></pre><p>测试程序的代码如下：</p><pre><code># File：kwsdemo.py\n#!/usr/bin/env python3\n\nfrom precise_runner import PreciseEngine, PreciseRunner\n\nengine = PreciseEngine('precise-engine/precise-engine', 'geektime.pb')\nrunner = PreciseRunner(engine, on_activation=lambda: print('hello'))\nrunner.start()\n\n# Sleep forever\nfrom time import sleep\nwhile True:\n    sleep(10)\n</code></pre><p>现在，我们把kwsdemo.py文件，还有两个geektime.pb模型相关的文件，都上传到树莓派的Mycroft Precise目录下，然后运行kwsdemo.py文件，说出“极客时间”几个字，就会看到终端显示出“hello”这个单词。</p><h3>语音识别</h3><p>对于语音识别，我们直接采用腾讯云提供的语音识别SDK来完成（你需要提前在腾讯云控制台开通这个服务）。它会将语音发送到云端，由云端服务器计算出文本信息。你可以通过下面命令来安装：</p><pre><code>$ pip3 install tencentcloud-sdk-python\n</code></pre><p>在开始使用之前，你需要访问<a href=\"https://console.cloud.tencent.com/cam/capi\">这个链接</a>创建一个密钥，然后记录下SecretId和SecretKey的信息。</p><p>你可以参考下面的代码，来完成一个录音文件的识别。</p><pre><code>from tencentcloud.common import credential\nfrom tencentcloud.common.profile.client_profile import ClientProfile\nfrom tencentcloud.common.profile.http_profile import HttpProfile\nfrom tencentcloud.common.exception.tencent_cloud_sdk_exception import TencentCloudSDKException \nfrom tencentcloud.asr.v20190614 import asr_client, models \nimport base64\nimport io \nimport sys \n\nSECRET_ID = &quot;你的Secret ID&quot;\nSECRET_KEY = &quot;你的Secret Key&quot;\n\ntry: \n    cred = credential.Credential(SECRET_ID, SECRET_KEY) \n    httpProfile = HttpProfile()\n    httpProfile.endpoint = &quot;asr.tencentcloudapi.com&quot;\n    clientProfile = ClientProfile()\n    clientProfile.httpProfile = httpProfile\n    clientProfile.signMethod = &quot;TC3-HMAC-SHA256&quot;  \n    client = asr_client.AsrClient(cred, &quot;ap-beijing&quot;, clientProfile) \n    #读取文件以及 base64\n    with open('./geektime-00.wav', &quot;rb&quot;) as f:\n        if sys.version_info[0] == 2:\n            content = base64.b64encode(f.read())\n        else:\n            content = base64.b64encode(f.read()).decode('utf-8')\n        f.close()\n    #发送请求\n    req = models.SentenceRecognitionRequest()\n    params = {&quot;ProjectId&quot;:0,&quot;SubServiceType&quot;:2,&quot;SourceType&quot;:1,&quot;UsrAudioKey&quot;:&quot;sessionid-geektime&quot;}\n    req._deserialize(params)\n    req.DataLen = len(content)\n    req.Data = content\n    req.EngSerViceType = &quot;16k_zh&quot;\n    req.VoiceFormat = &quot;wav&quot;\n    resp = client.SentenceRecognition(req) \n    print(resp.to_json_string()) \n\nexcept TencentCloudSDKException as err: \n    print(err)\n</code></pre><h3>语音合成</h3><p>接下来，我来介绍一下语音合成。</p><p>你可能会问，刚才介绍技术架构的时候，不是还讲了自然语言理解、技能和自然语言生成吗？这里怎么跳过去了呢？</p><p>首先，因为我们的任务很简单，只需要查询语音识别的文本中是否有“开”、“灯”，和“关”、“灯”就可以完成判断，所以自然语言理解直接判断字符串是否匹配即可。</p><p>其次，我们要实现控制智能电灯，这个技能我在后面会介绍。</p><p>最后，智能音箱只需要反馈执行开关灯的结果就可以，比如“我已经把灯打开了”或者“我已经把灯关了”，自然语言生成的部分按照固定的文本就可以了，不需要考虑动态生成的问题。</p><p>语音合成，就是我们希望把类似“我已经把灯关了”这样的文本信息，转换为音频，便于智能音箱播放出来。你可以基于离线的TTS引擎来实现，比如<a href=\"https://github.com/junzew/HanTTS\">HanTTS</a>这个项目。</p><p>当然，我们也可以使用腾讯云的语音合成服务（你需要提前在腾讯云控制台开通这个服务）。你可以参考下面的代码：</p><pre><code>import json\nimport base64\n\nfrom tencentcloud.common import credential\nfrom tencentcloud.common.profile.client_profile import ClientProfile\nfrom tencentcloud.common.profile.http_profile import HttpProfile\nfrom tencentcloud.common.exception.tencent_cloud_sdk_exception import TencentCloudSDKException\nfrom tencentcloud.tts.v20190823 import tts_client, models\n\nSECRET_ID = &quot;你的Secret ID&quot;\nSECRET_KEY = &quot;你的Secret Key&quot;\n\ntry: \n    cred = credential.Credential(SECRET_ID, SECRET_KEY) \n    httpProfile = HttpProfile()\n    httpProfile.endpoint = &quot;tts.tencentcloudapi.com&quot;\n\n    clientProfile = ClientProfile()\n    clientProfile.httpProfile = httpProfile\n    client = tts_client.TtsClient(cred, &quot;ap-beijing&quot;, clientProfile) \n\n    req = models.TextToVoiceRequest()\n    params = {\n        &quot;Text&quot;: &quot;我已经把灯关了&quot;,\n        &quot;SessionId&quot;: &quot;sessionid-geektime&quot;,\n        &quot;ModelType&quot;: 1,\n        &quot;ProjectId&quot;: 0,\n        &quot;VoiceType&quot;: 1002\n    }\n    req.from_json_string(json.dumps(params))\n\n    resp = client.TextToVoice(req) \n    print(resp.to_json_string()) \n\n    if resp.Audio is not None:\n        audio = resp.Audio\n        data = base64.b64decode(audio)\n        wav_file = open(&quot;temp.wav&quot;, &quot;wb&quot;)\n        wav_file.write(data)\n        wav_file.close()\n\nexcept TencentCloudSDKException as err: \n    print(err)\n</code></pre><h2>通过智能音箱控制电灯</h2><p>为了实现控制智能电灯的目的，我们需要借助物联网平台提供的开发接口。</p><p>首先，我们进入物联网开发平台，选择“智能家居”项目。</p><p><img src=\"https://static001.geekbang.org/resource/image/77/49/77f96b642b6d5a077865b40904c59a49.png\" alt=\"\"></p><p>然后，点击左侧的“应用开发”，进入新建应用的界面，点击“新建应用”。</p><p><img src=\"https://static001.geekbang.org/resource/image/26/d3/2630643ca6202249d3e4e7ba52e226d3.png\" alt=\"\"></p><p>完成后，点击应用列表里面的应用名称，进入应用的详情页面。你可以看到应用的SecretId和SecretKey信息。这里，你需要将下面“关联产品”中的智能电灯勾选上。只有建立关联，应用才可以控制这个设备。</p><p><img src=\"https://static001.geekbang.org/resource/image/6f/a2/6f93dbacdaa2d6573f6a183905d44da2.png\" alt=\"\"></p><p>具体代码可以参考腾讯提供的开源实现，包括<a href=\"https://github.com/tencentyun/iot-link-ios/tree/master/Source/LinkApp\">iOS</a>、<a href=\"https://github.com/tencentyun/iot-link-android/tree/master/app\">Android</a>和<a href=\"https://github.com/tencentyun/qcloud-iotexplorer-appdev-miniprogram-sdk-demo\">小程序</a>。</p><p>不过，这种方式需要用户账号的登录认证，在树莓派上不太方便。还有一个方式就是基于物联网开发平台提供的通用API接口。其中的“<a href=\"https://cloud.tencent.com/document/product/1081/34973\">设备远程控制</a>”接口可以满足我们的需求。</p><p>具体的控制方法，你可以参考下面的代码（注意，目前只支持ap-guangzhou区域）。</p><pre><code>import json\nfrom led2.main import PRODUCT_ID\nfrom tencentcloud.common import credential\nfrom tencentcloud.common.profile.client_profile import ClientProfile\nfrom tencentcloud.common.profile.http_profile import HttpProfile\nfrom tencentcloud.common.exception.tencent_cloud_sdk_exception import TencentCloudSDKException\nfrom tencentcloud.iotexplorer.v20190423 import iotexplorer_client, models\n\nSECRET_ID = &quot;你的Secret ID&quot;\nSECRET_KEY = &quot;你的Secret Key&quot;\nPRODUCT_ID = &quot;你的ProductID&quot;\n\ndef Light_control(state):\n    try: \n        cred = credential.Credential(SECRET_ID, SECRET_KEY) \n        httpProfile = HttpProfile()\n        httpProfile.endpoint = &quot;iotexplorer.tencentcloudapi.com&quot;\n\n        clientProfile = ClientProfile()\n        clientProfile.httpProfile = httpProfile\n        client = iotexplorer_client.IotexplorerClient(cred, &quot;ap-guangzhou&quot;, clientProfile) \n\n        req = models.ControlDeviceDataRequest()\n        data = {\n            &quot;power_switch&quot;: state\n        }\n        data_str = json.dumps(data)\n\n        params = {\n            &quot;DeviceName&quot;: &quot;Led_1&quot;,\n            &quot;ProductId&quot;: PRODUCT_ID,\n            &quot;Data&quot;: data_str\n        }\n        req.from_json_string(json.dumps(params))\n\n        resp = client.ControlDeviceData(req) \n        print(resp.to_json_string()) \n\n    except TencentCloudSDKException as err: \n        print(err) \n\nLight_control(0)\n</code></pre><h2>小结</h2><p>总结一下，在这一讲中，我介绍了智能音箱的技术架构，以及在树莓派上用于实现智能音箱的一些可选的技术方案，并且带你实现了语音控制智能电灯的目的。你需要重点关注的知识有：</p><ol>\n<li>智能音箱的实现，需要前端音箱本体和后端云平台上一系列技术的支持。这些技术有前端的拾音、语音信号处理、语音唤醒和播音，以及后端的语音识别、自然语言理解、技能、自然语言生成和语音合成。</li>\n<li>在树莓派的实现上，拾音可以选择使用麦克风阵列，因为基于麦克风阵列可以更好地实现前端语音信号处理，比如声源定位和波束成型等。</li>\n<li>语言唤醒需要在智能音箱本体上实现，所以需要一些轻量级的识别引擎和训练好的唤醒词模型。之前比较流行的Snowboy将要停止服务，这里我选择了Mycroft Precise这个开源方案。</li>\n<li>语音识别、自然语言理解、技能、自然语言生成和语音合成等任务适合基于云平台的能力来实现，因为云平台的计算能力更强，有更好的性能和准确度。</li>\n</ol><p>智能音箱的技术也一直在发展，比如现在越来越多的智能音箱开始配备屏幕和摄像头，这为智能音箱引入了声音、UI和视觉等多模态的交互方式，相应地，这也给声纹识别、人脸识别和动作识别等技术带来了新的应用场景。我相信智能音箱未来的产品形态和功能还会不断地进化和发展。</p><h2>思考题</h2><p>最后，我给你留一个思考题吧。</p><p>在这一讲中，我们是通过物联网平台提供的API接口来控制智能电灯的。除了这种方式，你还能想到其他的方法来远程控制智能电灯吗？你能实现一个虚拟的联网开关，基于场景联动来控制智能电灯的开和关吗？</p><p>欢迎你在留言区写下你思考的结果，也欢迎你将这一讲分享给你的朋友，大家一起交流学习。</p>",
                "article_title": "20 | 智能语音：好玩的语音控制是怎么实现的？"
            },
            {
                "title": "21 | 多传感器集成：浇花怎么实现自动化？",
                "id": 326153,
                "content": "<p>你好，我是郭朝斌。</p><p>在前几讲的实战中，我们已经完整地实现了一个智能家居的照明场景。你不但可以用手机小程序控制智能电灯的开关、亮度和颜色，也能让智能电灯根据光照强度自动地打开和关闭，甚至你还可以语音来操控它。</p><p>在这个过程中，你应该已经掌握了基于硬件开发板快速地开发智能硬件的方法。这一讲中，我们就围绕<strong>自动浇花</strong>，做一个新的智能家居场景解决方案，同时也巩固一下你在前几讲学习到的硬件开发知识（如有需要，你可以根据<a href=\"https://shimo.im/sheets/D3VVPdwcYRhhQRXh/MODOC\">这份文档</a>自行采购相关硬件）。</p><h2>研究场景需求</h2><p>在设计物联网产品的时候，我们需要先研究场景需求，明确监控指标，再根据这些指标安排合适的传感器。</p><p>比如自动浇花这个场景，很明显是为了自动控制水泵，及时给植物补充<strong>水分</strong>。毕竟水不仅是植物体的主要成分，支撑着细胞、维持着植物形态，而且也是传输营养物质的重要载体。所以，我们要监控的最重要的指标就是<strong>土壤湿度</strong>。</p><p>不过，用户的目的并不只是浇水而已，他们真正想要的，是看到自己养的植物健康地生长，所以我们最好把其他相关的数据也提供给他们。现在很多智能体重秤都会同时检测你的体脂率等其他反映身体健康的指标，也是一样的道理。</p><p>那么，植物生长还需要什么条件呢？</p><p><img src=\"https://static001.geekbang.org/resource/image/12/38/125935bdc5a8f747884871d6f7fd5c38.jpg\" alt=\"\"></p><p>首先是<strong>环境温湿度条件</strong>，热带的植物无法忍受低温和干燥的环境条件，而温带植物遇到高温，也可能出现热衰竭的现象，所以环境的<strong>温度</strong>和<strong>湿度</strong>最好也能监控。</p><!-- [[[read_end]]] --><p>其次是<strong>光照条件</strong>，毕竟要植物进行光合作用嘛，所以<strong>光照强度</strong>需要监控。</p><p>最后，<strong>空气质量</strong>对植物的生长来说也很重要，比如<strong>二氧化碳</strong>是否充足，<strong>有害气体</strong>是否超标等。</p><p>不过考虑到家居环境，空气质量在日常种植过程中一般没有问题，不需要特别关注。当然，你也可以作为扩展任务来尝试一下。</p><p>所以综合来看，我们需要监控的指标包括土壤湿度、环境温湿度和光照强度。相比于市面上其他只能控制浇水的产品，我们的产品考虑的场景就更加全面了。这也是自己动手（DIY）的好处。</p><h2>硬件电路</h2><p>明确了监控指标之后，相应的传感器也就可以确定了，分别是土壤湿度传感器、环境温湿度传感器和光照传感器。</p><p>下面，我总结一下自动浇花器需要用到的材料：</p><ol>\n<li>NodeMCU ESP32 开发板。不过，这里我们可以使用Wi-Fi来连接网络，而不是第18讲中用到的蓝牙技术。因为在现实中，考虑到自动浇花器的工作环境，连接电源还是比较常见的。</li>\n<li>继电器，用于控制水泵的供电电路的通断。</li>\n<li>水泵，用于从水箱中抽水，并送到花盆中。</li>\n<li>电池盒，用于给水泵供电。</li>\n<li>土壤湿度传感器，它可以测量花盆土壤的湿度，然后输出模拟信号。</li>\n<li>环境温湿度传感器，它基于DHT11传感器，用于测量房屋中的温度和湿度，并且输出数字信号。它采用单总线（1-wire）接口与NodeMCU连接。</li>\n<li>光照传感器，它可以测量花盆位置接收到的光照条件。每种植物有喜阳光、耐阴等不同的特性，光照度和一段时间的光照累积量可以给我们提供参考，以便更好地满足植物的光照需求。</li>\n<li>面包板和杜邦线。</li>\n</ol><p>这里，我给出了一个电路图，方便你了解整个自动浇花器的设备组成。</p><p><img src=\"https://static001.geekbang.org/resource/image/27/2d/276ff8040178c4f6ef7bdc347c27102d.png\" alt=\"\"></p><h2>软件实现</h2><p>接下来，我们还是使用Python语言来完成软件的开发工作。</p><h3>继电器</h3><p>首先是继电器的控制。它和<a href=\"https://time.geekbang.org/column/article/322528\">第17讲</a>介绍的智能电灯的继电器控制方法没有本质区别，主要是改变了连接的GPIO管脚。根据硬件电路的连线，这里我们使用的是GPIO23管脚。</p><p>我把代码直接贴在文稿中，供你参考（它连接的管脚是<strong>GPIO23</strong>）：</p><pre><code>## ！！！本文件采用商城的继电器模块FL-3FF-S-Z\n## ！！！on(), off()状态相反。\n## ！！！初始化中需要调用on()先关闭水泵电路\nfrom machine import Pin\n\nclass Relay():\n    ON = 0\n    OFF = 1\n\n    def __init__(self, pin):\n        self.relaypin = Pin(pin, Pin.OUT)\n        self.relaypin.on()\n        self.last_status = self.OFF\n\n    def set_state(self, state):\n        tmp_state = self.ON if state==1 else self.OFF\n        self.relaypin.value(tmp_state)\n        self.last_status = tmp_state\n\n    def state(self):\n        return self.last_status\n    def on(self):\n        self.relaypin.value(self.ON)\n        self.last_status = self.ON\n\n    def off(self):\n        self.relaypin.value(self.OFF)\n        self.last_status = self.OFF\n</code></pre><h3>土壤湿度传感器</h3><p>然后是土壤湿度传感器，我采用的是基于测量电阻值的变化来判断土壤水分含量的传感器模块。它会根据不同的电阻值，输出变化的模拟信息，数值越小，说明越干燥。使用的时候，你需要把它完全插入花盆的土壤中。</p><p>另外，还有一种基于土壤湿度变化，引起电容值变化的原理设计的<a href=\"https://wiki.dfrobot.com/Capacitive_Soil_Moisture_Sensor_SKU_SEN0193\">土壤湿度传感器</a>，你也可以考虑使用。它的好处是长期使用过程中不易腐蚀，因为没有裸露金属。</p><p>我把代码直接贴在文稿中，供你参考（它连接的管脚是<strong>GPIO34</strong>）：</p><pre><code>from machine import ADC\nfrom machine import Pin\n\nclass SoilSensor():\n\n    def __init__(self, pin):\n        self.sensor = ADC(Pin(pin))\n\n    def value(self):\n        value = self.sensor.read()\n        print(&quot;Sensor ADC value:&quot;,value)\n        return int(value*100/4095)\n</code></pre><h3>环境温湿度传感器</h3><p>我刚才介绍过，环境温湿度传感器是基于DHT11实现的，并且使用的是单总线的连接方式。不过代码的开发过程并不复杂，因为MicroPython已经为ESP32（也包括ESP8266）实现了DHT代码组件。我们可以直接使用。</p><p>注意，DHT11的单总线协议是奥松电子的<a href=\"https://cdn-shop.adafruit.com/datasheets/DHT11-chinese.pdf\">自定义协议</a>，它与Dallas半导体公司的OneWire协议是不同的。</p><p>代码我贴在下面，供你参考（它连接的管脚是<strong>GPIO14</strong>）：</p><pre><code>import dht\nfrom machine import Pin\n\nclass EnvSensor():\n\n    def __init__(self, pin):\n        self.sensor = dht.DHT11(Pin(pin))\n\n    def value(self):\n        self.sensor.measure()\n        return (self.sensor.temperature(), self.sensor.humidity())\n</code></pre><h3>光照传感器</h3><p>至于光照传感器，我们还可以继续使用<a href=\"https://time.geekbang.org/column/article/323428\">第18讲</a>的模组，所以我就不过多介绍了。</p><p>我直接贴出代码，供你参考（它连接的管脚是<strong>GPIO36</strong>）：</p><pre><code>from machine import ADC\nfrom machine import Pin\n\nclass IllumSensor():\n\n    def __init__(self, pin):\n        self.sensor = ADC(Pin(pin))\n\n    def value(self):\n        value = self.sensor.read()\n        print(&quot;Sensor ADC value:&quot;,value)\n        return int(value/4095*600\n</code></pre><h2>完成联网开发</h2><p>为了实现自动浇花器的联网控制，我们仍然需要将它接入腾讯云物联网平台。不过，我希望你能尝试独立完成这个工作。完成之后，你一定会感受到自己的成长。如果实现过程中有困难，可以回头参考第17讲的内容。</p><p>这里，我提供一下自动浇花器的物模型JSON文件，供你参考。</p><pre><code>{\n    &quot;version&quot;: &quot;1.0&quot;,\n    &quot;profile&quot;: {\n      &quot;ProductId&quot;: &quot;你的ProductID&quot;,\n      &quot;CategoryId&quot;: &quot;909&quot;\n    },\n    &quot;properties&quot;: [\n      {\n        &quot;id&quot;: &quot;power_switch&quot;,\n        &quot;name&quot;: &quot;水泵开关&quot;,\n        &quot;desc&quot;: &quot;控制水泵启动关闭&quot;,\n        &quot;mode&quot;: &quot;rw&quot;,\n        &quot;define&quot;: {\n          &quot;type&quot;: &quot;bool&quot;,\n          &quot;mapping&quot;: {\n            &quot;0&quot;: &quot;关&quot;,\n            &quot;1&quot;: &quot;开&quot;\n          }\n        }\n      },\n      {\n        &quot;id&quot;: &quot;water_shortage&quot;,\n        &quot;name&quot;: &quot;缺水状态&quot;,\n        &quot;desc&quot;: &quot;水箱是否缺水&quot;,\n        &quot;mode&quot;: &quot;r&quot;,\n        &quot;define&quot;: {\n          &quot;type&quot;: &quot;bool&quot;,\n          &quot;mapping&quot;: {\n            &quot;0&quot;: &quot;否&quot;,\n            &quot;1&quot;: &quot;是&quot;\n          }\n        }\n      },\n      {\n        &quot;id&quot;: &quot;humidity&quot;,\n        &quot;name&quot;: &quot;土壤湿度&quot;,\n        &quot;desc&quot;: &quot;当前的土壤湿度&quot;,\n        &quot;mode&quot;: &quot;r&quot;,\n        &quot;define&quot;: {\n          &quot;type&quot;: &quot;int&quot;,\n          &quot;min&quot;: &quot;0&quot;,\n          &quot;max&quot;: &quot;100&quot;,\n          &quot;start&quot;: &quot;0&quot;,\n          &quot;step&quot;: &quot;1&quot;,\n          &quot;unit&quot;: &quot;%&quot;\n        }\n      },\n      {\n        &quot;id&quot;: &quot;env_temp&quot;,\n        &quot;name&quot;: &quot;环境温度&quot;,\n        &quot;desc&quot;: &quot;空间环境的温度&quot;,\n        &quot;mode&quot;: &quot;r&quot;,\n        &quot;define&quot;: {\n          &quot;type&quot;: &quot;float&quot;,\n          &quot;min&quot;: &quot;-40&quot;,\n          &quot;max&quot;: &quot;100&quot;,\n          &quot;start&quot;: &quot;0&quot;,\n          &quot;step&quot;: &quot;0.1&quot;,\n          &quot;unit&quot;: &quot;℃&quot;\n        },\n        &quot;required&quot;: false\n      },\n      {\n        &quot;id&quot;: &quot;env_hum&quot;,\n        &quot;name&quot;: &quot;环境湿度&quot;,\n        &quot;desc&quot;: &quot;周围环境的湿度&quot;,\n        &quot;mode&quot;: &quot;r&quot;,\n        &quot;define&quot;: {\n          &quot;type&quot;: &quot;int&quot;,\n          &quot;min&quot;: &quot;0&quot;,\n          &quot;max&quot;: &quot;100&quot;,\n          &quot;start&quot;: &quot;0&quot;,\n          &quot;step&quot;: &quot;1&quot;,\n          &quot;unit&quot;: &quot;%&quot;\n        },\n        &quot;required&quot;: false\n      },\n      {\n        &quot;id&quot;: &quot;env_illum&quot;,\n        &quot;name&quot;: &quot;环境光照度&quot;,\n        &quot;desc&quot;: &quot;周围环境的光照度&quot;,\n        &quot;mode&quot;: &quot;r&quot;,\n        &quot;define&quot;: {\n          &quot;type&quot;: &quot;int&quot;,\n          &quot;min&quot;: &quot;0&quot;,\n          &quot;max&quot;: &quot;6000&quot;,\n          &quot;start&quot;: &quot;0&quot;,\n          &quot;step&quot;: &quot;1&quot;,\n          &quot;unit&quot;: &quot;lux&quot;\n        },\n        &quot;required&quot;: false\n      }\n    ],\n    &quot;events&quot;: [],\n    &quot;actions&quot;: []\n  }\n</code></pre><p>需要说明的一点是，其实DHT11的测温范围只有0～50℃，但这里设定的环境温度范围是-40℃～80℃。之所以这么设定，是因为另外一款温湿度传感器DHT22可以达到这个范围，这样当你想根据不同的环境条件灵活地调整温湿度传感器模块的时候，就不需要修改物模型了。</p><h2>多传感器融合</h2><p>在刚才的开发工作中，我们只使用了一个土壤湿度传感器来判断土壤的水分含量。先不考虑传感器本身的测量误差，单纯只测量土壤中一个位置的湿度数值，其实是不能准确反映整片土壤的水分情况的。</p><p>所以，我们可以使用多个土壤传感器进行测量，然后根据多个测量值来计算出更可靠的土壤水分含量。</p><p>这个计算过程就是<strong>多传感器融合</strong>（Multi-Sensor Fusion，MSF）。</p><p>它不仅在自动驾驶这样的前沿领域中成为了保证决策正确的关键技术，而且在日常生活中也已经有了广泛的应用，比如手机上的地理位置定位。</p><p>我们知道，GPS是通过卫星进行定位的，但是它的精度受到很多因素的影响。为了提高定位的精度，现在我们的手机上就普遍采用多传感器融合的方法，通过 GPS、蜂窝通信网基站和 Wi-Fi 热点的数据来综合计算，得到更准确的地理定位信息。</p><p>多传感器融合最关键的地方，不是多个传感器的<strong>硬件连接</strong>或<strong>数据收集</strong>，而是<strong>融合算法</strong>，也就是怎么进行多个不同维度的参数的处理，从而得到一个相对准确的、有意义的数据信息。</p><p>最基本的算法就是计算多个数值的加权平均值。适应性更广的算法有卡尔曼滤波和多贝叶斯估计等方法。</p><p><img src=\"https://static001.geekbang.org/resource/image/81/c1/8170f7fa73182f618b47afaecbdb35c1.jpg\" alt=\"\"></p><p>在条件允许的情况下，你可以尝试一下这个方法。毕竟NodeMCU丰富的ADC接口为我们提供了不错的实验条件。比如，你可以基于两个土壤湿度传感器，使用加权平均值算法优化自己的自动浇花器。</p><h2>小结</h2><p>总结一下，这一讲中，我介绍了自动浇花器的硬件电路参考设计和代码。你需要关注的主要内容有：</p><ol>\n<li>自动浇花器主要是通过检测土壤湿度来判断水分含量，然后基于水分含量来控制水泵电源通断来实现自动浇花的目的。</li>\n<li>环境温湿度传感器采用的是DHT11模组，它采用单总线的方式与控制芯片通信，这是奥松电子的<a href=\"https://cdn-shop.adafruit.com/datasheets/DHT11-chinese.pdf\">自定义协议</a>。不过，基于MicroPython开发的时候，我们不需要自己开发驱动，可以直接使用MicroPython提供的DHT库。</li>\n<li>联网的开发，我们可以继续基于腾讯云物联网平台来实现。我提供了物模型，希望你可以基于智能电灯的开发经验独立完成这个任务。</li>\n<li>多传感器融合是提高决策正确性的重要方法，其中融合算法是最关键的。</li>\n</ol><p>在实战篇，我们主要基于开源的开发板硬件来完成智能硬件的开发工作。这在工作中有很大的用处，因为当我们有新的产品想法时，可以快速地进行技术验证，甚至用户反馈。</p><p>这也就是<strong>最小可行性产品</strong>（Minimum Viable Product，MVP）方法论。在软件领域，这种方法比较常见，而基于硬件开发板，我们可以很好地验证智能硬件产品的可行性，为企业节约成本、降低风险。</p><h2>思考题</h2><p>最后，我给你留一个思考题吧。</p><p>在我提供的物模型里面，你应该可以看到“缺水状态”的属性。它可以用于指示水泵连接的水箱是不是已经缺水了，如果水箱水位不足，就会提醒我们及时给水箱补水。请你想一想，要怎么实现这个水位检测功能呢？请用文字描述一下你的思路。</p><p>欢迎你在留言区和我交流，也欢迎你将这一讲分享给你的朋友，大家一起交流学习。</p>",
                "article_title": "21 | 多传感器集成：浇花怎么实现自动化？"
            },
            {
                "title": "22 | 掌控数据：家里的数据可以怎么利用？",
                "id": 327968,
                "content": "<p>你好，我是郭朝斌。</p><p>到目前为止，我们已经完成智能电灯、光照传感器、智能音箱和自动浇花器的实战训练，在这个过程中，我们主要关注的是设备功能和远程控制的实现。</p><p>其实，物联网设备会生成大量的数据。如果我们能把这些数据存储到物联网系统的数据库中，并且好好应用这些数据，比如提供查询和分析功能，就能够产出更大的价值。</p><p>这一讲，我就基于自动浇花器来讲一讲数据的应用方法，主要包括以下两种：</p><ol>\n<li>基于腾讯云物联网平台提供的<strong>数据流</strong>功能，介绍一个<strong>设备消息推送应用</strong>的配置方法。</li>\n<li>基于腾讯云的<strong>HTTP方式的数据同步</strong>功能，开发一个<strong>Web数据应用系统</strong>。因为需要购买云服务器，所以你可以酌情选择是否实际部署。</li>\n</ol><h2>方法一：基于数据流的设备消息推送应用</h2><p>腾讯云物联网平台已经为我们提供了一种简便的数据应用方法。我们可以使用它的可视化编辑界面来完成数据流的创建工作。</p><p>你可以登录腾讯云物联网平台的<a href=\"https://console.cloud.tencent.com/iotexplorer\">控制台</a>，然后进入我们之前创建的“智能家居”项目，点击左边菜单栏中的“数据开发”。</p><p><img src=\"https://static001.geekbang.org/resource/image/13/3c/138e249c1d126a9b147f0e5e4068a43c.png\" alt=\"\"></p><p>然后，你需要新建一个数据流，名称可以是“自动浇花器”。点击数据流列表中的“自动浇花器”项目，你就可以进入可视化的编辑界面。</p><p><img src=\"https://static001.geekbang.org/resource/image/df/d0/dfffa9589666393a43a8b9fd6cebfed0.png\" alt=\"\"></p><p>在可视化编辑界面，我们可以看到，一个数据流包括“输入”“处理”和“输出”三个部分。</p><!-- [[[read_end]]] --><ol>\n<li>输入，包括设备数据、设备事件和设备状态三种，其中设备数据和设备事件与物模型中的定义是一致的。设备状态是设备的上线、下线的状态变化。</li>\n<li>处理，可以编写基本的判断逻辑来过滤输入数据。</li>\n<li>输出，可以作为消息将数据推送到App或者小程序中。你可以对消息的内容模板进行定义。</li>\n</ol><p>自动浇花器设备会上报环境的温度、湿度信息，那么我们可以定义一个温湿度不适宜的消息提醒。</p><p>你可以拖拽“设备数据”到编辑区域，然后点击这个模块，在右边的选项中定义设备数据，产品选择“自动浇花器”，属性选择“环境温度”和“环境湿度”。</p><p><img src=\"https://static001.geekbang.org/resource/image/20/f9/2033f1a7d6523523e9e53587c600e8f9.png\" alt=\"\"></p><p>接着，你可以添加“数据过滤”模块，并且将这个模块与“设备数据”模块相连，然后点击这个模块，在右边编辑过滤条件。</p><p><img src=\"https://static001.geekbang.org/resource/image/98/79/9818f8c65f3084e3888c6b8b32481079.png\" alt=\"\"></p><p><img src=\"https://static001.geekbang.org/resource/image/32/a8/32e69cf67e0ce0afb0c890e2455572a8.png\" alt=\"\"></p><p>完成数据过滤的定义后，你需要继续添加“公众号推送”模块，并且编辑消息推送的模板。具体的消息模板定义，你可以参考下面内容：</p><pre><code>环境温度、湿度不适宜：\n当前温度是$env_temp \n当前湿度是$env_hum \n当前时间是$timeStamp \n</code></pre><p><img src=\"https://static001.geekbang.org/resource/image/00/47/00bc33c4f76f24627c74de0704009447.png\" alt=\"\"></p><p>最后，点击页面上方的“保存”和“启用”，你就完成了数据流的定义。</p><p>如果你的自动浇花器设备是在线状态，那么当环境的温度或者湿度过高、过低时，你就会在腾讯连连小程序的消息列表中收到“告警”消息。</p><p><img src=\"https://static001.geekbang.org/resource/image/8b/7d/8b75bd0d379aae20bf5099f91106f77d.jpg\" alt=\"\"></p><h2>方法二：基于HTTP数据同步的Web数据应用</h2><p>物联网平台除了提供数据流的方式，还可以基于HTTP协议把数据推送到你指定的网址，比如你开发的Web服务器的网址。所以你也可以使用这种方式，更加灵活地利用物联网设备的数据。</p><h3>数据同步体验</h3><p>我们借助在线的Webhook服务，测试一下数据同步功能。</p><p>首先，打开<a href=\"https://webhook.site/\">webhook.site</a>网站，并且记录页面中显示的专属URL地址。</p><p>然后，你需要登录腾讯云物联网平台，进入我们之前创建的“智能家居”项目，再点击左边菜单栏中的“数据同步”，选择“HTTPS”标签。</p><p><img src=\"https://static001.geekbang.org/resource/image/bc/a7/bcd8b3bd706bfbb76f5f806e492438a7.png\" alt=\"\"></p><p>接着，点击“自动浇花器”对应的“设置”链接，在设置窗口，将webhook网站获取到的URL地址，粘贴在输入框。</p><p><img src=\"https://static001.geekbang.org/resource/image/ee/e2/eefc65fb6c6825ea9825fa75fee8eee2.png\" alt=\"\"></p><p>完成设置后，打开“生效状态”。</p><p><img src=\"https://static001.geekbang.org/resource/image/82/49/826161247a0456e3fb8f44e889d9d049.png\" alt=\"\"></p><p>在保证自动浇花器设备正常运行的情况下，你就可以在webhook网站的页面中看到设备上报的数据了。</p><p><img src=\"https://static001.geekbang.org/resource/image/a1/4b/a164cb71d5dd660b846511377ff9844b.png\" alt=\"\"></p><p>下面我来介绍一下用Python语言来开发Web服务器的方法。</p><p>因为购买云服务器需要费用，所以这个实战任务是选学内容，你可以在自己的电脑上实践一下Web服务器的开发过程，然后酌情考虑要不要部署到云服务器上。</p><h3>准备Django开发环境</h3><p>Django是一个流行的基于Python语言的Web开发框架。它提供了强大的功能，同时也简单易用。接下来，我们就基于Django来实现一个Web应用程序。</p><p>首先是在电脑上配置Django的开发环境，在终端上运行下面的命令安装Django，准备好需要用到的工具。</p><pre><code>$ pip3 install django\n</code></pre><p>安装完成后，你可以在终端上切换到一个代码开发目录，比如：</p><pre><code>$ cd ~/study/iot/geektime\n</code></pre><p>然后，直接使用Django提供的脚手架工具django-admin来创建一个项目：</p><pre><code>$ django-admin startproject watering_web\n</code></pre><p>这时，命令会创建一个名称为watering_web的目录。目录中包含manage.py、settings.py、urls.py、wsgi.py和asgi.py等几个项目“骨架”文件，其中：</p><ul>\n<li>manage.py是项目管理脚本，比如创建子应用、运行开发服务器等都可以通过它实现。</li>\n<li>settings.py是项目的整体配置文件。比如子应用的配置、数据库的配置等。</li>\n<li>urls.py是项目的全局路由声明文件。</li>\n<li>wsgi.py是WSGI（Python Web Server Gateway Interface的缩写）服务接口文件，是整个Django应用的调用入口。</li>\n<li>asgi.py是ASGI（Asynchronous Server Gateway Interface的缩写）服务接口文件。ASGI是WSGI的替代者，它增加了异步应用的能力。除了支持WSGI协议，同时对Websocket和HTTP2.0这些长连接方式的协议提供了支持。</li>\n</ul><p>现在，我们进入watering_web目录，运行下面的命令，就可以在电脑上启动这个项目的开发服务器了。</p><pre><code>$ python manage.py runserver\n</code></pre><p><img src=\"https://static001.geekbang.org/resource/image/8d/de/8d177591115a109be9dfb4bdddcbcede.png\" alt=\"\"></p><p>这非常有利于你的开发调试工作。比如，你可以在浏览器输入 <code>http://127.0.0.1:8000/</code> 随时访问Web应用的开发效果。</p><p><img src=\"https://static001.geekbang.org/resource/image/e6/0f/e61ab6ce1577c62fe7aaeb0b5923320f.png\" alt=\"\"></p><p>当你在浏览器上看到这个界面时，就说明Django应用的开发环境已经准备好了。下面，我们就来开发Web应用。</p><h3>Django应用开发</h3><h4>创建子应用watering</h4><p>首先，我们通过运行下面的命令，创建watering_web项目的子应用watering：</p><pre><code>$ python manage.py startapp watering\n</code></pre><p>这时，你应该可以看到项目目录下，新增加了watering的目录。目录中包含了watering子应用的基本代码模块。</p><ul>\n<li>admin.py是后台管理应用的配置文件，我们可以在其中增加数据库模型对象，让Django应用管理员能通过后台管理页面进行编辑。你在浏览器输入 <code>http://127.0.0.1:8000/admin/</code> 可以访问到后台管理应用。</li>\n<li>apps.py是子应用的配置文件。</li>\n<li>migrations是数据库迁移的文件目录，它下面会保存每次数据库迁移的中间文件。</li>\n<li>models.py是定义子应用的数据库数据模型文件。</li>\n<li>tests.py是子应用的单元测试代码文件。</li>\n<li>views.py是子应用的视图代码文件。</li>\n</ul><h4>理解Django的视图调用</h4><p>在Django里面，网页或者说HTTP的响应都是视图生成的，每个视图对应views.py中的一个函数。Django会根据HTTP请求的URL域名地址来选择相应的视图，而URL和视图函数的映射关系是在urls.py文件中定义的。</p><p>比如，你可以打开watering目录下的views.py文件，添加下面的函数：</p><pre><code>from django.http import HttpResponse\n\ndef demo(request):\n    return HttpResponse('Hello World!')\n</code></pre><p>然后，在watering目录下，新建一个urls.py文件，文件内容如下：</p><pre><code>from django.urls import path\n\nfrom . import views\n\nurlpatterns = [\n    path('demo', views.demo, name='demo'),\n]\n</code></pre><p>最后，在watering_web目录下的项目全局路由文件中，将urlpatterns的内容替换为下面的内容：</p><pre><code>from django.contrib import admin\nfrom django.urls import path, include\n\nurlpatterns = [\n    path('admin/', admin.site.urls),\n    path('', include('watering.urls')),\n]\n</code></pre><p>现在，你在浏览器输入地址<code>http://127.0.0.1:8000/demo</code>，就可以看看我们刚刚定义的demo视图的内容。</p><p><img src=\"https://static001.geekbang.org/resource/image/05/8d/05e33d8e7da78fd797c115255829508d.png\" alt=\"\"></p><h4>应用代码开发</h4><p>接下来，我们正式开始子应用的开发。</p><p>首先，我们需要定义数据库的数据模型。Django框架实现了ORM（Object-Relational Mapping，对象关系映射器）技术。你可以直接在Python代码中定义数据库的表结构。</p><p>基于这个定义，Django的migration工具能自动在数据库中创建相应的数据库表。在后面的部署阶段，我会讲解到具体的migration命令。</p><p>我把models.py的代码贴在文稿中，供你参考：</p><pre><code>from django.db import models\n\n# Create your models here.\nclass Watering(models.Model):\n    seq_no = models.IntegerField(blank=False, null=False)\n    device_name = models.CharField(max_length=64, blank=False)\n    product_id = models.CharField(max_length=64, blank=False)\n    power_switch = models.IntegerField(default=0)\n    humidity = models.IntegerField(default=0)\n    env_temp = models.FloatField(default=0.0)\n    env_hum = models.IntegerField(default=0)\n    env_illum = models.IntegerField(default=0)\n    timestamp = models.DateTimeField(auto_now=False)\n\n    def __str__(self):\n        return self.device_name + '_' + str(self.seq_no)\n</code></pre><p>有了数据模型之后，你就可以在views.py文件中开发视图，接收腾讯云物联网平台推送的HTTP请求，并且将数据存储到数据库中。</p><p>文稿中是我的示例代码，供你参考：</p><pre><code>from django.shortcuts import render\n\n# Create your views here.\nfrom django.http import HttpResponse, HttpResponseBadRequest\nfrom django.views.decorators.csrf import csrf_exempt\nfrom django.forms.models import model_to_dict\nimport json\nfrom datetime import datetime\nfrom tencentcloud.common import credential\nfrom tencentcloud.common.profile.client_profile import ClientProfile\nfrom tencentcloud.common.profile.http_profile import HttpProfile\nfrom tencentcloud.common.exception.tencent_cloud_sdk_exception import TencentCloudSDKException\nfrom tencentcloud.iotexplorer.v20190423 import iotexplorer_client, models\n\nSECRET_ID = &quot;你的Secret ID&quot;\nSECRET_KEY = &quot;你的Secret Key&quot;\nPRODUCT_ID = &quot;你的ProductID&quot;\n\nfrom .models import Watering\n\ndef build_response(resp, msg):\n    dict = {\n        &quot;resp&quot;: resp,\n        &quot;msg&quot;: msg,\n    }\n    return HttpResponse(json.dumps(dict), content_type='application/json')\n\ndef demo(request):\n    return HttpResponse('Hello World!')\n\n@csrf_exempt\ndef data_sync(request):\n    if request.method == 'POST':\n        json_data = json.loads(request.body.decode())\n    else:\n        return HttpResponseBadRequest('Bad Request')\n    \n    if 'seq' in json_data:\n        _seq = json_data['seq']\n    if 'devicename' in json_data:\n        _device_name = json_data['devicename']\n    if 'productid' in json_data:\n        _product_id = json_data['productid']\n    if 'timestamp' in json_data:\n        _timestamp = json_data['timestamp']\n    if 'payload' in json_data:\n        _payload = json_data['payload']\n        if 'method' in _payload and 'report' == _payload['method']:\n            _params = _payload['params']\n            _env_temp = _params['env_temp']\n            _env_hum = _params['env_hum']\n            _env_illum = _params['env_illum']\n            _humidity = _params['humidity']\n            _power_status = _params['power_switch']\n        \n            try:\n                Watering.objects.create(\n                    seq_no=_seq, device_name=_device_name, product_id=_product_id,\n                    power_switch=_power_status, humidity=_humidity,\n                    env_temp = _env_temp, env_hum = _env_hum, env_illum = _env_illum,\n                    timestamp=datetime.fromtimestamp(_timestamp) )\n                \n            except:\n                return HttpResponse('Insert Failed!')\n\n    return HttpResponse('OK')\n\n@csrf_exempt\ndef latest_data(request):\n    if request.method == 'POST':\n        json_data = json.loads(request.body.decode())\n    else:\n        return HttpResponseBadRequest('Bad Request')\n    \n    if 'devicename' in json_data:\n        _device_name = json_data['devicename']\n    else:\n        _device_name = None\n    \n    if _device_name is not None:\n        try:\n            data = Watering.objects.filter(device_name=_device_name).latest('timestamp')\n            data_dict = model_to_dict(data, fields=['seq_no','device_name','product_id','power_switch','humidity','env_temp','env_hum','env_illum'])\n            data_dict['timestamp'] = str(data.timestamp)\n            dict = {\n                &quot;resp&quot;: 0,\n                &quot;msg&quot;: &quot;OK&quot;,\n                &quot;data&quot;: data_dict\n            }\n            return HttpResponse(json.dumps(dict), content_type='application/json')\n        except Exception as e:\n            return build_response(1, str(e))\n    else:\n        return build_response(1, 'Parameter invalid.')\n</code></pre><p>为了能够控制自动浇花器的水泵打开和关闭，你也可以增加发送控制命令的视图。同样，你可以参考下面的代码：</p><pre><code>@csrf_exempt\ndef control_device(request):\n    if request.method == 'POST':\n        json_data = json.loads(request.body.decode())\n    else:\n        return HttpResponseBadRequest('Bad Request')\n    \n    if 'devicename' in json_data:\n        _device_name = json_data['devicename']\n    else:\n        _device_name = None\n    if 'status' in json_data:\n        _status = json_data['status']\n    else:\n        _status = None\n\n    if _device_name is not None and _status is not None:\n        try: \n            cred = credential.Credential(SECRET_ID, SECRET_KEY) \n            httpProfile = HttpProfile()\n            httpProfile.endpoint = &quot;iotexplorer.tencentcloudapi.com&quot;\n\n            clientProfile = ClientProfile()\n            clientProfile.httpProfile = httpProfile\n            client = iotexplorer_client.IotexplorerClient(cred, &quot;ap-guangzhou&quot;, clientProfile) \n\n            req = models.ControlDeviceDataRequest()\n            data = {\n                &quot;power_switch&quot;: _status\n            }\n            data_str = json.dumps(data)\n\n            params = {\n                &quot;DeviceName&quot;: _device_name,\n                &quot;ProductId&quot;: PRODUCT_ID,\n                &quot;Data&quot;: data_str\n            }\n            req.from_json_string(json.dumps(params))\n\n            resp = client.ControlDeviceData(req)\n\n            return build_response(0, resp.to_json_string())\n\n        except TencentCloudSDKException as err: \n            return build_response(1, str(err))\n\n    else:\n        return build_response(1, 'Parameter invalid.')\n</code></pre><p>完成视图的开发后，你需要更新urls.py文件中的urlpatterns，为新增视图添加映射关系。</p><pre><code>from django.contrib import admin\nfrom django.urls import path, include\n\nurlpatterns = [\n    path('admin/', admin.site.urls),\n    path('geektime/', include('watering.urls')),\n]\n</code></pre><p>同时，在watering子应用的目录增加一个urls.py文件，内容如下：</p><pre><code>from django.urls import path\n\nfrom . import views\n\nurlpatterns = [\n    path('demo', views.demo, name='demo'),\n    path('data', views.data_sync, name='data_sync'),\n    path('control', views.control_device, name='control_device'),\n    path('fetch', views.latest_data, name='latest_data'),\n]\n</code></pre><p>然后，我们来开发一个简单的网页，实现设备信息的显示和控制。为了便于理解，我这里只使用最基础的方法。当熟悉基本原理之后，你可以尝试使用VUE、React等前端应用框架来开发功能更丰富的Web前端应用。</p><p>我把代码贴在文稿中，供你参考：</p><pre><code>&lt;!doctype html&gt;\n&lt;html&gt;\n&lt;head&gt;\n&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot;&gt;\n&lt;meta content=&quot;webkit&quot; name=&quot;renderer&quot;&gt;\n&lt;meta content=&quot;width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0&quot; name=&quot;viewport&quot;&gt;\n&lt;meta content=&quot;IE=Edge,chrome=1&quot; http-equiv=&quot;X-UA-Compatible&quot;&gt;\n&lt;style type=&quot;text/css&quot;&gt;\n    th {\n    text-align: left;\n    }\n&lt;/style&gt;\n\n&lt;title&gt;Plant Watering&lt;/title&gt;\n&lt;script src=&quot;jquery-3.1.1.min.js&quot;&gt;&lt;/script&gt;\n&lt;/head&gt;\n\n&lt;body&gt;\n    &lt;h1&gt;Plant Watering&lt;/h1&gt;\n\n    &lt;table&gt;\n        &lt;tr&gt;\n            &lt;th&gt;Device Name: &lt;/th&gt;&lt;th id='devicename'&gt;&lt;/th&gt;\n        &lt;/tr&gt;\n\n        &lt;tr&gt;\n            &lt;th&gt;Date: &lt;/th&gt;&lt;th id='datetime'&gt;&lt;/th&gt;\n        &lt;/tr&gt;\n\n        &lt;tr&gt;\n            &lt;th&gt;Soil Moisture (&amp;#37;): &lt;/th&gt;&lt;th id='moisture'&gt;&lt;/th&gt;\n        &lt;/tr&gt;\n\n        &lt;tr&gt;\n            &lt;th&gt;Environment Temperature (℃): &lt;/th&gt;&lt;th id='envtemp'&gt;&lt;/th&gt;\n        &lt;/tr&gt;\n\n        &lt;tr&gt;\n            &lt;th&gt;Environment Humidity (&amp;#37;): &lt;/th&gt;&lt;th id='envhum'&gt;&lt;/th&gt;\n        &lt;/tr&gt;\n\n        &lt;tr&gt;\n            &lt;th&gt;Environment Illumination (Lux): &lt;/th&gt;&lt;th id='envillum'&gt;&lt;/th&gt;\n        &lt;/tr&gt;\n\n    &lt;/table&gt;\n\n    &lt;button id='on'&gt;Open&lt;/button&gt;\n    &lt;button id='off'&gt;Close&lt;/button&gt;\n\n    &lt;script type='text/javascript'&gt;\n        var timer = false\n        var interval = 5*1000   //5 seconds\n        var device_name = 'Watering_1'\n\n        $(&quot;#on&quot;).on('click',function(){\n            control(1)\n        })\n        $(&quot;#off&quot;).on('click',function(){\n            control(0)\n        })\n\n        function control(state){\n\n            var payload = {\n                &quot;devicename&quot;:device_name,\n                &quot;status&quot;:state\n            }\n\n            $.ajax({\n                url : &quot;http://159.75.214.14/geektime/control&quot;,\n                contentType: &quot;application/json; charset=utf-8&quot;,\n                method : 'POST',\n                dataType: &quot;json&quot;,\n                data: JSON.stringify(payload),\n                \n                success:function (obj) {\n\n                    if(obj.resp === 0){\n                        console.log(&quot;pump on&quot;);\n                    }\n                    else{\n                        console.log(obj.msg);\n                    }\n                },\n                error:function(e){\n                    console.log(&quot;control device post failed.&quot;);\n                }\n            })\n        }\n\n        function update_data(){\n            var payload = {\n                &quot;devicename&quot;:device_name,\n            }\n\n            $.ajax({\n                url : &quot;http://159.75.214.14/geektime/fetch&quot;,\n                contentType: &quot;application/json; charset=utf-8&quot;,\n                method : 'POST',\n                dataType: &quot;json&quot;,\n                data: JSON.stringify(payload),\n                \n                success:function (obj) {\n\n                    if(obj.resp === 0){\n                        console.log(&quot;fetch success&quot;);\n                        $(&quot;#devicename&quot;).text(device_name)\n                        $(&quot;#datetime&quot;).text(obj.data.timestamp)\n                        $(&quot;#moisture&quot;).text(obj.data.humidity)\n                        $(&quot;#envtemp&quot;).text(obj.data.env_temp)\n                        $(&quot;#envhum&quot;).text(obj.data.env_hum)\n                        $(&quot;#envillum&quot;).text(obj.data.env_illum)\n                    }\n                    else{\n                        console.log(obj.msg);\n                    }\n                },\n                error:function(e){\n                    console.log(&quot;fetch latest data failed.&quot;);\n                }\n            })\n        }\n\n        window.onload = function(){\n            update_data()   //Fetch data to get devicename first.\n            timer = setInterval(function(){\n                update_data()\n            }, interval)\n        }\n    &lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre><p>对于这些前端代码文件，你可以在watering_web项目的根目录下创建一个web目录，然后把它们放入这个目录下。</p><p>关于Django项目的settings.py文件，你需要在ALLOWED_HOSTS中增加自己服务器的IP地址。</p><pre><code>ALLOWED_HOSTS = [\n    '159.75.214.14',    #替换自己的云服务器IP\n]\n</code></pre><p>同时，在数据库的配置中，修改为MySQL的配置内容：</p><pre><code>DATABASES = {\n    # 'default': {\n    #     'ENGINE': 'django.db.backends.sqlite3',\n    #     'NAME': BASE_DIR / 'db.sqlite3',\n    # }\n    'default': {\n        'ENGINE': 'django.db.backends.mysql',\n        'NAME': 'geektime',\n        'USER': 'root',\n        'PASSWORD': 'geektime',\n        'HOST': '127.0.0.1',\n        'PORT': '3306',\n    }\n}\n</code></pre><h3>Django应用部署</h3><p>完成Django应用的开发，我们就可以把它部署到云服务器中。</p><p>首先，你需要先登录到<a href=\"https://console.cloud.tencent.com/\">腾讯云控制台</a>，从“云产品”中点击选择“云服务器”，进入云服务的配置页面。</p><p><img src=\"https://static001.geekbang.org/resource/image/02/ee/0273fa9e62c1b2a580b6fc21009a30ee.png\" alt=\"\"></p><p>在云服务器页面，点击“新建”，购买一台服务器。</p><p><img src=\"https://static001.geekbang.org/resource/image/e8/d2/e8f883446d099f88e41feea1d690ddd2.png\" alt=\"\"></p><p>在新建的页面，你可以根据自己的需求选择服务器的硬件配置。如果只是用来练习，选择最低的配置就行了。</p><p>服务器的操作系统选择“Ubuntu Server 16.04.1”，其他选项保持默认值。</p><p><img src=\"https://static001.geekbang.org/resource/image/70/a9/70f1a0f88d97cede64172b8d4b2c87a9.png\" alt=\"\"></p><p><img src=\"https://static001.geekbang.org/resource/image/d2/e4/d296d31ae02a2f74f42b2a2333813ee4.png\" alt=\"\"></p><p>点击“立即购买”，完成支付后，我们重新进入云服务器控制台，就可以看到我们的服务器新实例了。</p><p><img src=\"https://static001.geekbang.org/resource/image/aa/f7/aa37acca629ca8fd28454bfe26a637f7.png\" alt=\"\"></p><p>准备好云服务器后，我再介绍一下Django应用在Ubuntu服务器上的具体部署操作。</p><p>以下的介绍都是针对单台服务器部署展开的。如果多台机子部署，你需要做相应的调整，比如使用腾讯云的CDB（云数据库服务），你就需要对Django应用的设置文件（settings.py）中数据库部分作修改。</p><h4>Ubuntu准备</h4><p>首先，通过SSH登录到Ubuntu服务器，像连接树莓派一样，你仍然可以使用Putty或者SecureCRT这样的终端软件。</p><p>服务器的IP地址可以从腾讯云的云服务器控制台获取。关于用户名和密码，“腾讯云助手”公众号会在购买云服务器时发送消息通知。如果没有收到，你可以在控制台重置密码。</p><p>登录后，首先需要更新apt，你可以运行下面的命令：</p><pre><code>$ sudo apt-get update\n</code></pre><h4>代码上传</h4><p>接着，你需要将Django应用的代码上传到服务器某个目录下，比如 /home/ubuntu/iot/ 这个目录下。这涉及到下面介绍的Nginx和uWSGI的配置文件中的路径，因此，<strong>如果代码的路径不是这个，你需要相应地修改这些配置中的路径。</strong></p><p>上传的工具，你还是可以使用第19讲中提到的FileZilla等软件。</p><h4>数据库</h4><p>我们使用的MySQL数据库，可以通过以下命令来安装：</p><pre><code>$ sudo apt-get install mysql-server mysql-client libmysqlclient-dev\n</code></pre><p>说明一下，如果没有安装libmysqlclient-dev的话，接下来安装mysql-python的步骤可能会报错。</p><p>安装过程中，终端也提示你输入MySQL数据库的密码，你可以像我一样，输入“geektime”。</p><p><img src=\"https://static001.geekbang.org/resource/image/e8/7d/e83f9851db3064a202cf501b54676c7d.png\" alt=\"\"></p><p>安装完成后，你可以通过下面的命令，连接上数据库。</p><pre><code>$ mysql -p -u root\n</code></pre><p>然后，在数据库的交互命令行中，你需要输入下面的命令，创建 geektime 数据库。</p><pre><code>create database geektime; \nexit;\n</code></pre><h4>Python环境</h4><p>接下来，我们需要配置Python语言环境，因为应用程序和Django应用框架都是基于Python的。</p><p>首先，我们修改一下系统的默认python，将它修改为python3版本。运行下面的命令：</p><pre><code>$ vim ~/.bashrc\n</code></pre><p>在文件中，增加下面的内容：</p><pre><code>alias python='/usr/bin/python3'\n</code></pre><p>添加完成后，退出vim。在终端输入下面的命令，使其生效：</p><pre><code>$ source ~/.bashrc\n</code></pre><p>接着，我们需要安装 pip ，Python包管理器（Python package manager）。你可以运行下面的命令：</p><pre><code>$ sudo apt-get install python3-pip\n$ sudo pip3 install --upgrade pip\n</code></pre><p>接着，你还需要安装 python-dev ，一些软件包的安装需要依赖它。命令如下：</p><pre><code>$ sudo apt-get install python3-dev \n</code></pre><p>后面，你需要进入Django应用目录（我们这里是 /home/ubuntu/iot/watering_web），然后运行下面的命令，安装所有依赖的软件包。：</p><pre><code>pip3 install -r requirements.txt \n</code></pre><p>如果出现 locale.Error: unsupported locale setting 的错误，请在命令行输入下面的命令：</p><pre><code>export LC_ALL=&quot;en_US.UTF-8&quot;\n</code></pre><p>requirements.txt文件的内容如下：</p><pre><code>tencentcloud-sdk-python==3.0.313\nmysqlclient\nDjango\n</code></pre><p>现在，环境已经准备就绪，下面我来讲解一下数据库和uWSGI、Nginx的配置。</p><h4>数据库Migrate</h4><p>在Django中，数据库的创建已经处理得非常简单，框架本身做了很多的工作。</p><p>首先，在manage.py文件所在的目录，运行下面的命令：</p><pre><code>$ python manage.py makemigrations \n</code></pre><p>接着，只需要运行下面的命令，就可以完成所有的数据库表创建工作。</p><pre><code>$ python manage.py migrate\n</code></pre><h4>确认测试</h4><p>现在，你可以执行下面的命令，启动Django应用。然后，你可以通过浏览器确认Django 应用是否可以正常运行。</p><pre><code>$ python manage.py runserver 0.0.0.0:8080\n</code></pre><p>下面，我们就可以安装uWSGI和Nginx了。</p><h4>uWSGI安装</h4><p>uWSGI相当于是Django应用和Nginx之间的桥梁，它使用标准的WSGI接口与应用通信。你需要运行命令，安装uWSGI：</p><pre><code>$ sudo apt-get install -y uwsgi\n$ sudo apt-get install uwsgi-plugin-python3\n$ pip3 install uwsgi\n</code></pre><p>然后，在 /home/ubuntu/iot/config 目录下为uWSGI增加配置文件，文件内容如下:</p><pre><code>[uwsgi]\nsocket = 127.0.0.1:3031 \nchdir = /home/ubuntu/iot/watering_web\nwsgi-file = watering_web/wsgi.py \nprocesses = 4\nplugins = python3\nthreads = 2\nstats = 127.0.0.1:9191\n</code></pre><p>接着，运行下面的命令，查看uWSGI是否可以正常运行。</p><pre><code>$ sudo uwsgi --ini ./config/uwsgi.ini \n</code></pre><p>之后，我们还需要配置基于systemd的uWSGI的自启动流程。这需要创建systemd的unit文件。我们还是在 /home/ubuntu/config 目录下增加 uwsgi.service文件，内容如下：</p><pre><code>[Unit]\nDescription=uWSGI\nAfter=syslog.target  \n\n[Service]\nUser=ubuntu\nExecStart=/usr/bin/uwsgi --ini /home/ubuntu/iot/config/uwsgi.ini\nRestart=always\nKillSignal=SIGQUIT\nType=notify\nStandardError=syslog\nNotifyAccess=all\n\n[Install]\nWantedBy=multi-user.target\n</code></pre><p>这时，你还不需要添加这个service，在后面我们会通过命令添加、执行这个配置文件。</p><h4>安装Nginx</h4><p>首先，你需要执行下面的命令，安装Nginx软件。</p><pre><code>$ sudo apt-get install nginx \n</code></pre><p>然后，我们需要配置它。我们通过新添加文件，来配置我们的服务，在 /etc/nginx/conf.d/ 目录下，增加 iot.conf 文件，文件的内容如下:</p><pre><code>server {\n    listen 80;\n    #listen [::]:80 default_server; \n    server_name 159.75.214.14; #替换为自己服务器IP地址 \n\n    location / {\n        root /home/ubuntu/iot/watering_web/web/;\n        index index.html; \n    }\n\n    location ^~ /geektime/ {\n        include uwsgi_params;\n        uwsgi_pass 127.0.0.1:3031; \n    }\n\n    error_page 404 /404.html; \n    location = /40x.html {\n    }\n\n    error_page 500 502 503 504 /50x.html; \n    location = /50x.html {\n    }\n}\n</code></pre><p>并且，将/etc/nginx/nginx.conf文件中的“user www-data;” 修改为“user ubuntu;”。</p><p>现在，你需要执行下面的命令检查Nginx配置文件的语法：</p><pre><code>$ sudo nginx -t\n</code></pre><p>如果没有错误，就可以重启Nginx，来加载新的配置文件：</p><pre><code>$ sudo service nginx restart \n</code></pre><p>然后，把uWSGI的service配置文件拷贝到systemd配置目录下：</p><pre><code>$ sudo cp uwsgi.service /etc/systemd/system/ \n</code></pre><p>现在，你可以执行下面的命令，启动uWSGI服务：</p><pre><code>$ sudo systemctl start uwsgi\n</code></pre><p>如果一切正常，我们就可以把uWSGI添加到开机自启动中：</p><pre><code>$ sudo systemctl enable uwsgi\n</code></pre><p>到这里，服务就部署完毕了。</p><h3>云平台数据同步URL更新</h3><p>云服务器上的Web应用运行正常后，你可以对腾讯云物联网平台上的HTTP数据同步进行更新。修改配置中的URL地址为自己云服务器的视图地址。</p><p><img src=\"https://static001.geekbang.org/resource/image/49/28/49d7959887a67b4cdcb67db4951a6928.png\" alt=\"\"></p><p>更新完成后，你就可以在浏览器上访问自己的服务器地址，查看自动浇花器的实时数据，并且控制它进行浇水。</p><p><img src=\"https://static001.geekbang.org/resource/image/fc/56/fc4e7e4b040b94b5fca091faf8b9f856.png\" alt=\"\"></p><h2>小结</h2><p>总结一下，在这一讲中，我围绕自动浇花器讲解了智能家居系统中设备数据的应用系统开发方法。主要的内容有：</p><ol>\n<li>腾讯云物联网平台为我们提供了简单易用的数据开发方法。基于可视化界面，我们编辑“输入”，“处理”和“输出”就可以完成一个数据流的创建，实现数据的过滤和消息推送。</li>\n<li>我们可以基于物联网平台的数据同步能力，比如HTTP推送，实现物联网平台和应用服务器的对接。在应用服务器上，我们可以灵活地开发数据应用系统。</li>\n<li>Django是非常流行的，基于Python语言的Web应用开发框架。工作中，你可以使用Django比较快速地实现一个Web应用系统。</li>\n</ol><p>在这一讲中，我们的数据应用系统只包含了自动浇花器的数据，你在时间允许的情况下，也可以尝试在这个系统中增加一下智能电灯和光照传感器的数据。</p><p>另外，物联网平台的数据同步也提供了 CKafka（Cloud Kafka）的数据转发方式。通过订阅Topic主题消息，我们可以消费Kafka的消息，也可以直接将Kafka消息转储到MySQL云数据库中。</p><p>不过，Kafka的费用比云服务器要贵不少，这里就不介绍了。如果你的条件允许，也可以动手实践一下这种方式。</p><p>这里，我整理了一个思维导图，供你参考：</p><p><img src=\"https://static001.geekbang.org/resource/image/c1/cf/c1ca9362755ab00917f3969176a7fccf.png\" alt=\"\"></p><h2>思考题</h2><p>最后，我给你留一个思考题吧。</p><p>在Django应用开发的介绍部分，我提到了admin.py是后台管理应用的配置文件，而且访问<a href=\"http://127.0.0.1:8000/admin/\">http://127.0.0.1:8000/admin/</a>地址，就会出现管理员登录页面。你知道在Django项目中如果创建管理员账号吗？另外，如何在admin.py文件中增加Watering数据库模型对象，实现对自动浇花器监测数据的查询呢？</p><p>欢迎你在留言区写一写自己的思考，同时，也欢迎你将这一讲分享给对Web应用开发感兴趣的朋友，大家一起交流学习。</p>",
                "article_title": "22 | 掌控数据：家里的数据可以怎么利用？"
            }
        ]
    },
    {
        "chapterTitle": "结束语",
        "children": [
            {
                "title": "结束语 | 永远做一个具有极客精神的人",
                "id": 332949,
                "content": "<p>你好，我是郭朝斌。</p><p>今天是《物联网开发实战》结课的日子，祝贺你学完了这门课程！</p><h2>从书上学，和高人聊，在事上练</h2><p>回顾一下这门课程，在一开始的基础篇和进阶篇，我希望帮助你建立起物联网的知识体系。</p><p>通过留言区和交流群，我希望搭建一个交流的平台，让你可以和各个行业、专业的高手切磋，共同进步。</p><p>在最后的实战篇，我希望带着你动手实践，用学到的知识完成一个智能家居项目。</p><p>为什么这么设计呢？这跟我对个人成长的认知有关。</p><p>据说在美团公司内部流传着这么一句话：“<strong>从书上学，和高人聊，在事上练。</strong>”</p><p>我觉得很有道理，因为它非常准确地描述了掌握新知识的过程。</p><p>书本可以快速地让你对一个事物建立框架性、体系性的认知。</p><p>和高人或者专家交流可以解决你的疑惑，让你获取到最前沿的信息。</p><p>在实际生活和工作中应用知识属于输出，在输出的过程中，这些知识才能内化成你的一部分，这才算是真正掌握。</p><p>这门课程的安排，正是遵循了“从书上学（基础篇和进阶篇），和高人聊（留言区和交流群），在事上练（实战篇）”的理念。</p><p>如果要给这三个部分分配一个比例，我认为“从书上学”占10%，“和高人聊”占20%，“在事上练”占70%。</p><p>从这个角度看，光靠实战篇的几个小项目来练习是远远不够的，你还需要在更多的物联网项目中应用这些知识。所以，我希望<strong>这门课不是你的物联网之旅的终点，而应该是新的起点</strong>。</p><!-- [[[read_end]]] --><h2>我的物联网之旅的起点</h2><p>说到这里，我想起了自己当年的故事。</p><p>十多年前，我还在读大学。有一次上传感器的课程，教授讲得十分生动有趣。那堂课快结束的时候，教授说：“你们课后可以动手做一个关于传感器的小设备，我保证你的收获会非常大。”</p><p>我觉得自己好像被什么东西击中了，非常想去动手试一试。于是下课以后，我就跑到图书馆借了一堆书，开始查资料学习。缺元器件，我就拜托宿舍的哥们帮忙找，然后在宿舍里一通折腾。可以说，<strong>那几天是我在大学期间最充实的一段时间</strong>。</p><p>终于，赶在下一堂课之前，我完成了一个小作品——可以感应光线强弱自动开关的小灯。</p><p>那个时候我还没有条件用微控制芯片，整个电路是一个模拟电路，用 5 号电池供电，然后用一张纸包着光敏电阻。纸合上时，发光二极管点亮；当纸打开时，发光二极管熄灭。</p><p>上完课，我战战兢兢地把小灯拿给教授看，他饶有兴致地看着我演示。在我演示完之后，他对我说，暑假期间可以去他的实验室实习（那里全是研究生，作为本科生的我进去实习完全是破格的）。</p><p><strong>我是唯一一个带着作品去上课的学生，而我的收获确实像教授说的那样，非常大。无论是学到的知识还是激发出的兴趣，都让我受益终生。</strong></p><p>这个作品可以说是我的物联网之旅的起点，在那之后，我又参加了机器人竞赛，智能硬件开发乃至完整的物联网系统的研发。</p><p>如果你问我，这么多年还能保持学习和实践的热情，靠的是什么？我觉得应该是<strong>极客精神</strong>。</p><h2>极客精神是什么</h2><p>什么是极客精神呢？</p><p>“极客”这个词，来源于英文Geek，它代表一个群体，他们有鲜明的个性、超群的智力和高超的技术才能，并且热衷于克服限制、解决问题，所以总能做出很酷的新玩意儿。</p><p>在我看来，极客的精神内核主要包括两个方面，<strong>好奇心</strong>和<strong>创造力</strong>。</p><p><strong>首先，极客都有强烈的好奇心，乐于挖掘事物背后的本质，探索新技术的潜力。</strong></p><p>爱因斯坦曾经说过：“<strong>我没有什么特殊的天赋，只是拥有热切的好奇心。</strong>”</p><p>其实好奇心是人的天性，只是随着年龄的增长，太多人把它丢掉了，对新事物感到麻木。但是极客没有，他们在相当长的时间跨度里，都保持着对世界的好奇，反复地从不同角度去思考和研究同一个问题。</p><p>这种不断探索的勇气和激情，让他们获得了比别人更多的知识和技能。</p><p><strong>其次，极客还拥有旺盛的创造力，不满足于现状，希望亲自打造心目中的理想世界。</strong></p><p>他们相信创造新事物的价值，他们的知识和技能也为创造提供了坚实的基础，让设想不会沦为空想。</p><p>这种美好的愿景和强大的执行力，让他们成为一股推进世界进步的重要力量。</p><p>在《非自然选择》（Unnatural Selection）这本书中，作者甚至提出，随着高科技的不断发展，<strong>极客在人类的新进化历程中将获得巨大的优势</strong>。</p><h2>永远做一个具有极客精神的人</h2><p>所以，我想对你说，做一个具有极客精神的人吧！</p><p><strong>极客精神会为你提供自我不断地成长的原动力</strong>。你会专注于自己热爱的事情，不再焦虑，遇到困难的时候，也会迎难而上，不断尝试。</p><p>这种“虚怀若谷、求知若渴”的状态，自然会让你不断突破自我，成长为真正的“大牛”。</p><p>这显然不是一般的聪明人的选择，因为一般的聪明人会绕开困难走，永远选择当前最有利的选项。</p><p>但是，就像机器学习中的贪心算法一样，<strong>如果只是目光短浅地选择当下的最优解，最终也许只能得到一个局部最优解，跟真正的全局最优解相差十万八千里。</strong></p><p>现在我们所处的时代，已经不是简单地靠Copy to China就可以创立一番事业的时代。现实环境越来越强调创新，而创新则需要极客精神。</p><p>拥有极客精神的你，将会更加适应这个时代，做出更多创新，让社会变得更美好。更重要的是，你是发自内心地享受创新的过程和乐趣。</p><p>总之，技术是一条创新之路。<strong>愿你能够抱持一颗极客之心，不断探索，找到自己擅长、并且感兴趣的方向，在技术之路上成就自我，成就梦想！</strong></p><p><a href=\"https://jinshuju.net/f/ATvPeE\"><img src=\"https://static001.geekbang.org/resource/image/78/e6/78715a896b079aa0d86b293e25bcb4e6.jpg\" alt=\"\"></a></p><p>《物联网开发实战》课程结束了，这里有一份<a href=\"https://jinshuju.net/f/ATvPeE\">毕业问卷</a>，题目不多，希望你能花两分钟填一下。十分期待能听到你说一说，你对这个课程的想法和建议。</p>",
                "article_title": "结束语 | 永远做一个具有极客精神的人"
            }
        ]
    },
    {
        "chapterTitle": "测试题",
        "children": [
            {
                "title": "结课测试 | 这些物联网的问题，你都掌握了吗？",
                "id": 333469,
                "content": "<p>你好，我是郭朝斌。</p><p>到这里，《物联网开发实战》这门课程已经全部结束了。我给你准备了一个结课小测试，来帮助你检验自己的学习效果。</p><p>这套测试题共有 20 道题目，有单选题，也有多选题，满分 100 分，系统自动评分。</p><p>还等什么，点击下面按钮开始测试吧！</p><p><a href=\"http://time.geekbang.org/quiz/intro?act_id=362&exam_id=988\"><img src=\"https://static001.geekbang.org/resource/image/28/a4/28d1be62669b4f3cc01c36466bf811a4.png?wh=1142*201\" alt=\"\"></a></p><p>最后，我为你准备了<a href=\"https://jinshuju.net/f/ATvPeE\">调查问卷</a>，题目不多，希望你可以花两分钟填一下。十分期待能听到你的反馈，说说你对这门课程的想法和建议。</p><p><a href=\"https://jinshuju.net/f/ATvPeE\"><img src=\"https://static001.geekbang.org/resource/image/78/e6/78715a896b079aa0d86b293e25bcb4e6.jpg?wh=1142*801\" alt=\"\"></a></p><!-- [[[read_end]]] -->",
                "article_title": "结课测试 | 这些物联网的问题，你都掌握了吗？"
            }
        ]
    },
    {
        "chapterTitle": "加餐",
        "children": [
            {
                "title": "加餐一 | 这5本关于物联网的好书，值得一读",
                "id": 318769,
                "content": "<p>你好，我是郭朝斌。</p><p>《物联网开发实战》这门课程上线之后，很多同学在留言区和交流群提议，请我分享物联网相关的学习资料。我当时答应过你们，说一定会抽时间整理一下，今天终于要兑现这个承诺了。</p><p>有同学问我：“朝斌老师，你平时是怎么学习技术的？”我想，最主要的途径还是读书。</p><p>书籍有一个很大的优点，那就是它的知识内容组织是成体系的。这非常关键，因为只有体系化的知识，才能帮助你在一开始的时候就打好框架，然后你就只需要在这个基础上“添砖加瓦”就可以了。这一点也是符合大脑认知规律的。</p><p>所以今天，我会为你推荐5本非常值得读的书，如果你想从事物联网行业，一定不要错过。</p><h3>1. 每一个人都可以读的物联网科普书：《图解物联网》</h3><p><img src=\"https://static001.geekbang.org/resource/image/7d/92/7dce7572ed5a4c6d0f2e4b27e1c4fb92.png\" alt=\"\"></p><p>我推荐的第一本书是《图解物联网》。这本书适合所有人，就算你不是开发人员，甚至不是物联网从业者，也可以拿来阅读。</p><p>因为这本书的特色在于，用大量优美的图形来呈现知识。图形的好处是非常直观，有利于大脑的记忆和理解。所以你可以比较轻松、高效地了解物联网的知识。</p><p>不过，你千万不要以为这本书的内容不全面或者非常水。恰恰相反，它的内容很全面，讲解也深入浅出。</p><p>它由日本 NTT DATA 集团的河村雅人等人组成的团队共同完成。这么多人协同创作，还能写出行文风格一致，高质量的技术图书，真是非常难得。</p><!-- [[[read_end]]] --><p>物联网行业的工程师阅读这本书也会很有收获，因为它既有物联网架构，也有硬件工程师和嵌入式工程师关注的硬件设备知识，还有云平台工程师关注的服务器和数据分析等内容。甚至就连机器人它也有介绍，我想极客们大概会非常感兴趣。</p><h3>2. 最适合物联网专业学生和开发人员的书：《从创意到原型：物联网应用快速开发》</h3><p><img src=\"https://static001.geekbang.org/resource/image/76/48/76eace1e60ee359d0a01cce1e3dyy048.jpeg\" alt=\"\"></p><p>我推荐的第二本书是《从创意到原型：物联网应用快速开发》。它的内容是按照教材的方式组织的，非常适合物联网专业的学生和开发人员来学习。</p><p>这本书为学生考虑这么周到，正是因为它出自教授之手。它的作者是浙江大学的董玮教授和高艺副教授。</p><p>书里的每一章都配有习题，所以你学习完一章内容之后，就可以通过习题检测和巩固学习效果。这非常有利于知识的掌握。</p><p>除了习题的设计之外，这本书对物联网硬件和物联网操作系统也做了很多有价值的总结和介绍。更重要的是，它还介绍了作者团队打造的TinyLink系统。虽然你不一定使用这个系统，但是了解TinyLink的设计思路还是有利于你在工作中的实践的。</p><p>另外，作者他们的实验室，<a href=\"http://home.emnets.org:8888/zh/#about\">物联网系统与网络实验室</a>，一直专注于物联网方向的研究。经常关注他们的研究成果和相关论文，对你的学习和工作都是有帮助的。</p><h3>3. 物联网架构师和技术领导者不可错过的书：<em>Internet of Things for Architects</em></h3><p><img src=\"https://static001.geekbang.org/resource/image/68/4a/6846d13882cac180e8b598c5337c7b4a.jpg\" alt=\"\"></p><p>我推荐的第三本书是<em>Internet of Things for Architects</em>，它非常适合物联网行业的从业者，尤其是物联网架构师和技术领导者。</p><p>因为它对物联网技术体系覆盖得非常全面，不仅总结了物联网的整体架构，而且详细阐述了各种具体技术。可以说它是广度和深度兼备。</p><p>比如通信技术，无论是蓝牙、ZigBee、Z-Wave、6LoWPAN、Thread、Wi-Fi等<strong>局域和个人域技术</strong>，还是4G、5G、LoRa、LoRaWAN和SigFox等<strong>广域技术</strong>，它都有涉及到。</p><p>再比如网络协议，MQTT、MQTT-SN、CoAP和AMQP等常见协议，它也都讲到了。</p><p>更重要的是，这本书是2018年出版的。所以在这个技术发展日新月异的时代，它的内容还比较新，对云计算、边缘计算和数据分析等内容也做了介绍，这一点非常难得。</p><p>这么系统的内容，足以彰显作者的功力。这本书的作者叫Perry Lea，他曾经在惠普工作了21年，担任首席架构师的职位。进入物联网行业之后，帮助Cradlepoint公司进行了5G和IoT方向的转型；作为联合创始人参与了边缘计算领域的Rumble公司的创业；在微软时期，又作为首席架构师参与了微软云游戏产品的研发。</p><p>由此可见，能力和见识的背后是行业内的长期深耕。</p><p>不过有一点要提醒你，这本书还没有中文翻译版，如果你想读的话，可以跟我一样从京东上买英文电子版。</p><p>另外，Perry Lea还有一本物联网专著也是值得关注的，那就是2020年刚出版的<em>IoT and Edge Computing for Architects</em>。只不过这本书我现在也没有读完，没法为你详细介绍。</p><p><img src=\"https://static001.geekbang.org/resource/image/a2/eb/a2533c4a7ee1244511a9921257e80aeb.jpg\" alt=\"\"></p><h3>4. 介绍传感技术和通信技术最全面的书：《万物互联：物联网核心技术与安全》</h3><p><img src=\"https://static001.geekbang.org/resource/image/1c/02/1c5aca3590026a2yycf06bb97b372702.png\" alt=\"\"></p><p>我推荐的第四本书是《万物互联：物联网核心技术与安全》，它的特色是传感技术和通信技术介绍得特别全面。</p><p>这本书的作者是宋航博士，他潜心研究物联网技术十余年，是资深的物联网专家。同时他承担过物联网方向的很多课题，在物联网技术的广度和深度上都有积累。</p><p>这本书把物联网分为感知识别层技术体系、网络传输技术体系、管理服务技术体系和综合应用技术体系四个层次，然后围绕这四个技术体系进行了全面阐述，尤其是传感技术和通信技术的部分。比如传感器技术部分，对嗅觉和味觉都有介绍。</p><p>这本“大部头”著作，适合物联网从业者用来拓展技术视野，物联网专业的学生也可以拿它当参考书，作为教材的补充资料。</p><h3>5. 了解WoT最应该看的书：《从物联到万联：Node.js 与树莓派万维物联网构建实战》</h3><p>我推荐的第五本书是《从物联到万联：Node.js 与树莓派万维物联网构建实战》。它比较特别，为什么呢？因为它是关于WoT（Web of Things，万维物联网）的。</p><p>WoT 可以说是 IoT的一个子集。在这门课里，我主要讲解IoT的架构和技术体系；而WoT试图直接基于Web来构架物联网体系，这样就可以充分利用我们熟悉的Web应用的很多技术栈，而且可以实现物联网系统的互操作性。</p><p>这本书的作者是 Dominique Guinard 和 Vlad Trifa 两位物联网“老兵”，他们都是智能物联网平台EVRYTHNG 的联合创始人。除了EVRYTHNG ，他们还创立了一个<a href=\"https://webofthings.org/\">WoT组织</a>，专门用于推进WoT的发展。</p><p>在这本书中，两位作者基于Node.js和树莓派讲解了WoT的架构和各种概念，并且通过代码展示了各层的实现。</p><p>对HTML和JavaScript熟悉的开发人员可以基于本书的内容大展身手。另外，WoT已经是W3C（万维网联盟）组织在推进的一个标准规范，也许在未来会有不错的应用前景。如果你希望拓展关于WoT的技术视野，它是你最应该看的书。</p><h3>小结</h3><p>现在我们总结一下，今天我推荐了5本书，分别是：</p><ol>\n<li>NTT DATA 集团：《图解物联网》</li>\n<li>董玮，高艺：《创意到原型：物联网应用快速开发》</li>\n<li>Perry Lea: <em>Internet of Things for Architects</em></li>\n<li>宋航：《万物互联：物联网核心技术与安全》</li>\n<li>Dominique Guinard，Vlad Trifa：《从物联到万联：Node.js 与树莓派万维物联网构建实战》</li>\n</ol><p>衷心地希望你能从这些书籍中受益，也欢迎你和我分享读书心得。祝你在学有所成之后，真正地在物联网行业发挥自己的价值，做出自己的贡献。</p><p>另外，这只是我针对物联网领域的个人书单，难免会有不够全面的地方。如果你也有其他想推荐的书，欢迎在留言区和我分享。</p>",
                "article_title": "加餐一 | 这5本关于物联网的好书，值得一读"
            },
            {
                "title": "加餐二 | 行业应用：物联网的发展将如何重塑我们的生活？",
                "id": 328544,
                "content": "<p>你好，我是郭朝斌。</p><p>在之前的课程中，我们已经系统地学习了物联网的理论知识，并且动手完成了一系列的实战项目。我想，你已经对物联网有了一个比较全面的了解。</p><p>但是，从了解到灵活应用，我们还有很长的路要走。这个过程你既需要积累丰富的经验，也需要有一定的想象力。</p><p>今天，我就试着为你展望一下，物联网的发展在不久的未来，将怎样重塑我们的生活。</p><p>以下故事如有雷同，实属厉害。</p><h2>起床</h2><p>“小特，早上好，现在是早上7:05，根据你的监测数据，现在是起床的最佳时机。接下来，我会为你播报今天的热点资讯…….”</p><p>智能家庭管家甜美的声音伴随着轻柔的音乐，从床头一个类似闹钟的设备中发出。</p><p>所谓的监测数据，是从床垫和枕头的传感设备上采集的生理数据。基于脑波扫描数据和身体姿势的变化，智能家庭管家可以分析出人的睡眠周期次数，和每个周期中所处的睡眠阶段。它会选择在睡眠周期中最浅的阶段将人叫醒，既能让起床不那么痛苦，也能让起床之后的精力更充沛。</p><p>故事的主人公是小特，他的大名叫司马特。他一毕业就来到北京工作，成为一名“北漂”，算算日子，已经整整3年了。今天是星期五，上午十点有一个项目会议，绝对不能迟到，所以他起床之后，马上就开始洗漱了。</p><h2>洗漱</h2><p>司马特使用的是昨天快递刚送到的一款新牙刷，这款牙刷号称有很多智能功能，不但可以指导正确的刷牙动作和步骤，还可以通过微型摄像头分析牙齿和牙周的健康状况。这是司马特的同事艾欧媞媞推荐的，他马上就买了。</p><!-- [[[read_end]]] --><p>刷牙的时候，梳妆镜已经获取到牙刷的数据，在镜面上显示出了动作提示。司马特感慨：这款牙刷果然很智能。因为他之前刷牙很少关注的上颌的后槽牙，被重点关注到了，梳妆镜提示他多刷了1分钟。</p><p>刷牙完毕，梳妆镜上展示出了司马特的口腔健康报告：没有大问题，但是牙结石比较多，建议安排洗牙，否则会影响到牙龈的健康。</p><p>司马特直接说道：“帮我预约一个牙科诊所吧。”</p><p>梳妆镜传出家庭管家那熟悉的甜美声音：“好的，我查询到你工作的办公楼附近200米有间诊所，能够预约的最早时间是今天下午4点，请问可以吗？”</p><p>司马特知道那间诊所，确实挺方便的，所以他说：“没问题，记得帮我提交一个请假申请。”</p><p>智能家庭管家给出肯定答复后，开始继续播报热点资讯。</p><h2>早餐</h2><p>司马特到了厨房，拿起已经准备好的咖啡、烤吐司和煮鸡蛋来到餐桌上开始享用早餐。喝咖啡已经成为他的习惯，如果哪天没有喝，他就会觉得身体无法调整到100%的状态。</p><p>这些餐食并不是别人帮忙做的，而是司马特的早餐机完成的。当床垫将他起床的消息“告诉”智能家庭管家时，管家已经安排早餐机开始工作了。司马特只需要在前一天晚上把原材料加入机器里就可以了。</p><p>不过，这一台早餐机也只能准备这些简单的餐食，想来个煎饼果子或者鸡肉卷是不可能的。这也是司马特唯一不满意的地方，他想过段时间趁着电商节的优惠活动，再换一款功能更高级的。</p><h2>出门</h2><p>吃完饭，司马特穿戴齐整，对着门口的立式梳妆镜整理衣服，这时，梳妆镜用开玩笑的语气给他的形象打了100分，并且提醒司马特戴好围巾，因为今天的天气预报显示有大幅降温。</p><p>司马特在和他的猫咪道别之后就出门了。当他关上门并反锁门锁的时候，智能家庭管家自动切换到了“离家模式”。家里的照明全部自动关闭；监控摄像头的遮蔽罩打开，开始工作；扫地机器人开始清扫房间……</p><p>要说提升幸福感最大的智能产品，司马特觉得肯定是智能门锁，一个很重要的原因就是，他再也不用像之前一样，出门想起家里有灯没有关，再跑回去关灯。</p><p>而且他出门也不需要带钥匙了，这省了很多麻烦。毕竟作为一个经常丢三落四的人，以前他花在找钥匙上的时间真的不少，现在他连“记得带钥匙”的脑力负担都没有了。家里的门像是有了魔法，对别人是有形的，对他自己是隐形的，不管是指纹、密码，还是其他方式，他总是可以轻松地打开家门。</p><p>比如有一次他在外面出差，临时计划有变，出差时间从3天变成了5天。这可麻烦大了，因为他出差之前并没有给猫咪的喂食器添加足够吃5天的粮食，他的手机已经收到了“即将断粮”的消息提醒。好在智能门锁支持远程生成一次性的密码，他联系同事艾欧媞媞到他家去了一趟，给猫咪喂食。</p><h2>出行</h2><p>今天确实很冷，因为刮风，体感温度比实际温度还要低。幸好司马特家离地铁站并不远，他走了5分钟就到了。司马特拿出手机，贴到闸机的提示区域，闸机打开。与此同时，播放音乐的耳机里传来了地铁站欢迎的话。</p><p>虽然媒体介绍过，但是两年前当他第一次从耳机中听到“欢迎来到井湾站，我是你的服务专员小萌”的时候，内心还是非常激动的，一句“你好”脱口而出。</p><p>那个声音继续说道：“你好，这里是地铁5号线和7号线的交汇站，站内区域分布比较复杂，请问你要去哪里？我可以为你做站内导航。”</p><p>这个站内导航服务让司马特不禁竖起大拇指，它不仅可以准确地判断出司马特所处的位置，而且语音指示详细易懂，最重要的是，从导航提示的位置上车，车厢里人很少，还有几个空位可以选择。</p><p>今天，在简单地和司马特确认过目的地是否还是科技城之后，导航就又开始服务了。\b他在站台上没有等多久，地铁就到了，他选了一个靠近门口的座位坐下。</p><h2>远程逗猫</h2><p>结束了一个上午的忙碌工作后，司马特和几个同事一起吃午餐。午餐后是他每天的固定活动，远程逗猫。</p><p>司马特拿出手机，打开猫咪喂食器App，开始呼唤猫咪。这时他家中的喂食器上，屏幕开始显示他的远程视频影像，扬声器也同时发出他的声音。猫咪来到喂食器的镜头前，很认真地看着屏幕，时不时做几个伸展动作。</p><p>司马特通过远程控制激光红点，和猫咪开始互动。猫咪随着红点左扑右跳，身形非常敏捷。十分钟后，司马特不舍地结束了逗猫，开始下午的工作。</p><h2>看牙</h2><p>下午3点半，司马特的手机收到了智能家庭管家发来的消息，提醒他4点去洗牙。这时，他才想起早晨预约牙科诊所的事情。幸好有家庭管家，否则他肯定会忘记。</p><p>于是司马特收拾好自己的东西，背上背包，离开公司。到达诊所时，距离4点还有5分钟。他来到前台登记，前台人员给了他一个手环。</p><p>当司马特戴上手环，来到诊室通道，远远就看到了他的名字出现在诊室门口的显示屏上。当他进入诊室后，医生的显示屏自动地弹出他的基本信息。经过他的授权，医生访问到了他的口腔相关的医疗档案记录。</p><p>数字化的医疗档案记录是司马特本人所有的加密信息，它包含有完整的医疗记录，存储在云端。只有经过他的授权，医生才可以获取到部分信息。这些信息在所有医院之间都是相互认可的。</p><p>洗完牙，医生根据司马特的智能家庭管家提供的饮食信息，给他提出了一些饮食建议，建议他进一步减少甜食的摄取，适量增加纤维食物的比例。司马特谢过医生，来到前台归还手环。基于手环的记录，屏幕上显示出本次医疗的费用明细。司马特确认后，刷脸完成了支付。</p><h2>回家</h2><p>离开诊所后，司马特前往地铁站回家。回到小区后，他先来到了鲜食货柜区，通过手机扫描取出了自己的蔬菜、水果和面包。这是家庭管家根据他选择的食谱类别，提前一天网购的。</p><p>当他刷指纹打开房门时，门廊和客厅的电灯也自动打开了。家庭管家向司马特打招呼：“小特，欢迎回家。”猫咪也跑过来欢迎他。他和猫咪玩耍了一会儿，然后来到厨房，开始准备晚餐。</p><p>在做饭方面，他还是一个新手。之前他主要是在外面的餐馆解决晚餐，偶尔也订外卖。今年，他开始尝试自己做饭。在食谱教程的指导下，他现在也能做出一份味道及格的晚餐。</p><p>他通过语音指令打开厨房的显示屏，查看今晚的食谱教程。食谱配备了语音讲解，而且可以根据进度适当地等待。一通手忙脚乱之后，司马特总算可以享用晚餐了。</p><p>晚餐之后，他将餐具放入自动洗碗机，来到客厅看电视。电视上显示的是这几天他正在追的一部剧，并且询问他是否从上次播放的位置继续。</p><p>司马特说：“继续播放。”于是客厅的灯光自动调整到了观影模式，电视开始播放。</p><p>看完最新的一集，司马特开始看书。到了晚上十点，智能家庭管家通过语音提示他可以洗漱就寝了。</p><h2>睡觉</h2><p>司马特洗漱完，进入卧室。他躺在床上，听着枕头里传出的轻柔的音乐。据说这种音乐有助于快速进入睡眠。</p><p>以前司马特是有入睡困难的，躺在床上刷手机，不知不觉就到很晚了。后来，他开始尝试早睡早起。听说看枯燥的书籍有助于睡眠，他也尝试看深奥的专业书籍，但是效果不理想，稍微看一会儿，他就想拿起手机。</p><p>再后来，司马特买了这款助眠枕头，它不仅可以助眠，还可以和床垫一起通过传感器收集数据，分析睡眠质量。</p><p>伴随着音乐，司马特进入了梦乡。智能家庭管家收到助眠枕头的入睡消息后，切换到了“休息模式”。</p><h2>小结</h2><p>总结一下，随着物联网的发展，我们的生活可能发生巨大的变化。当我们考虑生活领域的物联网产品布局时，可以试着从人们最根本的“衣食住行”需求出发，展开思考。</p><ol>\n<li>衣：衣物的增减和搭配是我们每天都要关心的日常问题，而借助天气预报、衣物识别等技术的发展，我们可以给出更准确、更贴心的建议。</li>\n<li>食：围绕着做饭和吃饭的需求，我们可以用物联网技术做出体验更好的产品和解决方案，比如早餐机、基于现代营养学的食谱推荐和做饭指导方案都是有广泛需求的方向。</li>\n<li>住：对于住所，我们总是希望越智能越舒适越好，智能门锁、照明、睡眠提示、娱乐活动和宠物照看等都是非常值得尝试的产品领域。</li>\n<li>行：在公共出行的方式上（比如地铁），任何一点改进和优化都会惠及很多人，基于室内精准定位技术的导航应用就是一个这样的创新改进。</li>\n</ol><p><img src=\"https://static001.geekbang.org/resource/image/77/71/77eb3fd86f1da1ed908a09ef45f6a271.jpg\" alt=\"\"></p><h2>思考题</h2><p>最后是今天的思考题。生活领域的物联网产品创新空间非常大，你不妨也畅想一下有哪些可能的物联网应用吧，说不定就挖掘到了一个很有潜力的产品方向哦。</p><p>欢迎你在留言区写一写自己的想法，也欢迎你将这一讲分享给你的朋友，大家一起交流学习。</p>",
                "article_title": "加餐二 | 行业应用：物联网的发展将如何重塑我们的生活？"
            },
            {
                "title": "加餐三 | 行业应用：物联网的发展将如何升级第一、第二产业？",
                "id": 329209,
                "content": "<p>你好，我是郭朝斌。</p><p>上一讲中，我们展望了物联网对于生活的重塑作用。这一讲，我们继续畅想一下，物联网将为第一产业和第二产业提供哪些升级的机会。</p><p>故事的主人公，还是我们熟悉的司马特。</p><p>这个周末有一个物联网的年度展会，司马特早就想好了要去参加，了解一下行业里的最新动态。中午吃饭的时候，他提到了这件事，看看有没有同事想要一块儿去，这样路上也能有个伴，但是很可惜，没有一个人响应。</p><p>这也正常，大家都会把周末的娱乐活动安排得满满的，谁会想去参加这种枯燥的展会呢？</p><p>于是周六早上，司马特独自一人早早地来到了展会的现场。会场很大，有4个展馆，分别是农业展馆、工业展馆、智能家居展馆和云计算展馆。对于智能家居和云计算，司马特比较熟悉，所以他主要是想了解物联网在第一产业和第二产业的发展情况，也好开阔一下自己的眼界。</p><h3>温室大棚</h3><p>司马特首先来到农业展馆，远远地就看到一个温室大棚造型的展厅，这吸引了他的注意。他快步来到展厅前，看到大棚中均匀分布的架子上安装着一些有伸出探头的设备，地面上摆着十多盆鲜花，花盆中也插着一些设备。</p><p>这时一个展厅的工作人员走过来，跟他打招呼：“你好，我是花都科技的Annie。可以交换一下名片吗？”</p><p>司马特一边说着你好，一边拿出手机交换电子名片。他看了一眼名片信息，以询问的语气说道：“你们公司的业务是种植鲜花吗？”</p><!-- [[[read_end]]] --><p>“哈哈哈！”一阵爽朗的笑声之后，Annie接着说道：“不是的，我们主要是提供鲜花种植的智能化解决方案。我们的方案集成了各种先进的传感器和无线通信技术，能够采集所有影响鲜花生长的环境数据。”</p><p>随后Annie指引司马特来到一个架子前，指着上面的设备说：“这个设备可以采集温室大棚里面的温度、湿度、气压和二氧化碳的浓度。基于这些数据，我们的系统可以自动控制温室大棚上的卷帘，这些卷帘覆盖在大棚上，可以通过机械装置实现收起和放下。这些数值也是控制大棚风机通风的重要依据。”</p><p>司马特指着架子上的一个摄像头说：“这也是你们解决方案的一部分吗？”</p><p>“是的，它可以让种植人员远程查看鲜花的生长情况，比如植株的大小和花苞的发育阶段等。这些影像是不可或缺的判断依据。”Annie说。</p><p>接着，Annie又指着地上的花盆说：“这里面的设备可以测量土壤里面的水分含量、有机质含量、pH值和花盆位置的光照度。光是基于土壤湿度的智能化灌溉，我们就可以节约60%以上的种植用水。”</p><p>“那这些数据是在哪里处理的啊？”司马特问道。</p><p>“这些传感器设备是通过LoRa无线技术，把数据发送给那个网关设备的。”Annie指着大棚角落一个盒子说，“网关设备通过5G蜂窝网络将数据上传到云端服务器。摄像头是直接通过5G网络上传视频数据的。”</p><p>他们来到一个显示屏前，屏幕上面的左边显示着各种数据，右边是几个摄像头的实时影像。</p><p>Annie介绍道：“这里是整个大棚的数据。你可以看到很多需要重点关注的数值，比如水分含量和有机质含量等。同时，系统还会为你提供灌溉总量和施肥的建议。这都是云端基于收集到的数据实时生成的。</p><p>“根据我们的系统建议，菊花从分化到现蕾的时间可以缩短5到7天，出产合格商品的比例提高15%左右。现代的鲜花种植已经发展到了智能化阶段，过去的种植能手的经验已经转化成了数字化的精确决策。”</p><p>听到这里，司马特非常感慨：“原来物联网不仅可以节省人力，而且可以提高经济收益。”</p><h3>智能养猪</h3><p>司马特向Annie道完谢，继续往前走。他看到一个“智能养猪”的展厅，觉得很新奇，径直走了进去。</p><p>展厅内摆着几只可爱的小猪模型，有一个盒子在悬空的轨道上，来回移动。一个大屏幕上显示着各种数据，以及用不同色块标识的小猪的视频影像。</p><p>一位名叫Jason的工作人员向司马特介绍了这套智能养猪的解决方案。轨道上的盒子是一个物联网设备，它集成了不同的传感器，可以采集猪舍中的温度、湿度、氨气、二氧化碳和光照度等环境指标，也可以识别不同的小猪，完成每一头猪的跟踪、盘点和测重等工作。</p><p>“为什么需要特别监测猪舍中的氨气呢？”司马特问道。</p><p>Jason解释说：“猪毕竟是直接在猪舍内排便排尿的，粪便和尿中的含氨物质经过微生物的发酵就会产生氨气。氨气是一种强刺激性的气体。氨气会导致猪的采食量减少，消化能力也会受到影响，这些都会严重影响猪的生长速度。另外，氨气还会导致猪的抵抗力下降，更容易受结核病和其他传染病的影响。”</p><p>“那如何自动监测每一头猪的生病情况呢？”司马特继续问道。</p><p>“你是问到点上了。”Jason夸赞道，“就像人一样，主要是监测一些异常的指标。一方面是体温，猪一旦生病，体温往往也会升高，通过红外测温就可以持续测量猪的体温，及时发现异常的猪；另一方面是每头猪的采食量和饮水量，一旦它们食欲不振，我们就会注意到。”</p><p>Jason继续补充道：“及时发现生病的猪并且进行干预和处理，是预防疾病大面积扩散的重要措施。我们国家每年出栏的猪有近7亿头，整个养猪产业有万亿元级别的规模。所以，智能化的养猪模式是非常有前景的行业趋势。”</p><p>这么大的产业规模是司马特完全没有想到的。他越发觉得，自己来展会了解不同的行业知识是正确的决定。</p><h3>无人机</h3><p>司马特再往前走，看见一些无人机摆在一个展厅里面。他有些惊讶，以前自己观赏过无人机的夜空灯光秀，也看过无人机用于快递运输的介绍，却不知道无人机可以用于农业生产呢！</p><p>带着疑问，司马特来到了展厅。他询问工作人员：“无人机在农业领域有哪些应用？”</p><p>工作人员介绍说：</p><p>“无人机的特点就是快速灵活的空中机动能力和一定的有效负载运输能力。所以，它的应用主要体现在两个方面：</p><p>“首先，病虫害情况、锯齿类动物的破坏和农作物的长势情况等都是种植业者非常关心的问题。行业内已经有基于卫星遥感影像技术来实现农作物监测的解决方案，但是，无人机可以提供成本更低、更加灵活的方案。无人机安装的高清成像设备，可以对田间进行成像，结合GIS（Geographic Information System，地理信息系统）技术，还能实现绘图和测量的目的。</p><p>“通过对这些数据进行分析，就可以得到农作物LAI（Leaf Area Index，叶面积指数）等数据，进而分析出农作物的长势和病虫害等危害情况。基于农作物数量的测算和长势情况，系统就可以预测出农作物的产量。</p><p>“那另一个方面是什么呢？”司马特迫不及待地问。</p><p>工作人员接着说：“我们还利用无人机执行一些原来需要人来完成的工作，比如喷洒农药。这样一来可以减少人力投入，二来也可以减少人工田间作业对农作物的毁坏，三来还可以节约30%以上的农药投放。”</p><p>司马特道完谢，离开无人机展厅，继续往前走。展馆里面还有一些基于RFID标签和蓝牙标签的食品追溯系统。这些追溯系统可以实现从田间到消费者的全链条溯源和记录，从而有效提高供应链的效率和产品质量。不过时间有限，司马特没有停留太久，就匆匆地向工业展馆走去。</p><h3>机器故障监测</h3><p>对于工业领域，司马特更加陌生，而且这里展厅的布局也没有农业展馆那样活泼有趣，所以整体来说他的兴趣不是太浓厚。</p><p>不过，一想到工业制造是最强调效益的地方，物联网技术应该有不错的应用潜力，所以司马特还是希望获得一些新的认知。</p><p>他来到一个显示屏内容比较吸引人的展厅。显示屏上的数字快速地变化着，提示着这台设备的健康指数和待检修的预估时间。司马特找到一个工作人员询问具体细节，接待他的是一位叫Heidi的工作人员。\b</p><p>Heidi指着一个机器模型上的盒子说：“这是一个传感器设备，可以监测机器运转时的震动数据。设备会将这些数据发送到车间里部署的网关设备上。网关设备再将震动数据上传到云服务器。”</p><p>“这个好像并不是很难。”司马特随口说道。</p><p>“因为工作环境很复杂，传感器需要长时间可靠、准确地测量机器的震动数据。这个难度还是不小的。”Heidi平静地说，“另外，我们真正的核心在于数据的分析处理。仅仅根据震动数据来实现对机器运转状态评估，这需要在模型和算法上投入很多精力。基于机器学习算法，我们的系统还可以预测机器发生故障的时间，从而提前安排维修保养，实现延长机器使用寿命的目的。”</p><p>“原来是这样，看来确实不简单。”司马特表示赞同，同时也会自己刚才的失言感到懊悔。找个机会，他赶紧离开了展厅。</p><h3>智能制造</h3><p>司马特再往前走，看到一个围了很多人的展厅。在好奇心驱动下，他也径直走了过去。</p><p>一位工作人员正在讲解无人工厂：“智能工厂主要是实现了全面感知、协同优化、预测预警和科学决策；而无人工厂是在这个基础之上，建设全面的工业物联网平台，做到生产流程的全面联网化和自动化。</p><p>“生产需要的原材料是由自动导引运输车（Automated Guided Vehicle，AGV）基于ERP和PDM系统中的生产计划，从库房运输到生产线。生产线完全自动运转，每条生产线之间的衔接也是系统自动协调完成的，不需要人员的干预。</p><p>“产品生产完成后，机器人会将货物整齐地码放在自动运输车上，运到库房存放。产品的销售出货过程也是全面自动化的。”</p><p>工作人员指引司马特他们来到一块大型的显示屏前，接着说：“整个流程都有传感器和摄像头进行全面监控。这里展示的是现场实景的各种数据，如果有那个工序出现故障，屏幕马上就会显示出来，工厂管理人员可以及时了解情况。整体运营成本可以降低50%以上，生产效率至少提高80%，某些情况下甚至可以提升2到3倍以上。”</p><p>“中国作为世界工厂，在智能工厂和无人工厂领域的发展相当令人期待啊！”司马特一边听着，心里不禁这样想。</p><p>不知不觉已经中午了，司马特还有很多感兴趣的展厅没有去，但是他也只能不舍地离开，因为中午他还有一场约会呢！</p><h3>小结</h3><p>总结一下，除了智能家居和公共交通等生活领域，物联网技术在农业和工业这些传统的第一、第二产业也有广阔的应用前景。</p><p>在农业产业，物联网解决方案可以有效减少人力投入，获得更好的经济收益，比如：</p><ol>\n<li>利用传感器和摄像头实现智能化种植的温室大棚。</li>\n<li>实现猪舍环境监测和猪只识别的智能养猪解决方案。</li>\n<li>利用无人机进行田间影像监测和喷洒农药等创新应用。</li>\n</ol><p>在工业产业，物联网技术是企业追求效益的必然选择，比如：</p><ol>\n<li>基于传感器数据的机器故障监测和预测性维护应用场景。</li>\n<li>智能工厂、无人工厂这些覆盖原材料、生产、库存和销售等环节的全流程数字化、自动化解决方案。</li>\n</ol><p><img src=\"https://static001.geekbang.org/resource/image/cc/27/cc1583905c36e789abce8ac7640d3927.jpg\" alt=\"\"></p><h3>思考题</h3><p>最后，我给你留一个思考题吧。你还了解农业、工业产业中有哪些物联网应用案例呢？</p><p>欢迎你在留言区写一写，也欢迎你将这一讲分享给你的朋友，大家一起交流学习。</p>",
                "article_title": "加餐三 | 行业应用：物联网的发展将如何升级第一、第二产业？"
            },
            {
                "title": "加餐四 | 5G技术将如何推动物联网的发展？",
                "id": 329857,
                "content": "<p>你好，我是郭朝斌。</p><p>今天我继续给大家讲讲司马特的故事。</p><p>这天，通信技术专家Vincent来到司马特的公司做5G技术讲座，司马特非常兴奋。他上次去物联网展会的时候就注意到，很多物联网系统都用到了5G技术，所以他早就想深入地了解一下5G了，这次讲座正好是一个机会。</p><p>他早早地就来到了报告厅，此时报告厅里还一个人都没有呢。他选了一个前排的座位坐下，等待的过程中，在电脑上搜索、阅读着5G相关的文章。</p><p>讲座快开始了，报告厅里来的人越来越多，已经有6、7成的座位上坐上了人。司马特心想：“看来对5G感兴趣的人真是不少啊！”</p><p>专家提前5分钟到了，在讲台上准备着。时间一到，讲座就正式开始了。</p><h2>演讲笔记</h2><p>司马特一边听，一边在电脑上记着笔记。<br>\n<img src=\"https://static001.geekbang.org/resource/image/2b/e2/2b6880c13e1a5fd6777a29d431d34ce2.jpg\" alt=\"\" title=\"司马特的笔记之一：5G和物联网\"><br>\n<img src=\"https://static001.geekbang.org/resource/image/cb/f8/cb0b29ac2b2d1208289dec0f794265f8.jpg\" alt=\"\" title=\"司马特的笔记之二：5G的技术特点\"><br>\n<img src=\"https://static001.geekbang.org/resource/image/50/a5/500f56e3041e221dde17281ef36ccca5.jpg\" alt=\"\" title=\"司马特的笔记之三：5G技术创新\"><br>\n<img src=\"https://static001.geekbang.org/resource/image/5d/e5/5df8707b5dbedd100c0655f22dff48e5.jpg\" alt=\"\" title=\"司马特的笔记之四：5G标准化组织\"></p><h2>问答交流</h2><p>讲座结束后，司马特心想，这么难得的学习机会，绝对不能放过，于是趁着专家还没有离场，立即走上前去提问：“Vincent老师，能请教您几个问题吗？”</p><p>“叫我Vincent就行。”专家笑着说，“没问题，我还有几分钟时间。”</p><h3>为什么5G这么热？</h3><p>司马特说：“谢谢！请问5G现在为什么这么热呢？”其实他心中一直有这个疑问。</p><p>Vincent回答道：“要理解这个问题，你就要看4G时代发生了什么。4G出来之前，很多人认为3G已经够用了，手机无非是打电话、发短信和偶尔上网查个网页；但是当4G真正到来的时候，我们的生活方式发生了巨大的变化。</p><!-- [[[read_end]]] --><p>“比如，一系列的创新业务开始出现，移动支付取代了钱包、ATM机，我们用手机叫出租车、导航、骑共享单车，用手机点外卖，用手机看视频、玩游戏。总之，移动互联网改变了生活方式，也创造了很多新产业和新业态。”</p><p>“我们看到了通信基础设施发展的具体威力，所以希望5G能够做强做大移动互联网，甚至实现万物互联。技术是推动社会发展的根本，我们期待5G能够创造更大的价值，推动更多产业的发展。”</p><h3>毫米波是什么？</h3><p>“我刚才听您讲5G技术创新的时候，提到了一个新的频段，毫米波。请问毫米波到底是什么呢？”司马特接着问。</p><p>“毫米波是频率在30GHz到300GHz的电磁波。现在的蜂窝网络频率主要在3GHz以下，虽然这部分频率利用率并不高，但是能分配给5G使用的资源并不多，所以5G技术只能向高频率发展。不过毫米波因为频率高，波长自然就短，这导致穿透障碍物的能力不强。实践中，我们需要使用多天线波束成形技术来实现稳定的信号收发。”Vincent解释道。</p><h3>为什么要用Polar码？</h3><p>“您刚才还提到，5G会使用新的调制编码，Polar Code。关于这个编码，您能再多说明一下吗？”司马特问道。</p><p>Vincent笑道：“一看你就是个技术控。Polar码的提出充分说明了数学的重要性。之前的Turbo码都没有能达到香农极限，而Polar码基于信道极化的概念，在理论上已经可以达到香农极限，并且它的编解码算法的复杂度并不高。”</p><h3>SDN和NFV的意义是什么呢？</h3><p>“嗯，具体算法我回去查一下资料学习一下。”司马特说道：“那么5G网络架构中，SDN和NFV的意义是什么呢？”</p><p>Vincent介绍说：“这两个技术其实都来自IT领域，现在用到了通信领域。SDN主要是实现了控制和转发的分离，路由决策等控制功能由独立的控制器来统一处理，网络设备只负责具体的转发工作。这样可以通过编程来灵活定义网络功能。</p><p>“NFV是将传统的核心网功能部署到虚拟机上，从而实现硬件资源的高效利用。在5G网络架构中，SDN和NFV是结合起来使用的。这样网络可以根据负载情况灵活调度网络资源，实现网络高峰时的横向、纵向扩展。”</p><h3>如何思考5G在物联网中的具体应用呢？</h3><p>“明白了。最后一个问题，5G在物联网中有哪些具体应用呢？”司马特说道。</p><p>“你需要结合5G的发展阶段来考虑。从2019年我们国家的5G元年开始，起步阶段主要是eMBB的应用，也就是传统业务和高网络速率的应用，比如高清视频、云游戏。接着是低时延的渐进式发展，这个阶段有工业制造、自动驾驶、远程医疗等场景。最后是基于5G的海量物联网设备的接入和应用。应用场景的创新一定是一个不断探索、验证到正式商用的过程。”Vincent说道。</p><p>低头看了一眼手表，Vincent接着说道：“你也可以回头看看4G时代，新应用的诞生过程，这会有启发的。我必须得走了，否则时间来不及了。”</p><p>交流完，司马特满意地离开了报告厅，心里想着：“我对5G的理解，终于不是混沌一片了。改天也给小王他们几个科普科普。”。</p><h2>小结</h2><p>总而言之，5G是我们非常关注的通信技术，它蕴含着巨大的产业机会。接下来，我对司马特的笔记中的重点内容做一个梳理：</p><ol>\n<li>5G是物联网发展的重要基础，而物联网也是5G最重要的应用场景。5G的三大应用场景是eMMB超高速率移动带宽，uRLLC超高可靠低时延通信，和mMTC超大数量设备接入通信。其中uRLLC和mMTC都是面向物联网的应用场景。</li>\n<li>5G的特点主要有高速率、高地域覆盖、高连接数、高移动性、低时延和低功耗，这些也是5G的技术需求。</li>\n<li>5G的的无线通信技术主要有新型多址技术、新波形技术、大规模天线（Massive MIMO）、新调制编码技术和新频段通信等。</li>\n<li>5G的网络架构也在创新，包括接入网和核心网的功能融合、软件定义网络（SDN）和网络功能虚拟化（NFV）等。</li>\n<li>5G的标准化组织，国际上有ITU和3GPP，国内有IMT-2020（5G）推进组。</li>\n</ol><p><img src=\"https://static001.geekbang.org/resource/image/3d/37/3d5b25337c4b02a08947e14068f48137.jpg\" alt=\"\"></p><h3>思考题</h3><p>最后，我给你留一个思考题吧。</p><p>你使用过支持5G通信的手机吗，有什么使用感受呢？你认为随着5G技术的推广，还会有哪些创新应用和产品出现呢？</p><p>欢迎你在留言区写一写自己的思考。也欢迎你将这一讲分享给对5G技术感兴趣的朋友，大家一起交流学习。</p>",
                "article_title": "加餐四 | 5G技术将如何推动物联网的发展？"
            },
            {
                "title": "加餐五 | 投身物联网行业，如何做好职业规划？",
                "id": 332318,
                "content": "<p>你好，我是郭朝斌。</p><p>物联网是一个新兴行业，我想你选择进入物联网行业之前很可能有这样一个疑问：怎么做好自己的职业规划呢？</p><p>别着急，我们的老朋友司马特跟你也面临同样的问题，于是找到了学长求助，我们来看看他的学长是怎么说的吧。</p><p>今天是周日，司马特已经有了安排，中午要去拜访一位学长。这位学长在大学时期就是学校的“风云人物”，现在已经成为一家知名公司的中层管理者。司马特非常羡慕和崇拜他，并且把他当成自己的榜样，不断努力着。</p><p>司马特和学长是在一次同乡会上认识的，一直保持着联系。不过，平时他们各自忙于工作，虽然在同一座城市，见面的次数却不多。</p><p>最近司马特一直在思考下一步的职业发展，但是思路还是不清晰。今天好不容易约了一个饭局，他正盘算着好好请教一下学长。</p><p>吃过早餐，司马特开始看书。十点十五分，他听到了智能家庭管家的提醒。穿戴整齐后，司马特离开家，前往地铁站，他需要在十一点半赶到丽泽商城。那个商城离学长的家不远，司马特特意选在了那里，希望给学长省点时间。</p><p>十一点半，司马特到了丽泽商城，直接来到约定好的一家湘菜馆。他心里庆幸自己来得早，因为门口已经有人开始取号等待了，要是再晚一会儿，他等待的时间会更久。</p><p>很快就叫到了司马特的号码，他进入了餐厅，选了一个靠近墙角、比较安静的座位坐下。</p><!-- [[[read_end]]] --><p>十二点差五分的时候，学长终于到了，坐定后问道：“小特，你来得很早吧？我看外面等号的人很多。”</p><p>“还好了，没有太早，我到的时候，正好人还不多。你来点菜吧，我不太擅长。”司马特一边说，一边把菜单递过去。</p><h2>职业瓶颈</h2><p>点完菜，学长问司马特：“工作最近怎么样？”</p><p>司马特回答说：“最近工作上有些困惑，正想向你请教呢。”</p><p>学长示意他说下去，所以他接着说：“我感觉自己最近一年都没有明显的进步，做的事情难度不大，所以也提不起太大的兴趣。我是不是遇到职业瓶颈了？”</p><p>学长说：“<strong>瓶颈不可怕，天花板才可怕。<strong>遇到职业瓶颈有很多种原因，一种原因是</strong>自己的能力无法提高了</strong>。这在职业的初期比较少遇到，因为只要你肯学习，专业知识总是可以熟练掌握的。再加上现在的学习资源这么丰富，这么方便，学习的门槛更是大大降低了。以我对你的了解，你肯定不是这种情况。”</p><p>喝了一口水之后，学长接着说：“还有可能的原因是<strong>外部环境导致</strong>的，比如行业的趋势变化，影响了公司的业务发展，或者公司业务拓展的速度太慢等等。你们公司今年的业务的发展情况怎么样啊？”</p><p>司马特说：“公司今年业务挺好的，老产品销量不错，还开辟了一个新产品线。”</p><p>学长继续分析：“所以也不是公司成长的原因。据我了解，你们公司对员工的职业发展规划还是很完善的。那是不是你没有<strong>向领导提过自己的升职期望</strong>呢？”</p><p>司马特有些惊讶：“这怎么好意思主动提呢？上次我们老大问我‘你的职业规划是什么？’，我还不好意思地说‘听领导的安排’呢。”</p><p>学长听完，立即说：“这可千万不能不好意思啊！你工作已经有3年了吧，而且你的工作成绩很好，其实你已经符合晋升的条件了。但你们老大下面也有十来号人呢，如果你不主动说明自己的诉求，他是很难了解你的想法的。毕竟指标也有限，他不得已降低你的优先级，这种情况也是完全有可能的。”</p><p>这时，服务员端上来两道菜。在服务员走后，学长接着说：“而且，这会影响到工作任务的分配。你的工作没有挑战也是自然的事情了。”</p><p>司马特点头，表示明白了。</p><p>学长说道：“关于职业瓶颈，你也不需要太担心，分析出原因，去解决就是了。在你的职业生涯里面，你肯定还会遇到多次瓶颈，解决之道就是一个个跨过去。真正难突破的是天花板，这在小公司尤其常见。</p><p>“小公司层级少、业务小，一旦发展速度不够快，你很容易就会碰到职业的天花板，往往只能通过跳槽才能解决。不过你们公司足够大，已经给你提供了一个很好的平台。从这点说，你一毕业就站在了一个不错的起点。”</p><p>司马特感激地说：“我也是当时听取了你的建议，才进入了这个公司。”</p><p>学长摆摆手，说道：“我没有什么功劳，这是你努力学习，用你的才能争取来的。”</p><h2>把握职业节奏</h2><p>“不过，有一点我要提醒你。”学长接着说道，“你需要把握好自己职业发展的节奏。”</p><p>司马特问：“这个节奏要怎么把握呀？”</p><p>学长说道：“一个简单的方法是，<strong>每3年上一个台阶</strong>。这个‘3年’的数字不是定死的，你可能快一点，也可能慢一点，但是它可以提醒你对照自己的职业情况。”</p><p>吃了口菜，学长接着说：“时间是最宝贵的，失去了，你就永远也找不回来了。所以，千万不能停滞不前，否则短期内你可能看不出来，但是5年、10年过去你再看，可能已经跟别人拉开了很大的差距。”</p><p>司马特说：“确实是这样，那我要抓紧了，争取每年都有突破。”</p><p>学长提醒说：“你可千万不要从一个极端到另一个极端啊。每个人的职业生涯差不多都有二三十年，<strong>这是一场马拉松，而不是短跑冲刺</strong>。初期就是打基础、做好积累，不要太关注职位的提升、薪资的涨幅。否则你就成了揠苗助长，不利于自己职业的长期发展。”</p><p>司马特点了点头。</p><p>这时，服务员又端上两道菜，说道：“菜上齐了。祝你们用餐愉快。”</p><h2>先深度后广度</h2><p>司马特继续请教：“说到打基础，我一直有个疑问。我们上学的时候学得非常全面，计算机软硬件、通信技术、电子电路、传感器技术、网络安全、数据分析，甚至还有控制技术和物流管理等。但是工作中，我感觉好多东西都没有用到，这是不是基础打错了呢？”</p><p>学长思考了片刻，说道：“在学校学的主要还是通识性知识。虽然物联网专业的课程涵盖了很多不同的专业，但都只是对基本概念的了解，目的是让你有一个基本的认识。真正的职业基础还是从工作后开始积累的。</p><p>“打基础的一个基本原则是先选择一个方向，最好是自己感兴趣的方向，深入钻研下去，把这个方向变成自己的强项。然后再向外扩展自己的能力，也就是<strong>‘先深度后广度’</strong>。这样的话，你永远有一个根基，学习起其它知识，你也可以触类旁通。</p><p>“在拓展广度的时候，你仍然会遇到职业瓶颈。比如，你需要学习项目管理、团队管理、财务、营销等各种和你的专业完全不同的知识，这就需要你不断去突破自己。”</p><h2>积累通用能力</h2><p>司马特听完，有点沮丧：“这么多需要学习的东西啊，这怎么学得过来呢？”</p><p>学长鼓励道：“这没有你想象的那么难。因为你不一定要把每个技能都学到专家的程度，很多东西只要投入一定的时间，掌握个七七八八就够用了。而且，有些通用的能力，你只要不断积累，就会在各方面受益。”</p><p>司马特问道：“有哪些能力是通用的呢？”</p><p>学长说：“比方说<strong>沟通能力</strong>，无论你以后是继续从事技术专业的工作，还是走管理路线，它都非常重要。阐述技术构想的时候，你需要通过沟通来让大家真正理解，从而获得认可和支持。管理团队的时候，你也需要通过沟通来阐述团队目标，协调各种资源。”</p><p>司马特说道：“我感觉自己一直比较内向，不擅言辞。”</p><p>学长进一步鼓励说：“你放心，沟通能力你肯定可以不断提高。而且，你记住，关于沟通能力更重要的一点是，沟通不只是表达，还包括倾听。有效沟通的前提是听懂了对方，然后才能准确地回应，并且简单、清晰地表达出自己的意图。”</p><h2>职业相关书籍</h2><p>司马特听了学长的话，高兴地说：“那我有信心了。之前我只关注技术，以后我会多留意训练这方面的能力。学长你有什么书可以推荐给我学习吗？”</p><p>学长回答说：“我也只是工作了十年而已，对职场的认识也不一定全面。像《学习力》《金字塔原理》《麦肯锡工作法》这些讲具体的工作方法的书，我想别人也跟你推荐过了。这样吧，我给你推荐一本跟个人成长有关的书。</p><p>“这本书从更宏观的角度介绍了职业生涯的不同阶段，以及做好整个生涯职业规划的方法。书名是<strong>《远见：如何规划职业生涯的3大阶段》</strong>。你回头可以读一下，我相信一定会有收获的。”</p><p>司马特立即说：“我回去一定买来读一读。”</p><p>接着，他们一边吃饭，又一边聊了聊自行车骑行和家乡的话题。</p><p>饭菜吃得差不多了，学长看了一眼手表，说道：“我下午需要带孩子去上击剑课，今天我们只能聊到这里了。下次我们约着一起去骑行吧。”</p><p>“没问题。”司马特边说，边掏出手机，打算结账。结果，学长亮出手机，对司马特说已经支付了账单。司马特知道自己又晚了一步，也不再说什么。他们说笑着，一起走出了饭馆。</p><h2>小结</h2><p>总结一下，职业生涯是我们大部分人都要经历的一段旅程。在这段并不算短的旅程中，你可以从下面几个方面多思考：</p><ol>\n<li>职业瓶颈。意识到职业瓶颈是你在职业生涯中经常要面临的情况，你需要分析原因，并且不断突破。</li>\n<li>把握职业节奏。你需要不断对照自己的职业情况，有节奏地不断进取。</li>\n<li>先深度后广度。在专业技能上，你需要先关注深度，然后再扩展其它方面的能力。</li>\n<li>积累通用能力。有些能力是可以让你在多方面受益的，比如沟通能力，你要更早地关注这类能力的积累。</li>\n<li>职业相关书籍。关于职业生涯的规划，你可以读一读《远见：如何规划职业生涯的3大阶段》这本书。</li>\n</ol><p><img src=\"https://static001.geekbang.org/resource/image/10/6d/103416db77604eb6951b55d180e7b06d.jpg\" alt=\"\"></p><h2>思考题</h2><p>关于职业发展，你有什么困惑吗？欢迎在留言区和我交流，也欢迎你将这一讲分享给你的朋友，大家一起讨论交流。</p>",
                "article_title": "加餐五 | 投身物联网行业，如何做好职业规划？"
            }
        ]
    },
    {
        "chapterTitle": "用户故事",
        "children": [
            {
                "title": "用户故事 | 让野蛮生长成为职业发展的助推剂",
                "id": 326520,
                "content": "<p>你好，我叫Yueshi。</p><p>我是一名Java开发工程师，工作2年，坐标杭州。很荣幸有机会在这里分享学习《物联网开发实战》这门课程的心得。</p><h2>为什么学这门课程</h2><p>首先要感谢极客时间搭建了一个优秀的学习成长平台。当我在这个平台上看到郭朝斌老师的《物联网开发实战》这门课的时候，顿时兴趣十足，主要的原因有以下三点。</p><p>第一，<strong>环境</strong>。在我家里，小米生态链的东西林林总总加起来有几十件之多。在一个围绕着小爱同学构建的初级智能家居环境中，我实实在在地感受到了物联网的魅力。</p><p>享受便利的同时，我也经常想要去了解背后的实现原理，所以就趁着这个机会直接上车了。希望郭老师能带我打开物联网的大门，进一步深化自己对智能家居的理解。</p><p>第二，<strong>知识体系</strong>。当我看到郭老师贴出来的知识体系图时，就被深深地吸引了。以前我对物联网的技术体系是完全陌生的，但是看着这张图，我陷入了沉思：为什么还有一个行业用着和Java开发相似的技术栈，而我却对它一无所知？会不会还有很多行业用着和我们差不多的技术栈在蓬勃发展？我们的技术栈还是制约职业选择的重要因素吗？</p><p>这些疑问强烈地驱使着我去了解这些技术在物联网中是怎么运用的，跟我自己在工作中使用的有什么区别。</p><p><img src=\"https://static001.geekbang.org/resource/image/a3/64/a324a38ab7d0236bbef0a567288a2264.jpg\" alt=\"\"></p><p>第三，<strong>问题</strong>。生活在智能家居的环境中，我也在不断地探寻一些深层次的问题：什么是智能？智能仅仅是场景的联动吗？智能仅仅是简单的IF-ELSE吗？</p><!-- [[[read_end]]] --><p>智能究竟是什么，该怎么去定义，这个问题目前还没有标准的答案。只有亲自去实践，我们才能体会到智能的含义。</p><h2>学习课程的收获</h2><p>现在回顾一下，从这门课程中我学到了很多。课程每一讲都图文并茂，不仅定义足够简洁、准确，而且拓展的知识也指明了我们研究的路径。总的来说，我的收获主要体现在以下四个方面：</p><h3>1.  完善的知识体系</h3><p>正如郭老师在<a href=\"https://time.geekbang.org/column/article/305523\">开篇词</a>里说的：“物联网涉及的知识非常庞杂，包括通信技术、嵌入式开发、互联网系统、大数据、人工智能等等，甚至还有相关应用领域的专业知识。”我平时吸收的知识都是零散的、碎片化的，特别不利于物联网领域的学习。</p><p>但是在跟进这门课程的时候，郭老师带着我把这些零散的、碎片化的知识逐步网络化、系统化，让我对物联网建立了更全面、更立体的认知。</p><p><img src=\"https://static001.geekbang.org/resource/image/cf/f4/cf1139984e4bdcb6b53bbeb6e0f276f4.jpg\" alt=\"\" title=\"我的一部分笔记\"></p><h3>2.  知识网络的拓展点</h3><p>除了带来系统的认知，郭老师还给我指出了很多知识的<strong>拓展点</strong>（或者说知识的交互节点），而这些拓展点让知识的<strong>局域网</strong>变成了知识的<strong>互联网</strong>，实现了从“以点到面”进阶为“以面到体”的维度升级。</p><p>郭老师很自然地把这些重要的拓展点嵌入到课程中去，等待着我们去发现和探索，比如在第2讲补充的两个物联网行业专门的通信技术<a href=\"https://www.semtech.com/lora/what-is-lora\">LoRa</a>和<a href=\"https://build.sigfox.com/sigfox\">SigFox</a>，以及在介绍BLE（低功耗蓝牙）技术的时候，还特地准备了一份基础知识的<a href=\"https://learn.adafruit.com/introduction-to-bluetooth-low-energy/gatt\">资料</a>作为参考，可以说非常用心了。</p><h3>3. 动手操作的环境</h3><p>网上的各种教程浩如烟海，每一种都会教你搭建环境，教你快速入门。可是收藏了那么多教程之后，我却始终没有开始动手，没有去实现从0到1的突破。</p><p>一方面，当我面临的选择太多的时候，选择成本有时候比学习成本更大。</p><p>另一方面，网上虽然已经有一些 DIY 硬件设备的资料，但是大多都没有放在物联网的技术背景下去做。</p><p>所以我决定以这门课程为起点，完成从0到1的突破，借助极客商城的硬件套装和郭老师的操作教程，动手搭建操作环境，打出那一句“Hello World！”，毕竟“好的开始是成功的一半”嘛！</p><h3>4. 一群热情好学的同学</h3><p>其实不只是课程内容本身，留言区的问答和学习交流群的互动，同样是这门课程的精华所在。</p><p>留言区的用户提问，让这些知识经过不同的应用场景洗礼，越发显得生动立体；郭老师的认真回答，让这些知识经过进一步拓展，焕发出更强的生命力。而在交流群里热火朝天的讨论，让不同的思想碰撞，使得我们更加接近学习的本质。在这种氛围下，知识不再是冷冰冰的定义，而是像一个个生命体。</p><p>总的来说，在这门课程中，我学到了很多货真价实的物联网知识；而在留言区和交流群中，我也收获了很多应用和拓展的经验，这些都要感谢郭老师和热情好学的同学们。</p><h2>感触最大的两讲</h2><p>在这门课程中，有两讲是我觉得感触最大的，它们是<a href=\"https://time.geekbang.org/column/article/317861\">第13讲</a>《隐私：在实践中如何保护用户隐私？》和<a href=\"https://time.geekbang.org/column/article/319440\">第14讲</a>《安全：物联网平台如何应对安全风险？》。</p><p>这两讲的主题是隐私和安全，这两个词跟我们的日常生活关系非常密切。</p><p>当我们作为<strong>消费者</strong>时，是否足够在意隐私和安全，是否愿意为了隐私和安全买单，是否愿意成为良性市场的一份子，让市场的力量倒逼企业重视隐私和安全，从而促进行业准则的制定？</p><p>当我们作为<strong>开发者</strong>时，是否能做到比公司的开发要求多想一步，多思考一些？很多公司面临的机会和挑战是相似的，也许每次多思考一点，会成为我们在横向对比中胜出一筹的关键。</p><p>讨论隐私和安全，也不仅是局限当下，也是在放眼未来。未来的问题需要我们分配怎样的精力去面对和解决，是用长远的规划去提早应对变化还是着眼于当下更稳地走好每一步？这些开放式的问题，可能也需要我们不断思考和实践，锤炼出高超的职业素养之后才能回答。</p><h2>我对学习方法的思考</h2><p>接下来，我想聊聊对学习方法的思考。</p><p>设想这样的一个场景，在你面前有一堆陌生的零件和一份说明书，你需要把它们组装成一个能正常工作的产品，你会采取什么路径来解决这个问题呢？</p><p>你可能会先观察零件，试着组装一下，发现没那么简单之后，然后再去研究说明书，在说明书的指导下完成组装。</p><p>你也可能会直接把说明书摊开，一边看说明书，一边组装。</p><p>你还可能先快速地过一遍说明书，形成大致的印象后就开始组装。</p><p>但我想，应该没有人会先去仔细学习说明书，把说明书上的每一个知识点都了解得滚瓜烂熟以后，再动手开始组装吧？</p><p>现在我们看一下这门课程的安排，它分为基础篇、进阶篇和实战篇三个模块。假如把基础和进阶篇比作说明书，把实战篇比作我们动手组装的过程，你又会怎么安排学习进度呢？</p><p>我先分享一下我的学习计划：</p><p><strong>第一步，跟着课程的节奏，形成课程的完整画像，做到心中有课程大纲。</strong></p><p>这一步在于跟着老师的讲述，有序地梳理课程的脉络，做到心中有课程大纲，知道各个知识点分别在哪个篇章，能够快速地定位到它们。这一步同时也注重节奏，尽量避免“攒一波，一起消化”结果却消化不良的状况。</p><p><strong>第二步，跟着实战环节，通过动手去实践学到的知识，不断地在场景中深化对知识的理解。</strong></p><p>实战这一步是一个不小的挑战，要充分利用好交流群的作用。很可能自己遇到的问题别人也遇到过，并且已经有很成熟的解决方案。这个阶段的主要目的就是搭建预想的智能场景，通过第一步建立的知识点索引体系快速地找到不清楚的知识点并做补充。</p><p><strong>第三步，完成了实战环节，通过总结和回顾去形成体系化的知识总结。</strong></p><p>因为已经快接近课程尾声了，我会快速地过一遍课程的内容，然后以文字形式记录课程中的关键知识点，整理出知识网络图。</p><p><strong>第四步，沿着自己的兴趣去拓展知识网络。</strong></p><p>在前三步完成后，我还会根据自己感兴趣的方向去拓展知识体系。</p><p>在技术上，有一种叫做“银弹”的理想化方式，能一劳永逸地解决工程上的问题。但是计算机科学家<a href=\"http://wanweibaike.com/wiki-%E5%BC%97%E9%9B%B7%E5%BE%B7%E9%87%8C%E5%85%8B%C2%B7%E5%B8%83%E9%B2%81%E5%85%8B%E6%96%AF\">佛瑞德·布鲁克斯</a>却告诉我们，<strong>“没有银弹”</strong>。<br>\n<img src=\"https://static001.geekbang.org/resource/image/6c/8b/6cfddc61066b84a126abf9551c7bdf8b.jpg\" alt=\"\"><br>\n同样的道理，在学习中，也不存在“银弹”。我们在学习的时候，就不要妄想一劳永逸了，真正的知识只有在反复阅读和思考之后才能提炼出来的。我们必须摒弃“一遍就会”的想法，只有时常回顾、点面俱到，才能彻底地掌握到知识要点。</p><p><strong>毕竟学习的本质就是不断重复+刻意练习+不断思考。</strong></p><h2>成长的本质是野蛮生长</h2><p>最后，我还想谈谈关于成长的思考。</p><p>自从参加工作以来，我们就一心扑到自己的专业领域中，稳扎稳打、逐步提升。专业上的精进既为我们带来了职位、薪资和阅历的提升，也悄悄地为我们埋下了一些不好的种子。</p><p>在专业领域上越探越深的同时，我们的视野却可能会变得越来越窄，思考方式也可能会变得越来越单一，我把这种现象称为<strong>“发展的孤岛效应”</strong>。（你可以打开公众号，统计一下关注的占比；也可以尝试设想一个完全陌生的岗位一天的工作内容是什么，然后验证自己的设想是否准确。）</p><p>怎样摆脱这种束缚呢？我自己的看法是，<strong>技术的野蛮生长</strong>。</p><p>我们都在羡慕年轻人，公司也喜欢年轻人，整个社会大环境都在迎合年轻人。可是当我们羡慕年轻人的时候，我们究竟在羡慕什么？是面对困难的勇气？是朝气蓬勃的精神？还是在其身上找到当年自己的影子？</p><p>也许这些都是正确答案，但是对我来说，羡慕的是年轻人身上的<strong>无限种可能</strong>。</p><p>回想在校园的时光，我们的学习无拘无束，我们的研究单纯又高效，我们可以对单片机玩得痴迷，也可以对数学建模颇感兴趣，还可能为了学习拉普拉斯变化和傅立叶变化，去研究拉普拉斯和傅立叶的个人事迹。这种状态就是我所说的野蛮生长的状态，一切都是兴趣使然。</p><p>虽然这样的效率并不高，可当我们回头看一看的时候，却无比羡慕这种状态。</p><p>不知从什么时候开始，我们被“高效”这个词语给奴役。资本家要求我们高效工作，相亲市场要求我们高效配对，房价也要求我们高效赚钱；同时，我们也开始用“高效”去要求身边的人和事，我们要求高效地学习，高效地购物，甚至连上班通勤和外卖订单，我们都要求高效。</p><p>高效确实一种很厉害的状态，但它并不是人生的终极目的。在越来越快的节奏中，我们不能忘了成长的本质。</p><p>成长的本质是什么呢？我觉得就是<strong>野蛮生长，释放天然的学习热情，解锁人生的无限可能，不那么功利，不预设目的，尽情地去体验和感悟人生。</strong></p><h2>总结</h2><p>不知道你有没有注意到，在这次分享中我特意使用了“同学”这个词。</p><p>我们所处的时代，正是技术大爆炸的时代；我们所熟悉的技术，可能用不到五年就已经有了巨大地变化了。只有不断学习，我们才能在这个变革的年代找到自己的一席之地。</p><p>在工作中，我们面临着薪资和职级倒挂、中年危机、中产阶级陷阱和35岁末日之类的各种压力，我们只有不断学习，不断成长，才能让自己此刻稍微安心一些。</p><p>所以我今天的分享如果用一句话来概括就是，<strong>让野蛮生长成为职业发展的助推剂。</strong></p><p>不知道你是怎么学习这门课程的？有没有什么独特的学习方法和心路历程呢？欢迎你在留言区分享，我们一起交流，相互鼓励，共同进步！</p>",
                "article_title": "用户故事 | 让野蛮生长成为职业发展的助推剂"
            },
            {
                "title": "用户故事 | 转战物联网，我相信天道酬勤",
                "id": 331471,
                "content": "<p>你好，我叫谭方敏。</p><p>我是一名物联网架构师，坐标广州，目前已经工作十四年了，很高兴有机会能跟你分享自己学习《物联网开发实战》这门课程的心得。</p><h2>为什么要学这门课？</h2><p>首先我想跟你聊一聊为什么要学这门课，主要有三个方面原因。</p><p><strong>第一，完善物联网知识体系。</strong></p><p>在游戏行业泡了10年之后，因为一个偶然的机会，我进入了物联网行业，到现在差不多4年了。转行之后虽然也遇到了不少问题，但我依靠自己的摸索，一路上都有惊无险地解决了。</p><p>不过我毕竟是半路出家，底子不够厚，还是希望能全面地了解物联网的知识体系。我觉得一个人的技能应该长成一棵完整的大树，而不是一堆零乱的杂草，这样才拥有核心竞争力。</p><p><strong>第二，尝试物联网全生态的落地实践。</strong></p><p>知识不用，自然就会荒废。只有在实践中不断地消化和理解知识，才能形成闭环，做到知行合一，真正产生价值。</p><p>物联网的整个生态分为设备层、网络层和应用层，而我一直专注于应用层的研发，在工作中很少直接接触设备层和网络层。而在这门课程中，郭老师在实战篇介绍了几个实战小项目，这对我来说是一个很好的机会，让我能够打通全生态，完成整个物联网知识栈的建设。</p><p><strong>第三，为创业寻找方向和思路。</strong></p><p>2012年我在游戏行业的创业失败，到现在已经快十年了。我一直认为创业就是一个严谨的科学实验。复盘失败的原因，我发现自己在各个层次上都或多或少缺少某些创业者必备的能力。所以在一顿恶补之后，我也希望能看看还差多少。</p><!-- [[[read_end]]] --><p>另外，物联网相对互联网而言，从发起创业项目到真正落地，并不需要那么多的资源。一个简单的智能家居项目，成本也许可以控制在1000元以内，时间也可以控制在一周左右，这就勾起了我的创业兴趣。</p><p>最后，疫情这个外部环境深刻地影响着每个人，我们都需要去思考如何面对不确定性。一般来说，创新型创业是一件非常烧钱的事情，而物联网则先可以孵化一些小项目，用极低的成本完成前期的原型验证。</p><h2>我是怎么学习课程的？</h2><p>以前看到过一句话，我觉得说得挺好的：学习是个耗能的过程，所以想要效率更高，你就要尽量调用身体各个器官储备的能量一起来完成这件事情，包括五官、大脑和四肢。</p><p>记得当年我背英语单词那会儿，条件可比现在艰苦多了，因为音频资料获取途径不多，非常珍贵。我边读边写边思考，才实现了大二就通过大学英语六级的目标。</p><p>同样的道理，学习这门课程也得尽量调动身体储备的能量。我觉得学习是一个费力费神的事情，首先就要做好思想准备，否则你就把学习当成kill time的方式了。</p><p>我学习用的是土方法。因为如果太讲究方法，就会导致操作难度太高，很难长期坚持下去。知识的学习过程是一个“润物细无声”的过程，所以我们还是尽量采用相对自然的方式比较好。</p><ol>\n<li>第一遍对照文字听，熟悉文字内容。</li>\n<li>做笔记，将要点记录下来。</li>\n<li>盲听3～4遍，一般是通勤路上，比较方便。</li>\n<li>跟这门课程的同学互动。</li>\n</ol><p>在互动的过程中，我会尽量抽空回答同学们的问题，知无不言，言无不尽。这样做会让知识更容易形成闭环，加深我自己对知识理解，并且还有机会意外获得同窗的“革命友谊”。</p><p>比如“mosquito”同学曾经提过一个问题：“能否将消息存储在数据库或者redis中？”我当时就明确地告诉他，有相关的插件。（不过这样的互动大部分都发生在微信交流群，课程留言区的相对少一点。）</p><p><img src=\"https://static001.geekbang.org/resource/image/ff/ce/fff6b408yyc5f9d12fe7b2599c8890ce.png\" alt=\"\" title=\"我的一部分学习笔记\"></p><h2>学习过程中遇到过什么有趣的经历？</h2><p>古语云：“读万卷书不如行万里路，行万里路不如阅人无数。”</p><p>这个道理也可以用在现代职场。当你学会一些东西的时候，最好去跟面试官“对打”，打得过就赢得了一份工作，打不过也获得了一次深度沟通和交流的机会。毕竟翻到行业大佬牌子的机会不多呀，应该好好珍惜。</p><p>前段时间我去面试，发现面试官可能是极客时间铁粉，并且极有可能就是《物联网开发实战》这门课程的同学。他问了好几个问题，都是这门课讲过的。</p><p>比如，物联网跟互联网的区别是什么？</p><p>物联网=互联网+物（设备）。这是郭老师在第1讲探索物联网定义的时候说明的。</p><p>又比如，智能快递柜不能使用发布订阅的原因是什么？</p><p>因为关门指令和关门动作是分开的。郭老师在第3讲中介绍网络协议的时候解释过。</p><p>再比如，批处理跟流处理的区别？</p><p>批处理的关键点有离线数据、延迟、以Mapreduce/Spark为代表；流处理的关键点有实时数据、低延迟、以Storm/Flink/Spark Streaming为代表。这些知识，郭老师在第11讲解读数据处理框架的时候都详细说明过。</p><p>我发现面试官居然在帮我复习这门课程的知识，感觉特别亲切。虽然最后没有一起合作，但是这种经历还是蛮有趣的。传统意义上，面试只是为了找工作，而今天，它更像是一个跟行业专家深度交流与沟通的机会。</p><h2>学习课程有什么收获？</h2><p>我觉得到目前为止，自己学习这门课程的收获主要分为两个方面。</p><p>第一个方面是<strong>刷新概念</strong>。</p><p>在学习课程之前，我就看过《图解物联网》这本书，对物联网建立了基本的整体认识。比如整个物联网可以分为5个环节，分别是设备、传感器、网络、物联网服务和数据分析。我觉得这种分法挺好的。</p><p>不过在这门课程中，郭老师把物联网的知识体系简化为三层，分别是设备层（传感器+网络），网络层（网络），应用层（物联网服务+数据分析），这样界定业务边界的时候就更方便了。</p><p>我原来以为，把物联网服务处理好就相当于把应用层搞定了。学习课程之后才发现，应用层边界可不只是物联网服务（准确地说，这个算物联网接入层+部分业务逻辑），还包括数据分析这块。意识到这一点之后，我大吃一惊，马上就去强迫自己更新数据分析的技能树了。</p><p>另外，我以前对物联网数据的理解也不够深刻。我会把数据分为三个阶段，分别是数据采集（数字化）、数据传输（网络化）和数据分析应用（智能化）。</p><p>而在这门课程中，郭老师分成了五个阶段，分别是数据源数据采集、数据传输、数据存储、数据处理和数据分析应用，其中数据分析应用还进一步细化成三个部分，数据存储，数据处理和数据应用。这样学习和实践的时候，就更能做到有的放矢了。</p><p>业内实践派也有一些更加接地气的分法，比如比较常见的“云端数”。所谓的云是<strong>物联网云</strong>（类似于阿里飞燕平台）；端主要是<strong>设备端</strong>，有一些还会包括<strong>业务端</strong>；数则是指数据平台（大数据）。</p><p>这个分法则在更大尺度上界定了物联网各个部分的边界，也从一定程度上提炼了物联网生态最有价值的关键元素，数的提出更明确地确定了大数据在物联网生态的重要性，以及数据分析作为物联网全流程中必不可少的一环。在智慧系列项目里面，这种提法还是比较多的。</p><p>第二个方面是<strong>获得新知</strong>。</p><p>我在原来的公司主要负责物联网平台这一块，所以对配网方面的知识不够了解。而在这门课程的第2讲中，郭老师把设备配网解释得很清楚，Wi-Fi设备配网需要解决两个问题。</p><ol>\n<li>连上路由器（Wi-Fi或AP），实现数据上传和远程控制，也就是说，设备要获取到Wi-Fi热点的名称（SSID）和密码。</li>\n<li>获取Wi-Fi设备的MAC地址，或者生产时预存的信息，并与用户账号一起上传服务器，完成绑定。</li>\n</ol><p>具体来说，有两种实现方式，一种是smart config，另一种是设备热点。<br>\n<img src=\"https://static001.geekbang.org/resource/image/e3/5e/e320c19b0393e136e0cc765b99ab665e.jpg\" alt=\"\"><br>\n我在负责物联网平台的应用和开发的时候，为了更好地辅助运营小伙伴决策以及我们研发人员对业务做监控，在日常开发当中，我们会采用埋点打日志的方式。</p><p>我们注意到，很多智能设备一旦下线，就长期处于失联状态。将智能设备连接上物联网云各个环节拆解后，我们发现配网过程的成功率非常低，甚至有些设备除了第一次是成功的，之后的配网就再也没有成功过。</p><p>在学习郭老师的课程后，我们知道了，除了smart config之外，还有设备热点配网和手机热点配网等方式。于是我们把配网方式从一开始选择的smart config，换成了设备热点配网，从而在一定程度上改善了配网成功率。最终，我们在公司范围内推广了这个思路。</p><h2>总结</h2><p>从社会发展趋势来看，现在我们正处于互联网和物联网的过渡阶段，物联网很有可能会进一步成为新的网络基础设施，所以这门课程让我觉得非常有价值。</p><p>我在写这篇文章的时候，课程已经更新到第22讲，接近尾声，实战部分的内容悉数登场。目前，我已经完成了第一个产品场景，可以手机控制的智能电灯，并且接入了自己的物联网平台，真正实现了云端数一体化的目标。</p><p>当初我从做了10年的游戏行业转战物联网，就曾下定决心要“Make myself distinctive”，如今已经在物联网行业，自当努力奋斗。我相信天道酬勤，所有的付出都是值得的，不管是学知识，还是知识以外的其他内容。</p><p>在个人成长过程中，除了纵向地学习，建立自己的知识体系技能树之外，还需要横向地向同行学习，以技会友，相互切磋，补足或者加深自己在不同场景下的理解。即便同样是智能家居范畴，扫地机器人跟家用照明系统就完全不一样，技术不仅仅需要结合业务，更需要结合场景以形成深度认知。</p><p>最后，我想再分享孟子的一句话：“天降大任于是人也，必先苦其心志，劳其筋骨，饿其体肤，空乏其身，行拂乱其所为，所以动心忍性，曾益其所不能。”</p><p>与诸君共勉！</p>",
                "article_title": "用户故事 | 转战物联网，我相信天道酬勤"
            }
        ]
    }
]