exports.category = "frontend";
exports.title = "type-script入门实战笔记";
exports.data = [
    {
        "chapterTitle": "开篇词",
        "children": [
            {
                "content": "<p data-nodeid=\"1081\" class=\"\">你好，我是乾元，在 10 年的前端开发工作中，我曾就职于去哪儿、搜狗等大厂。作为核心成员，我曾负责过多个前端框架、组件库、开源项目核心模块的开发和维护，还为知名 MVVM 框架 Avalon 核心模块贡献过十多个 Commit。</p>\n<p data-nodeid=\"1082\">2018 年起，我正式推动 TypeScript 在部门级业务方向的全面应用。至今，我构建了 TypeScript + React、Redux、Nest.js 的全栈技术生态，并积累了丰富的 TypeScript 设计开发经验。同时，我还从 0-1 打造了一支全栈技术架构团队，目前该团队已平稳支撑了公司数百个业务项目。</p>\n<p data-nodeid=\"1083\">我是在什么样的机缘巧合下与 TypeScript 相逢的呢？这不得不提起当时的一场面试经历。</p>\n<h3 data-nodeid=\"1084\">一次激发我好奇心的面试经历</h3>\n<p data-nodeid=\"1085\">2018 年的一场社招面试中，我见到了一个来自微软的 C# 技术栈转前端的候选人。</p>\n<p data-nodeid=\"1086\">当时，前端的面试套路中必然包含 JavaScript 隐式类型转换的知识点，如下代码所示：</p>\n<pre class=\"lang-java\" data-nodeid=\"1087\"><code data-language=\"java\">[] == <span class=\"hljs-string\">''</span>\n</code></pre>\n<p data-nodeid=\"1088\">而这个候选人的回答让我很是诧异，一个从国际大厂出来的面试者，似乎并没有掌握 JavaScript 隐式类型转换的规则。</p>\n<blockquote data-nodeid=\"1089\">\n<p data-nodeid=\"1090\"><strong data-nodeid=\"1165\">注意</strong>：隐式类型转换的规则是当 == 操作符两侧的值不满足恒等时（===），则先将空数组转换为字符串类型，然后再进行恒等比较。</p>\n</blockquote>\n<p data-nodeid=\"1091\">我好奇地问他：“难道平时你都不关注这些基础知识？”</p>\n<p data-nodeid=\"1092\">他回答：“虽然平时使用 TypeScript，但是并不需要关注这些规则。”</p>\n<p data-nodeid=\"1093\">虽然这场面试并不算成功，但激发了我的好奇心：<strong data-nodeid=\"1173\">TypeScript 真的能将我们从隐式类型转换等 JavaScript 的各种坑中拯救出来</strong>？</p>\n<p data-nodeid=\"1094\">于是，我开始在业务应用中尝试引入 TypeScript。通过使用静态类型约束 React 组件 Props 和 State，我发现它与使用 JavaScript 相比，不仅支持在任何地方直观地获取组件的接口定义，还能对属性、状态中的值是否为空进行自动检测并给出提示（容错处理），甚至还支持对 React JSX 元素接收的各种属性、方法的检测和提示。</p>\n<p data-nodeid=\"1095\"><strong data-nodeid=\"1179\">这样看来 TypeScript 实在是太香了，这让我萌生了在接口调用、Redux 代码中全面引入 TypeScript 的想法</strong>。</p>\n<p data-nodeid=\"1096\">2018 年中，我开始做 To B 应用。考虑到 To B 应用的业务逻辑及其复杂性，它对代码的稳定性、易读性、可维护性要求极高，而这正高度契合 TypeScript 的优势。于是，<strong data-nodeid=\"1185\">我正式开始推广全栈式 TypeScript 技术方案</strong>。</p>\n<p data-nodeid=\"1097\">在接下来的两年多时间里，这套技术方案支撑了数百个应用的 Web 端、Node.js 端开发，接受了近百万行业务代码的实践考验。相对于 JavaScript 应用而言，TypeScript 使得许多低级的 Bug 在开发阶段就能被检测出来并得到快速解决，显著提升了项目的整体质量和稳定性。</p>\n<p data-nodeid=\"1098\">在见证业务发展的同时，我还见证了 TypeScript 版本从 3.0 迭代到 4.1，最终成了极其成熟且强大的语言和工具。其中，它有诸多重量级特性发布：</p>\n<ul data-nodeid=\"1099\">\n<li data-nodeid=\"1100\">\n<p data-nodeid=\"1101\">unknown（3.0）</p>\n</li>\n<li data-nodeid=\"1102\">\n<p data-nodeid=\"1103\">stricter generators（3.6）</p>\n</li>\n<li data-nodeid=\"1104\">\n<p data-nodeid=\"1105\">optional chain（3.7）</p>\n</li>\n<li data-nodeid=\"1106\">\n<p data-nodeid=\"1107\">type-only import &amp; export（3.8）</p>\n</li>\n<li data-nodeid=\"1108\">\n<p data-nodeid=\"1109\">template literal（4.1）</p>\n</li>\n</ul>\n<p data-nodeid=\"1110\">现如今，当我再次回味起那位候选人的回答，才明白 TypeScript 可能压根就不允许这么使用。因为当你写下 [] == ' '，立刻会收到一个红色波浪标注的 ts(2367) 错误提示。</p>\n<h3 data-nodeid=\"1111\">TypeScript 有这么好用吗？</h3>\n<h4 data-nodeid=\"1112\">1. TypeScript 的本质</h4>\n<p data-nodeid=\"1113\">TypeScript 与 JavaScript 本质并无区别，你可以将 TypeScipt 理解为是一个<strong data-nodeid=\"1212\">添加了类型注解的 JavaScript</strong>，比如 const num = 1，它同时符合 TypeScript 和 JavaScript 的语法。</p>\n<p data-nodeid=\"1114\">此外，TypeScript 是一门中间语言，最终它还需要转译为纯 JavaScript，再交给各种终端解释、执行。不过，<strong data-nodeid=\"1217\">TypeScript 并不会破坏 JavaScript 既有的知识体系，因为它并未创造迥异于 JavaScript 的新语法，依旧是“熟悉的配方”“熟悉的味道”。</strong></p>\n<h4 data-nodeid=\"1115\">2. TypeScript 更加可靠</h4>\n<p data-nodeid=\"1116\">在业务应用中引入 TypeScript 后，当我们收到 Sentry（一款开源的前端错误监控系统）告警，关于“'undefined' is not a function”“Cannot read property 'xx' of null|undefined” 之类的低级错误统计信息基本没有。<strong data-nodeid=\"1235\">而这正得益于 TypeScript 的静态类型检测，让至少 10% 的 JavaScript 错误（主要是一些低级错误）能在开发阶段就被发现并解决。</strong></p>\n<p data-nodeid=\"1117\">我们也可以这么理解，在所有操作符之前，TypeScript 都能检测到接收的类型（在代码运行时，操作符接收的是实际数据；静态检测时，操作符接收的则是类型）是否被当前操作符所支持。</p>\n<p data-nodeid=\"1118\">当 TypeScript 类型检测能力覆盖到整个文件、整个项目代码后，任意破坏约定的改动都能被自动检测出来（即便跨越多个文件、很多次传递），并提出类型错误。因此，你可以<strong data-nodeid=\"1242\">放心地修改、重构业务逻辑，而不用过分担忧因为考虑不周而犯下低级错误</strong>。</p>\n<p data-nodeid=\"1119\">接手复杂的大型应用时，TypeScript 能让应用易于维护、迭代，且稳定可靠，也会让你更有安全感。</p>\n<h4 data-nodeid=\"1120\">3. 面向接口编程</h4>\n<p data-nodeid=\"1121\">编写 TypeScript 类型注解，本质就是接口设计。</p>\n<p data-nodeid=\"1122\">以下是使用 TypeScript 设计的一个展示用户信息 React 组件示例，从中我们一眼就能了解组件接收数据的结构和类型，并清楚地知道如何在组件内部编写安全稳定的 JSX 代码。</p>\n<pre class=\"lang-typescript\" data-nodeid=\"1123\"><code data-language=\"typescript\"><span class=\"hljs-keyword\">interface</span> IUserInfo {\n  <span class=\"hljs-comment\">/** 用户 id */</span>\n  id: <span class=\"hljs-built_in\">number</span>;\n  <span class=\"hljs-comment\">/** 用户名 */</span>\n  name: <span class=\"hljs-built_in\">string</span>;\n  <span class=\"hljs-comment\">/** 头像 */</span>\n  avatar?: <span class=\"hljs-built_in\">string</span>;\n}\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">UserInfo</span>(<span class=\"hljs-params\">props: IUserInfo</span>) </span>{\n  ...\n}\n</code></pre>\n<p data-nodeid=\"1124\"><strong data-nodeid=\"1253\">TypeScript 极大可能改变你的思维方式，从而逐渐养成一个好习惯</strong>。比如，编写具体的逻辑之前，我们需要设计好数据结构、编写类型注解，并按照这接口约定实现业务逻辑。这显然可以减少不必要的代码重构，从而大大提升编码效率。</p>\n<p data-nodeid=\"1125\">同时，你会更明白接口约定的重要性，也会约束自己/他人设计接口、编写注解、遵守约定，乐此不疲。</p>\n<h4 data-nodeid=\"1126\">4. TypeScript 正成为主流</h4>\n<p data-nodeid=\"1127\">相比竞争对手 Facebook 的 Flow 而言，TypeScript 更具备类型编程的优势，而且还有 Microsoft、Google 这两家国际大厂做背书。</p>\n<p data-nodeid=\"1128\">另外，<strong data-nodeid=\"1268\">越来越多的主流框架</strong>（例如 React、Vue 3、Angular、Deno、Nest.js 等）<strong data-nodeid=\"1269\">要么选用 TypeScript 编写源码，要么为 TypeScript 提供了完美的支持</strong>。</p>\n<p data-nodeid=\"1129\">随着 TypeScript 的普及，TypeScript 在国内（国内滞后国外）成了一个主流的技术方向，国内各大互联网公司和中小型团队都开始尝试使用 TypeScript 开发项目，且越来越多的人正在学习和使用它。</p>\n<p data-nodeid=\"2420\" class=\"te-preview-highlight\">而能够熟练掌握 TypeScript 的开发人员，<strong data-nodeid=\"2426\">将能轻松拿下大厂 Offer</strong>。下面我截取了拉勾招聘官网的一些大厂招聘要求，你可以参考。</p>\n\n\n\n<p data-nodeid=\"1131\"><img src=\"https://s0.lgstatic.com/i/image6/M01/3D/3F/Cgp9HWCToWWAd44HAA6s79WBA5M709.png\" alt=\"Drawing 1.png\" data-nodeid=\"1280\"></p>\n<h3 data-nodeid=\"1132\">好工具，需要好的学习方式</h3>\n<p data-nodeid=\"1133\">TypeScript 在国内成为主流技术方向的时间较晚，大概在 2018 年左右才开始流行。相应地，本土化学习资料也比较匮乏。</p>\n<p data-nodeid=\"1134\">2018 年 9 月，在我推广 TypeScript 之际，就连 Babel、create-react-app 官方对 TypeScript 的支持都还不太友好，我主要通过 Medium 等国外资源查阅大量关于 Best Practice of TypeScript、React + TypeScript、Redux + TypeScript 的文章，最终设计并架构了面向部门业务的 TypeScript 技术栈。</p>\n<p data-nodeid=\"1135\">伴随着业务的成长，不断有新同学加入，而很多新同学其实并没有任何 TypeScript 开发的经验。那么，如何让更多同学更快速、有效地掌握技术栈，就成了我想解决的关键问题。因此，我又制作了系列培训内容帮助新人快速成长。<strong data-nodeid=\"1288\">本课程正是基于此前的实战经验精炼而成，旨在帮助你快速掌握 TypeScript 技术栈，学会构建高可读性、高稳定性前端应用。</strong></p>\n<p data-nodeid=\"1136\">结合<strong data-nodeid=\"1306\">上百个业务应用开发经验</strong>总结，我将课程划分为<strong data-nodeid=\"1307\">入门、进阶、实战</strong>3 个模块，讲解的都是<strong data-nodeid=\"1308\">真实业务场景</strong>中<strong data-nodeid=\"1309\">最实用的知识点，绝非纸上谈兵</strong>。按照知识点的顺序和难易程度，共计 22 讲。</p>\n<ul data-nodeid=\"1137\">\n<li data-nodeid=\"1138\">\n<p data-nodeid=\"1139\"><strong data-nodeid=\"1313\">模块 1：TypeScript 入门</strong></p>\n</li>\n</ul>\n<p data-nodeid=\"1140\">我将介绍 TypeScript 环境搭建，并结合浅显易懂的示例与应用场景讲解 TypeScript 基础类型，也会分享我作为过来人学习 TypeScript 时总结的经验和教训，让你尽量少走弯路，直达重点。<strong data-nodeid=\"1318\">这部分内容是掌握 TypeScript 编程的一块敲门砖，学完之后，你将对 TypeScript 的核心知识和概念有个整体印象。</strong></p>\n<ul data-nodeid=\"1141\">\n<li data-nodeid=\"1142\">\n<p data-nodeid=\"1143\"><strong data-nodeid=\"1322\">模块 2：TypeScript 进阶</strong></p>\n</li>\n</ul>\n<p data-nodeid=\"1144\">主要讲解类型守卫、类型兼容、工具类型等概念，及其在实际业务中的作用和使用技巧，助你快速成长为玩转 TypeScript 高阶开发的“魔法师”。<strong data-nodeid=\"1327\">学完之后，能加深你对进阶知识和工具的理解，并教你掌握造轮子（打造自己的工具类型）进行类型编程的能力。</strong></p>\n<ul data-nodeid=\"1145\">\n<li data-nodeid=\"1146\">\n<p data-nodeid=\"1147\"><strong data-nodeid=\"1331\">模块 3：实战指南</strong></p>\n</li>\n</ul>\n<p data-nodeid=\"1148\">我将结合业务实战经验系统化地讲解 TypeScript Config 配置、TypeScript 常见错误分析定位、浏览器和 Node.js 端开发等知识，以及 JavaScript 项目改造实践。让我们既可以按需定制 TypeScript 类型系统行为和转译产物，还能在碰到官方文档较少提及的各种错误时，快速地对问题进行定位和修复。另外，无论是从零开始的新项目，还是历史遗留的技术债，我们都能有章可循地引入 TypeScript。</p>\n<p data-nodeid=\"1149\">并且，<strong data-nodeid=\"1337\">此模块我会穿插分享历经数百个应用开发总结出来的 TypeScript 开发最佳实践经验，助你在业务开发中得心应手地应用 TypeScript，并获得 TypeScript 在 Web 和 Node.js 端最佳开发实践的建议。</strong></p>\n<p data-nodeid=\"1150\">TypeScript 发版频繁，特性日新月异，从构思课程到截稿，TypeScript 已经发布了 4.1、4.2 版本（当你读到这段文字，也有可能又发布了 4.3、4.4……），不过核心知识和思想并未过时。<strong data-nodeid=\"1342\">当然，在最后的结束语中，我也会介绍一些新版本比较重要的特性。</strong></p>\n<h3 data-nodeid=\"1151\">讲师寄语</h3>\n<p data-nodeid=\"1152\">看明白知识点很容易，而难点在于融会贯通。除了关注工程实践，我们更应该关注核心知识点的深入理解和吸收，避免从理论到实践无从着手的无力感，因为<strong data-nodeid=\"1349\">只有吃透其中的原理（生硬的知识点），才能真正打造属于自己的强有力武器</strong>。</p>\n<p data-nodeid=\"1153\" class=\"\">本专栏经过精心打磨，并巧妙打磨大量示例，带你轻松学习、有效吸收。你还在犹豫吗？赶紧搭上 TypeScript 学习班车，大厂 Offer 就在前方！</p>",
                "article_title": "开篇词 | 你为什么要选择 TypeScript？",
                "title": "开篇词 | 你为什么要选择 TypeScript？",
                "id": 7432
            }
        ]
    },
    {
        "chapterTitle": "模块一：TypeScript 入门",
        "children": [
            {
                "content": "<p data-nodeid=\"1421\" class=\"\">“工欲善其事，必先利其器。”因此，在正式讲解 TypeScript 之前，我们有必要先掌握 TypeScript 开发环境的搭建及相关注意事项。</p>\n<h3 data-nodeid=\"1422\">IDE for TypeScript</h3>\n<p data-nodeid=\"1423\">在搭建 TypeScript 环境之前，我们需要先认识几款适合 TypeScript 的 IDE。只有这样，在开发时我们才能根据实际情况选择合适的 IDE 进行安装，从而提升工作效率。</p>\n<h4 data-nodeid=\"1424\">VS Code</h4>\n<p data-nodeid=\"1425\">如果让我推荐一款 IDE 的话，我会首推微软的“亲儿子”——开源编辑器 VS Code（Visual Studio Code），因为它具备以下 4 点优势：</p>\n<ol data-nodeid=\"1426\">\n<li data-nodeid=\"1427\">\n<p data-nodeid=\"1428\">在传统语法高亮、自动补全功能的基础上拓展了基于变量类型、函数定义，以及引入模块的智能补全；</p>\n</li>\n<li data-nodeid=\"1429\">\n<p data-nodeid=\"1430\">支持在编辑器上直接运行和调试应用；</p>\n</li>\n<li data-nodeid=\"1431\">\n<p data-nodeid=\"1432\">内置了 Git Comands，能大幅提升使用 Git 及其他 SCM 管理工具的协同开发效率；</p>\n</li>\n<li data-nodeid=\"1433\">\n<p data-nodeid=\"1434\">基于 Electron 开发，具备超强的扩展性和定制性。</p>\n</li>\n</ol>\n<p data-nodeid=\"1435\">下面请你<a href=\"https://code.visualstudio.com/?fileGuid=xxQTRXtVcqtHK6j8\" data-nodeid=\"1569\">点击这里打开官方网站，并下载安装包进行安装</a>。安装好后，我们点击启动图标即可启动 VS Code。</p>\n<p data-nodeid=\"1436\">在 Mac 电脑上，如果你习惯使用命令行，可以将 VS Code bin 目录添加到环境变量 PATH 中，以便更方便地唤起它，如下代码所示：</p>\n<pre class=\"lang-shell\" data-nodeid=\"1437\"><code data-language=\"shell\">export PATH=\"$PATH:/Applications/Visual Studio Code.app/Contents/Resources/app/bin\"\n</code></pre>\n<p data-nodeid=\"1438\">然后，在 Mac 命令行工具中，我们使用 Vim 编辑“source ~/.bash_profile”即可让配置的环境变量生效。</p>\n<pre class=\"lang-shell\" data-nodeid=\"1439\"><code data-language=\"shell\">source ~/.bash_profile\n</code></pre>\n<p data-nodeid=\"1440\">Vim 保存退出后，输入“code 应用路径”（如下所示），我们就可以快速打开和编辑指定路径下的应用了。</p>\n<pre class=\"lang-shell\" data-nodeid=\"1441\"><code data-language=\"shell\">&nbsp;code 应用路径\n</code></pre>\n<p data-nodeid=\"1442\">因为 VS Code 中内置了特定版本的 TypeScript 语言服务，所以它天然支持 TypeScript 语法解析和类型检测，且这个内置的服务与手动安装的 TypeScript 完全隔离。因此，<strong data-nodeid=\"1583\">VS Code 支持在内置和手动安装版本之间动态切换语言服务，从而实现对不同版本的 TypeScript 的支持</strong>。</p>\n<p data-nodeid=\"1443\">如果当前应用目录中安装了与内置服务不同版本的 TypeScript，我们就可以点击 VS Code 底部工具栏的版本号信息，从而实现 “use VS Code's Version” 和 “use Workspace's Version” 两者之间的随意切换。</p>\n<p data-nodeid=\"1444\">设置当前窗口使用的 TypeScript 版本的具体操作，如下图所示：</p>\n<p data-nodeid=\"1445\"><img src=\"https://s0.lgstatic.com/i/image6/M01/3D/AB/Cgp9HWCV_ZaAcBb0ACrQ7VCdLNg442.gif\" alt=\"versions.gif\" data-nodeid=\"1592\"></p>\n<div data-nodeid=\"1446\"><p style=\"text-align:center\">可随意切换 TypeScript 版本窗口图</p></div>\n<p data-nodeid=\"1447\">我们也可以在当前应用目录下的 “.VS Code/settings.json” 内添加命令（如下所示）配置 VS Code 默认使用应用目录下安装的 TypeScript 版本，以便提供语法解析和类型检测服务。</p>\n<pre class=\"lang-json\" data-nodeid=\"1448\"><code data-language=\"json\">{\n  <span class=\"hljs-attr\">\"typescript.tsdk\"</span>: <span class=\"hljs-string\">\"node_modules/typescript/lib\"</span>\n}\n</code></pre>\n<p data-nodeid=\"1449\">在实际编写 TypeScript 代码时，我们可以使用“Shift + Command + M”快捷键打开问题面板查看所有的类型错误信息概览，如下图所示：</p>\n<p data-nodeid=\"1450\"><img src=\"https://s0.lgstatic.com/i/image6/M01/3D/B4/CioPOWCV_aiANRthACtpGH2EbVM328.gif\" alt=\"problems.gif\" data-nodeid=\"1597\"></p>\n<div data-nodeid=\"1451\"><p style=\"text-align:center\">查看所有的类型错误信息概览图</p></div>\n<p data-nodeid=\"1452\"><strong data-nodeid=\"1603\">这里请注意：不同操作系统、不同 VS Code 版本的默认快捷键可能不一致，我们可以点击菜单栏中的“视图（View）| 问题（Problems）” 查看具体快捷键。</strong></p>\n<p data-nodeid=\"1453\">当然，VS Code 也基于 TypeScript 语言服务提供了准确的代码自动补全功能，并显示详细的类型定义信息，如下图所示：</p>\n<p data-nodeid=\"1454\"><img src=\"https://s0.lgstatic.com/i/image6/M01/3D/AB/Cgp9HWCV_bqAahbtAASBXpVdoSk110.png\" alt=\"Drawing 3.png\" data-nodeid=\"1607\"></p>\n<div data-nodeid=\"1455\"><p style=\"text-align:center\">自动智能补全功能效果图</p></div>\n<p data-nodeid=\"1456\">除了类型定义之外，TypeScript 语言服务还能将使用 JSDoc 语法编写的结构化注释信息提供给 VS Code，而这些信息将在对应的变量或者类型中通过 hover 展示出来，极大地提升了代码的可读性和开发效率，如下图所示：</p>\n<p data-nodeid=\"1457\"><img src=\"https://s0.lgstatic.com/i/image6/M01/3D/B4/CioPOWCV_c-AUMxiACJEAc_XkjE624.gif\" alt=\"hover.gif\" data-nodeid=\"1611\"></p>\n<div data-nodeid=\"1458\"><p style=\"text-align:center\">JSDoc 信息提示图</p></div>\n<p data-nodeid=\"1459\">我们还可以通过 “Ctrl + `” 快捷键打开 VS Code 内置的命令行工具，以便在当前应用路径下执行各种操作，如下图所示：</p>\n<p data-nodeid=\"1460\"><img src=\"https://s0.lgstatic.com/i/image6/M01/3D/AC/Cgp9HWCV_dqAK7K-AALYUhjm47c225.png\" alt=\"Drawing 6.png\" data-nodeid=\"1617\"></p>\n<div data-nodeid=\"1461\"><p style=\"text-align:center\">VS Code 内置的命令行工具图</p></div>\n<p data-nodeid=\"1462\">以上就是 VS Code 编辑器的基本介绍了，此时有没有蠢蠢欲动的感觉？</p>\n<p data-nodeid=\"1463\">对于 VS Code 这款 IDE 而言，它比较大众化、开放化，已经能满足我们绝大多数的功能诉求。即便有些需求不能满足，我们也可以通过丰富的插件市场进行实现。</p>\n<p data-nodeid=\"1464\">而 VS Code 唯一的不足就是需要我们自己手动选择合适的插件拓展功能，对于选择困难症的人来说简直抓狂。</p>\n<h4 data-nodeid=\"1465\">WebStorm</h4>\n<p data-nodeid=\"1466\">另外一款值得推荐的 TypeScript 开发利器是 WebStorm，<strong data-nodeid=\"1626\">它具备开箱即用、无须做任何针对性的配置即可开发、执行和调试 TypeScript 源码这两大优势。</strong></p>\n<p data-nodeid=\"1467\">下面请<a href=\"https://www.jetbrains.com/webstorm/?fileGuid=xxQTRXtVcqtHK6j8\" data-nodeid=\"1630\">点击这里打开官方网站，并下载安装包进行安装</a>。</p>\n<p data-nodeid=\"1468\">WebStorm 也是基于标准的 TypeScript Language Service 来支持 TypeScript 的各种特性，与其他 IDE 在类型检测结果、自动完成提示上没有任何差异。</p>\n<p data-nodeid=\"1469\">比如，它同样可以准确地进行代码自动补全，如下图所示：</p>\n<p data-nodeid=\"1470\"><img src=\"https://s0.lgstatic.com/i/image6/M01/3D/AC/Cgp9HWCV_eqAU4ipAAUcTPGzEyU020.png\" alt=\"Drawing 8.png\" data-nodeid=\"1636\"></p>\n<div data-nodeid=\"1471\"><p style=\"text-align:center\">代码自动补全效果图</p></div>\n<p data-nodeid=\"1472\">再比如，它同样支持 hover 提示类型及 JSDoc 注释，如下图所示：</p>\n<p data-nodeid=\"1473\"><img src=\"https://s0.lgstatic.com/i/image6/M01/3D/AC/Cgp9HWCV_fyAO4ZRAASrHcWWn8Y686.png\" alt=\"Drawing 10.png\" data-nodeid=\"1640\"></p>\n<div data-nodeid=\"1474\"><p style=\"text-align:center\">提示类型及注释效果图</p></div>\n<p data-nodeid=\"1475\">因为 WebStorm 毕竟是一款商业化（收钱的）软件，所以它还集成了很多强大的 TypeScript 开发功能，具体内容你<a href=\"https://www.jetbrains.com/zh-cn/webstorm/features/?fileGuid=xxQTRXtVcqtHK6j8\" data-nodeid=\"1644\">可点击这里查看</a>。</p>\n<p data-nodeid=\"1476\">WebStorm 与 VS Code 相比，最大的<strong data-nodeid=\"1651\">优势在于开箱即用</strong>，这点可谓是选择困难症患者的福音。不过，它对电脑配置要求较高，对于 Mac 用户来说比较适合。</p>\n<h4 data-nodeid=\"1477\">Playground</h4>\n<p data-nodeid=\"1478\">官方也提供了一个在线开发 TypeScript 的云环境——Playground。</p>\n<p data-nodeid=\"1479\">基于它，我们无须在本地安装环境，只需要一个浏览器即可随时学习和编写 TypeScript，同时还可以方便地选择 TypeScript 版本、配置 tsconfig，并对 TypeScript 实时静态类型检测、转译输出 JavaScript 和在线执行。</p>\n<p data-nodeid=\"1480\">而且在体验上，它也一点儿不逊色于任何本地的 IDE，对于刚刚学习 TypeScript 的我们来说，算是一个不错的选择。</p>\n<ul data-nodeid=\"1481\">\n<li data-nodeid=\"1482\">\n<p data-nodeid=\"1483\"><a href=\"https://www.typescriptlang.org/zh/play?target=1&amp;module=1&amp;ts=3.9.7#code/Q&amp;fileGuid=xxQTRXtVcqtHK6j8\" data-nodeid=\"1658\">点击查看中文版地址</a>（如下图所示）</p>\n</li>\n<li data-nodeid=\"1484\">\n<p data-nodeid=\"1485\"><a href=\"https://www.typescriptlang.org/play?alwaysStrict=false&amp;target=1&amp;module=1&amp;ts=3.9.7#code/Q&amp;fileGuid=xxQTRXtVcqtHK6j8\" data-nodeid=\"1662\">点击查看英文版地址</a></p>\n</li>\n</ul>\n<p data-nodeid=\"1486\"><img src=\"https://s0.lgstatic.com/i/image6/M01/3D/AC/Cgp9HWCV_gmAJ3BOAAOjOVbf4SY600.png\" alt=\"Drawing 12.png\" data-nodeid=\"1665\"></p>\n<div data-nodeid=\"1487\"><p style=\"text-align:center\">中文版的 TypeScript Playground 效果图</p></div>\n<p data-nodeid=\"1488\">Playground 还为我们提供了分享的功能，比如我们可以把学习成果、遇到的难点通过 URL 的形式分享给他人。</p>\n<p data-nodeid=\"1489\">不过，<strong data-nodeid=\"1672\">在实际开发业务应用中，我们还是极力推荐使用 VS Code</strong>，毕竟它是微软的“亲儿子”，与 TypeScript 集成得更好,拥有极其完善的插件体系，更重要的是还完全免费。</p>\n<p data-nodeid=\"1490\">因此，接下来课程中的<strong data-nodeid=\"1677\">所有示例，我们都将使用 VS Code 进行开发和演示。</strong></p>\n<h3 data-nodeid=\"1491\">安装 TypeScript</h3>\n<p data-nodeid=\"1492\">接下来，我们继续了解如何基于 VS Code 完善 TypeScript 开发、转译环境。</p>\n<p data-nodeid=\"1493\">因为 VS Code 只集成了 TypeScript 语言服务，不包含转译器，所以我们还需要单独安装 TypeScript。</p>\n<p data-nodeid=\"1494\">为了方便快速完成一个入门小示例，这里我们推荐通过命令行工具使用 npm 全局安装 TypeScript。</p>\n<p data-nodeid=\"1495\">具体操作：使用“Ctrl + `”快捷键打开 VS Code 内置命令行工具，然后输入如下所示代码：</p>\n<pre class=\"lang-shell\" data-nodeid=\"1496\"><code data-language=\"shell\">npm i -g typescript\n</code></pre>\n<p data-nodeid=\"1497\"><strong data-nodeid=\"1691\">注意：因为本课程使用示例都是基于 TypeScript 3.9.* 版本，所以建议你在尝试操作时也安装本课程使用的 TypeScript 版本（比如 3.9.2、3.9.3……3.9.7）</strong>，如下代码所示：</p>\n<pre class=\"lang-shell\" data-nodeid=\"1498\"><code data-language=\"shell\">npm i -g typescript@3.9.*\n</code></pre>\n<p data-nodeid=\"1499\">TypeScript 安装完成后，我们输入如下所示命令即可查看当前安装的 TypeScript 版本。</p>\n<pre class=\"lang-shell\" data-nodeid=\"1500\"><code data-language=\"shell\">tsc -v\n</code></pre>\n<p data-nodeid=\"1501\">然后，我们可能会看到输出了我们安装的版本信息：</p>\n<pre class=\"lang-java\" data-nodeid=\"1502\"><code data-language=\"java\">Version <span class=\"hljs-number\">3.9</span><span class=\"hljs-number\">.2</span>\n</code></pre>\n<p data-nodeid=\"1503\">我们也可以通过安装在 Terminal 命令行中直接支持运行 TypeScript 代码（Node.js 侧代码）的 ts-node 来获得较好的开发体验。</p>\n<p data-nodeid=\"1504\">通过 npm 全局安装 ts-node 的操作如下代码所示：</p>\n<pre class=\"lang-shell\" data-nodeid=\"1505\"><code data-language=\"shell\">npm i -g ts-node\n</code></pre>\n<p data-nodeid=\"1506\">如果你是 Mac 或者 Linux 用户，就极有可能在 npm i -g typescript 中遭遇 “EACCES: permission denied” 错误，此时我们可以通过以下 4 种办法进行解决：</p>\n<ul data-nodeid=\"1507\">\n<li data-nodeid=\"1508\">\n<p data-nodeid=\"1509\">使用 nvm 重新安装 npm</p>\n</li>\n<li data-nodeid=\"1510\">\n<p data-nodeid=\"1511\">修改 npm 默认安装目录</p>\n</li>\n<li data-nodeid=\"1512\">\n<p data-nodeid=\"1513\">执行 sudo npm i -g xx</p>\n</li>\n<li data-nodeid=\"1514\">\n<p data-nodeid=\"1515\">执行 sudo chown -R [user]:[user] /usr/local/lib/node_modules</p>\n</li>\n</ul>\n<p data-nodeid=\"1516\"><a href=\"https://docs.npmjs.com/resolving-eacces-permissions-errors-when-installing-packages-globally?fileGuid=xxQTRXtVcqtHK6j8\" data-nodeid=\"1713\">你可以点击这里了解更多相关建议</a>。</p>\n<p data-nodeid=\"1517\">最后，我们创建了一个 ts-course 的应用目录用来记录学习过程中的各种练习例子，然后使用 VS Code 即可打开这个应用。</p>\n<h3 data-nodeid=\"1518\">编写 Hello World</h3>\n<p data-nodeid=\"1519\">我们可以在练习目录下输入“tsc --init”命令快速创建一个 tsconfig.json 文件，或者在 VS Code 应用窗口新建一个空的 tsconfg.json<strong data-nodeid=\"1721\">配置 TypeScript 的行为。</strong></p>\n<pre class=\"lang-shell\" data-nodeid=\"1520\"><code data-language=\"shell\">tsc --init\n</code></pre>\n<p data-nodeid=\"1521\">为了让 TypeScript 的行为更加严格、简单易懂，降低学习的心理负担，这就要求我们在 tsconfig.json 中开启如下所示设置，该设置将决定了 VS Code 语言服务如何对当前应用下的 TypeScript 代码进行类型检测。<strong data-nodeid=\"1726\">（说明：本课程中涉及的所有示例都是基于如下所示的统一配置编写。）</strong></p>\n<pre class=\"lang-javascript\" data-nodeid=\"1522\"><code data-language=\"javascript\">{\n  <span class=\"hljs-string\">\"compilerOptions\"</span>: {\n    <span class=\"hljs-comment\">/* Strict Type-Checking Options */</span>\n    <span class=\"hljs-string\">\"strict\"</span>: <span class=\"hljs-literal\">true</span>,                           <span class=\"hljs-comment\">/* Enable all strict type-checking options. */</span>\n    <span class=\"hljs-string\">\"noImplicitAny\"</span>: <span class=\"hljs-literal\">true</span>,                 <span class=\"hljs-comment\">/* Raise error on expressions and declarations with an implied 'any' type. */</span>\n    <span class=\"hljs-string\">\"strictNullChecks\"</span>: <span class=\"hljs-literal\">true</span>,              <span class=\"hljs-comment\">/* Enable strict null checks. */</span>\n    <span class=\"hljs-string\">\"strictFunctionTypes\"</span>: <span class=\"hljs-literal\">true</span>,           <span class=\"hljs-comment\">/* Enable strict checking of function types. */</span>\n    <span class=\"hljs-string\">\"strictBindCallApply\"</span>: <span class=\"hljs-literal\">true</span>,           <span class=\"hljs-comment\">/* Enable strict 'bind', 'call', and 'apply' methods on functions. */</span>\n    <span class=\"hljs-string\">\"strictPropertyInitialization\"</span>: <span class=\"hljs-literal\">true</span>,  <span class=\"hljs-comment\">/* Enable strict checking of property initialization in classes. */</span>\n    <span class=\"hljs-string\">\"noImplicitThis\"</span>: <span class=\"hljs-literal\">true</span>,                <span class=\"hljs-comment\">/* Raise error on 'this' expressions with an implied 'any' type. */</span>\n    <span class=\"hljs-string\">\"alwaysStrict\"</span>: <span class=\"hljs-literal\">false</span>,                  <span class=\"hljs-comment\">/* Parse in strict mode and emit \"use strict\" for each source file. */</span>\n  }\n}\n</code></pre>\n<p data-nodeid=\"1523\">然后，我们输入如下所示代码即可新建一个 HelloWorld.ts 文件：</p>\n<pre class=\"lang-typescript\" data-nodeid=\"1524\"><code data-language=\"typescript\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">say</span>(<span class=\"hljs-params\">word: <span class=\"hljs-built_in\">string</span></span>) </span>{\n  <span class=\"hljs-built_in\">console</span>.log(word);\n}\nsay(<span class=\"hljs-string\">'Hello, World'</span>);\n</code></pre>\n<p data-nodeid=\"1525\">在以上代码中，word 函数参数后边多出来的 “: string” 注解直观地告诉我们，这个变量的类型就是 string。如果你之前使用过其他强类型的语言（比如 Java），就能快速理解 TypeScript 语法。</p>\n<p data-nodeid=\"1526\">当然，在当前目录下，我们也可以通过如下代码创建一个同名的 HelloWorld.js 文件，而这个文件中抹掉了类型注解的 TypeScript 代码。</p>\n<pre class=\"lang-typescript\" data-nodeid=\"1527\"><code data-language=\"typescript\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">say</span>(<span class=\"hljs-params\">word</span>) </span>{\n  <span class=\"hljs-built_in\">console</span>.log(word);\n}\nsay(<span class=\"hljs-string\">'Hello, World'</span>);\n</code></pre>\n<p data-nodeid=\"1528\">这里我们可以看到，TypeScript 代码和我们熟悉的 JavaScript 相比，并没有明显的差异。</p>\n<p data-nodeid=\"1529\">.ts 文件创建完成后，我们就可以使用 tsc（TypeScript Compiler） 命令将 .ts 文件转译为 .js 文件。</p>\n<p data-nodeid=\"1530\"><strong data-nodeid=\"1735\">注意：指定转译的目标文件后，tsc 将忽略当前应用路径下的 tsconfig.json 配置，因此我们需要通过显式设定如下所示的参数，让 tsc 以严格模式检测并转译 TypeScript 代码。</strong></p>\n<pre class=\"lang-shell\" data-nodeid=\"1531\"><code data-language=\"shell\">tsc HelloWorld.ts --strict --alwaysStrict false\n</code></pre>\n<p data-nodeid=\"1532\">同时，我们可以给 tsc 设定一个 watch 参数监听文件内容变更，实时进行类型检测和代码转译，如下代码所示：</p>\n<pre class=\"lang-shell\" data-nodeid=\"1533\"><code data-language=\"shell\">tsc HelloWorld.ts --strict --alwaysStrict false --watch\n</code></pre>\n<p data-nodeid=\"1534\"><img src=\"https://s0.lgstatic.com/i/image6/M00/3D/AC/Cgp9HWCV_iGAYMjOAAVsTWlXVIk512.png\" alt=\"Drawing 14.png\" data-nodeid=\"1739\"></p>\n<div data-nodeid=\"1535\"><p style=\"text-align:center\">tsc 转译监听模式效果图</p></div>\n<p data-nodeid=\"1536\">我们也可以直接使用 ts-node 运行 HelloWorld.ts，如下代码所示：</p>\n<pre class=\"lang-java te-preview-highlight\" data-nodeid=\"1766\"><code data-language=\"java\">ts-node HelloWorld.ts\n</code></pre>\n\n<p data-nodeid=\"1538\">运行成功后，ts-node 就会输出如下所示内容：</p>\n<pre class=\"lang-java\" data-nodeid=\"1539\"><code data-language=\"java\">Hello, World\n</code></pre>\n<p data-nodeid=\"1540\">当然，我们也可以唤起“直接运行”（本质上是先自动进行转译，再运行）TypeScript 的 ts-node 命令行来编写代码，这就跟我们在 Node.js 命令行或者浏览器中调试工具一样。</p>\n<p data-nodeid=\"1541\">然后，我们再回车立即执行如下所示代码：</p>\n<pre class=\"lang-java\" data-nodeid=\"1542\"><code data-language=\"java\">&gt;&nbsp;ts-node\n&gt;&nbsp;<span class=\"hljs-function\">function <span class=\"hljs-title\">say</span><span class=\"hljs-params\">(word: string)</span> </span>{\n&gt;&nbsp;  console.log(word);\n&gt;&nbsp;}\n&gt; say(<span class=\"hljs-string\">'Hello, World'</span>);\nHello, World\nundefined\n</code></pre>\n<p data-nodeid=\"1543\"><strong data-nodeid=\"1747\">这里请注意：TypeScript 的类型注解旨在约束函数或者变量，在上面的例子中，我们就是通过约束一个示例函数来接收一个字符串类型（string）的参数。</strong></p>\n<p data-nodeid=\"1544\">在接下来演示的例子中，我们将故意犯一个低级错误，先传递一个数字类型的参数给如下所示函数：</p>\n<pre class=\"lang-typescript\" data-nodeid=\"1545\"><code data-language=\"typescript\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">say</span>(<span class=\"hljs-params\">word: <span class=\"hljs-built_in\">string</span></span>) </span>{\n  <span class=\"hljs-built_in\">console</span>.log(word);\n}\nsay(<span class=\"hljs-number\">1</span>);\n</code></pre>\n<p data-nodeid=\"1546\">然后 VS Code 会标红这个错误，并在问题（Problems）面板中显示错误信息，如下图所示：</p>\n<p data-nodeid=\"1547\"><img src=\"https://s0.lgstatic.com/i/image6/M00/3D/AC/Cgp9HWCV_jOAXmPNAAXOxhMuaTs987.png\" alt=\"Drawing 16.png\" data-nodeid=\"1752\"></p>\n<div data-nodeid=\"1548\"><p style=\"text-align:center\">VS Code 问题面板显示效果图</p></div>\n<p data-nodeid=\"1549\">最后，通过 tsc 转译或者 ts-node 运行这个示例，我们会看到如下所示的报错信息。</p>\n<pre class=\"lang-java\" data-nodeid=\"1550\"><code data-language=\"java\">error TS2345: Argument of type <span class=\"hljs-string\">'number'</span> is not assignable to parameter of type <span class=\"hljs-string\">'string'</span>.\n</code></pre>\n<p data-nodeid=\"1551\">这是因为函数 say 限定了形参的类型是 string，而我们调用 say 时传递的实参类型是 number，所以转译阶段抛出了这个错误。</p>\n<h3 data-nodeid=\"1552\">小结与预告</h3>\n<p data-nodeid=\"1553\">VS Code 让我们获得一种较为理想的开发体验，不必等到转译阶段，在编码时就能快速检测、抛出类型错误，极大地提升了 TypeScript 开发体验和效率。</p>\n<p data-nodeid=\"1554\">特别需要注意的是，VS Code 默认使用自身内置的 TypeScript 语言服务版本，而在应用构建过程中，构建工具使用的却是应用路径下 node_modules/typescript 里的 TypeScript 版本。如果两个版本之间存在不兼容的特性，就会造成开发阶段和构建阶段静态类型检测结论不一致的情况，因此，我们务必将 VS Code 语言服务配置成使用当前工作区的 TypeScript 版本。</p>\n<p data-nodeid=\"1555\"><strong data-nodeid=\"1764\">插播一个思考题：如何选择和设置 VS Code 语言服务需要使用的 TypeScript 版本？欢迎你在留言区与我互动、交流。另外，如果你觉得本专栏有价值，欢迎分享给更多好友哦~</strong></p>\n<p data-nodeid=\"1556\" class=\"\">到这里，TypeScript 开发环境就已经搭建好了，万事已具备。接下来我们的 TypeScript 学习开发班车就要发车了，你准备好迎接新的技能和新的挑战了吗？</p>",
                "article_title": "01 | 如何快速搭建 TypeScript 学习开发环境？",
                "title": "01 | 如何快速搭建 TypeScript 学习开发环境？",
                "id": 7433
            },
            {
                "content": "<p data-nodeid=\"38120\">这一讲，我们将从最基本的语法、原始类型层面的知识点正式开启 TypeScript 学习之旅。“不积跬步，无以至千里”，只有融会贯通、夯实基础，我们才能在后续的学习中厚积薄发。</p>\n<blockquote data-nodeid=\"39530\">\n<p data-nodeid=\"39531\" class=\"\"><strong data-nodeid=\"39537\">学习建议：</strong> 为了更直观地学习这一讲的内容，请你使用配置好的 VS Code IDE（可以回顾一下“01 | 如何快速搭建 TypeScript 开发环境？”的内容） 亲自尝试编写以下涉及的所有示例，比如新建一个“02.basic.1.ts”。</p>\n</blockquote>\n<h3 data-nodeid=\"39532\">TypeScript 简介</h3>\n\n\n<p data-nodeid=\"38124\">TypeScript 其实就是类型化的 JavaScript，它不仅支持 JavaScript 的所有特性，还在 JavaScript 的基础上添加了静态类型注解扩展。</p>\n<p data-nodeid=\"38125\">这里我们举个例子来说明一下，比如 JavaScript 中虽然提供了原始数据类型 string、number，但是它无法检测我们是不是按照约定的类型对变量赋值，而 TypeScript 会对赋值及其他所有操作默认做静态类型检测。</p>\n<p data-nodeid=\"38126\">因此，从某种意义上来说，<strong data-nodeid=\"38239\">TypeScript 其实就是 JavaScript 的超集</strong>，如下图所示：</p>\n<p data-nodeid=\"41229\"><img src=\"https://s0.lgstatic.com/i/image6/M00/3D/B5/CioPOWCV_xuAZSI_AAdZCdHFgM8072.png\" alt=\"Drawing 1.png\" data-nodeid=\"41233\"></p>\n<div data-nodeid=\"41230\" class=\"\"><p style=\"text-align:center\">TypeScript 是 JavaScript 的超集示意图</p></div>\n\n\n\n\n<p data-nodeid=\"38130\">在 TypeScript 中，我们不仅可以轻易复用 JavaScript 的代码、最新特性，还能使用可选的静态类型进行检查报错，使得编写的代码更健壮、更易于维护。比如在开发阶段，我们通过 TypeScript 代码转译器就能快速消除很多低级错误（如 typo、类型等）。</p>\n<p data-nodeid=\"38131\">接下来我们一起看看 TypeScript 的基本语法。</p>\n<h3 data-nodeid=\"38132\">基本语法</h3>\n<p data-nodeid=\"38133\">在语法层面，缺省类型注解的 TypeScript 与 JavaScript 完全一致。因此，我们可以把 TypeScript 代码的编写看作是为 JavaScript 代码添加类型注解。</p>\n<p data-nodeid=\"38134\">在 TypeScript 语法中，类型的标注主要通过类型后置语法来实现，下面我们通过一个具体示例进行说明。</p>\n<pre class=\"lang-typescript\" data-nodeid=\"38135\"><code data-language=\"typescript\"><span class=\"hljs-keyword\">let</span> num = <span class=\"hljs-number\">1</span>;\n</code></pre>\n<p data-nodeid=\"38136\">示例中的语法同时符合 JavaScript 语法和 TypeScript 语法。</p>\n<p data-nodeid=\"38137\">而 TypeScript 语法与 JavaScript 语法的区别在于，我们可以在 TypeScript 中显式声明变量<code data-backticks=\"1\" data-nodeid=\"38254\">num</code>仅仅是数字类型，也就是说只需在变量<code data-backticks=\"1\" data-nodeid=\"38256\">num</code>后添加<code data-backticks=\"1\" data-nodeid=\"38258\">: number</code>类型注解即可，如下代码所示：</p>\n<pre class=\"lang-typescript\" data-nodeid=\"38138\"><code data-language=\"typescript\"><span class=\"hljs-keyword\">let</span> num: <span class=\"hljs-built_in\">number</span> = <span class=\"hljs-number\">1</span>;\n</code></pre>\n<p data-nodeid=\"38139\"><strong data-nodeid=\"38270\">特殊说明：</strong><code data-backticks=\"1\" data-nodeid=\"38263\">number</code>表示数字类型，<code data-backticks=\"1\" data-nodeid=\"38265\">:</code>用<strong data-nodeid=\"38271\">来分割变量和类型的分隔符。</strong></p>\n<p data-nodeid=\"38140\">同理，我们也可以把<code data-backticks=\"1\" data-nodeid=\"38273\">:</code>后的<code data-backticks=\"1\" data-nodeid=\"38275\">number</code>换成其他的类型（比如 JavaScript 原始类型：number、string、boolean、null、undefined、symbol 等），此时，num 变量也就拥有了 TypeScript 同名的原始类型定义。</p>\n<p data-nodeid=\"38141\">关于 JavaScript 原始数据类型到 TypeScript 类型的映射关系如下表所示：</p>\n<p data-nodeid=\"41788\" class=\"\"><img src=\"https://s0.lgstatic.com/i/image6/M00/3D/B5/CioPOWCV_y2AfRkCAAJ0QW8Nr1k253.png\" alt=\"Drawing 2.png\" data-nodeid=\"41791\"></p>\n\n\n<p data-nodeid=\"38173\">接下来，我们详细地了解一下原始类型。</p>\n<h3 data-nodeid=\"38174\">原始类型</h3>\n<p data-nodeid=\"42246\" class=\"\">在 JavaScript 中，原始类型指的是非对象且没有方法的数据类型，它包括 string、number、bigint、boolean、undefined 和 symbol 这六种 <strong data-nodeid=\"42252\">（null 是一个伪原始类型，它在 JavaScript 中实际上是一个对象，且所有的结构化类型都是通过 null 原型链派生而来）</strong>。</p>\n\n<p data-nodeid=\"38176\">在 JavaScript 语言中，原始类型值是最底层的实现，对应到 TypeScript 中同样也是最底层的类型。</p>\n<p data-nodeid=\"38177\">为了实现更合理的逻辑边界，本专栏我们把以上原始类型拆分为基础类型和特殊类型这两部分进行讲解。02 讲主要讲解字符串、数字（包括 number 和 bigint）、布尔值、Symbol 这 4 种基础类型，03 讲主要讲解 null 和 undefined 等特殊字符。</p>\n<h4 data-nodeid=\"38178\">字符串</h4>\n<p data-nodeid=\"38179\">在 JavaScript 中，我们可以使用<code data-backticks=\"1\" data-nodeid=\"38312\">string</code>表示 JavaScript 中任意的字符串（包括模板字符串），具体示例如下所示：</p>\n<pre class=\"lang-typescript\" data-nodeid=\"38180\"><code data-language=\"typescript\"><span class=\"hljs-keyword\">let</span> firstname: <span class=\"hljs-built_in\">string</span> = <span class=\"hljs-string\">'Captain'</span>; <span class=\"hljs-comment\">// 字符串字面量</span>\n<span class=\"hljs-keyword\">let</span> familyname: <span class=\"hljs-built_in\">string</span> = <span class=\"hljs-built_in\">String</span>(<span class=\"hljs-string\">'S'</span>); <span class=\"hljs-comment\">// 显式类型转换</span>\n<span class=\"hljs-keyword\">let</span> fullname: <span class=\"hljs-built_in\">string</span> = <span class=\"hljs-string\">`my name is <span class=\"hljs-subst\">${firstname}</span>.<span class=\"hljs-subst\">${familyname}</span>`</span>;&nbsp;<span class=\"hljs-comment\">// 模板字符串</span>\n</code></pre>\n<blockquote data-nodeid=\"38181\">\n<p data-nodeid=\"38182\"><strong data-nodeid=\"38317\">说明：所有 JavaScript 支持的定义字符串的方法，我们都可以直接在 TypeScript 中使用。</strong></p>\n</blockquote>\n<h4 data-nodeid=\"38183\">数字</h4>\n<p data-nodeid=\"38184\">同样，我们可以使用<code data-backticks=\"1\" data-nodeid=\"38320\">number</code>类型表示 JavaScript 已经支持或者即将支持的十进制整数、浮点数，以及二进制数、八进制数、十六进制数，具体的示例如下所示：</p>\n<pre class=\"lang-typescript\" data-nodeid=\"38185\"><code data-language=\"typescript\"><span class=\"hljs-comment\">/** 十进制整数 */</span>\n<span class=\"hljs-keyword\">let</span> integer: <span class=\"hljs-built_in\">number</span> = <span class=\"hljs-number\">6</span>;\n<span class=\"hljs-comment\">/** 十进制整数 */</span>\n<span class=\"hljs-keyword\">let</span> integer2: <span class=\"hljs-built_in\">number</span> = <span class=\"hljs-built_in\">Number</span>(<span class=\"hljs-number\">42</span>);\n<span class=\"hljs-comment\">/** 十进制浮点数 */</span>\n<span class=\"hljs-keyword\">let</span> decimal: <span class=\"hljs-built_in\">number</span> = <span class=\"hljs-number\">3.14</span>;\n<span class=\"hljs-comment\">/** 二进制整数 */</span>\n<span class=\"hljs-keyword\">let</span> binary: <span class=\"hljs-built_in\">number</span> = <span class=\"hljs-number\">0b1010</span>;\n<span class=\"hljs-comment\">/** 八进制整数 */</span>\n<span class=\"hljs-keyword\">let</span> octal: <span class=\"hljs-built_in\">number</span> = <span class=\"hljs-number\">0o744</span>;\n<span class=\"hljs-comment\">/** 十六进制整数 */</span>\n<span class=\"hljs-keyword\">let</span> hex: <span class=\"hljs-built_in\">number</span> = <span class=\"hljs-number\">0xf00d</span>;\n</code></pre>\n<p data-nodeid=\"38186\">如果使用较少的大整数，那么我们可以使用<code data-backticks=\"1\" data-nodeid=\"38323\">bigint</code>类型来表示，如下代码所示。</p>\n<pre class=\"lang-typescript\" data-nodeid=\"38187\"><code data-language=\"typescript\"><span class=\"hljs-keyword\">let</span> big: bigint =  <span class=\"hljs-number\">100n</span>;\n</code></pre>\n<p data-nodeid=\"38188\"><strong data-nodeid=\"38332\">请注意：虽然</strong><code data-backticks=\"1\" data-nodeid=\"38328\">number</code>和<code data-backticks=\"1\" data-nodeid=\"38330\">bigint</code>都表示数字，但是这两个类型不兼容。</p>\n<p data-nodeid=\"38189\">因此，如果我们在 VS Code IDE 中输入如下示例，问题面板中将会抛出一个类型不兼容的  ts(2322)  错误。</p>\n<pre class=\"lang-typescript\" data-nodeid=\"38190\"><code data-language=\"typescript\">big = integer;\ninteger = big;\n</code></pre>\n<h4 data-nodeid=\"38191\">布尔值</h4>\n<p data-nodeid=\"38192\">同样，我们可以使用<code data-backticks=\"1\" data-nodeid=\"38336\">boolean</code>表示 True 或者 False，如下代码所示。</p>\n<pre class=\"lang-typescript\" data-nodeid=\"38193\"><code data-language=\"typescript\"><span class=\"hljs-comment\">/** TypeScript 真香 为 真 */</span>\n<span class=\"hljs-keyword\">let</span> TypeScriptIsGreat: <span class=\"hljs-built_in\">boolean</span> = <span class=\"hljs-literal\">true</span>;\n <span class=\"hljs-comment\">/** TypeScript 太糟糕了 为 否 */</span>\n<span class=\"hljs-keyword\">let</span> TypeScriptIsBad: <span class=\"hljs-built_in\">boolean</span> = <span class=\"hljs-literal\">false</span>;\n</code></pre>\n<h4 data-nodeid=\"38194\">Symbol</h4>\n<p data-nodeid=\"38195\">自 ECMAScript 6 起，TypeScript 开始支持新的<code data-backticks=\"1\" data-nodeid=\"38340\">Symbol</code>原始类型， 即我们可以通过<code data-backticks=\"1\" data-nodeid=\"38342\">Symbol</code>构造函数，创建一个独一无二的标记；同时，还可以使用<code data-backticks=\"1\" data-nodeid=\"38344\">symbol</code>表示如下代码所示的类型。</p>\n<pre class=\"lang-typescript\" data-nodeid=\"38196\"><code data-language=\"typescript\"><span class=\"hljs-keyword\">let</span> sym1: symbol = Symbol();\n<span class=\"hljs-keyword\">let</span> sym2: symbol = Symbol(<span class=\"hljs-string\">'42'</span>);\n</code></pre>\n<p data-nodeid=\"38197\"><strong data-nodeid=\"38349\">当然，TypeScript 还包含 Number、String、Boolean、Symbol 等类型（注意区分大小写）。</strong></p>\n<blockquote data-nodeid=\"38198\">\n<p data-nodeid=\"38199\"><strong data-nodeid=\"38354\">特殊说明：请你千万别将它们和小写格式对应的 number、string、boolean、symbol 进行等价</strong>。不信的话，你可以思考并验证如下所示的示例。</p>\n</blockquote>\n<pre class=\"lang-typescript\" data-nodeid=\"38200\"><code data-language=\"typescript\"><span class=\"hljs-keyword\">let</span> sym: symbol = Symbol(<span class=\"hljs-string\">'a'</span>);\n<span class=\"hljs-keyword\">let</span> sym2: Symbol = Symbol(<span class=\"hljs-string\">'b'</span>);\nsym = sym2 <span class=\"hljs-comment\">// ok or fail?</span>\nsym2 = sym <span class=\"hljs-comment\">// ok or fail?</span>\n<span class=\"hljs-keyword\">let</span> str: <span class=\"hljs-built_in\">String</span> = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">String</span>(<span class=\"hljs-string\">'a'</span>);\n<span class=\"hljs-keyword\">let</span> str2: <span class=\"hljs-built_in\">string</span> = <span class=\"hljs-string\">'a'</span>;\nstr = str2; <span class=\"hljs-comment\">// ok or fail?</span>\nstr2 = str; <span class=\"hljs-comment\">// ok or fail?</span>\n</code></pre>\n<p data-nodeid=\"38201\">实际上，我们压根使用不到 Number、String、Boolean、Symbol 类型，因为它们并没有什么特殊的用途。这就像我们不必使用 JavaScript Number、String、Boolean 等构造函数 new 一个相应的实例一样。</p>\n<p data-nodeid=\"38202\">介绍完这几种原始类型后，你可能会心生疑问：缺省类型注解的有无似乎没有什么明显的作用，就像如下所示的示例一样：</p>\n<pre class=\"lang-typescript\" data-nodeid=\"38203\"><code data-language=\"typescript\">{\n  <span class=\"hljs-keyword\">let</span> mustBeNum = <span class=\"hljs-number\">1</span>;\n}\n{\n  <span class=\"hljs-keyword\">let</span> mustBeNum: <span class=\"hljs-built_in\">number</span> = <span class=\"hljs-number\">1</span>;\n}\n</code></pre>\n<p data-nodeid=\"38204\">其实，以上这两种写法在 TypeScript 中是等价的，这得益于基于上下文的类型推导（这部分内容我们将在 04 讲中详细说明）。</p>\n<p data-nodeid=\"38205\">下面，我们对上面的示例稍做一下修改，如下代码所示：</p>\n<pre class=\"lang-typescript\" data-nodeid=\"38206\"><code data-language=\"typescript\">{\n  <span class=\"hljs-keyword\">let</span> mustBeNum = <span class=\"hljs-string\">'badString'</span>;\n}\n{\n  <span class=\"hljs-keyword\">let</span> mustBeNum: <span class=\"hljs-built_in\">number</span> = <span class=\"hljs-string\">'badString'</span>;\n}\n</code></pre>\n<p data-nodeid=\"38207\">此时，我们可以看到 VS Code 的内容和问题面板区域提示了错误（其他 IDE 也会出现类似提示），如下图所示：</p>\n<p data-nodeid=\"43164\" class=\"\"><img src=\"https://s0.lgstatic.com/i/image6/M01/3D/AC/Cgp9HWCV_0GAYFH7AATQLps4G-c499.png\" alt=\"Drawing 4.png\" data-nodeid=\"43168\"></p>\n<div data-nodeid=\"43165\"><p style=\"text-align:center\">错误提示效果图</p></div>\n\n\n\n<p data-nodeid=\"43623\">以上就是类型注解作用的直观体现。</p>\n\n\n<p data-nodeid=\"38212\">如果变量所处的上下文环境特别复杂，在开发阶段就能检测出低级类型错误的能力将显得尤为重要，而这种能力主要来源于 TypeScript 实现的静态类型检测。</p>\n<h3 data-nodeid=\"38213\">静态类型检测</h3>\n<p data-nodeid=\"38214\">在编译时期，静态类型的编程语言即可准确地发现类型错误，这就是静态类型检测的优势。</p>\n<p data-nodeid=\"38215\">在编译（转译）时期，TypeScript 编译器将通过对比检测变量接收值的类型与我们显示注解的类型，从而检测类型是否存在错误。如果两个类型完全一致，显示检测通过；如果两个类型不一致，它就会抛出一个编译期错误，告知我们编码错误，具体示例如下代码所示：</p>\n<pre class=\"lang-typescript\" data-nodeid=\"38216\"><code data-language=\"typescript\"><span class=\"hljs-keyword\">const</span> trueNum: <span class=\"hljs-built_in\">number</span> = <span class=\"hljs-number\">42</span>;\n<span class=\"hljs-keyword\">const</span> fakeNum: <span class=\"hljs-built_in\">number</span> = <span class=\"hljs-string\">\"42\"</span>; <span class=\"hljs-comment\">// ts(2322) Type 'string' is not assignable to type 'number'.</span>\n</code></pre>\n<p data-nodeid=\"38217\">在以上示例中，首先我们声明了一个数字类型的变量<code data-backticks=\"1\" data-nodeid=\"38373\">trueNum</code>，通过编译器检测后，发现接收值是 42，且它的类型是<code data-backticks=\"1\" data-nodeid=\"38375\">number</code>，可见两者类型完全一致。此时，TypeScript 编译器就会显示检测通过。</p>\n<p data-nodeid=\"38218\">而如果我们声明了一个<code data-backticks=\"1\" data-nodeid=\"38378\">string</code>类型的变量<code data-backticks=\"1\" data-nodeid=\"38380\">fakeNum</code>，通过编译器检测后，发现接收值为 \"42\"，且它的类型是<code data-backticks=\"1\" data-nodeid=\"38386\">number</code>，可见两者类型不一致 。此时，TypeScript 编译器就会抛出一个字符串值不能为数字类型变量赋值的ts(2322)  错误，也就是说检测不通过。</p>\n<p data-nodeid=\"38219\">实际上，正如 01 讲提到，TypeScript 的语言服务可以和 VS Code 完美集成。<strong data-nodeid=\"38392\">因此，在编写代码的同时，我们可以同步进行静态类型检测（无须等到编译后再做检测），极大地提升了开发体验和效率。</strong></p>\n<p data-nodeid=\"38220\">以上就是 TypeScript 中基本语法和原始类型的介绍。</p>\n<h3 data-nodeid=\"38221\">小结</h3>\n<p data-nodeid=\"38222\" class=\"\">这一讲通过与 JavaScript 的基础类型进行对比，我们得知：TypeScript 其实就是添加了类型注解的 JavaScript，它并没有任何颠覆性的变动。因此，学习并掌握 TypeScript 一定会是一件极其容易的事情。</p>\n<p data-nodeid=\"38223\"><strong data-nodeid=\"38399\">插播一个思考题：请举例说明 ts(2322)  是一个什么错误？什么时候会抛出这个错误？欢迎你在留言区进行互动、交流。</strong></p>\n<p data-nodeid=\"38224\">另外，如果你觉得本专栏有价值，欢迎分享给更多好友哦~</p>",
                "article_title": "02 | 简单基础类型：TypeScript 与 JavaScript 有何不同？",
                "title": "02 | 简单基础类型：TypeScript 与 JavaScript 有何不同？",
                "id": 7434
            },
            {
                "content": "<p data-nodeid=\"1409\" class=\"\">学习完原始类型等知识点，你可能已经对 TypeScript 有了基本的认知。在接下来这一讲中，我将带你接触稍微复杂一点的类型结构（比如数组、any 等比较难理解的特殊类型）及其使用场景。</p>\n<blockquote data-nodeid=\"1410\">\n<p data-nodeid=\"1411\">学习建议：请使用 VS Code 新建一个 03.Basic.2.ts 文件，然后尝试课程中的所有示例。</p>\n</blockquote>\n<h3 data-nodeid=\"1412\">数组</h3>\n<p data-nodeid=\"1413\">因为 TypeScript 的数组和元组转译为 JavaScript 后都是数组，所以这里我们把数组和元组这两个类型整合到一起介绍，也方便你更好地对比学习。</p>\n<h4 data-nodeid=\"1414\">数组类型（Array）</h4>\n<p data-nodeid=\"1415\">在 TypeScript 中，我们也可以像 JavaScript 一样定义数组类型，并且指定数组元素的类型。</p>\n<p data-nodeid=\"1416\">首先，我们可以直接使用 [] 的形式定义数组类型，如下代码所示：</p>\n<pre class=\"lang-typescript\" data-nodeid=\"1417\"><code data-language=\"typescript\"><span class=\"hljs-comment\">/** 子元素是数字类型的数组 */</span>\n<span class=\"hljs-keyword\">let</span> arrayOfNumber: <span class=\"hljs-built_in\">number</span>[] = [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>];\n<span class=\"hljs-comment\">/** 子元素是字符串类型的数组 */</span>\n<span class=\"hljs-keyword\">let</span> arrayOfString: <span class=\"hljs-built_in\">string</span>[] = [<span class=\"hljs-string\">'x'</span>, <span class=\"hljs-string\">'y'</span>, <span class=\"hljs-string\">'z'</span>];\n</code></pre>\n<p data-nodeid=\"1418\">同样，我们也可以使用 Array 泛型（在第 10 讲会详细介绍泛型）定义数组类型，如下代码所示：</p>\n<pre class=\"lang-typescript\" data-nodeid=\"1419\"><code data-language=\"typescript\"><span class=\"hljs-comment\">/** 子元素是数字类型的数组 */</span>\n<span class=\"hljs-keyword\">let</span> arrayOfNumber: <span class=\"hljs-built_in\">Array</span>&lt;<span class=\"hljs-built_in\">number</span>&gt; = [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>];\n<span class=\"hljs-comment\">/** 子元素是字符串类型的数组 */</span>\n<span class=\"hljs-keyword\">let</span> arrayOfString: <span class=\"hljs-built_in\">Array</span>&lt;<span class=\"hljs-built_in\">string</span>&gt; = [<span class=\"hljs-string\">'x'</span>, <span class=\"hljs-string\">'y'</span>, <span class=\"hljs-string\">'z'</span>];\n</code></pre>\n<p data-nodeid=\"1420\">以上两种定义数组类型的方式虽然本质上没有任何区别，但是我更推荐使用 [] 这种形式来定义。<strong data-nodeid=\"1558\">一方面可以避免与 JSX 的语法冲突，另一方面可以减少不少代码量</strong>。</p>\n<p data-nodeid=\"1421\">如果我们明确指定了数组元素的类型，以下所有操作都将因为不符合类型约定而提示错误。</p>\n<pre class=\"lang-typescript\" data-nodeid=\"1422\"><code data-language=\"typescript\"><span class=\"hljs-keyword\">let</span> arrayOfNumber: <span class=\"hljs-built_in\">number</span>[] = [<span class=\"hljs-string\">'x'</span>, <span class=\"hljs-string\">'y'</span>, <span class=\"hljs-string\">'z'</span>]; <span class=\"hljs-comment\">// 提示 ts(2322)</span>\narrayOfNumber[<span class=\"hljs-number\">3</span>] = <span class=\"hljs-string\">'a'</span>; <span class=\"hljs-comment\">// 提示 ts(2322)</span>\narrayOfNumber.push(<span class=\"hljs-string\">'b'</span>); <span class=\"hljs-comment\">// 提示 ts(2345)</span>\n<span class=\"hljs-keyword\">let</span> arrayOfString: <span class=\"hljs-built_in\">string</span>[] = [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>]; <span class=\"hljs-comment\">// 提示 ts(2322)</span>\narrayOfString[<span class=\"hljs-number\">3</span>] = <span class=\"hljs-number\">1</span>; <span class=\"hljs-comment\">// 提示 ts(2322)</span>\narrayOfString.push(<span class=\"hljs-number\">2</span>); <span class=\"hljs-comment\">// 提示 ts(2345)</span>\n</code></pre>\n<h4 data-nodeid=\"1423\">元组类型（Tuple）</h4>\n<p data-nodeid=\"1424\">元组最重要的特性是可以限制数组元素的个数和类型，它特别适合用来实现多值返回。</p>\n<p data-nodeid=\"1425\">我们熟知的一个使用元组的场景是 React Hooks（关于 React Hooks 的简介<a href=\"https://reactjs.org/docs/hooks-intro.html?fileGuid=xxQTRXtVcqtHK6j8\" data-nodeid=\"1565\">请点击这里查看</a>），例如 useState 示例：</p>\n<pre class=\"lang-typescript\" data-nodeid=\"1426\"><code data-language=\"typescript\"><span class=\"hljs-keyword\">import</span> { useState } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'react'</span>;\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">useCount</span>(<span class=\"hljs-params\"></span>) </span>{\n  <span class=\"hljs-keyword\">const</span> [count, setCount] = useState(<span class=\"hljs-number\">0</span>);\n  <span class=\"hljs-keyword\">return</span> ....;\n}\n</code></pre>\n<p data-nodeid=\"1427\">在 JavaScript 中并没有元组的概念，作为一门动态类型语言，它的优势是<strong data-nodeid=\"1572\">天然支持多类型元素数组</strong>。</p>\n<p data-nodeid=\"1428\">我们假设以下两个数组的元素类型如下代码所示：</p>\n<pre class=\"lang-typescript\" data-nodeid=\"1429\"><code data-language=\"typescript\">[state, setState]\n[setState, state]\n</code></pre>\n<p data-nodeid=\"1430\">从上面可以看出，state 是一个类型为 State 的对象，而 setState 是一个类型为 SetState 的函数。</p>\n<p data-nodeid=\"1431\"><strong data-nodeid=\"1578\">注意：这里我们用全小写表示值，首字母大写表示（TypeScript）类型。</strong></p>\n<p data-nodeid=\"1432\">对于 JavaScript 而言，上面的数组其实长的都一样，并没有一个有效的途径可以区分彼此。</p>\n<p data-nodeid=\"1433\">不过，出于较好的扩展性、可读性和稳定性考虑，我们往往会更偏向于<strong data-nodeid=\"1585\">把不同类型的值通过键值对的形式塞到一个对象中，再返回这个对象</strong>（尽管这样会增加代码量），而不是使用没有任何限制的数组。比如我们可能会使用如下的对象结构来替换数组：</p>\n<pre class=\"lang-typescript\" data-nodeid=\"1434\"><code data-language=\"typescript\">{\n  state,\n  setState\n}\n</code></pre>\n<p data-nodeid=\"1435\">而 TypeScript 的元组类型正好弥补了这个不足，使得定义包含固定个数元素、每个元素类型未必相同的数组成为可能。（需要注意的是，毕竟 TypeScript 会转译成 JavaScript，所以 TypeScript 的元组无法在运行时约束所谓的“元组”像真正的元组一样，保证元素类型、长度不可变更）。</p>\n<p data-nodeid=\"1436\">对于 TypeScript 而言，如下所示的两个元组类型其实并不相同：</p>\n<pre class=\"lang-typescript\" data-nodeid=\"1437\"><code data-language=\"typescript\">[State, SetState]\n[SetState, State]\n</code></pre>\n<p data-nodeid=\"1438\">所以添加了不同元组类型注解的数组后，在 TypeScript 静态类型检测层面就变成了两个不相同的元组，如下代码所示：</p>\n<pre class=\"lang-typescript\" data-nodeid=\"1439\"><code data-language=\"typescript\"><span class=\"hljs-keyword\">const</span> x: [State, SetState] = [state, setState];\n<span class=\"hljs-keyword\">const</span> y: [SetState, State] = [setState, state];\n</code></pre>\n<p data-nodeid=\"1440\">下面我们还是使用所熟知的 React Hooks 来介绍 TypeScript 元组的应用场景。</p>\n<p data-nodeid=\"1441\">比如 useState 的返回值类型是一个元组类型，如下代码所示（以下仅是简单的例子，事实上 useState 的类型定义更为复杂）：</p>\n<pre class=\"lang-typescript\" data-nodeid=\"1442\"><code data-language=\"typescript\">(state: State) =&gt; [State, SetState]\n</code></pre>\n<p data-nodeid=\"1443\">元组相较对象而言，不仅为我们实现解构赋值提供了极大便利，还减少了不少代码量，这可能也是 React 官方如此设计核心 Hooks 的重要原因之一。</p>\n<p data-nodeid=\"1444\">但事实上，许多第三方的 Hooks 往往会出于扩展性、稳定性等考虑，尤其是需要返回的值的个数超过 2 个时，会更偏向于使用对象作为返回值。</p>\n<blockquote data-nodeid=\"1445\">\n<p data-nodeid=\"1446\">这里需要注意：数组类型的值只有显示添加了元组类型注解后（或者使用 as const，声明为只读元组），TypeScript 才会把它当作元组，否则推荐出来的类型就是普通的数组类型（第 4 讲会介绍类型推断）。</p>\n</blockquote>\n<p data-nodeid=\"1447\">相对于以上熟悉的 JavaScript 一般味道的数组类型，接下来我们将介绍几种不一样且需要费点心力理解的类型——特殊类型（这是并不是 TypeScript 官方的定义，这么划分是为了更好地组织知识点）。</p>\n<h3 data-nodeid=\"1448\">特殊类型</h3>\n<h4 data-nodeid=\"1449\">1. any</h4>\n<p data-nodeid=\"1450\">any 指的是一个任意类型，它是官方提供的一个选择性绕过静态类型检测的作弊方式。</p>\n<p data-nodeid=\"1451\">我们可以对被注解为 any 类型的变量进行任何操作，包括获取事实上并不存在的属性、方法，并且 TypeScript 还无法检测其属性是否存在、类型是否正确。</p>\n<p data-nodeid=\"1452\">比如我们可以把任何类型的值赋值给 any 类型的变量，也可以把 any 类型的值赋值给任意类型（除 never 以外）的变量，如下代码所示：</p>\n<pre class=\"lang-typescript\" data-nodeid=\"1453\"><code data-language=\"typescript\"><span class=\"hljs-keyword\">let</span> anything: <span class=\"hljs-built_in\">any</span> = {};\nanything.doAnything(); <span class=\"hljs-comment\">// 不会提示错误</span>\nanything = <span class=\"hljs-number\">1</span>; <span class=\"hljs-comment\">// 不会提示错误</span>\nanything = <span class=\"hljs-string\">'x'</span>; <span class=\"hljs-comment\">// 不会提示错误</span>\n<span class=\"hljs-keyword\">let</span> num: <span class=\"hljs-built_in\">number</span> = anything;&nbsp;<span class=\"hljs-comment\">// 不会提示错误</span>\n<span class=\"hljs-keyword\">let</span> str: <span class=\"hljs-built_in\">string</span> = anything;&nbsp;<span class=\"hljs-comment\">// 不会提示错误</span>\n</code></pre>\n<p data-nodeid=\"1454\">如果我们不想花费过高的成本为复杂的数据添加类型注解，或者已经引入了缺少类型注解的第三方组件库，这时就可以把这些值全部注解为 any 类型，并告诉 TypeScript 选择性地忽略静态类型检测。</p>\n<p data-nodeid=\"1455\">尤其是在将一个基于 JavaScript 的应用改造成 TypeScript 的过程中，我们不得不借助 any 来选择性添加和忽略对某些 JavaScript 模块的静态类型检测，直至逐步替换掉所有的 JavaScript。</p>\n<p data-nodeid=\"1456\">any 类型会在对象的调用链中进行传导，即所有 any 类型的任意属性的类型都是 any，如下代码所示：</p>\n<pre class=\"lang-typescript\" data-nodeid=\"1457\"><code data-language=\"typescript\"><span class=\"hljs-keyword\">let</span> anything: <span class=\"hljs-built_in\">any</span> = {};\n<span class=\"hljs-keyword\">let</span> z = anything.x.y.z; <span class=\"hljs-comment\">// z 类型是 any，不会提示错误</span>\nz(); <span class=\"hljs-comment\">// 不会提示错误</span>\n</code></pre>\n<p data-nodeid=\"1458\">这里我们需要明白且记住：<strong data-nodeid=\"1610\">Any is Hell（Any 是地狱）</strong>。</p>\n<p data-nodeid=\"1459\">从长远来看，使用 any 绝对是一个坏习惯。如果一个 TypeScript 应用中充满了 any，此时静态类型检测基本起不到任何作用，也就是说与直接使用 JavaScript 没有任何区别。<strong data-nodeid=\"1615\">因此，除非有充足的理由，否则我们应该尽量避免使用 any ，并且开启禁用隐式 any 的设置。</strong></p>\n<h4 data-nodeid=\"1460\">2. unknown</h4>\n<p data-nodeid=\"1461\">unknown 是 TypeScript 3.0 中添加的一个类型，它主要用来描述类型并不确定的变量。</p>\n<p data-nodeid=\"1462\">比如在多个 if else 条件分支场景下，它可以用来接收不同条件下类型各异的返回值的临时变量，如下代码所示：</p>\n<pre class=\"lang-typescript\" data-nodeid=\"1463\"><code data-language=\"typescript\"><span class=\"hljs-keyword\">let</span> result: unknown;\n<span class=\"hljs-keyword\">if</span> (x) {\n  result = x();\n} <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (y) {\n  result = y();\n} ...\n</code></pre>\n<p data-nodeid=\"1464\">在 3.0 以前的版本中，只有使用 any 才能满足这种动态类型场景。</p>\n<p data-nodeid=\"1465\">与 any 不同的是，unknown 在类型上更安全。比如我们可以将任意类型的值赋值给 unknown，但 unknown 类型的值只能赋值给 unknown 或 any，如下代码所示：</p>\n<pre class=\"lang-typescript\" data-nodeid=\"1466\"><code data-language=\"typescript\"><span class=\"hljs-keyword\">let</span> result: unknown;\n<span class=\"hljs-keyword\">let</span> num: <span class=\"hljs-built_in\">number</span> = result; <span class=\"hljs-comment\">// 提示 ts(2322)</span>\n<span class=\"hljs-keyword\">let</span> anything: <span class=\"hljs-built_in\">any</span> = result; <span class=\"hljs-comment\">// 不会提示错误</span>\n</code></pre>\n<p data-nodeid=\"1467\">使用 unknown 后，TypeScript 会对它做类型检测。但是，如果不缩小类型（Type Narrowing），我们对 unknown 执行的任何操作都会出现如下所示错误：</p>\n<pre class=\"lang-typescript\" data-nodeid=\"1468\"><code data-language=\"typescript\"><span class=\"hljs-keyword\">let</span> result: unknown;\nresult.toFixed(); <span class=\"hljs-comment\">// 提示 ts(2571)</span>\n</code></pre>\n<p data-nodeid=\"1469\"><strong data-nodeid=\"1628\">而所有的类型缩小手段对 unknown 都有效</strong>，如下代码所示：</p>\n<pre class=\"lang-typescript\" data-nodeid=\"1470\"><code data-language=\"typescript\"><span class=\"hljs-keyword\">let</span> result: unknown;\n<span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">typeof</span> result === <span class=\"hljs-string\">'number'</span>) {\n  result.toFixed(); <span class=\"hljs-comment\">// 此处 hover result 提示类型是 number，不会提示错误</span>\n}\n</code></pre>\n<h4 data-nodeid=\"1471\">3. void、undefined、null</h4>\n<p data-nodeid=\"1472\">考虑再三，我们还是决定把 void、undefined 和 null “三废柴”特殊类型整合到一起介绍。</p>\n<p data-nodeid=\"1473\">依照官方的说法，它们实际上并没有太大的用处，尤其是在本专栏中强烈推荐并要求的 strict 模式下，它们是名副其实的“废柴”。</p>\n<p data-nodeid=\"1474\">首先我们来说一下 void 类型，它仅适用于表示没有返回值的函数。即如果该函数没有返回值，那它的类型就是 void。</p>\n<p data-nodeid=\"1475\">在 strict 模式下，声明一个 void 类型的变量几乎没有任何实际用处，因为我们不能把 void 类型的变量值再赋值给除了 any 和 unkown 之外的任何类型变量。</p>\n<p data-nodeid=\"1476\">然后我们说说 undefined 类型 和 null 类型，它们是 TypeScript 值与类型关键字同名的唯二例外。但这并不影响它们被称为“废柴”，因为单纯声明 undefined 或者 null 类型的变量也是无比鸡肋，示例如下所示：</p>\n<pre class=\"lang-typescript\" data-nodeid=\"1477\"><code data-language=\"typescript\"><span class=\"hljs-keyword\">let</span> undeclared: <span class=\"hljs-literal\">undefined</span> = <span class=\"hljs-literal\">undefined</span>; <span class=\"hljs-comment\">// 鸡肋</span>\n<span class=\"hljs-keyword\">let</span> nullable: <span class=\"hljs-literal\">null</span> = <span class=\"hljs-literal\">null</span>; <span class=\"hljs-comment\">// 鸡肋</span>\n</code></pre>\n<p data-nodeid=\"1478\">undefined 的最大价值主要体现在接口类型（第 7 讲会涉及）上，它表示一个可缺省、未定义的属性。</p>\n<p data-nodeid=\"1479\">这里分享一个稍微有点费解的设计：<strong data-nodeid=\"1642\">我们可以把 undefined 值或类型是 undefined 的变量赋值给 void 类型变量，反过来，类型是 void 但值是 undefined 的变量不能赋值给 undefined 类型。</strong></p>\n<pre class=\"lang-typescript\" data-nodeid=\"1480\"><code data-language=\"typescript\"><span class=\"hljs-keyword\">const</span> userInfo: {\n  id?: <span class=\"hljs-built_in\">number</span>;\n} = {};\n<span class=\"hljs-keyword\">let</span> undeclared: <span class=\"hljs-literal\">undefined</span> = <span class=\"hljs-literal\">undefined</span>;\n<span class=\"hljs-keyword\">let</span> unusable: <span class=\"hljs-built_in\">void</span> = <span class=\"hljs-literal\">undefined</span>;\nunusable = undeclared; <span class=\"hljs-comment\">// ok</span>\nundeclared = unusable; <span class=\"hljs-comment\">// ts(2322)</span>\n</code></pre>\n<p data-nodeid=\"1481\">而 null 的价值我认为主要体现在接口制定上，它表明对象或属性可能是空值。尤其是在前后端交互的接口，比如 Java Restful、Graphql，任何涉及查询的属性、对象都可能是 null 空对象，如下代码所示：</p>\n<pre class=\"lang-typescript\" data-nodeid=\"1482\"><code data-language=\"typescript\"><span class=\"hljs-keyword\">const</span> userInfo: {\n  name: <span class=\"hljs-literal\">null</span> | <span class=\"hljs-built_in\">string</span>\n} = { name: <span class=\"hljs-literal\">null</span> };\n</code></pre>\n<p data-nodeid=\"1483\">除此之外，undefined 和 null 类型还具备警示意义，它们可以提醒我们针对可能操作这两种（类型）值的情况做容错处理。</p>\n<p data-nodeid=\"1484\">我们需要类型守卫（Type Guard，<strong data-nodeid=\"1650\">第 11 讲会专门讲解</strong>）在操作之前判断值的类型是否支持当前的操作。类型守卫既能通过类型缩小影响 TypeScript 的类型检测，也能保障 JavaScript 运行时的安全性，如下代码所示：</p>\n<pre class=\"lang-typescript te-preview-highlight\" data-nodeid=\"5286\"><code data-language=\"typescript\"><span class=\"hljs-keyword\">const</span> userInfo: {\n  id?: <span class=\"hljs-built_in\">number</span>;\n  name?: <span class=\"hljs-literal\">null</span> | <span class=\"hljs-built_in\">string</span>\n} = { id: <span class=\"hljs-number\">1</span>, name: <span class=\"hljs-string\">'Captain'</span> };\n<span class=\"hljs-keyword\">if</span> (userInfo.id !== <span class=\"hljs-literal\">undefined</span>) { <span class=\"hljs-comment\">// Type Guard</span>\n  userInfo.id.toFixed(); <span class=\"hljs-comment\">// id 的类型缩小成 number</span>\n}\n</code></pre>\n\n\n\n\n\n\n<p data-nodeid=\"1486\">我们不建议随意使用非空断言（下面要讲的“类型断言”中会详细介绍非空断言）来排除值可能为 null 或 undefined 的情况，因为这样很不安全。</p>\n<pre class=\"lang-typescript\" data-nodeid=\"1487\"><code data-language=\"typescript\">userInfo.id!.toFixed(); <span class=\"hljs-comment\">// ok，但不建议</span>\nuserInfo.name!.toLowerCase() <span class=\"hljs-comment\">// ok，但不建议</span>\n</code></pre>\n<p data-nodeid=\"1488\">而比非空断言更安全、类型守卫更方便的做法是使用单问号（Optional Chain）、双问号（空值合并），我们可以使用它们来保障代码的安全性，如下代码所示：</p>\n<pre class=\"lang-typescript\" data-nodeid=\"1489\"><code data-language=\"typescript\">userInfo.id?.toFixed(); <span class=\"hljs-comment\">// Optional Chain</span>\n<span class=\"hljs-keyword\">const</span> myName = userInfo.name?? <span class=\"hljs-string\">`my name is <span class=\"hljs-subst\">${info.name}</span>`</span>; <span class=\"hljs-comment\">// 空值合并</span>\n</code></pre>\n<h4 data-nodeid=\"1490\">4. never</h4>\n<p data-nodeid=\"1491\">never 表示永远不会发生值的类型，这里我们举一个实际的场景进行说明。</p>\n<p data-nodeid=\"1492\">首先，我们定义一个统一抛出错误的函数，代码示例如下（圆括号后 : + 类型注解 表示函数返回值的类型，关于函数类型我们会在后续 <strong data-nodeid=\"1662\">“第 5 讲：函数类型”详细讲解</strong>）：</p>\n<pre class=\"lang-typescript\" data-nodeid=\"1493\"><code data-language=\"typescript\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">ThrowError</span>(<span class=\"hljs-params\">msg: <span class=\"hljs-built_in\">string</span></span>): <span class=\"hljs-title\">never</span> </span>{\n  <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-built_in\">Error</span>(msg);\n}\n</code></pre>\n<p data-nodeid=\"1494\">以上函数因为永远不会有返回值，所以它的返回值类型就是 never。</p>\n<p data-nodeid=\"1495\">同样，如果函数代码中是一个死循环，那么这个函数的返回值类型也是 never，如下代码所示。</p>\n<pre class=\"lang-typescript\" data-nodeid=\"1496\"><code data-language=\"typescript\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">InfiniteLoop</span>(<span class=\"hljs-params\"></span>): <span class=\"hljs-title\">never</span> </span>{\n  <span class=\"hljs-keyword\">while</span> (<span class=\"hljs-literal\">true</span>) {}\n}\n</code></pre>\n<p data-nodeid=\"1497\">never 是所有类型的子类型，它可以给所有类型赋值，如下代码所示。</p>\n<pre class=\"lang-typescript\" data-nodeid=\"1498\"><code data-language=\"typescript\"><span class=\"hljs-keyword\">let</span> Unreachable: never = <span class=\"hljs-number\">1</span>; <span class=\"hljs-comment\">// ts(2322)</span>\nUnreachable = <span class=\"hljs-string\">'string'</span>; <span class=\"hljs-comment\">// ts(2322)</span>\nUnreachable = <span class=\"hljs-literal\">true</span>; <span class=\"hljs-comment\">// ts(2322)</span>\n<span class=\"hljs-keyword\">let</span> num: <span class=\"hljs-built_in\">number</span> = Unreachable; <span class=\"hljs-comment\">// ok</span>\n<span class=\"hljs-keyword\">let</span> str: <span class=\"hljs-built_in\">string</span> = Unreachable;&nbsp;<span class=\"hljs-comment\">// ok</span>\n<span class=\"hljs-keyword\">let</span> bool: <span class=\"hljs-built_in\">boolean</span> = Unreachable;&nbsp;<span class=\"hljs-comment\">// ok</span>\n</code></pre>\n<p data-nodeid=\"1499\">但是反过来，除了 never 自身以外，其他类型（包括 any 在内的类型）都不能为 never 类型赋值。</p>\n<p data-nodeid=\"1500\">在恒为 false 的类型守卫条件判断下，变量的类型将缩小为 never（never 是所有其他类型的子类型，所以是类型缩小为 never，而不是变成 never）。因此，条件判断中的相关操作始终会报无法更正的错误（我们可以把这理解为一种基于静态类型检测的 Dead Code 检测机制），如下代码所示：</p>\n<pre class=\"lang-typescript\" data-nodeid=\"1501\"><code data-language=\"typescript\"><span class=\"hljs-keyword\">const</span> str: <span class=\"hljs-built_in\">string</span> = <span class=\"hljs-string\">'string'</span>;\n<span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">typeof</span> str === <span class=\"hljs-string\">'number'</span>) {\n  str.toLowerCase(); <span class=\"hljs-comment\">// Property 'toLowerCase' does not exist on type 'never'.ts(2339)</span>\n}\n</code></pre>\n<p data-nodeid=\"1502\">基于 never 的特性，我们还可以使用 never 实现一些有意思的功能。比如我们可以把 never 作为接口类型下的属性类型，用来禁止写接口下特定的属性，示例代码如下：</p>\n<pre class=\"lang-typescript\" data-nodeid=\"1503\"><code data-language=\"typescript\"><span class=\"hljs-keyword\">const</span> props: {\n  id: <span class=\"hljs-built_in\">number</span>,\n  name?: never\n} = {\n  id: <span class=\"hljs-number\">1</span>\n}\nprops.name = <span class=\"hljs-literal\">null</span>; <span class=\"hljs-comment\">// ts(2322))</span>\nprops.name = <span class=\"hljs-string\">'str'</span>; <span class=\"hljs-comment\">// ts(2322)</span>\nprops.name = <span class=\"hljs-number\">1</span>; <span class=\"hljs-comment\">// ts(2322)</span>\n</code></pre>\n<p data-nodeid=\"1504\">此时，无论我们给 props.name 赋什么类型的值，它都会提示类型错误，实际效果等同于 name 只读 。</p>\n<h4 data-nodeid=\"1505\">5. object</h4>\n<p data-nodeid=\"1506\">object 类型表示非原始类型的类型，即非&nbsp;number、string、boolean、bigint、symbol、null、undefined 的类型。然而，它也是个没有什么用武之地的类型，如下所示的一个应用场景是用来表示 Object.create 的类型。</p>\n<pre class=\"lang-typescript\" data-nodeid=\"1507\"><code data-language=\"typescript\"><span class=\"hljs-keyword\">declare</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">create</span>(<span class=\"hljs-params\">o: object | <span class=\"hljs-literal\">null</span></span>): <span class=\"hljs-title\">any</span></span>;\ncreate({}); <span class=\"hljs-comment\">// ok</span>\ncreate(<span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> <span class=\"hljs-literal\">null</span>); <span class=\"hljs-comment\">// ok</span>\ncreate(<span class=\"hljs-number\">2</span>); <span class=\"hljs-comment\">// ts(2345)</span>\ncreate(<span class=\"hljs-string\">'string'</span>); <span class=\"hljs-comment\">// ts(2345)</span>\n</code></pre>\n<h3 data-nodeid=\"1508\">类型断言（Type Assertion）</h3>\n<p data-nodeid=\"1509\">TypeScript 类型检测无法做到绝对智能，毕竟程序不能像人一样思考。有时会碰到我们比 TypeScript 更清楚实际类型的情况，比如下面的例子：</p>\n<pre class=\"lang-typescript\" data-nodeid=\"1510\"><code data-language=\"typescript\"><span class=\"hljs-keyword\">const</span> arrayNumber: <span class=\"hljs-built_in\">number</span>[] = [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>];\n<span class=\"hljs-keyword\">const</span> greaterThan2: <span class=\"hljs-built_in\">number</span> = arrayNumber.find(<span class=\"hljs-function\"><span class=\"hljs-params\">num</span> =&gt;</span> num &gt; <span class=\"hljs-number\">2</span>); <span class=\"hljs-comment\">// 提示 ts(2322)</span>\n</code></pre>\n<p data-nodeid=\"1511\">其中，greaterThan2 一定是一个数字（确切地讲是 3），因为 arrayNumber 中明显有大于 2 的成员，但静态类型对运行时的逻辑无能为力。</p>\n<p data-nodeid=\"1512\">在 TypeScript 看来，greaterThan2 的类型既可能是数字，也可能是 undefined，所以上面的示例中提示了一个 ts(2322) 错误，此时我们不能把类型 undefined 分配给类型 number。</p>\n<p data-nodeid=\"1513\">不过，我们可以使用一种笃定的方式——<strong data-nodeid=\"1683\">类型断言</strong>（类似仅作用在类型层面的强制类型转换）告诉 TypeScript 按照我们的方式做类型检查。</p>\n<p data-nodeid=\"1514\">比如，我们可以使用 as 语法做类型断言，如下代码所示：</p>\n<pre class=\"lang-typescript\" data-nodeid=\"1515\"><code data-language=\"typescript\"><span class=\"hljs-keyword\">const</span> arrayNumber: <span class=\"hljs-built_in\">number</span>[] = [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>];\n<span class=\"hljs-keyword\">const</span> greaterThan2: <span class=\"hljs-built_in\">number</span> = arrayNumber.find(<span class=\"hljs-function\"><span class=\"hljs-params\">num</span> =&gt;</span> num &gt; <span class=\"hljs-number\">2</span>) <span class=\"hljs-keyword\">as</span> <span class=\"hljs-built_in\">number</span>;\n</code></pre>\n<p data-nodeid=\"1516\">又或者是使用尖括号 + 类型的格式做类型断言，如下代码所示：</p>\n<pre class=\"lang-typescript\" data-nodeid=\"1517\"><code data-language=\"typescript\"><span class=\"hljs-keyword\">const</span> arrayNumber: <span class=\"hljs-built_in\">number</span>[] = [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>];\n<span class=\"hljs-keyword\">const</span> greaterThan2: <span class=\"hljs-built_in\">number</span> = &lt;<span class=\"hljs-built_in\">number</span>&gt;arrayNumber.find(<span class=\"hljs-function\"><span class=\"hljs-params\">num</span> =&gt;</span> num &gt; <span class=\"hljs-number\">2</span>);\n</code></pre>\n<p data-nodeid=\"1518\">以上两种方式虽然没有任何区别，但是尖括号格式会与 JSX 产生语法冲突，因此我们更推荐使用 as 语法。</p>\n<blockquote data-nodeid=\"1519\">\n<p data-nodeid=\"1520\">注意：类型断言的操作对象必须满足某些约束关系，否则我们将得到一个 ts(2352) 错误，即从类型“源类型”到类型“目标类型”的转换是错误的，因为这两种类型不能充分重叠。</p>\n</blockquote>\n<p data-nodeid=\"1521\">我一度喜欢用“指鹿为马”来形容类型断言，但其实也不够准确。</p>\n<p data-nodeid=\"1522\">从物种类型上看，鹿和马肯定不能转换，虽然它们都是动物（继承自同一个父类），但是鹿有“角属性”，马有“鬃毛属性”，所以两者不能充分重叠。</p>\n<p data-nodeid=\"1523\"><strong data-nodeid=\"1693\">如果我们把它换成“指白马为马”“指马为白马”，就可以很贴切地体现类型断言的约束条件：父子、子父类型之间可以使用类型断言进行转换。</strong></p>\n<blockquote data-nodeid=\"1524\">\n<p data-nodeid=\"1525\"><strong data-nodeid=\"1722\">注意</strong>：这个结论完全适用于复杂类型，但是对于 number、string、boolean 原始类型来说，不仅父子类型可以相互断言，父类型相同的类型也可以相互断言，比如 1 as 2、'a' as 'b'、true as false（这里的 2、'b'、false 被称之为字面量类型，在第 4 讲里会详细介绍），反过来 2 as 1、'b' as 'a'、false as true 也是被允许的（这里的 1、'a'、true 是字面量类型），尽管这样的断言没有任何意义。</p>\n</blockquote>\n<p data-nodeid=\"1526\">另外，any 和 unknown 这两个特殊类型属于万金油，因为它们既可以被断言成任何类型，反过来任何类型也都可以被断言成 any 或 unknown。因此，如果我们想强行“指鹿为马”，就可以先把“鹿”断言为 any 或 unknown，然后再把 any 和 unknown 断言为“马”，比如鹿 as any as 马。</p>\n<p data-nodeid=\"1527\">我们除了可以把特定类型断言成符合约束添加的其他类型之外，还可以使用“字面量值 + as const”语法结构进行常量断言，具体示例如下所示：</p>\n<pre class=\"lang-typescript\" data-nodeid=\"1528\"><code data-language=\"typescript\"><span class=\"hljs-comment\">/** str 类型是 '\"str\"' */</span>\n<span class=\"hljs-keyword\">let</span> str = <span class=\"hljs-string\">'str'</span> <span class=\"hljs-keyword\">as</span> <span class=\"hljs-keyword\">const</span>;\n<span class=\"hljs-comment\">/** readOnlyArr 类型是 'readonly [0, 1]' */</span>\n<span class=\"hljs-keyword\">const</span> readOnlyArr = [<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">1</span>] <span class=\"hljs-keyword\">as</span> <span class=\"hljs-keyword\">const</span>;\n</code></pre>\n<p data-nodeid=\"1529\">常量断言所涉及的字面量（字面量即代码中，比如 '\"str\"'、'1'、'true'、'{}'）与字面量类型相关的知识点将在 <strong data-nodeid=\"1748\">“第 03 讲：字面量类型”</strong> 中详细讲解，这里我们就不对实例代码做原理解析了。你可以保持着好奇心，期待后续内容。</p>\n<p data-nodeid=\"1530\">此外还有一种特殊非空断言，即在值（变量、属性）的后边添加 '!' 断言操作符，它可以用来排除值为 null、undefined 的情况，具体示例如下：</p>\n<pre class=\"lang-typescript\" data-nodeid=\"1531\"><code data-language=\"typescript\"><span class=\"hljs-keyword\">let</span> mayNullOrUndefinedOrString: <span class=\"hljs-literal\">null</span> | <span class=\"hljs-literal\">undefined</span> | <span class=\"hljs-built_in\">string</span>;\nmayNullOrUndefinedOrString!.toString(); <span class=\"hljs-comment\">// ok</span>\nmayNullOrUndefinedOrString.toString(); <span class=\"hljs-comment\">// ts(2531)</span>\n</code></pre>\n<p data-nodeid=\"1532\">对于非空断言来说，我们同样应该把它视作和 any 一样危险的选择。</p>\n<p data-nodeid=\"1533\">在复杂应用场景中，如果我们使用非空断言，就无法保证之前一定非空的值，比如页面中一定存在 id 为 feedback 的元素，数组中一定有满足 &gt; 2 条件的数字，这些都不会被其他人改变。而一旦保证被改变，错误只会在运行环境中抛出，而静态类型检测是发现不了这些错误的。</p>\n<p data-nodeid=\"1534\">所以，我们建议使用类型守卫（更多讲解，见“第 11 讲：类型守卫”）来代替非空断言，比如如下所示的条件判断：</p>\n<pre class=\"lang-typescript\" data-nodeid=\"1535\"><code data-language=\"typescript\"><span class=\"hljs-keyword\">let</span> mayNullOrUndefinedOrString: <span class=\"hljs-literal\">null</span> | <span class=\"hljs-literal\">undefined</span> | <span class=\"hljs-built_in\">string</span>;\n<span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">typeof</span> mayNullOrUndefinedOrString === <span class=\"hljs-string\">'string'</span>) {\n  mayNullOrUndefinedOrString.toString(); <span class=\"hljs-comment\">// ok</span>\n}\n</code></pre>\n<h3 data-nodeid=\"1536\">小结与预告</h3>\n<p data-nodeid=\"1537\">到这里，TypeScript 所有的基础类型就交代完了，你需要反复消化，夯实基础，为 04讲将要接触的稍微复杂的类型和应用场景做好准备。</p>\n<p data-nodeid=\"1538\" class=\"\">这里插播一个思考题：类型断言需要满足什么约束条件？欢迎你在留言区与我进行互动、交流。另外，如果你觉得本专栏有价值，欢迎分享给更多的好友哦~</p>",
                "article_title": "03 | 复杂基础类型：TypeScript 与 JavaScript 有何不同？",
                "title": "03 | 复杂基础类型：TypeScript 与 JavaScript 有何不同？",
                "id": 7435
            },
            {
                "content": "<blockquote data-nodeid=\"1141\" class=\"\">\n<p data-nodeid=\"1142\">学习建议：使用 VS Code，通过新建一个 04.Literal.ts 文件，尝试课程中的所有示例。</p>\n</blockquote>\n<p data-nodeid=\"1143\">在前面的课程中，我们已经学习了 TypeScript 的基本语法和基础类型，接下来通过几个例子温习一下（为了避免命名冲突，后续课程示例中会引入一对花括符 {} 创建块级作用域）：</p>\n<pre class=\"lang-typescript\" data-nodeid=\"1144\"><code data-language=\"typescript\">{\n  <span class=\"hljs-keyword\">let</span> str: <span class=\"hljs-built_in\">string</span> = <span class=\"hljs-string\">'this is string'</span>;\n  <span class=\"hljs-keyword\">let</span> num: <span class=\"hljs-built_in\">number</span> = <span class=\"hljs-number\">1</span>;\n  <span class=\"hljs-keyword\">let</span> bool: <span class=\"hljs-built_in\">boolean</span> = <span class=\"hljs-literal\">true</span>;\n}\n{\n  <span class=\"hljs-keyword\">const</span> str: <span class=\"hljs-built_in\">string</span> = <span class=\"hljs-string\">'this is string'</span>;\n  <span class=\"hljs-keyword\">const</span> num: <span class=\"hljs-built_in\">number</span> = <span class=\"hljs-number\">1</span>;\n  <span class=\"hljs-keyword\">const</span> bool: <span class=\"hljs-built_in\">boolean</span> = <span class=\"hljs-literal\">true</span>;\n}\n</code></pre>\n<p data-nodeid=\"1145\">看着上面的示例，可能你在 02 讲中已经嘀咕了：定义基础类型的变量都需要写明类型注解，TypeScript 太麻烦了吧？在示例中，使用 let 定义变量时，我们写明类型注解也就罢了，毕竟值可能会被改变。可是，使用 const 常量时还需要写明类型注解，那可真的很麻烦。</p>\n<p data-nodeid=\"1146\">实际上，TypeScript 早就考虑到了这么简单而明显的问题。</p>\n<p data-nodeid=\"1147\">在很多情况下，TypeScript 会根据上下文环境自动推断出变量的类型，无须我们再写明类型注解。因此，上面的示例可以简化为如下所示内容：</p>\n<pre class=\"lang-typescript\" data-nodeid=\"1148\"><code data-language=\"typescript\">{\n  <span class=\"hljs-keyword\">let</span> str = <span class=\"hljs-string\">'this is string'</span>; <span class=\"hljs-comment\">// 等价</span>\n  <span class=\"hljs-keyword\">let</span> num = <span class=\"hljs-number\">1</span>; <span class=\"hljs-comment\">// 等价</span>\n  <span class=\"hljs-keyword\">let</span> bool = <span class=\"hljs-literal\">true</span>; <span class=\"hljs-comment\">// 等价</span>\n}\n{\n  <span class=\"hljs-keyword\">const</span> str = <span class=\"hljs-string\">'this is string'</span>; <span class=\"hljs-comment\">// 不等价</span>\n  <span class=\"hljs-keyword\">const</span> num = <span class=\"hljs-number\">1</span>; <span class=\"hljs-comment\">// 不等价</span>\n  <span class=\"hljs-keyword\">const</span> bool = <span class=\"hljs-literal\">true</span>; <span class=\"hljs-comment\">// 不等价</span>\n}\n</code></pre>\n<blockquote data-nodeid=\"1149\">\n<p data-nodeid=\"1150\">注意：这里说的仅仅是“简化”，而不是说两个示例完全等价，接下来我们会进一步介绍。</p>\n</blockquote>\n<p data-nodeid=\"1151\">我们把 TypeScript 这种基于赋值表达式推断类型的能力称之为“类型推断”。</p>\n<h3 data-nodeid=\"1152\">类型推断</h3>\n<p data-nodeid=\"1153\">在 TypeScript 中，类型标注声明是在变量之后（即类型后置），它不像 Java 语言一样，先声明变量的类型，再声明变量的名称。</p>\n<p data-nodeid=\"1154\">使用类型标注后置的好处是编译器可以通过代码所在的上下文推导其对应的类型，无须再声明变量类型，具体示例如下：</p>\n<pre class=\"lang-typescript\" data-nodeid=\"1155\"><code data-language=\"typescript\">{\n  <span class=\"hljs-keyword\">let</span> x1 = <span class=\"hljs-number\">42</span>; <span class=\"hljs-comment\">// 推断出 x1 的类型是 number</span>\n  <span class=\"hljs-keyword\">let</span> x2: <span class=\"hljs-built_in\">number</span> = x1; <span class=\"hljs-comment\">// ok</span>\n}\n</code></pre>\n<p data-nodeid=\"1156\">在上述代码中，x1 的类型被推断为 number，将变量赋值给 number 类型的变量 x2 后，不会出现任何错误。</p>\n<p data-nodeid=\"1157\">在 TypeScript 中，具有初始化值的变量、有默认值的函数参数、函数返回的类型（05 讲中会专门介绍函数类型）都可以根据上下文推断出来。比如我们能根据 return 语句推断函数返回的类型，如下代码所示：</p>\n<pre class=\"lang-typescript\" data-nodeid=\"1158\"><code data-language=\"typescript\">{\n  <span class=\"hljs-comment\">/** 根据参数的类型，推断出返回值的类型也是 number */</span>\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">add1</span>(<span class=\"hljs-params\">a: <span class=\"hljs-built_in\">number</span>, b: <span class=\"hljs-built_in\">number</span></span>) </span>{\n    <span class=\"hljs-keyword\">return</span> a + b;\n  }\n  <span class=\"hljs-keyword\">const</span> x1= add1(<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">1</span>); <span class=\"hljs-comment\">// 推断出 x1 的类型也是 number</span>\n\n  <span class=\"hljs-comment\">/** 推断参数 b 的类型是数字或者 undefined，返回值的类型也是数字 */</span>\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">add2</span>(<span class=\"hljs-params\">a: <span class=\"hljs-built_in\">number</span>, b = 1</span>) </span>{\n    <span class=\"hljs-keyword\">return</span> a + b;\n  }\n  <span class=\"hljs-keyword\">const</span> x2 = add2(<span class=\"hljs-number\">1</span>);\n  <span class=\"hljs-keyword\">const</span> x3 = add2(<span class=\"hljs-number\">1</span>, <span class=\"hljs-string\">'1'</span>); <span class=\"hljs-comment\">// ts(2345) Argument of type '\"1\"' is not assignable to parameter of type 'number | undefined</span>\n}\n</code></pre>\n<p data-nodeid=\"1159\">在上述 add1 函数中，我们 return 了变量 a + b 的结果，因为 a 和 b 的类型为 number，所以函数返回类型被推断为 number。</p>\n<p data-nodeid=\"1160\">当然，拥有默认值的函数参数的类型也能被推断出来。比如上述 add2 函数中，b 参数被推断为 number | undefined 类型，如果我们给 b 参数传入一个字符串类型的值，由于函数参数类型不一致，此时编译器就会抛出一个 ts(2345) 错误。</p>\n<h3 data-nodeid=\"1161\">上下文推断</h3>\n<p data-nodeid=\"1162\">通过类型推断的例子，我们发现变量的类型可以通过被赋值的值进行推断。除此之外，在某些特定的情况下，我们也可以通过变量所在的上下文环境推断变量的类型，具体示例如下：</p>\n<pre class=\"lang-typescript\" data-nodeid=\"1163\"><code data-language=\"typescript\">{\n  <span class=\"hljs-keyword\">type</span> Adder = <span class=\"hljs-function\">(<span class=\"hljs-params\">a: <span class=\"hljs-built_in\">number</span>, b: <span class=\"hljs-built_in\">number</span></span>) =&gt;</span> <span class=\"hljs-built_in\">number</span>;\n  <span class=\"hljs-keyword\">const</span> add: Adder = <span class=\"hljs-function\">(<span class=\"hljs-params\">a, b</span>) =&gt;</span> {\n    <span class=\"hljs-keyword\">return</span> a + b;\n  }\n  <span class=\"hljs-keyword\">const</span> x1 = add(<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">1</span>); <span class=\"hljs-comment\">// 推断出 x1 类型是 number</span>\n  <span class=\"hljs-keyword\">const</span> x2 = add(<span class=\"hljs-number\">1</span>, <span class=\"hljs-string\">'1'</span>);  <span class=\"hljs-comment\">// ts(2345) Argument of type '\"1\"' is not assignable to parameter of type 'number</span>\n}\n</code></pre>\n<p data-nodeid=\"1164\">这里我们定义了一个实现加法功能的<strong data-nodeid=\"1268\">函数类型 Adde</strong>r（定义的 Adder 类型使用了 type 类型别名，这点会在 07 讲专门介绍），声明了<strong data-nodeid=\"1269\">add</strong>变量的类型为 Adder 并赋值一个匿名箭头函数，箭头函数参数 a 和 b 的类型和返回类型都没有显式声明。</p>\n<p data-nodeid=\"1165\">TypeScript 通过<strong data-nodeid=\"1275\">add</strong>的类型 Adder 反向（通过变量类型推断出值的相关类型）推断出箭头函数参数及返回值的类型，也就是说函数参数 a、b，以及返回类型在这个变量的声明上下文中被确定了（更多关于函数类型相关的知识点会在 05 讲中详细介绍）。</p>\n<p data-nodeid=\"1166\">正是得益于 TypeScript 这种类型推导机制和能力，使得我们无须显式声明，即可直接通过上下文环境推断出变量的类型，也就是说此时类型可缺省。</p>\n<p data-nodeid=\"1167\">下面回头看最前面的示例（如下所示），我们发现这些缺省类型注解的变量还可以通过类型推断出类型。</p>\n<pre class=\"lang-typescript\" data-nodeid=\"1168\"><code data-language=\"typescript\">{\n  <span class=\"hljs-keyword\">let</span> str = <span class=\"hljs-string\">'this is string'</span>; <span class=\"hljs-comment\">// str: string</span>\n  <span class=\"hljs-keyword\">let</span> num = <span class=\"hljs-number\">1</span>; <span class=\"hljs-comment\">// num: number</span>\n  <span class=\"hljs-keyword\">let</span> bool = <span class=\"hljs-literal\">true</span>; <span class=\"hljs-comment\">// bool: boolean</span>\n}\n{\n  <span class=\"hljs-keyword\">const</span> str = <span class=\"hljs-string\">'this is string'</span>; <span class=\"hljs-comment\">// str: 'this is string'</span>\n  <span class=\"hljs-keyword\">const</span> num = <span class=\"hljs-number\">1</span>; <span class=\"hljs-comment\">// num: 1</span>\n  <span class=\"hljs-keyword\">const</span> bool = <span class=\"hljs-literal\">true</span>; <span class=\"hljs-comment\">// bool: true</span>\n}\n</code></pre>\n<p data-nodeid=\"1169\">如上述代码中注释说明，通过 let 和 const 定义的赋予了相同值的变量，其推断出来的类型不一样。比如同样是 'this is string'（这里表示一个字符串值），通过 let 定义的变量类型是 string，而通过 const 定义的变量类型是 'this is string'（这里表示一个字符串字面量类型）。这里我们可以通过 VS Code hover 示例中的变量查看类型，验证一下这个结论。</p>\n<p data-nodeid=\"1170\">在讲解差异之前，我们先来聊一下字面量类型。</p>\n<h3 data-nodeid=\"1171\">字面量类型</h3>\n<p data-nodeid=\"1172\">在 TypeScript 中，字面量不仅可以表示值，还可以表示类型，即所谓的字面量类型。</p>\n<p data-nodeid=\"1173\">目前，TypeScript 支持 3 种字面量类型：字符串字面量类型、数字字面量类型、布尔字面量类型，对应的字符串字面量、数字字面量、布尔字面量分别拥有与其值一样的字面量类型，具体示例如下：</p>\n<pre class=\"lang-typescript\" data-nodeid=\"1174\"><code data-language=\"typescript\">{\n  <span class=\"hljs-keyword\">let</span> specifiedStr: <span class=\"hljs-string\">'this is string'</span> = <span class=\"hljs-string\">'this is string'</span>;\n  <span class=\"hljs-keyword\">let</span> specifiedNum: <span class=\"hljs-number\">1</span> = <span class=\"hljs-number\">1</span>;\n  <span class=\"hljs-keyword\">let</span> specifiedBoolean: <span class=\"hljs-literal\">true</span> = <span class=\"hljs-literal\">true</span>;\n}\n</code></pre>\n<p data-nodeid=\"1175\">字面量类型是集合类型的子类型，它是集合类型的一种更具体的表达。比如 'this is string' （这里表示一个字符串字面量类型）类型是 string 类型（确切地说是 string 类型的子类型），而 string 类型不一定是 'this is string'（这里表示一个字符串字面量类型）类型，如下具体示例：</p>\n<pre class=\"lang-typescript te-preview-highlight\" data-nodeid=\"9991\"><code data-language=\"typescript\">{\n  <span class=\"hljs-keyword\">let</span> specifiedStr: <span class=\"hljs-string\">'this is string'</span> = <span class=\"hljs-string\">'this is string'</span>;\n  <span class=\"hljs-keyword\">let</span> str: <span class=\"hljs-built_in\">string</span> = <span class=\"hljs-string\">'any string'</span>;\n  specifiedStr = str; <span class=\"hljs-comment\">// ts(2322) 类型 '\"string\"' 不能赋值给类型 'this is string'</span>\n  str = specifiedStr; <span class=\"hljs-comment\">// ok </span>\n}\n</code></pre>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n<p data-nodeid=\"1177\">这里，我们通过一个更通俗的说法来理解字面量类型和所属集合类型的关系。</p>\n<p data-nodeid=\"1178\">比如说我们用“马”比喻 string 类型，即“黑马”代指 'this is string' 类型，“黑马”肯定是“马”，但“马”不一定是“黑马”，它可能还是“白马”“灰马”。因此，'this is string' 字面量类型可以给 string 类型赋值，但是 string 类型不能给 'this is string' 字面量类型赋值，这个比喻同样适合于形容数字、布尔等其他字面量和它们父类的关系。</p>\n<p data-nodeid=\"1179\">接下来，我们介绍一下字符串字面量类型、数字字面量类型、布尔字面量类型。</p>\n<h4 data-nodeid=\"1180\">字符串字面量类型</h4>\n<p data-nodeid=\"1181\">一般来说，我们可以使用一个字符串字面量类型作为变量的类型，如下代码所示：</p>\n<pre class=\"lang-typescript\" data-nodeid=\"1182\"><code data-language=\"typescript\"><span class=\"hljs-keyword\">let</span> hello: <span class=\"hljs-string\">'hello'</span> = <span class=\"hljs-string\">'hello'</span>;\nhello = <span class=\"hljs-string\">'hi'</span>; <span class=\"hljs-comment\">// ts(2322) Type '\"hi\"' is not assignable to type '\"hello\"'</span>\n</code></pre>\n<p data-nodeid=\"1183\">实际上，定义单个的字面量类型并没有太大的用处，它真正的应用场景是可以把多个字面量类型组合成一个联合类型（详见 08 讲），用来描述拥有明确成员的实用的集合。</p>\n<p data-nodeid=\"1184\">如下代码所示，我们使用字面量联合类型描述了一个明确、可 'up' 可 'down' 的集合，这样就能清楚地知道需要的数据结构了。</p>\n<pre class=\"lang-typescript\" data-nodeid=\"1185\"><code data-language=\"typescript\"><span class=\"hljs-keyword\">type</span> Direction = <span class=\"hljs-string\">'up'</span> | <span class=\"hljs-string\">'down'</span>;\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">move</span>(<span class=\"hljs-params\">dir: Direction</span>) </span>{\n  <span class=\"hljs-comment\">// ...</span>\n}\nmove(<span class=\"hljs-string\">'up'</span>); <span class=\"hljs-comment\">// ok</span>\nmove(<span class=\"hljs-string\">'right'</span>); <span class=\"hljs-comment\">// ts(2345) Argument of type '\"right\"' is not assignable to parameter of type 'Direction'</span>\n</code></pre>\n<p data-nodeid=\"1186\">通过使用字面量类型组合的联合类型，我们可以限制函数的参数为指定的字面量类型集合，然后编译器会检查参数是否是指定的字面量类型集合里的成员。</p>\n<p data-nodeid=\"1187\">因此，相较于使用 string 类型，使用字面量类型（组合的联合类型）可以将函数的参数限定为更具体的类型。这不仅提升了程序的可读性，还保证了函数的参数类型，可谓一举两得。</p>\n<h4 data-nodeid=\"1188\">数字字面量类型及布尔字面量类型</h4>\n<p data-nodeid=\"1189\">数字字面量类型和布尔字面量类型的使用与字符串字面量类型的使用类似，我们可以使用字面量组合的联合类型将函数的参数限定为更具体的类型，比如声明如下所示的一个类型 Config：</p>\n<pre class=\"lang-typescript\" data-nodeid=\"1190\"><code data-language=\"typescript\"><span class=\"hljs-keyword\">interface</span> Config {\n    size: <span class=\"hljs-string\">'small'</span> | <span class=\"hljs-string\">'big'</span>;\n    isEnable:  <span class=\"hljs-literal\">true</span> | <span class=\"hljs-literal\">false</span>;\n    margin: <span class=\"hljs-number\">0</span> | <span class=\"hljs-number\">2</span> | <span class=\"hljs-number\">4</span>;\n}\n</code></pre>\n<p data-nodeid=\"1191\">在上述代码中，我们限定了 size 属性为字符串字面量类型 'small' | 'big'，isEnable 属性为布尔字面量类型 true | false（布尔字面量只包含 true 和 false，true | false 的组合跟直接使用 boolean 没有区别），margin 属性为数字字面量类型 0 | 2 | 4。</p>\n<p data-nodeid=\"1192\"><strong data-nodeid=\"1353\">介绍完三种字面量类型后，我们再来看看通过 let 和 const 定义的变量的值相同，而变量类型不一致的具体原因。</strong></p>\n<p data-nodeid=\"1193\">我们先来看一个 const 示例，如下代码所示：</p>\n<pre class=\"lang-typescript\" data-nodeid=\"1194\"><code data-language=\"typescript\">{\n  <span class=\"hljs-keyword\">const</span> str = <span class=\"hljs-string\">'this is string'</span>; <span class=\"hljs-comment\">// str: 'this is string'</span>\n  <span class=\"hljs-keyword\">const</span> num = <span class=\"hljs-number\">1</span>; <span class=\"hljs-comment\">// num: 1</span>\n  <span class=\"hljs-keyword\">const</span> bool = <span class=\"hljs-literal\">true</span>; <span class=\"hljs-comment\">// bool: true</span>\n}\n</code></pre>\n<p data-nodeid=\"1195\">在上述代码中，我们将 const 定义为一个不可变更的常量，在缺省类型注解的情况下，TypeScript 推断出它的类型直接由赋值字面量的类型决定，这也是一种比较合理的设计。</p>\n<p data-nodeid=\"1196\">接下来我们看看如下所示的 let 示例，此时理解起来可能会稍微难一些。</p>\n<pre class=\"lang-typescript\" data-nodeid=\"1197\"><code data-language=\"typescript\">{\n  <span class=\"hljs-keyword\">let</span> str = <span class=\"hljs-string\">'this is string'</span>; <span class=\"hljs-comment\">// str: string</span>\n  <span class=\"hljs-keyword\">let</span> num = <span class=\"hljs-number\">1</span>; <span class=\"hljs-comment\">// num: number</span>\n  <span class=\"hljs-keyword\">let</span> bool = <span class=\"hljs-literal\">true</span>; <span class=\"hljs-comment\">// bool: boolean</span>\n}\n</code></pre>\n<p data-nodeid=\"1198\">在上述代码中，缺省显式类型注解的可变更的变量的类型转换为了赋值字面量类型的父类型，比如 str 的类型是 'this is string' 类型（这里表示一个字符串字面量类型）的父类型 string，num 的类型是 1 类型的父类型 number。</p>\n<p data-nodeid=\"1199\">这种设计符合编程预期，意味着我们可以分别赋予 str 和 num 任意值（只要类型是 string 和 number 的子集的变量）：</p>\n<pre class=\"lang-typescript\" data-nodeid=\"1200\"><code data-language=\"typescript\">  str = <span class=\"hljs-string\">'any string'</span>;\n  num = <span class=\"hljs-number\">2</span>;\n  bool = <span class=\"hljs-literal\">false</span>;\n</code></pre>\n<p data-nodeid=\"1201\">我们将 TypeScript 的字面量子类型转换为父类型的这种设计称之为 \"literal widening\"，也就是字面量类型的拓宽，比如上面示例中提到的字符串字面量类型转换成 string 类型，下面我们着重介绍一下。</p>\n<h4 data-nodeid=\"1202\">Literal Widening</h4>\n<p data-nodeid=\"1203\">所有通过 let 或 var 定义的变量、函数的形参、对象的非只读属性，如果满足指定了初始值且未显式添加类型注解的条件，那么它们推断出来的类型就是指定的初始值字面量类型拓宽后的类型，这就是字面量类型拓宽。</p>\n<p data-nodeid=\"1204\">下面我们通过字符串字面量的示例来理解一下字面量类型拓宽：</p>\n<pre class=\"lang-typescript\" data-nodeid=\"1205\"><code data-language=\"typescript\">{\n  <span class=\"hljs-keyword\">let</span> str = <span class=\"hljs-string\">'this is string'</span>; <span class=\"hljs-comment\">// 类型是 string</span>\n  <span class=\"hljs-keyword\">let</span> strFun = <span class=\"hljs-function\">(<span class=\"hljs-params\">str = '<span class=\"hljs-keyword\">this</span> is <span class=\"hljs-built_in\">string</span>'</span>) =&gt;</span> str; <span class=\"hljs-comment\">// 类型是 (str?: string) =&gt; string;</span>\n  <span class=\"hljs-keyword\">const</span> specifiedStr = <span class=\"hljs-string\">'this is string'</span>; <span class=\"hljs-comment\">// 类型是 'this is string'</span>\n  <span class=\"hljs-keyword\">let</span> str2 = specifiedStr; <span class=\"hljs-comment\">// 类型是 'string'</span>\n  <span class=\"hljs-keyword\">let</span> strFun2 = <span class=\"hljs-function\">(<span class=\"hljs-params\">str = specifiedStr</span>) =&gt;</span> str; <span class=\"hljs-comment\">// 类型是 (str?: string) =&gt; string;</span>\n}\n</code></pre>\n<p data-nodeid=\"1206\">因为第 2~3 行满足了 let、形参且未显式声明类型注解的条件，所以变量、形参的类型拓宽为 string（形参类型确切地讲是 string | undefined）。</p>\n<p data-nodeid=\"1207\">因为第 5 行的常量不可变更，类型没有拓宽，所以 specifiedStr 的类型是 'this is string' 字面量类型。</p>\n<p data-nodeid=\"1208\">第 7~8 行，因为赋予的值 specifiedStr 的类型是字面量类型，且没有显式类型注解，所以变量、形参的类型也被拓宽了。其实，这样的设计符合实际编程诉求。我们设想一下，如果 str2 的类型被推断为 'this is string'，它将不可变更，因为赋予任何其他的字符串类型的值都会提示类型错误。</p>\n<p data-nodeid=\"1209\">基于字面量类型拓宽的条件，我们可以通过如下所示代码添加显示类型注解控制类型拓宽行为。</p>\n<pre class=\"lang-typescript\" data-nodeid=\"1210\"><code data-language=\"typescript\">{\n  <span class=\"hljs-keyword\">const</span> specifiedStr: <span class=\"hljs-string\">'this is string'</span> = <span class=\"hljs-string\">'this is string'</span>; <span class=\"hljs-comment\">// 类型是 '\"this is string\"'</span>\n  <span class=\"hljs-keyword\">let</span> str2 = specifiedStr; <span class=\"hljs-comment\">// 即便使用 let 定义，类型是 'this is string'</span>\n}\n</code></pre>\n<p data-nodeid=\"1211\">实际上，除了字面量类型拓宽之外，TypeScript 对某些特定类型值也有类似 \"Type Widening\" （类型拓宽）的设计，下面我们具体来了解一下。</p>\n<h4 data-nodeid=\"1212\">Type Widening</h4>\n<p data-nodeid=\"1213\">比如对 null 和 undefined 的类型进行拓宽，通过 let、var 定义的变量如果满足未显式声明类型注解且被赋予了 null 或 undefined 值，则推断出这些变量的类型是 any：</p>\n<pre class=\"lang-typescript\" data-nodeid=\"1214\"><code data-language=\"typescript\">{\n  <span class=\"hljs-keyword\">let</span> x = <span class=\"hljs-literal\">null</span>; <span class=\"hljs-comment\">// 类型拓宽成 any</span>\n  <span class=\"hljs-keyword\">let</span> y = <span class=\"hljs-literal\">undefined</span>; <span class=\"hljs-comment\">// 类型拓宽成 any</span>\n  <span class=\"hljs-comment\">/** -----分界线------- */</span>\n  <span class=\"hljs-keyword\">const</span> z = <span class=\"hljs-literal\">null</span>; <span class=\"hljs-comment\">// 类型是 null</span>\n  <span class=\"hljs-comment\">/** -----分界线------- */</span>\n  <span class=\"hljs-keyword\">let</span> anyFun = <span class=\"hljs-function\">(<span class=\"hljs-params\">param = <span class=\"hljs-literal\">null</span></span>) =&gt;</span> param; <span class=\"hljs-comment\">// 形参类型是 null</span>\n  <span class=\"hljs-keyword\">let</span> z2 = z; <span class=\"hljs-comment\">// 类型是 null</span>\n  <span class=\"hljs-keyword\">let</span> x2 = x; <span class=\"hljs-comment\">// 类型是 null</span>\n  <span class=\"hljs-keyword\">let</span> y2 = y; <span class=\"hljs-comment\">// 类型是 undefined</span>\n}\n</code></pre>\n<blockquote data-nodeid=\"1215\">\n<p data-nodeid=\"1216\">注意：在严格模式下，一些比较老的版本中（2.0）null 和 undefined 并不会被拓宽成“any”。因此，某些过时的资料中会存在与课程不一致的解释。</p>\n</blockquote>\n<p data-nodeid=\"1217\">在现代 TypeScript 中，以上示例的第 2~3 行的类型拓宽更符合实际编程习惯，我们可以赋予任何其他类型的值给具有 null 或 undefined 初始值的变量 x 和 y。</p>\n<p data-nodeid=\"1218\">示例第 7~10 行的类型推断行为因为开启了 strictNullChecks=true（说明：本课程所有示例都基于严格模式编写），此时我们可以从类型安全的角度试着思考一下：这几行代码中出现的变量、形参的类型为什么是 null 或 undefined，而不是 any？因为前者可以让我们更谨慎对待这些变量、形参，而后者不能。</p>\n<p data-nodeid=\"1219\">既然有类型拓宽，自然也会有类型缩小，下面我们简单介绍一下 Type Narrowing。</p>\n<h4 data-nodeid=\"1220\">Type Narrowing</h4>\n<p data-nodeid=\"1221\">在 TypeScript 中，我们可以通过某些操作将变量的类型由一个较为宽泛的集合缩小到相对较小、较明确的集合，这就是 \"Type Narrowing\"。</p>\n<p data-nodeid=\"1222\">比如，我们可以使用类型守卫（详见 11 讲的内容）将函数参数的类型从 any 缩小到明确的类型，具体示例如下：</p>\n<pre class=\"lang-typescript\" data-nodeid=\"1223\"><code data-language=\"typescript\">{\n  <span class=\"hljs-keyword\">let</span> func = <span class=\"hljs-function\">(<span class=\"hljs-params\">anything: <span class=\"hljs-built_in\">any</span></span>) =&gt;</span> {\n    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">typeof</span> anything === <span class=\"hljs-string\">'string'</span>) {\n      <span class=\"hljs-keyword\">return</span> anything; <span class=\"hljs-comment\">// 类型是 string&nbsp;</span>\n    } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">typeof</span> anything === <span class=\"hljs-string\">'number'</span>) {\n      <span class=\"hljs-keyword\">return</span> anything; <span class=\"hljs-comment\">// 类型是 number</span>\n    }\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">null</span>;\n  };\n}\n</code></pre>\n<p data-nodeid=\"1224\">在 VS Code 中 hover 到第 4 行的 anything 变量提示类型是 string，到第 6 行则提示类型是 number。</p>\n<p data-nodeid=\"1225\">同样，我们可以使用类型守卫将联合类型（详见 08 讲 内容）缩小到明确的子类型，具体示例如下：</p>\n<pre class=\"lang-typescript\" data-nodeid=\"1226\"><code data-language=\"typescript\">{\n  <span class=\"hljs-keyword\">let</span> func = <span class=\"hljs-function\">(<span class=\"hljs-params\">anything: <span class=\"hljs-built_in\">string</span> | <span class=\"hljs-built_in\">number</span></span>) =&gt;</span> {\n    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">typeof</span> anything === <span class=\"hljs-string\">'string'</span>) {\n      <span class=\"hljs-keyword\">return</span> anything; <span class=\"hljs-comment\">// 类型是 string </span>\n    } <span class=\"hljs-keyword\">else</span> {\n      <span class=\"hljs-keyword\">return</span> anything; <span class=\"hljs-comment\">// 类型是 number</span>\n    }\n  };\n}\n</code></pre>\n<p data-nodeid=\"1227\">当然，我们也可以通过字面量类型等值判断（===）或其他控制流语句（包括但不限于 if、三目运算符、switch 分支）将联合类型收敛为更具体的类型，如下代码所示：</p>\n<pre class=\"lang-typescript\" data-nodeid=\"1228\"><code data-language=\"typescript\">{\n  <span class=\"hljs-keyword\">type</span> Goods = <span class=\"hljs-string\">'pen'</span> | <span class=\"hljs-string\">'pencil'</span> |<span class=\"hljs-string\">'ruler'</span>;\n  <span class=\"hljs-keyword\">const</span> getPenCost = <span class=\"hljs-function\">(<span class=\"hljs-params\">item: 'pen'</span>) =&gt;</span> <span class=\"hljs-number\">2</span>;\n  <span class=\"hljs-keyword\">const</span> getPencilCost = <span class=\"hljs-function\">(<span class=\"hljs-params\">item: 'pencil'</span>) =&gt;</span> <span class=\"hljs-number\">4</span>;\n  <span class=\"hljs-keyword\">const</span> getRulerCost = <span class=\"hljs-function\">(<span class=\"hljs-params\">item: 'ruler'</span>) =&gt;</span> <span class=\"hljs-number\">6</span>;\n  <span class=\"hljs-keyword\">const</span> getCost = <span class=\"hljs-function\">(<span class=\"hljs-params\">item: Goods</span>) =&gt;</span>  {\n    <span class=\"hljs-keyword\">if</span> (item === <span class=\"hljs-string\">'pen'</span>) {\n      <span class=\"hljs-keyword\">return</span> getPenCost(item); <span class=\"hljs-comment\">// item =&gt; 'pen'</span>\n    } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (item === <span class=\"hljs-string\">'pencil'</span>) {\n      <span class=\"hljs-keyword\">return</span> getPencilCost(item); <span class=\"hljs-comment\">// item =&gt; 'pencil'</span>\n    } <span class=\"hljs-keyword\">else</span> {\n      <span class=\"hljs-keyword\">return</span> getRulerCost(item); <span class=\"hljs-comment\">// item =&gt; 'ruler'</span>\n    }\n  }\n}\n</code></pre>\n<p data-nodeid=\"1229\">在上述 getCost 函数中，接受的参数类型是字面量类型的联合类型，函数内包含了 if 语句的 3 个流程分支，其中每个流程分支调用的函数的参数都是具体独立的字面量类型。</p>\n<p data-nodeid=\"1230\">那为什么类型由多个字面量组成的变量 item 可以传值给仅接收单一特定字面量类型的函数 getPenCost、getPencilCost、getRulerCost 呢？这是因为在每个流程分支中，编译器知道流程分支中的 item 类型是什么。比如 item === 'pencil' 的分支，item 的类型就被收缩为“pencil”。</p>\n<p data-nodeid=\"1231\">事实上，如果我们将上面的示例去掉中间的流程分支，编译器也可以推断出收敛后的类型，如下代码所示：</p>\n<pre class=\"lang-typescript\" data-nodeid=\"1232\"><code data-language=\"typescript\">  <span class=\"hljs-keyword\">const</span> getCost = <span class=\"hljs-function\">(<span class=\"hljs-params\">item: Goods</span>) =&gt;</span>  {\n    <span class=\"hljs-keyword\">if</span> (item === <span class=\"hljs-string\">'pen'</span>) {\n      item; <span class=\"hljs-comment\">// item =&gt; 'pen'</span>\n    } <span class=\"hljs-keyword\">else</span> {\n      item; <span class=\"hljs-comment\">// =&gt; 'pencil' | 'ruler'</span>\n    }\n  }\n</code></pre>\n<h3 data-nodeid=\"1233\">小结与预告</h3>\n<p data-nodeid=\"1234\">这一讲中包含了类型推断、字面量类型、类型拓宽、类型缩小等知识，涉及的都是比较简单的字面量、赋值、函数的编程场景，而这些知识同样适用于 06 讲中更复杂的类型和结构，只不过你需要多花时间学习、理解并掌握。</p>\n<p data-nodeid=\"1235\">这里给你预留了一道思考题：涉及字面量的类型推断都有什么规则？欢迎你在留言区与我互动、交流。</p>\n<p data-nodeid=\"1236\" class=\"\">另外，如果你觉得本专栏有价值，欢迎分享给更多好友哦~</p>",
                "article_title": "04 | 什么是字面量类型、类型推断、类型拓宽和类型缩小？",
                "title": "04 | 什么是字面量类型、类型推断、类型拓宽和类型缩小？",
                "id": 7436
            },
            {
                "content": "<p data-nodeid=\"36887\">04 讲我们简单介绍了函数定义时的相关类型推断特性，这一讲将深入介绍一下函数类型。</p>\n<blockquote data-nodeid=\"36888\">\n<p data-nodeid=\"36889\">学习建议：使用 VS Code 新建一个 05.ts 文件，尝试这一讲中所有示例。</p>\n</blockquote>\n<p data-nodeid=\"36890\">在 JavaScript 中，函数是构建应用的一块基石，我们可以使用函数抽离可复用的逻辑、抽象模型、封装过程。在 TypeScript 中，虽然有类、命名空间、模块，但是函数同样是最基本、最重要的元素之一。</p>\n<p data-nodeid=\"36891\">在 TypeScript 里，我们可以通过 function 字面量和箭头函数的形式定义函数，示例如下：</p>\n<pre class=\"lang-typescript\" data-nodeid=\"36892\"><code data-language=\"typescript\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">add</span>(<span class=\"hljs-params\"></span>) </span>{}\n<span class=\"hljs-keyword\">const</span> add = <span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> {}\n</code></pre>\n<p data-nodeid=\"36893\">我们还可以显式指定函数参数和返回值的类型，示例如下。</p>\n<pre class=\"lang-typescript\" data-nodeid=\"36894\"><code data-language=\"typescript\"><span class=\"hljs-keyword\">const</span> add = (a: <span class=\"hljs-built_in\">number</span>, b: <span class=\"hljs-built_in\">number</span>): <span class=\"hljs-function\"><span class=\"hljs-params\">number</span> =&gt;</span> {\n     <span class=\"hljs-keyword\">return</span> a + b;\n}\n</code></pre>\n<p data-nodeid=\"36895\">如上述示例中，参数名后的 ':number' 表示参数类型都是数字类型，圆括号后的 ': number' 则表示返回值类型也是数字类型。下面我们具体介绍一下返回值类型和参数类型。</p>\n<h3 data-nodeid=\"36896\">返回值类型</h3>\n<p data-nodeid=\"36897\">在 JavaScript 中，我们知道一个函数可以没有显式 return，此时函数的返回值应该是 undefined：</p>\n<pre class=\"lang-typescript\" data-nodeid=\"36898\"><code data-language=\"typescript\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">fn</span>(<span class=\"hljs-params\"></span>) </span>{\n  <span class=\"hljs-comment\">// TODO</span>\n}\n<span class=\"hljs-built_in\">console</span>.log(fn()); <span class=\"hljs-comment\">// =&gt; undefined</span>\n</code></pre>\n<p data-nodeid=\"36899\"><strong data-nodeid=\"37018\">需要注意的是，在 TypeScript 中，如果我们显式声明函数的返回值类型为 undfined，将会得到如下所示的错误提醒。</strong></p>\n<pre class=\"lang-typescript\" data-nodeid=\"36900\"><code data-language=\"typescript\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">fn</span>(<span class=\"hljs-params\"></span>): <span class=\"hljs-title\">undefined</span> </span>{ <span class=\"hljs-comment\">// ts(2355) A function whose declared type is neither 'void' nor 'any' must return a value</span>\n  <span class=\"hljs-comment\">// TODO</span>\n}\n</code></pre>\n<p data-nodeid=\"36901\">此时，正确的做法是使用 03 讲介绍的 void 类型来表示函数没有返回值的类型（这是“废柴” void 类型唯一有用的场景），示例如下：</p>\n<pre class=\"lang-typescript\" data-nodeid=\"36902\"><code data-language=\"typescript\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">fn1</span>(<span class=\"hljs-params\"></span>): <span class=\"hljs-title\">void</span> </span>{\n}\nfn1().doSomething(); <span class=\"hljs-comment\">// ts(2339) Property 'doSomething' does not exist on type 'void'.</span>\n</code></pre>\n<p data-nodeid=\"36903\">我们可以使用类似定义箭头函数的语法来表示函数类型的参数和返回值类型，此时<code data-backticks=\"1\" data-nodeid=\"37021\">=&gt; 类型</code>仅仅用来定义一个函数类型而不用实现这个函数。</p>\n<p data-nodeid=\"36904\"><strong data-nodeid=\"37040\">需要注意的是，这里的</strong><code data-backticks=\"1\" data-nodeid=\"37026\">=&gt;</code><strong data-nodeid=\"37041\">与 ES6 中箭头函数的</strong><code data-backticks=\"1\" data-nodeid=\"37030\">=&gt;</code><strong data-nodeid=\"37042\">有所不同。TypeScript 函数类型中的</strong><code data-backticks=\"1\" data-nodeid=\"37034\">=&gt;</code><strong data-nodeid=\"37043\">用来表示函数的定义，其左侧是函数的参数类型，右侧是函数的返回值类型；而 ES6 中的</strong><code data-backticks=\"1\" data-nodeid=\"37038\">=&gt;</code>是函数的实现。</p>\n<p data-nodeid=\"36905\">如下示例中，我们定义了一个函数类型（这里我们使用了类型别名 type，详见 07 讲），并且使用箭头函数实现了这个类型。</p>\n<pre class=\"lang-typescript\" data-nodeid=\"36906\"><code data-language=\"typescript\"><span class=\"hljs-keyword\">type</span> Adder = <span class=\"hljs-function\">(<span class=\"hljs-params\">a: <span class=\"hljs-built_in\">number</span>, b: <span class=\"hljs-built_in\">number</span></span>) =&gt;</span> <span class=\"hljs-built_in\">number</span>; <span class=\"hljs-comment\">// TypeScript 函数类型定义</span>\n<span class=\"hljs-keyword\">const</span> add: Adder = <span class=\"hljs-function\">(<span class=\"hljs-params\">a, b</span>) =&gt;</span> a + b; <span class=\"hljs-comment\">// ES6 箭头函数</span>\n</code></pre>\n<p data-nodeid=\"36907\"><strong data-nodeid=\"37048\">这里请注意：右侧的箭头函数并没有显式声明类型注解，不过可以根据 04 讲中提到的上下文类型进行推断。</strong></p>\n<p data-nodeid=\"36908\">在对象（即接口类型，详见 07 讲）中，除了使用这种声明语法，我们还可以使用类似对象属性的简写语法来声明函数类型的属性，如下代码所示：</p>\n<pre class=\"lang-typescript\" data-nodeid=\"36909\"><code data-language=\"typescript\"><span class=\"hljs-keyword\">interface</span> Entity {\n    add: <span class=\"hljs-function\">(<span class=\"hljs-params\">a: <span class=\"hljs-built_in\">number</span>, b: <span class=\"hljs-built_in\">number</span></span>)&nbsp;=&gt;</span> <span class=\"hljs-built_in\">number</span>;\n    del(a: <span class=\"hljs-built_in\">number</span>, b: <span class=\"hljs-built_in\">number</span>): <span class=\"hljs-built_in\">number</span>;\n}\n<span class=\"hljs-keyword\">const</span> entity: Entity = {\n    add: <span class=\"hljs-function\">(<span class=\"hljs-params\">a, b</span>) =&gt;</span> a + b,\n    del(a, b) {\n      <span class=\"hljs-keyword\">return</span> a - b;\n    },\n};\n</code></pre>\n<p data-nodeid=\"36910\">在某种意义上来说，这两种形式都是等价的。但是很多时候，我们不必或者不能显式地指明返回值的类型，这就涉及可缺省和可推断的返回值类型的讲解。</p>\n<h4 data-nodeid=\"36911\">可缺省和可推断的返回值类型</h4>\n<p data-nodeid=\"36912\">幸运的是，函数返回值的类型可以在 TypeScript 中被推断出来，即可缺省。</p>\n<p data-nodeid=\"36913\">函数内是一个相对独立的上下文环境，我们可以根据入参对值加工计算，并返回新的值。从类型层面看，我们也可以通过类型推断（回想一下 04 讲中的类型推断、上下文类型推断）加工计算入参的类型，并返回新的类型，示例如下：</p>\n<pre class=\"lang-typescript\" data-nodeid=\"36914\"><code data-language=\"typescript\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">computeTypes</span>(<span class=\"hljs-params\">one: <span class=\"hljs-built_in\">string</span>, two: <span class=\"hljs-built_in\">number</span></span>) </span>{\n  <span class=\"hljs-keyword\">const</span> nums = [two];\n  <span class=\"hljs-keyword\">const</span> strs = [one]\n  <span class=\"hljs-keyword\">return</span> {\n    nums,\n    strs\n  } <span class=\"hljs-comment\">// 返回 { nums: number[]; strs: string[] } 的类型 </span>\n}\n</code></pre>\n<p data-nodeid=\"36915\"><strong data-nodeid=\"37057\">请记住：这是一个很重要也很有意思的特性，函数返回值的类型推断结合泛型（我们会在 10 讲中详细介绍）可以实现特别复杂的类型计算（本质是复杂的类型推断，这里称之为计算是为了表明其复杂性），比如 Redux Model 中 State、Reducer、Effect 类型的关联。</strong></p>\n<p data-nodeid=\"36916\">一般情况下，TypeScript 中的函数返回值类型是可以缺省和推断出来的，但是有些特例需要我们显式声明返回值类型，比如 Generator 函数的返回值。</p>\n<h4 data-nodeid=\"36917\">Generator 函数的返回值</h4>\n<p data-nodeid=\"36918\">ES6 中新增的 Generator 函数在 TypeScript 中也有对应的类型定义。</p>\n<p data-nodeid=\"36919\">Generator 函数返回的是一个 Iterator 迭代器对象，我们可以使用 Generator  的同名接口泛型或者 Iterator 的同名接口泛型（在 10 讲会介绍）表示返回值的类型（Generator 类型继承了 Iterator 类型），示例如下：</p>\n<pre class=\"lang-typescript\" data-nodeid=\"36920\"><code data-language=\"typescript\"><span class=\"hljs-keyword\">type</span>&nbsp;AnyType&nbsp;=&nbsp;<span class=\"hljs-built_in\">boolean</span>;\n<span class=\"hljs-keyword\">type</span>&nbsp;AnyReturnType&nbsp;=&nbsp;<span class=\"hljs-built_in\">string</span>;\n<span class=\"hljs-keyword\">type</span>&nbsp;AnyNextType&nbsp;=&nbsp;<span class=\"hljs-built_in\">number</span>;\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>&nbsp;*<span class=\"hljs-title\">gen</span>(<span class=\"hljs-params\"></span>):&nbsp;<span class=\"hljs-title\">Generator</span>&lt;<span class=\"hljs-title\">AnyType</span>, <span class=\"hljs-title\">AnyReturnType</span>, <span class=\"hljs-title\">AnyNextType</span>&gt; </span>{\n  <span class=\"hljs-keyword\">const</span> nextValue = <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-literal\">true</span>; <span class=\"hljs-comment\">// nextValue 类型是 number，yield 后必须是 boolean 类型</span>\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">`<span class=\"hljs-subst\">${nextValue}</span>`</span>; <span class=\"hljs-comment\">// 必须返回 string 类型</span>\n}\n</code></pre>\n<p data-nodeid=\"36921\"><strong data-nodeid=\"37065\">注意：TypeScript 3.6 之前的版本不支持指定 next、return  的类型，所以在某些有点历史的代码中，我们可能会看到 Generator 和 Iterator 类型不一样的表述。</strong></p>\n<h3 data-nodeid=\"36922\">参数类型</h3>\n<p data-nodeid=\"36923\">了解了定义函数的基本语法以及返回值类型后，我们再来详细看一下可选参数、默认参数、剩余参数的几个特性。</p>\n<h4 data-nodeid=\"36924\">可选参数和默认参数</h4>\n<p data-nodeid=\"36925\">在实际工作中，我们可能经常碰到函数参数可传可不传的情况，当然 TypeScript 也支持这种函数类型表达，如下代码所示：</p>\n<pre class=\"lang-typescript\" data-nodeid=\"36926\"><code data-language=\"typescript\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">log</span>(<span class=\"hljs-params\">x?: <span class=\"hljs-built_in\">string</span></span>) </span>{\n  <span class=\"hljs-keyword\">return</span> x;\n}\nlog(); <span class=\"hljs-comment\">// =&gt; undefined</span>\nlog(<span class=\"hljs-string\">'hello world'</span>); <span class=\"hljs-comment\">// =&gt; hello world</span>\n</code></pre>\n<p data-nodeid=\"36927\">在上述代码中，我们在类型标注的<code data-backticks=\"1\" data-nodeid=\"37071\">:</code>前添加<code data-backticks=\"1\" data-nodeid=\"37073\">?</code>表示 log 函数的参数 x 就是可缺省的。</p>\n<p data-nodeid=\"36928\">也就是说参数 x 的类型可能是 undefined（第 5 行调用 log 时不传入实参）类型或者是 string 类型（第 6 行调用 log 传入 'hello world' 实参），那是不是意味着可缺省和类型是 undefined 等价呢？我们来看看以下的示例：</p>\n<pre class=\"lang-typescript\" data-nodeid=\"36929\"><code data-language=\"typescript\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">log</span>(<span class=\"hljs-params\">x?: <span class=\"hljs-built_in\">string</span></span>) </span>{\n  <span class=\"hljs-built_in\">console</span>.log(x);\n}\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">log1</span>(<span class=\"hljs-params\">x: <span class=\"hljs-built_in\">string</span> | <span class=\"hljs-literal\">undefined</span></span>) </span>{\n  <span class=\"hljs-built_in\">console</span>.log(x);\n}\nlog();\nlog(<span class=\"hljs-literal\">undefined</span>);\nlog1(); <span class=\"hljs-comment\">// ts(2554) Expected 1 arguments, but got 0</span>\nlog1(<span class=\"hljs-literal\">undefined</span>);\n</code></pre>\n<p data-nodeid=\"36930\"><strong data-nodeid=\"37083\">答案显而易见：这里的 ?: 表示参数可以缺省、可以不传，也就是说调用函数时，我们可以不显式传入参数。但是，如果我们声明了参数类型为 xxx | undefined（这里使用了联合类型 |，详见 08 讲），就表示函数参数是不可缺省且类型必须是 xxx 或者 undfined。</strong></p>\n<p data-nodeid=\"36931\">因此，在上述代码中，log1 函数如果不显示传入函数的参数，TypeScript 就会报一个 ts(2554) 的错误，即函数需要 1 个参数，但是我们只传入了 0 个参数。</p>\n<p data-nodeid=\"36932\">在 ES6 中支持函数默认参数的功能，而 TypeScript 会根据函数的默认参数的类型来推断函数参数的类型，示例如下：</p>\n<pre class=\"lang-typescript\" data-nodeid=\"36933\"><code data-language=\"typescript\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">log</span>(<span class=\"hljs-params\">x = 'hello'</span>) </span>{\n    <span class=\"hljs-built_in\">console</span>.log(x);\n}\nlog(); <span class=\"hljs-comment\">// =&gt; 'hello'</span>\nlog(<span class=\"hljs-string\">'hi'</span>); <span class=\"hljs-comment\">// =&gt; 'hi'</span>\nlog(<span class=\"hljs-number\">1</span>); <span class=\"hljs-comment\">// ts(2345) Argument of type '1' is not assignable to parameter of type 'string | undefined'</span>\n</code></pre>\n<p data-nodeid=\"36934\">在上述示例中，根据函数的默认参数 'hello' ，TypeScript 推断出了 x 的类型为 string | undefined。</p>\n<p data-nodeid=\"36935\">当然，对于默认参数，TypeScript 也可以显式声明参数的类型（一般默认参数的类型是参数类型的子集时，我们才需要这么做）。不过，此时的默认参数只起到参数默认值的作用，如下代码所示：</p>\n<pre class=\"lang-typescript\" data-nodeid=\"36936\"><code data-language=\"typescript\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">log1</span>(<span class=\"hljs-params\">x: <span class=\"hljs-built_in\">string</span> = 'hello'</span>) </span>{\n    <span class=\"hljs-built_in\">console</span>.log(x);\n}\n<span class=\"hljs-comment\">// ts(2322) Type 'string' is not assignable to type 'number'</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">log2</span>(<span class=\"hljs-params\">x: <span class=\"hljs-built_in\">number</span> = 'hello'</span>) </span>{\n    <span class=\"hljs-built_in\">console</span>.log(x);\n}\nlog2();\nlog2(<span class=\"hljs-number\">1</span>);\nlog2(<span class=\"hljs-string\">'1'</span>); <span class=\"hljs-comment\">// ts(2345) Argument of type '\"1\"' is not assignable to parameter of type 'number | undefined'</span>\n</code></pre>\n<p data-nodeid=\"36937\">上例函数 log2 中，我们显式声明了函数参数 x 的类型为 number，表示函数参数 x 的类型可以不传或者是 number 类型。因此，如果我们将默认值设置为字符串类型，编译器就会抛出一个 ts(2322) 的错误。</p>\n<p data-nodeid=\"36938\">同理，如果我们将函数的参数传入了字符串类型，编译器也会抛出一个 ts(2345) 的错误。</p>\n<p data-nodeid=\"36939\"><strong data-nodeid=\"37098\">这里请注意：函数的默认参数类型必须是参数类型的子类型</strong>，下面我们看一下如下具体示例：</p>\n<pre class=\"lang-typescript\" data-nodeid=\"36940\"><code data-language=\"typescript\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">log3</span>(<span class=\"hljs-params\">x: <span class=\"hljs-built_in\">number</span> | <span class=\"hljs-built_in\">string</span> = 'hello'</span>) </span>{\n    <span class=\"hljs-built_in\">console</span>.log(x);\n}\n</code></pre>\n<p data-nodeid=\"36941\">在上述代码中，函数 log3 的函数参数 x 的类型为可选的联合类型 number | string，但是因为默认参数字符串类型是联合类型 number | string 的子类型，所以 TypeScript 也会检查通过。</p>\n<h4 data-nodeid=\"36942\">剩余参数</h4>\n<p data-nodeid=\"36943\">在 ES6 中，JavaScript 支持函数参数的剩余参数，它可以把多个参数收集到一个变量中。同样，在TypeScript 中也支持这样的参数类型定义，如下代码所示：</p>\n<pre class=\"lang-typescript\" data-nodeid=\"36944\"><code data-language=\"typescript\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">sum</span>(<span class=\"hljs-params\">...nums: <span class=\"hljs-built_in\">number</span>[]</span>) </span>{\n    <span class=\"hljs-keyword\">return</span> nums.reduce(<span class=\"hljs-function\">(<span class=\"hljs-params\">a, b</span>) =&gt;</span> a + b, <span class=\"hljs-number\">0</span>);\n}\nsum(<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>); <span class=\"hljs-comment\">// =&gt; 3</span>\nsum(<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>); <span class=\"hljs-comment\">// =&gt; 6</span>\nsum(<span class=\"hljs-number\">1</span>, <span class=\"hljs-string\">'2'</span>); <span class=\"hljs-comment\">// ts(2345) Argument of type 'string' is not assignable to parameter of type 'number'</span>\n</code></pre>\n<p data-nodeid=\"36945\">在上述代码中，sum 是一个求和的函数，<code data-backticks=\"1\" data-nodeid=\"37103\">...nums</code>将函数的所有参数收集到了变量 nums 中，而 nums 的类型应该是 number[]，表示所有被求和的参数是数字类型。因此，sum(1, '2') 抛出了一个 ts(2345) 的错误，因为参数 '2' 并不是 number 类型。</p>\n<p data-nodeid=\"36946\">如果我们将函数参数 nums 聚合的类型定义为 (number | string)[]，如下代码所示：</p>\n<pre class=\"lang-typescript\" data-nodeid=\"36947\"><code data-language=\"typescript\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">sum</span>(<span class=\"hljs-params\">...nums: (<span class=\"hljs-built_in\">number</span> | <span class=\"hljs-built_in\">string</span>)[]</span>): <span class=\"hljs-title\">number</span> </span>{\n    <span class=\"hljs-keyword\">return</span> nums.reduce&lt;<span class=\"hljs-built_in\">number</span>&gt;<span class=\"hljs-function\">(<span class=\"hljs-params\">(<span class=\"hljs-params\">a, b</span>) =&gt; a + <span class=\"hljs-built_in\">Number</span>(<span class=\"hljs-params\">b</span>), 0</span>);\n}\n<span class=\"hljs-params\">sum</span>(<span class=\"hljs-params\">1, '2', 3</span>); // 6\n</span></code></pre>\n<p data-nodeid=\"36948\">那么，函数的每一个参数的类型就是联合类型 number | string，因此 sum(1, '2', 3) 的类型检查也就通过了。</p>\n<p data-nodeid=\"36949\">介绍完函数的参数，我们再来了解一下函数中另外一个重要的知识点 this。</p>\n<h3 data-nodeid=\"40239\" class=\"\">this</h3>\n\n\n\n\n<p data-nodeid=\"36951\">众所周知，在 JavaScript 中，函数 this 的指向一直是一个令人头痛的问题。因为 this 的值需要等到函数被调用时才能被确定，更别说通过一些方法还可以改变 this 的指向。也就是说 this 的类型不固定，它取决于执行时的上下文。</p>\n<p data-nodeid=\"36952\">但是，使用了 TypeScript 后，我们就不用担心这个问题了。通过指定 this 的类型（严格模式下，必须显式指定 this 的类型），当我们错误使用了 this，TypeScript 就会提示我们，如下代码所示：</p>\n<pre class=\"lang-typescript\" data-nodeid=\"36953\"><code data-language=\"typescript\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">say</span>(<span class=\"hljs-params\"></span>) </span>{\n    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-keyword\">this</span>.name); <span class=\"hljs-comment\">// ts(2683) 'this' implicitly has type 'any' because it does not have a type annotation</span>\n}\nsay();\n</code></pre>\n<p data-nodeid=\"36954\">在上述代码中，如果我们直接调用 say 函数，this 应该指向全局 window 或 global（Node 中）。但是，在 strict 模式下的 TypeScript 中，它会提示 this 的类型是 any，此时就需要我们手动显式指定类型了。</p>\n<p data-nodeid=\"36955\">那么，在 TypeScript 中，我们应该如何声明 this 的类型呢？</p>\n<p data-nodeid=\"36956\">在 TypeScript 中，我们只需要在函数的第一个参数中声明 this 指代的对象（即函数被调用的方式）即可，比如最简单的作为对象的方法的 this 指向，如下代码所示：</p>\n<pre class=\"lang-typescript\" data-nodeid=\"36957\"><code data-language=\"typescript\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">say</span>(<span class=\"hljs-params\"><span class=\"hljs-keyword\">this</span>: Window, name: <span class=\"hljs-built_in\">string</span></span>) </span>{\n    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-keyword\">this</span>.name);\n}\n<span class=\"hljs-built_in\">window</span>.say = say;\n<span class=\"hljs-built_in\">window</span>.say(<span class=\"hljs-string\">'hi'</span>);\n<span class=\"hljs-keyword\">const</span> obj = {\n    say\n};\nobj.say(<span class=\"hljs-string\">'hi'</span>); <span class=\"hljs-comment\">// ts(2684) The 'this' context of type '{ say: (this: Window, name: string) =&gt; void; }' is not assignable to method's 'this' of type 'Window'.</span>\n</code></pre>\n<p data-nodeid=\"36958\">在上述代码中，我们在 window 对象上增加 say 的属性为函数 say。那么调用<code data-backticks=\"1\" data-nodeid=\"37136\">window.say()</code>时，this 指向即为 window 对象。</p>\n<p data-nodeid=\"36959\">调用<code data-backticks=\"1\" data-nodeid=\"37139\">obj.say()</code>后，此时 TypeScript 检测到 this 的指向不是 window，于是抛出了如下所示的一个 ts(2684) 错误。</p>\n<pre class=\"lang-typescript\" data-nodeid=\"36960\"><code data-language=\"typescript\">say(<span class=\"hljs-string\">'captain'</span>); <span class=\"hljs-comment\">// ts(2684) The 'this' context of type 'void' is not assignable to method's 'this' of type 'Window'</span>\n</code></pre>\n<p data-nodeid=\"36961\"><strong data-nodeid=\"37144\">需要注意的是，如果我们直接调用 say()，this 实际上应该指向全局变量 window，但是因为 TypeScript 无法确定 say 函数被谁调用，所以将 this 的指向默认为 void，也就提示了一个 ts(2684) 错误。</strong></p>\n<p data-nodeid=\"36962\">此时，我们可以通过调用 window.say() 来避免这个错误，这也是一个安全的设计。因为在 JavaScript 的严格模式下，全局作用域函数中 this 的指向是 undefined。</p>\n<p data-nodeid=\"36963\"><strong data-nodeid=\"37149\">同样，定义对象的函数属性时，只要实际调用中 this 的指向与指定的 this 指向不同，TypeScript 就能发现 this 指向的错误，示例代码如下：</strong></p>\n<pre class=\"lang-typescript\" data-nodeid=\"36964\"><code data-language=\"typescript\"><span class=\"hljs-keyword\">interface</span> Person {\n    name: <span class=\"hljs-built_in\">string</span>;\n    say(<span class=\"hljs-keyword\">this</span>: Person): <span class=\"hljs-built_in\">void</span>;\n}\n<span class=\"hljs-keyword\">const</span> person: Person = {\n    name: <span class=\"hljs-string\">'captain'</span>,\n    say() {\n        <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-keyword\">this</span>.name);\n    },\n};\n<span class=\"hljs-keyword\">const</span> fn = person.say;\nfn(); <span class=\"hljs-comment\">// ts(2684) The 'this' context of type 'void' is not assignable to method's 'this' of type 'Person'</span>\n</code></pre>\n<p data-nodeid=\"36965\"><strong data-nodeid=\"37153\">注意：显式注解函数中的 this 类型，它表面上占据了第一个形参的位置，但并不意味着函数真的多了一个参数，因为 TypeScript 转译为 JavaScript 后，“伪形参” this 会被抹掉，这算是 TypeScript 为数不多的特有语法。</strong></p>\n<p data-nodeid=\"36966\">当然，初次接触这个特性时让人费解，这就需要我们把它铭记于心。前边的 say 函数转译为 JavaScript 后，this 就会被抹掉，如下代码所示：</p>\n<pre class=\"lang-typescript\" data-nodeid=\"36967\"><code data-language=\"typescript\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">say</span>(<span class=\"hljs-params\">name</span>) </span>{\n    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-keyword\">this</span>.name);\n}\n</code></pre>\n<p data-nodeid=\"36968\">同样，我们也可以显式限定类（class 类的介绍详见 06 讲）函数属性中的 this 类型，TypeScript 也能检查出错误的使用方式，如下代码所示：</p>\n<pre class=\"lang-typescript\" data-nodeid=\"36969\"><code data-language=\"typescript\"><span class=\"hljs-keyword\">class</span> Component {\n  onClick(<span class=\"hljs-keyword\">this</span>: Component) {}\n}\n<span class=\"hljs-keyword\">const</span> component = <span class=\"hljs-keyword\">new</span> Component();\n<span class=\"hljs-keyword\">interface</span> UI {\n  addClickListener(onClick: <span class=\"hljs-function\">(<span class=\"hljs-params\"><span class=\"hljs-keyword\">this</span>: <span class=\"hljs-built_in\">void</span></span>) =&gt;</span> <span class=\"hljs-built_in\">void</span>): <span class=\"hljs-built_in\">void</span>;\n}\n<span class=\"hljs-keyword\">const</span> ui: UI = {\n  addClickListener() {}\n};\nui.addClickListener(<span class=\"hljs-keyword\">new</span> Component().onClick); <span class=\"hljs-comment\">// ts(2345)</span>\n</code></pre>\n<p data-nodeid=\"36970\">上面示例中，我们定义的 Component 类的 onClick 函数属性（方法）显式指定了 this 类型是 Component，在第 14 行作为入参传递给 ui 的  addClickListener 方法中，它指定的 this 类型是 void，两个 this 类型不匹配，所以抛出了一个 ts(2345) 错误。</p>\n<p data-nodeid=\"36971\">此外，在链式调用风格的库中，使用 this 也可以很方便地表达出其类型，如下代码所示：</p>\n<pre class=\"lang-typescript\" data-nodeid=\"36972\"><code data-language=\"typescript\"><span class=\"hljs-keyword\">class</span> Container {\n  <span class=\"hljs-keyword\">private</span> val: <span class=\"hljs-built_in\">number</span>;\n  <span class=\"hljs-keyword\">constructor</span>(<span class=\"hljs-params\">val: <span class=\"hljs-built_in\">number</span></span>) {\n    <span class=\"hljs-keyword\">this</span>.val = val;\n  }\n  map(cb: <span class=\"hljs-function\">(<span class=\"hljs-params\">x: <span class=\"hljs-built_in\">number</span></span>) =&gt;</span> <span class=\"hljs-built_in\">number</span>): <span class=\"hljs-keyword\">this</span> {\n    <span class=\"hljs-keyword\">this</span>.val = cb(<span class=\"hljs-keyword\">this</span>.val);\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">this</span>;\n  }\n  log(): <span class=\"hljs-keyword\">this</span> {\n    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-keyword\">this</span>.val);\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">this</span>;\n  }\n}\n<span class=\"hljs-keyword\">const</span> instance = <span class=\"hljs-keyword\">new</span> Container(<span class=\"hljs-number\">1</span>)\n  .map(<span class=\"hljs-function\">(<span class=\"hljs-params\">x</span>) =&gt;</span> x + <span class=\"hljs-number\">1</span>)\n  .log() <span class=\"hljs-comment\">// =&gt; 2</span>\n  .map(<span class=\"hljs-function\">(<span class=\"hljs-params\">x</span>) =&gt;</span> x * <span class=\"hljs-number\">3</span>)\n  .log(); <span class=\"hljs-comment\">// =&gt; 6  </span>\n</code></pre>\n<p data-nodeid=\"36973\">因为 Container 类中 map、log 等函数属性（方法）未显式指定 this 类型，默认类型是 Container，所以以上方法在被调用时返回的类型也是 Container，this 指向一直是类的实例，它可以一直无限地被链式调用。</p>\n<p data-nodeid=\"36974\">介绍完函数中 this 的指向和类型后，我们再来了解一下它的另外一个特性函数多态（函数重载）。</p>\n<h3 data-nodeid=\"42652\" class=\"\">函数重载</h3>\n\n\n\n\n<p data-nodeid=\"36976\">JavaScript 是一门动态语言，针对同一个函数，它可以有多种不同类型的参数与返回值，这就是函数的多态。</p>\n<p data-nodeid=\"36977\">而在 TypeScript 中，也可以相应地表达不同类型的参数和返回值的函数，如下代码所示：</p>\n<pre class=\"lang-typescript\" data-nodeid=\"36978\"><code data-language=\"typescript\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">convert</span>(<span class=\"hljs-params\">x: <span class=\"hljs-built_in\">string</span> | <span class=\"hljs-built_in\">number</span> | <span class=\"hljs-literal\">null</span></span>): <span class=\"hljs-title\">string</span> | <span class=\"hljs-title\">number</span> | -1 </span>{\n    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">typeof</span> x === <span class=\"hljs-string\">'string'</span>) {\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">Number</span>(x);\n    }\n    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">typeof</span> x === <span class=\"hljs-string\">'number'</span>) {\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">String</span>(x);\n    }\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">-1</span>;\n}\n<span class=\"hljs-keyword\">const</span> x1 = convert(<span class=\"hljs-string\">'1'</span>); <span class=\"hljs-comment\">// =&gt; string | number</span>\n<span class=\"hljs-keyword\">const</span> x2 = convert(<span class=\"hljs-number\">1</span>); <span class=\"hljs-comment\">// =&gt; string | number</span>\n<span class=\"hljs-keyword\">const</span> x3 = convert(<span class=\"hljs-literal\">null</span>); <span class=\"hljs-comment\">// =&gt; string | number</span>\n</code></pre>\n<p data-nodeid=\"36979\">在上述代码中，我们把 convert 函数的 string 类型的值转换为 number 类型，number 类型转换为 string 类型，而将 null 类型转换为数字 -1。此时， x1、x2、x3 的返回值类型都会被推断成 string | number 。</p>\n<p data-nodeid=\"36980\">那么，有没有一种办法可以更精确地描述参数与返回值类型约束关系的函数类型呢？有，这就是函数重载（Function Overload），如下示例中 1~3 行定义了三种各不相同的函数类型列表，并描述了不同的参数类型对应不同的返回值类型，而从第 4 行开始才是函数的实现。</p>\n<pre class=\"lang-typescript\" data-nodeid=\"36981\"><code data-language=\"typescript\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">convert</span>(<span class=\"hljs-params\">x: <span class=\"hljs-built_in\">string</span></span>): <span class=\"hljs-title\">number</span></span>;\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">convert</span>(<span class=\"hljs-params\">x: <span class=\"hljs-built_in\">number</span></span>): <span class=\"hljs-title\">string</span></span>;\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">convert</span>(<span class=\"hljs-params\">x: <span class=\"hljs-literal\">null</span></span>): -1</span>;\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">convert</span>(<span class=\"hljs-params\">x: <span class=\"hljs-built_in\">string</span> | <span class=\"hljs-built_in\">number</span> | <span class=\"hljs-literal\">null</span></span>): <span class=\"hljs-title\">any</span> </span>{\n    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">typeof</span> x === <span class=\"hljs-string\">'string'</span>) {\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">Number</span>(x);\n    }\n    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">typeof</span> x === <span class=\"hljs-string\">'number'</span>) {\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">String</span>(x);\n    }\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">-1</span>;\n}\n<span class=\"hljs-keyword\">const</span> x1 = convert(<span class=\"hljs-string\">'1'</span>); <span class=\"hljs-comment\">// =&gt; number</span>\n<span class=\"hljs-keyword\">const</span> x2 = convert(<span class=\"hljs-number\">1</span>); <span class=\"hljs-comment\">// =&gt; string</span>\n<span class=\"hljs-keyword\">const</span> x3 = convert(<span class=\"hljs-literal\">null</span>); <span class=\"hljs-comment\">// -1</span>\n</code></pre>\n<blockquote data-nodeid=\"36982\">\n<p data-nodeid=\"36983\">注意：函数重载列表的各个成员（即示例中的 1 ~ 3 行）必须是函数实现（即示例中的第 4 行）的子集，例如 “function convert(x: string): number”是“function convert(x: string | number | null): any”的子集。</p>\n</blockquote>\n<p data-nodeid=\"36984\">在 convert 函数被调用时，TypeScript 会从上到下查找函数重载列表中与入参类型匹配的类型，并优先使用第一个匹配的重载定义。因此，我们需要把最精确的函数重载放到前面。例如我们在第 14 行传入了字符串 '1'，查找到第 1 行即匹配，而第 15 行传入了数字 1，则查找到第 2 行匹配。</p>\n<p data-nodeid=\"43250\" class=\"te-preview-highlight\"><strong data-nodeid=\"43255\">为了方便你理解这部分内容，</strong> 下面我们通过以下一个示例进行具体说明。</p>\n\n<pre class=\"lang-typescript\" data-nodeid=\"36986\"><code data-language=\"typescript\"><span class=\"hljs-keyword\">interface</span> P1 {\n    name: <span class=\"hljs-built_in\">string</span>;\n}\n<span class=\"hljs-keyword\">interface</span> P2 <span class=\"hljs-keyword\">extends</span> P1 {\n    age: <span class=\"hljs-built_in\">number</span>;\n}\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">convert</span>(<span class=\"hljs-params\">x: P1</span>): <span class=\"hljs-title\">number</span></span>;\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">convert</span>(<span class=\"hljs-params\">x: P2</span>): <span class=\"hljs-title\">string</span></span>;\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">convert</span>(<span class=\"hljs-params\">x: P1 | P2</span>): <span class=\"hljs-title\">any</span> </span>{}\n<span class=\"hljs-keyword\">const</span> x1 = convert({ name: <span class=\"hljs-string\">\"\"</span> } <span class=\"hljs-keyword\">as</span> P1); <span class=\"hljs-comment\">// =&gt; number</span>\n<span class=\"hljs-keyword\">const</span> x2 = convert({ name: <span class=\"hljs-string\">\"\"</span>, age: <span class=\"hljs-number\">18</span> } <span class=\"hljs-keyword\">as</span> P2); <span class=\"hljs-comment\">// number</span>\n</code></pre>\n<p data-nodeid=\"36987\">因为 P2 继承自 P1，所以类型为 P2 的参数会和类型为  P1 的参数一样匹配到第一个函数重载，此时 x1、x2 的返回值都是 number。</p>\n<pre class=\"lang-typescript\" data-nodeid=\"36988\"><code data-language=\"typescript\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">convert</span>(<span class=\"hljs-params\">x: P2</span>): <span class=\"hljs-title\">string</span></span>;\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">convert</span>(<span class=\"hljs-params\">x: P1</span>): <span class=\"hljs-title\">number</span></span>;\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">convert</span>(<span class=\"hljs-params\">x: P1 | P2</span>): <span class=\"hljs-title\">any</span> </span>{ }\n<span class=\"hljs-keyword\">const</span> x1 = convert({ name: <span class=\"hljs-string\">''</span> } <span class=\"hljs-keyword\">as</span> P1); <span class=\"hljs-comment\">// =&gt; number</span>\n<span class=\"hljs-keyword\">const</span> x2 = convert({ name: <span class=\"hljs-string\">''</span>, age: <span class=\"hljs-number\">18</span> } <span class=\"hljs-keyword\">as</span> P2); <span class=\"hljs-comment\">// =&gt; string</span>\n</code></pre>\n<p data-nodeid=\"36989\">而我们只需要将函数重载列表的顺序调换一下，类型为 P2 和 P1 的参数就可以分别匹配到正确的函数重载了，例如第 5 行匹配到第 2 行，第 6 行匹配到第 1 行。</p>\n<h3 data-nodeid=\"36990\">类型谓词（is）</h3>\n<p data-nodeid=\"36991\">在 TypeScript 中，函数还支持另外一种特殊的类型描述，如下示例 ：</p>\n<pre class=\"lang-typescript\" data-nodeid=\"36992\"><code data-language=\"typescript\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>&nbsp;<span class=\"hljs-title\">isString</span>(<span class=\"hljs-params\">s</span>):&nbsp;<span class=\"hljs-title\">s</span>&nbsp;<span class=\"hljs-title\">is</span>&nbsp;<span class=\"hljs-title\">string</span>&nbsp;</span>{ <span class=\"hljs-comment\">// 类型谓词</span>\n&nbsp;&nbsp;<span class=\"hljs-keyword\">return</span>&nbsp;<span class=\"hljs-keyword\">typeof</span>&nbsp;s&nbsp;===&nbsp;<span class=\"hljs-string\">'string'</span>;\n}\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>&nbsp;<span class=\"hljs-title\">isNumber</span>(<span class=\"hljs-params\">n:&nbsp;<span class=\"hljs-built_in\">number</span></span>)&nbsp;</span>{\n&nbsp;&nbsp;<span class=\"hljs-keyword\">return</span>&nbsp;<span class=\"hljs-keyword\">typeof</span>&nbsp;n&nbsp;===&nbsp;<span class=\"hljs-string\">'number'</span>;\n}\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>&nbsp;<span class=\"hljs-title\">operator</span>(<span class=\"hljs-params\">x:&nbsp;unknown</span>)&nbsp;</span>{\n&nbsp;&nbsp;<span class=\"hljs-keyword\">if</span>(isString(x))&nbsp;{&nbsp;<span class=\"hljs-comment\">//&nbsp;ok&nbsp;x&nbsp;类型缩小为&nbsp;string</span>\n&nbsp;&nbsp;}\n&nbsp;&nbsp;<span class=\"hljs-keyword\">if</span>&nbsp;(isNumber(x))&nbsp;{&nbsp;<span class=\"hljs-comment\">//&nbsp;ts(2345)&nbsp;unknown&nbsp;不能赋值给&nbsp;number</span>\n&nbsp;&nbsp;}\n}\n</code></pre>\n<p data-nodeid=\"36993\">在上述代码中，在添加返回值类型的地方，我们通过“参数名 + is + 类型”的格式明确表明了参数的类型，进而引起类型缩小，所以类型谓词函数的一个重要的应用场景是实现自定义类型守卫（详见第 11 讲）。</p>\n<h3 data-nodeid=\"36994\">小结与预告</h3>\n<p data-nodeid=\"36995\">函数是 JavaScript 和 TypeScript 中极其重要的基础部分，无论是面向过程，还是面向对象编程，都离不开函数的抽象、封装。静态类型的加持，使得 TypeScript 中的函数相较于 JavaScript 来说，变得更加稳定、精确、安全。</p>\n<p data-nodeid=\"36996\">这里插播一个思考题：如何注解函数中 this 的类型？函数类型重载的匹配顺序是什么？欢迎你在留言区与我互动、交流。另外，如果你觉得本专栏有价值，欢迎分享给更多好友哦~</p>\n<p data-nodeid=\"36997\">06 讲我们将了解 TypeScript 另外一个抽象、封装及面向对象编程的利器——类，敬请期待！</p>",
                "article_title": "05 | 函数类型：返回值类型和参数类型到底如何定义？",
                "title": "05 | 函数类型：返回值类型和参数类型到底如何定义？",
                "id": 7437
            },
            {
                "content": "<p data-nodeid=\"973\" class=\"\">【黑马】2</p>\n<p data-nodeid=\"5638\" class=\"te-preview-highlight\">05 讲我们学习了 TypeScript 中抽象、封装的利器——函数类型，接下来我们将学习另一个集面向对象继承、封装、多态三要素为一体的编程利器，类类型。</p>\n\n\n\n\n\n\n\n\n\n\n<blockquote data-nodeid=\"975\">\n<p data-nodeid=\"976\">学习建议：请使用 VS Code，新建一个 06.ts 文件尝试以下所有示例，以便帮助你更好地理解、吸收知识。</p>\n</blockquote>\n<p data-nodeid=\"977\">在JavaScript（ES5）中仅支持通过函数和原型链继承模拟类的实现（用于抽象业务模型、组织数据结构并创建可重用组件），自 ES6 引入 class 关键字后，它才开始支持使用与<code data-backticks=\"1\" data-nodeid=\"1068\">Java</code>类似的语法定义声明类。</p>\n<p data-nodeid=\"978\">TypeScript 作为 JavaScript 的超集，自然也支持 class 的全部特性，并且还可以对类的属性、方法等进行静态类型检测。</p>\n<h3 data-nodeid=\"979\">类</h3>\n<p data-nodeid=\"980\">在实际业务中，任何实体都可以被抽象为一个使用类表达的类似对象的数据结构，且这个数据结构既包含属性，又包含方法，比如我们在下方抽象了一个狗的类。</p>\n<pre class=\"lang-typescript\" data-nodeid=\"981\"><code data-language=\"typescript\"><span class=\"hljs-keyword\">class</span> Dog {\n &nbsp;name: <span class=\"hljs-built_in\">string</span>;\n &nbsp;<span class=\"hljs-keyword\">constructor</span>(<span class=\"hljs-params\">name: <span class=\"hljs-built_in\">string</span></span>) {\n &nbsp; &nbsp;<span class=\"hljs-keyword\">this</span>.name = name;\n  }\n\n &nbsp;bark() {\n &nbsp; &nbsp;<span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'Woof! Woof!'</span>);\n  }\n}\n\n<span class=\"hljs-keyword\">const</span> dog = <span class=\"hljs-keyword\">new</span> Dog(<span class=\"hljs-string\">'Q'</span>);\ndog.bark(); <span class=\"hljs-comment\">// =&gt; 'Woof! Woof!'</span>\n</code></pre>\n<p data-nodeid=\"982\">首先，我们定义了一个 class Dog ，它拥有 string 类型的 name 属性（见第 2 行）、bark 方法（见第 7 行）和一个构造器函数（见第 3 行）。然后，我们通过 new 关键字创建了一个 Dog 的实例，并把实例赋值给变量 dog（见 12 行）。最后，我们通过实例调用了类中定义的 bark 方法（见 13 行）。</p>\n<p data-nodeid=\"983\">如果使用传统的 JavaScript 代码定义类，我们需要使用函数+原型链的形式进行模拟，如下代码所示：</p>\n<pre class=\"lang-typescript\" data-nodeid=\"984\"><code data-language=\"typescript\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">Dog</span>(<span class=\"hljs-params\">name: <span class=\"hljs-built_in\">string</span></span>) </span>{\n &nbsp;<span class=\"hljs-keyword\">this</span>.name = name; <span class=\"hljs-comment\">// ts(2683) 'this' implicitly has type 'any' because it does not have a type annotation.</span>\n}\nDog.prototype.bark = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>{\n &nbsp;<span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'Woof! Woof!'</span>);\n};\n\n<span class=\"hljs-keyword\">const</span> dog = <span class=\"hljs-keyword\">new</span> Dog(<span class=\"hljs-string\">'Q'</span>); <span class=\"hljs-comment\">// ts(7009) 'new' expression, whose target lacks a construct signature, implicitly has an 'any' type.</span>\ndog.bark(); <span class=\"hljs-comment\">// =&gt; 'Woof! Woof!'</span>\n</code></pre>\n<p data-nodeid=\"985\">在第 1～ 3 行，我们定义了 Dog 类的构造函数，并在构造函数内部定义了 name 属性，再在第 4 行通过 Dog 的原型链添加 bark 方法。</p>\n<p data-nodeid=\"986\">和通过 class 方式定义类相比，这种方式明显麻烦不少，而且还缺少静态类型检测。因此，类是 TypeScript 编程中十分有用且不得不掌握的工具。</p>\n<p data-nodeid=\"987\">下面我们看一下关于类最主要的特性——继承，也是面向对象编程三大要素之一。</p>\n<h3 data-nodeid=\"988\">继承</h3>\n<p data-nodeid=\"989\">在 TypeScript 中，使用 extends 关键字就能很方便地定义类继承的抽象模式，如下代码所示：</p>\n<pre class=\"lang-typescript\" data-nodeid=\"990\"><code data-language=\"typescript\"><span class=\"hljs-keyword\">class</span> Animal {\n &nbsp;<span class=\"hljs-keyword\">type</span> = <span class=\"hljs-string\">'Animal'</span>;\n &nbsp;say(name: <span class=\"hljs-built_in\">string</span>) {\n &nbsp; &nbsp;<span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">`I'm <span class=\"hljs-subst\">${name}</span>!`</span>);\n  }\n}\n\n<span class=\"hljs-keyword\">class</span> Dog <span class=\"hljs-keyword\">extends</span> Animal {\n &nbsp;bark() {\n &nbsp; &nbsp;<span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'Woof! Woof!'</span>);\n  }\n}\n\n<span class=\"hljs-keyword\">const</span> dog = <span class=\"hljs-keyword\">new</span> Dog();\ndog.bark(); <span class=\"hljs-comment\">// =&gt; 'Woof! Woof!'</span>\ndog.say(<span class=\"hljs-string\">'Q'</span>); <span class=\"hljs-comment\">// =&gt; I'm Q!</span>\ndog.type; <span class=\"hljs-comment\">// =&gt; Animal</span>\n</code></pre>\n<p data-nodeid=\"991\">上面的例子展示了类最基本的继承用法。比如第 8 ～12 行定义的<code data-backticks=\"1\" data-nodeid=\"1081\">Dog</code>是派生类，它派生自第 1～6 行定义的<code data-backticks=\"1\" data-nodeid=\"1083\">Animal</code>基类，此时<code data-backticks=\"1\" data-nodeid=\"1085\">Dog</code>实例继承了基类<code data-backticks=\"1\" data-nodeid=\"1087\">Animal</code>的属性和方法。因此，在第 15～17 行我们可以看到，实例 dog 支持 bark、say、type 等属性和方法。</p>\n<blockquote data-nodeid=\"992\">\n<p data-nodeid=\"993\">说明：派生类通常被称作子类，基类也被称作超类（或者父类）。</p>\n</blockquote>\n<p data-nodeid=\"994\">细心的你可能发现了，这里的 Dog 基类与第一个例子中的类相比，少了一个构造函数。<strong data-nodeid=\"1094\">这是因为派生类如果包含一个构造函数，则必须在构造函数中调用 super() 方法，这是 TypeScript 强制执行的一条重要规则。</strong></p>\n<p data-nodeid=\"995\">如下示例，因为第 1～10 行定义的 Dog 类构造函数中没有调用 super 方法，所以提示了一个 ts(2377) 的错误；而第 12～22 行定义的 Dog 类构造函数中添加了 super 方法调用，所以可以通过类型检测。</p>\n<pre class=\"lang-typescript\" data-nodeid=\"996\"><code data-language=\"typescript\"><span class=\"hljs-keyword\">class</span> Dog <span class=\"hljs-keyword\">extends</span> Animal {\n &nbsp;name: <span class=\"hljs-built_in\">string</span>;\n &nbsp;<span class=\"hljs-keyword\">constructor</span>(<span class=\"hljs-params\">name: <span class=\"hljs-built_in\">string</span></span>) { <span class=\"hljs-comment\">// ts(2377) Constructors for derived classes must contain a 'super' call.</span>\n &nbsp; &nbsp;<span class=\"hljs-keyword\">this</span>.name = name;\n  }\n\n &nbsp;bark() {\n &nbsp; &nbsp;<span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'Woof! Woof!'</span>);\n  }\n}\n\n<span class=\"hljs-keyword\">class</span> Dog <span class=\"hljs-keyword\">extends</span> Animal {\n &nbsp;name: <span class=\"hljs-built_in\">string</span>;\n &nbsp;<span class=\"hljs-keyword\">constructor</span>(<span class=\"hljs-params\">name: <span class=\"hljs-built_in\">string</span></span>) {\n &nbsp; &nbsp;<span class=\"hljs-keyword\">super</span>(); <span class=\"hljs-comment\">// 添加 super 方法</span>\n &nbsp; &nbsp;<span class=\"hljs-keyword\">this</span>.name = name;\n  }\n\n &nbsp;bark() {\n &nbsp; &nbsp;<span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'Woof! Woof!'</span>);\n  }\n}\n</code></pre>\n<p data-nodeid=\"997\">有些同学可能会好奇，这里的 super() 是什么作用？其实这里的 super 函数会调用基类的构造函数，如下代码所示：</p>\n<pre class=\"lang-typescript\" data-nodeid=\"998\"><code data-language=\"typescript\"><span class=\"hljs-keyword\">class</span> Animal {\n &nbsp;weight: <span class=\"hljs-built_in\">number</span>;\n &nbsp;<span class=\"hljs-keyword\">type</span> = <span class=\"hljs-string\">'Animal'</span>;\n &nbsp;<span class=\"hljs-keyword\">constructor</span>(<span class=\"hljs-params\">weight: <span class=\"hljs-built_in\">number</span></span>) {\n &nbsp; &nbsp;<span class=\"hljs-keyword\">this</span>.weight = weight;\n  }\n &nbsp;say(name: <span class=\"hljs-built_in\">string</span>) {\n &nbsp; &nbsp;<span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">`I'm <span class=\"hljs-subst\">${name}</span>!`</span>);\n  }\n}\n\n<span class=\"hljs-keyword\">class</span> Dog <span class=\"hljs-keyword\">extends</span> Animal {\n &nbsp;name: <span class=\"hljs-built_in\">string</span>;\n &nbsp;<span class=\"hljs-keyword\">constructor</span>(<span class=\"hljs-params\">name: <span class=\"hljs-built_in\">string</span></span>) {\n &nbsp; &nbsp;<span class=\"hljs-keyword\">super</span>(); <span class=\"hljs-comment\">// ts(2554) Expected 1 arguments, but got 0.</span>\n &nbsp; &nbsp;<span class=\"hljs-keyword\">this</span>.name = name;\n  }\n\n &nbsp;bark() {\n &nbsp; &nbsp;<span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'Woof! Woof!'</span>);\n  }\n}\n</code></pre>\n<p data-nodeid=\"999\">将鼠标放到第 15 行 Dog 类构造函数调用的 super 函数上，我们可以看到一个提示，它的类型是基类 Animal 的构造函数：constructor Animal(weight: number): Animal 。并且因为 Animal 类的构造函数要求必须传入一个数字类型的 weight 参数，而第 15 行实际入参为空，所以提示了一个 ts(2554) 的错误；如果我们显式地给 super 函数传入一个 number 类型的值，比如说 super(20)，则不会再提示错误了。</p>\n<h3 data-nodeid=\"1000\">公共、私有与受保护的修饰符</h3>\n<p data-nodeid=\"1001\">类属性和方法除了可以通过 extends 被继承之外，还可以通过修饰符控制可访问性。</p>\n<p data-nodeid=\"1002\">在 TypeScript 中就支持 3 种访问修饰符，分别是 public、private、protected。</p>\n<ul data-nodeid=\"1003\">\n<li data-nodeid=\"1004\">\n<p data-nodeid=\"1005\">public 修饰的是在任何地方可见、公有的属性或方法；</p>\n</li>\n<li data-nodeid=\"1006\">\n<p data-nodeid=\"1007\">private 修饰的是仅在同一类中可见、私有的属性或方法；</p>\n</li>\n<li data-nodeid=\"1008\">\n<p data-nodeid=\"1009\">protected 修饰的是仅在类自身及子类中可见、受保护的属性或方法。</p>\n</li>\n</ul>\n<p data-nodeid=\"1010\">在之前的代码中，示例类并没有用到可见性修饰符，在缺省情况下，类的属性或方法默认都是 public。如果想让有些属性对外不可见，那么我们可以使用<code data-backticks=\"1\" data-nodeid=\"1105\">private</code>进行设置，如下所示：</p>\n<pre class=\"lang-typescript\" data-nodeid=\"1011\"><code data-language=\"typescript\"><span class=\"hljs-keyword\">class</span> Son {\n &nbsp;<span class=\"hljs-keyword\">public</span> firstName: <span class=\"hljs-built_in\">string</span>;\n &nbsp;<span class=\"hljs-keyword\">private</span> lastName: <span class=\"hljs-built_in\">string</span> = <span class=\"hljs-string\">'Stark'</span>;\n &nbsp;<span class=\"hljs-keyword\">constructor</span>(<span class=\"hljs-params\">firstName: <span class=\"hljs-built_in\">string</span></span>) {\n &nbsp; &nbsp;<span class=\"hljs-keyword\">this</span>.firstName = firstName;\n    <span class=\"hljs-keyword\">this</span>.lastName; <span class=\"hljs-comment\">// ok</span>\n  }\n}\n\n<span class=\"hljs-keyword\">const</span> son = <span class=\"hljs-keyword\">new</span> Son(<span class=\"hljs-string\">'Tony'</span>);\n<span class=\"hljs-built_in\">console</span>.log(son.firstName); <span class=\"hljs-comment\">//  =&gt; \"Tony\"</span>\nson.firstName = <span class=\"hljs-string\">'Jack'</span>;\n<span class=\"hljs-built_in\">console</span>.log(son.firstName); <span class=\"hljs-comment\">//  =&gt; \"Jack\"</span>\n<span class=\"hljs-built_in\">console</span>.log(son.lastName); <span class=\"hljs-comment\">// ts(2341) Property 'lastName' is private and only accessible within class 'Son'.</span>\n</code></pre>\n<p data-nodeid=\"1012\">在上面的例子中我们可以看到，第 3 行 Son 类的 lastName 属性是私有的，只在 Son 类中可见；第 2 行定义的 firstName 属性是公有的，在任何地方都可见。因此，我们既可以通过第 10 行创建的 Son 类的实例 son 获取或设置公共的 firstName 的属性（如第 11 行所示），还可以操作更改 firstName 的值（如第 12 行所示）。</p>\n<p data-nodeid=\"1013\">不过，对于 private 修饰的私有属性，只可以在类的内部可见。比如第 6 行，私有属性 lastName 仅在 Son 类中可见，如果其他地方获取了 lastName ，TypeScript 就会提示一个 ts(2341) 的错误（如第 14 行）。</p>\n<blockquote data-nodeid=\"1014\">\n<p data-nodeid=\"1015\"><strong data-nodeid=\"1113\">注意</strong>：TypeScript 中定义类的私有属性仅仅代表静态类型检测层面的私有。如果我们强制忽略 TypeScript 类型的检查错误，转译且运行 JavaScript 时依旧可以获取到 lastName 属性，这是因为 JavaScript 并不支持真正意义上的私有属性。</p>\n</blockquote>\n<p data-nodeid=\"1016\">目前，JavaScript 类支持 private 修饰符的提案已经到 stage 3 了。相信在不久的将来，私有属性在类型检测和运行阶段都可以被限制为仅在类的内部可见。如果你感兴趣的话，可以在<a href=\"https://github.com/tc39/proposal-private-methods?fileGuid=KLALBzHdpAQfyj7n\" data-nodeid=\"1117\">proposal-private-methods</a>中进行查看。</p>\n<p data-nodeid=\"1017\">接下来我们再看一下受保护的属性和方法，如下代码所示：</p>\n<pre class=\"lang-typescript\" data-nodeid=\"1018\"><code data-language=\"typescript\"><span class=\"hljs-keyword\">class</span> Son {\n &nbsp;<span class=\"hljs-keyword\">public</span> firstName: <span class=\"hljs-built_in\">string</span>;\n &nbsp;<span class=\"hljs-keyword\">protected</span> lastName: <span class=\"hljs-built_in\">string</span> = <span class=\"hljs-string\">'Stark'</span>;\n &nbsp;<span class=\"hljs-keyword\">constructor</span>(<span class=\"hljs-params\">firstName: <span class=\"hljs-built_in\">string</span></span>) {\n &nbsp; &nbsp;<span class=\"hljs-keyword\">this</span>.firstName = firstName;\n    <span class=\"hljs-keyword\">this</span>.lastName; <span class=\"hljs-comment\">// ok</span>\n  }\n}\n\n<span class=\"hljs-keyword\">class</span> GrandSon <span class=\"hljs-keyword\">extends</span> Son {\n &nbsp;<span class=\"hljs-keyword\">constructor</span>(<span class=\"hljs-params\">firstName: <span class=\"hljs-built_in\">string</span></span>) {\n &nbsp; &nbsp;<span class=\"hljs-keyword\">super</span>(firstName);\n  }\n\n &nbsp;<span class=\"hljs-keyword\">public</span> getMyLastName() {\n &nbsp; &nbsp;<span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">this</span>.lastName;\n  }\n}\n\n<span class=\"hljs-keyword\">const</span> grandSon = <span class=\"hljs-keyword\">new</span> GrandSon(<span class=\"hljs-string\">'Tony'</span>);\n<span class=\"hljs-built_in\">console</span>.log(grandSon.getMyLastName()); <span class=\"hljs-comment\">// =&gt; \"Stark\"</span>\ngrandSon.lastName; <span class=\"hljs-comment\">// ts(2445) Property 'lastName' is protected and only accessible within class 'Son' and its subclasses.</span>\n</code></pre>\n<p data-nodeid=\"1019\">在第 3 行，修改 Son 类的 lastName 属性可见修饰符为 protected，表明此属性在 Son 类及其子类中可见。如示例第 6 行和第 16 行所示，我们既可以在父类 Son 的构造器中获取 lastName 属性值，又可以在继承自 Son 的子类 GrandSon 的 getMyLastName 方法获取 lastName 属性的值。</p>\n<blockquote data-nodeid=\"1020\">\n<p data-nodeid=\"1021\"><strong data-nodeid=\"1127\">需要注意</strong>：虽然我们不能通过派生类的实例访问<code data-backticks=\"1\" data-nodeid=\"1125\">protected</code>修饰的属性和方法，但是可以通过派生类的实例方法进行访问。比如示例中的第 21 行，通过实例的 getMyLastName 方法获取受保护的属性 lastName 是 ok 的，而第 22 行通过实例直接获取受保护的属性 lastName 则提示了一个 ts(2445) 的错误。</p>\n</blockquote>\n<h3 data-nodeid=\"1022\">只读修饰符</h3>\n<p data-nodeid=\"1023\">在前面的例子中，Son 类 public 修饰的属性既公开可见，又可以更改值，如果我们不希望类的属性被更改，则可以使用 readonly 只读修饰符声明类的属性，如下代码所示：</p>\n<pre class=\"lang-typescript\" data-nodeid=\"1024\"><code data-language=\"typescript\"><span class=\"hljs-keyword\">class</span> Son {\n  <span class=\"hljs-keyword\">public</span> readonly firstName: <span class=\"hljs-built_in\">string</span>;\n  <span class=\"hljs-keyword\">constructor</span>(<span class=\"hljs-params\">firstName: <span class=\"hljs-built_in\">string</span></span>) {\n    <span class=\"hljs-keyword\">this</span>.firstName = firstName;\n  }\n}\n<span class=\"hljs-keyword\">const</span> son = <span class=\"hljs-keyword\">new</span> Son(<span class=\"hljs-string\">'Tony'</span>);\nson.firstName = <span class=\"hljs-string\">'Jack'</span>; <span class=\"hljs-comment\">// ts(2540) Cannot assign to 'firstName' because it is a read-only property.</span>\n</code></pre>\n<p data-nodeid=\"1025\">在第 2 行，我们给公开可见属性 firstName 指定了只读修饰符，这个时候如果再更改 firstName 属性的值，TypeScript 就会提示一个 ts(2540) 的错误（参见第 9 行）。这是因为只读属性修饰符保证了该属性只能被读取，而不能被修改。</p>\n<blockquote data-nodeid=\"1026\">\n<p data-nodeid=\"1027\">注意：如果只读修饰符和可见性修饰符同时出现，我们需要将只读修饰符写在可见修饰符后面。</p>\n</blockquote>\n<h3 data-nodeid=\"1028\">存取器</h3>\n<p data-nodeid=\"1029\">除了上边提到的修饰符之外，在 TypeScript 中还可以通过<code data-backticks=\"1\" data-nodeid=\"1134\">getter</code>、<code data-backticks=\"1\" data-nodeid=\"1136\">setter</code>截取对类成员的读写访问。</p>\n<p data-nodeid=\"1030\">通过对类属性访问的截取，我们可以实现一些特定的访问控制逻辑。下面我们把之前的示例改造一下，如下代码所示：</p>\n<pre class=\"lang-typescript\" data-nodeid=\"1031\"><code data-language=\"typescript\"><span class=\"hljs-keyword\">class</span> Son {\n  <span class=\"hljs-keyword\">public</span> firstName: <span class=\"hljs-built_in\">string</span>;\n  <span class=\"hljs-keyword\">protected</span> lastName: <span class=\"hljs-built_in\">string</span> = <span class=\"hljs-string\">'Stark'</span>;\n  <span class=\"hljs-keyword\">constructor</span>(<span class=\"hljs-params\">firstName: <span class=\"hljs-built_in\">string</span></span>) {\n    <span class=\"hljs-keyword\">this</span>.firstName = firstName;\n  }\n}\n<span class=\"hljs-keyword\">class</span> GrandSon <span class=\"hljs-keyword\">extends</span> Son {\n  <span class=\"hljs-keyword\">constructor</span>(<span class=\"hljs-params\">firstName: <span class=\"hljs-built_in\">string</span></span>) {\n    <span class=\"hljs-keyword\">super</span>(firstName);\n  }\n  <span class=\"hljs-keyword\">get</span> myLastName() {\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">this</span>.lastName;\n  }\n  <span class=\"hljs-keyword\">set</span> myLastName(name: <span class=\"hljs-built_in\">string</span>) {\n    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">this</span>.firstName === <span class=\"hljs-string\">'Tony'</span>) {\n      <span class=\"hljs-keyword\">this</span>.lastName = name;\n    } <span class=\"hljs-keyword\">else</span> {\n      <span class=\"hljs-built_in\">console</span>.error(<span class=\"hljs-string\">'Unable to change myLastName'</span>);\n    }\n  }\n}\n<span class=\"hljs-keyword\">const</span> grandSon = <span class=\"hljs-keyword\">new</span> GrandSon(<span class=\"hljs-string\">'Tony'</span>);\n<span class=\"hljs-built_in\">console</span>.log(grandSon.myLastName); <span class=\"hljs-comment\">// =&gt; \"Stark\"</span>\ngrandSon.myLastName = <span class=\"hljs-string\">'Rogers'</span>;\n<span class=\"hljs-built_in\">console</span>.log(grandSon.myLastName); <span class=\"hljs-comment\">// =&gt; \"Rogers\"</span>\n<span class=\"hljs-keyword\">const</span> grandSon1 = <span class=\"hljs-keyword\">new</span> GrandSon(<span class=\"hljs-string\">'Tony1'</span>);\ngrandSon1.myLastName = <span class=\"hljs-string\">'Rogers'</span>; <span class=\"hljs-comment\">// =&gt; \"Unable to change myLastName\"</span>\n</code></pre>\n<p data-nodeid=\"1032\">在第 14～24 行，我们使用 myLastName 的<code data-backticks=\"1\" data-nodeid=\"1140\">getter</code>、<code data-backticks=\"1\" data-nodeid=\"1142\">setter</code>重写了之前的 GrandSon 类的方法，在 getter 中实际返回的是 lastName 属性。然后，在 setter 中，我们限定仅当 lastName 属性值为 'Tony' ，才把入参 name 赋值给它，否则打印错误。<br>\n在第 28 行中，我们可以像访问类属性一样访问<code data-backticks=\"1\" data-nodeid=\"1150\">getter</code>，同时也可以像更改属性值一样给<code data-backticks=\"1\" data-nodeid=\"1152\">setter</code>赋值，并执行一些自定义逻辑。</p>\n<p data-nodeid=\"1033\">在第 27 行，因为 grandSon 实例的 lastName 属性被初始化成了 'Tony'，所以在第 29 行我们可以把 'Rogers' 赋值给 setter 。而 grandSon1 实例的 lastName 属性在第 32 行被初始化为 'Tony1'，所以在第 33 行把 'Rogers' 赋值给 setter 时，打印了我们自定义的错误信息。</p>\n<h3 data-nodeid=\"1034\">静态属性</h3>\n<p data-nodeid=\"1035\">以上介绍的关于类的所有属性和方法，只有类在实例化时才会被初始化。实际上，我们也可以给类定义静态属性和方法。</p>\n<p data-nodeid=\"1036\">因为这些属性存在于类这个特殊的对象上，而不是类的实例上，所以我们可以直接通过类访问静态属性，如下代码所示：</p>\n<pre class=\"lang-typescript\" data-nodeid=\"1037\"><code data-language=\"typescript\"><span class=\"hljs-keyword\">class</span> MyArray {\n  <span class=\"hljs-keyword\">static</span> displayName = <span class=\"hljs-string\">'MyArray'</span>;\n  <span class=\"hljs-keyword\">static</span> isArray(obj: unknown) {\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">Object</span>.prototype.toString.call(obj).slice(<span class=\"hljs-number\">8</span>, <span class=\"hljs-number\">-1</span>) === <span class=\"hljs-string\">'Array'</span>;\n  }\n}\n<span class=\"hljs-built_in\">console</span>.log(MyArray.displayName); <span class=\"hljs-comment\">// =&gt; \"MyArray\"</span>\n<span class=\"hljs-built_in\">console</span>.log(MyArray.isArray([])); <span class=\"hljs-comment\">// =&gt; true</span>\n<span class=\"hljs-built_in\">console</span>.log(MyArray.isArray({})); <span class=\"hljs-comment\">// =&gt; false</span>\n</code></pre>\n<p data-nodeid=\"1038\">在第 2～3 行，通过 static 修饰符，我们给 MyArray 类分别定义了一个静态属性 displayName 和静态方法 isArray。之后，我们无须实例化 MyArray 就可以直接访问类上的静态属性和方法了，比如第 8 行访问的是静态属性 displayName，第 9～10 行访问的是静态方法 isArray。</p>\n<p data-nodeid=\"1039\">基于静态属性的特性，我们往往会把与类相关的常量、不依赖实例 this 上下文的属性和方法定义为静态属性，从而避免数据冗余，进而提升运行性能。</p>\n<blockquote data-nodeid=\"1040\">\n<p data-nodeid=\"1041\"><strong data-nodeid=\"1179\">注意：上边我们提到了不依赖实例 this 上下文的方法就可以定义成静态方法，这就意味着需要显式注解 this 类型才可以在静态方法中使用 this；非静态方法则不需要显式注解 this 类型，因为 this 的指向默认是类的实例。</strong></p>\n</blockquote>\n<h3 data-nodeid=\"1042\">抽象类</h3>\n<p data-nodeid=\"1043\">接下来我们看看关于类的另外一个特性——抽象类，它是一种不能被实例化仅能被子类继承的特殊类。</p>\n<p data-nodeid=\"1044\">我们可以使用抽象类定义派生类需要实现的属性和方法，同时也可以定义其他被继承的默认属性和方法，如下代码所示：</p>\n<pre class=\"lang-typescript\" data-nodeid=\"1045\"><code data-language=\"typescript\"><span class=\"hljs-keyword\">abstract</span> <span class=\"hljs-keyword\">class</span> Adder {\n  <span class=\"hljs-keyword\">abstract</span> x: <span class=\"hljs-built_in\">number</span>;\n  <span class=\"hljs-keyword\">abstract</span> y: <span class=\"hljs-built_in\">number</span>;\n  <span class=\"hljs-keyword\">abstract</span> add(): <span class=\"hljs-built_in\">number</span>;\n  displayName = <span class=\"hljs-string\">'Adder'</span>;\n  addTwice(): <span class=\"hljs-built_in\">number</span> {\n    <span class=\"hljs-keyword\">return</span> (<span class=\"hljs-keyword\">this</span>.x + <span class=\"hljs-keyword\">this</span>.y) * <span class=\"hljs-number\">2</span>;\n  }\n}\n<span class=\"hljs-keyword\">class</span> NumAdder <span class=\"hljs-keyword\">extends</span> Adder {\n  x: <span class=\"hljs-built_in\">number</span>;\n  y: <span class=\"hljs-built_in\">number</span>;\n  <span class=\"hljs-keyword\">constructor</span>(<span class=\"hljs-params\">x: <span class=\"hljs-built_in\">number</span>, y: <span class=\"hljs-built_in\">number</span></span>) {\n    <span class=\"hljs-keyword\">super</span>();\n    <span class=\"hljs-keyword\">this</span>.x = x;\n    <span class=\"hljs-keyword\">this</span>.y = y;\n  }\n  add(): <span class=\"hljs-built_in\">number</span> {\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">this</span>.x + <span class=\"hljs-keyword\">this</span>.y;\n  }\n}\n<span class=\"hljs-keyword\">const</span> numAdder = <span class=\"hljs-keyword\">new</span> NumAdder(<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>);\n<span class=\"hljs-built_in\">console</span>.log(numAdder.displayName); <span class=\"hljs-comment\">// =&gt; \"Adder\"</span>\n<span class=\"hljs-built_in\">console</span>.log(numAdder.add()); <span class=\"hljs-comment\">// =&gt; 3</span>\n<span class=\"hljs-built_in\">console</span>.log(numAdder.addTwice()); <span class=\"hljs-comment\">// =&gt; 6</span>\n</code></pre>\n<p data-nodeid=\"1046\">在第 1～10 行，通过 abstract 关键字，我们定义了一个抽象类 Adder，并通过<code data-backticks=\"1\" data-nodeid=\"1184\">abstract</code>关键字定义了抽象属性<code data-backticks=\"1\" data-nodeid=\"1186\">x</code>、<code data-backticks=\"1\" data-nodeid=\"1188\">y</code>及方法<code data-backticks=\"1\" data-nodeid=\"1190\">add</code>，而且任何继承 Adder 的派生类都需要实现这些抽象属性和方法。</p>\n<p data-nodeid=\"1047\">同时，我们还在抽象类 Adder 中定义了可以被派生类继承的非抽象属性<code data-backticks=\"1\" data-nodeid=\"1193\">displayName</code>和方法<code data-backticks=\"1\" data-nodeid=\"1195\">addTwice</code>。</p>\n<p data-nodeid=\"1048\">然后，我们在第 12～23 行定义了继承抽象类的派生类 NumAdder， 并实现了抽象类里定义的 x、y 抽象属性和 add 抽象方法。如果派生类中缺少对 x、y、add 这三者中任意一个抽象成员的实现，那么第 12 行就会提示一个 ts(2515) 错误，关于这点你可以亲自验证一下。</p>\n<p data-nodeid=\"1049\">抽象类中的其他非抽象成员则可以直接通过实例获取，比如第 26～28 行中，通过实例 numAdder，我们获取了 displayName 属性和 addTwice 方法。</p>\n<p data-nodeid=\"1050\">因为抽象类不能被实例化，并且派生类必须实现继承自抽象类上的抽象属性和方法定义，所以抽象类的作用其实就是对基础逻辑的封装和抽象。</p>\n<p data-nodeid=\"1051\">实际上，我们也可以定义一个描述对象结构的接口类型（详见 07 讲）抽象类的结构，并通过 implements 关键字约束类的实现。</p>\n<p data-nodeid=\"1052\">使用接口与使用抽象类相比，区别在于接口只能定义类成员的类型，如下代码所示：</p>\n<pre class=\"lang-typescript\" data-nodeid=\"1053\"><code data-language=\"typescript\"><span class=\"hljs-keyword\">interface</span> IAdder {\n&nbsp; x: <span class=\"hljs-built_in\">number</span>;\n&nbsp; y: <span class=\"hljs-built_in\">number</span>;\n&nbsp; add: <span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> <span class=\"hljs-built_in\">number</span>;\n}\n<span class=\"hljs-keyword\">class</span> NumAdder <span class=\"hljs-keyword\">implements</span> IAdder {\n&nbsp; x: <span class=\"hljs-built_in\">number</span>;\n&nbsp; y: <span class=\"hljs-built_in\">number</span>;\n&nbsp; <span class=\"hljs-keyword\">constructor</span>(<span class=\"hljs-params\">x: <span class=\"hljs-built_in\">number</span>, y: <span class=\"hljs-built_in\">number</span></span>) {\n&nbsp; &nbsp; <span class=\"hljs-keyword\">this</span>.x = x;\n&nbsp; &nbsp; <span class=\"hljs-keyword\">this</span>.y = y;\n&nbsp; }\n&nbsp; add() {\n&nbsp; &nbsp; <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">this</span>.x + <span class=\"hljs-keyword\">this</span>.y;\n&nbsp; }\n&nbsp; addTwice() {\n&nbsp; &nbsp; <span class=\"hljs-keyword\">return</span> (<span class=\"hljs-keyword\">this</span>.x + <span class=\"hljs-keyword\">this</span>.y) * <span class=\"hljs-number\">2</span>;\n&nbsp; }\n}\n</code></pre>\n<p data-nodeid=\"1054\">在第 1～5 行，我们定义了一个包含 x、y、add 属性和方法的接口类型（详见 07 讲），然后在第 6～12 行实现了拥有接口约定的x、y 属性和 add 方法，以及接口未约定的 addTwice 方法的NumAdder类 。</p>\n<h3 data-nodeid=\"1055\">类的类型</h3>\n<p data-nodeid=\"1056\">类的最后一个特性——类的类型和函数类似，即在声明类的时候，其实也同时声明了一个特殊的类型（确切地讲是一个接口类型），这个类型的名字就是类名，表示类实例的类型；在定义类的时候，我们声明的除构造函数外所有属性、方法的类型就是这个特殊类型的成员。如下代码所示：</p>\n<pre class=\"lang-typescript\" data-nodeid=\"1057\"><code data-language=\"typescript\"><span class=\"hljs-keyword\">class</span> A {\n  name: <span class=\"hljs-built_in\">string</span>;\n  <span class=\"hljs-keyword\">constructor</span>(<span class=\"hljs-params\">name: <span class=\"hljs-built_in\">string</span></span>) {\n    <span class=\"hljs-keyword\">this</span>.name = name;\n  }\n}\n<span class=\"hljs-keyword\">const</span> a1: A = {}; <span class=\"hljs-comment\">// ts(2741) Property 'name' is missing in type '{}' but required in type 'A'.</span>\n<span class=\"hljs-keyword\">const</span> a2: A = { name: <span class=\"hljs-string\">'a2'</span> }; <span class=\"hljs-comment\">// ok</span>\n</code></pre>\n<p data-nodeid=\"1058\">在第 1～6 行，我们在定义类 A ，也说明我们同时定义了一个包含字符串属性 name 的同名接口类型 A。因此，在第 7 行把一个空对象赋值给类型是 A 的变量 a1 时，TypeScript 会提示一个 ts(2741) 错误，因为缺少 name 属性。在第 8 行把对象{ name: 'a2' }赋值给类型同样是 A 的变量 a2 时，TypeScript 就直接通过了类型检查，因为有 name 属性。</p>\n<h3 data-nodeid=\"1059\">小结与预告</h3>\n<p data-nodeid=\"1060\">在 TypeScript 中，因为我们需要实践 OOP 编程思想，所以离不开类的支撑。在实际工作中，类与函数一样，都是极其有用的抽象、封装利器。</p>\n<p data-nodeid=\"1061\">这里插播一道思考题：public、private、protected 属性的区别是什么？欢迎你在留言区互动、交流。</p>\n<p data-nodeid=\"1062\">07 讲我们将详细介绍这一讲中重度涉及和依赖的接口类型，敬请期待。</p>\n<p data-nodeid=\"1063\" class=\"\">另外，如果你觉得本专栏有价值，欢迎分享给更多好友哦~</p>",
                "article_title": "06 | 类类型：如何高效使用类型化的面向对象编程利器？",
                "title": "06 | 类类型：如何高效使用类型化的面向对象编程利器？",
                "id": 7438
            },
            {
                "content": "<p data-nodeid=\"26025\">前面我们学习了 TypeScript 的基础类型、函数类型和类类型，它们都有一个共性——在 JavaScript 中都有对应的语法。</p>\n\n\n<p data-nodeid=\"25190\">这一讲我们将学习 TypeScript 与 JavaScript 不一样却堪称精华之一的特性——接口类型与类型别名。这些特性让 TypeScript 具备了 JavaScript 所缺少的、描述较为复杂数据结构的能力。在使用 TypeScript 之前，可能我们只能通过文档或大量的注释来做这件事。</p>\n<blockquote data-nodeid=\"27150\">\n<p data-nodeid=\"27151\"><strong data-nodeid=\"27160\">学习建议</strong>：<br>\n请使用 VS Code 新建一个 07.InterfaceAndType.ts 文件，并尝试课程中的所有示例。</p>\n<p data-nodeid=\"27152\" class=\"\"><strong data-nodeid=\"27165\">注意</strong>：为了避免同一作用域下同名冲突报错，在示例中我们使用了一对花括符 {} 创建块级作用域。</p>\n</blockquote>\n<h3 data-nodeid=\"27153\">Interface 接口类型</h3>\n\n\n\n\n<p data-nodeid=\"25196\">TypeScript 不仅能帮助前端改变思维方式，还能强化面向接口编程的思维和能力，而这正是得益于 Interface 接口类型。通过接口类型，我们可以清晰地定义模块内、跨模块、跨项目代码的通信规则。</p>\n<p data-nodeid=\"25197\">TypeScript 对对象的类型检测遵循一种被称之为“鸭子类型”（duck typing）或者“结构化类型（structural subtyping）”的准则，即只要两个对象的结构一致，属性和方法的类型一致，则它们的类型就是一致的。</p>\n<p data-nodeid=\"25198\">下面我们先通过 05 讲中介绍的函数类型的示例来初识一下接口类型，如下代码所示：</p>\n<pre class=\"lang-typescript\" data-nodeid=\"25199\"><code data-language=\"typescript\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">Study</span>(<span class=\"hljs-params\">language: { name: <span class=\"hljs-built_in\">string</span>; age: () =&gt; <span class=\"hljs-built_in\">number</span> }</span>) </span>{\n  <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">`ProgramLanguage <span class=\"hljs-subst\">${language.name}</span> created <span class=\"hljs-subst\">${language.age()}</span> years ago.`</span>);\n}\nStudy({\n  name: <span class=\"hljs-string\">'TypeScript'</span>,\n  age: <span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Date</span>().getFullYear() - <span class=\"hljs-number\">2012</span>\n});\n</code></pre>\n<p data-nodeid=\"25200\">在上述代码中，我们定义了一个拥有 string  类型属性name、函数类型属性age的对象 language 作为参数（形参 Parameter）的函数。同时，我们还使用类似定义 JavaScript 对象字面量的语法定义了一个内联接口类型来约束参数对象的类型。</p>\n<p data-nodeid=\"25201\">然后，我们传递了一个 name 属性为 'TypeScript'  的字符串、age 属性为计算年份差函数的对象字面量作为参数（argument）来调用这个函数。</p>\n<p data-nodeid=\"25202\">在调用函数的过程中，TypeScript 静态类型检测到传递的对象字面量类型为 string 的 name 属性和类型为() =&gt; number 的 age 属性与函数参数定义的类型一致，于是不会抛出一个类型错误。</p>\n<p data-nodeid=\"25203\">如果我们传入一个 name 属性是 number 类型或者缺少age属性的对象字面量，如下代码所示：</p>\n<pre class=\"lang-typescript\" data-nodeid=\"25204\"><code data-language=\"typescript\">Study({\n  name: <span class=\"hljs-number\">2</span>,\n  age: <span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Date</span>().getFullYear() - <span class=\"hljs-number\">2012</span>\n});\nStudy({\n  name: <span class=\"hljs-string\">'TypeScript'</span>\n});\n</code></pre>\n<p data-nodeid=\"25205\">这时，第 2 行会提示错误： ts(2322) number 不能赋值给 string，第 7 行也会提示错误： ts(2345) 实参(Argument)与形参(Parameter)类型不兼容，缺少必需的属性 age。</p>\n<p data-nodeid=\"25206\">同样，如果我们传入一个包含了形参类型定义里没有的 id 属性的对象字面量作为实参，也会得到一个类型错误 ts(2345)，实参（Argument）与形参（Parameter）类型不兼容，不存在的属性 id，如下代码所示：</p>\n<pre class=\"lang-typescript\" data-nodeid=\"25207\"><code data-language=\"typescript\"><span class=\"hljs-comment\">/** ts(2345) 实参(Argument)与形参(Parameter)类型不兼容，不存在的属性 id */</span>\nStudy({\n  id: <span class=\"hljs-number\">2</span>,\n  name: <span class=\"hljs-string\">'TypeScript'</span>,\n  age: <span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Date</span>().getFullYear() - <span class=\"hljs-number\">2012</span>\n});\n</code></pre>\n<p data-nodeid=\"25208\">有意思的是，在上边的示例中，如果我们先把这个对象字面量赋值给一个变量，然后再把变量传递给函数进行调用，那么 TypeScript 静态类型检测就会仅仅检测形参类型中定义过的属性类型，而包容地忽略任何多余的属性，此时也不会抛出一个 ts(2345) 类型错误。</p>\n<p data-nodeid=\"25209\">如下代码所示，第 6 行不会提示错误。</p>\n<pre class=\"lang-typescript\" data-nodeid=\"25210\"><code data-language=\"typescript\"><span class=\"hljs-keyword\">let</span> ts = {\n  id: <span class=\"hljs-number\">2</span>,\n  name: <span class=\"hljs-string\">'TypeScript'</span>,\n  age: <span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Date</span>().getFullYear() - <span class=\"hljs-number\">2012</span>\n};\nStudy(ts); <span class=\"hljs-comment\">// ok</span>\n</code></pre>\n<p data-nodeid=\"25211\">这并非一个疏忽或 bug，而是有意为之地将对象字面量和变量进行区别对待，我们把这种情况称之为对象字面量的 freshness（在 12 讲中会再次详细介绍）。</p>\n<p data-nodeid=\"25212\">因为这种内联形式的接口类型定义在语法层面与熟知的 JavaScript 解构颇为神似，所以很容易让我们产生混淆。下面我们通过如下示例对比一下解构语法与内联接口类型混用的效果。</p>\n<pre class=\"lang-typescript\" data-nodeid=\"25213\"><code data-language=\"typescript\"><span class=\"hljs-comment\">/** 纯 JavaScript 解构语法 */</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">StudyJavaScript</span>(<span class=\"hljs-params\">{name, age}</span>) </span>{\n  <span class=\"hljs-built_in\">console</span>.log(name, age);\n}\n<span class=\"hljs-comment\">/** TypeScript 里解构与内联类型混用 */</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">StudyTypeScript</span>(<span class=\"hljs-params\">{name, age}: {name: <span class=\"hljs-built_in\">string</span>, age: () =&gt; <span class=\"hljs-built_in\">number</span>}</span>) </span>{\n    <span class=\"hljs-built_in\">console</span>.log(name, age);\n}\n<span class=\"hljs-comment\">/** 纯 JavaScript 解构语法，定义别名 */</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">StudyJavaScript</span>(<span class=\"hljs-params\">{name: aliasName}</span>) </span>{ <span class=\"hljs-comment\">// 定义name的别名</span>\n  <span class=\"hljs-built_in\">console</span>.log(aliasName);\n}\n<span class=\"hljs-comment\">/** TypeScript */</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">StudyTypeScript</span>(<span class=\"hljs-params\">language: {name: <span class=\"hljs-built_in\">string</span>}</span>) </span>{\n  <span class=\"hljs-comment\">// console.log(name); // 不能直接打印name</span>\n  <span class=\"hljs-built_in\">console</span>.log(language.name);  \n}\n</code></pre>\n<p data-nodeid=\"25214\">从上述代码中我们可以看到，在函数中，对象解构和定义接口类型的语法很类似（如第 12 行和 17 行所示），注意不要混淆。实际上，定义内联的接口类型是不可复用的，所以我们应该更多地使用<code data-backticks=\"1\" data-nodeid=\"25345\">interface</code>关键字来抽离可复用的接口类型。</p>\n<p data-nodeid=\"25215\">在 TypeScript 中，接口的语法和其他类型的语言并没有太大区别，我们通过如下所示代码一起看看接口是如何定义的：</p>\n<pre class=\"lang-typescript\" data-nodeid=\"25216\"><code data-language=\"typescript\">/ ** 关键字 接口名称 */\n<span class=\"hljs-keyword\">interface</span> ProgramLanguage {\n  <span class=\"hljs-comment\">/** 语言名称 */</span>\n  name: <span class=\"hljs-built_in\">string</span>;\n  <span class=\"hljs-comment\">/** 使用年限 */</span>\n  age: <span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> <span class=\"hljs-built_in\">number</span>;\n}\n</code></pre>\n<p data-nodeid=\"25217\">在上述代码中，我们定义了一个描述编程语言的接口，它包含一个字符类型的属性 name 和一个函数类型的属性 age 。 从中我们发现接口的语法格式是在 interface 关键字的空格后+接口名字，然后属性与属性类型的定义用花括弧包裹。</p>\n<p data-nodeid=\"25218\">在前边示例中，通过内联参数类型定义的 Study 函数就可以直接使用 ProgramLanguage 接口来定义参数 language 的类型了。</p>\n<pre class=\"lang-typescript\" data-nodeid=\"25219\"><code data-language=\"typescript\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">NewStudy</span>(<span class=\"hljs-params\">language: ProgramLanguage</span>) </span>{\n  <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">`ProgramLanguage <span class=\"hljs-subst\">${language.name}</span> created <span class=\"hljs-subst\">${language.age()}</span> years ago.`</span>);\n}\n</code></pre>\n<p data-nodeid=\"25220\">我们还可以通过复用接口类型定义来约束其他逻辑。比如，我们通过如下所示代码定义了一个类型为 ProgramLanguage 的变量 TypeScript 。</p>\n<pre class=\"lang-typescript\" data-nodeid=\"25221\"><code data-language=\"typescript\"><span class=\"hljs-keyword\">let</span> TypeScript: ProgramLanguage;\n</code></pre>\n<p data-nodeid=\"25222\">接着，我们把满足接口类型约定的一个对象字面量赋值给了这个变量，如下代码所示，此时也不会提示类型错误。</p>\n<pre class=\"lang-typescript\" data-nodeid=\"25223\"><code data-language=\"typescript\">TypeScript = {\n  name: <span class=\"hljs-string\">'TypeScript'</span>,\n  age: <span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Date</span>().getFullYear() - <span class=\"hljs-number\">2012</span>\n}\n</code></pre>\n<p data-nodeid=\"25224\">而任何不符合约定的情况，都会提示类型错误。比如我们通过如下所示代码输入了一个空对象字面量，此时也会提示一个对象字面量类型 {} 缺少 name 和 age 属性的 ts(2739)  错误。</p>\n<pre class=\"lang-typescript\" data-nodeid=\"25225\"><code data-language=\"typescript\">TypeScript = {\n}\n</code></pre>\n<p data-nodeid=\"25226\">按照如下所示代码添加 name 属性后，还是会提示一个对象字面量类型 { name: string; } 缺少必需的 age 属性的 ts( 2741) 错误。</p>\n<pre class=\"lang-typescript\" data-nodeid=\"25227\"><code data-language=\"typescript\">TypeScript = {\n  name: <span class=\"hljs-string\">'TypeScript'</span>\n}\n</code></pre>\n<p data-nodeid=\"25228\">此外，如下代码所示，如果我们把一个 name 属性是 2、age 属性是 'Wrong Type' 的对象赋值给 TypeScript ，在第 2 行会提示错误：ts(2322) number 类型不能赋值给 string，第 3 行会提示错误：ts(2322)string 不能赋值给函数类型。</p>\n<pre class=\"lang-typescript\" data-nodeid=\"25229\"><code data-language=\"typescript\">TypeScript = {\n  name: <span class=\"hljs-number\">2</span>,\n  age: <span class=\"hljs-string\">'Wrong Type'</span>\n}\n</code></pre>\n<p data-nodeid=\"25230\">又或者如以下示例中额外多出了一个接口并未定义的属性 id，也会提示一个 ts(2322) 错误：对象字面量不能赋值给 ProgramLanguage 类型的变量 TypeScript。</p>\n<pre class=\"lang-typescript\" data-nodeid=\"25231\"><code data-language=\"typescript\">TypeScript = {\n  name: <span class=\"hljs-string\">'TypeScript'</span>,\n  age: <span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Date</span>().getFullYear() - <span class=\"hljs-number\">2012</span>,\n  id: <span class=\"hljs-number\">1</span>\n}\n</code></pre>\n<h4 data-nodeid=\"25232\">可缺省属性</h4>\n<p data-nodeid=\"25233\">在前边的例子中，如果我们希望缺少 age 属性的对象字面量也能符合约定且不抛出类型错误，确切地说在接口类型中 age 属性可缺省，那么我们可以在属性名之后通过添加如下所示的? 语法来标注可缺省的属性或方法。如以下示例中，OptionalProgramLanguage 接口就拥有一个可缺省的函数类型的 age 属性。</p>\n<pre class=\"lang-typescript\" data-nodeid=\"25234\"><code data-language=\"typescript\"><span class=\"hljs-comment\">/** 关键字 接口名称 */</span>\n<span class=\"hljs-keyword\">interface</span> OptionalProgramLanguage {\n  <span class=\"hljs-comment\">/** 语言名称 */</span>\n  name: <span class=\"hljs-built_in\">string</span>;\n  <span class=\"hljs-comment\">/** 使用年限 */</span>\n  age?: <span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> <span class=\"hljs-built_in\">number</span>;\n}\n<span class=\"hljs-keyword\">let</span> OptionalTypeScript: OptionalProgramLanguage = {\n  name: <span class=\"hljs-string\">'TypeScript'</span>\n}; <span class=\"hljs-comment\">// ok</span>\n</code></pre>\n<p data-nodeid=\"25235\">当属性被标注为可缺省后，它的类型就变成了显式指定的类型与 undefined 类型组成的联合类型（详见 08 讲），比如示例中 OptionalTypeScript 的 age 属性类型就变成了如下所示内容：</p>\n<pre class=\"lang-typescript\" data-nodeid=\"25236\"><code data-language=\"typescript\">(<span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> <span class=\"hljs-built_in\">number</span>) | <span class=\"hljs-literal\">undefined</span>;\n</code></pre>\n<p data-nodeid=\"25237\">既然如此，我们就来发散思考一下：你觉得如下所示的接口类型 OptionalTypeScript2 和 OptionalTypeScript 等价吗？</p>\n<pre class=\"lang-typescript\" data-nodeid=\"25238\"><code data-language=\"typescript\"><span class=\"hljs-comment\">/** 关键字 接口名称 */</span>\n<span class=\"hljs-keyword\">interface</span> OptionalProgramLanguage2 {\n  <span class=\"hljs-comment\">/** 语言名称 */</span>\n  name: <span class=\"hljs-built_in\">string</span>;\n  <span class=\"hljs-comment\">/** 使用年限 */</span>\n  age: <span class=\"hljs-function\">(<span class=\"hljs-params\">(<span class=\"hljs-params\"></span>) =&gt; <span class=\"hljs-built_in\">number</span></span>) | <span class=\"hljs-params\">undefined</span>;\n}\n</span></code></pre>\n<p data-nodeid=\"25239\">答案当然是不等价，这与 05 讲中提到函数可缺省参数和参数类型可以是 undefined 一样，可缺省意味着可以不设置属性键名，类型是 undefined 意味着属性键名不可缺省。</p>\n<p data-nodeid=\"25240\">既然值可能是 undefined ，如果我们需要对该对象的属性或方法进行操作，就可以使用类型守卫（详见 11 讲）或 Optional Chain（在第 5 行的属性名后加 ? ），如下代码所示：</p>\n<pre class=\"lang-typescript\" data-nodeid=\"25241\"><code data-language=\"typescript\"><span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">typeof</span> OptionalTypeScript.age === <span class=\"hljs-string\">'function'</span>) {\n  OptionalTypeScript.age();\n}\nOptionalTypeScript.age?.();\n</code></pre>\n<p data-nodeid=\"25242\">通过第 1 行所示的 typeof 条件判断，在确保了 age 属性是函数的情况下我们才会调用，这样就避免了运行时提示 age 不是函数的错误。</p>\n<h4 data-nodeid=\"25243\">只读属性</h4>\n<p data-nodeid=\"25244\">我们可能还会碰到这样的场景，希望对对象的某个属性或方法锁定写操作，比如前面例子中，定义了 TypeScriptLanguage 变量之后，name 属性的值肯定是稳定不可变更的 'TypeScript' ，而不能再被变更为 'JavaScript' 或 'AnyScript' 。这时，我们可以在属性名前通过添加 readonly 修饰符的语法来标注 name 为只读属性。</p>\n<pre class=\"lang-typescript\" data-nodeid=\"25245\"><code data-language=\"typescript\"><span class=\"hljs-keyword\">interface</span> ReadOnlyProgramLanguage {\n  <span class=\"hljs-comment\">/** 语言名称 */</span>\n  readonly name: <span class=\"hljs-built_in\">string</span>;\n  <span class=\"hljs-comment\">/** 使用年限 */</span>\n  readonly age: <span class=\"hljs-function\">(<span class=\"hljs-params\">(<span class=\"hljs-params\"></span>) =&gt; <span class=\"hljs-built_in\">number</span></span>) | <span class=\"hljs-params\">undefined</span>;\n}\n \n<span class=\"hljs-params\">let</span> <span class=\"hljs-params\">ReadOnlyTypeScript</span>: <span class=\"hljs-params\">ReadOnlyProgramLanguage</span> = {\n  <span class=\"hljs-params\">name</span>: '<span class=\"hljs-params\">TypeScript</span>',\n  <span class=\"hljs-params\">age</span>: <span class=\"hljs-params\">undefined</span>\n}\n/** <span class=\"hljs-params\">ts</span>(<span class=\"hljs-params\">2540</span>)错误，<span class=\"hljs-params\">name</span> 只读 */\n<span class=\"hljs-params\">ReadOnlyTypeScript</span>.<span class=\"hljs-params\">name</span> = '<span class=\"hljs-params\">JavaScript</span>';\n</span></code></pre>\n<p data-nodeid=\"25246\">需要注意的是，这仅仅是静态类型检测层面的只读，实际上并不能阻止对对象的篡改。因为在转译为 JavaScript 之后，readonly 修饰符会被抹除。因此，任何时候与其直接修改一个对象，不如返回一个新的对象，这会是一种比较安全的实践。</p>\n<h4 data-nodeid=\"25247\">定义函数类型</h4>\n<p data-nodeid=\"28835\" class=\"\">在以上示例中，你可能会觉得接口类型仅能用来定义对象的类型，但是如 05 讲中提到接口类型还可以用来定义函数的类型 <strong data-nodeid=\"28841\">（备注：仅仅是定义函数的类型，而不包含函数的实现）</strong>，具体示例如下。</p>\n\n\n\n<pre class=\"lang-typescript\" data-nodeid=\"25249\"><code data-language=\"typescript\"><span class=\"hljs-keyword\">interface</span> StudyLanguage {\n  (language: ProgramLanguage): <span class=\"hljs-built_in\">void</span>\n}\n<span class=\"hljs-comment\">/** 单独的函数实践 */</span>\n<span class=\"hljs-keyword\">let</span> StudyInterface: StudyLanguage \n  = <span class=\"hljs-function\"><span class=\"hljs-params\">language</span> =&gt;</span> <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">`<span class=\"hljs-subst\">${language.name}</span> <span class=\"hljs-subst\">${language.age()}</span>`</span>);\n</code></pre>\n<p data-nodeid=\"25250\">在示例第 1~3 行，我们定义了一个接口类型 StudyLanguage，它有一个函数类型的匿名成员，函数参数类型 ProgramLanguage，返回值的类型是 void，通过这样的格式定义的接口类型又被称之为可执行类型，也就是一个函数类型。</p>\n<p data-nodeid=\"25251\">在第 6 行中，我们声明了一个 StudyLanguage 类型的变量，并赋给它一个箭头函数作为值。回想一下 04 讲中提到的上下文类型推断，赋值操作左侧的 StudyLanguage 类型是可以约束箭头函数的类型，所以即便我们没有显式指定函数参数 language 的类型，TypeScript 也能推断出它的类型就是 ProgramLanguage。</p>\n<p data-nodeid=\"25252\">实际上，我们很少使用接口类型来定义函数的类型，更多使用内联类型或类型别名（本讲后半部分讲解）配合箭头函数语法来定义函数类型，具体示例如下：</p>\n<pre class=\"lang-typescript\" data-nodeid=\"25253\"><code data-language=\"typescript\"><span class=\"hljs-keyword\">type</span> StudyLanguageType = <span class=\"hljs-function\">(<span class=\"hljs-params\">language: ProgramLanguage</span>) =&gt;</span> <span class=\"hljs-built_in\">void</span>\n</code></pre>\n<p data-nodeid=\"25254\">我们给箭头函数类型指定了一个别名 StudyLanguageType，在其他地方就可以直接复用 StudyLanguageType，而不用重新声明新的箭头函数类型定义。</p>\n<h4 data-nodeid=\"25255\">索引签名</h4>\n<p data-nodeid=\"25256\">在实际工作中，使用接口类型较多的地方是对象，比如 React 组件的 Props &amp; State、HTMLElement 的 Props，这些对象有一个共性，即所有的属性名、方法名都确定。</p>\n<p data-nodeid=\"25257\">实际上，我们经常会把对象当 Map 映射使用，比如下边代码示例中定义了索引是任意数字的对象 LanguageRankMap 和索引是任意字符串的对象 LanguageMap。</p>\n<pre class=\"lang-typescript\" data-nodeid=\"25258\"><code data-language=\"typescript\"><span class=\"hljs-keyword\">let</span> LanguageRankMap = {\n  <span class=\"hljs-number\">1</span>: <span class=\"hljs-string\">'TypeScript'</span>,\n  <span class=\"hljs-number\">2</span>: <span class=\"hljs-string\">'JavaScript'</span>,\n  ...\n};\n<span class=\"hljs-keyword\">let</span> LanguageMap = {\n  TypeScript: <span class=\"hljs-number\">2012</span>,\n  JavaScript: <span class=\"hljs-number\">1995</span>,\n  ...\n};\n</code></pre>\n<p data-nodeid=\"25259\">这个时候，我们需要使用索引签名来定义上边提到的对象映射结构，并通过 “[索引名: 类型]”的格式约束索引的类型。</p>\n<p data-nodeid=\"25260\">索引名称的类型分为 string 和 number 两种，通过如下定义的 LanguageRankInterface 和 LanguageYearInterface 两个接口，我们可以用来描述索引是任意数字或任意字符串的对象。</p>\n<pre class=\"lang-typescript\" data-nodeid=\"25261\"><code data-language=\"typescript\"><span class=\"hljs-keyword\">interface</span> LanguageRankInterface {\n  [rank: <span class=\"hljs-built_in\">number</span>]: <span class=\"hljs-built_in\">string</span>;\n}\n<span class=\"hljs-keyword\">interface</span> LanguageYearInterface {\n  [name: <span class=\"hljs-built_in\">string</span>]: <span class=\"hljs-built_in\">number</span>;\n}\n{\n  <span class=\"hljs-keyword\">let</span> LanguageRankMap: LanguageRankInterface = {\n    <span class=\"hljs-number\">1</span>: <span class=\"hljs-string\">'TypeScript'</span>, <span class=\"hljs-comment\">// ok</span>\n    <span class=\"hljs-number\">2</span>: <span class=\"hljs-string\">'JavaScript'</span>, <span class=\"hljs-comment\">// ok</span>\n    <span class=\"hljs-string\">'WrongINdex'</span>: <span class=\"hljs-string\">'2012'</span> <span class=\"hljs-comment\">// ts(2322) 不存在的属性名</span>\n  };\n  \n  <span class=\"hljs-keyword\">let</span> LanguageMap: LanguageYearInterface = {\n    TypeScript: <span class=\"hljs-number\">2012</span>, <span class=\"hljs-comment\">// ok</span>\n    JavaScript: <span class=\"hljs-number\">1995</span>, <span class=\"hljs-comment\">// ok</span>\n    <span class=\"hljs-number\">1</span>: <span class=\"hljs-number\">1970</span> <span class=\"hljs-comment\">// ok</span>\n  };\n}\n</code></pre>\n<p data-nodeid=\"25262\"><strong data-nodeid=\"25412\">注意：在上述示例中，数字作为对象索引时，它的类型既可以与数字兼容，也可以与字符串兼容，这与 JavaScript 的行为一致。因此，使用 0 或 '0' 索引对象时，这两者等价。</strong></p>\n<p data-nodeid=\"25263\">同样，我们可以使用 readonly 注解索引签名，此时将对应属性设置为只读就行，如下代码所示：</p>\n<pre class=\"lang-typescript\" data-nodeid=\"25264\"><code data-language=\"typescript\">{\n  <span class=\"hljs-keyword\">interface</span> LanguageRankInterface {\n    readonly [rank: <span class=\"hljs-built_in\">number</span>]: <span class=\"hljs-built_in\">string</span>;\n  }\n  \n  <span class=\"hljs-keyword\">interface</span> LanguageYearInterface {\n    readonly [name: <span class=\"hljs-built_in\">string</span>]: <span class=\"hljs-built_in\">number</span>;\n  }\n} \n</code></pre>\n<p data-nodeid=\"25265\">在上述示例中，LanguageRankInterface 和 LanguageYearInterface 任意的数字或者字符串类型的属性都是只读的。</p>\n<p data-nodeid=\"25266\"><strong data-nodeid=\"25418\">注意：虽然属性可以与索引签名进行混用，但是属性的类型必须是对应的数字索引或字符串索引的类型的子集，否则会出现错误提示。</strong></p>\n<p data-nodeid=\"25267\">下面我们通过如下所示的示例具体来看一下。</p>\n<pre class=\"lang-typescript\" data-nodeid=\"25268\"><code data-language=\"typescript\">{\n  <span class=\"hljs-keyword\">interface</span> StringMap {\n    [prop: <span class=\"hljs-built_in\">string</span>]: <span class=\"hljs-built_in\">number</span>;\n    age: <span class=\"hljs-built_in\">number</span>; <span class=\"hljs-comment\">// ok</span>\n    name: <span class=\"hljs-built_in\">string</span>; <span class=\"hljs-comment\">// ts(2411) name 属性的 string 类型不能赋值给字符串索引类型 number</span>\n  }\n  <span class=\"hljs-keyword\">interface</span> NumberMap {\n    [rank: <span class=\"hljs-built_in\">number</span>]: <span class=\"hljs-built_in\">string</span>;\n    <span class=\"hljs-number\">1</span>: <span class=\"hljs-built_in\">string</span>; <span class=\"hljs-comment\">// ok</span>\n    <span class=\"hljs-number\">0</span>: <span class=\"hljs-built_in\">number</span>; <span class=\"hljs-comment\">// ts(2412) 0 属性的 number 类型不能赋值给数字索引类型 string</span>\n  }\n  <span class=\"hljs-keyword\">interface</span> LanguageRankInterface {\n    name: <span class=\"hljs-built_in\">string</span>; <span class=\"hljs-comment\">// ok</span>\n    <span class=\"hljs-number\">0</span>: <span class=\"hljs-built_in\">number</span>; <span class=\"hljs-comment\">// ok</span>\n    [rank: <span class=\"hljs-built_in\">number</span>]: <span class=\"hljs-built_in\">string</span>;\n    [name: <span class=\"hljs-built_in\">string</span>]: <span class=\"hljs-built_in\">number</span>;\n  }\n}\n</code></pre>\n<p data-nodeid=\"25269\">在上述示例中，因为接口 StringMap 属性 name 的类型 string 不是它所对应的字符串索引（第 3 行定义的 prop: string）类型 number 的子集，所以会提示一个错误。同理，因为接口 NumberMap 属性 0 的类型 number 不是它所对应的数字索引（第 8 行定义的 rank: number）类型 string 的子集，所以也会提示一个错误。</p>\n<p data-nodeid=\"25270\">另外，由于上边提到了数字类型索引的特殊性，所以我们不能约束数字索引属性与字符串索引属性拥有截然不同的类型，具体示例如下：</p>\n<pre class=\"lang-typescript\" data-nodeid=\"25271\"><code data-language=\"typescript\">{\n  <span class=\"hljs-keyword\">interface</span> LanguageRankInterface {\n    [rank: <span class=\"hljs-built_in\">number</span>]: <span class=\"hljs-built_in\">string</span>; <span class=\"hljs-comment\">// ts(2413) 数字索引类型 string 类型不能赋值给字符串索引类型 number</span>\n    [prop: <span class=\"hljs-built_in\">string</span>]: <span class=\"hljs-built_in\">number</span>;\n  }\n}\n</code></pre>\n<p data-nodeid=\"25272\">这里我们定义了 LanguageRankInterface 的数字索引 rank 的类型是 string，与定义的字符串索引 prop 的类型 number 不兼容，所以会提示一个 ts(2413) 错误。</p>\n<p data-nodeid=\"25273\"><strong data-nodeid=\"25427\">这里埋个伏笔</strong>：如果我们确实需要使用 age 是 number 类型、其他属性类型是 string 的对象数据结构，应该如何定义它的类型且不提示错误呢？</p>\n<p data-nodeid=\"25274\">比如如下示例中定义的 age 属性是数字、其他任意属性是字符串的对象，我们应该怎么定义它的类型呢？</p>\n<pre class=\"lang-javascript\" data-nodeid=\"25275\"><code data-language=\"javascript\">{\n  <span class=\"hljs-attr\">age</span>: <span class=\"hljs-number\">1</span>, <span class=\"hljs-comment\">// 数字类型</span>\n  <span class=\"hljs-attr\">anyProperty</span>: <span class=\"hljs-string\">'str'</span>, <span class=\"hljs-comment\">// 字符串</span>\n  ...\n}\n</code></pre>\n<p data-nodeid=\"25276\">由于属性和索引签名的类型限制，使得我们不能通过单一的接口来描述这个对象，这时我们该怎么办呢？请继续保持你的好奇心，08 讲中我们会解决这个问题。</p>\n<h4 data-nodeid=\"25277\">继承与实现</h4>\n<p data-nodeid=\"25278\">在面向接口编程时，我们怎么能少得了继承与实现？</p>\n<p data-nodeid=\"25279\">在 TypeScript 中，接口类型可以继承和被继承，比如我们可以使用如下所示的 extends 关键字实现接口的继承。</p>\n<pre class=\"lang-typescript\" data-nodeid=\"25280\"><code data-language=\"typescript\">{\n  <span class=\"hljs-keyword\">interface</span> DynamicLanguage <span class=\"hljs-keyword\">extends</span> ProgramLanguage {\n    rank: <span class=\"hljs-built_in\">number</span>; <span class=\"hljs-comment\">// 定义新属性</span>\n  }\n  \n  <span class=\"hljs-keyword\">interface</span> TypeSafeLanguage <span class=\"hljs-keyword\">extends</span> ProgramLanguage {\n    typeChecker: <span class=\"hljs-built_in\">string</span>; <span class=\"hljs-comment\">// 定义新的属性</span>\n  }\n  <span class=\"hljs-comment\">/** 继承多个 */</span>\n  <span class=\"hljs-keyword\">interface</span> TypeScriptLanguage <span class=\"hljs-keyword\">extends</span> DynamicLanguage, TypeSafeLanguage {\n    name: <span class=\"hljs-string\">'TypeScript'</span>; <span class=\"hljs-comment\">// 用原属性类型的兼容的类型(比如子集)重新定义属性</span>\n  }\n}\n</code></pre>\n<p data-nodeid=\"25281\">在上述示例中，从第 2~8 行我们定义了两个继承了 ProgramLanguage 的接口 DynamicLanguage 和 TypeSafeLanguage，它们会继承 ProgramLanguage 所有的属性定义。第 11 行我们定义了同时继承了 DynamicLanguage 和 TypeSafeLanguage 的接口 TypeScriptLanguage，它会继承 DynamicLanguage 和 TypeSafeLanguage 所有的属性定义，并且使用同名的 name 属性定义覆盖了继承过来的 name 属性定义。</p>\n<p data-nodeid=\"25282\"><strong data-nodeid=\"25440\">注意：我们仅能使用兼容的类型覆盖继承的属性</strong>，如下代码所示。</p>\n<pre class=\"lang-typescript\" data-nodeid=\"25283\"><code data-language=\"typescript\">{\n  <span class=\"hljs-comment\">/** ts(6196) 错误的继承，name 属性不兼容 */</span>\n  <span class=\"hljs-keyword\">interface</span> WrongTypeLanguage <span class=\"hljs-keyword\">extends</span> ProgramLanguage {\n    name: <span class=\"hljs-built_in\">number</span>;\n  }\n}\n</code></pre>\n<p data-nodeid=\"25284\">在上述代码中，因为 ProgramLanguage 的 name 属性是 string 类型，WrongTypeLanguage 的 name 属性是 number，二者不兼容，所以不能继承，也会提示一个 ts(6196) 错误。</p>\n<p data-nodeid=\"25285\">如 06 讲中提到，我们既可以使用接口类型来约束类，反过来也可以使用类实现接口，那两者之间的关系到底是什么呢？这里，我们通过使用如下所示的 implements 关键字描述一下类和接口之间的关系。</p>\n<pre class=\"lang-typescript\" data-nodeid=\"25286\"><code data-language=\"typescript\"><span class=\"hljs-comment\">/** 类实现接口 */</span>\n{\n  <span class=\"hljs-keyword\">class</span> LanguageClass <span class=\"hljs-keyword\">implements</span> ProgramLanguage {\n    name: <span class=\"hljs-built_in\">string</span> = <span class=\"hljs-string\">''</span>;\n    age = <span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Date</span>().getFullYear() - <span class=\"hljs-number\">2012</span>\n  }\n}\n</code></pre>\n<p data-nodeid=\"25287\">在上述代码中，类 LanguageClass 实现了 ProgramLanguage 接口约定的 name、age 等属性和方法，如果我们移除 name 或者 age 的实现，将会提示一个类型错误。</p>\n<h3 data-nodeid=\"25288\">Type 类型别名</h3>\n<p data-nodeid=\"25289\">接口类型的一个作用是将内联类型抽离出来，从而实现类型可复用。其实，我们也可以使用类型别名接收抽离出来的内联类型实现复用。</p>\n<p data-nodeid=\"25290\">此时，我们可以通过如下所示“<code data-backticks=\"1\" data-nodeid=\"25447\">type</code>别名名字 = 类型定义”的格式来定义类型别名。</p>\n<pre class=\"lang-typescript\" data-nodeid=\"25291\"><code data-language=\"typescript\"><span class=\"hljs-comment\">/** 类型别名 */</span>\n{\n  <span class=\"hljs-keyword\">type</span> LanguageType = {\n    <span class=\"hljs-comment\">/** 以下是接口属性 */</span>\n    <span class=\"hljs-comment\">/** 语言名称 */</span>\n    name: <span class=\"hljs-built_in\">string</span>;\n    <span class=\"hljs-comment\">/** 使用年限 */</span>\n    age: <span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> <span class=\"hljs-built_in\">number</span>;\n  }\n}\n</code></pre>\n<p data-nodeid=\"29396\">在上述代码中，乍看上去有点像是在定义变量，只不过这里我们把 let 、const 、var 关键字换成了 type 罢了。</p>\n<p data-nodeid=\"29397\">此外，针对接口类型无法覆盖的场景，比如组合类型、交叉类型（详见 08 讲），我们只能使用类型别名来接收，如下代码所示：</p>\n\n<pre class=\"lang-typescript\" data-nodeid=\"25293\"><code data-language=\"typescript\">{\n  <span class=\"hljs-comment\">/** 联合 */</span>\n  <span class=\"hljs-keyword\">type</span> MixedType = <span class=\"hljs-built_in\">string</span> | <span class=\"hljs-built_in\">number</span>;\n  <span class=\"hljs-comment\">/** 交叉 */</span>\n  <span class=\"hljs-keyword\">type</span> IntersectionType = { id: <span class=\"hljs-built_in\">number</span>; name: <span class=\"hljs-built_in\">string</span>; } \n    &amp; { age: <span class=\"hljs-built_in\">number</span>; name: <span class=\"hljs-built_in\">string</span> };\n  <span class=\"hljs-comment\">/** 提取接口属性类型 */</span>\n  <span class=\"hljs-keyword\">type</span> AgeType = ProgramLanguage[<span class=\"hljs-string\">'age'</span>];  \n}\n</code></pre>\n<p data-nodeid=\"25294\">在上述代码中，我们定义了一个 IntersectionType 类型别名，表示两个匿名接口类型交叉出的类型；同时定义了一个 AgeType 类型别名，表示抽取的 ProgramLanguage age 属性的类型。</p>\n<blockquote data-nodeid=\"25295\">\n<p data-nodeid=\"25296\">注意：类型别名，诚如其名，即我们仅仅是给类型取了一个新的名字，并不是创建了一个新的类型。</p>\n</blockquote>\n<h3 data-nodeid=\"25297\">Interface 与 Type 的区别</h3>\n<p data-nodeid=\"25298\">通过以上介绍，我们已经知道适用接口类型标注的地方大都可以使用类型别名进行替代，这是否意味着在相应的场景中这两者等价呢？</p>\n<p data-nodeid=\"25299\">实际上，在大多数的情况下使用接口类型和类型别名的效果等价，但是在某些特定的场景下这两者还是存在很大区别。比如，重复定义的接口类型，它的属性会叠加，这个特性使得我们可以极其方便地对全局变量、第三方库的类型做扩展，如下代码所示：</p>\n<pre class=\"lang-typescript\" data-nodeid=\"25300\"><code data-language=\"typescript\">{\n  <span class=\"hljs-keyword\">interface</span> Language {\n    id: <span class=\"hljs-built_in\">number</span>;\n  }\n  \n  <span class=\"hljs-keyword\">interface</span> Language {\n    name: <span class=\"hljs-built_in\">string</span>;\n  }\n  <span class=\"hljs-keyword\">let</span> lang: Language = {\n    id: <span class=\"hljs-number\">1</span>, <span class=\"hljs-comment\">// ok</span>\n    name: <span class=\"hljs-string\">'name'</span> <span class=\"hljs-comment\">// ok</span>\n  }\n}\n</code></pre>\n<p data-nodeid=\"25301\">在上述代码中，先后定义的两个 Language 接口属性被叠加在了一起，此时我们可以赋值给  lang 变量一个同时包含 id 和 name 属性的对象。</p>\n<p data-nodeid=\"25302\">不过，如果我们重复定义类型别名，如下代码所示，则会提示一个 ts(2300) 错误。</p>\n<pre class=\"lang-typescript\" data-nodeid=\"25303\"><code data-language=\"typescript\">{\n  <span class=\"hljs-comment\">/** ts(2300) 重复的标志 */</span>\n  <span class=\"hljs-keyword\">type</span> Language = {\n    id: <span class=\"hljs-built_in\">number</span>;\n  }\n  \n  <span class=\"hljs-comment\">/** ts(2300) 重复的标志 */</span>\n  <span class=\"hljs-keyword\">type</span> Language = {\n    name: <span class=\"hljs-built_in\">string</span>;\n  }\n  <span class=\"hljs-keyword\">let</span> lang: Language = {\n    id: <span class=\"hljs-number\">1</span>,\n    name: <span class=\"hljs-string\">'name'</span>\n  }\n}\n</code></pre>\n<p data-nodeid=\"25304\">在上述代码中，我们重复定义了一个类型别名 Language ，此时就提示了一个错误。</p>\n<h3 data-nodeid=\"25305\">小结与预告</h3>\n<p data-nodeid=\"25306\">接口类型是 TypeScript 最核心的知识点之一，掌握好接口类型，养成面向接口编程思维方式和惯性，将让我们的编程之路愈发顺利、高效。</p>\n<p data-nodeid=\"25307\">类型别名使得类型可以像值一样能赋予另外一个变量（别名），大大提升了类型复用性，最终也提升了我们的编程效率。</p>\n<p data-nodeid=\"25308\">这里插播一个思考题：接口类型和类型别名的区别是什么？欢迎你在留言区进行互动、交流。</p>\n<p data-nodeid=\"25309\">08 讲我们将介绍提升类型复用性的另外两个利器——联合和交叉类型，敬请期待吧~</p>\n<p data-nodeid=\"25310\">另外，如果你觉得本专栏有价值，欢迎分享给更多好友哦。</p>",
                "article_title": "07 | 接口类型与类型别名：这两者的用法与区别分别是什么？",
                "title": "07 | 接口类型与类型别名：这两者的用法与区别分别是什么？",
                "id": 7439
            },
            {
                "content": "<p data-nodeid=\"2616\" class=\"\">在前边课程中，我们介绍了基础类型、字面量类型、函数类型及接口类型等内容，它们都是单一、原子的类型元素。其实，如前边课程中一些稍微复杂、实际编程场景的示例所示，我们还需要通过组合/结合单一、原子类型构造更复杂的类型，以此描述更复杂的数据和结构。这就是这一讲中将介绍的内容——联合和交叉类型（Unions and Intersection Types）。</p>\n<blockquote data-nodeid=\"2617\">\n<p data-nodeid=\"2618\"><strong data-nodeid=\"2711\">学习建议</strong>：请使用 VS Code 新建一个 08.ts 文件，并尝试这一讲中涉及的所有示例。</p>\n</blockquote>\n<h3 data-nodeid=\"2619\">联合类型</h3>\n<p data-nodeid=\"2620\">联合类型（Unions）用来表示变量、参数的类型不是单一原子类型，而可能是多种不同的类型的组合。</p>\n<p data-nodeid=\"2621\">我们主要通过“|”操作符分隔类型的语法来表示联合类型。这里，我们可以把“|”类比为 JavaScript 中的逻辑或 “||”，只不过前者表示可能的类型。</p>\n<p data-nodeid=\"2622\">举个例子，我们封装了一个将 string 或者 number 类型的输入值转换成 '数字 + \"px\" 格式的函数，如下代码所示：</p>\n<pre class=\"lang-typescript\" data-nodeid=\"2623\"><code data-language=\"typescript\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">formatPX</span>(<span class=\"hljs-params\">size: unknown</span>) </span>{\n  <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">typeof</span> size === <span class=\"hljs-string\">'number'</span>) {\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">`<span class=\"hljs-subst\">${size}</span>px`</span>;\n  }\n  <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">typeof</span> size === <span class=\"hljs-string\">'string'</span>) {\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">`<span class=\"hljs-subst\">${<span class=\"hljs-built_in\">parseInt</span>(size) || <span class=\"hljs-number\">0</span>}</span>px`</span>;\n  }\n  <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-built_in\">Error</span>(<span class=\"hljs-string\">` 仅支持 number 或者 string`</span>);\n}\nformatPX(<span class=\"hljs-number\">13</span>);\nformatPX(<span class=\"hljs-string\">'13px'</span>);\n</code></pre>\n<p data-nodeid=\"2624\"><strong data-nodeid=\"2732\">说明：在学习联合类型之前，我们可能免不了使用 any 或 unknown 类型来表示参数的类型（为了让大家养成好习惯，推荐使用 unknown）。</strong></p>\n<p data-nodeid=\"2625\">通过这样的方式带来的问题是，在调用 formatPX 时，我们可以传递任意的值，并且可以通过静态类型检测（使用 any 亦如是），但是运行时还是会抛出一个错误，例如：</p>\n<pre class=\"lang-typescript\" data-nodeid=\"2626\"><code data-language=\"typescript\">formatPX(<span class=\"hljs-literal\">true</span>);\nformatPX(<span class=\"hljs-literal\">null</span>);\n</code></pre>\n<p data-nodeid=\"2627\">这显然不符合我们的预期，因为 size 应该是更明确的，即可能也只可能是 number 或 string 这两种可选类型的类型。</p>\n<p data-nodeid=\"2628\">所幸有联合类型，我们可以使用一个更明确表示<strong data-nodeid=\"2740\">可能是 number 或 string 的联合类型</strong>来注解 size 参数，如下代码所示：</p>\n<pre class=\"lang-typescript\" data-nodeid=\"2629\"><code data-language=\"typescript\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">formatPX</span>(<span class=\"hljs-params\">size: <span class=\"hljs-built_in\">number</span> | <span class=\"hljs-built_in\">string</span></span>) </span>{\n  <span class=\"hljs-comment\">// ...</span>\n}\nformatPX(<span class=\"hljs-number\">13</span>); <span class=\"hljs-comment\">// ok</span>\nformatPX(<span class=\"hljs-string\">'13px'</span>); <span class=\"hljs-comment\">// ok</span>\nformatPX(<span class=\"hljs-literal\">true</span>); <span class=\"hljs-comment\">// ts(2345) 'true' 类型不能赋予 'number | string' 类型</span>\nformatPX(<span class=\"hljs-literal\">null</span>); <span class=\"hljs-comment\">// ts(2345) 'null' 类型不能赋予 'number | string' 类型</span>\n</code></pre>\n<p data-nodeid=\"2630\">在第 1 行，我们定义了函数 formatPX 的参数 size 既可以是 number 类型也可以是 string 类型，所以第 5 行和第 6 行传入数字 13 和字符串 '13px' 都正确，但在第 8 行和第 9 行传入布尔类型的 true 或者 null 类型都会提示一个 ts(2345) 错误。</p>\n<p data-nodeid=\"2631\">当然，我们可以组合任意个、任意类型来构造更满足我们诉求的类型。比如，我们希望给前边的示例再加一个 unit 参数表示可能单位，这个时候就可以声明一个字符串字面类型组成的联合类型，如下代码所示：</p>\n<pre class=\"lang-typescript\" data-nodeid=\"2632\"><code data-language=\"typescript\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">formatUnit</span>(<span class=\"hljs-params\">size: <span class=\"hljs-built_in\">number</span> | <span class=\"hljs-built_in\">string</span>, unit: 'px' | 'em' | 'rem' | '%' = 'px'</span>) </span>{\n  <span class=\"hljs-comment\">// ...</span>\n}\nformatUnit(<span class=\"hljs-number\">1</span>, <span class=\"hljs-string\">'em'</span>); <span class=\"hljs-comment\">// ok</span>\nformatUnit(<span class=\"hljs-string\">'1px'</span>, <span class=\"hljs-string\">'rem'</span>); <span class=\"hljs-comment\">// ok</span>\nformatUnit(<span class=\"hljs-string\">'1px'</span>, <span class=\"hljs-string\">'bem'</span>); <span class=\"hljs-comment\">// ts(2345)</span>\n</code></pre>\n<p data-nodeid=\"2633\">我们定义了 formatPX 函数的第二个参数 unit，它的类型是由 'px'、'em'、'rem'、'%' 字符串字面类型组成的类型集合。因此，我们可以在第 5 行和第 6 行传入字符串字面量 'em' 和 'rem' 作为第二个实参。如果在第 8 行我们传入一个不在类型集合中的字符串字面量 'bem' ，就会提示一个 ts(2345) 错误。</p>\n<p data-nodeid=\"2634\">我们也可以使用类型别名抽离上边的联合类型，然后再将其进一步地联合，如下代码所示：</p>\n<pre class=\"lang-typescript\" data-nodeid=\"2635\"><code data-language=\"typescript\"><span class=\"hljs-keyword\">type</span> ModernUnit = <span class=\"hljs-string\">'vh'</span> | <span class=\"hljs-string\">'vw'</span>;\n<span class=\"hljs-keyword\">type</span> Unit = <span class=\"hljs-string\">'px'</span> | <span class=\"hljs-string\">'em'</span> | <span class=\"hljs-string\">'rem'</span>;\n<span class=\"hljs-keyword\">type</span> MessedUp = ModernUnit | Unit; <span class=\"hljs-comment\">// 类型是 'vh' | 'vw' | 'px' | 'em' | 'rem'</span>\n</code></pre>\n<p data-nodeid=\"2636\">这里我们定义了 ModernUnit 别名表示 'vh' 和 'vw' 这两个字面量类型的组合，且定义了 Unit 别名表示 'px' 和 'em' 和 'rem' 字面量类型组合，同时又定义了 MessedUp 别名表示 ModernUnit 和 Unit 两个类型别名的组合。</p>\n<blockquote data-nodeid=\"2637\">\n<p data-nodeid=\"2638\"><strong data-nodeid=\"2802\">这里埋一个伏笔：</strong> 如果将 string 原始类型和“string 字面量类型”组合成一个联合类型会是什么效果？你可以自己尝试一下，答案将在这一讲的最后揭晓。</p>\n</blockquote>\n<p data-nodeid=\"2639\">我们也可以把接口类型联合起来表示更复杂的结构，如下所示示例（援引官方示例，顺带复习一下类型断言 as）：</p>\n<pre class=\"lang-typescript\" data-nodeid=\"2640\"><code data-language=\"typescript\"><span class=\"hljs-keyword\">interface</span> Bird {\n  fly(): <span class=\"hljs-built_in\">void</span>;\n  layEggs(): <span class=\"hljs-built_in\">void</span>;\n}\n<span class=\"hljs-keyword\">interface</span> Fish {\n  swim(): <span class=\"hljs-built_in\">void</span>;\n  layEggs(): <span class=\"hljs-built_in\">void</span>;\n}\n<span class=\"hljs-keyword\">const</span> getPet: <span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> Bird | Fish = <span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> {\n  <span class=\"hljs-keyword\">return</span> {\n   <span class=\"hljs-comment\">// ...</span>\n  } <span class=\"hljs-keyword\">as</span> Bird | Fish;\n};\n<span class=\"hljs-keyword\">const</span> Pet = getPet();\nPet.layEggs(); <span class=\"hljs-comment\">// ok</span>\nPet.fly(); <span class=\"hljs-comment\">// ts(2339) 'Fish' 没有 'fly' 属性; 'Bird | Fish' 没有 'fly' 属性</span>\n</code></pre>\n<p data-nodeid=\"2641\">从上边的示例可以看到，在联合类型中，我们可以直接访问各个接口成员都拥有的属性、方法，且不会提示类型错误。但是，如果是个别成员特有的属性、方法，我们就需要区分对待了，此时又要引入类型守卫（详见 11 讲）来区分不同的成员类型。</p>\n<p data-nodeid=\"2642\">只不过，在这种情况下，我们还需要使用基于 in 操作符判断的类型守卫，如下代码所示：</p>\n<pre class=\"lang-typescript\" data-nodeid=\"2643\"><code data-language=\"typescript\"><span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">typeof</span> Pet.fly === <span class=\"hljs-string\">'function'</span>) { <span class=\"hljs-comment\">// ts(2339)</span>\n  Pet.fly(); <span class=\"hljs-comment\">// ts(2339)</span>\n}\n<span class=\"hljs-keyword\">if</span> (<span class=\"hljs-string\">'fly'</span> <span class=\"hljs-keyword\">in</span> Pet) {\n  Pet.fly(); <span class=\"hljs-comment\">// ok</span>\n}\n</code></pre>\n<p data-nodeid=\"2644\">因为 Pet 的类型既可能是 Bird 也可能是 Fish，这就意味着在第 1 行可能会通过 Fish 类型获取 fly 属性，但 Fish 类型没有 fly 属性定义，所以会提示一个 ts(2339) 错误。</p>\n<h3 data-nodeid=\"2645\">交叉类型</h3>\n<p data-nodeid=\"2646\">前边我们使用了逻辑或“||” 类比联合类型，那是不是还有一个逻辑与“&amp;&amp;”可以类比类型？</p>\n<p data-nodeid=\"2647\">在 TypeScript 中，确实还存在一种类似逻辑与行为的类型——交叉类型（Intersection Type），它可以把多个类型合并成一个类型，合并后的类型将拥有所有成员类型的特性。</p>\n<p data-nodeid=\"2648\">在 TypeScript 中，我们可以使用“&amp;”操作符来声明交叉类型，如下代码所示：</p>\n<pre class=\"lang-typescript\" data-nodeid=\"2649\"><code data-language=\"typescript\">{\n  <span class=\"hljs-keyword\">type</span> Useless = <span class=\"hljs-built_in\">string</span> &amp; <span class=\"hljs-built_in\">number</span>;\n}\n</code></pre>\n<p data-nodeid=\"2650\">很显然，如果我们仅仅把原始类型、字面量类型、函数类型等原子类型合并成交叉类型，是没有任何用处的，因为任何类型都不能满足同时属于多种原子类型，比如既是 string 类型又是 number 类型。因此，在上述的代码中，类型别名 Useless 的类型就是个 never。</p>\n<h4 data-nodeid=\"2651\">合并接口类型</h4>\n<p data-nodeid=\"2652\">联合类型真正的用武之地就是将多个接口类型合并成一个类型，从而实现等同接口继承的效果，也就是所谓的合并接口类型，如下代码所示：</p>\n<pre class=\"lang-typescript\" data-nodeid=\"2653\"><code data-language=\"typescript\">  <span class=\"hljs-keyword\">type</span> IntersectionType = { id: <span class=\"hljs-built_in\">number</span>; name: <span class=\"hljs-built_in\">string</span>; } \n    &amp; { age: <span class=\"hljs-built_in\">number</span> };\n  <span class=\"hljs-keyword\">const</span> mixed: IntersectionType = {\n    id: <span class=\"hljs-number\">1</span>,\n    name: <span class=\"hljs-string\">'name'</span>,\n    age: <span class=\"hljs-number\">18</span>\n  }\n</code></pre>\n<p data-nodeid=\"2654\">在上述示例中，我们通过交叉类型，使得 IntersectionType 同时拥有了 id、name、age 所有属性，这里我们可以试着将合并接口类型理解为求并集。</p>\n<blockquote data-nodeid=\"2655\">\n<p data-nodeid=\"2656\">这里，我们来发散思考一下：如果合并的多个接口类型存在同名属性会是什么效果呢？</p>\n</blockquote>\n<p data-nodeid=\"2657\">此时，我们可以根据同名属性的类型是否兼容（详见 12 讲）将这个问题分开来看。</p>\n<p data-nodeid=\"2658\">如果同名属性的类型不兼容，比如上面示例中两个接口类型同名的 name 属性类型一个是 number，另一个是 string，合并后，name 属性的类型就是 number 和 string 两个原子类型的交叉类型，即 never，如下代码所示：</p>\n<pre class=\"lang-typescript\" data-nodeid=\"2659\"><code data-language=\"typescript\">  <span class=\"hljs-keyword\">type</span> IntersectionTypeConfict = { id: <span class=\"hljs-built_in\">number</span>; name: <span class=\"hljs-built_in\">string</span>; } \n    &amp; { age: <span class=\"hljs-built_in\">number</span>; name: <span class=\"hljs-built_in\">number</span>; };\n  <span class=\"hljs-keyword\">const</span> mixedConflict: IntersectionTypeConfict = {\n    id: <span class=\"hljs-number\">1</span>,\n    name: <span class=\"hljs-number\">2</span>, <span class=\"hljs-comment\">// ts(2322) 错误，'number' 类型不能赋给 'never' 类型</span>\n    age: <span class=\"hljs-number\">2</span>\n  };\n</code></pre>\n<p data-nodeid=\"2660\">此时，我们赋予 mixedConflict 任意类型的 name 属性值都会提示类型错误。而如果我们不设置 name 属性，又会提示一个缺少必选的 name 属性的错误。在这种情况下，就意味着上述代码中交叉出来的 IntersectionTypeConfict 类型是一个无用类型。</p>\n<p data-nodeid=\"2661\">如果同名属性的类型兼容，比如一个是 number，另一个是 number 的子类型、数字字面量类型，合并后 name 属性的类型就是两者中的子类型。</p>\n<p data-nodeid=\"2662\">如下所示示例中 name 属性的类型就是数字字面量类型 2，因此，我们不能把任何非 2 之外的值赋予 name 属性。</p>\n<pre class=\"lang-typescript\" data-nodeid=\"2663\"><code data-language=\"typescript\">  <span class=\"hljs-keyword\">type</span> IntersectionTypeConfict = { id: <span class=\"hljs-built_in\">number</span>; name: <span class=\"hljs-number\">2</span>; } \n  &amp; { age: <span class=\"hljs-built_in\">number</span>; name: <span class=\"hljs-built_in\">number</span>; };\n  <span class=\"hljs-keyword\">let</span> mixedConflict: IntersectionTypeConfict = {\n    id: <span class=\"hljs-number\">1</span>,\n    name: <span class=\"hljs-number\">2</span>, <span class=\"hljs-comment\">// ok</span>\n    age: <span class=\"hljs-number\">2</span>\n  };\n  mixedConflict = {\n    id: <span class=\"hljs-number\">1</span>,\n    name: <span class=\"hljs-number\">22</span>, <span class=\"hljs-comment\">// '22' 类型不能赋给 '2' 类型</span>\n    age: <span class=\"hljs-number\">2</span>\n  };\n</code></pre>\n<h4 data-nodeid=\"2664\">合并联合类型</h4>\n<p data-nodeid=\"2665\">另外，我们可以合并联合类型为一个交叉类型，这个交叉类型需要同时满足不同的联合类型限制，也就是提取了所有联合类型的相同类型成员。这里，我们也可以将合并联合类型理解为求交集。</p>\n<p data-nodeid=\"2666\">在如下示例中，两个联合类型交叉出来的类型 IntersectionUnion 其实等价于 'em' | 'rem'，所以我们只能把 'em' 或者 'rem' 字符串赋值给 IntersectionUnion 类型的变量。</p>\n<pre class=\"lang-typescript\" data-nodeid=\"2667\"><code data-language=\"typescript\">  <span class=\"hljs-keyword\">type</span> UnionA = <span class=\"hljs-string\">'px'</span> | <span class=\"hljs-string\">'em'</span> | <span class=\"hljs-string\">'rem'</span> | <span class=\"hljs-string\">'%'</span>;\n  <span class=\"hljs-keyword\">type</span> UnionB = <span class=\"hljs-string\">'vh'</span> | <span class=\"hljs-string\">'em'</span> | <span class=\"hljs-string\">'rem'</span> | <span class=\"hljs-string\">'pt'</span>;\n  <span class=\"hljs-keyword\">type</span> IntersectionUnion = UnionA &amp; UnionB;\n  <span class=\"hljs-keyword\">const</span> intersectionA: IntersectionUnion = <span class=\"hljs-string\">'em'</span>; <span class=\"hljs-comment\">// ok</span>\n  <span class=\"hljs-keyword\">const</span> intersectionB: IntersectionUnion = <span class=\"hljs-string\">'rem'</span>; <span class=\"hljs-comment\">// ok</span>\n  <span class=\"hljs-keyword\">const</span> intersectionC: IntersectionUnion = <span class=\"hljs-string\">'px'</span>; <span class=\"hljs-comment\">// ts(2322)</span>\n  <span class=\"hljs-keyword\">const</span> intersectionD: IntersectionUnion = <span class=\"hljs-string\">'pt'</span>; <span class=\"hljs-comment\">// ts(2322)</span>\n</code></pre>\n<p data-nodeid=\"2668\">既然是求交集，如果多个联合类型中没有相同的类型成员，交叉出来的类型自然就是 never 了，如下代码所示：</p>\n<pre class=\"lang-typescript\" data-nodeid=\"2669\"><code data-language=\"typescript\">  <span class=\"hljs-keyword\">type</span> UnionC = <span class=\"hljs-string\">'em'</span> | <span class=\"hljs-string\">'rem'</span>;\n  <span class=\"hljs-keyword\">type</span> UnionD = <span class=\"hljs-string\">'px'</span> | <span class=\"hljs-string\">'pt'</span>;\n  <span class=\"hljs-keyword\">type</span> IntersectionUnionE = UnionC &amp; UnionD;\n  <span class=\"hljs-keyword\">const</span> intersectionE: IntersectionUnionE = <span class=\"hljs-string\">'any'</span> <span class=\"hljs-keyword\">as</span> <span class=\"hljs-built_in\">any</span>; <span class=\"hljs-comment\">// ts(2322) 不能赋予 'never' 类型</span>\n</code></pre>\n<p data-nodeid=\"2670\">在上述示例中，因为 UnionC 和 UnionD 没有交集，交叉出来的类型 IntersectionUnionE 就是 never，所以我们不能把任何类型的值赋予 IntersectionUnionE 类型的变量。</p>\n<h3 data-nodeid=\"2671\">联合、交叉组合</h3>\n<p data-nodeid=\"2672\">在前面的示例中，我们把一些联合、交叉类型抽离成了类型别名，再把它作为原子类型进行进一步的联合、交叉。其实，联合、交叉类型本身就可以直接组合使用，这就涉及 |、&amp; 操作符的优先级问题。实际上，联合、交叉运算符不仅在行为上表现一致，还在运算的优先级和 JavaScript 的逻辑或 ||、逻辑与 &amp;&amp; 运算符上表现一致 。</p>\n<p data-nodeid=\"2673\">联合操作符 | 的优先级低于交叉操作符 &amp;，同样，我们可以通过使用小括弧 () 来调整操作符的优先级。</p>\n<pre class=\"lang-typescript\" data-nodeid=\"2674\"><code data-language=\"typescript\">  <span class=\"hljs-keyword\">type</span> UnionIntersectionA = { id: <span class=\"hljs-built_in\">number</span>; } &amp; { name: <span class=\"hljs-built_in\">string</span>; } | { id: <span class=\"hljs-built_in\">string</span>; } &amp; { name: <span class=\"hljs-built_in\">number</span>; }; <span class=\"hljs-comment\">// 交叉操作符优先级高于联合操作符</span>\n  <span class=\"hljs-keyword\">type</span> UnionIntersectionB = (<span class=\"hljs-string\">'px'</span> | <span class=\"hljs-string\">'em'</span> | <span class=\"hljs-string\">'rem'</span> | <span class=\"hljs-string\">'%'</span>) | (<span class=\"hljs-string\">'vh'</span> | <span class=\"hljs-string\">'em'</span> | <span class=\"hljs-string\">'rem'</span> | <span class=\"hljs-string\">'pt'</span>); <span class=\"hljs-comment\">// 调整优先级</span>\n</code></pre>\n<p data-nodeid=\"2675\">进而，我们也可以把分配率、交换律等基本规则引入类型组合中，然后优化出更简洁、清晰的类型，如下代码所示：</p>\n<pre class=\"lang-typescript\" data-nodeid=\"2676\"><code data-language=\"typescript\">  <span class=\"hljs-keyword\">type</span> UnionIntersectionC = ({ id: <span class=\"hljs-built_in\">number</span>; } &amp; { name: <span class=\"hljs-built_in\">string</span>; } | { id: <span class=\"hljs-built_in\">string</span>; }) &amp; { name: <span class=\"hljs-built_in\">number</span>; };\n  <span class=\"hljs-keyword\">type</span> UnionIntersectionD = { id: <span class=\"hljs-built_in\">number</span>; } &amp; { name: <span class=\"hljs-built_in\">string</span>; } &amp; { name: <span class=\"hljs-built_in\">number</span>; } | { id: <span class=\"hljs-built_in\">string</span>; } &amp; { name: <span class=\"hljs-built_in\">number</span>; }; <span class=\"hljs-comment\">// 满足分配率</span>\n  <span class=\"hljs-keyword\">type</span> UnionIntersectionE = ({ id: <span class=\"hljs-built_in\">string</span>; } | { id: <span class=\"hljs-built_in\">number</span>; } &amp; { name: <span class=\"hljs-built_in\">string</span>; }) &amp; { name: <span class=\"hljs-built_in\">number</span>; }; <span class=\"hljs-comment\">// 满足交换律</span>\n</code></pre>\n<p data-nodeid=\"2677\">在上述代码中，第 2 行是在第 1 行的基础上进行展开，说明 &amp; 满足分配率；第 3 行则是在第 1 行的基础上调整了成员的顺序，说明 | 操作满足交换律。</p>\n<h3 data-nodeid=\"2678\">类型缩减</h3>\n<p data-nodeid=\"2679\">这里呼应一下在介绍联合类型时埋下的伏笔：如果将 string 原始类型和“string字面量类型”组合成联合类型会是什么效果？效果就是类型缩减成 string 了。</p>\n<p data-nodeid=\"2680\">同样，对于 number、boolean（其实还有枚举类型，详见第 9 讲）也是一样的缩减逻辑，如下所示示例：</p>\n<pre class=\"lang-typescript\" data-nodeid=\"2681\"><code data-language=\"typescript\">  <span class=\"hljs-keyword\">type</span> URStr = <span class=\"hljs-string\">'string'</span> | <span class=\"hljs-built_in\">string</span>; <span class=\"hljs-comment\">// 类型是 string</span>\n  <span class=\"hljs-keyword\">type</span> URNum = <span class=\"hljs-number\">2</span> | <span class=\"hljs-built_in\">number</span>; <span class=\"hljs-comment\">// 类型是 number</span>\n  <span class=\"hljs-keyword\">type</span> URBoolen = <span class=\"hljs-literal\">true</span> | <span class=\"hljs-built_in\">boolean</span>; <span class=\"hljs-comment\">// 类型是 boolean</span>\n  <span class=\"hljs-keyword\">enum</span> EnumUR {\n    ONE,\n    TWO\n  }\n  <span class=\"hljs-keyword\">type</span> URE = EnumUR.ONE | EnumUR; <span class=\"hljs-comment\">// 类型是 EnumUR</span>\n</code></pre>\n<p data-nodeid=\"2682\">TypeScript 对这样的场景做了缩减，它把字面量类型、枚举成员类型缩减掉，只保留原始类型、枚举类型等父类型，这是合理的“优化”。</p>\n<p data-nodeid=\"2683\">可是这个缩减，却极大地削弱了 IDE 自动提示的能力，如下代码所示：</p>\n<pre class=\"lang-typescript\" data-nodeid=\"2684\"><code data-language=\"typescript\">  <span class=\"hljs-keyword\">type</span> BorderColor = <span class=\"hljs-string\">'black'</span> | <span class=\"hljs-string\">'red'</span> | <span class=\"hljs-string\">'green'</span> | <span class=\"hljs-string\">'yellow'</span> | <span class=\"hljs-string\">'blue'</span> | <span class=\"hljs-built_in\">string</span>; <span class=\"hljs-comment\">// 类型缩减成 string</span>\n</code></pre>\n<p data-nodeid=\"2685\">在上述代码中，我们希望 IDE 能自动提示显示注解的字符串字面量，但是因为类型被缩减成 string，所有的字符串字面量 black、red 等都无法自动提示出来了。<br>\n不要慌，TypeScript 官方其实还提供了一个黑魔法，它可以让类型缩减被控制。如下代码所示，我们只需要给父类型添加“&amp; {}”即可。</p>\n<pre class=\"lang-typescript\" data-nodeid=\"2686\"><code data-language=\"typescript\">  <span class=\"hljs-keyword\">type</span> BorderColor = <span class=\"hljs-string\">'black'</span> | <span class=\"hljs-string\">'red'</span> | <span class=\"hljs-string\">'green'</span> | <span class=\"hljs-string\">'yellow'</span> | <span class=\"hljs-string\">'blue'</span> | <span class=\"hljs-built_in\">string</span> &amp; {}; <span class=\"hljs-comment\">// 字面类型都被保留</span>\n</code></pre>\n<p data-nodeid=\"4268\" class=\"te-preview-highlight\"><img src=\"https://s0.lgstatic.com/i/image6/M01/41/AB/Cgp9HWCtuN2AaTQhAAIsKJ6nHYA767.png\" alt=\"图片1.png\" data-nodeid=\"4272\"></p>\n<div data-nodeid=\"4269\"><p style=\"text-align:center\">VS Code 自动提示效果图</p></div>\n\n\n\n\n\n\n<p data-nodeid=\"2689\">此时，其他字面量类型就不会被缩减掉了，在 IDE 中字符串字面量 black、red 等也就自然地可以自动提示出来了。</p>\n<p data-nodeid=\"2690\">此外，当联合类型的成员是接口类型，如果满足其中一个接口的属性是另外一个接口属性的子集，这个属性也会类型缩减，如下代码所示：</p>\n<pre class=\"lang-typescript\" data-nodeid=\"2691\"><code data-language=\"typescript\">  <span class=\"hljs-keyword\">type</span> UnionInterce =\n  | {\n      age: <span class=\"hljs-string\">'1'</span>;\n    }\n  | ({\n      age: <span class=\"hljs-string\">'1'</span> | <span class=\"hljs-string\">'2'</span>;\n      [key: <span class=\"hljs-built_in\">string</span>]: <span class=\"hljs-built_in\">string</span>;\n    });\n</code></pre>\n<p data-nodeid=\"2692\">这里因为 '1' 是 '1' | '2' 的子集，所以 age 的属性变成 '1' | '2'：</p>\n<p data-nodeid=\"2693\">利用这个特性，我们来实现 07 讲中埋下的那个伏笔，如何定义如下所示 age 属性是数字类型，而其他不确定的属性是字符串类型的数据结构的对象？</p>\n<pre class=\"lang-javascript\" data-nodeid=\"2694\"><code data-language=\"javascript\">{\n  <span class=\"hljs-attr\">age</span>: <span class=\"hljs-number\">1</span>, <span class=\"hljs-comment\">// 数字类型</span>\n  <span class=\"hljs-attr\">anyProperty</span>: <span class=\"hljs-string\">'str'</span>, <span class=\"hljs-comment\">// 其他不确定的属性都是字符串类型</span>\n  ...\n}\n</code></pre>\n<p data-nodeid=\"2695\">在这里提到这个伏笔，想必你应该明白了，我们肯定要用到两个接口的联合类型及类型缩减，这个问题的核心在于找到一个既是 number 的子类型，这样 age 类型缩减之后的类型就是 number；同时也是 string 的子类型，这样才能满足属性和 string 索引类型的约束关系。</p>\n<p data-nodeid=\"2696\">哪个类型满足这个条件呢？我们一起回忆一下 02 讲中介绍的特殊类型 never。</p>\n<p data-nodeid=\"2697\">never 有一个特性是它是所有类型的子类型，自然也是 number 和 string 的子类型，所以答案如下代码所示：</p>\n<pre class=\"lang-typescript\" data-nodeid=\"2698\"><code data-language=\"typescript\">  <span class=\"hljs-keyword\">type</span> UnionInterce =\n  | {\n      age: <span class=\"hljs-built_in\">number</span>;\n    }\n  | ({\n      age: never;\n      [key: <span class=\"hljs-built_in\">string</span>]: <span class=\"hljs-built_in\">string</span>;\n    });\n  <span class=\"hljs-keyword\">const</span> O: UnionInterce = {\n    age: <span class=\"hljs-number\">2</span>,\n    <span class=\"hljs-built_in\">string</span>: <span class=\"hljs-string\">'string'</span>\n  };\n</code></pre>\n<p data-nodeid=\"2699\">在上述代码中，我们在第 3 行定义了 number 类型的 age 属性，第 6 行定义了 never 类型的 age 属性，等价于 age 属性的类型是由 number 和 never 类型组成的联合类型，所以我们可以把 number 类型的值（比如说数字字面量 1）赋予 age 属性；但是不能把其他任何类型的值（比如说字符串字面量 'string' ）赋予 age。</p>\n<p data-nodeid=\"2700\">同时，我们在第 5 行~第 8 行定义的接口类型中，还额外定义了 string 类型的字符串索引签名。因为 never 同时又是 string 类型的子类型，所以 age 属性的类型和字符串索引签名类型不冲突。如第 9 行~第 12 行所示，我们可以把一个 age 属性是 2、string 属性是 'string' 的对象字面量赋值给 UnionInterce 类型的变量 O。</p>\n<h3 data-nodeid=\"2701\">小结与预告</h3>\n<p data-nodeid=\"2702\">这一讲中介绍的联合和交叉类型赋予了 TypeScript 类型最基本的“编程”（运算）能力，学习和掌握联合和交叉类型后，可以培养我们抽离、复用公共类型的意识和能力。</p>\n<p data-nodeid=\"2703\">插播一个思考题：在联合类型中，类型缩减的规则是什么？欢迎你在留言区与我进行交流、互动。</p>\n<p data-nodeid=\"2704\">09 讲我们将介绍如何定义常量集合的方法——枚举类型，敬请期待~</p>\n<p data-nodeid=\"2705\" class=\"\">另外，如果你觉得本专栏有价值，欢迎分享给更多好友。</p>",
                "article_title": "08 | 高级类型：如何快速读懂联合类型和交叉类型的含义？",
                "title": "08 | 高级类型：如何快速读懂联合类型和交叉类型的含义？",
                "id": 7440
            },
            {
                "content": "<p data-nodeid=\"14018\">08 讲我们介绍了联合和交叉类型，其中有一个使用字面量联合类型来列举可能的类型（间接列举值）的场景，比如说表示星期的类型：</p>\n<pre class=\"lang-typescript\" data-nodeid=\"14019\"><code data-language=\"typescript\">  <span class=\"hljs-keyword\">type</span> Day = <span class=\"hljs-string\">'SUNDAY'</span> | <span class=\"hljs-string\">'MONDAY'</span> | <span class=\"hljs-string\">'TUESDAY'</span> | <span class=\"hljs-string\">'WEDNESDAY'</span> | <span class=\"hljs-string\">'THURSDAY'</span> | <span class=\"hljs-string\">'FRIDAY'</span> | <span class=\"hljs-string\">'SATURDAY'</span>;\n  <span class=\"hljs-keyword\">const</span> SUNDAY: Day = <span class=\"hljs-string\">'SUNDAY'</span>;\n  <span class=\"hljs-keyword\">const</span> SATURDAY: Day = <span class=\"hljs-string\">'SATURDAY'</span>;\n</code></pre>\n<p data-nodeid=\"14020\">通过这些有着明确含义的单词来定义表示星期几的状态，使得我们的代码更具备可读性。</p>\n<p data-nodeid=\"14021\">当然，为了更简洁和高效，我们也可以使用纯数值表示星期几，比如使用 0 到 1 表示从 'SUNDAY' 到 'MONDAY'。因为我们真正关注的是星期几这个状态，而不是具体的值，如下代码所示：</p>\n<pre class=\"lang-typescript\" data-nodeid=\"14022\"><code data-language=\"typescript\"><span class=\"hljs-keyword\">type</span> Day = <span class=\"hljs-number\">0</span> | <span class=\"hljs-number\">1</span> | <span class=\"hljs-number\">2</span> | <span class=\"hljs-number\">3</span> | <span class=\"hljs-number\">4</span> | <span class=\"hljs-number\">5</span> | <span class=\"hljs-number\">6</span>;\n</code></pre>\n<p data-nodeid=\"14023\">那有没有一种兼具语义化和简洁值优点的类型呢？在 C/C++/C# 中有能满足这个诉求的类型，它就是枚举（Enums），用来表示一个被命名的整型常数的集合。</p>\n<blockquote data-nodeid=\"14024\">\n<p data-nodeid=\"14025\">学习建议：请使用 VS Code 新建一个 09.ts 文件，尝试这一讲中的所有示例。</p>\n</blockquote>\n<h3 data-nodeid=\"14026\">枚举类型</h3>\n<p data-nodeid=\"14027\">在 JavaScript 原生语言中并没有与枚举匹配的概念，而 TypeScript 中实现了枚举类型（Enums），这就意味着枚举也是 TypeScript 特有的语法（相对于 JavaScript）。</p>\n<p data-nodeid=\"14028\">在 TypeScript 中，我们可以使用枚举定义包含被命名的常量的集合，比如 TypeScript 支持数字、字符两种常量值的枚举类型。</p>\n<p data-nodeid=\"14029\">我们也可以使用 enum 关键字定义枚举类型，格式是 enum + 枚举名字 + 一对花括弧，花括弧里则是被命名了的常量成员。</p>\n<p data-nodeid=\"14030\">下面我们把前边表示星期的联合类型示例使用枚举类型实现一遍，如下代码所示：</p>\n<pre class=\"lang-typescript\" data-nodeid=\"14031\"><code data-language=\"typescript\">  <span class=\"hljs-keyword\">enum</span> Day {\n    SUNDAY,\n    MONDAY,\n    TUESDAY,\n    WEDNESDAY,\n    THURSDAY,\n    FRIDAY,\n    SATURDAY\n  }  \n</code></pre>\n<blockquote data-nodeid=\"14032\">\n<p data-nodeid=\"14033\"><strong data-nodeid=\"14172\">注意</strong>：相对于其他类型，enum 也是一种比较特殊的类型，因为它兼具值和类型于一体，有点类似 class（在定义 class 结构时， 其实我们也自动定义了 class 实例的类型）。</p>\n</blockquote>\n<p data-nodeid=\"14034\">在上述示例中，Day 既可以表示集合，也可以表示集合的类型，所有成员（enum member）的类型都是 Day 的子类型。</p>\n<p data-nodeid=\"14035\">前边我们说过，JavaScript 中其实并没有与枚举类型对应的原始实现，而 TypeScript 转译器会把枚举类型转译为一个属性为常量、命名值从 0 开始递增数字映射的对象，在功能层面达到与枚举一致的效果（然而不是所有的特性在 JavaScript 中都有对应的实现）。</p>\n<p data-nodeid=\"14036\">下面我们通过如下所示示例看看将如上示例转译为 JavaScript 后的效果。</p>\n<pre class=\"lang-javascript\" data-nodeid=\"14037\"><code data-language=\"javascript\">    <span class=\"hljs-keyword\">var</span> Day = <span class=\"hljs-keyword\">void</span> <span class=\"hljs-number\">0</span>;\n    (<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">Day</span>) </span>{\n        Day[Day[<span class=\"hljs-string\">\"SUNDAY\"</span>] = <span class=\"hljs-number\">0</span>] = <span class=\"hljs-string\">\"SUNDAY\"</span>;\n        Day[Day[<span class=\"hljs-string\">\"MONDAY\"</span>] = <span class=\"hljs-number\">1</span>] = <span class=\"hljs-string\">\"MONDAY\"</span>;\n        Day[Day[<span class=\"hljs-string\">\"TUESDAY\"</span>] = <span class=\"hljs-number\">2</span>] = <span class=\"hljs-string\">\"TUESDAY\"</span>;\n        Day[Day[<span class=\"hljs-string\">\"WEDNESDAY\"</span>] = <span class=\"hljs-number\">3</span>] = <span class=\"hljs-string\">\"WEDNESDAY\"</span>;\n        Day[Day[<span class=\"hljs-string\">\"THURSDAY\"</span>] = <span class=\"hljs-number\">4</span>] = <span class=\"hljs-string\">\"THURSDAY\"</span>;\n        Day[Day[<span class=\"hljs-string\">\"FRIDAY\"</span>] = <span class=\"hljs-number\">5</span>] = <span class=\"hljs-string\">\"FRIDAY\"</span>;\n        Day[Day[<span class=\"hljs-string\">\"SATURDAY\"</span>] = <span class=\"hljs-number\">6</span>] = <span class=\"hljs-string\">\"SATURDAY\"</span>;\n    })(Day || (Day = {}));\n</code></pre>\n<p data-nodeid=\"14038\">我们可以看到 Day.SUNDAY 被赋予 0 作为值，Day.SATURDAY 被赋予 6 作为值。</p>\n<p data-nodeid=\"14039\">在 TypeScript 中，我们可以通过“枚举名字.常量命名”的格式获取枚举集合里的成员，如下代码所示：</p>\n<pre class=\"lang-typescript\" data-nodeid=\"14040\"><code data-language=\"typescript\">  <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">work</span>(<span class=\"hljs-params\">d: Day</span>) </span>{\n    <span class=\"hljs-keyword\">switch</span> (d) {\n      <span class=\"hljs-keyword\">case</span> Day.SUNDAY:\n      <span class=\"hljs-keyword\">case</span> Day.SATURDAY:\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">'take a rest'</span>;\n      <span class=\"hljs-keyword\">case</span> Day.MONDAY:\n      <span class=\"hljs-keyword\">case</span> Day.TUESDAY:\n      <span class=\"hljs-keyword\">case</span> Day.WEDNESDAY:\n      <span class=\"hljs-keyword\">case</span> Day.THURSDAY:\n      <span class=\"hljs-keyword\">case</span> Day.FRIDAY:\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">'work hard'</span>;\n    }\n  }\n</code></pre>\n<p data-nodeid=\"14041\">示例中的第 3 行到第 10 行，我们通过 Day.SUNDAY 这样的格式就可以访问枚举的所有成员了。 上面示例中的 work 函数转译为 JavaScript 后，里面的 switch 分支运行时的效果实际上等价于如下所示代码：</p>\n<pre class=\"lang-javascript\" data-nodeid=\"14042\"><code data-language=\"javascript\">    ...\n    switch (d) {\n      <span class=\"hljs-keyword\">case</span> <span class=\"hljs-number\">0</span>:\n      <span class=\"hljs-keyword\">case</span> <span class=\"hljs-number\">1</span>:\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">'take a rest'</span>;\n      <span class=\"hljs-keyword\">case</span> <span class=\"hljs-number\">2</span>:\n      <span class=\"hljs-keyword\">case</span> <span class=\"hljs-number\">3</span>:\n      <span class=\"hljs-keyword\">case</span> <span class=\"hljs-number\">4</span>:\n      <span class=\"hljs-keyword\">case</span> <span class=\"hljs-number\">5</span>:\n      <span class=\"hljs-keyword\">case</span> <span class=\"hljs-number\">6</span>:\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">'work hard'</span>;\n    }\n    ...\n</code></pre>\n<p data-nodeid=\"14043\">这就意味着在 JavaScript 中调用 work 函数时，传递的参数无论是 enum 还是数值，逻辑上将没有区别，当然这也符合 TypeScript 静态类型检测规则，如下代码所示：</p>\n<pre class=\"lang-typescript\" data-nodeid=\"14044\"><code data-language=\"typescript\">  work(Day.SUNDAY); <span class=\"hljs-comment\">// ok</span>\n  work(<span class=\"hljs-number\">0</span>); <span class=\"hljs-comment\">// ok</span>\n</code></pre>\n<p data-nodeid=\"14045\">这里我们既可以把枚举成员 Day.SUNDAY 作为 work 函数的入参，也可以把数字字面量 0 作为 work 函数的入参。</p>\n<p data-nodeid=\"14046\">下面我们就来详细介绍一下 7 种常见的枚举类型：<strong data-nodeid=\"14185\">数字类型、字符串类型、异构类型、常量成员和计算（值）成员、枚举成员类型和联合枚举、常量枚举、外部枚举。</strong></p>\n<h4 data-nodeid=\"14047\">数字枚举</h4>\n<p data-nodeid=\"14048\">从上边示例可知，在仅仅指定常量命名的情况下，我们定义的就是一个默认从 0 开始递增的数字集合，称之为数字枚举。</p>\n<p data-nodeid=\"14049\">如果我们希望枚举值从其他值开始递增，则可以通过“常量命名 = 数值” 的格式显示指定枚举成员的初始值，如下代码所示：</p>\n<pre class=\"lang-typescript\" data-nodeid=\"14050\"><code data-language=\"typescript\">  <span class=\"hljs-keyword\">enum</span> Day {\n    SUNDAY = <span class=\"hljs-number\">1</span>,\n    MONDAY,\n    TUESDAY,\n    WEDNESDAY,\n    THURSDAY,\n    FRIDAY,\n    SATURDAY\n  }\n</code></pre>\n<p data-nodeid=\"14051\">在上述示例中，我们指定了从 1 开始递增。</p>\n<p data-nodeid=\"14052\">事实上，我们可以给 SUNDAY 指定任意类型（比如整数、负数、小数等）、任意起始的数字，其后未显示指定值的成员会递增加 1。上边的示例转译为 JavaScript 之后，则是一个属性值从 1 开始递增的对象，如下代码所示：</p>\n<pre class=\"lang-javascript\" data-nodeid=\"14053\"><code data-language=\"javascript\">    <span class=\"hljs-keyword\">var</span> Day = <span class=\"hljs-keyword\">void</span> <span class=\"hljs-number\">0</span>;\n    (<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">MyDay</span>) </span>{\n        Day[Day[<span class=\"hljs-string\">\"SUNDAY\"</span>] = <span class=\"hljs-number\">1</span>] = <span class=\"hljs-string\">\"SUNDAY\"</span>;\n        Day[Day[<span class=\"hljs-string\">\"MONDAY\"</span>] = <span class=\"hljs-number\">2</span>] = <span class=\"hljs-string\">\"MONDAY\"</span>;\n        ...\n        Day[Day[<span class=\"hljs-string\">\"SATURDAY\"</span>] = <span class=\"hljs-number\">7</span>] = <span class=\"hljs-string\">\"SATURDAY\"</span>;\n    })(Day || (Day = {}));\n</code></pre>\n<p data-nodeid=\"14054\">这里 Day.SUNDAY 被赋予了 1 作为值，Day.SATURDAY 则被赋予了 7 作为值。</p>\n<p data-nodeid=\"14055\">当然我们也可以给任意位置的成员指定值，如下所示示例：</p>\n<pre class=\"lang-typescript\" data-nodeid=\"14056\"><code data-language=\"typescript\">  <span class=\"hljs-keyword\">enum</span> Day {\n    SUNDAY,\n    MONDAY,\n    TUESDAY,\n    WEDNESDAY,\n    THURSDAY,\n    FRIDAY,\n    SATURDAY = <span class=\"hljs-number\">5</span>\n  } \n</code></pre>\n<p data-nodeid=\"14057\">这里我们给最后一个成员 SATURDAY 指定了初始值 5，但转译后的结果就比较尴尬了，如下代码所示：</p>\n<pre class=\"lang-javascript\" data-nodeid=\"14058\"><code data-language=\"javascript\">  ...\n        Day[Day[<span class=\"hljs-string\">\"FRIDAY\"</span>] = <span class=\"hljs-number\">5</span>] = <span class=\"hljs-string\">\"FRIDAY\"</span>;\n        Day[Day[<span class=\"hljs-string\">\"SATURDAY\"</span>] = <span class=\"hljs-number\">5</span>] = <span class=\"hljs-string\">\"SATURDAY\"</span>;\n  ...\n</code></pre>\n<p data-nodeid=\"14059\">我们可以看到 MyDay.FRIDAY 和 MyDay.SATURDAY 的值都是数字 5，这就导致使用 Day 枚举作为 switch 分支条件的函数 work，在接收 MyDay.SATURDAY 作为入参时，也会进入 MyDay.FRIDAY 的分支，从而出现逻辑错误。</p>\n<p data-nodeid=\"14060\">这个经验告诉我们，由于枚举默认的值自递增且完全无法保证稳定性，所以给部分数字类型的枚举成员显式指定数值或给函数传递数值而不是枚举类型作为入参都属于不明智的行为，如下代码所示：</p>\n<pre class=\"lang-typescript\" data-nodeid=\"14061\"><code data-language=\"typescript\">  <span class=\"hljs-keyword\">enum</span> Day {\n    ...\n    SATURDAY = <span class=\"hljs-number\">5</span> <span class=\"hljs-comment\">// bad</span>\n  } \n  work(<span class=\"hljs-number\">5</span>); <span class=\"hljs-comment\">// bad</span>\n</code></pre>\n<p data-nodeid=\"14062\">此外，常量命名、结构顺序都一致的两个枚举，即便转译为 JavaScript 后，同名成员的值仍然一样（满足恒等 === ）。但在 TypeScript 看来，它们不相同、不满足恒等，如下代码所示：</p>\n<pre class=\"lang-typescript\" data-nodeid=\"14063\"><code data-language=\"typescript\">  <span class=\"hljs-keyword\">enum</span> MyDay {\n    SUNDAY,\n    ...\n  } \n  \n  Day.SUNDAY === MyDay.SUNDAY; <span class=\"hljs-comment\">// ts(2367) 两个枚举值恒不相等</span>\n  work(MyDay.SUNDAY); <span class=\"hljs-comment\">// ts(2345) 'MyDay.SUNDAY' 不能赋予 'Day'</span>\n</code></pre>\n<p data-nodeid=\"14064\">这里的 MyDay 和上边的 Day 看似一样，但是如果我们拿 MyDay 和 Day 的成员进行比较（第 6 行），或者把 MyDay 传值给形参是 Day 类型的 work 函数（第 7 行），就会发现都会提示错误。</p>\n<p data-nodeid=\"14065\">不仅仅是数字类型枚举，所有其他枚举都仅和自身兼容，这就消除了由于枚举不稳定性可能造成的风险，所以这是一种极其安全的设计。不过，这可能会使得枚举变得不那么好用，因为不同枚举之间完全不兼容，所以不少 TypeScript 编程人员觉得枚举类型是一种十分鸡肋的类型。而两个结构完全一样的枚举类型如果互相兼容，则会更符合我们的预期，比如说基于 Swagger 自动生成的不同模块中结构相同且描述同一个常量集合的多个同名枚举。</p>\n<p data-nodeid=\"14066\">不过，此时我们可能不得不使用类型断言（as）或者重构代码将“相同“的枚举类型抽离为同一个公共的枚举（我们更推荐后者）。</p>\n<h4 data-nodeid=\"14067\">字符串枚举</h4>\n<p data-nodeid=\"14068\">在 TypeScript 中，我们将定义值是字符串字面量的枚举称之为字符串枚举，字符串枚举转译为 JavaScript 之后也将保持这些值，我们来看下如下所示示例：</p>\n<pre class=\"lang-typescript\" data-nodeid=\"14069\"><code data-language=\"typescript\">  <span class=\"hljs-keyword\">enum</span> Day {\n    SUNDAY = <span class=\"hljs-string\">'SUNDAY'</span>,\n    MONDAY = <span class=\"hljs-string\">'MONDAY'</span>,\n    ...\n  }\n</code></pre>\n<p data-nodeid=\"14070\">这里我们定义了成员 SUNDAY 的值是 'SUNDAY'、MONDAY 的值是 'MONDAY'。</p>\n<p data-nodeid=\"14071\">而上述示例转译为 JavaScript 后，Day.SUNDAY 的值依旧是 'SUNDAY'，Day.MONDAY 的值依旧是 'MONDAY'，如下代码所示：</p>\n<pre class=\"lang-javascript\" data-nodeid=\"14072\"><code data-language=\"javascript\">    <span class=\"hljs-keyword\">var</span> Day = <span class=\"hljs-keyword\">void</span> <span class=\"hljs-number\">0</span>;\n    (<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">Day</span>) </span>{\n        Day[<span class=\"hljs-string\">\"SUNDAY\"</span>] = <span class=\"hljs-string\">\"SUNDAY\"</span>;\n        Day[<span class=\"hljs-string\">\"MONDAY\"</span>] = <span class=\"hljs-string\">\"MONDAY\"</span>;\n    })(Day || (Day = {}));\n</code></pre>\n<p data-nodeid=\"14073\">相比于没有明确意义的递增值的数字枚举，字符串枚举的成员在运行和调试阶段，更具备明确的含义和可读性，枚举成员的值就是我们显式指定的字符串字面量。</p>\n<h4 data-nodeid=\"14074\">异构枚举（Heterogeneous enums）</h4>\n<p data-nodeid=\"14075\">从技术上来讲，TypeScript 支持枚举类型同时拥有数字和字符类型的成员，这样的枚举被称之为异构枚举。</p>\n<p data-nodeid=\"14076\">当然，异构枚举也被认为是很“鸡肋”的类型。比如如下示例中，我们定义了成员 SUNDAY 是 'SUNDAY'、MONDAY 是 2，很抱歉，我也不知道这样的枚举能在哪些有用的场合进行使用。</p>\n<pre class=\"lang-typescript\" data-nodeid=\"14077\"><code data-language=\"typescript\">  <span class=\"hljs-keyword\">enum</span> Day {\n    SUNDAY = <span class=\"hljs-string\">'SUNDAY'</span>,\n    MONDAY = <span class=\"hljs-number\">2</span>,\n    ...\n  }\n</code></pre>\n<p data-nodeid=\"14078\">枚举成员的值既可以是数字、字符串这样的常量，也可以是通过表达式所计算出来的值。这就涉及枚举里成员的一个分类，即常量成员和计算成员。</p>\n<h4 data-nodeid=\"14079\">常量成员和计算（值）成员</h4>\n<p data-nodeid=\"14080\">在前边示例中，涉及的枚举成员的值都是字符串、数字字面量和未指定初始值从 0 递增数字常量，都被称作常量成员。</p>\n<p data-nodeid=\"14081\">另外，在转译时，通过被计算的常量枚举表达式定义值的成员，也被称作常量成员，比如如下几种情况：</p>\n<ul data-nodeid=\"14082\">\n<li data-nodeid=\"14083\">\n<p data-nodeid=\"14084\">引用来自预先定义的常量成员，比如来自当前枚举或其他枚举；</p>\n</li>\n<li data-nodeid=\"14085\">\n<p data-nodeid=\"14086\">圆括弧 () 包裹的常量枚举表达式；</p>\n</li>\n<li data-nodeid=\"14087\">\n<p data-nodeid=\"14088\">在常量枚举表达式上应用的一元操作符 +、 -、~ ；</p>\n</li>\n<li data-nodeid=\"14089\">\n<p data-nodeid=\"14090\">操作常量枚举表达式的二元操作符 +、-、*、/、%、&lt;&lt;、&gt;&gt;、&gt;&gt;&gt;、&amp;、|、^。</p>\n</li>\n</ul>\n<p data-nodeid=\"14091\">除以上这些情况之外，其他都被认为是计算（值）成员。</p>\n<p data-nodeid=\"14092\">如下所示示例（援引自官方示例）中，除了 G 是计算成员之外，其他都属于常量成员。</p>\n<pre class=\"lang-typescript\" data-nodeid=\"14093\"><code data-language=\"typescript\">  <span class=\"hljs-keyword\">enum</span> FileAccess {\n    <span class=\"hljs-comment\">// 常量成员</span>\n    None,\n    Read = <span class=\"hljs-number\">1</span> &lt;&lt; <span class=\"hljs-number\">1</span>,\n    Write = <span class=\"hljs-number\">1</span> &lt;&lt; <span class=\"hljs-number\">2</span>,\n    ReadWrite = Read | Write,\n    <span class=\"hljs-comment\">// 计算成员</span>\n    G = <span class=\"hljs-string\">\"123\"</span>.length,\n  }\n</code></pre>\n<blockquote data-nodeid=\"14094\">\n<p data-nodeid=\"14095\"><strong data-nodeid=\"14251\">注意</strong>：关于常量成员和计算成员的划分其实比较难理解，实际上它们也并没有太大的用处，只是告诉我们通过这些途径可以定义枚举成员的值。因此，我们只需记住缺省值（从 0 递增）、数字字面量、字符串字面量肯定是常量成员就够了。</p>\n</blockquote>\n<h4 data-nodeid=\"14096\">枚举成员类型和联合枚举</h4>\n<p data-nodeid=\"14097\">另外，对于不需要计算（值）的常量类型成员，即缺省值（从 0 递增）、数字字面量、字符串字面量这三种情况（这就是为什么我们只需记住这三种情况），被称之为字面量枚举成员。</p>\n<p data-nodeid=\"14098\">前面我们提到枚举值和类型是一体的，枚举成员的类型是枚举类型的子类型。</p>\n<p data-nodeid=\"14843\" class=\"te-preview-highlight\"><strong data-nodeid=\"14848\">枚举成员和枚举类型之间的关系分两种情况：</strong> 如果枚举的成员同时包含字面量和非字面量枚举值，枚举成员的类型就是枚举本身（枚举类型本身也是本身的子类型）；如果枚举成员全部是字面量枚举值，则所有枚举成员既是值又是类型，如下代码所示：</p>\n\n<pre class=\"lang-typescript\" data-nodeid=\"14100\"><code data-language=\"typescript\">  <span class=\"hljs-keyword\">enum</span> Day {\n    SUNDAY,\n    MONDAY,\n  }\n  <span class=\"hljs-keyword\">enum</span> MyDay {\n    SUNDAY,\n    MONDAY = Day.MONDAY\n  }\n  <span class=\"hljs-keyword\">const</span> mondayIsDay: Day.MONDAY = Day.MONDAY; <span class=\"hljs-comment\">// ok: 字面量枚举成员既是值，也是类型</span>\n  <span class=\"hljs-keyword\">const</span> mondayIsSunday = MyDay.SUNDAY; <span class=\"hljs-comment\">// ok: 类型是 MyDay，MyDay.SUNDAY 仅仅是值</span>\n  <span class=\"hljs-keyword\">const</span> mondayIsMyDay2: MyDay.MONDAY = MyDay.MONDAY; <span class=\"hljs-comment\">// ts(2535)，MyDay 包含非字面量值成员，所以 MyDay.MONDAY 不能作为类型</span>\n</code></pre>\n<p data-nodeid=\"14101\">这里因为 Day 的所有成员都是字面量枚举成员，所以 Day.MONDAY 可以同时作为值和类型使用（第 11 行）。但是 MyDay 的成员 MONDAY 是非字面量枚举成员（但是是常量枚举成员），所以 MyDay.MONDAY 仅能作为值使用（第 12 行 ok，第 13 行提示错误）。</p>\n<p data-nodeid=\"14102\">另外，如果枚举仅有一个成员且是字面量成员，那么这个成员的类型等于枚举类型，如下代码所示：</p>\n<pre class=\"lang-typescript\" data-nodeid=\"14103\"><code data-language=\"typescript\"><span class=\"hljs-keyword\">enum</span> Day {\n  MONDAY\n}\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> mondayIsDay: Day = Day.MONDAY; <span class=\"hljs-comment\">// ok</span>\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> mondayIsDay1: Day.MONDAY = mondayIsDay <span class=\"hljs-keyword\">as</span> Day; <span class=\"hljs-comment\">// ok</span>\n</code></pre>\n<p data-nodeid=\"14104\">因为枚举 Day 仅包含一个字面量成员 MONDAY，所以类型 Day 和 Day.MONDAY 可以互相兼容。比如第 4 行和第 5 行，我们既能把 Day.MONDAY 类型赋值给 Day 类型，也能把 Day 类型赋值给 Day.MONDAY 类型。</p>\n<p data-nodeid=\"14105\">此外，回想 04 讲中介绍的字面量类型特性，不同成员的类型就是不同的字面量类型。纯字面量成员枚举类型也具有字面量类型的特性，也就等价于枚举的类型将变成各个成员类型组成的联合（枚举）类型。</p>\n<p data-nodeid=\"14106\">联合类型使得 TypeScript 可以更清楚地枚举集合里的确切值，从而检测出一些永远不会成立的条件判断（俗称 Dead Code），如下所示示例（援引自官方恒为真的示例）：</p>\n<pre class=\"lang-typescript\" data-nodeid=\"14107\"><code data-language=\"typescript\">  <span class=\"hljs-keyword\">enum</span> Day {\n    SUNDAY,\n    MONDAY,\n  }\n  \n  <span class=\"hljs-keyword\">const</span> work = <span class=\"hljs-function\">(<span class=\"hljs-params\">x: Day</span>) =&gt;</span> {\n    <span class=\"hljs-keyword\">if</span> (x !== Day.SUNDAY || x !== Day.MONDAY) { <span class=\"hljs-comment\">// ts(2367)</span>\n    }\n  }\n</code></pre>\n<p data-nodeid=\"14108\">在上边示例中，TypeScript 确定 x 的值要么是 Day.SUNDAY，要么是 Day.MONDAY。因为 Day 是纯字面量枚举类型，可以等价地看作联合类型 Day.SUNDAY | Day.MONDAY，所以我们判断出第 7 行的条件语句恒为真，于是提示了一个 ts(2367) 错误。</p>\n<p data-nodeid=\"14109\">不过，如果枚举包含需要计算（值）的成员情况就不一样了。如下示例中，TypeScript 不能区分枚举 Day 中的每个成员。因为每个成员类型都是 Day，所以无法判断出第 7 行的条件语句恒为真，也就不会提示一个 ts(2367) 错误。</p>\n<pre class=\"lang-typescript\" data-nodeid=\"14110\"><code data-language=\"typescript\">  <span class=\"hljs-keyword\">enum</span> Day {\n    SUNDAY = +<span class=\"hljs-string\">'1'</span>,\n    MONDAY = <span class=\"hljs-string\">'aa'</span>.length,\n  }\n  \n  <span class=\"hljs-keyword\">const</span> work = <span class=\"hljs-function\">(<span class=\"hljs-params\">x: Day</span>) =&gt;</span> {\n    <span class=\"hljs-keyword\">if</span> (x !== Day.SUNDAY || x !== Day.MONDAY) { <span class=\"hljs-comment\">// ok</span>\n    }\n  }\n</code></pre>\n<p data-nodeid=\"14111\">此外，字面量类型所具有的类型推断、类型缩小的特性，也同样适用于字面量枚举类型，如下代码所示：</p>\n<pre class=\"lang-typescript\" data-nodeid=\"14112\"><code data-language=\"typescript\">  <span class=\"hljs-keyword\">enum</span> Day {\n    SUNDAY,\n    MONDAY,\n  }\n  <span class=\"hljs-keyword\">let</span> SUNDAY = Day.SUNDAY; <span class=\"hljs-comment\">// 类型是 Day</span>\n  <span class=\"hljs-keyword\">const</span> SUNDAY2 = Day.SUNDAY; <span class=\"hljs-comment\">// 类型 Day.SUNDAY</span>\n  <span class=\"hljs-keyword\">const</span> work = <span class=\"hljs-function\">(<span class=\"hljs-params\">x: Day</span>) =&gt;</span> {\n    <span class=\"hljs-keyword\">if</span> (x === Day.SUNDAY) {\n      x; <span class=\"hljs-comment\">// 类型缩小为 Day.SUNDAY</span>\n    }\n  }\n</code></pre>\n<p data-nodeid=\"14113\">在上述代码中，我们在第 5 行通过 let 定义了一个未显式声明类型的变量 SUNDAY，TypeScript 可推断其类型是 Day；在第 6 行通过 const 定义了一个未显式声明类型的变量 SUNDAY2，TypeScript 可推断其类型是 Day.SUNDAY；在第 8 行的 if 条件判断中，变量 x 类型也从 Day 缩小为 Day.SUNDAY。</p>\n<h4 data-nodeid=\"14114\">常量枚举（const enums）</h4>\n<p data-nodeid=\"14115\">枚举的作用在于定义被命名的常量集合，而 TypeScript 提供了一些途径让枚举更加易用，比如常量枚举。</p>\n<p data-nodeid=\"14116\">我们可以通过添加 const 修饰符定义常量枚举，常量枚举定义转译为 JavaScript 之后会被移除，并在使用常量枚举成员的地方被替换为相应的内联值，因此常量枚举的成员都必须是常量成员（字面量 + 转译阶段可计算值的表达式），如下代码所示：</p>\n<pre class=\"lang-typescript\" data-nodeid=\"14117\"><code data-language=\"typescript\">  <span class=\"hljs-keyword\">const</span> <span class=\"hljs-keyword\">enum</span> Day {\n    SUNDAY,\n    MONDAY\n  }\n  <span class=\"hljs-keyword\">const</span> work = <span class=\"hljs-function\">(<span class=\"hljs-params\">d: Day</span>) =&gt;</span> {\n    <span class=\"hljs-keyword\">switch</span> (d) {\n      <span class=\"hljs-keyword\">case</span> Day.SUNDAY:\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">'take a rest'</span>;\n      <span class=\"hljs-keyword\">case</span> Day.MONDAY:\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">'work hard'</span>;\n    }\n  }\n}\n</code></pre>\n<p data-nodeid=\"14118\">这里我们定义了常量枚举 Day，它的成员都是值自递增的常量成员，并且在 work 函数的 switch 分支里引用了 Day。</p>\n<p data-nodeid=\"14119\">转译为成 JavaScript 后，Day 枚举的定义就被移除了，work 函数中对 Day 的引用也变成了常量值的引用（第 3 行内联了 0、第 5 行内联了 1），如下代码所示：</p>\n<pre class=\"lang-javascript\" data-nodeid=\"14120\"><code data-language=\"javascript\">    <span class=\"hljs-keyword\">var</span> work = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">d</span>) </span>{\n        <span class=\"hljs-keyword\">switch</span> (d) {\n            <span class=\"hljs-keyword\">case</span> <span class=\"hljs-number\">0</span> <span class=\"hljs-comment\">/* SUNDAY */</span>:\n                <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">'take a rest'</span>;\n            <span class=\"hljs-keyword\">case</span> <span class=\"hljs-number\">1</span> <span class=\"hljs-comment\">/* MONDAY */</span>:\n                <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">'work hard'</span>;\n        }\n    }; \n</code></pre>\n<p data-nodeid=\"14121\">从以上示例我们可以看到，使用常量枚举不仅能减少转译后的 JavaScript 代码量（因为抹除了枚举定义），还不需要到上级作用域里查找枚举定义（因为直接内联了枚举值字面量）。</p>\n<p data-nodeid=\"14122\">因此，通过定义常量枚举，我们可以以清晰、结构化的形式维护相关联的常量集合，比如 switch case分支，使得代码更具可读性和易维护性。而且因为转译后抹除了定义、内联成员值，所以在代码的体积和性能方面并不会比直接内联常量值差。</p>\n<h4 data-nodeid=\"14123\">外部枚举（Ambient enums）</h4>\n<p data-nodeid=\"14124\">在 TypeScript 中，我们可以通过 declare 描述一个在其他地方已经定义过的变量，如下代码所示：</p>\n<pre class=\"lang-typescript\" data-nodeid=\"14125\"><code data-language=\"typescript\"><span class=\"hljs-keyword\">declare</span> <span class=\"hljs-keyword\">let</span> $: <span class=\"hljs-built_in\">any</span>;\n$(<span class=\"hljs-string\">'#id'</span>).addClass(<span class=\"hljs-string\">'show'</span>); <span class=\"hljs-comment\">// ok</span>\n</code></pre>\n<p data-nodeid=\"14126\">第 1 行我们使用 declare 描述类型是 any 的外部变量 $，在第 2 行则立即使用 $ ，此时并不会提示一个找不到 $ 变量的错误。</p>\n<p data-nodeid=\"14127\">同样，我们也可以使用 declare 描述一个在其他地方已经定义过的枚举类型，通过这种方式定义出来的枚举类型，被称之为外部枚举，如下代码所示：</p>\n<pre class=\"lang-typescript\" data-nodeid=\"14128\"><code data-language=\"typescript\"><span class=\"hljs-keyword\">declare</span> <span class=\"hljs-keyword\">enum</span> Day {\n  SUNDAY,\n  MONDAY,\n}\n<span class=\"hljs-keyword\">const</span> work = <span class=\"hljs-function\">(<span class=\"hljs-params\">x: Day</span>) =&gt;</span> {\n  <span class=\"hljs-keyword\">if</span> (x === Day.SUNDAY) {\n    x; <span class=\"hljs-comment\">// 类型是 Day</span>\n  }\n}\n</code></pre>\n<p data-nodeid=\"14129\">这里我们认定在其他地方已经定义了一个 Day 这种结构的枚举，且 work 函数中使用了它。</p>\n<p data-nodeid=\"14130\">转译为 JavaScript 之后，外部枚举的定义也会像常量枚举一样被抹除，但是对枚举成员的引用会被保留（第 2 行保留了对 Day.SUNDAY 的引用），如下代码所示：</p>\n<pre class=\"lang-javascript\" data-nodeid=\"14131\"><code data-language=\"javascript\"><span class=\"hljs-keyword\">var</span> work = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">x</span>) </span>{\n    <span class=\"hljs-keyword\">if</span> (x === Day.SUNDAY) {\n        x;\n    }\n};\n</code></pre>\n<p data-nodeid=\"14132\">外部枚举和常规枚举的差异在于以下几点：</p>\n<ul data-nodeid=\"14133\">\n<li data-nodeid=\"14134\">\n<p data-nodeid=\"14135\">在外部枚举中，如果没有指定初始值的成员都被当作计算（值）成员，这跟常规枚举恰好相反；</p>\n</li>\n<li data-nodeid=\"14136\">\n<p data-nodeid=\"14137\">即便外部枚举只包含字面量成员，这些成员的类型也不会是字面量成员类型，自然完全不具备字面量类型的各种特性。</p>\n</li>\n</ul>\n<p data-nodeid=\"14138\">我们可以一起使用 declare 和 const 定义外部常量枚举，使得它转译为 JavaScript 之后仍像常量枚举一样。在抹除枚举定义的同时，我们可以使用内联枚举值替换对枚举成员的引用。</p>\n<p data-nodeid=\"14139\">外部枚举的作用在于为两个不同枚举（实际上是指向了同一个枚举类型）的成员进行兼容、比较、被复用提供了一种途径，这在一定程度上提升了枚举的可用性，让其显得不那么“鸡肋”。</p>\n<h3 data-nodeid=\"14140\">小结与预告</h3>\n<p data-nodeid=\"14141\">以上就是“鸡肋”枚举的全部内容，下面我们提炼一下核心的几个知识点和建议：</p>\n<ol data-nodeid=\"14142\">\n<li data-nodeid=\"14143\">\n<p data-nodeid=\"14144\">使用常量枚举管理相关的常量，能提高代码的可读性和易维护性；</p>\n</li>\n<li data-nodeid=\"14145\">\n<p data-nodeid=\"14146\">不要使用其他任何类型替换所使用的枚举成员；</p>\n</li>\n</ol>\n<p data-nodeid=\"14147\">下面我们插播一个思考题，也是这一讲的核心点：枚举有什么特性？常量枚举有什么特性？欢迎你在留言区进行互动、交流。</p>\n<p data-nodeid=\"14148\">10 讲我们将学习 TypeScript 最有意思的类型——泛型，敬请期待！</p>\n<p data-nodeid=\"14149\">另外，如果你觉得本专栏有价值，欢迎分享给更多好友。</p>",
                "article_title": "09 | 枚举类型：详解常见枚举类型的 7 种用法",
                "title": "09 | 枚举类型：详解常见枚举类型的 7 种用法",
                "id": 7441
            },
            {
                "content": "<p data-nodeid=\"2\">最近几年，作为一名前端面试官，每次提问候选人时，我会经常提问 TypeScirpt 的这两个知识点：一个是如何使用 TypeScript 实现与 call（或者 apply） 功能类似的函数，重在考察候选人对泛型的应用；另一个是什么是泛型？泛型的作用是什么？重在考察候选人对泛型的理解。</p>\n<p data-nodeid=\"3\">如今，TypeScript 可谓是前端必须掌握的基本技能之一，而泛型则是 TypeScript 中非常基本、非常精华（有挑战）的特性，属于 TypeScript 入门（重在基础知识）和进阶（重在应用实践）之间衔接和升华的内容。因此，我把泛型的相关知识放在了 10 讲进行讲解。</p>\n<p data-nodeid=\"4\">在我看来，掌握了泛型后，就可以随心所欲地使用 TypeScript 了。</p>\n<blockquote data-nodeid=\"5\">\n<p data-nodeid=\"6\">学习建议：使用 VS Code 新建一个 10.ts 文件，并尝试这一讲中所有的示例。</p>\n</blockquote>\n<h3 data-nodeid=\"7\">什么是泛型？</h3>\n<p data-nodeid=\"8\">关于什么是泛型这个问题不是太好回答，比如在面试中，如果有候选人反过来问我这个问题，可能我也给不出一个特别标准的答案。</p>\n<p data-nodeid=\"9\">不过，我们可以借用 Java 中泛型的释义来回答这个问题：泛型指的是类型参数化，即将原来某种具体的类型进行参数化。和定义函数参数一样，我们可以给泛型定义若干个类型参数，并在调用时给泛型传入明确的类型参数。设计泛型的目的在于有效约束类型成员之间的关系，比如函数参数和返回值、类或者接口成员和方法之间的关系。</p>\n<blockquote data-nodeid=\"10\">\n<p data-nodeid=\"11\"><strong data-nodeid=\"115\">Tips：</strong><br>\n请一定要记住这个答案哦~在某天面试时，如果碰到的面试官恰好是我，那么你至少已经答对了一半 TypeScript 的面试题；至于另外一半（实现 call）就作为这一讲的课后思考题，学完后，你自然能回答得上（思路）来。</p>\n</blockquote>\n<h3 data-nodeid=\"12\">泛型类型参数</h3>\n<p data-nodeid=\"13\">泛型最常用的场景是用来约束函数参数的类型，我们可以给函数定义若干个被调用时才会传入明确类型的参数。</p>\n<p data-nodeid=\"14\">比如以下定义的一个 reflect 函数 ，它可以接收一个任意类型的参数，并原封不动地返回参数的值和类型，那我们该如何描述这个函数呢？好像得用上 unknown 了（其实我想说的是 any，因为 any is 魔鬼，所以还是用 unknown 吧）。</p>\n<pre class=\"lang-typescript\" data-nodeid=\"15\"><code data-language=\"typescript\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">reflect</span>(<span class=\"hljs-params\">param: unknown</span>) </span>{\n  <span class=\"hljs-keyword\">return</span> param;\n}\n<span class=\"hljs-keyword\">const</span> str = reflect(<span class=\"hljs-string\">'string'</span>); <span class=\"hljs-comment\">// str 类型是 unknown</span>\n<span class=\"hljs-keyword\">const</span> num = reflect(<span class=\"hljs-number\">1</span>); <span class=\"hljs-comment\">// num 类型 unknown</span>\n</code></pre>\n<p data-nodeid=\"16\">此时，reflect 函数虽然可以接收一个任意类型的参数并原封不动地返回参数的值，不过返回值类型不符合我们的预期。因为我们希望返回值类型与入参类型一一对应（比如 number 对 number、string 对 string），而不是无论入参是什么类型，返回值一律是 unknown。</p>\n<p data-nodeid=\"17\">此时，泛型正好可以满足这样的诉求，那如何定义一个泛型参数呢？首先，我们把参数 param 的类型定义为一个（类型层面的）参数、变量，而不是一个明确的类型，等到函数调用时再传入明确的类型。</p>\n<p data-nodeid=\"18\">比如我们可以通过尖括号 &lt;&gt; 语法给函数定义一个泛型参数 P，并指定 param 参数的类型为 P ，如下代码所示：</p>\n<pre class=\"lang-typescript\" data-nodeid=\"19\"><code data-language=\"typescript\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">reflect</span>&lt;<span class=\"hljs-title\">P</span>&gt;(<span class=\"hljs-params\">param: P</span>) </span>{\n  <span class=\"hljs-keyword\">return</span> param;\n}\n</code></pre>\n<p data-nodeid=\"20\">这里我们可以看到，尖括号中的 P 表示泛型参数的定义，param 后的 P 表示参数的类型是泛型 P（即类型受 P 约束）。</p>\n<p data-nodeid=\"21\">我们也可以使用泛型显式地注解返回值的类型，虽然没有这个必要（因为返回值的类型可以基于上下文推断出来）。比如调用如下所示的 reflect 时，我们可以通过尖括号 &lt;&gt; 语法给泛型参数 P 显式地传入一个明确的类型。</p>\n<pre class=\"lang-typescript\" data-nodeid=\"22\"><code data-language=\"typescript\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">reflect</span>&lt;<span class=\"hljs-title\">P</span>&gt;(<span class=\"hljs-params\">param: P</span>):<span class=\"hljs-title\">P</span> </span>{\n  <span class=\"hljs-keyword\">return</span> param;\n}\n</code></pre>\n<p data-nodeid=\"23\">然后在调用函数时，我们也通过 &lt;&gt; 语法指定了如下所示的 string、number 类型入参，相应地，reflectStr 的类型是 string，reflectNum 的类型是 number。</p>\n<pre class=\"lang-typescript\" data-nodeid=\"24\"><code data-language=\"typescript\"><span class=\"hljs-keyword\">const</span> reflectStr = reflect&lt;<span class=\"hljs-built_in\">string</span>&gt;(<span class=\"hljs-string\">'string'</span>); <span class=\"hljs-comment\">// str 类型是 string</span>\n<span class=\"hljs-keyword\">const</span> reflectNum = reflect&lt;<span class=\"hljs-built_in\">number</span>&gt;(<span class=\"hljs-number\">1</span>); <span class=\"hljs-comment\">// num 类型 number</span>\n</code></pre>\n<p data-nodeid=\"25\">另外，如果调用泛型函数时受泛型约束的参数有传值，泛型参数的入参可以从参数的类型中进行推断，而无须再显式指定类型（可缺省），因此上边的示例可以简写为如下示例：</p>\n<pre class=\"lang-typescript\" data-nodeid=\"26\"><code data-language=\"typescript\"><span class=\"hljs-keyword\">const</span> reflectStr2 = reflect(<span class=\"hljs-string\">'string'</span>); <span class=\"hljs-comment\">// str 类型是 string</span>\n<span class=\"hljs-keyword\">const</span> reflectNum2 = reflect(<span class=\"hljs-number\">1</span>); <span class=\"hljs-comment\">// num 类型 number</span>\n</code></pre>\n<p data-nodeid=\"27\">泛型不仅可以约束函数整个参数的类型，还可以约束参数属性、成员的类型，比如参数的类型可以是数组、对象，如下示例：</p>\n<pre class=\"lang-typescript\" data-nodeid=\"28\"><code data-language=\"typescript\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">reflectArray</span>&lt;<span class=\"hljs-title\">P</span>&gt;(<span class=\"hljs-params\">param: P[]</span>) </span>{\n  <span class=\"hljs-keyword\">return</span> param;\n}\n<span class=\"hljs-keyword\">const</span> reflectArr = reflectArray([<span class=\"hljs-number\">1</span>, <span class=\"hljs-string\">'1'</span>]); <span class=\"hljs-comment\">// reflectArr 是 (string | number)[]</span>\n</code></pre>\n<p data-nodeid=\"29\">这里我们约束了 param 的类型是数组，数组的元素类型是泛型入参。</p>\n<p data-nodeid=\"30\">通过泛型，我们可以约束函数参数和返回值的类型关系。举一个我们比较熟悉的实际场景 React Hooks useState 为例，如下示例中，第 2 行 return 的元组（因为 useState 返回的是长度为 2、元素类型固定的数组）的第一个元素的类型就是泛型 S，第二个函数类型元素的参数类型也是泛型 S。</p>\n<pre class=\"lang-typescript\" data-nodeid=\"31\"><code data-language=\"typescript\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">useState</span>&lt;<span class=\"hljs-title\">S</span>&gt;(<span class=\"hljs-params\">state: S, initialValue?: S</span>) </span>{\n  <span class=\"hljs-keyword\">return</span> [state, <span class=\"hljs-function\">(<span class=\"hljs-params\">s: S</span>) =&gt;</span> <span class=\"hljs-built_in\">void</span> <span class=\"hljs-number\">0</span>] <span class=\"hljs-keyword\">as</span> unknown <span class=\"hljs-keyword\">as</span> [S, <span class=\"hljs-function\">(<span class=\"hljs-params\">s: S</span>) =&gt;</span> <span class=\"hljs-built_in\">void</span>];\n}\n</code></pre>\n<p data-nodeid=\"1122\" class=\"\"><strong data-nodeid=\"1127\">注意：函数的泛型入参必须和参数/参数成员建立有效的约束关系才有实际意义。</strong> 比如在下面示例中，我们定义了一个仅约束返回值类型的泛型，它是没有任何意义的。</p>\n\n<pre class=\"lang-typescript\" data-nodeid=\"33\"><code data-language=\"typescript\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">uselessGenerics</span>&lt;<span class=\"hljs-title\">P</span>&gt;(<span class=\"hljs-params\"></span>): <span class=\"hljs-title\">P</span> </span>{\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">void</span> <span class=\"hljs-number\">0</span> <span class=\"hljs-keyword\">as</span> unknown <span class=\"hljs-keyword\">as</span> P;\n}\n</code></pre>\n<p data-nodeid=\"34\">我们可以给函数定义任何个数的泛型入参，如下代码所示：</p>\n<pre class=\"lang-typescript\" data-nodeid=\"35\"><code data-language=\"typescript\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">reflectExtraParams</span>&lt;<span class=\"hljs-title\">P</span>, <span class=\"hljs-title\">Q</span>&gt;(<span class=\"hljs-params\">p1: P, p2: Q</span>): [<span class=\"hljs-title\">P</span>, <span class=\"hljs-title\">Q</span>] </span>{\n  <span class=\"hljs-keyword\">return</span> [p1, p2];\n}\n</code></pre>\n<p data-nodeid=\"36\">在上述代码中，我们定义了一个拥有两个泛型入参（P 和 Q）的函数 reflectExtraParams，并通过 P 和 Q 约束函数参数 p1、p2 和返回值的类型。</p>\n<h3 data-nodeid=\"37\">泛型类</h3>\n<p data-nodeid=\"38\">在类的定义中，我们还可以使用泛型用来约束构造函数、属性、方法的类型，如下代码所示：</p>\n<pre class=\"lang-typescript\" data-nodeid=\"39\"><code data-language=\"typescript\"><span class=\"hljs-keyword\">class</span> Memory&lt;S&gt; {\n  store: S;\n  <span class=\"hljs-keyword\">constructor</span>(<span class=\"hljs-params\">store: S</span>) {\n    <span class=\"hljs-keyword\">this</span>.store = store;\n  }\n  <span class=\"hljs-keyword\">set</span>(store: S) {\n    <span class=\"hljs-keyword\">this</span>.store = store;\n  }\n  <span class=\"hljs-keyword\">get</span>() {\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">this</span>.store;\n  }\n}\n<span class=\"hljs-keyword\">const</span> numMemory = <span class=\"hljs-keyword\">new</span> Memory&lt;<span class=\"hljs-built_in\">number</span>&gt;(<span class=\"hljs-number\">1</span>); <span class=\"hljs-comment\">// &lt;number&gt; 可缺省</span>\n<span class=\"hljs-keyword\">const</span> getNumMemory = numMemory.get(); <span class=\"hljs-comment\">// 类型是 number</span>\nnumMemory.set(<span class=\"hljs-number\">2</span>); <span class=\"hljs-comment\">// 只能写入 number 类型</span>\n<span class=\"hljs-keyword\">const</span> strMemory = <span class=\"hljs-keyword\">new</span> Memory(<span class=\"hljs-string\">''</span>); <span class=\"hljs-comment\">// 缺省 &lt;string&gt;</span>\n<span class=\"hljs-keyword\">const</span> getStrMemory = strMemory.get(); <span class=\"hljs-comment\">// 类型是 string</span>\nstrMemory.set(<span class=\"hljs-string\">'string'</span>); <span class=\"hljs-comment\">// 只能写入 string 类型</span>\n</code></pre>\n<p data-nodeid=\"40\">首先，我们定义了一个支持读写的寄存器类 Memory，并使用泛型约束了 Memory 类的构造器函数、set 和 get 方法形参的类型，最后实例化了泛型入参分别是 number 和 string 类型的两种寄存器。</p>\n<p data-nodeid=\"2030\" class=\"\">泛型类和泛型函数类似的地方在于，在创建类实例时，如果受泛型约束的参数传入了明确值，则泛型入参（确切地说是传入的类型）可缺省，比如第 14 行、第 18 行，<code data-backticks=\"1\" data-nodeid=\"2032\">&lt;number&gt;</code>、<code data-backticks=\"1\" data-nodeid=\"2034\">&lt;string&gt;</code> 泛型入参就是可以缺省的。</p>\n\n\n<p data-nodeid=\"42\"><strong data-nodeid=\"152\">小贴士：对于 React 开发者而言，组件也支持泛型，如下代码所示。</strong></p>\n<pre class=\"lang-typescript\" data-nodeid=\"43\"><code data-language=\"typescript\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">GenericCom</span>&lt;<span class=\"hljs-title\">P</span>&gt;(<span class=\"hljs-params\">props: { prop1: <span class=\"hljs-built_in\">string</span> }</span>) </span>{\n  <span class=\"hljs-keyword\">return</span> &lt;&gt;&lt;/&gt;;\n};\n&lt;GenericCom&lt;{ name: <span class=\"hljs-built_in\">string</span>; }&gt; prop1=<span class=\"hljs-string\">\"1\"</span> ... /&gt;\n</code></pre>\n<p data-nodeid=\"44\">在第 1 行~第 3 行，我们定义了一个泛型组件 GenericCom，它接收了一个类型入参 P。在第 4 行，通过 JSX 语法创建组件元素的同时，我们还显式指定了接口类型 { name: string }  作为入参。</p>\n<blockquote data-nodeid=\"45\">\n<p data-nodeid=\"46\"><strong data-nodeid=\"160\">注意</strong>：这块的语法稍微有些奇怪，我们记住就可以了。</p>\n</blockquote>\n<h3 data-nodeid=\"47\">泛型类型</h3>\n<p data-nodeid=\"48\">02 讲中我们提到，我们可以使用 Array&lt;类型&gt; 的语法来定义数组类型，这里的 Array 本身就是一种类型。</p>\n<p data-nodeid=\"49\">在 TypeScript 中，类型本身就可以被定义为拥有不明确的类型参数的泛型，并且可以接收明确类型作为入参，从而衍生出更具体的类型，如下代码所示：</p>\n<pre class=\"lang-typescript\" data-nodeid=\"50\"><code data-language=\"typescript\"><span class=\"hljs-keyword\">const</span> reflectFn: &lt;P&gt;<span class=\"hljs-function\">(<span class=\"hljs-params\">param: P</span>) =&gt;</span> P = reflect; <span class=\"hljs-comment\">// ok</span>\n</code></pre>\n<p data-nodeid=\"51\">这里我们为变量 reflectFn 显式添加了泛型类型注解，并将 reflect 函数作为值赋给了它。</p>\n<p data-nodeid=\"52\">我们也可以把 reflectFn 的类型注解提取为一个能被复用的类型别名或者接口，如下代码所示：</p>\n<pre class=\"lang-typescript\" data-nodeid=\"53\"><code data-language=\"typescript\"><span class=\"hljs-keyword\">type</span> ReflectFuncton = &lt;P&gt;<span class=\"hljs-function\">(<span class=\"hljs-params\">param: P</span>) =&gt;</span> P;\n<span class=\"hljs-keyword\">interface</span> IReflectFuncton {\n  &lt;P&gt;(param: P): P\n}\n<span class=\"hljs-keyword\">const</span> reflectFn2: ReflectFuncton = reflect;\n<span class=\"hljs-keyword\">const</span> reflectFn3: IReflectFuncton = reflect;\n</code></pre>\n<p data-nodeid=\"54\">将类型入参的定义移动到类型别名或接口名称后，此时定义的一个接收具体类型入参后返回一个新类型的类型就是泛型类型。</p>\n<p data-nodeid=\"55\">如下示例中，我们定义了两个可以接收入参 P 的泛型类型（GenericReflectFunction 和 IGenericReflectFunction ）。</p>\n<pre class=\"lang-typescript\" data-nodeid=\"56\"><code data-language=\"typescript\"><span class=\"hljs-keyword\">type</span> GenericReflectFunction&lt;P&gt; = <span class=\"hljs-function\">(<span class=\"hljs-params\">param: P</span>) =&gt;</span> P;\n<span class=\"hljs-keyword\">interface</span> IGenericReflectFunction&lt;P&gt; {\n  (param: P): P;\n}\n<span class=\"hljs-keyword\">const</span> reflectFn4: GenericReflectFunction&lt;<span class=\"hljs-built_in\">string</span>&gt; = reflect; <span class=\"hljs-comment\">// 具象化泛型</span>\n<span class=\"hljs-keyword\">const</span> reflectFn5: IGenericReflectFunction&lt;<span class=\"hljs-built_in\">number</span>&gt; = reflect; <span class=\"hljs-comment\">// 具象化泛型</span>\n<span class=\"hljs-keyword\">const</span> reflectFn3Return = reflectFn4(<span class=\"hljs-string\">'string'</span>); <span class=\"hljs-comment\">// 入参和返回值都必须是 string 类型</span>\n<span class=\"hljs-keyword\">const</span> reflectFn4Return = reflectFn5(<span class=\"hljs-number\">1</span>); <span class=\"hljs-comment\">//  入参和返回值都必须是 number 类型</span>\n</code></pre>\n<p data-nodeid=\"57\">在泛型定义中，我们甚至可以使用一些类型操作符进行运算表达，使得泛型可以根据入参的类型衍生出各异的类型，如下代码所示：</p>\n<pre class=\"lang-typescript\" data-nodeid=\"58\"><code data-language=\"typescript\"><span class=\"hljs-keyword\">type</span> StringOrNumberArray&lt;E&gt; = E <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-built_in\">string</span> | <span class=\"hljs-built_in\">number</span> ? E[] : E;\n<span class=\"hljs-keyword\">type</span> StringArray = StringOrNumberArray&lt;<span class=\"hljs-built_in\">string</span>&gt;; <span class=\"hljs-comment\">// 类型是 string[]</span>\n<span class=\"hljs-keyword\">type</span> NumberArray = StringOrNumberArray&lt;<span class=\"hljs-built_in\">number</span>&gt;; <span class=\"hljs-comment\">// 类型是 number[]</span>\n<span class=\"hljs-keyword\">type</span> NeverGot = StringOrNumberArray&lt;<span class=\"hljs-built_in\">boolean</span>&gt;; <span class=\"hljs-comment\">// 类型是 boolean</span>\n</code></pre>\n<p data-nodeid=\"59\">这里我们定义了一个泛型，如果入参是 number | string 就会生成一个数组类型，否则就生成入参类型。而且，我们还使用了与 JavaScript 三元表达式完全一致的语法来表达类型运算的逻辑关系，15 讲中会更详细地介绍。</p>\n<p data-nodeid=\"60\"><strong data-nodeid=\"175\">发散一下，如果我们给上面这个泛型传入了一个 string | boolean 联合类型作为入参，将会得到什么类型呢？且看如下所示示例：</strong></p>\n<pre class=\"lang-typescript\" data-nodeid=\"61\"><code data-language=\"typescript\"><span class=\"hljs-keyword\">type</span> BooleanOrString = <span class=\"hljs-built_in\">string</span> | <span class=\"hljs-built_in\">boolean</span>;\n<span class=\"hljs-keyword\">type</span> WhatIsThis = StringOrNumberArray&lt;BooleanOrString&gt;; <span class=\"hljs-comment\">// 好像应该是 string | boolean ?</span>\n<span class=\"hljs-keyword\">type</span> BooleanOrStringGot = BooleanOrString <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-built_in\">string</span> | <span class=\"hljs-built_in\">number</span> ? BooleanOrString[] : BooleanOrString; <span class=\"hljs-comment\">//  string | boolean</span>\n</code></pre>\n<p data-nodeid=\"62\">嗯？难道不是 boolean | string ？</p>\n<p data-nodeid=\"63\">还真不是，如果你使用 VS Code 尝试了这个示例，并 hover 类型别名 WhatIsThis ，那么你会发现显示的类型将是 boolean | string[]。</p>\n<p data-nodeid=\"64\">BooleanOrStringGot 和 WhatIsThis 这两个类型别名的类型居然不一样，这 TM 是什么逻辑？这个就是所谓的分配条件类型（Distributive Conditional Types）。</p>\n<p data-nodeid=\"65\"><strong data-nodeid=\"186\">关于分配条件类型这个概念，官方的释义</strong>：在条件类型判断的情况下（比如上边示例中出现的 extends），如果入参是联合类型，则会被拆解成一个个独立的（原子）类型（成员）进行类型运算。</p>\n<p data-nodeid=\"66\">比如上边示例中的 string | boolean 入参，先被拆解成 string 和 boolean 这两个独立类型，再分别判断是否是 string | number 类型的子集。<strong data-nodeid=\"194\">因为 string 是子集而 boolean 不是，所以最终我们得到的 WhatIsThis 的类型是 boolean | string[]。</strong></p>\n<p data-nodeid=\"2484\" class=\"te-preview-highlight\">能接受入参的泛型类型和函数一样，都可以对入参类型进行计算并返回新的类型，像是在做类型运算。</p>\n\n<p data-nodeid=\"68\">利用泛型，我们可以抽象封装出很多有用、复杂的类型约束。比如在 Redux Model 中约束 State 和 Reducers 的类型定义关系，我们可以通过如下所示代码定义了一个既能接受 State 类型入参，又包含 state 和 reducers 这两个属性的接口类型泛型，并通过 State 入参约束了泛型的 state 属性和 reducers 属性下 action 索引属性的类型关系。</p>\n<pre class=\"lang-typescript\" data-nodeid=\"69\"><code data-language=\"typescript\"><span class=\"hljs-keyword\">interface</span> ReduxModel&lt;State&gt; {\n  state: State,\n  reducers: {\n    [action: <span class=\"hljs-built_in\">string</span>]: <span class=\"hljs-function\">(<span class=\"hljs-params\">state: State, action: <span class=\"hljs-built_in\">any</span></span>) =&gt;</span> State\n  }\n}\n</code></pre>\n<p data-nodeid=\"70\">然后根据实际需要，我们传入了一个具体的 State 类型具象化 ReduxModel，并约束了一个实际的 model，如下代码所示：</p>\n<pre class=\"lang-typescript\" data-nodeid=\"71\"><code data-language=\"typescript\"><span class=\"hljs-keyword\">type</span> ModelInterface = { id: <span class=\"hljs-built_in\">number</span>; name: <span class=\"hljs-built_in\">string</span> };\n<span class=\"hljs-keyword\">const</span> model: ReduxModel&lt;ModelInterface&gt; = {\n  state: { id: <span class=\"hljs-number\">1</span>, name: <span class=\"hljs-string\">'乾元'</span> }, <span class=\"hljs-comment\">//  ok 类型必须是 ModelInterface</span>\n  reducers: {\n    setId: <span class=\"hljs-function\">(<span class=\"hljs-params\">state, action: { payload: <span class=\"hljs-built_in\">number</span> }</span>) =&gt;</span> ({\n      ...state,\n      id: action.payload <span class=\"hljs-comment\">// ok must be number</span>\n    }),\n    setName: <span class=\"hljs-function\">(<span class=\"hljs-params\">state, action: { payload: <span class=\"hljs-built_in\">string</span> }</span>) =&gt;</span> ({\n      ...state,\n      name: action.payload <span class=\"hljs-comment\">// ok must be string</span>\n    })\n  }\n}\n</code></pre>\n<p data-nodeid=\"72\">在上述示例中，model 对象的 state 属性、reducers 属性的 setId、setName 方法的第一个参数 state 的类型都受到 ReduxModel 泛型入参 ModelInterface 的约束。</p>\n<blockquote data-nodeid=\"73\">\n<p data-nodeid=\"74\"><strong data-nodeid=\"205\">注意：枚举类型不支持泛型。</strong></p>\n</blockquote>\n<h3 data-nodeid=\"75\">泛型约束</h3>\n<p data-nodeid=\"76\">前面提到了泛型就像是类型的函数，它可以抽象、封装并接收（类型）入参，而泛型的入参也拥有类似函数入参的特性。因此，我们可以把泛型入参限定在一个相对更明确的集合内，以便对入参进行约束。</p>\n<p data-nodeid=\"77\">比如最前边提到的原封不动返回参数的 reflect 函数，我们希望把接收参数的类型限定在几种原始类型的集合中，此时就可以使用“泛型入参名 extends 类型”语法达到这个目的，如下代码所示：</p>\n<pre class=\"lang-typescript\" data-nodeid=\"78\"><code data-language=\"typescript\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">reflectSpecified</span>&lt;<span class=\"hljs-title\">P</span> <span class=\"hljs-title\">extends</span> <span class=\"hljs-title\">number</span> | <span class=\"hljs-title\">string</span> | <span class=\"hljs-title\">boolean</span>&gt;(<span class=\"hljs-params\">param: P</span>):<span class=\"hljs-title\">P</span> </span>{\n  <span class=\"hljs-keyword\">return</span> param;\n}\nreflectSpecified(<span class=\"hljs-string\">'string'</span>); <span class=\"hljs-comment\">// ok</span>\nreflectSpecified(<span class=\"hljs-number\">1</span>); <span class=\"hljs-comment\">// ok</span>\nreflectSpecified(<span class=\"hljs-literal\">true</span>); <span class=\"hljs-comment\">// ok</span>\nreflectSpecified(<span class=\"hljs-literal\">null</span>); <span class=\"hljs-comment\">// ts(2345) 'null' 不能赋予类型 'number | string | boolean'</span>\n</code></pre>\n<p data-nodeid=\"79\">在上述示例中，我们限定了泛型入参只能是 number | string | boolean 的子集。</p>\n<p data-nodeid=\"80\">同样，我们也可以把接口泛型入参约束在特定的范围内，如下代码所示：</p>\n<pre class=\"lang-typescript\" data-nodeid=\"81\"><code data-language=\"typescript\"><span class=\"hljs-keyword\">interface</span> ReduxModelSpecified&lt;State <span class=\"hljs-keyword\">extends</span> { id: <span class=\"hljs-built_in\">number</span>; name: <span class=\"hljs-built_in\">string</span> }&gt; {\n  state: State\n}\n<span class=\"hljs-keyword\">type</span> ComputedReduxModel1 = ReduxModelSpecified&lt;{ id: <span class=\"hljs-built_in\">number</span>; name: <span class=\"hljs-built_in\">string</span>; }&gt;; <span class=\"hljs-comment\">// ok</span>\n<span class=\"hljs-keyword\">type</span> ComputedReduxModel2 = ReduxModelSpecified&lt;{ id: <span class=\"hljs-built_in\">number</span>; name: <span class=\"hljs-built_in\">string</span>; age: <span class=\"hljs-built_in\">number</span>; }&gt;; <span class=\"hljs-comment\">// ok</span>\n<span class=\"hljs-keyword\">type</span> ComputedReduxModel3 = ReduxModelSpecified&lt;{ id: <span class=\"hljs-built_in\">string</span>; name: <span class=\"hljs-built_in\">number</span>; }&gt;; <span class=\"hljs-comment\">// ts(2344)</span>\n<span class=\"hljs-keyword\">type</span> ComputedReduxModel4 = ReduxModelSpecified&lt;{ id: <span class=\"hljs-built_in\">number</span>;}&gt;; <span class=\"hljs-comment\">// ts(2344)</span>\n</code></pre>\n<p data-nodeid=\"82\">在上述示例中，ReduxModelSpecified 泛型仅接收 { id: number; name: string } 接口类型的子类型作为入参。</p>\n<p data-nodeid=\"83\">我们还可以在多个不同的泛型入参之间设置约束关系，如下代码所示：</p>\n<pre class=\"lang-typescript\" data-nodeid=\"84\"><code data-language=\"typescript\"><span class=\"hljs-keyword\">interface</span> ObjSetter {\n  &lt;O <span class=\"hljs-keyword\">extends</span> {}, K <span class=\"hljs-keyword\">extends</span> keyof O, V <span class=\"hljs-keyword\">extends</span> O[K]&gt;(obj: O, key: K, value: V): V; \n}\n<span class=\"hljs-keyword\">const</span> setValueOfObj: ObjSetter = <span class=\"hljs-function\">(<span class=\"hljs-params\">obj, key, value</span>) =&gt;</span> (obj[key] = value);\nsetValueOfObj({ id: <span class=\"hljs-number\">1</span>, name: <span class=\"hljs-string\">'name'</span> }, <span class=\"hljs-string\">'id'</span>, <span class=\"hljs-number\">2</span>); <span class=\"hljs-comment\">// ok</span>\nsetValueOfObj({ id: <span class=\"hljs-number\">1</span>, name: <span class=\"hljs-string\">'name'</span> }, <span class=\"hljs-string\">'name'</span>, <span class=\"hljs-string\">'new name'</span>); <span class=\"hljs-comment\">// ok</span>\nsetValueOfObj({ id: <span class=\"hljs-number\">1</span>, name: <span class=\"hljs-string\">'name'</span> }, <span class=\"hljs-string\">'age'</span>, <span class=\"hljs-number\">2</span>); <span class=\"hljs-comment\">// ts(2345)</span>\nsetValueOfObj({ id: <span class=\"hljs-number\">1</span>, name: <span class=\"hljs-string\">'name'</span> }, <span class=\"hljs-string\">'id'</span>, <span class=\"hljs-string\">'2'</span>); <span class=\"hljs-comment\">// ts(2345)</span>\n</code></pre>\n<p data-nodeid=\"85\">在设置对象属性值的函数类型时，它拥有 3 个泛型入参：第 1 个是对象，第 2 个是第 1 个入参属性名集合的子集，第 3 个是指定属性类型的子类型（这里使用了 keyof 操作符，15 讲中我们会详细介绍 TypeScript 类型相关的操作符）。</p>\n<p data-nodeid=\"86\">另外，泛型入参与函数入参还有一个相似的地方在于，它也可以给泛型入参指定默认值（默认类型），且语法和指定函数默认参数完全一致，如下代码所示：</p>\n<pre class=\"lang-typescript\" data-nodeid=\"87\"><code data-language=\"typescript\"><span class=\"hljs-keyword\">interface</span> ReduxModelSpecified2&lt;State = { id: <span class=\"hljs-built_in\">number</span>; name: <span class=\"hljs-built_in\">string</span> }&gt; {\n  state: State\n}\n<span class=\"hljs-keyword\">type</span> ComputedReduxModel5 = ReduxModelSpecified2; <span class=\"hljs-comment\">// ok</span>\n<span class=\"hljs-keyword\">type</span> ComputedReduxModel6 = ReduxModelSpecified2&lt;{ id: <span class=\"hljs-built_in\">number</span>; name: <span class=\"hljs-built_in\">string</span>; }&gt;; <span class=\"hljs-comment\">// ok</span>\n<span class=\"hljs-keyword\">type</span> ComputedReduxModel7 = ReduxModelSpecified; <span class=\"hljs-comment\">// ts(2314) 缺少一个类型参数</span>\n</code></pre>\n<p data-nodeid=\"88\">在上述示例中，我们定义了入参有默认类型的泛型 ReduxModelSpecified2，因此使用 ReduxModelSpecified2 时类型入参可缺省。而 ReduxModelSpecified 的入参没有默认值，所以缺省入参时会提示一个类型错误。</p>\n<p data-nodeid=\"89\">泛型入参的约束与默认值还可以组合使用，如下代码所示：</p>\n<pre class=\"lang-typescript\" data-nodeid=\"90\"><code data-language=\"typescript\"><span class=\"hljs-keyword\">interface</span> ReduxModelMixed&lt;State <span class=\"hljs-keyword\">extends</span> {} = { id: <span class=\"hljs-built_in\">number</span>; name: <span class=\"hljs-built_in\">string</span> }&gt; {\n  state: State\n}\n</code></pre>\n<p data-nodeid=\"91\">这里我们限定了泛型 ReduxModelMixed 入参 State 必须是 {} 类型的子类型，同时也指定了入参缺省时的默认类型是接口类型 { id: number; name: string; }。</p>\n<h3 data-nodeid=\"92\">小结与预告</h3>\n<p data-nodeid=\"93\">这一讲关于泛型的知识点看起来不是太多，不过难点在于如何理解泛型。</p>\n<p data-nodeid=\"94\">我们可以试着将泛型理解为类型中的函数，并通过抽象、封装类型运算逻辑实现类型可复用，以便更好地掌握泛型。</p>\n<p data-nodeid=\"95\">这里插播一道思考题：如何使用 TypeScript 实现 call？欢迎你在留言区与我互动、交流。</p>\n<blockquote data-nodeid=\"96\">\n<p data-nodeid=\"97\">提示：因为仅凭本讲的内容可能无法回答这个问题，所以这里我提示几个关键词 Parameters、ReturnType。这些关键词与 Array 一样，都是 TypeScript 内封装好的泛型（第 14 讲里会介绍官方内置泛型），你可以在谷歌、百度搜索引擎或者官方文档中搜索一下 “TypeScript + 关键词” 提前获取更多信息。</p>\n</blockquote>\n<p data-nodeid=\"98\">11 讲我们将进入进阶课程的学习，敬请期待。</p>\n<p data-nodeid=\"99\">另外，如果你觉得本专栏有价值，欢迎分享给更多好友哦~</p>",
                "article_title": "10 | 泛型：如何正确使用泛型约束类型变量？",
                "title": "10 | 泛型：如何正确使用泛型约束类型变量？",
                "id": 7442
            }
        ]
    },
    {
        "chapterTitle": "模块二：TypeScript 进阶",
        "children": [
            {
                "content": "<p data-nodeid=\"95576\">在前面 10 讲中，我们学习了如何选择 TypeScript IDE 和搭建开发环境，也学习了原始类型、字面量类型、数组类型、函数类型、类类型、接口类型、类型别名、联合与交叉类型、枚举类型、泛型等类型元素，以及类型推断、类型断言、类型缩小、类型放大等特性。这些类型元素和特性，构成了 TypeScript 的基础认知。</p>\n\n\n<p data-nodeid=\"94831\">接下来我们将通过学习 TypeScript 进阶和业务实战两个模块的内容提升对 TypeScript 的理解，其中有 5 讲会介绍 TypeScript 应用较为广泛的进阶知识点，剩余 6 讲则围绕 TypeScript 在业务中的实践进行展开。</p>\n<p data-nodeid=\"94832\">接下来我们开始聊聊TypeScript 进阶的第一讲——类型守卫 。</p>\n<blockquote data-nodeid=\"94833\">\n<p data-nodeid=\"94834\">学习建议：使用 VS Code 新建一个 11.ts 文件，并尝试这一讲中出现的所有示例。</p>\n</blockquote>\n<h3 data-nodeid=\"94835\">类型守卫</h3>\n<p data-nodeid=\"94836\">JavaScript 作为一种动态语言，意味着其中的参数、值可以是多态（多种类型）。因此，我们需要区别对待每一种状态，以此确保对参数、值的操作合法。</p>\n<p data-nodeid=\"94837\">举一个常见的场景为例，如下我们定义了一个可以接收字符串或者字符串数组的参数 toUpperCase，并将参数转成大写格式输出的函数 convertToUpperCase。</p>\n<pre class=\"lang-javascript\" data-nodeid=\"94838\"><code data-language=\"javascript\">{\n  <span class=\"hljs-keyword\">const</span> convertToUpperCase = <span class=\"hljs-function\">(<span class=\"hljs-params\">strOrArray</span>) =&gt;</span> {\n    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">typeof</span> strOrArray === <span class=\"hljs-string\">'string'</span>) {\n      <span class=\"hljs-keyword\">return</span> strOrArray.toUpperCase();\n    } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">Array</span>.isArray(strOrArray)) {\n      <span class=\"hljs-keyword\">return</span> strOrArray.map(<span class=\"hljs-function\"><span class=\"hljs-params\">item</span> =&gt;</span> item.toUpperCase());\n    }\n  }\n}\n</code></pre>\n<p data-nodeid=\"94839\">在示例中的第 3 行、第 5 行，我们分别使用了 typeof、Array.isArray 确保字符串和字符串数组类型的入参在运行时分别进入正确的分支，而不至于入参是数组类型时，调用数组类型并不存在的 toUpperCase 方法，从而抛出一个“strOrArray.toUpperCase is not a function”的错误。</p>\n<p data-nodeid=\"94840\">在 TypeScript 中，因为受静态类型检测约束，所以在编码阶段我们必须使用类似的手段确保当前的数据类型支持相应的操作。当然，前提条件是已经显式地注解了类型的多态。</p>\n<p data-nodeid=\"94841\">比如如果我们将上边示例中的 convertToUpperCase 函数使用 TypeScript 实现，那么就需要显示地标明 strOrArray 的类型就是 string 和 string[] 类型组成的联合类型，如下代码所示：</p>\n<pre class=\"lang-typescript\" data-nodeid=\"94842\"><code data-language=\"typescript\">{\n  <span class=\"hljs-keyword\">const</span> convertToUpperCase = <span class=\"hljs-function\">(<span class=\"hljs-params\">strOrArray: <span class=\"hljs-built_in\">string</span> | <span class=\"hljs-built_in\">string</span>[]</span>) =&gt;</span> {\n    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">typeof</span> strOrArray === <span class=\"hljs-string\">'string'</span>) {\n      <span class=\"hljs-keyword\">return</span> strOrArray.toUpperCase();\n    } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">Array</span>.isArray(strOrArray)) {\n      <span class=\"hljs-keyword\">return</span> strOrArray.map(<span class=\"hljs-function\"><span class=\"hljs-params\">item</span> =&gt;</span> item.toUpperCase());\n    }\n  }\n}\n</code></pre>\n<p data-nodeid=\"94843\">在示例中，convertToUpperCase 函数的主体逻辑与 JavaScript 中的逻辑完全一致（除了添加的参数类型注解）。</p>\n<p data-nodeid=\"94844\">在 TypeScript 中，第 3 行和第 5 行的 typeof、Array.isArray 条件判断，除了可以保证转译为 JavaScript 运行后类型是正确的，还可以保证第 4 行和第 6 行在静态类型检测层面是正确的。</p>\n<p data-nodeid=\"94845\">很明显，第 4 行中入参 strOrArray 的类型因为 typeof 条件判断变成了 string，第 6 行入参 strOrArray 的类型因为 Array.isArray 变成了 string[]，所以没有提示类型错误。而这个类型变化就是 04 讲中学习的类型缩小，这里的 typeof、Array.isArray 条件判断就是类型守卫。</p>\n<p data-nodeid=\"94846\">从示例中，我们可以看到<strong data-nodeid=\"94952\">类型守卫的作用在于触发类型缩小。实际上，它还可以用来区分类型集合中的不同成员。</strong></p>\n<p data-nodeid=\"94847\">类型集合一般包括联合类型和枚举类型，下面我们看看如何区分联合类型。</p>\n<h3 data-nodeid=\"94848\">如何区分联合类型？</h3>\n<p data-nodeid=\"94849\">首先，我们看一下如何使用类型守卫来区分联合类型的不同成员，常用的类型守卫包括<strong data-nodeid=\"94960\">switch、字面量恒等、typeof、instanceof、in 和自定义类型守卫</strong>这几种。</p>\n<h4 data-nodeid=\"96072\" class=\"\">1. switch</h4>\n\n<p data-nodeid=\"94853\">我们往往会使用 switch 类型守卫来处理联合类型中成员或者成员属性可枚举的场景，即字面量值的集合，如以下示例：</p>\n<pre class=\"lang-typescript\" data-nodeid=\"94854\"><code data-language=\"typescript\">{\n  <span class=\"hljs-keyword\">const</span> convert = <span class=\"hljs-function\">(<span class=\"hljs-params\">c: 'a' | 1</span>) =&gt;</span> {\n    <span class=\"hljs-keyword\">switch</span> (c) {\n      <span class=\"hljs-keyword\">case</span> <span class=\"hljs-number\">1</span>:\n        <span class=\"hljs-keyword\">return</span> c.toFixed(); <span class=\"hljs-comment\">// c is 1</span>\n      <span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">'a'</span>:\n        <span class=\"hljs-keyword\">return</span> c.toLowerCase(); <span class=\"hljs-comment\">// c is 'a'</span>\n    }\n  }\n  <span class=\"hljs-keyword\">const</span> feat = <span class=\"hljs-function\">(<span class=\"hljs-params\">c: { animal: 'panda'; name: 'China' } | { feat: 'video'; name: 'Japan' }</span>) =&gt;</span> {\n    <span class=\"hljs-keyword\">switch</span> (c.name) {\n      <span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">'China'</span>:\n        <span class=\"hljs-keyword\">return</span> c.animal; <span class=\"hljs-comment\">// c is \"{ animal: 'panda'; name: 'China' }\"</span>\n      <span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">'Japan'</span>:\n        <span class=\"hljs-keyword\">return</span> c.feat; <span class=\"hljs-comment\">// c is \"{ feat: 'video'; name: 'Japan' }\"</span>\n    }\n  };\n}\n</code></pre>\n<p data-nodeid=\"97070\">在上述示例中，因为 convert 函数的参数及 feat 函数参数的 name 属性都是一个可被枚举的集合，所以我们可以使用 switch 来缩小类型。</p>\n<p data-nodeid=\"97071\">比如第 5 行中 c 的类型被缩小为数字 1，第 7 行的 c 被缩小为字符串 'Japan'，第 13 和 15 行的 c 也被缩小为相应的接口类型。因此，我们对参数 c 进行相关操作时，也就不会提示类型错误了。</p>\n\n\n\n<h4 data-nodeid=\"97568\" class=\"\">2. 字面量恒等</h4>\n\n<p data-nodeid=\"94859\">switch 适用的场景往往也可以直接使用字面量恒等比较进行替换，比如前边的 convert 函数可以改造成以下示例：</p>\n<pre class=\"lang-typescript\" data-nodeid=\"94860\"><code data-language=\"typescript\">  <span class=\"hljs-keyword\">const</span> convert = <span class=\"hljs-function\">(<span class=\"hljs-params\">c: 'a' | 1</span>) =&gt;</span> {\n    <span class=\"hljs-keyword\">if</span> (c === <span class=\"hljs-number\">1</span>) {\n      <span class=\"hljs-keyword\">return</span> c.toFixed(); <span class=\"hljs-comment\">// c is 1</span>\n    } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (c === <span class=\"hljs-string\">'a'</span>) {\n        <span class=\"hljs-keyword\">return</span> c.toLowerCase(); <span class=\"hljs-comment\">// c is 'a'</span>\n    }\n  }\n</code></pre>\n<p data-nodeid=\"94861\" class=\"\">在以上示例中，第 3 行、第 5 行的类型相应都缩小为了字面量 1 和 'a'。</p>\n<blockquote data-nodeid=\"94862\">\n<p data-nodeid=\"94863\" class=\"\">建议：一般来说，如果可枚举的值和条件分支越多，那么使用 switch 就会让代码逻辑更简洁、更清晰；反之，则推荐使用字面量恒等进行判断。</p>\n</blockquote>\n<h4 data-nodeid=\"98056\" class=\"\">3. typeof</h4>\n\n<p data-nodeid=\"94867\">反过来，当联合类型的成员不可枚举，比如说是字符串、数字等原子类型组成的集合，这个时候就需要使用 typeof。</p>\n<p data-nodeid=\"94868\">typeof 是一个比较特殊的操作符（15 讲中会再详细地介绍它），我们可以使用它对 convert 函数进行改造，如下代码所示：</p>\n<pre class=\"lang-typescript\" data-nodeid=\"94869\"><code data-language=\"typescript\">  <span class=\"hljs-keyword\">const</span> convert = <span class=\"hljs-function\">(<span class=\"hljs-params\">c: 'a' | 1</span>) =&gt;</span> {\n    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">typeof</span> c === <span class=\"hljs-string\">'number'</span>) {\n      <span class=\"hljs-keyword\">return</span> c.toFixed(); <span class=\"hljs-comment\">// c is 1</span>\n    } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">typeof</span> c === <span class=\"hljs-string\">'string'</span>) {\n        <span class=\"hljs-keyword\">return</span> c.toLowerCase(); <span class=\"hljs-comment\">// c is 'a'</span>\n    }\n  }\n</code></pre>\n<p data-nodeid=\"94870\">在上述示例中，因为 typeof c 表达式的返回值类型是字面量联合类型 'string' | 'number' | 'bigint' | 'boolean' | 'symbol' | 'undefined' | 'object' | 'function'，所以通过字面量恒等判断我们把在第 2 行和第 4 行的 typeof c 表达式值类型进行了缩小，进而将 c 的类型缩小为明确的 string、number 等原子类型。</p>\n<h4 data-nodeid=\"98540\" class=\"\">4. instanceof</h4>\n\n<p data-nodeid=\"94874\">此外，联合类型的成员还可以是类。比如以下示例中的第 9 行和第 11 行，我们使用了 instanceof 来判断 param 是 Dog 还是 Cat 类。</p>\n<pre class=\"lang-typescript\" data-nodeid=\"94875\"><code data-language=\"typescript\">{\n  <span class=\"hljs-keyword\">class</span> Dog {\n    wang = <span class=\"hljs-string\">'wangwang'</span>;\n  }\n  <span class=\"hljs-keyword\">class</span> Cat {\n    miao = <span class=\"hljs-string\">'miaomiao'</span>;\n  }\n  <span class=\"hljs-keyword\">const</span> getName = <span class=\"hljs-function\">(<span class=\"hljs-params\">animal: Dog | Cat</span>) =&gt;</span> {\n    <span class=\"hljs-keyword\">if</span> (animal <span class=\"hljs-keyword\">instanceof</span> Dog) {\n      <span class=\"hljs-keyword\">return</span> animal.wang;\n    } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (animal <span class=\"hljs-keyword\">instanceof</span> Cat) {\n      <span class=\"hljs-keyword\">return</span> animal.miao;\n    }\n  }\n}\n</code></pre>\n<p data-nodeid=\"94876\">这里我们可以看到，第 10 行、第 12 行的 animal 的类型也缩小为 Dog、Cat 了。接下来我们看看更复杂的情况——in。</p>\n<h4 data-nodeid=\"99020\" class=\"\">5. in</h4>\n\n<p data-nodeid=\"94880\">当联合类型的成员包含接口类型（对象），并且接口之间的属性不同，如下示例中的接口类型 Dog、Cat，我们不能直接通过“ . ”操作符获取 param 的 wang、miao 属性，从而区分它是 Dog 还是 Cat。</p>\n<pre class=\"lang-typescript\" data-nodeid=\"94881\"><code data-language=\"typescript\">{\n  <span class=\"hljs-keyword\">interface</span> Dog {\n    wang: <span class=\"hljs-built_in\">string</span>;\n  }\n  <span class=\"hljs-keyword\">interface</span> Cat {\n    miao: <span class=\"hljs-built_in\">string</span>;\n  }\n  <span class=\"hljs-keyword\">const</span> getName = <span class=\"hljs-function\">(<span class=\"hljs-params\">animal: Dog | Cat</span>) =&gt;</span> {\n    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">typeof</span> animal.wang == <span class=\"hljs-string\">'string'</span>) { <span class=\"hljs-comment\">// ts(2339)</span>\n      <span class=\"hljs-keyword\">return</span> animal.wang; <span class=\"hljs-comment\">// ts(2339)</span>\n    } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (animal.miao) { <span class=\"hljs-comment\">// ts(2339)</span>\n      <span class=\"hljs-keyword\">return</span> animal.miao; <span class=\"hljs-comment\">// ts(2339)</span>\n    }\n  }\n}\n</code></pre>\n<p data-nodeid=\"94882\">这里我们看到，在第 9~12 行都提示了一个 ts(2339)  Dog | Cat 联合类型没有 wang、miao 属性的错误。</p>\n<p data-nodeid=\"94883\">这个时候我们就需要使用 in 操作符来改造一下 getName 函数， 这样就不会提示类型错误了，如下代码所示：</p>\n<pre class=\"lang-typescript\" data-nodeid=\"94884\"><code data-language=\"typescript\"><span class=\"hljs-keyword\">const</span> getName = <span class=\"hljs-function\">(<span class=\"hljs-params\">animal: Dog | Cat</span>) =&gt;</span> {\n    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-string\">'wang'</span> <span class=\"hljs-keyword\">in</span> animal) { <span class=\"hljs-comment\">// ok</span>\n      <span class=\"hljs-keyword\">return</span> animal.wang; <span class=\"hljs-comment\">// ok</span>\n    } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-string\">'miao'</span> <span class=\"hljs-keyword\">in</span> animal) { <span class=\"hljs-comment\">// ok</span>\n      <span class=\"hljs-keyword\">return</span> animal.miao; <span class=\"hljs-comment\">// ok</span>\n    }\n  }\n</code></pre>\n<p data-nodeid=\"99968\">这里我们可以看到，第 3 行、第 4 行中的 animal 的类型也缩小成 Dog 和 Cat 了。</p>\n<p data-nodeid=\"99969\">最后我们要介绍的是自定义类型守卫，确切地讲是自定义函数，</p>\n\n<h4 data-nodeid=\"99496\" class=\"\">6. 自定义类型守卫</h4>\n\n<p data-nodeid=\"94889\">这时我们将使用 05 讲中学习过的类型谓词 is，比如封装一个 isDog 函数来区分 Dog 和 Cat，如下代码所示：</p>\n<pre class=\"lang-typescript\" data-nodeid=\"94890\"><code data-language=\"typescript\">  <span class=\"hljs-keyword\">const</span> isDog = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">animal: Dog | Cat</span>): <span class=\"hljs-title\">animal</span> <span class=\"hljs-title\">is</span> <span class=\"hljs-title\">Dog</span> </span>{\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">'wang'</span> <span class=\"hljs-keyword\">in</span> animal;\n  }\n  <span class=\"hljs-keyword\">const</span> getName = <span class=\"hljs-function\">(<span class=\"hljs-params\">animal: Dog | Cat</span>) =&gt;</span> {\n    <span class=\"hljs-keyword\">if</span> (isDog(animal)) {\n      <span class=\"hljs-keyword\">return</span> animal.wang;\n    }\n  }\n</code></pre>\n<p data-nodeid=\"94891\">这里我们在 getName 函数第 5 行的条件判断中使用了 isDog 将 animal 的类型缩小为 Dog，这样第 6 行就可以直接获取 wang 属性了，而不会提示一个 ts(2339) 的错误。</p>\n<p data-nodeid=\"94892\">除了联合类型之外，另外一个类型集合是枚举类型，下面我们聊聊如何区别枚举类型。</p>\n<h3 data-nodeid=\"94893\">如何区别枚举类型？</h3>\n<p data-nodeid=\"94894\">如 09 讲中介绍，枚举类型是命名常量的集合，所以我们也需要使用类型守卫区分枚举类型的成员。</p>\n<p data-nodeid=\"94895\">先回想一下枚举类型的若干特性，因为这将决定使用哪几种类型守卫来区分枚举既是可行的，又是安全的。</p>\n<p data-nodeid=\"94896\"><strong data-nodeid=\"95037\">特性 1</strong>：枚举和其他任何枚举、类型都不可比较，除了数字枚举可以与数字类型比较之外；</p>\n<p data-nodeid=\"94897\"><strong data-nodeid=\"95042\">特性 2</strong>：数字枚举极其不稳定。</p>\n<p data-nodeid=\"94898\">熟悉了这些特性后，得出一个结论：最佳实践时，我们永远不要拿枚举和除了自身之外的任何枚举、类型进行比较。</p>\n<p data-nodeid=\"94899\">下面我们看一个具体的示例：</p>\n<pre class=\"lang-typescript\" data-nodeid=\"94900\"><code data-language=\"typescript\">{\n  <span class=\"hljs-keyword\">enum</span> A {\n    one,\n    two\n  }\n  <span class=\"hljs-keyword\">enum</span> B {\n    one,\n    two\n  }\n  <span class=\"hljs-keyword\">const</span> cpWithNumber = <span class=\"hljs-function\">(<span class=\"hljs-params\">param: A</span>) =&gt;</span> {\n    <span class=\"hljs-keyword\">if</span> (param === <span class=\"hljs-number\">1</span>) { <span class=\"hljs-comment\">// bad</span>\n      <span class=\"hljs-keyword\">return</span> param;\n    }\n  }\n  <span class=\"hljs-keyword\">const</span> cpWithOtherEnum = <span class=\"hljs-function\">(<span class=\"hljs-params\">param: A</span>) =&gt;</span> {\n    <span class=\"hljs-keyword\">if</span> (param === B.two <span class=\"hljs-keyword\">as</span> unknown <span class=\"hljs-keyword\">as</span> A) { <span class=\"hljs-comment\">// ALERT bad</span>\n      <span class=\"hljs-keyword\">return</span> param;\n    }\n  }\n  <span class=\"hljs-keyword\">const</span> cpWithSelf = <span class=\"hljs-function\">(<span class=\"hljs-params\">param: A</span>) =&gt;</span> {\n    <span class=\"hljs-keyword\">if</span> (param === A.two) { <span class=\"hljs-comment\">// good</span>\n      <span class=\"hljs-keyword\">return</span> param;\n    }\n  }\n}\n</code></pre>\n<p data-nodeid=\"94901\">在第 10～14 行的函数 cpWithNumber 中，第 11 行我们将类型是枚举 A 的入参 param 和数字字面量 1 进行比较，因为 A 是数字枚举，所以 param 可以和 1 进行比较，而不会提示一个 ts(2367) 条件判断恒为 false 的错误。</p>\n<p data-nodeid=\"94902\">因为数字枚举不稳定，所以默认情况下 A.two 的值会是 1，因此第 11 行的条件判断在入参为 A.two 的时候为真。但是，如果我们给枚举 A 的成员 one 指定初始值 1，第 11 行的条件判断在入参为 A.two 的时候就为否了，因为 A.two 值变成了 2，所以这不是一个安全的实践。</p>\n<blockquote data-nodeid=\"94903\">\n<p data-nodeid=\"94904\">顺带再复习一下，在调用函数 cpWithNumber 的时候，我们使用数字类型做入参也是一种不安全的实践，原因同上。</p>\n</blockquote>\n<p data-nodeid=\"94905\">示例中第 15 ～ 19 行的函数 cpWithOtherEnum，我们使用了双重类型断言将枚举类型 B 转换为 A，主要是为了避免第 16 行提示一个 ts(2367) 错误，所以这同样也是一种不安全的实践。因为一旦 A 和 B 的结构出现了任何差异（比如给成员指定了不同的初始值、改变了成员的顺序或者个数），都会导致第 16 行的条件判断逻辑时真时否。</p>\n<blockquote data-nodeid=\"94906\">\n<p data-nodeid=\"94907\">注意：有时候我们确实避免不了像示例中第 16 行这样使用双重类型断言来绕过 TypeScript 静态类型检测，比如使用基于同一个 Swagger 定义自动生成的两个枚举类型。此时，我们就需要极其谨慎，而且还需要添加警示信息进行说明，比如第 16 行添加的 \"ALERT\" 注释。</p>\n</blockquote>\n<p data-nodeid=\"94908\">最安全的实践是使用第 21 行区分枚举成员的判断方式。</p>\n<p data-nodeid=\"94909\">以上结论，同样适用于使用其他类型守卫（例如 switch）来区分枚举成员的场景。</p>\n<blockquote data-nodeid=\"94910\">\n<p data-nodeid=\"94911\">注意：你应该还记得字面量成员枚举可等价为字面量成员类型组成的联合类型，所以类型守卫可以让字面量成员枚举发生类型缩小。比如第 22 行中 param 的类型是 A.two，此时如果我们在 VS Code 中 hover 到 param 变量上，则会看到一个信息验证提示。</p>\n</blockquote>\n<p data-nodeid=\"94912\">以上就是 TypeScript 中尽职尽责的类型守卫。</p>\n<p data-nodeid=\"94913\">不过，类型守卫实际上也会有力不足心的时候，下面我们一起看看失效的类型守卫。</p>\n<h3 data-nodeid=\"94914\">失效的类型守卫</h3>\n<p data-nodeid=\"94915\">失效的类型守卫指的是某些类型守卫应用在泛型函数中时不能缩小类型，即失效了。比如我们改造了一个可以接受泛型入参的 getName 函数，如下代码所示：</p>\n<pre class=\"lang-typescript\" data-nodeid=\"94916\"><code data-language=\"typescript\"><span class=\"hljs-keyword\">const</span> getName = &lt;T <span class=\"hljs-keyword\">extends</span> Dog | Cat&gt;<span class=\"hljs-function\">(<span class=\"hljs-params\">animal: T</span>) =&gt;</span> {\n  <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-string\">'wang'</span> <span class=\"hljs-keyword\">in</span> animal) {\n    <span class=\"hljs-keyword\">return</span> animal.wang; <span class=\"hljs-comment\">// ts(2339)</span>\n  }\n  <span class=\"hljs-keyword\">return</span> animal.miao; <span class=\"hljs-comment\">// ts(2339)</span>\n};\n</code></pre>\n<p data-nodeid=\"100442\">在上述示例中，虽然我们在第 2 行使用了 in 类型守卫，但是它并没有让 animal 的类型如预期那样缩小为 Dog 的子类型，所以第 3 行的 T 类型上没有 wang 属性，从而提示一个 ts(2339) 的错误。所以第 5 行的 animal 也不会缩小为 Cat 的子类型，从而也会提示一个 ts(2339) 的错误。</p>\n<p data-nodeid=\"100443\">可一旦我们把 in 操作换成自定义类型守卫 isDog 或者使用 instanceOf，animal 的类型就会缩小成了 Dog 的子类型（T &amp; Dog），所以第 3 行不会提示 ts(2339) 的错误。由此可见，in 和 instanceOf、类型谓词在泛型类型缩小上是有区别的。</p>\n\n<pre class=\"lang-typescript\" data-nodeid=\"94918\"><code data-language=\"typescript\"><span class=\"hljs-keyword\">const</span> getName = &lt;T <span class=\"hljs-keyword\">extends</span> Dog | Cat&gt;<span class=\"hljs-function\">(<span class=\"hljs-params\">animal: T</span>) =&gt;</span> {\n  <span class=\"hljs-keyword\">if</span> (isDog(animal)) { <span class=\"hljs-comment\">// instanceOf 亦可</span>\n    <span class=\"hljs-keyword\">return</span> animal.wang; <span class=\"hljs-comment\">// ok</span>\n  }\n  <span class=\"hljs-keyword\">return</span> animal.miao; <span class=\"hljs-comment\">// ts(2339)</span>\n};\n</code></pre>\n<p data-nodeid=\"100918\">但是，在缺省的 else 条件分支里，animal 的类型并没有缩小成 Cat 的子类型，所以第 5 行依旧会提示一个 ts(2339) 的错误（这是一个不太科学的设计，所幸在 TypeScript 4.3.2 里已经修改了）。</p>\n<p data-nodeid=\"100919\">这个时候，就需要使用类型断言，如下代码所示：</p>\n\n<pre class=\"lang-typescript\" data-nodeid=\"94920\"><code data-language=\"typescript\"><span class=\"hljs-keyword\">const</span> getName = &lt;T <span class=\"hljs-keyword\">extends</span> Dog | Cat&gt;<span class=\"hljs-function\">(<span class=\"hljs-params\">animal: T</span>) =&gt;</span> {\n  <span class=\"hljs-keyword\">if</span> (isDog(animal)) { <span class=\"hljs-comment\">// instanceOf 亦可</span>\n    <span class=\"hljs-keyword\">return</span> animal.wang; <span class=\"hljs-comment\">// ok</span>\n  }\n  <span class=\"hljs-keyword\">return</span> (animal <span class=\"hljs-keyword\">as</span> Cat).miao; <span class=\"hljs-comment\">// ts(2339)</span>\n};\n</code></pre>\n<p data-nodeid=\"94921\">在第 5 行，我们把 animal 的类型断言为 Cat，并获取了它的 miao 属性。</p>\n<h3 data-nodeid=\"94922\">小结和预告</h3>\n<p data-nodeid=\"94923\">好了，以上就是这一讲的主要内容。</p>\n<p data-nodeid=\"94924\">可能你已经发现，所谓的高阶内容并不仅仅指新增了多少高难度的知识点，还包括对之前所学的知识的综合回顾。因为任何进阶的知识、技能都是建立在之前打下坚实的基础之上。</p>\n<p data-nodeid=\"94925\">插播一道思考题：如何区分不同的接口对象类型？欢迎你在留言区交流、互动？</p>\n<p data-nodeid=\"94926\">12 讲我们将学习类型的兼容性，了解如何判定一个类型能否赋值给其他类型，敬请期待~</p>\n<p data-nodeid=\"94927\">另外，如果你觉得本专栏有价值，欢迎分享给更多好友~</p>",
                "article_title": "11 | 类型守卫：如何有效地保障类型的安全性？",
                "title": "11 | 类型守卫：如何有效地保障类型的安全性？",
                "id": 7443
            },
            {
                "content": "<p data-nodeid=\"102523\">因为 TypeScript 中有静态类型检测，所以我们再也不用像 JavaScript 中那样，赋给变量任意类型的值。</p>\n\n\n<p data-nodeid=\"101394\">在 TypeScript 中，能不能把一个类型赋值给其他类型是由类型兼容性决定的。因此，这一讲我们将围绕这个问题给出对应的答案。</p>\n<blockquote data-nodeid=\"101395\">\n<p data-nodeid=\"101396\" class=\"\">学习建议：使用 VS Code 新建一个 12.ts 文件，尝试这一讲中出现的所有代码示例，另外有的示例会提示 ts(2454) 错误，因为并不影响我想表达的知识点，所以在学习时你直接忽略就可以了。</p>\n</blockquote>\n<h3 data-nodeid=\"103275\">特例</h3>\n\n\n<p data-nodeid=\"101399\">首先，我们回顾一下 any、never、unknown 等特殊类型，它们在类型兼容性上十分有特色。</p>\n<h4 data-nodeid=\"101400\">（1）any</h4>\n<p data-nodeid=\"101401\">在 03 讲中，我们提及了万金油 any 类型可以赋值给除了 never 之外的任意其他类型，反过来其他类型也可以赋值给 any。也就是说 any 可以兼容除 never 之外所有的类型，同时也可以被所有的类型兼容（即 any 既是 bottom type，也是 top type）。因为 any 太特殊，这里我就不举例子了。</p>\n<blockquote data-nodeid=\"101402\">\n<p data-nodeid=\"101403\">再次强调：Any is 魔鬼，我们一定要慎用、少用。</p>\n</blockquote>\n<h4 data-nodeid=\"101404\">（2）never</h4>\n<p data-nodeid=\"101405\">never 的特性是可以赋值给任何其他类型，但反过来不能被其他任何类型（包括 any 在内）赋值（即 never 是 bottom type）。比如以下示例中的第 5~7 行，我们可以把 never 赋值给 number、函数、对象类型。</p>\n<pre class=\"lang-typescript\" data-nodeid=\"101406\"><code data-language=\"typescript\">{\n  <span class=\"hljs-keyword\">let</span> never: never = <span class=\"hljs-function\">(<span class=\"hljs-params\">(<span class=\"hljs-params\"></span>) =&gt; {\n    <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-built_in\">Error</span>(<span class=\"hljs-params\">'never'</span>);\n  }</span>)<span class=\"hljs-params\">()</span>;\n  <span class=\"hljs-params\">let</span> <span class=\"hljs-params\">a</span>: <span class=\"hljs-params\">number</span> = <span class=\"hljs-params\">never</span>; // <span class=\"hljs-params\">ok</span>\n  <span class=\"hljs-params\">let</span> <span class=\"hljs-params\">b</span>: <span class=\"hljs-params\">()</span> =&gt;</span> <span class=\"hljs-built_in\">any</span> = never; <span class=\"hljs-comment\">// ok</span>\n  <span class=\"hljs-keyword\">let</span> c: {} = never; <span class=\"hljs-comment\">// ok</span>\n}\n</code></pre>\n<h4 data-nodeid=\"101407\">（3）unknown</h4>\n<p data-nodeid=\"101408\">unknown 的特性和 never 的特性几乎反过来，即我们不能把 unknown 赋值给除了 any 之外任何其他类型，反过来其他类型都可以赋值给 unknown（即 unknown 是 top type）。比如以下示例中的第 3~5 行提示了一个 ts(2322) unknown 类型不能赋值给其他任何类型的错误。</p>\n<pre class=\"lang-typescript\" data-nodeid=\"101409\"><code data-language=\"typescript\">{\n  <span class=\"hljs-keyword\">let</span> unknown: unknown;\n  <span class=\"hljs-keyword\">const</span> a: <span class=\"hljs-built_in\">number</span> = unknown; <span class=\"hljs-comment\">// ts(2322)</span>\n  <span class=\"hljs-keyword\">const</span> b: <span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> <span class=\"hljs-built_in\">any</span> = unknown; <span class=\"hljs-comment\">// ts(2322)</span>\n  <span class=\"hljs-keyword\">const</span> c: {} = unknown; <span class=\"hljs-comment\">// ts(2322)</span>\n}\n</code></pre>\n<h4 data-nodeid=\"101410\">（4）void、null、undefined</h4>\n<p data-nodeid=\"101411\">void、null、undefined 这三大废材类型的兼容性也很特别，比如 void 类型仅可以赋值给 any 和 unknown 类型（下面示例第 9~10 行），反过来仅 any、never、undefined 可以赋值给 void（下面示例第 11~13 行）。</p>\n<pre class=\"lang-typescript\" data-nodeid=\"101412\"><code data-language=\"typescript\">{\n  <span class=\"hljs-keyword\">let</span> thisIsAny: <span class=\"hljs-built_in\">any</span>;\n  <span class=\"hljs-keyword\">let</span> thisIsNever: never;\n  <span class=\"hljs-keyword\">let</span> thisIsUnknown: unknown;\n  <span class=\"hljs-keyword\">let</span> thisIsVoid: <span class=\"hljs-built_in\">void</span>;\n  <span class=\"hljs-keyword\">let</span> thisIsUndefined: <span class=\"hljs-literal\">undefined</span>;\n  <span class=\"hljs-keyword\">let</span> thisIsNull: <span class=\"hljs-literal\">null</span>;\n  thisIsAny = thisIsVoid; <span class=\"hljs-comment\">// ok</span>\n  thisIsUnknown = thisIsVoid; <span class=\"hljs-comment\">// ok</span>\n  thisIsVoid = thisIsAny; <span class=\"hljs-comment\">// ok</span>\n  thisIsVoid = thisIsNever; <span class=\"hljs-comment\">// ok</span>\n  thisIsVoid = thisIsUndefined; <span class=\"hljs-comment\">// ok</span>\n  thisIsAny = thisIsNull; <span class=\"hljs-comment\">// ok</span>\n  thisIsUnknown = thisIsNull; <span class=\"hljs-comment\">// ok</span>\n  thisIsAny = thisIsUndefined; <span class=\"hljs-comment\">// ok</span>\n  thisIsUnknown = thisIsUndefined; <span class=\"hljs-comment\">// ok</span>\n  \n  thisIsNull = thisIsAny; <span class=\"hljs-comment\">// ok</span>\n  thisIsNull = thisIsNever; <span class=\"hljs-comment\">// ok</span>\n  thisIsUndefined = thisIsAny; <span class=\"hljs-comment\">// ok</span>\n  thisIsUndefined = thisIsNever; <span class=\"hljs-comment\">// ok</span>\n}\n</code></pre>\n<p data-nodeid=\"101413\">在我们推崇并使用的严格模式下，null、undefined 表现出与 void 类似的兼容性，即不能赋值给除 any 和 unknown 之外的其他类型（上面示例第 15~18 行），反过来其他类型（除了 any 和 never 之外）都不可以赋值给 null 或 undefined（上面示例第 20~23 行）。</p>\n<h4 data-nodeid=\"101414\">（5）enum</h4>\n<p data-nodeid=\"101415\">最后一个特例是 enum 枚举类型，其中数字枚举和数字类型相互兼容。</p>\n<p data-nodeid=\"101416\">在如下示例中，我们在第 5 行把枚举 A 赋值给了数字（number）类型，并在第 7 行使用数字字面量 1 替代了枚举 A。</p>\n<pre class=\"lang-typescript\" data-nodeid=\"101417\"><code data-language=\"typescript\">{\n  <span class=\"hljs-keyword\">enum</span> A {\n    one\n  }\n  <span class=\"hljs-keyword\">let</span> num: <span class=\"hljs-built_in\">number</span> = A.one; <span class=\"hljs-comment\">// ok</span>\n  <span class=\"hljs-keyword\">let</span> fun = <span class=\"hljs-function\">(<span class=\"hljs-params\">param: A</span>) =&gt;</span> <span class=\"hljs-built_in\">void</span> <span class=\"hljs-number\">0</span>;\n  fun(<span class=\"hljs-number\">1</span>); <span class=\"hljs-comment\">// ok </span>\n}\n</code></pre>\n<p data-nodeid=\"101418\">此外，不同枚举之间不兼容。如下示例中的第 10~11 行，因为枚举 A 和 B 不兼容，所以都会提示一个 ts(2322) 类型的错误。</p>\n<pre class=\"lang-typescript\" data-nodeid=\"101419\"><code data-language=\"typescript\">{\n  <span class=\"hljs-keyword\">enum</span> A {\n    one\n  }\n  <span class=\"hljs-keyword\">enum</span> B {\n    one\n  }\n  <span class=\"hljs-keyword\">let</span> a: A;\n  <span class=\"hljs-keyword\">let</span> b: B;\n  a = b; <span class=\"hljs-comment\">// ts(2322)</span>\n  b = a; <span class=\"hljs-comment\">// ts(2322)</span>\n}\n</code></pre>\n<h3 data-nodeid=\"101420\">类型兼容性</h3>\n<p data-nodeid=\"101421\">除了前边提到的所有特例，TypeScript 中类型的兼容性都是基于结构化子类型的一般原则进行判定的。</p>\n<p data-nodeid=\"101422\">下面我们从结构化类型和子类型这两方面了解一下一般原则。</p>\n<h4 data-nodeid=\"101423\">（1）子类型</h4>\n<p data-nodeid=\"101424\">从子类型的角度来看，所有的子类型与它的父类型都兼容，如下代码所示：</p>\n<pre class=\"lang-typescript\" data-nodeid=\"101425\"><code data-language=\"typescript\">{\n  <span class=\"hljs-keyword\">const</span> one = <span class=\"hljs-number\">1</span>;\n  <span class=\"hljs-keyword\">let</span> num: <span class=\"hljs-built_in\">number</span> = one; <span class=\"hljs-comment\">// ok</span>\n  <span class=\"hljs-keyword\">interface</span> IPar {\n    name: <span class=\"hljs-built_in\">string</span>;\n  }\n  <span class=\"hljs-keyword\">interface</span> IChild <span class=\"hljs-keyword\">extends</span> IPar {\n    id: <span class=\"hljs-built_in\">number</span>;\n  }\n  <span class=\"hljs-keyword\">let</span> Par: IPar;\n  <span class=\"hljs-keyword\">let</span> Child: IChild;\n  Par = Child; <span class=\"hljs-comment\">// ok</span>\n  <span class=\"hljs-keyword\">class</span> CPar {\n    cname = <span class=\"hljs-string\">''</span>;\n  }\n  <span class=\"hljs-keyword\">class</span> CChild <span class=\"hljs-keyword\">extends</span> CPar {\n    cid = <span class=\"hljs-number\">1</span>;\n  }\n  <span class=\"hljs-keyword\">let</span> ParInst: CPar;\n  <span class=\"hljs-keyword\">let</span> ChildInst: CChild;\n  ParInst = ChildInst; <span class=\"hljs-comment\">// ok</span>\n  <span class=\"hljs-keyword\">let</span> mixedNum: <span class=\"hljs-number\">1</span> | <span class=\"hljs-number\">2</span> | <span class=\"hljs-number\">3</span> = one; <span class=\"hljs-comment\">// ok</span>\n}\n</code></pre>\n<p data-nodeid=\"101426\">在示例中的第 3 行，我们可以把类型是数字字面量类型的 one 赋值给数字类型的 num。在第 12 行，我们可以把子接口类型的变量赋值给 Par。在第 21 行，我们可以把子类实例 ChildInst 赋值给 ParInst。</p>\n<p data-nodeid=\"101427\">因为成员类型兼容它所属的类型集合（其实联合类型和枚举都算类型集合，这里主要说的是联合类型），所以在示例中的第 22 行，我们可以把 one 赋值给包含字面类型 1 的联合类型。</p>\n<p data-nodeid=\"101428\">举一反三，由子类型组成的联合类型也可以兼容它们父类型组成的联合类型，如下代码所示：</p>\n<pre class=\"lang-typescript\" data-nodeid=\"101429\"><code data-language=\"typescript\">  <span class=\"hljs-keyword\">let</span> ICPar: IPar | CPar;\n  <span class=\"hljs-keyword\">let</span> ICChild: IChild | CChild;\n  ICPar = ICChild; <span class=\"hljs-comment\">// ok</span>\n</code></pre>\n<p data-nodeid=\"101430\">在示例中的第 3 行，因为 IChild 是 IPar 的子类，CChild 是 CPar 的子类，所以 IChild | CChild 也是 IPar | CPar 的子类，进而 ICChild 可以赋值给 ICPar。</p>\n<h4 data-nodeid=\"101431\">（2）结构类型</h4>\n<p data-nodeid=\"101432\">类型兼容性的另一准则是结构类型，即如果两个类型的结构一致，则它们是互相兼容的。比如拥有相同类型的属性、方法的接口类型或类，则可以互相赋值。</p>\n<p data-nodeid=\"101433\">下面我们看一个具体的示例：</p>\n<pre class=\"lang-typescript\" data-nodeid=\"101434\"><code data-language=\"typescript\">{\n  <span class=\"hljs-keyword\">class</span> C1 {\n    name = <span class=\"hljs-string\">'1'</span>;\n  }\n  <span class=\"hljs-keyword\">class</span> C2 {\n    name = <span class=\"hljs-string\">'2'</span>;\n  }\n  <span class=\"hljs-keyword\">interface</span> I1 {\n    name: <span class=\"hljs-built_in\">string</span>;\n  }\n  <span class=\"hljs-keyword\">interface</span> I2 {\n    name: <span class=\"hljs-built_in\">string</span>;\n  }\n  <span class=\"hljs-keyword\">let</span> InstC1: C1;\n  <span class=\"hljs-keyword\">let</span> InstC2: C2;\n  <span class=\"hljs-keyword\">let</span> O1: I1;\n  <span class=\"hljs-keyword\">let</span> O2: I2;\n  InstC1 = InstC2; <span class=\"hljs-comment\">// ok</span>\n  O1 = O2; <span class=\"hljs-comment\">// ok</span>\n  InstC1 = O1; <span class=\"hljs-comment\">// ok</span>\n  O2 = InstC2; <span class=\"hljs-comment\">// ok</span>\n}\n</code></pre>\n<p data-nodeid=\"101435\">因为类 C1、类 C2、接口类型 I1、接口类型 I2 的结构完全一致，所以在第 18~19 行我们可以把类 C2 的实例 InstC2 赋值给类 C1 的实例 Inst1，把接口类型 I2 的变量 O2 赋值给接口类型 I1 的变量 O1。</p>\n<p data-nodeid=\"101436\">在第 20~21 行，我们甚至可以把接口类型 I1 的变量 O1 赋值给类 C1 的实例，类 C2 的实例赋值给接口类型 I2 的变量 O2。</p>\n<p data-nodeid=\"101437\">另外一个特殊的场景：两个接口类型或者类，如果其中一个类型不仅拥有另外一个类型全部的属性和方法，还包含其他的属性和方法（如同继承自另外一个类型的子类一样），那么前者是可以兼容后者的。</p>\n<p data-nodeid=\"101438\">下面我们看一个具体的示例：</p>\n<pre class=\"lang-typescript\" data-nodeid=\"101439\"><code data-language=\"typescript\">{\n  <span class=\"hljs-keyword\">interface</span> I1 {\n    name: <span class=\"hljs-built_in\">string</span>;\n  }\n  <span class=\"hljs-keyword\">interface</span> I2 {\n    id: <span class=\"hljs-built_in\">number</span>;\n    name: <span class=\"hljs-built_in\">string</span>;\n  }\n  <span class=\"hljs-keyword\">class</span> C2 {\n    id = <span class=\"hljs-number\">1</span>;\n    name = <span class=\"hljs-string\">'1'</span>;\n  }\n  <span class=\"hljs-keyword\">let</span> O1: I1;\n  <span class=\"hljs-keyword\">let</span> O2: I2;\n  <span class=\"hljs-keyword\">let</span> InstC2: C2;\n  O1 = O2;\n  O1 = InstC2;\n}\n</code></pre>\n<p data-nodeid=\"101440\">在示例中的第 16~17 行，我们可以把类 C2 的实例 InstC2 和接口类型 I2 的变量 O2 赋值给接口类型 I1 的变量 O1，这是因为类 C2、接口类型 I2 和接口类型 I1 的 name 属性都是 string。不过，因为变量 O2、类 C2 都包含了额外的属性 id，所以我们不能把变量 O1 赋值给实例 InstC2、变量 O2。</p>\n<p data-nodeid=\"101441\"><strong data-nodeid=\"101603\">这里涉及一个需要特别注意的特性：虽然包含多余属性 id 的变量 O2 可以赋值给变量 O1，但是如果我们直接将一个与变量 O2 完全一样结构的对象字面量赋值给变量 O1，则会提示一个 ts(2322) 类型不兼容的错误（如下示例第 2 行），这就是对象字面的 freshness 特性。</strong></p>\n<p data-nodeid=\"101442\">也就是说一个对象字面量没有被变量接收时，它将处于一种 freshness 新鲜的状态。这时 TypeScript 会对对象字面量的赋值操作进行严格的类型检测，只有目标变量的类型与对象字面量的类型完全一致时，对象字面量才可以赋值给目标变量，否则会提示类型错误。</p>\n<p data-nodeid=\"101443\">当然，我们也可以通过使用变量接收对象字面量或使用类型断言解除 freshness，如下示例：</p>\n<pre class=\"lang-typescript\" data-nodeid=\"101444\"><code data-language=\"typescript\">  O1 = {\n    id: <span class=\"hljs-number\">2</span>, <span class=\"hljs-comment\">// ts(2322)</span>\n    name: <span class=\"hljs-string\">'name'</span>\n  };\n  <span class=\"hljs-keyword\">let</span> O3 = {\n    id: <span class=\"hljs-number\">2</span>,\n    name: <span class=\"hljs-string\">'name'</span>\n  };\n  O1 = O3; <span class=\"hljs-comment\">// ok</span>\n  O1 = {\n    id: <span class=\"hljs-number\">2</span>,\n    name: <span class=\"hljs-string\">'name'</span>\n  } <span class=\"hljs-keyword\">as</span> I2; <span class=\"hljs-comment\">// ok</span>\n</code></pre>\n<p data-nodeid=\"101445\">在示例中，我们在第 5 行和第 13 行把包含多余属性的类型赋值给了变量 O1，没有提示类型错误。</p>\n<p data-nodeid=\"101446\">另外，我们还需要注意类兼容性特性：实际上，在判断两个类是否兼容时，我们可以完全忽略其构造函数及静态属性和方法是否兼容，只需要比较类实例的属性和方法是否兼容即可。如果两个类包含私有、受保护的属性和方法，则仅当这些属性和方法源自同一个类，它们才兼容。</p>\n<p data-nodeid=\"101447\">下面我们看一个具体的示例：</p>\n<pre class=\"lang-java\" data-nodeid=\"101448\"><code data-language=\"java\">{\n  <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">C1</span> </span>{\n    name = <span class=\"hljs-string\">'1'</span>;\n    <span class=\"hljs-keyword\">private</span> id = <span class=\"hljs-number\">1</span>;\n    <span class=\"hljs-keyword\">protected</span> age = <span class=\"hljs-number\">30</span>;\n  }\n  <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">C2</span> </span>{\n    name = <span class=\"hljs-string\">'2'</span>;\n    <span class=\"hljs-keyword\">private</span> id = <span class=\"hljs-number\">1</span>;\n    <span class=\"hljs-keyword\">protected</span> age = <span class=\"hljs-number\">30</span>;\n  }\n  let InstC1: C1;\n  let InstC2: C2;\n  InstC1 = InstC2; <span class=\"hljs-comment\">// ts(2322)</span>\n  InstC2 = InstC1; <span class=\"hljs-comment\">// ts(2322)</span>\n}\n{\n  <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">CPar</span> </span>{\n    <span class=\"hljs-keyword\">private</span> id = <span class=\"hljs-number\">1</span>;\n    <span class=\"hljs-keyword\">protected</span> age = <span class=\"hljs-number\">30</span>;\n  }\n  <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">C1</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">CPar</span> </span>{\n    constructor(inital: string) {\n      <span class=\"hljs-keyword\">super</span>();\n    }\n    name = <span class=\"hljs-string\">'1'</span>;\n    <span class=\"hljs-keyword\">static</span> gender = <span class=\"hljs-string\">'man'</span>;\n  }\n  <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">C2</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">CPar</span> </span>{\n    constructor(inital: number) {\n      <span class=\"hljs-keyword\">super</span>();\n    }\n    name = <span class=\"hljs-string\">'2'</span>;\n    <span class=\"hljs-keyword\">static</span> gender = <span class=\"hljs-string\">'woman'</span>;\n  }\n  let InstC1: C1;\n  let InstC2: C2;\n  InstC1 = InstC2; <span class=\"hljs-comment\">// ok</span>\n  InstC2 = InstC1; <span class=\"hljs-comment\">// ok</span>\n}\n</code></pre>\n<p data-nodeid=\"101449\">在示例中的第 14~15 行，因为类 C1 和类 C2 各自包含私有和受保护的属性，且实例 InstC1 和 InstC2 不能相互赋值，所以提示了一个 ts(2322) 类型的错误。</p>\n<p data-nodeid=\"101450\">在第 38~39 行，因为类 C1、类 C2 的私有、受保护属性都继承自同一个父类 CPar，所以检测类型兼容性时会忽略其类型不相同的构造函数和静态属性 gender，也因此实例 InstC1 和 实例 InstC2 之间可以相互赋值。</p>\n<h4 data-nodeid=\"101451\">（3）可继承和可实现</h4>\n<p data-nodeid=\"101452\">类型兼容性还决定了接口类型和类是否可以通过 extends 继承另外一个接口类型或者类，以及类是否可以通过 implements 实现接口。</p>\n<p data-nodeid=\"101453\">下面我们看一个具体示例：</p>\n<pre class=\"lang-typescript\" data-nodeid=\"101454\"><code data-language=\"typescript\">{\n  <span class=\"hljs-keyword\">interface</span> I1 {\n    name: <span class=\"hljs-built_in\">number</span>;\n  }\n  <span class=\"hljs-keyword\">interface</span> I2 <span class=\"hljs-keyword\">extends</span> I1 { <span class=\"hljs-comment\">// ts(2430)</span>\n    name: <span class=\"hljs-built_in\">string</span>;\n  }\n  <span class=\"hljs-keyword\">class</span> C1 {\n    name = <span class=\"hljs-string\">'1'</span>;\n    <span class=\"hljs-keyword\">private</span> id = <span class=\"hljs-number\">1</span>;\n  }\n  <span class=\"hljs-keyword\">class</span> C2 <span class=\"hljs-keyword\">extends</span> C1 { <span class=\"hljs-comment\">// ts(2415)</span>\n    name = <span class=\"hljs-string\">'2'</span>;\n    <span class=\"hljs-keyword\">private</span> id = <span class=\"hljs-number\">1</span>;\n  }\n  <span class=\"hljs-keyword\">class</span> C3 <span class=\"hljs-keyword\">implements</span> I1 {\n    name = <span class=\"hljs-string\">''</span>; <span class=\"hljs-comment\">// ts(2416)</span>\n  }\n}\n</code></pre>\n<p data-nodeid=\"101455\">在示例中的第 5 行，因为接口类型 I1 和接口类型 I2 包含不同类型的 name 属性不兼容，所以接口类型 I2 不能继承接口类型 I1。</p>\n<p data-nodeid=\"101456\">同样，在第 12 行，因为类 C1 和类 C2 不满足类兼容条件，所以类 C2 也不能继承类 C1。</p>\n<p data-nodeid=\"101457\">而在第 16 行，因为接口类型 I1 和类 C3 包含不同类型的 name 属性，所以类 C3 不能实现接口类型 I1。</p>\n<p data-nodeid=\"101458\">学习了类型兼容性的一般原则，下面再来看看拥有类型入参的泛型。</p>\n<h3 data-nodeid=\"101459\">泛型</h3>\n<p data-nodeid=\"101460\">泛型类型、泛型类的兼容性实际指的是将它们实例化为一个确切的类型后的兼容性。</p>\n<p data-nodeid=\"101461\">10 讲中我们介绍过可以通过指定类型入参实例化泛型，且入参只有作为实例化后的类型的一部分时才能影响类型兼容性，下面看一个具体的示例：</p>\n<pre class=\"lang-typescript\" data-nodeid=\"101462\"><code data-language=\"typescript\">{\n  <span class=\"hljs-keyword\">interface</span> I1&lt;T&gt; {\n    id: <span class=\"hljs-built_in\">number</span>;\n  }\n  <span class=\"hljs-keyword\">let</span> O1: I1&lt;<span class=\"hljs-built_in\">string</span>&gt;;\n  <span class=\"hljs-keyword\">let</span> O2: I1&lt;<span class=\"hljs-built_in\">number</span>&gt;;\n  O1 = O2; <span class=\"hljs-comment\">// ol</span>\n}\n</code></pre>\n<p data-nodeid=\"104779\" class=\"\">在示例中的第 7 行，因为接口泛型 I1 的入参 T 是无用的，且实例化类型 I1<code data-backticks=\"1\" data-nodeid=\"104781\">&lt;string&gt;</code> 和 I1<code data-backticks=\"1\" data-nodeid=\"104783\">&lt;numer&gt;</code> 的结构一致，即类型兼容，所以对应的变量 O2 可以给变量 O1赋值。</p>\n\n\n<p data-nodeid=\"101464\">而对于未明确指定类型入参泛型的兼容性，例如函数泛型（实际上仅有函数泛型才可以在不需要实例化泛型的情况下赋值），TypeScript 会把 any 类型作为所有未明确指定的入参类型实例化泛型，然后再检测其兼容性，如下代码所示：</p>\n<pre class=\"lang-typescript\" data-nodeid=\"101465\"><code data-language=\"typescript\">{\n  <span class=\"hljs-keyword\">let</span> fun1 = &lt;T&gt;(p1: T): <span class=\"hljs-number\">1</span> =&gt; <span class=\"hljs-number\">1</span>;\n  <span class=\"hljs-keyword\">let</span> fun2 = &lt;T&gt;(p2: T): <span class=\"hljs-function\"><span class=\"hljs-params\">number</span> =&gt;</span> <span class=\"hljs-number\">2</span>;\n  fun2 = fun1; <span class=\"hljs-comment\">// ok？</span>\n}\n</code></pre>\n<p data-nodeid=\"101466\">在示例中的第 4 行，实际上相当于在比较函数类型 (p1: any) =&gt; 1 和函数类型 (param: any) =&gt; number 的兼容性，那么这两个函数的类型兼容吗？答案：兼容。</p>\n\n<p data-nodeid=\"101469\">为什么兼容呢？这就涉及接下来我们要介绍的函数类型兼容性。在此之前，我们先了解一下判定函数类型兼容性的基础理论知识：变型。</p>\n<h3 data-nodeid=\"101470\">变型</h3>\n<p data-nodeid=\"101471\">TypeScript 中的变型指的是根据类型之间的子类型关系推断基于它们构造的更复杂类型之间的子类型关系。比如根据 Dog 类型是 Animal 类型子类型这样的关系，我们可以推断数组类型 Dog[] 和 Animal[] 、函数类型 () =&gt; Dog 和 () =&gt; Animal 之间的子类型关系。</p>\n<p data-nodeid=\"101472\">在描述类型和基于类型构造的复杂类型之间的关系时，我们可以使用数学中函数的表达方式。比如 Dog 类型，我们可以使用 F(Dog) 表示构造的复杂类型；F(Animal) 表示基于 Animal 构造的复杂类型。</p>\n<p data-nodeid=\"101473\">这里的变型描述的就是基于 Dog 和 Animal 之间的子类型关系，从而得出 F(Dog) 和 F(Animal) 之间的子类型关系的一般性质。而这个性质体现为子类型关系可能会被保持、反转、忽略，因此它可以被划分为协变、逆变、双向协变和不变这 4 个专业术语。</p>\n<p data-nodeid=\"101474\">接下来我们分别看一下这 4 个专业术语的具体定义。</p>\n<h4 data-nodeid=\"101475\">（1）协变</h4>\n<p data-nodeid=\"101476\">协变也就是说如果 Dog 是 Animal 的子类型，则 F(Dog) 是 F(Animal) 的子类型，这意味着在构造的复杂类型中保持了一致的子类型关系，下面举个简单的例子：</p>\n<pre class=\"lang-typescript\" data-nodeid=\"101477\"><code data-language=\"typescript\">{\n  <span class=\"hljs-keyword\">type</span> isChild&lt;Child, Par&gt; = Child <span class=\"hljs-keyword\">extends</span> Par ? <span class=\"hljs-literal\">true</span> : <span class=\"hljs-literal\">false</span>;\n  <span class=\"hljs-keyword\">interface</span> Animal {\n    name: <span class=\"hljs-built_in\">string</span>;\n  }\n  <span class=\"hljs-keyword\">interface</span> Dog <span class=\"hljs-keyword\">extends</span> Animal {\n    woof: <span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> <span class=\"hljs-built_in\">void</span>;\n  }\n  <span class=\"hljs-keyword\">type</span> Covariance&lt;T&gt; = T;\n  <span class=\"hljs-keyword\">type</span> isCovariant = isChild&lt;Covariance&lt;Dog&gt;, Covariance&lt;Animal&gt;&gt;; <span class=\"hljs-comment\">// true</span>\n}\n</code></pre>\n<p data-nodeid=\"101478\">在示例中的第 1 行，我们首先定义了一个用来判断两个类型入参 Child 和 Par 子类型关系的工具类型 isChild，如果 Child 是 Par 的子类型，那么 isChild 会返回布尔字面量类型 true，否则返回 false。</p>\n<p data-nodeid=\"101479\">然后在第 3~8 行，我们定义了 Animal 类型和它的子类型 Dog。</p>\n<p data-nodeid=\"107027\" class=\"\">在第 9 行，我们定义了泛型 Covariant 是一个复杂类型构造器，因为它原封不动返回了类型入参 T，所以对于构造出来的复杂类型 Covariant<code data-backticks=\"1\" data-nodeid=\"107029\">&lt;Dog&gt;</code> 和 Covariant<code data-backticks=\"1\" data-nodeid=\"107031\">&lt;Animal&gt;</code> 应该与类型入参 Dog 和 Animal 保持一致的子类型关系。</p>\n\n\n<p data-nodeid=\"108530\" class=\"\"><strong data-nodeid=\"108538\">在第 10 行，因为 Covariant<code data-backticks=\"1\" data-nodeid=\"108533\">&lt;Dog&gt;</code> 是 Covariant<code data-backticks=\"1\" data-nodeid=\"108535\">&lt;Animal&gt;</code> 的子类型，所以类型 isCovariant 是 true，这就是协变。</strong></p>\n\n\n<p data-nodeid=\"101482\">实际上接口类型的属性、数组类型、函数返回值的类型都是协变的，下面看一个具体的示例：</p>\n<pre class=\"lang-typescript\" data-nodeid=\"101483\"><code data-language=\"typescript\">  <span class=\"hljs-keyword\">type</span> isPropAssignmentCovariant = isChild&lt;{ <span class=\"hljs-keyword\">type</span>: Dog }, { <span class=\"hljs-keyword\">type</span>: Animal }&gt;; <span class=\"hljs-comment\">// true</span>\n  <span class=\"hljs-keyword\">type</span> isArrayElementCovariant = isChild&lt;Dog[], Animal[]&gt;; <span class=\"hljs-comment\">// true</span>\n  <span class=\"hljs-keyword\">type</span> isReturnTypeCovariant  = isChild&lt;<span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> Dog, <span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> Animal&gt;; <span class=\"hljs-comment\">// true</span>\n</code></pre>\n<p data-nodeid=\"101484\">在示例中的第1~3 行，我们看到 isPropAssignmentCovariant、isArrayElementCovariant、isReturnTypeCovariant 类型都是 true，即接口类型 { type: Dog } 是 { type: Animal } 的子类型，数组类型 Dog[] 是 Animal[] 的子类型，函数类型 () =&gt; Dog 也是 () =&gt; Animal 的子类型。</p>\n<h4 data-nodeid=\"101485\">（2）逆变</h4>\n<p data-nodeid=\"101486\">逆变也就是说如果 Dog 是 Animal 的子类型，则 F(Dog) 是 F(Animal) 的父类型，这与协变正好反过来。</p>\n<p data-nodeid=\"101487\">实际场景中，在我们推崇的 TypeScript 严格模式下，函数参数类型是逆变的，具体示例如下：</p>\n<pre class=\"lang-typescript\" data-nodeid=\"101488\"><code data-language=\"typescript\">  <span class=\"hljs-keyword\">type</span> Contravariance&lt;T&gt; = <span class=\"hljs-function\">(<span class=\"hljs-params\">param: T</span>) =&gt;</span> <span class=\"hljs-built_in\">void</span>;\n  <span class=\"hljs-keyword\">type</span> isNotContravariance = isChild&lt;Contravariance&lt;Dog&gt;, Contravariance&lt;Animal&gt;&gt;; <span class=\"hljs-comment\">// false;</span>\n  <span class=\"hljs-keyword\">type</span> isContravariance = isChild&lt;Contravariance&lt;Animal&gt;, Contravariance&lt;Dog&gt;&gt;; <span class=\"hljs-comment\">// true;</span>\n</code></pre>\n<p data-nodeid=\"110033\" class=\"\">在示例中的第 1 行，我们定义了一个基于类型入参构造函数类型的构造器 Contravariance，且类型入参 T 仅约束返回的函数类型参数 param 的类型。因为 TypeScript 严格模式的设定是函数参数类型是逆变的，所以 Contravariance<code data-backticks=\"1\" data-nodeid=\"110035\">&lt;Animal&gt;</code> 会是 Contravariance<code data-backticks=\"1\" data-nodeid=\"110037\">&lt;Dog&gt;</code> 的子类型，也因此第 2 行 isNotContravariance 是 false，第 3 行 isContravariance 是 true。</p>\n\n\n<p data-nodeid=\"101490\">为了更易于理解，我们可以从安全性的角度理解函数参数是逆变的设定。</p>\n<p data-nodeid=\"101491\">如果函数参数类型是协变而不是逆变，那么意味着函数类型 (param: Dog) =&gt; void 和 (param: Animal) =&gt; void 是兼容的，这与 Dog 和 Animal 的兼容一致，所以我们可以用 (param: Dog) =&gt; void 代替 (param: Animal) =&gt; void 遍历 Animal[] 类型数组。</p>\n<p data-nodeid=\"101492\">但是，这样是不安全的，因为它不能确保 Animal[] 数组中的成员都是 Dog（可能混入 Animal 类型的其他子类型，比如 Cat），这就会导致 (param: Dog) =&gt; void 类型的函数可能接收到 Cat 类型的入参。</p>\n<p data-nodeid=\"101493\">下面我们来看一个具体示例：</p>\n<pre class=\"lang-typescript\" data-nodeid=\"101494\"><code data-language=\"typescript\">  <span class=\"hljs-keyword\">const</span> visitDog = <span class=\"hljs-function\">(<span class=\"hljs-params\">animal: Dog</span>) =&gt;</span> {\n    animal.woof();\n  };\n  <span class=\"hljs-keyword\">let</span> animals: Animal[] = [{ name: <span class=\"hljs-string\">'Cat'</span>, miao: <span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> <span class=\"hljs-built_in\">void</span> <span class=\"hljs-number\">0</span>, }];\n  animals.forEach(visitDog); <span class=\"hljs-comment\">// ts(2345)</span>\n</code></pre>\n<p data-nodeid=\"101495\">在示例中，如果函数参数类型是协变的，那么第 5 行就可以通过静态类型检测，而不会提示一个 ts(2345) 类型的错误。这样第 1 行定义的 visitDog 函数在运行时就能接收到 Dog 类型之外的入参，并调用不存在的 woof 方法，从而在运行时抛出错误。</p>\n<p data-nodeid=\"101496\">正是因为函数参数是逆变的，所以使用 visitDog 函数遍历 Animal[] 类型数组时，在第 5 行提示了类型错误，因此也就不出现 visitDog 接收到一只 cat 的情况。</p>\n<h4 data-nodeid=\"101497\">（3）双向协变</h4>\n<p data-nodeid=\"101498\">双向协变也就是说如果 Dog 是 Animal 的子类型，则 F(Dog) 是 F(Animal) 的子类型，也是父类型，既是协变也是逆变。</p>\n<p data-nodeid=\"101499\">对应到实际的场景，在 TypeScript 非严格模式下，函数参数类型就是双向协变的。<strong data-nodeid=\"101702\">如前边提到函数只有在参数是逆变的情况下才安全，且本课程一直在强调使用严格模式，所以双向协变并不是一个安全或者有用的特性，因此我们不大可能遇到这样的实际场景。</strong></p>\n<p data-nodeid=\"110783\" class=\"\">但在某些资料中有提到，如果函数参数类型是双向协变，那么它是有用的，并进行了举例论证 <strong data-nodeid=\"110789\">（以下示例缩减自网络）</strong>：</p>\n\n<pre class=\"lang-typescript\" data-nodeid=\"101501\"><code data-language=\"typescript\">  <span class=\"hljs-keyword\">interface</span> Event {\n    timestamp: <span class=\"hljs-built_in\">number</span>;\n  }\n  <span class=\"hljs-keyword\">interface</span> MouseEvent <span class=\"hljs-keyword\">extends</span> Event {\n    x: <span class=\"hljs-built_in\">number</span>;\n    y: <span class=\"hljs-built_in\">number</span>;\n  }\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">addEventListener</span>(<span class=\"hljs-params\">handler: (n: Event) =&gt; <span class=\"hljs-built_in\">void</span></span>) </span>{}\n  addEventListener(<span class=\"hljs-function\">(<span class=\"hljs-params\">e: MouseEvent</span>) =&gt;</span> <span class=\"hljs-built_in\">console</span>.log(e.x + <span class=\"hljs-string\">','</span> + e.y)); <span class=\"hljs-comment\">// ts(2769)</span>\n</code></pre>\n<p data-nodeid=\"101502\">在示例中，我们在第 4 行定义了接口 MouseEvent 是第 1 行定义的接口 Event 的子类型，在第 8 行定义了函数的 handler 参数是函数类型。如果参数类型是双向协变的，那么我们就可以在第 9 行把参数类型是 Event 子类型（比如说 MouseEvent 的函数）作为入参传给 addEventListener。</p>\n<p data-nodeid=\"101503\">这种方式确实方便了很多，但是并不安全，原因见前边 Dog 和 Cat 的示例。而且在严格模式下，参数类型是逆变而不是双向协变的，所以第 9 行提示了一个 ts(2769) 的错误。</p>\n<p data-nodeid=\"101504\">由此可以得出，真正有用且安全的做法是使用泛型，如下所示：</p>\n<pre class=\"lang-java\" data-nodeid=\"101505\"><code data-language=\"java\">  function addEventListener&lt;E extends Event&gt;(handler: (n: E) =&gt; <span class=\"hljs-keyword\">void</span>) {}\n  addEventListener((e: MouseEvent) =&gt; console.log(e.x + <span class=\"hljs-string\">','</span> + e.y)); <span class=\"hljs-comment\">// ok</span>\n</code></pre>\n<p data-nodeid=\"101506\">在示例中的第 1 行，因为我们重新定义了带约束条件泛型入参的 addEventListener，它可以传递任何参数类型是 Event 子类型的函数作为入参，所以在第 2 行传入参数类型是 MouseEvent 的箭头函数作为入参时，则不会提示类型错误。</p>\n<h4 data-nodeid=\"101507\">（4）不变</h4>\n<p data-nodeid=\"101508\" class=\"\">不变即只要是不完全一样的类型，它们一定是不兼容的。也就是说即便 Dog 是 Animal 的子类型，如果 F(Dog) 不是 F(Animal) 的子类型，那么 F(Animal) 也不是 F(Dog) 的子类型。</p>\n<p data-nodeid=\"101509\">对应到实际场景，出于类型安全层面的考虑，在特定情况下我们可能希望数组是不变的（实际上是协变），见示例：</p>\n<pre class=\"lang-typescript\" data-nodeid=\"101510\"><code data-language=\"typescript\">  <span class=\"hljs-keyword\">interface</span> Cat <span class=\"hljs-keyword\">extends</span> Animal {\n    miao: <span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> <span class=\"hljs-built_in\">void</span>; \n  }\n  <span class=\"hljs-keyword\">const</span> cat: Cat = {\n    name: <span class=\"hljs-string\">'Cat'</span>,\n    miao: <span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> <span class=\"hljs-built_in\">void</span> <span class=\"hljs-number\">0</span>,\n  };\n  <span class=\"hljs-keyword\">const</span> dog: Dog = {\n    name: <span class=\"hljs-string\">'Dog'</span>,\n    woof: <span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> <span class=\"hljs-built_in\">void</span> <span class=\"hljs-number\">0</span>,\n  };\n  <span class=\"hljs-keyword\">let</span> dogs: Dog[] = [dog];\n  animals = dogs; <span class=\"hljs-comment\">// ok</span>\n  animals.push(cat); <span class=\"hljs-comment\">// ok</span>\n  dogs.forEach(visitDog); <span class=\"hljs-comment\">// 类型 ok，但运行时会抛出错误</span>\n</code></pre>\n<p data-nodeid=\"101511\">在示例中的第 1~3 行，我们定义了一个 Animal 的另外一个子类 Cat。在第 4~8 行，我们分别定义了对象 cat 和对象 dog，并在第 12 行定义了 Dog[] 类型的数组 dogs。</p>\n<p data-nodeid=\"101512\">因为数组是协变的，所以我们可以在第 13 行把 dogs 数组赋值给 animals 数组，并且在第 14 行把 cat 对象塞到 animals 数组中。那么问题就来了，因为 animals 和 dogs 指向的是同一个数组，所以实际上我们是把 cat 塞到了 dogs 数组中。</p>\n<p data-nodeid=\"101513\">然后，我们在第 15 行使用了 visitDog 函数遍历 dogs 数组。虽然它可以通过静态类型检测，但是运行时 visitDog 遍历数组将接收一个混入的 cat 对象并抛出错误，因为 visitDog 中调用了 cat 上没有 woof 的方法。</p>\n<p data-nodeid=\"101514\"><strong data-nodeid=\"101728\">因此，对于可变的数组而言，不变似乎是更安全、合理的设定。不过，在 TypeScript 中可变、不变的数组都是协变的，这是需要我们注意的一个陷阱。</strong></p>\n<p data-nodeid=\"101515\">介绍完变型相关的术语以及对应的实际场景，我们已经了解了函数参数类型是逆变的，返回值类型是协变的，所以前面的函数类型  (p1: any) =&gt; 1 和 (param: any) =&gt; number 为什么兼容的问题已经给出答案了。<strong data-nodeid=\"101733\">因为返回值类型 1 是 number 的子类型，且返回值类型是协变的，所以 (p1: any) =&gt; 1 是 (param: any) =&gt; number 的子类型，即是兼容的。</strong></p>\n<h3 data-nodeid=\"101516\">函数类型兼容性</h3>\n<p data-nodeid=\"101517\">因为函数类型的兼容性、子类型关系有着更复杂的考量（它还需要结合参数和返回值的类型进行确定），所以下面我们详细介绍一下函数类型兼容性的一般规则。</p>\n<h4 data-nodeid=\"101518\">（1）返回值</h4>\n<p data-nodeid=\"101519\">前边我们已经讲过返回值类型是协变的，所以在参数类型兼容的情况下，函数的子类型关系与返回值子类型关系一致。也就是说返回值类型兼容，则函数兼容。</p>\n<h4 data-nodeid=\"101520\">（2）参数类型</h4>\n<p data-nodeid=\"101521\">前边我们也讲过参数类型是逆变的，所以在参数个数相同、返回值类型兼容的情况下，函数子类型关系与参数子类型关系是反过来的（逆变）。</p>\n<h4 data-nodeid=\"101522\">（3）参数个数</h4>\n<p data-nodeid=\"101523\">在索引位置相同的参数和返回值类型兼容的前提下，函数兼容性取决于参数个数，参数个数少的兼容个数多，下面我们看一个具体的示例：</p>\n<pre class=\"lang-typescript\" data-nodeid=\"101524\"><code data-language=\"typescript\">{\n  <span class=\"hljs-keyword\">let</span> lessParams = <span class=\"hljs-function\">(<span class=\"hljs-params\">one: <span class=\"hljs-built_in\">number</span></span>) =&gt;</span> <span class=\"hljs-built_in\">void</span> <span class=\"hljs-number\">0</span>;\n  <span class=\"hljs-keyword\">let</span> moreParams = <span class=\"hljs-function\">(<span class=\"hljs-params\">one: <span class=\"hljs-built_in\">number</span>, two: <span class=\"hljs-built_in\">string</span></span>) =&gt;</span> <span class=\"hljs-built_in\">void</span> <span class=\"hljs-number\">0</span>;\n  lessParams = moreParams; <span class=\"hljs-comment\">// ts(2322)</span>\n  moreParams = lessParams; <span class=\"hljs-comment\">// ok</span>\n}\n</code></pre>\n<p data-nodeid=\"101525\">在示例中，lessParams 参数个数少于 moreParams，所以如第 5 行所示 lessParams 和 moreParams 兼容，并可以赋值给 moreParams。</p>\n<blockquote data-nodeid=\"101526\">\n<p data-nodeid=\"101527\">注意：如果你觉得参数个数少的函数兼容参数个数多的函数不好理解，那么可以试着从安全性角度理解（是参数少的函数赋值给参数多的函数安全，还是参数多的函数赋值给参数少的函数安全），这里限于篇幅有限就不展开了（你可以作为思考题）。</p>\n</blockquote>\n<h4 data-nodeid=\"101528\">（4）可选和剩余参数</h4>\n<p data-nodeid=\"101529\">可选参数可以兼容剩余参数、不可选参数，下面我们具体看一个示例：</p>\n<pre class=\"lang-typescript\" data-nodeid=\"101530\"><code data-language=\"typescript\">  <span class=\"hljs-keyword\">let</span> optionalParams = <span class=\"hljs-function\">(<span class=\"hljs-params\">one?: <span class=\"hljs-built_in\">number</span>, tow?: <span class=\"hljs-built_in\">number</span></span>) =&gt;</span> <span class=\"hljs-built_in\">void</span> <span class=\"hljs-number\">0</span>;\n  <span class=\"hljs-keyword\">let</span> requiredParams = <span class=\"hljs-function\">(<span class=\"hljs-params\">one: <span class=\"hljs-built_in\">number</span>, tow: <span class=\"hljs-built_in\">number</span></span>) =&gt;</span> <span class=\"hljs-built_in\">void</span> <span class=\"hljs-number\">0</span>;\n  <span class=\"hljs-keyword\">let</span> restParams = <span class=\"hljs-function\">(<span class=\"hljs-params\">...args: <span class=\"hljs-built_in\">number</span>[]</span>) =&gt;</span> <span class=\"hljs-built_in\">void</span> <span class=\"hljs-number\">0</span>;\n  requiredParams = optionalParams; <span class=\"hljs-comment\">// ok</span>\n  restParams = optionalParams; <span class=\"hljs-comment\">// ok</span>\n  optionalParams = restParams; <span class=\"hljs-comment\">// ts(2322)</span>\n  optionalParams = requiredParams; <span class=\"hljs-comment\">// ts(2322)</span>\n  restParams = requiredParams; <span class=\"hljs-comment\">// ok</span>\n  requiredParams = restParams; <span class=\"hljs-comment\">// ok</span>\n</code></pre>\n<p data-nodeid=\"101531\">在示例中的第 4~5 行，我们可以把可选参数 optionalParams 赋值给不可选参数 requiredParams、剩余参数 restParams ，反过来则提示了一个 ts(2322) 的错误（第 5~6 行）。</p>\n<p data-nodeid=\"101532\">在第 8~9 行，不可选参数 requiredParams 和剩余参数 restParams 是互相兼容的；从安全性的角度理解第 9 行是安全的，所以可以赋值。</p>\n<p data-nodeid=\"101533\">最让人费解的是，在第 8 行中，把不可选参数 requiredParams 赋值给剩余参数 restParams 其实是不安全的（但是符合类型检测），我们需要从方便性上理解这个设定。</p>\n<p data-nodeid=\"101534\">正是基于这个设定，我们才可以将剩余参数类型函数定义为其他所有参数类型函数的父类型，并用来约束其他类型函数的类型范围，比如说在泛型中约束函数类型入参的范围。</p>\n<p data-nodeid=\"101535\">下面我们看一个具体的示例：</p>\n<pre class=\"lang-typescript\" data-nodeid=\"101536\"><code data-language=\"typescript\"><span class=\"hljs-keyword\">type</span> GetFun&lt;F <span class=\"hljs-keyword\">extends</span> (...args: <span class=\"hljs-built_in\">number</span>[]) =&gt; <span class=\"hljs-built_in\">any</span>&gt; = Parameters&lt;F&gt;;\n<span class=\"hljs-keyword\">type</span> GetRequiredParams = GetFun&lt;<span class=\"hljs-keyword\">typeof</span> requiredParams&gt;;\n<span class=\"hljs-keyword\">type</span> GetRestParams = GetFun&lt;<span class=\"hljs-keyword\">typeof</span> restParams&gt;;\n<span class=\"hljs-keyword\">type</span> GetEmptyParams = GetFun&lt;<span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> <span class=\"hljs-built_in\">void</span>&gt;;\n</code></pre>\n<p data-nodeid=\"101537\">在示例中的第 1 行，我们使用剩余参数函数类型 (...args: number[]) =&gt; any 约束了入参 F 的类型，而第 2~4 行传入的函数类型入参都是这个剩余参数函数类型的子类型。</p>\n<h3 data-nodeid=\"101538\">小结和预告</h3>\n<p data-nodeid=\"101539\">赋值是编程中一个非常常见的操作，因为类型兼容性决定了赋值操作是否可以通过类型检测，所以这一讲的内容十分重要。而且这一讲中涉及的名词术语比较难理解，在学习时，你需要反思阅读和思考。</p>\n<p data-nodeid=\"101540\">插播一道思考题：请从安全性角度解释一下为什么参数个数少兼容个数多？不可选参数和剩余参数互相兼容吗？</p>\n<p data-nodeid=\"101541\">13 讲我们将学习通过自定义模块、第三方模块等方式扩充、增强类型体系，敬请期待。</p>\n<p data-nodeid=\"101542\">另外，如果你觉得本专栏有价值，欢迎分享给更多好友哦~</p>",
                "article_title": "12 | 类型兼容：如何判断一个类型是否可以赋值给其他类型？",
                "title": "12 | 类型兼容：如何判断一个类型是否可以赋值给其他类型？",
                "id": 7444
            },
            {
                "content": "<p data-nodeid=\"1357\" class=\"\">经过前面入门课程的学习，我们了解了 TypeScript 所特有的类型，比如基础类型、字面量类型、类类型、联合类型和交叉类型等，也在前两讲的课程中学习了关于这些类型使用的一些高级技巧。</p>\n<p data-nodeid=\"1358\">然而，在平时使用 TypeScript 编写代码的过程中，我们可能会遇到某些库没有提供类型声明、库的版本和类型声明不一致、没有注入全局变量类型等各种问题。因此，这一讲我们将学习 TypeScript 增强类型系统，这样上边提到的问题就能迎刃而解了。</p>\n<p data-nodeid=\"1359\">在 TypeScript 中预留了一个增强类型的口子，使得我们可以方便地扩展原来的类型系统，以兼容 JavaScript 的代码。</p>\n<h3 data-nodeid=\"1360\">增强类型系统</h3>\n<p data-nodeid=\"1361\">增强类型系统，顾名思义就是对 TypeScript 类型系统的增强。在 npm 中，有很多历史悠久的库都是使用 JavaScript 编写的，而 TypeScript 作为 JavaScript 的超集，设计目标之一就是能在 TypeScript 中安全、方便地使用 JavaScript 库。</p>\n<p data-nodeid=\"1362\">TypeScript 相较于 JavaScript 而言，其一大特点就是类型。关于类型的定义方法，除了之前学习的内容之外，我们还可以通过以下方式扩展类型系统。</p>\n<h3 data-nodeid=\"1363\">声明</h3>\n<p data-nodeid=\"1364\">那么，我们如何在 TypeScript 中安全地使用 JavaScript 的库呢？关键的步骤就是使用 TypeScript 中的一个 declare 关键字。</p>\n<p data-nodeid=\"1365\">通过使用 declare 关键字，我们可以声明全局的变量、方法、类、对象。下面我们先说一下如何声明全局的变量。</p>\n<h4 data-nodeid=\"1366\">declare 变量</h4>\n<p data-nodeid=\"1367\">在运行时，前端代码 <code data-backticks=\"1\" data-nodeid=\"1516\">&lt;script&gt;</code> 标签会引入一个全局的库，再导入全局变量。此时，如果你想安全地使用全局变量，那么就需要对变量的类型进行声明。</p>\n<p data-nodeid=\"1368\">声明变量的语法： declare (var|let|const) 变量名称: 变量类型 ，具体示例如下：</p>\n<pre class=\"lang-typescript\" data-nodeid=\"1369\"><code data-language=\"typescript\"><span class=\"hljs-keyword\">declare</span> <span class=\"hljs-keyword\">var</span> val1: <span class=\"hljs-built_in\">string</span>;\n<span class=\"hljs-keyword\">declare</span> <span class=\"hljs-keyword\">let</span> val2: <span class=\"hljs-built_in\">number</span>;\n<span class=\"hljs-keyword\">declare</span> <span class=\"hljs-keyword\">const</span> val3: <span class=\"hljs-built_in\">boolean</span>;\nval1 = <span class=\"hljs-string\">'1'</span>;\nval1 = <span class=\"hljs-string\">'2'</span>;\nval2 = <span class=\"hljs-number\">1</span>;\nval2 = <span class=\"hljs-string\">'2'</span>; <span class=\"hljs-comment\">// TS2322: Type 'string' is not assignable to type 'number'.</span>\nval3 = <span class=\"hljs-literal\">true</span>; <span class=\"hljs-comment\">// TS2588: Cannot assign to 'val3' because it is a constant.</span>\n</code></pre>\n<p data-nodeid=\"1370\">在上面的代码示例中，我们分别使用 var、let、const 声明了 3 种不同类型的变量。其中，使用 var、let 声明的变量是可以更改变量赋值的，而使用 const 声明的变量则不可以。同时，对于变量类型不正确的错误，TypeScript 也可以正常检测出来。</p>\n<p data-nodeid=\"1371\">当然， declare 关键字还可以用来声明函数、类、枚举类型，下面我们一起来看看。</p>\n<h4 data-nodeid=\"1372\">声明函数</h4>\n<p data-nodeid=\"1373\">声明函数的语法与声明变量类型的语法相同，不同的是 declare 关键字后需要跟 function 关键字，如下示例：</p>\n<pre class=\"lang-typescript\" data-nodeid=\"1374\"><code data-language=\"typescript\"><span class=\"hljs-keyword\">declare</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">toString</span>(<span class=\"hljs-params\">x: <span class=\"hljs-built_in\">number</span></span>): <span class=\"hljs-title\">string</span></span>;\n<span class=\"hljs-keyword\">const</span> x = toString(<span class=\"hljs-number\">1</span>); <span class=\"hljs-comment\">// =&gt; string</span>\n</code></pre>\n<p data-nodeid=\"1375\">需要注意：使用 declare<strong data-nodeid=\"1536\">关键字时，我们不需要编写声明的变量、函数、类的具体实现（因为变量、函数、类在其他库中已经实现了），只需要声明其类型即可</strong>，如下示例：</p>\n<pre class=\"lang-typescript\" data-nodeid=\"1376\"><code data-language=\"typescript\"><span class=\"hljs-comment\">// TS1183: An implementation cannot be declared in ambient contexts.</span>\n<span class=\"hljs-keyword\">declare</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">toString</span>(<span class=\"hljs-params\">x: <span class=\"hljs-built_in\">number</span></span>) </span>{\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">String</span>(x);\n};\n</code></pre>\n<p data-nodeid=\"1377\">在上面的例子中，TypeScript 的报错信息提示：环境声明的上下文不需要实现。也就是说 declare 声明的所有类型只需要表明类型，不需要实现。</p>\n<h4 data-nodeid=\"1378\">声明类</h4>\n<p data-nodeid=\"1379\">声明类时，我们只需要声明类的属性、方法的类型即可。</p>\n<p data-nodeid=\"1380\">另外，关于类的可见性修饰符我们也可以在此进行声明，下面看一个具体的示例：</p>\n<pre class=\"lang-typescript\" data-nodeid=\"1381\"><code data-language=\"typescript\"><span class=\"hljs-keyword\">declare</span> <span class=\"hljs-keyword\">class</span> Person {\n  <span class=\"hljs-keyword\">public</span> name: <span class=\"hljs-built_in\">string</span>;\n  <span class=\"hljs-keyword\">private</span> age: <span class=\"hljs-built_in\">number</span>;\n  <span class=\"hljs-keyword\">constructor</span>(<span class=\"hljs-params\">name: <span class=\"hljs-built_in\">string</span></span>);\n  getAge(): <span class=\"hljs-built_in\">number</span>;\n}\n<span class=\"hljs-keyword\">const</span> person = <span class=\"hljs-keyword\">new</span> Person(<span class=\"hljs-string\">'Mike'</span>);\nperson.name; <span class=\"hljs-comment\">// =&gt; string</span>\nperson.age; <span class=\"hljs-comment\">// TS2341: Property 'age' is private and only accessible within class 'Person'.</span>\nperson.getAge(); <span class=\"hljs-comment\">// =&gt; number</span>\n</code></pre>\n<p data-nodeid=\"1382\">在上面的例子中，我们声明了公共属性 name 以及私有属性 age，此时我们看到无法访问私有属性 age。另外，我们还声明了方法 getAge ，并且 getAge 的返回值是 number 类型，所以 Person 实例调用后返回的类型也是 number 类型。</p>\n<h4 data-nodeid=\"1383\">声明枚举</h4>\n<p data-nodeid=\"1384\">声明枚举只需要定义枚举的类型，并不需要定义枚举的值，如下示例：</p>\n<pre class=\"lang-typescript\" data-nodeid=\"1385\"><code data-language=\"typescript\"><span class=\"hljs-keyword\">declare</span> <span class=\"hljs-keyword\">enum</span> Direction {\n  Up,\n  Down,\n  Left,\n  Right,\n}\n<span class=\"hljs-keyword\">const</span> directions = [Direction.Up, Direction.Down, Direction.Left, Direction.Right];\n</code></pre>\n<p data-nodeid=\"1386\">在上述示例中的第 1~6 行，我们声明了在其他地方定义的枚举 Direction 类型结构，然后在第 8 行就可以直接访问枚举的成员了（这其实就是我们在 09 讲中学习的外部枚举，Ambient Enums）。</p>\n<p data-nodeid=\"1387\"><strong data-nodeid=\"1551\">注意：声明枚举仅用于编译时的检查，编译完成后，声明文件中的内容在编译结果中会被删除，</strong> 相当于仅剩下面使用的语句:</p>\n<pre class=\"lang-typescript\" data-nodeid=\"1388\"><code data-language=\"typescript\"><span class=\"hljs-keyword\">const</span> directions = [Direction.Up, Direction.Down, Direction.Left, Direction.Right];\n</code></pre>\n<p data-nodeid=\"1389\">这里的 Direction 表示引入的全局变量。</p>\n<p data-nodeid=\"1390\">除了声明变量、函数、类型、枚举之外，我们还可以使用 declare 增强文件、模块的类型系统。</p>\n<h3 data-nodeid=\"1391\">declare 模块</h3>\n<p data-nodeid=\"1392\">在 JavaScript 还没有升级至 ES6 的时候，TypeScript 就提供了一种模块化方案，比如通过使用 module 关键字，我们就可以声明一个内部模块。但是由于 ES6 后来也使用了 module 关键字，为了兼容 ES6，所以 TypeScript 使用 namespace 替代了原来的 module，并更名为命名空间。</p>\n<blockquote data-nodeid=\"1393\">\n<p data-nodeid=\"1394\"><strong data-nodeid=\"1563\">需要注意：目前，任何使用</strong><code data-backticks=\"1\" data-nodeid=\"1559\">module</code>关键字声明一个内部模块的地方，我们都应该使用<code data-backticks=\"1\" data-nodeid=\"1561\">namespace</code>关键字进行替换。</p>\n</blockquote>\n<p data-nodeid=\"1395\">TypeScript 与 ES6 一样，任何包含顶级 import 或 export 的文件都会被当作一个模块。我们可以通过声明模块类型，为缺少 TypeScript 类型定义的三方库或者文件补齐类型定义，如下示例：</p>\n<pre class=\"lang-typescript\" data-nodeid=\"1396\"><code data-language=\"typescript\"><span class=\"hljs-comment\">// lodash.d.ts</span>\n<span class=\"hljs-keyword\">declare</span> <span class=\"hljs-keyword\">module</span> 'lodash' {\n  <span class=\"hljs-keyword\">export</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">first</span>&lt;<span class=\"hljs-title\">T</span> <span class=\"hljs-title\">extends</span> <span class=\"hljs-title\">unknown</span>&gt;(<span class=\"hljs-params\">array: T[]</span>): <span class=\"hljs-title\">T</span></span>;\n}\n<span class=\"hljs-comment\">// index.ts</span>\n<span class=\"hljs-keyword\">import</span> { first } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'lodash'</span>;\nfirst([<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>]); <span class=\"hljs-comment\">// =&gt; number;</span>\n</code></pre>\n<p data-nodeid=\"1397\">在上面的例子中，lodash.d.ts 声明了模块 lodash 导出的 first 方法，然后在 TypeScript 文件中使用了模块 lodash 中的 first 方法。</p>\n<blockquote data-nodeid=\"1398\">\n<p data-nodeid=\"1399\">说明：关于声明文件的知识点，我们一会再介绍，目前只需要知道声明文件是一个以<code data-backticks=\"1\" data-nodeid=\"1567\">.d.ts</code>为后缀的文件。</p>\n</blockquote>\n<p data-nodeid=\"1400\"><strong data-nodeid=\"1574\">声明模块的语法:</strong><code data-backticks=\"1\" data-nodeid=\"1572\">declare module '模块名' {}</code>。</p>\n<p data-nodeid=\"1401\">在模块声明的内部，我们只需要使用 export 导出对应库的类、函数即可。</p>\n<h3 data-nodeid=\"1402\">declare 文件</h3>\n<p data-nodeid=\"1403\">在使用 TypeScript 开发前端应用时，我们可以通过 import 关键字导入文件，比如先使用 import 导入图片文件，再通过 webpack 等工具处理导入的文件。</p>\n<p data-nodeid=\"1404\">但是，因为 TypeScript 并不知道我们通过 import 导入的文件是什么类型，所以需要使用 declare 声明导入的文件类型，下面看一个具体的示例：</p>\n<pre class=\"lang-typescript\" data-nodeid=\"1405\"><code data-language=\"typescript\"><span class=\"hljs-keyword\">declare</span> <span class=\"hljs-keyword\">module</span> '*.jpg' {\n  <span class=\"hljs-keyword\">const</span> src: <span class=\"hljs-built_in\">string</span>;\n  <span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> src;\n}\n<span class=\"hljs-keyword\">declare</span> <span class=\"hljs-keyword\">module</span> '*.png' {\n  <span class=\"hljs-keyword\">const</span> src: <span class=\"hljs-built_in\">string</span>;\n  <span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> src;\n}\n</code></pre>\n<p data-nodeid=\"1406\">在上面的例子中，我们使用了 *.xxx 模块通配符匹配一类文件。</p>\n<p data-nodeid=\"1407\">这里标记的图片文件的默认导出的类型是 string ，通过 import 使用图片资源时，TypeScript 会将导入的图片识别为 string 类型，因此也就可以把 import 的图片赋值给  的 src 属性，因为它们的类型都是 string，是匹配的。</p>\n<h3 data-nodeid=\"1408\">declare namespace</h3>\n<p data-nodeid=\"1409\">不同于声明模块，命名空间一般用来表示具有很多子属性或者方法的全局对象变量。</p>\n<p data-nodeid=\"1410\">我们可以将声明命名空间简单看作是声明一个更复杂的变量，如下示例：</p>\n<pre class=\"lang-typescript\" data-nodeid=\"1411\"><code data-language=\"typescript\"><span class=\"hljs-keyword\">declare</span> <span class=\"hljs-keyword\">namespace</span> $ {\n  <span class=\"hljs-keyword\">const</span> version: <span class=\"hljs-built_in\">number</span>;\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">ajax</span>(<span class=\"hljs-params\">settings?: <span class=\"hljs-built_in\">any</span></span>): <span class=\"hljs-title\">void</span></span>;\n}\n$.version; <span class=\"hljs-comment\">// =&gt; number</span>\n$.ajax();\n</code></pre>\n<p data-nodeid=\"1412\">在上面的例子中，因为我们声明了全局导入的 jQuery 变量 $，所以可以直接使用 $ 变量的 version 属性以及 ajax 方法。</p>\n<p data-nodeid=\"1413\">在 TypeScript 中，我们还可以编写以 .d.ts 为后缀的声明文件来增强（补齐）类型系统。</p>\n<h3 data-nodeid=\"1414\">声明文件</h3>\n<p data-nodeid=\"1415\">在 TypeScript 中，以 .d.ts 为后缀的文件为声明文件。如果你熟悉 C/C++，那么可以把它当作 .h 文件。 在声明文件时，我们只需要定义三方类库所暴露的 API 接口即可。</p>\n<p data-nodeid=\"1416\">在 TypeScript 中，存在类型、值、命名空间这 3 个核心概念。如果你掌握了这些核心概念，那么就能够为任何形式的类型书写声明文件了。</p>\n<h4 data-nodeid=\"1417\">类型</h4>\n<ul data-nodeid=\"1418\">\n<li data-nodeid=\"1419\">\n<p data-nodeid=\"1420\">类型别名声明；</p>\n</li>\n<li data-nodeid=\"1421\">\n<p data-nodeid=\"1422\">接口声明；</p>\n</li>\n<li data-nodeid=\"1423\">\n<p data-nodeid=\"1424\">类声明；</p>\n</li>\n<li data-nodeid=\"1425\">\n<p data-nodeid=\"1426\">枚举声明；</p>\n</li>\n<li data-nodeid=\"1427\">\n<p data-nodeid=\"1428\">导入的类型声明。</p>\n</li>\n</ul>\n<p data-nodeid=\"1429\">上面的每一个声明都创建了一个类型名称。</p>\n<h4 data-nodeid=\"1430\">值</h4>\n<p data-nodeid=\"1431\">值就是在运行时表达式可以赋予的值。</p>\n<p data-nodeid=\"1432\">我们可以通过以下 6 种方式创建值：</p>\n<ul data-nodeid=\"1433\">\n<li data-nodeid=\"1434\">\n<p data-nodeid=\"1435\">var、let、const 声明；</p>\n</li>\n<li data-nodeid=\"1436\">\n<p data-nodeid=\"1437\">namespace、module 包含值的声明；</p>\n</li>\n<li data-nodeid=\"1438\">\n<p data-nodeid=\"1439\">枚举声明；</p>\n</li>\n<li data-nodeid=\"1440\">\n<p data-nodeid=\"1441\">类声明；</p>\n</li>\n<li data-nodeid=\"1442\">\n<p data-nodeid=\"1443\">导入的值；</p>\n</li>\n<li data-nodeid=\"1444\">\n<p data-nodeid=\"1445\">函数声明。</p>\n</li>\n</ul>\n<h4 data-nodeid=\"1446\">命名空间</h4>\n<p data-nodeid=\"1447\">在命名空间中，我们也可以声明类型。比如 const x: A.B.C 这个声明，这里的类型 C 就是在 A.B 命名空间下的。</p>\n<blockquote data-nodeid=\"1448\">\n<p data-nodeid=\"1449\">说明：这种区别微妙而重要，这里的<code data-backticks=\"1\" data-nodeid=\"1610\">A.B</code>可能代表一个值，也可能代表一个类型。</p>\n</blockquote>\n<p data-nodeid=\"1450\">一个名称 A， 在 TypeScript 中可能表示一个类型、一个值，也可能是一个命名空间。通过类型、值、命名空间的组合，我们也就拥有了表达任意类型的能力。如果你想知道名称A 代表的实际意义，则需要看它所在的上下文。</p>\n<p data-nodeid=\"1451\">接下来我们通过实际的使用和示例分析来学习声明的书写方式。</p>\n<h3 data-nodeid=\"1452\">使用声明文件</h3>\n<p data-nodeid=\"1453\">安装 TypeScript 依赖后，一般我们会顺带安装一个 lib.d.ts 声明文件，这个文件包含了 JavaScript 运行时以及 DOM 中各种全局变量的声明，如下示例：</p>\n<pre class=\"lang-typescript\" data-nodeid=\"1454\"><code data-language=\"typescript\"><span class=\"hljs-comment\">// typescript/lib/lib.d.ts</span>\n<span class=\"hljs-comment\">/// &lt;reference no-default-lib=\"true\"/&gt;</span>\n<span class=\"hljs-comment\">/// &lt;reference lib=\"es5\" /&gt;</span>\n<span class=\"hljs-comment\">/// &lt;reference lib=\"dom\" /&gt;</span>\n<span class=\"hljs-comment\">/// &lt;reference lib=\"webworker.importscripts\" /&gt;</span>\n<span class=\"hljs-comment\">/// &lt;reference lib=\"scripthost\" /&gt;</span>\n</code></pre>\n<p data-nodeid=\"1455\">上面的示例其实就是 TypeScript 中的 lib.d.ts 文件的内容。</p>\n<p data-nodeid=\"1456\">其中，/// 是 TypeScript 中三斜线指令，后面的内容类似于 XML 标签的语法，用来指代引用其他的声明文件。通过三斜线指令，我们可以更好地复用和拆分类型声明。no-default-lib=\"true\" 表示这个文件是一个默认库。而最后 4 行的lib=\"...\" 表示引用内部的库类型声明。</p>\n<p data-nodeid=\"1457\">关于更多三斜线指令的内容，你可以查看<a href=\"https://www.typescriptlang.org/docs/handbook/triple-slash-directives.html?fileGuid=xxQTRXtVcqtHK6j8\" data-nodeid=\"1629\">链接</a>。</p>\n<h4 data-nodeid=\"1458\">使用 @types</h4>\n<p data-nodeid=\"1459\">前面我们介绍了如何为 JavaScript 库编写类型声明，然而为库编写类型声明非常耗费精力，且难以在多个项目中复用。<a href=\"https://github.com/DefinitelyTyped/DefinitelyTyped?fileGuid=xxQTRXtVcqtHK6j8\" data-nodeid=\"1635\">Definitely Typed</a>是最流行性的高质量 TypeScript 声明文件类库，正是因为有社区维护的这个声明文件类库，大大简化了 JavaScript 项目迁移 TypeScript 的难度。</p>\n<p data-nodeid=\"1460\">目前，社区已经记录了 90% 的 JavaScript 库的类型声明，意味着如果我们想使用的库有社区维护的类型声明，那么就可以通过安装类型声明文件直接使用 JavaScript 编写的类库了。</p>\n<p data-nodeid=\"1461\">具体操作：首先，<a href=\"https://www.typescriptlang.org/dt/search?search=&amp;fileGuid=xxQTRXtVcqtHK6j8\" data-nodeid=\"1641\">点击这里的链接</a>搜索你想要导入的类库的类型声明，如果有社区维护的声明文件。然后，我们只需要安装 @types/xxx 就可以在 TypeScript 中直接使用它了。</p>\n<p data-nodeid=\"1462\">然而，因为 Definitely Typed 是由社区人员维护的，如果原来的三方库升级，那么 Definitely Typed 所导出的三方库的类型定义想要升级还需要经过 PR、发布的流程，就会导致无法与原库保持完全同步。针对这个问题，在 TypeScript 中，我们可以通过类型合并、扩充类型定义的技巧临时解决。</p>\n<h3 data-nodeid=\"1463\">类型合并</h3>\n<p data-nodeid=\"1464\">在 TypeScript 中，相同的接口、命名空间会依据一定的规则进行合并。</p>\n<h4 data-nodeid=\"1465\">合并接口</h4>\n<p data-nodeid=\"1466\">最简单、常见的声明合并是接口合并，下面我们看一个具体的示例：</p>\n<pre class=\"lang-typescript\" data-nodeid=\"1467\"><code data-language=\"typescript\"><span class=\"hljs-keyword\">interface</span> Person {\n  name: <span class=\"hljs-built_in\">string</span>;\n}\n<span class=\"hljs-keyword\">interface</span> Person {\n  age: <span class=\"hljs-built_in\">number</span>;\n}\n<span class=\"hljs-comment\">// 相当于</span>\n<span class=\"hljs-keyword\">interface</span> Person {\n  name: <span class=\"hljs-built_in\">string</span>;\n  age: <span class=\"hljs-built_in\">number</span>;\n}\n</code></pre>\n<p data-nodeid=\"1468\">在上面的例子中，我们展示了接口合并最简单的情况，这里的合并相当于把接口的属性放入了一个同名的接口中。</p>\n<p data-nodeid=\"25018\" class=\"te-preview-highlight\"><strong data-nodeid=\"25023\">需要注意的是接口的非函数成员类型必须完全一样</strong>，如下示例：</p>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n<pre class=\"lang-typescript\" data-nodeid=\"1470\"><code data-language=\"typescript\"><span class=\"hljs-keyword\">interface</span> Person {\n  age: <span class=\"hljs-built_in\">string</span>;\n}\n<span class=\"hljs-keyword\">interface</span> Person {\n  <span class=\"hljs-comment\">// TS2717: Subsequent property declarations must have the same type.</span>\n  <span class=\"hljs-comment\">// Property 'age' must be of type 'string', but here has type 'number'.</span>\n  age: <span class=\"hljs-built_in\">number</span>;\n}\n</code></pre>\n<p data-nodeid=\"1471\">在上面的例子中，因为存在两个属性相同而类型不同的接口，所以编译器报了一个 ts(2717) 错误 。</p>\n<p data-nodeid=\"1472\">对于函数成员而言，每个同名的函数声明都会被当作这个函数的重载。</p>\n<p data-nodeid=\"1473\"><strong data-nodeid=\"1660\">需要注意的是后面声明的接口具有更高的优先级</strong>，下面看一个具体的示例：</p>\n<pre class=\"lang-typescript\" data-nodeid=\"1474\"><code data-language=\"typescript\"><span class=\"hljs-keyword\">interface</span>&nbsp;Obj&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;identity(val:&nbsp;<span class=\"hljs-built_in\">any</span>):&nbsp;<span class=\"hljs-built_in\">any</span>;\n}\n<span class=\"hljs-keyword\">interface</span>&nbsp;Obj&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;identity(val:&nbsp;<span class=\"hljs-built_in\">number</span>):&nbsp;<span class=\"hljs-built_in\">number</span>;\n}\n<span class=\"hljs-keyword\">interface</span>&nbsp;Obj&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;identity(val:&nbsp;<span class=\"hljs-built_in\">boolean</span>):&nbsp;<span class=\"hljs-built_in\">boolean</span>;\n}\n<span class=\"hljs-comment\">//&nbsp;相当于</span>\n<span class=\"hljs-keyword\">interface</span>&nbsp;Obj&nbsp;{\n&nbsp;&nbsp;identity(val:&nbsp;<span class=\"hljs-built_in\">boolean</span>):&nbsp;<span class=\"hljs-built_in\">boolean</span>;\n&nbsp;&nbsp;identity(val:&nbsp;<span class=\"hljs-built_in\">number</span>):&nbsp;<span class=\"hljs-built_in\">number</span>;\n&nbsp;&nbsp;identity(val:&nbsp;<span class=\"hljs-built_in\">any</span>):&nbsp;<span class=\"hljs-built_in\">any</span>;\n}\n<span class=\"hljs-keyword\">const</span>&nbsp;obj:&nbsp;Obj&nbsp;=&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;identity(val:&nbsp;<span class=\"hljs-built_in\">any</span>)&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"hljs-keyword\">return</span>&nbsp;val;\n&nbsp;&nbsp;&nbsp;&nbsp;}\n};\n<span class=\"hljs-keyword\">const</span>&nbsp;t1&nbsp;=&nbsp;obj.identity(<span class=\"hljs-number\">1</span>);&nbsp;<span class=\"hljs-comment\">//&nbsp;=&gt;&nbsp;number</span>\n<span class=\"hljs-keyword\">const</span>&nbsp;t2&nbsp;=&nbsp;obj.identity(<span class=\"hljs-literal\">true</span>);&nbsp;<span class=\"hljs-comment\">//&nbsp;=&gt;&nbsp;boolean</span>\n<span class=\"hljs-keyword\">const</span>&nbsp;t3&nbsp;=&nbsp;obj.identity(<span class=\"hljs-string\">\"t3\"</span>);&nbsp;<span class=\"hljs-comment\">//&nbsp;=&gt;&nbsp;any</span>\n</code></pre>\n<p data-nodeid=\"1475\">在上面的代码中，Obj 类型的 identity 函数成员有 3 个重载，与函数重载的顺序相同，声明在前面的重载类型会匹配。我们分开声明接口的 3 个函数成员，相当于 12~16 行的声明，因为后声明的接口具有更高的优先级，所以 t1、t2 的类型可以被重载为其对应的类型，而不是 any。</p>\n<p data-nodeid=\"1476\">接下来我们更改一下顺序，再看看结果。</p>\n<pre class=\"lang-typescript\" data-nodeid=\"1477\"><code data-language=\"typescript\"><span class=\"hljs-keyword\">interface</span> Obj {\n  identity(val: <span class=\"hljs-built_in\">boolean</span>): <span class=\"hljs-built_in\">boolean</span>;\n}\n<span class=\"hljs-keyword\">interface</span> Obj {\n  identity(val: <span class=\"hljs-built_in\">number</span>): <span class=\"hljs-built_in\">number</span>;\n}\n<span class=\"hljs-keyword\">interface</span> Obj {\n  identity(val: <span class=\"hljs-built_in\">any</span>): <span class=\"hljs-built_in\">any</span>;\n}\n<span class=\"hljs-comment\">//&nbsp;相当于</span>\n<span class=\"hljs-keyword\">interface</span>&nbsp;Obj&nbsp;{\n&nbsp;&nbsp;identity(val:&nbsp;<span class=\"hljs-built_in\">any</span>):&nbsp;<span class=\"hljs-built_in\">any</span>;\n&nbsp;&nbsp;identity(val:&nbsp;<span class=\"hljs-built_in\">number</span>):&nbsp;<span class=\"hljs-built_in\">number</span>;\n&nbsp;&nbsp;identity(val:&nbsp;<span class=\"hljs-built_in\">boolean</span>):&nbsp;<span class=\"hljs-built_in\">boolean</span>;\n}\n<span class=\"hljs-keyword\">const</span> obj: Obj = {\n  identity(val: <span class=\"hljs-built_in\">any</span>) {\n      <span class=\"hljs-keyword\">return</span> val;\n  }\n};\n<span class=\"hljs-keyword\">const</span> t1 = obj.identity(<span class=\"hljs-number\">1</span>); <span class=\"hljs-comment\">// =&gt; any</span>\n<span class=\"hljs-keyword\">const</span> t2 = obj.identity(<span class=\"hljs-literal\">true</span>); <span class=\"hljs-comment\">// =&gt; any</span>\n<span class=\"hljs-keyword\">const</span> t3 = obj.identity(<span class=\"hljs-string\">\"t3\"</span>); <span class=\"hljs-comment\">// =&gt; any</span>\n</code></pre>\n<p data-nodeid=\"1478\">在上面的代码中，identity 函数参数为 any 的重载在第一位，因此 t1、t2、t3 的返回值类型都被重载成了 any。</p>\n<h4 data-nodeid=\"1479\">合并 namespace</h4>\n<p data-nodeid=\"1480\">合并 namespace 与合并接口类似，命名空间的合并也会合并其导出成员的属性。不同的是，非导出成员仅在原命名空间内可见。</p>\n<p data-nodeid=\"1481\">下面看一个具体的示例：</p>\n<pre class=\"lang-typescript\" data-nodeid=\"1482\"><code data-language=\"typescript\"><span class=\"hljs-keyword\">namespace</span> Person {\n  <span class=\"hljs-keyword\">const</span> age = <span class=\"hljs-number\">18</span>;\n  <span class=\"hljs-keyword\">export</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">getAge</span>(<span class=\"hljs-params\"></span>) </span>{\n    <span class=\"hljs-keyword\">return</span> age;\n  }\n}\n<span class=\"hljs-keyword\">namespace</span> Person {\n  <span class=\"hljs-keyword\">export</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">getMyAge</span>(<span class=\"hljs-params\"></span>) </span>{\n    <span class=\"hljs-keyword\">return</span> age; <span class=\"hljs-comment\">// TS2304: Cannot find name 'age'.</span>\n  }\n}\n</code></pre>\n<p data-nodeid=\"1483\">在上面的例子，同名的命名空间 Person 中，有一个非导出的属性 age，在第二个命名空间 Person 中没有 age 属性却引用了 age，所以 TypeScript 报出了找不到 age 的错误。这是因为非导出成员仅在合并前的命名空间中可见，上例中即 1~6 行的命名空间中可以访问 age 属性。但是对于 8~12 行中的同名命名空间是不可以访问 age 属性的。</p>\n<h4 data-nodeid=\"1484\">不可合并</h4>\n<p data-nodeid=\"1485\">介绍类类型时我们说过，定义一个类类型，相当于定义了一个类，又定义了一个类的类型。因此，对于类这个既是值又是类型的特殊对象不能合并。</p>\n<p data-nodeid=\"1486\">除了可以通过接口和命名空间合并的方式扩展原来声明的类型外，我们还可以通过扩展模块或扩展全局对象来增强类型系统。</p>\n<h3 data-nodeid=\"1487\">扩充模块</h3>\n<p data-nodeid=\"1488\">JavaScript 是一门动态类型的语言，通过 prototype 我们可以很容易地扩展原来的对象。</p>\n<p data-nodeid=\"1489\">但是，如果我们直接扩展导入对象的原型链属性，TypeScript 会提示没有该属性的错误，因此我们就需要扩展原模块的属性。</p>\n<p data-nodeid=\"1490\">下面看一个具体的示例：</p>\n<pre class=\"lang-typescript\" data-nodeid=\"1491\"><code data-language=\"typescript\"><span class=\"hljs-comment\">// person.ts</span>\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">class</span> Person {}\n<span class=\"hljs-comment\">// index.ts</span>\n<span class=\"hljs-keyword\">import</span> { Person } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'./person'</span>;\n<span class=\"hljs-keyword\">declare</span> <span class=\"hljs-keyword\">module</span> './person' {\n  <span class=\"hljs-keyword\">interface</span> Person {\n    greet: <span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> <span class=\"hljs-built_in\">void</span>;\n  }\n}\nPerson.prototype.greet = <span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> {\n  <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'Hi!'</span>);\n};\n</code></pre>\n<p data-nodeid=\"1492\">在上面的例子中，我们声明了导入模块 person 中 Person 的属性，TypeScript 会与原模块的类型合并，通过这种方式我们可以扩展导入模块的类型。同时，我们为导入的 Person 类增加了原型链上的 greet 方法。</p>\n<pre class=\"lang-diff\" data-nodeid=\"1493\"><code data-language=\"diff\">// person.ts\nexport class Person {}\n\n// index.ts\nimport { Person } from './person';\n\ndeclare module './person' {\n  interface Person {\n &nbsp;  greet: () =&gt; void;\n  }\n}\n\n<span class=\"hljs-deletion\">- declare module './person' {</span>\n<span class=\"hljs-deletion\">- &nbsp; interface Person {</span>\n<span class=\"hljs-deletion\">- &nbsp; &nbsp; greet: () =&gt; void;</span>\n<span class=\"hljs-deletion\">- &nbsp; }</span>\n<span class=\"hljs-deletion\">- }</span>\n\n<span class=\"hljs-addition\">+ // TS2339: Property 'greet' does not exist on type 'Person'.</span>\nPerson.prototype.greet = () =&gt; {\n  console.log('Hi!');\n};\n</code></pre>\n<p data-nodeid=\"1494\">在上面的例子中，如果我们删除了扩展模块的声明，第 20 行则会报出 ts(2339) 不存在 greet 属性的类型错误。</p>\n<p data-nodeid=\"1495\">对于导入的三方模块，我们同样可以使用这个方法扩充原模块的属性。</p>\n<h3 data-nodeid=\"1496\">扩充全局</h3>\n<p data-nodeid=\"1497\">全局模块指的是不需要通过 import 导入即可使用的模块，如全局的 window、document 等。</p>\n<p data-nodeid=\"1498\">对全局对象的扩充与对模块的扩充是一样的，下面看一个具体示例：</p>\n<pre class=\"lang-typescript\" data-nodeid=\"1499\"><code data-language=\"typescript\"><span class=\"hljs-keyword\">declare</span> global {\n  <span class=\"hljs-keyword\">interface</span> Array&lt;T <span class=\"hljs-keyword\">extends</span> unknown&gt; {\n    getLen(): <span class=\"hljs-built_in\">number</span>;\n  }\n}\n<span class=\"hljs-built_in\">Array</span>.prototype.getLen = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>{\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">this</span>.length;\n};\n</code></pre>\n<p data-nodeid=\"1500\">在上面的例子中，因为我们声明了全局的 Array 对象有一个 getLen 方法，所以为 Array 对象实现 getLen 方法时，TypeScript 不会报错。</p>\n<h3 data-nodeid=\"1501\">小结与预告</h3>\n<p data-nodeid=\"1502\">这一讲我们学习了声明的基本语法和如何使用声明文件，同时还学习了如何扩展类型定义以及模块类型，掌握了这些技巧不但可以扩展增强原模块，还能修改原模块的类型定义。</p>\n<p data-nodeid=\"1503\">在14 讲中，我们将学习 TypeScript 官方提供的工具类型。<strong data-nodeid=\"1694\">通过使用这些内置工具类型，我们可以在不同的项目中轻松地组合出一些复杂的工具类型。</strong></p>\n<p data-nodeid=\"1504\" class=\"\">最后，如果你觉得本专栏有价值，欢迎分享给更多好友！</p>",
                "article_title": "13 | 必备增强类型系统的方式大盘点，让你的开发如虎添翼",
                "title": "13 | 必备增强类型系统的方式大盘点，让你的开发如虎添翼",
                "id": 7445
            },
            {
                "content": "<p data-nodeid=\"11916\">在 13 讲中我们学习了如何增强 TypeScript 类型系统，这一讲将继续深入了解 TypeScript 官方提供的全局工具类型。</p>\n\n\n<p data-nodeid=\"11267\">在 TypeScript 中提供了许多自带的工具类型，因为这些类型都是全局可用的，所以无须导入即可直接使用。了解了基础的工具类型后，我们不仅知道 TypeScript 如何利用前几讲介绍的基础类型知识实现这些工具类型，还知道如何更好地利用这些基础类型，以免重复造轮子，并能通过这些工具类型实现更复杂的类型。</p>\n<p data-nodeid=\"11268\">根据使用范围，我们可以将工具类型划分为操作接口类型、联合类型、函数类型、字符串类型这 4 个方向，下面一一介绍。</p>\n<h3 data-nodeid=\"11269\">操作接口类型</h3>\n<h4 data-nodeid=\"11270\">Partial</h4>\n<p data-nodeid=\"11271\">Partial 工具类型可以将一个类型的所有属性变为可选的，且该工具类型返回的类型是给定类型的所有子集，下面我们看一个具体的示例：</p>\n<pre class=\"lang-typescript\" data-nodeid=\"11272\"><code data-language=\"typescript\"><span class=\"hljs-keyword\">type</span> Partial&lt;T&gt; = {\n  [P <span class=\"hljs-keyword\">in</span> keyof T]?: T[P];\n};\n<span class=\"hljs-keyword\">interface</span> Person {\n  name: <span class=\"hljs-built_in\">string</span>;\n  age?: <span class=\"hljs-built_in\">number</span>;\n  weight?: <span class=\"hljs-built_in\">number</span>;\n}\n<span class=\"hljs-keyword\">type</span> PartialPerson = Partial&lt;Person&gt;;\n<span class=\"hljs-comment\">// 相当于</span>\n<span class=\"hljs-keyword\">interface</span> PartialPerson {\n  name?: <span class=\"hljs-built_in\">string</span>;\n  age?: <span class=\"hljs-built_in\">number</span>;\n  weight?: <span class=\"hljs-built_in\">number</span>;\n}\n</code></pre>\n<p data-nodeid=\"11273\">在上述示例中，我们使用映射类型取出了传入类型的所有键值，并将其值设定为可选的。</p>\n<h4 data-nodeid=\"11274\">Required</h4>\n<p data-nodeid=\"11275\">与 Partial 工具类型相反，Required 工具类型可以将给定类型的所有属性变为必填的，下面我们看一个具体示例。</p>\n<pre class=\"lang-typescript\" data-nodeid=\"11276\"><code data-language=\"typescript\"><span class=\"hljs-keyword\">type</span> Required&lt;T&gt; = {\n  [P <span class=\"hljs-keyword\">in</span> keyof T]-?: T[P];\n};\n<span class=\"hljs-keyword\">type</span> RequiredPerson = Required&lt;Person&gt;;\n<span class=\"hljs-comment\">// 相当于</span>\n<span class=\"hljs-keyword\">interface</span> RequiredPerson {\n  name: <span class=\"hljs-built_in\">string</span>;\n  age: <span class=\"hljs-built_in\">number</span>;\n  weight: <span class=\"hljs-built_in\">number</span>;\n}\n</code></pre>\n<p data-nodeid=\"11277\">在上述示例中，映射类型在键值的后面使用了一个 - 符号，- 与 ? 组合起来表示去除类型的可选属性，因此给定类型的所有属性都变为了必填。</p>\n<h4 data-nodeid=\"11278\">Readonly</h4>\n<p data-nodeid=\"11279\">Readonly 工具类型可以将给定类型的所有属性设为只读，这意味着给定类型的属性不可以被重新赋值，下面我们看一个具体的示例。</p>\n<pre class=\"lang-typescript\" data-nodeid=\"11280\"><code data-language=\"typescript\"><span class=\"hljs-keyword\">type</span> Readonly&lt;T&gt; = {\n  readonly [P <span class=\"hljs-keyword\">in</span> keyof T]: T[P];\n};\n<span class=\"hljs-keyword\">type</span> ReadonlyPerson = Readonly&lt;Person&gt;;\n<span class=\"hljs-comment\">// 相当于</span>\n<span class=\"hljs-keyword\">interface</span> ReadonlyPerson {\n  readonly name: <span class=\"hljs-built_in\">string</span>;\n  readonly age?: <span class=\"hljs-built_in\">number</span>;\n  readonly weight?: <span class=\"hljs-built_in\">number</span>;\n}\n</code></pre>\n<p data-nodeid=\"11281\">在上述示例中，经过 Readonly 处理后，ReadonlyPerson 的 name、age、weight 等属性都变成了 readonly 只读。</p>\n<h4 data-nodeid=\"11282\">Pick</h4>\n<p data-nodeid=\"11283\">Pick 工具类型可以从给定的类型中选取出指定的键值，然后组成一个新的类型，下面我们看一个具体的示例。</p>\n<pre class=\"lang-typescript\" data-nodeid=\"11284\"><code data-language=\"typescript\"><span class=\"hljs-keyword\">type</span> Pick&lt;T, K <span class=\"hljs-keyword\">extends</span> keyof T&gt; = {\n  [P <span class=\"hljs-keyword\">in</span> K]: T[P];\n};\n<span class=\"hljs-keyword\">type</span> NewPerson = Pick&lt;Person, <span class=\"hljs-string\">'name'</span> | <span class=\"hljs-string\">'age'</span>&gt;;\n<span class=\"hljs-comment\">// 相当于</span>\n<span class=\"hljs-keyword\">interface</span> NewPerson {\n  name: <span class=\"hljs-built_in\">string</span>;\n  age?: <span class=\"hljs-built_in\">number</span>;\n}\n</code></pre>\n<p data-nodeid=\"11285\">在上述示例中，Pick工具类型接收了两个泛型参数，第一个 T 为给定的参数类型，而第二个参数为需要提取的键值 key。有了参数类型和需要提取的键值 key，我们就可以通过映射类型很容易地实现 Pick 工具类型的功能。</p>\n<h4 data-nodeid=\"11286\">Omit</h4>\n<p data-nodeid=\"11287\">与 Pick 类型相反，Omit 工具类型的功能是返回去除指定的键值之后返回的新类型，下面我们看一个具体的示例：</p>\n<pre class=\"lang-typescript\" data-nodeid=\"11288\"><code data-language=\"typescript\"><span class=\"hljs-keyword\">type</span> Omit&lt;T, K <span class=\"hljs-keyword\">extends</span> keyof <span class=\"hljs-built_in\">any</span>&gt; = Pick&lt;T, Exclude&lt;keyof T, K&gt;&gt;;\n<span class=\"hljs-keyword\">type</span> NewPerson = Omit&lt;Person, <span class=\"hljs-string\">'weight'</span>&gt;;\n<span class=\"hljs-comment\">// 相当于</span>\n<span class=\"hljs-keyword\">interface</span> NewPerson {\n  name: <span class=\"hljs-built_in\">string</span>;\n  age?: <span class=\"hljs-built_in\">number</span>;\n}\n</code></pre>\n<p data-nodeid=\"11289\">在上述示例中，Omit 类型的实现使用了前面介绍的 Pick 类型。我们知道 Pick 类型的作用是选取给定类型的指定属性，那么这里的 Omit 的作用应该是选取除了指定属性之外的属性，而 Exclude 工具类型的作用就是从入参 T 属性的联合类型中排除入参 K 指定的若干属性。</p>\n<blockquote data-nodeid=\"11290\">\n<p data-nodeid=\"11291\"><strong data-nodeid=\"11394\">Tips</strong>：操作接口类型这一小节所介绍的工具类型都使用了映射类型。通过映射类型，我们可以对原类型的属性进行重新映射，从而组成想要的类型。</p>\n</blockquote>\n<h3 data-nodeid=\"11292\">联合类型</h3>\n<h4 data-nodeid=\"11293\">Exclude</h4>\n<p data-nodeid=\"11294\">在介绍 Omit 类型的实现中，我们使用了 Exclude 类型。通过使用 Exclude 类型，我们从接口的所有属性中去除了指定属性，因此，Exclude 的作用就是从联合类型中去除指定的类型。</p>\n<p data-nodeid=\"11295\">下面我们看一个具体的示例：</p>\n<pre class=\"lang-typescript\" data-nodeid=\"11296\"><code data-language=\"typescript\"><span class=\"hljs-keyword\">type</span> Exclude&lt;T, U&gt; = T <span class=\"hljs-keyword\">extends</span> U ? never : T;\n<span class=\"hljs-keyword\">type</span> T = Exclude&lt;<span class=\"hljs-string\">'a'</span> | <span class=\"hljs-string\">'b'</span> | <span class=\"hljs-string\">'c'</span>, <span class=\"hljs-string\">'a'</span>&gt;; <span class=\"hljs-comment\">// =&gt; 'b' | 'c'</span>\n<span class=\"hljs-keyword\">type</span> NewPerson = Omit&lt;Person, <span class=\"hljs-string\">'weight'</span>&gt;;\n<span class=\"hljs-comment\">// 相当于</span>\n<span class=\"hljs-keyword\">type</span> NewPerson = Pick&lt;Person, Exclude&lt;keyof Person, <span class=\"hljs-string\">'weight'</span>&gt;&gt;;\n<span class=\"hljs-comment\">// 其中</span>\n<span class=\"hljs-keyword\">type</span> ExcludeKeys = Exclude&lt;keyof Person, <span class=\"hljs-string\">'weight'</span>&gt;; <span class=\"hljs-comment\">// =&gt; 'name' | 'age'</span>\n</code></pre>\n<p data-nodeid=\"11297\">在上述示例中，Exclude 的实现使用了条件类型。如果类型 T 可被分配给类型 U ，则不返回类型 T，否则返回此类型 T ，这样我们就从联合类型中去除了指定的类型。</p>\n<p data-nodeid=\"11298\">再回看之前的 NewPerson 类型的例子，我们也就很明白了。在 ExcludeKeys 中，如果 Person 类型的属性是我们要去除的属性，则不返回该属性，否则返回其类型。</p>\n<h4 data-nodeid=\"11299\">Extract</h4>\n<p data-nodeid=\"11300\">Extract 类型的作用与 Exclude 正好相反，Extract 主要用来从联合类型中提取指定的类型，类似于操作接口类型中的 Pick 类型。</p>\n<p data-nodeid=\"11301\">下面我们看一个具体的示例：</p>\n<pre class=\"lang-typescript\" data-nodeid=\"11302\"><code data-language=\"typescript\"><span class=\"hljs-keyword\">type</span> Extract&lt;T, U&gt; = T <span class=\"hljs-keyword\">extends</span> U ? T : never;\n<span class=\"hljs-keyword\">type</span> T = Extract&lt;<span class=\"hljs-string\">'a'</span> | <span class=\"hljs-string\">'b'</span> | <span class=\"hljs-string\">'c'</span>, <span class=\"hljs-string\">'a'</span>&gt;; <span class=\"hljs-comment\">// =&gt; 'a'</span>\n</code></pre>\n<p data-nodeid=\"11303\">通过上述示例，我们发现 Extract 类型相当于取出两个联合类型的交集。</p>\n<p data-nodeid=\"11304\">此外，我们还可以基于 Extract 实现一个获取接口类型交集的工具类型，如下示例：</p>\n<pre class=\"lang-typescript\" data-nodeid=\"11305\"><code data-language=\"typescript\"><span class=\"hljs-keyword\">type</span> Intersect&lt;T, U&gt; = {\n  [K <span class=\"hljs-keyword\">in</span> Extract&lt;keyof T, keyof U&gt;]: T[K];\n};\n<span class=\"hljs-keyword\">interface</span> Person {\n  name: <span class=\"hljs-built_in\">string</span>;\n  age?: <span class=\"hljs-built_in\">number</span>;\n  weight?: <span class=\"hljs-built_in\">number</span>;\n}\n<span class=\"hljs-keyword\">interface</span> NewPerson {\n  name: <span class=\"hljs-built_in\">string</span>;\n  age?: <span class=\"hljs-built_in\">number</span>;\n}\n<span class=\"hljs-keyword\">type</span> T = Intersect&lt;Person, NewPerson&gt;;\n<span class=\"hljs-comment\">// 相当于</span>\n<span class=\"hljs-keyword\">type</span> T = {\n  name: <span class=\"hljs-built_in\">string</span>;\n  age?: <span class=\"hljs-built_in\">number</span>;\n};\n</code></pre>\n<p data-nodeid=\"11306\">在上述的例子中，我们使用了 Extract 类型来提取两个接口类型属性的交集，并使用映射类型生成了一个新的类型。</p>\n<h4 data-nodeid=\"11307\">NonNullable</h4>\n<p data-nodeid=\"11308\">NonNullable 的作用是从联合类型中去除 null 或者 undefined 的类型。如果你对条件类型已经很熟悉了，那么应该知道如何实现 NonNullable 类型了。</p>\n<p data-nodeid=\"11309\">下面看一个具体的示例：</p>\n<pre class=\"lang-typescript\" data-nodeid=\"11310\"><code data-language=\"typescript\"><span class=\"hljs-keyword\">type</span> NonNullable&lt;T&gt; = T <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-literal\">null</span> | <span class=\"hljs-literal\">undefined</span> ? never : T;\n<span class=\"hljs-comment\">// 等同于使用 Exclude</span>\n<span class=\"hljs-keyword\">type</span> NonNullable&lt;T&gt; = Exclude&lt;T, <span class=\"hljs-literal\">null</span> | <span class=\"hljs-literal\">undefined</span>&gt;;\n<span class=\"hljs-keyword\">type</span> T = NonNullable&lt;<span class=\"hljs-built_in\">string</span> | <span class=\"hljs-built_in\">number</span> | <span class=\"hljs-literal\">undefined</span> | <span class=\"hljs-literal\">null</span>&gt;; <span class=\"hljs-comment\">// =&gt; string | number</span>\n</code></pre>\n<p data-nodeid=\"11311\">在上述示例中，如果 NonNullable 传入的类型可以被分配给 null 或是 undefined ，则不返回该类型，否则返回其具体类型。</p>\n<h4 data-nodeid=\"11312\">Record</h4>\n<p data-nodeid=\"11313\">Record 的作用是生成接口类型，然后我们使用传入的泛型参数分别作为接口类型的属性和值。</p>\n<p data-nodeid=\"11314\">下面我们看一个具体的示例：</p>\n<pre class=\"lang-typescript\" data-nodeid=\"11315\"><code data-language=\"typescript\"><span class=\"hljs-keyword\">type</span> Record&lt;K <span class=\"hljs-keyword\">extends</span> keyof <span class=\"hljs-built_in\">any</span>, T&gt; = {\n  [P <span class=\"hljs-keyword\">in</span> K]: T;\n};\n<span class=\"hljs-keyword\">type</span> MenuKey = <span class=\"hljs-string\">'home'</span> | <span class=\"hljs-string\">'about'</span> | <span class=\"hljs-string\">'more'</span>;\n<span class=\"hljs-keyword\">interface</span> Menu {\n  label: <span class=\"hljs-built_in\">string</span>;\n  hidden?: <span class=\"hljs-built_in\">boolean</span>;\n}\n<span class=\"hljs-keyword\">const</span> menus: Record&lt;MenuKey, Menu&gt; = {\n  about: { label: <span class=\"hljs-string\">'关于'</span> },\n  home: { label: <span class=\"hljs-string\">'主页'</span> },\n  more: { label: <span class=\"hljs-string\">'更多'</span>, hidden: <span class=\"hljs-literal\">true</span> },\n};\n</code></pre>\n<p data-nodeid=\"11316\">在上述示例中，Record 类型接收了两个泛型参数：第一个参数作为接口类型的属性，第二个参数作为接口类型的属性值。</p>\n<blockquote data-nodeid=\"11317\">\n<p data-nodeid=\"11318\"><strong data-nodeid=\"11420\">需要注意：这里的实现限定了第一个泛型参数继承自</strong><code data-backticks=\"1\" data-nodeid=\"11418\">keyof any</code>。</p>\n</blockquote>\n<p data-nodeid=\"11319\">在 TypeScript 中，keyof any 指代可以作为对象键的属性，如下示例：</p>\n<pre class=\"lang-typescript\" data-nodeid=\"11320\"><code data-language=\"typescript\"><span class=\"hljs-keyword\">type</span> T = keyof <span class=\"hljs-built_in\">any</span>; <span class=\"hljs-comment\">// =&gt; string | number | symbol</span>\n</code></pre>\n<blockquote data-nodeid=\"11321\">\n<p data-nodeid=\"11322\"><strong data-nodeid=\"11432\">说明</strong>：目前，JavaScript 仅支持<code data-backticks=\"1\" data-nodeid=\"11426\">string</code>、<code data-backticks=\"1\" data-nodeid=\"11428\">number</code>、<code data-backticks=\"1\" data-nodeid=\"11430\">symbol</code>作为对象的键值。</p>\n</blockquote>\n<h3 data-nodeid=\"11323\">函数类型</h3>\n<h4 data-nodeid=\"11324\">ConstructorParameters</h4>\n<p data-nodeid=\"11325\">ConstructorParameters 可以用来获取构造函数的构造参数，而 ConstructorParameters 类型的实现则需要使用 infer 关键字推断构造参数的类型。</p>\n<p data-nodeid=\"11326\">关于 infer 关键字，我们可以把它当成简单的模式匹配来看待。如果真实的参数类型和 infer 匹配的一致，那么就返回匹配到的这个类型。</p>\n<p data-nodeid=\"11327\">下面看一个具体的示例：</p>\n<pre class=\"lang-typescript\" data-nodeid=\"11328\"><code data-language=\"typescript\"><span class=\"hljs-keyword\">type</span> ConstructorParameters&lt;T <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-keyword\">new</span> (...args: <span class=\"hljs-built_in\">any</span>) =&gt; <span class=\"hljs-built_in\">any</span>&gt; = T <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-keyword\">new</span> (\n  ...args: infer P\n) =&gt; <span class=\"hljs-built_in\">any</span>\n  ? P\n  : never;\n<span class=\"hljs-keyword\">class</span> Person {\n  <span class=\"hljs-keyword\">constructor</span>(<span class=\"hljs-params\">name: <span class=\"hljs-built_in\">string</span>, age?: <span class=\"hljs-built_in\">number</span></span>) {}\n}\n<span class=\"hljs-keyword\">type</span> T = ConstructorParameters&lt;<span class=\"hljs-keyword\">typeof</span> Person&gt;; <span class=\"hljs-comment\">// [name: string, age?: number]</span>\n</code></pre>\n<p data-nodeid=\"11329\">在上述示例中，ConstructorParameters 泛型接收了一个参数，并且限制了这个参数需要实现构造函数。于是，我们通过 infer 关键字匹配了构造函数内的构造参数，并返回了这些参数。因此，可以看到第 11 行匹配了 Person 构造函数的两个参数，并返回了一个元组类型 [string, number] 给类型别名 T。</p>\n<h4 data-nodeid=\"11330\">Parameters</h4>\n<p data-nodeid=\"11331\">Parameters 的作用与 ConstructorParameters 类似，Parameters 可以用来获取函数的参数并返回序对，如下示例：</p>\n<pre class=\"lang-typescript\" data-nodeid=\"11332\"><code data-language=\"typescript\"><span class=\"hljs-keyword\">type</span> Parameters&lt;T <span class=\"hljs-keyword\">extends</span> (...args: <span class=\"hljs-built_in\">any</span>) =&gt; <span class=\"hljs-built_in\">any</span>&gt; = T <span class=\"hljs-keyword\">extends</span> (...args: infer P) =&gt; <span class=\"hljs-built_in\">any</span> ? P : never;\n<span class=\"hljs-keyword\">type</span> T0 = Parameters&lt;<span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> <span class=\"hljs-built_in\">void</span>&gt;; <span class=\"hljs-comment\">// []</span>\n<span class=\"hljs-keyword\">type</span> T1 = Parameters&lt;<span class=\"hljs-function\">(<span class=\"hljs-params\">x: <span class=\"hljs-built_in\">number</span>, y?: <span class=\"hljs-built_in\">string</span></span>) =&gt;</span> <span class=\"hljs-built_in\">void</span>&gt;; <span class=\"hljs-comment\">// [x: number, y?: string]</span>\n</code></pre>\n<p data-nodeid=\"11333\">在上述示例中，Parameters 的泛型参数限制了传入的类型需要满足函数类型。</p>\n<h4 data-nodeid=\"11334\">ReturnType</h4>\n<p data-nodeid=\"11335\">ReturnType 的作用是用来获取函数的返回类型，下面我们看一个具体的示例：</p>\n<pre class=\"lang-typescript\" data-nodeid=\"11336\"><code data-language=\"typescript\"><span class=\"hljs-keyword\">type</span> ReturnType&lt;T <span class=\"hljs-keyword\">extends</span> (...args: <span class=\"hljs-built_in\">any</span>) =&gt; <span class=\"hljs-built_in\">any</span>&gt; = T <span class=\"hljs-keyword\">extends</span> (...args: <span class=\"hljs-built_in\">any</span>) =&gt; infer R ? R : <span class=\"hljs-built_in\">any</span>;\n<span class=\"hljs-keyword\">type</span> T0 = ReturnType&lt;<span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> <span class=\"hljs-built_in\">void</span>&gt;; <span class=\"hljs-comment\">// =&gt; void</span>\n<span class=\"hljs-keyword\">type</span> T1 = ReturnType&lt;<span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> <span class=\"hljs-built_in\">string</span>&gt;; <span class=\"hljs-comment\">// =&gt; string</span>\n</code></pre>\n<p data-nodeid=\"11337\">在上述示例中，<code data-backticks=\"1\" data-nodeid=\"11449\">ReturnType</code>的泛型参数限制了传入的类型需要满足函数类型。</p>\n<h4 data-nodeid=\"11338\">ThisParameterType</h4>\n<p data-nodeid=\"11339\">ThisParameterType 可以用来获取函数的 this 参数类型。</p>\n<p data-nodeid=\"11340\">关于函数的 this 参数，我们在 05 讲函数类型中介绍过，下面看一个具体的示例：</p>\n<pre class=\"lang-typescript\" data-nodeid=\"11341\"><code data-language=\"typescript\"><span class=\"hljs-keyword\">type</span> ThisParameterType&lt;T&gt; = T <span class=\"hljs-keyword\">extends</span> (<span class=\"hljs-keyword\">this</span>: infer U, ...args: <span class=\"hljs-built_in\">any</span>[]) =&gt; <span class=\"hljs-built_in\">any</span> ? U : unknown;\n<span class=\"hljs-keyword\">type</span> T = ThisParameterType&lt;<span class=\"hljs-function\">(<span class=\"hljs-params\"><span class=\"hljs-keyword\">this</span>: <span class=\"hljs-built_in\">Number</span>, x: <span class=\"hljs-built_in\">number</span></span>) =&gt;</span> <span class=\"hljs-built_in\">void</span>&gt;; <span class=\"hljs-comment\">// Number</span>\n</code></pre>\n<p data-nodeid=\"11342\">在上述示例的第 1 行中，因为函数类型的第一个参数声明的是 this 参数类型，所以我们可以直接使用 infer 关键字进行匹配并获取 this 参数类型。在示例的第 3 行，类型别名 T 得到的类型就是 Number。</p>\n<h4 data-nodeid=\"11343\">ThisType</h4>\n<p data-nodeid=\"11344\">ThisType 的作用是可以在对象字面量中指定 this 的类型。ThisType 不返回转换后的类型，而是通过 ThisType 的泛型参数指定 this 的类型，下面看一个具体的示例：</p>\n<blockquote data-nodeid=\"11345\">\n<p data-nodeid=\"11346\">注意：如果你想使用这个工具类型，那么需要开启<code data-backticks=\"1\" data-nodeid=\"11458\">noImplicitThis</code>的 TypeScript 配置。</p>\n</blockquote>\n<pre class=\"lang-typescript\" data-nodeid=\"11347\"><code data-language=\"typescript\"><span class=\"hljs-keyword\">type</span> ObjectDescriptor&lt;D, M&gt; = {\n  data?: D;\n  methods?: M &amp; ThisType&lt;D &amp; M&gt;; <span class=\"hljs-comment\">// methods 中 this 的类型是 D &amp; M</span>\n};\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">makeObject</span>&lt;<span class=\"hljs-title\">D</span>, <span class=\"hljs-title\">M</span>&gt;(<span class=\"hljs-params\">desc: ObjectDescriptor&lt;D, M&gt;</span>): <span class=\"hljs-title\">D</span> &amp; <span class=\"hljs-title\">M</span> </span>{\n  <span class=\"hljs-keyword\">let</span> data: object = desc.data || {};\n  <span class=\"hljs-keyword\">let</span> methods: object = desc.methods || {};\n  <span class=\"hljs-keyword\">return</span> { ...data, ...methods } <span class=\"hljs-keyword\">as</span> D &amp; M;\n}\n<span class=\"hljs-keyword\">const</span> obj = makeObject({\n  data: { x: <span class=\"hljs-number\">0</span>, y: <span class=\"hljs-number\">0</span> },\n  methods: {\n    moveBy(dx: <span class=\"hljs-built_in\">number</span>, dy: <span class=\"hljs-built_in\">number</span>) {\n      <span class=\"hljs-keyword\">this</span>.x += dx; <span class=\"hljs-comment\">// this =&gt; D &amp; M</span>\n      <span class=\"hljs-keyword\">this</span>.y += dy; <span class=\"hljs-comment\">// this =&gt; D &amp; M</span>\n    },\n  },\n});\nobj.x = <span class=\"hljs-number\">10</span>;\nobj.y = <span class=\"hljs-number\">20</span>;\nobj.moveBy(<span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">5</span>);\n</code></pre>\n<p data-nodeid=\"11348\">在上述示例子中，methods 属性的 this 类型为 D &amp; M，在上下文中指代 { x: number, y: number } &amp; { moveBy(dx: number, dy: number): void }。</p>\n<p data-nodeid=\"11349\">ThisType 工具类型只是提供了一个空的泛型接口，仅可以在对象字面量上下文中被 TypeScript 识别，如下所示：</p>\n<pre class=\"lang-typescript\" data-nodeid=\"11350\"><code data-language=\"typescript\"><span class=\"hljs-keyword\">interface</span> ThisType&lt;T&gt; {}\n</code></pre>\n<p data-nodeid=\"11351\">也就是说该类型的作用相当于任意空接口。</p>\n<h4 data-nodeid=\"11352\">OmitThisParameter</h4>\n<p data-nodeid=\"11353\">OmitThisParameter 工具类型主要用来去除函数类型中的 this 类型。如果传入的函数类型没有显式声明 this 类型，那么返回的仍是原来的函数类型。</p>\n<p data-nodeid=\"11354\">下面看一个具体的示例：</p>\n<pre class=\"lang-typescript\" data-nodeid=\"11355\"><code data-language=\"typescript\"><span class=\"hljs-keyword\">type</span> OmitThisParameter&lt;T&gt; = unknown <span class=\"hljs-keyword\">extends</span> ThisParameterType&lt;T&gt;\n  ? T\n  : T <span class=\"hljs-keyword\">extends</span> (...args: infer A) =&gt; infer R\n  ? <span class=\"hljs-function\">(<span class=\"hljs-params\">...args: A</span>) =&gt;</span> R\n  : T;\n<span class=\"hljs-keyword\">type</span> T = OmitThisParameter&lt;<span class=\"hljs-function\">(<span class=\"hljs-params\"><span class=\"hljs-keyword\">this</span>: <span class=\"hljs-built_in\">Number</span>, x: <span class=\"hljs-built_in\">number</span></span>) =&gt;</span> <span class=\"hljs-built_in\">string</span>&gt;; <span class=\"hljs-comment\">// (x: number) =&gt; string</span>\n</code></pre>\n<p data-nodeid=\"11356\">在上述示例中， ThisParameterType 类型的实现如果传入的泛型参数无法推断 this 的类型，则会返回 unknown 类型。在OmitThisParameter 的实现中，第一个条件语句如果传入的函数参数没有 this 类型，则返回原类型；否则通过 infer 分别获取函数参数和返回值的类型构造一个新的没有 this 的函数类型，并返回这个函数类型。</p>\n<h3 data-nodeid=\"11357\">字符串类型</h3>\n<h4 data-nodeid=\"11358\">模板字符串</h4>\n<p data-nodeid=\"11359\">TypeScript 自 4.1版本起开始支持模板字符串字面量类型。为此，TypeScript 也提供了 Uppercase、Lowercase、Capitalize、Uncapitalize这 4 种内置的操作字符串的类型，如下示例：</p>\n<pre class=\"lang-typescript\" data-nodeid=\"11360\"><code data-language=\"typescript\"><span class=\"hljs-comment\">// 转换字符串字面量到大写字母</span>\n<span class=\"hljs-keyword\">type</span> Uppercase&lt;S <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-built_in\">string</span>&gt; = intrinsic;\n<span class=\"hljs-comment\">// 转换字符串字面量到小写字母</span>\n<span class=\"hljs-keyword\">type</span> Lowercase&lt;S <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-built_in\">string</span>&gt; = intrinsic;\n<span class=\"hljs-comment\">// 转换字符串字面量的第一个字母为大写字母</span>\n<span class=\"hljs-keyword\">type</span> Capitalize&lt;S <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-built_in\">string</span>&gt; = intrinsic;\n<span class=\"hljs-comment\">// 转换字符串字面量的第一个字母为小写字母</span>\n<span class=\"hljs-keyword\">type</span> Uncapitalize&lt;S <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-built_in\">string</span>&gt; = intrinsic;\n<span class=\"hljs-keyword\">type</span> T0 = Uppercase&lt;<span class=\"hljs-string\">'Hello'</span>&gt;; <span class=\"hljs-comment\">// =&gt; 'HELLO'</span>\n<span class=\"hljs-keyword\">type</span> T1 = Lowercase&lt;T0&gt;; <span class=\"hljs-comment\">// =&gt; 'hello'</span>\n<span class=\"hljs-keyword\">type</span> T2 = Capitalize&lt;T1&gt;; <span class=\"hljs-comment\">// =&gt; 'Hello'</span>\n<span class=\"hljs-keyword\">type</span> T3 = Uncapitalize&lt;T2&gt;; <span class=\"hljs-comment\">// =&gt; 'hello'</span>\n</code></pre>\n<p data-nodeid=\"11361\">在上述示例中，这 4 种操作字符串字面量工具类型的实现都是使用 JavaScript 运行时的字符串操作函数计算出来的，且不支持语言区域设置。以下代码是这 4 种字符串工具类型的实际实现。</p>\n<pre class=\"lang-typescript\" data-nodeid=\"11362\"><code data-language=\"typescript\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">applyStringMapping</span>(<span class=\"hljs-params\">symbol: Symbol, str: <span class=\"hljs-built_in\">string</span></span>) </span>{\n  <span class=\"hljs-keyword\">switch</span> (intrinsicTypeKinds.get(symbol.escapedName <span class=\"hljs-keyword\">as</span> <span class=\"hljs-built_in\">string</span>)) {\n    <span class=\"hljs-keyword\">case</span> IntrinsicTypeKind.Uppercase:\n      <span class=\"hljs-keyword\">return</span> str.toUpperCase();\n    <span class=\"hljs-keyword\">case</span> IntrinsicTypeKind.Lowercase:\n      <span class=\"hljs-keyword\">return</span> str.toLowerCase();\n    <span class=\"hljs-keyword\">case</span> IntrinsicTypeKind.Capitalize:\n      <span class=\"hljs-keyword\">return</span> str.charAt(<span class=\"hljs-number\">0</span>).toUpperCase() + str.slice(<span class=\"hljs-number\">1</span>);\n    <span class=\"hljs-keyword\">case</span> IntrinsicTypeKind.Uncapitalize:\n      <span class=\"hljs-keyword\">return</span> str.charAt(<span class=\"hljs-number\">0</span>).toLowerCase() + str.slice(<span class=\"hljs-number\">1</span>);\n  }\n  <span class=\"hljs-keyword\">return</span> str;\n}\n</code></pre>\n<p data-nodeid=\"11363\">在上述代码中可以看到，字符串的转换使用了 JavaScript 中字符串的 toUpperCase 和 toLowerCase 方法，而不是 toLocaleUpperCase 和 toLocaleLowerCase。其中 toUpperCase 和 toLowerCase 采用的是 Unicode 编码默认的大小写转换规则。</p>\n<h3 data-nodeid=\"11364\">小结与预告</h3>\n<p data-nodeid=\"11365\">这一讲我们学习了操作接口类型、联合类型、函数、字符串的工具类。</p>\n<p data-nodeid=\"11366\">在学习这些工具类型的实现时，我们发现它们都是基于映射类型、条件类型、infer 推断实现的。可以说掌握了这 3 种类型操作的技巧，我们就可以自由地组合更多的工具类型了。</p>\n<p data-nodeid=\"11367\">插播一道思考题：基于 Exclude 工具类型的代码实现，请你分析一下为什么它可以从联合类型中排除掉指定成员？欢迎你在留言区与我互动/交流。</p>\n<p data-nodeid=\"11368\">当然，这道题涉及的知识点大概率超纲了，在 15 讲编写自定义工具类型中我们将更详细地分析。请你保持好奇心，敬请期待吧！</p>\n<p data-nodeid=\"11369\">如果你觉得本专栏有价值，欢迎分享给更多好友！</p>",
                "article_title": "14 | 掌握 TypeScript 这些官方工具类型，让你的开发事半功倍",
                "title": "14 | 掌握 TypeScript 这些官方工具类型，让你的开发事半功倍",
                "id": 7446
            },
            {
                "content": "<p data-nodeid=\"18571\">14 讲我们学习了常见 TypeScript 官方内置的工具类型（官方轮子），它们的本质就是自定义的复杂类型构造器（确切地讲是泛型）。这一讲我们就来学习一下如何自己造轮子，并剖析一些常见第三方轮子的实现。</p>\n<blockquote data-nodeid=\"18572\">\n<p data-nodeid=\"18573\">学习建议：使用 VS Code 新建一个 15.ts 文件，尝试这一讲中出现的所有示例。</p>\n</blockquote>\n<h3 data-nodeid=\"18574\">类型物料</h3>\n<p data-nodeid=\"18575\">在正式造轮子之前，我们先来熟悉一下即将用到的物料，这可能涉及前面每一讲中的知识点和一些新语法。如果你连泛型特性都记不清的话，那么请至少从 10 讲开始温习一遍。</p>\n<p data-nodeid=\"18576\">言归正传，接下来我们一起看看重度依赖的一些类型物料。</p>\n<h4 data-nodeid=\"18577\">泛型</h4>\n<p data-nodeid=\"18578\">首先是泛型（回顾 10 讲），笔者认为工具类型的本质就是构造复杂类型的泛型。如果一个工具类型不能接受类型入参，那么它和普通的类型别名又有什么区别？因此，使用泛型进行变量抽离、逻辑封装其实就是在造类型的轮子，下面举一个具体的示例：</p>\n<pre class=\"lang-typescript\" data-nodeid=\"18579\"><code data-language=\"typescript\">  <span class=\"hljs-keyword\">type</span> isXX = <span class=\"hljs-number\">1</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-built_in\">number</span> ? <span class=\"hljs-literal\">true</span> : <span class=\"hljs-literal\">false</span>;\n  <span class=\"hljs-keyword\">type</span> isYY = <span class=\"hljs-string\">'string'</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-built_in\">string</span> ? <span class=\"hljs-literal\">true</span> : <span class=\"hljs-literal\">false</span>;\n</code></pre>\n<p data-nodeid=\"18580\">在示例中的第 1~2 行，我们重复使用了 extends 关键字和三元运算符实现根据类型 1 和 number、'string' 和 string 的子类型关系分别返回布尔字面量 true 或者 false，并给类型起了别名 isXX、isYY，这明显是一种效率低下的做法，因为我们不能把其中的逻辑复用在对其他类型子类型关系的判断上。这时，我们就需要把确切的类型抽离为入参，然后封装成一个可复用的泛型。</p>\n<p data-nodeid=\"18581\">下面一起看一个具体的示例：</p>\n<pre class=\"lang-typescript\" data-nodeid=\"18582\"><code data-language=\"typescript\">  <span class=\"hljs-keyword\">type</span> isSubTying&lt;Child, Par&gt; = Child <span class=\"hljs-keyword\">extends</span> Par ? <span class=\"hljs-literal\">true</span> : <span class=\"hljs-literal\">false</span>;\n  <span class=\"hljs-keyword\">type</span> isXX2 = isSubTyping&lt;<span class=\"hljs-number\">1</span>, <span class=\"hljs-built_in\">number</span>&gt;; <span class=\"hljs-comment\">// true</span>\n  <span class=\"hljs-keyword\">type</span> isYY2 = isSubTyping&lt;<span class=\"hljs-string\">'string'</span>, <span class=\"hljs-built_in\">string</span>&gt;; <span class=\"hljs-comment\">// true</span>\n  <span class=\"hljs-keyword\">type</span> isZZ2 = isSubTyping&lt;<span class=\"hljs-literal\">true</span>, <span class=\"hljs-built_in\">boolean</span>&gt;; <span class=\"hljs-comment\">// true</span>\n</code></pre>\n<p data-nodeid=\"18583\">示例中的第 1 行封装出来的工具泛型其实是我们在 12 讲中使用到的工具类型 isSubTyping，如果类型入参 Child 是 Par 的子类型，则返回布尔字面量类型 true，否则返回 false。这样，我们就可以使用 isSubTyping 判断其他任意两个类型之间的子类型关系了。</p>\n<p data-nodeid=\"18584\">比如示例中的第 2~4 行，因为 1 和 number、'string' 和 string、true 和 boolean 都是子类型和父类型的关系，所以返回的都是布尔字面量类型 true。</p>\n<h4 data-nodeid=\"18585\">条件类型</h4>\n<p data-nodeid=\"18586\">如我们在泛型中提到，TypeScript 支持使用三元运算的条件类型，它可以根据 ？前面的条件判断返回不同的类型。同时，三元运算还支持嵌套。</p>\n<p data-nodeid=\"18587\">在三元运算的条件判断逻辑中，它主要使用 extends 关键字判断两个类型的子类型关系，如下代码所示：</p>\n<pre class=\"lang-typescript\" data-nodeid=\"18588\"><code data-language=\"typescript\">  <span class=\"hljs-keyword\">type</span> isSubTyping&lt;Child, Par&gt; = Child <span class=\"hljs-keyword\">extends</span> Par ? <span class=\"hljs-literal\">true</span> : <span class=\"hljs-literal\">false</span>;\n  <span class=\"hljs-keyword\">type</span> isAssertable&lt;T, S&gt; = T <span class=\"hljs-keyword\">extends</span> S ? <span class=\"hljs-literal\">true</span> :  S <span class=\"hljs-keyword\">extends</span> T ? <span class=\"hljs-literal\">true</span> : <span class=\"hljs-literal\">false</span>;\n  <span class=\"hljs-keyword\">type</span> isNumAssertable = isAssertable&lt;<span class=\"hljs-number\">1</span>, <span class=\"hljs-built_in\">number</span>&gt;; <span class=\"hljs-comment\">// true</span>\n  <span class=\"hljs-keyword\">type</span> isStrAssertable = isAssertable&lt;<span class=\"hljs-built_in\">string</span>, <span class=\"hljs-string\">'string'</span>&gt;; <span class=\"hljs-comment\">// true</span>\n  <span class=\"hljs-keyword\">type</span> isNotAssertable = isAssertable&lt;<span class=\"hljs-number\">1</span>, <span class=\"hljs-built_in\">boolean</span>&gt;; <span class=\"hljs-comment\">// false</span>\n</code></pre>\n<p data-nodeid=\"18589\">以上示例，除了在第 1 行定义了 isSubTyping 之外，我们还在第 2 行定义了使用嵌套的三元运算，用来判断类型入参 T 是否可以被断言成类型 S（T as  S）的泛型  isAssertable，并使用 extends 关键字判断入参 T 是否是 S 的子类型或 S 是 T 的子类型，从而判断它们之间的可断言关系。</p>\n<p data-nodeid=\"18590\">在示例中的第 3~5 行，因为 1 是 number 类型的子类型，满足条件分支 T extends S，所以返回了 true；因为字符串字面量 'string' 是 string 类型的子类型，满足条件分支 S extends T，所以返回了 true；因为 1 既不是 boolean 的子类型，也不是父类型，不满足任何条件分支，所以返回了 false。</p>\n<p data-nodeid=\"18591\">下面我们一起来看看条件类型的另外一个特性：分配条件类型。</p>\n<h4 data-nodeid=\"18592\">分配条件类型（Distributive Conditional Types）</h4>\n<p data-nodeid=\"18593\">如我们在 10 讲中提到，在条件类型中，如果入参是联合类型，则会被拆解为一个个独立的（原子）类型（成员），然后再进行类型运算。</p>\n<p data-nodeid=\"18594\">下面我们看一个具体的示例：</p>\n<pre class=\"lang-typescript\" data-nodeid=\"18595\"><code data-language=\"typescript\">  <span class=\"hljs-keyword\">type</span> BooleanOrString = <span class=\"hljs-built_in\">string</span> | <span class=\"hljs-built_in\">boolean</span>;\n  <span class=\"hljs-keyword\">type</span> StringOrNumberArray&lt;E&gt; = E <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-built_in\">string</span> | <span class=\"hljs-built_in\">number</span> ? E[] : E;\n  <span class=\"hljs-keyword\">type</span> WhatIsThis = StringOrNumberArray&lt;BooleanOrString&gt;; <span class=\"hljs-comment\">// boolean | string[]</span>\n  <span class=\"hljs-keyword\">type</span> BooleanOrStringGot = BooleanOrString <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-built_in\">string</span> | <span class=\"hljs-built_in\">number</span> ? BooleanOrString[] : BooleanOrString; <span class=\"hljs-comment\">//  string | boolean</span>\n</code></pre>\n<p data-nodeid=\"18596\">在示例中的第 3 行， string 和 boolean 组成的联合类型 BooleanOrString 作为泛型 StringOrNumberArray 入参的时候，则会被拆解成 string 和 boolean 这两个独立的类型，再通过 extends 关键字判断是否是 string | number 类型的子类型。</p>\n<p data-nodeid=\"18597\">因为 string 是子集，而 boolean 不是，所以最终我们得到的 WhatIsThis 的类型是 boolean | string[]**。**但是，在非泛型条件类型中（示例中的第 4 行），因为 BooleanOrString 被当成了一个整体对待，所以 BooleanOrStringGot 的类型是 string | boolean。</p>\n<p data-nodeid=\"18598\">同样，通过某些手段强制类型入参被当成一个整体，也可以解除类型分配，如下示例：</p>\n<pre class=\"lang-typescript\" data-nodeid=\"18599\"><code data-language=\"typescript\">  <span class=\"hljs-keyword\">type</span> StringOrNumberArray&lt;E&gt; = [E] <span class=\"hljs-keyword\">extends</span> [<span class=\"hljs-built_in\">string</span> | <span class=\"hljs-built_in\">number</span>] ? E[] : E;\n  <span class=\"hljs-keyword\">type</span> WhatIsThis = StringOrNumberArray&lt;<span class=\"hljs-built_in\">string</span> | <span class=\"hljs-built_in\">boolean</span>&gt;; <span class=\"hljs-comment\">// string | boolean</span>\n</code></pre>\n<p data-nodeid=\"18600\">在示例中的第 1 行，我们使用 [] 将入参 E 包起来，即便入参是联合类型 string | boolean，也会被当成一个整体对待，所以第 2 行返回的是 string | boolean。</p>\n<p data-nodeid=\"18601\"><strong data-nodeid=\"18757\">注意：包含条件类型的泛型接收 never 作为泛型入参时，存在一定“陷阱”</strong>，如下示例：</p>\n<pre class=\"lang-typescript\" data-nodeid=\"18602\"><code data-language=\"typescript\">  <span class=\"hljs-keyword\">type</span> GetSNums = never <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-built_in\">number</span> ? <span class=\"hljs-built_in\">number</span>[] : never <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-built_in\">string</span> ? <span class=\"hljs-built_in\">string</span>[] : never; <span class=\"hljs-comment\">// number[];</span>\n  <span class=\"hljs-keyword\">type</span> GetNever = StringOrNumberArray&lt;never&gt;; <span class=\"hljs-comment\">// never</span>\n</code></pre>\n<p data-nodeid=\"18603\">在上述示例中的第 1 行，因为 never 是所有类型的子类型，自然也是 number 的子类型，所以返回的是 number 类型的数组；在第 2 行传入 never 作为入参来实例化前面定义的泛型 StringOrNumberArray 时，返回的类型却是 never，而不是 number[]。</p>\n<p data-nodeid=\"18604\">你要知道，泛型 StringOrNumberArray 的实现与示例第 1 行“=”右侧的逻辑并没有任何区别（除 never 被抽离成入参之外）。这是因为 never 是不能分配的底层类型，如果作为入参以原子形式出现在条件判断 extends 关键字左侧，则实例化得到的类型也是 never。</p>\n<p data-nodeid=\"18605\">下面看一个具体的示例：</p>\n<pre class=\"lang-typescript\" data-nodeid=\"18606\"><code data-language=\"typescript\">  <span class=\"hljs-keyword\">type</span> UsefulNeverX&lt;T&gt; = T <span class=\"hljs-keyword\">extends</span> {} ? T[] : [];\n  <span class=\"hljs-keyword\">type</span> UselessNeverX&lt;T, S&gt; = S <span class=\"hljs-keyword\">extends</span> {} ? S[] : [];\n  <span class=\"hljs-keyword\">type</span> UselessNeverY&lt;T, S&gt; = S <span class=\"hljs-keyword\">extends</span> {} ? T[] : [];\n  <span class=\"hljs-keyword\">type</span> UselessNeverZ&lt;T&gt; = [T] <span class=\"hljs-keyword\">extends</span> [{}] ? T[] : [];\n  <span class=\"hljs-keyword\">type</span> ThisIsNeverX = UsefulNeverX&lt;never&gt;; <span class=\"hljs-comment\">// never</span>\n  <span class=\"hljs-keyword\">type</span> ThisIsNotNeverX = UselessNeverX&lt;never, <span class=\"hljs-built_in\">string</span>&gt;; <span class=\"hljs-comment\">// string[]</span>\n  <span class=\"hljs-keyword\">type</span> ThisIsNotNeverY = UselessNeverY&lt;never, <span class=\"hljs-built_in\">string</span>&gt;; <span class=\"hljs-comment\">// never[]</span>\n  <span class=\"hljs-keyword\">type</span> ThisIsNotNeverZ = UselessNeverZ&lt;never&gt;; <span class=\"hljs-comment\">// never[]</span>\n</code></pre>\n<p data-nodeid=\"18607\">在示例中的第 1 行，因为我们定义的泛型 UsefulNeverX 的入参 T 被三元运算中的 extends 使用，所以第 5 行返回的类型是 never。而第 2 行、第 3 行定义的泛型入参 T 都没有被三元运算中的 extends 使用，所以第 6~7 行所返回的类型分别是 string[] 和 never[]。在第 4 行，因为入参 T 是以 T[] 而不是以原子形式被 extends 使用，所以第 8 行返回的类型也是 never[]。</p>\n<h4 data-nodeid=\"18608\">条件类型中的类型推断 infer</h4>\n<p data-nodeid=\"18609\">另外，我们可以在条件类型中使用类型推断操作符 infer 来获取类型入参的组成部分，比如说获取数组类型入参里元素的类型。</p>\n<p data-nodeid=\"18610\">下面我们来看一个具体的示例：</p>\n<pre class=\"lang-typescript\" data-nodeid=\"18611\"><code data-language=\"typescript\">{\n  <span class=\"hljs-keyword\">type</span> ElementTypeOfArray&lt;T&gt; = T <span class=\"hljs-keyword\">extends</span> (infer E)[] ? E : never;\n  <span class=\"hljs-keyword\">type</span> isNumber = ElementTypeOfArray&lt;<span class=\"hljs-built_in\">number</span>[]&gt;; <span class=\"hljs-comment\">// number</span>\n  <span class=\"hljs-keyword\">type</span> isNever = ElementTypeOfArray&lt;<span class=\"hljs-built_in\">number</span>&gt;; <span class=\"hljs-comment\">// never</span>\n}\n</code></pre>\n<p data-nodeid=\"18612\">在示例中的第 1 行，我们定义了接收入参 T 的泛型 ElementTypeOfArray，并在三元运算的条件判断中，通过 (infer E)[] 定义了一个有对元素类型推断参数 E 的数组。当入参 T 满足是 (infer E)[] 数组类型的子类型的条件，则返回参数 E，即数组元素类型，所以在第 3 行传入 number[] 入参时返回的是 number 类型，而传入 number 时返回的则是 never。</p>\n<p data-nodeid=\"18613\">我们还可以通过 infer 创建任意个类型推断参数，以此获取任意的成员类型，如下示例：</p>\n<pre class=\"lang-typescript\" data-nodeid=\"18614\"><code data-language=\"typescript\">{\n  <span class=\"hljs-keyword\">type</span> ElementTypeOfObj&lt;T&gt; = T <span class=\"hljs-keyword\">extends</span> { name: infer E; id: infer I } ? [E, I] : never;\n  <span class=\"hljs-keyword\">type</span> isArray = ElementTypeOfObj&lt;{ name: <span class=\"hljs-string\">'name'</span>; id: <span class=\"hljs-number\">1</span>; age: <span class=\"hljs-number\">30</span> }&gt;; <span class=\"hljs-comment\">// ['name', 1]</span>\n  <span class=\"hljs-keyword\">type</span> isNever = ElementTypeOfObj&lt;<span class=\"hljs-built_in\">number</span>&gt;; <span class=\"hljs-comment\">// never</span>\n}\n</code></pre>\n<p data-nodeid=\"18615\">在示例中的第 1 行，我们定义了入参是 T 的泛型 ElementTypeOfObj，并通过两个 infer 类型推断来获取入参 name、id 属性的类型。在第 3 行，因为入参是包含 name、id 属性的接口类型，所以提取到了元组类型 ['name', 1]。而在第 4 行，因为入参 number 不满足三元运算中的条件判断，所以返回了 never。</p>\n<h4 data-nodeid=\"18616\">索引访问类型</h4>\n<p data-nodeid=\"18617\">索引访问类型其实更像是获取物料的方式，首先我们可以通过属性名、索引、索引签名按需提取对象（接口类型）任意成员的类型（<strong data-nodeid=\"18811\">注意：只能使用 [索引名] 的语法</strong>），如下示例。</p>\n<pre class=\"lang-typescript\" data-nodeid=\"18618\"><code data-language=\"typescript\">  <span class=\"hljs-keyword\">interface</span> MixedObject {\n    animal: {\n      <span class=\"hljs-keyword\">type</span>: <span class=\"hljs-string\">'animal'</span> | <span class=\"hljs-string\">'dog'</span> | <span class=\"hljs-string\">'cat'</span>;\n      age: <span class=\"hljs-built_in\">number</span>;\n    };\n    [name: <span class=\"hljs-built_in\">number</span>]: {\n      <span class=\"hljs-keyword\">type</span>: <span class=\"hljs-built_in\">string</span>;\n      age: <span class=\"hljs-built_in\">number</span>;\n      nickname: <span class=\"hljs-built_in\">string</span>;\n    };\n    [name: <span class=\"hljs-built_in\">string</span>]: {\n      <span class=\"hljs-keyword\">type</span>: <span class=\"hljs-built_in\">string</span>;\n      age: <span class=\"hljs-built_in\">number</span>;\n    };\n  }\n  <span class=\"hljs-keyword\">type</span> animal = MixedObject[<span class=\"hljs-string\">'animal'</span>];\n  <span class=\"hljs-keyword\">type</span> animalType = MixedObject[<span class=\"hljs-string\">'animal'</span>][<span class=\"hljs-string\">'type'</span>];\n  <span class=\"hljs-keyword\">type</span> numberIndex = MixedObject[<span class=\"hljs-built_in\">number</span>];\n  <span class=\"hljs-keyword\">type</span> numberIndex0 = MixedObject[<span class=\"hljs-number\">0</span>];\n  <span class=\"hljs-keyword\">type</span> stringIndex = MixedObject[<span class=\"hljs-built_in\">string</span>];\n  <span class=\"hljs-keyword\">type</span> stringIndex0 = MixedObject[<span class=\"hljs-string\">'string'</span>];\n</code></pre>\n<p data-nodeid=\"18619\">在示例的第 16 行，我们通过 'animal' 索引获取了 MixedObject 接口的 animal 属性的类型。在第 17 行，我们通过多级属性索引获取了更深层级 type 属性的类型。</p>\n<p data-nodeid=\"18620\">然后，在第 18 行、第 19 行，我们通过 number 类型索引签名和数字索引 0 获取了第 6~10 行定义的同一个接口类型。</p>\n<p data-nodeid=\"18621\">最后，在第 20 行、第 21 行，我们通过 string 类型索引签名和字符串字面量索引 'string' 获取了第 11~14 行定义的同一个接口类型（回顾 7 讲）。</p>\n<h4 data-nodeid=\"18622\">keyof</h4>\n<p data-nodeid=\"18623\">其次，我们还可以使用 keyof 关键字提取对象属性名、索引名、索引签名的类型，如下示例：</p>\n<pre class=\"lang-typescript\" data-nodeid=\"18624\"><code data-language=\"typescript\">  <span class=\"hljs-keyword\">type</span> MixedObjectKeys = keyof MixedObject; <span class=\"hljs-comment\">// string | number</span>\n  <span class=\"hljs-keyword\">type</span> animalKeys = keyof animal; <span class=\"hljs-comment\">// 'type' | 'age'</span>\n  <span class=\"hljs-keyword\">type</span> numberIndexKeys = keyof numberIndex; <span class=\"hljs-comment\">// \"type\" | \"age\" | \"nickname\"</span>\n</code></pre>\n<p data-nodeid=\"18625\">在示例中的第 1 行，我们使用 keyof 提取了 MixedObject 接口的属性和索引签名，它是由 string、number 和 'animal' 类型组成的联合类型，缩减之后就是 string | number 联合类型。在第 2 行，我们提取了 'type' 和 'age' 字符串字面量类型组成的联合类型。在第 3 行，我们提取了 'type'、'age' 和 'nickname' 组成的联合类型。</p>\n<h4 data-nodeid=\"18626\">typeof</h4>\n<p data-nodeid=\"18627\">最后介绍的操作符物料是 typeof。</p>\n<p data-nodeid=\"18628\">如果我们在表达式上下文中使用 typeof，则是用来获取表达式值的类型，如果在类型上下文中使用，则是用来获取变量或者属性的类型。当然，在 TypeScript 中，typeof 的主要用途是在类型上下文中获取变量或者属性的类型，下面我们通过一个具体示例来理解一下。</p>\n<pre class=\"lang-typescript\" data-nodeid=\"18629\"><code data-language=\"typescript\">{\n  <span class=\"hljs-keyword\">let</span> StrA = <span class=\"hljs-string\">'a'</span>;\n  <span class=\"hljs-keyword\">const</span> unions = <span class=\"hljs-keyword\">typeof</span> StrA; <span class=\"hljs-comment\">// unions 类型是 \"string\" | \"number\" | \"bigint\" | \"boolean\" | \"symbol\" | \"undefined\" | \"object\" | \"function\"</span>\n  <span class=\"hljs-keyword\">const</span> str: <span class=\"hljs-keyword\">typeof</span> StrA = <span class=\"hljs-string\">'string'</span>; <span class=\"hljs-comment\">// strs 类型是 string</span>\n  <span class=\"hljs-keyword\">type</span> DerivedFromStrA = <span class=\"hljs-keyword\">typeof</span> StrA; <span class=\"hljs-comment\">// string</span>\n}\n</code></pre>\n<p data-nodeid=\"18630\">在示例中的第 3 行，typeof 作用在表达式上下文中，获取的是 StrA 值的类型，因为与静态类型上下文无关，所以变量 unions 的类型是 'string'、'number' 等字符串字面量组成的联合类型。</p>\n<p data-nodeid=\"18631\">而在第 4 行，typeof 作用在类型上下文中，提取的是变量 StrA 的类型，因为第 1 行推断出来 StrA 的类型是 string，所以提取的类型、变量 str 的类型也是 string。</p>\n<p data-nodeid=\"18632\">当然，我们也可以使用一个类型别名专门接收从变量 StrA 提取的类型，比如示例中的第 5 行，类型别名 DerivedFromStrA 的类型是 string。</p>\n<p data-nodeid=\"18633\">对于任何未显式添加类型注解或值与类型注解一体（比如函数、类）的变量或属性，我们都可以使用 typeof 提取它们的类型，这是一个十分方便、有用的设计，如下示例：</p>\n<pre class=\"lang-typescript\" data-nodeid=\"18634\"><code data-language=\"typescript\">  <span class=\"hljs-keyword\">const</span> animal = {\n    id: <span class=\"hljs-number\">1</span>,\n    name: <span class=\"hljs-string\">'animal'</span>\n  };\n  <span class=\"hljs-keyword\">type</span> Animal = <span class=\"hljs-keyword\">typeof</span> animal;\n  <span class=\"hljs-keyword\">const</span> animalFun = <span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> animal;\n  <span class=\"hljs-keyword\">type</span> AnimalFun = <span class=\"hljs-keyword\">typeof</span> animalFun;\n</code></pre>\n<p data-nodeid=\"18635\">在示例中的第 5 行、第 7 行，我们使用 typeof 提取了对象 animal 和函数 animaFun 的类型。</p>\n<h4 data-nodeid=\"18636\">映射类型</h4>\n<p data-nodeid=\"18637\">我们可以使用索引签名语法和 in 关键字限定对象属性的范围，如下示例：</p>\n<pre class=\"lang-typescript\" data-nodeid=\"18638\"><code data-language=\"typescript\">  <span class=\"hljs-keyword\">type</span> SpecifiedKeys = <span class=\"hljs-string\">'id'</span> | <span class=\"hljs-string\">'name'</span>;\n  <span class=\"hljs-keyword\">type</span> TargetType = {\n    [key <span class=\"hljs-keyword\">in</span> SpecifiedKeys]: <span class=\"hljs-built_in\">any</span>;\n  };&nbsp;<span class=\"hljs-comment\">// { id: any; name: any; }</span>\n  <span class=\"hljs-keyword\">type</span> TargetGeneric&lt;O <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-built_in\">string</span> | <span class=\"hljs-built_in\">number</span> | symbol&gt; = {\n    [key <span class=\"hljs-keyword\">in</span> O]: <span class=\"hljs-built_in\">any</span>;\n  }\n  <span class=\"hljs-keyword\">type</span> TargetInstance = TargetGeneric&lt;SpecifiedKeys&gt;; <span class=\"hljs-comment\">// { id: any; name: any; }</span>\n</code></pre>\n<p data-nodeid=\"18639\">在示例中的第 1 行，我们定义了联合类型 SpecifiedKeys，并在第 3 行、第 6 行使用 in 限定了 AnimalNormal 对象和泛型 AnimalGeneric 的属性必须是 SpecifiedKeys 的成员，所以最终第 2 行、第 8 行得到的类型都是 { id: any; name: any; }。</p>\n<p data-nodeid=\"18640\"><strong data-nodeid=\"18877\">注意：我们只能在类型别名定义中使用 in，如果在接口中使用，则会提示一个 ts(1169) 的错误</strong>，如下示例第 2 行所示。</p>\n<pre class=\"lang-typescript\" data-nodeid=\"18641\"><code data-language=\"typescript\">  <span class=\"hljs-keyword\">interface</span> ITargetInterface {\n    [key <span class=\"hljs-keyword\">in</span> SpecifiedKeys]: <span class=\"hljs-built_in\">any</span>; <span class=\"hljs-comment\">// ts(1169)</span>\n  }\n</code></pre>\n<p data-nodeid=\"18642\">在定义类型时，我们可以组合使用 in 和 keyof，并基于已有的类型创建一个新类型，使得新类型与已有类型保持一致的只读、可选特性，这样的泛型被称之为映射类型。</p>\n<blockquote data-nodeid=\"18643\">\n<p data-nodeid=\"18644\"><strong data-nodeid=\"18882\">注意：in 和 keyof 也只能在类型别名定义中组合使用。</strong></p>\n</blockquote>\n<p data-nodeid=\"18645\">下面我们看一个具体的示例：</p>\n<pre class=\"lang-typescript\" data-nodeid=\"18646\"><code data-language=\"typescript\">  <span class=\"hljs-keyword\">interface</span> SourceInterface {\n    readonly id: <span class=\"hljs-built_in\">number</span>;\n    name?: <span class=\"hljs-built_in\">string</span>;\n  }\n  <span class=\"hljs-keyword\">type</span> TargetType = {\n    [key <span class=\"hljs-keyword\">in</span> keyof SourceInterface]: SourceInterface[key];\n  }; <span class=\"hljs-comment\">// { readonly id: number; name?: string | undefined }</span>\n  <span class=\"hljs-keyword\">type</span> TargetGenericType&lt;S&gt; = {\n    [key <span class=\"hljs-keyword\">in</span> keyof S]: S[key];\n  };\n  <span class=\"hljs-keyword\">type</span> TargetInstance = TargetGenericType&lt;SourceInterface&gt;; <span class=\"hljs-comment\">// { readonly id: number; name?: string | undefined }</span>\n</code></pre>\n<p data-nodeid=\"18647\">在示例中的第 6 行、第 9 行，我们使用 in 和 keyof，以及基于接口类型 SourceInterface 和泛型入参 S 分别创建了一个新类型，最终第 5 行的 TargetType、第 11 行的TargetInstance 也获得了只读的 id 属性和可选的 name 属性。</p>\n<p data-nodeid=\"18648\">同样，我们可以在映射类型中使用 readonly、? 修饰符来描述属性的可读性、可选性，也可以在修饰符前添加 +、- 前缀表示添加、移除指定修饰符（默认是 +、添加），如下示例：</p>\n<pre class=\"lang-typescript\" data-nodeid=\"18649\"><code data-language=\"typescript\">  <span class=\"hljs-keyword\">type</span> TargetGenericTypeReadonly&lt;S&gt; = {\n    readonly [key <span class=\"hljs-keyword\">in</span> keyof S]: S[key];\n  }\n  <span class=\"hljs-keyword\">type</span> TargetGenericTypeReadonlyInstance = TargetGenericTypeReadonly&lt;SourceInterface&gt;; <span class=\"hljs-comment\">// { readonly id: number; readonly name?: string | undefined }</span>\n  <span class=\"hljs-keyword\">type</span> TargetGenericTypeOptional&lt;S&gt; = {\n    [key <span class=\"hljs-keyword\">in</span> keyof S]?: S[key];\n  }\n  <span class=\"hljs-keyword\">type</span> TargetGenericTypeOptionalInstance = TargetGenericTypeOptional&lt;SourceInterface&gt;; <span class=\"hljs-comment\">// { readonly id?: number; readonly name?: string | undefined }</span>\n  <span class=\"hljs-keyword\">type</span> TargetGenericTypeRemoveReadonly&lt;S&gt; = {\n    -readonly [key <span class=\"hljs-keyword\">in</span> keyof S]: S[key];\n  }\n  <span class=\"hljs-keyword\">type</span> TargetGenericTypeRemoveReadonlyInstance = TargetGenericTypeRemoveReadonly&lt;SourceInterface&gt;; <span class=\"hljs-comment\">// { id: number; name?: string | undefined }</span>\n  <span class=\"hljs-keyword\">type</span> TargetGenericTypeRemoveOptional&lt;S&gt; = {\n    [key <span class=\"hljs-keyword\">in</span> keyof S]-?: S[key];\n  }\n  <span class=\"hljs-keyword\">type</span> TargetGenericTypeRemoveOptionalInstance = TargetGenericTypeRemoveOptional&lt;SourceInterface&gt;; <span class=\"hljs-comment\">// { readonly id: number; name: string }</span>\n</code></pre>\n<p data-nodeid=\"18650\">在示例中的第 1~3 行，我们给所有属性添加了 readonly 修饰符，所以第 4 行得到的类型是 { readonly id: number; readonly name?: string | undefined }。</p>\n<p data-nodeid=\"18651\">在第 5~7 行，我们给所有属性添加了 ? 可选修饰符，所以第 8 行得到的类型是 { readonly id?: number; readonly name?: string | undefined }。</p>\n<p data-nodeid=\"18652\">在第 9~11 行，我们通过 -readonly 移除了只读修饰符，所以第 12 行得到的类型是 { id: number; name?: string | undefined }。</p>\n<p data-nodeid=\"18653\">在第 13~15 行，我们通过 -? 移除了可选修饰符，所以第 16 行得到的类型是 { readonly id: number; name: string }。</p>\n<p data-nodeid=\"18654\"><strong data-nodeid=\"18901\">使用 as 重新映射 key</strong></p>\n<p data-nodeid=\"18655\">穿越一下，<strong data-nodeid=\"18907\">自 TypeScript 4.1 起，我们可以在映射类型的索引签名中使用类型断言</strong>，如下示例（TypeScript 4.1 以下则会提示错误）：</p>\n<pre class=\"lang-typescript\" data-nodeid=\"18656\"><code data-language=\"typescript\">  <span class=\"hljs-keyword\">type</span> TargetGenericTypeAssertiony&lt;S&gt; = {\n    [key <span class=\"hljs-keyword\">in</span> keyof S <span class=\"hljs-keyword\">as</span> Exclude&lt;key, <span class=\"hljs-string\">'id'</span>&gt;]: S[key];\n  }\n  <span class=\"hljs-keyword\">type</span> TargetGenericTypeAssertionyInstance = TargetGenericTypeAssertiony&lt;SourceInterface&gt;; <span class=\"hljs-comment\">// { name?: string | undefined; }</span>\n</code></pre>\n<p data-nodeid=\"18657\">在示例中的第 2 行，我们将 key 断言为排除 'id' 以外的联合类型，所以第 4 行实例得到的类型是 { name?: string | undefined; }。</p>\n<p data-nodeid=\"18658\">以上就是自定义工具类型所需要的物料。将物料与官方内置工具类型结合起来，我们就可以愉快地造轮子了。</p>\n<h3 data-nodeid=\"18659\">造轮子</h3>\n<p data-nodeid=\"18660\">其实，在前面的示例中，我们已经实现了例如 isAssertable、isSubTyping 等自定义工具类型，接下来再介绍几个第三方自定义工具和类型的实现。</p>\n<h4 data-nodeid=\"18661\">Exclude</h4>\n<p data-nodeid=\"18662\">我们再来复习一下 14 讲中介绍的官方自带工具类型 Exclude&lt;T, U&gt;，它用来排除入参 T 内是入参 U 子类型的成员类型，如下示例：</p>\n<pre class=\"lang-typescript\" data-nodeid=\"18663\"><code data-language=\"typescript\">  <span class=\"hljs-keyword\">type</span> ExcludeSpecifiedNumber = Exclude&lt;<span class=\"hljs-number\">1</span> | <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">1</span>&gt;; <span class=\"hljs-comment\">// 2</span>\n  <span class=\"hljs-keyword\">type</span> ExcludeSpecifiedString = Exclude&lt;<span class=\"hljs-string\">'id'</span> | <span class=\"hljs-string\">'name'</span>, <span class=\"hljs-string\">'id'</span>&gt;; <span class=\"hljs-comment\">// 'name</span>\n  <span class=\"hljs-keyword\">type</span> ExcludeSpecifiedBoolean = Exclude&lt;<span class=\"hljs-built_in\">boolean</span>, <span class=\"hljs-literal\">true</span>&gt;; <span class=\"hljs-comment\">// false</span>\n</code></pre>\n<p data-nodeid=\"18664\">在示例中的第 1~3 行，排除指定成员类型 1、'id'、true 之后得到的类型是 2、'name'、false。</p>\n<p data-nodeid=\"18665\">我们可以在 VS Code 中使用快捷键 Ctrl/Command + 点击 Exclude 查看它在 node_modules/typescript/lib/lib.es5.d.ts 中的定义，代码实现如下：</p>\n<pre class=\"lang-typescript\" data-nodeid=\"18666\"><code data-language=\"typescript\"><span class=\"hljs-keyword\">type</span> Exclude&lt;T, U&gt; = T <span class=\"hljs-keyword\">extends</span> U ? never : T;\n</code></pre>\n<p data-nodeid=\"18667\">这里明显利用了分配条件类型的特性，所以入参 T 会被拆解为成员类型。如果成员类型是入参 U 的子类型，则返回 never，否则返回成员类型。</p>\n<p data-nodeid=\"18668\">当入参分别是联合类型 1 | 2 与字面量类型 1，因为联合类型被拆解后的成员 1 是 1 的子类型，而成员 2 不是 1 的子类型，所以返回的是联合类型 never | 2。由于 never 是 2 的子类型，最终类型缩减后得到的就是 2。</p>\n<p data-nodeid=\"18669\">接下来我们开始介绍一个自定义工具类型 ReturnTypeOfResolved<f>。</f></p>\n<h4 data-nodeid=\"18670\">ReturnTypeOfResolved</h4>\n<p data-nodeid=\"18671\">ReturnTypeOfResolved 和官方 ReturnType 的区别：如果入参 F 的返回类型是泛型 Promise 的实例，则返回 Promise 接收的入参。</p>\n<p data-nodeid=\"18672\">我们可以借鉴 ReturnType 的定义实现 ReturnTypeOfResolved<f>，如下示例：</f></p>\n<pre class=\"lang-typescript\" data-nodeid=\"18673\"><code data-language=\"typescript\">  <span class=\"hljs-comment\">// type ReturnType&lt;T extends (...args: any) =&gt; any&gt; = T extends (...args: any) =&gt; infer R ? R : any;</span>\n  <span class=\"hljs-keyword\">type</span> ReturnTypeOfResolved&lt;F <span class=\"hljs-keyword\">extends</span> (...args: <span class=\"hljs-built_in\">any</span>) =&gt; <span class=\"hljs-built_in\">any</span>&gt; = F <span class=\"hljs-keyword\">extends</span> (...args: <span class=\"hljs-built_in\">any</span>[]) =&gt; <span class=\"hljs-built_in\">Promise</span>&lt;infer R&gt; ? R : ReturnType&lt;F&gt;;\n  <span class=\"hljs-keyword\">type</span> isNumber = ReturnTypeOfResolved&lt;<span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> <span class=\"hljs-built_in\">number</span>&gt;; <span class=\"hljs-comment\">// number</span>\n  <span class=\"hljs-keyword\">type</span> isString = ReturnTypeOfResolved&lt;<span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> <span class=\"hljs-built_in\">Promise</span>&lt;<span class=\"hljs-built_in\">string</span>&gt;&gt;; <span class=\"hljs-comment\">// string</span>\n</code></pre>\n<p data-nodeid=\"18674\">示例中第 1 行注释的代码是官方工具类型 ReturnType 的实现，第 2 行我们自定义了一个泛型 ReturnTypeOfResolved，并约束了入参 F 必须是函数类型。当入参 F 的返回值是 Promise 类型，通过条件类型，我们推断 infer 获取了 Promise 入参类型，所以第 3 行返回的是入参函数返回值类型 number，第 4 行返回的是入参函数返回 Promise 入参类型 string。</p>\n<h4 data-nodeid=\"18675\">Merge</h4>\n<p data-nodeid=\"18676\">接下来我们再基于映射类型将类型入参 A 和 B 合并为一个类型的泛型 Merge&lt;A, B&gt;，如下示例：</p>\n<pre class=\"lang-typescript\" data-nodeid=\"18677\"><code data-language=\"typescript\">  <span class=\"hljs-keyword\">type</span> Merge&lt;A, B&gt; = {\n    [key <span class=\"hljs-keyword\">in</span> keyof A | keyof B]: key <span class=\"hljs-keyword\">extends</span> keyof A\n      ? key <span class=\"hljs-keyword\">extends</span> keyof B\n        ? A[key] | B[key]\n        : A[key]\n      : key <span class=\"hljs-keyword\">extends</span> keyof B\n      ? B[key]\n      : never;\n  };\n  <span class=\"hljs-keyword\">type</span> Merged = Merge&lt;{ id: <span class=\"hljs-built_in\">number</span>; name: <span class=\"hljs-built_in\">string</span> }, { id: <span class=\"hljs-built_in\">string</span>; age: <span class=\"hljs-built_in\">number</span> }&gt;;\n</code></pre>\n<p data-nodeid=\"18678\">在第 2 行，我们限定了返回类型属性 key 为入参 A、B 属性的联合类型。当 key 为 A、B 的同名属性，合并后的属性类型为联合类型 A[key] | B[key]（第 2~4 行）；当 key 为 A 或者 B 的属性，合并后的属性类型为 A[key] 或者 B[key]（第 5~7 行）。</p>\n<p data-nodeid=\"18679\">最后，我们在第 10 行使用了 Merge 合并两个接口类型，从而得到了 { id: number | string; name: string; age: number }。</p>\n<h4 data-nodeid=\"18680\">Equal</h4>\n<p data-nodeid=\"18681\">我们再来实现一个自定义工具类型 Equal&lt;S, T&gt;，它可以用来判断入参 S 和 T 是否是相同的类型。如果相同，则返回布尔字面量类型 true，否则返回 false。</p>\n<p data-nodeid=\"18682\">此时，我们很容易想到，如果 S 是 T 的子类型且 T 也是 S 的子类型，则说明 S 和 T 是相同的类型，所以 Equal 的实现似乎是这样的：</p>\n<pre class=\"lang-typescript\" data-nodeid=\"18683\"><code data-language=\"typescript\"><span class=\"hljs-keyword\">type</span> EqualV1&lt;S, T&gt; = S <span class=\"hljs-keyword\">extends</span> T ? T <span class=\"hljs-keyword\">extends</span> S ? <span class=\"hljs-literal\">true</span> : <span class=\"hljs-literal\">false</span> : <span class=\"hljs-literal\">false</span>;\n<span class=\"hljs-keyword\">type</span> ExampleV11 = EqualV1&lt;<span class=\"hljs-number\">1</span> | <span class=\"hljs-built_in\">number</span> &amp; {}, <span class=\"hljs-built_in\">number</span>&gt;; <span class=\"hljs-comment\">// true but boolean</span>\n<span class=\"hljs-keyword\">type</span> ExampleV12 = EqualV1&lt;never, never&gt;; <span class=\"hljs-comment\">// true but never</span>\n</code></pre>\n<p data-nodeid=\"18684\">在示例中的第 1 行，我们实现了泛型 EqualV1；第 2 行中的第一个入参是联合类型，因为分配条件类型的设定，所以第一个类型入参被拆解，最终返回类型 boolean（实际上是联合类型 true | false）。同样，在第 3 行中，当入参是 never，则返回类型 never。因此，EqualV1 并不符合我们的预期。</p>\n<p data-nodeid=\"18685\">**此时，我们需要使用 [] 解除条件分配类型和 never “陷阱”，**确保自定义泛型仅返回 true 或者 false，所以前面示例的改良版本 EqualV2 如下：</p>\n<pre class=\"lang-typescript\" data-nodeid=\"18686\"><code data-language=\"typescript\">  <span class=\"hljs-keyword\">type</span> EqualV2&lt;S, T&gt; = [S] <span class=\"hljs-keyword\">extends</span> [T] ? [T] <span class=\"hljs-keyword\">extends</span> [S] ? <span class=\"hljs-literal\">true</span> : <span class=\"hljs-literal\">false</span> : <span class=\"hljs-literal\">false</span>;\n  <span class=\"hljs-keyword\">type</span> ExampleV21 = EqualV2&lt;<span class=\"hljs-number\">1</span> | <span class=\"hljs-built_in\">number</span> &amp; {}, <span class=\"hljs-built_in\">number</span>&gt;; <span class=\"hljs-comment\">// true</span>\n  <span class=\"hljs-keyword\">type</span> ExampleV22 = EqualV2&lt;never, never&gt;; <span class=\"hljs-comment\">// true</span>\n  <span class=\"hljs-keyword\">type</span> ExampleV23 = EqualV2&lt;<span class=\"hljs-built_in\">any</span>, <span class=\"hljs-built_in\">number</span>&gt;; <span class=\"hljs-comment\">// false but true</span>\n</code></pre>\n<p data-nodeid=\"18687\">在示例中的第 2 行、第 3 行，虽然我们解决了联合类型和 never 的问题，但是还是无法区分万金油类型 any 和其他类型。在第 4 行，当入参是 any 和 number，预期应该返回 false，却返回了 true。</p>\n<p data-nodeid=\"18688\">这时，我们还需要使用一个可以能识别 any 的改良版 EqualV3 如下：</p>\n<pre class=\"lang-typescript\" data-nodeid=\"18689\"><code data-language=\"typescript\">  <span class=\"hljs-keyword\">type</span> IsAny&lt;T&gt; = <span class=\"hljs-number\">0</span> <span class=\"hljs-keyword\">extends</span> (<span class=\"hljs-number\">1</span> &amp; T) ? <span class=\"hljs-literal\">true</span> : <span class=\"hljs-literal\">false</span>;\n  <span class=\"hljs-keyword\">type</span> EqualV3&lt;S, T&gt; = IsAny&lt;S&gt; <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-literal\">true</span>\n    ? IsAny&lt;T&gt; <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-literal\">true</span>\n      ? <span class=\"hljs-literal\">true</span>\n      : <span class=\"hljs-literal\">false</span>\n    : IsAny&lt;T&gt; <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-literal\">true</span>\n    ? <span class=\"hljs-literal\">false</span>\n    : [S] <span class=\"hljs-keyword\">extends</span> [T]\n    ? [T] <span class=\"hljs-keyword\">extends</span> [S]\n      ? <span class=\"hljs-literal\">true</span>\n      : <span class=\"hljs-literal\">false</span>\n    : <span class=\"hljs-literal\">false</span>;\n  <span class=\"hljs-keyword\">type</span> ExampleV31 = EqualV3&lt;<span class=\"hljs-number\">1</span> | <span class=\"hljs-built_in\">number</span> &amp; {}, <span class=\"hljs-built_in\">number</span>&gt;; <span class=\"hljs-comment\">// true but false got</span>\n  <span class=\"hljs-keyword\">type</span> ExampleV32 = EqualV3&lt;never, never&gt;; <span class=\"hljs-comment\">// true</span>\n  <span class=\"hljs-keyword\">type</span> ExampleV34 = EqualV3&lt;<span class=\"hljs-built_in\">any</span>, <span class=\"hljs-built_in\">any</span>&gt;; <span class=\"hljs-comment\">// true</span>\n  <span class=\"hljs-keyword\">type</span> ExampleV33 = EqualV3&lt;<span class=\"hljs-built_in\">any</span>, <span class=\"hljs-built_in\">number</span>&gt;; <span class=\"hljs-comment\">// false</span>\n  <span class=\"hljs-keyword\">type</span> ExampleV35 = EqualV3&lt;never, <span class=\"hljs-built_in\">any</span>&gt;; <span class=\"hljs-comment\">// false </span>\n</code></pre>\n<p data-nodeid=\"18690\">在示例中的第 1 行，我们定义了可以区分 any 和其他类型的泛型 IsAny，<strong data-nodeid=\"18991\">因为只有 any 和 1 交叉得到的类型（any）是 0 的父类型，所以如果入参是 any 则会返回 true，否则返回 false</strong>。</p>\n<p data-nodeid=\"18691\">在第 2~7 行，我们定义了 EqualV3（首先特殊处理了类型入参 S 和 T 至少有一个是 any 的情况），当 S 和 T 都是 any 才返回 true，否则返回 false。因此，在第 15~17 行，EqualV3 是可以区分 any 和其他类型的。</p>\n<p data-nodeid=\"18692\">在第 8 ~12 行，我们复用了 EqualV2 的逻辑，并通过 [] 解除了条件分配类型，所以第 13~14 行 EqualV3 可以判断出联合类型 1 | number &amp; {} 和 number、never 和 never 是相同的类型。</p>\n<p data-nodeid=\"18693\">至此，我们造的第一个轮子 Equal（实际上，用来区分 any 类型的泛型 IsAny 也可以算一个轮子）基本可以正确地区分大多数类型了。</p>\n<blockquote data-nodeid=\"18694\">\n<p data-nodeid=\"18695\">插播一道思考题：尝试找一个 ExampleV3 不能正确分区类型的反例，并改良 ExampleV3。</p>\n</blockquote>\n<h3 data-nodeid=\"18696\">小结与预告</h3>\n<p data-nodeid=\"18697\">这一讲我们介绍了很多的知识点和特性，在学习时，你可以结合以上知识点、特性、工具类型，以及官方工具类型源码实现剖析。只有这样，我们才能构造出较为复杂的工具类型。</p>\n<p data-nodeid=\"18698\">这里插播一道思考题：什么是分配条件类型？欢迎你在留言区进行互动、交流。</p>\n<p data-nodeid=\"18699\">从 16 讲开始，我们将学习本课程的第三部分 TypeScript 实践的经验和建议，敬请期待。</p>\n<p data-nodeid=\"18700\">最后，如果你觉得本专栏有价值，欢迎分享给更多好友哦~</p>",
                "article_title": "15 | 类型编程：如何打造属于自己的工具类型？",
                "title": "15 | 类型编程：如何打造属于自己的工具类型？",
                "id": 7447
            }
        ]
    },
    {
        "chapterTitle": "模块三：实战指南",
        "children": [
            {
                "content": "<p data-nodeid=\"15965\">tsconfig.json 是 TypeScript 项目的配置文件。如果一个目录下存在一个 tsconfig.json 文件，那么往往意味着这个目录就是 TypeScript 项目的根目录。</p>\n<p data-nodeid=\"15966\">tsconfig.json 包含 TypeScript 编译的相关配置，通过更改编译配置项，我们可以让 TypeScript 编译出 ES6、ES5、node 的代码。</p>\n<p data-nodeid=\"15967\">这一讲我们将分别介绍 tsconfig.json 中的相关配置选项，并对比较重要的编译选项进行着重介绍。</p>\n<h3 data-nodeid=\"15968\">compilerOptions</h3>\n<p data-nodeid=\"15969\">编译选项是 TypeScript 配置的核心部分，compilerOptions 内的配置根据功能可以分为 6 个部分，接下来我们分别介绍一下。</p>\n<h4 data-nodeid=\"15970\">项目选项</h4>\n<p data-nodeid=\"15971\">这些选项用于配置项目的运行时期望、转译 JavaScript 的输出方式和位置，以及与现有 JavaScript 代码的集成级别。</p>\n<p data-nodeid=\"15972\"><strong data-nodeid=\"16128\">target</strong></p>\n<p data-nodeid=\"15973\">target 选项用来指定 TypeScript 编译代码的目标，不同的目标将影响代码中使用的特性是否会被降级。</p>\n<p data-nodeid=\"15974\">target 的可选值包括<code data-backticks=\"1\" data-nodeid=\"16131\">ES3</code>、<code data-backticks=\"1\" data-nodeid=\"16133\">ES5</code>、<code data-backticks=\"1\" data-nodeid=\"16135\">ES6</code>、<code data-backticks=\"1\" data-nodeid=\"16137\">ES7</code>、<code data-backticks=\"1\" data-nodeid=\"16139\">ES2017</code>、<code data-backticks=\"1\" data-nodeid=\"16141\">ES2018</code>、<code data-backticks=\"1\" data-nodeid=\"16143\">ES2019</code>、<code data-backticks=\"1\" data-nodeid=\"16145\">ES2020</code>、<code data-backticks=\"1\" data-nodeid=\"16147\">ESNext</code>这几种。</p>\n<p data-nodeid=\"15975\">一般情况下，target 的默认值为<code data-backticks=\"1\" data-nodeid=\"16150\">ES3</code>，如果不配置选项的话，代码中使用的<code data-backticks=\"1\" data-nodeid=\"16152\">ES6</code>特性，比如箭头函数会被转换成等价的函数表达式。</p>\n<p data-nodeid=\"15976\"><strong data-nodeid=\"16157\">module</strong></p>\n<p data-nodeid=\"15977\">module 选项可以用来设置 TypeScript 代码所使用的模块系统。</p>\n<p data-nodeid=\"15978\">如果 target 的值设置为 ES3、ES5 ，那么 module 的默认值则为 CommonJS；如果 target 的值为 ES6 或者更高，那么 module 的默认值则为 ES6。</p>\n<p data-nodeid=\"15979\">另外，module 还支持 ES2020、UMD、AMD、System、ESNext、None 的选项。</p>\n<p data-nodeid=\"15980\"><strong data-nodeid=\"16164\">jsx</strong></p>\n<p data-nodeid=\"15981\">jsx 选项用来控制 jsx 文件转译成 JavaScript 的输出方式。该选项只影响<code data-backticks=\"1\" data-nodeid=\"16166\">.tsx</code>文件的 JS 文件输出，并且没有默认值选项。</p>\n<ul data-nodeid=\"15982\">\n<li data-nodeid=\"15983\">\n<p data-nodeid=\"15984\">react: 将 jsx 改为等价的对 React.createElement 的调用，并生成 .js 文件。</p>\n</li>\n<li data-nodeid=\"15985\">\n<p data-nodeid=\"15986\">react-jsx: 改为 __jsx 调用，并生成 .js 文件。</p>\n</li>\n<li data-nodeid=\"15987\">\n<p data-nodeid=\"15988\">react-jsxdev: 改为 __jsx 调用，并生成 .js 文件。</p>\n</li>\n<li data-nodeid=\"15989\">\n<p data-nodeid=\"15990\">preserve: 不对 jsx 进行改变，并生成 .jsx 文件。</p>\n</li>\n<li data-nodeid=\"15991\">\n<p data-nodeid=\"15992\">react-native: 不对 jsx 进行改变，并生成 .js 文件。</p>\n</li>\n</ul>\n<p data-nodeid=\"15993\"><strong data-nodeid=\"16180\">incremental</strong></p>\n<p data-nodeid=\"15994\">incremental 选项用来表示是否启动增量编译。incremental 为<code data-backticks=\"1\" data-nodeid=\"16182\">true</code>时，则会将上次编译的工程图信息保存到磁盘上的文件中。</p>\n<p data-nodeid=\"15995\"><strong data-nodeid=\"16187\">declaration</strong></p>\n<p data-nodeid=\"15996\">declaration 选项用来表示是否为项目中的 TypeScript 或 JavaScript 文件生成 .d.ts 文件，这些 .d.ts 文件描述了模块导出的 API 类型。</p>\n<p data-nodeid=\"15997\">具体的行为你可以在<a href=\"http://www.typescriptlang.org/play\" data-nodeid=\"16192\">Playground</a>中编写代码，并在右侧的 .D.TS 观察输出。</p>\n<p data-nodeid=\"15998\"><strong data-nodeid=\"16197\">sourceMap</strong></p>\n<p data-nodeid=\"15999\">sourceMap 选项用来表示是否生成<a href=\"https://developer.mozilla.org/docs/Tools/Debugger/How_to/Use_a_source_map\" data-nodeid=\"16201\">sourcemap 文件</a>，这些文件允许调试器和其他工具在使用实际生成的 JavaScript 文件时，显示原始的 TypeScript 代码。</p>\n<p data-nodeid=\"16000\">Source map 文件以 .js.map （或 .jsx.map）文件的形式被生成到与 .js 文件相对应的同一个目录下。</p>\n<p data-nodeid=\"16001\"><strong data-nodeid=\"16207\">lib</strong></p>\n<p data-nodeid=\"16002\">在 13 讲中我们介绍过，安装 TypeScript 时会顺带安装一个 lib.d.ts 声明文件，并且默认包含了 ES5、DOM、WebWorker、ScriptHost 的库定义。</p>\n<p data-nodeid=\"16003\">lib 配置项允许我们更细粒度地控制代码运行时的库定义文件，比如说 Node.js 程序，由于并不依赖浏览器环境，因此不需要包含 DOM 类型定义；而如果需要使用一些最新的、高级 ES 特性，则需要包含 ESNext  类型。</p>\n<p data-nodeid=\"16004\">具体的详情你可以在<a href=\"https://github.com/microsoft/TypeScript/tree/master/lib\" data-nodeid=\"16213\">TypeScript 源码</a>中查看完整的列表，并且自定义编译需要的<code data-backticks=\"1\" data-nodeid=\"16215\">lib</code>类型定义。</p>\n<h4 data-nodeid=\"16005\">严格模式</h4>\n<p data-nodeid=\"16006\">TypeScript 兼容 JavaScript 的代码，默认选项允许相当大的灵活性来适应这些模式。</p>\n<p data-nodeid=\"16007\">在迁移 JavaScript 代码时，你可以先暂时关闭一些严格模式的设置。在正式的 TypeScript 项目中，我推荐开启 strict 设置启用更严格的类型检查，以减少错误的发生。</p>\n<p data-nodeid=\"16008\"><strong data-nodeid=\"16223\">strict</strong></p>\n<p data-nodeid=\"16009\">开启 strict 选项时，一般我们会同时开启一系列的类型检查选项，以便更好地保证程序的正确性。</p>\n<p data-nodeid=\"16010\">strict 为 true 时，一般我们会开启以下编译配置。</p>\n<ul data-nodeid=\"16011\">\n<li data-nodeid=\"16012\">\n<p data-nodeid=\"16013\">alwaysStrict：保证编译出的文件是 ECMAScript 的严格模式，并且每个文件的头部会添加 'use strict'。</p>\n</li>\n<li data-nodeid=\"16014\">\n<p data-nodeid=\"16015\">strictNullChecks：更严格地检查 null 和 undefined 类型，比如数组的 find 方法的返回类型将是更严格的 T | undefined。</p>\n</li>\n<li data-nodeid=\"16016\">\n<p data-nodeid=\"16017\">strictBindCallApply：更严格地检查 call、bind、apply 函数的调用，比如会检查参数的类型与函数类型是否一致。</p>\n</li>\n<li data-nodeid=\"16018\">\n<p data-nodeid=\"16019\">strictFunctionTypes：更严格地检查函数参数类型和类型兼容性。</p>\n</li>\n<li data-nodeid=\"16020\">\n<p data-nodeid=\"16021\">strictPropertyInitialization：更严格地检查类属性初始化，如果类的属性没有初始化，则会提示错误。</p>\n</li>\n<li data-nodeid=\"16022\">\n<p data-nodeid=\"16023\">noImplicitAny：禁止隐式 any 类型，需要显式指定类型。TypeScript 在不能根据上下文推断出类型时，会回退到 any 类型。</p>\n</li>\n<li data-nodeid=\"16024\">\n<p data-nodeid=\"16025\">noImplicitThis：禁止隐式 this 类型，需要显示指定 this 的类型。</p>\n</li>\n</ul>\n<blockquote data-nodeid=\"16026\">\n<p data-nodeid=\"16027\"><strong data-nodeid=\"16244\">注意：将</strong><code data-backticks=\"1\" data-nodeid=\"16240\">strict</code>设置为<code data-backticks=\"1\" data-nodeid=\"16242\">true</code>，开启严格模式，是本课程极力推荐的最佳实践。</p>\n</blockquote>\n<h4 data-nodeid=\"16028\">额外检查</h4>\n<p data-nodeid=\"16029\">TypeScript 支持一些额外的代码检查，在某种程度上介于编译器与静态分析工具之间。如果你想要更多的代码检查，可能更适合使用 ESLint 这类工具。</p>\n<ul data-nodeid=\"16030\">\n<li data-nodeid=\"16031\">\n<p data-nodeid=\"16032\"><strong data-nodeid=\"16251\">noImplicitReturns</strong>：禁止隐式返回。如果代码的逻辑分支中有返回，则所有的逻辑分支都应该有返回。</p>\n</li>\n<li data-nodeid=\"16033\">\n<p data-nodeid=\"16034\"><strong data-nodeid=\"16256\">noUnusedLocals</strong>：禁止未使用的本地变量。如果一个本地变量声明未被使用，则会抛出错误。</p>\n</li>\n<li data-nodeid=\"16035\">\n<p data-nodeid=\"16036\"><strong data-nodeid=\"16261\">noUnusedParameters</strong>：禁止未使用的函数参数。如果函数的参数未被使用，则会抛出错误。</p>\n</li>\n<li data-nodeid=\"16037\">\n<p data-nodeid=\"16038\"><strong data-nodeid=\"16266\">noFallthroughCasesInSwitch</strong>：禁止 switch 语句中的穿透的情况。开启 noFallthroughCasesInSwitch 后，如果 switch 语句的流程分支中没有 break 或 return ，则会抛出错误，从而避免了意外的 swtich 判断穿透导致的问题。</p>\n</li>\n</ul>\n<h4 data-nodeid=\"16039\">模块解析</h4>\n<p data-nodeid=\"16040\">模块解析部分的编译配置会影响代码中模块导入以及编译相关的配置。</p>\n<p data-nodeid=\"16041\"><strong data-nodeid=\"16272\">moduleResolution</strong></p>\n<p data-nodeid=\"16042\">moduleResolution 用来指定模块解析策略。</p>\n<p data-nodeid=\"16043\">module 配置值为 AMD、UMD、System、ES6 时，moduleResolution 默认为 classic，否则为 node。在目前的新代码中，我们一般都是使用 node，而不使用classic。</p>\n<p data-nodeid=\"16044\">具体的模块解析策略，你可以查看<a href=\"https://www.typescriptlang.org/docs/handbook/module-resolution.html#module-resolution-strategies\" data-nodeid=\"16278\">模块解析策略</a>。</p>\n<p data-nodeid=\"16045\"><strong data-nodeid=\"16283\">baseUrl</strong></p>\n<p data-nodeid=\"16046\">baseUrl 指的是基准目录，用来设置解析非绝对路径模块名时的基准目录。比如设置 baseUrl 为 './' 时，TypeScript 将会从 tsconfig.json 所在的目录开始查找文件。</p>\n<p data-nodeid=\"16047\"><strong data-nodeid=\"16292\">paths</strong></p>\n<p data-nodeid=\"16048\">paths 指的是路径设置，用来将模块路径重新映射到相对于 baseUrl 定位的其他路径配置。这里我们可以将 paths 理解为 webpack 的 alias 别名配置。</p>\n<p data-nodeid=\"16049\">下面我们看一个具体的示例：</p>\n<pre class=\"lang-json\" data-nodeid=\"16050\"><code data-language=\"json\">{\n  <span class=\"hljs-attr\">\"compilerOptions\"</span>: {\n    <span class=\"hljs-attr\">\"paths\"</span>: {\n      <span class=\"hljs-attr\">\"@src/*\"</span>: [<span class=\"hljs-string\">\"src/*\"</span>],\n      <span class=\"hljs-attr\">\"@utils/*\"</span>: [<span class=\"hljs-string\">\"src/utils/*\"</span>]\n    }\n  }\n}\n</code></pre>\n<p data-nodeid=\"16051\">在上面的例子中，TypeScript 模块解析支持以一些自定义前缀来寻找模块，避免在代码中出现过长的相对路径。</p>\n<blockquote data-nodeid=\"16052\">\n<p data-nodeid=\"16053\"><strong data-nodeid=\"16299\">注意：因为 paths 中配置的别名仅在类型检测时生效，所以在使用 tsc 转译或者 webpack 构建 TypeScript 代码时，我们需要引入额外的插件将源码中的别名替换成正确的相对路径。</strong></p>\n</blockquote>\n<p data-nodeid=\"16054\"><strong data-nodeid=\"16303\">rootDirs</strong></p>\n<p data-nodeid=\"16055\">rootDirs 可以指定多个目录作为根目录。这将允许编译器在这些“虚拟”目录中解析相对应的模块导入，就像它们被合并到同一目录中一样。</p>\n<p data-nodeid=\"16056\"><strong data-nodeid=\"16308\">typeRoots</strong></p>\n<p data-nodeid=\"16057\">typeRoots 用来指定类型文件的根目录。</p>\n<p data-nodeid=\"16058\">在默认情况下，所有 node_modules/@types 中的任何包都被认为是可见的。如果手动指定了 typeRoots ，则仅会从指定的目录里查找类型文件。</p>\n<p data-nodeid=\"16059\"><strong data-nodeid=\"16316\">types</strong></p>\n<p data-nodeid=\"16060\">在默认情况下，所有的 typeRoots 包都将被包含在编译过程中。</p>\n<p data-nodeid=\"16061\">手动指定 types 时，只有列出的包才会被包含在全局范围内，如下示例：</p>\n<pre class=\"lang-json\" data-nodeid=\"16062\"><code data-language=\"json\">{\n  <span class=\"hljs-attr\">\"compilerOptions\"</span>: {\n    <span class=\"hljs-attr\">\"types\"</span>: [<span class=\"hljs-string\">\"node\"</span>, <span class=\"hljs-string\">\"jest\"</span>, <span class=\"hljs-string\">\"express\"</span>]\n  }\n}\n</code></pre>\n<p data-nodeid=\"16063\">在上述示例中可以看到，手动指定 types 时 ，仅包含了 node、jest、express 三个  node 模块的类型包。</p>\n<p data-nodeid=\"16064\"><strong data-nodeid=\"16323\">allowSyntheticDefaultImports</strong></p>\n<p data-nodeid=\"16065\">allowSyntheticDefaultImports****允许合成默认导出。</p>\n<p data-nodeid=\"16066\">当 allowSyntheticDefaultImports 设置为 true，即使一个模块没有默认导出（export default），我们也可以在其他模块中像导入包含默认导出模块一样的方式导入这个模块，如下示例：</p>\n<pre class=\"lang-typescript\" data-nodeid=\"16067\"><code data-language=\"typescript\"><span class=\"hljs-comment\">// allowSyntheticDefaultImports: true 可以使用</span>\n<span class=\"hljs-keyword\">import</span> React <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'react'</span>;\n<span class=\"hljs-comment\">// allowSyntheticDefaultImports: false</span>\n<span class=\"hljs-keyword\">import</span> * <span class=\"hljs-keyword\">as</span> React <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'react'</span>;\n</code></pre>\n<p data-nodeid=\"16068\">在上面的示例中，对于没有默认导出的模块 react，如果设置了 allowSyntheticDefaultImports 为 true，则可以直接通过 import 导入 react；但如果设置 allowSyntheticDefaultImports 为 false，则需要通过 import * as 导入 react。</p>\n<p data-nodeid=\"16069\"><strong data-nodeid=\"16334\">esModuleInterop</strong></p>\n<p data-nodeid=\"16070\">esModuleInterop 指的是 ES 模块的互操作性。</p>\n<p data-nodeid=\"16071\">在默认情况下，TypeScript 像 ES6 模块一样对待 CommonJS / AMD / UMD，但是此时的 TypeScript 代码转移会导致不符合 ES6 模块规范。不过，开启 esModuleInterop 后，这些问题都将得到修复。</p>\n<p data-nodeid=\"16072\">一般情况下，在启用 esModuleInterop 时，我们将同时启用 allowSyntheticDefaultImports。</p>\n<h4 data-nodeid=\"16073\">Source Maps</h4>\n<p data-nodeid=\"16074\">为了支持丰富的调试工具，并为开发人员提供有意义的崩溃报告，TypeScript 支持生成符合 JavaScript Source Map 标准的附加文件（即 .map 文件）。</p>\n<p data-nodeid=\"16075\"><strong data-nodeid=\"16343\">sourceRoot</strong></p>\n<p data-nodeid=\"16076\">sourceRoot 用来指定调试器需要定位的 TypeScript 文件位置，而不是相对于源文件的路径。</p>\n<p data-nodeid=\"16077\">sourceRoot<strong data-nodeid=\"16350\">的</strong>取值可以是路径或者 URL。</p>\n<p data-nodeid=\"16078\"><strong data-nodeid=\"16354\">mapRoot</strong></p>\n<p data-nodeid=\"16079\">mapRoot 用来指定调试器需要定位的 source map 文件的位置，而不是生成的文件位置。</p>\n<p data-nodeid=\"16080\"><strong data-nodeid=\"16359\">inlineSourceMap</strong></p>\n<p data-nodeid=\"16081\">开启 inlineSourceMap 选项时，将不会生成 .js.map 文件，而是将 source map 文件内容生成内联字符串写入对应的 .js 文件中。虽然这样会生成较大的 JS 文件，但是在不支持 .map 调试的环境下将会很方便。</p>\n<p data-nodeid=\"16082\"><strong data-nodeid=\"16364\">inlineSources</strong></p>\n<p data-nodeid=\"16083\">开启 inlineSources 选项时，将会把源文件的所有内容生成内联字符串并写入 source map 中。这个选项的用途和 inlineSourceMap 是一样的。</p>\n<h4 data-nodeid=\"16084\">实验选项</h4>\n<p data-nodeid=\"16085\">TypeScript 支持一些尚未在 JavaScript 提案中稳定的语言特性，因此在 TypeScript 中实验选项是作为实验特性存在的。</p>\n<p data-nodeid=\"16086\"><strong data-nodeid=\"16371\">experimentalDecorators</strong></p>\n<p data-nodeid=\"16087\">experimentalDecorators****选项会开启<a href=\"https://github.com/tc39/proposal-decorators\" data-nodeid=\"16377\">装饰器提案</a>的特性。</p>\n<p data-nodeid=\"16088\"><strong data-nodeid=\"16382\">目前，装饰器提案在 stage 2 仍未完全批准到 JavaScript 规范中，且 TypeScript 实现的装饰器版本可能和 JavaScript 有所不同。</strong></p>\n<p data-nodeid=\"16089\"><strong data-nodeid=\"16386\">emitDecoratorMetadata</strong></p>\n<p data-nodeid=\"16090\">emitDecoratorMetadata****选项允许装饰器使用反射数据的特性。</p>\n<h4 data-nodeid=\"16091\">高级选项</h4>\n<p data-nodeid=\"16092\"><strong data-nodeid=\"16394\">skipLibCheck</strong></p>\n<p data-nodeid=\"16093\">开启 skipLibCheck****选项，表示可以跳过检查声明文件。</p>\n<p data-nodeid=\"16094\">如果我们开启了这个选项，则可以节省编译期的时间，但可能会牺牲类型系统的准确性。<strong data-nodeid=\"16406\">在设置该选项时，我推荐值为</strong>true**。**</p>\n<p data-nodeid=\"16095\"><strong data-nodeid=\"16410\">forceConsistentCasingInFileNames</strong></p>\n<p data-nodeid=\"16096\">TypeScript 对文件的大小写是敏感的。如果有一部分的开发人员在大小写敏感的系统开发，而另一部分的开发人员在大小写不敏感的系统开发，则可能会出现问题。</p>\n<p data-nodeid=\"16097\"><strong data-nodeid=\"16415\">开启此选项后，如果开发人员正在使用和系统不一致的大小写规则，则会抛出错误。</strong></p>\n<h3 data-nodeid=\"16098\">include</h3>\n<p data-nodeid=\"16099\">include 用来指定需要包括在 TypeScript 项目中的文件或者文件匹配路径。如果我们指定了 files 配置项，则 include 的 默认值为 []，否则 include 默认值为 [\"**/*\"] ，即包含了目录下的所有文件。</p>\n<p data-nodeid=\"16100\">如果 glob 匹配的文件中没有包含文件的扩展名，则只有 files 支持的扩展名会被包含。</p>\n<p data-nodeid=\"16101\">一般来说，include 的默认值为.ts、.tsx 和 .d.ts。如果我们开启了 allowJs 选项，还包括 .js 和 .jsx 文件。</p>\n<h3 data-nodeid=\"16102\">exclude</h3>\n<p data-nodeid=\"16103\">exclude 用来指定解析 include 配置中需要跳过的文件或者文件匹配路径。一般来说，exclude 的默认值为 [\"node_modules\", \"bower_components\", \"jspm_packages\"]。</p>\n<blockquote data-nodeid=\"16104\">\n<p data-nodeid=\"16105\"><strong data-nodeid=\"16461\">需要注意</strong>：<code data-backticks=\"1\" data-nodeid=\"16457\">exclude</code>配置项只会改变<code data-backticks=\"1\" data-nodeid=\"16459\">include</code>配置项中的结果。</p>\n</blockquote>\n<h3 data-nodeid=\"16106\">files</h3>\n<p data-nodeid=\"16107\">files 选项用来指定 TypeScript 项目中需要包含的文件列表。</p>\n<p data-nodeid=\"16108\">如果项目非常小，那么我们可以使用 files<strong data-nodeid=\"16472\">指定项目的文件，否则更适合使用</strong>include<strong data-nodeid=\"16473\">指定项目文件。</strong></p>\n<h3 data-nodeid=\"16109\">extends</h3>\n<p data-nodeid=\"16110\">extends 配置项的值是一个字符串，用来声明当前配置需要继承的另外一个配置的路径，这个路径使用 Node.js 风格的解析模式。TypeScript 首先会加载 extends 的配置文件，然后使用当前的 tsconfig.json 文件里的配置覆盖继承的文件里的配置。</p>\n<p data-nodeid=\"16111\">TypeScript 会基于当前 tsconfig.json 配置文件的路径解析所继承的配置文件中出现的相对路径。</p>\n<h3 data-nodeid=\"16112\">小结和预告</h3>\n<p data-nodeid=\"16113\">tsconfig.json 是 TypeScript 项目非常重要的配置文件，这一讲我们着重介绍了编译选项中不同功能的常用选项，更多的 TypeScript 配置可以在<a href=\"https://www.typescriptlang.org/tsconfig\" data-nodeid=\"16481\">TSConfig Reference</a>中查看学习。</p>\n<p data-nodeid=\"16114\">你也可以结合这一讲的内容新建项目并更改 tsconfig.json 实践学习。</p>\n<p data-nodeid=\"16115\">17 讲我们将介绍解析在 TypeScript 项目开发中常见的类型错误以及如何为 TypeScript 类型编写单元测试，敬请期待！</p>\n<p data-nodeid=\"16116\">另外，如果你觉得本专栏有价值，欢迎分享给更多好友。</p>",
                "article_title": "16 | tsconfig.json 配置：如何定制 TypeScript 的行为？",
                "title": "16 | tsconfig.json 配置：如何定制 TypeScript 的行为？",
                "id": 7448
            },
            {
                "content": "<p data-nodeid=\"2306\">经过前面课程的学习，你已经掌握了 TypeScript 的基本知识，并了解了如何利用 TypeScript 的基本知识实现一些高级类型和特性。这一讲我将介绍一些平时在开发过程中常见但在官方文档甚少提及的 TypeScript 类型错误，并教你如何给 TypeScript 代码编写单元测试。</p>\n<h3 data-nodeid=\"2307\">常见错误</h3>\n<p data-nodeid=\"2308\">TypeScript 错误信息由错误码和详细信息组成。其中，错误码是以“TS”开头 + 数字（一般是 4 位数字）结尾这样的格式组成的字符串，用来作为特定类型错误的专属代号。如果你想查看所有的错误信息和错误码，可以点击<a href=\"https://github.com/Microsoft/TypeScript/blob/master/src/compiler/diagnosticMessages.json\" data-nodeid=\"2391\">TypeScript 源码仓库</a>。当然，随着 TypeScript 版本的更新，也会逐渐增加更多新的类型错误。</p>\n<p data-nodeid=\"2309\">下面我们看一下那些常见但在官方文档甚少提及的类型错误。</p>\n<h4 data-nodeid=\"2310\">TS2456</h4>\n<p data-nodeid=\"2311\">首先是由于类型别名循环引用了自身造成的 TS2456 类型错误，如下示例：</p>\n<pre class=\"lang-typescript\" data-nodeid=\"2312\"><code data-language=\"typescript\"><span class=\"hljs-comment\">// TS2456: Type alias 'T' circularly references itself.</span>\n<span class=\"hljs-keyword\">type</span> T = Readonly&lt;T&gt;;\n</code></pre>\n<p data-nodeid=\"3766\" class=\"\">在上述示例中，对于 T 这个类型别名，如果 TypeScript 编译器想知道 T 类型是什么，就需要展开类型别名赋值的 Readonly<code data-backticks=\"1\" data-nodeid=\"3768\">&lt;T&gt;</code>。而为了确定 Readonly<code data-backticks=\"1\" data-nodeid=\"3770\">&lt;T&gt;</code> 的类型，TypeScript 编译器需要继续判断类型入参 T 的类型，这就形成了一个循环引用。类似函数循环调用自己，如果没有正确的终止条件，就会一直处于无限循环的状态。</p>\n\n\n<p data-nodeid=\"2314\">当然，如果在类型别名的定义中设定了正确的终止条件，我们就可以使用循环引用的特殊数据结构，如下示例：</p>\n<pre class=\"lang-java\" data-nodeid=\"2315\"><code data-language=\"java\">type JSON = string | number | <span class=\"hljs-keyword\">boolean</span> | <span class=\"hljs-keyword\">null</span> | JSON[] | { [key: string]: JSON };\n​\n<span class=\"hljs-keyword\">const</span> json1: JSON = <span class=\"hljs-string\">'json'</span>;\n<span class=\"hljs-keyword\">const</span> json2: JSON = [<span class=\"hljs-string\">'str'</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-keyword\">true</span>, <span class=\"hljs-keyword\">null</span>];\n<span class=\"hljs-keyword\">const</span> json3: JSON = { key: <span class=\"hljs-string\">'value'</span> };\n</code></pre>\n<p data-nodeid=\"2316\">在上面的例子中，我们定义了 JSON 数据结构的 TypeScript 类型。其中，就有对类型别名 JSON 自身的循环引用，即示例中出现的 JSON[] | { [key: string]: JSON }。与第 1 个例子不同的是，这里的引用最终可以具体展开为 string | number | boolean | null 类型，所以不会出现无限循环的情况。</p>\n<blockquote data-nodeid=\"2317\">\n<p data-nodeid=\"2318\"><strong data-nodeid=\"2413\">注意：第 2 个例子只能在 TypeScript 3.7 以上的版本使用，如果版本小于 3.7 仍会提示  TS2456 错误。</strong></p>\n</blockquote>\n<h4 data-nodeid=\"2319\">TS2554</h4>\n<p data-nodeid=\"2320\">另外，我们需要介绍的是比较常见的一个 TS2554 错误，它是由于形参和实参个数不匹配造成的，如下示例：</p>\n<pre class=\"lang-java\" data-nodeid=\"2321\"><code data-language=\"java\"><span class=\"hljs-function\">function <span class=\"hljs-title\">toString</span><span class=\"hljs-params\">(x: number | undefined)</span>: string </span>{\n &nbsp;<span class=\"hljs-keyword\">if</span> (x === undefined) {\n &nbsp; &nbsp;<span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">''</span>;\n  }\n &nbsp;<span class=\"hljs-keyword\">return</span> x.toString();\n}\n​\ntoString(); <span class=\"hljs-comment\">// TS2554: Expected 1 arguments, but got 0.</span>\ntoString(undefined);\ntoString(<span class=\"hljs-number\">1</span>);\n</code></pre>\n<p data-nodeid=\"2322\">上面例子报错的原因是，在 TypeScript 中，undefined 是一个特殊的类型。由于类型为  undefined，并不代表可缺省，因此示例中的第 8 行提示了 TS2554 错误。</p>\n<p data-nodeid=\"2323\">而可选参数是一种特殊的类型，虽然在代码执行层面上，最终参数类型是 undefined 和参数可选的函数，接收到的入参的值都可以是 undefined，但是在 TypeScript 的代码检查中，undefined 类型的参数和可选参数都会被当作不同的类型来对待，如下示例：</p>\n<pre class=\"lang-java\" data-nodeid=\"2324\"><code data-language=\"java\"><span class=\"hljs-function\">function <span class=\"hljs-title\">toString</span><span class=\"hljs-params\">(x?: number)</span>: string </span>{\n &nbsp;<span class=\"hljs-keyword\">if</span> (x === undefined) {\n &nbsp; &nbsp;<span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">''</span>;\n  }\n &nbsp;<span class=\"hljs-keyword\">return</span> x.toString();\n}\n​\n<span class=\"hljs-function\">function <span class=\"hljs-title\">toString</span><span class=\"hljs-params\">(x = <span class=\"hljs-string\">''</span>)</span>: string </span>{\n &nbsp;<span class=\"hljs-keyword\">return</span> x.toString();\n}\n</code></pre>\n<p data-nodeid=\"2325\">因此，如果在编程的过程中函数的参数是可选的，我们最好使用可选参数的语法，这样就可以避免手动传入 undefined 的值，并顺利通过 TypeScript 的检查。</p>\n<p data-nodeid=\"4186\" class=\"te-preview-highlight\">值得一提的是，在 TypeScript 4.1 大版本的更新中，Promise 构造的 resolve 参数不再是默认可选的了，所以如以下示例第 2 行所示，在未指定入参的情况下，调用 resolve 会提示类型错误 <strong data-nodeid=\"4192\">（注意：为了以示区分，官方使用了 TS2794 错误码指代这个错误）</strong>。</p>\n\n<pre class=\"lang-java\" data-nodeid=\"2327\"><code data-language=\"java\"><span class=\"hljs-keyword\">new</span> Promise((resolve) =&gt; {\n &nbsp;resolve(); <span class=\"hljs-comment\">// TS2794: Expected 1 arguments, but got 0. Did you forget to include 'void' in your type argument to 'Promise'? </span>\n});\n</code></pre>\n<p data-nodeid=\"2328\">如果我们不需要参数，只需要给 Promise 的泛型参数传入 void 即可，如下示例：</p>\n<pre class=\"lang-java\" data-nodeid=\"2329\"><code data-language=\"java\"><span class=\"hljs-keyword\">new</span> Promise&lt;<span class=\"hljs-keyword\">void</span>&gt;((resolve) =&gt; {\n &nbsp;resolve();\n});\n</code></pre>\n<p data-nodeid=\"2330\">在上述示例中，因为我们在第 1 行给泛型类 Promise 指定了 void 类型入参（注意是 void 而不是 undefined），所以在第 3 行调用 resolve 时无须指定入参。</p>\n<h4 data-nodeid=\"2331\">TS1169</h4>\n<p data-nodeid=\"2332\">接下来是 TS1169 类型错误，它是在接口类型定义中由于使用了非字面量或者非唯一 symbol 类型作为属性名造成的，如下示例：</p>\n<pre class=\"lang-java\" data-nodeid=\"2333\"><code data-language=\"java\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title\">Obj</span> </span>{\n  [key in <span class=\"hljs-string\">'id'</span> | <span class=\"hljs-string\">'name'</span>]: any; <span class=\"hljs-comment\">// TS1169: A computed property name in an interface must refer to an expression whose type is a literal type or a 'unique symbol' type.</span>\n};\n</code></pre>\n<p data-nodeid=\"2334\">在上述示例中，因为interface 类型的属性必须是字面量类型(string、number) 或者是 unique symbol 类型，所以在第 2 行提示了 TS1169 错误。</p>\n<p data-nodeid=\"2335\">关于接口类型支持的用法如下示例：</p>\n<pre class=\"lang-java\" data-nodeid=\"2336\"><code data-language=\"java\"><span class=\"hljs-keyword\">const</span> symbol: unique symbol = Symbol();\n​\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title\">Obj</span> </span>{\n  [key: string]: any;\n  [key: number]: any;\n  [symbol]: any;\n}\n</code></pre>\n<p data-nodeid=\"2337\">在上述示例中的第 4~6 行，我们使用了 string、number 和 symbol 作为接口属性，所以不会提示类型错误。</p>\n<p data-nodeid=\"2338\">但是，在 type 关键字声明的类型别名中，我们却可以使用映射类型定义属性，如下示例：</p>\n<pre class=\"lang-java\" data-nodeid=\"2339\"><code data-language=\"java\">type Obj = {\n  [key in <span class=\"hljs-string\">'id'</span> | <span class=\"hljs-string\">'name'</span>]: any;\n};\n</code></pre>\n<p data-nodeid=\"2340\">在示例中的第 2 行，我们定义了一个包含 id 和 name 属性的类型别名 Obj。</p>\n<h4 data-nodeid=\"2341\">TS2345</h4>\n<p data-nodeid=\"2342\">接下来我们介绍一下非常常见的 TS2345 类型错误，它是在传参时由于类型不兼容造成的，如下示例：</p>\n<pre class=\"lang-java\" data-nodeid=\"2343\"><code data-language=\"java\"><span class=\"hljs-keyword\">enum</span> A {\n &nbsp;x = <span class=\"hljs-string\">'x'</span>,\n &nbsp;y = <span class=\"hljs-string\">'y'</span>,\n &nbsp;z = <span class=\"hljs-string\">'z'</span>,\n}\n<span class=\"hljs-keyword\">enum</span> B {\n &nbsp;x = <span class=\"hljs-string\">'x'</span>,\n &nbsp;y = <span class=\"hljs-string\">'y'</span>,\n &nbsp;z = <span class=\"hljs-string\">'z'</span>,\n}\n​\n<span class=\"hljs-function\">function <span class=\"hljs-title\">fn</span><span class=\"hljs-params\">(val: A)</span> </span>{}\nfn(B.x); <span class=\"hljs-comment\">// TS2345: Argument of type 'B.x' is not assignable to parameter of type 'A'.</span>\n</code></pre>\n<p data-nodeid=\"2344\">如上面的例子所示，函数 fn 参数的 val 类型是枚举 A，在 13 行我们传入了与枚举 A 类似的枚举 B 的值，此时 TypeScript 提示了类型不匹配的错误。这是因为枚举是在运行时真正存在的对象，因此 TypeScript 并不会判断两个枚举是否可以互相兼容。</p>\n<p data-nodeid=\"2345\">此时解决这个错误的方式也很简单，我们只需要让这两个枚举类型互相兼容就行，比如使用类型断言绕过 TypeScript 的类型检查，如下示例：</p>\n<pre class=\"lang-java\" data-nodeid=\"2346\"><code data-language=\"java\"><span class=\"hljs-function\">function <span class=\"hljs-title\">fn</span><span class=\"hljs-params\">(val: A)</span> </span>{}\nfn((B.x as unknown) as A);\n</code></pre>\n<p data-nodeid=\"2347\">在示例中的第 2 行，我们使用了 as 双重类型断言让枚举 B.x 兼容枚举类型 A，从而不再提示类型错误。</p>\n<h4 data-nodeid=\"2348\">TS2589</h4>\n<p data-nodeid=\"2349\">接下来我们介绍 TS2589 类型错误，它是由泛型实例化递归嵌套过深造成的，如下示例：</p>\n<pre class=\"lang-java\" data-nodeid=\"2350\"><code data-language=\"java\">type RepeatX&lt;N extends number, T extends any[] = []&gt; = T[<span class=\"hljs-string\">'length'</span>] extends N\n &nbsp;? T\n  : RepeatX&lt;N, [...T, <span class=\"hljs-string\">'X'</span>]&gt;;\ntype T1 = RepeatX&lt;<span class=\"hljs-number\">5</span>&gt;; <span class=\"hljs-comment\">// =&gt; [\"X\", \"X\", \"X\", \"X\", \"X\"]</span>\n<span class=\"hljs-comment\">// TS2589: Type instantiation is excessively deep and possibly infinite.</span>\ntype T2 = RepeatX&lt;<span class=\"hljs-number\">50</span>&gt;; <span class=\"hljs-comment\">// =&gt; any</span>\n</code></pre>\n<p data-nodeid=\"2351\">在上面的例子中，因为第 1 行的泛型 RepeatX 接收了一个数字类型入参 N，并返回了一个长度为 N、元素都是 'X' 的数组类型，所以第 4 行的类型 T1 包含了 5 个 \"X\" 的数组类型；但是第 6 行的类型 T2 的类型却是 any，并且提示了 TS2589 类型错误。这是因为 TypeScript 在处理递归类型的时候，最多实例化 50 层，如果超出了递归层数的限制，TypeScript 便不会继续实例化，并且类型会变为 top 类型 any。</p>\n<p data-nodeid=\"2352\">对于上面的错误，我们使用 @ts-ignore 注释忽略即可。</p>\n<h4 data-nodeid=\"2353\">TS2322</h4>\n<p data-nodeid=\"2354\">接下来需要介绍的是一个常见的字符串字面量类型的 TS2322 错误，如下示例：</p>\n<pre class=\"lang-typescript\" data-nodeid=\"2355\"><code data-language=\"typescript\"><span class=\"hljs-keyword\">interface</span> CSSProperties {\n  display: <span class=\"hljs-string\">'block'</span> | <span class=\"hljs-string\">'flex'</span> | <span class=\"hljs-string\">'grid'</span>;\n}\n<span class=\"hljs-keyword\">const</span> style = {\n  display: <span class=\"hljs-string\">'flex'</span>,\n};\n<span class=\"hljs-comment\">// TS2322: Type '{ display: string; }' is not assignable to type 'CSSProperties'.</span>\n<span class=\"hljs-comment\">//  Types of property 'display' are incompatible.</span>\n<span class=\"hljs-comment\">//   Type 'string' is not assignable to type '\"block\" | \"flex\" | \"grid\"'.</span>\n<span class=\"hljs-keyword\">const</span> cssStyle: CSSProperties = style;\n</code></pre>\n<p data-nodeid=\"2356\">在上面的例子中，CSSProperties 的 display 属性的类型是字符串字面量类型 'block' | 'flex' | 'grid'，虽然变量 style 的 display 属性看起来与 CSSProperties 类型完全兼容，但是 TypeScript 提示了 TS2322 类型不兼容的错误。这是因为变量 style 的类型被自动推断成了 { display: string }，string 类型自然无法兼容字符串字面量类型 'block' | 'flex' | 'grid'，所以变量 style 不能赋值给 cssStyle。</p>\n<p data-nodeid=\"2357\">如下我提供了两种解决这个错误的方法。</p>\n<pre class=\"lang-typescript\" data-nodeid=\"2358\"><code data-language=\"typescript\"><span class=\"hljs-comment\">// 方法 1</span>\n<span class=\"hljs-keyword\">const</span> style: CSSProperties = {\n  display: <span class=\"hljs-string\">'flex'</span>,\n};\n<span class=\"hljs-comment\">// 方法 2</span>\n<span class=\"hljs-keyword\">const</span> style = {\n  display: <span class=\"hljs-string\">'flex'</span> <span class=\"hljs-keyword\">as</span> <span class=\"hljs-string\">'flex'</span>,\n};\n<span class=\"hljs-comment\">// typeof style = { display: 'flex' }</span>\n</code></pre>\n<p data-nodeid=\"2359\">在方法 1 中，我们显式声明了 style 类型为 CSSProperties，因此变量 style 类型与 cssStyle 期望的类型兼容。在方法 2 中，我们使用了类型断言声明 display 属性的值为字符串字面量类型 'flex'，因此 style 的类型被自动推断成了 { display: 'flex' }，与 CSSProperties 类型兼容。</p>\n<h4 data-nodeid=\"2360\">TS2352</h4>\n<p data-nodeid=\"2361\">接下来我要介绍的是一个 TypeScript 类型收缩特性的 TS2352 类型错误，如下示例：</p>\n<pre class=\"lang-typescript\" data-nodeid=\"2362\"><code data-language=\"typescript\"><span class=\"hljs-keyword\">let</span> x: <span class=\"hljs-built_in\">string</span> | <span class=\"hljs-literal\">undefined</span>;\n<span class=\"hljs-keyword\">if</span> (x) {\n  x.trim();\n  setTimeout(<span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> {\n    x.trim(); <span class=\"hljs-comment\">// TS2532: Object is possibly 'undefined'.</span>\n  });\n}\n<span class=\"hljs-keyword\">class</span> Person {\n  greet() {}\n}\n<span class=\"hljs-keyword\">let</span> person: Person | <span class=\"hljs-built_in\">string</span>;\n<span class=\"hljs-keyword\">if</span> (person <span class=\"hljs-keyword\">instanceof</span> Person) {\n  person.greet();\n  <span class=\"hljs-keyword\">const</span> innerFn = <span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> {\n    person.greet(); <span class=\"hljs-comment\">// TS2532: Object is possibly 'undefined'.</span>\n  };\n}\n</code></pre>\n<p data-nodeid=\"2363\">在上述示例中的第 1 行，变量 x 的类型是 sting | undefined。在第 3 行的 if 语句中，变量 x 的类型按照之前讲的类型收缩特性应该是 string，可以看到第 4 行的代码可以通过类型检查，而第 6 行的代码报错 x 类型可能是 undefined（因为 setTimeout 的类型守卫失效，所以 x 的类型不会缩小为 string）。</p>\n<p data-nodeid=\"2364\">同样，对于第 10 行的变量 person ，我们可以使用 instanceof 将它的类型收缩为 Person，因此第 16 行的代码通过了类型检查，而第 18 行则提示了 TS2352 错误。这是因为函数中对捕获的变量不会使用类型收缩的结果，因为编译器不知道回调函数什么时候被执行，也就无法使用之前类型收缩的结果。</p>\n<p data-nodeid=\"2365\">针对这种错误的处理方式也很简单，将类型收缩的代码放入函数体内部即可，如下示例：</p>\n<pre class=\"lang-typescript\" data-nodeid=\"2366\"><code data-language=\"typescript\"><span class=\"hljs-keyword\">let</span> x: <span class=\"hljs-built_in\">string</span> | <span class=\"hljs-literal\">undefined</span>;\nsetTimeout(<span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> {\n  <span class=\"hljs-keyword\">if</span> (x) {\n    x.trim(); <span class=\"hljs-comment\">// OK</span>\n  }\n});\n<span class=\"hljs-keyword\">class</span> Person {\n  greet() {}\n}\n<span class=\"hljs-keyword\">let</span> person: Person | <span class=\"hljs-literal\">undefined</span>;\n<span class=\"hljs-keyword\">const</span> innerFn = <span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> {\n  <span class=\"hljs-keyword\">if</span> (person <span class=\"hljs-keyword\">instanceof</span> Person) {\n    person.greet(); <span class=\"hljs-comment\">// Ok</span>\n  }\n};\n</code></pre>\n<h3 data-nodeid=\"2367\">单元测试</h3>\n<p data-nodeid=\"2368\">在单元测试中，我们需要测试的是函数的输出与预计的输出是否相等。在 TypeScript 的类型测试中，我们需要测试的是编写的工具函数转换后的类型与预计的类型是否一致。</p>\n<p data-nodeid=\"2369\">我们知道当赋值、传参的类型与预期不一致，TypeScript 就会抛出类型错误，如下示例：</p>\n<pre class=\"lang-java\" data-nodeid=\"2370\"><code data-language=\"java\"><span class=\"hljs-keyword\">const</span> x: string = <span class=\"hljs-number\">1</span>; <span class=\"hljs-comment\">// TS2322: Type 'number' is not assignable to type 'string'.</span>\n</code></pre>\n<p data-nodeid=\"2371\">在上述示例中可以看到，把数字字面量 1 赋值给 string 类型变量 x 时，会提示 TS2322 错误。</p>\n<p data-nodeid=\"2372\">因此，我们可以通过泛型限定需要测试的类型。只有需要测试的类型与预期类型一致时，才可以通过 TypeScript 编译器的检查，如下示例：</p>\n<pre class=\"lang-java\" data-nodeid=\"2373\"><code data-language=\"java\">type ExpectTrue&lt;T extends <span class=\"hljs-keyword\">true</span>&gt; = T;\ntype T1 = ExpectTrue&lt;<span class=\"hljs-keyword\">true</span>&gt;;\ntype T2 = ExpectTrue&lt;<span class=\"hljs-keyword\">null</span>&gt;; <span class=\"hljs-comment\">// TS2344: Type 'null' does not satisfy the constraint 'true'.</span>\n</code></pre>\n<p data-nodeid=\"2374\">在上面 ExpectTrue 的测试方法中，因为第 1 行预期的类型是 true，所以第 2 行的入参为 true 时不会出现错误提示。但是，因为第 3 行的入参是 null ，所以会提示类型错误。</p>\n<p data-nodeid=\"2375\">自 TS 3.9 版本起，官方支持了与 @ts-ignore 注释相反功能的 @ts-expect-error 注释。使用 @ts-expect-error 注释，我们可以标记代码中应该有类型错误的部分。</p>\n<p data-nodeid=\"2376\">与 ts-ignore 不同的是，如果下一行代码中没有错误，则会提示 TS2578 的错误，如下示例：</p>\n<pre class=\"lang-typescript\" data-nodeid=\"2377\"><code data-language=\"typescript\"><span class=\"hljs-comment\">// @ts-expect-error</span>\n<span class=\"hljs-keyword\">const</span> x: <span class=\"hljs-built_in\">number</span> = <span class=\"hljs-string\">'42'</span>;\n<span class=\"hljs-comment\">// TS2578: Unused '@ts-expect-error' directive.</span>\n<span class=\"hljs-comment\">// @ts-expect-error</span>\n<span class=\"hljs-keyword\">const</span> y: <span class=\"hljs-built_in\">number</span> = <span class=\"hljs-number\">42</span>;\n</code></pre>\n<p data-nodeid=\"2378\">在上述示例的第 2 行代码处并不会提示类型不兼容的错误，这是因为 @ts-expect-error 注释命令表示下一行应当有类型错误，符合预期。而第 6 行的代码会提示 TS2578 未使用的 @ts-expect-error 命令，这是因为第 6 行的代码没有类型错误。</p>\n<blockquote data-nodeid=\"2379\">\n<p data-nodeid=\"2380\"><strong data-nodeid=\"2509\">备注</strong>：<code data-backticks=\"1\" data-nodeid=\"2507\">@ts-expect-error</code>注释命令在编写预期失败的单元测试中很有用处。</p>\n</blockquote>\n<h3 data-nodeid=\"2381\">小结与预告</h3>\n<p data-nodeid=\"2382\">这一讲我们介绍了一些 TypeScript 开发中可能遇到的错误码，并分析解析了错误的原因，同时介绍了如何为之前学习的工具类型、自定义函数编写单元测试。</p>\n<p data-nodeid=\"2383\">18 讲我们将正式进入实践环节，教你如何使用 TypeScript 开发类型安全的 HTTP 静态文件服务，敬请期待！</p>\n<p data-nodeid=\"2384\">另外，如果你觉得本专栏有价值，欢迎分享给更多好友。</p>",
                "article_title": "17 | 来自 100 +项目经历的常见 TypeScript 错误汇总分析",
                "title": "17 | 来自 100 +项目经历的常见 TypeScript 错误汇总分析",
                "id": 7449
            },
            {
                "content": "<p data-nodeid=\"17551\">在前面的课程中，我们学习了 TypeScript 的常见配置、错误及相关实践。从这一讲开始，我们将以项目级实践为例，一起学习 TypeScript 在 Node.js、Web 端开发的经验。</p>\n<blockquote data-nodeid=\"17552\">\n<p data-nodeid=\"17553\">学习建议：请按照课程中的操作步骤，实践一个完整的开发流程。</p>\n</blockquote>\n<p data-nodeid=\"17554\">在实际业务中，经常需要使用 Node.js 的场景包括重量级后端应用以及各种 CLI 模块。因此，这一讲我们将引入 TypeScript 开发一个可以指定端口、文件目录、缓存设置等参数的 HTTP 静态文件服务 http-serve CLI NPM 模块。</p>\n<h3 data-nodeid=\"17555\">开发 NPM 模块</h3>\n<p data-nodeid=\"17556\">在开发阶段，我们使用 ts-node 直接运行 TypeScript 源码就行。构建时，我们使用官方转译工具 tsc 将 TypeScript 源码转译为 JavaScript，并使用 TypeScript + Jest 做单元测试。</p>\n<p data-nodeid=\"17557\">下面我们先看看如何初始化 NPM 模块。</p>\n<h4 data-nodeid=\"17558\">初始化模块</h4>\n<p data-nodeid=\"17559\">首先，我们创建一个 http-serve 目录，然后在 VS Code IDE 中打开目录，再使用“ctrl + `”快捷键打开 IDE 内置命令行工具，并执行“npm init”命令初始化 NPM 模块。</p>\n<pre class=\"lang-powershell\" data-nodeid=\"17560\"><code data-language=\"powershell\">npm init\n</code></pre>\n<p data-nodeid=\"17561\">因为我们编写的仅仅是一个示例性项目，所以在初始化过程中我们只需要使用默认的模块设置一直回车确认就可以。执行完命令后，NPM 会在当前目录下自动创建一个 package.json。</p>\n<p data-nodeid=\"17562\">接下来需要划分项目结构，我们可以通过命令行工具或者 IDE 创建 src 目录用来存放所有的 TypeScript 源码。</p>\n<p data-nodeid=\"17563\">TypeScript 转译为 JavaScript 后，lib 目录一般不需要手动创建，因为转译工具会自动创建，此时我们只需要修改 tsconfig.json 中相应的配置即可。</p>\n<p data-nodeid=\"23178\" class=\"\">此外，我们还需要按照如下命令手动创建单元测试文件目录 __tests__。</p>\n\n\n\n\n\n\n\n\n<pre class=\"lang-java\" data-nodeid=\"17565\"><code data-language=\"java\">mkdir src; <span class=\"hljs-comment\">// 创建放 TypeScript 源码的目录</span>\ntouch src/cli.ts <span class=\"hljs-comment\">// CLI 命令入口文件</span>\ntouch src/http-serve.ts <span class=\"hljs-comment\">// CLI 命令入口文件</span>\nmkdir lib; <span class=\"hljs-comment\">// 转译工具自动创建放 JavaScript 代码的目录</span>\nmkdir __tests__; <span class=\"hljs-comment\">// 单元测试文件目录</span>\n</code></pre>\n<p data-nodeid=\"17566\">这里是 TypeScript 开发模块的一个经典目录结构，极力推荐你使用。</p>\n<p data-nodeid=\"17567\">接下来我们可以按照如下命令先行安装项目需要的基本依赖。</p>\n<pre class=\"lang-shell\" data-nodeid=\"17568\"><code data-language=\"shell\">npm install typescript -D;\nnpm install ts-node -D;\nnpm install jest@24 -D;\nnpm install ts-jest@24 -D;\nnpm install @types/jest -D;\n</code></pre>\n<p data-nodeid=\"17569\">在上述命令中，TypeScript、ts-node、Jest、Jest 类型声明是作为开发依赖 devDependencies 安装的。</p>\n<p data-nodeid=\"17570\">安装完依赖后，我们需要把模块的 main/bin 等参数、start/build/test 等命令写入 package.json 中，如下代码所示：</p>\n<pre class=\"lang-json\" data-nodeid=\"17571\"><code data-language=\"json\">{\n  ...\n  \"bin\": \"lib/bin.js\",\n  \"main\": \"lib/http-serve.js\",\n  \"files\": [\"lib\"],\n  \"scripts\": {\n    \"build\": \"tsc -p tsconfig.prod.json\",\n    \"start\": \"ts-node src/cli.ts\",\n    \"test\": \"jest --all\"\n  },\n  ...\n}\n</code></pre>\n<p data-nodeid=\"17572\">在上述示例第 3 行 bin 参数指定了 CLI 命令可执行文件指向的是转译后的 lib/cli.js；第 4 行 main 参数则指定了模块的主文件是转译后的 lib/http-serve.js；第 5 行指定了发布到 NPM 时包含的文件列表；第 7 行 build 命令则指定了使用 tsc 命令可以基于 tsconfig.prod.json 配置来转译 TypeScript 源码；第 8 行 start 命令则指定了使用 ts-node 可以直接运行 TypeScript 源码；第 9 行 test 命令则表示使用 Jest 可以执行所有单测。</p>\n<p data-nodeid=\"17573\">如此配置之后，我们就可以通过以下命令进行构建、开发、单测了。</p>\n<pre class=\"lang-java\" data-nodeid=\"17574\"><code data-language=\"java\">npm start; <span class=\"hljs-comment\">// 开发</span>\nnpm run build; <span class=\"hljs-comment\">// 构建</span>\nnpm test; <span class=\"hljs-comment\">// 单测</span>\n</code></pre>\n<p data-nodeid=\"17575\">接下来我们需要初始化 tsconfig 配置。</p>\n<h4 data-nodeid=\"17576\">初始化 tsconfig</h4>\n<p data-nodeid=\"17577\">如果我们已经安装了全局的 TypeScript，那么就可以直接使用全局的 tsc 命令初始化。</p>\n<p data-nodeid=\"17578\">当然，我们也可以直接使用当前模块目录下安装的 TypeScript 来初始化 tsconfig 配置。这里我推荐全局安装 npx，可以更方便地调用安装在当前目录下的各种 CLI 工具，如下代码所示：</p>\n<pre class=\"lang-java\" data-nodeid=\"17579\"><code data-language=\"java\">tsc --init; <span class=\"hljs-comment\">// 使用全局</span>\nnpm install npx -g; <span class=\"hljs-comment\">// 安装 npx</span>\nnpx tsc --init; <span class=\"hljs-comment\">// 或者使用 npx 调用当前目录下 node_modules 目录里安装的 tsc 版本</span>\n</code></pre>\n<p data-nodeid=\"17580\">以上命令会在当前目录下创建一个 tsconfig.json 文件用来定制 TypeScript 的行为。</p>\n<p data-nodeid=\"17581\">一般来说，我们需要将 declaration、sourceMap 这两个配置设置为 true，这样构建时就会生成类型声明和源码映射文件。此时，即便模块在转译之后被其他项目引用，也能对 TypeScript 类型化和运行环境源码提供调试支持。</p>\n<p data-nodeid=\"17582\">此外，一般我们会把 target 参数设置为 es5，module 参数设置为 commonjs，这样转译后模块的代码和格式就可以兼容较低版本的 Node.js 了。</p>\n<p data-nodeid=\"17583\">然后，我们需要把 tsc 转译代码的目标目录 outDir 指定为 \"./lib\"。</p>\n<p data-nodeid=\"17584\">除了构建行为相关的配置之外，我们还需要按照如下命令将 esModuleInterop 配置为 true，以便在类型检测层面兼容 CommonJS 和 ES 模块的引用关系，最终适用于 Node.js 开发的 tsconfig。</p>\n<pre class=\"lang-json\" data-nodeid=\"17585\"><code data-language=\"json\">{\n  <span class=\"hljs-attr\">\"compilerOptions\"</span>: {\n    <span class=\"hljs-attr\">\"target\"</span>: <span class=\"hljs-string\">\"es5\"</span>,\n    <span class=\"hljs-attr\">\"module\"</span>: <span class=\"hljs-string\">\"commonjs\"</span>,\n    <span class=\"hljs-attr\">\"declaration\"</span>: <span class=\"hljs-literal\">true</span>,\n    <span class=\"hljs-attr\">\"sourceMap\"</span>: <span class=\"hljs-literal\">true</span>,\n    <span class=\"hljs-attr\">\"outDir\"</span>: <span class=\"hljs-string\">\"./lib\"</span>,\n    <span class=\"hljs-attr\">\"rootDir\"</span>: <span class=\"hljs-string\">\"./src\"</span>,\n    <span class=\"hljs-attr\">\"strict\"</span>: <span class=\"hljs-literal\">true</span>,\n    <span class=\"hljs-attr\">\"esModuleInterop\"</span>: <span class=\"hljs-literal\">true</span>,\n    <span class=\"hljs-attr\">\"skipLibCheck\"</span>: <span class=\"hljs-literal\">true</span>,\n    <span class=\"hljs-attr\">\"forceConsistentCasingInFileNames\"</span>: <span class=\"hljs-literal\">true</span>\n  }\n}\n</code></pre>\n<p data-nodeid=\"24367\" class=\"\">下面我们需要手动创建一个 tsconfig.prod.json，告诉 tsc 在转译源码时忽略 __tests__ 目录。当然，我们也可以根据实际情况把其他文件、目录添加到 exclude 配置中，如下代码所示：</p>\n\n\n<pre class=\"lang-json\" data-nodeid=\"17587\"><code data-language=\"json\">{\n  <span class=\"hljs-attr\">\"extends\"</span>: <span class=\"hljs-string\">\"./tsconfig.json\"</span>,\n  <span class=\"hljs-attr\">\"exclude\"</span>: [<span class=\"hljs-string\">\"__tests__\"</span>, <span class=\"hljs-string\">\"lib\"</span>]\n}\n</code></pre>\n<blockquote data-nodeid=\"17588\">\n<p data-nodeid=\"17589\">注意：在实际项目中，我们并不经常使用 tsc --init 初始化 tsconfig。</p>\n</blockquote>\n<p data-nodeid=\"17590\">出于统一和可控性考虑，我们可以将通用的 tsconfig 配置抽离为单独的 NPM 或直接使用第三方封装的配置，再通过 extends 参数进行复用，比如可以安装<a href=\"https://www.npmjs.com/package/@tsconfig/node10\" data-nodeid=\"17733\">https://www.npmjs.com/package/@tsconfig/node10</a>等，如下代码所示：</p>\n<pre class=\"lang-java\" data-nodeid=\"17591\"><code data-language=\"java\">npm install <span class=\"hljs-meta\">@tsconfig</span>/node10 -D;\n</code></pre>\n<p data-nodeid=\"17592\">在当前模块的 tsconfig.json 中，我们只需保留路径相关的配置即可，其他配置可以继承自 node_modules 中安装的 tsconfig 模块，如下代码所示：</p>\n<pre class=\"lang-json\" data-nodeid=\"17593\"><code data-language=\"json\">{\n  <span class=\"hljs-attr\">\"extends\"</span>: <span class=\"hljs-string\">\"@tsconfig/node10\"</span>,\n  <span class=\"hljs-attr\">\"compilerOptions\"</span>: {\n    <span class=\"hljs-attr\">\"baseUrl\"</span>: <span class=\"hljs-string\">\".\"</span>,\n    <span class=\"hljs-attr\">\"outDir\"</span>: <span class=\"hljs-string\">\"./lib\"</span>\n  }\n}&nbsp;\n</code></pre>\n<blockquote data-nodeid=\"17594\">\n<p data-nodeid=\"17595\">插播一个任务：请将你惯用的 tsconfig 配置抽离为公共可复用的 NPM 模块，然后发布到 NPM 中，并在示例里引入。</p>\n</blockquote>\n<p data-nodeid=\"17596\">接下来，我们需要使用 Node.js 内置的 http 模块和第三方 ecstatic、commander 模块实现 http-serve 静态文件服务器。</p>\n<h4 data-nodeid=\"17597\">接口设计和编码实现</h4>\n<p data-nodeid=\"17598\">首先，我们需要安装以下相关依赖。</p>\n<pre class=\"lang-powershell\" data-nodeid=\"17599\"><code data-language=\"powershell\">npm install @types/node <span class=\"hljs-literal\">-D</span>;\nnpm install commander <span class=\"hljs-literal\">-S</span>;\nnpm install ecstatic <span class=\"hljs-literal\">-S</span>;\n</code></pre>\n<p data-nodeid=\"17600\">以上命令第 1 行会把 Node.js 内置模块类型声明文件作为开发依赖安装，第 2 行安装的是 CLI 需要用到的 commander，第 3 行安装的是用来处理静态文件请求的 ecstatic。</p>\n<p data-nodeid=\"17601\">不幸的是，ecstatic 并不是一个对 TypeScript 友好的模块，因为它没有内置类型声明文件，也没有第三方贡献的 @types/ecstatic 类型声明模块。因此，<strong data-nodeid=\"17747\">我们需要在项目根目录下新建一个 types.d.ts 用来补齐缺失的类型声明，如下代码所示：</strong></p>\n<pre class=\"lang-typescript\" data-nodeid=\"17602\"><code data-language=\"typescript\"><span class=\"hljs-comment\">// types.d.ts</span>\n<span class=\"hljs-keyword\">declare</span> <span class=\"hljs-keyword\">module</span> 'ecstatic' {\n  <span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> (options?: {\n    root?: <span class=\"hljs-built_in\">string</span>;\n    baseDir?: <span class=\"hljs-built_in\">string</span>;\n    autoIndex?: <span class=\"hljs-built_in\">boolean</span>;\n    showDir?: <span class=\"hljs-built_in\">boolean</span>;\n    showDotfiles?: <span class=\"hljs-built_in\">boolean</span>;\n    humanReadable?: <span class=\"hljs-built_in\">boolean</span>;\n    hidePermissions?: <span class=\"hljs-built_in\">boolean</span>;\n    si?: <span class=\"hljs-built_in\">boolean</span>;\n    cache?: <span class=\"hljs-built_in\">string</span> | <span class=\"hljs-built_in\">number</span>;\n    cors?: <span class=\"hljs-built_in\">boolean</span>;\n    gzip?: <span class=\"hljs-built_in\">boolean</span>;\n    brotli?: <span class=\"hljs-built_in\">boolean</span>;\n    defaultExt?: <span class=\"hljs-string\">'html'</span> | <span class=\"hljs-built_in\">string</span> &amp; {};\n    handleError?: <span class=\"hljs-built_in\">boolean</span>;\n    serverHeader?: <span class=\"hljs-built_in\">boolean</span>;\n    contentType?: <span class=\"hljs-string\">'application/octet-stream'</span> | <span class=\"hljs-built_in\">string</span> &amp; {};\n    weakEtags?: <span class=\"hljs-built_in\">boolean</span>;\n    weakCompare?: <span class=\"hljs-built_in\">boolean</span>;\n    handleOptionsMethod?: <span class=\"hljs-built_in\">boolean</span>;\n  }) =&gt; <span class=\"hljs-built_in\">any</span>;\n}\n</code></pre>\n<p data-nodeid=\"17603\">在上述示例中，我们通过 declare module 补齐了 ecstatic 类型声明，这样在引入 ecstatic 的时候就不会再提示一个 ts(2307) 的错误了。同时，IDE 还能自动补全。</p>\n<p data-nodeid=\"17604\">很多时候因为类型声明补全的成本较高，所以我们也可以通过一行 “declare module 'ecstatic';”快速绕过 ts(2307) 错误提示。</p>\n<blockquote data-nodeid=\"17605\">\n<p data-nodeid=\"17606\">注意：在业务实践中，如果碰到某个模块缺失类型声明文件，则会提示一个 ts(2307) 的错误，此时我们可以先尝试通过 npm i @types/模块名 -D 安装可能存在的第三方补齐类型声明。如果找不到，再通过 declare module 手动补齐。</p>\n</blockquote>\n<p data-nodeid=\"17607\">接下来，我们在<strong data-nodeid=\"17760\">src/http-serve.ts</strong>中实现主逻辑。</p>\n<p data-nodeid=\"17608\">首先，我们约定模块接收的参数及需要对外暴露的接口，如下示例：</p>\n<pre class=\"lang-typescript\" data-nodeid=\"17609\"><code data-language=\"typescript\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">interface</span> IHttpServerOptions {\n  <span class=\"hljs-comment\">/** 静态文件目录，默认是当前目录 */</span>\n  root?: <span class=\"hljs-built_in\">string</span>;\n  <span class=\"hljs-comment\">/** 缓存时间 */</span>\n  cache?: <span class=\"hljs-built_in\">number</span>;\n}\n<span class=\"hljs-comment\">/** 对外暴露的方法 */</span>\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">interface</span> IHttpServer {\n  <span class=\"hljs-comment\">/** 启动服务 */</span>\n  listen(port: <span class=\"hljs-built_in\">number</span>): <span class=\"hljs-built_in\">void</span>;\n  <span class=\"hljs-comment\">/** 关闭服务 */</span>\n  close(): <span class=\"hljs-built_in\">void</span>;\n}\n</code></pre>\n<p data-nodeid=\"17610\">因为这里仅仅需要支持设置文件目录、缓存时间这两个配置项，所以示例第 1～6 行中我们定义的接口类型 IHttpServerOptions 即可满足需求。然后，在第 9～14 行，我们约定了实例对外暴露接收端口参数的 listen 和没有参数的 close 两个方法。</p>\n<p data-nodeid=\"17611\">以上定义的接口都可以通过 export 关键字对外导出，并基于接口约定实现主逻辑类 HttpServer，如下代码所示：</p>\n<pre class=\"lang-typescript\" data-nodeid=\"17612\"><code data-language=\"typescript\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-keyword\">class</span> HttpServer <span class=\"hljs-keyword\">implements</span> IHttpServer {\n  <span class=\"hljs-keyword\">private</span> server: http.Server;\n  <span class=\"hljs-keyword\">constructor</span>(<span class=\"hljs-params\">options: IHttpServerOptions</span>) {\n    <span class=\"hljs-keyword\">const</span> root = options.root || process.cwd();\n    <span class=\"hljs-keyword\">this</span>.server = http.createServer(ecstatic({\n      root,\n      cache: options.cache === <span class=\"hljs-literal\">undefined</span> ? <span class=\"hljs-number\">3600</span> : options.cache,\n      showDir: <span class=\"hljs-literal\">true</span>,\n      defaultExt: <span class=\"hljs-string\">'html'</span>,\n      gzip: <span class=\"hljs-literal\">true</span>,\n      contentType: <span class=\"hljs-string\">'application/octet-stream'</span>,\n    }));\n  }\n  <span class=\"hljs-keyword\">public</span> listen(port: <span class=\"hljs-built_in\">number</span>) {\n    <span class=\"hljs-keyword\">this</span>.server.listen(port);\n  }\n  <span class=\"hljs-keyword\">public</span> close() {\n    <span class=\"hljs-keyword\">this</span>.server.close();\n  };\n}\n</code></pre>\n<p data-nodeid=\"17613\">在示例中的第 1 行，我们定义了 HttpServer 类，它实现了 IHttpServer 接口约定。在第 15～21 行，我们实现了公共开放的 listen 和 close 方法。在第 2 行，因为 HttpServer 的 server 属性是  http.Server 的实例，并且我们希望它对外不可见，所以被标注为成了 private 属性。</p>\n<p data-nodeid=\"17614\">在第 3～13 行，HttpServer 类的构造器函数接收了 IHttpServerOptions 接口约定的参数，并调用 Node.js 原生 http 模块创建了 Server 实例，再赋值给 server 属性。</p>\n<p data-nodeid=\"17615\">最后，为了让 TypeScript 代码可以在 ts-node 中顺利跑起来，我们可以在 src/http-serve.ts 引入模块依赖之前，显式地引入手动补齐的缺失的类型声明文件，如下代码所示：</p>\n<pre class=\"lang-typescript\" data-nodeid=\"17616\"><code data-language=\"typescript\"><span class=\"hljs-comment\">/// &lt;reference path=\"../types.d.ts\" /&gt;</span>\n<span class=\"hljs-keyword\">import</span> http <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'http'</span>;\n<span class=\"hljs-keyword\">import</span> ecstatic <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'ecstatic'</span>;\n</code></pre>\n<p data-nodeid=\"17617\">在示例中的第 1 行，我们通过相对路径引入了前面定义的 types.d.ts 类型声明。</p>\n<p data-nodeid=\"17618\">接下来，我们基于上边实现的 http-serve.ts 和 commander 模块编码实现 src/cli.ts，具体示例如下：</p>\n<pre class=\"lang-typescript\" data-nodeid=\"17619\"><code data-language=\"typescript\"><span class=\"hljs-keyword\">import</span> { program } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'commander'</span>;\n<span class=\"hljs-keyword\">import</span> HttpServer, { IHttpServerOptions } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'./http-serve'</span>;\nprogram\n  .option(<span class=\"hljs-string\">'--cache, &lt;cache&gt;'</span>, <span class=\"hljs-string\">'设置缓存时间，秒数'</span>)\n  .option(<span class=\"hljs-string\">'--root, &lt;root&gt;'</span>, <span class=\"hljs-string\">'静态文件目录'</span>)\n  .option(<span class=\"hljs-string\">'-p, --port, &lt;port&gt;'</span>, <span class=\"hljs-string\">'监听端口'</span>, <span class=\"hljs-string\">'3000'</span>)\n  .action(<span class=\"hljs-function\">(<span class=\"hljs-params\">options: Omit&lt;IHttpServerOptions, 'cache'&gt; &amp; { cache?: <span class=\"hljs-built_in\">string</span>; port: <span class=\"hljs-built_in\">string</span> }</span>) =&gt;</span> {\n    <span class=\"hljs-keyword\">const</span> { root, cache, port } = options;\n    <span class=\"hljs-keyword\">const</span> server = <span class=\"hljs-keyword\">new</span> HttpServer({\n      root,\n      cache: cache &amp;&amp; <span class=\"hljs-built_in\">parseInt</span>(cache)\n    });\n    server.listen(+port);\n    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">`监听 <span class=\"hljs-subst\">${port}</span>`</span>);\n  });\nprogram.parse(process.argv);\n</code></pre>\n<p data-nodeid=\"17620\">在示例中的第 5～7 行，首先我们指定了 CLI 支持的参数（commander 的更多用法可以查看其官方文档）。然后，在第 8 行我们通过 Omit 工具类型剔除了 IHttpServerOptions 接口中的 cache 属性，并重新构造 options 参数的类型。最后，在第 10～14 行我们创建了 HttpServer 的实例，并在指定端口启动了服务侦听。</p>\n<p data-nodeid=\"17621\">接下来我们可以通过 npm start 直接运行 src/cli.ts 或通过 npm run build 将 TypeScript 代码转译为 JavaScript 代码，并运行 node lib/cli.js 启动静态服务，浏览器访问服务效果图如下：</p>\n<p data-nodeid=\"24960\" class=\"\"><img src=\"https://s0.lgstatic.com/i/image6/M00/49/B6/CioPOWDcIQOAK0rcAAIAVQXojdE355.png\" alt=\"Drawing 0.png\" data-nodeid=\"24963\"></p>\n\n<p data-nodeid=\"17623\">在实际的开发过程中，我们肯定会碰到各种错误，不可能那么顺利。<strong data-nodeid=\"17776\">因此，在定位错误时，我们除了可以结合之前介绍的 TypeScript 常见错误等实用技能之外，还可以通过 VS Code 免转译直接调试源码。</strong></p>\n<p data-nodeid=\"17624\"><strong data-nodeid=\"17780\">下面我们一起看看如何使用 VS Code 调试源码。</strong></p>\n<h4 data-nodeid=\"17625\">使用 VS Code 调试</h4>\n<p data-nodeid=\"17626\">首先，我们需要给当前项目创建一个配置文件，具体操作方法为通过 VS Code 左侧或者顶部菜单 Run 选项添加或在 .vscode 目录中手动添加 launch.json，如图例所示：</p>\n<p data-nodeid=\"25554\" class=\"\"><img src=\"https://s0.lgstatic.com/i/image6/M00/49/AD/Cgp9HWDcIQqAemuKAAwOfFNd21o140.png\" alt=\"Drawing 1.png\" data-nodeid=\"25557\"></p>\n\n<p data-nodeid=\"17628\">然后，我们将以下配置添加到 launch.json 文件中。</p>\n<pre class=\"lang-typescript\" data-nodeid=\"17629\"><code data-language=\"typescript\">{\n  <span class=\"hljs-string\">\"version\"</span>: <span class=\"hljs-string\">\"0.2.0\"</span>,\n  <span class=\"hljs-string\">\"configurations\"</span>: [\n    {\n      <span class=\"hljs-string\">\"type\"</span>: <span class=\"hljs-string\">\"node\"</span>,\n      <span class=\"hljs-string\">\"request\"</span>: <span class=\"hljs-string\">\"launch\"</span>,\n      <span class=\"hljs-string\">\"name\"</span>: <span class=\"hljs-string\">\"http-serve/cli\"</span>,\n      <span class=\"hljs-string\">\"runtimeArgs\"</span>: [<span class=\"hljs-string\">\"-r\"</span>, <span class=\"hljs-string\">\"ts-node/register\"</span>],\n      <span class=\"hljs-string\">\"args\"</span>: [<span class=\"hljs-string\">\"${workspaceFolder}/src/cli.ts\"</span>]\n    }\n  ]\n}\n</code></pre>\n<p data-nodeid=\"17630\">在上述配置中，我们唤起了 node 服务，并通过预载 ts-node/register 模块让 node 可以解析执行 TypeScript 文件（转译过程对使用者完全透明）。</p>\n<p data-nodeid=\"17631\">此时，我们可以在源文件中添加断点，并点击 Run 运行调试，如图例所示：</p>\n<p data-nodeid=\"26152\" class=\"\"><img src=\"https://s0.lgstatic.com/i/image6/M00/49/AD/Cgp9HWDcIRKAFCLmAAdLT9Jo0xw822.png\" alt=\"Drawing 2.png\" data-nodeid=\"26155\"></p>\n\n<p data-nodeid=\"17633\">TypeScript 并不是万能的，虽然它可以帮助我们减少低级错误，但是并不能取代单元测试。因此，我们有必要介绍一个单元测试的内容。</p>\n<h4 data-nodeid=\"17634\">单元测试</h4>\n<p data-nodeid=\"17635\">一个健壮的项目往往离不开充分的单元测试，接下来我们将学习如何使用 TypeScript + Jest 为 http-serve 模块编写单测。</p>\n<p data-nodeid=\"17636\">在前面的步骤中，我们已经安装了 Jest 相关的依赖，并且配置好了 npm run test 命令，此时可以在项目的根目录下通过如下代码新建一个 jest.config.js 配置。</p>\n<pre class=\"lang-javascript\" data-nodeid=\"17637\"><code data-language=\"javascript\"><span class=\"hljs-built_in\">module</span>.exports = {\n  <span class=\"hljs-attr\">collectCoverageFrom</span>: [<span class=\"hljs-string\">'src/**/*.{ts}'</span>],\n  <span class=\"hljs-attr\">setupFiles</span>: [<span class=\"hljs-string\">'&lt;rootDir&gt;/__tests__/setup.ts'</span>],\n  <span class=\"hljs-attr\">testMatch</span>: [<span class=\"hljs-string\">'&lt;rootDir&gt;/__tests__/**/?(*.)(spec|test).ts'</span>],\n  <span class=\"hljs-attr\">testEnvironment</span>: <span class=\"hljs-string\">'node'</span>,\n  <span class=\"hljs-attr\">testURL</span>: <span class=\"hljs-string\">'http://localhost:4444'</span>,\n  <span class=\"hljs-attr\">transform</span>: {\n    <span class=\"hljs-string\">'^.+\\\\.ts$'</span>: <span class=\"hljs-string\">'ts-jest'</span>\n  },\n  <span class=\"hljs-attr\">transformIgnorePatterns</span>: [\n    <span class=\"hljs-string\">'[/\\\\\\\\]node_modules[/\\\\\\\\].+\\\\.(js|jsx|mjs|ts|tsx)$'</span>,\n  ],\n  <span class=\"hljs-attr\">moduleNameMapper</span>: {},\n  <span class=\"hljs-attr\">moduleFileExtensions</span>: [<span class=\"hljs-string\">'js'</span>, <span class=\"hljs-string\">'ts'</span>],\n  <span class=\"hljs-attr\">globals</span>: {\n    <span class=\"hljs-string\">'ts-jest'</span>: {\n      <span class=\"hljs-attr\">tsConfig</span>: <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'path'</span>).join(process.cwd(), <span class=\"hljs-string\">'tsconfig.test.json'</span>),\n    },\n  },\n};\n</code></pre>\n<p data-nodeid=\"27364\" class=\"\">在配置文件中的第 3 行，我们指定了 setupFiles（需要手动创建 __tests__/setup.ts）初始化单元测试运行环境、加载 polyfill 模块等。在第 4 行，我们指定了查找单测文件的规则。在第 8 行，我们指定了使用 ts-jest 转译 *.ts 文件。在第 16～18 行，我们配置了 ts-jest 基于项目目录下的 tsconfig.test.json 转译为 TypeScript。</p>\n\n\n<p data-nodeid=\"17639\">一般来说，运行 Node.js 端的模块转译单测代码使用的 tsconfig.test.json 配置和转译生成代码使用的 tsconfig.prod.json 配置完全一样，因此我们可以直接将 tsconfig.prod.json 复制到 tsconfig.test.json。</p>\n<blockquote data-nodeid=\"17640\">\n<p data-nodeid=\"17641\">注意：以上配置文件依赖 jest@24、ts-jest@24 版本。</p>\n</blockquote>\n<p data-nodeid=\"28579\" class=\"te-preview-highlight\">配置好 Jest 后，我们就可以把 http-serve 模块单元测试编入\\ <em data-nodeid=\"28588\">_tests</em>_/http-serve.test.ts 中，具体示例如下（更多的 Jest 使用说明，请查看官方文档）：</p>\n\n\n<pre class=\"lang-typescript\" data-nodeid=\"17643\"><code data-language=\"typescript\"><span class=\"hljs-keyword\">import</span> http <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'http'</span>;\n<span class=\"hljs-keyword\">import</span> HttpServer <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\"../src/http-serve\"</span>;\ndescribe(<span class=\"hljs-string\">'http-serve'</span>, <span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> {\n  <span class=\"hljs-keyword\">let</span> server: HttpServer;\n  beforeEach(<span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> {\n    server = <span class=\"hljs-keyword\">new</span> HttpServer({});\n    server.listen(<span class=\"hljs-number\">8099</span>);\n  });\n  afterEach(<span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> {\n    server.close();\n  });\n  it(<span class=\"hljs-string\">'should listen port'</span>, <span class=\"hljs-function\">(<span class=\"hljs-params\">done</span>) =&gt;</span> {\n    http.request({\n      method: <span class=\"hljs-string\">'GET'</span>,\n      hostname: <span class=\"hljs-string\">'localhost'</span>,\n      port: <span class=\"hljs-number\">8099</span>,\n    }).end(<span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> {\n      done();\n    })\n  });\n});\n</code></pre>\n<p data-nodeid=\"17644\">在示例中的第 6～9 行，我们定义了每个 it 单测开始之前，需要先创建一个 HttpServer 实例，并监听 8099 端口。在第 10～12 行，我们定义了每个 it 单测结束后，需要关闭 HttpServer 实例。在第 13～21 行，我们定义了一个单测，它可以通过发起 HTTP 请求来验证 http-serve 模块功能是否符合预期。</p>\n<blockquote data-nodeid=\"17645\">\n<p data-nodeid=\"17646\"><strong data-nodeid=\"17813\">注意</strong>：源码中使用的路径别名，比如用“@/module”代替“src/sub-directory/module”，这样可以缩短引用路径，这就需要我们调整相应的配置。</p>\n</blockquote>\n<p data-nodeid=\"17647\">下面我们讲解一下啊如何处理路径别名。</p>\n<h4 data-nodeid=\"17648\">处理路径别名</h4>\n<p data-nodeid=\"17649\">首先，我们需要在 tsconfig.json 中添加如下所示 paths 配置，这样 TypeScript 就可以解析别名模块。</p>\n<pre class=\"lang-json\" data-nodeid=\"17650\"><code data-language=\"json\">{\n  \"compilerOptions\": {\n    ...,\n    \"baseUrl\": \"./\",\n    \"paths\": {\n      \"@/*\": [\"src/sub-directory/*\"]\n    },   \n    ...\n  }\n}\n</code></pre>\n<blockquote data-nodeid=\"17651\">\n<p data-nodeid=\"17652\">注意：需要显式设置 baseUrl，不然会提示一个无法解析相对路径的错误。</p>\n</blockquote>\n<p data-nodeid=\"17653\">接下来我们在 jest.config.js 中通过如下代码配置相应的规则，告知 Jest 如何解析别名模块。</p>\n<pre class=\"lang-javascript\" data-nodeid=\"17654\"><code data-language=\"javascript\"><span class=\"hljs-built_in\">module</span>.exports = {\n  ...,\n  <span class=\"hljs-attr\">moduleNameMapper</span>: {\n    <span class=\"hljs-string\">'^@/(.*)$'</span>: <span class=\"hljs-string\">'&lt;rootDir&gt;/src/sub-directory/$1'</span>\n  },\n  ...\n}\n</code></pre>\n<p data-nodeid=\"17655\">因为 tsc 在转译代码的时候不会把别名替换成真实的路径，所以我们引入额外的工具处理别名。此时我们可以按照如下命令安装 tsc-alias 和 tsconfig-paths 分别供 tsc 和 ts-node 处理别名。</p>\n<pre class=\"lang-java\" data-nodeid=\"17656\"><code data-language=\"java\">npm install tsc-alias -D;\nnpm install tsconfig-paths -D;\n</code></pre>\n<p data-nodeid=\"17657\">最后，我们需要修改 package.json scripts 配置，如下代码所示：</p>\n<pre class=\"lang-json\" data-nodeid=\"17658\"><code data-language=\"json\">{\n  ...,\n  \"scripts\": {\n    \"build\": \"tsc -p tsconfig.prod.json &amp;&amp; tsc-alias -p tsconfig.prod.json\",\n    \"start\": \"node -r tsconfig-paths/register -r ts-node/register src/cli.ts\",\n    ...\n  },\n  ...\n}\n</code></pre>\n<p data-nodeid=\"17659\">tsc 构建转译之后，第 4 行的 build 命令会使用 tsc-alias 将别名替换成相对路径。在载入 ts-node/register 模块之前，第 5 行会预载 tsconfig-paths/register，这样 ts-node 也可以解析别名了。</p>\n<p data-nodeid=\"17660\">当然，除了选择官方工具 tsc 之外，我们也可以选择其他的工具构建 TypeScript 代码，比如说 Rollup、Babel 等，因篇幅有限，这里就不做深入介绍了。</p>\n<h3 data-nodeid=\"17661\">小结和预告</h3>\n<p data-nodeid=\"17662\">以上就是使用 TypeScript 开发一个简单静态文件服务 NPM 模块的全过程，我们充分利用了 TypeScript 生态中的各种工具和特性。</p>\n<p data-nodeid=\"17663\">关于如何开发基于 TypeScript 的 Node.js 模块和服务，我在下面也总结了一些建议。</p>\n<ul data-nodeid=\"17664\">\n<li data-nodeid=\"17665\">\n<p data-nodeid=\"17666\">export 导出模块内的所有必要的类型定义，可以帮助我们减少 ts(4023) 错误。</p>\n</li>\n<li data-nodeid=\"17667\">\n<p data-nodeid=\"17668\">我们可以开启 importHelpers 配置，公用 tslib 替代内联 import 等相关 polyfill 代码，从而大大减小生成代码的体积，配置示例如下：</p>\n</li>\n</ul>\n<pre class=\"lang-typescript\" data-nodeid=\"17669\"><code data-language=\"typescript\">{\n  <span class=\"hljs-string\">\"extends\"</span>: <span class=\"hljs-string\">\"./tsconfig.json\"</span>,\n  <span class=\"hljs-string\">\"compilerOptions\"</span>: {\n    <span class=\"hljs-string\">\"importHelpers\"</span>: <span class=\"hljs-literal\">true</span>\n  },\n  <span class=\"hljs-string\">\"exclude\"</span>: [<span class=\"hljs-string\">\"__tests__\"</span>, <span class=\"hljs-string\">\"lib\"</span>]\n}\n</code></pre>\n<p data-nodeid=\"17670\">如以上示例第 4 行，配置 importHelpers 为 true，<strong data-nodeid=\"17832\">此时一定要把 tslib 加入模块依赖中：</strong></p>\n<pre class=\"lang-powershell\" data-nodeid=\"17671\"><code data-language=\"powershell\">npm install tslib <span class=\"hljs-literal\">-S</span>; // 安装 tslib 依赖\n</code></pre>\n<ul data-nodeid=\"17672\">\n<li data-nodeid=\"17673\">\n<p data-nodeid=\"17674\">确保 tsconfig.test.json 和 tsconfig.prod.json 中代码转译相关的配置尽可能一致，避免逻辑虽然通过了单测，但是构建之后运行提示错误。</p>\n</li>\n<li data-nodeid=\"17675\">\n<p data-nodeid=\"17676\">慎用 import * as ModuleName，因为较低版本的 tslib 实现的 __importStar 补丁有 bug。如果模块 export 是类的实例，经 __importStar 处理后，会造成实例方法丢失。另外一个建议是避免直接 export 一个类的实例，如下代码所示：</p>\n</li>\n</ul>\n<pre class=\"lang-javascript\" data-nodeid=\"17677\"><code data-language=\"javascript\">exports = <span class=\"hljs-built_in\">module</span>.exports = <span class=\"hljs-keyword\">new</span> Command(); <span class=\"hljs-comment\">// bad</span>\n</code></pre>\n<ul data-nodeid=\"17678\">\n<li data-nodeid=\"17679\">\n<p data-nodeid=\"17680\">推荐使用完全支持 TypeScript 的 NestJS 框架开发企业级 Node.js 服务端应用。</p>\n</li>\n</ul>\n<p data-nodeid=\"17681\">插播一道思考题：请对这一讲中的静态文件服务示例进行改造，并为 HttpServer 类及 CLI 添加更多的可配置项，然后通过 VS Code 源码调试及其他章节的经验解决改造过程中碰到的问题。</p>\n<p data-nodeid=\"17682\">19 讲我们将学习 TypeScript 在 Web 端应用开发中的实践，敬请期待。</p>\n<p data-nodeid=\"17683\">另外，如果你觉得本专栏有价值，欢迎分享给更多好友。</p>",
                "article_title": "18 | 手把手教你使用 TypeScript 开发 Node.js 应用",
                "title": "18 | 手把手教你使用 TypeScript 开发 Node.js 应用",
                "id": 7450
            },
            {
                "content": "<p data-nodeid=\"22179\">18 讲我们学习了如何使用 TypeScript 开发运行 Node.js 端的静态文件服务模块，然而对于大多数的前端人而言，Web 端可能才是主战场。因此，这一讲我们将从 DOM 原生操作和 React 框架这两个方面学习 Web + TypeScript 开发实践。</p>\n<blockquote data-nodeid=\"22180\">\n<p data-nodeid=\"22181\">学习建议：请按照这一讲中的操作步骤，实践一个完整的开发流程。</p>\n</blockquote>\n<h3 data-nodeid=\"22182\">DOM 原生操作</h3>\n<p data-nodeid=\"22183\">无论我们使用前端框架与否，都免不了需要使用原生操作接口，因此将 TypeScript 与 DOM 原生操作组合起来进行学习很有必要。</p>\n<p data-nodeid=\"22184\">接下来，我们通过手写一个简单的待办管理应用来熟悉常见的操作接口。</p>\n<h4 data-nodeid=\"22185\">配置项目</h4>\n<p data-nodeid=\"22186\">首先，我们可以参照 18 讲中初始化 Node.js 模块的步骤创建一个 todo-web 项目，并安装 TypeScript 依赖。</p>\n<p data-nodeid=\"22187\">然后，我们可以按需调整 lib 和 alwaysStrict 参数配置 tsconfig，如下所示：</p>\n<pre class=\"lang-json\" data-nodeid=\"22188\"><code data-language=\"json\">{\n  \"compilerOptions\": {\n    ...,\n    \"target\": \"es5\",\n    \"lib\": [\"ESNext\", \"DOM\"],                \n    \"strict\": true,                       \n    \"alwaysStrict\": false,\n    ...           \n  }\n}\n</code></pre>\n<p data-nodeid=\"22189\">在以上配置的第 4 行，我们设置了 tagert 参数是“es5”。在第 5 行，我们设置了 lib 参数为 \"ESNext\" 和 \"DOM\"。这样，我们就可以在 TypeScript 中使用最新的语言特性了（比如 Promise.any 等）。</p>\n<blockquote data-nodeid=\"22190\">\n<p data-nodeid=\"22191\"><strong data-nodeid=\"22320\">注意</strong>：因为设置了 target es5，所以这里我们还需要手动引入 ts-polyfill 为新特性打补丁，以兼容较低版本的浏览器。</p>\n</blockquote>\n<p data-nodeid=\"22192\">此外，如果我们想在函数中使用 this，则可以把 alwaysStrict 设置为 false，这样生成的代码中就不会有“use strict”（关闭严格模式）了。</p>\n<p data-nodeid=\"22193\">配置好项目后，我们开始进行编码实现。</p>\n<h4 data-nodeid=\"22194\">编码实现</h4>\n<p data-nodeid=\"22195\">首先我们可以创建一个模型 src/model.ts，用来维护待办数据层的增删操作，具体示例如下：</p>\n<pre class=\"lang-typescript\" data-nodeid=\"22196\"><code data-language=\"typescript\"><span class=\"hljs-keyword\">class</span> TodoModel {\n  <span class=\"hljs-keyword\">private</span> gid: <span class=\"hljs-built_in\">number</span> = <span class=\"hljs-number\">0</span>;\n  <span class=\"hljs-keyword\">public</span> add = <span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> <span class=\"hljs-keyword\">this</span>.gid++;\n  <span class=\"hljs-keyword\">public</span> remove = <span class=\"hljs-function\">(<span class=\"hljs-params\">id: <span class=\"hljs-built_in\">number</span></span>) =&gt;</span> <span class=\"hljs-built_in\">void</span> <span class=\"hljs-number\">0</span>\n}\n<span class=\"hljs-keyword\">declare</span> <span class=\"hljs-keyword\">var</span> todoModel: TodoModel;\ntodoModel = <span class=\"hljs-keyword\">new</span> TodoModel;\n</code></pre>\n<p data-nodeid=\"22197\">在上述示例中，我们定义了模型 TodoModel（示例中仅仅实现了架子，你可以按需丰富这个示例），并在第 7~8 行把模型实例赋值给了全局变量 todoModel。</p>\n<p data-nodeid=\"22198\">接下来我们开始实现 src/view.ts，用来维护视图层操作 Dom 逻辑，具体示例如下：</p>\n<pre class=\"lang-typescript\" data-nodeid=\"22199\"><code data-language=\"typescript\"><span class=\"hljs-keyword\">const</span> list = <span class=\"hljs-built_in\">document</span>.getElementById(<span class=\"hljs-string\">'todo'</span>) <span class=\"hljs-keyword\">as</span> HTMLUListElement | <span class=\"hljs-literal\">null</span>;\n<span class=\"hljs-keyword\">const</span> addButton = <span class=\"hljs-built_in\">document</span>.querySelector&lt;HTMLButtonElement&gt;(<span class=\"hljs-string\">'#add'</span>);\naddButton?.addEventListener(<span class=\"hljs-string\">'click'</span>, add);\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">remove</span>(<span class=\"hljs-params\"><span class=\"hljs-keyword\">this</span>: HTMLButtonElement, id: <span class=\"hljs-built_in\">number</span></span>) </span>{\n  <span class=\"hljs-keyword\">const</span> todo = <span class=\"hljs-keyword\">this</span>.parentElement;\n  todo &amp;&amp; list?.removeChild(todo) &amp;&amp; todoModel.remove(id);\n}\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">add</span>(<span class=\"hljs-params\"></span>) </span>{\n  <span class=\"hljs-keyword\">const</span> id = todoModel.add();\n  <span class=\"hljs-keyword\">const</span> todoEle = <span class=\"hljs-built_in\">document</span>.createElement(<span class=\"hljs-string\">'li'</span>);\n  todoEle.innerHTML = <span class=\"hljs-string\">`待办 <span class=\"hljs-subst\">${id}</span> &lt;button&gt;删除&lt;/button&gt;`</span>;\n  <span class=\"hljs-keyword\">const</span> button = todoEle.getElementsByTagName(<span class=\"hljs-string\">'button'</span>)[<span class=\"hljs-number\">0</span>];\n  button.style.color = <span class=\"hljs-string\">'red'</span>;\n  <span class=\"hljs-keyword\">if</span> (button) {\n    button.onclick = remove.bind(button, id);\n  }\n  list?.appendChild(todoEle);\n}\n</code></pre>\n<p data-nodeid=\"22200\">上述示例中，我们在 tsconfig 的 lib 参数中添加了 DOM（如果 lib 参数缺省，则默认包含了  DOM；如果显式设置了 lib 参数，那么一定要添加 DOM），TypeScript 便会自动引入内置的 DOM 类型声明（node_modules/typescript/lib/lib.dom.d.ts），这样所有的 DOM 原生操作都将支持静态类型检测。</p>\n<p data-nodeid=\"22201\">在第 1 行，我们把通过 id 获取 HTMLElement | null 类型的元素断言为 HTMLUListElement | null，这是因为 HTMLUListElement 是 HTMLElement 的子类型。同样，第 6 行、12 行、14 行的相关元素都也有明确类型。尤其是第 12 行的 createElement、第 14 行的 getElementsByTagName，它们都可以根据标签名返回更确切的元素类型 HTMLLIElement、HTMLButtonElement。</p>\n<p data-nodeid=\"22202\">然后，在第 2 行我们通过给 querySelector 指定了明确的类型入参，其获取的元素类型也就变成了更明确的 HTMLButtonElement。</p>\n<p data-nodeid=\"22203\">此外，因为 DOM 元素的 style 属性也支持静态类型检测，所以我们在第 15 行可以把字符串 'red' 赋值给 color。但是，如果我们把数字 1 赋值给 color，则会提示一个 ts(2322) 错误。</p>\n<p data-nodeid=\"22204\">接下来，我们就可以转译代码，并新建一个 index.html 引入转译后的 lib/model.js、lib/view.js 中，再使用 19 讲中开发的 http-serve CLI 启动服务预览页面。</p>\n<p data-nodeid=\"22205\">通过这个简单的例子，我们感受到了 TypeScript 对 DOM 强大的支持，并且官方也根据 JavaScript 的发展十分及时地补齐了新语法特性。因此，即便开发原生应用，TypeScript 也会是一个不错的选择。</p>\n<p data-nodeid=\"22206\">接下来，我们将学习 TypeScript 与前端主流框架 React 的搭配使用。</p>\n<h3 data-nodeid=\"22207\">React 框架</h3>\n<p data-nodeid=\"22208\" class=\"\">React 作为目前非常流行的前端框架，TypeScript 对其支持也是超级完善。在 1.6 版本中，TypeScript 官方专门实现了对 React JSX 语法的静态类型支持，并在 tsconfig 中新增了一个 jsx 参数用来定制 JSX 的转译规则。</p>\n<p data-nodeid=\"22209\">而且，React 官方及周边生态对 TypeScript 的支持也越来越完善，比如 create-react-app 支持 TypeScript 模板、babel 支持转译 TypeScript。要知道，在 2018 年我们还需要手动搭建 TypeScript 开发环境，现在通过以下命令即可快速创建 TypeScript 应用，并且还不用过分关心 tsconfig 和开发构建相关的配置，只需把重心放在 React 和 TypeScript 的使用上（坏处则是修改默认配置会比较麻烦）。</p>\n<pre class=\"lang-powershell\" data-nodeid=\"22210\"><code data-language=\"powershell\">npm i create<span class=\"hljs-literal\">-react</span><span class=\"hljs-literal\">-app</span> <span class=\"hljs-literal\">-g</span>;\ncreate<span class=\"hljs-literal\">-react</span><span class=\"hljs-literal\">-app</span> my<span class=\"hljs-literal\">-ts</span><span class=\"hljs-literal\">-app</span> -<span class=\"hljs-literal\">-template</span> typescript;\n<span class=\"hljs-built_in\">cd</span> my<span class=\"hljs-literal\">-ts</span><span class=\"hljs-literal\">-app</span>;\nnpm <span class=\"hljs-built_in\">start</span>; // 或者 yarn <span class=\"hljs-built_in\">start</span>\n</code></pre>\n<p data-nodeid=\"22211\">接下来我们将分别从 Service、Component、状态管理这三个分层介绍 TypeScript 在 React App 开发中的实践。</p>\n<h4 data-nodeid=\"22212\">Service 类型化</h4>\n<p data-nodeid=\"22213\">首先我们介绍的是 TypeScript 在 Service 层的应用，称之为 Service 类型化，实际就是把 JavaScript 编写的接口调用代码使用 TypeScript 实现。</p>\n<p data-nodeid=\"22214\">举个例子， 以下是使用 JavaScript 编写的 getUserById 方法：</p>\n<pre class=\"lang-javascript\" data-nodeid=\"22215\"><code data-language=\"javascript\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> getUserById = <span class=\"hljs-function\"><span class=\"hljs-params\">id</span> =&gt;</span> fetch(<span class=\"hljs-string\">`/api/get/user/by/<span class=\"hljs-subst\">${id}</span>`</span>, { <span class=\"hljs-attr\">method</span>: <span class=\"hljs-string\">'GET'</span> });\n</code></pre>\n<p data-nodeid=\"22216\">在这个示例中，除了知道参数名 id 以外，我们对该方法接收参数、返回数据的类型和格式一无所知。</p>\n<p data-nodeid=\"22217\">以上示例换成 TypeScript 实现后效果如下：</p>\n<pre class=\"lang-typescript\" data-nodeid=\"22218\"><code data-language=\"typescript\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> getUserById = (id: <span class=\"hljs-built_in\">number</span>): <span class=\"hljs-built_in\">Promise</span>&lt;{ id: <span class=\"hljs-built_in\">number</span>; name: <span class=\"hljs-built_in\">string</span> }&gt; =&gt;\n  fetch(<span class=\"hljs-string\">`/api/get/user/by/<span class=\"hljs-subst\">${id}</span>`</span>, { method: <span class=\"hljs-string\">'GET'</span> }).then(<span class=\"hljs-function\"><span class=\"hljs-params\">res</span> =&gt;</span> res.json());\n<span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">test</span>(<span class=\"hljs-params\"></span>) </span>{\n  <span class=\"hljs-keyword\">const</span> { id2, name } = <span class=\"hljs-keyword\">await</span> getUserById(<span class=\"hljs-string\">'string'</span>); <span class=\"hljs-comment\">// ts(2339) ts(2345)</span>\n} \n</code></pre>\n<p data-nodeid=\"22219\">在使用 TypeScript 的示例中，我们可以清楚地知道 getUserById 方法接收了一个不可缺省、number 类型的参数 id，返回的数据是一个异步的包含数字类型属性 id 和字符串类型属性 name 的对象。而且如果我们错误地调用该方法，比如第 5 行解构了一个不存在的属性 id2，就提示了一个 ts(2339) 错误，入参 'string' 类型不匹配也提示了一个 ts(2345) 错误。</p>\n<p data-nodeid=\"22220\">通过两个示例的对比，Service 类型化的优势十分明显。</p>\n<p data-nodeid=\"22221\">但是，在实际项目中，我们需要调用的接口少则数十个，多则成百上千，如果想通过手写 TypeScript 代码的方式定义清楚参数和返回值的类型结构，肯定不是一件轻松的事情。此时，我们可以借助一些工具，并基于格式化的接口文档自动生成 TypeScript 接口调用代码。</p>\n<p data-nodeid=\"22222\">在业务实践中，前后端需要约定统一的接口规范，并使用格式化的 Swagger 或者 YAPI 等方式定义接口格式，然后自动生成 TypeScript 接口调用代码。目前，这块已经有很多成熟、开源的技术方案，例如<a href=\"https://swagger.io/tools/swagger-codegen/\" data-nodeid=\"22361\">Swagger Codegen</a>、<a href=\"https://github.com/acacode/swagger-typescript-api\" data-nodeid=\"22365\">swagger-typescript-api</a>、<a href=\"https://gogoyqj.github.io/auto-service/\" data-nodeid=\"22369\">Autos</a>、<a href=\"https://github.com/fjc0k/yapi-to-typescript\" data-nodeid=\"22373\">yapi-to-typescript</a>。</p>\n<p data-nodeid=\"22223\">此外，对于前后端使用 GraphQL 交互的业务场景，我们也可以使用<a href=\"https://graphql-code-generator.com/\" data-nodeid=\"22378\">GraphQL Code Generator</a>等工具生成 TypeScript 接口调用代码。你可以通过官方文档了解这些自动化工具的更多信息，这里就不做深入介绍了。</p>\n<p data-nodeid=\"22224\"><strong data-nodeid=\"22383\">以上提到的 Service 类型化其实并未与 React 深度耦合，因此我们也可以在 Vue 或者其他框架中使用 TypeScript 手写或者基于工具生成接口调用代码。</strong></p>\n<p data-nodeid=\"22225\">接下来我们将学习 TypeScript 在 React Component 中的应用，将其称之为 Component 类型化。</p>\n<h4 data-nodeid=\"22226\">Component 类型化</h4>\n<p data-nodeid=\"22227\">Component 类型化的本质在于清晰地表达组件的属性、状态以及 JSX 元素的类型和结构。</p>\n<blockquote data-nodeid=\"22228\">\n<p data-nodeid=\"22229\">注意：TypeScript 中有专门的 .tsx 文件用来编写 React 组件，并且不能使用与 JSX 语法冲突的尖括号类型断言（“&lt;类型&gt;”）。此外，我们还需要确保安装了 @types/react、@types/react-dom 类型声明，里边定义了 React 和 ReactDOM 模块所有的接口和类型。</p>\n</blockquote>\n<p data-nodeid=\"22230\">我们首先了解一下最常用的几个接口和类型。</p>\n<p data-nodeid=\"22231\"><strong data-nodeid=\"22394\">（1）class 组件</strong></p>\n<p data-nodeid=\"22232\">所有的 class 组件都是基于****React.Component 和 React.PureComponent 基类创建的，下面我们看一个具体示例：</p>\n<pre class=\"lang-typescript\" data-nodeid=\"22233\"><code data-language=\"typescript\"><span class=\"hljs-keyword\">interface</span> IEProps {\n  Cp?: React.ComponentClass&lt;{ id?: <span class=\"hljs-built_in\">number</span> }&gt;;\n}\n<span class=\"hljs-keyword\">interface</span> IEState { id: <span class=\"hljs-built_in\">number</span>; }\n<span class=\"hljs-keyword\">const</span> ClassCp: React.ComponentClass&lt;IEProps, IEState&gt; = <span class=\"hljs-keyword\">class</span> ClassCp <span class=\"hljs-keyword\">extends</span> React.Component&lt;IEProps, IEState&gt; {\n  <span class=\"hljs-keyword\">public</span> state: IEState = { id: <span class=\"hljs-number\">1</span> };\n  render() {\n    <span class=\"hljs-keyword\">const</span> { Cp } = <span class=\"hljs-keyword\">this</span>.props <span class=\"hljs-keyword\">as</span> Required&lt;IEProps&gt;;\n    <span class=\"hljs-keyword\">return</span> &lt;Cp id={<span class=\"hljs-string\">`<span class=\"hljs-subst\">${<span class=\"hljs-keyword\">this</span>.state.id}</span>`</span>} /&gt;; <span class=\"hljs-comment\">// ts(2322)</span>\n  }\n  <span class=\"hljs-keyword\">static</span> defaultProps: Partial&lt;IEProps&gt; = {\n    Cp: <span class=\"hljs-keyword\">class</span> <span class=\"hljs-keyword\">extends</span> React.Component { render = <span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> <span class=\"hljs-literal\">null</span> }\n  }\n}\n</code></pre>\n<p data-nodeid=\"22234\">在示例中的第 5~14 行，因为 React.Component 基类接收了 IEProps 和 IEState 两个类型入参，并且类型化了 class 组件 E 的 props、state 和 defaultProps 属性，所以如果我们错误地调用了组件 props 中 Cp 属性，第 9 行就会提示一个 ts(2322) 错误。</p>\n<p data-nodeid=\"23163\" class=\"\">然后我们可以使用接口类型 React.ComponentClass 来指代所有 class 组件的类型。例如在第 5 行，我们可以把 class 组件 ClassCp 赋值给 React.ComponentClass 类型的变量 ClassCp。</p>\n\n<p data-nodeid=\"22236\" class=\"\">但在业务实践中，我们往往只使用 React.ComponentClass 来描述外部组件或者高阶组件属性的类型。比如在示例中的第 2 行，我们使用了 React.ComponentClass 描述 class 组件 E 的 Cp 属性，而不会像第 5 行那样，把定义好的 class 组件赋值给一个 React.ComponentClass 类型的变量。</p>\n<p data-nodeid=\"22237\">此外，在定义 class 组件时，使用 public/private 控制属性/方法的可见性，以及使用Readonly 标记 state、props 为只读，都是特别推荐的实践经验。</p>\n<p data-nodeid=\"22238\">下面我们看一个具体的示例：</p>\n<pre class=\"lang-typescript\" data-nodeid=\"22239\"><code data-language=\"typescript\"><span class=\"hljs-keyword\">class</span> ClassCpWithModifier <span class=\"hljs-keyword\">extends</span> React.Component&lt;Readonly&lt;IEProps&gt;, Readonly&lt;IEState&gt;&gt; {\n  <span class=\"hljs-keyword\">private</span> gid: <span class=\"hljs-built_in\">number</span> = <span class=\"hljs-number\">1</span>;\n  <span class=\"hljs-keyword\">public</span> state: Readonly&lt;IEState&gt; = { id: <span class=\"hljs-number\">1</span> };\n  render() { <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">this</span>.state.id = <span class=\"hljs-number\">2</span>; } <span class=\"hljs-comment\">// ts(2540)</span>\n}\n</code></pre>\n<p data-nodeid=\"22240\">在示例中的第 2 行，如果我们不希望对外暴露 gid 属性，就可以把它标记为 private 私有。</p>\n<p data-nodeid=\"22241\">如果我们想禁止直接修改 state、props 属性，则可以在第 1 行中使用 Readonly 包裹 IEProps、IEState。此时，如果我们在第 4 行直接给 state id 属性赋值，就会提示一个 ts(2540) 错误。</p>\n<p data-nodeid=\"22242\"><strong data-nodeid=\"22412\">函数组件</strong></p>\n<p data-nodeid=\"22243\">我们可以使用类型 React.FunctionComponent（简写为 React.FC）描述函数组件的类型。因为函数组件没有 state 属性，所以我们只需要类型化 props。</p>\n<p data-nodeid=\"22244\">下面我们看一个具体的示例：</p>\n<pre class=\"lang-typescript\" data-nodeid=\"22245\"><code data-language=\"typescript\">interface IEProps { id?: number; }\nconst ExplicitFC: React.FC&lt;IEProps&gt; = props =&gt; &lt;&gt;{props.id}&lt;/&gt;; // ok\nExplicitFC.defaultProps = { id: 1 } // ok id must be number\nconst ExplicitFCEle = &lt;ExplicitFC id={1} /&gt;; // ok id must be number\nconst ExplicitFCWithError: React.FC&lt;IEProps&gt; = props =&gt; &lt;&gt;{props.id2}&lt;/&gt;; // ts(2399)\nExplicitFCWithError.defaultProps = { id2: 1 } // ts(2332)\nconst thisIsJSX2 = &lt;ExplicitFCWithError id2={2} /&gt;; // ts(2332)\n</code></pre>\n<p data-nodeid=\"23817\" class=\"te-preview-highlight\">在上述示例中，因为我们定义了类型是 React.FC<code data-backticks=\"1\" data-nodeid=\"23819\">&lt;IEProps&gt;</code> 的组件 ExplicitFC、ExplicitFCWithError，且类型入参 IEProps 可以同时约束 props 参数和 defaultProps 属性的类型，所以第 2~4 行把 number 类型值赋予接口中已定义的 id 属性可以通过静态类型检测。但是，在第 5~7 行，因为操作了未定义的属性 id2，所以提示了 ts(2399)、 ts(2332) 错误。</p>\n\n<blockquote data-nodeid=\"22247\">\n<p data-nodeid=\"22248\">注意：函数组件返回值类型必须是 React.Element（稍后会详细介绍） 或者 null，反过来如果函数返回值类型是 React.Element 或者 null，即便未显式声明类型，函数也是合法的函数组件。</p>\n</blockquote>\n<p data-nodeid=\"22249\">如以下示例中，因为我们定义了未显式声明类型、返回值分别是 null 和 JSX 的函数 ImplicitFCReturnNull、ImplicitFCReturnJSX，所以第 3 行、第 6 行的这两个组件都可以用来创建 JSX。但是，因为第 8 行定义的返回值类型是 number 的函数 NotAFC，所以被用来创建 JSX 时会在第 9 行提示一个 ts(2786) 错误。</p>\n<pre class=\"lang-typescript\" data-nodeid=\"22250\"><code data-language=\"typescript\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">ImplicitFCReturnNull</span>(<span class=\"hljs-params\"></span>) </span>{ <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">null</span>; }\nImplicitFCReturnNull.defaultProps = { id: <span class=\"hljs-number\">1</span> }\n<span class=\"hljs-keyword\">const</span> ImplicitFCReturnNullEle = &lt;ImplicitFCReturnNull id={<span class=\"hljs-number\">1</span>} /&gt;; <span class=\"hljs-comment\">// ok id must be number</span>\n<span class=\"hljs-keyword\">const</span> ImplicitFCReturnJSX = <span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> &lt;&gt;&lt;/&gt;;\nImplicitFCReturnJSX.defaultProps = { id2: <span class=\"hljs-number\">1</span> }\n<span class=\"hljs-keyword\">const</span> ImplicitFCReturnJSXEle = &lt;ImplicitFCReturnJSX id2={<span class=\"hljs-number\">2</span>} /&gt;; <span class=\"hljs-comment\">// ok</span>\n<span class=\"hljs-comment\">/** 分界线 **/</span>\n<span class=\"hljs-keyword\">const</span> NotAFC = <span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> <span class=\"hljs-number\">1</span>; <span class=\"hljs-comment\">// </span>\n<span class=\"hljs-keyword\">const</span> WithError = &lt;NotAFC /&gt;; <span class=\"hljs-comment\">// ts(2786)</span>\n</code></pre>\n<p data-nodeid=\"22251\">对于编写函数组件而言，显式注解类型是一个好的实践，另外一个好的实践是用 props 解构代替定义 defaultProps 来指定默认属性的值。</p>\n<p data-nodeid=\"22252\">此外，组件和泛型 class、函数一样，也是可以定义成接收若干个入参的泛型组件。</p>\n<p data-nodeid=\"22253\">以列表组件为例，<strong data-nodeid=\"22430\">我们希望可以根据列表里渲染条目的类型（比如说“User”或“Todo”），分别使用不同的视图组件渲染条目，这个时候就需要使用泛型来约束表示条目类型的入参和视图渲染组件之间的类型关系。</strong></p>\n<p data-nodeid=\"22254\">下面看一个具体的示例：</p>\n<pre class=\"lang-typescript\" data-nodeid=\"22255\"><code data-language=\"typescript\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">interface</span> IUserItem {\n  username: <span class=\"hljs-built_in\">string</span>;\n}\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">RenderUser</span>(<span class=\"hljs-params\">props: IUserItem</span>): <span class=\"hljs-title\">React</span>.<span class=\"hljs-title\">ReactElement</span> </span>{\n  <span class=\"hljs-keyword\">return</span> &lt;&gt;{props.username}&lt;/&gt;\n}\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">interface</span> ITodoItem {\n  taskName: <span class=\"hljs-built_in\">string</span>;\n}\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">RenderTodo</span>(<span class=\"hljs-params\">props: ITodoItem</span>): <span class=\"hljs-title\">React</span>.<span class=\"hljs-title\">ReactElement</span> </span>{\n  <span class=\"hljs-keyword\">return</span> &lt;&gt;{props.taskName}&lt;/&gt;\n}\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">ListCp</span>&lt;<span class=\"hljs-title\">Item</span> <span class=\"hljs-title\">extends</span> </span>{}&gt;(props: { Cp: React.ComponentType&lt;Item&gt; }): React.ReactElement {\n  <span class=\"hljs-keyword\">return</span> &lt;&gt;&lt;/&gt;;\n}\n<span class=\"hljs-keyword\">const</span> UserList = &lt;ListCp&lt;IUserItem&gt; Cp={RenderUser} /&gt;; <span class=\"hljs-comment\">// ok</span>\n<span class=\"hljs-keyword\">const</span> TodoList = &lt;ListCp&lt;ITodoItem&gt; Cp={RenderTodo} /&gt;; <span class=\"hljs-comment\">// ok</span>\n<span class=\"hljs-keyword\">const</span> UserListError = &lt;ListCp&lt;ITodoItem&gt; Cp={RenderUser} /&gt;; <span class=\"hljs-comment\">// ts(2322)</span>\n<span class=\"hljs-keyword\">const</span> TodoListError = &lt;ListCp&lt;IUserItem&gt; Cp={RenderTodo} /&gt;; <span class=\"hljs-comment\">// ts(2322)</span>\n</code></pre>\n<p data-nodeid=\"22256\">在示例中的第 13 行，定义的泛型组件 ListCp 通过类型入参 Item 约束接收了 props  的 Cp 属性的具体类型。在第 16 行、第 17 行，因为类型入参 IUserItem、ITodoItem 和 Cp 属性 RenderUser、RenderTodo 类型一一对应，所以可以通过静态类型检测。但是，在第 18 行、第 19 行，因为对应关系不正确，所以提示了一个 ts(2322) 错误。</p>\n<p data-nodeid=\"22257\"><strong data-nodeid=\"22437\">class 组件和函数组件类型组成的联合类型被称之为组件类型  React.ComponentType，组件类型一般用来定义高阶组件的属性</strong>，如下代码所示：</p>\n<pre class=\"lang-typescript\" data-nodeid=\"22258\"><code data-language=\"typescript\">React.ComponentType&lt;P&gt; = React.ComponentClass&lt;P&gt; | React.FunctionComponent&lt;P&gt;;\n</code></pre>\n<p data-nodeid=\"22259\">最后介绍几个常用类型：</p>\n<ul data-nodeid=\"22260\">\n<li data-nodeid=\"22261\">\n<p data-nodeid=\"22262\"><strong data-nodeid=\"22443\">元素类型 React.ElementType</strong>：指的是所有可以通过 JSX 语法创建元素的类型组合，包括html 原生标签（比如 div、a 等）和 React.ComponentType，元素类型可以接收一个表示 props 的类型入参；</p>\n</li>\n<li data-nodeid=\"22263\">\n<p data-nodeid=\"22264\"><strong data-nodeid=\"22448\">元素节点类型 React.ReactElement</strong>：指的是元素类型通过 JSX 语法创建的节点类型，它可以接收两个分别表示 props 和元素类型的类型入参；</p>\n</li>\n<li data-nodeid=\"22265\">\n<p data-nodeid=\"22266\"><strong data-nodeid=\"22453\">节点类型 React.ReactNode</strong>：指的是由 string、number、boolean、undefined、null、React.ReactElement 和元素类型是 React.ReactElement 的数组类型组成的联合类型，合法的 class 组件 render 方法返回值类型必须是 React.ReactNode；</p>\n</li>\n<li data-nodeid=\"22267\">\n<p data-nodeid=\"22268\"><strong data-nodeid=\"22460\">JSX 元素类型 JSX.Element</strong>：指的是元素类型通过 JSX 语法创建的节点类型，JSX.Element 等于 React.ReactElement&lt;any, any&gt;。</p>\n</li>\n</ul>\n<p data-nodeid=\"22269\">以上就是 React Component 相关的类型及简单的类型化。</p>\n<p data-nodeid=\"22270\">在实际业务中，因为组件接收的 props 数据可能来自路由、Redux，所以我们还需要对类型进行更明确的分解。</p>\n<p data-nodeid=\"22271\">下面我们看一个具体的示例：</p>\n<pre class=\"lang-typescript\" data-nodeid=\"22272\"><code data-language=\"typescript\"><span class=\"hljs-keyword\">import</span> React <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'react'</span>; \n<span class=\"hljs-keyword\">import</span> { bindActionCreators, Dispatch } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\"redux\"</span>;\n<span class=\"hljs-keyword\">import</span> { connect } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\"react-redux\"</span>;\n<span class=\"hljs-keyword\">import</span> { RouteComponentProps } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'react-router-dom'</span>;\n<span class=\"hljs-comment\">/** 路由 Props */</span>\n<span class=\"hljs-keyword\">type</span> RouteProps = RouteComponentProps&lt;{ routeId: <span class=\"hljs-built_in\">string</span> }&gt;;\n<span class=\"hljs-comment\">/** Redux Store Props */</span>\n<span class=\"hljs-keyword\">type</span> StateProps = ReturnType&lt;<span class=\"hljs-keyword\">typeof</span> mapStateToProps&gt;;\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">mapStateToProps</span>(<span class=\"hljs-params\">state: {}</span>) </span>{\n  <span class=\"hljs-keyword\">return</span> {\n    reduxId: <span class=\"hljs-number\">1</span>\n  };\n}\n<span class=\"hljs-comment\">/** Redux Actions Props */</span>\n<span class=\"hljs-keyword\">type</span> DispatchProps = ReturnType&lt;<span class=\"hljs-keyword\">typeof</span> mapDispatchToProps&gt;;\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">mapDispatchToProps</span>(<span class=\"hljs-params\">dispatch: Dispatch</span>) </span>{\n  <span class=\"hljs-keyword\">return</span> {\n    actions: bindActionCreators({\n      doSomething: <span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> <span class=\"hljs-built_in\">void</span> <span class=\"hljs-number\">0</span>\n    }, dispatch),\n  };\n}\n<span class=\"hljs-comment\">/** 组件属性 */</span>\n<span class=\"hljs-keyword\">interface</span> IOwnProps {\n  ownId: <span class=\"hljs-built_in\">number</span>;\n}\n<span class=\"hljs-comment\">/** 最终 Props */</span>\n<span class=\"hljs-keyword\">type</span> CpProps = IOwnProps &amp; RouteProps &amp; StateProps &amp; DispatchProps;\n<span class=\"hljs-keyword\">const</span> OriginalCp = <span class=\"hljs-function\">(<span class=\"hljs-params\">props: CpProps</span>) =&gt;</span> {\n  <span class=\"hljs-keyword\">const</span> {\n    match: { params: { routeId } }, <span class=\"hljs-comment\">// 路由 Props</span>\n    reduxId, <span class=\"hljs-comment\">// Redux Props</span>\n    ownId, <span class=\"hljs-comment\">// 组件 Props</span>\n    actions: {\n      doSomething <span class=\"hljs-comment\">// Action Props</span>\n    },\n  } = props;\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">null</span>;\n};\n<span class=\"hljs-keyword\">const</span> ConnectedCp = connect&lt;StateProps, DispatchProps, IOwnProps&gt;(mapStateToProps, mapDispatchToProps)(OriginalCp <span class=\"hljs-keyword\">as</span> React.ComponentType&lt;IOwnProps&gt;);\n<span class=\"hljs-keyword\">const</span> ConnectedCpJSX = &lt;ConnectedCp ownId={<span class=\"hljs-number\">1</span>} /&gt;; <span class=\"hljs-comment\">// ok</span>\n</code></pre>\n<p data-nodeid=\"22273\">在第 7 行，我们定义了 RouteProps，描述的是从路由中获取的属性。在第 9 行获取了 mapStateToProps 函数返回值类型 StateProps，描述的是从 Redux Store 中获取的属性。</p>\n<p data-nodeid=\"22274\">在第 16 行，我们获取了 mapDispatchToProps 函数返回值类型 DispatchProps，描述的是 Redux Actions 属性。在第 25 行，我们定义的是组件自有的属性，所以最终组件 OriginalCp 的属性类型 CpProps 是 RouteProps、StateProps、DispatchProps 和 IOwnProps 四个类型的交叉类型。在第 31~38 行，我们解构了 props 中不同来源的属性、方法，并且可以通过静态类型检测。</p>\n<p data-nodeid=\"22275\"><strong data-nodeid=\"22471\">这里插播一道思考题：以上示例会提示一个缺少 react-redux、react-router-dom 类型声明的错误，应该如何解决呢？</strong></p>\n<blockquote data-nodeid=\"22276\">\n<p data-nodeid=\"22277\">注意：在示例中的第 41 行，connect 之前，我们把组件 OriginalCp 断言为 React.ComponentType<iownprops> 类型，这样在第 42 行使用组件的时候，就只需要传入 IOwnProps 中定义的属性（因为 RouteProps、StateProps、DispatchProps 属性可以通过路由或者 connect 自动注入）。</iownprops></p>\n</blockquote>\n<p data-nodeid=\"22278\">这里使用的类型断言是开发 HOC 高阶组件（上边示例中 connect(mapStateToProps, mapDispatchToProps) 返回的是一个高阶组件）的一个惯用技巧，一般我们可以通过划分 HOCProps、IOwnProps 或 Omit 来剔除高阶组件注入的属性，如下示例中的第 4 行、第 5 行。</p>\n<pre class=\"lang-typescript\" data-nodeid=\"22279\"><code data-language=\"typescript\"><span class=\"hljs-keyword\">interface</span> IHOCProps { injectId: <span class=\"hljs-built_in\">number</span>; }\n<span class=\"hljs-keyword\">interface</span> IOwnProps { ownId: <span class=\"hljs-built_in\">number</span>; }\n<span class=\"hljs-keyword\">const</span> hoc = &lt;C <span class=\"hljs-keyword\">extends</span> React.ComponentType&lt;<span class=\"hljs-built_in\">any</span>&gt;&gt;<span class=\"hljs-function\">(<span class=\"hljs-params\">cp: C</span>) =&gt;</span> cp;\n<span class=\"hljs-keyword\">const</span> InjectedCp1 = hoc(OriginalCp <span class=\"hljs-keyword\">as</span> React.ComponentType&lt;IOwnProps&gt;);\n<span class=\"hljs-keyword\">const</span> InjectedCp2 = hoc(OriginalCp <span class=\"hljs-keyword\">as</span> React.ComponentType&lt;Omit&lt;IHOCProps &amp; IOwnProps, <span class=\"hljs-string\">'injectId'</span>&gt;&gt;); \n</code></pre>\n<p data-nodeid=\"22280\">组件类型化还涉及 Hooks 等知识点，限于篇幅，本文就不继续展开了。</p>\n<p data-nodeid=\"22281\">接下来我们简单了解一下使用 Redux 进行状态管理技术方案的类型化，将其称之为 Redux 类型化。</p>\n<h4 data-nodeid=\"22282\">Redux 类型化</h4>\n<p data-nodeid=\"22283\">Redux 类型化涉及 state、action、reducer 三要素类型化，具体示例如下：</p>\n<pre class=\"lang-typescript\" data-nodeid=\"22284\"><code data-language=\"typescript\"><span class=\"hljs-comment\">// src/redux/user.ts</span>\n<span class=\"hljs-comment\">// state</span>\n<span class=\"hljs-keyword\">interface</span> IUserInfoState {\n  userid?: <span class=\"hljs-built_in\">number</span>;\n  username?: <span class=\"hljs-built_in\">string</span>;\n}\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> initialState: IUserInfoState = {};\n<span class=\"hljs-comment\">// action</span>\n<span class=\"hljs-keyword\">interface</span> LoginAction {\n  <span class=\"hljs-keyword\">type</span>: <span class=\"hljs-string\">'userinfo/login'</span>;\n  payload: Required&lt;IUserInfoState&gt;;\n}\n<span class=\"hljs-keyword\">interface</span> LogoutAction {\n  <span class=\"hljs-keyword\">type</span>: <span class=\"hljs-string\">'userinfo/logout'</span>;\n}\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">doLogin</span>(<span class=\"hljs-params\"></span>): <span class=\"hljs-title\">LoginAction</span> </span>{\n  <span class=\"hljs-keyword\">return</span> {\n    <span class=\"hljs-keyword\">type</span>: <span class=\"hljs-string\">'userinfo/login'</span>,\n    payload: {\n      userid: <span class=\"hljs-number\">101</span>,\n      username: <span class=\"hljs-string\">'乾元亨利贞'</span>\n    }\n  };\n}\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">doLogout</span>(<span class=\"hljs-params\"></span>): <span class=\"hljs-title\">LogoutAction</span> </span>{\n  <span class=\"hljs-keyword\">return</span> {\n    <span class=\"hljs-keyword\">type</span>: <span class=\"hljs-string\">'userinfo/logout'</span>\n  };\n}\n<span class=\"hljs-comment\">// reducer</span>\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">applyUserInfo</span>(<span class=\"hljs-params\">state = initialState, action: LoginAction | LogoutAction</span>): <span class=\"hljs-title\">IUserInfoState</span> </span>{\n  <span class=\"hljs-keyword\">switch</span> (action.type) {\n    <span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">'userinfo/login'</span>:\n      <span class=\"hljs-keyword\">return</span> {\n        ...action.payload\n      };\n    <span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">'userinfo/logout'</span>:\n      <span class=\"hljs-keyword\">return</span> {};\n  }\n}\n</code></pre>\n<p data-nodeid=\"22285\">在示例中的第 2~7 行，我们定义了 state 的详细类型，并在第 8~29 行分别定义了表示登入、登出的 action 类型和函数，还在第 30~40 行定义了处理前边定义的 action 的 reducer 函数。</p>\n<p data-nodeid=\"22286\">然后，我们就将类型化后的 state、action、reducer 合并到 redux store，再通过 react-redux 关联 React，这样组件在 connect 之后，就能和 Redux 交互了。</p>\n<p data-nodeid=\"22287\">不过，因为 state、action、reducer 分别类型化的形式写起来十分复杂，所以我们可以借助 typesafe-actions、redux-actions、rematch、dvajs、@ekit/model 等工具更清晰、高效地组织 Redux 代码。限于篇幅，这里就不做深入介绍了，你可以自行到<a href=\"https://www.npmjs.com/\" data-nodeid=\"22491\">https://www.npmjs.com/</a>上查看更多信息。</p>\n<h4 data-nodeid=\"22288\">单元测试</h4>\n<p data-nodeid=\"22289\">我们可以选择 Jest + Enzyme + jsdom + ReactTestUtils 作为 React + TypeScript 应用的单元测试技术方案，不过麻烦的地方在于需要手动配置 Jest、Enzyme。因此，我更推荐选择<a href=\"https://github.com/testing-library/react-testing-library\" data-nodeid=\"22497\">react-testing-library</a>这个方案，这也是 create-react-app 默认内置的单元测试方案。</p>\n<p data-nodeid=\"22290\">如下示例，我们为前边定义的 RenderUser 组件编写了单元测试。</p>\n<pre class=\"lang-typescript\" data-nodeid=\"22291\"><code data-language=\"typescript\"><span class=\"hljs-keyword\">import</span> React <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'react'</span>;\n<span class=\"hljs-keyword\">import</span> { render, screen } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'@testing-library/react'</span>;\n<span class=\"hljs-keyword\">import</span> { RenderUser } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'./Cp'</span>;\ntest(<span class=\"hljs-string\">'renders learn react link'</span>, <span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> {\n  render(&lt;RenderUser username={<span class=\"hljs-string\">'乾元亨利贞'</span>} /&gt;);\n  <span class=\"hljs-keyword\">const</span> linkElement = screen.getByText(<span class=\"hljs-regexp\">/乾元亨利贞/i</span>);\n  expect(linkElement).toBeInTheDocument();\n});\n</code></pre>\n<blockquote data-nodeid=\"22292\">\n<p data-nodeid=\"22293\">注意：以上介绍的单测执行环境是 Node.js，TypeScript 会被转译成 CommonJS 格式，而在浏览器端运行时，则会被转译成 ES 格式。因此，不同模块之间存在循环依赖时，转译后代码在浏览器端可以正确运行，而在 Node.js 端运行时可能会出现引入的其他模块成员未定义（undefined）的错误。</p>\n</blockquote>\n<h3 data-nodeid=\"22294\">小结和预告</h3>\n<p data-nodeid=\"22295\">以上就是 TypeScript 和 Dom 原生操作及结合 React 框架在 Web 侧开发的实践建议，其核心在于类型化 Dom API 和 React 组件、Redux 和 Service。</p>\n<p data-nodeid=\"22296\">插播一道思考题：类型化 React 组件的要义是什么？欢迎你在留言区进行互动、交流。</p>\n<p data-nodeid=\"22297\">20 讲我们将学习如何从 JavaScript 迁移到 TypeScript，敬请期待。</p>\n<p data-nodeid=\"22298\">另外，如果你觉得本专栏有价值，欢迎分享给更多好友~</p>",
                "article_title": "19 | 使用 TypeScript 开发 Web 应用的最佳实践",
                "title": "19 | 使用 TypeScript 开发 Web 应用的最佳实践",
                "id": 7451
            },
            {
                "content": "<p data-nodeid=\"25275\">在前面几讲，我们学习了如何从零开始新建 TypeScript Node.js、Web 项目。</p>\n\n\n<p data-nodeid=\"24479\">然而，TypeScript 作为 JavaScript 的超集，花费了漫长的时间才替代了 JavaScript，并成长为构建应用的主流技术。比如我自己所负责的项目，最初也主要是基于 ES6（JavaScript） 源码构建的，甚至极个别项目是基于无须转译的 ES5（JavaScript） 代码构建的。</p>\n<p data-nodeid=\"24480\">从 JavaScript 进化到 TypeScript，也就意味着需要大量的迁移、重构操作。因此，接下来我们将学习将 JavaScript 技术栈项目迁移到 TypeScript 的操作步骤和实用技巧。</p>\n<h3 data-nodeid=\"24481\">迁移步骤</h3>\n<h4 data-nodeid=\"24482\">调整项目结构</h4>\n<p data-nodeid=\"24483\">首先，我们可以参照 18 讲和 19 讲的内容调整项目结构，比如使用 src 目录组织源码，typings 目录组织类型声明定义，lib 目录作为 Node.js 模块的构建产物，build 目录作为 Web 项目的构建产物。</p>\n<p data-nodeid=\"24484\">然后，我们需要在项目根目录下创建一个 tsconfig.json，让源码和单测共享一个配置文件。</p>\n<p data-nodeid=\"24485\">因为如今大多数的 JavaScript 项目都是基于 ES6+ 组织源码，再转译为 JavaScript，其项目结构基本可以划分为如下所示，所以我们只需要创建一个 tsconfig.json 即可。</p>\n<pre class=\"lang-java\" data-nodeid=\"24486\"><code data-language=\"java\">JavaScript2TypeScriptProject\n├── src\n│   ├── a.js\n│   └── b.js\n├── build 或则 lib\n├── typings\n├── <span class=\"hljs-keyword\">package</span>.json\n└── tsconfig.json\n</code></pre>\n<p data-nodeid=\"24487\">接下来就是如何配置 tsconfig.json 了，下面我们一起探讨一下。</p>\n<h4 data-nodeid=\"24488\">配置 tsconfig</h4>\n<p data-nodeid=\"24489\">在正式讲解之前，我们先插播一道思考题：Node.js 项目需要如何配置？</p>\n<blockquote data-nodeid=\"24490\">\n<p data-nodeid=\"24491\">提示信息：区别仅在于 Node.js 项目需要指定 rootDir、outDir。</p>\n</blockquote>\n<p data-nodeid=\"24492\">以配置 React Web 项目为例，为了尽可能少改动源码、让项目正常运行起来，我们不要一步到位开启严格模式，而应该尽量宽松地配置 tsconfig，如下配置所示。</p>\n<pre class=\"lang-java\" data-nodeid=\"24493\"><code data-language=\"java\">{\n  <span class=\"hljs-string\">\"compilerOptions\"</span>: {\n    <span class=\"hljs-string\">\"target\"</span>: <span class=\"hljs-string\">\"es5\"</span>,\n    <span class=\"hljs-string\">\"lib\"</span>: [\n      <span class=\"hljs-string\">\"dom\"</span>,\n      <span class=\"hljs-string\">\"dom.iterable\"</span>,\n      <span class=\"hljs-string\">\"esnext\"</span>\n    ],\n    <span class=\"hljs-string\">\"allowJs\"</span>: <span class=\"hljs-keyword\">true</span>,\n    <span class=\"hljs-string\">\"skipLibCheck\"</span>: <span class=\"hljs-keyword\">true</span>,\n    <span class=\"hljs-string\">\"esModuleInterop\"</span>: <span class=\"hljs-keyword\">true</span>,\n    <span class=\"hljs-string\">\"allowSyntheticDefaultImports\"</span>: <span class=\"hljs-keyword\">true</span>,\n    <span class=\"hljs-string\">\"forceConsistentCasingInFileNames\"</span>: <span class=\"hljs-keyword\">true</span>,\n    <span class=\"hljs-string\">\"module\"</span>: <span class=\"hljs-string\">\"esnext\"</span>,\n    <span class=\"hljs-string\">\"moduleResolution\"</span>: <span class=\"hljs-string\">\"node\"</span>,\n    <span class=\"hljs-string\">\"resolveJsonModule\"</span>: <span class=\"hljs-keyword\">true</span>,\n    <span class=\"hljs-string\">\"isolatedModules\"</span>: <span class=\"hljs-keyword\">true</span>,\n    <span class=\"hljs-string\">\"noEmit\"</span>: <span class=\"hljs-keyword\">true</span>,\n    <span class=\"hljs-string\">\"jsx\"</span>: <span class=\"hljs-string\">\"react\"</span>,\n    <span class=\"hljs-string\">\"typeRoots\"</span>: [<span class=\"hljs-string\">\"node_modules/@types\"</span>, <span class=\"hljs-string\">\"./typings\"</span>]\n  },\n  <span class=\"hljs-string\">\"include\"</span>: [ <span class=\"hljs-string\">\"src\"</span>, <span class=\"hljs-string\">\"typings\"</span> ]\n}\n</code></pre>\n<p data-nodeid=\"24494\">其中，比较重要的配置项分为如下 5 个。</p>\n<ul data-nodeid=\"29679\">\n<li data-nodeid=\"29680\">\n<p data-nodeid=\"29681\">第 3 行配置“target”为 \"es5\"，用来将 TypeScript 转译为低版本、各端兼容性较好的 ES5 代码。</p>\n</li>\n<li data-nodeid=\"29682\">\n<p data-nodeid=\"29683\">第 9 行开启的 allowJs，它允许 JavaScript 和 TypeScript 混用，这使得我们可以分批次、逐模块地迁移代码。</p>\n</li>\n<li data-nodeid=\"29684\">\n<p data-nodeid=\"29685\">第 20 行我们把 typings 目录添加到类型查找路径，让 TypeScript 可以查找到自定义类型声明，比如为缺少类型声明的第三方模块补齐类型声明。</p>\n</li>\n<li data-nodeid=\"29686\">\n<p data-nodeid=\"29687\" class=\"\">第 22 行我们把 src 和 typings 目录添加到 TypeScript 需要识别的文件中（也可以按照实际需要添加其他目录或者文件，比如说独立的单测文件目录 __tests__）。</p>\n</li>\n<li data-nodeid=\"29688\">\n<p data-nodeid=\"29689\">因为是 React Web 项目，所以我们还需要在第 19 行将“jsx”配置为“react”。</p>\n</li>\n</ul>\n\n\n\n\n\n\n\n\n<blockquote data-nodeid=\"24506\">\n<p data-nodeid=\"24507\">注意：因为 Web 项目中不会直接使用 tsc 转译 TypeScript，所以我们无需配置 rootDir、outDir，甚至可以开启 noEmit 配置（如上边配置第 18 行所示，开启该配置 tsc 不会生成转译产物）。</p>\n</blockquote>\n<p data-nodeid=\"24508\">接下来，我们需要结合项目所使用的构建工具集成 TypeScript 构建环境。</p>\n<h4 data-nodeid=\"24509\">构建工具集成 TypeScript</h4>\n<p data-nodeid=\"24510\">下面我们以非常常见的构建工具 Webpack 集成 TypeScript 为例。</p>\n<p data-nodeid=\"24511\">首先我们需要安装如下所示依赖，比如所有用到的第三模块类型声明（通过“npm i -D @types/模块名”进行安装）以及需要用来加载并转译 TypeScript 代码的 Webpack Loader。</p>\n<pre class=\"lang-java\" data-nodeid=\"24512\"><code data-language=\"java\">npm install -D typescript;\nnpm install -D <span class=\"hljs-meta\">@types</span>/react;\nnpm install -D <span class=\"hljs-meta\">@types</span>/react-dom;\n... <span class=\"hljs-comment\">// 其他必要依赖</span>\nnpm install -D ts-loader;\n</code></pre>\n<p data-nodeid=\"24513\">然后，我们选择 ts-loader 作为 TypeScript 加载器，并在 webpack.config.js 配置文件中添加 resolve 和 module 规则，如下配置所示：</p>\n<pre class=\"lang-javascript\" data-nodeid=\"24514\"><code data-language=\"javascript\"><span class=\"hljs-built_in\">module</span>.exports = {\n  <span class=\"hljs-comment\">// 其他配置 ...,</span>\n  <span class=\"hljs-attr\">resolve</span>: {\n    <span class=\"hljs-attr\">extensions</span>: [<span class=\"hljs-string\">\".ts\"</span>, <span class=\"hljs-string\">\".tsx\"</span>, <span class=\"hljs-string\">\".js\"</span>, <span class=\"hljs-string\">\".jsx\"</span>, <span class=\"hljs-string\">\".json\"</span>],\n  },\n  <span class=\"hljs-attr\">module</span>: {\n    <span class=\"hljs-attr\">rules</span>: [\n      <span class=\"hljs-comment\">// 其他配置&nbsp;loader 规则...,</span>\n      {\n        <span class=\"hljs-attr\">test</span>: <span class=\"hljs-regexp\">/\\.tsx?$/</span>,\n        use: [\n          {\n            <span class=\"hljs-attr\">loader</span>: <span class=\"hljs-string\">\"ts-loader\"</span>,\n            <span class=\"hljs-attr\">options</span>: { <span class=\"hljs-attr\">transpileOnly</span>: <span class=\"hljs-literal\">true</span> }\n          }\n        ]\n      }\n    ],\n  },\n  <span class=\"hljs-attr\">plugins</span>: [\n    <span class=\"hljs-comment\">// ...其他配置</span>\n    <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'fork-ts-checker-webpack-plugin'</span>)({\n      <span class=\"hljs-attr\">async</span>: <span class=\"hljs-literal\">false</span>,\n      <span class=\"hljs-attr\">tsconfig</span>: <span class=\"hljs-string\">'...'</span> <span class=\"hljs-comment\">// tsconfig.json 文件地址</span>\n    });\n  ]\n  <span class=\"hljs-comment\">// 其他配置...</span>\n};\n</code></pre>\n<p data-nodeid=\"24515\">首先，我们在第 4 行的 extensions 配置中添加了 .ts、.tsx 文件后缀名，是为了让 Webpack 在解析模块的时候同时识别 TypeScript 文件。</p>\n<blockquote data-nodeid=\"24516\">\n<p data-nodeid=\"24517\">注意：因为 Webpack 是以从左到右的顺序读取 extensions 配置并查找文件，所以按照如上配置，当碰到模块同名的情况，Webpack 将优先解析到 TypeScript 模块。</p>\n</blockquote>\n<p data-nodeid=\"24518\">然后，我们在 17~19 行的 rules 配置中添加了 ts-loader，是为了让 Webpack 使用 ts-loader 加载和转译 .ts、.tsx 文件。</p>\n<blockquote data-nodeid=\"30763\">\n<p data-nodeid=\"30764\">一个比较好的实践是，我们可以开启 ts-loader 的 transpileOnly 配置，让 ts-loader 在处理 TypeScript 文件时，只转译而不进行静态类型检测，这样就可以提升构建速度了。</p>\n<p data-nodeid=\"30765\" class=\"\">不过，这并不意味着构建时静态检测不重要，相反这是保证类型安全的最后一道防线。此时，我们可以通过其他性能更优的插件做静态类型检测。</p>\n</blockquote>\n\n\n<p data-nodeid=\"24523\">最后，我们在第 22 行引入了 fork-ts-checker-webpack-plugin 专门对 TypeScript 文件进行构建时静态类型检测（可以通过如下命令，安装该插件）。这样，只要出现任何 TypeScript 类型错误，构建就会失败并提示错误信息。</p>\n<p data-nodeid=\"24524\">我们可以通过如下命令安装 fork-ts-checker-webpack-plugin 插件。</p>\n<pre class=\"lang-shell\" data-nodeid=\"24525\"><code data-language=\"shell\">npm install -D fork-ts-checker-webpack-plugin;\n</code></pre>\n<p data-nodeid=\"24526\">实际上，静态类型检测确实会耗费性能和时间，尤其是项目特别庞大的时候，这个损耗会极大地降低开发体验。此时，我们可以根据实际情况优化 Webpack 配置，比如仅在生产构建时开启静态类型检测、开发构建时关闭静态类型检测，这样既可以保证开发体验，也能保证生产构建的安全性。</p>\n<p data-nodeid=\"24527\">除了使用 ts-loader 之外，现在我们也可以使用版本号大于 7 的 babel-loader 作为 TypeScript 的加载器。</p>\n<p data-nodeid=\"24528\">具体操作：首先，我们可以通过如下命令安装处理 TypeScript 的 babel preset。</p>\n<pre class=\"lang-java\" data-nodeid=\"24529\"><code data-language=\"java\"><span class=\"hljs-comment\">// npm i -D babel-loader; // 确保安装版本 &gt; 7</span>\nnpm i -D <span class=\"hljs-meta\">@babel</span>/preset-typescript;\n</code></pre>\n<blockquote data-nodeid=\"24530\">\n<p data-nodeid=\"24531\"><strong data-nodeid=\"24657\">注意：因为 React Web 项目必然已经安装了 babel-loader（必须依赖），所以我们不用重新安装 babel-loader，只需确保 babel-loader 的版本号大于 7 即可。</strong></p>\n</blockquote>\n<p data-nodeid=\"24532\">然后，我们在 webpack.config.js 中添加支持 TypeScript 的配置，如下代码所示：</p>\n<pre class=\"lang-javascript\" data-nodeid=\"24533\"><code data-language=\"javascript\"><span class=\"hljs-built_in\">module</span>.exports = {\n  ​<span class=\"hljs-comment\">// 其他配置 ...</span>\n  ​resolve: \n    ​extensions: [<span class=\"hljs-string\">\".ts\"</span>, <span class=\"hljs-string\">\".tsx\"</span>, <span class=\"hljs-string\">\".js\"</span>, <span class=\"hljs-string\">\".jsx\"</span>, <span class=\"hljs-string\">\".json\"</span>]\n  ​},\n  ​<span class=\"hljs-built_in\">module</span>: {\n    ​rules: [\n      {\n        <span class=\"hljs-attr\">test</span>: <span class=\"hljs-regexp\">/\\.(js|jsx|ts|tsx)$/</span>,\n        use: [<span class=\"hljs-string\">'babel-loader'</span>]\n      },\n      <span class=\"hljs-comment\">// ...其他配置</span>\n    ​]\n  ​},\n  ​<span class=\"hljs-comment\">// ...其他配置</span>\n};\n</code></pre>\n<p data-nodeid=\"24534\">在以上配置中的第 4 行、第 9 行，我们配置并使用了 babel-loader 来转换 .ts、.tsx 文件。</p>\n<p data-nodeid=\"24535\">最后，我们在 babel 配置文件中添加了如下所示的 typescript presets（参见第 5 行）。</p>\n<pre class=\"lang-java\" data-nodeid=\"24536\"><code data-language=\"java\">{\n   <span class=\"hljs-string\">\"presets\"</span>: [\n     <span class=\"hljs-string\">\"@babel/preset-env\"</span>,\n     <span class=\"hljs-string\">\"@babel/preset-react\"</span>,\n     [<span class=\"hljs-string\">'@babel/preset-typescript'</span>, { allowNamespaces: <span class=\"hljs-keyword\">true</span> }]\n   ],\n   <span class=\"hljs-comment\">// ...其他配置</span>\n}\n</code></pre>\n<blockquote data-nodeid=\"24537\">\n<p data-nodeid=\"24538\">注意：因为每个项目中使用的模板不同，所以 babel 配置项可能在 .babelrc、babel.config.js 单独的配置文件中或者内置在 package.json 中。</p>\n</blockquote>\n<p data-nodeid=\"24539\">这样，babel-loader 就可以加载并转换 TypeScript 代码了。</p>\n<blockquote data-nodeid=\"24540\">\n<p data-nodeid=\"24541\">需要注意：因为 babel-loader 也是只对 TypeScript 代码做转换，而不进行静态类型检测，所以我们同样需要引入 fork-ts-checker-webpack-plugin 插件做静态类型检测。</p>\n</blockquote>\n<p data-nodeid=\"24542\">配置好构建工具后，接下来需要迁移 JavaScript 代码，我把这个过程形容为“愚公移山”。</p>\n<h4 data-nodeid=\"24543\">愚公移山</h4>\n<p data-nodeid=\"24544\">为什么形容为“愚公移山”？因为将 JavaScript 迁移到 TypeScript 是一项个<strong data-nodeid=\"24671\">没有太大技术含量的体力活，同时也是一项长久、渐进的过程</strong>。</p>\n<p data-nodeid=\"24545\">迁移 JavaScript 代码的具体操作：首先，我们需要逐个将 .js 文件重名为 .ts、.jsx 文件重名为 .tsx，比如将项目的主入口文件 index.js 改成 index.ts（相应的 webpack.config.js 也需要更改）。然后，我们启动本地服务（npm start）。</p>\n<p data-nodeid=\"24546\">不出意外的话，IDE（比如我们推荐的 VS Code）和 fork-ts-checker-webpack-plugin 都会提示 index.ts 有 N 个各式各样的类型错误。</p>\n<p data-nodeid=\"24547\">如果我们希望前期始于一个比较高且好的起点，比如在 tsconfig.json 中配置 noImplicitAny 为 true（禁用隐式 any），这样就会提示更多的类型错误。</p>\n<blockquote data-nodeid=\"24548\">\n<p data-nodeid=\"24549\">注意：作为过来人，建议你在 tsconfig.json 的配置上一步到位开启 strict 严格模式。一方面因为我们的课程是基于严格模式编写的，学以致用，另一方面是为了后续无需重复迁移过程，一步到位。当然，你也可以根据项目的实际诉求，选择开启严格模式一步到位或宽松配置 tsconfig。</p>\n</blockquote>\n<h3 data-nodeid=\"24550\">解决错误</h3>\n<p data-nodeid=\"24551\">接下来我们要做的事情就是综合利用前面课程的知识（例如 17 讲中介绍的较为常见的错误和分析），逐个解决迁移后的 TypeScript 文件中的各种类型错误。</p>\n<h4 data-nodeid=\"24552\">缺少类型注解</h4>\n<p data-nodeid=\"24553\">我们看到的第一个错误大概率是缺少某个模块的类型声明文件 ts(7016)，比如说缺少路由组件 react-router-dom 的类型声明。</p>\n<p data-nodeid=\"24554\">此时，我们可以先通过以下命令尝试安装 DefinitelyTyped 上可能存在的类型声明依赖。</p>\n<pre class=\"lang-java\" data-nodeid=\"24555\"><code data-language=\"java\">npm i -D <span class=\"hljs-meta\">@types</span>/react-router-dom;\n</code></pre>\n<p data-nodeid=\"24556\">如果命令执行成功，则说明类型声明存在，并且安装成功，这也意味着我们快速且低成本地解决了一个错误。如果 DefinitelyTyped 上恰好没有定义好的依赖类型声明，那么我们就需要自己解决这个问题了。</p>\n<p data-nodeid=\"24557\">回想一下 18 讲中是如何解决依赖的 ecstatic 模块缺少类型声明问题的，首先我们需要频繁使用 declare module 补齐类型声明。然后，我们将各种补齐类型声明的文件统一放在 typings 目录中，比如示例 1 中自定义的 jQuery.d.ts（注意：DefinitelyTyped 有 jQuery 类型定义），示例 2 中声明的静态资源 svg、png、jpg、gif 文件模块的 images.d.ts。</p>\n<p data-nodeid=\"24558\">示例 1</p>\n<pre class=\"lang-java\" data-nodeid=\"24559\"><code data-language=\"java\"><span class=\"hljs-comment\">// jQuery.d.ts</span>\ndeclare <span class=\"hljs-keyword\">module</span> <span class=\"hljs-string\">'jQuery'</span>;\n</code></pre>\n<p data-nodeid=\"24560\">示例 2</p>\n<pre class=\"lang-typescript\" data-nodeid=\"24561\"><code data-language=\"typescript\"><span class=\"hljs-comment\">// images.d.ts</span>\n<span class=\"hljs-keyword\">declare</span> <span class=\"hljs-keyword\">module</span> '*.svg';\ndeclare <span class=\"hljs-keyword\">module</span> '*.png';\ndeclare <span class=\"hljs-keyword\">module</span> '*.jpg';\ndeclare <span class=\"hljs-keyword\">module</span> '*.gif';\n</code></pre>\n<p data-nodeid=\"24562\">关于全局变量、属性缺少类型定义的错误，我们也可以使用 declare 或者扩充相应的接口类型进行解决。</p>\n<p data-nodeid=\"24563\">首先我们可以创建一个 global.d.ts 补齐缺少的类型声明，如下代码所示：</p>\n<pre class=\"lang-typescript\" data-nodeid=\"24564\"><code data-language=\"typescript\"><span class=\"hljs-keyword\">declare</span> <span class=\"hljs-keyword\">var</span> $: <span class=\"hljs-built_in\">any</span>;\n<span class=\"hljs-keyword\">interface</span> Window {\n  __REDUX_DEVTOOLS_EXTENSION__: <span class=\"hljs-built_in\">any</span>;\n}\n<span class=\"hljs-keyword\">interface</span> NodeModule {\n  hot?: {\n    accept: <span class=\"hljs-function\">(<span class=\"hljs-params\">id: <span class=\"hljs-built_in\">string</span>, callback: (<span class=\"hljs-params\">...args: <span class=\"hljs-built_in\">any</span></span>) =&gt; <span class=\"hljs-built_in\">void</span></span>) =&gt;</span> <span class=\"hljs-built_in\">void</span>;\n  };\n}\n</code></pre>\n<p data-nodeid=\"24565\">在示例中的第 1 行，我们声明了全局变量 $，从而解决了找不到 $ 的 ts(2581) 错误。在第 2~4 行，我们扩充了 Window 接口，从而解决了访问 window.<strong data-nodeid=\"24698\">REDUX_DEVTOOLS_EXTENSION</strong> 时提示属性不存在的 ts(2339) 错误。然后在第 5 到第 9 行，我们扩充了 NodeModule 接口，从而解决了调用 module.hot.accept 方法时提示的 ts(2339) 错误。</p>\n<blockquote data-nodeid=\"31825\">\n<p data-nodeid=\"31826\">注意：不要在 global.d.ts 内添加顶层的 import 或者 export 语句。</p>\n<p data-nodeid=\"31827\" class=\"\">插播一道思考题：回忆一下 TypeScript 中 script 和 module 的区别。</p>\n</blockquote>\n<h4 data-nodeid=\"31828\">隐式 any</h4>\n\n\n\n\n<p data-nodeid=\"24571\">接下来就是大量函数参数具有隐式 any 类型的 ts(7006) 错误，此时我们需要给所有函数添加类型注解。在解决这些错误时，如果我们结合 05 讲的知识（比如可选参数、剩余参数函数和函数重载）将会得心应手。</p>\n<blockquote data-nodeid=\"24572\">\n<p data-nodeid=\"24573\">一个好的实践建议：如果我们确实需要暂时使用万金油类型 any 来绕过静态类型检测，则可以声明一个具有特殊含义的全局类型 AnyToFix 来代替 any。比如我们可以在 global.d.ts 内添加如下所示的 AnyToFix 类型别名定义。</p>\n</blockquote>\n<pre class=\"lang-typescript\" data-nodeid=\"24574\"><code data-language=\"typescript\"><span class=\"hljs-comment\">/** 需要替换成更明确的类型 */</span>\n<span class=\"hljs-keyword\">type</span> AnyToFix = <span class=\"hljs-built_in\">any</span>;\n</code></pre>\n<p data-nodeid=\"24575\">这样，我们就可以在任何地方使用 AnyToFix 替代 any ，比如下图中的 func 函数参数 arg 的类型就是 AnyToFix。并且在条件成熟时，我们可以很方便地筛选出需要类型重构的 func 函数，然后将其参数类型修改为更明确的类型。</p>\n<p data-nodeid=\"32356\" class=\"te-preview-highlight\"><img src=\"https://s0.lgstatic.com/i/image6/M01/4A/53/CioPOWDe5jaAcn06AAE09h1BBNU745.png\" alt=\"Drawing 0.png\" data-nodeid=\"32359\"></p>\n\n<h4 data-nodeid=\"24577\">动态类型</h4>\n<p data-nodeid=\"24578\">另一类极有可能出现的错误是 JavaScript 动态类型特性造成的。</p>\n<p data-nodeid=\"24579\">如下示例第 1~3 行所示，我们习惯先定义一个空对象，再动态添加属性，迁移到 TypeScript 后就会提示一个对象上属性不存在的 ts(2339) 错误 。</p>\n<pre class=\"lang-javascript\" data-nodeid=\"24580\"><code data-language=\"javascript\"><span class=\"hljs-keyword\">const</span> obj = {};\nobj.id = <span class=\"hljs-number\">1</span>; <span class=\"hljs-comment\">// ts(2339)</span>\nobj.name = <span class=\"hljs-string\">'乾元亨利贞'</span>; <span class=\"hljs-comment\">// ts(2339)</span>\n</code></pre>\n<p data-nodeid=\"24581\">此时，我们需要通过重构代码解决这个问题，具体操作是预先定义完整的对象结构或类型断言。</p>\n<p data-nodeid=\"24582\">代码重构后的示例如下：</p>\n<pre class=\"lang-javascript\" data-nodeid=\"24583\"><code data-language=\"javascript\">interface IUserInfo {\n  <span class=\"hljs-attr\">id</span>: number;\n  name: string;\n}\n<span class=\"hljs-keyword\">const</span> obj = {} <span class=\"hljs-keyword\">as</span> IUserInfo;\nobj.id = <span class=\"hljs-number\">1</span>; <span class=\"hljs-comment\">// ok</span>\nobj.name = <span class=\"hljs-string\">'乾元亨利贞'</span>; <span class=\"hljs-comment\">// ok</span>\n</code></pre>\n<p data-nodeid=\"24584\">在第 5 行中，我们使用了类型断言解决了 ts(2339) 错误。</p>\n<h4 data-nodeid=\"24585\">有用的坏习惯</h4>\n<p data-nodeid=\"24586\">必要时，我们可以使用 // @ts-ignore 注释强制关闭下一行代码静态类型检测，但这绝对是一个坏习惯，示例如下：</p>\n<blockquote data-nodeid=\"24587\">\n<p data-nodeid=\"24588\"><strong data-nodeid=\"24719\">Tips：我们需要铭记所有绕过静态类型检测的方法都是魔鬼，尽量避免使用。</strong></p>\n</blockquote>\n<pre class=\"lang-typescript\" data-nodeid=\"24589\"><code data-language=\"typescript\"><span class=\"hljs-keyword\">const</span> objString = {\n  toString: <span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> <span class=\"hljs-string\">'乾元亨利贞'</span>\n}\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">getString</span>(<span class=\"hljs-params\">str: <span class=\"hljs-built_in\">string</span></span>) </span>{\n  <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">`<span class=\"hljs-subst\">${str}</span>`</span>);\n}\n<span class=\"hljs-comment\">// @ts-ignore</span>\ngetString(objString); <span class=\"hljs-comment\">// ts(2345)</span>\n</code></pre>\n<p data-nodeid=\"24590\">在示例中的第 7 行，因为我们使用了 // @ts-ignore 注释强行关闭第 8 行的静态类型检测，所以第 8 行并不会提示 ts(2345) 错误。</p>\n<p data-nodeid=\"24591\">另外，我们还可以使用 // @ts-nocheck 注释强制关闭整个文件静态类型检测。<strong data-nodeid=\"24725\">不过，我建议任何时候都不要使用这个注释。</strong></p>\n<p data-nodeid=\"24592\">另外一个有用的坏习惯是双重类型断言，即先把源类型值断言为 unknown，再把 unknown 断言为目标类型。比如上边使用 // @ts-ignore 注释的示例，我们也可以将它改造为双重类型断言，如下代码所示：</p>\n<pre class=\"lang-typescript\" data-nodeid=\"24593\"><code data-language=\"typescript\">getString(objString <span class=\"hljs-keyword\">as</span> unknown <span class=\"hljs-keyword\">as</span> <span class=\"hljs-built_in\">string</span>);&nbsp;\n</code></pre>\n<p data-nodeid=\"24594\">这样也不会提示 ts(2345) 错误了。</p>\n<h4 data-nodeid=\"24595\">自动迁移工具</h4>\n<p data-nodeid=\"24596\">如上边所提到，迁移过程是一项没有技术含量的体力活，因为其中存在很多重复、简单、有规律的操作，比如说将 JavaScript 文件修改为 TypeScript 文件、将模块引入方式从 ES5 require 改为 ES 6 import、将参数隐式 any 类型改为显式 any，这就意味着我们可以借助程序自动完成部分重复的迁移操作。</p>\n<p data-nodeid=\"24597\">比如我们可以使用 Airebnb 开源迁移工具<a href=\"https://github.com/airbnb/ts-migrate\" data-nodeid=\"24733\">ts-migrate</a>，快速地将 JavaScript 项目转换为基本可运行的 TypeScript 项目。因为该工具通过语法分析，可以快速推断出逻辑比较简单的函数/对象/类的类型。如下示例 1 中，JavaScript 函数 mult 经 ts-migrate 自动转换为 TypeScript 后，如下示例 2 中所示的参数 first、second 以及函数返回值类型都被明确为 number。</p>\n<p data-nodeid=\"24598\">示例 1</p>\n<pre class=\"lang-javascript\" data-nodeid=\"24599\"><code data-language=\"javascript\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">mult</span>(<span class=\"hljs-params\">first, second</span>) </span>{\n    <span class=\"hljs-keyword\">return</span> first * second;\n}\n</code></pre>\n<p data-nodeid=\"24600\">示例 2</p>\n<pre class=\"lang-typescript\" data-nodeid=\"24601\"><code data-language=\"typescript\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">mult</span>(<span class=\"hljs-params\">first: <span class=\"hljs-built_in\">number</span>, second: <span class=\"hljs-built_in\">number</span></span>): <span class=\"hljs-title\">number</span> </span>{\n    <span class=\"hljs-keyword\">return</span> first * second;\n}\n</code></pre>\n<h3 data-nodeid=\"24602\">小结和预告</h3>\n<p data-nodeid=\"24603\">以上就是JavaScript 应用迁移到 TypeScript 的全部内容，在实际迁移过程中，你需要综合利用前面所有课程的知识才能得心应手。课后建议你挑选一个中小型 JavaScript 项目尝试迁移。</p>\n<p data-nodeid=\"24604\">插播一道思考题：将 JavaScript 应用迁移到 TypeScript 的过程中，最常见的错误有哪些？都是如何解决的？</p>\n<p data-nodeid=\"24605\">下一讲是结束语，我们将一起回顾过往课程中涉及的一些重难知识点、实用技巧，以及概览 TypeScript 新版本中新增的若干重要特性，敬请期待。</p>\n<p data-nodeid=\"24606\">如果你觉得本专栏有价值，欢迎分享给更多好友~</p>",
                "article_title": "20 | 如何将 JavaScript 应用切换至 TypeScript？",
                "title": "20 | 如何将 JavaScript 应用切换至 TypeScript？",
                "id": 7452
            }
        ]
    },
    {
        "chapterTitle": "结束语",
        "children": [
            {
                "content": "<p data-nodeid=\"16788\" class=\"\">经过前面 20 讲的学习，我们已经了解了 TypeScript 从开发环境搭建、基础类型、高阶类型到业务实践的全链路知识。</p>\n<p data-nodeid=\"16789\">最后一讲我们再一起对过往实用的技能、重点或者容易混淆的知识进行提炼汇总，查漏补缺。</p>\n<h3 data-nodeid=\"16790\">知识回顾</h3>\n<h4 data-nodeid=\"16791\">Number、String、Boolean、Symbol</h4>\n<p data-nodeid=\"16792\">首先，我们来回顾一下初学 TypeScript 时，很容易和原始类型 number、string、boolean、symbol 混淆的首字母大写的 Number、String、Boolean、Symbol 类型，后者是相应原始类型的包裹对象，姑且把它们称之为对象类型。</p>\n<p data-nodeid=\"16793\">从类型兼容性上看，原始类型兼容对应的对象类型，反过来对象类型不兼容对应的原始类型。</p>\n<p data-nodeid=\"33258\">下面我们看一个具体的示例：</p>\n<pre data-nodeid=\"35472\" class=\"\"><code>let num: number;\nlet Num: Number;\nNum = num; // ok\nnum = Num; // ts(2322)\n\n</code></pre>\n\n\n\n\n\n<p data-nodeid=\"16796\">在示例中的第 3 行，我们可以把 number 赋给类型 Number，但在第 4 行把 Number 赋给 number 就会提示 ts(2322) 错误。</p>\n<p data-nodeid=\"16797\">因此，<strong data-nodeid=\"16904\">我们需要铭记不要使用对象类型来注解值的类型，因为这没有任何意义。</strong></p>\n<h4 data-nodeid=\"16798\">object、Object 和 {}</h4>\n<p data-nodeid=\"16799\">另外，object（首字母小写，03 讲我们介绍过，以下称“小 object”）、Object（首字母大写，以下称“大 Object”）和 {}（以下称“空对象”）也是容易混淆的类型。</p>\n<p data-nodeid=\"16800\">小 object 代表的是所有非原始类型，也就是说我们不能把 number、string、boolean、symbol 原始类型赋值给 object。<strong data-nodeid=\"16916\">在严格****模式下，null 和 undefined 类型也不能赋给 object。</strong></p>\n<p data-nodeid=\"35925\">下面我们看一个具体示例：</p>\n<pre data-nodeid=\"35926\" class=\"\"><code>let lowerCaseObject: object;\nlowerCaseObject = 1; // ts(2322)\nlowerCaseObject = 'a'; // ts(2322)\nlowerCaseObject = true; // ts(2322)\nlowerCaseObject = null; // ts(2322)\nlowerCaseObject = undefined; // ts(2322)\nlowerCaseObject = {}; // ok\n\n</code></pre>\n\n\n\n\n<p data-nodeid=\"16803\">在示例中的第 2~6 行都会提示 ts(2322) 错误，但是我们在第 7 行把一个空对象赋值给 object 后，则可以通过静态类型检测。</p>\n<p data-nodeid=\"16804\">大Object 代表所有拥有 toString、hasOwnProperty 方法的类型，所以所有原始类型、非原始类型都可以赋给 Object。<strong data-nodeid=\"16942\">同样，在严格模式下，null 和 undefined 类型也不能赋给 Object。</strong></p>\n<p data-nodeid=\"39064\">下面我们也看一个具体的示例：</p>\n<pre data-nodeid=\"39065\" class=\"\"><code>let upperCaseObject: Object;\nupperCaseObject = 1; // ok\nupperCaseObject = 'a'; // ok\nupperCaseObject = true; // ok\nupperCaseObject = null; // ts(2322)\nupperCaseObject = undefined; // ts(2322)\nupperCaseObject = {}; // ok\n\n</code></pre>\n\n\n\n\n<p data-nodeid=\"16807\">在示例中的第 2~4 行、第 7 行都可以通过静态类型检测，而第 5~6 行则会提示 ts(2322) 错误。</p>\n<p data-nodeid=\"16808\">从上面示例可以看到，大 Object 包含原始类型，小 object 仅包含非原始类型，所以大 Object 似乎是小 object 的父类型。实际上，大 Object 不仅是小 object 的父类型，同时也是小 object 的子类型（回想 15 讲中我们实现的判断两个类型是否相等的工具泛型 isEqualV3，其实就是区分不了大 Object 和小 object）。</p>\n<p data-nodeid=\"39685\">下面我们还是通过一个具体的示例进行说明。</p>\n<pre data-nodeid=\"39686\" class=\"\"><code>type isLowerCaseObjectExtendsUpperCaseObject = object extends Object ? true : false; // true\ntype isUpperCaseObjectExtendsLowerCaseObject = Object extends object ? true : false; // true\nupperCaseObject = lowerCaseObject; // ok\nlowerCaseObject = upperCaseObject; // ok\n\n</code></pre>\n\n\n\n\n<p data-nodeid=\"16811\">在示例中的第 1 行和第 2 行返回的类型都是 true，第3 行和第 4 行的 upperCaseObject 与 lowerCaseObject 可以互相赋值。</p>\n<blockquote data-nodeid=\"16812\">\n<p data-nodeid=\"16813\"><strong data-nodeid=\"16979\">注意：尽管官方文档说可以使用小 object 代替大 Object，但是我们仍要明白大 Object 并不完全等价于小 object。</strong></p>\n</blockquote>\n<p data-nodeid=\"42678\">{}空对象类型和大 Object 一样，也是表示原始类型和非原始类型的集合，并且在严格模式下，null 和 undefined 也不能赋给 {} ，如下示例：</p>\n<pre data-nodeid=\"42679\" class=\"\"><code>let ObjectLiteral: {};\nObjectLiteral = 1; // ok\nObjectLiteral = 'a'; // ok\nObjectLiteral = true; // ok\nObjectLiteral = null; // ts(2322)\nObjectLiteral = undefined; // ts(2322)\nObjectLiteral = {}; // ok\ntype isLiteralCaseObjectExtendsUpperCaseObject = {} extends Object ? true : false; // true\ntype isUpperCaseObjectExtendsLiteralCaseObject = Object extends {} ? true : false; // true\nupperCaseObject = ObjectLiteral;\nObjectLiteral = upperCaseObject;\n\n</code></pre>\n\n\n\n\n<p data-nodeid=\"16816\">在示例中的第 8 行和第 9 行返回的类型都是 true，第10 行和第 11 行的 ObjectLiteral 与 upperCaseObject 可以互相赋值，第2~4 行、第 7 行的赋值操作都符合静态类型检测；而第5 行、第 6 行则会提示 ts(2322) 错误。</p>\n<p data-nodeid=\"42917\" class=\"\"><strong data-nodeid=\"42921\">综上结论：{}、大 Object 是比小 object 更宽泛的类型（least specific），{} 和大 Object 可以互相代替，用来表示原始类型（null、undefined 除外）和非原始类型；而小 object 则表示非原始类型。</strong></p>\n\n<blockquote data-nodeid=\"16818\">\n<p data-nodeid=\"16819\" class=\"\">这里插播一道思考题：基于以上总结，请实现一个能够区分大 Object 和小 object 的 isEqualV4。</p>\n</blockquote>\n<h4 data-nodeid=\"16820\">严格与非严格模式</h4>\n<p data-nodeid=\"16821\">关于静态类型检测的工作模式，在课程中我们也经常提到严格和非严格模式的区别，实际上最让人困惑的是 strictNullChecks 和 strictFunctionTypes 这两个设置。</p>\n<p data-nodeid=\"16822\">strictNullChecks 影响的是 null、undefined 与其他类型的兼容性问题，比如上边提到，开启 strictNullChecks 时，null、undefined 不兼容大、小 object 和 {}，但关闭 strictNullChecks 时，它们又是兼容的。</p>\n<p data-nodeid=\"16823\">strictFunctionTypes 则影响的是函数类型检测，开启 strictFunctionTypes 时，函数参数是逆变的，而关闭 strictFunctionTypes 时，函数参数则变成了双向协变。</p>\n<p data-nodeid=\"43409\" class=\"\"><strong data-nodeid=\"43420\">因此</strong>，在 TypeScript 的所有项目中使用严格模式（尤其是以上两个配置），实际上可以降低心智成本。<b><strong data-nodeid=\"43421\">在实</strong></b>际工作中，我们只需要理解 TypeScript 在严格模式下的特性并严格遵循，代码就是类型安全的。</p>\n\n\n<h4 data-nodeid=\"16825\">类型增强</h4>\n<p data-nodeid=\"16826\">在 TypeScript 中，如果文件包含顶层的 export 或者 import，则会被当作 module，在 module 中定义的、没有显式 export 的变量、函数、类对外都不可见；相反，如果文件不包含顶层的 export 或者 import，则会被当作 script，script 里的内容（类型声明、变量声明）都是全局可见的（对 module 也是可见的）。</p>\n<p data-nodeid=\"16827\">这就是为什么使用同样的语法进行人工补齐类型声明时，有的类型声明在其他的模块、文件中无需显式 import 就可以直接使用，而有的类型声明必须显式 import 之后才可以使用。</p>\n<p data-nodeid=\"16828\"><strong data-nodeid=\"17046\">需要注意</strong>：因为 script 中的内容都是全局可见的，一方面我们应该避免定义过多全局类型，另一方面也要使用足够特性化的唯一标识来命名全局类型，从而避免全局命名污染。</p>\n<p data-nodeid=\"45672\">下面看一个具体的示例：</p>\n<pre data-nodeid=\"45673\" class=\"\"><code>// myAugmention.ts\nnamespace MyNameSpaceExample {\nexport type id = number; // 此处非顶层 export\nexport type name = string;\n}\ntype TSCourseUserInfoName = string;\n\n</code></pre>\n\n\n\n\n\n\n\n\n\n\n\n<p data-nodeid=\"16831\" class=\"\">在示例中的第 2~4 行，我们使用了 namespace 组织 id、name 等比较容易出现命名冲突的类型（namespace 中只有显式 export 的成员才对外可见），然后在第 6 行命名了一个足够特性化的全局 TSCourseUserInfoName。接下来我们就可以在任何其他地方通过类型名、命名空间名 + 类型名访问全局类型。</p>\n<p data-nodeid=\"16832\"><strong data-nodeid=\"17072\">此外，为了避免其他人在 myAugmention.ts 中添加顶层 export 或者 import，导致 script 变 module、类型全局可见性被破坏，我们可以显式添加描述信息，比如标明“ script 文件，请勿添加顶层 export 或者 import”。<b><strong data-nodeid=\"17071\">反过</strong></b>来，我们也可以在 script 中添加“export {}”，显式地把 script 改为 module，避免类型全局污染。</strong></p>\n<p data-nodeid=\"48143\">如果我们确实想让 module 中的类型全局可见，则可以使用 declare global 声明全局类型，如下示例：</p>\n<pre data-nodeid=\"48144\" class=\"\"><code>// myGlobalModule.ts\ndeclare global {\ntype GlobalUserId = number;\n}\n\n</code></pre>\n\n\n\n\n<p data-nodeid=\"16835\">在示例中的第 2~4 行，我们声明了可以在任何地方访问的全局类型 GlobalUserId（如果你们的示例中只有这么几行代码，肯定访问不到 GlobalUserId）。</p>\n<p data-nodeid=\"16836\">下面我们再来回顾一下类型断言的一般性原则。</p>\n<h4 data-nodeid=\"16837\">类型断言</h4>\n<p data-nodeid=\"25544\">对于复杂类型而言，父子类型可以互相断言；对于原始类型 number、string、boolean 而言，属于同一原始类型的字面量类型以及字面量类型组成的联合类型也可以互相断言，如下示例：</p>\n<pre data-nodeid=\"31613\" class=\"\"><code>let NumberLiteral1: 1 = 1;\nlet NumberLiteral2: 2 = 2;\nlet StringLiterala: 'a' = 'a';\nlet StringLiteralb: 'b' = 'b';\nlet MixedLiteral1: typeof NumberLiteral1 \\| typeof StringLiterala = 1;\nlet MixedLiteral2: typeof NumberLiteral2 \\| typeof StringLiteralb = 2;\nNumberLiteral1 = NumberLiteral2 as 1; // ok\nNumberLiteral2 = NumberLiteral1 as 2; // ok\nStringLiterala = StringLiteralb as 'a'; // ok\nStringLiteralb = StringLiterala as 'b'; // ok\nMixedLiteral1 = MixedLiteral2 as typeof MixedLiteral1; // ok\nMixedLiteral2 = MixedLiteral1 as typeof MixedLiteral2; // ok\n</code></pre>\n<p data-nodeid=\"31614\" class=\"\">在示例中的第 7~12 行的类型断言虽然都符合静态类型检测，却没有任何实际的意义，并且不安全。</p>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n<p data-nodeid=\"16841\">以上是对本专栏的重难点回顾，接下来我们了解一下 TypeScript 最近一段时间新增的重要特性。</p>\n<h3 data-nodeid=\"16842\">TypeScript 新特性和变更</h3>\n<p data-nodeid=\"16843\">TypeScript 迭代十分活跃，至本课程截稿已经发布了 4.0、4.1、4.2 版本，以下我按照版本号整理了部分新增特性和 break changes。</p>\n<h4 data-nodeid=\"16844\"><strong data-nodeid=\"17148\">4.0</strong>可变元组</h4>\n<p data-nodeid=\"16845\">03 讲中我们学习了元组的定义：元素类型、个数确定的数组即元组，在 TypeScript 4.0 版本中，新引入了两处功能性的变更支持可变元组：</p>\n<ul data-nodeid=\"52767\">\n<li data-nodeid=\"52768\">\n<p data-nodeid=\"52769\">第一个变更是在元组类型的语法中，我们可以对泛型使用展开运算符，如以下示例第 4 行（注意：TypeScript 4.0 以下版本会提示 ts(1256) 错误）；</p>\n</li>\n<li data-nodeid=\"52770\" class=\"\">\n<p data-nodeid=\"52771\">另外一个变更是可以在元组中的任何位置使用剩余元素，如以下示例第 8 行所示。</p>\n</li>\n</ul>\n<pre data-nodeid=\"52772\" class=\"\"><code>const TupleA = ['A'] as const;\nconst TupleB = ['B'] as const;\ntype TupleType = readonly any[];\nfunction concat\\&lt;T extends TupleType, U extends TupleType&gt;(arr1: T, arr2: U): [...T, ...U] { // ts(1256)\nreturn [...arr1, ...arr2]; // ts(2741)\n}\nconst TupleC = concat(TupleA, TupleB); // ['A', 'B']\ntype ConcatedTuple = [ ...(typeof TupleA), ...(typeof TupleB)];\n\n</code></pre>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n<p data-nodeid=\"16851\">可变元组的引入，使得我们可以极其方便地实现一些有意思的功能，比如合并两个元组为一个新的元组的函数，在上述示例中的第 7 行，我们调用了第 4~6 行定义的函数 concat 合并元组 ['A'] 和 ['B'] ，从而得到了新的元组类型 ['A', 'B'] 。如果没有可变元组（比如 在 TypeScript 3.9 中），我们就需要给函数 concat 编写 m * n 个重载类型，比如支持长度为 5 的元组合并就需要编写 25 个类型重载。</p>\n<p data-nodeid=\"16852\">可变元组还可以极大地提升函数式编程的类型体验和可能性，我们可以在函数组合中使用可变元组约束高阶函数入参和返回值的类型，比如对 JavaScript 内置 bind 方法更好地进行类型检测支持。</p>\n<h4 data-nodeid=\"16853\">4.0 元组元素标签</h4>\n<p data-nodeid=\"55299\">另外一个元组相关的变更是我们可以在元组类型的定义中给元素指定标签，让代码更具语义化、可读性，如下示例：</p>\n<pre data-nodeid=\"55300\" class=\"\"><code>type LabeledTupleType = [id: number, name: string];\n\n</code></pre>\n\n\n\n\n<p data-nodeid=\"16856\">在示例中的第 1 行，我们给元组的两个元素分别指定了 id 和 name 的标签。</p>\n<p data-nodeid=\"16857\">接下来，我们了解一下 4.1 版本中的新特性和变更。</p>\n<h4 data-nodeid=\"16858\"><strong data-nodeid=\"17247\">4.1</strong>模板字面量类型</h4>\n<p data-nodeid=\"16859\">不得不说，模板字面量类型是 4.1 版本中非常有创造力和想象力的新特性，它使得字符串类型也具备了可变可运算的能力。</p>\n<p data-nodeid=\"59777\">我们可以基于已有的字符串字面量衍生出新的字面量类型，也就是说既可以使用模板语法拼接字符串，也可以使用内置工具函数对模板变量进行转换，如下示例：</p>\n<pre data-nodeid=\"59778\" class=\"\"><code>type PrefixType\\&lt;P extends string, N extends string&gt; = `${P}/${Capitalize&lt;string &amp; N&gt;}`;\ntype UserLoginAction = PrefixType&lt;'User', 'login'&gt;; // 'User/Login'\n\n</code></pre>\n\n\n\n\n\n\n\n\n\n\n\n<p data-nodeid=\"16862\">示例中的第 1 行，因为我们定义了泛型 PrefixType，它可以接收字符串类型入参 P 和 N，并以“P + / + 首字母大写 N ”的格式返回，所以第 2 行入参是 'User' 和 'login' 时，返回的类型是 'User/Login'。</p>\n<p data-nodeid=\"16863\">回想一下在 18 讲中介绍的组件和 Redux 类型化中提到的路由属性和 action type，我们就可以基于模板字符串类型实现更全面的类型化。</p>\n<p data-nodeid=\"16864\">我们可以将路由属性中的 params 参数对象和路由字符串规则关联起来，比如将 { id: string; name: string}和“user/:id/:name/”进行关联。同样，我们也可以更方便地将 Redux 中的 action name 和 action type 关联起来，比如将 doLogin 和 'user'/'login' 进行关联。</p>\n<h4 data-nodeid=\"16865\">4.1 映射类型键名重新映射</h4>\n<p data-nodeid=\"62182\">4.1 版本另一个重要的特性：在映射类型中，我们可以使用 as 操作符对键名重新映射（可以理解为针对类型的类型断言），如下示例：</p>\n<pre data-nodeid=\"62763\" class=\"\"><code>type Getters = {\n[K in keyof T as `get${Capitalize&lt;string &amp; K&gt;}`]: () =&gt; T[K];\n};\ntype UserInfoGetters = Getters&lt;{ id: number; name: string; }&gt;\n\n</code></pre>\n\n\n\n\n\n\n<p data-nodeid=\"16869\">在示例中的第 2 行，因为我们提取了入参 T 的属性名，并将其重新映射为“get”前缀+属性名首字母大写拼接格式的新属性名，然后作为返回新类型的属性，所以第三行返回的类型是 { getId: number; getName: string; }。</p>\n<p data-nodeid=\"16870\">接下来我们看一下本课程截稿前发布的最新版本（ 4.2 版本）的新特性。</p>\n<h4 data-nodeid=\"16871\"><strong data-nodeid=\"17316\">4.2</strong>元组头部/中间剩余元素</h4>\n<p data-nodeid=\"64592\">在 4.2 版本中，我们可以在元组的任何地方使用剩余元素表达式，而不再仅仅局限于元组的尾部，如下示例：</p>\n<pre data-nodeid=\"64593\" class=\"\"><code>let prefixRestTuple: [...rest: string[], number] = ['a', 'b', 1];\nlet middleRestTuple: [boolean, ...rest: string[], number] = [true\n,'a', 'b', 1];\n\n</code></pre>\n\n\n\n\n<p data-nodeid=\"16874\">在示例中的第 1 行，我们在元组的头部定义了剩余元素。第 2 行，我们在元组的中间位置定义了剩余元素。</p>\n<h4 data-nodeid=\"16875\">4.2 yield 表达式提示 noImplicitAny 错误</h4>\n<p data-nodeid=\"65331\" class=\"\">在 TypeScript 的 4.2 版本中，另一个有用而颇具破坏性的特性是，必须显式注解 yield 表达式的返回值类型，否则会提示 noImplicitAny 错误。</p>\n\n<p data-nodeid=\"16877\">这个变更极有可能影响第 18 讲“TypeScript Web 开发”中提到的使用 Redux-saga 管理副作用的 Redux 类型化方案。如果之前我们在 Redux-saga 副作用函数中没有显式指定 yield 表达式返回值类型，那么 TypeScript 升级为 4.2 版本之后就需要重构代码，并补全缺失的返回值类型。</p>\n<p data-nodeid=\"16878\">以上就是我觉得有必要单独补充和同步的 TypeScript 官方新特性和变更。</p>\n<p data-nodeid=\"69004\" class=\"te-preview-highlight\">从这些新特性和变更中我们不难发现，实际上所有的变更都是朝着愈发严格而全面的类型安全目标演进的。因此，我们与其被动地重构代码，以兼容愈发严格的静态类型检测，不如从学习使用 TypeScript 之初就启用严格模式，以追求最高标准，养成好习惯。这也是我在整个专栏期间最中肯的建议和最执着的要求，当然也是最好的实践。</p>\n\n\n\n\n\n<p data-nodeid=\"16880\">注意：TypeScript 更新快，特性日新月异，我们可以通过官方文档的发版日志模块获取更多详细信息，详见[链接]。</p>\n<h3 data-nodeid=\"16881\">寄语</h3>\n<p data-nodeid=\"16882\">以上就是这一讲的全部内容，感谢你坚持到最后一讲。</p>\n<p data-nodeid=\"16883\">这门课程的学习过程，对你们而言是一场有意义的 TypeScript 学习之旅，对我自己而言也同样是一场有意义的系统性复习和总结之旅。</p>\n<p data-nodeid=\"16884\" class=\"\">最后，感谢大家的支持，希望我总结的经验能帮助你更快、更好地了解和掌握 TypeScript，愿严格安全的静态类型保佑你！</p>",
                "article_title": "结束语 | TypeScript 的这些实用技能，你不得不知",
                "title": "结束语 | TypeScript 的这些实用技能，你不得不知",
                "id": 7453
            }
        ]
    }
]