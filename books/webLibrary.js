exports.category = "frontend";
exports.title = "手把手带你写一个Web框架";
exports.data = [
  {
    chapterTitle: "开篇词",
    children: [
      {
        title: "开篇词｜为什么我们要从零开发框架？",
        id: 417657,
        content:
          '<p>你好，我是叶剑峰，可能你更熟悉我的网名“轩脉刃”。</p><p>作为一线程序员，我已经工作十多年了，前后就职于奇虎、滴滴、腾讯，专注服务端研发，包括服务端的架构搭建、维护、优化等等。</p><p>因为一直在一线为技术团队搭建业务架构和解决实际问题，在这个过程中踩过太多坑，所以逐步形成了自己的一套方法论，之前在团队内部分享效果很好，朋友也总跟我说，该找时间整理输出。</p><p>所以当极客时间找到我开这门 Go Web 框架课的时候，我很高兴，希望尽可能帮新同学少走点弯路，尤其现在Web框架层出不穷，如果你还没有合适的入门方法，在学习或者使用框架的时候，就很容易迷失在追逐新框架、新特性的泥潭中。</p><p>那么如何选择或者打造一款称手的 Web 应用框架呢？这是我们在日常工作中经常遇到的问题。</p><p>因为不管什么语言，在 Web 领域，总有很多款开发框架，真的可以说是日新月异，<a href="https://github.com/mingrammer/go-web-framework-stars">GitHub 上的 Go Web 框架</a>现在已经有41款了。</p><p><img src="https://static001.geekbang.org/resource/image/17/00/17e06aeac40547a148cdbed09bfecf00.png?wh=1782x1342" alt=""></p><p>面对如此多的选择，有的同学喜欢追求最全的框架，觉得功能越多越好，但是往往并不是每一个功能都能在实际工作中用到；有的同学喜欢追求性能最高的框架，但是总觉得用起来非常别扭；也常有同学会认为框架无好坏，每个框架基本都差不多，最终的选择就是两个字：都行。</p><!-- [[[read_end]]] --><p>但是这些说法其实是进入了一个思维误区：<strong>没有把框架放到特定场景上讨论，这个特定场景，就是开发团队的业务环境</strong>。</p><p>比如，如果你一个人负责一个小的外包项目，那可以说所有框架都差不多；如果是 2～3 个服务端人员的初创团队，你用的框架要承担的工作大概率是提升开发效率，那就要选择功能更强大、易用性更好的框架；等团队再大一些，框架所承担的职责就更多了，往往得更多考虑性能、扩展性，或者定制自己的框架。</p><h2>聊聊Web 框架</h2><p>所有框架都有倾向性，我觉得基本可以分为两个大类：一类是追求运行性能，一类是追求开发效率。</p><p>追求性能的框架往往很简洁，包含的东西也很少，一个路由一个 MVC 就完事了，比如 Gin 框架；另外一类框架追求开发效率，封装得非常好，很多功能会让你惊叹，能帮你省很多事，最典型的就是 Beego 框架。</p><p>但从我个人经验看，在 Web 领域，特别是中小型项目，开发效率往往才是业务的第一需求。一个产品拥有的市场机会总是转瞬即逝的，抢占市场都是靠更快的开发速度和迭代速度。所以，<strong>在任何领域做到第一名的产品基本上都有一个共性：开发、迭代速度快。</strong>这就和古龙小说中评价天下侠士的武功一样，唯快不破。</p><p>所以作为开发必备的框架，在提效上尤为重要。这就要求好的框架要能区分清楚业务团队和架构团队的边界，什么应该是写业务的人负责的？什么应该是做架构的人负责的?</p><p>写架构的同学，做好框架的底层封装。而写业务的同学可以从底层实现中释放出来，专注于业务逻辑，遇到任何底层问题，在框架中都有简单易用的封装可用，框架中的每一个类、每一个服务接口都在告诉你，要完成这个功能，只需要这样使用，无需更多的操作。</p><p>总而言之，框架是为加速业务发展而生的，它需要兼顾业务的开发效率和底层的性能效率，而这两者在 Go 这门语言出现后得到了很好地结合。</p><h2>Go Web框架</h2><p>在 Go 出现之前，我们都知道，PHP 和 Java 基本上是 Web 领域的主流，特别是 PHP，是当时各种公司建站的首选。其实 PHP 和 HTML 的契合性是好于 Go 的，尤其在快速编写动态网页的时候，因为它可嵌入 HTML 的特性，于是建立 Web 站就变成了一件非常容易的事。</p><p>但是这几年，Web 领域越来越流行前后端分离，Web 后端开发慢慢从繁杂的 HTML 渲染中解放出来了，开始把研发注意力放在如何建立数据模型（接口设计）、如何搭建更稳定可扩展的服务（分布式）上。在这个大趋势下，Go 在 Web 领域可以说是大放异彩。</p><p>我接触 Go 算是比较早的，2012 年第一次接触的时候 Go 还在 0.9 版本，当时看它的并发编程，我都震惊了，居然这么简易。之后，我就开始推动 Go 的落地实践，在大大小小的工作项目中，发现 <strong>Go 真的很好地平衡了开发和性能</strong>。</p><p>比方说，Go 语言中的 Goroutine 设计，提供了“一个请求一个协程”的请求模型，对比 PHP 的“一个请求一个进程”的模型，能有效提升后端的资源占用和调度负载；另外，Go 的 Runtime 机制让运行程序不再依赖各种的环境和库，将 Web 服务的部署和搭建变得简单高效；而 Go 提供的交叉编译、数据结构、channel 等语言级别特性，都让“处理 Web 请求”这个事情变得非常简单。</p><p>所以这几年，Go 在各个领域，比如云原生、游戏、微服务、区块链等等，优势也越发明显。</p><p>这也是我为什么选择 Golang 来搭建 Web 框架的原因，一方面看好 Golang 的市场前景，另一方面 Golang 确实让 Web 开发变得越来越有效率。</p><h2>为什么要从零开发</h2><p>决定好用什么语言了，我们就得关注怎么学了。好框架能提升开发效率，那要了解 Web 框架，为什么我又鼓励你从零开发呢？这不是自相矛盾了，自己造轮子能比用现成的快吗？</p><p>或许你可以听听我的经验之谈！</p><p>首先，对我们程序员来说，了解一个东西最好的办法就是去实现它。只有自己搭建一个新的框架，才能掌握Web服务的本质。</p><p>可选框架这么多，新框架也层出不穷，我们不可能也没有必要完全掌握所有框架。<strong>如果你只学怎么用框架，按照文档“按部就班”，是永远不可能真正做到掌握框架的</strong>。</p><p>但是只要你开始动手做一个框架，你就能站在框架作者的角度，遇到作者开发时遇到的问题，思考作者开发时选择的方案，从本质上理解清楚这些框架都在做些什么、为什么这么设计，之后在工作中遇到类似问题的时候，也会清楚这个问题为什么会出现，解决也就不在话下了。</p><p>其次，<strong>从零开发作为一种学习方法，并不意味着在工作中我们要从零搭建框架</strong>。</p><p>从作者的角度了解清楚框架本质后，再思考工作中我们实际要用的框架，你就会发现，它有自己的倾向性，有自己的设计感，并不是每个设计都能满足你的需求。那么框架用久了，我们就要思考，如果我需要一个能满足我想法的框架，它应该是什么样子的？有怎样的设计？</p><p>举个例子，框架就像大楼的地基，而业务就像是房子。房子的形态可以是各异的，随业务不同任你发挥，但建房子之前你必须打造好自己的地基，这期间你当然可以参考前人的方案、经验、实施策略，让自己的框架地基更牢靠。</p><p>这样，新的业务需求来了，你就能快速搭出房子解决问题，而我们这门课要讲的就是我在 Web 领域所打造的地基，也是你可以深度参与的一个实战项目。</p><h2>学习路径</h2><p>最终目标是使用 Golang 开发出一个属于自己的工业级 Web 框架，而在具体的学习上，我设置了四个关卡。</p><p><img src="https://static001.geekbang.org/resource/image/f6/23/f65904c0ef6f3d729d974c43f2019823.jpg?wh=1920x1080" alt=""></p><p><strong>实战第一关</strong>：我会带你分析 Web 框架的本质，从最底层的 Go 的 HTTP 库开始讲起，如何基于 HTTP 库建立server、如何搭建路由、如何增加中间件等等，从而搭建出一个 Web 框架最核心的设计部分。</p><p><strong>实战第二关</strong>：框架核心搭建好了，我们会基于具体业务场景重新思考：设计框架的目标到底是什么? 框架的设计感和要解决的问题在哪里? 框架的倾向性是什么? 如果要搭建出一个“一切皆服务”的框架应该如何设计。</p><p>思考清楚后，我们会用 Gin 框架集成实战第一关自研的 Web 框架的核心，要知道，站在巨人的肩膀上，我们才能有更广阔的视野，然后一步步实现框架核心的功能服务。</p><p><strong>实战第三关</strong>：我将带你为这个框架增加不同的周边功能，在添加功能时，我们会先讨论目前社区中的标准做法是什么样的，有没有更好的设计，最终把这些标准做法融合到我们的框架中。</p><p><strong>实战第四关</strong>：现在框架已经基本搭建完成了，我们会用这个框架应用开发一个类似知乎的问答管理后台，我们使用vue-element-admin来做前端封面，再结合我们的框架开发具体的统计展示和计算业务。</p><p>通关不易，所以每一讲我都会依次为你讲解实现过程和细节，阐述每个设计的思路和原理，同时也会将我个人在 Golang 领域的一些学习技巧和小方法分享给你。希望你在认真学习后，不仅仅是获得了框架代码这条鱼，更能懂得如何思考和动手捕鱼。</p><p>另外，每节课我都会给到代码demo，你能跟着课程一步步实现。课程的所有代码，包括这个框架我都已经放在<a href="https://github.com/gohade/hade"> GitHub </a>上了，还有完整的<a href="http://hade.funaio.cn/">说明文档</a>。带着目标去学习也是一个很好的方法，所以如果你想了解一下最终的成型框架，提前看看成品也是可以的。</p><p><img src="https://static001.geekbang.org/resource/image/d8/5b/d871bd96cb0bd3d7c184d8c8da6e795b.png?wh=2540x1414" alt=""></p><p>最后再多说一点，解说代码的时候，可能会有些枯燥，我会画图帮助你理解。关键代码也都增加了注释，如果你有疑问，欢迎给我留言，我会一一解答！</p><p>孤军奋战遇到劲敌很容易折戟沉沙，如果你身边有在使用 Web框架的同学，也欢迎你把这门课程分享给TA，共同学习，一起仗剑走天涯。</p><p>好了，现在就让我们一起开始这场充满挑战的 Go Web 框架研发之旅吧!</p><p><a href="https://jinshuju.net/f/Uk3003">点这里</a>进微信群，一起讨论。</p>',
        article_title: "开篇词｜为什么我们要从零开发框架？",
      },
    ],
  },
  {
    chapterTitle: "实战第1关：从零开始",
    children: [
      {
        title: "01｜net/http：使用标准库搭建Server并不是那么简单",
        id: 417674,
        content:
          '<p>你好，我是轩脉刃。欢迎加入我的课程，和我一起从0开始构建Web框架。</p><p>之前我简单介绍了整个课程的设计思路，也是搭建Web框架的学习路径，我们会先基于标准库搭建起Server，然后一步一步增加控制器、路由、中间件，最后完善封装和重启，在整章学完后，你就能建立起一套自己的Web框架了。</p><p>其实你熟悉Golang的话就会知道，用官方提供的 net/http 标准库搭建一个Web Server，是一件非常简单的事。我在面试的时候也发现，不少同学，在怎么搭怎么用的问题上，回答的非常溜，但是再追问一句为什么这个 Server 这么设计，涉及的 net/http 实现原理是什么? 一概不知。</p><p>这其实是非常危险的。<strong>实际工作中，我们会因为不了解底层原理，想当然的认为它的使用方式</strong>，直接导致在代码编写、应用调优的时候出现各种问题。</p><p>所以今天，我想带着你从最底层的 HTTP 协议开始，搞清楚Web Server本质，通过 net/http 代码库梳理 HTTP 服务的主流程脉络，先知其所以然，再搭建框架的Server结构。</p><p>之后，我们会基于今天分析的整个 HTTP 服务主流程原理继续开发。所以这节课你掌握的程度，对于后续内容的理解至关重要。</p><h2>Web Server 的本质</h2><!-- [[[read_end]]] --><p>既然要搭 Web Server，那我也先简单介绍一下，维基百科上是这么解释的，Web Server 是一个通过 HTTP 协议处理Web请求的计算机系统。这句话乍听有点绕口，我给你解释下。</p><p>HTTP 协议，在 OSI 网络体系结构中，是基于TCP/IP之上第七层应用层的协议，全称叫做超文本传输协议。啥意思？就是说HTTP协议传输的都是文本字符，只是这些字符是有规则排列的。这些字符的排列规则，就是一种约定，也就是协议。这个协议还有一个专门的描述文档，就是<a href="https://datatracker.ietf.org/doc/html/rfc2616">RFC 2616</a>。</p><p>对于 HTTP 协议，无论是请求还是响应，传输的消息体都可以分为两个部分：HTTP头部和 HTTP Body体。头部描述的一般是和业务无关但与传输相关的信息，比如请求地址、编码格式、缓存时长等；Body 里面主要描述的是与业务相关的信息。<img src="https://static001.geekbang.org/resource/image/cb/e0/cbbafb7ac6128b6e6f8bde0c983c7ae0.jpg?wh=1920x1080" alt=""></p><p>Web Server 的本质，实际上就是<strong>接收、解析</strong> HTTP 请求传输的文本字符，理解这些文本字符的指令，然后进行<strong>计算</strong>，再将返回值<strong>组织成</strong> HTTP 响应的文本字符，通过 TCP 网络<strong>传输回去</strong>。</p><p>理解了Web Server 干的事情，我们接下来继续看看在语言层面怎么实现。</p><h2>一定要用标准库吗</h2><p>对 Web Server 来说，Golang 提供了 net 库和 net/http 库，分别对应OSI的 TCP 层和 HTTP 层，它们两个负责的就是 HTTP 的接收和解析。</p><p>一般我们会使用 net/http 库解析 HTTP 消息体。但是可能会有人问，如果我想实现 Web 服务，可不可以不用 net/http 库呢？比如我直接用 net 库，逐字读取消息体，然后自己解析获取的传输字符。</p><p>答案是可以的，如果你有兼容其它协议、追求极致性能的需求，而且你有把握能按照 HTTP 的RFC 标准进行解析，那完全可以自己封装一个HTTP库。</p><p>其实在一些大厂中确实是这么做的，每当有一些通用的协议需求，比如一个服务既要支持 HTTP，又要支持 Protocol Buffers，又或者想要支持自定义的协议，那么他们就可能抛弃 HTTP 库，甚至抛弃 net 库，直接自己进行网络事件驱动，解析 HTTP 协议。</p><p>有个开源库，叫 <a href="https://github.com/valyala/fasthttp">FastHTTP</a>，它就是抛弃标准库 net/http 来实现的。作者为了追求极高的HTTP性能，自己封装了网络事件驱动，解析了HTTP协议。你感兴趣的话，可以去看看。</p><p>但是现在绝大部分的 Web 框架，都是基于 net/http 标准库的。我认为原因主要有两点：</p><ul>\n<li>第一是<strong>相信官方开源的力量</strong>。自己实现HTTP协议的解析，不一定会比标准库实现得更好，即使当前标准库有一些不足之处，我们也都相信，随着开源贡献者越来越多，标准库也会最终达到完美。</li>\n<li>第二是<strong>Web 服务架构的变化</strong>。随着容器化、Kubernetes 等技术的兴起，业界逐渐达成共识，单机并发性能并不是评判 Web 服务优劣的唯一标准了，易用性、扩展性也是底层库需要考量的。</li>\n</ul><p>所以总体来说，net/http 标准库，作为官方开源库，其易用性和扩展性都经过开源社区和Golang官方的认证，是我们目前构建Web Server首选的HTTP协议库。</p><p>用net/http来创建一个 HTTP 服务，其实很简单，下面是<a href="https://pkg.go.dev/net/http@go1.15.5">官方文档</a>里的例子。我做了些注释，帮你理解。</p><pre><code class="language-go">// 创建一个Foo路由和处理函数\nhttp.Handle("/foo", fooHandler)\n\n// 创建一个bar路由和处理函数\nhttp.HandleFunc("/bar", func(w http.ResponseWriter, r *http.Request) {\n\tfmt.Fprintf(w, "Hello, %q", html.EscapeString(r.URL.Path))\n})\n\n// 监听8080端口\nlog.Fatal(http.ListenAndServe(":8080", nil))\n</code></pre><p>是不是代码足够简单？一共就5行，但往前继续推进之前，我想先问你几个问题，<strong>这五行代码做了什么，为什么就能启动一个 HTTP 服务，具体的逻辑是什么样的</strong>？</p><p>要回答这些问题，你就要深入理解 net/http 标准库。要不然，只会简单调用，却不知道原理，后面哪里出了问题，或者你想调优，就无从下手了。</p><p>所以，我们先来看看 net/http 标准库，从代码层面搞清楚整个 HTTP 服务的主流程原理，最后再基于原理讲实现。</p><h2>net/http 标准库怎么学</h2><p>想要在 net/http 标准库纷繁复杂的代码层级和调用中，弄清楚主流程不是一件容易事。要快速熟悉一个标准库，就得找准方法。</p><p><strong>这里我教给你一个快速掌握代码库的技巧：库函数 &gt; 结构定义 &gt; 结构函数</strong>。</p><p>简单来说，就是当你在阅读一个代码库的时候，不应该从上到下阅读整个代码文档，而应该先阅读整个代码库提供的对外库函数（function），再读这个库提供的结构（struct/class），最后再阅读每个结构函数（method）。<img src="https://static001.geekbang.org/resource/image/81/79/8150f242d1f0ee96f44793112c4dcf79.jpg?wh=1920x1080" alt=""></p><p>为什么要这么学呢？因为这种阅读思路和代码库作者的思路是一致的。</p><p>首先搞清楚这个库要提供什么功能（提供什么样的对外函数），然后为了提供这些功能，我要把整个库分为几个核心模块（结构），最后每个核心模块，我应该提供什么样的能力（具体的结构函数）来满足我的需求。</p><h3>库函数（功能）</h3><p>按照这个思路，我们来阅读 net/http 库，先看提供的对外库函数是为了实现哪些功能。这里顺带补充说明一下，我们课程对应的Golang源码的版本是1.15.5，你可以在<a href="https://github.com/gohade/coredemo/blob/geekbang/01/go.mod">01分支的coredemo/go.mod</a>里看到。</p><p>你直接通过  <code>go doc net/http | grep "^func"</code> 命令行能查询出 net/http 库所有的对外库函数：</p><pre><code>func CanonicalHeaderKey(s string) string\nfunc DetectContentType(data []byte) string\nfunc Error(w ResponseWriter, error string, code int)\nfunc Get(url string) (resp *Response, err error)\nfunc Handle(pattern string, handler Handler)\nfunc HandleFunc(pattern string, handler func(ResponseWriter, *Request))\nfunc Head(url string) (resp *Response, err error)\nfunc ListenAndServe(addr string, handler Handler) error\nfunc ListenAndServeTLS(addr, certFile, keyFile string, handler Handler) error\nfunc MaxBytesReader(w ResponseWriter, r io.ReadCloser, n int64) io.ReadCloser\nfunc NewRequest(method, url string, body io.Reader) (*Request, error)\nfunc NewRequestWithContext(ctx context.Context, method, url string, body io.Reader) (*Request, error)\nfunc NotFound(w ResponseWriter, r *Request)\nfunc ParseHTTPVersion(vers string) (major, minor int, ok bool)\nfunc ParseTime(text string) (t time.Time, err error)\nfunc Post(url, contentType string, body io.Reader) (resp *Response, err error)\nfunc PostForm(url string, data url.Values) (resp *Response, err error)\nfunc ProxyFromEnvironment(req *Request) (*url.URL, error)\nfunc ProxyURL(fixedURL *url.URL) func(*Request) (*url.URL, error)\nfunc ReadRequest(b *bufio.Reader) (*Request, error)\nfunc ReadResponse(r *bufio.Reader, req *Request) (*Response, error)\nfunc Redirect(w ResponseWriter, r *Request, url string, code int)\nfunc Serve(l net.Listener, handler Handler) error\nfunc ServeContent(w ResponseWriter, req *Request, name string, modtime time.Time, ...)\nfunc ServeFile(w ResponseWriter, r *Request, name string)\nfunc ServeTLS(l net.Listener, handler Handler, certFile, keyFile string) error\nfunc SetCookie(w ResponseWriter, cookie *Cookie)\nfunc StatusText(code int) string\n</code></pre><p>在这个库提供的方法中，我们去掉一些 New 和 Set 开头的函数，因为你从命名上可以看出，这些函数是对某个对象或者属性的设置。</p><p>剩下的函数大致可以分成三类：</p><ul>\n<li>为服务端提供创建 HTTP 服务的函数，名字中一般包含 Serve 字样，比如 Serve、ServeFile、ListenAndServe等。</li>\n<li>为客户端提供调用 HTTP 服务的类库，以 HTTP 的 method 同名，比如 Get、Post、Head等。</li>\n<li>提供中转代理的一些函数，比如ProxyURL、ProxyFromEnvironment 等。</li>\n</ul><p>我们现在研究的是，如何创建一个 HTTP 服务，所以关注包含 Serve 字样的函数就可以了。</p><pre><code class="language-go">// 通过监听的URL地址和控制器函数来创建HTTP服务\nfunc ListenAndServe(addr string, handler Handler) error{}\n// 通过监听的URL地址和控制器函数来创建HTTPS服务\nfunc ListenAndServeTLS(addr, certFile, keyFile string, handler Handler) error{}\n// 通过net.Listener结构和控制器函数来创建HTTP服务\nfunc Serve(l net.Listener, handler Handler) error{}\n// 通过net.Listener结构和控制器函数来创建HTTPS服务\nfunc ServeTLS(l net.Listener, handler Handler, certFile, keyFile string) error{}\n</code></pre><h3>结构定义（模块）</h3><p>然后，我们过一遍这个库提供的所有struct，看看核心模块有哪些，同样使用 go doc:</p><pre><code class="language-go">&nbsp;go doc net/http | grep "^type"|grep struct\n</code></pre><p>你可以看到整个库最核心的几个结构：</p><pre><code class="language-go">type Client struct{ ... }\ntype Cookie struct{ ... }\ntype ProtocolError struct{ ... }\ntype PushOptions struct{ ... }\ntype Request struct{ ... } \ntype Response struct{ ... }\ntype ServeMux struct{ ... }\ntype Server struct{ ... }\ntype Transport struct{ ... }\n</code></pre><p>看结构的名字或者go doc查看结构说明文档，能逐渐了解它们的功能：</p><ul>\n<li>Client 负责构建HTTP客户端；</li>\n<li>Server 负责构建HTTP服务端；</li>\n<li>ServerMux 负责HTTP服务端路由；</li>\n<li>Transport、Request、Response、Cookie负责客户端和服务端传输对应的不同模块。</li>\n</ul><p>现在通过库方法（function）和结构体（struct），我们对整个库的结构和功能有大致印象了。整个库承担了两部分功能，一部分是构建HTTP客户端，一部分是构建HTTP服务端。</p><p>构建的HTTP服务端除了提供真实服务之外，也能提供代理中转服务，它们分别由 Client 和 Server 两个数据结构负责。除了这两个最重要的数据结构之外，HTTP 协议的每个部分，比如请求、返回、传输设置等都有具体的数据结构负责。</p><h3>结构函数（能力）</h3><p>下面从具体的需求出发，我们来阅读具体的结构函数（method）。</p><p>我们当前的需求是创建 HTTP 服务，开头我举了一个最简单的例子：</p><pre><code class="language-go">// 创建一个Foo路由和处理函数\nhttp.Handle("/foo", fooHandler)\n\n// 创建一个bar路由和处理函数\nhttp.HandleFunc("/bar", func(w http.ResponseWriter, r *http.Request) {\n\tfmt.Fprintf(w, "Hello, %q", html.EscapeString(r.URL.Path))\n})\n\n// 监听8080端口\nlog.Fatal(http.ListenAndServe(":8080", nil))\n</code></pre><p>我们跟着 http.ListenAndServe 这个函数来理一下 net/http 创建服务的主流程逻辑。</p><p>阅读具体的代码逻辑用 <code>go doc</code> 命令明显就不够了，你需要两个东西：</p><p>一个是可以灵活进行代码跳转的 IDE，VS Code 和 GoLand 都是非常好的工具。以我们现在要查看的 http.ListenAndServe 这个函数为例，我们可以从上面的例子代码中，直接通过IDE跳转到这个函数的源码中阅读，有一个能灵活跳转的IDE工具是非常必要的。</p><p>另一个是可以方便记录代码流程的笔记，这里我的个人方法是使用思维导图。</p><p>具体方法是<strong>将要分析的代码从入口处一层层记录下来，每个函数，我们只记录其核心代码，然后对每个核心代码一层层解析</strong>。记得把思维导图的结构设置为右侧分布，这样更直观。</p><p>比如下面这张图，就是我解析部分HTTP库服务端画的<a href="https://github.com/gohade/geekbang/tree/main/01">代码分析图</a>。</p><p><img src="https://static001.geekbang.org/resource/image/3a/cd/3ab5c45e113ddf4cc3bdb0e09c85c7cd.png?wh=2464x1192" alt=""></p><p>这张图看上去层级复杂，不过不用担心，对照着思维导图，我带你一层一层阅读，讲解每一层的逻辑，带你看清楚代码背后的设计思路。</p><p>我们先顺着 http.ListenAndServe 的脉络读。</p><p><strong>第一层</strong>，http.ListenAndServe 本质是通过创建一个 Server 数据结构，调用 <code>server.ListenAndServe</code> 对外提供服务，这一层完全是比较简单的封装，目的是，将Server结构创建服务的方法 ListenAndServe ，直接作为库函数对外提供，增加库的易用性。</p><p><img src="https://static001.geekbang.org/resource/image/4e/01/4eeaace11e29989b3bfc2344ca8e4001.png?wh=810x582" alt=""></p><p>进入到<strong>第二层</strong>，创建服务的方法 ListenAndServe 先定义了监听信息 <code>net.Listen</code>，然后调用 Serve 函数。</p><p>而在<strong>第三层</strong> Serve 函数中，用了一个 for 循环，通过 <code>l.Accept</code>不断接收从客户端传进来的请求连接。当接收到了一个新的请求连接的时候，通过 <code>srv.NewConn</code>创建了一个连接结构（<code>http.conn</code>），并创建一个 Goroutine 为这个请求连接对应服务（<code>c.serve</code>）。</p><p>从第四层开始，后面就是单个连接的服务逻辑了。</p><p><img src="https://static001.geekbang.org/resource/image/79/72/798e88645b4d77a3da302a6c6d719472.jpeg?wh=1026x860" alt=""></p><p>在<strong>第四层</strong>，<code>c.serve</code>函数先判断本次  HTTP 请求是否需要升级为 HTTPs，接着创建读文本的reader和写文本的buffer，再进一步读取本次请求数据，然后<strong>第五层</strong>调用最关键的方法 <code>serverHandler{c.server}.ServeHTTP(w,&nbsp;w.req)</code> ，来处理这次请求。</p><p>这个关键方法是为了实现自定义的路由和业务逻辑，调用写法是比较有意思的：</p><pre><code class="language-go">serverHandler{c.server}.ServeHTTP(w,&nbsp;w.req)\n</code></pre><p>serverHandler结构体，是标准库封装的，代表“请求对应的处理逻辑”，它只包含了一个指向总入口服务server的指针。</p><p>这个结构将总入口的服务结构Server和每个连接的处理逻辑巧妙联系在一起了，你可以看接着的<strong>第六层</strong>逻辑：</p><pre><code class="language-go">// serverHandler 结构代表请求对应的处理逻辑\ntype serverHandler struct {\n\tsrv *Server\n}\n\n// 具体处理逻辑的处理函数\nfunc (sh serverHandler) ServeHTTP(rw ResponseWriter, req *Request) {\n\thandler := sh.srv.Handler\n\tif handler == nil {\n\t\thandler = DefaultServeMux\n\t}\n\t...\n\thandler.ServeHTTP(rw, req)\n}\n</code></pre><p>如果入口服务server结构已经设置了 Handler，就调用这个Handler来处理此次请求，反之则使用库自带的 DefaultServerMux。</p><p>这里的serverHandler设计，能同时保证这个库的扩展性和易用性：你可以很方便使用默认方法处理请求，但是一旦有需求，也能自己扩展出方法处理请求。</p><p>那么DefaultServeMux 是怎么寻找 Handler 的呢，这就是思维导图的最后一部分<strong>第七层</strong>。</p><p><img src="https://static001.geekbang.org/resource/image/34/fe/344fc7d6f2d1aca635ef1284185621fe.png?wh=2268x418" alt=""></p><p><code>DefaultServeMux.Handle</code> 是一个非常简单的 map 实现，key 是路径（pattern），value 是这个 pattern 对应的处理函数（handler）。它是通过 <code>mux.match</code>(path) 寻找对应 Handler，也就是从 DefaultServeMux 内部的 map 中直接根据 key 寻找到 value 的。</p><p>这种根据 map 直接查找路由的方式是不是可以满足我们的路由需求呢？我们会在第三讲路由中详细解说。</p><p>好，HTTP库 Server 的代码流程我们就梳理完成了，整个逻辑线大致是：</p><pre><code class="language-plain">创建服务 -&gt; 监听请求 -&gt; 创建连接 -&gt; 处理请求\n</code></pre><p>如果你觉得层次比较多，对照着思维导图多看几遍就顺畅了。这里我也给你整理了一下逻辑线各层的关键结论：</p><ul>\n<li>第一层，标准库创建HTTP服务是通过创建一个 Server 数据结构完成的；</li>\n<li>第二层，Server 数据结构在for循环中不断监听每一个连接；</li>\n<li>第三层，每个连接默认开启一个 Goroutine 为其服务；</li>\n<li>第四、五层，serverHandler 结构代表请求对应的处理逻辑，并且通过这个结构进行具体业务逻辑处理；</li>\n<li>第六层，Server 数据结构如果没有设置处理函数 Handler，默认使用 DefaultServerMux处理请求；</li>\n<li>第七层，DefaultServerMux 是使用 map 结构来存储和查找路由规则。</li>\n</ul><p>如果你对上面几点关键结论还有疑惑的，可以再去看一遍思维导图。阅读核心逻辑代码是会有点枯燥，但是<strong>这条逻辑线是HTTP服务启动最核心的主流程逻辑</strong>，后面我们会基于这个流程继续开发，你要掌握到能背下来的程度。千万不要觉得要背诵了，压力太大，其实对照着思维导图，顺几遍逻辑，理解了再记忆就很容易。</p><h2>创建框架的Server结构</h2><p>现在原理弄清楚了，该下手搭 HTTP 服务了。</p><p>刚刚咱也分析了主流程代码，其中第一层的关键结论就是：net/http 标准库创建服务，实质上就是通过创建 Server 数据结构来完成的。所以接下来，我们就来创建一个 Server 数据结构。</p><p>通过 <code>go doc net/http.Server</code> 我们可以看到 Server 的结构：</p><pre><code class="language-go">type Server struct {\n    // 请求监听地址\n\tAddr string\n    // 请求核心处理函数\n\tHandler Handler \n\t...\n}\n</code></pre><p>其中最核心的是 Handler这个字段，从主流程中我们知道（第六层关键结论），当 Handler 这个字段设置为空的时候，它会默认使用 DefaultServerMux 这个路由器来填充这个值，但是我们一般都会使用自己定义的路由来替换这个默认路由。</p><p>所以在框架代码中，我们要创建一个自己的核心路由结构，实现 Handler。</p><p>先来理一下目录结构，我们在<a href="https://github.com/gohade/coredemo/tree/geekbang/01">GitHub</a>上创建一个项目coredemo，这个项目是这门课程所有的代码集合，包含要实现的框架和使用框架的示例业务代码。</p><p><strong>所有的框架代码都存放在framework文件夹中，而所有的示例业务代码都存放在framework文件夹之外</strong>。这里为了后面称呼方便，我们就把framework文件夹叫框架文件夹，而把外层称为业务文件夹。</p><p>当然 GitHub 上的这个coredemo是我在写课程的时候为了演示创建的，推荐你跟着一步一步写。成品在<a href="https://github.com/gohade/hade">hade项目</a>里，你可以先看看，在最后发布的时候，我们会将整个项目进行发布。在一个新的业务中，如果要使用到我们自己写好的框架，可以直接通过引用 “import 项目地址/framework” 来引入，在最后一部分做实战项目的时候我们会具体演示。</p><p>好，下面我们来一步步实现这个项目。</p><p>创建一个framework文件夹，新建core.go，在里面写入。</p><pre><code class="language-go">package framework\n\nimport "net/http"\n\n// 框架核心结构\ntype Core struct {\n}\n\n// 初始化框架核心结构\nfunc NewCore() *Core {\n\treturn &amp;Core{}\n}\n\n// 框架核心结构实现Handler接口\nfunc (c *Core) ServeHTTP(response http.ResponseWriter, request *http.Request) {\n\t// TODO\n}\n\n</code></pre><p>而在业务文件夹中创建main.go，其中的main函数就变成这样：</p><pre><code class="language-go">func main() {\n\tserver := &amp;http.Server{\n        // 自定义的请求核心处理函数\n\t\tHandler: framework.NewCore(),\n        // 请求监听地址\n\t\tAddr:&nbsp; &nbsp; ":8080",\n\t}\n\tserver.ListenAndServe()\n}\n\n</code></pre><p>整理下这段代码，我们通过自己创建了 Server 数据结构，并且在数据结构中创建了自定义的Handler（Core数据结构）和监听地址，实现了一个 HTTP 服务。这个服务的具体业务逻辑都集中在我们自定义的Core结构中，后续我们要做的事情就是不断丰富这个Core数据结构的功能逻辑。</p><p>后续每节课学完之后，我都会把代码放在对应的GitHub的分支中。你跟着课程敲完代码过程中有不了解的地方，可以对比参考分支。</p><p>本节课我们完成的代码分支是：<a href="https://github.com/gohade/coredemo/tree/geekbang/01">geekbang/01</a> ，代码结构我也截了图：<img src="https://static001.geekbang.org/resource/image/2c/d2/2c481d0c93efede365a7e079c4eb49d2.png?wh=734x396" alt=""></p><h2>小结</h2><p>今天我以 net/http 标准库为例，分享了快速熟悉代码库的技巧，<strong>库函数 &gt; 结构定义 &gt; 结构函数。</strong>在阅读代码库时，从功能出发，先读对外库函数，再细读这个库提供的结构，搞清楚功能和对应结构之后，最后基于实际需求看每个结构函数。</p><p>读每个结构函数的时候，我们使用思维导图梳理了net/http 创建 HTTP 服务的主流程逻辑，基于主流程原理，创建了一个属于我们框架的 Server 结构，你可以再回顾一下这张图。</p><p><img src="https://static001.geekbang.org/resource/image/3a/cd/3ab5c45e113ddf4cc3bdb0e09c85c7cd.png?wh=2464x1192" alt=""></p><p>主流程的链条比较长，但是你先理顺逻辑，记住几个关键的节点，再结合思维导图，就能记住整个主流程逻辑了，之后所有关于 HTTP 的细节和问题，我们都会基于这个主流程逻辑来思考和回答。</p><h2>思考题</h2><p>今天我用思维导图梳理了最核心的 HTTP 服务启动的主流程逻辑，知易行难，你不妨用这个思路做做下面这道思考题，尝试绘制出属于你自己的思维导图。</p><p>HTTP 库提供 FileServer 来封装对文件读取的 HTTP 服务。实现代码也非常简单：</p><pre><code class="language-go">fs := http.FileServer(http.Dir("/home/bob/static"))\nhttp.Handle("/static/", http.StripPrefix("/static", fs))\n</code></pre><p>请问它的主流程逻辑是什么？你认为其中最关键的节点是什么？</p><p>欢迎在留言区分享你的思考。感谢你的收听，如果你觉得今天的内容对你有帮助，也欢迎你把今天的内容分享给你身边的朋友，邀请他一起学习。</p><p><a href="https://jinshuju.net/f/Uk3003">点这里</a>进微信群，一起学习讨论。</p>',
        article_title: "01｜net/http：使用标准库搭建Server并不是那么简单",
      },
      {
        title: "02｜Context：请求控制器，让每个请求都在掌控之中",
        id: 418283,
        content:
          '<p>你好，我是轩脉刃。</p><p>上一讲我们使用 net/http 搭建了一个最简单的 HTTP 服务，为了帮你理解服务启动逻辑，我用思维导图梳理了主流程，如果你还有不熟悉，可以再回顾一下。</p><p>今天我将带你进一步丰富我们的框架，添加上下文 Context 为请求设置超时时间。</p><p>从主流程中我们知道（第三层关键结论），HTTP 服务会为每个请求创建一个 Goroutine 进行服务处理。在服务处理的过程中，有可能就在本地执行业务逻辑，也有可能再去下游服务获取数据。如下图，本地处理逻辑 A，下游服务 a/b/c/d， 会形成一个标准的树形逻辑链条。</p><p><img src="https://static001.geekbang.org/resource/image/33/71/33361f90298865f98e3038f11f02e671.jpg?wh=1920x1080" alt=""></p><p>在这个逻辑链条中，每个本地处理逻辑，或者下游服务请求节点，都有可能存在超时问题。<strong>而对于 HTTP 服务而言，超时往往是造成服务不可用、甚至系统瘫痪的罪魁祸首</strong>。</p><p>系统瘫痪也就是我们俗称的雪崩，某个服务的不可用引发了其他服务的不可用。比如上图中，如果服务 d 超时，导致请求处理缓慢甚至不可用，加剧了 Goroutine 堆积，同时也造成了服务 a/b/c 的请求堆积，Goroutine 堆积，瞬时请求数加大，导致 a/b/c 的服务都不可用，整个系统瘫痪，怎么办？</p><p>最有效的方法就是从源头上控制一个请求的“最大处理时长”，所以，对于一个 Web 框架而言，“超时控制”能力是必备的。今天我们就用 Context 为框架增加这个能力。</p><!-- [[[read_end]]] --><h2>context 标准库设计思路</h2><p>如何控制超时，官方是有提供 context 标准库作为解决方案的，但是由于标准库的功能并不够完善，一会我们会基于标准库，来根据需求自定义框架的 Context。所以理解其背后的设计思路就可以了。</p><p>为了防止雪崩，context 标准库的解决思路是：<strong>在整个树形逻辑链条中，用上下文控制器 Context，实现每个节点的信息传递和共享</strong>。</p><p>具体操作是：用 Context 定时器为整个链条设置超时时间，时间一到，结束事件被触发，链条中正在处理的服务逻辑会监听到，从而结束整个逻辑链条，让后续操作不再进行。</p><p>明白操作思路之后，我们深入 context 标准库看看要对应具备哪些功能。</p><p>按照上一讲介绍的了解标准库的方法，我们先通过  <code>go doc context | grep "^func"</code> 看提供了哪些库函数（function）：</p><pre><code class="language-go">// 创建退出 Context\nfunc WithCancel(parent Context) (ctx Context, cancel CancelFunc){}\n// 创建有超时时间的 Context\nfunc WithTimeout(parent Context, timeout time.Duration) (Context, CancelFunc){}\n// 创建有截止时间的 Context\nfunc WithDeadline(parent Context, d time.Time) (Context, CancelFunc){}\n</code></pre><p>其中，WithCancel 直接创建可以操作退出的子节点，WithTimeout 为子节点设置了超时时间（还有多少时间结束），WithDeadline 为子节点设置了结束时间线（在什么时间结束）。</p><p>但是这只是表层功能的不同，其实这三个库函数的<strong>本质是一致的</strong>。怎么理解呢？</p><p>我们先通过  <code>go doc context | grep "^type"</code> ，搞清楚 Context 的结构定义和函数句柄，再来解答这个问题。</p><pre><code class="language-go">type Context interface {\n    // 当 Context 被取消或者到了 deadline，返回一个被关闭的 channel\n    Done() &lt;-chan struct{}\n    ...\n}\n\n//函数句柄\ntype CancelFunc func() \n</code></pre><p>这个库虽然不大，但是设计感强，比较抽象，并不是很好理解。所以这里，我把 Context 的其他字段省略了。现在，我们只理解核心的 Done() 方法和 CancelFunc 这两个函数就可以了。</p><p>在树形逻辑链条上，<strong>一个节点其实有两个角色：一是下游树的管理者；二是上游树的被管理者</strong>，那么就对应需要有两个能力：</p><ul>\n<li>一个是能让整个下游树结束的能力，也就是函数句柄 CancelFunc；</li>\n<li>另外一个是在上游树结束的时候被通知的能力，也就是 Done()方法。同时因为通知是需要不断监听的，所以 Done() 方法需要通过 channel 作为返回值让使用方进行监听。</li>\n</ul><p>看<a href="https://pkg.go.dev/context@go1.15.5">官方代码</a>示例：</p><pre><code class="language-go">package main\n\nimport (\n\t"context"\n\t"fmt"\n\t"time"\n)\n\nconst shortDuration = 1 * time.Millisecond\n\nfunc main() {\n    // 创建截止时间\n\td := time.Now().Add(shortDuration)\n    // 创建有截止时间的 Context\n\tctx, cancel := context.WithDeadline(context.Background(), d)\n\tdefer cancel()\n\n    // 使用 select 监听 1s 和有截止时间的 Context 哪个先结束\n\tselect {\n\tcase &lt;-time.After(1 * time.Second):\n\t\tfmt.Println("overslept")\n\tcase &lt;-ctx.Done():\n\t\tfmt.Println(ctx.Err())\n\t}\n\n}\n</code></pre><p>主线程创建了一个 1 毫秒结束的定时器 Context，在定时器结束的时候，主线程会通过 Done()函数收到事件结束通知，然后主动调用函数句柄 cancelFunc 来通知所有子 Context 结束（这个例子比较简单没有子 Context）。</p><p>我打个更形象的比喻，CancelFunc 和 Done 方法就像是电话的话筒和听筒，话筒 CancelFunc，用来告诉管辖范围内的所有 Context 要进行自我终结，而通过监听听筒 Done 方法，我们就能听到上游父级管理者的终结命令。</p><p>总之，<strong>CancelFunc 是主动让下游结束，而 Done 是被上游通知结束</strong>。</p><p>搞懂了具体实现方法，我们回过头来看这三个库函数 WithCancel / WithDeadline / WithTimeout 就很好理解了。</p><p>它们的本质就是“通过定时器来自动触发终结通知”，WithTimeout 设置若干秒后通知触发终结，WithDeadline 设置未来某个时间点触发终结。</p><p>对应到 Context 代码中，它们的功能就是：<strong>为一个父节点生成一个带有 Done 方法的子节点，并且返回子节点的 CancelFunc 函数句柄</strong>。</p><p><img src="https://static001.geekbang.org/resource/image/90/c5/900361486571bb703261d2cfd56e87c5.jpg?wh=1920x1080" alt=""><br>\n我们用一张图来辅助解释一下，Context的使用会形成一个树形结构，下游指的是树形结构中的子节点及所有子节点的子树，而上游指的是当前节点的父节点。比如图中圈起来的部分，当WithTimeout调用CancelFunc的时候，所有下游的With系列产生的Context都会从Done中收到消息。</p><h2>Context 是怎么产生的</h2><p>现在我们已经了解标准库 context 的设计思路了，在开始写代码之前，我们还要把 Context 放到 net/http 的主流程逻辑中，其中有两个问题要搞清楚：<strong>Context 在哪里产生？它的上下游逻辑是什么？</strong></p><p>要回答这两个问题，可以用我们在上一讲介绍的思维导图方法，因为主流程已经拎清楚了，现在你只需要把其中 Context 有关的代码再详细过一遍，然后在思维导图上标记出来就可以了。</p><p>这里，我已经把 Context 的关键代码都用蓝色背景做了标记，你可以检查一下自己有没有标漏。</p><p><img src="https://static001.geekbang.org/resource/image/79/a4/79a3c7eafc3ccfbe1b162e646902c5a4.png?wh=1413x906" alt=""></p><p>照旧看图梳理代码流程，来看蓝色部分，从前到后的层级梳理就不再重复讲了，我们看关键位置。</p><p>从图中最后一层的代码 req.ctx = ctx 中看到，每个连接的 Context 最终是放在 request 结构体中的。</p><p>而且这个时候， Context 已经有多层父节点。因为，在代码中，每执行一次 WithCancel、WithValue，就封装了一层 Context，我们通过这一张流程图能清晰看到最终 Context 的生成层次。</p><p><img src="https://static001.geekbang.org/resource/image/dd/22/ddbca0e4d1c66ed417b9de97c338ae22.jpg?wh=1920x1080" alt=""></p><p>你发现了吗，<strong>其实每个连接的 Context 都是基于 baseContext 复制来的</strong>。对应到代码中就是，在为某个连接开启 Goroutine 的时候，为当前连接创建了一个 connContext，这个 connContext 是基于 server 中的 Context 而来，而 server 中 Context 的基础就是 baseContext。</p><p>所以，Context 从哪里产生这个问题，我们就解决了，但是如果我们想要对 Context 进行必要的修改，还要从上下游逻辑中，找到它的修改点在哪里。</p><p>生成最终的 Context 的流程中，net/http 设计了<strong>两处可以注入修改</strong>的地方，都在 Server 结构里面，一处是 BaseContext，另一处是 ConnContext。</p><ul>\n<li>BaseContext 是整个 Context 生成的源头，如果我们不希望使用默认的 context.Backgroud()，可以替换这个源头。</li>\n<li>而在每个连接生成自己要使用的 Context 时，会调用 ConnContext ，它的第二个参数是 net.Conn，能让我们对某些特定连接进行设置，比如要针对性设置某个调用 IP。</li>\n</ul><p>这两个函数的定义我写在下面的代码里了，展示一下，你可以看看。</p><pre><code class="language-go">type Server struct {\n\t...\n\n    // BaseContext 用来为整个链条创建初始化 Context\n    // 如果没有设置的话，默认使用 context.Background()\n\tBaseContext func(net.Listener) context.Context{}\n\n    // ConnContext 用来为每个连接封装 Context\n    // 参数中的 context.Context 是从 BaseContext 继承来的\n\tConnContext func(ctx context.Context, c net.Conn) context.Context{}\n    ...\n}\n</code></pre><p>最后，我们回看一下 req.ctx 是否能感知连接异常。<img src="https://static001.geekbang.org/resource/image/a1/fc/a1d0ece41997ac873a5292301ee988fc.jpg?wh=1920x1080" alt=""><br>\n是可以的，因为链条中一个父节点为 CancelContext，其 cancelFunc 存储在代表连接的 conn 结构中，连接异常的时候，会触发这个函数句柄。</p><p>好，讲完 context 库的核心设计思想，以及在 net/http 的主流程逻辑中嵌入 context 库的关键实现，我们现在心中有图了，就可以撸起袖子开始写框架代码了。</p><p>你是不是有点疑惑，为啥要自己先理解一遍 context 标准库的生成流程，咱们直接动手干不是更快？有句老话说得好，磨刀不误砍柴功。</p><p>我们确实是要自定义，不是想直接使用标准库的 Context，因为它完全是标准库 Context 接口的实现，只能控制链条结束，封装性并不够。但是只有先搞清楚了 context 标准库的设计思路，才能精准确定自己能怎么改、改到什么程度合适，下手的时候才不容易懵。</p><p>下面我们就基于刚才讲的设计思路，从封装自己的 Context 开始，写今天的核心逻辑，也就是为单个请求设置超时，最后考虑一些边界场景，并且进行优化。</p><p>我们还是再拉一个分支 <a href="https://github.com/gohade/coredemo/tree/geekbang/02">geekbang/02</a>，接着上一节课的代码结构，在框架文件夹中封装一个自己的Context。</p><h2>封装一个自己的 Context</h2><p>在框架里，我们需要有更强大的 Context，除了可以控制超时之外，常用的功能比如获取请求、返回结果、实现标准库的 Context 接口，也都要有。</p><p><strong>我们首先来设计提供获取请求、返回结果功能</strong>。</p><p>先看一段未封装自定义 Context 的控制器代码：</p><pre><code class="language-go">// 控制器\nfunc Foo1(request *http.Request, response http.ResponseWriter) {\n\tobj := map[string]interface{}{\n\t\t"data":&nbsp; &nbsp;nil,\n\t}\n    // 设置控制器 response 的 header 部分\n\tresponse.Header().Set("Content-Type", "application/json")\n\n    // 从请求体中获取参数\n\tfoo := request.PostFormValue("foo")\n\tif foo == "" {\n\t\tfoo = "10"\n\t}\n\tfooInt, err := strconv.Atoi(foo)\n\tif err != nil {\n\t\tresponse.WriteHeader(500)\n\t\treturn\n\t}\n    // 构建返回结构\n\tobj["data"] = fooInt&nbsp;\n\tbyt, err := json.Marshal(obj)\n\tif err != nil {\n\t\tresponse.WriteHeader(500)\n\t\treturn\n\t}\n    // 构建返回状态，输出返回结构\n\tresponse.WriteHeader(200)\n\tresponse.Write(byt)\n\treturn\n}\n</code></pre><p>这段代码重点是操作调用了 http.Request 和 http.ResponseWriter ，实现 WebService 接收和处理协议文本的功能。但这两个结构提供的接口粒度太细了，需要使用者非常熟悉这两个结构的内部字段，比如response里设置Header和设置Body的函数，用起来肯定体验不好。</p><p>如果我们能<strong>将这些内部实现封装起来，对外暴露语义化高的接口函数</strong>，那么我们这个框架的易用性肯定会明显提升。什么是好的封装呢？再看这段有封装的代码：</p><pre><code class="language-go">// 控制器\nfunc Foo2(ctx *framework.Context) error {\n\tobj := map[string]interface{}{\n\t\t"data":&nbsp; &nbsp;nil,\n\t}\n    // 从请求体中获取参数\n \tfooInt := ctx.FormInt("foo", 10)\n    // 构建返回结构  \n\tobj["data"] = fooInt\n    // 输出返回结构\n\treturn ctx.Json(http.StatusOK, obj)\n}\n</code></pre><p>你可以明显感受到封装性高的 Foo2 函数，更优雅更易读了。首先它的代码量更少，而且语义性也更好，近似对业务的描述：从请求体中获取 foo 参数，并且封装为 Map，最后 JSON 输出。</p><p>思路清晰了，所以这里可以将 request 和 response 封装到我们自定义的 Context 中，对外提供请求和结果的方法，我们把这个Context结构写在框架文件夹的context.go文件中：</p><pre><code class="language-go">// 自定义 Context\ntype Context struct {\n\trequest&nbsp; &nbsp; &nbsp; &nbsp; *http.Request\n\tresponseWriter http.ResponseWriter\n\t...\n}\n</code></pre><p>对request和response封装的具体实现，我们到第五节课封装的时候再仔细说。</p><p><strong>然后是第二个功能，标准库的 Context 接口</strong>。</p><p>标准库的 Context 通用性非常高，基本现在所有第三方库函数，都会根据官方的建议，将第一个参数设置为标准 Context 接口。所以我们封装的结构只有实现了标准库的 Context，才能方便直接地调用。</p><p>到底有多方便，我们看使用示例：</p><pre><code class="language-go">func Foo3(ctx *framework.Context) error {\n\trdb := redis.NewClient(&amp;redis.Options{\n\t\tAddr:&nbsp; &nbsp; &nbsp;"localhost:6379",\n\t\tPassword: "", // no password set\n\t\tDB:&nbsp; &nbsp; &nbsp; &nbsp;0,&nbsp; // use default DB\n\t})\n\n\treturn rdb.Set(ctx, "key", "value", 0).Err()\n}\n\n</code></pre><p>这里使用了 go-redis 库，它每个方法的参数中都有一个标准 Context 接口，这让我们能将自定义的 Context 直接传递给 rdb.Set。</p><p>所以在我们的框架上实现这一步，只需要调用刚才封装的 request 中的 Context 的标准接口就行了，很简单，我们继续在context.go中进行补充：</p><pre><code class="language-go">func (ctx *Context) BaseContext() context.Context {\n\treturn ctx.request.Context()\n}\n\nfunc (ctx *Context) Done() &lt;-chan struct{} {\n\treturn ctx.BaseContext().Done()\n}\n</code></pre><p>这里举例了两个method的实现，其他的都大同小异就不在文稿里展示，你可以先自己写，然后对照我放在<a href="https://github.com/gohade/coredemo/blob/geekbang/02/framework/context.go">GitHub</a>上的完整代码检查一下。</p><p>自己封装的 Context 最终需要提供四类功能函数：</p><ul>\n<li>base 封装基本的函数功能，比如获取 http.Request 结构</li>\n<li>context 实现标准 Context 接口</li>\n<li>request 封装了 http.Request 的对外接口</li>\n<li>response 封装了 http.ResponseWriter 对外接口</li>\n</ul><p>完成之后，使用我们的IDE里面的结构查看器（每个IDE显示都不同），就能查看到如下的函数列表：<img src="https://static001.geekbang.org/resource/image/3c/cc/3c0c98741275beb7bdf5d6333b0c91cc.jpg?wh=1248x1456" alt=""></p><p>有了我们自己封装的 Context 之后，控制器就非常简化了。把框架定义的 ControllerHandler 放在框架目录下的controller.go文件中：</p><pre><code class="language-go">type ControllerHandler func(c *Context) error\n</code></pre><p>把处理业务的控制器放在业务目录下的controller.go文件中：</p><pre><code class="language-go">func FooControllerHandler(ctx *framework.Context) error {\n\treturn ctx.Json(200, map[string]interface{}{\n\t\t"code": 0,\n\t})\n}\n</code></pre><p>参数只有一个 framework.Context，是不是清爽很多，这都归功于刚完成的自定义 Context。</p><h2>为单个请求设置超时</h2><p>上面我们封装了自定义的 Context，从设计层面实现了标准库的Context。下面回到我们这节课核心要解决的问题，为单个请求设置超时。</p><p>如何使用自定义 Context 设置超时呢？结合前面分析的标准库思路，我们三步走完成：</p><ol>\n<li>继承 request 的 Context，创建出一个设置超时时间的 Context；</li>\n<li>创建一个新的 Goroutine 来处理具体的业务逻辑；</li>\n<li>设计事件处理顺序，当前 Goroutine 监听超时时间 Contex 的 Done()事件，和具体的业务处理结束事件，哪个先到就先处理哪个。</li>\n</ol><p>理清步骤，我们就可以在业务的controller.go文件中完成业务逻辑了。<strong>第一步生成一个超时的 Context</strong>：</p><pre><code class="language-go">durationCtx, cancel := context.WithTimeout(c.BaseContext(), time.Duration(1*time.Second))\n// 这里记得当所有事情处理结束后调用 cancel，告知 durationCtx 的后续 Context 结束\ndefer cancel()\n</code></pre><p>这里为了最终在浏览器做验证，我设置超时事件为1s，这样最终验证的时候，最长等待1s 就可以知道超时是否生效。</p><p><strong>第二步创建一个新的 Goroutine 来处理业务逻辑</strong>：</p><pre><code class="language-go">finish := make(chan struct{}, 1)\n\ngo func() {\n\t\t...\n\t\t// 这里做具体的业务\n\t\ttime.Sleep(10 * time.Second)\n        c.Json(200, "ok")\n        ...\n        // 新的 goroutine 结束的时候通过一个 finish 通道告知父 goroutine\n\t\tfinish &lt;- struct{}{}\n}()\n</code></pre><p>为了最终的验证效果，我们使用time.Sleep将新 Goroutine 的业务逻辑事件人为往后延迟了10s，再输出“ok”，这样最终验证的时候，效果比较明显，因为前面的超时设置会在1s生效了，浏览器就有表现了。</p><p><strong>到这里我们这里先不急着进入第三步，还有错误处理情况没有考虑到位</strong>。这个新创建的Goroutine如果出现未知异常怎么办？需要我们额外捕获吗？</p><p>其实在 Golang 的设计中，每个 Goroutine 都是独立存在的，父 Goroutine 一旦使用 Go 关键字开启了一个子 Goroutine，父子 Goroutine 就是平等存在的，他们互相不能干扰。而在异常面前，所有 Goroutine 的异常都需要自己管理，不会存在父 Goroutine 捕获子 Goroutine 异常的操作。</p><p>所以切记：在 Golang 中，每个 Goroutine 创建的时候，我们要使用 defer 和 recover 关键字为当前 Goroutine 捕获 panic 异常，并进行处理，否则，任意一处 panic 就会导致整个进程崩溃！</p><p>这里你可以标个重点，面试会经常被问到。</p><p>搞清楚这一点，<strong>我们回看第二步，做完具体业务逻辑就结束是不行的，还需要处理 panic</strong>。所以这个 Goroutine 应该要有两个 channel 对外传递事件：</p><pre><code class="language-go">// 这个 channal 负责通知结束\nfinish := make(chan struct{}, 1)\n// 这个 channel 负责通知 panic 异常\npanicChan := make(chan interface{}, 1)\n\ngo func() {\n        // 这里增加异常处理\n\t\tdefer func() {\n\t\t\tif p := recover(); p != nil {\n\t\t\t\tpanicChan &lt;- p\n\t\t\t}\n\t\t}()\n\t\t// 这里做具体的业务\n\t\ttime.Sleep(10 * time.Second)\n        c.Json(200, "ok")\n        ...\n        // 新的 goroutine 结束的时候通过一个 finish 通道告知父 goroutine\n\t\tfinish &lt;- struct{}{}\n}(）\n</code></pre><p>现在第二步才算完成了，我们继续写第三步监听。使用 select 关键字来监听三个事件：异常事件、结束事件、超时事件。</p><pre><code class="language-go">  select {\n    // 监听 panic\n\tcase p := &lt;-panicChan:\n\t\t...\n        c.Json(500, "panic")\n    // 监听结束事件\n\tcase &lt;-finish:\n\t\t...\n        fmt.Println("finish")\n    // 监听超时事件\n\tcase &lt;-durationCtx.Done():\n\t\t...\n        c.Json(500, "time out")\n\t}\n</code></pre><p>接收到结束事件，只需要打印日志，但是，在接收到异常事件和超时事件的时候，我们希望告知浏览器前端“异常或者超时了”，所以会使用 c.Json 来返回一个字符串信息。</p><p>三步走到这里就完成了对某个请求的超时设置，你可以通过 go build、go run 尝试启动下这个服务。如果你在浏览器开启一个请求之后，浏览器不会等候事件处理 10s，而在等待我们设置的超时事件 1s 后，页面显示“time out”就结束这个请求了，就说明我们为某个事件设置的超时生效了。</p><h2>边界场景</h2><p>到这里，我们的超时逻辑设置就结束且生效了。但是，这样的代码逻辑只能算是及格，为什么这么说呢？因为它并没有覆盖所有的场景。</p><p>我们的代码逻辑要再严谨一些，<strong>把边界场景也考虑进来</strong>。这里有两种可能：</p><ol>\n<li>异常事件、超时事件触发时，需要往 responseWriter 中写入信息，这个时候如果有其他 Goroutine 也要操作 responseWriter，会不会导致 responseWriter 中的信息出现乱序？</li>\n<li>超时事件触发结束之后，已经往 responseWriter 中写入信息了，这个时候如果有其他 Goroutine 也要操作 responseWriter， 会不会导致 responseWriter 中的信息重复写入？</li>\n</ol><p>你先分析第一个问题，是很有可能出现的。方案不难想到，我们要保证在事件处理结束之前，不允许任何其他 Goroutine 操作 responseWriter，这里可以使用一个锁（sync.Mutex）对 responseWriter 进行写保护。</p><p>在框架文件夹的context.go中对Context结构进行一些设置：</p><pre><code class="language-go">type Context struct {\n\t// 写保护机制\n\twriterMux&nbsp; *sync.Mutex\n}\n\n// 对外暴露锁\nfunc (ctx *Context) WriterMux() *sync.Mutex {\n\treturn ctx.writerMux\n}\n</code></pre><p>在刚才写的业务文件夹controller.go 中也进行对应的修改：</p><pre><code>func FooControllerHandler(c *framework.Context) error {\n\t...\n    // 请求监听的时候增加锁机制\n\tselect {\n\tcase p := &lt;-panicChan:\n\t\tc.WriterMux().Lock()\n\t\tdefer c.WriterMux().Unlock()\n\t\t...\n\t\tc.Json(500, &quot;panic&quot;)\n\tcase &lt;-finish:\n        ...\n\t\tfmt.Println(&quot;finish&quot;)\n\tcase &lt;-durationCtx.Done():\n\t\tc.WriterMux().Lock()\n\t\tdefer c.WriterMux().Unlock()\n\t\tc.Json(500, &quot;time out&quot;)\n\t\tc.SetTimeout()\n\t}\n\treturn nil\n}\n</code></pre><p>那第二个问题怎么处理，我提供一个方案。我们可以<strong>设计一个标记</strong>，当发生超时的时候，设置标记位为 true，在 Context 提供的 response 输出函数中，先读取标记位；当标记位为 true，表示已经有输出了，不需要再进行任何的 response 设置了。</p><p>同样在框架文件夹中修改context.go：</p><pre><code class="language-go">type Context struct {\n    ...\n\t// 是否超时标记位\n\thasTimeout bool\n\t...\n}\n\nfunc (ctx *Context) SetHasTimeout() {\n\tctx.hasTimeout = true\n}\n\nfunc (ctx *Context) Json(status int, obj interface{}) error {\n\tif ctx.HasTimeout() {\n\t\treturn nil\n\t}\n\t...\n}\n</code></pre><p>在业务文件夹中修改controller.go：</p><pre><code>func FooControllerHandler(c *framework.Context) error {\n\t...\n\tselect {\n\tcase p := &lt;-panicChan:\n\t\t...\n\tcase &lt;-finish:\n\t\tfmt.Println(&quot;finish&quot;)\n\tcase &lt;-durationCtx.Done():\n\t\tc.WriterMux().Lock()\n\t\tdefer c.WriterMux().Unlock()\n\t\tc.Json(500, &quot;time out&quot;)\n        // 这里记得设置标记为\n\t\tc.SetHasTimeout()\n\t}\n\treturn nil\n}\n</code></pre><p>好了，到了这里，我们就完成了请求超时设置，并且考虑了边界场景。</p><p>剩下的验证部分，我们写一个简单的路由函数，将这个控制器路由在业务文件夹中创建一个route.go:</p><pre><code class="language-go">func registerRouter(core *framework.Core) {\n  // 设置控制器\n   core.Get("foo", FooControllerHandler)\n}\n</code></pre><p>并修改main.go：</p><pre><code class="language-go">func main() {\n   ...\n   // 设置路由\n   registerRouter(core)\n   ...\n}\n</code></pre><p>就可以运行了。完整代码照旧放在GitHub的 <a href="https://github.com/gohade/coredemo/tree/geekbang/02">geekbang/02 分支</a>上了。<br>\n<img src="https://static001.geekbang.org/resource/image/72/e4/7277357c506bc95b9155d6a35cdee3e4.png?wh=714x656" alt=""></p><h2>小结</h2><p>今天，我们定义了一个属于自己框架的 Context，它有两个功能：在各个 Goroutine 间传递数据；控制各个 Goroutine，也就是是超时控制。</p><p>这个自定义 Context 结构封装了 net/http 标准库主逻辑流程产生的 Context，与主逻辑流程完美对接。它除了实现了标准库的 Context 接口，还封装了 request 和 response 的请求。你实现好了 Context 之后，就会发现它跟百宝箱一样，在处理具体的业务逻辑的时候，如果需要获取参数、设置返回值等，都可以通过 Context 获取。</p><p>封装后，我们通过三步走为请求设置超时，并且完美地考虑了各种边界场景。</p><p>你是不是觉得我们这一路要思考的点太多了，又是异常，又是边界场景。但是这里我要特别说明，其实真正要衡量框架的优劣，要看什么？就是看细节。</p><p><strong>所有框架的基本原理和基本思路都差不多，但是在细节方面，各个框架思考的程度是不一样的，才导致使用感天差地别</strong>。所以如果你想完成一个真正生产能用得上的框架，这些边界场景、异常分支，都要充分考虑清楚。</p><h2>思考题</h2><p>在context库的官方文档中有这么一句话：</p><blockquote>\n<p>Do not store Contexts inside a struct type;<br>\ninstead, pass a Context explicitly to each function that needs it.<br>\nThe Context should be the first parameter.</p>\n</blockquote><p>大意是说建议我们设计函数的时候，将Context作为函数的第一个参数。你能理解官方为什么如此建议，有哪些好处？可以结合你的工作经验，说说自己的看法。</p><p>欢迎在留言区分享你的思考，畅所欲言。如果你觉得今天的内容有所帮助，也欢迎你分享给你身边的朋友，邀他一起学习。</p>',
        article_title: "02｜Context：请求控制器，让每个请求都在掌控之中",
      },
      {
        title: "03｜路由：如何让请求更快寻找到目标函数？",
        id: 419293,
        content:
          '<p>你好，我是轩脉刃。</p><p>上一讲，我们封装了框架的Context， 将请求结构 request 和返回结构 responseWriter 都封装在 Context 中。利用这个 Context， 我们将控制器简化为带有一个参数的函数FooControllerHandler，这个控制器函数的输入和输出都是固定的。在框架层面，我们也定义了对应关于控制器的方法结构ControllerHandler来代表这类控制器的函数。</p><p>每一个请求逻辑，都有一个控制器ControllerHandler与之对应。那么一个请求，如何查找到指定的控制器呢？这就是今天要研究的内容：路由，我将带你理解路由，并且实现一个高效、易用的路由模块。</p><h2>路由设计思路</h2><p>相信你对路由是干啥的已经有大致了解，具体来说就是让 Web 服务器根据规则，理解 HTTP 请求中的信息，匹配查找出对应的控制器，再将请求传递给控制器执行业务逻辑，<strong>简单来说就是制定匹配规则</strong>。</p><p><img src="https://static001.geekbang.org/resource/image/11/7b/11dee96201a6f32358d8cceced0f137b.jpg?wh=1920x1080" alt=""></p><p>但是就是这么简单的功能，<strong>路由的设计感不同，可用性有天壤之别</strong>。为什么这么说呢，我们带着这个问题，先来梳理一下制定路由规则需要的信息。</p><p>路由可以使用HTTP请求体中的哪些信息，得回顾我们第一节课讲 HTTP 的内容。</p><p>一个 HTTP 请求包含请求头和请求体。请求体内一般存放的是请求的业务数据，是基于具体控制业务需要的，所以，我们不会用来做路由。</p><!-- [[[read_end]]] --><p>而请求头中存放的是和请求状态有关的信息，比如User-Agent 代表的是请求的浏览器信息，Accept代表的是支持返回的文本类型。以下是一个标准请求头的示例：</p><pre><code class="language-xml">GET /home.html HTTP/1.1\nHost: developer.mozilla.org\nUser-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.9; rv:50.0) Gecko/20100101 Firefox/50.0\nAccept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8 \nAccept-Language: en-US,en;q=0.5\nAccept-Encoding: gzip, deflate, br\nReferer: https://developer.mozilla.org/testpage.html\n</code></pre><p>每一行的信息和含义都是非常大的课题，也与今天要讲的内容无关，我们这里要关注的是 HTTP 请求的第一行，叫做 Request Line，由三个部分组成：<strong>Method、Request-URI 和 HTTP-Version</strong>（<a href="https://datatracker.ietf.org/doc/html/rfc2616">RFC2616</a>）。</p><p><img src="https://static001.geekbang.org/resource/image/7b/d7/7bd9061513922ff9e748f4ed90422dd7.jpg?wh=1920x1080" alt=""></p><p>Method 是HTTP的方法，标识对服务端资源的操作属性。它包含多个方法，每个方法都代表不同的操作属性。</p><pre><code class="language-xml">       Method         = "OPTIONS"                ; Section 9.2\n                      | "GET"                    ; Section 9.3\n                      | "HEAD"                   ; Section 9.4\n                      | "POST"                   ; Section 9.5\n                      | "PUT"                    ; Section 9.6\n                      | "DELETE"                 ; Section 9.7\n                      | "TRACE"                  ; Section 9.8\n                      | "CONNECT"                ; Section 9.9\n                      | extension-method\n       extension-method = token\n</code></pre><p>Request-URI是请求路径，也就是浏览器请求地址中域名外的剩余部分。</p><p><img src="https://static001.geekbang.org/resource/image/a8/ac/a8ca2560e0096b2e364f569079496eac.jpg?wh=1920x1080" alt=""></p><p>HTTP-Version 是 HTTP 的协议版本，目前常见的有1.0、1.1、2.0。</p><p>Web Service 在路由中使用的就是Method和Request-URI这两个部分。了解制定路由规则时，请求体中可以使用的元素之后，我们再回答刚才的问题，什么是路由的设计感。</p><p>这里说的设计感指的是：<strong>框架设计者希望使用者如何用路由模块</strong>。</p><p>如果框架支持REST风格的路由设计，那么使用者在写业务代码的时候，就倾向于设计REST风格的接口；如果框架支持前缀匹配，那么使用者在定制URI的时候，也会倾向于把同类型的URI归为一类。</p><p>这些设计想法通通会<strong>体现在框架的路由规则上，最终影响框架使用者的研发习惯</strong>，这个就是设计感。所以其实，设计感和框架设计者偏好的研发风格直接相关，也没有绝对的优劣。</p><p>这里你很容易走入误区，我要说明一下。很多同学认为设计感的好坏体现在路由规则的多少上，其实不是。</p><p>路由规则，是根据路由来查找控制器的逻辑，它本身就是一个框架需求。我们可以天马行空设想100条路由规则，并且全部实现它，也可以只设计1、2个最简单的路由规则。很多或者很少的路由规则，都不会根本性影响使用者，所以，并不是衡量一个框架好坏的标准。</p><h2>路由规则的需求</h2><p>回到我们的框架，开头我们说过希望使用者高效、易用地使用路由模块，那出于这一点考虑，基本需求可以有哪些呢？</p><p>按照从简单到复杂排序，路由需求我整理成下面四点：</p><ul>\n<li><strong>需求1：HTTP方法匹配</strong></li>\n</ul><p>早期的 WebService 比较简单，HTTP 请求体中的 Request Line 或许只会使用到 Request-URI 部分，但是随着 REST 风格 WebService 的流行，为了让 URI 更具可读性，在现在的路由输入中，HTTP Method 也是很重要的一部分了，所以，我们框架也需要支持多种 HTTP Method，比如GET、POST、PUT、DELETE。</p><ul>\n<li><strong>需求2：静态路由匹配</strong></li>\n</ul><p>静态路由匹配是一个路由的基本功能，指的是路由规则中没有可变参数，即路由规则地址是固定的，与Request-URI 完全匹配。</p><p>我们在第一讲中提到的DefaultServerMux这个路由器，从内部的 map 中直接根据 key 寻找 value ，这种查找路由的方式就是静态路由匹配。</p><ul>\n<li><strong>需求3：批量通用前缀</strong></li>\n</ul><p>因为业务模块的划分，我们会同时为某个业务模块注册一批路由，所以在路由注册过程中，为了路由的可读性，一般习惯统一定义这批路由的通用前缀。比如 /user/info、/user/login 都是以 /user 开头，很方便使用者了解页面所属模块。</p><p>所以如果路由有能力统一定义批量的通用前缀，那么在注册路由的过程中，会带来很大的便利。</p><ul>\n<li><strong>需求4：动态路由匹配</strong></li>\n</ul><p>这个需求是针对需求2改进的，因为 URL 中某个字段或者某些字段并不是固定的，是按照一定规则（比如是数字）变化的。那么，我们希望路由也能够支持这个规则，将这个动态变化的路由URL匹配出来。所以我们需要，使用自己定义的路由来补充，只支持静态匹配的DefaultServerMux默认路由。</p><p>现在四个最基本的需求我们已经整理出来了，接下来通过一个例子来解释下，比如我们需要能够支持一个日志网站的这些功能：</p><p><img src="https://static001.geekbang.org/resource/image/dc/62/dc6e322c49be2334954d85b9883d0862.jpg?wh=1920x1080" alt=""></p><p>接下来就是今天的重头戏了，要匹配这样的路由列表，路由规则定义代码怎么写呢？我把最终的使用代码贴在这里，你可以先看看，然后我们一步步实现，分析清楚每行代码背后的方法如何定义、为什么要这么定义。</p><pre><code class="language-go">// 注册路由规则\nfunc registerRouter(core *framework.Core) {\n    // 需求1+2:HTTP方法+静态路由匹配\n\tcore.Post("/user/login", UserLoginController)\n    \n    // 需求3:批量通用前缀\n  \tsubjectApi := core.Group("/subject")\n\t{\n\t\tsubjectApi.Post("/add", SubjectAddController)\n        // 需求4:动态路由\n\t\tsubjectApi.Delete("/:id", SubjectDelController)\n\t\tsubjectApi.Put("/:id", SubjectUpdateController)\n\t\tsubjectApi.Get("/:id", SubjectGetController)\n        subjectApi.Get("/list/all", SubjectListController)\n\t}\t\n}\n</code></pre><p>（这段代码会在最后补充到上节课中创建的业务目录中的路由文件router.go。）</p><h2>实现HTTP方法和静态路由匹配</h2><p>我们首先看第一个需求和第二个需求。由于有两个待匹配的规则，Request-URI 和 Method，所以自然联想到可以使用两级哈希表来创建映射。</p><p><img src="https://static001.geekbang.org/resource/image/13/dc/13377ea20d08bcf39b3f1b735eca83dc.jpg?wh=1920x1232" alt=""><br>\n第一级hash是请求Method，第二级hash是Request-URI。</p><p>这个路由map我们会存放在第一讲定义的Core结构里（如下），并且在初始化 Core 结构的时候，初始化第一层map。所以还是拉出<a href="https://github.com/gohade/coredemo/blob/geekbang/03/framework/core.go">geekbang/03分支</a>，来更新框架文件夹中的core.go 文件：</p><pre><code class="language-go">// 框架核心结构\ntype Core struct {\n}\n\n// 初始化框架核心结构\nfunc NewCore() *Core {\n\treturn &amp;Core{}\n}\n\n// 框架核心结构实现Handler接口\nfunc (c *Core) ServeHTTP(response http.ResponseWriter, request *http.Request) {\n\t// TODO\n}\n</code></pre><p>接下来我们按框架使用者使用路由的顺序分成四步来完善这个结构：<strong>定义路由map、注册路由、匹配路由、填充ServeHTTP 方法</strong>。</p><p>首先，第一层map 的每个key值都代表Method，而且为了避免之后在匹配的时候，要转换一次大小写，我们将每个key都设置为大写。继续在框架文件夹中的core.go 文件里写：</p><pre><code class="language-go">// 框架核心结构\ntype Core struct {\n\trouter map[string]map[string]ControllerHandler // 二级map\n}\n\n// 初始化框架核心结构\nfunc NewCore() *Core {\n    // 定义二级map\n\tgetRouter := map[string]ControllerHandler{}\n\tpostRouter := map[string]ControllerHandler{}\n\tputRouter := map[string]ControllerHandler{}\n\tdeleteRouter := map[string]ControllerHandler{}\n\n    // 将二级map写入一级map\n\trouter := map[string]map[string]ControllerHandler{}\n\trouter["GET"] = getRouter\n\trouter["POST"] = postRouter\n\trouter["PUT"] = putRouter\n\trouter["DELETE"] = deleteRouter\n\n\treturn &amp;Core{router: router}\n}\n</code></pre><p>下一步就是路由注册，我们将路由注册函数按照Method名拆分为4个方法：Get、Post、Put和Delete。</p><pre><code class="language-go">// 对应 Method = Get\nfunc (c *Core) Get(url string, handler ControllerHandler) {\n\tupperUrl := strings.ToUpper(url)\n\tc.router["GET"][upperUrl] = handler\n}\n\n// 对应 Method = POST\nfunc (c *Core) Post(url string, handler ControllerHandler) {\n\tupperUrl := strings.ToUpper(url)\n\tc.router["POST"][upperUrl] = handler\n}\n\n// 对应 Method = PUT\nfunc (c *Core) Put(url string, handler ControllerHandler) {\n\tupperUrl := strings.ToUpper(url)\n\tc.router["PUT"][upperUrl] = handler\n}\n\n// 对应 Method = DELETE\nfunc (c *Core) Delete(url string, handler ControllerHandler) {\n\tupperUrl := strings.ToUpper(url)\n\tc.router["DELETE"][upperUrl] = handler\n}\n</code></pre><p>我们这里将URL全部转换为大写了，<strong>在后续匹配路由的时候，也要记得把匹配的URL进行大写转换</strong>，这样我们的路由就会是“大小写不敏感”的，对使用者的容错性就大大增加了。</p><p>注册完路由之后，如何匹配路由就是我们第三步需要做的事情了。首先我们实现匹配路由方法，这个匹配路由的逻辑我用注释写在代码中了。继续在框架文件夹中的core.go 文件里写入：</p><pre><code class="language-go">// 匹配路由，如果没有匹配到，返回nil\nfunc (c *Core) FindRouteByRequest(request *http.Request) ControllerHandler {\n\t// uri 和 method 全部转换为大写，保证大小写不敏感\n\turi := request.URL.Path\n\tmethod := request.Method\n\tupperMethod := strings.ToUpper(method)\n\tupperUri := strings.ToUpper(uri)\n\n\t// 查找第一层map\n\tif methodHandlers, ok := c.router[upperMethod]; ok {\n\t\t// 查找第二层map\n\t\tif handler, ok := methodHandlers[upperUri]; ok {\n\t\t\treturn handler\n\t\t}\n\t}\n\treturn nil\n}\n</code></pre><p>代码很容易看懂，匹配逻辑就是去二层哈希map中一层层匹配，先查找第一层匹配Method，再查第二层匹配Request-URI。</p><p>最后，我们就可以填充未实现的 ServeHTTP 方法了，所有请求都会进到这个函数中处理。（如果你有点模糊了，可以拿出第一节课中的思维导图，再巩固下 net/http 的核心逻辑。）继续在框架文件夹中的core.go 文件里写：</p><pre><code class="language-go">func (c *Core) ServeHTTP(response http.ResponseWriter, request *http.Request) {\n\n\t// 封装自定义context\n\tctx := NewContext(request, response)\n\n\t// 寻找路由\n\trouter := c.FindRouteByRequest(request)\n\tif router == nil {\n\t\t// 如果没有找到，这里打印日志\n\t\tctx.Json(404, "not found")\n\t\treturn\n\t}\n\n\t// 调用路由函数，如果返回err 代表存在内部错误，返回500状态码\n\tif err := router(ctx); err != nil {\n\t\tctx.Json(500, "inner error")\n\t\treturn\n\t}\n}\n</code></pre><p>这个函数就把我们前面三讲的内容都串起来了。先封装第二讲创建的自定义Context，然后使用 FindRouteByRequest 函数寻找我们需要的路由，如果没有找到路由，返回404状态码；如果找到了路由，就调用路由控制器，另外如果路由控制器出现内部错误，返回500状态码。</p><p>到这里，第一个和第二个需求就都完成了。</p><h2>实现批量通用前缀</h2><p>对于第三个需求，我们可以通过一个 Group 方法归拢路由前缀地址。修正在业务文件夹下的route.go文件，使用方法改成这样：</p><pre><code class="language-go">// 注册路由规则\nfunc registerRouter(core *framework.Core) {\n\t// 需求1+2:HTTP方法+静态路由匹配\n\tcore.Get("/user/login", UserLoginController)\n\n\t// 需求3:批量通用前缀\n\tsubjectApi := core.Group("/subject")\n\t{\n\t\tsubjectApi.Get("/list", SubjectListController)\n\t}\n}\n</code></pre><p>看下这个Group方法，它的参数是一个前缀字符串，返回值应该是包含Get、Post、Put、Delete 方法的一个结构，我们给这个结构命名Group，在其中实现各种方法。</p><p>在这里我们暂停一下，看看有没有优化点。</p><p>这么设计直接返回 Group 结构，确实可以实现功能，但试想一下，随着框架发展，如果我们发现Group结构的具体实现并不符合我们的要求了，需要引入实现另一个Group2结构，该怎么办？直接修改Group结构的具体实现么？<img src="https://static001.geekbang.org/resource/image/b4/ef/b40828bd1dbc2651dc649ac5ecd29fef.jpg?wh=1920x1080" alt=""></p><p><strong>其实更好的办法是使用接口来替代结构定义</strong>。在框架设计之初，我们要保证框架使用者，在最少的改动中，就能流畅迁移到Group2，这个时候，如果返回接口 IGroup，而不是直接返回 Group 结构，就不需要修改core.Group的定义了，只需要修改core.Group的具体实现，返回Group2就可以。<br>\n<img src="https://static001.geekbang.org/resource/image/2a/9b/2a969d91845f3fe1f8afd0144273509b.jpg?wh=1920x1080" alt=""><br>\n尽量使用接口来解耦合，是一种比较好的设计思路。</p><p>怎么实现呢，这里我们定义 IGroup 接口来作为Group方法的返回值。在框架文件夹下创建<a href="https://github.com/gohade/coredemo/blob/geekbang/03/framework/group.go">group.go文件</a>来存放分组相关的信息：</p><pre><code class="language-go">// IGroup 代表前缀分组\ntype IGroup interface {\n\tGet(string, ControllerHandler)\n\tPost(string, ControllerHandler)\n\tPut(string, ControllerHandler)\n\tDelete(string, ControllerHandler)\n}\n</code></pre><p>并且继续搭好Group 结构代码来实现这个接口：</p><pre><code class="language-go">// Group struct 实现了IGroup\ntype Group struct {\n\tcore&nbsp; &nbsp;*Core\n\tprefix string\n}\n\n// 初始化Group\nfunc NewGroup(core *Core, prefix string) *Group {\n\treturn &amp;Group{\n\t\tcore:&nbsp; &nbsp;core,\n\t\tprefix: prefix,\n\t}\n}\n\n// 实现Get方法\nfunc (g *Group) Get(uri string, handler ControllerHandler) {\n\turi = g.prefix + uri\n\tg.core.Get(uri, handler)\n}\n\n....\n\n// 从core中初始化这个Group\nfunc (c *Core) Group(prefix string) IGroup {\n\treturn NewGroup(c, prefix)\n}\n</code></pre><p>这个 Group 结构包含自身的前缀地址和Core结构的指针。它的 Get、Put、Post、Delete 方法就是把这个Group结构的前缀地址和目标地址组合起来，作为Core的Request-URI地址。<img src="https://static001.geekbang.org/resource/image/b5/f8/b5f6f18b380db972600032dcc97dfff8.jpg?wh=1920x1080" alt=""></p><p>讲到这里，有的同学可能不以为然，觉得这不就是个人代码风格的问题吗。其实并不是，希望你能够意识到，这个选择并不仅仅是代码风格，而是关于框架设计、关于代码扩展性。</p><p>接口是一种协议，它忽略具体的实现，定义的是两个逻辑结构的交互，因为两个函数之间定义的是一种约定，不依赖具体的实现。</p><p>你可以这么判断：<strong>如果你觉得这个模块是完整的，而且后续希望有扩展的可能性，那么就应该尽量使用接口来替代实现</strong>。在代码中，多大程度使用接口进行逻辑结构的交互，是评价框架代码可扩展性的一个很好的标准。这种思维会贯穿在我们整个框架的设计中，后续我会时不时再提起的。</p><p>所以回到我们的路由，使用IGroup接口后，core.Group 这个方法返回的是一个约定，而不依赖具体的Group实现。</p><h2>实现动态路由匹配</h2><p>现在已经完成了前三个需求，下面我们考虑第四个需求，希望在写业务的时候能支持像下列这种动态路由：</p><pre><code class="language-go">func registerRouter(core *framework.Core) {\n\t// 需求1+2:HTTP方法+静态路由匹配\n\tcore.Get("/user/login", UserLoginController)\n\n\t// 需求3:批量通用前缀\n\tsubjectApi := core.Group("/subject")\n\t{\n\t\t// 需求4:动态路由\n\t\tsubjectApi.Delete("/:id", SubjectDelController)\n\t\tsubjectApi.Put("/:id", SubjectUpdateController)\n\t\tsubjectApi.Get("/:id", SubjectGetController)\n\t\tsubjectApi.Get("/list/all", SubjectListController)\n\t}\n}\n</code></pre><p>如何实现？我们继续看。</p><p>首先，你要知道的是，<strong>一旦引入了动态路由匹配的规则，之前使用的哈希规则就无法使用了</strong>。因为有通配符，在匹配Request-URI的时候，请求URI的某个字符或者某些字符是动态变化的，无法使用URI做为key来匹配。那么，我们就需要其他的算法来支持路由匹配。</p><p>如果你对算法比较熟悉，会联想到<strong>这个问题本质是一个字符串匹配</strong>，而字符串匹配，比较通用的高效方法就是字典树，也叫trie树。</p><p>这里，我们先简单梳理下trie树的数据结构。trie树不同于二叉树，它是多叉的树形结构，根节点一般是空字符串，而叶子节点保存的通常是字符串，一个节点的所有子孙节点都有相同的字符串前缀。</p><p>所以根据trie树的特性，我们结合前三条路由规则，可以构建出这样的结构：</p><pre><code class="language-go">1 /user/login\n2 /user/logout\n3 /subject/name\n4 /subject/name/age\n5 /subject/:id/name\n</code></pre><p>画成图更清晰一些：<img src="https://static001.geekbang.org/resource/image/68/98/6837822864392bbb5e7345518448b098.jpg?wh=1920x1080" alt=""></p><p>这个trie树是按照路由地址的每个段(segment)来切分的，每个segment在trie树中都能找到对应节点，每个节点保存一个segment。树中，每个叶子节点都代表一个URI，对于中间节点来说，有的中间节点代表一个URI（比如上图中的 /subject/name），而有的中间节点并不是一个URI（因为没有路由规则对应这个URI）。</p><p>现在分析清楚了，我们开始动手实现trie树。还是照旧先明确下可以分为几步：</p><ol>\n<li>定义树和节点的数据结构</li>\n<li>编写函数：“增加路由规则”</li>\n<li>编写函数：“查找路由”</li>\n<li>将“增加路由规则”和“查找路由”添加到框架中</li>\n</ol><p>步骤非常清晰，好，废话不多说，我们一步一步来，首先定义对应的数据结构（node 和 tree）。先在框架文件夹下创建tree.go文件，存储trie树相关逻辑：</p><pre><code class="language-go">// 代表树结构\ntype Tree struct {\n\troot *node // 根节点\n}\n\n// 代表节点\ntype node struct {\n\tisLast&nbsp; bool&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // 代表这个节点是否可以成为最终的路由规则。该节点是否能成为一个独立的uri, 是否自身就是一个终极节点\n\tsegment string&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // uri中的字符串，代表这个节点表示的路由中某个段的字符串\n\thandler ControllerHandler // 代表这个节点中包含的控制器，用于最终加载调用\n\tchilds&nbsp; []*node&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;// 代表这个节点下的子节点\n}\n</code></pre><p>Tree结构中包含一个根节点，只是这个根节点是一个没有segment的空的根节点。</p><p>node的结构定义了四个字段。childs字段让node组成了一个树形结构，handler是具体的业务控制器逻辑存放位置，segment是树中的这个节点存放的内容，isLast用于区别这个树中的节点是否有实际的路由含义。</p><p>有了数据结构后，第二步，我们就往Tree这个trie树结构中增加“路由规则”的逻辑。写之前，我们还是暂停一下想一想，会不会出现问题。<strong>之前提过会存在通配符，那直接加规则其实是有可能冲突的</strong>。比如：</p><pre><code class="language-go">/user/name\n/user/:id\n</code></pre><p>这两个路由规则实际上就冲突了，如果请求地址是/user/name，那么两个规则都匹配，无法确定哪个规则生效。所以在增加路由之前，我们需要判断这个路由规则是否已经在trie树中存在了。</p><p>这里，我们可以用matchNode方法，寻找某个路由在trie树中匹配的节点，如果有匹配节点，返回节点指针，否则返回nil。<strong>matchNode方法的参数是一个URI，返回值是指向node的指针，它的实现思路是使用函数递归</strong>，我简单说明一下思路：</p><p>首先，将需要匹配的URI根据第一个分隔符/进行分割，只需要最多分割成为两个段。</p><p>如果只能分割成一个段，说明URI中没有分隔符了，这时候再检查下一级节点中是否有匹配这个段的节点就行。</p><p>如果分割成了两个段，我们用第一个段来检查下一个级节点中是否有匹配这个段的节点。</p><ul>\n<li>如果没有，说明这个路由规则在树中匹配不到。</li>\n<li>如果下一级节点中有符合第一个分割段的（这里需要注意可能不止一个符合），我们就将所有符合的节点进行函数递归，重新应用于matchNode函数中，只不过这时候matchNode函数作用于子节点，参数变成了切割后的第二个段。</li>\n</ul><p>好思路就讲完了，整个流程里，会频繁使用到“过滤下一层满足segment规则的子节点” ，所以我们也用一个函数 filterChildNodes 将它封装起来。这个函数的逻辑就比较简单了：遍历下一层子节点，判断segment是否匹配传入的参数segment。</p><p>在框架文件夹中的tree.go中，我们完成matchNode 和 filterChildNodes完整代码实现，放在这里了，具体逻辑我也加了详细的批注帮你理解。</p><pre><code class="language-go">// 判断一个segment是否是通用segment，即以:开头\nfunc isWildSegment(segment string) bool {\n\treturn strings.HasPrefix(segment, ":")\n}\n\n// 过滤下一层满足segment规则的子节点\nfunc (n *node) filterChildNodes(segment string) []*node {\n\tif len(n.childs) == 0 {\n\t\treturn nil\n\t}\n\n\t// 如果segment是通配符，则所有下一层子节点都满足需求\n\tif isWildSegment(segment) {\n\t\treturn n.childs\n\t}\n\n\tnodes := make([]*node, 0, len(n.childs))\n\t// 过滤所有的下一层子节点\n\tfor _, cnode := range n.childs {\n\t\tif isWildSegment(cnode.segment) {\n\t\t\t// 如果下一层子节点有通配符，则满足需求\n\t\t\tnodes = append(nodes, cnode)\n\t\t} else if cnode.segment == segment {\n\t\t\t// 如果下一层子节点没有通配符，但是文本完全匹配，则满足需求\n\t\t\tnodes = append(nodes, cnode)\n\t\t}\n\t}\n\n\treturn nodes\n}\n\n// 判断路由是否已经在节点的所有子节点树中存在了\nfunc (n *node) matchNode(uri string) *node {\n\t// 使用分隔符将uri切割为两个部分\n\tsegments := strings.SplitN(uri, "/", 2)\n\t// 第一个部分用于匹配下一层子节点\n\tsegment := segments[0]\n\tif !isWildSegment(segment) {\n\t\tsegment = strings.ToUpper(segment)\n\t}\n\t// 匹配符合的下一层子节点\n\tcnodes := n.filterChildNodes(segment)\n\t// 如果当前子节点没有一个符合，那么说明这个uri一定是之前不存在, 直接返回nil\n\tif cnodes == nil || len(cnodes) == 0 {\n\t\treturn nil\n\t}\n\n\t// 如果只有一个segment，则是最后一个标记\n\tif len(segments) == 1 {\n\t\t// 如果segment已经是最后一个节点，判断这些cnode是否有isLast标志\n\t\tfor _, tn := range cnodes {\n\t\t\tif tn.isLast {\n\t\t\t\treturn tn\n\t\t\t}\n\t\t}\n\n\t\t// 都不是最后一个节点\n\t\treturn nil\n\t}\n\n\t// 如果有2个segment, 递归每个子节点继续进行查找\n\tfor _, tn := range cnodes {\n\t\ttnMatch := tn.matchNode(segments[1])\n\t\tif tnMatch != nil {\n\t\t\treturn tnMatch\n\t\t}\n\t}\n\treturn nil\n}\n</code></pre><p>现在有了matchNode 和 filterChildNodes 函数，我们就可以开始写第二步里最核心的增加路由的函数逻辑了。</p><p><strong>首先，确认路由是否冲突</strong>。我们先检查要增加的路由规则是否在树中已经有可以匹配的节点了。如果有的话，代表当前待增加的路由和已有路由存在冲突，这里我们用到了刚刚定义的matchNode。更新刚才框架文件夹中的tree.go文件：</p><pre><code class="language-go">// 增加路由节点\nfunc (tree *Tree) AddRouter(uri string, handler ControllerHandler) error {\n\tn := tree.root\n    // 确认路由是否冲突\n\tif n.matchNode(uri) != nil {\n\t\treturn errors.New("route exist: " + uri)\n\t}\n\n\t...\n}\n\n</code></pre><p><strong>然后继续增加路由规则</strong>。我们增加路由的每个段时，先去树的每一层中匹配查找，如果已经有了符合这个段的节点，就不需要创建节点，继续匹配待增加路由的下个段；否则，需要创建一个新的节点用来代表这个段。这里，我们用到了定义的 filterChildNodes。</p><pre><code class="language-go">// 增加路由节点\n/*\n/book/list\n/book/:id (冲突)\n/book/:id/name\n/book/:student/age\n/:user/name\n/:user/name/:age(冲突)\n*/\nfunc (tree *Tree) AddRouter(uri string, handler ControllerHandler) error {\n\tn := tree.root\n\tif n.matchNode(uri) != nil {\n\t\treturn errors.New("route exist: " + uri)\n\t}\n\n\tsegments := strings.Split(uri, "/")\n\t// 对每个segment\n\tfor index, segment := range segments {\n\n\t\t// 最终进入Node segment的字段\n\t\tif !isWildSegment(segment) {\n\t\t\tsegment = strings.ToUpper(segment)\n\t\t}\n\t\tisLast := index == len(segments)-1\n\n\t\tvar objNode *node // 标记是否有合适的子节点\n\n\t\tchildNodes := n.filterChildNodes(segment)\n\t\t// 如果有匹配的子节点\n\t\tif len(childNodes) &gt; 0 {\n\t\t\t// 如果有segment相同的子节点，则选择这个子节点\n\t\t\tfor _, cnode := range childNodes {\n\t\t\t\tif cnode.segment == segment {\n\t\t\t\t\tobjNode = cnode\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif objNode == nil {\n\t\t\t// 创建一个当前node的节点\n\t\t\tcnode := newNode()\n\t\t\tcnode.segment = segment\n\t\t\tif isLast {\n\t\t\t\tcnode.isLast = true\n\t\t\t\tcnode.handler = handler\n\t\t\t}\n\t\t\tn.childs = append(n.childs, cnode)\n\t\t\tobjNode = cnode\n\t\t}\n\n\t\tn = objNode\n\t}\n\n\treturn nil\n}\n</code></pre><p>到这里，第二步增加路由的规则逻辑已经有了，<strong>我们要开始第三步，编写“查找路由”的逻辑</strong>。这里你会发现，由于我们之前已经定义过matchNode（匹配路由节点），所以这里只需要复用这个函数就行了。</p><pre><code class="language-go">// 匹配uri\nfunc (tree *Tree) FindHandler(uri string) ControllerHandler {\n    // 直接复用matchNode函数，uri是不带通配符的地址\n\tmatchNode := tree.root.matchNode(uri)\n\tif matchNode == nil {\n\t\treturn nil\n\t}\n\treturn matchNode.handler\n}\n\n</code></pre><p>前三步已经完成了，<strong>最后一步，我们把“增加路由规则”和“查找路由”添加到框架中</strong>。还记得吗，在静态路由匹配的时候，在Core中使用哈希定义的路由，这里将哈希替换为trie树。还是在框架文件夹中的core.go文件，找到对应位置作修改：</p><pre><code class="language-go">type Core struct {\n\trouter map[string]*Tree // all routers\n}\n</code></pre><p>对应路由增加的方法，也从哈希的增加逻辑，替换为trie树的“增加路由规则”逻辑。同样更新core.go文件中的下列方法：</p><pre><code class="language-go">// 初始化Core结构\nfunc NewCore() *Core {\n\t// 初始化路由\n\trouter := map[string]*Tree{}\n\trouter["GET"] = NewTree()\n\trouter["POST"] = NewTree()\n\trouter["PUT"] = NewTree()\n\trouter["DELETE"] = NewTree()\n\treturn &amp;Core{router: router}\n}\n\n\n\n// 匹配GET 方法, 增加路由规则\nfunc (c *Core) Get(url string, handler ControllerHandler) {\n\tif err := c.router["GET"].AddRouter(url, handler); err != nil {\n\t\tlog.Fatal("add router error: ", err)\n\t}\n}\n\n// 匹配POST 方法, 增加路由规则\nfunc (c *Core) Post(url string, handler ControllerHandler) {\n\tif err := c.router["POST"].AddRouter(url, handler); err != nil {\n\t\tlog.Fatal("add router error: ", err)\n\t}\n}\n\n// 匹配PUT 方法, 增加路由规则\nfunc (c *Core) Put(url string, handler ControllerHandler) {\n\tif err := c.router["PUT"].AddRouter(url, handler); err != nil {\n\t\tlog.Fatal("add router error: ", err)\n\t}\n}\n\n// 匹配DELETE 方法, 增加路由规则\nfunc (c *Core) Delete(url string, handler ControllerHandler) {\n\tif err := c.router["DELETE"].AddRouter(url, handler); err != nil {\n\t\tlog.Fatal("add router error: ", err)\n\t}\n}\n</code></pre><p>之前在Core中定义的匹配路由函数的实现逻辑，从哈希匹配修改为trie树匹配就可以了。继续更新core.go文件：</p><pre><code class="language-go">// 匹配路由，如果没有匹配到，返回nil\nfunc (c *Core) FindRouteByRequest(request *http.Request) ControllerHandler {\n\t// uri 和 method 全部转换为大写，保证大小写不敏感\n\turi := request.URL.Path\n\tmethod := request.Method\n\tupperMethod := strings.ToUpper(method)\n\n\t// 查找第一层map\n\tif methodHandlers, ok := c.router[upperMethod]; ok {\n\t\treturn methodHandlers.FindHandler(uri)\n\t}\n\treturn nil\n}\n\n</code></pre><p>动态匹配规则就改造完成了。</p><h2>验证</h2><p>现在，四个需求都已经实现了。我们验证一下：定义包含有静态路由、批量通用前缀、动态路由的路由规则，每个控制器我们就直接输出控制器的名字，然后启动服务。</p><p>这个时候我们就可以去修改业务文件夹下的路由文件route.go：</p><pre><code class="language-go">// 注册路由规则\nfunc registerRouter(core *framework.Core) {\n\t// 需求1+2:HTTP方法+静态路由匹配\n\tcore.Get("/user/login", UserLoginController)\n\n\t// 需求3:批量通用前缀\n\tsubjectApi := core.Group("/subject")\n\t{\n\t\t// 需求4:动态路由\n\t\tsubjectApi.Delete("/:id", SubjectDelController)\n\t\tsubjectApi.Put("/:id", SubjectUpdateController)\n\t\tsubjectApi.Get("/:id", SubjectGetController)\n\t\tsubjectApi.Get("/list/all", SubjectListController)\n\t}\n}\n</code></pre><p>同时在业务文件夹下创建对应的业务控制器user_controller.go和subject_controller.go。具体里面的逻辑代码就是打印出对应的控制器名字，比如</p><pre><code class="language-go">func UserLoginController(c *framework.Context) error {\n   // 打印控制器名字\n   c.Json(200, "ok, UserLoginController")\n   return nil\n}\n</code></pre><p>来看服务启动情况：访问地址/user/login 匹配路由UserLoginContorller。</p><p><img src="https://static001.geekbang.org/resource/image/df/52/df2cf7aaf2be03c6da8bb8e72a10fd52.png?wh=684x191" alt="图片"></p><p>访问地址/subject/list/all 匹配路由SubjectListController。</p><p><img src="https://static001.geekbang.org/resource/image/b5/0a/b5f4248d9ee478eed83b121c886c640a.png?wh=663x267" alt="图片"></p><p>访问地址 /subject/100 匹配动态路由 SubjectGetController。</p><p><img src="https://static001.geekbang.org/resource/image/a6/f0/a6f095eb721b20dbeeb6952aa24df7f0.png?wh=655x227" alt="图片"></p><p>路由规则符合要求！</p><p>今天的文件及代码结构如下，新建的文件夹多一点你可以对照着GitHub再看看，代码地址在<a href="https://github.com/gohade/coredemo/tree/geekbang/03">geekbang/03</a>分支上：<br>\n<img src="https://static001.geekbang.org/resource/image/c2/3c/c2518fc8d20034aacb93b5e509375b3c.png?wh=726x942" alt=""></p><h2>小结</h2><p>在这一讲，我们一步步实现了满足四个需求的路由：HTTP方法匹配、批量通用前缀、静态路由匹配和动态路由匹配。</p><p>我们使用IGroup结构和在Core中定义key为方法的路由，实现了HTTP方法匹配、批量通用前缀这两个需求，并且用哈希来实现静态路由匹配，之后我们使用trie树算法替代哈希算法，实现了动态路由匹配的需求。</p><p>所以，你有没有发现，<strong>其实所谓的实现功能，写代码只是其中一小部分，如何思考、如何考虑容错性、扩展性和复用性，这个反而是更大的部分</strong>。</p><p>以今天实现的路由这个功能为例，你是否考虑到了URI的容错性，在Group返回时候是否使用接口增加扩展性，在实现动态匹配的时候是否考虑函数复用性。我们要记住的是，思路比代码实现更重要。</p><h1>思考题</h1><p>光说不练假把式，毕竟我们是实战课，那针对第三个需求“批量通用前缀”，我们扩展一下变成：需要能多层嵌套通用前缀，这么定义路由：</p><pre><code class="language-go">// 注册路由规则\nfunc registerRouter(core *framework.Core) {\n\t// 静态路由+HTTP方法匹配\n\tcore.Get("/user/login", UserLoginController)\n\n\t// 批量通用前缀\n\tsubjectApi := core.Group("/subject")\n\t{\n\t\tsubjectInnerApi := subjectApi.Group("/info")\n\t\t{\n\t\t\tsubjectInnerApi.Get("/name", SubjectNameController)\t\n\t\t}\n    }\n}\n</code></pre><p>结合刚才说的考虑代码的设计感，你想一想如何实现呢？</p><p>欢迎在留言区分享你的思考。如果你觉得今天的内容对你有所帮助，也欢迎你把今天的内容分享给你身边的朋友，邀请他一起学习～</p>',
        article_title: "03｜路由：如何让请求更快寻找到目标函数？",
      },
      {
        title: "04｜中间件：如何提高框架的可拓展性？",
        id: 420006,
        content:
          '<p>你好，我是轩脉刃。</p><p>到目前为止我们已经完成了Web框架的基础部分，使用net/http启动了一个Web服务，并且定义了自己的Context，可以控制请求超时。</p><p>之前在讲具体实现的时候，我们反复强调要注意代码的优化。那么如何优化呢？具体来说，很重要的一点就是封装。所以今天我们就回顾一下之前写的代码，看看如何通过封装来进一步提高代码扩展性。</p><p>在第二课，我们在业务文件夹中的controller.go的逻辑中设置了一个有超时时长的控制器：</p><pre><code class="language-go">func FooControllerHandler(c *framework.Context) error {\n\t...\n    // 在业务逻辑处理前，创建有定时器功能的 context\n\tdurationCtx, cancel := context.WithTimeout(c.BaseContext(), time.Duration(1*time.Second))\n\tdefer cancel()\n\n\tgo func() {\n\t\t...\n\t\t// 执行具体的业务逻辑\n        \n\t\ttime.Sleep(10 * time.Second)\n        // ...\n              \n\t\tfinish &lt;- struct{}{}\n\t}()\n\t// 在业务逻辑处理后，操作输出逻辑...\n    select {\n\t...\n\tcase &lt;-finish:\n\t\tfmt.Println("finish")\n\t...\n\t}\n\treturn nil\n}\n</code></pre><!-- [[[read_end]]] --><p>在正式执行业务逻辑之前，创建了一个具有定时器功能的 Context，然后开启一个 Goroutine 执行正式的业务逻辑，并且监听定时器和业务逻辑，哪个先完成，就先输出内容。</p><p>首先从代码功能分析，这个控制器像由两部分组成。</p><p>一部分是<strong>业务逻辑</strong>，也就是time.Sleep函数所代表的逻辑，在实际生产过程中，这里会有很重的业务逻辑代码；而另一部分是<strong>非业务逻辑</strong>，比如创建Context、通道等待finish信号等。很明显，这个非业务逻辑是非常通用的需求，可能在多个控制器中都会使用到。</p><p>而且考虑复用性，这里只是写了一个控制器，那如果有多个控制器呢，我们难道要为每个控制器都写上这么一段超时代码吗？那就非常冗余了。</p><p>所以，能不能设计一个机制，<strong>将这些非业务逻辑代码抽象出来，封装好，提供接口给控制器使用</strong>。这个机制的实现，就是我们今天要讲的中间件。</p><p>怎么实现这个中间件呢？我们再观察一下刚才的代码找找思路。</p><p>代码的组织顺序很清晰，先预处理请求，再处理业务逻辑，最后处理返回值，你发现没有这种顺序，其实很符合设计模式中的装饰器模式。装饰器模式，顾名思义，就是在核心处理模块的外层增加一个又一个的装饰，类似洋葱。<img src="https://static001.geekbang.org/resource/image/f9/2c/f94ccc78af2ca491afe1591e674e3f2c.jpg?wh=1920x912" alt=""></p><p>现在，抽象出中间件的思路是不是就很清晰了，把核心业务逻辑先封装起来，然后一层一层添加装饰，最终让所有请求正序一层层通过装饰器，进入核心处理模块，再反序退出装饰器。原理就是这么简单，不难理解，我们接着看该如何实现。</p><h2>使用函数嵌套方式实现中间件</h2><p>装饰器模式是一层一层的，所以具体实现其实也不难想到，就是使用函数嵌套。</p><p>首先，我们封装核心的业务逻辑。就是说，这个中间件的输入是一个核心的业务逻辑 ControllerHandler，输出也应该是一个 ControllerHandler。所以<strong>对于一个超时控制器，我们可以定义一个中间件为 TimeoutHandler</strong>。</p><p>在框架文件夹中，我们创建一个timeout.go文件来存放这个中间件。</p><pre><code class="language-go">func TimeoutHandler(fun ControllerHandler, d time.Duration) ControllerHandler {\n\t// 使用函数回调\n\treturn func(c *Context) error {\n\n\t\tfinish := make(chan struct{}, 1)\n\t\tpanicChan := make(chan interface{}, 1)\n\n\t\t// 执行业务逻辑前预操作：初始化超时 context\n\t\tdurationCtx, cancel := context.WithTimeout(c.BaseContext(), d)\n\t\tdefer cancel()\n\n\t\tc.request.WithContext(durationCtx)\n\n\t\tgo func() {\n\t\t\tdefer func() {\n\t\t\t\tif p := recover(); p != nil {\n\t\t\t\t\tpanicChan &lt;- p\n\t\t\t\t}\n\t\t\t}()\n\t\t\t// 执行具体的业务逻辑\n\t\t\tfun(c)\n\n\t\t\tfinish &lt;- struct{}{}\n\t\t}()\n\t\t// 执行业务逻辑后操作\n\t\tselect {\n\t\tcase p := &lt;-panicChan:\n\t\t\tlog.Println(p)\n\t\t\tc.responseWriter.WriteHeader(500)\n\t\tcase &lt;-finish:\n\t\t\tfmt.Println("finish")\n\t\tcase &lt;-durationCtx.Done():\n\t\t\tc.SetHasTimeout()\n\t\t\tc.responseWriter.Write([]byte("time out"))\n\t\t}\n\t\treturn nil\n\t}\n}\n</code></pre><p>仔细看下这段代码，中间件函数的返回值是一个匿名函数，这个匿名函数实现了ControllerHandler 函数结构，参数为Context，返回值为error。</p><p>在这个匿名函数中，我们先创建了一个定时器Context，然后开启一个Goroutine，在Goroutine中执行具体的业务逻辑。这个Goroutine会在业务逻辑执行结束后，通过一个finish的channel来传递结束信号；也会在业务出现异常的时候，通过panicChan来传递异常信号。</p><p>而在业务逻辑之外的主Goroutine中，会同时进行多个信号的监听操作，包括结束信号、异常信号、超时信号，耗时最短的信号到达后，请求结束。这样，我们就完成了设置业务超时的任务。</p><p>于是在业务文件夹route.go中，路由注册就可以修改为：</p><pre><code class="language-go">// 在核心业务逻辑 UserLoginController 之外，封装一层 TimeoutHandler\ncore.Get("/user/login", framework.TimeoutHandler(UserLoginController, time.Second))\n</code></pre><p>这种函数嵌套方式，让下层中间件是上层中间件的参数，通过一层层嵌套实现了中间件的装饰器模式。</p><p>但是你再想一步，就会发现，这样实现的中间件机制有两个问题：</p><ol>\n<li><strong>中间件是循环嵌套的</strong>，当有多个中间件的时候，整个嵌套长度就会非常长，非常不优雅的，比如：</li>\n</ol><pre><code class="language-go">TimeoutHandler(LogHandler(recoveryHandler(UserLoginController)))\n</code></pre><ol start="2">\n<li>刚才的实现，<strong>只能为单个业务控制器设置中间件，不能批量设置</strong>。上一课我们开发的路由是具有同前缀分组功能的（IGroup），需要批量为某个分组设置一个超时时长。</li>\n</ol><p>所以，我们要对刚才实现的简单中间件代码做一些改进。怎么做呢？</p><h2>使用 pipeline 思想改造中间件</h2><p>一层层嵌套不好用，如果我们将每个核心控制器所需要的中间件，使用一个数组链接（Chain）起来，形成一条流水线（Pipeline），就能完美解决这两个问题了。</p><p>请求流的流向如下图所示：<img src="https://static001.geekbang.org/resource/image/e1/2a/e1aa5937627e46c8b2b21e45426f342a.jpg?wh=1920x915" alt=""></p><p>这个Pipeline模型和前面的洋葱模型不一样的点在于，<strong>Middleware不再以下一层的ControllerHandler为参数了，它只需要返回有自身中间件逻辑的ControllerHandler</strong>。</p><p>也就是在框架文件夹中的timeout.go中，我们将Middleware的形式从刚才的：</p><pre><code class="language-go">func TimeoutHandler(fun ControllerHandler, d time.Duration) ControllerHandler {\n\t// 使用函数回调\n\treturn func(c *Context) error {\n   //...\n    }\n}\n</code></pre><p>变成这样：</p><pre><code class="language-go">// 超时控制器参数中ControllerHandler结构已经去掉\nfunc Timeout(d time.Duration) framework.ControllerHandler {\n\t// 使用函数回调\n\treturn func(c *framework.Context) error {\n      //...\n    }\n}\n</code></pre><p>但是在中间件注册的回调函数中，如何调用下一个ControllerHandler呢？在回调函数中，只有framework.Context 这个数据结构作为参数。</p><p>所以就需要我们在Context这个数据结构中想一些办法了。回顾下目前有的数据结构：Core、Context、Tree、Node、Group。<img src="https://static001.geekbang.org/resource/image/8e/7b/8ef582e74e9c5ca1c0f54e7c1d75a67b.jpg?wh=1920x1277" alt=""></p><p>它们基本上都是以 Core 为中心，在 Core 中设置路由 router，实现了 Tree 结构，在 Tree 结构中包含路由节点 node；在注册路由的时候，将对应的业务核心处理逻辑 handler ，放在 node 结构的 handler 属性中。</p><p>而 Core 中的 ServeHttp 方法会创建 Context 数据结构，然后ServeHttp方法再根据 Request-URI 查找指定 node，并且将 Context 结构和 node 中的控制器 ControllerHandler 结合起来执行具体的业务逻辑。</p><p>结构都梳理清楚了，怎么改造成流水线呢？</p><p>我们可以<strong>将每个中间件构造出来的 ControllerHandler 和最终的业务逻辑的 ControllerHandler 结合在一起</strong>，成为一个 ControllerHandler 数组，也就是控制器链。在最终执行业务代码的时候，能一个个调用控制器链路上的控制器。</p><p>这个想法其实是非常自然的，因为中间件中创造出来的ControllerHandler匿名函数，和最终的控制器业务逻辑ControllerHandler，都是<strong>同样的结构</strong>，<strong>所以我们可以选用Controllerhander的数组，来表示某个路由的业务逻辑</strong>。</p><p>对应到代码上，我们先搞清楚使用链路的方式，再看如何注册和构造链路。</p><h3>如何使用控制器链路</h3><p>首先，我们研究下如何使用这个控制器链路，即图中右边部分的改造。<br>\n<img src="https://static001.geekbang.org/resource/image/49/c8/49c2d50b26d48e338c3acd2e1374f4c8.jpg?wh=1920x1277" alt=""></p><p>第一步，我们需要修改路由节点node。</p><p>在node节点中将原先的Handler，替换为控制器链路Handlers。这样在寻找路由节点的时候，就能找到对应的控制器链路了。修改框架文件夹中存放trie树的trie.go文件：</p><pre><code class="language-go">// 代表节点\ntype node struct {\n\t...\n\thandlers []ControllerHandler // 中间件+控制器 \n    ...\n}\n\n</code></pre><p>第二步，我们修改Context结构。</p><p>由于我们上文提到，在中间件注册的回调函数中，只有framework.Context 这个数据结构作为参数，所以在Context中也需要保存这个控制器链路(handlers)，并且要记录下当前执行到了哪个控制器（index）。修改框架文件夹的context.go文件：</p><pre><code class="language-go">// Context代表当前请求上下文\ntype Context struct {\n\t...\n\n\t// 当前请求的handler链条\n\thandlers []ControllerHandler\n\tindex&nbsp; &nbsp; int // 当前请求调用到调用链的哪个节点\n}\n</code></pre><p>第三步，来实现链条调用方式。</p><p>为了控制实现链条的逐步调用，我们为Context实现一个Next方法。这个Next方法每调用一次，就将这个控制器链路的调用控制器，往后移动一步。继续在框架文件夹中的context.go文件里写：</p><pre><code class="language-go">// 核心函数，调用context的下一个函数\nfunc (ctx *Context) Next() error {\n\tctx.index++\n\tif ctx.index &lt; len(ctx.handlers) {\n\t\tif err := ctx.handlers[ctx.index](ctx); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n</code></pre><p>这里我再啰嗦一下，Next() 函数是整个链路执行的重点，要好好理解，它通过维护Context中的一个下标，来控制链路移动，这个下标表示当前调用Next要执行的控制器序列。</p><p>Next() 函数会在框架的两个地方被调用：</p><ul>\n<li>第一个是在此次请求处理的入口处，即Core的ServeHttp；</li>\n<li>第二个是在每个中间件的逻辑代码中，用于调用下个中间件。<br>\n<img src="https://static001.geekbang.org/resource/image/73/3c/73a80752cf6d94b90febd2e23e80bc3c.jpg?wh=1920x915" alt=""></li>\n</ul><p>这里要注意，index下标表示当前调用Next要执行的控制器序列，它的<strong>初始值应该为-1，每次调用都会自增1</strong>，这样才能保证第一次调用的时候index为0，定位到控制器链条的下标为0的控制器，即第一个控制器。</p><p>在框架文件夹context.go的初始化Context函数中，代码如下：</p><pre><code class="language-go">// NewContext 初始化一个Context\nfunc NewContext(r *http.Request, w http.ResponseWriter) *Context {\n\treturn &amp;Context{\n\t\t...\n\t\tindex:&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; -1,\n\t}\n}\n</code></pre><p>被调用的第一个地方，在入口处调用的代码，写在框架文件夹中的core.go文件中：</p><pre><code class="language-go">// 所有请求都进入这个函数, 这个函数负责路由分发\nfunc (c *Core) ServeHTTP(response http.ResponseWriter, request *http.Request) {\n\n\t// 封装自定义context\n\tctx := NewContext(request, response)\n\n\t// 寻找路由\n\thandlers := c.FindRouteByRequest(request)\n\tif handlers == nil {\n\t\t// 如果没有找到，这里打印日志\n\t\tctx.Json(404, "not found")\n\t\treturn\n\t}\n\n    // 设置context中的handlers字段\n\tctx.SetHandlers(handlers)\n\n\t// 调用路由函数，如果返回err 代表存在内部错误，返回500状态码\n\tif err := ctx.Next(); err != nil {\n\t\tctx.Json(500, "inner error")\n\t\treturn\n\t}\n}\n</code></pre><p>被调用的第二个位置在中间件中，每个中间件都通过调用 context.Next 来调用下一个中间件。所以我们可以在框架文件夹中创建middleware目录，其中创建一个test.go存放我们的测试中间件：</p><pre><code class="language-go">func Test1() framework.ControllerHandler {\n\t// 使用函数回调\n\treturn func(c *framework.Context) error {\n\t\tfmt.Println("middleware pre test1")\n\t\tc.Next()  // 调用Next往下调用，会自增contxt.index\n\t\tfmt.Println("middleware post test1")\n\t\treturn nil\n\t}\n}\n\nfunc Test2() framework.ControllerHandler {\n\t// 使用函数回调\n\treturn func(c *framework.Context) error {\n\t\tfmt.Println("middleware pre test2")\n\t\tc.Next() // 调用Next往下调用，会自增contxt.index\n\t\tfmt.Println("middleware post test2")\n\t\treturn nil\n\t}\n}\n\n</code></pre><h3>如何注册控制器链路</h3><p>如何使用控制器链路，我们就讲完了，再看控制器链路如何注册，就是之前UML图的左边部分。<img src="https://static001.geekbang.org/resource/image/3c/b5/3c2012fcfcabcfc0159e4ecec2fdb8b5.jpg?wh=1920x1277" alt=""></p><p>很明显，现有的函数没有包含注册中间件逻辑，所以我们需要为Group和Core两个结构增加注册中间件入口，要设计两个地方：</p><ul>\n<li>Core和Group单独设计一个Use函数，为其数据结构负责的路由批量设置中间件</li>\n<li>为Core和Group注册单个路由的 Get / Post / Put / Delete 函数，设置中间件</li>\n</ul><p>先看下批量设置中间件的Use函数，我们在框架文件夹中的core.go修改：</p><pre><code class="language-go">// 注册中间件\nfunc (c *Core) Use(middlewares ...ControllerHandler) {\n   c.middlewares = append(c.middlewares, middlewares...)\n}\n</code></pre><p>和框架文件夹中的group.go中修改：</p><pre><code class="language-go">// 注册中间件\nfunc (g *Group) Use(middlewares ...ControllerHandler) {\n   g.middlewares = append(g.middlewares, middlewares...)\n}\n</code></pre><p>注意下这里的参数，使用的是Golang的可变参数，<strong>这个可变参数代表，我可以传递0～n个ControllerHandler类型的参数</strong>，这个设计会增加函数的易用性。它在业务文件夹中使用起来的形式是这样的，在main.go中：</p><pre><code class="language-go">// core中使用use注册中间件\ncore.Use(\n\t\tmiddleware.Test1(),\n\t\tmiddleware.Test2())\n\n// group中使用use注册中间件\nsubjectApi := core.Group("/subject")\nsubjectApi.Use(middleware.Test3())\n</code></pre><p>再看单个路由设置中间件的函数，我们也使用可变参数，改造注册路由的函数（Get /Post /Delete /Put），继续在框架文件夹中的core.go里修改：</p><pre><code class="language-go">// Core的Get方法进行改造\nfunc (c *Core) Get(url string, handlers ...ControllerHandler) {\n\t// 将core的middleware 和 handlers结合起来\n\tallHandlers := append(c.middlewares, handlers...)\n\tif err := c.router["GET"].AddRouter(url, allHandlers); err != nil {\n\t\tlog.Fatal("add router error: ", err)\n\t}\n}\n... \n</code></pre><p>同时修改框架文件夹中的group.go：</p><pre><code class="language-go">// 改造IGroup 的所有方法\ntype IGroup interface {\n\t// 实现HttpMethod方法\n\tGet(string, ...ControllerHandler)\n\tPost(string, ...ControllerHandler)\n\tPut(string, ...ControllerHandler)\n\tDelete(string, ...ControllerHandler)\n    //..\n}\n\n// 改造Group的Get方法\nfunc (g *Group) Get(uri string, handlers ...ControllerHandler) {\n\turi = g.getAbsolutePrefix() + uri\n\tallHandlers := append(g.getMiddlewares(), handlers...)\n\tg.core.Get(uri, allHandlers...)\n}\n\n...\n</code></pre><p>这样，回到业务文件夹中的router.go，我们注册路由的使用方法就可以变成如下形式：</p><pre><code class="language-go">// 注册路由规则\nfunc registerRouter(core *framework.Core) {\n\t// 在core中使用middleware.Test3() 为单个路由增加中间件\n\tcore.Get("/user/login", middleware.Test3(), UserLoginController)\n\n\t// 批量通用前缀\n\tsubjectApi := core.Group("/subject")\n\t{\n        ...\n        // 在group中使用middleware.Test3() 为单个路由增加中间件\n\t\tsubjectApi.Get("/:id", middleware.Test3(), SubjectGetController)\n\t}\n}\n</code></pre><p>不管是通过批量注册中间件，还是单个注册中间件，最终都要汇总到路由节点node中，所以这里我们调用了上一节课最终增加路由的函数Tree.AddRouter，把将这个请求对应的Core结构里的中间件和Group结构里的中间件，都聚合起来，成为最终路由节点的中间件。</p><p>聚合的逻辑在group.go和core.go中都有，实际上就是<strong>将Handler和Middleware一起放在一个数组中</strong>。</p><pre><code class="language-go">// 获取某个group的middleware\n// 这里就是获取除了Get/Post/Put/Delete之外设置的middleware\nfunc (g *Group) getMiddlewares() []ControllerHandler {\n\tif g.parent == nil {\n\t\treturn g.middlewares\n\t}\n\n\treturn append(g.parent.getMiddlewares(), g.middlewares...)\n}\n\n// 实现Get方法\nfunc (g *Group) Get(uri string, handlers ...ControllerHandler) {\n\turi = g.getAbsolutePrefix() + uri\n\tallHandlers := append(g.getMiddlewares(), handlers...)\n\tg.core.Get(uri, allHandlers...)\n}\n</code></pre><p>在core.go文件夹里写：</p><pre><code class="language-go">// 匹配GET 方法, 增加路由规则\nfunc (c *Core) Get(url string, handlers ...ControllerHandler) {\n\t// 将core的middleware 和 handlers结合起来\n\tallHandlers := append(c.middlewares, handlers...)\n\tif err := c.router["GET"].AddRouter(url, allHandlers); err != nil {\n\t\tlog.Fatal("add router error: ", err)\n\t}\n}\n\n</code></pre><p>到这里，我们使用 pipeline 思想对中间件的改造就完成了, 最终的UML类图如下：<br>\n<img src="https://static001.geekbang.org/resource/image/7f/ab/7f26e60d79ec987dba10a1b5045aa2ab.jpg?wh=1920x1277" alt=""></p><p>让我们简要回顾下改造过程。</p><p>第一步使用控制器链路，我们<strong>改造了node和Context两个数据结构</strong>。为node增加了handlers，存放这个路由注册的所有中间件；Context也增加了handlers，在Core.ServeHttp的函数中，创建Context结构，寻找到请求对应的路由节点，然后把路由节点的handlers数组，复制到Context中的handlers。</p><p>为了实现真正的链路调用，需要在框架的<strong>两个地方调用Context.Next() 方法</strong>，一个是启动业务逻辑的地方，一个是每个中间件的调用。</p><p>第二步如何注册控制器链路，我们<strong>改造了Group和Core两个数据结构，为它们增加了注册中间件的入口</strong>，一处是批量增加中间件函数Use，一处是在注册单个路由的Get / Post / Delete / Put方法中，为单个路由设置中间件。在设计入口的时候，我们使用了可变参数的设计，提高注册入口的可用性。</p><h2>基本的中间件: Recovery</h2><p>我们现在已经将中间件机制搭建并运行起来了， 但是具体需要实现哪些中间件呢？这要根据不同需求进行不同的研发，是个长期话题。</p><p>这里我们演示一个最基本的中间件：Recovery。</p><p>中间件那么多，比如超时中间件、统计中间件、日志中间件，为什么我说Recovery是最基本的呢？给出我的想法之前，你可以先思考这个问题：在编写业务核心逻辑的时候，如果出现了一个panic，而且在业务核心逻辑函数中未捕获处理，会发生什么？</p><p>我们还是基于第一节课讲的net/http的主流程逻辑来思考，关键结论有一点是，<strong>每个HTTP连接都会开启一个Goroutine为其服务</strong>，所以很明显， net/http 的进程模型是单进程、多协程。<img src="https://static001.geekbang.org/resource/image/0f/ee/0fa86b64b6d1b1e96560420243ec6aee.jpg?wh=1920x1133" alt=""></p><p>在Golang的这种模型中，每个协程是独立且平等的，即使是创建子协程的父协程，在Goroutine 中也无法管理子协程。所以，<strong>每个协程需要自己保证不会外抛panic</strong>，一旦外抛panic了，整个进程就认为出现异常，会终止进程。</p><p>这一点搞清楚了，再看Recovery为什么必备就很简单。在net/http处理业务逻辑的协程中，要捕获在自己这个协程中抛出的panic，就必须自己实现 Recovery 机制。</p><p>而Recovery中间件就是用来为每个协程增加Recovery机制的。我们在框架的middleware文件夹中增加recovery.go存放这个中间件：</p><pre><code class="language-go">// recovery机制，将协程中的函数异常进行捕获\nfunc Recovery() framework.ControllerHandler {\n\t// 使用函数回调\n\treturn func(c *framework.Context) error {\n\t\t// 核心在增加这个recover机制，捕获c.Next()出现的panic\n\t\tdefer func() {\n\t\t\tif err := recover(); err != nil {\n\t\t\t\tc.Json(500, err)\n\t\t\t}\n\t\t}()\n\t\t// 使用next执行具体的业务逻辑\n\t\tc.Next()\n\n\t\treturn nil\n\t}\n}\n</code></pre><p>这个中间件就是在context.Next() 之前设置了defer 函数，这个函数的作用就是捕获c.Next()中抛出的异常panic。之后在业务文件夹中的main.go，我们就可以通过Core结构的Use方法，对所有的路由都设置这个中间件。</p><pre><code class="language-go">core.Use(middleware.Recovery())\n</code></pre><p>今天所有代码的目录结构截图，我也贴在这里供你对比检查，代码放在GitHub上的 <a href="https://github.com/gohade/coredemo/tree/geekbang/04/framework">04分支</a>里。<br>\n<img src="https://static001.geekbang.org/resource/image/b8/yy/b8a053e4650ec9560754383d0f3974yy.png?wh=784x1274" alt=""></p><h2>小结</h2><p>今天我们最终为自己的框架增加了中间件机制。中间件机制的本质就是装饰器模型，对核心的逻辑函数进行装饰、封装，所以一开始我们就使用函数嵌套的方式实现了中间件机制。</p><p>但是实现之后，我们发现函数嵌套的弊端：一是不优雅，二是无法批量设置中间件。所以我们<strong>引入了pipeline的思想，将所有中间件做成一个链条，通过这个链条的调用，来实现中间件机制</strong>。</p><p>最后，我们选了最基础的Recovery中间件演示如何具体实现，一方面作为中间件机制的示例，另一方面，也在功能上为我们的框架增强了健壮性。</p><p>中间件机制是我们必须要掌握的机制，很多Web框架中都有这个逻辑。<strong>在架构层面，中间件机制就相当于，在每个请求的横切面统一注入了一个逻辑</strong>。这种统一处理的逻辑是非常有用的，比如统一打印日志、统一打点到统计系统、统一做权限登录验证等。</p><h2>思考题</h2><p>现在希望能对每个请求都进行请求时长统计，所以想写一个请求时长统计的中间件，在日志中输出请求 URI、请求耗时。不知道你如何实现呢？</p><p>欢迎在留言区分享你的思考。如果你觉得今天的内容对你有所帮助，也欢迎分享给你身边的朋友，邀请他一起学习～</p>',
        article_title: "04｜中间件：如何提高框架的可拓展性？",
      },
      {
        title: "05｜封装：如何让你的框架更好用？",
        id: 420009,
        content:
          '<p>你好，我是轩脉刃。</p><p>在前面几节课，我们实现了框架的路由、中间件等机制，并且自定义 context 结构来封装请求。但是回顾在对 context 的封装中，我们只是将 request、response 结构直接放入 context 结构体中，对应的方法并没有很好的封装。所以这节课，我们要做的事情就是为 context 封装更多的方法，让框架更好用。</p><p>在今天的学习中，希望你能认识到，函数封装并不是一件很简单、很随意的事情。相反，如何封装出易用、可读性高的函数是非常需要精心考量的，<strong>框架中每个函数的参数、返回值、命名，都代表着我们作为作者在某个事情上的思考</strong>。想要针对某个功能，封装出一系列比较完美的接口，更要我们从系统性的角度思考。</p><h2>思考如何封装请求和返回</h2><p>我们的目标是尽量在 context 这个数据结构中，封装“读取请求数据”和“封装返回数据”中的方法。在动手之前还是先做到心中有数，我们将请求和返回这两个事情分开思考。</p><ul>\n<li>读取请求数据</li>\n</ul><p>要读取请求数据包含哪些内容呢？第一讲我们提到过，HTTP 消息体分为两个部分：HTTP 头部和 HTTP Body 体。头部描述的一般是和业务无关但与传输相关的信息，比如请求地址、编码格式、缓存时长等；Body 里面主要描述的是与业务相关的信息。</p><!-- [[[read_end]]] --><p>所以针对请求数据的这两部分，我们应该设计不同的方法。</p><p>Header 信息中，包含 HTTP 的一些基础信息，比如请求地址、请求方法、请求 IP、请求域名、Cookie 信息等，是经常读取使用的，为了方便，我们需要一一提供封装。</p><p>而另外一些更细节的内容编码格式、缓存时长等，由于涉及的 HTTP 协议细节内容比较多，我们很难将每个细节都封装出来，但是它们都是以 key=value 的形式传递到服务端的，所以这里也考虑封装一个通用的方法。</p><p>Body 信息中，HTTP 是已经以某种形式封装好的，可能是 JSON 格式、XML 格式，也有可能是 Form 表单格式。其中 Form 表单注意一下，它可能包含 File 文件，请求参数和返回值肯定和其他的 Form 表单字段是不一样的，需要我们对其单独封装一个函数。</p><ul>\n<li>封装返回数据</li>\n</ul><p>封装返回数据，指的是将处理后的数据返回给浏览器。同样，它也分为两个部分，Header 头部和 Body 体。</p><p>Header 头部，我们经常要设置的是返回状态码和 Cookie，所以单独为其封装。其他的 Header 同样是 key=value 形式设置的，设置一个通用的方法即可。</p><p>返回数据的 Body 体是有不同形式的，比如 JSON、JSONP、XML、HTML或者其他文本格式，所以我们要针对不同的Body体形式，进行不同的封装。</p><p>一路分析下来，再列出这样一个思维导图就非常清晰了。<img src="https://static001.geekbang.org/resource/image/5d/3b/5d7b8554f7cbd074db00a62acdfe5a3b.jpg?wh=2038x2209" alt=""></p><h2>定义接口让封装更明确</h2><p>现在分析完需要封装哪些方法了，你已经迫不及待想开始进行封装函数的实现了吧。但是这里，我再给一个编码小建议：<strong>对于比较完整的功能模块，先定义接口，再具体实现</strong>。</p><p>首先，定义一个清晰的、包含若干个方法的接口，可以让使用者非常清楚：这个功能模块提供了哪些函数、哪些函数是我要的、哪些函数是我不要的，在用的时候，查找也更方便。如果你有过，在超过 20 个函数的结构体中，查找你需要的函数的惨痛经历，你就会觉得这一点尤为重要了。</p><p>其次，定义接口能做到“实现解耦”。使用接口作为参数、返回值，能够让使用者在写具体函数的时候，有不同的实现；而且在不同实现中，只需要做到接口一致，就能很简单进行替换，而不用修改使用方的任何代码。</p><p>好，明白这两点，我们再回到封装需求上，先定义两个接口：IRequest 和 IResponse，分别对应“读取请求数据”和“封装返回数据” 这两个功能模块。</p><p>我们分别在框架目录下创建request.go和response.go来存放这两个接口及其实现。</p><h3>IRequest接口定义</h3><p>读取请求数据 IRequest，我们定义的方法如下，在request.go中进行修改：</p><pre><code class="language-go">// 代表请求包含的方法\ntype IRequest interface {\n\t// 请求地址 url 中带的参数\n\t// 形如: foo.com?a=1&amp;b=bar&amp;c[]=bar\n\tQueryInt(key string, def int) (int, bool)\n\tQueryInt64(key string, def int64) (int64, bool)\n\tQueryFloat64(key string, def float64) (float64, bool)\n\tQueryFloat32(key string, def float32) (float32, bool)\n\tQueryBool(key string, def bool) (bool, bool)\n\tQueryString(key string, def string) (string, bool)\n\tQueryStringSlice(key string, def []string) ([]string, bool)\n\tQuery(key string) interface{}\n\n\t// 路由匹配中带的参数\n\t// 形如 /book/:id\n\tParamInt(key string, def int) (int, bool)\n\tParamInt64(key string, def int64) (int64, bool)\n\tParamFloat64(key string, def float64) (float64, bool)\n\tParamFloat32(key string, def float32) (float32, bool)\n\tParamBool(key string, def bool) (bool, bool)\n\tParamString(key string, def string) (string, bool)\n\tParam(key string) interface{}\n\n\t// form 表单中带的参数\n\tFormInt(key string, def int) (int, bool)\n\tFormInt64(key string, def int64) (int64, bool)\n\tFormFloat64(key string, def float64) (float64, bool)\n\tFormFloat32(key string, def float32) (float32, bool)\n\tFormBool(key string, def bool) (bool, bool)\n\tFormString(key string, def string) (string, bool)\n\tFormStringSlice(key string, def []string) ([]string, bool)\n\tFormFile(key string) (*multipart.FileHeader, error)\n\tForm(key string) interface{}\n\n\t// json body\n\tBindJson(obj interface{}) error\n\n\t// xml body\n\tBindXml(obj interface{}) error\n\n\t// 其他格式\n\tGetRawData() ([]byte, error)\n\n\t// 基础信息\n\tUri() string\n\tMethod() string\n\tHost() string\n\tClientIp() string\n\n\t// header\n\tHeaders() map[string][]string\n\tHeader(key string) (string, bool)\n\n\t// cookie\n\tCookies() map[string]string\n\tCookie(key string) (string, bool)\n}\n</code></pre><p>简单说明一下，我们使用了 QueryXXX 的系列方法来代表从 URL 的参数后缀中获取的参数；使用 ParamXXX 的系列方法来代表从路由匹配中获取的参数；使用 FormXXX 的系列方法来代表从 Body 的 form 表单中获取的参数。</p><p>不知道你发现了没有，<strong>这三个系列的方法，我们统一了参数和返回值</strong>。</p><ul>\n<li>参数一般都有两个：一个是 key，代表从参数列表中查找参数的关键词；另外一个是 def，代表如果查找不到关键词，会使用哪个默认值进行返回。</li>\n<li>返回值返回两个：一个代表对应 key 的匹配值，而另一个 bool 返回值代表是否有这个返回值。</li>\n</ul><p>这样的设计，在获取参数的时候，能让需要处理的两个逻辑，默认参数和是否有参数，都得到很好的处理；同时对于 JSON 格式、XML 格式的 Body 结构读取，也提供了对应的方法。</p><p>对基础信息，我们提供了 URI、Method、Host、ClinetIp 等方法；对 Header 头，我们提供根据 key 获取 Header 值的通用方法；同时，也对 Cookie 单独提供了批量获取 Cookie 和按照关键词获取 Cookie 的两个方法。</p><p>这些都对应我们第一部分分析的思维导图中“读取请求数据”部分。</p><h3>IResponse接口定义</h3><p>对于封装返回数据 IResponse，我们在response.go中定义的方法如下：</p><pre><code class="language-go">// IResponse 代表返回方法\ntype IResponse interface {\n\t// Json 输出\n\tJson(obj interface{}) IResponse\n\n\t// Jsonp 输出\n\tJsonp(obj interface{}) IResponse\n\n\t//xml 输出\n\tXml(obj interface{}) IResponse\n\n\t// html 输出\n\tHtml(template string, obj interface{}) IResponse\n\n\t// string\n\tText(format string, values ...interface{}) IResponse\n\n\t// 重定向\n\tRedirect(path string) IResponse\n\n\t// header\n\tSetHeader(key string, val string) IResponse\n\n\t// Cookie\n\tSetCookie(key string, val string, maxAge int, path, domain string, secure, httpOnly bool) IResponse\n\n\t// 设置状态码\n\tSetStatus(code int) IResponse\n\n\t// 设置 200 状态\n\tSetOkStatus() IResponse\n}\n</code></pre><p>对于 Header 部分，我们设计了状态码的设置函数 SetStatus/SetOkStatus/Redirect，还设计了 Cookie 的设置函数 SetCookie，同时，我们提供了通用的设置 Header 的函数 SetHeader。</p><p>对于 Body 部分，我们设计了 JSON、JSONP、XML、HTML、Text 等方法来输出不同格式的 Body。</p><p>这里注意下，<strong>很多方法的返回值使用 IResponse 接口本身， 这个设计能允许使用方进行链式调用</strong>。链式调用的好处是，能很大提升代码的阅读性，比如在业务逻辑代码controller.go里这个调用方法：</p><pre><code class="language-plain">c.SetOkStatus().Json("ok, UserLoginController: " + foo)\n</code></pre><p>就能很好地阅读：“返回成功，并且输出 JSON 字符串”。这种通过返回值返回接口本身的小技巧，我们后面会经常用到。</p><h2>实现具体的接口</h2><p>接下来，我们需要实现这两个接口，直接将 Context 这个数据结构，实现这两个接口定义的方法就行了。<strong>因为在 Golang 中，只要包含了接口所带的函数就是实现了接口，并不需要显式标记继承</strong>。</p><p>由于这些接口有的比较重复，所以这里只解说几个重点的实现，具体可以参考 <a href="https://github.com/gohade/coredemo/tree/geekbang/05">GitHub 仓库</a>。</p><h2>请求相关接口实现</h2><p>我们先将注意力专注在 Request 请求相关的方法上，首先处理刚才在request.go中定义的 Query 相关的参数请求方法。</p><pre><code class="language-go">    // 请求地址 url 中带的参数\n\t// 形如: foo.com?a=1&amp;b=bar&amp;c[]=bar\n\tQueryInt(key string, def int) (int, bool)\n\tQueryInt64(key string, def int64) (int64, bool)\n\tQueryFloat64(key string, def float64) (float64, bool)\n\tQueryFloat32(key string, def float32) (float32, bool)\n\tQueryBool(key string, def bool) (bool, bool)\n\tQueryString(key string, def string) (string, bool)\n\tQueryStringSlice(key string, def []string) ([]string, bool)\n\tQuery(key string) interface{}\n</code></pre><p>如何获取请求参数呢，我们可以从 http.Request 结构中，通过 Query 方法，获取到请求 URL 中的参数。</p><h3>Query 请求方法实现</h3><p>所以，在request.go中，我们先创建一个 QueryAll() 方法。</p><pre><code class="language-go">// 获取请求地址中所有参数\nfunc (ctx *Context) QueryAll() map[string][]string {\n\tif ctx.request != nil {\n\t\treturn map[string][]string(ctx.request.URL.Query())\n\t}\n\treturn map[string][]string{}\n}\n</code></pre><p>接着要做的，就是将这个 QueryAll 查询出来的 map 结构根据 key 查询，并且转换为其他类型的数据结构，比如 Int、Int64、Float64、Float32 等。</p><p>这里我推荐一个<a href="https://github.com/spf13/cast">第三方库cast</a>，这个库实现了多种常见类型之间的相互转换，返回最符合直觉的结果，通过<a href="https://pkg.go.dev/">这个网站</a>可以查看其提供的所有方法，这里展示部分你可以看看：</p><pre><code class="language-go">...\nfunc ToUint(i interface{}) uint\nfunc ToUint16(i interface{}) uint16\nfunc ToUint16E(i interface{}) (uint16, error)\nfunc ToUint32(i interface{}) uint32\nfunc ToUint32E(i interface{}) (uint32, error)\nfunc ToUint64(i interface{}) uint64\nfunc ToUint64E(i interface{}) (uint64, error)\nfunc ToUint8(i interface{}) uint8\nfunc ToUint8E(i interface{}) (uint8, error)\nfunc ToUintE(i interface{}) (uint, error)\n...\n</code></pre><p>归纳起来，cast 提供类型转换方法，参数可以是任意类型，转换为对应的目标类型，每种转换会提供两组方法，一组是带 error 返回值的方法，一组是不带 error 返回值的。如果使用 cast 库，我们将request.go中 QueryXXX 方式的实现修改一下：</p><pre><code class="language-go">// 获取 Int 类型的请求参数\nfunc (ctx *Context) QueryInt(key string, def int) (int, bool) {\n\tparams := ctx.QueryAll()\n\tif vals, ok := params[key]; ok {\n\t\tif len(vals) &gt; 0 {\n\t\t\t// 使用 cast 库将 string 转换为 Int\n\t\t\treturn cast.ToInt(vals[0]), true\n\t\t}\n\t}\n\treturn def, false\n}\n</code></pre><p>QueryAll返回一个map结构，根据key查找出对应的参数值，并且通过cast库将对应的参数值转化成目标数据结构。</p><p>Query 的参数请求方法就实现完成了。<strong>Form 表单相关的请求方法是从 HTTP Body 中获取参数，同 Query 方法相类似，我们就不再重复</strong>，简单说下思路：可以从 http.Request 中获取到 Form 的请求参数，然后再用 cast 库进行类型转换。</p><h3>Param 请求方法实现</h3><p>接下来，我们需要实现 Param 相关的请求方法。</p><p>Param 的请求方法是：通过路由解析请求地址，抽取请求地址中包含通配符的段。比如路由规则为 /subject/:id，真实请求 URI 为 /subject/1，那么获取 key 为 id 的 Param 值就为 1。</p><p>怎么实现我们得回顾第三节课讲的路由，用 trie 树实现了路由规则。当请求进入的时候，将请求的 URI 地址根据分隔符分成不同的段，用这个段去匹配 trie 树。只有当每个段都匹配 trie 树中某个路径的时候，我们才将路径终止节点里的 Handlers ，作为这个请求的最终处理函数。<br>\n<img src="https://static001.geekbang.org/resource/image/68/98/6837822864392bbb5e7345518448b098.jpg?wh=1920x1080" alt=""></p><p>而在这个匹配路径中，有的节点是根据通配符进行匹配的，这些节点就是我们要查找的 Param 参数。</p><p>现在就要获取路由解析过程中的这些通配符参数，<strong>最朴素的想法就是：查找出这个匹配路径，然后查找出其中的通配符节点，再和请求 URI 对应，获取这些通配符参数</strong>。我们看这个想法如何实现。</p><p>之前查找路由的时候，查到的是匹配路径的最终节点，如何追溯到整个匹配路径呢？这里我们可以考虑构造一个双向链表：改造 node 节点，增加一个 parent 指针，指向父节点，将 trie 树变成一个双向指针。来修改框架目录中的trie.go：</p><pre><code class="language-go">// 代表节点\ntype node struct {\n\t...\n\tparent&nbsp; &nbsp;*node&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;// 父节点，双向指针\n}\n</code></pre><p>在增加路由规则（AddRouter）的时候，创建子节点也要同时修改这个 parent 指针，继续写：</p><pre><code class="language-go">func (tree *Tree) AddRouter(uri string, handlers []ControllerHandler) error {\n\t...\n\t// 对每个 segment\n\tfor index, segment := range segments {\n\n\t\t...\n\t\tif objNode == nil {\n\t\t\t// 创建一个当前 node 的节点\n\t\t\tcnode := newNode()\n\t\t\tcnode.segment = segment\n\t\t\tif isLast {\n\t\t\t\tcnode.isLast = true\n\t\t\t\tcnode.handlers = handlers\n\t\t\t}\n\t\t\t// 父节点指针修改\n\t\t\tcnode.parent = n\n\t\t\tn.childs = append(n.childs, cnode)\n\t\t\tobjNode = cnode\n\t\t}\n\n\t\tn = objNode\n\t}\n\n\treturn nil\n}\n</code></pre><p>这样，双向链表就修改完了。接着就根据最终匹配的节点和请求 URI，查找出整个匹配链路中的通配符节点和对应 URI 中的分段，还是在trie.go里继续写：</p><pre><code class="language-go">// 将 uri 解析为 params\nfunc (n *node) parseParamsFromEndNode(uri string) map[string]string {\n\tret := map[string]string{}\n\tsegments := strings.Split(uri, "/")\n\tcnt := len(segments)\n\tcur := n\n\tfor i := cnt - 1; i &gt;= 0; i-- {\n\t\tif cur.segment == "" {\n\t\t\tbreak\n\t\t}\n\t\t// 如果是通配符节点\n\t\tif isWildSegment(cur.segment) {\n\t\t\t// 设置 params\n\t\t\tret[cur.segment[1:]] = segments[i]\n\t\t}\n\t\tcur = cur.parent\n\t}\n\treturn ret\n}\n</code></pre><p>接下来，为了让 context 中有 map 结构的路由参数，我们将解析出来的 params 存储到 context 结构中。这里修改框架目录中的core.go文件：</p><pre><code class="language-go">// 所有请求都进入这个函数, 这个函数负责路由分发\nfunc (c *Core) ServeHTTP(response http.ResponseWriter, request *http.Request) {\n\n\t// 封装自定义 context\n\tctx := NewContext(request, response)\n\n\t// 寻找路由\n\tnode := c.FindRouteNodeByRequest(request)\n\t...\n\n\t// 设置路由参数\n\tparams := node.parseParamsFromEndNode(request.URL.Path)\n\tctx.SetParams(params)\n\n\t...\n}\n</code></pre><p>最后，回到框架目录的request.go，我们还是使用 cast 库来将这个 Param 系列方法完成：</p><pre><code class="language-go">// 获取路由参数\nfunc (ctx *Context) Param(key string) interface{} {\n\tif ctx.params != nil {\n\t\tif val, ok := ctx.params[key]; ok {\n\t\t\treturn val\n\t\t}\n\t}\n\treturn nil\n}\n\n// 路由匹配中带的参数\n// 形如 /book/:id\nfunc (ctx *Context) ParamInt(key string, def int) (int, bool) {\n\tif val := ctx.Param(key); val != nil {\n\t\t// 通过 cast 进行类型转换\n\t\treturn cast.ToInt(val), true\n\t}\n\treturn def, false\n}\n</code></pre><h3>Bind 请求方法实现</h3><p>到这里，ParamXXX系列函数就完成了，接下来我们看下 BindXXX 系列函数，比如 BindJson。它的实现只需要简单2步：读取 Body 中的文本、解析 body 文本到结构体。所以修改response.go中的函数：</p><pre><code class="language-go">// 将 body 文本解析到 obj 结构体中\nfunc (ctx *Context) BindJson(obj interface{}) error {\n\tif ctx.request != nil {\n\t\t// 读取文本\n\t\tbody, err := ioutil.ReadAll(ctx.request.Body)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t// 重新填充 request.Body，为后续的逻辑二次读取做准备\n\t\tctx.request.Body = ioutil.NopCloser(bytes.NewBuffer(body))\n\n\t\t// 解析到 obj 结构体中\n\t\terr = json.Unmarshal(body, obj)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t} else {\n\t\treturn errors.New("ctx.request empty")\n\t}\n\treturn nil\n}\n</code></pre><p>读取 Body 中的文本，我们使用 ioutil.ReadAll 方法，解析 Body 文本到结构体中，我们使用 json.Unmarshal 方法。</p><p>这里要注意，<strong>request.Body 的读取是一次性的</strong>，读取一次之后，下个逻辑再去 request.Body 中是读取不到数据内容的。所以我们读取完 request.Body 之后，还要再复制一份 Body 内容，填充到 request.Body 里。</p><h2>返回相关接口实现</h2><p>返回接口中的 JSON、XML、TEXT 的输出是比较简单的，将输出数据结构进行序列化就行，这里我们重点讲比较复杂的两种实现 JSONP 输出和 HTML 输出。</p><h3>JSONP 输出方法实现</h3><p>JSONP 是一种我们常用的解决跨域资源共享的方法，简要介绍下这个方法的原理。</p><p>在 JavaScript 中使用 HTTP 请求（Ajax）会受到同源策略的限制。比如说 A 网站的页面不能在 JavaScript 中跨域访问 B 网站的资源。但是，如果我们希望能跨域访问怎么办？</p><p>我们知道 HTML 中标签&lt;script&gt;中的请求是不受同源策略影响的，<strong>那如果能将B网站的资源数据，通过script标签返回来，是不是就直接解决了跨域问题</strong>？确实，JSONP就是这么设计的，通过script标签的源地址，返回数据资源+ JavaScript代码。</p><p>比如 A 网站的网页如下，它希望从 B 网站中获取数据，填充进 id 为"context"的 div 标签中。</p><pre><code class="language-xml">&lt;html&gt;\n  &lt;body&gt;\n    &lt;div id="context"&gt;&lt;/div&gt;\n  &lt;/body&gt;\n&lt;/html&gt;\n\n&lt;script&gt;\n  function callfun(data) {\n     document.getElementById(\'context\').innerHTML = data;\n  }\n&lt;/script&gt;\n\n&lt;script src="http://B.com/jsonp?callback=callfun"&gt;&lt;/script&gt;\n</code></pre><p>使用 ajax 请求的时候，我们是做不到这一点的，因为同源策略限制了网页和数据必须在同一个源下。但是如果 B 网站的接口支持了 JSONP，它能根据请求参数返回一段 JavaScript 代码，类似：</p><pre><code class="language-plain">callfunc({"id":1, "name": jianfengye})\n</code></pre><p>这时 A 网站的网页，就能直接调用 callfunc 方法，并且获取到 B 网站返回的数据。</p><p>了解了 JSONP 的原理，我们回到服务端实现 JSONP 的方法中。这个方法要做的事情就是：<strong>获取请求中的参数作为函数名，获取要返回的数据 JSON 作为函数参数，将函数名+函数参数作为返回文本</strong>。</p><p>我们在response.go中补充Jsonp方法。</p><pre><code class="language-go">// Jsonp 输出\nfunc (ctx *Context) Jsonp(obj interface{}) IResponse {\n\t// 获取请求参数 callback\n\tcallbackFunc, _ := ctx.QueryString("callback", "callback_function")\n\tctx.SetHeader("Content-Type", "application/javascript")\n\t// 输出到前端页面的时候需要注意下进行字符过滤，否则有可能造成 XSS 攻击\n\tcallback := template.JSEscapeString(callbackFunc)\n\n\t// 输出函数名\n\t_, err := ctx.responseWriter.Write([]byte(callback))\n\tif err != nil {\n\t\treturn ctx\n\t}\n\t// 输出左括号\n\t_, err = ctx.responseWriter.Write([]byte("("))\n\tif err != nil {\n\t\treturn ctx\n\t}\n\t// 数据函数参数\n\tret, err := json.Marshal(obj)\n\tif err != nil {\n\t\treturn ctx\n\t}\n\t_, err = ctx.responseWriter.Write(ret)\n\tif err != nil {\n\t\treturn ctx\n\t}\n\t// 输出右括号\n\t_, err = ctx.responseWriter.Write([]byte(")"))\n\tif err != nil {\n\t\treturn ctx\n\t}\n\treturn ctx\n}\n</code></pre><h3>HTML 输出方法实现</h3><p>接下来我们分析下 HTML 输出。</p><p>HTML 函数输出的就是一个纯 HTML 页面。现在的 HTML 页面，基本都是动态页面，也就是说页面基本内容都是一样，但是根据不同请求、不同逻辑，页面中的数据部分是不同的。所以，我们在输出 HTML 页面内容的时候，常用“模版+数据”的方式。</p><p>模版中存放的是页面基本内容，包括布局信息（CSS）、通用脚本（JavaScript）、页面整体结构（HTML）。但是页面结构中，某个标签的具体内容、具体数值，就表示成数据，在模版中保留数据的位置，在最终渲染 HTML 内容的时候，把数据填充进入模版就行了。</p><p>在 Golang 中，这种“模版+数据”的文本渲染方式是有一个官方库来实现的 <a href="https://golang.org/pkg/html/template/">html/template</a> ，它的模版使用{{.XX}} 作为数据的占位符，表示传入的数据结构的某个字段：</p><pre><code class="language-go">&lt;h1&gt;{{.PageTitle}}&lt;/h1&gt;\n&lt;ul&gt;\n    {{range .Todos}}\n        {{if .Done}}\n            &lt;li class="done"&gt;{{.Title}}&lt;/li&gt;\n        {{else}}\n            &lt;li&gt;{{.Title}}&lt;/li&gt;\n        {{end}}\n    {{end}}\n&lt;/ul&gt;\n</code></pre><p>传入的数据结构为：</p><pre><code class="language-go">data := TodoPageData{\n    PageTitle: "My TODO list",\n    Todos: []Todo{\n        {Title: "Task 1", Done: false},\n        {Title: "Task 2", Done: true},\n        {Title: "Task 3", Done: true},\n    },\n}\n</code></pre><p>所以具体的渲染可以分成两步：<strong>先根据模版创造出 template 结构；再使用 template.Execute 将传入数据和模版结合</strong>。</p><p>我们的 HTML 函数可以使用 html/template，修改框架目录response.go中的Html方法：</p><pre><code class="language-go">// html 输出\nfunc (ctx *Context) Html(file string, obj interface{}) IResponse {\n\t// 读取模版文件，创建 template 实例\n\tt, err := template.New("output").ParseFiles(file)\n\tif err != nil {\n\t\treturn ctx\n\t}\n\t// 执行 Execute 方法将 obj 和模版进行结合\n\tif err := t.Execute(ctx.responseWriter, obj); err != nil {\n\t\treturn ctx\n\t}\n\n\tctx.SetHeader("Content-Type", "application/html")\n\treturn ctx\n}\n\n</code></pre><p>参数为模版文件和输出对象，先使用 ParseFiles 来读取模版文件，创建一个 template 数据结构，然后使用 Execute 方法，将数据对象和模版进行结合，并且输出到 responseWriter 中。</p><p>这节课的代码结构放在这里了，完整的代码在GitHub上的<a href="https://github.com/gohade/coredemo/tree/geekbang/05">geekbang/05</a>分支上。<br>\n<img src="https://static001.geekbang.org/resource/image/f3/37/f352fyyb3443eeed2ce318859638bb37.png?wh=746x1398" alt=""></p><h2>小结</h2><p>我们这节课在 context 这个数据结构中，封装和实现“读取请求数据”和“封装返回数据”的方法。首先系统思考这两个需求功能的封装；再设计IRequest和IResponse两个接口，定义了对应的方法，并且让context实现这两个接口；最后，我们对这两个接口的方法进行了具体实现。</p><p>你现在是不是认识到了，为什么我在开头会说，函数封装并不是一件很简单、很随意的事情，如何封装出易用、可读性高的函数是需要我们精心考量的。</p><p>如果说一定要记住一句话，希望你能记住，在实现“读取请求数据”和“封装返回数据”的过程中，采用“<strong>先系统设计，再定义接口，最后具体实现</strong>”的系统思考方法。如果你一接到要开发某些功能模块需求，不先想清楚就立刻上手，最终实现的代码，细节会非常混乱，复用性极差。</p><p>请记住，设计永远优于实现！</p><h2>思考题</h2><p>作为一个Web框架，安全性是很关键的一个环节，我们在实现JSONP方法的时候，有这一行代码：</p><pre><code class="language-go">//输出到前端页面的时候需要注意下进行字符过滤，否则有可能造成 XSS 攻击\ncallback := template.JSEscapeString(callbackFunc)\n</code></pre><p>请你思考下，如果我直接将callbackFunc输出到页面上，会有什么不安全的问题吗？什么是XSS攻击？</p><p>欢迎在留言区分享你的思考。感谢你的收听，如果你觉得今天的内容对你有所帮助，也欢迎分享给你身边的朋友，邀请他一起学习。下节课见～</p>',
        article_title: "05｜封装：如何让你的框架更好用？",
      },
      {
        title: "06｜重启：如何进行优雅关闭？",
        id: 421354,
        content:
          '<p>你好，我是轩脉刃。</p><p>通过前面几节课的学习，我们已经能启动一个按照路由规则接收请求、进入控制器计算逻辑的服务器了。</p><p>但是，在实际业务开发过程中，功能和需求一定是不断迭代的，在迭代过程中，势必需要重启服务，这里的重启就是指一个关闭、启动进程的完成过程。</p><p>目前所有服务基本都无单点问题，都是集群化部署。对一个服务的关闭、启动进程来说，启动的流程基本上问题不大，可以由集群的统一管理器，比如Kubernetes，来进行服务的启动，启动之后慢慢将流量引入到新启动的节点，整个服务是无损的。</p><p>但是在关闭服务的过程中，要考虑的情况就比较复杂了，比如说有服务已经在连接请求中怎么办？如果关闭服务的操作超时了怎么办？所以这节课我们就来研究下如何优雅关闭一个服务。</p><h2>如何优雅关闭</h2><p>什么叫优雅关闭？你可以对比着想，不优雅的关闭比较简单，就是什么都不管，强制关闭进程，这明显会导致有些连接被迫中断。</p><p>或许你并没有意识到这个问题的严重性，不妨试想下，当一个用户在购买产品的时候，由于不优雅关闭，请求进程中断，导致用户的钱包已经扣费了，但是商品还未进入用户的已购清单中。这就会给用户带来实质性的损失。</p><p>所以，优雅关闭服务，其实说的就是，关闭进程的时候，不能暴力关闭进程，而是要等进程中的所有请求都逻辑处理结束后，才关闭进程。按照这个思路，需要研究两个问题“<strong>如何控制关闭进程的操作</strong>” 和 “<strong>如何等待所有逻辑都处理结束</strong>”。</p><!-- [[[read_end]]] --><p>当我们了解了如何控制进程关闭操作，就可以延迟关闭进程行为，设置为等连接的逻辑都处理结束后，再关闭进程。</p><h3>如何控制关闭进程的操作</h3><p>那么第一个问题，如何控制关闭进程的操作怎么解决？你可以先想想平时关闭一个进程的方法有哪些，如果这些方法都有办法控制关闭操作，那么是不是就达到目的了。</p><ul>\n<li>Ctrl+C</li>\n</ul><p>在终端，在非后台模式下启动一个进程的时候，要想关闭，我们在控制台会使用 Ctrl+C 来关闭进程。不管在 Unix 类的系统，还是在 Windows 系统中，Ctrl+C 都是向进程发送信号 SIGINT，这个信号代表的是中断，常用在通过键盘通知前台进程关闭程序的情景中。这个信号是可以被阻塞和处理的。</p><ul>\n<li>Ctrl+\\</li>\n</ul><p>这个键盘操作是向进程发送信号 SIGQUIT，这个信号其实和 SIGINT 差不多，也是可以被阻塞和处理的，它们都是为了通知进程结束，唯一不同的是，进程处理 QUIT 退出的时候，默认行为会产生 core 文件。</p><ul>\n<li>Kill 命令</li>\n</ul><p>当使用后台模式挂起一个进程的时候，操作系统会给这个进程分配一个进程号 pid， 我们可以通过 kill pid 或者 kill -9 pid 来杀死某个进程。</p><p>kill pid 会向进程发送 SIGTERM 信号，而 kill -9 会向进程发送 SIGKILL 信号。这两个信号都用于立刻结束进程，但是 SIGTERM 是可以被阻塞和处理的，而 SIGKILL 信号是不能被阻塞和处理的。</p><p>用表格总结一下终止进程的这几个信号和对应的操作：<img src="https://static001.geekbang.org/resource/image/ff/eb/ff73733e54b5f94a3cbe6af2b3cc94eb.jpg?wh=1920x1080" alt=""></p><p>除了 SIGKILL 信号无法被捕获之外，其他的信号都能捕获，所以，只要在程序中捕获住这些信号，就能实现控制关闭进程操作了。那么接下来要解决的问题就是，在 Golang 中如何捕获信号呢？</p><p>对于这个问题，标准库提供了 os/signal 这个库，还记得第一节课说的快速了解一个库的方法么，<strong>库函数 &gt; 结构定义 &gt; 结构函数。</strong></p><h3>os/signal 库</h3><p>所以，第一步我们使用  <code>go doc os/signal|grep "^func"</code> 来了解下这个库的函数，看看提供了哪些功能。</p><pre><code class="language-go">// 忽略某个信号\nfunc Ignore(sig ...os.Signal){}\n// 判断某个信号是否被忽略了\nfunc Ignored(sig os.Signal) bool{}\n// 关注某个/某些/全部 信号\nfunc Notify(c chan&lt;- os.Signal, sig ...os.Signal){}\n// 取消使用 notify 对信号产生的效果\nfunc Reset(sig ...os.Signal){}\n// 停止所有向 channel 发送的效果\nfunc Stop(c chan&lt;- os.Signal){}\n</code></pre><p>这个库提供了订阅信号的方法 Notify 和忽略信号的方法 Ignore ，为了全局管理方便，也提供了停止所有订阅的 Stop 函数。另外还有，停止某些订阅的 Reset 函数，当我们已经订阅了某些信号之后，想重新将其中的某些信号不进行订阅，那么可以使用Reset方法。</p><p>然后就是第二、第三步，通过  <code>go doc os/signal|grep "^type"</code> 了解到，这个库比较简单，没有任何结构定义和结构函数，因为管理信号只需要几个库函数即可，不需要进行更多的模块划分和数据结构抽象。在Golang的官方类库中，有不少都是这样只提供库函数，而没有自定义的模块数据结构的。</p><p>理解完了捕获信号的 os/signal 库，我们就明白了，要控制这些信号量可以使用 Notify 方法，所以在业务main.go里补充：</p><pre><code class="language-go">func main() {\n\t...\n\t// 这个 Goroutine 是启动服务的 Goroutine\n\tgo func() {\n\t\tserver.ListenAndServe()\n\t}()\n\n\t// 当前的 Goroutine 等待信号量\n\tquit := make(chan os.Signal)\n\t// 监控信号：SIGINT, SIGTERM, SIGQUIT\n\tsignal.Notify(quit, syscall.SIGINT, syscall.SIGTERM, syscall.SIGQUIT)\n\t// 这里会阻塞当前 Goroutine 等待信号\n\t&lt;-quit\n\n\t...\n}\n</code></pre><p>注意下这里有两个 Goroutine，一个 Goroutine 是提供启动服务的，另外一个 Goroutine 用于监听信号并且结束进程。那么哪个Goroutine用于监听信号呢？</p><p>答案是main 函数所在的当前 Goroutine。因为使用Ctrl或者kill命令，它们发送的信号是进入main函数的，即只有main函数所在的Goroutine会接收到，<strong>所以必须在main函数所在的Goroutine监听信号</strong>。</p><p>在监听信号的 Goroutine 中，我们先创建了一个等待信号量的 channel，然后通过 Notify 方法，订阅 SIGINT、SIGTERM、SIGQUIT 三个可以捕获处理的信号量，并且将信号量导入到 channel 中。</p><p>最后，使用 channel 的导出操作，来阻塞当前 Goroutine，让当前 Goroutine 只有捕获到结束进程的信号之后，才进行后续的关闭操作。这样就实现了第一个问题进程关闭的可控。</p><h2>如何等待所有逻辑都处理结束</h2><p>然后就是第二个问题“如何等待所有逻辑都处理结束”。</p><p>在 Golang 1.8 版本之前，net/http 是没有提供方法的，所以当时开源社区涌现了不少第三方解决方案： <a href="https://github.com/braintree/manners">manners</a> 、 <a href="https://github.com/tylerstillwater/graceful">graceful</a> 、 <a href="https://github.com/facebookarchive/grace">grace</a> 。</p><p>它们的思路都差不多：自定义一个Server数据结构，其中包含net/http的Server数据结构，以及和net/http中Server一样的启动服务函数，在这个函数中，除了调用启动服务，还设计了一个监听事件的函数。监听事件结束后，通过channel等机制来等待主流程结束。</p><p>而在1.8版本之后，net/http引入了server.Shutdown来进行优雅重启。</p><p><strong>server.Shutdown方法是个阻塞方法，</strong><strong>一旦执行之后，它会阻塞当前 Goroutine，并且在所有连接请求都结束之后，才继续往后执行</strong>。实现非常容易，思路也和之前的第三方解法差不多，所以就重点理解这个方法。</p><h3>server.Shutdown源码</h3><p>来看server.Shutdown的源码，同样你可以通过IDE跳转工具直接跳转到Shutdown源码进行阅读，使用第一节课教的思维导图的方式，列出Shutdown函数的代码逻辑流程图。我们还是从前往后讲。<br>\n<img src="https://static001.geekbang.org/resource/image/5a/83/5ab0b74f880bed2273490c71b4d44783.png?wh=1454x303" alt=""></p><p>第一层，在运行Shutdown方法的时候，先做一个标记，将server中的isShutdown标记为true。</p><pre><code class="language-go">srv.inShutdown.setTrue()\n\nfunc (b *atomicBool) setTrue()&nbsp; &nbsp; { atomic.StoreInt32((*int32)(b), 1)&nbsp;\n</code></pre><p>这里标准库实现的就很细节了。inShutdown是一个标记，它用来标记服务器是否正在关闭，<strong>标记的时候，还使用了 atomic 操作来保证标记的原子性</strong>。这里要琢磨一下，为什么要使用atomic操作呢？</p><p>在Golang中，所有的赋值操作都不能保证是原子的，比如int类型的a=a+1，或者bool类型的a=true，这些赋值操作，在底层并不一定是由一个独立的CPU指令完成的。所以在并发场景下，我们并不能保证并发赋值的操作是安全的。</p><p>比如有两个操作同时对a变量进行读写，写a变量的线程如果不是原子的，那么读a变量的线程就有可能读到写了一半的a变量。</p><p>所以为保证原子性，Golang提供了一个atomic包，当对一个字段赋值的时候，<strong>如果你无法保证其是否原子操作，你可以使用atomic包来对这个字段进行赋值</strong>。atomic包，在底层一定会保证，这个操作是在一个单独的CPU指令内完成的。</p><p>因为这里的srv.inShutdown是一个非常重要的标记位。一旦由于任何原因，它读取错误，会发生严重问题，比如进程已经在处理结束的时候，启动server的进程还继续监听请求，这个时候会导致新接收的请求有服务错误。所以，这里为了保险起见，使用了一个标准库atomic来保证其原子性操作。</p><p>然后是逻辑代码：</p><pre><code class="language-go">for _, f := range srv.onShutdown {\n  go f()\n}\n</code></pre><p>onShutdown在server结构中按需求设置。这个字段保存的是回调方法，即用户希望server在关闭时进行的回调操作。比如用户可以设置在服务结束的时候，打印一个日志或者调用一个通知机制。如果用户设置了回调，则执行这些回调条件，如果没有设置，可以忽略。</p><h3>for循环</h3><p>接下来进入这一层最重要的for循环。这个for循环是一个无限循环，它使用ticker来控制每次循环的节奏，通过return来控制循环的终止条件。这个写法很值得我们学习。</p><pre><code class="language-go">ticker := time.NewTicker(shutdownPollInterval) // 设置轮询时间\n\tdefer ticker.Stop()\n\tfor {\n        // 真正的操作\n\t\tif srv.closeIdleConns() &amp;&amp; srv.numListeners() == 0 {\n\t\t\treturn lnerr\n\t\t}\n\t\tselect {\n\t\tcase &lt;-ctx.Done(): // 如果ctx有设置超时，有可能触发超时结束\n\t\t\treturn ctx.Err()\n\t\tcase &lt;-ticker.C:&nbsp; // 如果没有结束，最长等待时间，进行轮询\n\t\t}\n\t}\n</code></pre><p>我们在工作中经常会遇到类似的需求：每隔多少时间，执行一次操作，应该有不少同学会使用time.Sleep来做间隔时长，而这里演示了如何使用time.Ticker来进行轮询设置。这两种方式其实都能完成“每隔多少时间做一次操作”，但是又有一些不同。</p><p>time.Sleep是用阻塞当前Goroutine的方式来实现的，它需要调度先唤醒当前Goroutine，才能唤醒后续的逻辑。<strong>而Ticker创建了一个底层数据结构定时器runtimeTimer，并且监听runtimeTimer计时结束后产生的信号</strong>。</p><p>这个runtimeTimer是Golang定义的定时器，做了一些比较复杂的优化。比如在有海量定时器的场景下，runtimeTimer会为每个核，创建一个runtimeTimer，进行统一调度，所以它的CPU消耗会远低于time.Sleep。所以说，使用ticker是Golang中最优的定时写法。<br>\n<img src="https://static001.geekbang.org/resource/image/07/18/07db466da8f4da1de087b7b9995d5318.png?wh=1454x182" alt=""></p><p>再回到源码思维导图中，可以看到真正执行操作的是 closeIdleConns 方法。这个方法的逻辑就是：判断所有连接中的请求是否已经完成操作（是否处于Idle状态），如果完成，关闭连接，如果未完成，则跳过，等待下次循环。</p><pre><code class="language-go">// closeIdleConns 关闭所有的连接并且记录是否服务器的连接已经全部关闭\nfunc (s *Server) closeIdleConns() bool {\n\ts.mu.Lock()\n\tdefer s.mu.Unlock()\n\tquiescent := true\n\tfor c := range s.activeConn {\n\t\tst, unixSec := c.getState()\n\t\t// Issue 22682: 这里预留5s以防止在第一次读取连接头部信息的时候超过5s\n\t\tif st == StateNew &amp;&amp; unixSec &lt; time.Now().Unix()-5 {\n\t\t\tst = StateIdle\n\t\t}\n\t\tif st != StateIdle || unixSec == 0 {\n\t\t\t// unixSec == 0 代表这个连接是非常新的连接，则标记位需要标记false\n\t\t\tquiescent = false\n\t\t\tcontinue\n\t\t}\n\t\tc.rwc.Close()\n\t\tdelete(s.activeConn, c)\n\t}\n\treturn quiescent\n}\n</code></pre><p>这个函数返回的quiescent标记位，是用来标记是否所有的连接都已经关闭。如果有一个连接还未关闭，标记位返回false，否则返回true。</p><p>现在源码就梳理好了，再整理一下。</p><p>为了实现先阻塞，然后等所有连接处理完再结束退出，Shutdown 使用了两层循环。其中：</p><ul>\n<li>第一层循环是定时无限循环，每过ticker的间隔时间，就进入第二层循环；</li>\n<li>第二层循环会遍历连接中的所有请求，如果已经处理完操作处于Idle状态，就关闭连接，直到所有连接都关闭，才返回。</li>\n</ul><p>所以我们可以在业务代码main.go中这么写：</p><pre><code class="language-go">func main() {\n\t...\n\n\t// 当前的 Goroutine 等待信号量\n\tquit := make(chan os.Signal)\n\t// 监控信号：SIGINT, SIGTERM, SIGQUIT\n\tsignal.Notify(quit, syscall.SIGINT, syscall.SIGTERM, syscall.SIGQUIT)\n\t// 这里会阻塞当前 Goroutine 等待信号\n\t&lt;-quit\n\n\t// 调用Server.Shutdown graceful结束\n\tif err := server.Shutdown(context.Background()); err != nil {\n\t\tlog.Fatal("Server Shutdown:", err)\n\t}\n}\n</code></pre><p>在监听到关闭进程的信号之后，直接执行server.Shutdown操作，等待这个程序执行结束，再结束main函数，就可以了。</p><h2>验证</h2><p>到这里，我们就完成了优雅关闭的逻辑。最后验证成果，写一个10s才能结束的控制器：</p><pre><code class="language-go">func UserLoginController(c *framework.Context) error {\n\tfoo, _ := c.QueryString("foo", "def")\n\t// 等待10s才结束执行\n\ttime.Sleep(10 * time.Second)\n\t// 输出结果\n\tc.SetOkStatus().Json("ok, UserLoginController: " + foo)\n\treturn nil\n}\n</code></pre><p>按顺序执行下列操作，就能检验出你的关闭逻辑能不能跑通了。</p><ol>\n<li>在控制台启动Web服务</li>\n<li>在浏览器启动一个请求进入10s才能结束的控制器</li>\n<li>10s内在控制台执行Ctrl+C关闭程序</li>\n<li>观察控制台程序是否不会立刻结束，而是在10s后结束</li>\n<li>浏览器端正常输出</li>\n</ol><p>依次操作后，你在控制台可以看到，在执行完成URI之后，程序才退出。<br>\n<img src="https://static001.geekbang.org/resource/image/77/0a/777151e8f5604b3fa6cf228ee3956f0a.png?wh=1488x252" alt=""></p><p>而且，浏览器中正常输出控制器结果。说明你已经完整完成了优雅关闭逻辑！<br>\n<img src="https://static001.geekbang.org/resource/image/1f/7a/1fd82869f6a25c1fe856356b0d59547a.png?wh=563x118" alt=""><br>\n今天只修改了业务文件夹中的main.go代码，框架目录并没有什么变化。<br>\n<img src="https://static001.geekbang.org/resource/image/e0/69/e0e66094f173768b93e2d121e1556069.png?wh=744x1392" alt=""></p><p>有的同学可能会很奇怪，重启这个逻辑不应该放在框架目录的某个地方么，难道每次启动一个服务都要写这个逻辑么？不急，先了解掌握好优雅关闭的原理，在后续章节我们会为框架引入命令行工具，这些优雅关闭的逻辑就会作为框架的一部分存放在框架目录中了。</p><h2>小结</h2><p>今天完成了优雅关闭进程的逻辑，通过标准库os.Signal来控制关闭进程的操作，并且通过net/http提供的server.Shutdown来实现优雅关闭。所有代码都同样放在GitHub上的 <a href="https://github.com/gohade/coredemo/tree/geekbang/06">geekbang/06</a> 分支了。</p><p>讲了很多代码细节，相信你看完shutdown这个函数的实现原理后，会不由得感叹Golang源码的优雅。很多同学会说没有好的Golang项目可以跟着学习，其实Golang源码本身就是一个非常好的学习资料。</p><p>如果你能对其中的每个细节点画出思维导图，顺着导图中的分支展开分析，思考作者为什么会选择这种写法、有没有其他写法，多多练习，你一定会受益颇丰。</p><h3>思考题</h3><p>在如何控制关闭进程操作中，阻塞的最长时间实际上也是可以进行控制的，请尝试一下修改代码，控制优雅关闭的最长等待时间为5s？</p><p>欢迎在留言区分享你的思考。感谢你的收听，如果你觉得今天的内容有所帮助，也欢迎分享给你身边的朋友，邀请他一起学习。我们下节课见～</p>',
        article_title: "06｜重启：如何进行优雅关闭？",
      },
    ],
  },
  {
    chapterTitle: "实战第2关：框架核心",
    children: [
      {
        title: "07｜目标：站在巨人肩膀，你的理想框架到底长什么样？",
        id: 422168,
        content:
          '<p>你好，我是轩脉刃。</p><p>在前面几节课，我们使用 Golang 的 net/http 库实现了一个带有控制器、路由、中间件等功能的 Web 框架，凡事都在向完成一个自定义 Web 框架的方向发展。</p><p>在开发的过程中，不知道你有没有意识到，其实框架中的某个模块，比如说路由，实现的方法不止一种，每一个模块要实现的功能也各有不同，所以用哪一种方法来实现，以及要实现哪些功能，都是一种选择。</p><p>而每种选择的背后，其实都是方向问题，因为这些选择共同构成了一个框架的倾向性，也就是设计感。你要明白，我们的最终方向是：实现我们想要的理想框架。这就好比驾驶汽车的时候，作为司机，你要对目的地有明确清晰的认识。</p><p>那理想框架到底是什么样子的？这个终极问题，闭门造车是无法得到答案的，所以今天，我想让你先从埋头搭建 Web 框架的视角中暂时跳出来，站在更高的角度来纵观全局。</p><h2>开源框架怎么比较</h2><p>我们先进入开源世界，对比开源世界中现有的各种 Web 框架，理解一下它们的实现选择和意图。</p><p>Golang 语言的 Web 开发有很多的框架可以用，但是选择太多也不是好事，因为在技术群里我总会遇到群友有这些疑问：哪款框架比较好呢？我要选择哪款框架呢？这些疑问至少暴露出两个问题：一不知道如何比较开源框架、二不了解这些开源框架，那么接下来我们一一解答。</p><!-- [[[read_end]]] --><p>如何比较开源框架？说到比较，是一定要有标准的。但是衡量一个Web框架是多维度的事情，也没有定论。这里我按照优先级顺序，列出我衡量一个框架的评判标准，你可以参考。<img src="https://static001.geekbang.org/resource/image/e1/2a/e1a7ae856c5c936b0byyb1456ed3a22a.jpg?wh=1920x1080" alt=""></p><h4>核心模块</h4><p>一个框架最核心的几个部分就是我们前几节课讲到的：HTTP服务的启动方式、路由、Context、中间件、重启方式，它们的实现非常关键，往往影响到整个框架的表现，也能直接体现出框架作者的开发水平。</p><p><strong>框架的核心模块就好像是汽车的引擎，一旦核心模块出了问题，或者有隐性的缺陷，后果往往是无法弥补的</strong>。理想的核心模块必须要有设计感，有自己的思想，代码质量、性能都不能出问题。</p><h4>功能完备性</h4><p>框架最好能尽可能多地提供功能或者规范，比如有自己的日志模块、脚手架、命令行工具，甚至自己的ORM、缓存等等。</p><p>要知道，框架的本质还是在于提高开发效率，在团队中，我们<strong>希望不同水平的同学能写出基本一样的代码，那就要靠框架这个顶层设计来规范了</strong>。试想一下，如果框架中提供了很方便的参数验证规范，那在开发应用的时候，还有谁愿意走解析和正则匹配来验证参数呢?</p><p>在功能完备性的选择上，我们往往会根据之后是否希望自定义需求来确定。这里说的自定义需求，指的是定制自己的日志、ORM等模块的需求。</p><h4>框架扩展性</h4><p>理想的框架，它的扩展性一定要好。<strong>框架要做的事情应该是定义模块与模块之间的交互标准，而不应该直接定义模块的具体实现方式</strong>。我可以在这个标准上扩展出我需要的功能，这样整个框架才会比较灵活。</p><p>Web 领域的技术边界在不断扩展，谁也无法保证框架中所用的库，哪怕是最基本的日志库，能永远满足需求。当框架使用者想为应用增加一个功能，或者替换某个第三方库的时候，如果改动的地方非常多，要大动干戈，甚至根本就无法支持替换和增加，那这个框架的扩展性就比较弱了。</p><h4>框架性能</h4><p>虽然大部分框架都是封装 net/http，但是封装程度不同以及具体的实现选择不同（使用的路由匹配、上下文机制等），就会有不同的性能表现。</p><p>我们选择框架之后，最终是要在框架上运行代码的，如果运行效率有指数级别的差距，是不能接受的。市面上所有框架的性能，你可以参考这个<a href="https://web-frameworks-benchmark.netlify.app/result">第三方测评结果</a>。</p><p>其实对框架性能来说，大部分场景里，我们是不会有极致性能需求的。所以看各种框架的性能评估，<strong>我们不应该把各个框架孤立出来看，应该将差不多量级的性能归为一组</strong>。不要去比较单个框架的性能差异，而应该去比较不同量级组之间的性能差异，因为在相同量级下，其实框架和框架之间的性能差别并不是很大。</p><h4>文档完备度及社区活跃度</h4><p>开源不仅仅是将代码分享出去，同时分享的还有使用文档，官方必须提供足够的介绍资料，包括文档、视频、demo 等。</p><p>文档和社区是需要不断运营的，因为在使用的过程中，我们一定会遇到各种各样的问题，官方的回复以及一个活跃的社区是保障问题能得到解决的必要条件。</p><p>所以当我们选择一个框架的时候，官网、GitHub的star、issue都是很好的衡量标准。当选择框架之后，<strong>不妨每天花一点时间在这个项目的官网、GitHub或者邮件组上，你会得到很多真实信息</strong>。</p><p>现在基本了解这五点评判标准了，我们可以用这把尺子衡量一下市面上的框架，帮助你迅速熟悉起来。</p><h2>比较开源框架</h2><p>在开源社区有个<a href="https://github.com/mingrammer/go-web-framework-stars"> go-web-framework-stars 项目</a>，把41款 Go Web 框架按流行程度做了个列表，其中 Gin、Beego、Echo 这三个框架是 Star 数排名前三的，下面我们就针对这三个框架来分析。</p><p>在刚才的五个维度中，我们会重点分析这三个框架的核心模块和功能完备性这两点，另外三点扩展性、性能以及文档完备性资料很多，我只在表格中简单说明一下。</p><h3>Beego</h3><p>Beego 是一款国人开发的 Web 框架，它出现得非常早，中间经历过一次比较大的改版，目前版本定位在 2.0.0。</p><p>先来看Beego的核心模块，我们还是从HTTP服务的启动方式、路由、Context、中间件、重启方式这五个方面来分析。</p><p>Beego 提供多种服务启动方式：HTTP/HTTPS、CGI、Graceful。</p><p>它的路由原理是为每个 HTTP 方法建立一个路由树，这个路由树结构的每个叶子节点是具体的执行控制器，每个中间节点是HTTP请求中斜杠“/”分隔的节。比如 /user/name 从根到叶子节点的通路就是：1 个根节点、1 个中间节点 user、一个叶子节点 name。</p><p><img src="https://static001.geekbang.org/resource/image/38/a2/38436fe72b0415cb08bfc4d4c3267ca2.jpg?wh=1920x1080" alt=""></p><p>Beego的自动匹配路由和注解路由是比较有特色的，这里我简单解释一下：</p><ul>\n<li>自动匹配路由的意思是，如果我们把一个控制器注册到自动路由中，路由寻址的时候，会根据“控制器名称+控制器类”中的方法名，自动进行映射匹配。</li>\n<li>注解路由是指在注册路由树的时候，会根据控制器类中某个方法的注释来解析并创建路由树。</li>\n</ul><p>Context 的设计方面，Beego 的 Context 是藏在 controller 结构中的，而不是每个函数的第一个参数带着 Context，这个和现在 Golang 提倡的“函数第一个参数为 Context”的规范是有些不同的，可能也是因为 Beego 出现的时间比较早。</p><p>在功能完备性方面，Beego 框架提供了很多周边的功能。比如 Beego 提供了一个原生的 ORM 框架、自定义的 Logger 库、参数验证 Validate 库，甚至还默认提供了管理 GC、Goroutine 等管理接口。</p><p><img src="https://static001.geekbang.org/resource/image/c8/1a/c8c7a18c8faee74ac7ce82bbcf2e121a.jpg?wh=1920x1080" alt=""></p><p>总体来说，使用 Beego 的最大感受就是“全”。这是一个很全的框架，开发 Web 应用所需要的所有组件基本都能在这里找到，<strong>如果选择它做业务开发，功能完备性是最重要的因素</strong>。所以在从零开始，希望快速开发的场景中，我们会尽量选择使用这个框架。</p><h3>Echo</h3><p>Echo 框架目前最新版本是 v4.0.0。它的底层也是基于 net/http，但并没有提供类似 Beego 通过信号的 Graceful 启动方式，而是暴露标准库的 ShutDown 方法进行请求的关闭接口，具体使用的方式是开关还是配置，都交由使用者决定。</p><p>在路由方面，Echo 的路由也是使用字典树的结构。和 Beego 的树不同，它并不是为每个HTTP方法建立一个树，而是只整体建立一个树，在叶子节点中，根据不同的 HTTP 方法存放了不同的控制处理函数，所以你可以在它的叶子节点中看到如下这么一个 methodHandler 结构：</p><p><img src="https://static001.geekbang.org/resource/image/73/3e/73539151493721461fe49625c270f73e.png?wh=742x766" alt=""></p><p>Echo 也封装了自己的 Context 接口，提供了一系列像 JSON、Validate、Bind 等很好用的对 request 和 response 的封装。</p><p>相较于 Beego 库，Echo 库非常轻量，除了基本的路由、Context 之外，大部分功能都以 Middleware 的形式提供出来。Echo 的 Middleware 是一个 echo.MiddlewareFunc 结构体的无参数函数。在框架的 middleware 文件夹中，提供了诸如 logger、jwt、csrf 等中间件。</p><p><img src="https://static001.geekbang.org/resource/image/64/2f/642ac8a8caf500e2f9287a27ef9ecf2f.jpg?wh=1920x1080" alt=""></p><p>总体来说，<strong>Echo的使用者更看中扩展性和框架性能</strong>。和定位一样，它是一种高性能、可扩展、轻量级的Web框架，但麻雀虽小，五脏俱全。目前看起来，它的社区活跃度比 Gin 框架稍差一些（从两者的中间件贡献数可以看出）。所以我感觉，Echo 框架更适合个人开发者，而且需要有一定的扩展框架能力。</p><h3>Gin</h3><p>Gin 框架目前最新版本 1.7.2。它和 Echo 一样属于非常轻量级的应用，基本实现的就是 Web 框架最核心的部分。</p><p>路由方面，和 Echo 一样使用字典树，但是又和 Echo/Beego 不一样的是，它的中间节点并不是斜杠分隔的请求路由，而是<strong>相同的字符串部分</strong>。</p><p>比如下图左边的例子，/welcome 和/welgood 会创建一个中间节点(/wel) 和两个叶子节点(come) 和 (good)，而且并不是只有叶子节点才包含控制器处理函数，中间节点也可能存在控制器节点函数。比如下图的右边例子，/welcome 和/welcome2 包含中间节点(/welcome)和叶子节点(2)，中间节点/welcome 也包含了一个处理函数。</p><p><img src="https://static001.geekbang.org/resource/image/be/4a/be93c883c89e659d8e34a289c3e65c4a.jpg?wh=1920x1080" alt=""></p><p>Gin 的路由还有一个特色就是，<strong>使用索引来加速子树查询效率</strong>。再看图中左边的例子，/wel 中间节点还带着一个索引 cg，代表的是子树的第一个字母。所以路由查找的时候，会先去索引 cg 中查找，当前路由除“/wel”的第一个字母，是否在索引中，如果在，索引的下标序列就代表第几个子树节点。</p><p>不过，Gin 的路由并不是这个框架作者原创的，使用的是第三方的 httprouter 包。Gin 使用这个核心包的方法也不是直接 import 第三方包，而是将其 copy 进自己的代码库，当然可以这么用也是因为 httprouter 第三方库使用的是 BSD 这种有很大自由度的许可证协议。</p><p>Context 基本就和 Echo/Beego 的设计一样，自己封装了 Context 结构。但是，Gin 的 Context 结构实现了标准库定义的 Context 接口，即 Deadline、Done 等接口。所以按照 Golang 中定义的鸭子类型概念（长得像鸭子，那么就是鸭子），我们可以把 Gin 中的 Context 当作标准库的 Context 一样使用，这点在实际开发工作中是非常方便的。</p><p>在中间件上，Gin框架没有定义所有的middleware，而是定义了 middleware 函数：</p><pre><code class="language-plain">HandlerFunc func(*Context)\n</code></pre><p>链式加载和调用 middleware，并将这个 middleware 的具体实现开放给社区，设计了 <a href="https://github.com/gin-contrib">社区贡献 organizations</a> ，让社区的开源贡献者把自己实现的中间件统一放在这个 organizations 中，提供给所有人使用，而 Gin 的核心代码及相关则放在另一个organizations 中。这种为开源社区制定标准，并且不断推进和审核开源贡献代码的做法，也是 Gin 社区活跃度如此之高的原因之一。</p><p><img src="https://static001.geekbang.org/resource/image/56/f0/56eb9bf16283bf70c76f69b229e278f0.jpg?wh=1920x1080" alt=""></p><p>总体来说，<strong>Gin 比较适合企业级团队使用</strong>。它的社区活跃度较高，社区贡献的功能模块较多，能很好补充其功能完备性；同时 Gin 的扩展性也很好，我们可以在社区贡献模块和自研模块中做出很好的取舍。</p><p>这里我们只介绍了三个框架，之后你想要快速了解一个新框架，也可以参考这套思路。</p><h2>你理想的框架是什么样的</h2><p>现在你已经知道了如何比较开源框架，也对三款最受欢迎的开源框架有一定了解。那么我们再回答开头提到的终极问题：如果我们要做一款Web框架，它应该是什么样子?</p><p>其实从刚才的分析也可以看出来，<strong>这个问题是见仁见智的，和你的工作经验、技术阅历、甚至技术的理念都有关系</strong>。有的人追求的是世界上运行速度最快的框架；有的人追求的是灵活性最高的框架；有的人追求的是功能最全的框架。</p><p>具体你要根据自己的应用场景来选择，包括你Web应用的业务场景、并发需求、团队规模、工期等等。回看刚才提出的五个选择维度，以我们聊过的三个Web框架为例。</p><p>在保证框架的核心模块能满足要求的情况下，我们一般在功能完备性和框架扩展性之间取舍。</p><p>如果你开发一个运营管理后台，并发量基本在 100 以下，单机使用，开发的团队规模可能就 1～2 个人，那你<strong>最应该考虑功能完备性，明显使用 Beego 的收益会远远大于使用 Gin 和 Echo</strong>。因为如果你选择 Gin 和 Echo 之后，还会遇到比如应该选用哪种 ORM、应该选用哪种缓存等一系列问题，而这些在功能组件相当全面的 Beego 中早就被定义好了。</p><p>如果你有一定的团队规模，有比较高的并发量，而且你感觉后续对框架的改动需求或者扩展需求会很高，比如你希望自己开发一个适合团队使用的缓存方法。那么这个时候，<strong>你应该把框架扩展性放在最高级，可能 Gin 和Echo 更适合你</strong>。如果你要更多的灵活性，你可能会考虑直接从 net/http 标准库开始，不使用任何的开源Web框架。</p><p>所以，选择框架信奉一个原则：只选最适合的，不选最贵的。如果你在几个框架中犹豫不定，除了可以用五个维度比较框架之外，你更应该多花时间内省思考清楚你的真正需求。</p><h2>小结</h2><p>我们今天尝试通过回答两个分问题，来思考一个终极问题，理想框架究竟应该是什么样的。<img src="https://static001.geekbang.org/resource/image/e1/2a/e1a7ae856c5c936b0byyb1456ed3a22a.jpg?wh=1920x1080" alt=""></p><p>对第一个分问题如何比较开源框架，我们提出了五个维度，按照优先级顺序依次为：核心模块、功能完备性、框架扩展性、框架性能、文档完备度及社区活跃度。然后从这五个维度，简要分析了现在最流行的三个开源框架 Beego、Gin和Echo。</p><p>最后我们回到终极问题，探讨我们理想中的框架应该是什么样子的？总结一句话就是，<strong>在搞清楚真正的业务需求后，选最合适的框架就可以了</strong>。把握好这一点，你今后在遇到框架选择问题的时候，就不会太迷茫。</p><h2>思考题</h2><p>我们比较了三个框架，但是你可能也用过其他的框架，不妨介绍一下你在过去工作中使用过的框架，以及使用感受？</p><p>欢迎在留言区分享你的思考。感谢你的收听，如果你觉得有收获，也欢迎你把今天的内容分享给你身边的朋友，邀他一起学习。我们下节课见～</p>',
        article_title: "07｜目标：站在巨人肩膀，你的理想框架到底长什么样？",
      },
      {
        title: "08｜自研or借力（上）：集成Gin替换已有核心",
        id: 422990,
        content:
          '<p>你好，我是轩脉刃。</p><p>之前我们从零开始研发了一个有控制器、路由、中间件等组件的 Web 服务器框架，这个服务器框架可以说是麻雀虽小，但五脏俱全。上节课我们还介绍了目前最主流的一些框架 Gin、Echo 和Beego。</p><p>这里不知道你有没有这些疑问，我们的框架和这些顶级的框架相比，差了什么呢？如何才能快速地把我们的框架可用性，和这些框架提升到同一个级别？我们做这个框架除了演示每个实现细节，它的优势是什么呢？</p><p>不妨带着这些问题，把我们新出炉的框架和GitHub上star数最高的<a href="https://github.com/gin-gonic/gin">Gin框架</a>比对一下，思考下之间的差距到底是什么。</p><h2>和Gin对比</h2><p>Gin 框架无疑是现在最火的框架，你能想出很多它的好处，但是在我看来，它之所以那么成功，<strong>最主要的原因在于两点：细节和生态</strong>。</p><p>其实框架之间的实现原理都差不多，但是生产级别的框架和我们写的示例级别的框架相比，差别就在于细节，这个细节是需要很多人、很多时间去不断打磨的。</p><p>如果你的 Golang 经验积累到一定时间，那肯定能很轻松实现一个示例级别的框架，但是往往是没有开源市场的，因为你的框架，在细节上的设计没有经过很多人验证，也没有经过在生产环境中的实战。这些都需要一个较为庞大的使用群体和较长时间才能慢慢打磨出来。</p><!-- [[[read_end]]] --><p>Gin 里面的每一行代码，基本都是在很长时间里，经过各个贡献者的打磨，才演变至今的。我们看 Gin 框架的代码优化和提交频率，从这一讲落笔算起（2021 年 8 月 9 日），最近的一次提交改进是 6 天前（2021 年 8 月 3 日），Gin 框架升级到了 v1.7.3 版本。</p><p>我们也可以统计一下Gin 的 master 分支，从 2014 开始至今已经有 1475 次优化提交。这里的每一次优化提交，都是对 Gin 框架细节的再一次打磨。</p><h3>Recovery 的错误捕获</h3><p>光放数字说服力不明显，我们直接比较代码，看看之前实现的各个逻辑在 Gin 框架中是如何实现的，你就可以感受到在细节上的差距了。</p><p>还记得在第四课的时候，我们实现了一个 Recovery 中间件么？放在框架middleware文件夹的recovery.go中：</p><pre><code class="language-go">// recovery 机制，将协程中的函数异常进行捕获\nfunc Recovery() framework.ControllerHandler {\n\t// 使用函数回调\n\treturn func(c *framework.Context) error {\n\t\t// 核心在增加这个 recover 机制，捕获 c.Next()出现的 panic\n\t\tdefer func() {\n\t\t\tif err := recover(); err != nil {\n\t\t\t\tc.Json(500, err)\n\t\t\t}\n\t\t}()\n\t\t// 使用 next 执行具体的业务逻辑\n\t\tc.Next()\n\n\t\treturn nil\n\t}\n}\n</code></pre><p>这个中间件的作用是捕获协程中的函数异常。我们使用 defer、recover 函数，捕获了 c.Next 中抛出的异常，并且在 HTTP 请求中返回 500 内部错误的状态码。</p><p>乍看这段代码，是没有什么问题的。但是我们再仔细思考下是否有需要完善的细节？</p><p>首先是异常类型，我们原先认为，所有异常都可以通过状态码，直接将异常状态返回给调用方，但是这里是有问题的。<strong>这里的异常，除了业务逻辑的异常，是不是也有可能是底层连接的异常</strong>？</p><p>以底层连接中断异常为例，对于这种连接中断，我们是没有办法通过设置 HTTP 状态码来让浏览器感知的，并且一旦中断，后续的所有业务逻辑都没有什么作用了。同时，如果我们持续给已经中断的连接发送请求，会在底层持续显示网络连接错误（broken pipe）。</p><p>所以在遇到这种底层连接异常的时候，应该直接中断后续逻辑。来看看 Gin 对于连接中断的捕获是怎么处理的。（你可以查看Gin的Recovery <a href="https://github.com/gin-gonic/gin/blob/master/recovery.go">GitHub地址</a>）</p><pre><code class="language-go">return func(c *Context) {\n\t\tdefer func() {\n\t\t\tif err := recover(); err != nil {\n\t\t\t\t// 判断是否是底层连接异常，如果是的话，则标记 brokenPipe\n\t\t\t\tvar brokenPipe bool\n\t\t\t\tif ne, ok := err.(*net.OpError); ok {\n\t\t\t\t\tif se, ok := ne.Err.(*os.SyscallError); ok {\n\t\t\t\t\t\tif strings.Contains(strings.ToLower(se.Error()), "broken pipe") || strings.Contains(strings.ToLower(se.Error()), "connection reset by peer") {\n\t\t\t\t\t\t\tbrokenPipe = true\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t...\n\n                \n\t\t\t\tif brokenPipe {\n\t\t\t\t\t// 如果有标记位，我们不能写任何的状态码\n\t\t\t\t\tc.Error(err.(error)) // nolint: errcheck\n\t\t\t\t\tc.Abort()\n\t\t\t\t} else {\n\t\t\t\t\thandle(c, err)\n\t\t\t\t}\n\t\t\t}\n\t\t}()\n\t\tc.Next()\n\t}\n</code></pre><p>这段代码先判断了底层抛出的异常是否是网络异常（net.OpError），如果是的话，再根据异常内容是否包含“broken pipe”或者“connection reset by peer”，来判断这个异常是否是连接中断的异常。如果是，就设置标记位，并且直接使用 c.Abort() 来中断后续的处理逻辑。</p><p>这个处理异常的逻辑可以说是非常细节了，<strong>区分了网络连接错误的异常和普通的逻辑异常，并且进行了不同的处理逻辑</strong>。这一点，可能是绝大多数的开发者都没有考虑到的。</p><h3>Recovery 的日志打印</h3><p>我们再看下 Recovery 的日志打印部分，也非常能体现出 Gin 框架对细节的考量。</p><p>当然在第四讲我们只是完成了最基础的部分，没有考虑到打印 Recovery 捕获到的异常，不妨在这里先试想下，如果是自己实现，你会如何打印这个异常呢？如果你有想法了，我们再来对比看看 Gin 是如何实现这个异常信息打印的(<a href="https://github.com/gin-gonic/gin/blob/master/recovery.go">GitHub地址</a>)。</p><p>首先，打印异常内容是一定得有的。这里直接使用 logger.Printf 就可以打印出来了。</p><pre><code class="language-go">logger.Printf("%s\\n%s%s", err, ...)\n</code></pre><p>其次，异常是由某个请求触发的，所以触发这个异常的请求内容，也是必要的调试信息，需要打印。</p><pre><code class="language-go">httpRequest, _ := httputil.DumpRequest(c.Request, false)\nheaders := strings.Split(string(httpRequest), "\\r\\n")\n// 如果 header 头中有认证信息，隐藏，不打印。\nfor idx, header := range headers {\ncurrent := strings.Split(header, ":")\n  if current[0] == "Authorization" {\n  \t  headers[idx] = current[0] + ": *"\n  }\n}\nheadersToStr := strings.Join(headers, "\\r\\n")\n</code></pre><p>分析一下这段代码，Gin 使用了一个 DumpRequest 来输出请求中的数据，包括了 HTTP header 头和 HTTP Body。</p><p>这里值得注意的是，为了安全考虑 Gin 还注意到了，<strong>如果请求头中包含 Authorization 字段，即包含 HTTP 请求认证信息，在输出的地方会进行隐藏处理</strong>，不会由于 panic 就把请求的认证信息输出在日志中。这一个细节，可能大多数开发者也都没有考虑到。</p><p>最后看堆栈信息打印，Gin 也有其特别的实现。我们打印堆栈一般是使用 <a href="https://pkg.go.dev/runtime@go1.17.1#Caller">runtime 库的 Caller</a> 来打印：</p><pre><code class="language-go">// 打印堆栈信息，是否有这个堆栈\nfunc Caller(skip int) (pc uintptr, file string, line int, ok bool)\n</code></pre><p>caller 方法返回的是堆栈函数所在的函数指针、文件名、函数所在行号信息。但是在使用过程中你就会发现，使用 Caller 是打印不出真实代码的。</p><p>比如下面这个例子，我们使用 Caller 方法，将文件名、行号、堆栈函数打印出来：</p><pre><code class="language-go">// 在 prog.go 文件，main 库中调用 call 方法\nfunc call(skip int) bool {   //24 行\n\tpc,file,line,ok := runtime.Caller(skip) //25 行\n\tpcName := runtime.FuncForPC(pc).Name()&nbsp; //26 行\n\tfmt.Println(fmt.Sprintf("%v %s %d %s",pc,file,line,pcName)) //27 行\n\treturn ok //28 行\n} //29 行\n</code></pre><p>打印出的第一层堆栈函数的信息：</p><pre><code class="language-go">4821380 /tmp/sandbox064396492/prog.go 25 main.call\n</code></pre><p>这个堆栈信息并不友好，它告诉我们，第一层信息所在地址为 prog.go 文件的第 25 行，在 main 库的 call 函数里面。所以如果想了解下第 25 行有什么内容，用这个堆栈信息去源码中进行文本查找，是做不到的。这个时候就非常希望信息能打印出具体的真实代码。</p><p>在 Gin 中，打印堆栈的时候就有这么一个逻辑：<strong>先去本地查找是否有这个源代码文件，如果有的话，获取堆栈所在的代码行数，将这个代码行数直接打印到控制台中</strong>。</p><pre><code class="language-go">// 打印具体的堆栈信息\nfunc stack(skip int) []byte {\n\t...\n    // 循环从第 skip 层堆栈到最后一层\n\tfor i := skip; ; i++ { \n\t\tpc, file, line, ok := runtime.Caller(i)\n\t\t// 获取堆栈函数所在源文件\n\t\tif file != lastFile {\n\t\t\tdata, err := ioutil.ReadFile(file)\n\t\t\tif err != nil {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tlines = bytes.Split(data, []byte{\'\\n\'})\n\t\t\tlastFile = file\n\t\t}\n        // 打印源代码的内容\n\t\tfmt.Fprintf(buf, "\\t%s: %s\\n", function(pc), source(lines, line))\n\t}\n\treturn buf.Bytes()\n}\n\n</code></pre><p>这样，打印出来的堆栈信息形如：</p><pre><code class="language-go">/Users/yejianfeng/Documents/gopath/pkg/mod/github.com/gin-gonic/gin@v1.7.2/context.go:165 (0x1385b5a)\n        (*Context).Next: c.handlers[c.index](c)\n</code></pre><p>这个堆栈信息就友好多了，它告诉我们，这个堆栈函数发生在文件的 165 行，它的代码为 c.handlers<a href="c">c.index</a>， 这行代码所在的父级别函数为 (*Context).Next。</p><p>最终，Gin 打印出来的 panic 信息形式如下：</p><pre><code class="language-go">2021/08/15 14:18:57 [Recovery] 2021/08/15 - 14:18:57 panic recovered:\nGET /first HTTP/1.1\nHost: localhost:8080\nAccept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/ *;q=0.8,application/signed-exchange;v=b3;q=0.9\nAccept-Encoding: gzip, deflate, br\n...\nUser-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/92.0.4515.131 Safari/537.36\n\n\n\n%!s(int=121321321)\n/Users/yejianfeng/Documents/UGit/gindemo/main.go:19 (0x1394214)\n&nbsp; &nbsp; &nbsp; &nbsp; main.func1: panic(121321321)\n/Users/yejianfeng/Documents/gopath/pkg/mod/github.com/gin-gonic/gin@v1.7.2/context.go:165 (0x1385b5a)\n&nbsp; &nbsp; &nbsp; &nbsp; (*Context).Next: c.handlers[c.index](c)\n/Users/yejianfeng/Documents/gopath/pkg/mod/github.com/gin-gonic/gin@v1.7.2/recovery.go:99 (0x1392c48)\n&nbsp; &nbsp; &nbsp; &nbsp; CustomRecoveryWithWriter.func1: c.Next()\n/Users/yejianfeng/Documents/gopath/pkg/mod/github.com/gin-gonic/gin@v1.7.2/context.go:165 (0x1385b5a)\n&nbsp; &nbsp; &nbsp; &nbsp; (*Context).Next: c.handlers[c.index](c)\n...\n/usr/local/Cellar/go/1.15.5/libexec/src/net/http/server.go:1925 (0x12494ac)\n&nbsp; &nbsp; &nbsp; &nbsp; (*conn).serve: serverHandler{c.server}.ServeHTTP(w, w.req)\n/usr/local/Cellar/go/1.15.5/libexec/src/runtime/asm_amd64.s:1374 (0x106bb00)\n&nbsp; &nbsp; &nbsp; &nbsp; goexit: BYTE&nbsp; &nbsp; $0x90&nbsp; &nbsp;// NOP\n</code></pre><p>可以说这个调试信息就非常丰富了，对我们在实际工作中的调试会有非常大的帮助。但是这些丰富的细节都是在开源过程中，不断补充起来的。</p><h3>路由对比</h3><p>刚才只挑Recovery 中间件的错误捕获和日志打印简单说了一下，我们可以再挑核心一些的功能，例如比较一下我们实现的路由和 Gin 的路由的区别。</p><p>在第三节课使用 trie 树实现了一个路由，它的每一个节点是一个 segment。<br>\n<img src="https://static001.geekbang.org/resource/image/4b/b7/4b53584aa86dbd992263867ff1f3e7b7.jpg?wh=1920x1224" alt=""></p><p>而 Gin 框架的路由选用的是一种压缩后的基数树（radix tree），它和我们之前实现的 trie 树相比最大的区别在于，它并不是把按照分隔符切割的 segment 作为一个节点，而是<strong>把整个 URL 当作字符串，尽可能匹配相同的字符串作为公共前缀</strong>。<br>\n<img src="https://static001.geekbang.org/resource/image/88/94/8869327a3ef4fb0037f364f74f3d0994.jpg?wh=1920x1080" alt=""></p><p>为什么 Gin 选了这个模型？其实 radix tree 和 trie 树相比，最大的区别就在于它节点的压缩比例最大化。直观比较上面两个图就能看得出来，对于 URL 比较长的路由规则，trie 树的节点数就比 radix tree 的节点数更多，整个数的层级也更深。</p><p>针对路由这种功能模块，创建路由树的频率远低于查找路由点频率，那么<strong>减少节点层级，无异于能提高查找路由的效率，整体路由模块的性能也能得到提高</strong>，所以 Gin 用 radix tree 是更好的选择。</p><p>另外在路由查找中，Gin 也有一些细节做得很好。首先，从父节点查找子节点，并不是像我们之前实现的那样，通过遍历所有子节点来查找是否有子节点。Gin 在每个 node 节点保留一个 indices 字符串，这个字符串的每个字符代表子节点的第一个字符：</p><p>在Gin源码的<a href="https://github.com/gin-gonic/gin/blob/master/tree.go">tree.go</a>中可以看到。</p><pre><code class="language-go">// node 节点\ntype node struct {\n\tpath&nbsp; &nbsp; &nbsp; string\n\tindices&nbsp; &nbsp;string  // 子节点的第一个字符\n\t...\n\tchildren&nbsp; []*node // 子节点\n    ...\n}\n</code></pre><p>这个设计是为了加速子节点的查询效率。使用 Hash 查找的时间复杂度为 O(1)，而我们使用遍历子节点的方式进行查找的效率为 O(n)。</p><p>在拼接 indices 字符串的时候，这里 Gin 还有一个代码方面的细节值得注意，<a href="https://github.com/gin-gonic/gin/blob/master/tree.go">在tree.go中</a>有一段这样的代码：</p><pre><code class="language-go"> \tpath = path[i:]\n\tc := path[0]\n\n\t...\n\t// 插入子节点\n\tif c != \':\' &amp;&amp; c != \'*\' &amp;&amp; n.nType != catchAll {\n\t\t// []byte for proper unicode char conversion, see #65\n        // 将字符串拼接进入 indices\n\t\tn.indices += bytesconv.BytesToString([]byte{c})\n\t\t...\n\t\tn.addChild(child)\n\t\t...\n</code></pre><p>将字符 c 拼接进入 indices 的时候，使用了一个 bytesconv.BytesToString 方法来将字符 c 转换为 string。你可以先想想，这里为什么不使用 string 关键字直接转换呢？</p><p>因为在 Golang 中，string 转化为 byte 数组，以及 byte 数组转换为 string ，都是有内存消耗的。以 byte 数组使用关键字 string 转换为字符串为例，Golang 会先在内存空间中重新开辟一段字符串空间，然后将 byte 数组复制进入这个字符串空间，这样不管是在内存使用的效率，还是在CPU资源使用的效率上，都存在一定消耗。</p><p>而在 Gin 的第 <a href="https://github.com/gin-gonic/gin/pull/2206/files">#2206</a> 号提交中，有开源贡献者就使用自研的 bytesconv 包，将 Gin 中的字符数组和 string 的转换统一做了一次修改。</p><pre><code class="language-go">package bytesconv\n\n// 字符串转化为字符数组，不需要创建新的内存\nfunc StringToBytes(s string) []byte {\n\treturn *(*[]byte)(unsafe.Pointer(\n\t\t&amp;struct {\n\t\t\tstring\n\t\t\tCap int\n\t\t}{s, len(s)},\n\t))\n}\n\n// 字符数组转换为字符串，不需要创建新的内存\nfunc BytesToString(b []byte) string {\n\treturn *(*string)(unsafe.Pointer(&amp;b))\n}\n</code></pre><p>bytesconv 包的原理就是，直接使用 unsafe.Pointer 来强制转换字符串或者字符数组的类型。</p><p>这些细节的修改，一定程度上减少了 Gin 包内路由的内存占用空间。类似的细节点还有很多，需要每一行代码琢磨过去，而且这里的每一个细节优化点都是，开源贡献者在生产环境中长期使用 Gin 才提炼出来的。</p><p>不要小看这些看似非常细小的修改。因为细节往往是积少成多的，所有的这些细节逐渐优化、逐渐完善，才让 Gin 框架的实用度得到持久的提升，和其他框架的差距就逐渐体现出来了，这样才让Gin框架成了生产环境中首选的框架。</p><h2>生态</h2><p>聊完细节，再来看看生态。你肯定有点疑惑，为什么我会把生态这个点单独拿出来说，难道生态不是由于框架的质量好而附带的生态繁荣吗？</p><p>其实不然。一个开源项目的成功，最重要的是两个事情，<strong>第一个是质量，开源项目的代码质量是摆在第一位的，但是还有一个是不能被忽略的：生态的完善</strong>。</p><p>一个好的开源框架项目，不仅仅只有代码，还需要围绕着核心代码打造文档、框架扩展、辅助命令等。这些代码周边的组件和功能的打造，虽然从难度上看，并没有核心代码那么重要，但是它是一个长期推进和完善的过程。</p><p>Gin 的整个生态环境是非常优质的，在开源中间件、社区上都能看到其优势。</p><p>从 2014 年至今 Gin 已有多个开源共享者为其共享了开源中间件，目前<a href="https://github.com/orgs/gin-contrib/repositories">官方GitHub</a>组织收录的中间件有 23 个，非收录官方，但是在<a href="https://github.com/gin-gonic/contrib">官方README</a>记录的也有 45 个。</p><p>这些中间件包含了 Web 开发各个方面的功能，比如提供跨域请求的 cors 中间件、提供本地缓存的 cache 中间件、集成了 pprof 工具的 pprof 中间件、自动生成全链路 trace 的 opengintracing 中间件等等。<strong>如果你用一个自己的框架，就需要重建生态一一开发，这是非常烦琐的，而且工作量巨大</strong>。</p><p>Gin 的 GitHub 官网的社区活跃度比较高，对于已有的一些问题，在官网的 issue 提出来立刻就会有人回复，在 Google 或者 Baidu 上搜索 Gin，也会有很多资料。所以对于工作中必然会出现的问题，我们可以在网络上很方便找寻到这个框架的解决办法。这也是 Gin 大受欢迎的原因之一。</p><p>其实除了Gin框架，我们可以从不少其他语言的框架中看到生态的重要性。比如前端的Vue框架，它不仅仅提供了最核心的Vue的框架代码，还提供了脚手架工具Vue-CLI、Vue的Chrome插件、Vue的官方论坛和聊天室、Vue的示例文档Cookbook。这些周边生态对Vue框架的成功起到了至关重要的作用。</p><h2>站在巨人的肩膀才能做得更好</h2><p>刚才分析了一些 Gin 框架的细节以及它强大的生态，相信已经回答了开头我们提出来的问题：和这些顶级的框架相比，我们做的到底差了什么？我们的框架在可用性上，能不能迅速提升到这些顶级框架的级别？很明显短时间是不可能的。</p><p>讲了这么多，其实我想说：只有站在巨人的肩膀才能做得更好。</p><p>如果是为了学习，我们之前从零自己边造轮子边学是个好方法；<strong>但是如果你的目标是工业使用，那从零开始就非常不明智了</strong>。</p><p>因为在现在的技术氛围下，开源早已成为了共识。互联网的开源社区早就有我们需要的各个成形零件，我们要做的是，使用这些零件来继续开发。在 Golang Web 框架这个领域也是一样的，如果是想从头开始制造框架，除非你后面有很强大的团队在支撑，否则写出来的框架不仅没有市场，可能连实用性也会受到质疑。</p><p><strong>其实很多市面上的框架，也都是基于已有的轮子来再开发的</strong>。就拿 Gin 框架本身来说吧，它的路由是基于 httprouter 这个项目来定制化修改的；再比如 Macaron 框架，它是基于 Martini 框架的设计实现的。它们都是在原有的开源项目基础上，按照自己的设计思路重新改造的，也都获得了成功。</p><p>而且从我的个人经验来看，那些从头开始所有框架功能都是由自己开发的同学，往往很难坚持下来。所以你现在是不是明白了，为什么在课程最开始会说，我们先从零搭建出框架的核心部分，然后基于 Gin 来做进一步拓展和完善。</p><p>因为我们希望通过这门课花大力气搭建出来的 Golang Web 框架，不只是一个示例级别的框架，而是真正能用到具体工作环境中的，要做到这一点，它得使用开源社区的各种优秀开源库，目的就是提升你解决问题的效率。</p><h2>小结</h2><p>今天通过对比 Gin 框架和我们之前设计的框架间的细节，展示了一个成熟的生产级别的框架与一个示例级别框架在细节上的距离。</p><p><strong>现代框架的理念不在于实现，而更多在于组合</strong>。基于某些基础组件或者基础实现，不断按照自己或者公司的需求，进行二次改造和二次开发，从而打造出适合需求的形态。</p><p>比如 PHP 领域的 Laravel 框架，就是将各种底层组件、Symfony、Eloquent ORM、Monolog 等进行组装，而框架自身提供统一的组合调度方式；比如 Ruby 领域的 Rails 框架，整合了 Ruby 领域的各种优秀开源库，<strong>而框架的重点在于如何整理组件库、如何提供更便捷的机制，让程序员迅速解决问题</strong>。</p><p>所以，接下来我们设计框架的思路，就要从之前的从零开始造轮子，转换为站在巨人的肩膀上了，会借用 Gin 框架来继续实现。准备好，下一讲我们就要开始动手改造了。</p><h3>思考题</h3><p>在Gin框架中，也和我们第5讲一样提供了Query系列方法，你能看出Gin实现的Query系列方法和我们实现的有什么不同么？</p><p>欢迎在留言区分享你的思考。感谢你的收听，如果你觉得有收获，也欢迎你把今天的内容分享给你身边的朋友，邀他一起学习。我们下节课见。</p>',
        article_title: "08｜自研or借力（上）：集成Gin替换已有核心",
      },
      {
        title: "09｜自研or借力（下）：集成Gin替换已有核心",
        id: 423982,
        content:
          '<p>你好，我是轩脉刃。</p><p>在上一节课，比对了 Gin 框架和我们之前写的框架，明确框架设计的目标是，要设计出真正具有实用性的一个工业级框架，所以我们接下来会基于现有的比较成熟的 Gin 框架，并且好好利用其中间件的生态，站在巨人的肩膀，继续搭建自己的框架。</p><h2>如何借力，讨论开源项目的许可协议</h2><p>有的人可能就有点困惑了，这样借鉴其他框架或者其他库不是侵权行为吗？</p><p>要解答这个问题，我们得先搞清楚站在巨人肩膀是要做什么操作。借鉴和使用 Gin 框架作为我们的底层框架基本思路是，以复制的形式将 Gin 框架引入到我们的自研框架中，替换和修改之前实现的几个核心模块。</p><p>我们后续会在这个以 Gin 为核心的新框架上，进行其余核心或者非核心框架模块的设计和开发，同时我们也需要找到比较好的方式，能将 Gin 生态中丰富的开源中间件进行复制和使用。</p><p>现在我们再来回答是否侵权的问题，首先得了解开源许可证，并且知道可以对 Gin 框架做些什么操作？</p><p>开源社区有非常多的开源项目，每个项目都需要有许可说明，包含：是否可以引用、是否允许修改、是否允许商用等。目前的开源许可证有非常多种，每个许可证都是一份使用这个开源项目需要遵守的协议，而主流的开源许可证在 OSI 组织（开放源代码促进会）都有 <a href="https://opensource.org/licenses">登记</a> 。<strong>最主流的开源许可证有 6 种：Apache、BSD、GPL、LGPL、MIT、Mozillia</strong>。</p><!-- [[[read_end]]] --><p>BSD 许可证、MIT 许可证和 Apache 许可证属于三个比较宽松的许可，都允许对源代码进行修改，且可以在闭源软件中使用，区别在于对新的修改，是否必须使用原先的许可证格式，以及修改后的软件是否能以原软件的名义进行销售等。</p><p>我们这里重点讲一下 Gin 框架使用的 <a href="https://github.com/gin-gonic/gin/blob/master/LICENSE">MIT开源许可证</a> ，这个许可证内容非常简单，对使用者的要求也最低。</p><ul>\n<li>允许被许可人使用、复制、修改、合并、出版发行、散布、再许可、售卖软件及软件副本。</li>\n<li>唯一条件是在软件和软件副本中必须包含著作权声明和本许可声明。</li>\n</ul><p>所以如果软件用的是MIT许可证，不管你开发的项目是开源的，还是商业闭源的，都可以放心使用这个软件，<strong>只需要在软件中包含著作权声明和许可协议声明就行，且不要求新的文件必须使用 MIT 协议</strong>。</p><p>以使用了 MIT 协议的 Gin 框架为例，你可以在新项目中以引用或者复制的形式，使用 Gin 框架，也允许你在复制的 Gin 框架中进行修改，修改可以不用注明 Gin 的版权，但是非修改部分是需要包含版权声明的。</p><p>所以，如果我们使用复制形式使用 Gin 框架的话，需要在 Gin 框架每个文件的头部，增加上著作权和许可声明：</p><pre><code class="language-go">// Copyright 2014 Manu Martinez-Almeida.&nbsp; All rights reserved.\n// Use of this source code is governed by a MIT style\n// license that can be found in the LICENSE file.\n</code></pre><h2>如何将 Gin 迁移进入我们的框架</h2><p>明确了 Gin 是允许被复制、修改和合并进入我们的框架，我们就可以开始规划迁移的具体方案了。</p><p>首先确定 Gin 的迁移版本，截止到目前（2021 年 8 月 14 日）最新的 Gin 版本为 1.7.3，所以我们将 Gin 的版本确定为 <a href="https://github.com/gin-gonic/gin/releases/tag/v1.7.3">1.7.3</a> 。</p><p>在 Golang 中，要在一个项目中引入另外一个项目，一般有两种做法，一种做法是<strong>把要引用的项目通过 go mod 引入到目标库中</strong>，而另外一种做法则费劲的多，<strong>使用复制源码的方式引入要引用的项目</strong>。</p><p>go mod 是 Go 官方提供的第三方库管理工具。go mod 的使用方式是在代码方面，也就是在你要使用第三方库功能的时候，使用 import 关键字进行引用。它的好处是简单方便，我们直接使用官方提供的 go get 方法，就能将某个框架进行使用和升级。</p><p>但是如果希望对第三方库进行源码级别的修改，go mod 的方式就会受到限制了。比如我们使用了 Gin 项目，想扩展项目中的 Context 这个结构，为其增加一个函数方法 A，这个需求用 go mod 的方式是做不到的。</p><p>go mod 的方式提倡的是“使用第三方库”而不是“定制第三方库”。所以<strong>对于很强的定制第三方库的需求，我们只能选择复制源码的方式</strong>。</p><p>有的同学可能会觉得这种源码复制的方式有点奇怪，但是这种复制出来，再进行定制化的方式，其实在一些项目中是常常可以见到的。</p><p>比如 Gin 框架在使用 httprouter 的时候，由于要对其进行深度定制化和优化，所以直接将 httprouter 的代码以复制的方式引入到自己的项目中；上一讲简单提过，比较成功的开源项目 <a href="https://github.com/go-macaron/macaron">macaron</a> ，在项目的最初期也是参考另外一个项目 <a href="https://github.com/go-martini/martini">martini</a> ，将 martini 中的一些源码拷贝后进行优化。我们还能在这两个项目的某些代码文件中看到对第三方库的版权申明。</p><p>由于我们对Gin框架有深度定制改造的需求，所以接下来也采用源码复制的方式引入Gin框架。首先将Gin1.7.3的源码完整复制进入项目，存放在framework目录中创建一个gin目录。<br>\n<img src="https://static001.geekbang.org/resource/image/e0/3a/e0ae3bba9e6775d407893969eb26253a.png?wh=1084x962" alt=""></p><p>复制之后需要做两步操作：</p><ul>\n<li>将Gin目录下的go.mod的内容放在项目目录下</li>\n</ul><p>既然我们以复制源码的方式引入了Gin，那么Gin的地址就成为我们项目中的一部分，它就不是一个有go.mod的第三方库了，而Gin原本引入的第三方库，成为了我们项目所需要的第三方库。所以第一步需要将Gin目录下的go.mod和go.sum删除，并且将go.mod的内容复制到项目的根目录中。</p><ul>\n<li>将Gin中原有Gin库的引用地址，统一替换为当前项目的地址</li>\n</ul><p>go.mod中的module代表了当前项目的模块名称，而在项目的go.mod中，我们将我们这个框架的模块名称从“coredemo”修改为“github.com/gohade/hade”。在项目的go.mod文件：</p><pre><code class="language-go">module github.com/gohade/hade\n\ngo 1.15\n\nrequire (\n   ...\n)\n\n</code></pre><p>其实这个module并不一定是GitHub上的一个项目地址，也可以自己定义的，我们之前用的coredemo就是一个自定义的字符串。但是开源项目的普遍做法是，将模块名定义为你的开源地址名称，这样能让开源项目使用者在导入包的时候，直接根据模块名查找到对应文件。</p><p>所有第三方引用在查询时，go.mod中的当前模块名称为github.com/gohade/hade，那么复制过来之后，对应的Gin框架的引用地址就是github.com/gohade/hade/framework/gin，而Gin框架之前go.mod中的模块名称为github.com/gin-gonic/gin。</p><p>所以我们这里<strong>要做一次统一替换</strong>，将之前Gin框架中的所有引用github.com/gin-gonic/gin的地方替换为github.com/gohade/hade/framework/gin。</p><p>比如：</p><pre><code class="language-plain">"github.com/gin-gonic/gin/binding"  替换为 "github.com/gohade/hade/framework/gin/binding"\n"github.com/gin-gonic/gin/render"  替换为 "github.com/gohade/hade/framework/gin/render"\n</code></pre><p>这里就要借用IDE的强大替换工具了，进行一次批量替换。</p><p>做完上述两步的操作之后，我们的项目github.com/gohade/hade就包含了Gin 1.3.7了。下面就是重头戏了，需要思考如何将之前研发的定制化功能迁移到Gin上。</p><h2>如何迁移</h2><p>首先，梳理下目前已经实现的模块：</p><ul>\n<li>Context：请求控制器，控制每个请求的超时等逻辑；</li>\n<li>路由：让请求更快寻找目标函数，并且支持通配符、分组等方式制定路由规则；</li>\n<li>中间件：能将通用逻辑转化为中间件，并串联中间件实现业务逻辑；</li>\n<li>封装：提供易用的逻辑，把 request 和 response 封装在 Context 结构中；</li>\n<li>重启：实现优雅关闭机制，让服务可以重启。</li>\n</ul><p>在 Gin 的框架中，Context、路由、中间件，都已经有了 Gin 自己的实现，而且我们从源码上分析了细节。</p><p>Context方面，Gin的实现基本和我们之前的实现是一致的。之前实现的Core数据结构对应Gin中的Engine，Group数据结构对应Gin的Group结构，Context数据结构对应Gin的Context数据结构。</p><p>路由方面，Gin的路由实现得比我们要好，这一点上一节课详细分析了Gin路由就不再赘述。</p><p>中间件方面，Gin的中间件实现和我们之前的没有什么太大的差别，只有一点，我们定义的Handler为：</p><pre><code class="language-plain">type ControllerHandler func(c *Context) error\n</code></pre><p>而Gin定义的Handler为：</p><pre><code class="language-plain">type HandlerFunc func(*Context)\n</code></pre><p>可以看到相比Gin，我们多定义了一个error返回值。因为Gin的作者认为，中断一个请求返回一个error并没有什么用，<strong>他希望中断一个请求的时候直接操作Response</strong>，比如设置返回状态码、设置返回错误信息，而不希望用error来进行返回，所以框架也不会用这个error来操作任何的返回信息。这一点我认为Gin框架的考量是有道理的，所以我们也沿用这种方式。<br>\n而对于 Request 和 Response 的封装， Gin 的实现比较简陋。Gin对Request并没有以接口的方式，将Request支持哪些接口展示出来；并且在参数查询的时候，返回类型并不多，比如从Form中获取参数的系列方法，Gin只实现了几个方法：</p><pre><code class="language-go">PostForm\nDefaultPostForm\nGetPostForm\nPostFormArray\nGetPostFormArray\nPostFormMap\nGetPostFormMap\n</code></pre><p>但是在我们定义的Request中，我们实现了按照不同类型获取参数的方法。</p><pre><code class="language-go">// form表单中带的参数\nDefaultFormInt(key string, def int) (int, bool)\nDefaultFormInt64(key string, def int64) (int64, bool)\nDefaultFormFloat64(key string, def float64) (float64, bool)\nDefaultFormFloat32(key string, def float32) (float32, bool)\nDefaultFormBool(key string, def bool) (bool, bool)\nDefaultFormString(key string, def string) (string, bool)\nDefaultFormStringSlice(key string, def []string) ([]string, bool)\nDefaultFormFile(key string) (*multipart.FileHeader, error)\nDefaultForm(key string) interface{}\n</code></pre><p>而且在Response中，我们的设计是带有链式调用方法的，而Gin中没有。</p><pre><code class="language-plain">c.SetOkStatus().Json("ok, UserLoginController: " + foo)\n</code></pre><p>这两点在使用者使用框架开发具体业务的时候会非常便利，所以我们将这些功能集成到Gin中，迁移这部分Request和Response的封装。</p><p>最后一个优雅关闭的逻辑，我们和Gin都是直接使用 HTTP 库的 server.Shutdown 实现的，不受 Gin 代码迁移的影响。</p><p>所以再明确下，context、路由、中间件、重启机制，我们都不需要迁移，唯一需要迁移的是对Request和Response的封装。</p><h3>使用加法最小化和定制化我们的需求</h3><p>对于 request 和 response 的封装，涉及易用性，我们希望能保留自己的定制化需求，同时又不希望影响 Gin 原有的代码逻辑。所以，可以用<strong>加法最小化的方式</strong>迁移这个封装。</p><p>为了尽量不侵入原有的文件，我们创建两个新的文件 hade_request.go、hade_response.go 来存放之前对request和response的封装。</p><p>回顾下第五节课封装的request，定义的IRequest接口包含：通过地址URL获取参数的QueryXXX系列接口、通过路由匹配获取参数的ParamXXX系列接口、通过Form表单获取参数的FormXXX系列接口，以及一些基础接口。</p><p><strong>所以现在的目标是，要让Gin框架的Context也实现这些接口</strong>。对比之前写的和Gin框架原有的实现方法，可以发现，接口存在下列三种情况：</p><ol>\n<li>Gin框架中已经存在相同参数、相同返回值、相同接口名的接口</li>\n<li>Gin框架中不存在相同接口名的接口</li>\n<li>Gin框架中存在相同接口名，但是不同返回值的接口</li>\n</ol><p>第一种情况，由于Gin框架原先就已经有了相同的接口，所以不需要做任何迁移动作，Gin的Context就已经具备了我们设计的封装。对第二种情况来说，由于Gin框架没有对应接口，我们把之前实现的接口原封不动迁移过来即可。</p><p>对于第三种情况则棘手一些。以Gin中已经有的QueryXXX系列接口为例，它的QueryXXX系列接口和我们想要的有一定差别，比如它的Query不支持多种数据类型的直接获取。怎么办？</p><p><strong>可以选择将QueryXXX系列接口重新命名</strong>，又因为Query接口都带有一个默认值，所以我们将其重新命名为DefaultQueryXXX。</p><p>经过上述三种情况的修改，IRequest的定义修改为(在框架目录的framework/gin/hade_request.go中)：</p><pre><code class="language-go">// 代表请求包含的方法\ntype IRequest interface {\n\n\t// 请求地址url中带的参数\n\t// 形如: foo.com?a=1&amp;b=bar&amp;c[]=bar\n\tDefaultQueryInt(key string, def int) (int, bool)\n\tDefaultQueryInt64(key string, def int64) (int64, bool)\n\tDefaultQueryFloat64(key string, def float64) (float64, bool)\n\tDefaultQueryFloat32(key string, def float32) (float32, bool)\n\tDefaultQueryBool(key string, def bool) (bool, bool)\n\tDefaultQueryString(key string, def string) (string, bool)\n\tDefaultQueryStringSlice(key string, def []string) ([]string, bool)\n\n\t// 路由匹配中带的参数\n\t// 形如 /book/:id\n\tDefaultParamInt(key string, def int) (int, bool)\n\tDefaultParamInt64(key string, def int64) (int64, bool)\n\tDefaultParamFloat64(key string, def float64) (float64, bool)\n\tDefaultParamFloat32(key string, def float32) (float32, bool)\n\tDefaultParamBool(key string, def bool) (bool, bool)\n\tDefaultParamString(key string, def string) (string, bool)\n\tDefaultParam(key string) interface{}\n\n\t// form表单中带的参数\n\tDefaultFormInt(key string, def int) (int, bool)\n\tDefaultFormInt64(key string, def int64) (int64, bool)\n\tDefaultFormFloat64(key string, def float64) (float64, bool)\n\tDefaultFormFloat32(key string, def float32) (float32, bool)\n\tDefaultFormBool(key string, def bool) (bool, bool)\n\tDefaultFormString(key string, def string) (string, bool)\n\tDefaultFormStringSlice(key string, def []string) ([]string, bool)\n\tDefaultFormFile(key string) (*multipart.FileHeader, error)\n\tDefaultForm(key string) interface{}\n\n\t// json body\n\tBindJson(obj interface{}) error\n\n\t// xml body\n\tBindXml(obj interface{}) error\n\n\t// 其他格式\n\tGetRawData() ([]byte, error)\n\n\t// 基础信息\n\tUri() string\n\tMethod() string\n\tHost() string\n\tClientIp() string\n\n\t// header\n\tHeaders() map[string]string\n\tHeader(key string) (string, bool)\n\n\t// cookie\n\tCookies() map[string]string\n\tCookie(key string) (string, bool)\n}\n</code></pre><p>IRequest的封装就迁移完成了，对于我们封装的IResponse结构，也是同样的思路。</p><p>和Gin的response实现对比之后，我们发现由于设计了一个链式调用，很多方法的返回值使用 IResponse 接口本身，所以大部分定义的IResponse的接口，在Gin中都有同样接口名，但是返回值不同。所以我们可以用同样的方式来修改接口名。</p><p>因为大都返回IResponse接口，那么可以在所有接口名前面，加一个I字母作为区分。在 framework/gin/hade_response.go中：</p><pre><code class="language-go">// IResponse代表返回方法\ntype IResponse interface {\n\t// Json输出\n\tIJson(obj interface{}) IResponse\n\n\t// Jsonp输出\n\tIJsonp(obj interface{}) IResponse\n\n\t//xml输出\n\tIXml(obj interface{}) IResponse\n\n\t// html输出\n\tIHtml(template string, obj interface{}) IResponse\n\n\t// string\n\tIText(format string, values ...interface{}) IResponse\n\n\t// 重定向\n\tIRedirect(path string) IResponse\n\n\t// header\n\tISetHeader(key string, val string) IResponse\n\n\t// Cookie\n\tISetCookie(key string, val string, maxAge int, path, domain string, secure, httpOnly bool) IResponse\n\n\t// 设置状态码\n\tISetStatus(code int) IResponse\n\n\t// 设置200状态\n\tISetOkStatus() IResponse\n}\n</code></pre><p>现在 IRequest 和 IResponse 接口的修改已经完成了。</p><p>下面我们就应该迁移每个接口的具体实现。这里接口的实现比较多，就不一一赘述，Request和Response我们分别举其中一个接口例子进行说明，其他的接口迁移可以具体参考GitHub仓库的<a href="https://github.com/gohade/coredemo/tree/geekbang/09">geekbang/09分支</a>。</p><p>在Request中我们定义了一个DefaultQueryInt方法，是Gin框架中没有的，怎么迁移这个接口呢？首先将之前定义的QueryInt迁移过来，并重新命名为 DefaultQueryInt。</p><pre><code class="language-go">// 获取请求地址中所有参数\nfunc (ctx *Context) QueryAll() map[string][]string {\n   if ctx.request != nil {\n      return map[string][]string(ctx.request.URL.Query())\n   }\n   return map[string][]string{}\n}\n\n// 获取Int类型的请求参数\nfunc (ctx *Context) DefaultQueryInt(key string, def int) (int, bool) {\n   params := ctx.QueryAll()\n   if vals, ok := params[key]; ok {\n      if len(vals) &gt; 0 {\n         // 使用cast库将string转换为Int\n         return cast.ToInt(vals[0]), true\n      }\n   }\n   return def, false\n}\n</code></pre><p>然后这里看QueryAll函数，其实是可以优化的。Gin框架在获取QueryAll的时候，使用了一个QueryCache，实现了在第一次获取参数的时候，用方法initQueryCache 将 ctx.request.URL.Query() 缓存在内存中。</p><p>所以既然已经源码引入Gin框架了，我们也是可以使用这个方法来优化QueryAll() 方法的，先调用initQueryCache，再直接从queryCache中返回参数：</p><pre><code class="language-go">// 获取请求地址中所有参数\nfunc (ctx *Context) QueryAll() map[string][]string {\n   ctx.initQueryCache()\n   return map[string][]string(ctx.queryCache)\n}\n</code></pre><p>这样QueryAll方法和DefaultQueryInt方法就都迁移改造完成了。</p><p>在Response中，我们没有需要优化的点，只要将代码迁移就行。比如原先定义的Jsonp方法：</p><pre><code class="language-go">// Jsonp输出\nfunc (ctx *Context) Jsonp(obj interface{}) IResponse {\n   ...\n}\n</code></pre><p>直接修改函数名为IJsonp即可：</p><pre><code class="language-go">// Jsonp输出\nfunc (ctx *Context) IJsonp(obj interface{}) IResponse {\n   ...\n}\n</code></pre><p>接口和实现都修改了，最后肯定还要对应修改下业务代码中之前定义的一些控制器。</p><p>第一个是控制器的参数，从framework.Context 修改为 gin.Context， 这里的gin是引用github.com/gohade/hade/framework/gin，还有把之前定义的Handler的error返回值删除。</p><p>第二个是修改里面的调用，因为现在的Response方法都带上了一个前缀I。比如在业务目录下subject_controller.go中，把原先的SubjectListController：</p><pre><code class="language-go">func SubjectListController(c *framework.Context) error {\n   c.SetOkStatus().Json("ok, SubjectListController")\n   return nil\n}\n</code></pre><p>修改为：</p><pre><code class="language-go">func SubjectListController(c *gin.Context) {\n   c.ISetOkStatus().IJson("ok, SubjectListController")\n}\n</code></pre><h2>验证</h2><p>所有修改完成之后，我们可以通过 test来进行验证，调用 <code>go test ./...</code> 来运行Gin程序的所有测试用例，显示成功则表示我们的迁移成功。<br>\n<img src="https://static001.geekbang.org/resource/image/85/30/85832f31e6835617b804239de53cd430.png?wh=1630x378" alt=""></p><p>并且我们通过  <code>go build &amp;&amp; ./hade</code> 可以看到熟悉的gin调试模式的输出：<br>\n<img src="https://static001.geekbang.org/resource/image/c3/55/c3f631feba724cc00f51033801480d55.png?wh=1378x542" alt=""></p><h2>小结</h2><p>今天我们讨论几个开源项目的许可协议，比如Gin 框架使用的 MIT 协议，在明确修改权限后，我们将Gin框架迁移进自己手写的hade框架，替换前面开发的Context、路由等模块，为后续拓展做好准备。</p><p>在迁移的过程中，我们选择使用复制源码的方式进行替换，并且用了加法最小化的方法，尽量保留了我们的定制化接口。可能有的同学会觉得这种方式比较暴力，但是后续随着我们对框架的改造需求不断增加，这种方式会越来越体现出其优势。</p><h3>思考题</h3><p>我们的hade框架也希望用MIT协议进行开源，你知道如何改造来将它开源么？</p><p>欢迎在留言区分享你的思考。感谢你的收听，如果你觉得有收获，也欢迎你把今天的内容分享给你身边的朋友，邀他一起学习。我们下节课见。</p>',
        article_title: "09｜自研or借力（下）：集成Gin替换已有核心",
      },
      {
        title: "加餐｜国庆特别放送：什么是业务架构，什么是基础架构？",
        id: 423931,
        content:
          '<p>你好，我是轩脉刃。</p><p>相信你的公司一定有架构师这么一级岗位，但是肯定不只一个，而且岗位要求还各不相同，有的岗位要求熟悉Linux底层原理，有的岗位要求对业务有较强的敏感度。不知道你对这些岗位真实的需求有什么了解？为什么同样叫架构师有这么大的差异呢？职业发展方向有什么差异呢？今天我们就聊聊这个话题。</p><h2>架构和开发</h2><p>想要了解架构师之间的区别，首先得对架构师的工作内容有了解，所以我们先对比一线开发，看看架构师的价值核心是什么。</p><p>所谓架构，和一线开发最大的区别就在于是否有系统设计工作。</p><p><strong>一线开发的工作内容是在获取到一个细分需求后，思考如何用代码实现这个细分需求</strong>。如果是初级开发工程师，拿到手的甚至可能是一个已经定义好接口和交互的技术方案，要做的事情就是往这个技术方案中填充内容，让一个功能可以如期运行。</p><p>如果职别高一点，是高级开发工程师，工作要求会比简单实现功能更复杂，因为拿到手的是一个功能需求，往往需要进行技术方案设计，梳理拆分成一个个小的功能需求点，然后将功能需求实现出来。不过仍然是以编码实现为主。</p><p>而架构师的工作价值已经不是体现在编码实现上，而更多是体现在设计上。</p><p>架构师面对的是系统，这个系统或大或小，可能是一个复杂功能模块、一个复杂业务，也可能是一个公司级别的基础服务，<strong>但都有一个特点，就是比较庞大和复杂</strong>。如何将这个庞大又复杂的系统清晰地分层、如何设计流程、如何拆分子系统、每个子系统负责什么、难点系统的技术应该选择什么技术，这就是架构师最大的价值体现。</p><!-- [[[read_end]]] --><h2>基础架构和业务架构</h2><p>虽然工作内容类似，但各个公司在架构师岗位上的称谓多种多样，比如云平台架构师、研发架构师、数据安全架构师、系统架构师等等，但是不管怎么起称谓，架构师的本质就是两种：基础架构和业务架构。</p><p>基础架构师，主要负责的是对基础服务的架构设计。<strong>所谓基础服务，就是和业务无关，基本上所有业务都会使用到的服务</strong>，比如数据库、缓存、队列等。</p><p>这些基础服务的重要性毋庸置疑，它的稳定性往往决定着整个公司的业务稳定性。试想一下，如果你的公司数据库出现不可用，是不是所有的业务线都会受到影响呢？而基础架构做的事情就是设计出合理的一套技术方案，来保证这些基础服务的可用性和稳定性。</p><p>业务架构师，主要负责的是业务服务的技术方案设计。你应该听说过这么一句话，技术是为业务服务的。是的，技术最终的价值就体现在业务实现上，<strong>而业务架构师，核心作用就是让技术更好地服务业务</strong>。</p><p>在过去的工作中，我更多承担的是业务架构师的职责，所以对于这个岗位也可以再聊聊我自己的想法，给你一些职业发展的参考。</p><h4>你的技术服务什么业务</h4><p>作为业务架构师，我觉得首先要清楚的是，你的技术是服务什么业务的。每个业务都带有行业属性，所以业务架构师的一个必要条件是了解你当前负责业务的行业。这里面不限于行业的技术发展趋势、竞品对手的动向，以及自己产品的后续发展方向。</p><p>有的人可能觉得这个没有什么必要。但是这点其实非常关键，最明显的体现就在技术选型上。<strong>因为实现一个功能的方法有很多种，但是最符合我们自身业务的技术选型才是最优的</strong>。</p><p>以如何选型和设计数据库为例，在分层模型上是否要增加服务层、在模块划分上是否要单独增加某个模块服务，这些的设计都需要考虑到行业的需求。</p><p>之前在交通领域，我们要设计一个信号灯管理系统，就需要考虑到国内国外的信号灯行业标准、各个信号灯厂商的标准、后续是否可能有地理位置查询的需求等，才能设计出比较好的数据库方案。</p><h4>你的技术广度和深度如何</h4><p>其次，你需要有足够的技术广度。业务架构师在进行技术选型的时候，要从多种可行性方案里进行选择，如果你没有足够的技术广度，对各种技术的优缺点的了解度不够，那么你的视野本身就被局限在一定范围内，大概率会做出错误选择。</p><p>但是如果所有技术都只有浅层了解，也是不够的。以前有个总监在给我们做培训的时候说，<strong>技术人员最终的技术能力模型应该是一个大T字形，即在某个领域有足够的深度，而在多个领域有足够的广度</strong>。</p><p>因为各个技术领域，深入到底层逻辑都有很多相似的地方，也就是说如果你在特长领域的钻研越深，想横向扩展技术广度也会越容易。这一点我一直铭记于心，也分享给你。</p><h4>业务架构师和一线</h4><p>最后我觉得非常重要的一点，业务架构师一定不能脱离一线。</p><p>如果不是在一线长期摸爬滚打过来，很难有接地气的设计。而在实现阶段，如果不时刻关注代码的质量，进行足够的代码检查，实现是有极大可能偏离设计的。</p><p>这种因为设计脱离一线，导致系统出现问题的例子真是比比皆是，你在实际工作中一定也遇到过不少。在工作过程中遇到了不合理的现象，其实都可以考虑是否是设计出现了问题，比如微服务过度导致两个人维护多个业务。</p><p>所以说，业务架构师不可能长时间脱离一线，否则就根本没有办法把控整个设计以及设计的落地实现了。</p><p>我可以分享一个我自己的习惯。<strong>不管你能力有多强，接手或者到了新的一个业务中，前面3个月尽量不要做大的架构级别的修改</strong>，因为不深度了解业务，没有足够时间了解一线的代码逻辑，是不可能做出好的架构调整的。</p><h2>职业发展方向</h2><p>刚才从工作内容的角度聊了聊基础架构和业务架构的区别，我觉得可以从职业选择的角度再谈谈这两个架构在之后发展方向的区别，毕竟在现在或者今后的某个时间，你在职场中一定会遇到这两个方向的职业选择问题。</p><p>不管你愿意从事基础架构还是业务架构，两者都是有淘汰周期的，都需要进行技术更新。这个是首先要说清楚的。所以如果你抱着哪个岗位更稳定的想法做选择，就不太靠谱了。</p><p>基础架构虽然听名字是底层，仍然有可能被淘汰。比如云和微服务的出现，对于之前的服务器运维方向的基础架构工作是一个很大的打击，现在的基础运维很多都新加了服务编排等工作。</p><p>而业务架构的更新淘汰更是常事，或许你在某个行业深耕多年，但由于各种政策原因，大行业都变化了，想不被淘汰，你的行业知识就必须重新补充了。</p><p>总而言之，你需要明白的是，没有什么会是一成不变的，只有不断更新自己，才可能跟上变化。清楚这一点，我们再继续聊。</p><p>基础架构的同学更大可能是往技术专家方向发展。他们<strong>对技术的成就感更多来源于为某个软件或者某种语言增加了特性</strong>，比如会追求成为Apache PMC、微软的MVP等，他们的研究是有可能改变某个技术行业的。所以如果你想走这个方向，必须有热衷于某个技术行业的觉悟。</p><p>而业务架构的同学更多可能是往业务管理方向发展，他们对技术的成就感更多来源于<strong>创造出某个比较流行的产品</strong>。比如有的业务架构同学就希望在教育行业有所发展，能设计并实现出改变教育行业的产品。</p><p>两种职业发展方向并没有优劣之分，而且不管哪个方向做到顶尖的人都是市场上非常稀缺的人。你在做职业选择的时候，更多的是要看清楚自己的兴趣所在，只有把自己的兴趣和工作相匹配，你的职业生涯才比较快乐。</p><h2>系统架构</h2><p>聊了那么多道理，最后再讨论一下做架构在术上的东西，希望能给你现在或者之后的工作一些参考。</p><p>这里我推荐一本书《系统架构-复杂系统的产品设计与开发》，作者 Edward Crawley 是麻省理工学院航空航天学位以及工程系统学的教授。之前说过，架构师的工作就是把一个复杂的系统进行拆分设计，这本书告诉带给读者的，就是如何做的一套思考并创建系统架构的方式，即一些思考系统的原则和定律。</p><p>我看完受益匪浅，这里也分享我认为非常有启发的几点。</p><blockquote>\n<p>歧义原则：系统架构的早期阶段充满了歧义。架构师必须解决这种歧义，以便给架构团队定出目标，并持续更新该目标。<br>\n架构师角色原则：架构师的角色是解决歧义，专注创新，并简化复杂度。</p>\n</blockquote><p>系统在初期的时候，最大的问题其实是充满了歧义，由于系统设计未成型，所有人对一个系统的理解大不相同，所以在沟通交流的时候是有很多歧义的。而<strong>架构师必须解决这种歧义</strong>，将所有人对系统的认知先统一起来，为整个架构的设计定出目标，并且不断更新团队认知，减少歧义，持续更新目标。</p><blockquote>\n<p>架构决策原则：我们要把架构决策和其他决策分开，并且要提前花一些时间来谨慎地决定这些问题，因为以后如果要想变更会付出很大的代价。</p>\n</blockquote><p>架构师在系统设计的时候会有很多决策要做，非常重要的一点，你需要<strong>区分架构决策和其他决策，而且必须提前花时间来决定，是否需要考虑这些架构之外的决策</strong>。</p><p>比如我们做架构设计的时候，是否要考虑团队的技术能力结构。以音视频业务的语言技术决策为例，目前这个领域最成熟的语言还是CPP，那么不管团队的技术能力结构如何，可能你就只能在架构上选择这个语言了。</p><p>而这个决策一旦做下去了，后续的影响可是非常大的，可能会导致整个团队的人员替换、整个业务的重构等。后期要想改变，会付出很大的代价。</p><blockquote>\n<p>Conway定律：设计系统的组织，总是会产生出与该组织的沟通结构相同的设计。</p>\n</blockquote><p>还有一个我读了之后想明白很多事情原理的 Conway定律。不知道你接手一个新的业务的时候，是不是会很唾弃，为什么这里这么设计、为什么这个地方需要拆分服务。这个定律就是告诉我们，其实<strong>在设计的时候，<strong><strong>我们</strong></strong>会很倾向于把系统设计的符合当时的组织结构</strong>。</p><p>比如用户这个信息，如果组织结构分为两个部门，一个部门负责乘客，另一个负责司机，那么服务就会很自然至少分为乘客服务和司机服务。但是司机和乘客实际上都是自然人抽象出来的模型，在只有一个司乘人员的部门中，可能就只会分为一个服务了。</p><p>了解这个定律以后，每次在接手新业务的时候，我都会去了解一下当时这个业务所在的人员组织结构，有时候对业务的架构会有更深刻的了解。</p><blockquote>\n<p>产品进化原则：系统必须进化，否则就会失去竞争力。<br>\n2下1上原则：要想判断出对level1所做的分解是否合适，必须再向下分解一层，以确定level2中的各种关系。</p>\n</blockquote><p>书的内容很多，更多的内容需要你自行阅读。还记得第一节课使用思维导图来读取源码的技巧吗？其实我们也可以使用思维导图来读一本书。</p><p>这里附带上我读这本书时制作的思维导图，你也可以边看这本书，边对照参考。也附带上我之前在组内分享这本书的时候制作的PPT，都放在项目GitHub上的<a href="https://github.com/gohade/coredemo/tree/geekbang/national_day">geekbang/natinal_day</a>分支上了，希望你能从中受益。</p><h2>小结</h2><p>今天咱们聊了基础架构和业务架构工作内容和职业发展的区别，相信你对这两个职位和如何设计系统架构有了更深的了解了。</p><p>你在过去的工作经历中，经历过哪些系统架构方面的问题，或者有过哪些系统架构的经验呢？欢迎在留言区分享你的思考和经历，我们下节课见～</p>',
        article_title: "加餐｜国庆特别放送：什么是业务架构，什么是基础架构？",
      },
      {
        title: "加餐｜阶段答疑：这些代码里的小知识点你都知道吗？",
        id: 423976,
        content:
          '<p>你好，我是轩脉刃。</p><p>上节课国庆特别放送，我们围绕业务架构和基础架构，聊了聊这两种方向在工作上以及在后续发展上的区别，也讲了做系统架构设计的一些术。今天就回归课程，特别整理了关于课程的五个共性问题来解答一下。</p><h2>Q1、GitHub分支代码跑不起来怎么办？</h2><p>GitHub 中的每个分支代码都是可以跑起来的，我本人亲测过了。出现这个问题，可能是因为有的同学只使用go run main.go。</p><p>go run main.go 只会运行编译运行的指定文件，而一旦当前目录下有其他文件，就不会运行到了，所以比如在geekbang/02 或者 geekbang/03 分支中，根目录下有其他文件，就不能运行了。<strong>你需要使用 go build 先编译，然后使用./coredemo来运行</strong>。</p><p>另外因为最近Go版本更新了，有同学问到这个问题：go mod 能指定 1.xx.x 版本么？比如想要把 go.mod 中指定 go 版本的go 1.17&nbsp;修改为go 1.17.1，希望我的项目最低要求 1.17.1。但是 Goland 老是把版本号修改回&nbsp;go 1.17，是不是我哪里设置有问题？</p><p>这是一个小知识点，不过估计不是每个人都知道。其实这里不是设置有问题，而是 go.mod 要求就是如此。</p><p>指定 go 版本的地方叫 go directive 。它的格式是：</p><!-- [[[read_end]]] --><pre><code class="language-go">GoDirective = "go" GoVersion newline .\nGoVersion = string | ident .  /* valid release version; see above */\nThe version must be a valid Go release version: a positive integer followed by a dot and a non-negative integer (for example, 1.9, 1.14).\n</code></pre><p>其中所谓的 valid release version 为必须是像 1.17 这样，前面是一个点，前面是正整数（其实现在也只能是 1），后面是非负整数。<br>\ngo 的版本形如 1.2.3-pre。</p><p>一般最多由两个点组成，其中 1 叫做 major version，主版本，非常大的改动的时候才会升级这个版本。而 2 叫做 minor version，表示有一些接口级别的增加，但是会保证向后兼容，才会升级这个版本。而 3 叫做 patch version，顾名思义，一些不影响接口，但是打了一些补丁和修复的版本。</p><p>而最后的 pre 叫做 pre-release suffix。可以理解是和 beta 版本一样的概念，在 release 版本出现之前，预先投放在市场的试用版本。</p><p>所以<strong> go mod 中的格式只能允许 major version 和 minor version</strong>。它认为，使用者关注这两个版本号就行，这样能保证使用者在使用 golang 标准库的时候，源码接口并没有增加和修改，不管你使用什么 patch version，你的业务代码都能跑起来。</p><h2>Q2、思维导图怎么画？</h2><p>从第一节课讲Go标准库的源码开始，我们就频繁用到思维导图的方法。这个方法非常好用，特别是复杂的逻辑跳转，画完图之后也就对逻辑基本了解了。当时建议课后你也自己做一下，留言区有同学画了自己的思维导图非常棒，逻辑是正确的。</p><p>但是在画图的过程中，我们会出现新的问题，尤其是基础不那么扎实的同学，在不能一眼看出来每行代码都是干什么的，比如可能过多关注分支细节，不知道才能更好地剥离出主逻辑代码。</p><p>那怎么才能快速分辨什么是主线、什么是细节呢？</p><p>我提供一个思路，在使用思维导图的时候，对于比较复杂的逻辑，我们要<strong>在头脑中模拟一下，要实现这个逻辑，哪些是关键步骤，然后用寻找这些关键步骤的方法来去源码中阅读</strong>。</p><p>比如FileServer，是用来实现静态文件服务器的，首先我们先在头脑中有个模拟，我要先对接上ServerHTTP方法，然后要把判断请求路径，要是请求的是文件，那么我就把文件内容拷贝到请求输出中不就行了么。</p><p>那么是不是这样的呢，我们带着这种模拟查看代码就能找到代码的关键点有两个。</p><p>一是fileHandler，我们能和ListenAndServe 连接起来，它提供了ServeHTTP的方法， 这个是请求处理的入口函数：</p><pre><code class="language-go">// 返回了fileHandler方法\nfunc FileServer(root FileSystem) Handler {\n   return &amp;fileHandler{root}\n}\n\nfunc (f *fileHandler) ServeHTTP(w ResponseWriter, r *Request) {\n   // 请求的入口\n   serveFile(w, r, f.root, path.Clean(upath), true)\n}\n</code></pre><p>二是 FileServer 最本质的函数，封装了io.CopyN，基本逻辑是：如果是读取文件夹，就遍历文件夹内所有文件，把文件名直接输出返回值；如果是读取文件，就设置文件的阅读指针，使用io.CopyN读取文件内容输出返回值。这里如果需要多次读取文件，创建Goroutine，并为每个Goroutine创建阅读指针。</p><pre><code class="language-go">func serveFile(w ResponseWriter, r *Request, fs FileSystem, name string, redirect bool) {\n   ...\n   serveContent(w, r, d.Name(), d.ModTime(), sizeFunc, f)\n}\n\nfunc serveContent(w ResponseWriter, r *Request, name string, modtime time.Time, sizeFunc func() (int64, error), content io.ReadSeeker) {\n   ...\n   if size &gt;= 0 {\n   ranges, err := parseRange(rangeReq, size)\n   ...\n      switch {\n      case len(ranges) == 1:\n          ...\n         ra := ranges[0]\n         if _, err := content.Seek(ra.start, io.SeekStart); err != nil {\n            Error(w, err.Error(), StatusRequestedRangeNotSatisfiable)\n            return\n         }\n         sendSize = ra.length\n         code = StatusPartialContent\n         w.Header().Set("Content-Range", ra.contentRange(size))\n      case len(ranges) &gt; 1:\n         ...\n         go func() {\n            for _, ra := range ranges {\n               part, err := mw.CreatePart(ra.mimeHeader(ctype, size))\n               ...\n               if _, err := content.Seek(ra.start, io.SeekStart); err != nil {\n                  pw.CloseWithError(err)\n                  return\n               }\n               if _, err := io.CopyN(part, content, ra.length); err != nil {\n                  pw.CloseWithError(err)\n                  return\n               }\n            }\n            mw.Close()\n            pw.Close()\n         }()\n      }\n      ...\n   }\n   w.WriteHeader(code)\n   if r.Method != "HEAD" {\n      io.CopyN(w, sendContent, sendSize)\n   }\n}\n</code></pre><p>按照这种先模拟步骤再去对比源码寻找的方式，很好用，即使你的模拟步骤出了问题，也会引导你思考，为什么出了问题？哪里出了问题，促使你更仔细地查看源码。不妨试试。</p><h2>Q3、http.Server源码为什么是两层循环？</h2><p>第一节课用思维导图分析了一下http.Server的源码，有同学问了这么一个问题：go&nbsp;c.serve(connCtx)&nbsp;里面为什么还有一个循环？c指的是一个connection，我理解不是每个连接处理一次就好了吗，为啥还有一个for循环呢？</p><p>这里其实有一个扩展知识， HTTP 的keep-alive机制。</p><p><strong>HTTP层有个keep-alive，它主要是用于客户端告诉服务端，这个连接我还会继续使用，在使用完之后不要关闭</strong>。这个设置会影响Web服务的哪几个方面呢？</p><ul>\n<li>性能</li>\n</ul><p>这个设置首先会在性能上对客户端和服务器端性能上有一定的提升。很好理解的是，少了TCP的三次握手和四次挥手，第二次传递数据就可以通过前一个连接，直接进行数据交互了。当然会提升服务性能了。</p><ul>\n<li>服务器TIME_WAIT的时间</li>\n</ul><p>由于HTTP服务的发起方一般都是浏览器，即客户端，但是先执行完逻辑，传输完数据的一定是服务端。那么一旦没有keep-alive机制，服务端在传送完数据之后，会率先发起连接断开的操作。</p><p>由于TCP的四次挥手机制，先发起连接断开的一方，会在连接断开之后进入到TIME_WAIT的状态，达到2MSL之久。</p><p>设想，如果没有开启HTTP的keep-alive，那么这个TIME_WAIT就会留在服务端，由于服务端资源是非常有限的，<strong>我们当然倾向于服务端不会同一时间hold住过多的连接，这种TIME_WAIT的状态应该尽量在客户端保持</strong>。那么这个HTTP的keep-alive机制就起到非常重要的作用了。</p><p>所以基于这两个原因，现在的浏览器发起Web请求的时候，都会带上connection:keep-alive的头了。</p><p>而我们的Go服务器，使用net/http 在启动服务的时候，则会按照当前主流浏览器的设置，默认开启keep-alive机制。服务端的意思就是，只要浏览器端发送的请求头里，要求我开启keep-alive，我就可以支持。</p><p>所以在源码这段服务一个连接的conn.server中，会看到有一个for循环，在这个循环中循环读取请求。</p><pre><code class="language-go">// 服务一个连接\nfunc&nbsp;(c&nbsp;*conn)&nbsp;serve(ctx&nbsp;context.Context)&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;c.remoteAddr&nbsp;=&nbsp;c.rwc.RemoteAddr().String()\n&nbsp;&nbsp;&nbsp;&nbsp;ctx&nbsp;=&nbsp;context.WithValue(ctx,&nbsp;LocalAddrContextKey,&nbsp;c.rwc.LocalAddr())\n\n&nbsp;&nbsp;&nbsp;&nbsp;...\n    // 循环读取，每次读取一次请求\n&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;w,&nbsp;err&nbsp;:=&nbsp;c.readRequest(ctx)\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...\n        // 判断开启keep-alive\n        if !w.conn.server.doKeepAlives() {\n           return\n        }\n        ...\n    }\n}\n</code></pre><p>那要关闭keep-alive怎么办呢？你也可以在for循环中的w.conn.server.doKeepAlives&nbsp;看到，</p><p>它判断如果服务端的&nbsp;disableKeepAlives&nbsp;不是0，则设置了关闭keep-alive，就不进行for循环了。</p><pre><code class="language-go">// 判断是否开启keep-alive\nfunc (s *Server) doKeepAlives() bool {\n    // 如果没开keep-alive，或者在shutdown过程中，就返回false\n   return atomic.LoadInt32(&amp;s.disableKeepAlives) == 0 &amp;&amp; !s.shuttingDown()\n}\n</code></pre><h2>Q5、为什么context 作为函数的第一个参数？</h2><p>context 作为第一个参数在实际工作中是非常有用的一个实践。不管是设计一个函数，还是设计一个结构体的方法或者服务，我们一旦养成了将第一个参数作为 context 的习惯，那么这个 context 在相互调用的时候，就会传递下去。这里会带来两大好处：</p><ol>\n<li>链路通用内容传递。</li>\n</ol><p>在context 中，是可以通过 WithValue 方法，将某些字段封装在 context 里面，并且传递的。最常见的字段是 traceId、spanId。而在日志中带上这些 ID，再将日志收集起来，我们就能进行分析了。这也是现在比较流行的全链路分析的原理。</p><ol start="2">\n<li>链路统一设置超时。</li>\n</ol><p>我们在定义一个服务的时候，将第一个参数固定设置为 context，就可以通过这个 context 进行超时设置，而这个超时设置，是由上游调用方来设置的，这样就形成了一个统一的超时设置机制。比如 A 设置了 5s 超时，自己使用了 1s，传递到下游 B 服务的时候，设置 B 的 context 超时时长为 4s。这样全链路超时传递下去，就能保持统一设置了。</p><h2>Q5、服务雪崩 case 有哪些？</h2><p>在第二节课中我们完成了添加 Context 为请求设置超时时间，提到超时很有可能造成雪崩，有同学问到相关问题，引发了我对服务雪崩场景的思考，这里我也简单总结一下。</p><p>雪崩的顾名思义，一个服务中断导致其他服务也中断，进而导致大片服务都中断。这里我们最常见的雪崩原因有下列几个：</p><ul>\n<li>超时设置不合理</li>\n</ul><p>服务雪崩最常见的就是<strong>下游服务没设置超时</strong>，导致上游服务不可用，也是我们设置 Context 的原因。<img src="https://static001.geekbang.org/resource/image/04/db/049079366831da0c849c65b4672744db.jpg?wh=1920x1080" alt=""></p><p>比如像上图的，A-&gt;B-&gt;C， C 的超时不合理，导致 B 请求不中止，而进而堆积，B 服务逐渐不可用，同理导致 A 服务也不可用。而在微服务盛行的链式结构中这种影响面会更大。<img src="https://static001.geekbang.org/resource/image/66/78/664ef442085a4b46f64c193b37649878.jpg?wh=1920x1080" alt=""></p><p>按照前面的分析，除了 G 之外，其他的节点都会收到波及。</p><ul>\n<li>重试加大流量</li>\n</ul><p>我们在下游调用的时候，经常会使用重试机制来防止网络抖动问题，但是<strong>重试机制一旦使用不合理</strong>，也有可能导致下游服务的不可用。</p><p>理论上，越下层的服务可承受的 QPS 应该越高。在微服务链路中，有某个下游服务的 QPS，比如上图中 C 的QPS没有预估正确，当正常请求量上来，C 先扛不住，而扛不住返回的错误码又会让上游服务不断增加重试机制，进一步加剧了下游服务的不可用，进而整个系统雪崩。</p><ul>\n<li>缓存雪崩</li>\n</ul><p>缓存雪崩顾名思义就是，<strong>原本应该打在缓存中的请求全部绕开缓存，打到了 DB</strong>，从而导致 DB 不可用，而 DB 作为一个下游服务节点，不可用会导致上游都出现雪崩效应（这里的 DB 也有可能是各种数据或者业务服务）。<img src="https://static001.geekbang.org/resource/image/b2/f8/b25dec592b78c1c0ef01bc90223fdcf8.jpg?wh=1920x1080" alt=""></p><p>为什么会出现缓存雪崩呢，我列了一下工作中经常遇到的缓存导致雪崩的原因，有如下三种：</p><p>1.被攻击</p><p>在平时写代码中我们日常使用这样的逻辑：“根据请求中的某个值建立 key 去缓存中获取，获取不到就去数据库中获取”。但是这种逻辑其实很容易被攻击者利用，攻击者<strong>只需要建立大量非合理的 key</strong>，就可以打穿缓存进入数据库进行请求。请求量只要足够大，就可以导致绕过缓存，让数据库不可用。</p><p>2.缓存瞬时失效</p><p>“通过第一个请求建立缓存，建立之后一段时间后失效”。这也是一个经常出现瞬时缓存雪崩的原因。因为有可能在第一次批量建立了缓存后，进行业务逻辑，而<strong>后续并没有更新缓存时长</strong>，那就可能导致批量在统一时间内缓存失效。缓存失效后大批量的请求会涌入后端数据库，导致数据库不可用。</p><p>3.缓存热 key</p><p>还有一种情况是缓存中的<strong>某个 key 突然有大批量的请求涌</strong>入，而缓存的分布式一般是按照 key 进行节点分布的。这样会导致某个缓存服务节点流量过于集中，不可用。而缓存节点不可用又会导致大批量的请求穿透缓存进入数据库，导致数据库不可用。</p><p>关于留言问题的回答，今天就暂时到这里了，之后也会收集做统一答疑。所以欢迎你继续留言给我。下节课见～</p>',
        article_title: "加餐｜阶段答疑：这些代码里的小知识点你都知道吗？",
      },
      {
        title: "10｜面向接口编程（上）：一切皆服务，服务基于协议",
        id: 424529,
        content:
          '<p>你好，我是轩脉刃。</p><p>在上一节课我们已经将 Gin 框架迁移到自己的 hade 框架中，但是如果 hade 框架只止步于 Gin 的已有功能：支持 Context、路由、中间件这些框架最简单的功能，显然背离了我们设计这个框架的初衷，毕竟我们的目标是搭建一个生产中可用且具有丰富功能模块的框架。</p><p>那么如何组织这些功能模块更好地协作，就是我们今天要讨论的问题。</p><p>组织的方法也很简单，之前提到过。如果你还记得我们第五课封装请求和返回结构的时候，先定义了 IRequest 和 IResponse 接口，再一一实现具体的函数方法，<strong>这种先接口后实现的方式，其实不仅仅是一种代码优化手段，更是一种编程思想：面向接口编程</strong>，这其实就是我们组织功能模块的核心思路。</p><h2>面向接口编程</h2><p>面向接口编程的思想到底是什么含义？我们从关键词“接口”开始思考。</p><p>不知道你考虑过这个问题没有，现在的高级语言，比如 PHP、Golang、Java 等，除了函数、对象等定义之外，都无一例外地拥有“接口”。但是为什么这些高级语言会需要有“接口”这个定义呢？我们从接口做到了什么的角度来反向思考。</p><h3>抽象业务</h3><p>首先，接口实现了对业务逻辑的抽象，设计接口就是抽象业务的过程。</p><p>因为在工作、生活中，我们需要把业务转换到代码中。但是一个真实的业务需求往往有很多复杂的描述，有些描述是某个业务特有的，而有些描述是所有同类型业务共有的，我们需要把描述的相同点抽象出来，成为一个个的步骤。而每个步骤实际上都是一个通过输入、产生输出的方法，把这些方法聚合起来，就是一个接口。</p><!-- [[[read_end]]] --><p>这段话说得有点抽象，我们结合一个具体例子来加深理解。在《面向接口设计（Interface Oriented Design）》这本书中，作者举了寻找一个 pizza 店并购买pizza的例子，很简单也便于理解，这里我们是为了明白接口实现了什么，所以就不再另外举例，直接看这个例子就好。</p><p>在找pizza店之前我们首先要知道pizza店是什么，所以先来定义一个pizza店，并且来寻找所有pizza店共性的地方。</p><p>作者发现购买 pizza 的流程基本都是相似的，先确认大小、再确认佐料、再确认收货地址、最后被告知送货时间，<strong>所以可以将“购买 pizza”这个业务逻辑，抽象成一个接口结构：PizzaOrdering</strong>。它包含四个方法：set_size、set_toppings、set_address、get_time_till_delivered。</p><ul>\n<li>set_size 的参数是一个枚举，代表 pizza 的预设大小；</li>\n<li>set_toppings 的输入是一个数组，代表不同的佐料；</li>\n<li>set_address 的输入是一个字符串，代表收货地址；</li>\n<li>get_time_till_delivered 的输入为空，但是输出为时间格式，代表预估的送货到达时间。<br>\n<img src="https://static001.geekbang.org/resource/image/05/ed/05d91d7cbdc8fc05f3a0a66032f419ed.jpg?wh=1920x1080" alt=""></li>\n</ul><p>所以“寻找 pizza 店”这个事情，也可以抽象成为一个接口：PizzaOrderingFinder。它实现的方法有三个，都返回对于pizza店的 PizzaOrdering 接口。</p><ul>\n<li><code>PizzaOrdering find_implementation_by_name(String name_of_pizza_shop)</code> 根据名字查询对应的 pizza 店；</li>\n<li><code>PizzaOrdering find_first_implementation()</code> 查找第一个 pizza 店；</li>\n<li><code>PizzaOrdering find_last_implementation()</code> 查找最后一个 pizza 店。</li>\n</ul><p>从上面这个例子我们可以看出，一个业务可以由一个或者多个接口组成。针对去 pizza 店预订 pizza 这个业务，我们定义了两个接口：寻找 pizza 店的接口、pizza 店的接口。</p><p>其中寻找 pizza 店的接口，它提供多种筛选能力，比如按名字查询、按正序/倒序第一查询；pizza 店的接口拥有四个能力，它们有自己的输入输出，这四个能力聚合组成了 pizza 店的抽象接口。</p><p>这就是一种业务抽象，用一个接口结构抽象可以购买 pizza 的店铺所具有的能力，用另外一个接口数据抽象查询 pizza 店铺的方法。当设计完一个业务的接口之后，我们实际上就完成了对这个业务从实际生活到代码世界的抽象和建模。</p><h3>屏蔽具体实现</h3><p>其次，接口的使用能让调用方对能力敏感，而对具体实现不敏感。</p><p>拿我们在第五章设计的 IRequest 接口举例，如果一个对象实现了这个接口，那么不管在什么模块调用这个对象，我们都能知道它拥有的能力有哪些、能通过哪些方式来获取到这些能力。</p><p>具体来说在写业务的时候，如果我们要从 URL 中获取请求参数，可以寻找实现了 IRequest 接口的对象，不管是什么对象，只要实现了IRequest接口，它就能满足我们的需求。比如在我们这个框架中就是 context 数据结构。从 context 这个对象中，通过 IRequest 中封装的 QueryXXX 系列的接口，就能获取到 URL 中的参数。<img src="https://static001.geekbang.org/resource/image/72/ee/72eca7562af15da8de58f8dd5705a7ee.jpg?wh=1920x1080" alt=""></p><p>当模块之间的调用有了接口，调用方就无需关心被调用模块的具体实现。因为在调用方逻辑中，不会出现被调用者具体实现的数据结构名称，只会出现被调用者承诺能力的一个简单接口。</p><p>这对调用方是非常友好的。一方面调用方不用担心被调用方内部的结构调整，只要被调用方按照承诺的能力提供服务；另一方面，调用方可以随时换掉被调用方，只要替换者也提供同等的能力即可。</p><p>比如上面那个寻找 Pizza 店的业务，PizzaOrderFinder 这个结构中的方法 find_implementation_by_name 返回的，就直接是接口 PizzaOrdering。意思是，要查询的是满足 PizzaOrdering 定义的一个店铺，只要有定义中的四个能力，顾客就能购买到 Pizza。所以，不管这个店铺是 pizza 店还是超市，只要提供了 pizza 店有的四个能力，就能将店铺放进寻找范围内。</p><h3>面向接口/对象/过程</h3><p>理解了接口的优势，我们来思考下“面向接口编程”的意义，它和“面向对象编程”、“面向过程编程”又有什么区别。</p><p>其实，这三个名词描述的都是思维方式，就是我们在抽象业务的时候如何思考问题。</p><ul>\n<li>“面向过程编程”是指进行业务抽象的时候，<strong>我们定义一个一个的过程方法，通过这些过程方法的串联完成具体的业务</strong>。</li>\n</ul><p>还是拿查询 Pizza 店的业务举例，面向过程编程的思考思路可能是最符合我们平时的思维逻辑：第一步，先查找附近的所有店铺；第二步，过滤出 pizza 店；第三步，按照自定义规则再过滤，查找出我要的 pizza 店。<img src="https://static001.geekbang.org/resource/image/21/1e/218ba4dd6036168ca472793e2byy3f1e.jpg?wh=1920x1080" alt=""></p><p>所以面向过程编程的整个思路就是实现思路，它的思维方式比较直接简单，按照目标一步步实现。<strong>但缺点是一旦需求有一些变化，整个链路的改动都会受影响</strong>。</p><p>比如最终的目标从按照 pizza 店铺的名字进行搜索，变化成按照店铺中的座位数进行搜索，那么由于这个需求变化，第二步过滤的逻辑，原本只返回 pizza 店铺的名字，就要增加返回 pizza 店铺的座位。这种改动往往涉及到全链路的改动，影响比较大。</p><ul>\n<li>“面向对象编程”表示的是在业务抽象的时候，<strong>我们先定义业务中的对象，通过这些对象之间的关联来表示整个业务</strong>。</li>\n</ul><p>对于寻找 Pizza 店的例子，我们会将所有的 pizza 店铺抽象成一个数据结构 Pizza 店，这个 Pizza 店铺提供购买 pizza 的能力和一些属性。这个时候过滤这些店铺就比较简单了，直接按照某些属性进行过滤。<img src="https://static001.geekbang.org/resource/image/8e/e6/8e8c304b5841d38e0f6ddf3161ayy0e6.jpg?wh=1920x1080" alt=""></p><p>所以面向对象编程抽象性就很强了，但是它的问题就是调用方依赖具体的数据结构pizza。比如还是按照座位号过滤，调用方会根据pizza结构中的座位号字段来过滤，但是pizza中的座位号这个字段我定义成什么变量，这个其实调用方并不想知道。所以我们其实还可以再进一步抽象，就是面向接口编程。</p><p>面对业务，我们并不先定义具体的对象、思考对象有哪些属性，而是<strong>先思考如何抽象接口，把接口的定义放在第一步，然后多个模块之间梳理如何通过接口进行交互，最后才是实现具体的模块</strong>。<img src="https://static001.geekbang.org/resource/image/2c/ff/2c99bcc53aa920f7b678c84d8b4699ff.jpg?wh=1920x1080" alt=""></p><h2>接口服务的理论基础</h2><p>现在理解了面向接口编程的理念，就可以将这个理念运用到我们的 hade 框架中了。在框架中会包含很多模块，这些模块会和框架主体交互，也会互相交互，所以如果从功能的交互上看，整体会是一个非常复杂的网状结构。<br>\n<img src="https://static001.geekbang.org/resource/image/66/b7/664016abbd655007de0f91b9f95d81b7.jpg?wh=1920x1080" alt=""></p><p>如果改变一下思路，按照面向接口编程的理念，将每个模块看成是一个服务，服务的具体实现我们其实并不关心，我们关心的是服务提供的能力，即接口协议。那么框架主体真正要做的事情是什么呢？其实是：<strong>定义好每个模块服务的接口协议，规范服务与服务之间的调用，并且管理每个服务的具体实现。</strong></p><p>所有的服务都去框架主体中注册自身的模块接口协议，其他的服务调用功能模块的时候，并不是直接去这个服务获取实例，而是从框架主体中获取有这个接口协议的服务实例。</p><p>这样，所有的模块服务都不和具体的服务进行交互，而是和框架主体进行交互，所有的接口也都注册在框架主体中，非常方便管理。<br>\n<img src="https://static001.geekbang.org/resource/image/72/18/72cc85773ccce8634fd90cda78c2dd18.jpg?wh=1920x1080" alt=""></p><p>每个模块服务都做两件事情：一是它和自己提供的接口协议做绑定，这样当其他人要使用这个接口协议时能找到自己；二是它使用到其他接口协议的时候，去框架主体中寻找。</p><p>所以，这个时候，每个模块服务都是一个“<strong>服务提供者</strong>”（service provider），而我们主体框架需要承担起来的角色叫做“<strong>服务容器</strong>”（service container），服务容器中绑定了多个接口协议，每个接口协议都由一个服务提供者提供服务。</p><p>在框架初始化启动的时候，我们可以选择在服务容器中绑定多个服务提供者，每个服务提供者对应一个凭证。当要使用到某个服务的时候，再根据这个凭证去服务容器中，获取这个服务提供者提供的服务。这样就能很方便地获取服务了。</p><p>这两个结构的逻辑非常重要，这里我再强调一下。我们的设计是将每个服务，不管是配置、还是日志、还是缓存，都看成是一个服务。</p><p><strong>这个服务，通过提供一个服务提供者注册到服务容器中。服务提供者提供的是“创建服务实例的方法”，服务容器提供的是“实例化服务的方法”</strong>。至于这个服务实例拥有哪些能力，即符合哪个接口协议，是预先在框架主体中定义好的。</p><p>讲完服务提供者和服务容器的理论基础，就要讲具体实现了，今天我们先了解服务提供者如何实现，下一课接着学服务容器。</p><h2>服务提供者的接口定义</h2><p>按照面向接口编程的逻辑，一个服务提供者需要有哪些能力呢？一共有五个能力，先简单看一眼做到心中有数，再来详细理解为什么要设计这些能力：</p><ul>\n<li>获取服务凭证的能力 Name；</li>\n<li>创建服务实例化方法的能力 Register；</li>\n<li>获取服务实例化方法参数的能力 Params；</li>\n<li>两个与实例化控制相关的方法，控制实例化时机方法 IsDefer、实例化预处理的方法Boot。</li>\n</ul><p>我们将服务提供者的接口定义放在框架目录的framework/provider.go中。</p><h3>基本功能</h3><p>首先因为要和服务容器做绑定，所以一个服务提供者需要有一个凭证，绑定时作为凭证关联。这里的凭证我们就直接设计为一个字符串结构，即<strong>服务提供者首先有一个获取凭证字符串的方法 Name()</strong>。</p><pre><code class="language-go">// Name 代表了这个服务提供者的凭证\nName() string\n</code></pre><p><strong>然后一个服务提供者需要有创建服务实例方法的能力</strong>。因为在服务容器中绑定后，如果服务容器要初始化一个服务实例，就需要调用服务提供者中创建服务实例的方法。</p><p>按照面向接口编程的思想，每个具体服务“创建服务实例”的方法不一样，比如日志服务初始化的时候可能需要有日志输出地址，但是配置服务初始化的时候需要有配置文件地址，但是我们这里需要规范它们的输入和输出，使用 Golang 中的 function type，也叫函数定义，是可以做这个事情的。</p><pre><code class="language-go">// NewInstance 定义了如何创建一个新实例，所有服务容器的创建服务\ntype NewInstance func(...interface{}) (interface{}, error)\n</code></pre><p>这个 NewInstance 就是一个函数定义，它规定所有创建服务实例的方法必须：有相同的参数interface{} 数组，并且返回 interface{}和错误信息这两个数据结构。</p><ul>\n<li>interface{} 数组代表实例化一个服务所需要的参数，我们这里设计为可变参数，为的是适配不同数量、不同类型的参数需求；</li>\n<li>返回值返回的 interface{} 结构代表了具体的服务实例。</li>\n</ul><p>定义好了“创建服务实例的方法”的函数，我们再看服务提供者的创建能力如何实现，也就是 NewInstance 方法，它的返回值就是刚才写的 NewInstance 的函数定义。</p><pre><code class="language-go">// Register 在服务容器中注册了一个实例化服务的方法，是否在注册的时候就实例化这个服务，需要参考 IsDefer 接口。\nRegister(Container) NewInstance\n</code></pre><p>而对于方法的输入参数，将服务容器传进来是因为，如果后续希望根据一个服务的某个能力，比如配置服务的获取某个配置的能力，返回定义好的不同 NewInstance 函数，那我们就需要先从服务容器中获取配置服务，才能判断返回哪个 NewInstance。</p><p>所以这里我们将服务容器作为传入参数。（这个服务容器的结构我们下节课再具体讨论，这里先用 Container 名称代替。）</p><p>“创建服务实例的方法”的能力，除了实现 NewInstance 方法之外，还需要注册 NewInstance 方法的参数，即可变的 interface{}参数。<strong>所以我们的服务提供者还需要提供一个获取服务参数的能力</strong>。</p><pre><code class="language-go">// Params params 定义传递给 NewInstance 的参数，可以自定义多个，建议将 container 作为第一个参数\nParams(Container) []interface{}\n</code></pre><h3>实例化过程的控制</h3><p>到这里服务提供者的能力已经基本设计好了。不过我们可以再思考下实例化的过程，看看还有没有什么讲究。</p><ul>\n<li>实例化的时机，可以在服务提供者注册的时候，也可以是第一次获取服务的时候，即是注册的时候就实例化，还是延迟到获取服务的时候实例化。</li>\n</ul><p>所以我们需要有一个能力能控制实例化的时机，对应到服务提供者上，要提供告知服务容器是否延迟实例化的方法 IsDefer。同样在framework/provider.go中。</p><pre><code class="language-go">// IsDefer 决定是否在注册的时候实例化这个服务，如果不是注册的时候实例化，那就是在第一次 make 的时候进行实例化操作\n// false 表示不需要延迟实例化，在注册的时候就实例化。true 表示延迟实例化\nIsDefer() bool\n</code></pre><ul>\n<li>实例化之前有可能需要做一些准备工作，比如在每次实例化之前，想记录一下日志，或者想通过确认某些配置，修改一下实例化参数。</li>\n</ul><p>所以这里我们需要设计一个在实例化前调用准备工作的函数 Boot。它的参数是服务容器，返回值是一个 error，在实例化服务的时候，如果准备工作 Boot 失败了，那么我们就不进行后续的实例化操作了，将这个 error 直接返回给获取服务的方法。</p><pre><code class="language-go">// Boot 在调用实例化服务的时候会调用，可以把一些准备工作：基础配置，初始化参数的操作放在这个里面。\n// 如果 Boot 返回 error，整个服务实例化就会实例化失败，返回错误\nBoot(Container) error\n</code></pre><p>到这里，我们就定义好了服务提供者的接口了。再简单回顾一下，有三个基础能力、两个控制相关的能力：</p><ul>\n<li>获取服务凭证的能力 Name；</li>\n<li>注册服务实例化的方法的能力 Register；</li>\n<li>获取服务实例化方法参数的能力 Params；</li>\n<li>两个与实例化控制相关的方法，控制实例化时机方法 IsDefer、实例化预处理的方法Boot。</li>\n</ul><p>framework/provider.go中完整代码如下：</p><pre><code class="language-go">package framework\n\n// NewInstance 定义了如何创建一个新实例，所有服务容器的创建服务\ntype NewInstance func(...interface{}) (interface{}, error){}\n\n// ServiceProvider 定义一个服务提供者需要实现的接口\ntype ServiceProvider interface {\n\t// Register 在服务容器中注册了一个实例化服务的方法，是否在注册的时候就实例化这个服务，需要参考 IsDefer 接口。\n\tRegister(Container) NewInstance\n\t// Boot 在调用实例化服务的时候会调用，可以把一些准备工作：基础配置，初始化参数的操作放在这个里面。\n\t// 如果 Boot 返回 error，整个服务实例化就会实例化失败，返回错误\n\tBoot(Container) error\n\t// IsDefer 决定是否在注册的时候实例化这个服务，如果不是注册的时候实例化，那就是在第一次 make 的时候进行实例化操作\n\t// false 表示不需要延迟实例化，在注册的时候就实例化。true 表示延迟实例化\n\tIsDefer() bool\n\t// Params params 定义传递给 NewInstance 的参数，可以自定义多个，建议将 container 作为第一个参数\n\tParams(Container) []interface{}\n\t// Name 代表了这个服务提供者的凭证\n\tName() string\n}\n\n</code></pre><p>今天主要说明了面向接口编程的逻辑，以及服务提供者、服务容器、服务之间的关系。代码层面我们只增加了一个provider.go。代码我已经上传到了GitHub上的<a href="https://github.com/gohade/coredemo/tree/geekbang/10">geekbang/10 </a>分支。但是在定义Provider的时候，我们在参数中使用了下节课需要定义的服务容器结构Container，所以目前这个分支的代码暂时还是不能运行的。<br>\n<img src="https://static001.geekbang.org/resource/image/9e/93/9e1d9d6b52913ea14dffab052c709c93.png?wh=754x784" alt=""></p><h2>小结</h2><p>结合面向接口编程的理念，我们希望设计出的框架是一个服务容器，也就是说，并不是在它的内部实现各种各样的功能模块，而是在框架中，<strong>定义好每个模块服务的接口，规范服务与服务之间的调用，并且管理每个服务的具体实现。</strong></p><p>具体功能模块的实现由绑定的服务提供者进行，我们只需要规范服务提供者的能力，就能获取到具体的服务实例了。</p><p>今天的内容比较偏向理论，一直围绕“面向接口编程”的概念讨论。但是希望你不要觉得枯燥，还是那句话，不仅要知其然，还要知其所以然。先搞清楚为什么要这么设计我们的 hade 框架、它的理论基础是什么，才能顺利实现，并且在后期灵活调整和拓展。下一讲我们继续学习服务容器的实现。</p><h2>思考题</h2><p>今天花了很大篇幅来解释面向接口的思想，我们会将这个思想贯穿在Web框架的整个设计中。其实面向接口思想不仅仅应用在编程分层中，在架构设计、微服务中也都有所体现，你可以想想在工作生活中有遇到使用面向接口思想的一些实例么？</p><p>欢迎在留言区分享你的思考。感谢你的收听，如果你觉得有收获，也欢迎你把今天的内容分享给你身边的朋友，邀他一起学习。我们下节课见。</p>',
        article_title: "10｜面向接口编程（上）：一切皆服务，服务基于协议",
      },
      {
        title: "11｜面向接口编程（下）：一切皆服务，服务基于协议",
        id: 425093,
        content:
          '<p>你好，我是轩脉刃。</p><p>之前对比面向过程/面向对象，讲解了抽象程度更高的面向接口编程理念，先定义接口再梳理如何通过接口协议交互，最后实现具体模块。</p><p>根据这一理念，我们框架的核心设计就是：框架主体作为一个服务容器，其他各个服务模块都作为服务提供者，在服务容器中注册自己的服务凭证和服务接口，通过服务凭证来获取具体的服务实例。这样，功能的具体实现交给了各个服务模块，我们只需要规范服务提供者也就是服务容器中的接口协议。</p><p>在上节课也已经完成了服务提供方接口的实现。所以今天就接着实现框架的主体逻辑。</p><h2>服务容器的实现</h2><p>首先是服务容器，先看它需要具有什么能力。同样的，按照面向接口编程，我们不考虑具体实现，先思考服务容器的接口设计。</p><p>将服务容器实现在 framework/container.go 文件中。</p><p>正如之前讨论的，<strong>一个服务容器主要的功能是：为服务提供注册绑定、提供获取服务实例</strong>，所以服务容器至少有两个方法：注册方法 Bind、获取实例方法 Make。</p><ul>\n<li>对于注册的方法，直接将一个服务提供者注册到容器中，参数是之前定义的服务提供者，返回值则是error是否注册成功。</li>\n</ul><pre><code class="language-go">// Bind 绑定一个服务提供者，如果关键字凭证已经存在，会进行替换操作，不返回 error\nBind(provider ServiceProvider) error\n</code></pre><!-- [[[read_end]]] --><ul>\n<li>获取实例的方法是 Make，它会根据一个关键字凭证，来获取容器中已经实例化好的服务。所以参数是一个关键字凭证 string，返回值是实例化好的服务 interface和是否有错误的 error 信息。</li>\n</ul><pre><code class="language-go">// Make 根据关键字凭证获取一个服务，\nMake(key string) (interface{}, error)\n</code></pre><p>有了这两个基础方法，再考虑在注册绑定及获取服务实例过程中，有什么方面可以扩展。</p><p>首先，因为有绑定操作，那么需要有一个确认某个关键字凭证是否已经绑定的能力：IsBind，参数为关键字凭证，返回为 bool 表示是否已经绑定。</p><p>其次，Make 方法返回值中带 error 信息，其实这在易用性上并不友好，因为大部分情况下，我们能确定某个服务容器已经被注册了，并不需要处理这个 error。所以可以增加一个 MustMake 方法，它的参数和 Make 方法一样，为关键字凭证，返回值为实例化服务，但是不返回 error。</p><p>最后我们考虑 Make 的一种拓展场景，<strong>是否会有在获取服务实例的时候，按照不同参数初始化的需求</strong>？</p><p>上节课说服务提供者提供了，初始化服务实例方法的能力 Register 和获取初始化服务实例参数的能力 Params。一旦服务实例被初始化了，它就保存在服务容器中了，下次获取的时候，只需要获取已经实例化好的服务。</p><p>但是在某次获取的时候，也会有需求要根据不同参数获取新的实例。比如需要根据不同的配置，获取不同的缓存实例的时候，我们可能需要传递不同的参数。所以可以定义一个 MakeNew 的方法，根据参数获取不同实例。</p><p>整理一下服务容器的五个接口能力，在framework/container.go中代码如下：</p><pre><code class="language-go">// Container 是一个服务容器，提供绑定服务和获取服务的功能\ntype Container interface {\n\t// Bind 绑定一个服务提供者，如果关键字凭证已经存在，会进行替换操作，返回 error\n\tBind(provider ServiceProvider) error\n\t// IsBind 关键字凭证是否已经绑定服务提供者\n\tIsBind(key string) bool\n\n\t// Make 根据关键字凭证获取一个服务，\n\tMake(key string) (interface{}, error)\n\t// MustMake 根据关键字凭证获取一个服务，如果这个关键字凭证未绑定服务提供者，那么会 panic。\n\t// 所以在使用这个接口的时候请保证服务容器已经为这个关键字凭证绑定了服务提供者。\n\tMustMake(key string) interface{}\n\t// MakeNew 根据关键字凭证获取一个服务，只是这个服务并不是单例模式的\n\t// 它是根据服务提供者注册的启动函数和传递的 params 参数实例化出来的\n\t// 这个函数在需要为不同参数启动不同实例的时候非常有用\n\tMakeNew(key string, params []interface{}) (interface{}, error)\n}\n</code></pre><h2>具体实现</h2><p>现在接口设计好了，下面结合交互思考下如何实现这个服务容器。我们就定义一个 HadeContainer 数据结构来实现 Container 接口，因为功能是提供绑定服务和获取服务，需要根据关键字获取一个对象，所以 Hash Map 是符合需求的。</p><p>在 HadeContainer 内部应该有一个 map[string]interface{} 结构 instances，其中 key 为关键字，value 为具体的服务实例，这样 instances 结构可以存储每个关键字凭证对应的服务实例，在 Make 系列的方法中，就可以根据这个结构获取对应的服务实例。</p><p>同理服务提供方也需要设计一个 map[string]ServiceProvider 来存储它们，这样在 Bind 操作的时候，只需要将服务提供方绑定到某个关键字凭证上即可。</p><p>另外还要关注一下数据结构的并发性。因为当 Bind 的时候<strong>会对实例或者服务提供方有一定的变动，需要使用一个机制来保证 HadeContianer 的并发性</strong>，是用读写锁还是互斥锁呢？</p><p>这里我们就要关注功能了，这个 HadeContainer 是一个读多于写的数据结构，即 Bind 是一次性的，但是 Make 是频繁的。所以使用读写锁的性能会优于互斥锁。</p><p>好整理一下，在framework/container.go中 HadeContainer 的字段定义如下：</p><pre><code class="language-go">// HadeContainer 是服务容器的具体实现\ntype HadeContainer struct {\n\tContainer // 强制要求 HadeContainer 实现 Container 接口\n\t// providers 存储注册的服务提供者，key 为字符串凭证\n\tproviders map[string]ServiceProvider\n\t// instance 存储具体的实例，key 为字符串凭证\n\tinstances map[string]interface{}\n\t// lock 用于锁住对容器的变更操作\n\tlock sync.RWMutex\n}\n</code></pre><p>然后对应 HadeContainer ，来实现 Container 定义的几个方法就比较容易了，本质上就是对 providers 和 instances 两个 map 结构的修改和读取。这里最核心的 Bind 方法，我会结合代码讲得比较细致，你可以认真体会。</p><h3>Bind 方法</h3><p>首先因为 Bind 方法是一个写操作，会修改 providers 和 instances，所以在函数一开头，先给加上一个写锁，然后我们修改 providers 这个字段，它的 key 为关键字，value 为注册的 ServiceProvider。</p><p>接着这里<strong>需要先判断是否实例化</strong>，因为定义的 ServiceProvider 中的 IsDefer 方法，控制了实例化时机。</p><p>如果 IsDefer 方法标记这个服务实例要延迟实例化，即等到第一次 make 的时候再实例化，那么在 Bind 操作的时候，就什么都不需要做；而如果 IsDefer 方法为 false，即注册时就要实例化，那么我们就要在 Bind 函数中增加实例化的方法。</p><p>所以接下来实现实例化，方法和参数就是 ServiceProvider 中的 Register 和 Params 方法，分别取出实例化方法和参数进行调用，就获取到了具体的服务实例。</p><p>最后还有一点要注意下，之前为 ServiceProvider 定义过一个 Boot 方法，是为了服务实例化前做一些准备工作的。所以在实例化之前，要先调用这个 Boot 方法，同样在framework/container.go中进行修改。</p><pre><code class="language-go">// Bind 将服务容器和关键字做了绑定\nfunc (hade *HadeContainer) Bind(provider ServiceProvider) error {\n\thade.lock.Lock()\n\tdefer hade.lock.Unlock()\n\tkey := provider.Name()\n\n\thade.providers[key] = provider\n\n\t// if provider is not defer\n\tif provider.IsDefer() == false {\n\t\tif err := provider.Boot(hade); err != nil {\n\t\t\treturn err\n\t\t}\n\t\t// 实例化方法\n\t\tparams := provider.Params(hade)\n\t\tmethod := provider.Register(hade)\n\t\tinstance, err := method(params...)\n\t\tif err != nil {\n\t\t\treturn errors.New(err.Error())\n\t\t}\n\t\thade.instances[key] = instance\n\t}\n\treturn nil\n}\n</code></pre><h3>Make 方法</h3><p>为服务提供注册绑定的Bind方法我们就完成了，再来看服务容器的另一个功能提供获取服务实例，也就是 Make 方法。</p><p>先判断某个关键字是否已经注册了服务提供者，如果没有注册则后续不能成功返回错误，如果已经注册了就进行实例化操作。</p><p>同时注意下，在上面解释过，也会有扩展需求，按照不同参数再次初始化服务的需求。也就是MakeNew方法，它和Make方法在内部调用最大的不同是传递了一个强制初始化的标记forceNew，和初始化需要的参数params。</p><p>所以，在两个函数共同的内部实现make方法中，我们要先判断是否需要强制初始化实例，如果需要强制初始化，初始化后直接返回。而不需要强制初始化，那么就需要判断之前是否已经实例化了，如果已经实例化了，则返回。</p><p>方法的实现同样在framework/container.go中：</p><pre><code class="language-go">// Make 方式调用内部的 make 实现\nfunc (hade *HadeContainer) Make(key string) (interface{}, error) {\n\treturn hade.make(key, nil, false)\n}\n\n// MakeNew 方式使用内部的 make 初始化\nfunc (hade *HadeContainer) MakeNew(key string, params []interface{}) (interface{}, error) {\n\treturn hade.make(key, params, true)\n}\n\n// 真正的实例化一个服务\nfunc (hade *HadeContainer) make(key string, params []interface{}, forceNew bool) (interface{}, error) {\n\thade.lock.RLock()\n\tdefer hade.lock.RUnlock()\n\t// 查询是否已经注册了这个服务提供者，如果没有注册，则返回错误\n\tsp := hade.findServiceProvider(key)\n\tif sp == nil {\n\t\treturn nil, errors.New("contract " + key + " have not register")\n\t}\n\n\tif forceNew {\n\t\treturn hade.newInstance(sp, params)\n\t}\n\n\t// 不需要强制重新实例化，如果容器中已经实例化了，那么就直接使用容器中的实例\n\tif ins, ok := hade.instances[key]; ok {\n\t\treturn ins, nil\n\t}\n\n\t// 容器中还未实例化，则进行一次实例化\n\tinst, err := hade.newInstance(sp, nil)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\thade.instances[key] = inst\n\treturn inst, nil\n}\n</code></pre><h2>容器和框架的结合</h2><p>完成了服务容器的接口和对应具体实现，下面就要思考如何将服务容器融合进入框架中。</p><p>回顾下 hade 框架中最核心的两个数据结构 Engine 和 Context。</p><ul>\n<li>Engine 就是在<a href="https://time.geekbang.org/column/article/417674">第一节课</a>中实现的 Core 数据结构，这个数据结构是整个框架的入口，也承担了整个框架最核心的路由、中间件等部分。</li>\n<li>Context 数据结构对应<a href="https://time.geekbang.org/column/article/418283">第二课</a>中实现的 Context 数据结构，它为每个请求创建一个 Context，其中封装了各种对请求操作的方法。</li>\n</ul><p>对应来看我们的服务容器，它提供了两类方法，绑定操作和获取操作。绑定操作是全局的操作，而获取操作是在单个请求中使用的。所以在全局，我们为服务容器绑定了服务提供方，就能在单个请求中获取这个服务。</p><p>那么对应到框架中，可以<strong>将服务容器存放在 Engine 中，并且在 Engine 初始化 Context 的时候，将服务容器传递进入 Context</strong>。思路很清晰，接下来就按部就班写。</p><p>首先，在框架文件framework/gin/gin.go 中修改 Engine 的数据结构，增加 container 容器，并且在初始化 Engine 的时候，也同时初始化 container。</p><pre><code class="language-go">type Engine struct {\n\t// 容器\n\tcontainer framework.Container\n    ...\n}\n\nfunc New() *Engine {\n\tdebugPrintWARNINGNew()\n\tengine := &amp;Engine{\n\t\t...\n\t\t// 这里注入了 container\n\t\tcontainer:&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; framework.NewHadeContainer(),\n\t\t...\n\t}\n\t...\n\treturn engine\n}\n</code></pre><p>接着，在 Engine 创建 context 的时候，我们将 engine 中的 container 容器注入到每个 context 中，并且修改 Context 的数据结构，增加 container 容器。同样修改framework/gin/gin.go中的allocateContext方法。</p><pre><code class="language-go">// engine 创建 context\nfunc (engine *Engine) allocateContext() *Context {\n\tv := make(Params, 0, engine.maxParams)\n\t// 在分配新的 Context 的时候，注入了 container\n\treturn &amp;Context{engine: engine, params: &amp;v, container: engine.container}\n}\n</code></pre><p>和修改framework/gin/context.go中的Context定义。</p><pre><code class="language-go">// Context 在每个请求中都有\ntype Context struct {\n\t// Context 中保存容器\n\tcontainer framework.Container\n    ...\n}\n</code></pre><p>这样就完成了服务容器的创建和传递，接下来完成服务容器方法的封装。</p><p>根据上面描述的，Engine 中负责绑定，Context 中负责获取，所以我们将 container 的五个能力拆分到 Engine 和 Context 数据结构中。Engine 封装 Bind 和 IsBind 方法，Context 封装 Make、MakeNew、MustMake 方法。</p><p>将这些为Engine和Context 增加的新的方法单独存放在一个新的文件framework/gin/hade_context.go中。</p><pre><code class="language-go">// engine 实现 container 的绑定封装\nfunc (engine *Engine) Bind(provider framework.ServiceProvider) error {\n\treturn engine.container.Bind(provider)\n}\n\n// IsBind 关键字凭证是否已经绑定服务提供者\nfunc (engine *Engine) IsBind(key string) bool {\n\treturn engine.container.IsBind(key)\n}\n\n\n\n// context 实现 container 的几个封装\n// 实现 make 的封装\nfunc (ctx *Context) Make(key string) (interface{}, error) {\n\treturn ctx.container.Make(key)\n}\n\n// 实现 mustMake 的封装\nfunc (ctx *Context) MustMake(key string) interface{} {\n\treturn ctx.container.MustMake(key)\n}\n\n// 实现 makenew 的封装\nfunc (ctx *Context) MakeNew(key string, params []interface{}) (interface{}, error) {\n\treturn ctx.container.MakeNew(key, params)\n}\n</code></pre><p>到这里，我们就将服务容器和框架结合了，还需要完成创建服务提供方并创建服务的逻辑。</p><h2>如何创建一个服务提供方</h2><p>下面我们来创建一个服务 DemoService，为这个服务创建一个服务提供方 DemoServiceProvider，并注入到服务容器中。在业务目录中创建一个目录provider/demo存放这个服务。</p><p>先搞清楚需要为这个服务设计几个文件。</p><ul>\n<li>要有一个服务接口文件 contract.go，存放服务的接口文件和服务凭证。</li>\n<li>需要设计一个 provider.go，这个文件存放服务提供方 ServiceProvider 的实现。</li>\n<li>最后在 service.go 文件中实现具体的服务实例。<br>\n<img src="https://static001.geekbang.org/resource/image/ac/2f/ac03471e430a73a1d90d4fb5a18d4a2f.png?wh=507x411" alt=""></li>\n</ul><p>所以先来看第一个服务接口说明文件 contract.go，在文件中要做两个事情。一是定义一个服务的关键字凭证，这个凭证是用来注册服务到容器中使用的，这里使用“hade:demo”来作为服务容器的关键字。</p><p>另外在这个文件中，我们要设计这个服务的接口，包括接口方法和接口方法使用的对象。比如这里就设计了 demo.Service 接口，它有一个 GetFoo 方法，返回了 Foo 的数据结构。</p><pre><code class="language-go">package demo\n\n// Demo 服务的 key\nconst Key = "hade:demo"\n\n// Demo 服务的接口\ntype Service interface {\n\tGetFoo() Foo\n}\n\n// Demo 服务接口定义的一个数据结构\ntype Foo struct {\n\tName string\n}\n</code></pre><p>接下来是服务提供方 DemoServiceProvider，在上一节课中，我们描述了服务提供方 ServiceProvider 需要实现的五个能力方法，一一对照完成定义。</p><ul>\n<li>Name 方法直接将服务对应的字符串凭证返回，在这个例子中就是“hade.demo"。</li>\n<li>Register 方法，是注册初始化服务实例的方法，这里先暂定为 NewDemoService。</li>\n<li>Params 方法表示实例化的参数。这里只实例化一个参数：container，表示我们在 NewDemoService 这个函数中，只有一个参数container。</li>\n<li>IsDefer 方法表示是否延迟实例化，这里设置为 true，将这个服务的实例化延迟到第一次 make 的时候。</li>\n<li>Boot 方法，这里就简单设计为什么逻辑都不执行，只打印一行日志信息。</li>\n</ul><p>在provider/demo/provider.go中定义逻辑：</p><pre><code class="language-go">// 服务提供方\ntype DemoServiceProvider struct {\n}\n\n// Name 方法直接将服务对应的字符串凭证返回，在这个例子中就是“hade.demo"\nfunc (sp *DemoServiceProvider) Name() string {\n\treturn Key\n}\n\n// Register 方法是注册初始化服务实例的方法，这里先暂定为 NewDemoService\nfunc (sp *DemoServiceProvider) Register(c framework.Container) framework.NewInstance {\n\treturn NewDemoService\n}\n\n// IsDefer 方法表示是否延迟实例化，我们这里设置为 true，将这个服务的实例化延迟到第一次 make 的时候\nfunc (sp *DemoServiceProvider) IsDefer() bool {\n\treturn true\n}\n\n// Params 方法表示实例化的参数。我们这里只实例化一个参数：container，表示我们在 NewDemoService 这个函数中，只有一个参数，container\nfunc (sp *DemoServiceProvider) Params(c framework.Container) []interface{} {\n\treturn []interface{}{c}\n}\n\n// Boot 方法我们这里我们什么逻辑都不执行, 只打印一行日志信息\nfunc (sp *DemoServiceProvider) Boot(c framework.Container) error {\n\tfmt.Println("demo service boot")\n\treturn nil\n}\n</code></pre><p>在最后的具体 Demo 服务实现文件 service.go 中，我们需要实现 demo 的接口。创建一个 DemoService 的数据结构，来实现 demo 的接口 GetFoo，和正常写一个服务实现某个接口的逻辑是一样的。</p><pre><code class="language-go">// 具体的接口实例\ntype DemoService struct {\n\t// 实现接口\n\tService\n\n    // 参数\n\tc framework.Container\n}\n\n// 实现接口\nfunc (s *DemoService) GetFoo() Foo {\n\treturn Foo{\n\t\tName: "i am foo",\n\t}\n}\n</code></pre><p>这里不知道你有没有发现，在 DemoService 的数据结构中，<strong>直接嵌套显式地写了 Service 接口，表示这个 DemoService 必须实现 Service 接口</strong>。这是我个人的小习惯，当然这里也可以不用这样显式强调接口实现的，因为在 Golang 中，一个数据结构只需要实现了一个接口的方法，它就隐式地实现了这个接口。</p><p>但是我还是习惯这样显式强调的写法，也推荐你可以试一试，有两个好处。</p><p>第一对 IDE 友好，有的 IDE比如 VS Code，在“根据接口查找具体实现的数据结构”的时候，如果没有这么一个显式标记，是寻找不出来的。第二个更重要的原因是对编译友好，一旦接口 Service 变化了，那么这个实现接口的实例，必须要有对应变化，否则在编译期就会出现错误了。</p><p>现在有了具体的接口实现结构 DemoService，我们只需要最后实现一个初始化这个服务实例的方法 NewDemoService。它的参数是一个数组接口，返回值是服务实例。还是把这个方法存放在provider/demo/service.go中：</p><pre><code class="language-go">// 初始化实例的方法\nfunc NewDemoService(params ...interface{}) (interface{}, error) {\n\t// 这里需要将参数展开\n\tc := params[0].(framework.Container)\n\n\tfmt.Println("new demo service")\n\t// 返回实例\n\treturn &amp;DemoService{c: c}, nil\n}\n</code></pre><p>到这里，就创建了一个示例的服务提供方 DemoService。下面再看看如何使用这个服务提供方。</p><h2>如何通过服务提供方创建服务</h2><p>这里实现非常简单，我们需要做两个操作，绑定服务提供方、获取服务。</p><p>首先是在业务文件夹的main.go中绑定操作，在 main 函数中，完成 engine 的创建之后，用在 engine 中封装的 Bind 方法做一次绑定操作。</p><pre><code class="language-go">func main() {\n\t// 创建 engine 结构\n\tcore := gin.New()\n\t// 绑定具体的服务\n\tcore.Bind(&amp;demo.DemoServiceProvider{})\n    ...\n}\n</code></pre><p>然后就是服务的获取了。在具体的业务逻辑控制器中，我们选择路由/subject/list/all 对应的控制器 SubjectListController，使用为 context 封装的 MustMake 方法来获取 demo 服务实例。</p><p>MustMake 的参数为 demo 的服务凭证 demo.Key，返回的是一个 interface 结构，这个 interface 结构实际上是实现了 demo.Service 接口的一个服务实例。</p><p>而在接口的具体输出中，输出的是这个接口定义的GetFoo()方法的输出，也就是最终会从服务容器中获取到DemoService 的GetFoo()方法的返回值Foo结构，带有字段Name: “i am foo”输出在页面上。</p><pre><code class="language-go">// 对应路由 /subject/list/all\nfunc SubjectListController(c *gin.Context) {\n\t// 获取 demo 服务实例\n\tdemoService := c.MustMake(demo.Key).(demo.Service)\n\n\t// 调用服务实例的方法\n\tfoo := demoService.GetFoo()\n\n\t// 输出结果\n\tc.ISetOkStatus().IJson(foo)\n}\n</code></pre><p>最后验证一下，在浏览器中，我们访问这个路由 /subject/list/all，获取到了 Foo 数据结构 Json 化出来的结果，如下图，验证完毕。</p><p><img src="https://static001.geekbang.org/resource/image/41/f2/41950355f4yy02446f4cd19fed3435f2.png?wh=616x188" alt="图片"></p><p>现在服务容器、服务提供者的整个框架主体就搭建完成了。</p><p>今天所有的代码都已经上传到GitHub的<a href="https://github.com/gohade/coredemo/tree/geekbang/11">geekbang/11</a>分支了。目录截图如下：<br>\n<img src="https://static001.geekbang.org/resource/image/20/05/2032cf8a1f4bf7e8a57ba76a2c709105.png?wh=383x1231" alt=""><img src="https://static001.geekbang.org/resource/image/26/fb/267b73d56814f5d0e2e2c2b941350bfb.png?wh=385x551" alt=""></p><h2>小结</h2><p>我们在主体框架中实现了服务容器、服务提供者的逻辑，现在，hade框架就包含一个服务容器，所有的服务都会在服务容器中注册。当业务需要获取某个服务实例的时候，也就是从服务容器中获取服务。</p><p>在这节课中，你是不是能感知到服务容器的方便之处了。只需要往服务容器中注册服务提供者，之后不管任何时候，想要获取某个服务，都能很方便地从服务容器中，获取到符合服务接口的实例，而不需要考虑到服务的具体实现。<strong>这种设计的拓展性非常好，之后在实际业务中我们只要保证服务协议不变，而不用担心具体的某个服务实现进行了变化</strong>。</p><p>后续开发的所有服务模块，比如日志、配置等我们都会以服务的形式进行开发，先定义好服务的接口，后定义服务的服务提供者，最后再定义服务的具体实例化方法。</p><h2>思考题</h2><p>在实现服务容器时，不知道你会不会有一个疑问：我们将服务容器的 Make 系列的方法在 Context 中实现了，为什么不把 Bind 系列方法也在 Context 中实现呢？这个问题你会怎么思考呢？Context 允许 Bind 方法有什么好处和什么不好的地方呢？</p><p>欢迎在留言区分享你的思考。感谢你的收听，如果你觉得有收获，也欢迎你把今天的内容分享给你身边的朋友，邀他一起学习。我们下节课见。</p>',
        article_title: "11｜面向接口编程（下）：一切皆服务，服务基于协议",
      },
      {
        title: "12｜结构：如何系统设计框架的整体目录？",
        id: 425820,
        content:
          '<p>你好，我是轩脉刃。</p><p>到现在，我们已经将Gin集成到框架hade中，同时又引入了服务容器和服务提供者，明确框架的核心思想是面向服务编程，一切皆服务，所有服务都是基于协议。后续也会以服务的形式，封装一个个的服务，让我们的框架越来越丰富。</p><p>但是服务文件代码应该存放在哪里呢？这是我们会最先遇到的问题。业务的目录结构是否应该有规范，应该如何规范？所以今天这节课我们就来讨论这个问题，从系统的角度考虑框架的整体目录设计。</p><h2>框架和业务区分</h2><p>有人可能会问了，我们写的不是一个 Web 框架么，为什么要规范业务的目录结构？像 Gin 框架，就没有规范业务应用的目录结构，业务方根据自己的需要，想怎么组织业务目录就怎么组织，不好么？作为一个框架，想规范业务的目录结构，这样做是不是有点越俎代庖？</p><p>这个问题其实很有意义，我们需要搞清楚目录结构到底是用来干什么的。</p><p><strong>业务代码的目录结构是一种工程化的规范</strong>。所谓工程化，简单来说就是希望不管是谁，在一个工程项目中，都按照一种做法来完成某个事情。而目录结构，就是项目工程化的一个起点。</p><p>在一个公司或者一个部门中，如果有架构团队，基本上要做的第一个事情就是，规范公司或者部门的代码目录结构。整体目录结构不仅仅代表着分层、归纳，也包含着很多架构的思想。</p><!-- [[[read_end]]] --><p>而对于 hade 框架而言，因为目标是将框架应用于实际生产，工程化使用，所以对业务的目录结构，<strong>制定最小化的工程化规范，并且提供默认的整体目录结构</strong>是很有必要的。</p><p>不过请注意，这里是希望制定最小化的工程化规范，就是说，对于这个框架，规范某些最小化的功能性目录是必要的，如果没有这些功能性目录，我们会认为目录设计是不合理的。</p><p>下面就来讨论下如何制定目录结构。</p><h2>如何设计</h2><p>在制定具体的目录结构之前，我们要明确一点：<strong>业务的目录结构也是一个服务，是一个应用目录服务</strong>。在这个服务中，我们制定框架要求的最小化的工程化规范，即框架要求业务至少有哪些目录结构。</p><p>而在其他服务中，一旦需要用到某个目录，我们能从目录结构服务中，查找出对应的结构。比如后续要创建配置服务，它需要去某个配置目录文件中读取配置，而去哪个配置目录呢，只需要去服务容器中获取这个应用目录服务就能知道了。</p><p>所以按照面向接口编程的思想，先为“应用目录服务”定义一下服务接口协议，也就是应用要提供哪些接口。</p><p>在今后的章节中，我们会定义许多框架级别的基础服务，这些服务我们都存放在框架目录中。<strong>服务的接口协议，统一放在框架目录下的framework/contract中，而对应的服务提供者和服务实现，统一存放在框架目录下的framework/provider中</strong>。</p><p>这里将所有框架级别的接口协议放在framework/contract中的设计有两个好处。</p><p>一是框架协议的关键字，我希望使用contract.xxx 这个语义来区分，比如App服务的接口为contract.App、日志服务的接口为contract.Log，它们的namespace都是contract，这样在使用的时候记忆成本会比较低。另外将框架提供的所有接口协议都放在一个文件夹中，在阅读框架提供哪些服务的时候，也更清晰明了。</p><p>以“应用目录服务”为例，我们在framework/contract目录中创建app.go 存放服务协议。在framework/contract/app.go中，我们定义应用目录服务接口名称为 App，代表整个应用。它对应的服务字符串凭证为“hade:app”。</p><pre><code class="language-go">const AppKey = "hade:app"\n</code></pre><p>这个接口的抽象，我们按照创建应用需要哪些目录的顺序来思考。</p><p>首先创建一个应用需要明确应用所在的根目录，这个就是根目录 BaseFolder；其次，我们需要一个目录保存配置文件，所以要有一个配置文件的目录 ConfigFolder；应用要输出日志，日志输出的存放路径也是需要设置的，所以我们再创建一个 LogFolder 来设置日志存放。</p><p>再考虑下，业务的服务提供者和对应接口需要有一个地方存放，我们将其命名为 ProviderFolder。同时，我们业务也有可能创建自己的中间件，所以需要有个 MiddlewareFolder 来存放中间件。</p><p>在后续的章节中，我们预计让框架支持命令行命令，并且使用命令行来控制进程的运行时状态，所以需要有个 CommandFolder 来存放各种命令行命令、一个 RuntimeFolder 来存放运行时的进程 ID 等信息。</p><p>最后当然了还需要有一个文件来存放单元测试信息，比如单元测试的初始化和终止的一些默认操作等，所以我们有一个 TestFolder 目录。</p><p>按照目前能想到的需求，可以将目录先分为这些文件夹，后续在开发模块的过程中，遇到需要增加的目录，我们还可以继续迭代修改 App 接口。</p><p>按照以上的分析，我们在框架的framework/contract/app.go中定义了一个 App 的服务接口：</p><pre><code class="language-go">package contract\n// AppKey 定义字符串凭证\nconst AppKey = "hade:app"\n// App 定义接口\ntype App interface {\n   // Version 定义当前版本\n   Version() string\n   //BaseFolder 定义项目基础地址\n   BaseFolder() string\n   // ConfigFolder 定义了配置文件的路径\n   ConfigFolder() string\n   // LogFolder 定义了日志所在路径\n   LogFolder() string\n   // ProviderFolder 定义业务自己的服务提供者地址\n   ProviderFolder() string\n   // MiddlewareFolder 定义业务自己定义的中间件\n   MiddlewareFolder() string\n   // CommandFolder 定义业务定义的命令\n   CommandFolder() string\n   // RuntimeFolder 定义业务的运行中间态信息\n   RuntimeFolder() string\n   // TestFolder 存放测试所需要的信息\n   TestFolder() string\n}\n</code></pre><h2>定义默认目录结构</h2><p>定义好了应用目录服务接口，我们再来思考它的实现，也就是设计使用这个 hade 框架的应用的默认目录。</p><p>目录结构的设计我们可以先去看看市面上的优秀框架，这里挑选的是 PHP 目前最火的应用框架 <a href="https://github.com/laravel/laravel">Laravel</a>，它的目录设计非常值得我们学习和参考，<strong>很合理地将各个功能模块放在各自的文件，并且文件定义清晰、无歧义</strong>。所以有了下面这个默认目录结构，我们来解释下对应的每个目录。</p><p><img src="https://static001.geekbang.org/resource/image/13/b7/131d82414bda554aa5d28a60a05801b7.png?wh=335x744" alt="图片"></p><p>在根目录下，有五个文件：app、framework、config、storage、test，我们一个个描述功能看看下面都应该怎么划分。</p><h3>app 目录</h3><p>一个业务就是一个 App，和业务代码相关的，比如所有的请求、控制台命令、控制器、服务提供者等都放在这个目录中，而业务逻辑代码之外的，比如配置文件、缓存、日志等，都放在外面。这样能把“业务逻辑”和“非业务逻辑”区分得更清晰。</p><p>我们继续看业务逻辑目录 app 下有哪些子目录。</p><p><img src="https://static001.geekbang.org/resource/image/62/37/62fd7201f0690235a505acda04e18337.jpg?wh=335x416" alt="图片"></p><p>第一层有三个目录：console、http、provider。因为业务除了提供 Web 服务，也提供控制台进程，所以在 app 目录下有两个子目录：一个是 console，业务中所有的控制台进程逻辑都放在这里；而另一个就是 http 目录，所有 Web 服务的逻辑都存放在里面。</p><p>同时这两者有很多逻辑是通用的，比如有可能用到同一个服务提供者，所以我们将两者通用的服务提供者的代码 provider 目录，也放在 app 目录下。</p><p>再看第二层的细分目录。</p><ul>\n<li>首先是 app 目录下的 console，存放的是所有命令行工具的逻辑代码。</li>\n</ul><p>控制台命令设计为多级命令，比如在命令  <code>./hade task info</code> 中，hade 是命令行工具，task 为一级命令，info 为二级命令。所以在 console 目录下，我们要创建一个 command 目录，并且 command 目录下按照一级、二级……递归保存。（关于命令行工具的更多详细设计和实现我们在下节课实现。）</p><ul>\n<li>提供 Web 服务的 http 目录还有更细的层级。</li>\n</ul><p>HTTP 服务一般会按照模块划分，比如一个图书馆业务，我们会分为注册模块、图书模块、用户模块等，所以我们在 http 目录下定义了一个 module 目录，这个 module 目录下每个子目录代表一个模块服务。而 Web 服务特有的通用中间件，我们使用 http 目录下的 middleware 目录来保存。</p><ul>\n<li>app 下的 provider 目录，提供的是定义一个服务需要的文件。</li>\n</ul><p>在 provider 目录中，每个子目录就代表一个业务服务。而按照上一节课描述的，每个服务都需要有三个文件：代表服务协议的 contract.go 文件、代表服务提供者的 provider.go 文件，以及代表具体服务实现的 service.go 文件。</p><p>这里要强调是，这个 provider 目录存放业务提供的服务，而框架提供的服务，我们会放在 framework 目录下。</p><p>app 目录我们解释完了，下面来研究根目录下的其他几个文件夹。</p><h3>framework 目录</h3><p>framework 目录就是我们这个框架所有的代码。在这个目录里，除了之前引入了 Gin 框架有的 gin 目录，还有一些子目录：command、contract、middleware、provider、util。</p><p><img src="https://static001.geekbang.org/resource/image/4f/2d/4f357e976abebac4b5cfafdcb2b1e72d.png?wh=321x647" alt="图片"></p><p>这几个目录的功能也比较好理解。command 提供的是框架自带的命令行工具；middleware 存放框架为 Web 服务提供的中间件；contract 存放框架默认提供的服务协议；而对应服务协议的具体实现以及服务提供者，我们存放在 provider 目录下；util 目录则存放在框架研发过程中通用的一些函数。</p><p>不难发现，provider和command的服务，在业务（app目录）和框架（framework目录）层面都有相同的目录，区别就是一个是业务提供的，一个是框架提供的。</p><p>我们这个项目为了演示框架开发的全过程，把框架和业务合并在一起，但是因为最终版框架在开源发布的时候，framework 目录是会剥离出去，作为一个单独的 git 项目的。所以，<strong>你在开发的时候要时刻明确，哪些是框架提供的命令行工具和服务，哪些是业务提供的命令行和服务</strong>。框架的内容需要放在 framework 目录下，业务的就要放在 framework 外。</p><h3>config、storage、test 目录</h3><p>在应用根目录下还剩 config 、storage、test 目录。config这个目录存放的是配置文件，至于不同环境的配置文件如何存放和组织，我们后面会统一探讨整体的配置文件存放机制。test 目录存放的是测试相关的信息，比如测试用例或者测试数据等信息。</p><p>应用根目录下的 storage 存放应用运行过程中产生的内容。首先是日志，日志是应用运行过程中必然产生的信息，在 storage 下的 log 子目录里保存；其次是运行的进程 ID 等信息，这些都会存放在 storage 下的 runtime 目录中。</p><p>好，目录结构讲完了，我们整理下，从应用根目录开始，分为 5 个子目录app、framework、config、storage、test，其中：</p><ul>\n<li>app 按应用的使用方式和通用性分为 console 和 http，以及通用的 provider 目录。framework 根据框架需要提供的功能分为 command、contract、gin、middleware、provider和util 6 个子目录。</li>\n<li>config 和 test 分别保存配置和测试相关的信息；storage 目录保存应用运行产生的信息，分为 log 和 runtime 两个目录。</li>\n</ul><h2>默认目录的实现</h2><p>在今天最开始我们说了，目录结构也是一个服务，其他服务想要使用目录结构的时候，可以通过服务容器，来获取目录结构服务实例。而现在我们有了想要创建的默认目录结构，那么下面就要实现这个目录结构服务实例了。</p><p>我们定义一个 HadeApp 来实现这个目录结构服务接口，<strong>这个 HadeApp 结构的元素除了服务实例之外，只需要一个项目的基础路径 basePath</strong>。因为我们设计的默认目录结构只要有了这个 basePath，就可以按照设计找出其余的所有目录了。</p><p>我们在framework/provider/app/service.go中定义HadeApp结构：</p><pre><code class="language-go">// HadeApp 代表 hade 框架的 App 实现\ntype HadeApp struct {\n   container framework.Container // 服务容器\n   baseFolder  string              // 基础路径\n}\n</code></pre><p>看最重要的 BaseFolder 的实现思路。</p><p>BaseFolder 是获取项目的基础路径，所以我们可以提供一种方式，在注册服务提供者的时候，实现 BaseFolder 的设置。来看代码，设置 hade 框架默认的 App 服务提供者为 HadeAppProvider，它带有一个可以设置的属性 BaseFolder，这个属性作为参数传入给服务实例初始化函数。</p><p>我们在framework/provider/app/provider.go中定义HadeAppProvider结构和方法：</p><pre><code class="language-go">// HadeAppProvider 提供 App 的具体实现方法\ntype HadeAppProvider struct {\n   BaseFolder string\n}\n\n...\n\n// Params 获取初始化参数\nfunc (h *HadeAppProvider) Params(container framework.Container) []interface{} {\n   return []interface{}{container, h.BaseFolder}\n}\n...\n\n\n\n// NewHadeApp 初始化 HadeApp\nfunc NewHadeApp(params ...interface{}) (interface{}, error) {\n   if len(params) != 2 {\n      return nil, errors.New("param error")\n   }\n   // 有两个参数，一个是容器，一个是 baseFolder\n   container := params[0].(framework.Container)\n   baseFolder := params[1].(string)\n   return &amp;HadeApp{baseFolder: baseFolder, container: container}, nil\n}\n</code></pre><p>这样，在业务目录的main.go中注册 App 服务的时候，就可以创建指定我们的 BaseFolder：</p><pre><code class="language-go">func main() {\n   // 创建 engine 结构\n   core := gin.New()\n   // 指定 BaseFolder\n   core.Bind(&amp;app.HadeAppProvider{BaseFolder: "/tmp"})\n   ...\n}\n</code></pre><p>但是刚才的实现在每次注册服务的时候，都需要设置一遍，为了提高易用性，我们希望这个 BaseFolder 能自动设置。怎么办？</p><p>这里要先考虑使用这个框架开发的业务的场景有哪些，一般来说会有两个，开发场景和运行场景。</p><p>在开发场景中，我们<strong>在开发业务代码时，这个 BaseFolder 代表业务的开发路径，即业务代码所在的目录；而在另一个运行场景中，框架开发的业务需要去现网，也就是生产环境中运行</strong>，只需要二进制文件、配置文件、日志文件即可，因为这时候的 BaseFolder 其实是会根据项目部署地址变化的。</p><p>所以对于第一种场景，我们提供获取当前开发路径的方法，可以使用 Golang 标准库的 os.Getwd() 方法获取到当前所在的开发路径。</p><pre><code class="language-go">// GetExecDirectory 获取当前执行程序目录\nfunc GetExecDirectory() string {\n   file, err := os.Getwd()\n   if err == nil {\n      return file + "/"\n   }\n   return ""\n}\n</code></pre><p>而对于第二种运行场景，我们希望这个 BaseFolder 在运行的时候再指定。所以可以<strong>为程序设计一个 base_folder 参数，这样在运行的时候，就解析参数将BaseFolder 设置对应值</strong>。借用 Golang 的 flag 标准库，我们能很容易做到解析参数、获取参数。</p><p>BaseFolder 的代码实现如下，其中有两次判断。我们先判断服务提供者是否有指定，如果有指定的话使用指定值，如果没有指定的话，再判断；如果是运行场景，看命令行参数中有没有传递 base_folder 参数，传递了就使用参数设置 BaseFolder，否则默认为开发场景，使用当前路径。</p><p>于是framework/provider/app/service.go定义BaseFolder如下：</p><pre><code class="language-go">// BaseFolder 表示基础目录，可以代表开发场景的目录，也可以代表运行时候的目录\nfunc (h HadeApp) BaseFolder() string {\n   if h.baseFolder != "" {\n      return h.baseFolder\n   }\n   // 如果没有设置，则使用参数\n   var baseFolder string\n   flag.StringVar(&amp;baseFolder, "base_folder", "", "base_folder 参数, 默认为当前路径")\n   flag.Parse()\n   if baseFolder != "" {\n      return baseFolder\n   }\n   // 如果参数也没有，使用默认的当前路径\n   return util.GetExecDirectory()\n}\n</code></pre><p>在 BaseFolder 的实现中，关键点就是需要区分业务场景。服务协议的其他接口基本都是从 BaseFolder 这个目录上进行扩展的。</p><p>比如存放日志的目录LogFolder，我们先通过BaseFolder定义出StorageFolder目录，然后再通过StorageFolder，定义出LogFolder的位置。同样在 framework/provider/app/service.go 中定义对应的StorageFolder和LogFolder下，在后面讲配置的时候会更新这段代码：</p><pre><code class="language-go">func (h HadeApp) StorageFolder() string {\n\treturn filepath.Join(h.BaseFolder(), "storage")\n}\n\n// LogFolder 表示日志存放地址\nfunc (h HadeApp) LogFolder() string {\n  return filepath.Join(h.StorageFolder(), "log")\n}\n</code></pre><p>其他目录地址的实现就不再赘述了，都是大同小异的。<br>\n本节课的所有代码我都存放在 GitHub 上的 <a href="https://github.com/gohade/coredemo/tree/geekbang/12">geekbang/12</a> 分支上了。这里附带上当前的代码结构截图。</p><p><img src="https://static001.geekbang.org/resource/image/7c/8f/7ce79e33e5d807ff58e269byy0a3f08f.png?wh=363x865" alt="图片"></p><h2>总结</h2><p>今天我们其实就讨论了一个核心问题：如何从框架层来规范业务的目录结构。是不是有点惊讶，只是一个目录结构的设计，居然也有如此多的门道。框架设计就是这样，好的框架之所以能让所有人都喜欢，就是因为具备非常优秀的设计感，在每个模块和每个细节点上，都包含作者的思考。</p><p>比如我们的目录结构，<strong>不仅仅是一种分目录的设计，还贯彻了面向接口的思想，将目录作为一个服务提供在服务容器中</strong>，后续的所有服务在使用到业务目录的时候，可以直接通过这个目录服务，获取具体的目录路径，是非常方便的。</p><h2>思考题</h2><p>我们对框架的目录做了详细的拆分，其中HTTP服务中的module目录，表示具体的业务模块。</p><p>这个业务模块的文件设计，我们没有限制，你可以使用MVC，也可以使用DDD来做具体的业务模块文件设计，这个文件结构不知道你日常有没有什么设计倾向？这是一个开放性问题，我们可以一起讨论。</p><p>欢迎在留言区分享你的思考。感谢你的收听，如果你觉得有收获，也欢迎你把今天的内容分享给你身边的朋友，邀他一起学习。我们下节课见。</p>',
        article_title: "12｜结构：如何系统设计框架的整体目录？",
      },
      {
        title: "13｜交互：可以执行命令行的框架才是好框架",
        id: 426765,
        content:
          '<p>你好，我是轩脉刃。</p><p>上一节课，我们开始把框架向工业级迭代，重新规划了目录，这一节课将对框架做更大的改动，让框架支持命令行工具。</p><p>一个拥有命令行工具的框架会非常受欢迎。比如 Beego 框架提供了一个命令行工具 Bee、Vue 框架提供了 Vue-CLI，这些工具无疑给框架的使用者提供了不少便利。在使用框架过程中，命令行工具能将很多编码行为自动化。</p><p>而且退一步说，在实际工作中你会发现，即使用的框架没有提供任何命令行工具，在业务运营的过程中，我们也需要开发各种大大小小的命令行运营工具，作为业务运营的必要辅助。所以一个自带命令行工具，且很方便让用户自行开发命令行的框架，是非常有必要的。</p><p>这节课我们就研究一下如何将hade框架改造成为支持命令行交互的框架。</p><h2>第三方命令行工具库 cobra</h2><p>要让一个程序支持命令行，那么它的核心功能就是要能解析参数，比如 <code>./hade app start --address=:8888</code> 其中的 ./hade 是我们要运行的程序，而后面的 app 和 start 两个字段以及–address=:8888 就是这个程序对应的参数了。</p><p>那么如何解析参数呢？</p><p>Golang 标准库提供了 flag 包能对参数进行解析。但是 flag 包<strong>只是一个命令行解析的类库，不支持组织，所以如果想基于 flag 包实现父子命令行工具，显然就不够了</strong>。出于不重复造轮子，站在巨人肩膀上的想法，我们将视线移向开源社区一个最出名的命令行工具库 <a href="https://github.com/spf13/cobra">cobra</a>。</p><!-- [[[read_end]]] --><p>cobra 是由大名鼎鼎的谷歌工程师 Steve Francia（spf13）开发并开源的一个项目。Steve Francia 是 Golang 开源界比较出名的一名程序员，是 Golang、Doctor、MongoDB 的开源贡献者，同时开源的 hugo、viper 等项目应用也非常广泛。而由他开发开源的 cobra 目前在 GitHub 上已经有了 23k 的 star。</p><p>cobra 不仅仅能让我们快速构建一个命令行，它更大的优势是能更快地组织起有许多命令行工具，因为从根命令行工具开始，cobra 把所有的命令按照树形结构组织起来了。</p><p><img src="https://static001.geekbang.org/resource/image/68/33/6812f5845567d0c771dea8190eb35e33.jpg?wh=1920x1080" alt=""></p><p>要使用 cobra 就要从源码上了解这个库。按照第一节课说的，按照 <strong>库函数 &gt; 结构定义 &gt; 结构函数</strong>的顺序读，你会发现，cobra 这个库最核心的内容是一个数据结构 <a href="https://github.com/spf13/cobra/blob/master/command.go">Command</a> 。</p><p>一个 Command 代表一个执行命令。这个 Command 包含很多可设置的字段，如何使用这个 Command，就取决于我们如何设置这些属性。下面是源码片段，我在注释中列出了这些属性的意义。</p><pre><code class="language-go">// Command代表执行命令的结构\ntype Command struct {\n&nbsp; &nbsp; &nbsp; &nbsp; // 代表当前命令的，如何执行，root 最好和生成的命令工具名称一致\n&nbsp; &nbsp; &nbsp; &nbsp; Use string\n        \n        // 代表这个工具的别名，在 subCommand 中有用，比如 root cmd1 和 root cmd_1 想要都执行一个 subCommand 就需要这样\n&nbsp; &nbsp; &nbsp; &nbsp; Aliases []string\n\n&nbsp; &nbsp; &nbsp; &nbsp; // 由于不强制设置，用于输入错误的时候建议字段\n&nbsp; &nbsp; &nbsp; &nbsp; SuggestFor []string\n\n&nbsp; &nbsp; &nbsp; &nbsp; // 这个就是在 help 的时候一句话描述这个命令的功能\n&nbsp; &nbsp; &nbsp; &nbsp; Short string\n\n&nbsp; &nbsp; &nbsp; &nbsp; // 详细描述这个命令的功能\n&nbsp; &nbsp; &nbsp; &nbsp; Long string\n\n&nbsp; &nbsp; &nbsp; &nbsp; // 例子\n&nbsp; &nbsp; &nbsp; &nbsp; Example string\n\n&nbsp; &nbsp; &nbsp; &nbsp; // 需要验证的参数\n&nbsp; &nbsp; &nbsp; &nbsp; ValidArgs []string\n\n&nbsp; &nbsp; &nbsp; &nbsp; // 有多少个参数，这里放了一个验证函数，可以是 ExactArgs，MaximumNArgs 等，验证有多少个参数\n&nbsp; &nbsp; &nbsp; &nbsp; Args PositionalArgs\n\n&nbsp; &nbsp; &nbsp; &nbsp; // 参数别名\n&nbsp; &nbsp; &nbsp; &nbsp; ArgAliases []string\n\n&nbsp; &nbsp; &nbsp; &nbsp; // 自动生成的命令设置\n&nbsp; &nbsp; &nbsp; &nbsp; BashCompletionFunction string\n\n&nbsp; &nbsp; &nbsp; &nbsp; // 如果这个命令已经废弃了，那么就这里写上废弃信息\n&nbsp; &nbsp; &nbsp; &nbsp; Deprecated string\n\n&nbsp; &nbsp; &nbsp; &nbsp; // 如果这个命令要被隐藏，设置这个字段\n&nbsp; &nbsp; &nbsp; &nbsp; Hidden bool\n\n&nbsp; &nbsp; &nbsp; &nbsp; // Annotations are key/value pairs that can be used by applications to identify or\n&nbsp; &nbsp; &nbsp; &nbsp; // group commands.\n&nbsp; &nbsp; &nbsp; &nbsp; Annotations map[string]string\n\n&nbsp; &nbsp; &nbsp; &nbsp; // 这个命令的版本\n&nbsp; &nbsp; &nbsp; &nbsp; Version string\n\n        // 是否要打印错误信息\n        SilenceErrors bool\n\n        // 是否要打印如何使用\n        SilenceUsage bool\n\n        // 是否有 flag，如果这个命令没有 flag，设置为 true，那么所有的命令后面的参数都会是 arguments\n        DisableFlagParsing bool\n\n        // 是否打印自动生成字样： ("Auto generated by spf13/cobra...")\n        DisableAutoGenTag bool\n\n        // 是否显示[flags]字样\n        DisableFlagsInUseLine bool\n\n        // 是否打印建议\n        DisableSuggestions bool\n\n        // 两个字符串的差距多少会进入 suggest\n        SuggestionsMinimumDistance int\n\n        // 是否使用 Traverse 的方式来解析参数\n        TraverseChildren bool\n\n        // 解析错误白名单, 比如像未知参数\n        FParseErrWhitelist FParseErrWhitelist\n        \n        // The *Run 函数运行顺序：\n        //   * PersistentPreRun()\n        //   * PreRun()\n        //   * Run()\n        //   * PostRun()\n        //   * PersistentPostRun()\n&nbsp; &nbsp; &nbsp; &nbsp; // 会被继承的前置 Run\n&nbsp; &nbsp; &nbsp; &nbsp; PersistentPreRun func(cmd *Command, args []string)\n\n&nbsp; &nbsp; &nbsp; &nbsp; // 会被继承的前置 Run, 带 error\n&nbsp; &nbsp; &nbsp; &nbsp; PersistentPreRunE func(cmd *Command, args []string) error\n\n&nbsp; &nbsp; &nbsp; &nbsp; // 当前这个命令的前置 Run\n&nbsp; &nbsp; &nbsp; &nbsp; PreRun func(cmd *Command, args []string)\n&nbsp; &nbsp; &nbsp; &nbsp; // 当前这个命令的前置 Run，带 Error\n&nbsp; &nbsp; &nbsp; &nbsp; PreRunE func(cmd *Command, args []string) error\n&nbsp; &nbsp; &nbsp; &nbsp; // zh: 实际跑的时候运行的函数\n&nbsp; &nbsp; &nbsp; &nbsp; Run func(cmd *Command, args []string)\n&nbsp; &nbsp; &nbsp; &nbsp; // zh: Run 执行错误了之后\n&nbsp; &nbsp; &nbsp; &nbsp; RunE func(cmd *Command, args []string) error\n&nbsp; &nbsp; &nbsp; &nbsp; // 后置运行\n&nbsp; &nbsp; &nbsp; &nbsp; PostRun func(cmd *Command, args []string)\n&nbsp; &nbsp; &nbsp; &nbsp; // 后置运行，带 error\n&nbsp; &nbsp; &nbsp; &nbsp; PostRunE func(cmd *Command, args []string) error\n&nbsp; &nbsp; &nbsp; &nbsp; // 会被继承的后置运行\n&nbsp; &nbsp; &nbsp; &nbsp; PersistentPostRun func(cmd *Command, args []string)\n&nbsp; &nbsp; &nbsp; &nbsp; // 会被继承的后置运行，带 error\n&nbsp; &nbsp; &nbsp; &nbsp; PersistentPostRunE func(cmd *Command, args []string) error\n\n&nbsp; &nbsp; &nbsp; &nbsp; \n}\n</code></pre><p>这里属性非常多，你也不需要都记住是啥。来看一些常用属性，我们用一个设置好的输出结果图就能很好理解。</p><p><img src="https://static001.geekbang.org/resource/image/15/ed/159f41e9792178f9ca60950192fee4ed.png?wh=1186x956" alt=""></p><p>它对应的代码如下，后面会解释每一行都是怎么实现的：</p><pre><code class="language-go">// InitFoo 初始化 Foo 命令\nfunc InitFoo() *cobra.Command {\n   FooCommand.AddCommand(Foo1Command)\n   return FooCommand\n}\n// FooCommand 代表 Foo 命令\nvar FooCommand = &amp;cobra.Command{\n   Use:     "foo",\n   Short:   "foo 的简要说明",\n   Long:    "foo 的长说明",\n   Aliases: []string{"fo", "f"},\n   Example: "foo 命令的例子",\n   RunE: func(c *cobra.Command, args []string) error {\n      container := c.GetContainer()\n      log.Println(container)\n      return nil\n   },\n}\n// Foo1Command 代表 Foo 命令的子命令 Foo1\nvar Foo1Command = &amp;cobra.Command{\n   Use:     "foo1",\n   Short:   "foo1 的简要说明",\n   Long:    "foo1 的长说明",\n   Aliases: []string{"fo1", "f1"},\n   Example: "foo1 命令的例子",\n   RunE: func(c *cobra.Command, args []string) error {\n      container := c.GetContainer()\n      log.Println(container)\n      return nil\n   },\n}\n</code></pre><p>对照代码和输出结果图，能看出 Command 中最常用的一些字段设置。</p><ul>\n<li>Use 代表这个命令的调用关键字，比如要调用 Foo1 命令，我们就要用  <code>./hade foo foo1</code> 。Short 代表这个命令的简短说明，它会出现在上级命令的使用文档中。</li>\n<li>Long 代表这个命令的长说明，它会出现在当前命令的使用文档中。</li>\n<li>Aliases 是当前命令的别名，等同于 Use 字段；</li>\n<li>Example 是当前命令的例子，也是显示在当前命令的使用文档中。</li>\n</ul><p>而 <strong>RunE 代表当前命令的真正执行函数</strong>：</p><pre><code class="language-go">RunE: func(c *cobra.Command, args []string) error \n</code></pre><p>这个执行函数的参数有两个：一个是 cobra.Command，表示当前的这个命令；而第二个参数是 args，表示当前这个命令的参数，返回值是一个 error，代表命令的执行成功或者失败。</p><h2>如何使用命令行 cobra</h2><p>现在大致了解 cobra 这个库的使用方法和最核心的 Command 结构，就要想想接下来我们要用它来做些什么事情了。</p><p><strong>首先，要把 cobra 库引入到框架中</strong>。由于希望后续能修改 Command 的数据，并且在后面的章节中会在 Command 结构中，继续加入一些字段来支持定时的命令行，所以和 Gin 框架的引入一样，我们采用源码引入的方式。</p><p>引入后要对 Command 结构进行修改。我们希望把服务容器嵌入到 Command 结构中，让 Command 在调用执行函数 RunE 时，能从参数中获取到服务容器，这样就能从服务容器中使用之前定义的 Make 系列方法获取出具体的服务实例了。</p><p>那服务容器嵌到哪里合适呢？因为刚才说，在 cobra 中 Command 结构是一个树形结构，所有的命令都是由一个根 Command 衍生来的。所以我们可以在根 Command 中设置服务容器，让所有的子 Command 都可以根据 Root 方法来找到树的根 Command，最终找到服务容器。</p><p>不要忘记了，最终目的是完善 Web 框架，所以<strong>之前存放在 main 函数中的启动 Web 服务的一些方法我们也要做修改</strong>，让它们能通过一个命令启动。main 函数不再是启动一个 Web 服务了，而是启动一个 cobra 的命令。</p><p>也就是说，我们将Web服务的启动逻辑封装为一个Command命令，将这个Command挂载到根Command中，然后根据参数获取到这个 Command 节点，执行这个节点中的 RunE 方法，就能启动Web服务了。</p><p><strong>但是在调用Web服务所在节点的RunE方法的时候，存在一个Engine结构的传递问题</strong>。</p><p>在main函数中，我们使用gin.New创建了一个Engine结构，在业务中对这个Engine结构进行路由设置，这些都应该在业务代码中。而后，我们就进入了框架代码中，调用Web服务所在Command节点的RunE方法，在这个方法里进行初始化http.Server，并且启动Goroutine进行监听：</p><pre><code class="language-go">func main() {\n   // 创建engine结构\n   core := gin.New()\n   ...\n\n   hadeHttp.Routes(core)\n\n   server := &amp;http.Server{\n      Handler: core,\n      Addr:    ":8888",\n   }\n\n   // 这个goroutine是启动服务的goroutine\n   go func() {\n      server.ListenAndServe()\n   }()\n   ...\n}\n</code></pre><p>也就是说，我们只能根据 Command 拿到服务容器，那怎么拿到 Gin 函数创建的 Engine 结构呢？这个问题我提供一个解决思路，是否可以将“提供服务引擎”作为一个接口，通过服务提供者注入进服务容器？这样就能在命令行中就能获取服务容器了。</p><h2>使用 cobra 增加框架的交互性</h2><p>现在思路有了，可能发生的问题也想到了，下面进入实操。</p><p>首先是源码引入 cobra 库。引入的方式基本上和 Gin 框架引入的方式一样，先看下 cobra 源码的许可证，是 Apache License。这种许可证允许修改、商用、私有化等，只要求保留著作声明。所以我们直接拷贝最新的 cobra 源码，用 cobra<a href="https://github.com/spf13/cobra/tree/v1.2.1"> v1.2.1 版本</a>，将它放在 framework/cobra 目录下。</p><p><img src="https://static001.geekbang.org/resource/image/1e/1e/1e64756d99eeecbb99034d99682be71e.png?wh=456x556" alt=""></p><p>然后，对 Command 结构进行修改。要在 Command 结构中加入服务容器，由于刚才是源码引入的，很容易为 Command 增加一个container字段，在framework/cobra/command.go中修改Command结构：</p><pre><code class="language-go">type Command struct {\n   // 服务容器\n   container framework.Container\n   ...\n}\n</code></pre><p><strong>再为 Command 提供两个方法：设置服务容器、获取服务容器</strong>。设置服务容器的方法是为了在创建根 Command 之后，能将服务容器设置到里面去；而获取服务容器的方法，是为了在执行命令的 RunE 函数的时候，能从参数 Command 中获取到服务容器。</p><p>将定义的方法放在单独的一个文件framework/cobra/hade_command.go中。</p><pre><code class="language-go">// SetContainer 设置服务容器\nfunc (c *Command) SetContainer(container framework.Container) {\n   c.container = container\n}\n// GetContainer 获取容器\nfunc (c *Command) GetContainer() framework.Container {\n   return c.Root().container\n}\n</code></pre><p>做到这里，前面两步cobra的引入和Command结构的修改就都完成了。</p><h2>将 Web 启动改成一个命令</h2><p>第三步，如何改造 Web 启动服务是最繁琐的，先简单梳理一下。</p><ul>\n<li>把创建 Web 服务引擎的方法作为一个服务封装在服务容器中，完成准备工作。</li>\n<li>开始 main 函数的改造。首先要做的必然是初始化一个服务容器，然后将各个服务绑定到这个服务容器中，有一个就是刚才定义的提供 Web 引擎的服务。</li>\n<li>在业务代码中将业务需要的路由绑定到 Web 引擎中去。</li>\n<li>完成服务的绑定之后，最后要创建一个根Command，并且创建一个Web启动的Command，这两个Command会形成一个树形结构。</li>\n</ul><p>我们先要将创建 Web 服务引擎的方法作为一个服务封装在服务容器中，按照<a href="https://time.geekbang.org/column/article/424529">第十节课</a>封装服务的三个步骤：封装接口协议、定义一个服务提供者、初始化服务实例。</p><p>在framework/contract/kernel.go中，把创建 Engine 的过程封装为一个服务接口协议：</p><pre><code class="language-go">// KernelKey 提供 kenel 服务凭证\nconst KernelKey = "hade:kernel"\n\n// Kernel 接口提供框架最核心的结构\ntype Kernel interface {\n   // HttpEngine http.Handler结构，作为net/http框架使用, 实际上是gin.Engine\n   HttpEngine() http.Handler\n}\n</code></pre><p>在定义的 Kernel 接口，提供了 HttpEngine 的方法，返回了net/http 启动的时候需要的 http.Handler接口，并且设置它在服务容器中的字符串凭证为"hade:kernel"。<br>\n然后为这个服务定义一个服务提供者。这个服务提供者可以在初始化服务的时候传递 Web 引擎，如果初始化的时候没有传递，则需要在启动的时候默认初始化。</p><p>在对应的Kernel的服务提供者代码framework/provider/kernel/provider.go中，我们实现了服务提供者需要实现的五个函数Register、Boot、isDefer、Params、Name。</p><pre><code class="language-go">package kernel\nimport (\n   "github.com/gohade/hade/framework"\n   "github.com/gohade/hade/framework/contract"\n   "github.com/gohade/hade/framework/gin"\n)\n\n// HadeKernelProvider 提供web引擎\ntype HadeKernelProvider struct {\n   HttpEngine *gin.Engine\n}\n\n// Register 注册服务提供者\nfunc (provider *HadeKernelProvider) Register(c framework.Container) framework.NewInstance {\n   return NewHadeKernelService\n}\n\n// Boot 启动的时候判断是否由外界注入了Engine，如果注入的化，用注入的，如果没有，重新实例化\nfunc (provider *HadeKernelProvider) Boot(c framework.Container) error {\n   if provider.HttpEngine == nil {\n      provider.HttpEngine = gin.Default()\n   }\n   provider.HttpEngine.SetContainer(c)\n   return nil\n}\n\n// IsDefer 引擎的初始化我们希望开始就进行初始化\nfunc (provider *HadeKernelProvider) IsDefer() bool {\n   return false\n}\n\n// Params 参数就是一个HttpEngine\nfunc (provider *HadeKernelProvider) Params(c framework.Container) []interface{} {\n   return []interface{}{provider.HttpEngine}\n}\n\n// Name 提供凭证\nfunc (provider *HadeKernelProvider) Name() string {\n   return contract.KernelKey\n}\n</code></pre><p>创建服务的第三步就是初始化实例了。这个服务实例比较简单，就是一个包含着 Web 引擎的服务结构。在刚才实现的 HttpEngine()接口中，把服务结构中包含的 Web 引擎返回即可。</p><pre><code class="language-go">// 引擎服务\ntype HadeKernelService struct {\n   engine *gin.Engine\n}\n\n// 初始化 web 引擎服务实例\nfunc NewHadeKernelService(params ...interface{}) (interface{}, error) {\n   httpEngine := params[0].(*gin.Engine)\n   return &amp;HadeKernelService{engine: httpEngine}, nil\n}\n\n// 返回 web 引擎\nfunc (s *HadeKernelService) HttpEngine() http.Handler {\n   return s.engine\n}\n</code></pre><p>现在我们完成了Web服务Kernel的设计，转而我们改造一下入口函数。 main 函数是我们的入口，但是现在，入口函数就不再是启动一个 HTTP 服务了，而是执行一个命令。那么这个 main 函数要做些什么呢？</p><p>整个框架目前都是围绕服务容器进行设计的了。所以在业务目录的main.go的 main 函数中，我们第一步要做的，必然是初始化一个服务容器。</p><pre><code class="language-go">// 初始化服务容器\ncontainer := framework.NewHadeContainer()\n</code></pre><p>接着，要将各个服务绑定到这个服务容器中。目前要绑定的服务容器有两个，一个是上一节课我们定义的目录结构服务HadeAppProvider，第二个是这节课定义的提供 Web 引擎的服务。</p><pre><code class="language-go">// 绑定 App 服务提供者\ncontainer.Bind(&amp;app.HadeAppProvider{})\n\n// 后续初始化需要绑定的服务提供者...\n// 将 HTTP 引擎初始化,并且作为服务提供者绑定到服务容器中\nif engine, err := http.NewHttpEngine(); err == nil {\n   container.Bind(&amp;kernel.HadeKernelProvider{HttpEngine: engine})\n}\n</code></pre><p>http.NewHttpEngine 这个创建 Web 引擎的方法必须放在业务层，因为这个 Web 引擎不仅仅是调用了 Gin 创建 Web 引擎的方法，更重要的是调用了业务需要的绑定路由的功能。</p><p>将业务需要的路由绑定到 Web 引擎中去。因为这个是业务逻辑，我们放在业务目录的app/kernel.go 文件中：</p><pre><code class="language-go">// NewHttpEngine 创建了一个绑定了路由的 Web 引擎\nfunc NewHttpEngine() (*gin.Engine, error) {\n   // 设置为 Release，为的是默认在启动中不输出调试信息\n   gin.SetMode(gin.ReleaseMode)\n   // 默认启动一个 Web 引擎\n   r := gin.Default()\n   // 业务绑定路由操作\n   Routes(r)\n   // 返回绑定路由后的 Web 引擎\n   return r, nil\n}\n</code></pre><p>而对应的业务绑定路由操作，还是放在业务代码的app/http/route.go中：</p><pre><code class="language-plain">\n// Routes 绑定业务层路由\nfunc Routes(r *gin.Engine) {\n\n   r.Static("/dist/", "./dist/")\n\n   demo.Register(r)\n}\n</code></pre><p>完成服务提供者的绑定和路由设置之后，<strong>最后要创建一个根 Command，并且将业务的 Command 和框架定义的 Command 都加载到根 Command 中，形成一个树形结构</strong>。</p><p>在 main 中，我们用 console.RunCommand 来创建和运行根 Command。</p><pre><code class="language-go">// 运行 root 命令\nconsole.RunCommand(container)\n</code></pre><p>而这里RunCommand 的方法简要来说做了三个事情：</p><ol>\n<li>创建根 Command，并且将容器设置进根 Command 中。</li>\n<li>绑定框架和业务的 Command 命令。</li>\n<li>调用 Execute 启动命令结构。</li>\n</ol><p>具体的代码实现放在业务目录的app/console/kernel.go文件中，如下：</p><pre><code class="language-go">// RunCommand  初始化根 Command 并运行\nfunc RunCommand(container framework.Container) error {\n   // 根 Command\n   var rootCmd = &amp;cobra.Command{\n      // 定义根命令的关键字\n      Use: "hade",\n      // 简短介绍\n      Short: "hade 命令",\n      // 根命令的详细介绍\n      Long: "hade 框架提供的命令行工具，使用这个命令行工具能很方便执行框架自带命令，也能很方便编写业务命令",\n      // 根命令的执行函数\n      RunE: func(cmd *cobra.Command, args []string) error {\n         cmd.InitDefaultHelpFlag()\n         return cmd.Help()\n      },\n      // 不需要出现 cobra 默认的 completion 子命令\n      CompletionOptions: cobra.CompletionOptions{DisableDefaultCmd: true},\n   }\n   // 为根 Command 设置服务容器\n   rootCmd.SetContainer(container)\n   // 绑定框架的命令\n   command.AddKernelCommands(rootCmd)\n   // 绑定业务的命令\n   AddAppCommand(rootCmd)\n   // 执行 RootCommand\n   return rootCmd.Execute()\n</code></pre><p>仔细看这段代码，我们这一节课前面说的内容都在这里得到了体现。</p><p>首先，根 Command 的各个属性设置是基于我们对 cobra 的 Command 结构比较熟悉才能进行的；而为根 Command 设置服务容器，我们用之前为服务容器扩展的 SetContainer 方法设置的；最后运行 cobra 的命令是调用 Execute 方法来实现的。</p><p>这里额外注意下， 这里有<strong>两个函数 AddKernelCommands 和 AddAppCommand，分别是将框架定义的命令和业务定义的命令挂载到根Command下</strong>。</p><p>框架定义的命令我们使用framework/command/kernel.go 中的 AddKernelCommands 进行挂载。而业务定义的命令我们使用 app/console/kernel.go 中的 AddAppCommand进行挂载。比如下面要定义的启动服务的命令 appCommand 是所有业务通用的一个框架命令，最终会在 framework/command/kernel.go 的 AddKernelCommands 中进行挂载。</p><h3>启动服务</h3><p>现在已经将 main 函数改造成根据命令行参数定位 Command 树并执行，且在执行函数的参数 Command 中已经放入了服务容器，在服务容器中我们也已经注入了 Web 引擎。那么下面就来创建一个命令  <code>./hade app start</code> 启动 Web 服务。</p><p>这个命令和业务无关，是框架自带的，所以它的实现应该放在 frame/command 下，而启动 Web 服务的命令是一个二级命令，其一级命令关键字为 app，二级命令关键字为 start。</p><p>那么我们先创建一级命令，这个一级命令 app 没有具体的功能，只是打印帮助信息。在framework/command/app.go中定义appCommand：</p><pre><code class="language-go">// AppCommand 是命令行参数第一级为 app 的命令，它没有实际功能，只是打印帮助文档\nvar appCommand = &amp;cobra.Command{\n   Use:   "app",\n   Short: "业务应用控制命令",\n   RunE: func(c *cobra.Command, args []string) error {\n      // 打印帮助文档\n      c.Help()\n      return nil\n   },\n}\n</code></pre><p><strong>而二级命令关键字为 start，它是真正启动 Web 服务的命令</strong>。这个命令的启动执行函数有哪些逻辑呢？</p><p>首先，它需要获取 Web 引擎。具体方法根据前面讲的，要从参数 Command 中获取服务容器，从服务容器中获取引擎服务实例，从引擎服务实例中获取 Web 引擎：</p><pre><code class="language-go">// 从 Command 中获取服务容器\ncontainer := c.GetContainer()\n// 从服务容器中获取 kernel 的服务实例\nkernelService := container.MustMake(contract.KernelKey).(contract.Kernel)\n// 从 kernel 服务实例中获取引擎\ncore := kernelService.HttpEngine()\n</code></pre><p>获取到了 Web 引擎之后如何启动 Web 服务，就和第一节课描述的一样，通过创建 http.Server，并且调用其 ListenAndServe 方法。这里贴一下具体的appStartCommand命令的实现，供你参考思路，在framework/command/app.go中：</p><pre><code class="language-go">// appStartCommand 启动一个Web服务\nvar appStartCommand = &amp;cobra.Command{\n   Use:   "start",\n   Short: "启动一个Web服务",\n   RunE: func(c *cobra.Command, args []string) error {\n      // 从Command中获取服务容器\n      container := c.GetContainer()\n      // 从服务容器中获取kernel的服务实例\n      kernelService := container.MustMake(contract.KernelKey).(contract.Kernel)\n      // 从kernel服务实例中获取引擎\n      core := kernelService.HttpEngine()\n\n      // 创建一个Server服务\n      server := &amp;http.Server{\n         Handler: core,\n         Addr:    ":8888",\n      }\n\n      // 这个goroutine是启动服务的goroutine\n      go func() {\n         server.ListenAndServe()\n      }()\n\n      // 当前的goroutine等待信号量\n      quit := make(chan os.Signal)\n      // 监控信号：SIGINT, SIGTERM, SIGQUIT\n      signal.Notify(quit, syscall.SIGINT, syscall.SIGTERM, syscall.SIGQUIT)\n      // 这里会阻塞当前goroutine等待信号\n      &lt;-quit\n\n      // 调用Server.Shutdown graceful结束\n      timeoutCtx, cancel := context.WithTimeout(context.Background(), 5*time.Second)\n      defer cancel()\n\n      if err := server.Shutdown(timeoutCtx); err != nil {\n         log.Fatal("Server Shutdown:", err)\n      }\n\n      return nil\n   },\n}\n</code></pre><p><strong>最后将RootCommand和AppCommand进行关联</strong>。在framework/command/app.go中定义initAppCommand()方法，将appStartCommand作为appCommand的子命令：</p><pre><code class="language-go">// initAppCommand 初始化app命令和其子命令\nfunc initAppCommand() *cobra.Command {\n   appCommand.AddCommand(appStartCommand)\n   return appCommand\n}\n</code></pre><p>在framework/command/kernel.go中，挂载对应的appCommand的命令：</p><pre><code class="language-go">// AddKernelCommands will add all command/* to root command\nfunc AddKernelCommands(root *cobra.Command) {\n   // 挂载AppCommand命令\n   root.AddCommand(initAppCommand())\n}\n</code></pre><p>我们就完成了Web启动的改造工作了。</p><h2>验证</h2><p>好了到这里，整个命令行工具就引入成功，并且Web 框架也改造完成了。下面做一下验证。编译后调用./hade ，我们获取到根 Command 命令行工具的帮助信息：</p><p><img src="https://static001.geekbang.org/resource/image/yy/cf/yy95ac2233fd4145a311f80422422dcf.png?wh=1418x824" alt=""></p><p>提示可以通过一级关键字 app 获取下一级命令：</p><p><img src="https://static001.geekbang.org/resource/image/29/c2/2969de0887cbf2b918374279f9d031c2.png?wh=1034x676" alt=""></p><p>而./hade app 提醒我们可以通过二级关键字 start 来启动一个 Web 服务，调用  <code>./hade app start</code> 。</p><p>Web 服务启动成功，通过浏览器可以访问到业务定义的/demo/demo 路径。</p><p><img src="https://static001.geekbang.org/resource/image/52/3b/52d5f4d8fc431ab7853def837b78e73b.png?wh=1390x804" alt=""></p><p>今天所有代码都存放在GitHub 的 <a href="https://github.com/gohade/coredemo/tree/geekbang/13">geekbang/13</a> 分支了，文中未展示的代码直接参考这个分支。本节课结束对应的目录结构如下：</p><p><img src="https://static001.geekbang.org/resource/image/3f/5e/3f0b7e94b7f7d10bc0e2b23aca54145e.png?wh=377x1279" alt=""></p><h2>总结</h2><p>今天我们把之前的 Web 框架改造成了一个命令行工具，引入了 cobra 库，并且将原本的进程启动，也就是启动 Web 服务的方式，改成了调用一个命令来启动 Web 服务。</p><p>不知道你有没有感觉，将框架的入口改造成命令行，这个设计<strong>不仅仅是简单换了一种 Web 服务的启动方式，而且是扩展了框架的另外一种可能性——设计命令行工具</strong>。改造后，这个框架可以用来开发业务需要的各种命令行工具，同时也允许我们后续为框架增加多种多样易用性高的工具。</p><h2>思考题</h2><p>其实在之前的版本，我在framework/contract/kernel.go是这么设计kernel服务接口的：</p><pre><code class="language-go">package contract\n\nconst KernelKey = "hade:kernel"\n\n// Kernel 接口提供框架最核心的结构\ntype Kernel interface {\n   // HttpEngine 提供gin的Engine结构\n   HttpEngine() *gin.Engine\n}\n</code></pre><p>在provider/kernel/service.go中是这么实现接口的：</p><pre><code class="language-go">// 返回web引擎\nfunc (s *HadeKernelService) HttpEngine() *gin.Engine {\n   return s.engine\n}\n</code></pre><p>和现在实现最大的不同是返回值。之前的返回值是返回了 *gin.Engine。而现在的返回值是返回了http.Handler，其他的实现没有任何变化。你能看出这样的改动相较之前有什么好处么？为什么这么改？</p><p>欢迎在留言区分享你的思考。感谢你的阅读，如果觉得有收获，也欢迎你把今天的内容分享给你身边的朋友，邀他一起学习。我们下节课见。</p>',
        article_title: "13｜交互：可以执行命令行的框架才是好框架",
      },
      {
        title: "14｜定时任务：如何让框架支持分布式定时脚本？",
        id: 427090,
        content:
          '<p>你好，我是轩脉刃。</p><p>上一节课，我们改造框架让它支持命令行工具了。这样业务开发者可以使用框架定义好的命令行工具来执行框架预设的一些行为，比如启动一个Web服务，也可以自己定义业务需要的命令行工具来执行业务行为，非常方便。</p><p>今天继续思考如何优化，因为业务在开发过程中，不可能每个命令都要手动操作，定时执行某个命令的需求应该是非常普遍的。比如设计一个定时扫描数据命令来发送统计报告，或者设计一个定时删除某些过期数据的命令。</p><p>那我们的框架是否能支持这个需求，如果要开发一个定时命令，能不能做到在业务中增加一行代码就行了？这节课我们就来挑战这个目标。</p><h2>使用timer定时执行命令</h2><p>怎么做到计时执行这个事情呢？Golang有个标准库time，里面提供一个计时器timer的结构，是否可以使用这个timer来执行呢？我们先来看看timer是怎么使用的：</p><pre><code class="language-go">func main() { \n  timer := time.NewTimer(3 * time.Second) // 定一个计时器，3s后触发\n  select { \n    now &lt;-timer.C:  // 监听计时器中的事件\n      fmt.Println("3秒执行任务, 现在时间", now)  //3s后执行\n  } \n}\n</code></pre><p>首先time.NewTimer会初始化一个计时器，这个计时器到定时时间后，就从C这个channel中返回一个时间Time。逻辑很简单。所以我们的main函数只需要监听timer.C这个channel，一旦有时间从这个channel中出来，就说明到计时器时间了。</p><!-- [[[read_end]]] --><p>知道如何定时执行了，接下来得结合实际业务场景考虑会存在什么问题了：<strong>如果有一堆定时任务，要怎么定时执行呢</strong>？</p><p>这个也难不倒我们：遍历所有的定时任务，计算出这些定时任务下一次要执行的时间，然后按照从近到远排序，用timer来设置一个定时器到最近的时间触发，然后等计时一到，开启一个Goroutine触发执行。触发之后再进行一轮计算，计算出所有定时任务下一次要执行的时间，再初始化一个定时器。</p><p>写一下大致的伪代码如下。</p><ul>\n<li>假设定义每个定时任务结构为Entry，先计算每个Entry的下一次运行的时间，接着进入循环；</li>\n<li>在循环中，根据Next排序，然后根据最近的Entry实例化一个计时器，进入阻塞等待；</li>\n<li>等计时器时间到了，通过timer.C获取到时间，再进行遍历，把到了时间的任务进行一次执行，并且更新所有任务的下次执行时间。</li>\n</ul><pre><code class="language-go">// Entity代表每个定时任务\nentries := []Entry\t\n\n// 计算每个定时任务时间\nfor _, entry := entries {\n  entry.Next = next(entry)\n}\n\nfor {\n    // 根据Next时间排序\n    sortByTime(entries)\n    \n    // 创建计时器\n    timer = time.NewTimer(entries.Early.Sub(time.Now()))&nbsp;\n    \n    select {\n    \tcase now = &lt;-timer.C:\n    \t\tfor _, entry := entries {\n    \t\t\t// 对已经到了时间的任务，执行\n    \t\t\tif entry.Next.Ok() {\n    \t\t\t\tgo startJob(entry)\n    \t\t\t}\n    \t\t\t\n    \t\t\t// 所有任务重新计算下个timer\n    \t\t\tentry.Next = next(entry)\n    \t\t}\n    }\n}\n</code></pre><h2>使用cron包定时执行命令</h2><p>其实我们刚才对定时执行任务的分析，就是开源定时执行库<a href="https://github.com/robfig/cron"> cron </a>的核心实现。</p><p>cron库的作者 robfig 是一名资深的Golang开源贡献者，他最出名的两个作品cron库和Revel框架目前已经分别有了8.4k和12.4k的star数。cron库的Licence是基于MIT的，允许商用、允许私有化，目前最新的稳定版本为v3。</p><p>cron库可以实现多个定时任务的执行功能，核心原理正如刚才讲的那样，底层也是使用timer来进行每个定时任务的计算，但是细节实现远不止这些。我们看它的用法就能感受出来：</p><pre><code class="language-go">// 创建一个cron实例\nc := cron.New()\n\n// 每整点30分钟执行一次\nc.AddFunc("30 * * * *", func() { \n  fmt.Println("Every hour on the half hour") \n})\n// 上午3-6点，下午8-11点的30分钟执行\nc.AddFunc("30 3-6,20-23 * * *", func() {\n  fmt.Println(".. in the range 3-6am, 8-11pm") \n})\n// 东京时间4:30执行一次\nc.AddFunc("CRON_TZ=Asia/Tokyo 30 04 * * *", func() { \n  fmt.Println("Runs at 04:30 Tokyo time every day") \n})\n// 从现在开始每小时执行一次\nc.AddFunc("@hourly",      func() { \n  fmt.Println("Every hour, starting an hour from now") \n})\n// 从现在开始，每一个半小时执行一次\nc.AddFunc("@every 1h30m", func() { \n  fmt.Println("Every hour thirty, starting an hour thirty from now") \n})\n\n// 启动cron\nc.Start()\n\n...\n// 在cron运行过程中增加任务\nc.AddFunc("@daily", func() { fmt.Println("Every day") })\n..\n// 查看运行中的任务\ninspect(c.Entries())\n..\n// 停止cron的运行，优雅停止，所有正在运行中的任务不会停止。\nc.Stop() \n</code></pre><p>这个例子充分展示了这个库的能力。</p><p>首先，它具有<strong>极其丰富的“时间描述语言”</strong>。我们可以通过和Linux的crontab一样的语法，定义五个星号来表示在一天中的某个时间点，时间点的维度可以是分钟、小时、日、月、星期，也可以将这五个星号替换为不同维度的值或者范围。前两个例子就很好地展示了在每小时30分的时候，和在上午3-6点、下午8-11点的每30分钟的时候执行的方法。</p><p>而第三个例子，它定义了日本东京时区的某个时间点来执行，这个已经超出了Linux的crontab能力了。看第四、五个例子，它还能通过符号@ 和非常语义化的hourly、every 1h30m 的描述语句，来表示从现在开始的时间计算。</p><p>或许你会好奇这种神奇的时间描述语言是怎么实现的？可以看cron源码的<a href="https://github.com/robfig/cron/blob/master/parser.go">parser.go</a>文件。它的本质就是将字符串解析成为一个包含秒、分、小时等时间数据的结构SpecSchedule。看下面的部分源码：（不是今天的重点，就不解释具体的字符串解析步骤了，有兴趣的同学可以自行查看完整源码）</p><pre><code class="language-go">// 用来表示调度时间的一个结构\ntype SpecSchedule struct {\n  // Dom表示dayOfMonth,每个月的第几天\n  // Dow表示dayOfWeek,每个星期的第几天\n  Second, Minute, Hour, Dom, Month, Dow uint64\n\n  // 时区\n  Location *time.Location\n}\n</code></pre><p>你会发现SpecSchedule 中有秒的时间字段，是的，这是我想介绍这个库的第二个强大能力：<strong>支持秒级别的定时</strong>。看下面的例子：</p><pre><code class="language-go">// 创建一个cron实例\nc := cron.New(cron.WithParser(cron.NewParser(cron.SecondOptional | cron.Minute | cron.Hour | cron.Dom | cron.Month | cron.Dow | cron.Descriptor)))\n\n// 每秒执行一次\nc.AddFunc("* * * * * *", func() { \n  fmt.Println("Every hour on the half hour") \n})\n</code></pre><p>在初始化实例的时候使用NewParser，设置了允许定时字符串支持秒级别的选项cron.SecondOptional。这样，我们可以使用6个星号来表示在秒级别的时候调用一次。这个功能是很多第三方库，甚至Linux的crontab都做不到的。</p><p>除了这两个强大的能力之外，cron还支持动态增加定时任务、任务调用链等功能。不过这些功能暂时用不到，就不在这里介绍了。有兴趣的同学可以自己课后研究cron库的源码。</p><h2>定时命令的思路与实现</h2><p>我们下一步就是要考虑如何将cron库应用在hade框架中了。</p><p>从使用角度开始思考，今天一开始我们说了，挑战只增加一行代码就能定时执行某个命令。那这个代码应该有两个参数，一是设置定时时间，二是定制执行的命令。就像这样：</p><pre><code class="language-go">// 每秒调用一次Foo命令\nrootCmd.AddCronCommand("* * * * * *", demo.FooCommand)\n</code></pre><p>第一个参数对应cron库中的“时间描述语言”，第二个参数对应我们的Command结构。</p><p>从刚才的两个使用小例子能看到，在cron库中，增加一个定时任务的AddFunc方法，有两个参数：时间描述语言、匿名函数。那么明显，<strong>AddCronCommand函数中核心要做的，就是将Command结构的执行封装成一个匿名函数，再调用cron的AddFunc方法就可以了</strong>。</p><p>这里还有一个需要先解决的问题，cron库需要初始化一个Cron对象，就是上面库例子中的cron.New方法创建的对象，这个Cron对象存放在哪里呢？</p><p>记得上一节课，我们将服务容器container存放在根Command中么，让所有的命令都可以通过Root() 方法获取到根Command，再获取到container。那这里也可以如法炮制，将初始化的Cron对象放在根Command中。</p><p>所以，在框架目录的framework/cobra/Command.go中，我们对Command结构进行修改：</p><pre><code>type Command struct {\n   // Command支持cron，只在RootCommand中有这个值\n   Cron *cron.Cron\n   // 对应Cron命令的信息\n   CronSpecs []CronSpec\n   ...\n}\n</code></pre><p>除了在根Command结构中放入Cron实例，我还放入了一个CronSpecs的数组，这个数组用来保存所有Cron命令的信息，为后续查看所有定时任务而准备。</p><p>思考清楚了这些，我们就能开始动手写AddCronCommand这个函数了。</p><h3>cron的初始化和回调</h3><p>先获取根Command，判断是否已经初始化了Cron实例，如果没有，就要初始化。接着，补充Cron命令的信息到CronSpecs数组中。最后封装一个匿名函数，在这个匿名函数中，我们将要执行的Command进行封装。</p><pre><code class="language-go">// AddCronCommand 是用来创建一个Cron任务的\nfunc (c *Command) AddCronCommand(spec string, cmd *Command) {\n   // cron结构是挂载在根Command上的\n   root := c.Root()\n   if root.Cron == nil {\n      // 初始化cron\n      root.Cron = cron.New(cron.WithParser(cron.NewParser(cron.SecondOptional | cron.Minute | cron.Hour | cron.Dom | cron.Month | cron.Dow | cron.Descriptor)))\n      root.CronSpecs = []CronSpec{}\n   }\n   // 增加说明信息\n   root.CronSpecs = append(root.CronSpecs, CronSpec{\n      Type: "normal-cron",\n      Cmd:  cmd,\n      Spec: spec,\n   })\n   // 制作一个rootCommand\n   var cronCmd Command\n   ctx := root.Context()\n   cronCmd = *cmd\n   cronCmd.args = []string{}\n   cronCmd.SetParentNull()\n   cronCmd.SetContainer(root.GetContainer())\n   // 增加调用函数\n   root.Cron.AddFunc(spec, func() {\n      // 如果后续的command出现panic，这里要捕获\n      defer func() {\n         if err := recover(); err != nil {\n            log.Println(err)\n         }\n      }()\n      err := cronCmd.ExecuteContext(ctx)\n      if err != nil {\n         // 打印出err信息\n         log.Println(err)\n      }\n   })\n}\n\n</code></pre><p>这里有几个细节需要注意一下。</p><p>封装匿名函数的时候，要记得保证这个匿名函数不会抛出异常，因为在cron中，匿名函数是开启一个Goroutine来执行的，而在Golang中，每个Goroutine都是平等的，任何一个Goroutine出现panic，都会导致整个进程中止。</p><p>另外在匿名函数中，封装的并不是传递进来的Command，而是<strong>把这个Command做了一个副本，并且将其父节点设置为空，让它自身就是一个新的根节点；然后调用这个Command的Execute方法</strong>。</p><p>这么做主要是因为我在调试过程中发现，cobra库在执行任意一个Command的Execute系列方法时，都会从根Command开始，根据参数进行遍历查询。这是因为我们是通过定时器进行调用的，这个定时器调用并没有真正的控制台，如果希望找到这个cronCmd，直接调用其Execute命令就行。</p><p>所以在上面的代码里，复制了一个当前Command结构的cronCmd，并且将其设置为根Command，就是SetParentNull() 函数，将其上游设置为空，就可以直接在定时器启动的时候调用这个cronCmd的ExecuteCrontext了。</p><h2>启动cron的思路与实现</h2><p>好了，现在完成了cron的初始化和回调，下面要解决启动cron的时机了。</p><p>上一节课我们将main函数修改为一个命令行调用，还将启动Web服务设计为一个子命令。那么类比到这里，启动cron服务也应该改造成为一个子命令。所以定义一个二级命令cron，五个三级命令start、stop、restart、list、state。</p><pre><code class="language-go">&nbsp;～: ./hade cron\n定时任务相关命令\n\nUsage:\n&nbsp; hade cron [flags]\n&nbsp; hade cron [command]\n\nAvailable Commands:\n&nbsp; list&nbsp; &nbsp; &nbsp; &nbsp; 列出所有的定时任务\n&nbsp; restart&nbsp; &nbsp; &nbsp;重启cron常驻进程\n&nbsp; start&nbsp; &nbsp; &nbsp; &nbsp;启动cron常驻进程\n&nbsp; state&nbsp; &nbsp; &nbsp; &nbsp;cron常驻进程状态\n&nbsp; stop&nbsp; &nbsp; &nbsp; &nbsp; 停止cron常驻进程\n\nFlags:\n&nbsp; -h, --help&nbsp; &nbsp;help for cron\n\nUse "hade cron [command] --help" for more information about a command.\n\n</code></pre><p>这五个三级命令中最核心的就是启动cron的命令，我们就详细讲解这个命令，其他的大同小异，你可以课后对照GitHub补充。</p><p>在<code>./hade cron start</code> 这个命令中，必须要考虑的有两个问题：</p><p>首先，<strong>我们希望使用cron的三级命令对某个进程进行管理</strong>。想达到这个目的，获取这个被管理进程的PID，并放入指定文件中非常重要，只有这样，才能在不同命令之间，通过获取这个PID，来查询或者停止这个进程。</p><p>解决方案倒不难。获取当前进程，我们可以使用标准库os<code>os.GetPid()</code> 。而PID的存放目录，之前在第12节课中定义服务目录的时候，有一个runtimeFolder是存放当前运行状态文件的，可以把cron进程的PID存放在这个目录中。</p><p>其次，在启动常驻进程的时候，我们可能以直接挂起进程的方式启动，也可能以后台deamon的方式启动，所以对于<strong>start 的命令最好能支持两种形态</strong>。这两种形态可以通过一个参数进行区分，在文件framework/command/cron.go中增加deamon参数：</p><pre><code class="language-go">// start命令有一个deamon参数，简写为d\ncronStartCommand.Flags().BoolVarP(&amp;cronDeamon, "deamon", "d", false, "start serve deamon")\n</code></pre><p>直接挂起的逻辑比较简单，就是直接调用cron的Run函数：</p><pre><code class="language-go">c.Root().Cron.Run()\n</code></pre><p>那么如何以deamon方式后台运行一个命令呢？或许你的第一反应是直接进行系统调用fork行不行？但是要告诉你，不行。</p><p>因为在Golang中，fork可以启动一个子进程，但是这个子进程是无法继承父进程的调度模型的。<strong>Golang的调度模型是在用户态的runtime中自己进行调度的，而系统调用fork出来的子进程默认只会有单线程</strong>。所以在Golang中尽量不要使用fork的方式来复制启动当前进程。</p><p>这里，实际上希望能fork出一个同样有运行到当前代码Go环境的进程。</p><p><strong>另一个办法是使用os.StartProcess 来启动一个进程，执行当前进程相同的二进制文件以及当前进程相同的参数</strong>。同时，由于二进制文件相同，还要为启动的子进程单独配置一个环境变量，这样在生成二进制文件的代码中，就能根据环境变量区分是主进程还是子进程。</p><p>这里整个启动子进程的方法在开源社区已经有封装好的了——开源库 <a href="https://github.com/sevlyar/go-daemon">go-daemon</a>。这个开源库目前star数有1.5k，采用MIT的licence，是现在比较流行的将进程deamon化的库了。它的原理和上面分析的是一样的，我们看下使用思路。</p><p>这个库会初始化一个daemon.Context结构，在这个结构中可以设置子进程的参数、环境变量、PID生成的文件、输出日志生成的文件、权限等。然后调用一个Reborn方法启动一个子进程，这个Reborn除了error之外，还有一个返回值os.Process，如果非空，代表当前为父进程，能从这个方法获取子进程信息，如果为空，代表当前为子进程。</p><h3>启动cron的实现</h3><p>现在启动cron命令的两个实现关键点都考虑清楚了。</p><p>结合我们当前的需求，要启动一个子进程，命令为：<code>./hade cron start --deamon=true</code>，这个子进程会运行cron.Run，子进程PID写入runtimeFolder目录下，子进程日志打印在logFolder目录下。而父进程打印成功信息，直接返回，不做任何操作。</p><p>代码framework/command/cron.go 中的 cronStartCommand 核心逻辑如下：</p><pre><code class="language-go">// deamon 模式\nif cronDeamon {\n   // 创建一个Context\n   cntxt := &amp;daemon.Context{\n      // 设置pid文件\n      PidFileName: serverPidFile,\n      PidFilePerm: 0664,\n      // 设置日志文件\n      LogFileName: serverLogFile,\n      LogFilePerm: 0640,\n      // 设置工作路径\n      WorkDir: currentFolder,\n      // 设置所有设置文件的mask，默认为750\n      Umask: 027,\n      // 子进程的参数，按照这个参数设置，子进程的命令为 ./hade cron start --deamon=true\n      Args: []string{"", "cron", "start", "--deamon=true"},\n   }\n   // 启动子进程，d不为空表示当前是父进程，d为空表示当前是子进程\n   d, err := cntxt.Reborn()\n   if err != nil {\n      return err\n   }\n   if d != nil {\n      // 父进程直接打印启动成功信息，不做任何操作\n      fmt.Println("cron serve started, pid:", d.Pid)\n      fmt.Println("log file:", serverLogFile)\n      return nil\n   }\n   // 子进程执行Cron.Run\n   defer cntxt.Release()\n   fmt.Println("deamon started")\n   gspt.SetProcTitle("hade cron")\n   c.Root().Cron.Run()\n   return nil\n}\n</code></pre><p>整体实现可以参考GitHub中当前章节的分支。</p><p>下面验证一下前面对定时任务的改造是否成功。先在业务app/console/command/demo/foo.go中创建一个Foo命令，它的执行行为就是打印一行字符“execute foo command”：</p><pre><code class="language-go">// FooCommand 代表Foo命令\nvar FooCommand = &amp;cobra.Command{\n   Use:     "foo",\n   Short:   "foo的简要说明",\n   Long:    "foo的长说明",\n   Aliases: []string{"fo", "f"},\n   Example: "foo命令的例子",\n   RunE: func(c *cobra.Command, args []string) error {\n      log.Println("execute foo command")\n      return nil\n   },\n}\n</code></pre><p>然后将这个FooCommand，通过AddCronCommand绑定到根Command中，并且设置其调用时间为每秒调用一次。</p><pre><code class="language-go">// 绑定业务的命令\nfunc AddAppCommand(rootCmd *cobra.Command) {\n   // 每秒调用一次Foo命令\n   rootCmd.AddCronCommand("* * * * * *", demo.FooCommand)\n}\n</code></pre><p>启动三级命令行工具<code>./hade cron start -d</code>，看到控制台打印出了子进程PID信息，和日志存储地址。</p><p><img src="https://static001.geekbang.org/resource/image/86/44/869bc53899f491456ed408c5519b9544.png?wh=520x73" alt="图片"></p><p>使用tail命令查看日志，可以看到确实是每秒执行打印一次字符串：execute foo command</p><p><img src="https://static001.geekbang.org/resource/image/fd/41/fd8a17e32yy2e296f0ae2fde92760d41.png?wh=871x169" alt="图片"></p><p>到这里，我们对框架的定时命令改造就完成了。</p><h2>如何实现分布式定时器</h2><p>但现在的定时器还是单机版本的定时器，容灾性很低，如果有很多定时任务都挂载在一个进程中，一旦这个进程或者这个机器出现灾难性不可恢复，那么定时任务就直接无法运行了。</p><p>容灾性更高的是分布式定时器。也就是很多机器都同时挂载定时任务，在同一时间都启动任务，只有一台机器能抢占到这个定时任务并且执行，其他机器由于抢占不到定时任务，不执行任何操作。</p><p>我们的框架也能做到这个分布式定时器的功能。</p><p>这种分布式定时器如何实现呢？你第一个想到的是不是使用Redis？我们用Redis做一个分布式锁，然后所有进程去抢占这个锁。</p><p>还是这样思考问题就比较低层次了。在第十、十一章，我们花了大量的篇幅讲了面向接口编程的思想，这里就可以用到这个思想。<strong>先定义接口，这个接口的功能是一个分布式的选择器，当有很多节点要执行某个服务的时候，只选择出其中一个节点</strong>。这样不管底层是否用Redis实现分布式选择器，在业务层我们都可以不用关心。</p><p>在文件framework/contract/distributed.go 文件中。我们先定义接口Distributed。其中有一个分布式选举方法Select。它的参数有三个，serviceName 代表服务名字、appID代表节点的ID、holdTime表示这个选择结果持续多久，也就是在选举出来之后多久内有效。它返回两个值，selectAppID表示选举的结果，即最终哪个节点被选举出来了，另一个返回值error表示异常。</p><pre><code class="language-go">package contract\n\nimport "time"\n\n// DistributedKey 定义字符串凭证\nconst DistributedKey = "hade:distributed"\n\n// Distributed 分布式服务\ntype Distributed interface {\n   // Select 分布式选择器, 所有节点对某个服务进行抢占，只选择其中一个节点\n   // ServiceName 服务名字\n   // appID 当前的AppID\n   // holdTime 分布式选择器hold住的时间\n   // 返回值\n   // selectAppID 分布式选择器最终选择的App\n   // err 异常才返回，如果没有被选择，不返回err\n   Select(serviceName string, appID string, holdTime time.Duration) (selectAppID string, err error)\n}\n\n</code></pre><p>这里提到了一个appID是我们之前没有见过的，简单说明一下。appID是为每个当前应用起的唯一标识，它用Google的 <a href="https://github.com/google/uuid">uuid生成库</a> 就可以很方便生成。它怎么通过服务容器获取呢？我们可以将appID作为服务容器中App服务的一个方法，这样就能从服务容器中获取App服务，再获取到appID了。</p><p>所以这里插一步来修改对应的 App 接口和其对应实现HadeApp，详细的修改点都以注释的形式写在下面代码中了。</p><p>在framework/contract/framework/contract/app.go中增加AppID的接口函数：</p><pre><code class="language-go">// App 定义接口\ntype App interface {\n   // AppID 表示当前这个app的唯一id, 可以用于分布式锁等\n   AppID() string\n   ...\n}\n</code></pre><p>在framework/provider/app/service.go中也增加对AppID的实现：</p><pre><code class="language-go">// HadeApp 代表hade框架的App实现\ntype HadeApp struct {\n   ...\n   appId      string              // 表示当前这个app的唯一id, 可以用于分布式锁等\n}\n\n// NewHadeApp 初始化HadeApp\nfunc NewHadeApp(params ...interface{}) (interface{}, error) {\n   ...\n   appId := uuid.New().String()\n   return &amp;HadeApp{baseFolder: baseFolder, container: container, appId: appId}, nil\n}\n\n// AppID 表示这个App的唯一ID\nfunc (h HadeApp) AppID() string {\n   return h.appId\n}\n\n</code></pre><p>分布式服务Distributed的接口定义好，我们再回到它的具体实现。</p><p>这个具体实现就有很多方式了，Redis只是其中一种而已，而且Redis要到后面章节才能引入。这里就实现一个本地文件锁。当一个服务器上有多个进程需要进行抢锁操作，文件锁是一种单机多进程抢占的很简易的实现方式。在Golang中，其使用方法也比较简单。</p><p>多个进程同时使用os.OpenFile打开一个文件，并使用syscall.Flock带上syscall.LOCK_EX参数来对这个文件加文件锁，这里只会有一个进程抢占到文件锁，而其他抢占不到的进程从syscall.Flock函数中获取到的就是error。<strong>根据这个error是否为空，我们就能判断是否抢占到了文件锁</strong>。</p><p>释放文件锁有两种方式，一种方式是调用syscall.Flock带上syscall.LOCK_UN的参数，另外一种方式是抢占到锁的进程结束，也会自动释放文件锁。</p><p>来看分布式选择器的本地文件锁的具体实现，在代码framework/provider/distributed/service_local.go文件中：</p><pre><code class="language-go">// Select 为分布式选择器\nfunc (s LocalDistributedService) Select(serviceName string, appID string, holdTime time.Duration) (selectAppID string, err error) {\n   appService := s.container.MustMake(contract.AppKey).(contract.App)\n   runtimeFolder := appService.RuntimeFolder()\n   lockFile := filepath.Join(runtimeFolder, "disribute_"+serviceName)\n   // 打开文件锁\n   lock, err := os.OpenFile(lockFile, os.O_RDWR|os.O_CREATE, 0666)\n   if err != nil {\n      return "", err\n   }\n   // 尝试独占文件锁\n   err = syscall.Flock(int(lock.Fd()), syscall.LOCK_EX|syscall.LOCK_NB)\n   // 抢不到文件锁\n   if err != nil {\n      // 读取被选择的appid\n      selectAppIDByt, err := ioutil.ReadAll(lock)\n      if err != nil {\n         return "", err\n      }\n      return string(selectAppIDByt), err\n   }\n   // 在一段时间内，选举有效，其他节点在这段时间不能再进行抢占\n   go func() {\n      defer func() {\n         // 释放文件锁\n         syscall.Flock(int(lock.Fd()), syscall.LOCK_UN)\n         // 释放文件\n         lock.Close()\n         // 删除文件锁对应的文件\n         os.Remove(lockFile)\n      }()\n      // 创建选举结果有效的计时器\n      timer := time.NewTimer(holdTime)\n      // 等待计时器结束\n      &lt;-timer.C\n   }()\n   // 这里已经是抢占到了，将抢占到的appID写入文件\n   if _, err := lock.WriteString(appID); err != nil {\n      return "", err\n   }\n   return appID, nil\n}\n</code></pre><p>大概逻辑是先打开或者创建文件锁对应的文件，然后在这个文件上加上文件锁，加上锁的过程就是抢占的过程。对于没有抢占到的，文件中内容为抢占到的那个应用的ID，将应用ID返回；抢占到的，就写入自己的应用ID到文件中，并且通过一个新的Goroutine开启计时器，等待计时器结束后解开文件锁，并且删除文件锁对应的文件。</p><p>而这个分布式服务Distributed的服务提供者 framework/provider/distributed/provider_local.go 的逻辑就比较简单了，就是正常的实现serviceProvider的5个方法，这里就不赘述了，可以参考GitHub上的代码分支。</p><p>现在有了分布式选择器，就可以实现分布式调度了。<strong>我们为Command结构增加一个方法AddDistributedCronCommand，这个方法有四个参数</strong>：</p><ul>\n<li>serviceName 这个服务的唯一名字，不允许带有空格</li>\n<li>spec 具体的执行时间</li>\n<li>cmd 具体的执行命令</li>\n<li>holdTime 表示如果我选择上了，这次选择持续的时间也就是锁释放的时间</li>\n</ul><p>它的实现和AddCronCommand差不多，唯一的区别就是在封装cron.AddFunc的匿名函数中，运行目标命令之前，要做一次分布式选举，如果被选举上了，才执行目标命令。所以来增加一个文件，在framework/cobra/hade_command_distributed.go 中，定义 AddDistributedCronCommand 方法：</p><pre><code class="language-go">// AddDistributedCronCommand 实现一个分布式定时器\n// serviceName 这个服务的唯一名字，不允许带有空格\n// spec 具体的执行时间\n// cmd 具体的执行命令\n// holdTime 表示如果我选择上了，这次选择持续的时间，也就是锁释放的时间\nfunc (c *Command) AddDistributedCronCommand(serviceName string, spec string, cmd *Command, holdTime time.Duration) {\n   root := c.Root()\n   // 初始化cron\n   if root.Cron == nil {\n      root.Cron = cron.New(cron.WithParser(cron.NewParser(cron.SecondOptional | cron.Minute | cron.Hour | cron.Dom | cron.Month | cron.Dow | cron.Descriptor)))\n      root.CronSpecs = []CronSpec{}\n   }\n   // cron命令的注释，这里注意Type为distributed-cron，ServiceName需要填写\n   root.CronSpecs = append(root.CronSpecs, CronSpec{\n      Type:        "distributed-cron",\n      Cmd:         cmd,\n      Spec:        spec,\n      ServiceName: serviceName,\n   })\n   appService := root.GetContainer().MustMake(contract.AppKey).(contract.App)\n   distributeServce := root.GetContainer().MustMake(contract.DistributedKey).(contract.Distributed)\n   appID := appService.AppID()\n   // 复制要执行的command为cronCmd，并且设置为rootCmd\n   var cronCmd Command\n   ctx := root.Context()\n   cronCmd = *cmd\n   cronCmd.args = []string{}\n   cronCmd.SetParentNull()\n   // cron增加匿名函数\n   root.Cron.AddFunc(spec, func() {\n      // 防止panic\n      defer func() {\n         if err := recover(); err != nil {\n            log.Println(err)\n         }\n      }()\n      // 节点进行选举，返回选举结果\n      selectedAppID, err := distributeServce.Select(serviceName, appID, holdTime)\n      if err != nil {\n         return\n      }\n      // 如果自己没有被选择到，直接返回\n      if selectedAppID != appID {\n         return\n      }\n      // 如果自己被选择到了，执行这个定时任务\n      err = cronCmd.ExecuteContext(ctx)\n      if err != nil {\n         log.Println(err)\n      }\n   })\n}\n\n</code></pre><p>完成了实现逻辑，下面照例做验证。</p><p>我们将打印字符“execute foo command”的FooCommand 命令执行的服务名设置为 “foo_func_for_test”。设置为每5秒进行一次选举并产生结果，每次选举结果保留2秒钟：</p><pre><code class="language-go">// 绑定业务的命令\nfunc AddAppCommand(rootCmd *cobra.Command) {\n\n   // 启动一个分布式任务调度，调度的服务名称为init_func_for_test，每个节点每5s调用一次Foo命令，抢占到了调度任务的节点将抢占锁持续挂载2s才释放\n   rootCmd.AddDistributedCronCommand("foo_func_for_test", "*/5 * * * * *", demo.FooCommand, 2*time.Second)\n}\n</code></pre><p>开启两个控制台，启动两个进程  <code>./hade cron start</code> 。</p><p><img src="https://static001.geekbang.org/resource/image/17/fe/174d0df274f5ab7197b533d3f05ee7fe.png?wh=464x207" alt="图片"></p><p><img src="https://static001.geekbang.org/resource/image/27/d5/276276b1cbe3a9ba12bfdaaeb47e25d5.png?wh=491x142" alt="图片"></p><p>能看到36分00秒的任务是在PID为40425的进程执行，而36分05秒的任务是在PID为40653的进程执行。而且仿造容灾演练，关闭掉其中任何一个进程，剩余每5秒钟执行的任务，都会落在存活的那个进程中。</p><p>到这里，我们就为hade框架提供了分布式定时器的功能。这节课的所有代码都在GitHub上的 <a href="https://github.com/gohade/coredemo/tree/geekbang/14">geekbang/14</a> 分支。对应的目录结构截图如下：</p><p><img src="https://static001.geekbang.org/resource/image/2f/73/2fdda7d387012e4d6fdf3c6c89c2e073.png?wh=362x1228" alt="图片"></p><h2>小结</h2><p>今天内容有点多，对不太清楚的地方，你可以多看几遍慢慢理解。</p><p>我们先使用cron包来为框架增加了定时执行命令的功能。在实现过程中，介绍了在Golang中，如何启动一个当前二进制文件的子进程。这个启动子进程的方式非常重要，后续在多个命令行工具中还会使用到，得熟练掌握。</p><p>接着一起实现了分布式定时器的功能。在实现分布式定时器的功能中，你也能更深一步感受到前几节课说的<strong>面向接口编程和服务容器设计的好处</strong>。比如说我们实现分布式定时器需要appID，就去app服务中增加一个获取AppID的接口；需要分布式选举服务，就创建了一个分布式服务接口。非常方便。</p><h2>思考题</h2><p>本节课实现了cron的五个三级命令其中最重要的一个cron start。你可以思考并尝试写一下其他几个命令：</p><ul>\n<li>cron stop 停止启动的进程</li>\n<li>cron state 判断当前cron进程是否已经启动，返回PID</li>\n<li>cron restart 重新启动cron进程</li>\n<li>cron list 列出挂载的所有cron任务</li>\n</ul><p>欢迎在留言区分享你的思考。如果你觉得有收获，也欢迎把今天的内容分享给身边的朋友，邀他一起学习。我们下节课见。</p>',
        article_title: "14｜定时任务：如何让框架支持分布式定时脚本？",
      },
      {
        title: "15｜配置和环境（上）：配置服务中的设计思路",
        id: 428012,
        content:
          '<p>你好，我是轩脉刃。</p><p>经过前面几节课对框架的改造，我们能很方便在 hade 框架中创造一个定时任务，或者一个 Web 服务了。但是随着开始编写业务，你会发现，业务中有大量的配置项，比如数据库的用户名密码、缓存 Redis 的 IP 和端口、第三方调用的地址等。如何通过统一的方法快速获取到这些配置项，就是今天要讨论的内容。</p><p>当你看到获取配置项这个需求，第一个反应是不是要创建一个读取配置文件的服务。但是，一个程序获取配置项只有读取配置文件这个方法么？其实不是的，获取配置项的方法有很多，<strong>读取本地配置文件、读取远端配置服务、获取环境变量</strong>，都是获取配置项的方法。</p><p>获取远端配置服务是通过一个远程调用来获取配置信息的方法，它依赖于远端的服务提供。而读取本地配置文件和获取环境变量，是我们通过进程本身获取配置项最常用的方法，这节课就为框架增加这两种获取配置项的能力。</p><h2>环境变量获取配置思路分析</h2><p>在现在服务越来越容器化的时代，环境变量越来越重要。因为一个服务一旦被封装为 Docker 镜像，镜像就会被部署在不同的环境中。如何区分不同的环境呢？在容器内部已经把程序、配置文件都进行了打包，唯一能在不同环境变化的就是环境变量了。</p><p>所以顾名思义，环境变量也就是为不同环境准备的，不同环境有不同的设置。</p><!-- [[[read_end]]] --><p>为一个程序设置环境变量的方式是多种多样的。如果是容器化的进程，可以在创建镜像的时候设置，也可以在容器启动的时候设置，在 Linux 系统中，我们也可以通过在启动进程的时候，通过前面加上“KEY=VALUE”的方式，为单个进程设置环境变量，比如：</p><pre><code class="language-go">FOO_ENV=bar ./hade foo\n</code></pre><p><strong>就为当前这个进程设置了一个 key 为 FOO_ENV，值为 bar 的环境变量</strong>。要记住这种方式，我们后续测试的时候，会用这种方式测试环境变量是否设置成功。</p><p>但是不管是哪种设置环境变量的方式，在 Golang 中，都能通过 os 标准库的<code>os.Environ()</code>获取。Environ 方法，会将进程中设置的所有环境变量，都以字符串数组形式返回，每个字符串为“KEY=VALUE”的环境变量设置。</p><p>读取环境变量获取配置的大思路有了，但是考虑到配置的设置还有一个问题。</p><p>环境变量可能会有很多。但是我们每次部署一个环境的时候，设置的环境变量可能就只有一两个，那其他的环境变量就需要有一个“默认值”。这个默认值我们一般使用一个以 dot 点号开头的文件.env 来进行设置。</p><p>其实<strong>使用.env 文件来设置默认环境变量，在运行的时候再使用真实的环境变量替换部分默认值</strong>，这种做法，在业界已经是一种非常普遍的加载环境变量的方式了。比如，在 Docker 中有个 env-file 配置项，会在启动的时候读取默认环境变量文件；又比如 Vue 中，Webpack 打包各种不同环境的时候，会根据根目录下.env 文件读取环境配置。</p><p>而我们的 hade 框架，也可以借鉴这个思路设计成相同的方式：在 baseFolder 目录下存放一个.env 文件保存默认值，这个.env 文件中的每一行，为一个环境变量 Key=Value 的形式，等运行的时候，进程运行的环境变量设置会覆盖.env 文件的设置。</p><p>有了上面对环境变量的设置、读取环境变量获取配置的分析之后，我们就可以开始着手设计了。分成两步来写：</p><ul>\n<li>环境变量服务的接口及具体实现</li>\n<li>读取配置文件服务的接口及具体实现</li>\n</ul><h2>环境变量服务的接口和实现</h2><p>首先按照一切皆服务的思想，通过环境变量获取配置项，这本身可以设计成一个服务，存放在服务容器中。所以我们先设计配置项服务 Env 的接口。</p><p>环境变量服务设计了四个方法：</p><ul>\n<li>AppEnv，获取 APP_ENV 这个环境变量，这个环境变量代表当前应用所在的环境；</li>\n<li>IsExist，判断某个环境变量是否存在；</li>\n<li>Get，获取某个环境变量，如果没有设置，则返回空字符串；</li>\n<li>All，获取所有的环境变量。</li>\n</ul><p>在framework/contract/env.go文件中：</p><pre><code class="language-go">package contract\n\nconst (\n   // EnvProduction 代表生产环境\n   EnvProduction = "production"\n   // EnvTesting 代表测试环境\n   EnvTesting = "testing"\n   // EnvDevelopment 代表开发环境\n   EnvDevelopment = "development"\n   // EnvKey 是环境变量服务字符串凭证\n   EnvKey = "hade:env"\n)\n// Env 定义环境变量服务\ntype Env interface {\n   // AppEnv 获取当前的环境，建议分为 development/testing/production\n   AppEnv() string\n   // IsExist 判断一个环境变量是否有被设置\n   IsExist(string) bool\n   // Get 获取某个环境变量，如果没有设置，返回""\n   Get(string) string\n   // All 获取所有的环境变量，.env 和运行环境变量融合后结果\n   All() map[string]string\n}\n</code></pre><p>这里有两点你可能觉得有点奇怪。</p><ul>\n<li>为什么有 Get 方法为什么没有 Set 方法？</li>\n</ul><p>这点我是这么考虑的，环境变量本质代表的是当前程序运行的环境，是一个程序运行时就固定的，它不应该允许程序运行中进行设置，这是一个不安全的行为。所以这里故意没有设计 Set 方法，让环境变量在运行时被修改。</p><ul>\n<li>AppEnv 是什么，为什么要单独设置一个 APP_ENV 这个环境变量？</li>\n</ul><p>这是参考 Laravel 和 Vue 这两个项目，它们都会为当前的应用，设置一个固定的环境变量 APP_ENV，这样在代码中，可以根据这个环境变量加载不同的配置文件、运行不同的业务逻辑。所以我单独为 APP_ENV 设置了环境变量，同时为这个 APP_ENV 预设了三个模式：开发模式 development、测试模式 testing、生产模式 production，默认为开发模式。</p><p>下面就来说接口的具体实现，在框架文件framework/provider/env/service.go中，大致就是按照先读取本地默认.env文件，再读取运行环境变量。</p><p>我们使用一个 map[string]string 来保存最终的环境变量值，设置这个 map 初始有一个 APP_ENV 的 key，并将它设置为开发环境。</p><pre><code class="language-go">hadeEnv := &amp;HadeEnv{\n   folder: folder,\n   // 实例化环境变量，APP_ENV 默认设置为开发环境\n   maps: map[string]string{"APP_ENV": contract.EnvDevelopment},\n}\n</code></pre><p>接下来先读取.env 文件中保存的默认环境变量，这里读取就使用 Golang 里面的文件读取方式：先用 os.Open 打开文件，使用 bufio.NewReader 创建一个读取器，然后使用 ReadLine 逐行读取，读取之后将结果保存到 map 中。</p><pre><code class="language-go">// 打开文件.env\nfi, err := os.Open(file)\nif err == nil {\n   defer fi.Close()\n   // 读取文件\n   br := bufio.NewReader(fi)\n   for {\n      // 按照行进行读取\n      line, _, c := br.ReadLine()\n      if c == io.EOF {\n         break\n      }\n      // 按照等号解析\n      s := bytes.SplitN(line, []byte{\'=\'}, 2)\n      // 如果不符合规范，则过滤\n      if len(s) &lt; 2 {\n         continue\n      }\n      // 保存 map\n      key := string(s[0])\n      val := string(s[1])\n      hadeEnv.maps[key] = val\n   }\n}\n</code></pre><p>最后再使用开头说的 os.Environ 来读取程序的所有环境变量，并且直接覆盖 map 变量。</p><pre><code class="language-go">// 获取当前程序的环境变量，并且覆盖.env 文件下的变量\nfor _, e := range os.Environ() {\n   pair := strings.SplitN(e, "=", 2)\n   if len(pair) &lt; 2 {\n      continue\n   }\n   hadeEnv.maps[pair[0]] = pair[1]\n}\n</code></pre><p>而环境变量服务最终提供的 Get 接口，也就非常简单了，直接从 map 中获取某个 key 的环境变量即可。并且由于在运行过程中没有 Set 等修改环境变量的方法，所以也不需要加锁。</p><pre><code class="language-go">// Get 获取某个环境变量，如果没有设置，返回""\nfunc (en *HadeEnv) Get(key string) string {\n   if val, ok := en.maps[key]; ok {\n      return val\n   }\n   return ""\n}\n</code></pre><p>到这里接口和实现就基本完成了，简单写段代码测试一下。</p><p>我们可以创建一个一级命令 <code>./hade env</code> 来获取当前 app 的环境，并且验证刚才写的环境变量服务，在这个命令中，我们直接将 AppEnv 打印到控制台。在文件framework/command/contract.go中：</p><pre><code class="language-go">// envCommand 获取当前的 App 环境\nvar envCommand = &amp;cobra.Command{\n   Use:   "env",\n   Short: "获取当前的 App 环境",\n   Run: func(c *cobra.Command, args []string) {\n      // 获取 env 环境\n      container := c.GetContainer()\n      envService := container.MustMake(contract.EnvKey).(contract.Env)\n      // 打印环境\n      fmt.Println("environment:", envService.AppEnv())\n   },\n}\n</code></pre><p><img src="https://static001.geekbang.org/resource/image/ac/4c/ac302d459988707346429c7da6a4304c.png?wh=409x48" alt="图片"></p><p>再尝试在进程启动的时候注入 APP_ENV 环境变量为 testing。控制台会将 APP_ENV 替换为 testing，而不是默认的 development 了。</p><p><img src="https://static001.geekbang.org/resource/image/9c/f6/9cfc2f36ff663fc13c63dc3bbdfd88f6.png?wh=1052x98" alt="图片"></p><h2>读取配置服务的接口</h2><p>下面我们就来思考配置文件的设计。</p><p>基于一切皆服务的思想，我们也可以将配置文件的读取作为服务容器中的一个服务，照旧先定义它的接口。配置文件服务的接口是我们经常使用的，需要充分考虑其易用性。</p><p>在项目中会使用一个配置文件还是多个配置文件？这个是需要先思考清楚的。</p><p>比如我们可以强制要求所有配置放在一个文件中，这样读取会非常方便。但是在实际工作中，这种实践的感受是非常糟糕的，不仅仅这个配置文件会非常冗长，而且更严重的是，<strong>导致配置文件失去了语义化，因为每个配置文件是为了某个模块功能而设计的</strong>，比如我们看到 log.yaml，就能知道这个配置文件是存放日志相关的配置，而 database.yaml 是存放数据库相关的配置。</p><p>所以配置文件一定是多个存在比较好。</p><p>明确了多配置文件之后，要思考下这个配置文件的存放目录。在<a href="https://time.geekbang.org/column/article/425820">第 12 节课</a>中，我们已经确定了整体 App 的目录结构，其中存放配置文件的目录是，应用结构服务 appService 的 ConfigFolder 这个目录。但是再结合环境配置问题考虑。</p><p>之前在环境变量中设置了 APP_ENV，表示这个应用在不同环境会有不同配置，所以如果将每个环境的配置文件存放在 ConfigFolder 下的不同文件夹下，这样配置文件结构是不是显得更为清晰呢？</p><p>我们读取文件的时候，<strong>直接根据 APP_ENV 的环境变量，去不同的配置文件的文件夹下获取对应的配置文件即可</strong>，很方便。</p><p><img src="https://static001.geekbang.org/resource/image/cc/f7/cc0eb964df002d95a37a5cb0cf9303f7.png?wh=716x1020" alt="图片" title="多个配置文件+不同配置文件夹"></p><p>接下来就是要从某个配置文件读取某个目标配置项了。我们可以设计成先读取文件、再读取某个字段的方式，但这样有点复杂，更简单的是，<strong>使用点号分割的路径读取方式</strong>来增加读取的易用性。</p><p>比如我们要读取 app.yaml 配置文件下的 data 配置项，可以直接通过 app.data 来获取这个配置项。如果 data 配置项中还有下级属性，比如 name，那可以通过 app.data.name 来获取这个 name 属性。这种根据点来区分配置路径层级的方式，能很大加速我们的读取效率。</p><p>最后，我们考虑配置文件服务的具体方法。</p><p>你应该还记得在<a href="https://time.geekbang.org/column/article/420009">第五节课</a>的时候，我们为 Request 封装了一系列查询的方法，同样的，在这里也可以为配置文件服务设计 Get 系列的方法，根据带有点的查询路径，来获取不同类型返回值的配置项。另外再增加一个判断路径是否存在的 IsExist 方法、一个能将某个配置项解析到一个对象的 Load 方法。</p><p>我们在框架文件framework/contract/config.go中：</p><pre><code class="language-go">// Config 定义了配置文件服务，读取配置文件，支持点分割的路径读取\n// 例如: .Get("app.name") 表示从 app 文件中读取 name 属性\n// 建议使用 yaml 属性, https://yaml.org/spec/1.2/spec.html\ntype Config interface {\n   // IsExist 检查一个属性是否存在\n   IsExist(key string) bool\n   // Get 获取一个属性值\n   Get(key string) interface{}\n   // GetBool 获取一个 bool 属性\n   GetBool(key string) bool\n   // GetInt 获取一个 int 属性\n   GetInt(key string) int\n   // GetFloat64 获取一个 float64 属性\n   GetFloat64(key string) float64\n   // GetTime 获取一个 time 属性\n   GetTime(key string) time.Time\n   // GetString 获取一个 string 属性\n   GetString(key string) string\n   // GetIntSlice 获取一个 int 数组属性\n   GetIntSlice(key string) []int\n   // GetStringSlice 获取一个 string 数组\n   GetStringSlice(key string) []string\n   // GetStringMap 获取一个 string 为 key，interface 为 val 的 map\n   GetStringMap(key string) map[string]interface{}\n   // GetStringMapString 获取一个 string 为 key，string 为 val 的 map\n   GetStringMapString(key string) map[string]string\n   // GetStringMapStringSlice 获取一个 string 为 key，数组 string 为 val 的 map\n   GetStringMapStringSlice(key string) map[string][]string\n   // Load 加载配置到某个对象\n   Load(key string, val interface{}) error\n}\n</code></pre><p>到这里，配置文件服务的接口就设计完成了，下一节课我们接着讨论整个服务的具体实现。</p><h2>小结</h2><p>今天我们围绕获取配置这一个功能点，设计了环境变量服务和配置文件服务。</p><p>环境变量服务按照先读取本地默认.env 文件，再读取运行环境变量的方式来实现，并且为其设置了最关键的环境变量 APP_ENV 来表示这个应用当前运行的环境。后续我们根据这个 APP_ENV 来获取具体环境的本地配置文件。</p><p>有的人可能会觉得要获取一个变量，直接使用配置文件就行啊，为什么要绕这么一圈？但是，环境变量是一个应用运行环境的一些参数，在现在的容器化流行的架构设计中，一般都会选择使用环境变量来区别不同的环境和配置。所以我们为框架提供获取环境变量的方式，在实际架构，特别是微服务相关的架构中，是非常有用的。</p><h2>思考题</h2><p>关于使用环境变量作为配置项，其实有一个比较出名的服务设计经验建议了 <a href="https://12factor.net/zh_cn/">The Twelve-Factor App</a>，这 12 条的实践标准，出自一个做 Paas 服务的 Herku 公司，是他们工程师的经验之谈。在配置文件这块，它建议所有环境的配置统一成一份，只通过环境变量进行区分。</p><p>实际上今天我们并没有完全按照实践标准来做，还是提供了将不同环境的配置分目录的方式。你不妨阅读这 12 条的实践标准，说说你的观点。</p><p>欢迎在留言区分享你的思考。感谢你的收听，如果觉得有收获，也欢迎把今天的内容分享给你身边的朋友，邀他一起学习。我们下节课见～</p>',
        article_title: "15｜配置和环境（上）：配置服务中的设计思路",
      },
      {
        title: "16｜配置和环境（下）：配置服务中的设计思路",
        id: 429059,
        content:
          '<p>你好，我是轩脉刃。</p><p>上一节课，我们已经定义好了配置文件服务的接口，这节课就来实现这些接口。先来规划配置文件服务目录，按照上一节课分析的，多个配置文件按类别放在不同配置文件夹中，在框架文件夹中，我们将配置文件接口代码写在框架文件夹下的contract/config.go文件中，将具体实现放在provider/config/目录中。</p><h2>配置服务的设计</h2><p>不过设计优于实现，动手之前我们先思考下实现这个接口要如何设计。</p><p>首先，要读取一下配置文件夹中的文件。上节课说了，最终的配置文件夹地址为，应用服务的 ConfigFolder 下的环境变量对应的文件夹，比如 ConfigFolder/development。但是还有一个问题，就是配置文件的格式的选择。</p><p><strong>目前市面上的配置文件格式非常多，但是很难说哪种配置文件比较好，完全是不同平台、不同时代下的产物</strong>。比如Windows开发的配置常用INI、Java开发配置常用Properties，我这里选择了使用YAML格式。</p><h3>配置文件的读取</h3><p>YAML格式是在Golang的项目中比较通用的一种格式，比如Kubernetes、Docker、Swagger等项目，都是使用YAML作为其配置文件的。YAML配置文件除了能表达基础类型比如string、int、float 之外，也能表达复杂的数组、结构等数据类型。</p><!-- [[[read_end]]] --><p>目前最新的YAML版本为1.2版本，配置的说明文档在<a href="https://yaml.org/">官网</a>上。它提供多种语言的解析库，其中<a href="https://github.com/go-yaml/yaml">go-yaml</a> 就是非常通用的一个Go解析库，这个库的封装性非常好。</p><p>我们通过第一节课讲的快速阅读一个库的命令 <code>go doc github.com/go-yaml/yaml |grep \'^func\'</code>，可以看出来这个库对外提供的方法非常明确，一共三个方法：</p><ul>\n<li>Marshal 表示序列化一个结构成为YAML格式；</li>\n<li>Unmarshal表示反序列化一个YAML格式文本成为一个结构；</li>\n<li>还有一个UnmarshalStrict 函数，表示严格反序列化，比如如果YAML格式文件中包含重复key的字段，那么使用UnmarshalStrict 函数反序列化会出现错误。</li>\n</ul><pre><code class="language-plain">// 序列化\nfunc Marshal(in interface{}) (out []byte, err error)\n// 反序列化\nfunc Unmarshal(in []byte, out interface{}) (err error)\n// 严格反序列化\nfunc UnmarshalStrict(in []byte, out interface{}) (err error)\n</code></pre><p>我们选择Unmarshal的函数进行反序列化，因为这样能提高框架对配置文件的容错性和易用性。好，读取配置文件的格式和对应工具搞定，下一步就是想清楚怎么替换了。</p><h3>配置文件的替换</h3><p>在上一节课说的环境变量服务中，存放了包括.env中设置的环境变量，那么我们自然会希望使用上这些环境变量，把配置文件中有的字段使用环境变量替换掉。那么这里在配置文件中就需要有一个“占位符”。这个占位符表示当前这个字段去环境变量中进行阅读。</p><p>这个占位符的设计只有一个要求：够特别。只要这个占位符能和其他配置文件字符区分开就行，所以这里设计占位符为比较有语义的“env(XXXX)”。比如app/config/development/database.yaml 文件中的数据库密码，使用占位符表示如下：</p><pre><code class="language-yaml">mysql:\n  hostname: 127.0.0.1\n  username: yejianfeng\n  password: env(DB_PASSWORD)\n  timeout: 1\n  readtime: 2.3\n</code></pre><p>要实现这个功能，其实也很简单，可以在读取YAML配置文件内容之后，进行完整的文本匹配，将所有环境变量env(xxx) 的字符替换为环境变量。我们应该能设计出替换文本的函数。</p><p>在框架目录的provider/config/service.go中，可以先实现这个方法。</p><pre><code class="language-go">// replace 表示使用环境变量maps替换context中的env(xxx)的环境变量\nfunc replace(content []byte, maps map[string]string) []byte {\n   if maps == nil {\n      return content\n   }\n   // 直接使用ReplaceAll替换。这个性能可能不是最优，但是配置文件加载，频率是比较低的，可以接受\n   for key, val := range maps {\n      reKey := "env(" + key + ")"\n      content = bytes.ReplaceAll(content, []byte(reKey), []byte(val))\n   }\n   return content\n}\n</code></pre><h3>配置项的解析</h3><p>读取并解析完配置文件内容，接下来就要根据path来解析某个配置项了。上一节课说，我们使用点号分割的路径读取方式，比如database.mysql.password 表示在配置文件夹中的database.yaml文件，其中的mysql配置，对应的是数据结构中的password字段。</p><p>那这种根据path来读取字段应该怎么实现呢？</p><p>在获取配置项的时候，我们已经通过go-yaml库将配置文件解析到一个map数据结构中了，而这个map数据结构的子项，明显也有可能是一个map数据结构。所以按照path路径查找，这明显应该是一个<strong>函数递归逻辑</strong>。</p><p>还是用刚才的database.mysql.password举例，可以拆分为3个结构。database 去根map中寻找；如果有这个key，就拿着mysql.password的path，去 database这个key对应的value中进行寻找；而递归寻找到了最后一级path为password，发现这个path没有下一级了，就停止递归。</p><p>详细的代码方法如下，同样存放在框架目录的provider/config/service.go中。</p><pre><code class="language-go">// 查找某个路径的配置项\nfunc searchMap(source map[string]interface{}, path []string) interface{} {\n   if len(path) == 0 {\n      return source\n   }\n\n   // 判断是否有下个路径\n   next, ok := source[path[0]]\n   if ok {\n      // 判断这个路径是否为1\n      if len(path) == 1 {\n         return next\n      }\n\n      // 判断下一个路径的类型\n      switch next.(type) {\n      case map[interface{}]interface{}:\n         // 如果是interface的map，使用cast进行下value转换\n         return searchMap(cast.ToStringMap(next), path[1:])\n      case map[string]interface{}:\n         // 如果是map[string]，直接循环调用\n         return searchMap(next.(map[string]interface{}), path[1:])\n      default:\n         // 否则的话，返回nil\n         return nil\n      }\n   }\n   return nil\n}\n\n// 通过path获取某个元素\nfunc (conf *HadeConfig) find(key string) interface{} {\n   ...\n   return searchMap(conf.confMaps, strings.Split(key, conf.keyDelim))\n}\n\n</code></pre><p>想通了以上三个核心实现难点，我们就可以着手整体代码实现了。</p><h2>配置服务的代码实现</h2><p>首先，在框架文件夹的provider/config/service.go 中，创建一个配置文件服务HadeConfig。它有几个属性：folder代表配置本地配置文件所在的文件夹；keyDelim代表路径中的分割符号，也就是点；envMaps存放所有的环境变量；而confMaps存放每个配置解析后的结构，confRaws存放每个配置的原始文件信息。</p><pre><code class="language-go">// HadeConfig  表示hade框架的配置文件服务\ntype HadeConfig struct {\n   c        framework.Container    // 容器\n   folder   string                 // 文件夹\n   keyDelim string                 // 路径的分隔符，默认为点\n   ...\n   envMaps  map[string]string      // 所有的环境变量\n   confMaps map[string]interface{} // 配置文件结构，key为文件名\n   confRaws map[string][]byte      // 配置文件的原始信息\n}\n</code></pre><p>我们初始化这个HadeConfig的函数，它从服务提供者provider/config/provider.go中获取到三个参数，除了容器之外，另外两个是文件夹地址和所有的环境变量。</p><p>我们这里对provider.go 只列一下参数函数，其他的四个服务提供者函数(Register、Boot、IsDefer、Name) 可以参考<a href="https://github.com/gohade/coredemo/blob/geekbang/16/framework/provider/config/provider.go">GitHub上的代码</a>。</p><pre><code class="language-go">// Paramas 服务提供者实例化的时候参数\nfunc (provider *HadeConfigProvider) Params(c framework.Container) []interface{} {\n   appService := c.MustMake(contract.AppKey).(contract.App)\n   envService := c.MustMake(contract.EnvKey).(contract.Env)\n   env := envService.AppEnv()\n   // 配置文件夹地址\n   configFolder := appService.ConfigFolder()\n   envFolder := filepath.Join(configFolder, env)\n   // 传递容器，配置文件夹地址，所有环境变量\n   return []interface{}{c, envFolder, envService.All()}\n}\n</code></pre><p>那么在provider/config/service.go中，实例化的函数逻辑如下：</p><pre><code class="language-go">// NewHadeConfig 初始化Config方法\nfunc NewHadeConfig(params ...interface{}) (interface{}, error) {\n   container := params[0].(framework.Container)\n   envFolder := params[1].(string)\n   envMaps := params[2].(map[string]string)\n   \n   // 检查文件夹是否存在\n   if _, err := os.Stat(envFolder); os.IsNotExist(err) {\n      return nil, errors.New("folder " + envFolder + " not exist: " + err.Error())\n   }\n   // 实例化\n   hadeConf := &amp;HadeConfig{\n      c:        container,\n      folder:   envFolder,\n      envMaps:  envMaps,\n      confMaps: map[string]interface{}{},\n      confRaws: map[string][]byte{},\n      keyDelim: ".",\n      lock:     sync.RWMutex{},\n   }\n   // 读取每个文件\n   files, err := ioutil.ReadDir(envFolder)\n   if err != nil {\n      return nil, errors.WithStack(err)\n   }\n   for _, file := range files {\n      fileName := file.Name()\n      err := hadeConf.loadConfigFile(envFolder, fileName)\n      if err != nil {\n         log.Println(err)\n         continue\n      }\n   }\n   ...\n   return hadeConf, nil\n}\n\n// 读取某个配置文件\nfunc (conf *HadeConfig) loadConfigFile(folder string, file string) error {\n   conf.lock.Lock()\n   defer conf.lock.Unlock()\n   //  判断文件是否以yaml或者yml作为后缀\n   s := strings.Split(file, ".")\n   if len(s) == 2 &amp;&amp; (s[1] == "yaml" || s[1] == "yml") {\n      name := s[0]\n      // 读取文件内容\n      bf, err := ioutil.ReadFile(filepath.Join(folder, file))\n      if err != nil {\n         return err\n      }\n      // 直接针对文本做环境变量的替换\n      bf = replace(bf, conf.envMaps)\n      // 解析对应的文件\n      c := map[string]interface{}{}\n      if err := yaml.Unmarshal(bf, &amp;c); err != nil {\n         return err\n      }\n      conf.confMaps[name] = c\n      conf.confRaws[name] = bf\n   }\n   return nil\n}\n</code></pre><p>逻辑非常清晰。先检查配置文件夹是否存在，然后读取文件夹中的每个以yaml或者yml后缀的文件；读取之后，先用replace对环境变量进行一次替换；替换之后使用 go-yaml，对文件进行解析。</p><p>初始化实例就是一个完整的 解析文件的过程，解析结束之后，confMaps里存放的就是解析之后的结果。</p><p>配置文件的获取接口上节课已经写好了，定义了接口的系列方法，这里我们就详细实现Get/GetBool/GetInt，其他方法大同小异，就不贴出来了，你可以直接参考<a href="https://github.com/gohade/coredemo/blob/geekbang/16/framework/provider/config/service.go">GitHub上的代码</a>。</p><p>前面已经想好了，用方法find，通过path，从一个嵌套map confMaps中获取数据。所以Get方法就是调用一下find方法而已，同样也在service.go中：</p><pre><code class="language-go">// Get 获取某个配置项\nfunc (conf *HadeConfig) Get(key string) interface{} {\n   return conf.find(key)\n}\n</code></pre><p>而对应的Get系列的方法我们使用cast库进行类型转换，比如：</p><pre><code class="language-go">// GetBool 获取bool类型配置\nfunc (conf *HadeConfig) GetBool(key string) bool {\n   return cast.ToBool(conf.find(key))\n}\n// GetInt 获取int类型配置\nfunc (conf *HadeConfig) GetInt(key string) int {\n   return cast.ToInt(conf.find(key))\n}\n</code></pre><p>到这里，配置服务的代码已经基本成型了。但是实际上还有两个细节我们需要认真思考。</p><p>首先，因为之前我们设置过App服务，将一个App服务的目录都安排好了，但是如果之后有需求要改变这些目录的配置呢？如果有的话，是否可以通过配置来进行修改呢？所以第一个问题就是，我们要思考配置文件更新App服务的操作。</p><p>其次，假设现在配置服务能从文件中获取配置了，但是如果文件修改了，我们是否需要重新启动应用呢？是否有能不启动应用的方法呢？</p><p>下面我们来一一解决这两个问题。</p><h2>配置文件更新App服务</h2><p>现在有了配置文件服务，但在没有配置文件服务之前，我们启动服务的appService，也是有可能要修改这个服务的配置的。回忆<a href="https://time.geekbang.org/column/article/423982">第十二</a><a href="https://time.geekbang.org/column/article/423982">课</a>，appService中存放了启动这个业务实例默认设置的文件夹目录和地址。</p><pre><code class="language-go">//BaseFolder 定义项目基础地址\nBaseFolder() string\n// ConfigFolder 定义了配置文件的路径\nConfigFolder() string\n// LogFolder 定义了日志所在路径\nLogFolder() string\n// ProviderFolder 定义业务自己的服务提供者地址\nProviderFolder() string\n// MiddlewareFolder 定义业务自己定义的中间件\nMiddlewareFolder() string\n// CommandFolder 定义业务定义的命令\nCommandFolder() string\n// RuntimeFolder 定义业务的运行中间态信息\nRuntimeFolder() string\n// TestFolder 存放测试所需要的信息\nTestFolder() string\n</code></pre><p>现在有需求将这些文件夹目录，在配置文件中进行配置并修改。所以应该在加载到配置服务时，再更新下appService。加载逻辑如下：</p><p><img src="https://static001.geekbang.org/resource/image/f5/ee/f5141333501ce140314fb985b75c6eee.jpg?wh=1920x1080" alt="图片"></p><p>可以把设定App的这些配置文件，存放在配置文件夹的app.yaml文件的path设置项下，其中每个配置项的key，对应appService中每个对应的服务。比如log_folder对应LogFolder目录：</p><pre><code class="language-go">path:\n  log_folder: "/home/jianfengye/hade/log/"\n  runtime_folder: "/home/jianfengye/hade/runtime/"\n</code></pre><p>现在加载配置服务的时候，当读取到配置服务app.path下有内容，就需要更新appService的配置。首先需要修改appService，修改框架目录下的provider/app/service.go文件。</p><p>将HadeApp增加一个configMap字段：</p><pre><code class="language-go">// HadeApp 代表hade框架的App实现\ntype HadeApp struct {\n   ...\n   configMap map[string]string // 配置加载\n}\n</code></pre><p>同时为HadeApp增加LoadAppConfig方法，用于读取配置文件中的信息：</p><pre><code class="language-go">// LoadAppConfig 加载配置map\nfunc (app *HadeApp) LoadAppConfig(kv map[string]string) {\n   for key, val := range kv {\n      app.configMap[key] = val\n   }\n}\n</code></pre><p>再修改对应的LogFolder等一系列XXXFolder的方法，先读取configMap中的值，如果有的话，先用configMap中的值：</p><pre><code class="language-go">// LogFolder 表示日志存放地址\nfunc (app HadeApp) LogFolder() string {\n   if val, ok := app.configMap["log_folder"]; ok {\n      return val\n   }\n   return filepath.Join(app.StorageFolder(), "log")\n}\n\n</code></pre><p>这样，对appService的修改就完成了。</p><p>在configService，读取配置文件loadConfigFile的时候，要注意，如果当前的配置文件是app.yaml， 我们需要调用appService的LoadAppConfig方法：</p><pre><code class="language-go">// 读取某个配置文件\nfunc (conf *HadeConfig) loadConfigFile(folder string, file string) error {\n   ...\n\n   //  判断文件是否以yaml或者yml作为后缀\n   s := strings.Split(file, ".")\n   if len(s) == 2 &amp;&amp; (s[1] == "yaml" || s[1] == "yml") {\n      name := s[0]\n\n      ...\n\n      // 读取app.path中的信息，更新app对应的folder\n      if name == "app" &amp;&amp; conf.c.IsBind(contract.AppKey) {\n         if p, ok := c["path"]; ok {\n            appService := conf.c.MustMake(contract.AppKey).(contract.App)\n            appService.LoadAppConfig(cast.ToStringMapString(p))\n         }\n      }\n   }\n   return nil\n}\n</code></pre><p>这样在加载app.yaml的配置文件的时候，就同时更新了appService 里面的配置。</p><h2>配置文件热更新</h2><p>正常来说，在程序启动的时候会读取一次配置文件，但是在程序运行过程中，我们难免会遇到需要修改配置文件的操作。也就是之前思考的第二个问题。</p><p>这个时候，是否需要重新启动一次程序再加载一次配置文件呢？这当然是没有问题的，但是更为强大的是，<strong>我们可以自动监控配置文件目录下的所有文件，当配置文件有修改和更新的时候，能自动更新程序中的配置文件信息，也就是实现配置文件热更新</strong>。</p><p>这个热更新看起来很麻烦，其实在Golang中是非常简单的事情。我们使用 <a href="https://github.com/fsnotify/fsnotify">fsnotify</a> 库能很方便对一个文件夹进行监控，当文件夹中有文件增/删/改的时候，会通过channel进行事件回调。</p><p>这个库的使用方式很简单。大致思路就是先使用NewWatcher创建一个监控器watcher，然后使用Add来监控某个文件夹，通过watcher设置的events来判断文件是否有变化，如果有变化，就进行对应的操作，比如更新内存中配置服务存储的map结构。</p><pre><code class="language-go">// NewHadeConfig 初始化Config方法\nfunc NewHadeConfig(params ...interface{}) (interface{}, error) {\n   ...\n\n   // 监控文件夹文件\n   watch, err := fsnotify.NewWatcher()\n   if err != nil {\n      return nil, err\n   }\n   err = watch.Add(envFolder)\n   if err != nil {\n      return nil, err\n   }\n   go func() {\n      defer func() {\n         if err := recover(); err != nil {\n            fmt.Println(err)\n         }\n      }()\n\n      for {\n         select {\n         case ev := &lt;-watch.Events:\n            {\n               //判断事件发生的类型，如下5种\n               // Create 创建\n               // Write 写入\n               // Remove 删除\n               path, _ := filepath.Abs(ev.Name)\n               index := strings.LastIndex(path, string(os.PathSeparator))\n               folder := path[:index]\n               fileName := path[index+1:]\n\n               if ev.Op&amp;fsnotify.Create == fsnotify.Create {\n                  log.Println("创建文件 : ", ev.Name)\n                  hadeConf.loadConfigFile(folder, fileName)\n               }\n               if ev.Op&amp;fsnotify.Write == fsnotify.Write {\n                  log.Println("写入文件 : ", ev.Name)\n                  hadeConf.loadConfigFile(folder, fileName)\n               }\n               if ev.Op&amp;fsnotify.Remove == fsnotify.Remove {\n                  log.Println("删除文件 : ", ev.Name)\n                  hadeConf.removeConfigFile(folder, fileName)\n               }\n            }\n         case err := &lt;-watch.Errors:\n            {\n               log.Println("error : ", err)\n               return\n            }\n         }\n      }\n   }()\n\n   return hadeConf, nil\n}\n</code></pre><p>代码如上，我们使用NewWatcher创建一个监听器，监听配置文件目录，接着启动一个新的Goroutine作为监听协程。在监听协程中，监听配置文件的创建、更新、删除操作。创建和更新对应 LoadConfigFile 操作。</p><p>而删除，对应的是 removeConfigFile操作，这个操作的内容就是删除配置服务中的confMaps中对应的key。</p><pre><code class="language-go">// 删除文件的操作\nfunc (conf *HadeConfig) removeConfigFile(folder string, file string) error {\n   conf.lock.Lock()\n   defer conf.lock.Unlock()\n   s := strings.Split(file, ".")\n   // 只有yaml或者yml后缀才执行\n   if len(s) == 2 &amp;&amp; (s[1] == "yaml" || s[1] == "yml") {\n      name := s[0]\n      // 删除内存中对应的key\n      delete(conf.confRaws, name)\n      delete(conf.confMaps, name)\n   }\n   return nil\n}\n</code></pre><p>这里注意下，由于在运行时增加了对confMaps的写操作，所以需要对confMaps进行锁设置，以防止在写confMaps的时候，读操作进入读取了错误信息。</p><p>分析目前的这个场景，读明显多于写。所以我们的锁应该是一个读写锁，读写锁可以让多个读并发读，但是只要有一个写操作，读和写都需要等待。这个很符合当前这个场景。</p><p>所以在框架目录的provider/config/service.go中的HadeConfig，我们增加了一个读写锁lock。</p><pre><code class="language-go">// HadeConfig  表示hade框架的配置文件服务\ntype HadeConfig struct {\n   ...\n   lock     sync.RWMutex           // 配置文件读写锁\n   ...\n}\n</code></pre><p>而在loadConfigFile和removeConfigFile这两个对配置有修改的情况，使用写锁锁住HadeConfig。</p><pre><code class="language-go">// 读取某个配置文件\nfunc (conf *HadeConfig) loadConfigFile(folder string, file string) error {\n   conf.lock.Lock()\n   defer conf.lock.Unlock()\n\n   ...\n}\n</code></pre><p>在Get系列方法调用的find函数中，使用读锁来进行读操作。</p><pre><code class="language-go">// 通过path来获取某个配置项\nfunc (conf *HadeConfig) find(key string) interface{} {\n   conf.lock.RLock()\n   defer conf.lock.RUnlock()\n   ...\n}\n</code></pre><p>这样，配置服务就开发完成了。</p><h2>验证</h2><p>我们先测试环境变量注入配置文件的功能。将业务目录下的config/development/database.yaml 中的mysql.password，使用环境变量进行替换。</p><pre><code class="language-yaml">mysql:\n  hostname: 127.0.0.1\n  username: yejianfeng\n  password: env(DB_PASSWORD)\n  timeout: 1\n  readtime: 2.3\n</code></pre><p>然后修改业务目录下的module/demo/api.go，替换其中/demo/demo对应的路由方法。</p><pre><code class="language-go">func (api *DemoApi) Demo(c *gin.Context) {\n   // 获取password\n   configService := c.MustMake(contract.ConfigKey).(contract.Config)\n   password := configService.GetString("database.mysql.password")\n   // 打印出来\n   c.JSON(200, password)\n}\n</code></pre><p>最后使用命令行  <code>./hade app start</code> 启动服务。打开浏览器，看到输出：</p><p><img src="https://static001.geekbang.org/resource/image/27/f1/275ddfb18f04549dd62e6b45fc3cccf1.png?wh=478x86" alt="图片"></p><p>说明此时还没注入环境变量。下面使用命令行：</p><pre><code class="language-plain">DB_PASSWORD=123 ./hade app start\n</code></pre><p>启动服务。这个命令注入了DB_PASSWORD这个环境变量。<br>\n重启打开浏览器看到输出。</p><p><img src="https://static001.geekbang.org/resource/image/33/b6/33f14f5277ea8294458141d5393269b6.png?wh=405x90" alt="图片"></p><p>环境变量注入成功！</p><p>这个时候我们不停止进程，直接修改配置文件database.yaml中的mysql.password：</p><pre><code class="language-yaml">mysql:\n  hostname: 127.0.0.1\n  username: yejianfeng\n  password: 456789\n  timeout: 1\n  readtime: 2.3\n</code></pre><p>打开浏览器，输出已经变化了。</p><p><img src="https://static001.geekbang.org/resource/image/6c/b7/6c86bf1f4f055d94fb17c756415a94b7.png?wh=377x82" alt="图片"></p><p>说明热更新已经生效了，测试成功。</p><p>今天所有代码的目录结构截图，也贴在这里供你对比检查，代码放在GitHub上的 <a href="https://github.com/gohade/coredemo/tree/geekbang/16">16分支</a> 里。</p><p><img src="https://static001.geekbang.org/resource/image/6c/38/6c9b9046f41e4b5c0719fe205540c438.png?wh=351x1140" alt="图片"></p><h2>小结</h2><p>配置服务在框架中是一个非常基础且重要的服务。</p><p>我们考虑了整个配置服务的实现，先读取配置文件，再替换环境变量，最后再根据路径获取配置项，这样三步走完成了基本的配置服务。在配置服务的基础上，我们又补充了配置服务加载时对App服务的更新，并且为配置服务增加了热更新的机制。</p><p>我个人认为，配置服务是一个App中最常用到的服务了，有非常方便的配置服务接口，能为业务代码节省不少的代码量。<strong>提供多种设置配置的方式，是真实从业务需求出发的</strong>。</p><p>比如在实际工作中，有的需求要求数据库密码不能进入git库，必须通过环境变量获取，我们就可以通过环境变量获取配置；而有的需求要求在一个服务器上调试测试和预发布环境，我们可以通过.env切换不同环境。所以，有个多层次的环境配置机制，对于一个框架来说是非常必要的。</p><h2>思考题</h2><p>现在有配置文件服务了，但是根据路径、获取某个配置却只能在代码中获取。这里我们希望有一个命令行工具  <code>./hade config get "database.mysql"</code> 能获取到这个path路径对应的配置。你可以尝试实现么？</p><p>欢迎在留言区分享你的思考。感谢你的收听，如果觉得有收获，也欢迎把今天的内容分享给你身边的朋友，邀他一起学习。我们下节课见～</p>',
        article_title: "16｜配置和环境（下）：配置服务中的设计思路",
      },
      {
        title: "17｜日志：如何设计多输出的日志服务？",
        id: 429685,
        content:
          '<p>你好，我是轩脉刃。</p><p>上面两节课，我们将环境变量和配置服务作为一个服务注册到容器中了。这样，在业务中就能很方便获取环境变量和配置了。不知道你有没有逐渐体会到这种“一切皆服务”思想的好处。</p><p>就像堆积积木，只要想好了一个服务的接口，我们逐步实现服务之后，这一个服务就是一块积木，之后可以用相同的思路实现各种服务的积木块，用它们来拼出我们需要的业务逻辑。这节课，我们就来实现另一个框架最核心的积木：日志服务。</p><p>实现一个框架的服务，我们习惯了要创建三个文件：接口协议文件 framework/contract/log.go、服务提供者 framework/provider/log/provider.go、接口实例framework/provider/log/service.go。</p><h2>日志接口协议</h2><p>说到日志服务，最先冒出来的一定是三个问题：什么样的日志需要输出？日志输出哪些内容？日志输出到哪里？一个个来分析。</p><h3>日志级别</h3><p>什么样的日志需要输出，这是个关于日志级别的问题。我们想要把日志分为几个级别？每个级别代表什么？这个日志级别其实在不同系统中有不同划分，比如Linux的<a href="https://datatracker.ietf.org/doc/html/rfc5424">syslog</a>中将系统划分为以下八种日志级别：<br>\n<img src="https://static001.geekbang.org/resource/image/f5/ea/f5382bc685494efb2c024f31f25aa2ea.png?wh=912x438" alt=""><br>\n而Java的<a href="https://zh.wikipedia.org/wiki/Log4j">log4j</a>将日志分为以下七种日志级别：<br>\n<img src="https://static001.geekbang.org/resource/image/e0/78/e07a0aefb9039788d17921e192394f78.jpg?wh=1920x1080" alt=""></p><!-- [[[read_end]]] --><p>其实仔细看，它们的日志级别差别都不大。比如都同意用Error级别代表运行时的错误情况，而Warn级别代表运行时可以弥补的错误、Info级别代表运行时信息、debug代表调试的时候需要打印的信息。</p><p>不同点就在是否有trace级别以及Error级别往上的级别定义。syslog没有trace级别，而在Error级别往上分别定义了Emergency级别、Alert级别、Critical级别。而log4j在ERROR上定义了两个级别FATAL和OFF，也同时保留了Trace级别。</p><p>在我看来，syslog和log4j的日志区分主要是由于场景不同。syslog比较偏向于<strong>操作系统的使用场景</strong>，它的分级语义更多是告诉我们系统的情况，比如Alert这个级别表示“系统有问题，需要立即采取行动”；而log4j的日志级别定义是<strong>从一个应用出发的</strong>，它的影响范围理论上会小一些，所以它很难定义比如像“需要立即采取行动”这样的级别。</p><p>所以，这里我们主要参考log4j的日志级别方法，并做了一些小调整，归并为下列七种日志级别：</p><ul>\n<li>panic，表示会导致整个程序出现崩溃的日志信息</li>\n<li>fatal，表示会导致当前这个请求出现提前终止的错误信息</li>\n<li>error，表示出现错误，但是不一定影响后续请求逻辑的错误信息</li>\n<li>warn，表示出现错误，但是一定不影响后续请求逻辑的报警信息</li>\n<li>info，表示正常的日志信息输出</li>\n<li>debug，表示在调试状态下打印出来的日志信息</li>\n<li>trace，表示最详细的信息，一般信息量比较大，可能包含调用堆栈等信息</li>\n</ul><p>在error级别之上，我们把导致程序崩溃和导致请求结束的错误拆分出来，分为panic和fatal两个类型来定义级别。而其他的error、warn、info、debug 都和其他的日志系统一致。另外也增加一个trace级别，当需要打印调用堆栈等这些比较详细的信息的时候，可以使用这种日志级别。</p><p><strong>日志级别是按照严重顺序从下往上排列的</strong>。也就是说，如果我们设置了日志输出级别为info，那么info级别的日志及info级别往上，日志级别更高的warn、error、fatal、panic的日志，也需要被打印出来。</p><p>按照这个思路，我们在framework/contract/log.go中定义的接口协议如下：</p><pre><code class="language-go">package contract\nimport (\n   "context"\n   "io"\n   "time"\n)\n\n// 协议关键字\nconst LogKey = "hade:log"\n\ntype LogLevel uint32\n\nconst (\n   // UnknownLevel 表示未知的日志级别\n   UnknownLevel LogLevel = iota\n   // PanicLevel level, panic 表示会导致整个程序出现崩溃的日志信息\n   PanicLevel\n   // FatalLevel level. fatal 表示会导致当前这个请求出现提前终止的错误信息\n   FatalLevel\n   // ErrorLevel level. error 表示出现错误，但是不一定影响后续请求逻辑的错误信息\n   ErrorLevel\n   // WarnLevel level. warn 表示出现错误，但是一定不影响后续请求逻辑的报警信息\n   WarnLevel\n   // InfoLevel level. info 表示正常的日志信息输出\n   InfoLevel\n   // DebugLevel level. debug 表示在调试状态下打印出来的日志信息\n   DebugLevel\n   // TraceLevel level. trace 表示最详细的信息，一般信息量比较大，可能包含调用堆栈等信息\n   TraceLevel\n)\n...\n\n// Log define interface for log\ntype Log interface {\n   // Panic 表示会导致整个程序出现崩溃的日志信息\n   Panic(ctx context.Context, msg string, fields map[string]interface{})\n   // Fatal 表示会导致当前这个请求出现提前终止的错误信息\n   Fatal(ctx context.Context, msg string, fields map[string]interface{})\n   // Error 表示出现错误，但是不一定影响后续请求逻辑的错误信息\n   Error(ctx context.Context, msg string, fields map[string]interface{})\n   // Warn 表示出现错误，但是一定不影响后续请求逻辑的报警信息\n   Warn(ctx context.Context, msg string, fields map[string]interface{})\n   // Info 表示正常的日志信息输出\n   Info(ctx context.Context, msg string, fields map[string]interface{})\n   // Debug 表示在调试状态下打印出来的日志信息\n   Debug(ctx context.Context, msg string, fields map[string]interface{})\n   // Trace 表示最详细的信息，一般信息量比较大，可能包含调用堆栈等信息\n   Trace(ctx context.Context, msg string, fields map[string]interface{})\n   // SetLevel 设置日志级别\n   SetLevel(level LogLevel)\n   ...\n}\n</code></pre><p>在接口中，我们针对七种日志级别设置了七个不同的方法，并且提供SetLevel方法，来设置当前这个日志服务需要输出的日志级别。</p><h3>日志格式</h3><p>定义好了日志级别，下面该定义日志格式了。日志格式包括输出哪些内容、如何输出？</p><p>首先明确下需要输出的日志信息，不外乎有下面四个部分：</p><ul>\n<li>日志级别，输出当前日志的级别信息。</li>\n<li>日志时间，输出当前日志的打印时间。</li>\n<li>日志简要信息，输出当前日志的简要描述信息，一句话说明日志错误。</li>\n<li>日志上下文字段，输出当前日志的附带信息。这些字段代表日志打印的上下文。</li>\n</ul><p>比如这就是一个完整的日志信息：</p><pre><code class="language-plain">[Info]&nbsp; 2021-09-22T00:04:21+08:00&nbsp; &nbsp; &nbsp; &nbsp;"demo test error"&nbsp; &nbsp; &nbsp; &nbsp;map[api:demo/demo cspan_id: parent_id: span_id:c55051d94815vbl56i2g trace_id:c55051d94815vbl56i20 user:jianfengye]\n</code></pre><p>上面那条日志，日志级别为Info，时间为2021-09-21年15:40:03，时区为+08:00。简要信息demo test error 表示这个日志希望打印的信息，剩下的map表示的key、value为补充的日志上下文字段。</p><p>它对应的调用函数如下：</p><pre><code class="language-go">logger.Info(c, "demo test error", map[string]interface{}{\n   "api":  "demo/demo",\n   "user": "jianfengye",\n})\n</code></pre><p>这里我额外说一下日志上下文字段。它是一个map值，来源可能有两个：一个是用户在打印日志的时候传递的map，比如上面代码中的api和user；而另外一部分数据是可能来自context，因为在具体业务开发中，我们很有可能把一些通用信息，比如trace_id等放在context里，这一部分信息也会希望取出放在日志的上下文字段中。</p><p>所以这里有一个从context中获取日志上下文字段的方法。在framework/contract/log.go中定义其为CtxFielder。</p><pre><code class="language-go">// CtxFielder 定义了从context中获取信息的方法\ntype CtxFielder func(ctx context.Context) map[string]interface{}\n</code></pre><p>明确了打印哪些信息，更要明确这些信息按照什么输出格式输出。这个输出格式也是一个通用方法Fomatter，它的传入参数就是刚才的四个日志信息。</p><pre><code class="language-go">// Formatter 定义了将日志信息组织成字符串的通用方法\ntype Formatter func(level LogLevel, t time.Time, msg string, fields map[string]interface{}) ([]byte, error)\n</code></pre><p>同时在log服务协议中增加了SetFormatter 和 SetCtxFielder的方法。</p><pre><code class="language-go">// Log 定义了日志服务协议\ntype Log interface {\n   ...\n   // SetCtxFielder 从context中获取上下文字段field\n   SetCtxFielder(handler CtxFielder)\n   // SetFormatter 设置输出格式\n   SetFormatter(formatter Formatter)\n   ...\n}\n</code></pre><h3>日志输出</h3><p>已经解决了前两个问题，明确了日志的级别和输出格式，那日志可以输出在哪些地方？</p><p>其实我们在定义接口的时候，并不知道它会输出到哪里。但是只需要知道一定会输出到某个输出管道就可以了，之后在每个应用中使用的时候，我们再根据每个应用的配置，来确认具体的输出管道实现。</p><p>目前这个输出管道我们使用io.Writer来进行设置：</p><pre><code class="language-go">// Log 定义了日志服务协议\ntype Log interface {\n   ...\n   // SetOutput 设置输出管道\n   SetOutput(out io.Writer)\n}\n</code></pre><h2>日志服务提供者</h2><p>日志接口协议文件就完成了，下面来实现日志的服务提供者，在framework/provider/log/provider.go中。</p><p>在编写服务提供者的时候，我们需要先明确最终会提供哪些服务。对于日志服务，按照我们平时的使用情况，可以分为四类：</p><ul>\n<li>控制台输出</li>\n<li>本地单个日志文件输出</li>\n<li>本地单个日志文件，自动进行切割输出</li>\n<li>自定义输出</li>\n</ul><p>这四种输出我们都各自定义一个服务，分别放在framework/provider/log/service/ 目录下的四个文件里：</p><ul>\n<li>console.go 表示控制台输出，定义初始化实例方法NewHadeConsoleLog；</li>\n<li>single.go 表述单个日志文件输出，定义初始化实例方法NewHadeSingleLog；</li>\n<li>rotate.go 表示单个文件输出，但是自动进行切割，定义初始化实例方法NewHadeRotateLog；</li>\n<li>custom.go 表示自定义输出，定义实例化方法NewHadeCustomLog。</li>\n</ul><p>那在服务提供者的Register注册服务实例方法中，我们设计成根据配置项“log.driver” ，来选择不同的实例化方法，默认为NewHadeConsoleLog 方法。</p><pre><code class="language-go">// Register 注册一个服务实例\nfunc (l *HadeLogServiceProvider) Register(c framework.Container) framework.NewInstance {\n   if l.Driver == "" {\n      tcs, err := c.Make(contract.ConfigKey)\n      if err != nil {\n         // 默认使用console\n         return services.NewHadeConsoleLog\n      }\n      cs := tcs.(contract.Config)\n      l.Driver = strings.ToLower(cs.GetString("log.Driver"))\n   }\n   // 根据driver的配置项确定\n   switch l.Driver {\n   case "single":\n      return services.NewHadeSingleLog\n   case "rotate":\n      return services.NewHadeRotateLog\n   case "console":\n      return services.NewHadeConsoleLog\n   case "custom":\n      return services.NewHadeCustomLog\n   default:\n      return services.NewHadeConsoleLog\n   }\n}\n</code></pre><p>而上一节里面分析的，日志的几个配置：日志级别、输出格式方法、context内容获取方法、输出方法，都以服务提供者provider.go 中参数的方式提供。</p><pre><code class="language-go">// HadeLogServiceProvider 服务提供者\ntype HadeLogServiceProvider struct {\n   ...\n\n   // 日志级别\n   Level contract.LogLevel\n   // 日志输出格式方法\n   Formatter contract.Formatter\n   // 日志context上下文信息获取函数\n   CtxFielder contract.CtxFielder\n   // 日志输出信息\n   Output io.Writer\n}\n</code></pre><p>默认提供两种输出格式，一种是文本输出形式，比如上面举的那个例子，</p><pre><code class="language-plain">[Info]&nbsp; 2021-09-22T00:04:21+08:00&nbsp; &nbsp; &nbsp; &nbsp;"demo test error"&nbsp; &nbsp; &nbsp; &nbsp;map[api:demo/demo cspan_id: parent_id: span_id:c55051d94815vbl56i2g trace_id:c55051d94815vbl56i20 user:jianfengye]\n</code></pre><p>另外一种是JSON输出形式，如下：</p><pre><code class="language-plain">{"api":"demo/demo","cspan_id":"","level":5,"msg":"demo1","parent_id":"","span_id":"c54v0tt9481537jasreg","timestamp":"2021-09-21T22:47:19+08:00","trace_id":"c54v0tt9481537jasre0","user":"jianfengye"}\n</code></pre><p>这两种输出除了格式不同，其中的内容应该是相同的。具体使用起来，文本输出更便于我们阅读，而JSON输出更便于机器或者程序阅读。</p><p>在实现文件夹framework/provider/log/formatter/ 里，我们增加两个文件json.go和text.go表示两种格式输出，对应的TextFormatter和JsonFormatter是对应的文本格式输出方法，</p><p>这里就贴出text.go的具体实现，很简单，其他的差别不大，可以参考<a href="https://github.com/gohade/coredemo/blob/geekbang/17/framework/provider/log/formatter/text.go">G</a><a href="https://github.com/gohade/coredemo/blob/geekbang/17/framework/provider/log/formatter/text.go">it</a><a href="https://github.com/gohade/coredemo/blob/geekbang/17/framework/provider/log/formatter/text.go">H</a><a href="https://github.com/gohade/coredemo/blob/geekbang/17/framework/provider/log/formatter/text.go">ub</a>。</p><pre><code class="language-go">// TextFormatter 表示文本格式输出\nfunc TextFormatter(level contract.LogLevel, t time.Time, msg string, fields map[string]interface{}) ([]byte, error) {\n   bf := bytes.NewBuffer([]byte{})\n   Separator := "\\t"\n\n   // 先输出日志级别\n   prefix := Prefix(level)\n\n   bf.WriteString(prefix)\n   bf.WriteString(Separator)\n\n   // 输出时间\n   ts := t.Format(time.RFC3339)\n   bf.WriteString(ts)\n   bf.WriteString(Separator)\n\n   // 输出msg\n   bf.WriteString("\\"")\n   bf.WriteString(msg)\n   bf.WriteString("\\"")\n   bf.WriteString(Separator)\n\n   // 输出map\n   bf.WriteString(fmt.Sprint(fields))\n   return bf.Bytes(), nil\n}\n</code></pre><p>再回到 framework/provider/log/provider.go，定义服务提供者的Params方法。比如获取格式化方法Formatter，我们就设定成，先判断在初始化的时候，是否定义了服务提供者；如果没有，再判断配置项log.formatter是否指定了格式化方法 json/text，设置最终的Formatter，并且传递实例化的方法。</p><pre><code class="language-go">// Params 定义要传递给实例化方法的参数\nfunc (l *HadeLogServiceProvider) Params(c framework.Container) []interface{} {\n   // 获取configService\n   configService := c.MustMake(contract.ConfigKey).(contract.Config)\n\n   // 设置参数formatter\n   if l.Formatter == nil {\n      l.Formatter = formatter.TextFormatter\n      if configService.IsExist("log.formatter") {\n         v := configService.GetString("log.formatter")\n         if v == "json" {\n            l.Formatter = formatter.JsonFormatter\n         } else if v == "text" {\n            l.Formatter = formatter.TextFormatter\n         }\n      }\n   }\n\n   if l.Level == contract.UnknownLevel {\n      l.Level = contract.InfoLevel\n      if configService.IsExist("log.level") {\n         l.Level = logLevel(configService.GetString("log.level"))\n      }\n   }\n\n   // 定义5个参数\n   return []interface{}{c, l.Level, l.CtxFielder, l.Formatter, l.Output}\n}\n</code></pre><p>至于日志服务提供者的其他几个方法（Register、Boot、IsDefer、Name），就不在这里说明了，可以参考<a href="https://github.com/gohade/coredemo/blob/geekbang/17/framework/provider/log/provider.go">GitHub</a>上的代码。</p><h2>日志服务的具体实现</h2><p>最后就到具体的日志服务的实现了。上面我们说，针对四种不同的输出方式，定义了四个不同的服务实例，<strong>这四个不同的服务实例都需要实现前面定义的日志服务协议。如果每个实例都实现一遍，还是非常麻烦的。这里可以使用一个技巧：类型嵌套</strong>。</p><p>我们先创建一个通用的服务实例HadeLog，在HadeLog中存放通用的字段，比如上述日志服务提供者传递的五个参数：container、level、ctxFielder、formatter、output。</p><p>在 provider/log/services/log.go中定义这个结构：</p><pre><code class="language-go">// HadeLog 的通用实例\ntype HadeLog struct {\n   // 五个必要参数\n   level      contract.LogLevel   // 日志级别\n   formatter  contract.Formatter  // 日志格式化方法\n   ctxFielder contract.CtxFielder // ctx获取上下文字段\n   output     io.Writer           // 输出\n   c          framework.Container // 容器\n}\n</code></pre><p>接着在通用实例中，使用这几个必要的参数，就能实现日志协议的所有接口了，这里展示了Info方法是怎么打印信息的：</p><pre><code class="language-go">// Info 会打印出普通的日志信息\nfunc (log *HadeLog) Info(ctx context.Context, msg string, fields map[string]interface{}) {\n   log.logf(contract.InfoLevel, ctx, msg, fields)\n}\n\n// logf 为打印日志的核心函数\nfunc (log *HadeLog) logf(level contract.LogLevel, ctx context.Context, msg string, fields map[string]interface{}) error {\n   // 先判断日志级别\n   if !log.IsLevelEnable(level) {\n      return nil\n   }\n\n   // 使用ctxFielder 获取context中的信息\n   fs := fields\n   if log.ctxFielder != nil {\n      t := log.ctxFielder(ctx)\n      if t != nil {\n         for k, v := range t {\n            fs[k] = v\n         }\n      }\n   }\n\n   ...\n\n   // 将日志信息按照formatter序列化为字符串\n   if log.formatter == nil {\n      log.formatter = formatter.TextFormatter\n   }\n   ct, err := log.formatter(level, time.Now(), msg, fs)\n   if err != nil {\n      return err\n   }\n\n   // 如果是panic级别，则使用log进行panic\n   if level == contract.PanicLevel {\n      pkgLog.Panicln(string(ct))\n      return nil\n   }\n\n   // 通过output进行输出\n   log.output.Write(ct)\n   log.output.Write([]byte("\\r\\n"))\n   return nil\n}\n</code></pre><p>可以看到，Info打印最终调用logf 方法，而logf方法的实现步骤也很清晰，简单梳理一下：</p><ul>\n<li>先判断日志级别是否符合要求，如果不符合要求，则直接返回，不进行打印；</li>\n<li>再使用ctxFielder，从context中获取信息放在上下文字段中；</li>\n<li>接着将日志信息按照formatter序列化为字符串；</li>\n<li>最后通过output进行输出。</li>\n</ul><p>HadeLog其他方法的实现和Info大同小异，这里就不展示所有代码了。实现了基础的HadeLog实例，接下来，就实现对应的四个不同输出类型的实例HadeConsoleLog、HadeSingleLog、HadeRotateLog、HadeCustomLog。<br>\n<img src="https://static001.geekbang.org/resource/image/f2/a5/f2a9c4d54dyy468f00ce97f8888049a5.jpg?wh=1920x1080" alt=""></p><p>这里四个具体实例使用类型嵌套的方式，就能自动拥有HadeLog已经实现了的那些方法。</p><p>比如在 framework/provider/log/service/console.log 中，使用类型嵌套实现 HadeConsoleLog：</p><pre><code class="language-go">// HadeConsoleLog 代表控制台输出\ntype HadeConsoleLog struct {\n   // 类型嵌套HadeLog\n   HadeLog\n}\n</code></pre><p>相当于 HadeConsoleLog 就已经实现了日志服务协议了。我们唯一要做的就是在实例化HadeConosoleLog的时候，将基础HadeLog中的通用字段进行填充。比如 HadeConsoleLog 最重要就是将输出类型output设置为控制台os.stdout：</p><pre><code class="language-go">// NewHadeConsoleLog 实例化HadeConsoleLog\nfunc NewHadeConsoleLog(params ...interface{}) (interface{}, error) {\n   c := params[0].(framework.Container)\n   level := params[1].(contract.LogLevel)\n   ctxFielder := params[2].(contract.CtxFielder)\n   formatter := params[3].(contract.Formatter)\n\n   log := &amp;HadeConsoleLog{}\n\n   log.SetLevel(level)\n   log.SetCtxFielder(ctxFielder)\n   log.SetFormatter(formatter)\n\n   // 最重要的将内容输出到控制台\n   log.SetOutput(os.Stdout)\n   log.c = c\n   return log, nil\n}\n</code></pre><p>四种输出文件其实都大同小异，这里就挑选一个最复杂的带有日志切割的HadeRotateLog来讲解。</p><p>Golang中日志切割有个非常好用的 <a href="https://github.com/lestrrat-go/file-rotatelogs">file-rotatelogs</a>，这个库的使用方法也不复杂，最核心的就是一个初始化操作New：</p><pre><code class="language-go">func New(p string, options ...Option) (*RotateLogs, error) \n</code></pre><p>它有两个参数，第一个参数p是带目录的日志地址，可以允许有通配符代表日期的日志文件名。这里的通配符符合Linux的strftime的定义，具体哪个通配符代表日期、小时、分钟等可以参考strftime的<a href="https://man7.org/linux/man-pages/man3/strftime.3.html">文档说明</a>。而第二个参数是Option数组，表示这个切割日志的一些配置，比如多久切割一次日志文件、切割后的日志文件保存多少天等。</p><p>使用很简单，直接看我们对HadeRotateLog的具体实现。大致思路就是<strong>先定义结构，再实现初始化方法，在初始化方法中，我们实例化file-rotatelogs的初始化操作New</strong>。</p><p>首先定义了 HadeRotateLog 的结构，其中嵌套了基础实例结构HadeLog，同时有这个结构特定的字段folder和file：</p><pre><code class="language-go">// HadeRotateLog 代表会进行切割的日志文件存储\ntype HadeRotateLog struct {\n   HadeLog\n   // 日志文件存储目录\n   folder string\n   // 日志文件名\n   file string\n}\n</code></pre><p>实例化的NewHadeRotateLog 先获取参数，然后从配置文件中获取参数属性folder、file、date_format、rotate_count、rotate_size、max_age、rotate_time，这些属性都和 file-rotatelogs 库实例化的Option参数一一对应。</p><p>所以这里也展示一下我们的log.yaml配置文件可配置的rotate：</p><pre><code class="language-yaml">driver: rotate # 切割日志\nlevel: trace # 日志级别\nfile: coredemo.log # 保存的日志文件\nrotate_count: 10  # 最多日志文件个数\nrotate_size: 120000 # 每个日志大小\nrotate_time: "1m" # 切割时间\nmax_age: "10d" # 文件保存时间\ndate_format: "%Y-%m-%d-%H-%M" # 文件后缀格式\n</code></pre><p>再回到 NewHadeRotateLog，设置了这些配置属性之后，我们实例化 file-rotatelogs，得到了一个符合io.Writer的输出，将这个输出使用 SetOutput 设置到嵌套的 HadeLog 中即可。</p><pre><code class="language-go">// NewHadeRotateLog 实例化HadeRotateLog\nfunc NewHadeRotateLog(params ...interface{}) (interface{}, error) {\n   // 参数解析\n   c := params[0].(framework.Container)\n   level := params[1].(contract.LogLevel)\n   ctxFielder := params[2].(contract.CtxFielder)\n   formatter := params[3].(contract.Formatter)\n\n   appService := c.MustMake(contract.AppKey).(contract.App)\n   configService := c.MustMake(contract.ConfigKey).(contract.Config)\n\n   // 从配置文件中获取folder信息，否则使用默认的LogFolder文件夹\n   folder := appService.LogFolder()\n   if configService.IsExist("log.folder") {\n      folder = configService.GetString("log.folder")\n   }\n   // 如果folder不存在，则创建\n   if !util.Exists(folder) {\n      os.MkdirAll(folder, os.ModePerm)\n   }\n\n   // 从配置文件中获取file信息，否则使用默认的hade.log\n   file := "hade.log"\n   if configService.IsExist("log.file") {\n      file = configService.GetString("log.file")\n   }\n\n   // 从配置文件获取date_format信息\n   dateFormat := "%Y%m%d%H"\n   if configService.IsExist("log.date_format") {\n      dateFormat = configService.GetString("log.date_format")\n   }\n\n   linkName := rotatelogs.WithLinkName(filepath.Join(folder, file))\n   options := []rotatelogs.Option{linkName}\n\n   // 从配置文件获取rotate_count信息\n   if configService.IsExist("log.rotate_count") {\n      rotateCount := configService.GetInt("log.rotate_count")\n      options = append(options, rotatelogs.WithRotationCount(uint(rotateCount)))\n   }\n\n   // 从配置文件获取rotate_size信息\n   if configService.IsExist("log.rotate_size") {\n      rotateSize := configService.GetInt("log.rotate_size")\n      options = append(options, rotatelogs.WithRotationSize(int64(rotateSize)))\n   }\n\n   // 从配置文件获取max_age信息\n   if configService.IsExist("log.max_age") {\n      if maxAgeParse, err := time.ParseDuration(configService.GetString("log.max_age")); err == nil {\n         options = append(options, rotatelogs.WithMaxAge(maxAgeParse))\n      }\n   }\n\n   // 从配置文件获取rotate_time信息\n   if configService.IsExist("log.rotate_time") {\n      if rotateTimeParse, err := time.ParseDuration(configService.GetString("log.rotate_time")); err == nil {\n         options = append(options, rotatelogs.WithRotationTime(rotateTimeParse))\n      }\n   }\n\n   // 设置基础信息\n   log := &amp;HadeRotateLog{}\n   log.SetLevel(level)\n   log.SetCtxFielder(ctxFielder)\n   log.SetFormatter(formatter)\n   log.folder = folder\n   log.file = file\n\n   w, err := rotatelogs.New(fmt.Sprintf("%s.%s", filepath.Join(log.folder, log.file), dateFormat), options...)\n   if err != nil {\n      return nil, errors.Wrap(err, "new rotatelogs error")\n   }\n   log.SetOutput(w)\n   log.c = c\n   return log, nil\n}\n</code></pre><p>本节课我们只是修改了框架目录中的日志服务相关的文件。文件目录：</p><p><img src="https://static001.geekbang.org/resource/image/8c/a8/8c305493bba44f8787efecdf1a8694a8.png?wh=404x512" alt="图片"></p><p><img src="https://static001.geekbang.org/resource/image/e7/2e/e78a3a67060e989616fa0440bd792d2e.png?wh=630x1122" alt="图片"></p><p>所有代码都放在GitHub上的 <a href="https://github.com/gohade/coredemo/tree/geekbang/17">geekbang/17</a> 分支，欢迎比对查看。</p><h2>小结</h2><p>我们这节课通过定义了日志级别、日志格式、日志输出，来实现了日志的级别，并且使用类型嵌套方法实现了四种本地日志输出方式。</p><p>回顾今天实现的日志服务，你会发现和其他服务的实现思路是差不多的。我们<strong>在一个服务中，实现了多个实现类，但是所有的实现类都实现了同样的服务接口</strong>，最后能让我们根据配置来决定这个服务使用哪个实现类，其中还使用了嵌套方式，能节省大量重复性的代码。</p><p>希望你能熟练掌握这种实现方式，因为我们的服务会越来越多，越上层的服务，比如数据库、缓存，它的具体实现就越是多种多样，到时候我们都可以用同样的套路来进行。</p><h2>思考题</h2><p>在微服务盛行的今天，全链路日志是非常重要的一个需求。全链路日志的需求本质就是在日志中增加trace_id、span_id 这样的链路字段。具体实现有三点：</p><ul>\n<li>在接收请求的时候，从请求request中解析全链路字段，存放进入context中</li>\n<li>在打印日志的时候从context中获取全链路字段序列化进入日志</li>\n<li>在发送请求的时候将全链路字段加入到request中</li>\n</ul><p>你可以思考下这个功能应该怎么实现？</p><p>欢迎在留言区分享你的思考。感谢你的收听，如果觉得有收获，也欢迎把今天的内容分享给你身边的朋友，邀他一起学习。我们下节课见。</p>',
        article_title: "17｜日志：如何设计多输出的日志服务？",
      },
    ],
  },
  {
    chapterTitle: "实战第3关：完善功能",
    children: [
      {
        title: "18｜一体化：前端和后端一定要项目分开吗?",
        id: 431016,
        content:
          '<p>你好，我是轩脉刃。</p><p>从这节课开始，我们一起进入了实战第三关。如果说实战第一关怎么从零开始搭建框架是研究如何种栽一株盆栽，实战第二关框架核心的优化，是搭建了盆栽的枝叶，让盆栽可以健康生长，那么实战第三关就是为盆栽增加花叶，之后每一节课讨论和实现的功能都能为框架增色不少。</p><p>下面让我们开始第三关的第一节课框架一体化吧。</p><h2>前后端一体化的架构方案</h2><p>在前后端分离流行的现在，我们已经习惯了前端一个Vue项目+后端一个Web接口项目的组合。这样的组合对于大项目来说，非常符合社会分工的原则，前端由一个人或者一个部门来负责，后端由另外一个人或者一个部门来负责。</p><p>不过作为后端工程师，你一定遇到过要研发一个简单页面的需求。比如一个开发使用的运营后台或者一个简单的工具页面。这个时候如果一个人开发两个项目，你应该会有在两个项目中频繁切换疲于奔命的感觉。所以<strong>如果一个框架能同时支持前端开发，又支持后端接口开发，且两者能完美融合一起</strong>，那该多好啊。这也是我最开始萌生的想法。</p><p>那我们先来思考下，是否可以把这个在一个项目中前后端一体化的设想，设计到真实架构层面的修改中？</p><p>在架构层面，前后端分离的架构经常是，Nginx作为网关，前端页面作为Nginx的一个location路由，而后端接口作为Nginx的另外一个location路由。</p><!-- [[[read_end]]] --><p><img src="https://static001.geekbang.org/resource/image/64/40/646211a81eac29484106cb68644c8c40.jpg?wh=1920x1080" alt="图片"></p><p>这里其实还有一段逻辑代码是存放在Nginx配置中的。所以如果前后端分离，你需要调试开发的除了前端、后端，还有Nginx这一端。而且很多时候，我们会需要在网关Nginx层增加一些统一逻辑，比如有时候会增加路由重写、权限认证等，这里的逻辑也是比较复杂的，于是诞生出nginx_lua之类的网关层的逻辑编写方法。</p><p>但是在Golang的时代，我们是有另外一种选择的，那就是<strong>将API层往上提，使用Golang替代网关的逻辑</strong>，架构形如：</p><p><img src="https://static001.geekbang.org/resource/image/fc/92/fc63dc06df54d50400f4e25714705192.jpg?wh=1920x1080" alt="图片"></p><p>不知道你能否感受到这两种架构的区别和适用场景？先说明一下，<strong>架构无好坏，只有适用不适用</strong>。</p><p>第一种架构的缺点是复杂度高一些，而且一旦在网关层增加逻辑，因为语言异构，网关层逻辑和业务层逻辑不是一个，开发起来会十分痛苦。但是它的优点是模块化，前端、后端、网关是独立模块，互相不干扰。</p><p>而第二种架构的缺点是将三个模块一体化，但是也正是由于一体化了，开发复杂度降低了不少，开发效率提高，通用网关逻辑的研发成本就降低了。</p><p>在实际开发过程中，第二种架构也是有一定场景需求的，比如对一些管理后台、一些快速工具页面的开发，会非常有帮助。所以我们这节课要做的事情就是让hade框架，能快速支持这种前后端一体化的架构。</p><h2>前后端一体化改造</h2><p>既然架构上可以这么做，也有需求。我们来思考如何做前后端一体化。</p><p>前端框架我们就选用目前最火的<a href="https://vuejs.org/">Vue框架</a>。Vue框架是曾就职于Google的华人工程师尤雨溪的大作，目前<a href="https://github.com/vuejs/vue">在GitHub上</a>已经有189k之多的star了。这里简要说一下Vue的使用方式，具体的语法和原理也有很多课程介绍就不多说。</p><p>Vue是一种带构建工具的前端代码生成方式，它的逻辑代码都是以vue后缀的文件实现的，每个vue文件代表一个页面模块，这个模块包含页面HTML、逻辑脚本JS和页面样式CSS。逻辑代码通过构建工具，最终会编译成在浏览器中可运行的HTML和JS文件。</p><p>所以我们只需要将Vue最终编译出来的文件目录，在Golang框架中进行代理，让某个路径能访问到这个静态目录文件即可。不知道你还记得第一节课讲net/http留的思考题么，思考题中提到HTTP 库提供 FileServer来封装对文件读取的 HTTP 服务。我们就可以使用这个FileServer，来对前端编译出来的最终的浏览器可运行文件，提供HTTP服务。</p><p>所以，<strong>将Vue的项目代码集成到业务代码中，然后确定其编译结果文件夹，在路由中，将某个请求路由到我们的编译结果文件夹</strong>，就完成了上面架构提到的同一个项目同时支持前端请求和后端请求了。</p><p>逻辑很清晰，下面就来进行具体的操作。</p><h3>把Vue项目代码集成到业务代码中</h3><p>我们使用 Vue 自带的 vue-init 命令来初始化一个完整的Vue项目。在使用vue-init的时候，会需要选择使用何种构建方式，这里可以选择通用的Webpack构建工具。</p><p>使用命令 <code>vue-init webpack hade</code> 创建一个最完整的hade项目，在创建的过程中，具体是否初始化vue-router、使用使用eslint等，都选用最默认开启的设置。具体的设置参考下图：<br>\n<img src="https://static001.geekbang.org/resource/image/58/9f/5894e71550c89498fb8494e05fd46f9f.png?wh=2092x974" alt=""></p><p>创建完毕，初始化完成。<br>\n<img src="https://static001.geekbang.org/resource/image/3d/60/3d18140ed0d88409c509b92a3067c560.png?wh=1614x486" alt=""></p><p>我们可以看到前端hade目录中的文件如下：<br>\n<img src="https://static001.geekbang.org/resource/image/6c/7a/6c243ddeeaf75b9772486b1786ee167a.png?wh=763x452" alt=""></p><p>这里很基础地认识一下这些目录和文件的具体作用。.xxx 隐藏文件都是一些配置文件信息，比如语法配置、git配置等信息。然后看加粗显示的五个目录：</p><ul>\n<li>build 目录，存放项目构建（Webpack）相关的代码。</li>\n<li>config 是配置目录，包括端口号等配置。</li>\n<li>src目录，这个是我们要开发的目录，业务逻辑代码基本上都在里面。其中有四项：assets 存放一些图片信息，比如logo；componenets 存放组件信息文件；App.vue 存放项目的入口组件App；main.js 是项目的入口js，引用加载入口组件App。</li>\n<li>static目录，存放静态文件信息，比如图片、字体等。</li>\n<li>test目录，存放测试相关的信息。</li>\n</ul><p>剩余的两项，index.html 是 Vue首页的入口页面，package.json 是项目的配置文件，保存引用的第三方库等信息。</p><h3>确定编译结果文件夹</h3><p>前端hade项目生成之后，下一步我们就要把它的文件复制到hade框架的根目录下。</p><p>这里借用IDE就能直接copy前端hade目录下的文件到目标目录。因为和我们之前定义的文件夹和文件并没有什么冲突，所以就不修改任何的文件，保持文件和文件夹一致复制就行。这里需要再提醒一下的是，要将隐藏文件也复制到hade框架的根目录下。</p><p>然后在hade框架的根目录下，我们调用命令 <code>npm install</code> 加载目录所需要的第三方库，再执行 <code>npm run build</code> 就能执行Vue的编译操作，编译src中的Vue代码文件。生成的index文件，存放在根目录的dist 目录下，这个目录就是我们需要的要代理的静态文件目录了。</p><p>这里Vue的目录结构和这些配置文件，使用了Vue最标准的设置。最终，我们只关注编译出来的目录，所以除了这个目录之外，其他的Vue生成目录你都是可以按照需求进行修改的，也就是说，<strong>你完全可以自主替换上面列出的让你认识的Vue目录文件。</strong></p><p>如果你对Vue比较熟悉，或者你有一个现成的Vue项目，比如在课程最后一关我们会用到的vue-element-admin，它有自己的目录结构和配置，会直接进行替换的。</p><h3>把请求路由到结果文件夹</h3><p>下一步要来修改我们的Golang路由了。</p><p>这里要先思考一下了，我们希望路由是什么样子的？一般进入一个网站，打开默认路由 a.com/ 后，会访问默认的index.html，就是编译生成的dist文件夹下的index.html。而在这个网站中，我们要同时访问静态文件 /a.js 或者动态请求 /api/demo/demo。<strong>所以，顺序应该是先看静态文件在/dist 文件夹中是否存在，如果存在则返回静态文件，如果不存在，则访问动态请求</strong>。</p><p>那这种“先查询静态文件，再进行动态请求”的逻辑，在Gin的路由中如何实现呢？</p><p>其实Gin的生态中已经有这个实现方式了。在Gin的开源贡献项目github.com/gin-contrib 中的一个中间件 <a href="https://github.com/gin-contrib/static">static</a> 就是实现这个的。来看GitHub上的使用例子：</p><pre><code class="language-go">func main() {\n\tr := gin.Default()\n\n\t// 根目录先查询本地的tmp文件夹中是否有文件，返回这个文件\n\tr.Use(static.Serve("/", static.LocalFile("/tmp", false)))\n    // 同时提供动态请求路由ping\n\tr.GET("/ping", func(c *gin.Context) {\n\t\tc.String(200, "test")\n\t})\n\t// 启动服务\n\tr.Run(":8080")\n}\n</code></pre><p>它是怎么实现的呢？用的就是前面提过的 HTTP 库提供 FileServer。我们先将这个中间件复制到框架目录的framework/middleware/static/static.go 文件中，再来具体分析下这段实现代码。</p><p>用之前的思维导图方法，就很快速能理清这个static中间件的原理。<br>\n<img src="https://static001.geekbang.org/resource/image/3f/64/3fd7b05aa5d32b2eafa589d4869fdc64.png?wh=2186x425" alt=""></p><p>它的逻辑大概是，先使用http.FileServer创建一个文件服务器，但是这个文件服务器只有处理逻辑fileHandler，没有启动端口；所有请求会进入func(c*gin.Context) 中间件处理函数，在这个处理函数中：</p><ul>\n<li>先判断最终路径的文件是否存在，如果存在，则找到目标文件，如果不存在，判断这个路径是否为目录，如果是目录，再判断目录下的index.html是否存在；如果存在，就找目标文件。</li>\n<li>如果找到了目标文件，则调用文件服务器的ServeHTTP方法来处理这个请求，并且调用Abort来终止后续的请求。</li>\n<li>如果没有找到目标文件，则什么都不做，继续后续的路由请求。</li>\n</ul><p>在复制的过程中注意两个点，一是将static.go中的 github.com/gin-gonic/gin 替换为我们hade框架的gin地址 github.com/gohade/hade/framework/gin；第二点是这个项目是MIT协议，所以我们要保留其协议申明，将LICENCE.md 文件也同时复制。</p><p>最后修改一下路由设置，业务目录下的 app/http/route.go：</p><pre><code class="language-go">// Routes 绑定业务层路由\nfunc Routes(r *gin.Engine) {\n\n // /路径先去./dist目录下查找文件是否存在，找到使用文件服务提供服务\n r.Use(static.Serve("/", static.LocalFile("./dist", false)))\n\n // 动态路由定义\n demo.Register(r)\n}\n</code></pre><p>好了，现在我们的前端Vue项目和静态路由就完成了。做一下验证，先使用命令  <code>npm install</code> 和  <code>npm build</code> 编译好前端，再使用  <code>go build</code> 编译好后端。然后使用命令   <code>./hade app start</code> 启动服务。</p><p>访问地址 <a href="http://localhost:8888/">http://localhost:8888/</a> 能访问到dist目录下生成的Vue静态文件地址：<br>\n<img src="https://static001.geekbang.org/resource/image/5d/25/5df31fbdd2fa0132d165cba5c9b76725.png?wh=2560x1327" alt=""></p><p>同时访问 <a href="http://localhost:8888/demo/demo">http://localhost:8888/demo/demo</a> 也能访问 Golang 定义的动态路由地址：<br>\n<img src="https://static001.geekbang.org/resource/image/90/73/90eaeb3d5263055ff351e76d94a26e73.png?wh=943x252" alt=""></p><p>验证完毕，前后端一体化改造完毕！</p><h2>前后端一体化编译命令改造</h2><p>在改造过程中，不知道你有没有发现，我们频繁使用到了 go build、npm build 等命令进行前后端编译，在实际生产过程中，这种命令执行肯定会更加频繁。那顺着这个问题思考，既然我们这个框架有很方便的命令行工具，<strong>能不能将这些编译命令统一封装一下变成方便使用的命令呢</strong>？</p><p>可以把需求整理成以下四个命令：</p><pre><code class="language-go">编译前端  ./hade build frontend\n编译后端  ./hade build backend\n同时编译前后端 ./hade build all\n自编译 ./hade build self\n</code></pre><p>编译前端，封装npm build命令，而编译后端封装go build 命令，同时编译前后端我们同时调用 npm build 和 go build 就行，自编译其实和编译后端一样，编译./hade 命令行工具自身。</p><p>这里我们就用编译前端命令 ./hade build frontend 来做一个具体实现说明，其他实现基本上都是大同小异了。</p><p>获取npm命令，我们使用 Golang 标准库自带的 exec.LookPath 来查找。如果查找到了，就接着使用 exec.Command 来运行 npm run build，并且将输出 cmd.CombinedOutput，输出到控制台中；如果查找不到，就打印出错误信息。</p><p>实现也不难，在框架目录framework/command/build.go中，我们编辑下列代码：</p><pre><code class="language-go">// 打印前端的命令\nvar buildFrontendCommand = &amp;cobra.Command{\n Use:   "frontend",\n Short: "使用npm编译前端",\n RunE: func(c *cobra.Command, args []string) error {\n  // 获取path路径下的npm命令\n  path, err := exec.LookPath("npm")\n  if err != nil {\n   log.Fatalln("请安装npm在你的PATH路径下")\n  }\n\n  // 执行npm run build\n  cmd := exec.Command(path, "run", "build")\n  // 将输出保存在out中\n  out, err := cmd.CombinedOutput()\n  if err != nil {\n   fmt.Println("=============  前端编译失败 ============")\n   fmt.Println(string(out))\n   fmt.Println("=============  前端编译失败 ============")\n   return err\n  }\n  // 打印输出\n  fmt.Print(string(out))\n  fmt.Println("=============  前端编译成功 ============")\n  return nil\n },\n}\n</code></pre><p>同时要记得将这个 buildFrontendCommand 挂载到build系列命令中。在framework/command/build.go中：</p><pre><code class="language-go">// build相关的命令\nfunc initBuildCommand() *cobra.Command {\n ...\n buildCommand.AddCommand(buildFrontendCommand)\n ...\n return buildCommand\n}\n</code></pre><p>并且挂载到框架目录的 framework/command/kernel.go中：</p><pre><code class="language-go">// AddKernelCommands will add all command/* to root command\nfunc AddKernelCommands(root *cobra.Command) {\n ...\n // build 命令\n root.AddCommand(initBuildCommand())\n</code></pre><p>现在我们可以使用命令 <code>framework/command/kernel.go</code> 来编译前端了：<br>\n<img src="https://static001.geekbang.org/resource/image/df/f4/df3fb101102c8a6ba900996212bb39f4.png?wh=716x607" alt=""></p><p>今天的主要内容前后端一体化改造，以及进一步优化成编译命令我们就完成了。完整的代码示例在GitHub上的 <a href="https://github.com/gohade/coredemo/tree/geekbang/18">geekbang/18</a> 分支，欢迎比对查看。</p><p>本节课我们为hade框架增加了Vue标准项目文件：<br>\n<img src="https://static001.geekbang.org/resource/image/58/95/586eb2e8d01860d6802e9160eed60995.png?wh=444x732" alt=""></p><p>并且在框架目录中增加了build系列命令：<br>\n<img src="https://static001.geekbang.org/resource/image/c2/c5/c28e8641f983958273b403009fd606c5.png?wh=279x560" alt=""></p><h2>小结</h2><p>我们将前端的Vue集成进到hade框架中，并且增加了static中间件，让框架具有同时提供前后端服务的功能。最后在改造过程中，发现频繁用到go build、npm build 等命令做前后端编译，不太方便，所以我们改造了build命令行工具为统一编译前后端命令，提升了编译效率。</p><p>目前的框架，确实很少有支持前后端一体化的，但是我个人的工作经验来说，如果你开发的是一个运营后台系统，很多时候前端和后端都是一个人开发的，那么，前后端一体化的功能就是非常实用的，能大大加快我们的开发效率。</p><h2>思考题</h2><p>我们为hade框架增加了build命令，但是在运行过程中还会用到go 和 npm命令，我们希望框架所有可能用到的命令都封装在./hade 命令下，所以最好能封装一个 ./hade go 和 ./hade npm 命令。这个怎么实现呢？</p><p>欢迎在留言区分享你的思考。感谢你的收听，如果觉得有收获，也欢迎把今天的内容分享给你身边的朋友，邀他一起学习。我们下节课见～</p>',
        article_title: "18｜一体化：前端和后端一定要项目分开吗?",
      },
      {
        title: "19｜提效（上）：实现调试模式加速开发效率",
        id: 431041,
        content:
          '<p>你好，我是轩脉刃。</p><p>上一节课我们把前端Vue融合进hade框架中，让框架能直接通过命令行启动包含前端和后端的一个应用，今天继续思考优化。</p><p>在使用Vue的时候，你一定使用过 <code>npm run dev</code> 这个命令，为前端开启调试模式，在这个模式下，只要你修改了src下的文件，编译器就会自动重新编译，并且更新浏览器页面上的渲染。这种调试模式，为开发者提高了不少开发效率。</p><p>那这种调试模式能否应用到Golang后端，让前后端都开启这种调试模式，来进一步提升我们开发应用的效率呢？接下来两节课，我们就来尝试实现这种调试模式。</p><h2>方案思考和设计</h2><p>先来思考下调试模式应该怎么设计？因为分为前端和后端，关于Vue前端，既然已经有了 <code>npm run dev</code> 这种调试模式，自然可以直接使用这种方式，要改的主要就是后端。</p><p>对于后端Golang代码，Golang本身并没有提供任何调试模式的方式进行代码调试，<strong>只能先通过go build 编译出二进制文件，通过运行二进制文件再启动服务</strong>。那我们如何实现刚才的想法，一旦修改代码源文件，就能重新编译运行呢？</p><p>相信你一定很快想到了之前实现过配置文件的热更新。在第16章开发配置服务的时候，我们使用了 <a href="https://github.com/fsnotify/fsnotify">fsnotify</a> 库，来对配置目录下的所有文件进行变更监听，一旦修改了配置目录下的文件，就重新更新内存中的配置文件map。</p><!-- [[[read_end]]] --><p>那这里是否可以如法炮制，将 AppPath 目录下的文件也进行监听呢？一旦这个目录下的文件有了变更，就重新编译运行后端服务？</p><p>是的，原理可行，我们完全可以按照这种想法来构想一下。现在假设我们<strong>监听了后端文件，能变更调试后端服务，也能通过Vue自带命令调试前端</strong>，但这里又遇到难点了，如果需要前后端服务同时调试呢？</p><p>前端启动调试模式的方式和我们之前的编译方式完全不一样，它是直接启动一个端口来服务，并没有在dist下生成最终编译文件。这样，我们上一章设计的后端直接代理最终编译文件的方法就无法使用了。怎么办？</p><p>虽然过程不一样，但启动后的行为是差不多的。后端，实现了监听文件重新编译启动后，也是启动了一个进程来提供服务。思考到这里，自然而然，我们就想到<strong>是否能在前端和后端服务的前面，设计一个反向代理proxy服务呢</strong>？</p><p><img src="https://static001.geekbang.org/resource/image/86/16/86d2c8a583a1dafa52ee79fb95f30616.jpg?wh=1920x1080" alt="图片"></p><p>让所有外部请求进入这个反响代理服务，然后由反向代理服务进行代理分发，前端请求分发到前端进程，后端请求分发到后端进程。</p><p>方案思路很流畅，我们来看如何实现。</p><h2>实现技术难点分析</h2><p>先攻坚最关键的技术难点，如何实现反向代理。</p><p>所谓反向代理，就是能将一个请求按照条件分发到不同的服务中去。在Golang中的net/http/httputil 包中提供了ReverseProxy 这么一个数据结构，它是实现整个反向代理的关键。</p><p>我们使用命令  <code>go doc net/http/httputil.ReverseProxy</code> 看下这个数据结构的定义，每个字段的说明我详细写在代码注释里面了：</p><pre><code class="language-go">// 反向代理\ntype ReverseProxy struct {\n    // Director这个函数传入的参数是新复制的一个请求，我们可以修改这个请求\n    // 比如修改请求的请求Host或者请求URL等\n\tDirector func(*http.Request)\n\n\t// Transport 代表底层的连接池设置，比如连接最长保持多久等\n    // 如果不填的话，则使用默认的设置\n\tTransport http.RoundTripper\n\n\t// FlushInterval表示多久将下游的response的数据拷贝到proxy的response\n\tFlushInterval time.Duration\n\n\t// ErrorLog 表示错误日志打印的句柄\n\tErrorLog *log.Logger\n\n\t// BufferPool表示将下游response拷贝到proxy的response的时候使用的缓冲池大小\n\tBufferPool BufferPool\n\n\t// ModifyResponse 函数表示，如果要将下游的response内容进行修改，再传递给proxy\n    // 的response，这个函数就可以进行设置，但是如果这个函数返回了error，则将response\n    // 传递进入ErrorHandler，否则使用默认设置\n\tModifyResponse func(*http.Response) error\n\n\t// ErrorHandler 处理ModifyResponse返回的Error\n\tErrorHandler func(http.ResponseWriter, *http.Request, error)\n}\n</code></pre><p>这里我着重解释一下这次会使用到的三个字段 Director、ModifyResponse、ErrorHandler，Director是必须填写的，而ModifyResponse、ErrorHandler是可选的。</p><p><strong>Director的参数是请求，表示如何对请求进行转发</strong>。最简单的，我们可以修改请求的目标Host，将请求转发到后端的服务。具体如何使用，可以看net/http/httputil库带的NewSingleHostReverseProxy方法，它将请求转发给后端target地址的时候，直接将request的scheme、host、path 都进行了替换。这个方法也是后面我们经常要用到的。</p><pre><code class="language-go">// 将原先的请求转发到target地址\nfunc NewSingleHostReverseProxy(target *url.URL) *ReverseProxy {\n   targetQuery := target.RawQuery\n   // 设置director\n   director := func(req *http.Request) {\n      // 将原先的request替换scheme, host，path。\n      req.URL.Scheme = target.Scheme\n      req.URL.Host = target.Host\n      req.URL.Path, req.URL.RawPath = joinURLPath(target, req.URL)\n      ...\n   }\n   return &amp;ReverseProxy{Director: director}\n}\n</code></pre><p>其次是<strong>ModifyResponse字段</strong>，在下游response要拷贝给上游proxy的response的时候，会使用到它代表的函数，如果我们要对下游的返回数据进行修改，就可以设置这个字段。</p><pre><code class="language-go">\tModifyResponse func(*http.Response) error\n</code></pre><p>这个字段的参数就只有一个，http.Response指针，代表的是下游返回给上游的返回结构，我们可以对这个指针的内容进行操作。而返回值error，代表操作的结果，如果在操作过程中出现错误，会返回error。</p><p>返回的error，就会进入<strong>第三个字段函数 ErrorHandler</strong>中。</p><pre><code class="language-go">\tErrorHandler func(http.ResponseWriter, *http.Request, error)\n</code></pre><p>ErrorHandler有三个参数，responseWriter是新proxy的reponse的写句柄，request 是Director修改后给下游的request，而error则是ModifyResponse处理后的error。</p><p>了解清楚这三个字段函数中每个参数和返回值是非常重要的，这样才能准确地使用这些字段。下面我们就活学活用这个ReverseProxy。</p><p><strong>使用ReverseProxy作为反向代理，那么对应的路由规则是什么样的呢？什么样的请求进入后端，什么样的请求进入前端呢</strong>？这里我们需要再思考下。</p><p>还记得么，在上一节课增加前端代码Vue进入hade框架中的时候，我们使用了一个中间件static，来将请求按照规则进行分发：如果请求地址在dist目录中存在，返回对应的请求文件，而如果请求地址在dist目录中不存在，就什么都不做，进行后续的路由规则判定。</p><p>但是在调试模式下，并没有前端编译环境，那我们怎么判断这个请求是进入前端，还是进入后端呢？这里是一个比较难的点。</p><p>可以反过来做。<strong>一个请求到了，直接先请求一下后端服务，如果后端发现请求不存在，返回404 Not Found之后， 我们再将请求再请求到前端服务</strong>，就可以完美解决这个问题。这里用到刚才学习的 ReverseProxy 结构里面的 Director。</p><p>在Director中，将请求设置为转发给后端服务。这样当后端服务查找到路由不存在，返回404的时候，我们是能在 ModifyResponse 中获取到后端返回的StatusCode的。之后再判断如果为404，让 ModifyResponse 返回一个自定义的 NotFoundErr。</p><p>一旦ModifyResponse返回了Error，就会进入到 ErrorHandler 函数中，在这个函数中，我们判断一下参数中的error是否是之前定义的NotFoundErr，如果是的话，就再用NewSingleHostReverseProxy来创建一个前端的Proxy，将这个请求代理到前端服务中。</p><p>把这段实现的网关服务逻辑翻译成代码，在framework/command/dev.go中：</p><pre><code class="language-go">// 重新启动一个proxy网关\nfunc (p *Proxy) newProxyReverseProxy(frontend, backend *url.URL) *httputil.ReverseProxy {\n ...\n // 先创建一个后端服务的directory\n director := func(req *http.Request) {\n  req.URL.Scheme = backend.Scheme\n  req.URL.Host = backend.Host\n }\n \n // 定义一个NotFoundErr\n NotFoundErr := errors.New("response is 404, need to redirect")\n \n return &amp;httputil.ReverseProxy{\n  Director: director, // 先转发到后端服务\n  \n  ModifyResponse: func(response *http.Response) error {\n   \n   // 如果后端服务返回了404，我们返回NotFoundErr 会进入到errorHandler中\n   if response.StatusCode == 404 {\n    return NotFoundErr\n   }\n   return nil\n  },\n  \n  ErrorHandler: func(writer http.ResponseWriter, request *http.Request, err error) {\n   \n   // 判断 Error 是否为NotFoundError, 是的话则进行前端服务的转发，重新修改writer\n   if errors.Is(err, NotFoundErr) {\n    httputil.NewSingleHostReverseProxy(frontend).ServeHTTP(writer, request)\n   }\n  }}\n}\n</code></pre><h2>command 设计</h2><p>思考清楚了技术难点，我们就可以开始设计命令了。这里为我们的框架重新定义一个dev一级命令，这个命令专门是调试模式，没有什么实际的作用，只是显示帮助信息。而它下面有三个二级命令：dev frontend 调试前端、dev backend 调试后端、dev all 前后端同时调试。</p><pre><code class="language-go">./hade dev //显示帮助信息\n./hade dev frontend // 调试前端\n./hade dev backend  // 调试后端\n./hade dev all  // 显示所有\n</code></pre><p>在定义工具命令的时候，如果遇到有前端和后端的，我们应该统一在命令中使用关键字 frontend 和 backend 分别代表前后端，这样可以给使用者不断加深强调这两个关键字，这样我们在使用命令的时候，就能很快反应出前后端对应的命令了。</p><p>创建一个 framework/command/dev.go 来存放这个调试命令：</p><pre><code class="language-go">// 初始化Dev命令\nfunc initDevCommand() *cobra.Command {\n devCommand.AddCommand(devBackendCommand)\n devCommand.AddCommand(devFrontendCommand)\n devCommand.AddCommand(devAllCommand)\n return devCommand\n}\n\n// devCommand 为调试模式的一级命令\nvar devCommand = &amp;cobra.Command{\n Use:   "dev",\n Short: "调试模式",\n RunE: func(c *cobra.Command, args []string) error {\n  c.Help()\n  return nil\n },\n}\n\n// devBackendCommand 启动后端调试模式\nvar devBackendCommand = &amp;cobra.Command{\n Use:   "backend",\n Short: "启动后端调试模式",\n RunE: func(c *cobra.Command, args []string) error {\n  ...\n },\n}\n\n// devFrontendCommand 启动前端调试模式\nvar devFrontendCommand = &amp;cobra.Command{\n Use:   "frontend",\n Short: "前端调试模式",\n RunE: func(c *cobra.Command, args []string) error {\n   ...\n },\n}\n\n// 同时启动前端和后端调试\nvar devAllCommand = &amp;cobra.Command{\n Use:   "all",\n Short: "同时启动前端和后端调试",\n RunE: func(c *cobra.Command, args []string) error {\n  ...\n },\n}\n</code></pre><p>同时在 framework/command/kernel.go 中，我们加上dev的命令：</p><pre><code class="language-go">// 框架核心命令\nfunc AddKernelCommands(root *cobra.Command) {\n ...\n // dev 调试命令\n root.AddCommand(initDevCommand())\n</code></pre><h2>proxy 类的设计</h2><p>定义了dev 命令的设计，我们再思考一下它如何实现。首先需要一个结构来承担起调试模式所有的逻辑，这里定义为Proxy结构。proxy结构和proxy结构对应的方法我们都存放在 framework/command/dev.go中：</p><pre><code class="language-go">// Proxy 代表serve启动的服务器代理\ntype Proxy struct {\n  ...\n}\n</code></pre><p>同时定义一个NewProxy方法来初始化这个Proxy结构：</p><pre><code class="language-go">func NewProxy(c framework.Container) *Proxy\n</code></pre><p>在初始化proxy的时候，需要容器中的一些服务，比如配置文件服务等，所以这里传递了一个容器的参数。</p><p>这个proxy结构应该有几个方法，按照代理分发的结构示意图，我们要<strong>定义proxy服务需要的方法、前端服务需要的方法和后端服务需要的方法</strong>。</p><p>针对proxy服务，首先需要定义我们在讲反向代理技术难点的时候提到的方法 newProxyReverseProxy，用来创建一个代理前后端的代理ReverseProxy结构。</p><pre><code class="language-go">func (p *Proxy) newProxyReverseProxy(frontend, backend *url.URL) *httputil.ReverseProxy\n</code></pre><p>其次，还需要一个启动proxy的方法 startProxy。它的传入参数就直接设置为两个bool，代表是否要开启前端服务的代理、以及是否要开启后端服务的代理。</p><pre><code class="language-go">func (p *Proxy) startProxy(startFrontend, startBackend bool) error\n</code></pre><p>再来定义前后端服务的方法。明显要有一个方法能启动前端服务、也要有一个方法能启动后端服务：</p><pre><code class="language-go">func (p *Proxy) restartFrontend() error\nfunc (p *Proxy) restartBackend() error \n</code></pre><p>这里注意一下，前端服务是直接使用 <code>npm run dev</code> 命令启动调试模式的，而后端服务是先进行  <code>go build</code> 再进行  <code>go run</code> ，所以后端服务是需要进行编译的，所以我们还需要一个编译后端服务的方法：</p><pre><code class="language-go">func (p *Proxy) rebuildBackend() error\n</code></pre><p>同时，由于前端服务已经自己有了监控文件变更的逻辑，不需要我们再监控前端文件是否有变更了。而后端服务需要一个函数来监控源码文件的变更：</p><pre><code class="language-go">func (p *Proxy) monitorBackend() error\n</code></pre><p>这个监控文件我们设计为阻塞式的，在for 循环中不断监控文件的变动，所以在调用的时候，如果不需要在这个函数中阻塞，可以开启一个Goroutine进行监听。</p><p>有了这些函数，我们就串联一下上面的command的设计。</p><p>首先前端调试模式，就非常简单，启动一个只带有前端的proxy就行：</p><pre><code class="language-go">// devFrontendCommand 启动前端调试模式\nvar devFrontendCommand = &amp;cobra.Command{\n ...\n RunE: func(c *cobra.Command, args []string) error {\n  // 启动前端服务\n  proxy := NewProxy(c.GetContainer())\n  return proxy.startProxy(true, false)\n },\n}\n</code></pre><p>其次是后端调试模式，先启动一个Goroutine监听后端文件，再启动一个只有后端的proxy：</p><pre><code class="language-go">// devBackendCommand 启动后端调试模式\nvar devBackendCommand = &amp;cobra.Command{\n ...\n RunE: func(c *cobra.Command, args []string) error {\n  proxy := NewProxy(c.GetContainer())\n  // 监听后端文件\n  go proxy.monitorBackend()\n  // 启动只有后端的proxy\n  if err := proxy.startProxy(false, true); err != nil {\n   return err\n  }\n  return nil\n },\n}\n</code></pre><p>而前后端同时调试，则是先启动一个Goroutine监听后端文件，再同时启动监听前后端的proxy：</p><pre><code class="language-go">var devAllCommand = &amp;cobra.Command{\n ...\n RunE: func(c *cobra.Command, args []string) error {\n  proxy := NewProxy(c.GetContainer())\n  // 监听后端文件\n  go proxy.monitorBackend()\n  // 启动前后端同时监听的proxy\n  if err := proxy.startProxy(true, true); err != nil {\n   return err\n  }\n  return nil\n },\n}\n</code></pre><p>今天只在framework/command/目录下增加了一个dev.go文件，代码地址在 <a href="https://github.com/gohade/coredemo/tree/geekbang/19">geekbang/19</a> 分支上。下节课我们继续完成调试模式的具体实现。<br>\n<img src="https://static001.geekbang.org/resource/image/4f/62/4f70c9293be8ccdyy55b395bc9705862.png?wh=734x1450" alt=""></p><h2>小结</h2><p>今天这节课最关键的点就在于ReverseProxy的运用。ReverseProxy是Golang标准库提供的反向代理的实现方式。而反向代理，在实际业务开发过程中实际上是非常好用的。</p><p>比如我们在业务开发过程中很有可能会需要自研网关，来全局代理和监控所有的后端接口；又或者在拆分微服务的时候，需要有一个统一路由层来引导流量。这个ReverseProxy结构的熟练使用就是这些功能的核心关键。</p><p>今天我们为hade框架增加了调试模式，这个模式在很多Golang的框架中是没有的，算是我们的hade框架的一大特色了。大多数框架是依赖于日志进行编译调试。而hade框架之所以能提供这种方便的调试模式，也是依赖于我们前面已经实现的前后端一体、目录服务，配置服务等逻辑。</p><p>在实际工作中，特别在调试的时候，这种调试模式一定能为你带来很大的便利。</p><h2>思考题</h2><p>讲ReverseProxy时，我们的逻辑是先请求后端服务，如果后端服务出现404，再请求前端。这里有两个问题你可以思考下：</p><p>1.可以不可以先请求vue的前端服务，如果前端服务出现404，再请求后端呢？</p><p>2.某些vue确定的请求地址，比如"/app.js", “/” ，是否可以不用走这个先后端服务、再前端服务的逻辑？如果可以，怎么做呢？</p><p>欢迎在留言区分享你的思考。感谢你的收听，如果觉得有收获，也欢迎把今天的内容分享给你身边的朋友，邀他一起学习。我们下节课见～</p>',
        article_title: "19｜提效（上）：实现调试模式加速开发效率",
      },
      {
        title: "20｜提效（下）：实现调试模式加速开发效率",
        id: 431084,
        content:
          '<p>你好，我是轩脉刃。</p><p>上一节课，我们讨论了调试模式的整体设计思路和关键的技术难点-反向代理，最后定义了具体的命令设计，包括三个二级命令，能让我们调试前端/后端，或者同时调试。现在，大的框架都建立好了，但是其中的细节实现还没有讨论。成败在于细节，今天我们就撸起袖子开始实现它们。</p><h2>配置项的设计</h2><p>简单回顾一下调试模式的架构设计。所有外部请求进入反响代理服务后，会由反向代理服务进行分发，前端请求分发到前端进程，后端请求分发到后端进程。<br>\n<img src="https://static001.geekbang.org/resource/image/86/16/86d2c8a583a1dafa52ee79fb95f30616.jpg?wh=1920x1080" alt=""><br>\n在这个设计中，前端服务启动的时候占用哪个端口？后端服务启动的时候占用哪个端口？反向代理服务proxy启动的时候占用哪个端口呢？这些都属于配置项，需要在设计之初就规划好，所以我们先设计配置项的具体实现。</p><p>由于调试模式配置项比较多，在framework/command/dev.go 中，我们定义如下的配置结构devConfig来表示配置信息：</p><pre><code class="language-go">// devConfig 代表调试模式的配置信息\ntype devConfig struct {\n\n   Port    string   // 调试模式最终监听的端口，默认为8070\n   \n   Backend struct { // 后端调试模式配置\n      RefreshTime   int    // 调试模式后端更新时间，如果文件变更，等待3s才进行一次更新，能让频繁保存变更更为顺畅, 默认1s\n      Port          string // 后端监听端口， 默认 8072\n      MonitorFolder string // 监听文件夹，默认为AppFolder\n   }\n   \n   Frontend struct { // 前端调试模式配置\n      Port string // 前端启动端口, 默认8071\n   }\n}\n</code></pre><!-- [[[read_end]]] --><p>这个结构可以说已经非常清晰了。结构根目录下的Port代表proxy的端口，而根目录下的Backend 和 Frontend 分别代表后端和前端的配置。</p><p>其中，前端只需要配置一个端口Port，<strong>而后端，我们除了配置端口Port之外，还另外多了两个配置，一个是监听的文件夹MonitorFolder，另外一个是监听文件夹的变更时间RefreshTime</strong>，这两个配置都是和后端监听文件夹相关的，具体如何使用，我们在后面写proxy的方法monitorBackend再详细说。</p><p>有了这个配置结构还不够，我们还要定义配置结构中每个值的赋值和默认值，在配置文件app.yaml中对应定义的配置字段如下：</p><pre><code class="language-yaml">dev: # 调试模式\n  port: 8070 # 调试模式最终监听的端口，默认为8070\n  backend: # 后端调试模式配置\n    refresh_time: 3  # 调试模式后端更新时间，如果文件变更，等待3s才进行一次更新，能让频繁保存变更更为顺畅, 默认1s\n    port: 8072 # 后端监听端口，默认8072\n    monitor_folder: "" # 监听文件夹地址，为空或者不填默认为AppFolder\n  frontend: # 前端调试模式配置\n    port: 8071 # 前端监听端口, 默认8071\n</code></pre><p>之后如果在配置文件中有配置这些字段，就使用配置文件中的字段，否则的话，则使用默认配置。对应到代码上，我们可以在framework/command/dev.go中实现一个initDevConfig。</p><p>实现思路也不难，参数只需要把服务容器传递进入就行了，在这个函数中，我们先定义好默认的配置，然后从容器中获取配置服务，通过配置服务，获取对应的配置文件的设置，如果配置文件有对应字段的话，就进行对应字段的配置。</p><pre><code class="language-go">// 初始化配置文件\nfunc initDevConfig(c framework.Container) *devConfig {\n    // 设置默认值\n    devConfig := &amp;devConfig{\n        Port: "8087",\n        Backend: struct {\n            RefreshTime   int\n            Port          string\n            MonitorFolder string\n        }{\n            1,\n            "8072",\n            "",\n        },\n        Frontend: struct {\n            Port string\n        }{\n            "8071",\n        },\n    }\n    // 容器中获取配置服务\n    configer := c.MustMake(contract.ConfigKey).(contract.Config)\n    // 每个配置项进行检查\n    if configer.IsExist("app.dev.port") {\n        devConfig.Port = configer.GetString("app.dev.port")\n    }\n    if configer.IsExist("app.dev.backend.refresh_time") {\n        devConfig.Backend.RefreshTime = configer.GetInt("app.dev.backend.refresh_time")\n    }\n    if configer.IsExist("app.dev.backend.port") {\n        devConfig.Backend.Port = configer.GetString("app.dev.backend.port")\n    }\n    \n    // monitorFolder 默认使用目录服务的AppFolder()\n    monitorFolder := configer.GetString("app.dev.backend.monitor_folder")\n    if monitorFolder == "" {\n        appService := c.MustMake(contract.AppKey).(contract.App)\n        devConfig.Backend.MonitorFolder = appService.AppFolder()\n    }\n    if configer.IsExist("app.dev.frontend.port") {\n        devConfig.Frontend.Port = configer.GetString("app.dev.frontend.port")\n    }\n    return devConfig\n}\n\n</code></pre><p>这里着重说一下monitorFolder这个配置的逻辑，如果配置文件中有定义这个配置的话，我们就使用配置文件的配置，否则我们就去目录服务中获取AppFolder。其实这种有层次的配置方式，在配置服务那一节我们已经见过了，多使用这种配置方式能让框架可用性更高。</p><p>但是之前<a href="https://time.geekbang.org/column/article/425820">第12节课</a>，定义目录服务接口的时候，没有定义App的服务接口，所以我们得去稍微修改下目录服务接口 framework/contract/app.go，为其增加AppFolder这个目录接口：</p><pre><code class="language-go">// App 定义接口\ntype App interface {\n   ...\n\n   // AppFolder 定义业务代码所在的目录，用于监控文件变更使用\n   AppFolder() string\n   ...\n}\n</code></pre><p>同时修改其对应实现 framework/provider/app/service.go，增加这个AppFolder的实现：</p><pre><code class="language-go">// AppFolder 代表app目录\nfunc (app *HadeApp) AppFolder() string {\n   if val, ok := app.configMap["app_folder"]; ok {\n      return val\n   }\n   return filepath.Join(app.BaseFolder(), "app")\n}\n</code></pre><p>到这里，配置结构devConfig及配置结构初始化方法 initDevConfig，就实现完成了。</p><h2>具体实现</h2><p>现在，来完成拼图的最后一个部分，回到framework/command/dev.go中，上节课只定义了Proxy结构，但是Proxy结构中的字段，我们没有讨论。</p><p>首先有了上面定义的devConfig结构之后，Proxy的结构中，应该有一个字段保存这个Proxy的配置信息devConfig。</p><p>其次，在restart前端或者后端的时候，由于<strong>新进程和旧进程都使用一样的端口</strong>，我们一定是先关闭旧的前端进程或者后端进程，才能启动新的前端或者后端进程。所以这里要记录一下前后端进程的进程ID，设置了backendPid和 frontendPid来存储进程ID。</p><pre><code class="language-go">// Proxy 代表serve启动的服务器代理\ntype Proxy struct {\n   devConfig   *devConfig // 配置文件\n   backendPid  int        // 当前的backend服务的pid\n   frontendPid int        // 当前的frontend服务的pid\n}\n</code></pre><p>下面我们就针对每个函数的具体实现一一说明，这里把上节课定义的各个函数简单再列一下，如果你对它们的功能有点模糊了，可以再回顾一下第19课。</p><pre><code class="language-go">// 初始化一个Proxy\nfunc NewProxy(c framework.Container) *Proxy{}\n// 重新启动一个proxy网关\nfunc (p *Proxy) newProxyReverseProxy(frontend, backend *url.URL) *httputil.ReverseProxy{}\n// 启动前端服务\nfunc (p *Proxy) restartFrontend() error{}\n// 启动后端服务\nfunc (p *Proxy) restartBackend() error {}\n// 编译后端服务\nfunc (p *Proxy) rebuildBackend() error {}\n// 启动proxy\nfunc (p *Proxy) startProxy(startFrontend, startBackend bool) error{}\n// 监控后端服务源码文件的变更\nfunc (p *Proxy) monitorBackend() error{}\n</code></pre><h3>newProxyReverseProxy</h3><p>首先是newProxyReverseProxy，它的核心逻辑就是创建ReverseProxy，设置Director、ModifyResponse、ErrorHandler三个字段。但是我们在细节上要做一些补充。</p><p>首先，既然已经在proxy中存了前后端的PID，那就可以知道当下前端服务或者后端服务是否已经启动了。如果只启动了前端服务，我们直接代理前端就好了；如果只启动后端服务，就直接代理后端。而<strong>只有两个服务都启动了，我们才进行上一节课说的：先请求后端服务，遇到404了，再请求前端服务</strong>。</p><p>同时稍微修改一下director，对于前端一些固定的请求地址，比如 / 或者 /app.js，我们直接将这个地址固定请求前端。</p><pre><code class="language-go">// 重新启动一个proxy网关\nfunc (p *Proxy) newProxyReverseProxy(frontend, backend *url.URL) *httputil.ReverseProxy {\n   if p.frontendPid == 0 &amp;&amp; p.backendPid == 0 {\n      fmt.Println("前端和后端服务都不存在")\n      return nil\n   }\n\n   // 后端服务存在\n   if p.frontendPid == 0 &amp;&amp; p.backendPid != 0 {\n      return httputil.NewSingleHostReverseProxy(backend)\n   }\n\n   // 前端服务存在\n   if p.backendPid == 0 &amp;&amp; p.frontendPid != 0 {\n      return httputil.NewSingleHostReverseProxy(frontend)\n   }\n\n   // 两个都有进程\n   // 先创建一个后端服务的directory\n   director := func(req *http.Request) {\n      if req.URL.Path == "/" || req.URL.Path == "/app.js" {\n         req.URL.Scheme = frontend.Scheme\n         req.URL.Host = frontend.Host\n      } else {\n         req.URL.Scheme = backend.Scheme\n         req.URL.Host = backend.Host\n      }\n   }\n\n   // 定义一个NotFoundErr\n   NotFoundErr := errors.New("response is 404, need to redirect")\n   return &amp;httputil.ReverseProxy{\n      Director: director, // 先转发到后端服务\n      ModifyResponse: func(response *http.Response) error {\n         // 如果后端服务返回了404，我们返回NotFoundErr 会进入到errorHandler中\n         if response.StatusCode == 404 {\n            return NotFoundErr\n         }\n         return nil\n      },\n      ErrorHandler: func(writer http.ResponseWriter, request *http.Request, err error) {\n         // 判断 Error 是否为NotFoundError, 是的话则进行前端服务的转发，重新修改writer\n         if errors.Is(err, NotFoundErr) {\n            httputil.NewSingleHostReverseProxy(frontend).ServeHTTP(writer, request)\n         }\n      }}\n}\n</code></pre><h3>rebuildBackend / restartBackend</h3><p>下一个函数是rebuildBackend。这个函数的作用是重新编译后端。</p><p>那如何编译后端呢？还记得第18课中为编译后端定义了命令行么？所以在“调试命令”中，我们只需要调用“编译命令”就行了。</p><ul>\n<li>编译前端  ./hade build frontend</li>\n<li>编译后端  ./hade build backend</li>\n<li>同时编译前后端 ./hade build all</li>\n<li>自编译 ./hade build self</li>\n</ul><p>所以rebuildBackend 这个函数，我们就是调用一次 <code>./hade build backend</code> 。</p><pre><code class="language-go">// rebuildBackend 重新编译后端\nfunc (p *Proxy) rebuildBackend() error {\n   // 重新编译hade\n   cmdBuild := exec.Command("./hade", "build", "backend")\n   cmdBuild.Stdout = os.Stdout\n   cmdBuild.Stderr = os.Stderr\n   if err := cmdBuild.Start(); err == nil {\n      err = cmdBuild.Wait()\n      if err != nil {\n         return err\n      }\n   }\n   return nil\n}\n</code></pre><p>编译后端函数实现了，下面就是重启后端进程restartBackend。</p><p>我们当然也会记得在<a href="https://time.geekbang.org/column/article/425820">第12章</a>将启动Web服务变成一个命令  <code>./hade app start</code> 。所以重启后端服务的步骤就是：</p><ul>\n<li>关闭旧进程（kill）</li>\n<li>启动新进程（./hade app start）</li>\n</ul><p>但是这里有个小问题，<strong>之前启动进程的时候，进程端口是写死的。但是，现在需要固定启动的App的进程端口</strong>。所以要对  <code>./hade app start</code> 命令进行一些改造。</p><p>来修改framework/command/app.go，我们增加一个appAddress地址，这个地址可以传递类似   <code>localhost:8888</code> 或者  <code>:8888</code> 这样的启动服务地址，并且在appStartCommand中使用这个appAddress。</p><pre><code class="language-go">// app启动地址\nvar appAddress = ""\n\n// initAppCommand 初始化app命令和其子命令\nfunc initAppCommand() *cobra.Command {\n   // 设置启动地址\n   appStartCommand.Flags().StringVar(&amp;appAddress, "address", ":8888", "设置app启动的地址，默认为:8888")\n\n   appCommand.AddCommand(appStartCommand)\n   return appCommand\n}\n\n// appStartCommand 启动一个Web服务\nvar appStartCommand = &amp;cobra.Command{\n   Use:   "start",\n   Short: "启动一个Web服务",\n   RunE: func(c *cobra.Command, args []string) error {\n      ...\n      // 创建一个Server服务\n      server := &amp;http.Server{\n         Handler: core,\n         Addr:    appAddress,\n      }\n      // 这个goroutine是启动服务的goroutine\n      go func() {\n         server.ListenAndServe()\n      }()\n      ...\n   },\n}\n</code></pre><p>这样，后端进程就可以通过命令  <code>./hade app start --address=:8888</code> 这样的方式，来指定端口启动服务了。</p><p>小问题解决之后，回到framework/command/dev.go， 我们实现restartBackend方法。先杀死旧的进程，再通过命令  <code>./hade app start</code> 带上参数 address，启动新的后端服务。启动之后，再将启动的进程ID存储到proxy结构的backendPid字段中：</p><pre><code class="language-go">// restartBackend 启动后端服务\nfunc (p *Proxy) restartBackend() error {\n\n   // 杀死之前的进程\n   if p.backendPid != 0 {\n      syscall.Kill(p.backendPid, syscall.SIGKILL)\n      p.backendPid = 0\n   }\n\n   // 设置随机端口，真实后端的端口\n   port := p.devConfig.Backend.Port\n   hadeAddress := fmt.Sprintf(":" + port)\n   // 使用命令行启动后端进程\n   cmd := exec.Command("./hade", "app", "start", "--address="+hadeAddress)\n   cmd.Stdout = os.NewFile(0, os.DevNull)\n   cmd.Stderr = os.Stderr\n   fmt.Println("启动后端服务: ", "http://127.0.0.1:"+port)\n   err := cmd.Start()\n   if err != nil {\n      fmt.Println(err)\n   }\n   p.backendPid = cmd.Process.Pid\n   fmt.Println("后端服务pid:", p.backendPid)\n   return nil\n}\n</code></pre><h3>restartFrontend</h3><p>而重启前端服务的函数restartFrontend也是一样的逻辑，先关闭旧的前端进程，然后启动新的前端进程。这里同样也有一个问题，启动前端进程的命令是  <code>npm run dev</code> ，我们怎么固定其端口呢？</p><p>在Vue中，我们可以通过<a href="https://stackoverflow.com/questions/47219819/how-to-change-port-number-in-vue-cli-project">设置环境变量PORT</a>，来规定前端进程的启动端口。也就是让启动命令变为  <code>PORT=8071 npm run dev</code> ，在Golang中启动一个命令，并为命令设置环境变量是这样设置的：</p><pre><code class="language-go">// 运行命令\ncmd := exec.Command("npm", "run", "dev")\n// 为默认的环境变量增加PORT=xxx的变量\ncmd.Env = os.Environ()\ncmd.Env = append(cmd.Env, fmt.Sprintf("%s%s", "PORT=", port))\n</code></pre><p>所以启动前端服务的逻辑就如下，很简单，重点位置你可以看注释。</p><pre><code class="language-go">// 启动前端服务\nfunc (p *Proxy) restartFrontend() error {\n   // 启动前端调试模式\n   // 先杀死旧进程\n   if p.frontendPid != 0 {\n      syscall.Kill(p.frontendPid, syscall.SIGKILL)\n      p.frontendPid = 0\n   }\n   // 否则开启npm run serve\n   port := p.devConfig.Frontend.Port\n   path, err := exec.LookPath("npm")\n   if err != nil {\n      return err\n   }\n   cmd := exec.Command(path, "run", "dev")\n   cmd.Env = os.Environ()\n   cmd.Env = append(cmd.Env, fmt.Sprintf("%s%s", "PORT=", port))\n   cmd.Stdout = os.NewFile(0, os.DevNull)\n   cmd.Stderr = os.Stderr\n   // 因为npm run serve 是控制台挂起模式，所以这里使用go routine启动\n   err = cmd.Start()\n   fmt.Println("启动前端服务: ", "http://127.0.0.1:"+port)\n   if err != nil {\n      fmt.Println(err)\n   }\n   p.frontendPid = cmd.Process.Pid\n   fmt.Println("前端服务pid:", p.frontendPid)\n   return nil\n}\n</code></pre><h3>startProxy</h3><p>下面我们来实现startProxy方法，它有两个参数，表示在启动Proxy时是否要启动前端、后端服务。</p><p>这个方法的逻辑也并不复杂，步骤有四步，先根据参数判断是否启动后端服务，根据参数判断是否启动前端服务，然后使用newProxyReverseProxy来创建新的ReverseProxy，最后启动Proxy服务。在代码中也做了步骤说明了：</p><pre><code class="language-go">// 启动proxy服务，并且根据参数启动前端服务或者后端服务\nfunc (p *Proxy) startProxy(startFrontend, startBackend bool) error {\n   var backendURL, frontendURL *url.URL\n   var err error\n\n   // 启动后端\n   if startBackend {\n      if err := p.restartBackend(); err != nil {\n         return err\n      }\n   }\n   // 启动前端\n   if startFrontend {\n      if err := p.restartFrontend(); err != nil {\n         return err\n      }\n   }\n\n   if frontendURL, err = url.Parse(fmt.Sprintf("%s%s", "http://127.0.0.1:", p.devConfig.Frontend.Port)); err != nil {\n      return err\n   }\n\n   if backendURL, err = url.Parse(fmt.Sprintf("%s%s", "http://127.0.0.1:", p.devConfig.Backend.Port)); err != nil {\n      return err\n   }\n\n   // 设置反向代理\n   proxyReverse := p.newProxyReverseProxy(frontendURL, backendURL)\n   proxyServer := &amp;http.Server{\n      Addr:    "127.0.0.1:" + p.devConfig.Port,\n      Handler: proxyReverse,\n   }\n\n   fmt.Println("代理服务启动:", "http://"+proxyServer.Addr)\n   // 启动proxy服务\n   err = proxyServer.ListenAndServe()\n   if err != nil {\n      fmt.Println(err)\n   }\n   return nil\n}\n</code></pre><h3>monitorBackend</h3><p>最后是一个monitorBackend方法，监控某个文件夹的变动，并且重新编译并且运行后端服务。</p><p>这个方法我们重点说一下，有些逻辑还是比较绕的。</p><p>首先，在前一节课说过了，可以使用 <a href="https://github.com/fsnotify/fsnotify">fsnotify</a> 库对目录进行监控。那么对哪个目录进行监控呢？之前在配置devConfig中，定义了一个Backend.MonitorFolder目录，这个配置默认使用的是AppFolder目录。这个就是我们监控的目标目录。</p><p>其次，每次有变化的时候，都要进行一次编译后端服务、杀死旧进程、重启新进程么？</p><p>在开发过程中我们知道，每次调整一个逻辑的时候，是有可能短时间内重复修改、保存多个文件的，或者保存一个文件多次。而重新编译、重新启动进程的过程，又是有一定耗时的，如果每改一次就重来一次，可以想象这个体验是很差的。</p><p>能怎么优化这种体验呢？我们可以使用一种计时时间机制。</p><p>这个机制的逻辑就是，<strong>每次有文件变动，并不立刻进行实质的操作，而是开启一个计时时间</strong>，如果这个时间内，没有任何后续的文件变动了，那么在计时时间到了之后，我们再进行实质的操作。而如果在计时时间内，有任何更新的文件变动，我们就将计时时间机制重新开始计时。</p><p>这种机制能有一定概率保证，在“更新代码等待一段时间后”进行后端的重启服务。而这里的计时时间我们也变成一个配置，devConfig里面的Backend.RefreshTime，默认时长为1s。</p><p>对应在framework/command/dev.go的monitorBackend代码实现中，我们大致分为这么几步，<strong>先创建watcher，监听目标目录，有变动的时候开启计时时间机制，循环监听</strong>：</p><ul>\n<li>目标目录变更事件，有事件更新计时机制；</li>\n<li>计时机制到点事件，计时到点事件触发，代表有一个或多个目标目录变更已经存在，更新后端服务。</li>\n</ul><p>这里在监听目标目录的时候，我们需要监听AppFolder目录下的所有子目录及孙目录，所以这里需要用到递归 filepath.Walk ，来递归一遍所有子目录及孙目录。如果是目录，就使用watcher.Add 来将目录加入到监控列表中。</p><p>具体的代码逻辑可以看framework/command/dev.go中的monitorBackend：</p><pre><code class="language-go">// monitorBackend 监听应用文件\nfunc (p *Proxy) monitorBackend() error {\n   // 监听\n   watcher, err := fsnotify.NewWatcher()\n   if err != nil {\n      return err\n   }\n   defer watcher.Close()\n\n   // 开启监听目标文件夹\n   appFolder := p.devConfig.Backend.MonitorFolder\n   fmt.Println("监控文件夹：", appFolder)\n   // 监听所有子目录，需要使用filepath.walk\n   filepath.Walk(appFolder, func(path string, info os.FileInfo, err error) error {\n      if info != nil &amp;&amp; !info.IsDir() {\n         return nil\n      }\n      // 如果是隐藏的目录比如 . 或者 .. 则不用进行监控\n      if util.IsHiddenDirectory(path) {\n         return nil\n      }\n      return watcher.Add(path)\n   })\n\n   // 开启计时时间机制\n   refreshTime := p.devConfig.Backend.RefreshTime\n   t := time.NewTimer(time.Duration(refreshTime) * time.Second)\n   // 先停止计时器\n   t.Stop()\n   for {\n      select {\n      case &lt;-t.C:\n         // 计时器时间到了，代表之前有文件更新事件重置过计时器\n         // 即有文件更新\n         fmt.Println("...检测到文件更新，重启服务开始...")\n         if err := p.rebuildBackend(); err != nil {\n            fmt.Println("重新编译失败：", err.Error())\n         } else {\n            if err := p.restartBackend(); err != nil {\n               fmt.Println("重新启动失败：", err.Error())\n            }\n         }\n         fmt.Println("...检测到文件更新，重启服务结束...")\n         // 停止计时器\n         t.Stop()\n      case _, ok := &lt;-watcher.Events:\n         if !ok {\n            continue\n         }\n         // 有文件更新事件，重置计时器\n         t.Reset(time.Duration(refreshTime) * time.Second)\n      case err, ok := &lt;-watcher.Errors:\n         if !ok {\n            continue\n         }\n         // 如果有文件监听错误，则停止计时器\n         fmt.Println("监听文件夹错误：", err.Error())\n         t.Reset(time.Duration(refreshTime) * time.Second)\n      }\n   }\n}\n</code></pre><h2>验证</h2><p>到这里Proxy相关的逻辑和调试对应的命令行工具都开发完成了，下面我们来做一下对应的验证，一共三次验证，单独的前端、后端修改，以及同时对前后端的修改。</p><p>先修改一下config/development/app.yaml，增加对应的调试模式配置：</p><pre><code class="language-yaml">dev: # 调试模式\n  port: 8070 # 调试模式最终监听的端口，默认为8070\n  backend: # 后端调试模式配置\n    refresh_time: 3  # 调试模式后端更新时间，如果文件变更，等待3s才进行一次更新，能让频繁保存变更更为顺畅, 默认1s\n    port: 8072 # 后端监听端口，默认8072\n    monitor_folder: "" # 监听文件夹地址，为空或者不填默认为AppFolder\n  frontend: # 前端调试模式配置\n    port: 8071 # 前端监听端口, 默认8071\n</code></pre><p>这里设置refresh_time为3s，代表后续后端变更后3s后会触发重新编译。对我们的代码进行一次编译，不用go build了，可以使用自定义的build命令了。<br>\n<img src="https://static001.geekbang.org/resource/image/bc/dc/bccyy36fb507fc398b4ac69d6fab12dc.png?wh=744x53" alt=""></p><h3>前端验证</h3><p>首先验证前端调试模式。调用命令 <code>./hade dev front</code>，可以看到如下的控制台信息：<br>\n<img src="https://static001.geekbang.org/resource/image/69/3f/6932b5eacdd96f46bd7c431388a5663f.png?wh=1837x388" alt=""></p><p>先是出现几行信息：</p><pre><code class="language-go">启动前端服务:&nbsp; http://127.0.0.1:8071\n前端服务pid: 13750\n代理服务启动: http://127.0.0.1:8070\n</code></pre><p>然后进入到了Vue的调试模式，从上述信息我们知道，代理服务启动在8070端口，使用浏览器打开 <a href="http://127.0.0.1:8070">http://127.0.0.1:8070</a> 看到了熟悉的Vue界面。<br>\n<img src="https://static001.geekbang.org/resource/image/51/cd/51bbd33f01b482fe38543e09fcf6a8cd.png?wh=821x675" alt=""></p><p>然后修改首页的前端组件，业务目录下src/components/HelloWorld.vue，将其展示在首页的msg内容：</p><pre><code class="language-javascript">&lt;script&gt;\nexport default {\n  name: \'HelloWorld\',\n  data() {\n    return {\n      msg: \'Welcome to Your Vue.js App \'\n    }\n  }\n}\n&lt;/script&gt;\n</code></pre><p>修改为：</p><pre><code class="language-javascript">&lt;script&gt;\nexport default {\n    name: \'HelloWorld\',\n    data() {\n        return {\n            msg: \'Welcome to Hade Vue.js App \'\n        }\n    }\n}\n&lt;/script&gt;\n</code></pre><p>现在你可以看到，前端自动更新：<br>\n<img src="https://static001.geekbang.org/resource/image/54/3b/54b76e64904e2c38b011e0625317cf3b.png?wh=823x700" alt=""><br>\n前端验证完成。下面验证后端调试模式。</p><h3>后端验证</h3><p>我们已经在业务代码app/http/module/demo/api.go中，定义了/demo/demo的路由，并且简单输出文字"this is demo"。</p><pre><code class="language-go">func Register(r *gin.Engine) error {\n   api := NewDemoApi()\n   ...\n   r.GET("/demo/demo", api.Demo)\n   ...\n   return nil\n}\n\nfunc (api *DemoApi) Demo(c *gin.Context) {\n   c.JSON(200, "this is demo")\n}\n</code></pre><p>使用命令  <code>./hade dev backend</code> ，有如下输出，可以看到输出中已经把监控文件夹、后端服务端口、代理服务端口完整输出了：<br>\n<img src="https://static001.geekbang.org/resource/image/a1/71/a140ce0ef5yya414bb7c51879966a871.png?wh=756x126" alt=""></p><p>访问代理服务 <a href="http://127.0.0.1:8087/demo/demo">http://127.0.0.1:8087/demo/demo</a>：<br>\n<img src="https://static001.geekbang.org/resource/image/9c/35/9cfabbc9617ea7d382ef7a7656bbyy35.png?wh=819x223" alt=""></p><p>输出了后端接口内容。</p><p>同时在代码中修改下输出内容之后：</p><pre><code class="language-go">func (api *DemoApi) Demo(c *gin.Context) {\n   c.JSON(200, "this is demo for dev")\n}\n</code></pre><p>在控制台中我们可以看到，等待了3s后（这里配置文件设置为3s），在控制台看到如下输出：<br>\n<img src="https://static001.geekbang.org/resource/image/a9/77/a9f482cf449bdd63ab10b9589552f677.png?wh=766x251" alt=""></p><p>检测到文件更新，重启服务开启。</p><p>这个时候我们再刷新浏览器的接口，输出已经变化了。<br>\n<img src="https://static001.geekbang.org/resource/image/8d/cd/8d2e45d4e396cda0772855466c864bcd.png?wh=826x257" alt=""><br>\n后端调试模式通过！</p><h3>前后端验证</h3><p>最后同时验证前端和后端，其实和前面单独验证的方法一样，只是启动命令换成了  <code>./hade dev all</code></p><p>这里我们同时打开两个窗口，<a href="http://127.0.0.1:8070/demo/demo">http://127.0.0.1:8070/demo/demo</a>、<a href="http://127.0.0.1:8070/#/">http://127.0.0.1:8070/#/</a>，能同时看到前端和后端信息：<br>\n<img src="https://static001.geekbang.org/resource/image/94/8b/948ca235cb9aaafafdfd019ec49c6e8b.png?wh=822x648" alt=""><img src="https://static001.geekbang.org/resource/image/24/a5/244a3f45c561081d2836da782c9d3ba5.png?wh=824x258" alt=""></p><p>修改前端msg和修改后端内容后，变更生效：<br>\n<img src="https://static001.geekbang.org/resource/image/b8/4b/b8322b3854a955ddab449324afb8574b.png?wh=822x686" alt=""><img src="https://static001.geekbang.org/resource/image/3e/8a/3eba5c41cdafd870878609274f05658a.png?wh=825x204" alt=""><br>\n到这里，前后端同时调试模式验证成功！</p><p>今天的主要内容是创建调试模式的三个二级命令。完整的代码示例在GitHub上的 <a href="https://github.com/gohade/coredemo/tree/geekbang/20">geekbang/20</a> 分支，欢迎比对查看。本节课我们只在命令文件中增加了一个framework/command/dev.go文件：<br>\n<img src="https://static001.geekbang.org/resource/image/e7/y3/e7yy0d64af957beed7139733ac2fdyy3.png?wh=296x811" alt=""></p><h2>小结</h2><p>今天我们具体实现了调试模式，其实了解了上节课对调试模式的设计之后，今天的内容主要是细节上的代码实现了，就是工作量。不过其中的实现细节，也是在工作中不断积累下来的，你可以多多体会。</p><p>比如refresh_time这个计时器窗口设计，在最初版本是没有的，在实际工作中，使用这个调试模式，遇到了频繁重建的困扰，才做了这个设计。总之，整个调试模式支持是非常赞的，它能让我们的Web开发效率提高了一个档次，希望你也能感同身受。</p><h2>思考题</h2><p>在回答同学们问题的时候，我发现有不少是其他语言转来Go的，不知道你的经历是怎样的，可以来聊一聊你在使用其他语言时，调试一个程序都是怎么调试的呢？有没有比较好的调试模式？</p><p>欢迎在留言区分享你的思考。感谢你的收听，我们下节课见～</p>',
        article_title: "20｜提效（下）：实现调试模式加速开发效率",
      },
      {
        title: "21｜自动化（上）：DRY，如何自动化一切重复性劳动？",
        id: 435518,
        content:
          '<p>你好，我是轩脉刃。</p><p>不知道你有没有听过这种说法，优秀程序员应该有三大美德：懒惰、急躁和傲慢，这句话是Perl语言的发明者Larry Wall说的。其中懒惰这一点指的就是，程序员为了懒惰，不重复做同样的事情，会思考是否能把一切重复性的劳动自动化（don’t repeat yourself）。</p><p>而框架开发到这里，我们也需要思考，有哪些重复性劳动可以自动化么？</p><p>从第十章到现在我们一直在说，框架核心是服务提供者，在开发具体应用时，一定会有很多需求要创建各种各样的服务，毕竟“一切皆服务”；而每次创建服务的时候，我们都需要至少编写三个文件，服务接口、服务提供者、服务实例。<strong>如果能自动生成三个文件，提供一个“自动化创建服务的工具”，应该能节省不少的操作</strong>。</p><p>说到创建工具，我们经常需要为了一个事情而创建一个命令行工具，而每次创建命令行工具，也都需要创建固定的Command.go文件，其中有固定的Command结构，这些代码我们能不能偷个懒，“<strong>自动化创建命令行工具</strong>”呢？</p><p>另外之前我们做过几次中间件的迁移，先将源码拷贝复制，再修改对应的Gin路径，这个操作也是颇为繁琐的。那么，我们是否可以写一个“<strong>自动化中间件迁移工具</strong>”，一个命令自动复制和替换呢？</p><!-- [[[read_end]]] --><p>这些命令都是可以实现的，这节课我们就来尝试完成这三项自动化，“自动化创建服务工具”， “自动化创建命令行工具”，以及“自动化中间件迁移工具”。</p><h2>自动化创建服务工具</h2><p>在创建各种各样的服务时，“自动化创建服务工具”能帮我们节省不少开发时间。我们先思考下这个工具应该如何实现。</p><p>既然之前已经引入cobra，将框架修改为可以支持命令行工具，创建命令并不是一个难事，我们来定义一套创建服务的provider 命令即可。照旧先设计好要创建的命令，再一一实现。</p><h3>命令创建</h3><p>“自动化创建服务工具”如何设计命令层级呢？我们设计一个一级命令和两个二级命令：</p><ul>\n<li><code>./hade provider</code> 一级命令，provider，打印帮助信息；</li>\n<li><code>./hade provider new</code> 二级命令，创建一个服务；</li>\n<li><code>./hade provider list</code> 二级命令，列出容器内的所有服务，列出它们的字符串凭证。</li>\n</ul><p>首先将provider的这两个二级命令，都存放在command/provider.go中。而对应的一级命令 providerCommand 是一个打印帮助信息的空实现。</p><pre><code class="language-go">// providerCommand 一级命令\nvar providerCommand = &amp;cobra.Command{\n   Use:   "provider",\n   Short: "服务提供相关命令",\n   RunE: func(c *cobra.Command, args []string) error {\n      if len(args) == 0 {\n         c.Help()\n      }\n      return nil\n   },\n}\n</code></pre><p>预先将两个二级命令挂载到这个一级命令中，在 framework/command/provider.go：</p><pre><code class="language-go">// 初始化provider相关服务\nfunc initProviderCommand() *cobra.Command {\n   providerCommand.AddCommand(providerCreateCommand)\n   providerCommand.AddCommand(providerListCommand)\n   return providerCommand\n}\n</code></pre><p>并且在 framework/command/kernel.go，将这个一级命令挂载到一级命令rootCommand中：</p><pre><code class="language-go">func AddKernelCommands(root *cobra.Command) {\n   // provider一级命令\n   root.AddCommand(initProviderCommand()\n}\n</code></pre><p>下面来实现这两个二级命令new和list。</p><h3>List命令的实现</h3><p>先说  <code>./hade provider list</code> 这个命令，因为列出容器内的所有服务是比较简单的。还记得吗，在十一章实现服务容器的时候，其中有一个providers，它存储所有的服务容器提供者，放在文件 framework/container.go 中：</p><pre><code class="language-go">// HadeContainer 是服务容器的具体实现\ntype HadeContainer struct {\n\t...\n\t// providers 存储注册的服务提供者，key 为字符串凭证\n\tproviders map[string]ServiceProvider\n    ...\n}\n</code></pre><p>我们只需要将这个providers进行遍历，根据其中每个ServiceProvider的Name() 方法，获取字符串凭证列表即可。</p><p>所以，在framework/container.go 的HadeContainer中，增加一个NameList方法，返回所有提供服务者的字符串凭证，方法也很简单，直接遍历这个providers 字段。</p><pre><code class="language-go">// NameList 列出容器中所有服务提供者的字符串凭证\nfunc (hade *HadeContainer) NameList() []string {\n   ret := []string{}\n   for _, provider := range hade.providers {\n      name := provider.Name()\n      ret = append(ret, name)\n   }\n   return ret\n}\n</code></pre><p>而在 framework/command/provider.go 中的providerListCommand 命令中，我们调用这个命令并且打印出来。</p><pre><code class="language-go">// providerListCommand 列出容器内的所有服务\nvar providerListCommand = &amp;cobra.Command{\n   Use:   "list",\n   Short: "列出容器内的所有服务",\n   RunE: func(c *cobra.Command, args []string) error {\n      container := c.GetContainer()\n      hadeContainer := container.(*framework.HadeContainer)\n      // 获取字符串凭证\n      list := hadeContainer.NameList()\n      // 打印\n      for _, line := range list {\n         println(line)\n      }\n      return nil\n   },\n}\n</code></pre><p>可以验证一下。编译  <code>./hade build self</code> 并且执行 <code>./hade provider list</code> ，可以看到如下信息：<br>\n<img src="https://static001.geekbang.org/resource/image/0c/35/0c4d1fb73cd17aabc02fe7c3b5f2f335.png?wh=481x215" alt=""></p><p>你可以很清晰看到容器中绑定了哪些服务提供者，它们的字符串凭证是什么。这样我们在定义一个新的服务的时候，可以很方便看到哪些服务提供者的关键字已经被使用了，避免使用已有的服务关键字。</p><p>下面我们来说稍微复杂一点的创建服务的命令  <code>./hade provider new</code> 。</p><h3>new命令的实现</h3><p>在实际业务开发过程中，我们一想到一个服务，比如去某个用户系统获取信息，一定会想到创建服务的三步骤：创建一个用户系统的交互协议contract.go、再创建一个提供协议的用户服务提供者 provider.go、最后才实现具体的用户服务实例 service.go。</p><p>每次都需要创建这三个文件，且这三个文件的文件大框架都有套路可言。那我们如何将这些重复的套路性的代码自动化生成呢？</p><p>首先这里有一个增加参数的过程，我们需要知道要创建服务的服务名是什么？创建这个服务的文件夹名字是什么？当然了，这些参数也可以使用在命令后面增加flag参数的方式来表示。但是其实还有一种更便捷的方式：交互。</p><p>交互的表现形式如：</p><pre><code class="language-go">输入：./hade provider new (我想创建一个服务)\n输出：请输入服务名称(服务凭证):\n输入：demo\n输出：请求输入服务目录名称(默认和服务名称相同)：\n输入：demo\n输出：创建服务成功, 文件夹地址：xxxxx\n输出：请不要忘记挂载新创建的服务\n</code></pre><p>这种命令行交互的方式是不是更智能化？但是如何实现呢？</p><p>这里我们借助一个第三方库 <a href="https://github.com/AlecAivazis/survey">survey</a>。这个库目前在GitHub上已经有2.7k个star，最新版本是v2版本，使用的是MIT License协议，可以放心使用。这个survey库支持多种交互模式：单行输入、多行输入、单选、多选、y/n 确认选择，在<a href="https://github.com/AlecAivazis/survey">项目GitHub首页</a>上就能很清晰看到这个库的使用方式。</p><pre><code class="language-go">name := false\n// 使用survey.XXX 的方式来选择交互形式\nprompt := &amp;survey.Confirm{\n    Message: "Do you like pie?",\n}\n// 使用&amp;将最终的选择存储进入变量\nsurvey.AskOne(prompt, &amp;name)\n</code></pre><p>在provider new命令中，我们也可以用survey 来增加交互性。通过交互，我们可以确认用户想创建的服务凭证，以及想把这个服务创建在 app/provider/ 下的哪个目录中。</p><p>当然，<strong>在用户通过交互输入了服务凭证和服务目录之后，是需要进行参数判断的</strong>。服务凭证需要和容器中已注册服务的字符串凭证进行比较，如果已经存在了，应该报错；而服务目录如果已经存在，也应该直接报错。</p><p>如果都验证ok了，最后一步就是在 app/provider/ 下创建对应的服务目录，在目录下创建contract.go、provider.go、service.go 三个文件，并且在三个文件中根据预先定义好的模版填充内容。这里我们如何实现呢？使用模版、变更模版中的某些字段、形成新的文本，这个你应该能联想到 Golang 标准库中的 <a href="https://pkg.go.dev/text/template">text/template</a> 库。</p><p>这个库的使用方法比较多，我这里把我们用得到的方法解说一下，解析contract.go文件的生成过程，就可以了解其使用方法了。</p><pre><code class="language-go">// 创建title这个模版方法\nfuncs := template.FuncMap{"title": strings.Title}\n{\n   //  创建contract.go\n   file := filepath.Join(pFolder, folder, "contract.go")\n   f, err := os.Create(file)\n   if err != nil {\n      return errors.Cause(err)\n   }\n   // 使用contractTmp模版来初始化template，并且让这个模版支持title方法，即支持{{.|title}}\n   t := template.Must(template.New("contract").Funcs(funcs).Parse(contractTmp))\n   // 将name传递进入到template中渲染，并且输出到contract.go 中\n   if err := t.Execute(f, name); err != nil {\n      return errors.Cause(err)\n   }\n}\n</code></pre><p>上面代码的逻辑最核心的就是创建模版的template.Must 和渲染模版的t.Execute方法。</p><p>但是在创建模版之前，我们使用了一个<strong>template.FuncMap方法，它比较不好理解，主要作用就是在模版中，让我们可以使用定义的模版方法来控制渲染效果</strong>。这个FuncMap结构定义了模版中支持的模版方法，比如我支持title这个方法，这个方法实际调用的是string.Title 函数，把字符串首字母大写。</p><p>在刚才的代码中，我们使用contractTmp来创建模版，在渲染contractTmp的时候，传递了一个name变量。假设这个name变量代表的是字符串user，而我希望创建一个字符串“NameKey”的变量，可以这么定义contractTmp：</p><pre><code class="language-go">var contractTmp string = `package {{.}}\n\nconst {{.|title}}Key = "{{.}}"\n\ntype Service interface {\n   // 请在这里定义你的方法\n    Foo() string\n}\n`\n</code></pre><p>注意到了么，其中的{{.|title}} 实际上是相当于调用了strings.Title(name) 的方法填充，能将字符串name替换为字符串Name。</p><p>而定义好了FuncMap之后，我们随后使用了os.Create创建contract.go文件，然后初始化template：</p><pre><code class="language-plain">t := template.Must(template.New("contract").Funcs(funcs).Parse(contractTmp))\n</code></pre><p>这行代码的几个函数我们来看看。</p><p><strong>template.Must 表示后面的template创建必须成功，否则会panic</strong>。这种Must的方法来简化代码的error处理逻辑，在标准库中经常使用。我们的hade框架的MustMake也是同样的原理。</p><p>template.New() 方法，创建一个text/template 的 Template结构，其中的参数contract字符串是为这个Template结构命名的，后面的Funcs() 方法是将签名定义的模版函数注册到这个Template结构中，最后的Parse()是使用这个Template结构解析具体的模版文本。</p><p>定义好了模版t之后，使用代码：</p><pre><code class="language-go">t.Execute(f, name)\n</code></pre><p>来将变量name 注册进入模版t，并且输出到f。这里的f，是我们之前创建的contract.go文件。也就是使用变量name解析模版t，输出到contract.go文件中。</p><p>这里的变量可以是一个struct结构，也可以是基础变量，比如我们这里定义的字符串。在模版中{{.}} 就代表这个结构。所以再回顾前面定义的contractTmp模版，你会看出其中变量name为字符串user的时候，最终的显示是什么吗？</p><p>好，创建服务命令的所有思路我们就梳理清楚了，最后也贴出完整的代码供你参考，关键步骤都在注释中详细说明了，实现并不难：</p><pre><code class="language-go">// providerCreateCommand 创建一个新的服务，包括服务提供者，服务接口协议，服务实例\nvar providerCreateCommand = &amp;cobra.Command{\n   Use:     "new",\n   Aliases: []string{"create", "init"},\n   Short:   "创建一个服务",\n   RunE: func(c *cobra.Command, args []string) error {\n      container := c.GetContainer()\n      fmt.Println("创建一个服务")\n      var name string\n      var folder string\n      {\n         prompt := &amp;survey.Input{\n            Message: "请输入服务名称(服务凭证)：",\n         }\n         err := survey.AskOne(prompt, &amp;name)\n         if err != nil {\n            return err\n         }\n      }\n      {\n         prompt := &amp;survey.Input{\n            Message: "请输入服务所在目录名称(默认: 同服务名称):",\n         }\n         err := survey.AskOne(prompt, &amp;folder)\n         if err != nil {\n            return err\n         }\n      }\n      // 检查服务是否存在\n      providers := container.(*framework.HadeContainer).NameList()\n      providerColl := collection.NewStrCollection(providers)\n      if providerColl.Contains(name) {\n         fmt.Println("服务名称已经存在")\n         return nil\n      }\n      if folder == "" {\n         folder = name\n      }\n      app := container.MustMake(contract.AppKey).(contract.App)\n      pFolder := app.ProviderFolder()\n      subFolders, err := util.SubDir(pFolder)\n      if err != nil {\n         return err\n      }\n      subColl := collection.NewStrCollection(subFolders)\n      if subColl.Contains(folder) {\n         fmt.Println("目录名称已经存在")\n         return nil\n      }\n      // 开始创建文件\n      if err := os.Mkdir(filepath.Join(pFolder, folder), 0700); err != nil {\n         return err\n      }\n      // 创建title这个模版方法\n      funcs := template.FuncMap{"title": strings.Title}\n      {\n         //  创建contract.go\n         file := filepath.Join(pFolder, folder, "contract.go")\n         f, err := os.Create(file)\n         if err != nil {\n            return errors.Cause(err)\n         }\n         // 使用contractTmp模版来初始化template，并且让这个模版支持title方法，即支持{{.|title}}\n         t := template.Must(template.New("contract").Funcs(funcs).Parse(contractTmp))\n         // 将name传递进入到template中渲染，并且输出到contract.go 中\n         if err := t.Execute(f, name); err != nil {\n            return errors.Cause(err)\n         }\n      }\n      {\n         // 创建provider.go\n         file := filepath.Join(pFolder, folder, "provider.go")\n         f, err := os.Create(file)\n         if err != nil {\n            return err\n         }\n         t := template.Must(template.New("provider").Funcs(funcs).Parse(providerTmp))\n         if err := t.Execute(f, name); err != nil {\n            return err\n         }\n      }\n      {\n         //  创建service.go\n         file := filepath.Join(pFolder, folder, "service.go")\n         f, err := os.Create(file)\n         if err != nil {\n            return err\n         }\n         t := template.Must(template.New("service").Funcs(funcs).Parse(serviceTmp))\n         if err := t.Execute(f, name); err != nil {\n            return err\n         }\n      }\n      fmt.Println("创建服务成功, 文件夹地址:", filepath.Join(pFolder, folder))\n      fmt.Println("请不要忘记挂载新创建的服务")\n      return nil\n   },\n}\nvar contractTmp string = `package {{.}}\nconst {{.|title}}Key = "{{.}}"\ntype Service interface {\n   // 请在这里定义你的方法\n    Foo() string\n}\n`\nvar providerTmp string = `package {{.}}\nimport (\n   "github.com/gohade/hade/framework"\n)\ntype {{.|title}}Provider struct {\n   framework.ServiceProvider\n   c framework.Container\n}\nfunc (sp *{{.|title}}Provider) Name() string {\n   return {{.|title}}Key\n}\nfunc (sp *{{.|title}}Provider) Register(c framework.Container) framework.NewInstance {\n   return New{{.|title}}Service\n}\nfunc (sp *{{.|title}}Provider) IsDefer() bool {\n   return false\n}\nfunc (sp *{{.|title}}Provider) Params(c framework.Container) []interface{} {\n   return []interface{}{c}\n}\nfunc (sp *{{.|title}}Provider) Boot(c framework.Container) error {\n   return nil\n}\n`\nvar serviceTmp string = `package {{.}}\nimport "github.com/gohade/hade/framework"\ntype {{.|title}}Service struct {\n   container framework.Container\n}\nfunc New{{.|title}}Service(params ...interface{}) (interface{}, error) {\n   container := params[0].(framework.Container)\n   return &amp;{{.|title}}Service{container: container}, nil\n}\nfunc (s *{{.|title}}Service) Foo() string {\n    return ""\n}\n`\n\n</code></pre><p>最后我们验证一下这个创建服务命令。同样编译./hade 命令之后，执行 <code>./hade provider new</code> , 定义服务凭证为user，目录名称同样为user。<br>\n<img src="https://static001.geekbang.org/resource/image/b7/3c/b7ae3ba7edee1ce7a216e891d1b8e23c.png?wh=620x193" alt=""></p><p>能看到 app/provider/ 目录下创建了user文件夹，其中有contract.go、provider.go、service.go三个文件：<br>\n<img src="https://static001.geekbang.org/resource/image/46/e6/46900bb2ea53135b890763687f4cc0e6.png?wh=376x276" alt=""></p><p>其中每个文件的定义都完整，且可以直接再次编译通过，验证完成！</p><h2>自动化创建命令行工具</h2><p>到这里我们就完成了创建服务工具的自动化。开头提到具体运营一个应用的时候，我们也会经常需要创建一个自定义的命令行。比如运营一个网站，可能会创建一个命令来统计网站注册人数，也可能要创建一个命令来定期检查是否有违禁的文章需要封禁等。所以自动创建命令行工具在实际工作中是非常有必要的。</p><p>同服务命令一样，我们可以有一套创建命令行工具的命令。</p><ul>\n<li><code>./hade command</code> 一级命令，显示帮助信息</li>\n<li><code>./hade command list</code> 二级命令，列出所有控制台命令</li>\n<li><code>./hade command new</code> 二级命令，创建一个控制台命令</li>\n</ul><p>command相关的命令和provider的命令的实现基本是一致的。这里我们简要解说下重点，具体对应的代码详情可以参考GitHub上的<a href="https://github.com/gohade/coredemo/blob/geekbang/21/framework/command/cmd.go">framework/command/cmd.go</a> 文件。</p><p>一级命令./hade command 我们就不说了，是简单地显示帮助信息。</p><p>二级命令 ./hade command list。功能是列出所有的控制台命令。这个功能实际上和直接调用 ./hade 显示的帮助信息差不多，把一级根命令全部列了出来，只不过我们使用了一个更为语义化的 ./hade command list 来显示。<br>\n<img src="https://static001.geekbang.org/resource/image/85/9e/85fd992ca12552e3d5fef51994b1079e.png?wh=946x722" alt=""></p><p>它的实现也并不复杂，具体就是使用Root().Commands() 方法遍历一级跟命令的所有一级命令。</p><pre><code class="language-go">// cmdListCommand 列出所有的控制台命令\nvar cmdListCommand = &amp;cobra.Command{\n   Use:   "list",\n   Short: "列出所有控制台命令",\n   RunE: func(c *cobra.Command, args []string) error {\n      cmds := c.Root().Commands()\n      ps := [][]string{}\n      for _, cmd := range cmds {\n         line := []string{cmd.Name(), cmd.Short}\n         ps = append(ps, line)\n      }\n      util.PrettyPrint(ps)\n      return nil\n   },\n}\n</code></pre><p>二级命令 ./hade command new创建命令行工具，就是在app/console/command/ 文件夹下增加一个目录，然后在这个目录中存放命令的相关代码。</p><p>比如要创建一个foo命令，就是要在app/console/command/ 目录下创建一个foo目录，其中创建一个foo.go 文件名，这个文件名可以随意起，这里我们就和目录名保持一致。然后在 app/console/command/foo.go 文件中输入模版：</p><pre><code class="language-go">// 命令行工具模版\nvar cmdTmpl string = `package {{.}}\n\nimport (\n   "fmt"\n\n   "github.com/gohade/hade/framework/cobra"\n)\n\nvar {{.|title}}Command = &amp;cobra.Command{\n   Use:   "{{.}}",\n   Short: "{{.}}",\n   RunE: func(c *cobra.Command, args []string) error {\n        container := c.GetContainer()\n      fmt.Println(container)\n      return nil\n   },\n}\n</code></pre><p>实现步骤也很简单：survery 交互先要求用户输入命令名称；然后要求用户输入文件夹名称，记得检查命令名称和文件夹名称是否合理；之后创建文件夹 app/console/command/xxx 和文件 app/console/command/xxx/xxx.go；最后使用template将模版写入文件中。</p><h2>自动化中间件迁移工具</h2><p>除了服务工具和命令行工具的创建，对于中间件，我们在开发过程中也是经常会使用创建的，同样的，可以为中间件定义一系列的命令来自动化。</p><ul>\n<li><code>./hade middleware</code> 一级命令，显示帮助信息</li>\n<li><code>./hade middleware list</code> 二级命令，列出所有的业务中间件</li>\n<li><code>./hade middleware new</code> 二级命令，创建一个新的业务中间件</li>\n<li><code>./hade middleware migrate</code> 二级命令，迁移Gin已有的中间件</li>\n</ul><p>其中的前面三个命令基本上和provider、command 命令如出一辙，我们就不赘述了，同样你可以通过GitHub 上的<a href="https://github.com/gohade/coredemo/blob/geekbang/21/framework/command/middleware.go">framework/command/middleware.go 文件</a>参考其具体实现，相信你可以顺利写出来。</p><p>这里重点说一下  <code>./hade middleware migrate</code> 命令。</p><p>不知道你有没有好奇，为什么迁移也要写一个命令？当时在将Gin迁移进入hade框架的时候我们说，Gin作为一个成熟的开源作品，有丰富的中间件库，存放GitHub的一个项目 <a href="https://github.com/gin-contrib/">gin-contrib</a> 中。那么在开发过程中，我们一定会经常需要使用到这些中间件。</p><p>但是由于这些中间件使用到的Gin框架的地址为 ：</p><pre><code class="language-plain">github.com/gin-gonic/gin\n</code></pre><p>而我们的Gin框架地址为：</p><pre><code class="language-plain">github.com/gohade/hade/framework/gin\n</code></pre><p>所以我们不能使用import直接使用这些中间件，那么有没有一个办法，能直接一键迁移gin-contrib下的某个中间件呢？比如  <code>git@github.com:gin-contrib/cors.git</code> ，直接拷贝并且自动修改好Gin框架引用地址，放到我们的 app/http/middleware/ 目录中。</p><p>于是就有了这个  <code>./hade middleware migragte</code> 命令。下面就梳理一下这个命令的逻辑步骤。以下载cors中间件为例，我们的思路是从GitHub上将这个<a href="https://github.com/gin-contrib/cors">cors项目</a>复制下来，<strong>并且删除这个项目的一些不必要的文件</strong>。</p><p>什么是不必要的文件呢？.git目录、go.mod、go.sum，这些都是作为一个“项目”才会需要的，而我们要把项目中的这些删掉，让它成为一个文件，存放在我们的app/http/middleware/cors目录下。最后再遍历这个目录的所有文件，将所有出现“github.com/gin-gonic/gin” 的地方替换为“github.com/gohade/hade/framework/gin”就可以了。</p><p>从git上复制一个项目，在Golang中可以使用一个第三方库 <a href="https://github.com/go-git/go-git">go-git</a>，这个第三方库已经有2.7k 个star，且基于Apache 的Licence，是可以直接import使用的。目前这个库最新的版本为v5。</p><p>它的使用方式如下：</p><pre><code class="language-go">_, err := git.PlainClone("/tmp/foo", false, &amp;git.CloneOptions{\n    URL:      "https://github.com/go-git/go-git",\n    Progress: os.Stdout,\n})\n</code></pre><p>将某个Git的URL地址使用gitclone，下载到/tmp/foo目录，并且把输出也输出到控制台。</p><p>我们也可以使用这样的方式进行复制。具体的代码逻辑也不难，归纳一下，migrate的实现步骤如下：</p><ol>\n<li>参数中获取中间件名称；</li>\n<li>使用go-git，将对应的gin-contrib的项目clone到目录/app/http/middleware；</li>\n<li>删除不必要的文件go.mod、go.sum、.git；</li>\n<li>替换关键字 “github.com/gin-gonic/gin”。</li>\n</ol><p>在framework/command/middleware.go中，对应的代码如下：</p><pre><code class="language-go">// 从gin-contrib中迁移中间件\nvar middlewareMigrateCommand = &amp;cobra.Command{\n   Use:   "migrate",\n   Short: "迁移gin-contrib中间件, 迁移地址：https://github.com/gin-contrib/[middleware].git",\n   RunE: func(c *cobra.Command, args []string) error {\n      container := c.GetContainer()\n      fmt.Println("迁移一个Gin中间件")\n      // step1: 获取参数\n      var repo string\n      {\n         prompt := &amp;survey.Input{\n            Message: "请输入中间件名称：",\n         }\n         err := survey.AskOne(prompt, &amp;repo)\n         if err != nil {\n            return err\n         }\n      }\n      // step2 : 下载git到一个目录中\n      appService := container.MustMake(contract.AppKey).(contract.App)\n\n      middlewarePath := appService.MiddlewareFolder()\n      url := "https://github.com/gin-contrib/" + repo + ".git"\n      fmt.Println("下载中间件 gin-contrib:")\n      fmt.Println(url)\n      _, err := git.PlainClone(path.Join(middlewarePath, repo), false, &amp;git.CloneOptions{\n         URL:      url,\n         Progress: os.Stdout,\n      })\n      if err != nil {\n         return err\n      }\n\n      // step3:删除不必要的文件 go.mod, go.sum, .git\n      repoFolder := path.Join(middlewarePath, repo)\n      fmt.Println("remove " + path.Join(repoFolder, "go.mod"))\n      os.Remove(path.Join(repoFolder, "go.mod"))\n      fmt.Println("remove " + path.Join(repoFolder, "go.sum"))\n      os.Remove(path.Join(repoFolder, "go.sum"))\n      fmt.Println("remove " + path.Join(repoFolder, ".git"))\n      os.RemoveAll(path.Join(repoFolder, ".git"))\n\n      // step4 : 替换关键词\n      filepath.Walk(repoFolder, func(path string, info os.FileInfo, err error) error {\n         if info.IsDir() {\n            return nil\n         }\n\n         if filepath.Ext(path) != ".go" {\n            return nil\n         }\n\n         c, err := ioutil.ReadFile(path)\n         if err != nil {\n            return err\n         }\n         isContain := bytes.Contains(c, []byte("github.com/gin-gonic/gin"))\n         if isContain {\n            fmt.Println("更新文件:" + path)\n            c = bytes.ReplaceAll(c, []byte("github.com/gin-gonic/gin"), []byte("github.com/gohade/hade/framework/gin"))\n            err = ioutil.WriteFile(path, c, 0644)\n            if err != nil {\n               return err\n            }\n         }\n\n         return nil\n      })\n      return nil\n   },\n}\n</code></pre><p>我们可以下载cors项目做一下验证，运行 <code>./hade middleware migrate</code> 命令，并且输入cors。你会在控制台看到这些信息：<br>\n<img src="https://static001.geekbang.org/resource/image/6f/5f/6fd8197207c92b3b362a89cc4676015f.png?wh=682x384" alt=""></p><p>并且在目录中看到cors中间件已经完整下载下来了。<br>\n<img src="https://static001.geekbang.org/resource/image/70/09/709dbbc8c2140byy56459c202aa66909.png?wh=343x610" alt=""></p><p>然后，可以直接在app/http/route.go中直接使用这个cors中间件：</p><pre><code class="language-go">...\n\n// Routes 绑定业务层路由\nfunc Routes(r *gin.Engine) {\n   ...\n   // 使用cors中间件\n   r.Use(cors.Default())\n   ...\n }\n</code></pre><p>验证完成！</p><p>今天所有代码都保存在GitHub上的<a href="https://github.com/gohade/coredemo/tree/geekbang/21">geekbang/21</a>分支了。附上目录结构供你对比查看，只修改了framework/command/目录下的cmd.go、provider.go、middleware.go文件。<br>\n<img src="https://static001.geekbang.org/resource/image/78/89/7889877151dc4d4e306554a64c550c89.png?wh=476x936" alt=""></p><h2>小结</h2><p>今天增加的命令不少，自动化创建服务工具、命令行工具，以及中间件迁移工具，这些命令都为我们后续开发应用提供了不少便利。</p><p>其实每个自动化命令行工具实现的思路都是差不多的，先思考清楚对于这个工具我们要自动化生成什么，然后使用代码和对应的模版生成对应的文件，并且替换其中特有的单词。原理不复杂，但是对于实际的工作，是非常有帮助的。</p><p>这一节课你应该可以感受到之前将cobra引入我们的框架是一个多么正确的决定，在cobra之上，我们才能实现这些方便的自动化工具。</p><h3>思考题</h3><p>我们实现的自动化服务./hade command list命令，目前只展示了一级命令，在写这篇文章的时候我反思了一下，其实可以扩展成为树形结构展示，同时展示一级/二级/三级/命令。你可以想想如何实现，如果可以的话，可以去github.com/gohade/hade 项目中提交一个merge request 来补充这个功能吧！</p><p>欢迎在留言区分享你的思考。我们下节课见。</p>',
        article_title: "21｜自动化（上）：DRY，如何自动化一切重复性劳动？",
      },
      {
        title: "22｜自动化（下）：DRY，如何自动化一切重复性劳动？",
        id: 435534,
        content:
          '<p>你好，我是轩脉刃。</p><p>上一节课我们增加了自动化创建服务工具、命令行工具，以及中间件迁移工具。你会发现，这些工具实现起来并不复杂，但是在实际工作中却非常有用。今天我们继续思考还能做点什么。</p><p>我们的框架是定义了业务的目录结构的，每次创建一个新的应用，都需要将AppService中定义的目录结构创建好，如果这个行为能自动化，实现<strong>一个命令就能创建一个定义好所有目录结构，甚至有demo示例的新应用</strong>呢？是不是有点心动，这就是我们今天要实现的工具了，听起来功能有点庞大，所以我们还是慢慢来，先设计再实现。</p><h2>初始化脚手架设计</h2><p>这个功能倒不是什么新想法，有用过Vue的同学就知道，Vue官网有介绍一个 <code>vue create</code> <a href="https://cli.vuejs.org/zh/guide/creating-a-project.html">命令</a>，可以从零开始创建一个包含基本Vue结构的目录，这个目录可以直接编译运行。</p><p>在初始化一个Vue项目的时候，大多数刚接触Vue的同学对框架的若干文件还不熟悉，很容易建立错误vue的目录结构，而这个工具能帮Vue新手们有效规避这种错误。</p><p>同理，我们的框架也有基本的hade结构的目录，初学者在创建hade应用的时候，也大概率容易建立错误目录。所以参考这一点，让自己的框架也有这么一个命令，能直接创建一个新的包含hade框架业务脚手架目录的命令。这样，能很大程度方便使用者就在这个脚手架目录上不断开发，完成所需的业务功能。</p><!-- [[[read_end]]] --><p>我们要设计的命令是一个一级命令<code>./hade new</code> 。一般来说，新建命令创建一个脚手架，要做的事情就是：</p><ul>\n<li>确定目标目录，如果没有就创建目录</li>\n<li>创建业务模块目录</li>\n<li>初始化go module 模块，补充模块名称、框架版本号</li>\n<li>在业务模块目录中创建对应的文件代码</li>\n</ul><p>我们跟着这个思路走。先梳理一下在这个命令中，要传入的参数有哪些？</p><p>首先是目录，在控制台目录之下要创建一个子目录，这个<strong>子目录的名称，是需要用户传递进入的</strong>。不过，这个参数记得做一下验证，如果子目录已经存在了，给用户一个提示，是直接删除原先的子目录？还是停止操作？如果用户需要删除原先的子目录，我们就直接删除。</p><p>其次是<strong>需要用户传入新应用的模块名称</strong>，也就是go.mod中的module后面的名称，一般会设置为应用的项目地址，比如github.com/jianfengye/testdemo。关于模块名称，我们要详细做一下解说。</p><h3>业务、框架模块地址</h3><p>一直到这一节课的GitHub地址，不知道你有没有疑惑，别的框架，比如Gin、Echo，都是把框架代码放在GitHub上，比如github/gin-gonic/gin，而业务代码是单独存放的。但我们这个项目github.com/gohade/coredemo，却是把业务代码和框架代码都放在一个项目中？</p><p>其实是这样，这个项目github.com/gohade/coredemo，是我为geekbang这个课程单独设置的项目，将hade框架的每个实现步骤，重新在这个项目做了一次还原。而 github.com/gohade/hade 才是我们最终的项目地址。所以不管在 coredemo 这个项目还是 hade这个项目，go.mod 中的module 都是叫做 github.com/gohade/hade。</p><p><strong>但是即使是最终的github.com/gohade/hade项目，我们的业务代码app目录和框架目录 framework目录也是在一个项目里的</strong>，按道理说在这个hade项目中，应该只有framework目录的内容即可啊？<br>\n<img src="https://static001.geekbang.org/resource/image/15/54/15d2de9d05e7f68dc072708945beaa54.png?wh=400x562" alt=""></p><p>这里我是这么设计的，将framework目录和其他的业务目录都同时放在github.com/gohade/hade项目中，这样这个项目也同时就是我们hade框架的一个示例项目。只是这个项目带着framework目录而已。</p><p>后续如果要创建一个新的业务项目，比如github.com/jianfengye/testdemo。我们<strong>不是做加法把业务文件夹一点点复制过来，而是做依赖这个github.com/gohade/hade项目做减法</strong>，把不必要的文件夹（比如框架文件夹）删掉。</p><p>即我们只需要直接拷贝这个github.com/gohade/hade 项目，并且将其中的framework目录删除，保留业务目录，同时把go.mod中的原先的“github.com/gohade/hade”模块名修改为github.com/jianfengye/testdemo这个模块名，用到hade框架的部分直接引用“github.com/gohade/hade/framework” 即可。</p><p>这就是说，如果你要创建的项目的模块名为github.com/jianfengye/testdemo，go.mod应该如下：</p><pre><code class="language-go">// 这里是你的模块地址\nmodule github.com/jianfengye/testdemo\n\ngo 1.15\n\nrequire (\n   // 这里引用github.com/gohade/hade\n   github.com/gohade/hade v0.0.2\n   ...\n\n)\n</code></pre><p>目录应该和github.com/gohade/hade 只有一处不同：没有framework目录。<br>\n<img src="https://static001.geekbang.org/resource/image/d4/63/d4208f4ea094ba3404da935a1bf21263.png?wh=254x414" alt=""></p><p>而在你自己的github.com/jianfengye/testdemo 项目中的所有文件，如果是框架中的，也就是要使用hade已有的服务提供者、中间件、命令行的时候，是使用<code>import github.com/gohade/hade/framework</code>；而在使用自己的服务提供者、中间件、命令行，所有在业务目录内的结构的时候，是使用 <code>import github.com/jianfengye/testdemo/xxx</code>。</p><p>比如main.go 就形如：</p><pre><code class="language-go">package main\n\nimport (\n    // 业务的目录app内的文件\n   "github.com/jianfengye/testdemo/app/console"\n   "github.com/jianfengye/testdemo/app/http"\n   // 框架目录的文件\n   "github.com/gohade/hade/framework"\n   "github.com/gohade/hade/framework/provider/app"\n   "github.com/gohade/hade/framework/provider/config"\n   "github.com/gohade/hade/framework/provider/distributed"\n   "github.com/gohade/hade/framework/provider/env"\n   "github.com/gohade/hade/framework/provider/id"\n   "github.com/gohade/hade/framework/provider/kernel"\n   "github.com/gohade/hade/framework/provider/log"\n   "github.com/gohade/hade/framework/provider/trace"\n)\n\nfunc main() {\n   // 初始化服务容器\n   container := framework.NewHadeContainer()\n   // 绑定App服务提供者\n   container.Bind(&amp;app.HadeAppProvider{})\n   // 后续初始化需要绑定的服务提供者...\n   container.Bind(&amp;env.HadeEnvProvider{})\n   container.Bind(&amp;distributed.LocalDistributedProvider{})\n   container.Bind(&amp;config.HadeConfigProvider{})\n   container.Bind(&amp;id.HadeIDProvider{})\n   container.Bind(&amp;trace.HadeTraceProvider{})\n   container.Bind(&amp;log.HadeLogServiceProvider{})\n\n   // 将HTTP引擎初始化,并且作为服务提供者绑定到服务容器中\n   if engine, err := http.NewHttpEngine(); err == nil {\n      container.Bind(&amp;kernel.HadeKernelProvider{HttpEngine: engine})\n   }\n\n   // 运行root命令\n   console.RunCommand(container)\n}\n</code></pre><p>说到这里相信你应该理解了，最终我们这个框架只维护 github.com/gohade/hade 这么一个项目，<strong>这个项目中的framework目录，存放的是框架所有的代码，而framework之外的目录和文件都是示例代码</strong>。</p><p>所以，回到今天的主题，让 <code>./hade new</code> 命令创建一个脚手架，要做的事情现在就变成了：</p><ul>\n<li>下载github.com/gohade/hade项目到目标文件夹</li>\n<li>删除framework目录</li>\n<li>修改go.mod中的模块名称</li>\n<li>修改go.mod中的require信息，增加require github.com/gohade/hade</li>\n<li>修改所有文件使用业务目录的地方，将原本使用“github.com/gohade/hade/app”  的所有引用改成 “[模块名称]/app”</li>\n</ul><p>也就是说第二个输入，我们需要用户确切输入一个模块名称。</p><h3>框架的版本号信息</h3><p>除了新建时必须的子目录的名称和新建模块的名称，第三个需要用户输入的是hade的版本号。</p><p>我们的hade框架是会不断变化的，和Golang语言一样，使用形如v1.2.3这样的版本号进行迭代，v代表版本的英文缩写，1代表的是大版本，只有非常大变更的时候我们才会更新这个版本；2代表的是小版本，有接口变更或者类库变更之类的时候我们会迭代这个版本；3代表的是补丁版本，如果发现有需要补丁修复的地方，就会使用这个版本。</p><p>而每个hade框架版本对应的脚手架，也有可能有一定变化的。因为在脚手架中，我们会把框架的使用示例等放在应用代码中。</p><p>hade框架的每个版本发布时，都会打对应的tag，每个tag我们都会在GitHub上发布一个release版本与之对应，比如截止到10/7日，已经发布了v0.0.1和v0.0.2两个tag和release版本，你可以直接通过<a href="https://github.com/gohade/hade/releases">GitHub地址</a>来进行查看。<br>\n<img src="https://static001.geekbang.org/resource/image/ba/a4/ba9e3152dbc9469327a820d1cac205a4.png?wh=1323x331" alt=""><img src="https://static001.geekbang.org/resource/image/a7/dc/a77a6affec75c2051df984fcff89fbdc.png?wh=1284x886" alt=""></p><p>所以回到 <code>./hade new</code> 命令，第三个需要用户输入的就是这个版本号，如果用户需要创建一个v0.0.1版本的hade脚手架，则需要输入v0.0.1，如果用户没有输入，我们默认使用最新的版本。</p><p>好了，简单总结一下，用户目前输入的三个信息：</p><ul>\n<li>目录名，最终是“当前执行目录+目录名”</li>\n<li>模块名，最终创建应用的module</li>\n<li>版本号，对应的hade的release版本号</li>\n</ul><p>用户输入相关的代码如下，在我们的 framework/command/new.go中：</p><pre><code class="language-go">     var name string\n      var folder string\n      var mod string\n      var version string\n      var release *github.RepositoryRelease\n      {\n         prompt := &amp;survey.Input{\n            Message: "请输入目录名称：",\n         }\n         err := survey.AskOne(prompt, &amp;name)\n         if err != nil {\n            return err\n         }\n\n         folder = filepath.Join(currentPath, name)\n         if util.Exists(folder) {\n            isForce := false\n            prompt2 := &amp;survey.Confirm{\n               Message: "目录" + folder + "已经存在,是否删除重新创建？(确认后立刻执行删除操作！)",\n               Default: false,\n            }\n            err := survey.AskOne(prompt2, &amp;isForce)\n            if err != nil {\n               return err\n            }\n\n            if isForce {\n               if err := os.RemoveAll(folder); err != nil {\n                  return err\n               }\n            } else {\n               fmt.Println("目录已存在，创建应用失败")\n               return nil\n            }\n         }\n      }\n      {\n         prompt := &amp;survey.Input{\n            Message: "请输入模块名称(go.mod中的module, 默认为文件夹名称)：",\n         }\n         err := survey.AskOne(prompt, &amp;mod)\n         if err != nil {\n            return err\n         }\n         if mod == "" {\n            mod = name\n         }\n      }\n      {\n         // 获取hade的版本\n         client := github.NewClient(nil)\n         prompt := &amp;survey.Input{\n            Message: "请输入版本名称(参考 https://github.com/gohade/hade/releases，默认为最新版本)：",\n         }\n         err := survey.AskOne(prompt, &amp;version)\n         if err != nil {\n            return err\n         }\n         if version != "" {\n            // 确认版本是否正确\n            release, _, err = client.Repositories.GetReleaseByTag(context.Background(), "gohade", "hade", version)\n            if err != nil || release == nil {\n               fmt.Println("版本不存在，创建应用失败，请参考 https://github.com/gohade/hade/releases")\n               return nil\n            }\n         }\n         if version == "" {\n            release, _, err = client.Repositories.GetLatestRelease(context.Background(), "gohade", "hade")\n            version = release.GetTagName()\n         }\n      }\n</code></pre><h2>初始化脚手架具体实现</h2><p>有了这三个信息，我们将之前讨论的 hade new 命令的步骤再详细展开讨论：</p><ul>\n<li>下载github.com/gohade/hade项目到目标文件夹</li>\n<li>删除framework目录</li>\n<li>修改go.mod中的模块名称</li>\n<li>修改go.mod中的require信息，增加require github.com/gohade/hade</li>\n<li>修改所有文件使用业务目录的地方，将原本使用“github.com/gohade/hade/app”  的所有引用改成 “[模块名称]/app”</li>\n</ul><p>第一步下载稍微复杂一点，我们重点说，剩下四步就是简单的按部就班了。</p><h3>项目下载</h3><p>因为有版本号更新的可能，其中的第一步“复制github.com/gohade/hade项目到目标文件夹” ，我们就要变化为“下载github.com/gohade/hade 的某个release版本到目标文件夹”。</p><p>这个能怎么做呢？可以想到GitHub有提供对外的开放平台接口 api.github.com，你可以看它的<a href="https://docs.github.com/cn/rest/reference/repos">官方文档地址</a>。</p><p>我们可以通过开放平台接口，对公共的GitHub仓库进行信息查询。比如要查看某个GitHub仓库的release分支，可以通过调用“<a href="https://docs.github.com/cn/rest/reference/repos#list-releases">/repos/{owner}/{repo}/releases</a>”，而获取某个GitHub仓库的最新release分支，可以通过调用“<a href="https://docs.github.com/cn/rest/reference/repos#get-the-latest-release">/repos/{owner}/{repo}/releases/latest</a>”。</p><p>使用GitHub的开放平台接口，是可以直接调用，但是这个方法有个明显的问题，我们还要手动封装这个接口调用。</p><p>其实更简单的方式是，使用Google给我们提供好的Golang语言的SDK，<a href="https://github.com/google/go-github">go-github</a>。这个库本质就是封装了GitHub的调用接口。比如获取仓库github.com/gohade/hade的release分支：</p><pre><code class="language-go">client := github.NewClient(nil)\nreleases, _, err = client.Repositories.GetReleases(context.Background(), "gohade", "hade")\n</code></pre><p>而获取它最新release分支也很简单：</p><pre><code class="language-go">client := github.NewClient(nil)\nrelease, _, err = client.Repositories.GetLatestRelease(context.Background(), "gohade", "hade")\n</code></pre><p>在返回的RepositoryRelease结构中，我们可以找到下载这个release版本的各种信息。其中包括release版本对应的版本号信息和zip下载地址：</p><pre><code class="language-go">// RepositoryRelease represents a GitHub release in a repository.\ntype RepositoryRelease struct {\n   // 对应的版本号信息\n   TagName                *string `json:"tag_name,omitempty"`\n   ...\n   // release版本的zip下载地址\n   ZipballURL  *string         `json:"zipball_url,omitempty"`\n   \n   ...\n}\n</code></pre><p>库信息了解到这里，我们回到刚才要执行的第一步“下载github.com/gohade/hade 的某个release版本到目标文件夹”，就可以使用这个zip下载地址，下载对应的zip包，并且使用unzip解压这个zip目录。</p><p>对于下载zip包，直接使用http.Get就能下载了。这个函数我们封装在framework/util/file.go中：</p><pre><code class="language-go">// DownloadFile 下载url中的内容保存到本地的filepath中\nfunc DownloadFile(filepath string, url string) error {\n\n   // 获取\n   resp, err := http.Get(url)\n   if err != nil {\n      return err\n   }\n   defer resp.Body.Close()\n\n   // 创建目标文件\n   out, err := os.Create(filepath)\n   if err != nil {\n      return err\n   }\n   defer out.Close()\n\n   // 拷贝内容\n   _, err = io.Copy(out, resp.Body)\n   return err\n}\n</code></pre><p>而unzip解压，我们可以使用Golang标准库的 archive/zip，来读取zip包中的内容，然后将每个文件都复制到目标目录中。unzip的基本逻辑就是使用zip包读取压缩文件，然后遍历压缩文件中的文件夹，将对应的文件和文件夹都复制到目标目录中。</p><p>具体代码存放在framework/util/zip.go中，代码中也做了对应注释：</p><pre><code class="language-go">// Unzip 解压缩zip文件，复制文件和目录都到目标目录中\nfunc Unzip(src string, dest string) ([]string, error) {\n\n   var filenames []string\n\n   // 使用archive/zip读取\n   r, err := zip.OpenReader(src)\n   if err != nil {\n      return filenames, err\n   }\n   defer r.Close()\n\n   // 所有内部文件都读取\n   for _, f := range r.File {\n\n      // 目标路径\n      fpath := filepath.Join(dest, f.Name)\n\n      if !strings.HasPrefix(fpath, filepath.Clean(dest)+string(os.PathSeparator)) {\n         return filenames, fmt.Errorf("%s: illegal file path", fpath)\n      }\n\n      filenames = append(filenames, fpath)\n\n      if f.FileInfo().IsDir() {\n         // 如果是目录，则创建目录\n         os.MkdirAll(fpath, os.ModePerm)\n         continue\n      }\n\n      //否则创建文件\n      if err = os.MkdirAll(filepath.Dir(fpath), os.ModePerm); err != nil {\n         return filenames, err\n      }\n\n      outFile, err := os.OpenFile(fpath, os.O_WRONLY|os.O_CREATE|os.O_TRUNC, f.Mode())\n      if err != nil {\n         return filenames, err\n      }\n\n      rc, err := f.Open()\n      if err != nil {\n         return filenames, err\n      }\n      \n      // 复制内容\n      _, err = io.Copy(outFile, rc)\n\n      \n      outFile.Close()\n      rc.Close()\n\n      if err != nil {\n         return filenames, err\n      }\n   }\n   return filenames, nil\n}\n</code></pre><p>但是你在调试的过程中就会发现，下载的zip包中带有一层目录，gohade-hade-xxxx，目录下面才是我们需要的hade库的真实代码。如果直接复制zip包，就会在目标文件夹下创建gohade-hade-xxx目录，但是这个目录层级并不是我们想要的。</p><p>所以这里要修改“下载github.com/gohade/hade 的某个release版本到目标文件夹”的实现步骤，大致思路就是<strong>通过创建和删除一个临时目录，来达到把zip包解压的目的</strong>。</p><p>具体操作就是，先创建临时目录 template-hade-version-[timestamp]，然后下载release的zip包地址临时目录，并命名为template.zip，在临时目录中解压zip包 template.zip，生成gohade-hade-xxxx目录。这个时候就完成了一半，拿到了需要的hade库真实代码。</p><p>之后，查找临时目录中名为 gohade-hade-开头的目录，定位到gohade-hade-xxx目录，将这个目录使用os.rename 移动成为目标文件夹。最后收尾删除临时目录。</p><p>对应代码在framework/command/new.go中：</p><pre><code class="language-go">    templateFolder := filepath.Join(currentPath, "template-hade-"+version+"-"+cast.ToString(time.Now().Unix()))\n      os.Mkdir(templateFolder, os.ModePerm)\n      fmt.Println("创建临时目录", templateFolder)\n\n      // 拷贝template项目\n      url := release.GetZipballURL()\n      err := util.DownloadFile(filepath.Join(templateFolder, "template.zip"), url)\n      if err != nil {\n         return err\n      }\n      fmt.Println("下载zip包到template.zip")\n\n      _, err = util.Unzip(filepath.Join(templateFolder, "template.zip"), templateFolder)\n      if err != nil {\n         return err\n      }\n\n      // 获取folder下的gohade-hade-xxx相关解压目录\n      fInfos, err := ioutil.ReadDir(templateFolder)\n      if err != nil {\n         return err\n      }\n      for _, fInfo := range fInfos {\n         // 找到解压后的文件夹\n         if fInfo.IsDir() &amp;&amp; strings.Contains(fInfo.Name(), "gohade-hade-") {\n            if err := os.Rename(filepath.Join(templateFolder, fInfo.Name()), folder); err != nil {\n               return err\n            }\n         }\n      }\n      fmt.Println("解压zip包")\n\n      if err := os.RemoveAll(templateFolder); err != nil {\n         return err\n      }\n      fmt.Println("删除临时文件夹", templateFolder)\n</code></pre><p>第一步的源码复制完成之后，就是后面很简单的四步了，我直接把顺序写在注释中了，你可以对照代码看，同样在framework/command/new.go中：</p><pre><code class="language-go">os.RemoveAll(path.Join(folder, ".git"))\n      fmt.Println("删除.git目录")\n\n      // 删除framework 目录\n      os.RemoveAll(path.Join(folder, "framework"))\n      fmt.Println("删除framework目录")\n\n      filepath.Walk(folder, func(path string, info os.FileInfo, err error) error {\n         if info.IsDir() {\n            return nil\n         }\n\n         c, err := ioutil.ReadFile(path)\n         if err != nil {\n            return err\n         }\n         // 修改go.mod中的模块名称、修改go.mod中的require信息\n         // 增加require github.com/gohade/hade\n         if path == filepath.Join(folder, "go.mod") {\n            fmt.Println("更新文件:" + path)\n            c = bytes.ReplaceAll(c, []byte("module github.com/gohade/hade"), []byte("module "+mod))\n            c = bytes.ReplaceAll(c, []byte("require ("), []byte("require (\\n\\tgithub.com/gohade/hade "+version))\n            err = ioutil.WriteFile(path, c, 0644)\n            if err != nil {\n               return err\n            }\n            return nil\n         }\n         // 最后修改所有文件使用业务目录的地方，\n         // 将原本使用“github.com/gohade/hade/app” 的所有引用\n         // 改成 “[模块名称]/app”\n         isContain := bytes.Contains(c, []byte("github.com/gohade/hade/app"))\n         if isContain {\n            fmt.Println("更新文件:" + path)\n            c = bytes.ReplaceAll(c, []byte("github.com/gohade/hade/app"), []byte(mod+"/app"))\n            err = ioutil.WriteFile(path, c, 0644)\n            if err != nil {\n               return err\n            }\n         }\n\n         return nil\n      })\n      fmt.Println("创建应用结束")\n      fmt.Println("目录：", folder)\n      fmt.Println("====================================================")\n      return nil\n</code></pre><h3>验证</h3><p>最后我们验证下。使用 <code>./hade new</code> 创建一个目录名称为testdemo、模块名为 github.com/jianfengye/testdemo、版本为最新版本v0.0.2的脚手架。<br>\n<img src="https://static001.geekbang.org/resource/image/82/c5/8211f96faf4ff3a4b86e2213b0678ec5.png?wh=691x574" alt=""></p><p>进入testdemo目录，执行 <code>go build</code> 命令可直接编译，并且生成了可运行的二进制文件。<br>\n<img src="https://static001.geekbang.org/resource/image/44/ff/446ac21ea8f351989778fa83437be2ff.png?wh=1025x646" alt=""></p><p>自动化初始化脚手架命令完成！</p><p>今天所有代码都保存在GitHub上的<a href="https://github.com/gohade/coredemo/tree/geekbang/22">geekbang/22</a>分支了。附上目录结构供你对比查看，只修改了framework/command/目录下的new.go代码。<br>\n<img src="https://static001.geekbang.org/resource/image/f4/95/f4e3c5e4f359b3a005854e9451b32395.png?wh=392x996" alt=""></p><h2>小结</h2><p>今天我们增加了一个新的命令，自动化初始化脚手架的命令设计，让hade框架也可以像Vue框架一样，直接使用一个二进制命令 <code>./hade new</code> 创建一个脚手架。我们把框架和脚手架示例代码同时放在github.com/gohade/hade仓库中，实现了框架和脚手架示例代码版本的关联。</p><p>在创建脚手架的时候，我们是<strong>基于这个仓库的某个tag版本做减法</strong>，而不是费劲地做加法来进行创建。</p><p>同时在每次更新框架的时候，我们也会自然而然更新这个示例代码，<strong>框架和示例代码永远是一一对应的，而下载的时候会保留这种一一对应的关系</strong>。这种设计让hade版本的框架设计更为方便了。</p><p>这两节课的四个工具的自动化，是我们目前能想到的比较常用的“重复性”劳动了。当然随着框架使用的深入，还可能有更多的自动化需求，但是基本上都和这几个自动化命令是同样的套路，所以掌握这两节课的内容和方法，你已经可以自行简化这些“重复性”劳动了。</p><h2>思考题</h2><p>这节课的代码比较多，希望你能仔细对比GitHub上的代码。经过这两节课的练习，你可以思考一下，作为一个“懒惰”的程序员，在hade框架中，我们还有哪些工作还可以自动化么？</p><p>欢迎在留言区分享你的思考。如果你觉得有收获，也欢迎把今天的内容分享给身边的朋友，邀他一起学习。我们下节课见。</p>',
        article_title: "22｜自动化（下）：DRY，如何自动化一切重复性劳动？",
      },
      {
        title: "23｜管理接口：如何集成swagger自动生成文件？",
        id: 435582,
        content:
          '<p>你好，我是轩脉刃。</p><p>不管你是前端页面开发，还是后端服务开发，你一定经历过前后端联调的场景，前后端联调最痛苦的事情，莫过于没有完善的接口文档、没有可以调用调试的接口返回值了，所以一般都会采用形如Postman这样的第三方工具，来进行接口的调用和联调。</p><p>但是这一节课，我们要做的事情，就是为自己的Web应用集成swagger，使用swagger自动生成一个可以查看接口、可以调用执行的页面。</p><h3>swagger</h3><p>说到swagger，可能有的同学还比较陌生，我来简要介绍一下。swagger框架在2009年启动，之前是Reverb公司内部开发的一个项目，他们的工程师在与第三方调试REST接口的过程中，为了解决大量的接口与文档问题，就设计了swagger这个项目。</p><p>项目最终成型的方案是，先设计一个JSON规则，开发工程师把所有服务接口按照这种规则来写成一个JSON文件，<strong>这个JSON文件可以直接生成一个交互式UI，可以提供调用者查看、调用调试</strong>。</p><p>swagger的应用是非常广泛的。非常多的开源项目在提供对外接口的时候都使用swagger来进行描述。比如目前最火的Kubernetes项目，每次在发布版本的时候，都会在项目根目录上，带上符合swagger规则的<a href="https://github.com/kubernetes/kubernetes/blob/master/api/openapi-spec/swagger.json">JSON文件</a>，用来向使用者提供内部接口。</p><!-- [[[read_end]]] --><p>swagger的产品有两类。</p><p>一个是前面说的JSON规则，就是OpenAPI的文档，它说明了我们要写一个接口说明文档的每个字段含义和要求。</p><p>OpenAPI的规则也是有版本的，目前最新版本是3.0，但是3.0版本目前市场上相应的配套支持还不成熟，比如Golang版本的SDK库<a href="https://github.com/go-openapi/spec">spec</a>还不支持。目前市面上对OpenAPI2.0的支持还是最全的。所以我们的hade框架就使用swagger2.0版本。</p><p>swagger的另外一类产品是工具，包括swagger-ui、swagger-editor和swagger-codegen。</p><p><a href="https://editor.swagger.io/">swagger-editor</a>提供一个开源网站，在线编辑swagger文件。<a href="https://swagger.io/tools/swagger-codegen/download/">swagger-codegen</a>提供一个Java命令行工具，通过swagger文件生成client端代码。而<a href="https://petstore.swagger.io/">swagger-ui</a>，通过提供一个开源网站，将swagger接口在线展示出来，并且可以让调用者查看、调试。我们的目标是生成一个可以查看接口，进行调用调试的页面，所以要将swagger-ui集成进hade框架。</p><h3>命令设计</h3><p>了解了swagger，结合框架，我们照例先思考下希望如何使用它。</p><p>按照swagger的定义，我们应该在业务项目中维护一个JSON文件，这个文件描述了这个业务的所有接口。但是你想过没有，<strong>随着项目的接口数越来越大，维护swagger的JSON描述文档本身，就是一个很大很繁杂的工作量</strong>。</p><p>由于每个接口在代码开发的时候，我们都会有注释，而更新代码的时候，我们是会去更新注释的。所以能不能有一个方法，通过代码的注释，自动生成这个JSON文件呢？</p><p>好，这个就是我们希望定义的一个swagger命令，<code>./hade swagger gen</code> ，能通过注释生成swagger.json文件。</p><p>但是考虑具体的实现设计，怎么用Golang的代码，注释生成swagger.json呢？既然swagger.json是有一定的规则的，那么注释的写法也是有一定规则的吧？是的。目前有一个最流行的将Golang注释转化为swagger.json 的开源项目<a href="https://github.com/swaggo/swag">swag</a>。</p><h3>swag项目</h3><p>这个swag项目是MIT 协议，目前已经有4.9k 个star了。它的用法和我们想要的一样，生成swagger.json分三步：</p><ul>\n<li>在API接口中编写注释。注释的详细写法需要参考<a href="https://github.com/swaggo/swag#declarative-comments-format">说明文档</a>。</li>\n<li>下载swag工具或者安装swag库</li>\n<li>使用工具或者库将指定代码生成swagger.json</li>\n</ul><p>步骤很简单，不过第一步怎么写swag的注释说明文档，是使用这个技术必须要学习的一个知识，这个的学习确实是有些门槛的，需要熟读对应的说明文档才能写出比较好的注释。这里我们用一个例子来讲解我在编写代码的时候常用的一些字段，供你参考。</p><pre><code class="language-go">// Demo2  for godoc\n// @Summary 获取所有学生\n// @Description 获取所有学生，不进行分页\n// @Produce  json\n// @Tags demo\n// @Success 200 {array} []UserDTO\n// @Router /demo/demo2 [get]\nfunc (api *DemoApi) Demo2(c *gin.Context) {\n   demoProvider := c.MustMake(demoService.DemoKey).(demoService.IService)\n   students := demoProvider.GetAllStudent()\n   usersDTO := StudentsToUserDTOs(students)\n   c.JSON(200, usersDTO)\n}\n\ntype UserDTO struct {\n   ID   int    `json:"id"`\n   Name string `json:"name"`\n}\n</code></pre><p>观察注释。第一行  <code>Demo2 for godoc</code> 这个在swagger中并没有实际作用，它是用来给godoc工具生成说明文档的。从第二行开始，就是我们swaggo的注释语法了，使用@符号加上关键字的方式来进行说明。<br>\n例子的关键字有这些：</p><ul>\n<li>Summary，为接口增加简要说明</li>\n<li>Description，为接口增加详细说明</li>\n<li>Produce，说明接口返回格式</li>\n<li>Tags，为接口打标签，可以为多个，便于查看者查找</li>\n<li>Success，接口返回成功时候的说明</li>\n<li>Router，接口的路由调用</li>\n</ul><p>具体对应的swagger-ui界面是这样的：<br>\n<img src="https://static001.geekbang.org/resource/image/94/ec/94c4a5c83dc771be6f8b60527e9951ec.png?wh=2872x1644" alt=""></p><p>我们对照注释和界面，很容易就看出每个注释的最终显示效果。不过这里再啰嗦解释下比较复杂的Success注释。</p><p>在这个例子中，是这样使用Success注释的：</p><pre><code class="language-go">// @Success 200 {array} UserDTO\n</code></pre><p>在成功的时候，返回UserDTO结构的数组，这里，swaggo会自动去项目中寻找UserDTO结构，来生成swagger-ui中的返回结构说明。</p><p>不过这里能这么写，是因为恰好UserDTO是和API放在同一个namespace下，如果你的返回结构放在不同的namespace下，需要在注释中注明返回结构的命名空间。比如：</p><pre><code class="language-go">// @Success 200 {array} model.Account\n</code></pre><p>同时，这个返回结构还支持返回对象嵌套，比如下面这个例子：</p><pre><code class="language-go">// 返回了一个JsonResult对象，其中这个对象的data字段是Order结构\n@success 200 {object} jsonresult.JSONResult{data=proto.Order} "desc"\n\ntype JSONResult struct {\n    Code    int          `json:"code" `\n    Message string       `json:"message"`\n    Data    interface{}  `json:"data"`\n}\n\ntype Order struct { //in `proto` package\n    Id  uint            `json:"id"`\n    Data  interface{}   `json:"data"`\n}\n</code></pre><p>它返回了一个JSONResult对象，这个JSONResult对象中的一个字段data是Order结构。</p><h3>命令实现</h3><p>现在注释已经标记好了，我们再回到生成JSON文件的命令 <code>./hade swagger gen</code> 。</p><p>这个命令通过swaggo准备好的命令行工具swag或者类库，来生成JSON文件。由于我们的框架已经集成了命令行工具，所以不会选择额外使用swag工具，而是在我们的命令中集成swaggo类库：<a href="https://github.com/swaggo/swag/tree/master/gen">swag/gen</a>。</p><p>这个类库最核心的结构就是<a href="https://github.com/swaggo/swag/blob/master/gen/gen.go">Config结构</a>。来看这个swagger gen命令的具体实现代码，写在framework/command/swagger.go中：</p><pre><code class="language-go">// swaggerGenCommand 生成具体的swagger文档\nvar swaggerGenCommand = &amp;cobra.Command{\n   Use:   "gen",\n   Short: "生成对应的swagger文件, contain swagger.yaml, doc.go",\n   Run: func(c *cobra.Command, args []string) {\n      container := c.GetContainer()\n      appService := container.MustMake(contract.AppKey).(contract.App)\n      outputDir := filepath.Join(appService.AppFolder(), "http", "swagger")\n      httpFolder := filepath.Join(appService.AppFolder(), "http")\n      conf := &amp;gen.Config{\n         // 遍历需要查询注释的目录\n         SearchDir: httpFolder,\n         // 不包含哪些文件\n         Excludes: "",\n         // 输出目录\n         OutputDir: outputDir,\n         // 整个swagger接口的说明文档注释\n         MainAPIFile: "swagger.go",\n         // 名字的显示策略，比如首字母大写等\n         PropNamingStrategy: "",\n         // 是否要解析vendor目录\n         ParseVendor: false,\n         // 是否要解析外部依赖库的包\n         ParseDependency: false,\n         // 是否要解析标准库的包\n         ParseInternal: false,\n         // 是否要查找markdown文件，这个markdown文件能用来为tag增加说明格式\n         MarkdownFilesDir: "",\n         // 是否应该在docs.go中生成时间戳\n         GeneratedTime: false,\n      }\n      err := gen.New().Build(conf)\n      if err != nil {\n         fmt.Println(err)\n      }\n   },\n}\n</code></pre><p>结合这个具体实现，我们来看这个Config结构的关键字段SearchDir、OutputDir和MainAPIFile，这几个字段的含义必须完全理解才能设置正确，其他的几个字段如果不理解，直接使用默认值就行。</p><p><strong>第一个 SearchDir 表示要swaggo去哪个目录遍历代码的注释，来生成swagger的JSON文件</strong>。对于我们的hade框架，所有接口文件都存放在app/http文件夹中，所以要遍历的就是这个文件夹了。</p><p>第二个关键字段 OutputDir，表示要输出的swagger文件的存放地址。我们在app/http目录下，创建一个swagger目录，来存放要输出的swagger文件。这里再补充一点，前面说swagger最终会生成JSON文件，但是你运行一次swagger gen 会发现，这个生成目录下除了有swagger.json这个文件，还有两个文件swagger.yaml 和 docs.go。</p><p>对于额外生成的这两个文件，swagger.yaml 是YAML格式的接口说明文档，里面的内容和swagger.json其实是一样的。<strong>而docs.go 是“接口说明文档”的代码，它是为go项目直接引入接口说明文档生成swagger-ui用的</strong>。</p><p>也就是说生成的docs.go，我们的框架只需要import它，就能从这个文件的变量doc中直接获取到“接口说明文档”，不需要用读取文件的方式读取swagger.json 或者swagger.yaml。下一节课我们会使用它来让框架启动服务的时候自动启动swagger-ui。</p><p><strong>第三个关键字段 MainAPIFile，表示整个swagger接口的说明文档</strong>。这是什么意思呢？在最终生成的swagger-ui界面上的头部，你会看到对当前swagger接口的整体说明，包括作者、接口版本、接口licence等信息。<br>\n<img src="https://static001.geekbang.org/resource/image/8e/a8/8ec3d0027ec7ed8e76587dcfcf7b87a8.png?wh=2918x718" alt=""></p><p>这些信息也都是使用注释来自动生成的，而这一部分注释，就是存放在这个MainApiFile所指向的Go文件中。</p><p>我们的项目就固定将这个文件命名为swagger.go，存放在app/http/swagger.go 文件中。这个文件只是增加注释，不增加任何的业务逻辑。其中的每个注释的关键字说明，也是参考swaggo的<a href="https://github.com/swaggo/swag#declarative-comments-format">说明文档</a>。</p><pre><code class="language-go">// Package http API.\n// @title hade\n// @version 1.1\n// @description hade测试\n// @termsOfService https://github.com/swaggo/swag\n\n// @contact.name yejianfeng1\n// @contact.email yejianfeng\n\n// @license.name Apache 2.0\n// @license.url http://www.apache.org/licenses/LICENSE-2.0.html\n\n// @BasePath /\n// @query.collection.format multi\n\n// @securityDefinitions.basic BasicAuth\n\n// @securityDefinitions.apikey ApiKeyAuth\n// @in header\n// @name Authorization\n\n// @x-extension-openapi {"example": "value on a json format"}\n\npackage http\n</code></pre><p>现在按照前面的说明，我们设置好了Config结构，在swaggerGenCommand 命令逻辑的最后，只需调用一次Build方法，就能按照Config配置来生成 docs.go、swagger.json、swagger.yaml这三个文件了。</p><pre><code class="language-go">err := gen.New().Build(conf)\n</code></pre><p>记得将这个二级命令 <code>./hade swagger gen</code> 挂载到一级命令 <code>./hade swagger</code> 下，并且挂载到framework/command/kernel.go 中。这个步骤，前面几章中都已经重复做过了，这里就不赘述了。</p><p>挂载好之后，我们尝试运行一下：<br>\n<img src="https://static001.geekbang.org/resource/image/2e/b7/2e46d84c14b1b219abdd5cf378d9edb7.png?wh=1650x340" alt=""></p><p>可以看到，日志信息打印非常详细，包括去哪个目录查找、最终生成哪些文件。</p><p>查看app/http/swagger目录，确实最终生成了docs.go、swagger.json、swagger.yaml 这三个文件：<br>\n<img src="https://static001.geekbang.org/resource/image/f2/3b/f2f05578d6483d2e4a4d483aee1ecb3b.png?wh=680x574" alt=""></p><h3>启动swagger-ui</h3><p>有了swagger生成文件了，应该怎么使用它呢？还是先设想，我们希望的是，能在启动服务的时候，同时启动一个swagger-ui页面，给接口使用人员来查看服务接口，并且他们可以直接在这个页面进行接口调用。</p><p>到这里相信你已经想到了，在启动服务的时候，<strong>增加一个打开swagger-ui页面路由</strong>，就可以达到我们的目的了。还是查看swaggo这个项目，<a href="https://github.com/swaggo/swag#how-to-use-it-with-gin">官方文档</a>中有一段如何将swaggo结合Gin来生成路由的方法说明，正好我们框架的路由用的Gin，所以就考虑使用这个方法来开辟一个swagger-ui路由。</p><p>swaggo开发了一个<a href="https://github.com/swaggo/gin-swagger">gin-swagger</a> 中间件，来为Gin框架增加路由设置。怎么使用它呢？看官方文档的这个<a href="https://github.com/swaggo/gin-swagger">例子</a>：</p><pre><code class="language-go">package main\n\nimport (\n&nbsp; &nbsp;"github.com/gin-gonic/gin"\n&nbsp; &nbsp;docs "github.com/go-project-name/docs"\n&nbsp; &nbsp;swaggerfiles "github.com/swaggo/files"\n&nbsp; &nbsp;ginSwagger "github.com/swaggo/gin-swagger"\n&nbsp; &nbsp;"net/http"\n)\n// @BasePath /api/v1\n\n// PingExample godoc\n// @Summary ping example\n// @Schemes\n// @Description do ping\n// @Tags example\n// @Accept json\n// @Produce json\n// @Success 200 {string} Helloworld\n// @Router /example/helloworld [get]\nfunc Helloworld(g *gin.Context)&nbsp; {\n&nbsp; &nbsp;g.JSON(http.StatusOK,"helloworld")\n}\n\nfunc main()&nbsp; {\n&nbsp; &nbsp;r := gin.Default()\n&nbsp; &nbsp;docs.SwaggerInfo.BasePath = "/api/v1"\n&nbsp; &nbsp;v1 := r.Group("/api/v1")\n&nbsp; &nbsp;{\n&nbsp; &nbsp; &nbsp; eg := v1.Group("/example")\n&nbsp; &nbsp; &nbsp; {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;eg.GET("/helloworld",Helloworld)\n&nbsp; &nbsp; &nbsp; }\n&nbsp; &nbsp;}\n&nbsp; &nbsp;r.GET("/swagger/*any", ginSwagger.WrapHandler(swaggerfiles.Handler))\n&nbsp; &nbsp;r.Run(":8080")\n}\n</code></pre><h3>gin-swagger原理分析</h3><p>我们着重注意下这几行：</p><pre><code class="language-go">package main\n\nimport (\n   ...\n&nbsp; &nbsp;docs "github.com/go-project-name/docs"\n&nbsp; &nbsp;swaggerfiles "github.com/swaggo/gin-swagger/swaggerFiles"\n&nbsp; &nbsp;ginSwagger "github.com/swaggo/gin-swagger"\n   ...\n)\n...\n\nfunc main()&nbsp; {\n&nbsp; ...\n&nbsp; &nbsp;r.GET("/swagger/*any", ginSwagger.WrapHandler(swaggerfiles.Handler))\n&nbsp; &nbsp;...\n}\n</code></pre><p>首先，import的三个文件分别是做什么用的，必须要理解清楚。</p><p>swagger-ui是一个HTML + JSON接口的页面，那么里面分别有动态内容和静态内容，静态内容包括HTML、JS、CSS、png 等，动态内容包括swagger JSON化的结构。也就是说我们现在的<strong>目标是要创建一个包含HTML+JSON的服务</strong>，如何做呢？</p><p>一种方法当然是将这些静态文件直接放在项目中，在服务启动的时候，使用读取文件的方式并返回这些静态文件提供服务。但是这就要求在发布的时候，这些静态文件，必须同时被带着上线，它们成为了服务必须的一部分，特别是作为一个类库提供的时候，如果要求使用者必须带着库的静态文件，是非常不方便的。</p><p>而这里gin-swagger采用了另外一种更为极致的做法，是<strong>将这些静态文件代码化，嵌入到go代码中</strong>，比如让一个变量返回HTML的内容，我们在提供获取HTML页面的服务时，直接将变量返回就可以了。</p><p>这里代码第6行的github.com/swaggo/gin-swagger/swaggerFiles，这个库就做了这个事情，它将swagger-ui的所有HTML、JS、CSS、png 文件都变化成为了go文件，并且作为HTTP服务提供出来。其中的swaggerfiles.Handler 就是实现了net/http 的<a href="https://pkg.go.dev/net/http#HandlerFunc"> HandlerFunc 接口</a>。</p><p>而另外一部分，动态JSON接口，返回的是具体的swagger JSON化的内容。这个怎么获取呢？</p><p>是通过前面我们说的swaggo 生成的几个文件中的doc.go 文件来获取的，在例子中就是第5行引入的 github.com/go-project-name/docs 库，它的原理就是生成doc 全局变量，并且通过 ReadDoc() 方法来提供JSON的内容读取。</p><p>好，现在有了动态JSON接口和静态文件服务接口，如何集成到Gin的Engine里呢？</p><p>要一个中间件就行了，就是第7行 import中引入的 github.com/swaggo/gin-swagger 库。它通过创建一个Gin的中间件，将动态和静态的请求都承接起来，静态请求就请求到swaggo/files库，动态请求就请求到docs库中。</p><p>所以在路由中，我们*<em>创建一个路由/swagger/<em>any，就可以获取swagger-ui 并且读取swaggo 创建的doc.go 文件内容了</em></em>。</p><pre><code class="language-go">r.GET("/swagger/*any", ginSwagger.WrapHandler(swaggerfiles.Handler))\n</code></pre><h3>如何集成</h3><p>好，gin-swagger的原理理解清楚了，如何集成进入我们框架呢？</p><p>gin-swagger本质就是一个Gin中间件。集成Gin的中间件，我们只需要拷贝这个中间件源码，并且将中间件的 github.com/gin-gonic/gin 替换为hade框架的gin地址：github.com/gohade/hade/framework/gin就可以了。</p><p>所以把这个中间件放在framework/middleware/gin-swagger 下。存放完之后的目录截图，你可以对比检查一下：<br>\n<img src="https://static001.geekbang.org/resource/image/e3/de/e367057db0277465e92141d14cf112de.png?wh=1042x1292" alt=""></p><p>把gin-swagger中间件处理完，就剩下将路由存放到我们的app业务路由中去了。</p><p>这里再设计一个小细节。<strong>毕竟我们其实并不希望线上服务也提供这么一个swagger路由，也就是说只希望swagger-ui在测试和开发环境使用</strong>，所以可以在配置文件app.yaml 中有这么一个配置项：</p><pre><code class="language-go">swagger: true\n</code></pre><p>来表示是否开启这个swagger路由。<br>\n那在应用路由中如何获取到这个配置呢？之前应用路由中的参数只有一个gin.Engine。我们需要为gin.Enigne增加一个获取服务容器的接口，GetContainer()。来修改framework/gin/hade_engine.go：</p><pre><code class="language-go">// GetContainer 从Engine中获取container\nfunc (engine *Engine) GetContainer() framework.Container {\n   return engine.container\n}\n</code></pre><p>现在就是真正的万事俱备了，我们来改造应用路由app/http/route.go。</p><ul>\n<li>首先要引入gin-swagger提示的三个import。</li>\n</ul><p>这里我将最后一个docs对应的import，放在了同级目录的app/http/swagger.go文件中。</p><p>我是这么考虑的，<strong>docs.go是我们用命令行生成的，而生成的时候swagger的全局说明配置是放在swagger.go中的</strong>，所以这两个文件关系更为紧密，比较适合放在一起。</p><p>app/http/swagger.go文件信息：</p><pre><code class="language-go">// Package http API.\n// @title hade\n// @version 1.1\n// @description hade测试\n// @termsOfService https://github.com/swaggo/swag\n...\npackage http\n\nimport (\n    _ "github.com/gohade/hade/app/http/swagger"\n)\n</code></pre><p>回到app/http/route.go中。我们引入了另外两个库，并且先判断app.swagger配置项是否为true，如果为true，则开启swagger路由。</p><p>app/http/route.go代码实现，你应该能很容易写出来。要点刚才都详细讲过了：</p><pre><code class="language-go">package http\n\nimport (\n   ...\n   ginSwagger "github.com/gohade/hade/framework/middleware/gin-swagger"\n   "github.com/gohade/hade/framework/middleware/gin-swagger/swaggerFiles"\n   ...\n)\n\n// Routes 绑定业务层路由\nfunc Routes(r *gin.Engine) {\n   container := r.GetContainer()\n   configService := container.MustMake(contract.ConfigKey).(contract.Config)\n\n   ...\n\n   // 如果配置了swagger，则显示swagger的中间件\n   if configService.GetBool("app.swagger") == true {\n      r.GET("/swagger/*any", ginSwagger.WrapHandler(swaggerFiles.Handler))\n   }\n\n   ...\n}\n</code></pre><p>到这里我们就完美将swagger-ui集成进入我们服务了。</p><h3>验证</h3><p>最后做一下验证。先用  <code>./hade swagger gen</code> 命令生成我们要的docs.go文件：<br>\n<img src="https://static001.geekbang.org/resource/image/6d/dc/6d19784c05ec703a26fd7df34d7dabdc.png?wh=1646x358" alt=""></p><p>再使用 <code>./hade build self</code> ，将生成的docs.go 打包编译进./hade命令，启动服务  <code>./hade app start</code> ：<br>\n<img src="https://static001.geekbang.org/resource/image/12/a8/1263d0d128550ca1bf6abfd8631045a8.png?wh=1014x154" alt=""></p><p>浏览器打开地址 <a href="http://localhost:8888/swagger/index.html">http://localhost:8888/swagger/index.html</a> ，可以看到整个swagger-ui界面：<br>\n<img src="https://static001.geekbang.org/resource/image/d4/9e/d483de87fa8da4b313cc8eeefb80d19e.png?wh=3584x2904" alt=""></p><p>并且点击某个接口的 execute 按钮，可以真实地调用这个接口，返回返回数据，进行调试。非常方便：<br>\n<img src="https://static001.geekbang.org/resource/image/9c/29/9c54d8909aeff6f2752ce8abf4664329.png?wh=2288x1566" alt=""></p><p>验证完成！</p><p>今天所有代码都保存在GitHub上的<a href="https://github.com/gohade/coredemo/tree/geekbang/23">geekbang/23</a>分支了。附上目录结构供你对比查看。<br>\n<img src="https://static001.geekbang.org/resource/image/bb/bb/bb80e3120d81cc92668874d5270f2cbb.png?wh=776x890" alt=""><br>\n<img src="https://static001.geekbang.org/resource/image/d7/8b/d793238b11b89ccdfa78fbcf2a73988b.png?wh=1122x1570" alt=""></p><h3>小结</h3><p>这一节课，我们其实就做了一件事情：将swagger融合进入hade框架。</p><p>我们依赖swag项目和gin-swagger中间件，成功地将swagger放到hade框架中，之后使用一个配置，能同时启动hade后端服务和swagger前端调试工具，自动生成一个可以查看接口、可以调用执行的页面。相信在实际工作中开发过后端接口的同学就知道这个工具是有多实用。</p><p>当然熟练使用swagger，以及熟练编写swagger的代码注释，需要对swagger的规则和swag的注释定义有一定了解，这个需要你花时间去掌握。但是相信我，虽然写swagger注释有一些繁琐，但是它能节省大量你和前端同学联调的时间。</p><h3>思考题</h3><p>我之前在一个项目中使用swagger的JSON文件自动生成了项目的接口word说明文档。不知道你在实际工作中，是如何使用swagger的呢？能分享一下你/你们公司使用swagger的一些经历么？</p><p>欢迎在留言区分享你的思考。感谢你的收听，如果觉得今天的内容对你有所帮助，也欢迎分享给你身边的朋友，邀请他一起学习。我们下节课见～</p>',
        article_title: "23｜管理接口：如何集成swagger自动生成文件？",
      },
      {
        title: "24｜管理进程：如何设计完善的运行命令？",
        id: 440646,
        content:
          '<p>你好，我是轩脉刃。</p><p>在<a href="https://time.geekbang.org/column/article/426765">第13章</a>我们引入命令行的时候，将Web启动方式改成了一个命令行。但是当时只完成了一个最简单的启动Web服务的命令，这节课，我们要做的是完善这个Web服务运行命令，让Web服务的运行有完整的启动、停止、重启、查询的进程管理功能。</p><p>这套完整的进程管理功能，能让应用管理者非常方便地通过一套命令来统一管控一个应用，降低应用管理者的管理成本，后续也能为实现应用自动化部署到远端服务的工具提供了基础。下面我们来具体看下如何设计这套命令并且实现它吧。</p><h3>运行命令的设计</h3><p>首先照惯例需要设计一下运行命令，一级命令为 app，二级命令设计如下：</p><ul>\n<li><code>./hade app start</code> 二级命令，启动一个app服务</li>\n<li><code>./hade app state</code> 二级命令，获取启动的app的信息</li>\n<li><code>./hade app stop</code> 二级命令，停止已经启动的app服务</li>\n<li><code>./hade app restart</code> 二级命令，重新启动一个app服务</li>\n</ul><p>这四个二级命令，有app服务的启动、停止、重启、查询，基本上已经把一个app服务启动的状态变更都包含了，能基本满足后面我们对于一个应用的管理需求。下面来讨论下每个命令的功能和设计。</p><h3>启动命令</h3><p>首先是start这个命令，写在framework/command/app.go中。我们先分析下参数。</p><!-- [[[read_end]]] --><p>想要启动app服务，至少需要一个参数，就是<strong>启动服务的监听地址</strong>。如何获取呢？首先可以直接从默认配置获取，另外因为这是一个控制台命令，也一定可以直接从命令行获取。除了这两种方式，我们回顾下之前的配置项获取方法，还有环境变量和配置项。</p><p>所以总结起来，环境变量这个参数我们设计为有四个方式可以获取，一个是直接从命令行参数获取address参数，二是从环境变量ADDRESS中获取，然后是从配置文件中获取配置项app.address，最后如果以上三个方式都没有设置，就使用默认值:8888。关键的代码逻辑如下：</p><pre><code class="language-go">if appAddress == "" {\n    envService := container.MustMake(contract.EnvKey).(contract.Env)\n    if envService.Get("ADDRESS") != "" {\n        appAddress = envService.Get("ADDRESS")\n    } else {\n        configService := container.MustMake(contract.ConfigKey).(contract.Config)\n        if configService.IsExist("app.address") {\n            appAddress = configService.GetString("app.address")\n        } else {\n            appAddress = ":8888"\n        }\n    }\n}\n</code></pre><p>除了监听地址的参数，回忆之前cron命令运行的时候，启动app服务，我们是有两种启动方式的，一种是启动后直接挂在控制台，这种启动方式适合调试开发使用；而另外一种，以守护进程daemon的方式启动，直接挂载在后台。所以，对于这两种启动方式，我们也需要有一个参数daemon，标记是使用哪种方式启动。</p><p>有了appAddress、daemon这两个参数，我们顺着继续想<strong>启动服务时需要的记录文件</strong>。</p><p>不管是使用挂载方式，还是daemon方式启动进程，都能获取到一个进程PID，启动app服务的时候，要将这个PID记录在一个文件中，这里我们就存储在 app/storage/runtime/app.pid 文件中。在运行时候，需要保证这个目录和文件是存在的。</p><p>同时也会产生日志，日志存放在app/storage/log/app.log中，所以我们要确认这个目录是否存在。</p><p>关于app.pid和app.log对应的代码：</p><pre><code class="language-go">appService := container.MustMake(contract.AppKey).(contract.App)\n\npidFolder := appService.RuntimeFolder()\nif !util.Exists(pidFolder) {\n    if err := os.MkdirAll(pidFolder, os.ModePerm); err != nil {\n        return err\n    }\n}\nserverPidFile := filepath.Join(pidFolder, "app.pid")\nlogFolder := appService.LogFolder()\nif !util.Exists(logFolder) {\n    if err := os.MkdirAll(logFolder, os.ModePerm); err != nil {\n        return err\n    }\n}\n// 应用日志\nserverLogFile := filepath.Join(logFolder, "app.log")\ncurrentFolder := util.GetExecDirectory()\n</code></pre><p>好到这里，准备工作都做好了，我们看看Web服务的启动，逻辑和之前设计的基本上没有什么区别，使用net/http来启动一个Web服务。</p><p><strong>重点是启动的时候注意设置优雅关闭机制</strong>。先使用<a href="https://time.geekbang.org/column/article/421354">第六章</a>实现的优雅关闭机制：开启一个Goroutine启动服务，主Goroutine监听信号，当获取到信号之后，等待所有请求都结束或者超过最长等待时长，就结束信号。当然，这里的最长等待时长可以设置为配置项，从app.close_wait配置项中获取，如果没有配置项，我们默认使用5s的最长等待时长。</p><p>启动相关代码：</p><pre><code class="language-go">// 启动AppServer, 这个函数会将当前goroutine阻塞\nfunc startAppServe(server *http.Server, c framework.Container) error {\n    // 这个goroutine是启动服务的goroutine\n    go func() {\n        server.ListenAndServe()\n    }()\n\n    // 当前的goroutine等待信号量\n    quit := make(chan os.Signal)\n    // 监控信号：SIGINT, SIGTERM, SIGQUIT\n    signal.Notify(quit, syscall.SIGINT, syscall.SIGTERM, syscall.SIGQUIT)\n    // 这里会阻塞当前goroutine等待信号\n    &lt;-quit\n\n    // 调用Server.Shutdown graceful结束\n    closeWait := 5\n    configService := c.MustMake(contract.ConfigKey).(contract.Config)\n    if configService.IsExist("app.close_wait") {\n        closeWait = configService.GetInt("app.close_wait")\n    }\n    timeoutCtx, cancel := context.WithTimeout(context.Background(), time.Duration(closeWait)*time.Second)\n    defer cancel()\n\n    if err := server.Shutdown(timeoutCtx); err != nil {\n        return err\n    }\n    return nil\n}\n</code></pre><p>但是这里还出现了一个问题，挂在控制台的启动，比较简单，直接调用封装好的 startAppServe 就行了。但daemon方式如何启动呢？它是不能直接在主进程中调用startAppServe方法的，会把主进程给阻塞挂起来了，怎么办呢？</p><p>这个其实在<a href="https://time.geekbang.org/column/article/427090">第十四章</a>定时任务中有说到，我们可以使用和定时任务一样的实现机制，使用开源库 <a href="https://github.com/sevlyar/go-daemon">go-daemon</a>。比较重要，所以这里再啰嗦一下，<strong>理解go-daemon库的使用，要理解最核心的daemon.Context结构</strong>。</p><p>在我们框架这个需求中，daemon方式启动命令为  <code>./hade app start --daemon=true</code> 。所以在daemon.Context结构中的Args参数填写如下：</p><pre><code class="language-go">// 创建一个Context\ncntxt := &amp;daemon.Context{\n   ...\n   // 子进程的参数，按照这个参数设置，子进程的命令为 ./hade app start --daemon=true\n   Args: []string{"", "app", "start", "--daemon=true"},\n}\n// 启动子进程，d不为空表示当前是父进程，d为空表示当前是子进程\nd, err := cntxt.Reborn()\n\nif d != nil {\n   // 父进程直接打印启动成功信息，不做任何操作\n   fmt.Println("app启动成功，pid:", d.Pid)\n   fmt.Println("日志文件:", serverLogFile)\n   return nil\n}\n...\n</code></pre><p>有的同学对这个启动子进程的Reborn可能有些疑惑。</p><p>我们把Reborn理解成fork，当调用这个函数的时候，父进程会继续往下走，但是返回值d不为空，它的信息是子进程的进程号等信息。而子进程会重新运行对应的命令，再次进入到Reborn函数的时候，返回的d就为nil。所以<strong>在Reborn的后面，我们让父进程直接return，而让子进程继续往后进行操作，这样就达到了fork一个子进程的效果了</strong>。</p><p>理解了这一点，对应的代码就很简单了：</p><pre><code class="language-go">// daemon 模式\nif appDaemon {\n    // 创建一个Context\n    cntxt := &amp;daemon.Context{\n        // 设置pid文件\n        PidFileName: serverPidFile,\n        PidFilePerm: 0664,\n        // 设置日志文件\n        LogFileName: serverLogFile,\n        LogFilePerm: 0640,\n        // 设置工作路径\n        WorkDir: currentFolder,\n        // 设置所有设置文件的mask，默认为750\n        Umask: 027,\n        // 子进程的参数，按照这个参数设置，子进程的命令为 ./hade app start --daemon=true\n        Args: []string{"", "app", "start", "--daemon=true"},\n    }\n    // 启动子进程，d不为空表示当前是父进程，d为空表示当前是子进程\n    d, err := cntxt.Reborn()\n    if err != nil {\n        return err\n    }\n    if d != nil {\n        // 父进程直接打印启动成功信息，不做任何操作\n        fmt.Println("app启动成功，pid:", d.Pid)\n        fmt.Println("日志文件:", serverLogFile)\n        return nil\n    }\n    defer cntxt.Release()\n    // 子进程执行真正的app启动操作\n    fmt.Println("deamon started")\n    gspt.SetProcTitle("hade app")\n    if err := startAppServe(server, container); err != nil {\n        fmt.Println(err)\n    }\n    return nil\n}\n</code></pre><p>到这里服务的进程启动成功，最后还有一点细节，对于启动的进程，我们一般都希望能自定义它的进程名称。</p><p>这里可以使用一个第三方库 <a href="https://github.com/erikdubbelboer/gspt">gspt</a>。它使用MIT协议，虽然star数不多，但是我个人亲测是功能齐全且有效的。在Golang中没有现成的设置进程名称的方法，只能调用C的设置进程名称的方法 setproctitle。所以这个库使用的方式是，使用cgo从Go中调用C的方法来实现进程名称的修改。</p><p>它的使用非常简单，就是一个函数SetProcTitle方法：</p><pre><code class="language-go">gspt.SetProcTitle("hade app")\n</code></pre><p>现在，进程的启动就基本完成了。当然最后还有非常重要的关闭逻辑也记得加上。</p><p>好了，以上我们讨论了start的关键设计，再回头梳理一遍这个命令的实现步骤：</p><ul>\n<li>从四个方式获取参数appAddress</li>\n<li>获取参数daemon</li>\n<li>确认runtime目录和PID文件存在</li>\n<li>确认log目录的log文件存在</li>\n<li>判断是否是daemon方式。如果是，就使用go-daemon来启动一个子进程；如果不是，直接进行后续调用</li>\n<li>使用gspt来设置当前进程名称</li>\n<li>启动app服务</li>\n</ul><p>具体的实现步骤相信你已经很清楚了，完整代码我们写在<a href="https://github.com/gohade/coredemo/blob/geekbang/24/framework/command/app.go"> framework/command/app.go</a>中了。</p><h3>获取进程</h3><p>已经完成了启动进程的命令，那么第二个获取进程PID的命令就非常简单了。因为启动命令的时候创建了一个PID文件，app/storage/runtime/app.pid，读取这个文件就可以获取到进程的PID信息了。</p><p>但是这里我们可以更谨慎一些加一步，获取到PID之后，去操作系统中查询这个PID的进程是否存在，存在的话，就确定这个PID是可行的。</p><p>如何根据PID查询一个进程是否存在呢？常用的比如Linux的ps和grep命令，基本上都是通过Linux的其他命令来检查输出，<strong>但最为可靠的方式是直接使用信号对接要查询的进程：通过给进程发送信号来检测，这个信号就是信号0</strong>。</p><p>给进程发送信号0之后什么都不会操作，如果进程存在，不返回错误信息；如果进程不存在，会返回不存在进程的错误信息。在Golang中，我们可以用os库的Process结构来发送信号。</p><p>代码在 framework/util/exec.go 中，逻辑也很清晰，先用os.FindProcess来获取这个PID对应的进程，然后给进程发送signal 0， 如果返回nil，代表进程存在，否则进程不存在。</p><pre><code class="language-go">// CheckProcessExist 检查进程pid是否存在，如果存在的话，返回true\nfunc CheckProcessExist(pid int) bool {\n   // 查询这个pid\n   process, err := os.FindProcess(pid)\n   if err != nil {\n      return false\n   }\n\n   // 给进程发送signal 0, 如果返回nil，代表进程存在, 否则进程不存在\n   err = process.Signal(syscall.Signal(0))\n   if err != nil {\n      return false\n   }\n   return true\n}\n</code></pre><p>这个关键函数实现之后，其他的就很容易了。</p><p>这里我们也简单说一下进程获取的具体步骤：获取PID文件内容之后，做判断，如果有PID文件且有内容就继续，否则返回无进程；然后：</p><ul>\n<li>将内容转换为PID的int类型，转换失败视为无进程；</li>\n<li><strong>使用signal 0 确认这个进程是否存在，存在返回结果有进程，不存在返回结构无进程</strong>。</li>\n</ul><p>具体代码如下，存放在 framework/command/app.go文件中：</p><pre><code class="language-go">// 获取启动的app的pid\nvar appStateCommand = &amp;cobra.Command{\n   Use:   "state",\n   Short: "获取启动的app的pid",\n   RunE: func(c *cobra.Command, args []string) error {\n      container := c.GetContainer()\n      appService := container.MustMake(contract.AppKey).(contract.App)\n\n      // 获取pid\n      serverPidFile := filepath.Join(appService.RuntimeFolder(), "app.pid")\n\n      content, err := ioutil.ReadFile(serverPidFile)\n      if err != nil {\n         return err\n      }\n\n      if content != nil &amp;&amp; len(content) &gt; 0 {\n         pid, err := strconv.Atoi(string(content))\n         if err != nil {\n            return err\n         }\n         if util.CheckProcessExist(pid) {\n            fmt.Println("app服务已经启动, pid:", pid)\n            return nil\n         }\n      }\n      fmt.Println("没有app服务存在")\n      return nil\n   },\n}\n</code></pre><h3>停止命令</h3><p>命令的启动和获取完成了，就到了第三个停止命令了。既然有了进程号，需要停止一个进程，我们还是可以使用第六章说的信号量方法，回顾下当时说的四个关闭信号：<br>\n<img src="https://static001.geekbang.org/resource/image/e9/50/e93163afd641b744b2b3f8faf46f4e50.jpg?wh=1920x1080" alt=""></p><p>由于启动进程监听了SIGINT、SIGQUIT、SIGTERM 这三个信号，所以我们在这三个信号中选取一个发送给PID所在的进程即可，这里就选择更符合“关闭”语义的SIGTERM信号。</p><p>同样实现步骤也很清晰，获取PID文件内容之后，判断如果有PID文件且有内容再继续，否则什么都不做，之后就是：</p><ul>\n<li>将内容转换为PID的int类型，转换失败则什么都不做</li>\n<li>直接给这个PID进程发送SIGTERM信号</li>\n<li>将PID文件内容清空</li>\n</ul><p>对应代码同样在framework/command/app.go中：</p><pre><code class="language-go">// 停止一个已经启动的app服务\nvar appStopCommand = &amp;cobra.Command{\n   Use:   "stop",\n   Short: "停止一个已经启动的app服务",\n   RunE: func(c *cobra.Command, args []string) error {\n      container := c.GetContainer()\n      appService := container.MustMake(contract.AppKey).(contract.App)\n\n      // GetPid\n      serverPidFile := filepath.Join(appService.RuntimeFolder(), "app.pid")\n\n      content, err := ioutil.ReadFile(serverPidFile)\n      if err != nil {\n         return err\n      }\n\n      if content != nil &amp;&amp; len(content) != 0 {\n         pid, err := strconv.Atoi(string(content))\n         if err != nil {\n            return err\n         }\n         // 发送SIGTERM命令\n         if err := syscall.Kill(pid, syscall.SIGTERM); err != nil {\n            return err\n         }\n         if err := ioutil.WriteFile(serverPidFile, []byte{}, 0644); err != nil {\n            return err\n         }\n         fmt.Println("停止进程:", pid)\n      }\n      return nil\n   },\n}\n</code></pre><h3>重启命令</h3><p>最后我们要完成重启命令，还是在framework/command/app.go中。大致逻辑也很清晰，读取PID文件之后判断，如果PID文件中没有PID，说明没有进程在运行，直接启动新进程；如果PID文件中有PID，检查旧进程是否存在，如果不存在，直接启动新进程，如果存在，这里就有一些需要注意的了。</p><pre><code class="language-go">//获取pid\n...\n\nif content != nil &amp;&amp; len(content) != 0 {\n    // 解析pid是否存在\n    if util.CheckProcessExist(pid) {\n        // 关闭旧的pid进程\n        ...\n    }\n}\n\nappDaemon = true\n// 启动新的进程\nreturn appStartCommand.RunE(c, args)\n</code></pre><p>因为重启的逻辑是先结束旧进程，再启动新进程。结束进程和停止命令一样，使用SIGTERM信号就能保证进程的优雅关闭了。但是<strong>由于新、旧进程都是使用同一个端口，所以必须保证旧进程结束，才能启动新的进程</strong>。</p><p>而怎么保证旧进程确实结束了呢？</p><p>这里可以使用前面定义的 CheckProcessExist 方法，每秒做一次轮询，检测PID对应的进程是否已经关闭。那么轮询多少次呢？</p><p>我们知道在启动进程的时候，设置了一个优雅关闭的最大超时时间closeWait，这个closeWait的时间设置为秒。那么<strong>为了轮询检查旧进程是否关闭，我们只需要设置次数超过closeWait的轮询时间即可</strong>。考虑到net/http 在closeWait之后还有一些程序运行的逻辑，这里我们可以设置为2 * closeWait，时间是非常充裕的。关键代码如下：</p><pre><code class="language-go">// 确认进程已经关闭,每秒检测一次， 最多检测closeWait * 2秒\nfor i := 0; i &lt; closeWait*2; i++ {\n    if util.CheckProcessExist(pid) == false {\n        break\n    }\n    time.Sleep(1 * time.Second)\n}\n</code></pre><p>再严谨一些，可以这么设置，如果在2*closeWait时间内，旧进程还未关闭，那么就不能启动新进程了，需要直接返回错误。所以，在 2 * closeWait 轮询之后，我们还需要再做一次检查，检查进程是否关闭，如果没有关闭的话，直接返回error：</p><pre><code class="language-go">// 确认进程已经关闭,每秒检测一次， 最多检测closeWait * 2秒\nfor i := 0; i &lt; closeWait*2; i++ {\n    if util.CheckProcessExist(pid) == false {\n        break\n    }\n    time.Sleep(1 * time.Second)\n}\n\n// 如果进程等待了2*closeWait之后还没结束，返回错误，不进行后续的操作\nif util.CheckProcessExist(pid) == true {\n    fmt.Println("结束进程失败:"+strconv.Itoa(pid), "请查看原因")\n    return errors.New("结束进程失败")\n}\n</code></pre><p>在确认旧进程结束后，记得把PID文件清空，再启动一个新进程。启动进程的逻辑还是比较复杂的，就不重复写了，我们直接调用appStartCommand的RunE方法来实现，会更优雅一些。</p><p>同其他命令一样，这里再梳理一下判断旧进程存在之后详细的实现步骤，如果存在：</p><ul>\n<li>发送SIGTERM信号</li>\n<li>循环2*closeWait次数，每秒执行一次查询进程是否已经结束</li>\n<li>如果某次查询进程已经结束，或者等待2*closeWait循环结束之后，再次查询一次进程</li>\n<li>如果还未结束，返回进程结束失败</li>\n<li>如果已经结束，将PID文件清空，启动新进程</li>\n</ul><p>在framework/command/app.go中，整体代码如下：</p><pre><code class="language-go">// 重新启动一个app服务\nvar appRestartCommand = &amp;cobra.Command{\n   Use:   "restart",\n   Short: "重新启动一个app服务",\n   RunE: func(c *cobra.Command, args []string) error {\n      container := c.GetContainer()\n      appService := container.MustMake(contract.AppKey).(contract.App)\n\n      // GetPid\n      serverPidFile := filepath.Join(appService.RuntimeFolder(), "app.pid")\n\n      content, err := ioutil.ReadFile(serverPidFile)\n      if err != nil {\n         return err\n      }\n\n      if content != nil &amp;&amp; len(content) != 0 {\n         pid, err := strconv.Atoi(string(content))\n         if err != nil {\n            return err\n         }\n         if util.CheckProcessExist(pid) {\n            // 杀死进程\n            if err := syscall.Kill(pid, syscall.SIGTERM); err != nil {\n               return err\n            }\n            if err := ioutil.WriteFile(serverPidFile, []byte{}, 0644); err != nil {\n               return err\n            }\n\n            // 获取closeWait\n            closeWait := 5\n            configService := container.MustMake(contract.ConfigKey).(contract.Config)\n            if configService.IsExist("app.close_wait") {\n               closeWait = configService.GetInt("app.close_wait")\n            }\n\n            // 确认进程已经关闭,每秒检测一次， 最多检测closeWait * 2秒\n            for i := 0; i &lt; closeWait*2; i++ {\n               if util.CheckProcessExist(pid) == false {\n                  break\n               }\n               time.Sleep(1 * time.Second)\n            }\n\n            // 如果进程等待了2*closeWait之后还没结束，返回错误，不进行后续的操作\n            if util.CheckProcessExist(pid) == true {\n               fmt.Println("结束进程失败:"+strconv.Itoa(pid), "请查看原因")\n               return errors.New("结束进程失败")\n            }\n\n            fmt.Println("结束进程成功:" + strconv.Itoa(pid))\n         }\n      }\n\n      appDaemon = true\n      // 直接daemon方式启动apps\n      return appStartCommand.RunE(c, args)\n   },\n}\n</code></pre><h3>测试</h3><p>下面来测试一下。首先记得使用 <code>./hade build sef</code> 命令编译，我们设置的默认服务启动地址为 “:8888”，这里就不用这个默认启动地址，使用环境变量ADDRESS=:8080 来启动服务。这样能测试到环境变量是否能生效。</p><p>调用命令  <code>ADDRESS=:8080 ./hade app start --daemon=true</code> 以daemon方式启动一个8080端口的服务：<br>\n<img src="https://static001.geekbang.org/resource/image/5d/a4/5dc59ecb06330bd5097c79fc2040e6a4.png?wh=1316x150" alt=""></p><p>使用浏览器打开 localhost:8080/demo/demo：<br>\n<img src="https://static001.geekbang.org/resource/image/aa/97/aa16b16c741b837d94682664d1c0yy97.png?wh=1458x372" alt=""></p><p>服务启动成功，且正常提供服务。</p><p>使用  <code>./hade app state</code> 查看进程状态：<br>\n<img src="https://static001.geekbang.org/resource/image/eb/ee/eb02d0c5f341cbc3632037a6f119dcee.png?wh=922x98" alt=""><br>\n使用命令  <code>ADDRESS=:8080 ./hade app restart</code> 重新启动进程：<br>\n<img src="https://static001.geekbang.org/resource/image/2a/c4/2a1b9e077e357364529e43b786e943c4.png?wh=1152x194" alt=""></p><p>再次访问浏览器 localhost:8080/demo/demo，正常提供服务：<br>\n<img src="https://static001.geekbang.org/resource/image/95/f4/95a1ce5d43a1bf28133a75f773341cf4.png?wh=804x280" alt=""><br>\n最后调用停止进程命令 <code>./hade app stop</code> ：</p><p><img src="https://static001.geekbang.org/resource/image/0f/40/0fb19b39412d970ccb72e43635830040.png?wh=964x100" alt=""></p><p>到这里，对进程的启动、关闭、查询和重启的命令就验证完成了。</p><p>今天我们的所有代码都保存在GitHub上的<a href="https://github.com/gohade/coredemo/tree/geekbang/24">geekbang/24</a>分支了。只修改了framework/command/app.go 和 framework/util/exec.go文件，其他保持不变。<br>\n<img src="https://static001.geekbang.org/resource/image/c1/6b/c137079e767c7fb3a4e1bd2292b6ca6b.png?wh=584x1626" alt=""></p><h3>小结</h3><p>今天我们完成了运行app相关的命令，包括app一级命令和四个二级命令，启动app服务、停止app服务、重启app服务、查询app服务。基本上已经把一个app服务启动的状态变更都包含了。有了这些命令，我们对app的控制就方便很多了。特别是daemon运行模式，为线上运行提供了不少方便。</p><p>在实现这四个命令的过程中，我们使用了不少第三方库，gspt、go-daemon，这些库的使用你要能熟练掌握，特别是go-daemon库，我们已经不止一次使用到它了。确认一个进程是否已经结束，我们使用每秒做一次轮询的 CheckProcessExist 方法实现了检查机制，并仔细考虑了轮训的次数和效果，你可以多多体会这么设计的好处。</p><h3>思考题</h3><p>我们在启动应用的时候，使用的地址格式为“:8080”，其实这里也可以为“localhost:8080”、“127.0.0.1:8080”或者“10.11.22.33:8080”（10.11.22.33为本机绑定的IP）。你了解localhost、127.0.0.1、10.11.22.33 以及不填写IP的区别么？</p><p>欢迎在留言区分享你的思考。感谢你的收听，如果你觉得今天的内容对你有所帮助，也欢迎分享给你身边的朋友，邀请他一起学习。我们下节课见～</p>',
        article_title: "24｜管理进程：如何设计完善的运行命令？",
      },
      {
        title: "25｜GORM（上）：数据库的使用必不可少",
        id: 440695,
        content:
          '<p>你好，我是轩脉刃。</p><p>一个 Web 应用，有很大部分功能是对数据库中数据的获取和加工。比如一个用户管理系统，我们在业务代码中需要频繁增加用户、删除用户、修改用户等，而用户的数据都存放在数据库中。所以对数据库的增删改查，是做 Web 应用必须实现的功能。而我们的 hade 框架如何更好地支持数据库操作呢？这两节课我们就要讨论这个内容。</p><h2>ORM</h2><p>提到数据库，就不得不提ORM了，有的同学一接触 Web 开发，就上手使用 ORM 了，这里我们要明确一点：ORM 并不等同于数据库操作。</p><p>数据库操作，本质上是使用 SQL 语句对数据库发送命令来操作数据。而 ORM 是一种将数据库中的数据映射到代码中对象的技术，这个技术的需求出发点就是，<strong>代码中有类，数据库中有数据表，我们可以将类和数据表进行映射，从而使得在代码中操作类就等同于操作数据库中的数据表了</strong>。</p><p>ORM 这个概念出现的时间无从考究了，基本上从面向对象的编程思想出来的时候就有讨论了。但是到现在，是否要使用 ORM 的讨论也一直没有停止。</p><p>不支持使用 ORM 的阵营的观点基本上是使用 ORM 会影响性能，且会让使用者不了解底层的具体最终拼接出来的SQL，容易造成用不上索引或者最终拼接错误的情况。而支持使用 ORM 的阵营的观点主要是它能切切实实加速应用开发。</p><!-- [[[read_end]]] --><p>就我个人的观点和经验，我还是支持使用 ORM 的。我认为 ORM 不仅仅是一种映射技术，也是一种建模思想。<strong>因为数据库是和业务紧密关联起来的，建立数据库表结构的时候，也是建立了一个业务模型</strong>。使用代码中的类定义，比如定义了一个 User 类，基本上就定义了一个 User 表，这样也是一个建立业务模型的过程。</p><p>其实不论 ORM 的讨论如何激烈，基本上各个语言都已经有了 ORM 的实现，比如 Java 的 Hibernate、PHP 的 Doctrine、Ruby 的 ActiveRecord。而在 Golang 中，现在最流行的 ORM 库是国人的开源项目<a href="https://github.com/go-gorm/gorm">Gorm</a> 。</p><p>Gorm 作者 Jinzhu 目前是字节跳动的员工，他在 GitHub 上开源共享了诸如 copier、configer 等开源项目，Gorm 目前 star 数有 26k 之多，使用 MIT 的许可证协议，项目启动于 2013 年，目前是 v2 版本。</p><p>这个 <strong>v2 版本对应 Gorm GitHub 上 v1.20 以上的 tag</strong>，这点我们要额外注意。因为网上的分析文章很多都是基于Gorm 的 v1 版本写的，但Gorm 的 v1 和 v2 版本相差比较大。所以在看 Gorm 文章的时候需要先明确下是什么版本。</p><p>我们的框架侧重于整合，站在巨人的肩膀上才更符合现代化框架的要求。基于此， hade 框架并不打算重新开发一套 ORM 框架，而是会直接融合 Gorm 框架成为我们容器中的一个服务 orm service。</p><p>版本选择的是 Gorm 截止 2021/10/23 日最新的 v1.21.16 的 tag。毕竟 Gorm 是个有一定体量的项目，而且理解它的重点部分源码的实现原理，对使用者来说非常重要，值得我们先花一章来学习理解。如何融合 Gorm，我们下节课继续学。</p><h2>Gorm</h2><p>一个 ORM 库，最核心要了解两个部分。一个部分是数据库连接，它是怎么和数据库建立连接的，第二部分是数据库操作，即它是怎么操作数据库的。</p><p>我们看一个最精简的 Gorm 的使用例子：</p><pre><code class="language-go">package main\n\nimport (\n  "gorm.io/gorm"\n  "gorm.io/driver/mysql"\n)\n\n// 定义一个 gorm 类\ntype User struct {\n   ID           uint\n   Name         string\n}\n\nfunc main() {\n  // 创建 mysql 连接\n  dsn := "xxxxxxx"\n  db, err := gorm.Open(mysql.Open(dsn), &amp;gorm.Config{})\n  ...\n\n  // 插入一条数据\n  db.Create(&amp;User{Name: "jianfengye"})\n\n  ...\n}\n</code></pre><p>main 函数，先创建一个 MySQL 连接，再插入一条数据，这个 User 数据是通过事先定义好的 User 结构来进行设置的。<strong>其中的 gorm.Open 就是一个快速连接数据库的接口，而后续的 Create 是如何操作数据库的接口</strong>。</p><p>我们今天的任务就是理解这几行代码的实现原理，后面会不断拿这个例子举例。</p><h2>数据结构</h2><p>先把重点放在理解这个 Open 函数上，因为这个函数包含了 Gorm 中关键的几个对象，把这些关键数据结构一一理解透，再跟踪具体的源码能事半功倍。另外也推荐你边看边自己画出这几个关键参数的关系，非常有助于理解和记忆，每个参数讲完之后我也会展示一下我画的分析图供你参考。</p><p>来看它的源码定义：</p><pre><code class="language-go">// 初始化数据库连接\nfunc Open(dialector Dialector, opts ...Option) (db *DB, err error)\n</code></pre><p>这个初始化数据库链接的Open函数有两个参数dialector、opts，和两个返回值gorm.DB、error。我们先理解下这几个参数的意义。</p><h2>Dialector</h2><p>第一个参数是 Dialector，这是什么呢？它代表数据库连接器。这里也是一个面向接口编程的思想，连接器结构 Dialector 是一个接口，代表如果你要使用 Gorm 来连接你的数据库，那么，只需要实现这个接口定义的所有方法，就可以使用 Gorm 来操作你的数据库了。</p><p>所以，这个接口 Dialecotor 中定义的所有方法，都是在后续的查询、更新、数据库迁移等操作中会使用到的。具体每个方法在哪里使用到的，如果你感兴趣可以跟踪下去，如果你不感兴趣也无所谓，只需要记得在后续某个 gorm 接口的具体实现中会用到就行。</p><pre><code class="language-go">// Dialector GORM database dialector\ntype Dialector interface {\n   Name() string // 连接器名称\n   Initialize(*DB) error // 连接器初始化连接方法\n   Migrator(db *DB) Migrator // 数据库迁移方法\n   DataTypeOf(*schema.Field) string // 类中每个字段的类型对应到 sql 语句\n   DefaultValueOf(*schema.Field) clause.Expression // 每个字段的默认值对应到 sql 语句\n   BindVarTo(writer clause.Writer, stmt *Statement, v interface{}) // 使用预编译模式的时候使用\n   QuoteTo(clause.Writer, string) // 将类中的注释对应到 sql 语句中\n   Explain(sql string, vars ...interface{}) string // 将有占位符的 sql 解析为无占位符 sql，常用于日志打印等\n}\n</code></pre><p>不同的数据库有不同的 Dialector 实现，我们称之为“驱动”。每个数据库的驱动，都有一个 git 地址进行存放。目前 gorm 官方支持五种数据库驱动：</p><ul>\n<li>MySQL 的 Gorm 驱动地址为<a href="http://gorm.io/driver/mysql"> </a>gorm.io/driver/mysql</li>\n<li>Postgres 的 Gorm 驱动地址为 gorm.io/driver/postgres</li>\n<li>SQLite 的 gorm 驱动地址为 gorm.io/driver/sqlite</li>\n<li>SQL Server 的 gorm 驱动地址为 gorm.io/driver/sqlserver</li>\n<li>ClickHouse 的 gorm 驱动地址为 gorm.io/driver/clickhouse</li>\n</ul><p><strong>如果要创建对应数据库的连接，要先引入对应的驱动</strong>。而在对应的驱动库中都有一个约定的 Open 方法，来创建一个新的数据库驱动。比如要创建 MySQL 的连接，使用下面这个例子：</p><pre><code class="language-go">import (\n  "gorm.io/driver/mysql"\n  "gorm.io/gorm"\n)\n\n// 创建连接\ndsn := "gorm:gorm@tcp(localhost:9910)/gorm?charset=utf8&amp;parseTime=True&amp;loc=Local"\ndb, err := gorm.Open(mysql.Open(dsn), &amp;gorm.Config{})\n</code></pre><p>我们看到这里有个 mysql.Open，就是创建MySQL 的 Gorm 驱动用的。而这个 Open 函数只有一个字符串参数 DSN，这个参数可能有的同学还不是很了解，我们一起研究下。</p><h4>DSN</h4><p>DSN 全称叫 Data Source Name，数据库的源名称。</p><p>DSN 定义了一个数据库的连接方式及信息，包含用户名、密码、数据库 IP、数据库端口、数据库字符集、数据库时区等信息。可以说<strong>一个 DSN 就是一个数据源的描述</strong>。但是 DSN 并没有明确的官方文档要求其格式，每个语言、每个平台都可以自己定义 DSN 格式，只要定义和解析能对得上就行。</p><p>在社区中，大家普遍会按照以下这种格式来进行定义：</p><pre><code class="language-plain">scheme://username:password@host:port/dbname?param1=value1&amp;param2=value2&amp;...\n</code></pre><p>比如通过 Unix 的 socket 句柄连接本机 MySQL：</p><pre><code class="language-plain">mysql://user@unix(/path/to/socket)/dbname\n</code></pre><p>通过 TCP 连接远端 postgres：</p><pre><code class="language-plain">pgsql://user:pass@tcp(localhost:5555)/dbname\n</code></pre><p>DSN在gorm中的使用就如下图所示，我们使用这个dsn结合具体的驱动来生成Open函数的第一个参数，数据库连接器。<br>\n<img src="https://static001.geekbang.org/resource/image/64/e0/6484f9f91a60120d485a0ea2020fb7e0.jpg?wh=2185x1256" alt=""></p><p>在具体使用中，我们当然可以直接执行字符串拼接，来拼接出一个 DSN，但是我们更希望能<strong>通过定义一个 Golang 的数据结构自动拼接出一个 DSN，或者是从一个 DSN 字符串反序列化生成这个数据结构</strong>。</p><p>在 Golang 中有一个第三方库 github.com/go-sql-driver/mysql 就提供了这样的功能。这个库用来对 Go 中的 SQL 提供 MySQL 驱动，其中定义了一个 Config 结构，能映射到 DSN 字符串。Config 结构中一些比较重要的字段说明，我写在注释中了：</p><pre><code class="language-go">type Config struct {\n   User             string            // 用户名\n   Passwd           string            // 密码 (requires User)\n   Net              string            // 网络类型\n   Addr             string            // 地址 (requires Net)\n   DBName           string            // 数据库名\n   Params           map[string]string // 其他连接参数\n   Collation        string            // 字符集\n   Loc              *time.Location    // 时区\n   MaxAllowedPacket int               // 最大包大小\n   ServerPubKey     string            // 连接公钥名称\n   pubKey           *rsa.PublicKey    // 连接公钥 key\n   TLSConfig        string            // TLS 的配置名称\n   tls              *tls.Config       // TLS 的配置项\n   Timeout          time.Duration     // 连接超时\n   ReadTimeout      time.Duration     // 读超时\n   WriteTimeout     time.Duration     // 写超时\n\n   ...\n   CheckConnLiveness       bool // 在使用连接前确认连接可用\n   ...\n   ParseTime               bool // 是否解析时间格式\n   ...\n}\n</code></pre><p>从 DSN 到这个 Config 结构，我们使用 github.com/go-sql-driver/mysql 的 <a href="https://github.com/go-sql-driver/mysql/blob/master/dsn.go">ParseDSN</a> ，而从 Config 结构到 DSN 我们使用 <a href="https://github.com/go-sql-driver/mysql/blob/master/dsn.go">FormatDSN</a> 方法：</p><pre><code class="language-go">// 解析 dsn\nfunc ParseDSN(dsn string) (cfg *Config, err error) \n\n// 生成 dsn\nfunc (cfg *Config) FormatDSN() string\n</code></pre><p>这两个方法都先记下，下节课会用到。</p><h2>Option</h2><p>第一个初始化数据库的参数 dialector 以及之前必要的驱动引入相关参数DSN，就讲解到这里。我们回头继续看 Open 函数：</p><pre><code class="language-go">// 初始化数据库连接\nfunc Open(dialector Dialector, opts ...Option) (db *DB, err error)\n</code></pre><p>第二个参数 opts是 Option 的可变参数，而这个 Option 是一个实现了 Apply 和 AfterInitialize 的接口：</p><pre><code class="language-go">// Option 接口\ntype Option interface {\n   Apply(*Config) error\n   AfterInitialize(*DB) error\n}\n</code></pre><p>这种可变参数如何使用呢？我们看下 Open 的源码：</p><pre><code class="language-go">// Open 初始化 DB 的 Session\nfunc Open(dialector Dialector, opts ...Option) (db *DB, err error) {\n   config := &amp;Config{}\n\n   ...\n\n   for _, opt := range opts {\n      if opt != nil {\n         // 先调用 Apply 初始化 Config\n         if err := opt.Apply(config); err != nil {\n            return nil, err\n         }\n         // Open 最后结束后调用 AfterInitialize\n         defer func(opt Option) {\n            if errr := opt.AfterInitialize(db); errr != nil {\n               err = errr\n            }\n         }(opt)\n      }\n   }\n</code></pre><p>可以看到，对每一个option，我们直接调用它的Apply方法来对数据库的配置config进行修改。Option 的这种编程方式常用在初始化一个比较复杂的结构里面。</p><p>比如这里在 Gorm 中，要初始化一个 Gorm 的构造配置 gorm.Config，而这个 Config 结构有非常多的配置项，我们希望在创建初始化的时候，能对这个配置进行调整。所以就可以在 Option 方法中再定义一个 Apply 方法，它的参数是 gorm.Config 指针：</p><pre><code class="language-plain">func (c *Config) Apply(config *Config) error\n</code></pre><p>这样，可以遍历所有的 Option，挨个调用它们的 Apply 方法对 Config 进行设置，最终我们获取的就是经过所有 Option 处理后的 Config。</p><p>这种 Option 的编程方法在 Golang 中十分常用，要好好掌握，下一节课，我们也会用这种方式为 hade 的 ORM 服务来注册参数。</p><p>Gorm 这里还有一个比较巧妙的设计，Config 结构本身也实现了 Option 接口。按照这个设计实现之后，你会发现，Config 本身也可以作为一个 Option 在 Open 的第二个参数中出现。</p><pre><code class="language-go">func (c *Config) Apply(config *Config) error {\n   if config != c {\n      *config = *c\n   }\n   return nil\n}\n\nfunc (c *Config) AfterInitialize(db *DB) error {\n   if db != nil {\n      for _, plugin := range c.Plugins {\n         if err := plugin.Initialize(db); err != nil {\n            return err\n         }\n      }\n   }\n   return nil\n}\n</code></pre><p>讲到这里相信你能画出第二个参数的要点了，Gorm实现的时候使用的是gorm.Config，之所以它可以匹配Open函数定义的Option的参数的原因是Config结构本身也实现了Option接口。<br>\n<img src="https://static001.geekbang.org/resource/image/de/76/deda009d08f4bf80e384f85dc0d9ce76.jpg?wh=2185x1256" alt=""></p><p>通过上图我们就理解了Open函数在使用的时候，第一个参数和第二个参数是如何对应函数定义两个参数的了。</p><p>所以 Gorm 官方连接<a href="https://gorm.io/zh_CN/docs/connecting_to_the_database.html">MySQL的示例</a>就很好理解了，看注释：</p><pre><code class="language-go">import (\n  "gorm.io/driver/mysql"\n  "gorm.io/gorm"\n)\nfunc main() {\n  // 参考 https://github.com/go-sql-driver/mysql#dsn-data-source-name 获取详情\n  dsn := "user:pass@tcp(127.0.0.1:3306)/dbname?charset=utf8mb4&amp;parseTime=True&amp;loc=Local"\n  // 第一个参数是 dialector\n  // 第二个参数是 option，但是由于 gorm.Config 实现了 option，所以可以这么使用\n  db, err := gorm.Open(mysql.Open(dsn), &amp;gorm.Config{})\n}\n</code></pre><h2>gorm.DB</h2><p>两个传入参数讲完了，我们继续看Open 的返回结构，除了常规的 error 外，还有一个 gorm.DB 的结构指针，定义如下：</p><pre><code class="language-go">type DB struct {\n\t*Config\n\tError&nbsp; &nbsp; &nbsp; &nbsp; error\n\tRowsAffected int64\n\tStatement&nbsp; &nbsp; *Statement\n\t// Has unexported fields.\n}\n</code></pre><p>它具有丰富的操作数据库的方法，比如增加数据的 Create 方法、更新数据的 Update 方法。</p><p>我们研究下 gorm.DB 的结构，它嵌套了一层 gorm.Config 结构，里面有几个关键字段：</p><pre><code class="language-go">// Config GORM config\ntype Config struct {\n   ...\n   // gorm 的日志输出\n   Logger logger.Interface\n   ...\n   \n   // db 的具体连接\n   ConnPool ConnPool\n   // db 驱动器\n   Dialector\n   ...\n\n   callbacks  *callbacks  // 回调方法\n   ...\n}\n</code></pre><p>其中的 Logger 、 ConnPool 和 Callback字段，值得详细研究一下。</p><h3>Logger</h3><p>我们从 Open 看到了，一个 gorm.DB 结构就代表一个数据库连接，而这个数据库连接的所有日志操作输出在哪里呢？就是通过这个 Logger 字段配置的。</p><p>Logger 字段是一个接口，表示如果有一个实现了 logger.Interface 接口的日志输出类，我就能让这个 DB 的所有数据库操作的日志，都输出到这个类中。</p><pre><code class="language-go">// Interface logger interface\ntype Interface interface {\n   LogMode(LogLevel) Interface\n   Info(context.Context, string, ...interface{})\n   Warn(context.Context, string, ...interface{})\n   Error(context.Context, string, ...interface{})\n   Trace(ctx context.Context, begin time.Time, fc func() (sql string, rowsAffected int64), err error)\n}\n</code></pre><p>Gorm 使用 Logger 接口的方法，和我们 hade 框架定义 Logger 服务的方法如出一辙，它<strong>不定义具体的实现类，而是定义了具体的接口</strong>。所以下一节课，我们将 Gorm 融合进入 hade 框架的时候，要做的事情就是封装一个实现了 Gorm 的 logger.Interface 接口的实现类，而这个实现类的具体实现方法，使用 hade 框架的日志服务类来实现。</p><h3>ConnPool</h3><p>ConnPool 也定义了一个接口，它代表数据库的真实连接所在的连接池。这个接口的定义，我认为是Gorm 中最精妙的一个地方了：</p><pre><code class="language-go">// ConnPool db conns pool interface\ntype ConnPool interface {\n   PrepareContext(ctx context.Context, query string) (*sql.Stmt, error)\n   ExecContext(ctx context.Context, query string, args ...interface{}) (sql.Result, error)\n   QueryContext(ctx context.Context, query string, args ...interface{}) (*sql.Rows, error)\n   QueryRowContext(ctx context.Context, query string, args ...interface{}) *sql.Row\n}\n</code></pre><p>这个接口定义了四个方法，但它们并不是随便定义的，而是根据 Golang 标准库的 database/sql 的 Conn 结构来定义的，这是什么意思呢？</p><p>首先我们要知道，Golang 的标准库 database/sql 其实定义了一套数据库连接规范。官方的基本思想就是，数据库的种类非常多，我不可能对每一个数据库都实现一套定制化的类库，所以我定义一套基本数据结构和方法，并且提供每个数据库需要实现的驱动接口。<strong>使用者只需要实现驱动接口，就能使用这套基本数据结构和方法了</strong>。</p><p>是不是和前面说的 Gorm 的驱动逻辑一样？是的。Golang 中所有的 ORM 库，底层都是基于标准库的 database/sql 来实现数据库的连接和基本操作。只是在具体操作上，会封装一层逻辑，当使用不同驱动接口的时候，实现不一样的接口操作。</p><p>这里的 ConnPool 就是 Gorm 对 database/sql 的数据结构的封装。换句话说，开头的 Gorm 使用例子，在底层 database/sql 的简要实现大致如下：</p><pre><code class="language-go">package main\n\nimport (\n\t"database/sql"\n)\n\nfunc main() {\n\t\n\tdsn := "xxxx"\n\t...\n\tdb, err = sql.Open("mysql", *dsn)\n\t...\n    \n    result, err := db.ExecContext(ctx, "INSERT INTO user (name) values (\'jianfengye\')")\n    ...\n}\n</code></pre><p>这里 sql.Open 创建的 sql.DB 结构，就包含 ConnPool 中定义的四个接口：PrepareContext、ExecContext、QueryContext、QueryRowContext。也就是说：<strong>database/sql 的 sql.DB 结构实现了 Gorm 库的 ConnPool 接口</strong>。</p><p>而实际上，database/sql 里面的 sql.DB 结构就是一个连接池结构，我们可以通过以下四个方法设置连接池的不同属性：</p><pre><code class="language-go">// 设置连接的最大空闲时长\nfunc (db *DB) SetConnMaxIdleTime(d time.Duration)\n// 设置连接的最大生命时长\nfunc (db *DB) SetConnMaxLifetime(d time.Duration)\n// 设置最大空闲连接数\nfunc (db *DB) SetMaxIdleConns(n int)\n// 设置最大打开连接数\nfunc (db *DB) SetMaxOpenConns(n int)\n</code></pre><p>所以 gorm.DB 里面的 ConnPool 实际上存放的就是 database/sql 的 sql.DB 结构。</p><h3>callbacks</h3><p>最后看 gorm.DB 里面的 callbacks 字段，它存放的是所有具体函数的调用方法。callback 指针指向的数据结构也是叫做同名的 callbacks：</p><pre><code class="language-go">// callbacks gorm callbacks manager\ntype callbacks struct {\n   processors map[string]*processor\n}\n</code></pre><p>它里面使用的 map 包含多个 processor。一个 processor 就是一种操作的处理器。processer 的结构定义为：</p><pre><code class="language-go">type processor struct {\n   db        *DB // 对应的 gorm.DB\n   Clauses   []string  // 处理器对应的 sql 片段\n   fns       []func(*DB) // 这个处理器对应的处理函数\n   callbacks []*callback // 这个处理器对应的回调函数，生成 fns\n}\n</code></pre><p>开头的那个例子，我们调用了 gorm.DB 的 Create 方法，它会去 gorm.DB 的 callbacks 中的 processors 里，寻找 key 为“create”的处理器 processor。然后逐个调用处理器中设置好的 fns。下面分析源码的时候也会看到具体的实现逻辑。<br>\n<img src="https://static001.geekbang.org/resource/image/59/9c/591e738e8aa8af160fac58fd44d8639c.jpg?wh=2185x1256" alt=""></p><h2>源码</h2><p>现在理解了 Gorm 在创建连接过程中涉及的几个关键对象，我们就再从源码开始梳理一下 Gorm 的核心逻辑，理解下 Gorm 是怎么使用 Open 创建数据库连接、怎么使用创建的数据库连接的 Create 方法来创建一条数据的。再把开头官网的例子拿出来。</p><pre><code class="language-go">package main\n\nimport (\n  "gorm.io/gorm"\n  "gorm.io/driver/mysql"\n)\n\ntype Product struct {\n  gorm.Model\n  Code  string\n  Price uint\n}\n\nfunc main() {\n  dsn := "xxxxxxx"\n  db, err := gorm.Open(mysql.Open(dsn), &amp;gorm.Config{})\n  if err != nil {\n    panic("failed to connect database")\n  }\n\n  ...\n\n  // Create\n  db.Create(&amp;Product{Code: "D42", Price: 100})\n\n  ...\n}\n</code></pre><p>用第一节课教的思维导图的方式来分析这个 Gorm 的主流程，主要就是 gorm.Open 和 db.Create 两个方法。</p><h3>gorm.Open</h3><p>首先是 gorm.Open：</p><pre><code class="language-go">  db, err := gorm.Open(mysql.Open(dsn), &amp;gorm.Config{})\n</code></pre><p>我们将函数源码分为四个大步：<br>\n<img src="https://static001.geekbang.org/resource/image/a9/cf/a9afa90a5dba63aa3f2c341c47517ecf.png?wh=1356x1364" alt=""></p><p>第一大步，初始化 gorm.Config 结构。通过使用参数中的 Option 可变参数的 Apply 接口，对最终的配置结构 gorm.Config进行相应的修改，其中包括修改输出的 Logger 结构。</p><p>第二步，初始化 gorm.DB 结构：</p><pre><code class="language-plain">db = &amp;DB{Config: config, clone: 1}\n</code></pre><p>第三步，初始化 gorm.DB 的 callbacks。<br>\n<img src="https://static001.geekbang.org/resource/image/f4/4a/f482ff99aa62eb3cd3991867d967f74a.png?wh=1920x814" alt=""></p><p>这里我们只拆解了这个例子的 create 函数相关的 callback。核心的关键函数在 Gorm 库 callback.go 的 RegisterDefaultCallbacks 方法。比如下列的代码，就是创建 create 相关的执行方法 fns：</p><pre><code class="language-go">createCallback := db.Callback().Create()\ncreateCallback.Match(enableTransaction).Register("gorm:begin_transaction", BeginTransaction)\ncreateCallback.Register("gorm:before_create", BeforeCreate)\ncreateCallback.Register("gorm:save_before_associations", SaveBeforeAssociations(true))\ncreateCallback.Register("gorm:create", Create(config))\ncreateCallback.Register("gorm:save_after_associations", SaveAfterAssociations(true))\ncreateCallback.Register("gorm:after_create", AfterCreate)\ncreateCallback.Match(enableTransaction).Register("gorm:commit_or_rollback_transaction", CommitOrRollbackTransaction)\nif len(config.CreateClauses) == 0 {\n   config.CreateClauses = createClauses\n}\ncreateCallback.Clauses = config.CreateClauses\n</code></pre><p>我们可以看到，Gorm 在一个 create 方法，定义了 7 个执行方法 fns，分别是：BeginTransaction、BeforeCreate、SaveBeforeAssociations、Create、SaveAfterAssociations、AfterCreate、CommitOrRollbackTransaction。这七个执行方法就是按照顺序，从上到下每个 Create 函数都会执行的方法。</p><p>其中关注一下 Create 方法，它又分为五个步骤：<br>\n<img src="https://static001.geekbang.org/resource/image/74/97/74168a832a7ea27fc84548cc980d1297.png?wh=1920x719" alt=""></p><p>我们看到了熟悉的 ExecContent 函数，这个就对应上了 Golang 标准库的 database/sql 中 sql.DB 的 ExecContext 方法。原来它藏在这里！</p><p>那前面说的 database/sql 的 sql.DB 的 Open 方法，又放在哪里呢？就在 gorm.Open 的第四大步中：</p><pre><code class="language-plain">db.ConnPool, err = sql.Open(dialector.DriverName, dialector.DSN)\n</code></pre><p>将 database/sql 中生成的 sql.DB 结构，设置在了 gorm.DB 的 ConnPool 上。</p><h3>db.Create</h3><p>下面再来看 gorm.DB 的 Create 方法。它的任务就很简单了：触发启动 processor 中的 fns 方法。具体最核心的代码就在 Gorm 的 callback.go 中的 Execute 函数里。<br>\n<img src="https://static001.geekbang.org/resource/image/d4/7a/d41214f972f885c9c18da6aeb7e2e77a.png?wh=1920x566" alt=""></p><p>可以看到，在 Execute 函数中，最核心的是遍历 fns，调用 fn(db) 方法，其中就有我们前面定义的 Create 方法了，也就是执行了 database/sql 的 db.ExecContext 方法。</p><p>这里我们就根据思维导图找到了 Gorm 封装的 database/sql 的两个关键步骤：</p><ul>\n<li>sql.Open</li>\n<li>db.ExecContext</li>\n</ul><p>理解了这一点，就基本理解了 Gorm 最核心的实现原理了。<br>\n<img src="https://static001.geekbang.org/resource/image/ee/88/eec03fdb85d622202f8e7c8ac7e70488.jpg?wh=4861x3258" alt=""></p><p>当然 Gorm 中还有一个部分，是将我们定义的 Model解析成为 SQL 语句，这里又是 Gorm 定义的一套非常庞大的数据结构支撑的了，其中包括 Statement、Schema、Field、Relationship 等和数据表操作相关的数据结构。</p><p>这需要用另外一个篇幅来描述了。不过这块 Model 解析，对我们下一章 hade 框架融合 Gorm 的影响并不大。有兴趣的同学可以追着上述 Create 方法中的 stmt.Parse 方法进一步分析。</p><p>今天我们还没有涉及代码修改，思维导图保存在 GitHub 上的 <a href="https://github.com/gohade/coredemo/tree/geekbang/25">geekbang/25</a> 分支中根目录的 mysql.xmind 中了。</p><h2>小结</h2><p>我们分析了 Gorm 的具体数据结构和创建连接的核心源码流程。想要检验自己是否理解这节课也很简单，你可以对照开头为 user 表插入一行的代码，看看能不能清晰分析出它的底层是如何封装标准库的 database/sql 来实现的。</p><p>我们在阅读 Gorm 源码的同时，也是在学习它的优秀编码方式，比如今天讲到的 Option 方式、定义驱动、ConnPool 定义实现标准库方法的接口。这些都是 Gorm 设计精妙的地方。</p><p>当然 Gorm 的代码远不是一篇文章能说透的。其中包含的 Model 解析，以及更多的具体细节实现，都得靠你在后续使用过程中多看<a href="https://gorm.io/zh_CN/">官网</a>、多思考、多解析，才能完全吃透这个库。</p><h3>思考题</h3><p>GORM 有一个功能我非常喜欢，DryRun 空跑，这个设置是在 gorm.DB 结构中的。如果我们设置了 gorm.DB 的 DryRun，能让我在这个 DB 中的所有 SQL 操作并不真正执行，这个功能在调试的时候是非常有用的。你能再顺着思维导图，分析出 DryRun 是怎么做到这一点的么？</p><p>欢迎在留言区分享你的思考。感谢你的收听，如果你觉得今天的内容对你有所帮助，也欢迎分享给身边的朋友，邀请他一起学习。我们下节课见～</p>',
        article_title: "25｜GORM（上）：数据库的使用必不可少",
      },
      {
        title: "26｜GORM（下）：数据库的使用必不可少",
        id: 440701,
        content:
          '<p>你好，我是轩脉刃。</p><p>上一节课，我们梳理了Gorm的核心逻辑，也通过思维导图，详细分析了Gorm的源码搞清楚它是如何封装database/sql的。这节课我们就要思考和操作，如何将Gorm融合进入hade框架了。</p><p>Gorm的使用分为两个部分，数据库的连接和数据库的操作。</p><p>对于数据库操作接口的封装，Gorm已经做的非常好了，它在gorm.DB中定义了非常多的对数据库的操作接口，这些接口已经是非常易用了，而且每个操作接口在<a href="https://gorm.io/docs/">官方文档</a>中都有对应的说明和使用教程。比如在DB的操作接口列表中，我们可以看到常用的增删改查的逻辑：</p><pre><code class="language-go">func (db *DB) Create(value interface{}) (tx *DB)\n\nfunc (db *DB) Delete(value interface{}, conds ...interface{}) (tx *DB)\n\nfunc (db *DB) Get(key string) (interface{}, bool)\n\nfunc (db *DB) Update(column string, value interface{}) (tx *DB)\n</code></pre><p>同时，<a href="https://gorm.io/docs/">官方首页</a>的例子也把获取到DB后的增删改查操作显示很清楚了，建议你在浏览器收藏这个Gorm的说明文档，因为在具体的应用开发中，你会经常参考使用它的。</p><!-- [[[read_end]]] --><p>所以今天我们要做的事情，就是封装Gorm的数据库连接部分。</p><h2>ORM服务</h2><p>按照“一切皆服务”的思想，我们也计划将Gorm封装为一个服务。而服务三要素是服务接口、服务提供者、服务实例化。我们先来定义ORM服务接口。</p><h3>服务接口</h3><p>这个服务接口并不复杂，它的唯一任务就是能够初始化出gorm.DB 实例。回顾上节课说的Gorm初始化gorm.DB的方法：</p><pre><code class="language-go">  dsn := "xxxxxxx"\n  db, err := gorm.Open(mysql.Open(dsn), &amp;gorm.Config{})\n</code></pre><p>参数看起来就这两个部分DSN和gorm.Config。</p><p>不过我们希望设计一个hade框架自定义的配置结构，将所有创建连接需要的配置项整合起来。所以除了DSN和gorm.Config这两个配置项，其实还需要加上连接池的配置，就是上节课说的database/sql中提供的对连接池的配置信息。再回顾一下这四个影响底层创建连接池设置的配置信息：</p><pre><code class="language-go">// 设置连接的最大空闲时长\nfunc (db *DB) SetConnMaxIdleTime(d time.Duration)\n// 设置连接的最大生命时长\nfunc (db *DB) SetConnMaxLifetime(d time.Duration)\n// 设置最大空闲连接数\nfunc (db *DB) SetMaxIdleConns(n int)\n// 设置最大打开连接数\nfunc (db *DB) SetMaxOpenConns(n int)\n</code></pre><p><strong>所以可以定义这么一个DBConfig结构，将所有的创建DB相关的配置都放在这里面</strong>。代码在framework/contract/orm.go中：</p><pre><code class="language-go">// DBConfig 代表数据库连接的所有配置\ntype DBConfig struct {\n   // 以下配置关于dsn\n   WriteTimeout string `yaml:"write_timeout"` // 写超时时间\n   Loc          string `yaml:"loc"`           // 时区\n   Port         int    `yaml:"port"`          // 端口\n   ReadTimeout  string `yaml:"read_timeout"`  // 读超时时间\n   Charset      string `yaml:"charset"`       // 字符集\n   ParseTime    bool   `yaml:"parse_time"`    // 是否解析时间\n   Protocol     string `yaml:"protocol"`      // 传输协议\n   Dsn          string `yaml:"dsn"`           // 直接传递dsn，如果传递了，其他关于dsn的配置均无效\n   Database     string `yaml:"database"`      // 数据库\n   Collation    string `yaml:"collation"`     // 字符序\n   Timeout      string `yaml:"timeout"`       // 连接超时时间\n   Username     string `yaml:"username"`      // 用户名\n   Password     string `yaml:"password"`      // 密码\n   Driver       string `yaml:"driver"`        // 驱动\n   Host         string `yaml:"host"`          // 数据库地址\n\n   // 以下配置关于连接池\n   ConnMaxIdle     int    `yaml:"conn_max_idle"`     // 最大空闲连接数\n   ConnMaxOpen     int    `yaml:"conn_max_open"`     // 最大连接数\n   ConnMaxLifetime string `yaml:"conn_max_lifetime"` // 连接最大生命周期\n   ConnMaxIdletime string `yaml:"conn_max_idletime"` // 空闲最大生命周期\n\n   // 以下配置关于gorm\n   *gorm.Config // 集成gorm的配置\n}\n</code></pre><p>其中DSN是一个复杂的字符串。但我们又不希望使用者直接设置这些复杂字符串来进行传递，所以这里设置了多个字段来生成这个DSN。</p><p>另外上节课也说过，DSN并没有一个标准的格式约定，不同的数据库可能有不同的解析，所以也同时保留直接设置DSN的权限，如果用户手动设置了Dsn字段，那么其他关于Dsn的字段设置均无效。</p><p>所以这里同时需要实现一个方法，使用DBConfig来生成最终使用的字符串Dsn，使用上节课介绍的 github.com/go-sql-driver/mysql 库，就能很方便地实现了。我们继续写：</p><pre><code class="language-go">import (\n   "github.com/go-sql-driver/mysql"\n   ...\n)\n\n// FormatDsn 生成dsn\nfunc (conf *DBConfig) FormatDsn() (string, error) {\n   port := strconv.Itoa(conf.Port)\n   timeout, err := time.ParseDuration(conf.Timeout)\n   if err != nil {\n      return "", err\n   }\n   readTimeout, err := time.ParseDuration(conf.ReadTimeout)\n   if err != nil {\n      return "", err\n   }\n   writeTimeout, err := time.ParseDuration(conf.WriteTimeout)\n   if err != nil {\n      return "", err\n   }\n   location, err := time.LoadLocation(conf.Loc)\n   if err != nil {\n      return "", err\n   }\n   driverConf := &amp;mysql.Config{\n      User:         conf.Username,\n      Passwd:       conf.Password,\n      Net:          conf.Protocol,\n      Addr:         net.JoinHostPort(conf.Host, port),\n      DBName:       conf.Database,\n      Collation:    conf.Collation,\n      Loc:          location,\n      Timeout:      timeout,\n      ReadTimeout:  readTimeout,\n      WriteTimeout: writeTimeout,\n      ParseTime:    conf.ParseTime,\n   }\n   return driverConf.FormatDSN(), nil\n}\n</code></pre><p>可以看到Gorm配置，我们使用结构嵌套的方式，将gorm.Config直接嵌套进入DBConfig中。你可以琢磨下这种写法，它有两个好处。</p><p><strong>一是可以直接设置DBConfig来设置gorm.Config</strong>。比如这个函数是可行的，它直接设置config.DryRun，就是直接设置gorm.Config：</p><pre><code class="language-go">func(container framework.Container, config *contract.DBConfig) error {\n   config.DryRun = true\n   return nil\n}\n</code></pre><p><strong>二是DBConfig继承了*gorm.Config的所有方法</strong>。比如这段代码，我们来理解一下：</p><pre><code class="language-go">config := &amp;contract.DBConfig{}\ndb, err = gorm.Open(mysql.Open(config.Dsn), config)\n</code></pre><p>还记得gorm.Open的第二个参数是Option么，它是一个接口，需要实现Apply和AfterInitialize方法，而我们的DBConfig并没有显式实现这两个方法。但是它嵌套了实现了这两个方法的*gorm.Config，所以，默认DB.Config也就实现了这两个方法。</p><pre><code class="language-go">type Option interface {\n   Apply(*Config) error\n   AfterInitialize(*DB) error\n}\n</code></pre><p>现在，gorm.Open的两个参数DSN和gorm.Config都封装在DBConfig中，而修改DBConfig的方法，我们封装为DBOption。</p><p>如何让设置DBOption的方法更为优雅呢？这里就使用到上节课刚学到的Option可变参数的编程方法了。定义一个DBOption的结构，它代表一个可以对DBConfig进行设置的方法，这个结构作为获取ORM服务GetDB方法的参数。在framework/contract/orm.go中：</p><pre><code class="language-go">package contract\n\n// ORMKey 代表 ORM的服务\nconst ORMKey = "hade:orm"\n\n// ORMService 表示传入的参数\ntype ORMService interface {\n   GetDB(option ...DBOption) (*gorm.DB, error)\n}\n\n// DBOption 代表初始化的时候的选项\ntype DBOption func(container framework.Container, config *DBConfig) error\n</code></pre><p>这样就能通过设置不同的方法来对DBConfig进行配置。</p><p>比如要设置DBConfig中gorm.Config的DryRun空跑字段，设计了这么一个方法在framework/provider/orm/config.go中：</p><pre><code class="language-go">// WithDryRun 设置空跑模式\nfunc WithDryRun() contract.DBOption {\n   return func(container framework.Container, config *contract.DBConfig) error {\n      config.DryRun = true\n      return nil\n   }\n}\n</code></pre><p>之后，在使用ORM服务的时候，我们就可以这样设置：</p><pre><code class="language-go">gormService := c.MustMake(contract.ORMKey).(contract.ORMService)\n// 可变参数为WithDryRun()\ndb, err := gormService.GetDB(orm.WithDryRun())\n</code></pre><h3>服务提供者</h3><p>下一步来完成服务提供者，我们也并不需要过于复杂的设计，只要注意一下两点：</p><ul>\n<li>ORM服务一定是要延迟加载的，因为这个服务并不是一个基础服务。如果设置为非延迟加载，在框架启动的时候就会去建立这个服务，这并不是我们想要的。所以我们设计ORM的provider的时候，需要将IsDefer函数设置为true。</li>\n<li>第二点考虑到我们后续会使用container中的配置服务，来创建具体的gorm.DB实例，传递一个container是必要的。</li>\n</ul><p>所以具体的服务提供者代码如下，在framework/provider/orm/provider.go中：</p><pre><code class="language-go">package orm\n\nimport (\n   "github.com/gohade/hade/framework"\n   "github.com/gohade/hade/framework/contract"\n)\n\n// GormProvider 提供App的具体实现方法\ntype GormProvider struct {\n}\n\n// Register 注册方法\nfunc (h *GormProvider) Register(container framework.Container) framework.NewInstance {\n   return NewHadeGorm\n}\n\n// Boot 启动调用\nfunc (h *GormProvider) Boot(container framework.Container) error {\n   return nil\n}\n\n// IsDefer 是否延迟初始化\nfunc (h *GormProvider) IsDefer() bool {\n   return true\n}\n\n// Params 获取初始化参数\nfunc (h *GormProvider) Params(container framework.Container) []interface{} {\n   return []interface{}{container}\n}\n\n// Name 获取字符串凭证\nfunc (h *GormProvider) Name() string {\n   return contract.ORMKey\n}\n</code></pre><h2>服务实例化</h2><p>服务实例化是今天的重点内容，我们先把Gorm的配置结构和日志结构的准备工作完成，再写稍微复杂一点的具体ORM服务的实例 HadeGorm。</p><h3>配置</h3><p>前面定义了hade框架专属的DBConfig配置结构，如何设置它是一个需要讲究的问题。</p><p>虽然已经设计了一种修改配置文件的方式，就是通过GetDB中的Option参数来设置。但是每个字段都这么设置又非常麻烦，我们自然会想到使用配置文件来配置这个结构。另外如果要连接多个数据库，每个数据库都进行同样的配置，还是颇为麻烦，是不是可以有个默认配置呢？</p><p>于是我们的配置文件可以这样设计：在 database.yaml 中保存数据库的默认值，如果想对某个数据库连接有单独的配置，可以用内嵌yaml结构的方式来进行配置。看下面这个配置例子：</p><pre><code class="language-go">conn_max_idle: 10 # 通用配置，连接池最大空闲连接数\nconn_max_open: 100 # 通用配置，连接池最大连接数\nconn_max_lifetime: 1h # 通用配置，连接数最大生命周期\nprotocol: tcp # 通用配置，传输协议\nloc: Local # 通用配置，时区\n\ndefault:\n    driver: mysql # 连接驱动\n    dsn: "" # dsn，如果设置了dsn, 以下的所有设置都不生效\n    host: localhost # ip地址\n    port: 3306 # 端口\n    database: coredemo # 数据库\n    username: jianfengye # 用户名\n    password: "123456789" # 密码\n    charset: utf8mb4 # 字符集\n    collation: utf8mb4_unicode_ci # 字符序\n    timeout: 10s # 连接超时\n    read_timeout: 2s # 读超时\n    write_timeout: 2s # 写超时\n    parse_time: true # 是否解析时间\n    protocol: tcp # 传输协议\n    loc: Local # 时区\n    conn_max_idle: 10 # 连接池最大空闲连接数\n    conn_max_open: 20 # 连接池最大连接数\n    conn_max_lifetime: 1h # 连接数最大生命周期\n\nread:\n    driver: mysql # 连接驱动\n    dsn: "" # dsn，如果设置了dsn, 以下的所有设置都不生效\n    host: localhost # ip地址\n    port: 3306 # 端口\n    database: coredemo # 数据库\n    username: jianfengye # 用户名\n    password: "123456789" # 密码\n    charset: utf8mb4 # 字符集\n    collation: utf8mb4_unicode_ci # 字符序\n</code></pre><p>在这个database.yaml中，我们配置了database.default和database.read两个数据源。database.read数据源，并没有设置诸如时区loc、连接池conn_max_open配置，这些缺省的配置要从databse.yaml的根结构中获取。</p><p>要实现这个也并不难，先在framework/provider/orm/service.go中实现一个GetBaseConfig方法，来读取database.yaml根目录的结构：</p><pre><code class="language-go">// GetBaseConfig 读取database.yaml根目录结构\nfunc GetBaseConfig(c framework.Container) *contract.DBConfig {\n\n   configService := c.MustMake(contract.ConfigKey).(contract.Config)\n   logService := c.MustMake(contract.LogKey).(contract.Log)\n   \n   config := &amp;contract.DBConfig{}\n   // 直接使用配置服务的load方法读取,yaml文件\n   err := configService.Load("database", config)\n   if err != nil {\n      // 直接使用logService来打印错误信息\n      logService.Error(context.Background(), "parse database config error", nil)\n      return nil\n   }\n   return config\n}\n\n</code></pre><p>然后设计一个根据配置路径加载某个配置结构的方法。这里这个方法一定是在具体初始化某个DB实例的时候使用到，所以要封装为一个Option结构，写在framework/provider/orm/config.go中：</p><pre><code class="language-go">// WithConfigPath 加载配置文件地址\nfunc WithConfigPath(configPath string) contract.DBOption {\n   return func(container framework.Container, config *contract.DBConfig) error {\n      configService := container.MustMake(contract.ConfigKey).(contract.Config)\n        // 加载configPath配置路径\n      if err := configService.Load(configPath, config); err != nil {\n         return err\n      }\n      return nil\n   }\n}\n</code></pre><p>现在，对于使用者来说，要初始化一个配置路径为database.default的数据库，就可以这么使用：</p><pre><code class="language-go">gormService := c.MustMake(contract.ORMKey).(contract.ORMService)\ndb, err := gormService.GetDB(orm.WithConfigPath("database.default"), orm.WithDryRun())\n</code></pre><h3>日志</h3><p>配置项设计清楚了，我们再来思考下日志这块。上一章介绍过了，Gorm是有自己的输出规范的，在初始化参数 gorm.Config 中定义了一个日志输出接口Interface。我们来仔细看下这个接口的定义：</p><pre><code class="language-go">const (\n   Silent LogLevel = iota + 1\n   Error\n   Warn\n   Info\n)\n\n// Interface logger interface\ntype Interface interface {\n   LogMode(LogLevel) Interface // 日志级别\n   Info(context.Context, string, ...interface{})\n   Warn(context.Context, string, ...interface{})\n   Error(context.Context, string, ...interface{})\n   Trace(ctx context.Context, begin time.Time, fc func() (sql string, rowsAffected int64), err error)\n}\n</code></pre><p>Gorm接口的日志级别分类比较简单：Info、Warn、Error、Trace。恰巧，这几个日志级别都在我们hade框架定义的7个日志级别中，所以完全可以将Gorm的这几个级别，映射到hade的日志级别中。也就是说，Gorm打印的Info级别日志输出到hade的Info日志中、error日志输出到hade的error日志中。</p><p>至于Gorm提供的一个LogMode来调整日志级别，由于我们的hade框架已经可以通过配置进行日志级别设置了，所以LogMode函数对我们来说是没有什么意义的。</p><p>好，了解Gorm的日志接口之后，我们明确了接下来要做的事情：<strong>实现一个Gorm的日志实现类，但是这个日志实现类中的每个方法都用 hade 的日志服务来实现</strong>。</p><p>我们在framework/provider/orm/logger.go中定义一个OrmLogger结构，它带有一个logger属性，这个logger属性存放的是hade容器中的log服务：</p><pre><code class="language-go">// OrmLogger orm的日志实现类, 实现了gorm.Logger.Interface\ntype OrmLogger struct {\n   logger contract.Log // 有一个logger对象存放hade的log服务\n}\n\n// NewOrmLogger 初始化一个ormLogger,\nfunc NewOrmLogger(logger contract.Log) *OrmLogger {\n   return &amp;OrmLogger{logger: logger}\n}\n</code></pre><p>它实现了Gorm的Logger.Interface 接口。其中LogMode什么都不做，Info、Error、Warn、Trace 分别对应hade容器中log服务的Info、Error、Warn、Trace方法：</p><pre><code class="language-go">// Info 对接hade的info输出\nfunc (o *OrmLogger) Info(ctx context.Context, s string, i ...interface{}) {\n   fields := map[string]interface{}{\n      "fields": i,\n   }\n   o.logger.Info(ctx, s, fields)\n}\n\n// Warn 对接hade的Warn输出\nfunc (o *OrmLogger) Warn(ctx context.Context, s string, i ...interface{}) {\n   fields := map[string]interface{}{\n      "fields": i,\n   }\n   o.logger.Warn(ctx, s, fields)\n}\n\n// Error 对接hade的Error输出\nfunc (o *OrmLogger) Error(ctx context.Context, s string, i ...interface{}) {\n   fields := map[string]interface{}{\n      "fields": i,\n   }\n   o.logger.Error(ctx, s, fields)\n}\n\n// Trace 对接hade的Trace输出\nfunc (o *OrmLogger) Trace(ctx context.Context, begin time.Time, fc func() (sql string, rowsAffected int64), err error) {\n   sql, rows := fc()\n   elapsed := time.Since(begin)\n   fields := map[string]interface{}{\n      "begin": begin,\n      "error": err,\n      "sql":   sql,\n      "rows":  rows,\n      "time":  elapsed,\n   }\n\n   s := "orm trace sql"\n   o.logger.Trace(ctx, s, fields)\n}\n</code></pre><p>这里稍微注意下Trace方法，Gorm的Trace方法的参数中有传递时间戳begin，这个时间戳代表SQL执行的开始时间，而在函数中使用time.Now获取到当前时间之后，两个相减，我们可以获取到这个SQL的实际执行时间，然后作为hade 日志服务的fields map的一个字段输出。除了Trace，其他几个基本上简单封装hade的日志服务方法就好了。</p><h3>服务实例</h3><p>好了，到现在Gorm的配置结构和日志结构也完成了。万事俱备，下面我们就开始写具体的ORM服务的实例 HadeGorm，在framework/provider/orm/service.go中。</p><p>首先，定义实现contract.ORMService的结构HadeGorm。要明确一点，我们会使用这个结构来生成不同数据库的gorm.DB结构，<strong>所以这个HadeGorm是一个与某个数据库设置无关的结构，而且它应该对单个数据库是一个单例模式</strong>，即在一个服务中，我从HadeGorm两次获取到的default数据库的gorm.DB是同一个。</p><p>设置HadeGrom结构如下：</p><pre><code class="language-go">// HadeGorm 代表hade框架的orm实现\ntype HadeGorm struct {\n   container framework.Container // 服务容器\n   dbs       map[string]*gorm.DB // key为dsn, value为gorm.DB（连接池）\n\n   lock *sync.RWMutex\n}\n</code></pre><p>dbs就是为了单例存在，它的key直接设计为一个string，也就是连接数据库的DSN字符串，而value就是gorm.DB结构。</p><p>这样我们在拿到一个DSN的时候，从这个map中就能判断出是否已经实例化过这个数据库对应的gorm.DB了；如果没有实例化过，就实例化一个gorm.DB，并且将这个实例挂到这个map中。<strong>不过这个逻辑会对dbs有并发修改操作，所以这里要使用一个读写锁来锁住这个dbs的修改</strong>。</p><p>对应实例化HadeGorm的方法为NewHadeGorm，它的具体实现就是初始化HadeGorm中的每个字段。继续写入这段：</p><pre><code class="language-go">// NewHadeGorm 代表实例化Gorm\nfunc NewHadeGorm(params ...interface{}) (interface{}, error) {\n   container := params[0].(framework.Container)\n   dbs := make(map[string]*gorm.DB)\n   lock := &amp;sync.RWMutex{}\n   return &amp;HadeGorm{\n      container: container,\n      dbs:       dbs,\n      lock:      lock,\n   }, nil\n}\n</code></pre><p>重头戏在GetDB方法的实现上。</p><p>首先初始化orm.Config，其中包括从配置中获取设置项，也包括初始化内部的Gorm；然后将GetDB的option参数作用于初始化的orm.Config，修改默认配置；通过orm.Config生成DSN字符串。</p><pre><code class="language-go">  // 读取默认配置\n    config := GetBaseConfig(app.container)\n\n    logService := app.container.MustMake(contract.LogKey).(contract.Log)\n\n    // 设置Logger\n    ormLogger := NewOrmLogger(logService)\n    config.Config = &amp;gorm.Config{\n        Logger: ormLogger,\n    }\n\n    // option对opt进行修改\n    for _, opt := range option {\n        if err := opt(app.container, config); err != nil {\n            return nil, err\n        }\n    }\n</code></pre><p><strong>之后根据dsn字符串判断数据库实例gorm.DB是否已经存在了</strong>。如果存在直接返回gorm.DB，如果不存在需要实例化gorm.DB，这一步逻辑稍微复杂一点：</p><ul>\n<li>根据配置项orm.Config中的不同驱动，来实例化gorm.DB（支持MySQL/Postgres/SQLite/SQL Server/ClickHouse）</li>\n<li>根据配置项orm.Config中的连接池配置，设置gorm.DB的连接池</li>\n<li>将实例化后的gorm.DB和DSN放入map映射中</li>\n<li>返回实例化后的gorm.DB</li>\n</ul><p>代码如下：</p><pre><code class="language-go">// 如果最终的config没有设置dsn,就生成dsn\n    if config.Dsn == "" {\n        dsn, err := config.FormatDsn()\n        if err != nil {\n            return nil, err\n        }\n        config.Dsn = dsn\n    }\n\n    // 判断是否已经实例化了gorm.DB\n    app.lock.RLock()\n    if db, ok := app.dbs[config.Dsn]; ok {\n        app.lock.RUnlock()\n        return db, nil\n    }\n    app.lock.RUnlock()\n\n    // 没有实例化gorm.DB，那么就要进行实例化操作\n    app.lock.Lock()\n    defer app.lock.Unlock()\n\n    // 实例化gorm.DB\n    var db *gorm.DB\n    var err error\n    switch config.Driver {\n    case "mysql":\n        db, err = gorm.Open(mysql.Open(config.Dsn), config)\n    case "postgres":\n        db, err = gorm.Open(postgres.Open(config.Dsn), config)\n    case "sqlite":\n        db, err = gorm.Open(sqlite.Open(config.Dsn), config)\n    case "sqlserver":\n        db, err = gorm.Open(sqlserver.Open(config.Dsn), config)\n    case "clickhouse":\n        db, err = gorm.Open(clickhouse.Open(config.Dsn), config)\n    }\n\n    // 设置对应的连接池配置\n    sqlDB, err := db.DB()\n    if err != nil {\n        return db, err\n    }\n\n    if config.ConnMaxIdle &gt; 0 {\n        sqlDB.SetMaxIdleConns(config.ConnMaxIdle)\n    }\n    if config.ConnMaxOpen &gt; 0 {\n        sqlDB.SetMaxOpenConns(config.ConnMaxOpen)\n    }\n    if config.ConnMaxLifetime != "" {\n        liftTime, err := time.ParseDuration(config.ConnMaxLifetime)\n        if err != nil {\n            logger.Error(context.Background(), "conn max lift time error", map[string]interface{}{\n                "err": err,\n            })\n        } else {\n            sqlDB.SetConnMaxLifetime(liftTime)\n        }\n    }\n\n    if config.ConnMaxIdletime != "" {\n        idleTime, err := time.ParseDuration(config.ConnMaxIdletime)\n        if err != nil {\n            logger.Error(context.Background(), "conn max idle time error", map[string]interface{}{\n                "err": err,\n            })\n        } else {\n            sqlDB.SetConnMaxIdleTime(idleTime)\n        }\n    }\n\n    // 挂载到map中，结束配置\n    if err != nil {\n        app.dbs[config.Dsn] = db\n    }\n\n    return db, err\n</code></pre><p>如果前面的内容都理解了，这段代码实现也没有什么难点了。唯一要注意的地方就是锁的使用，<strong>由于对存在gorm.DB的map是读多写少，所以这里也是使用读写锁</strong>，在读取的时候加了一个读锁，如果map中没有我们要的gorm.DB，先把读锁解开，再加一个写锁，初始化完gorm.DB、保存进入map映射后，再把写锁解开。这样能有效防止对map的并发读写。</p><p>完整的GetDB方法可以参考GitHub上的<a href="https://github.com/gohade/coredemo/blob/geekbang/26/framework/provider/orm/service.go">framework/provider/orm/service.go</a>。</p><p>最后记得去业务代码main.go中，把我们的GormProvider注入服务容器：</p><pre><code class="language-go">func main() {\n   // 初始化服务容器\n   container := framework.NewHadeContainer()\n   ...\n   container.Bind(&amp;orm.GormProvider{})\n\n   ...\n\n   // 运行root命令\n   console.RunCommand(container)\n}\n</code></pre><p>整个Gorm就已经结合到hade框架中了。</p><h2>测试</h2><p>下面来做一下测试。我们用真实的MySQL进行测试。当然你需要在本机/远端/Docker搭建一个MySQL，至于怎么搭建，教程网上有很多了，这里就不详细描述。</p><p>我用的是Mac，使用homebrew 能很方便搭建一个MySQL服务。我的MySQL实例搭建在本机的3306端口，并且搭建完成之后，我创建了一个coredemo的database数据库：<br>\n<img src="https://static001.geekbang.org/resource/image/e8/68/e81e9f92ea1fe6e27edd3d819f577268.png?wh=1836x1388" alt=""></p><p>所以我的配置文件config/development/database.yaml配置如下：</p><pre><code class="language-go">conn_max_idle: 10 # 通用配置，连接池最大空闲连接数\nconn_max_open: 100 # 通用配置，连接池最大连接数\nconn_max_lifetime: 1h # 通用配置，连接数最大生命周期\nprotocol: tcp # 通用配置，传输协议\nloc: Local # 通用配置，时区\n\ndefault:\n    driver: mysql # 连接驱动\n    dsn: "" # dsn，如果设置了dsn, 以下的所有设置都不生效\n    host: localhost # ip地址\n    port: 3306 # 端口\n    database: coredemo # 数据库\n    username: jianfengye # 用户名\n    password: "123456789" # 密码\n    charset: utf8mb4 # 字符集\n    collation: utf8mb4_unicode_ci # 字符序\n    timeout: 10s # 连接超时\n    read_timeout: 2s # 读超时\n    write_timeout: 2s # 写超时\n    parse_time: true # 是否解析时间\n    protocol: tcp # 传输协议\n    loc: Local # 时区\n</code></pre><p>我们想在coredemo数据库中增加一个user表，按照Gorm的规范，需要先定义一个数据结构User。在app/http/module/demo/model.go中：</p><pre><code class="language-go">// User is gorm model\ntype User struct {\n   ID           uint\n   Name         string\n   Email        *string\n   Age          uint8\n   Birthday     *time.Time\n   MemberNumber sql.NullString\n   ActivatedAt  sql.NullTime\n   CreatedAt    time.Time\n   UpdatedAt    time.Time\n}\n</code></pre><p>然后在应用目录app/http/module/demo/api_orm.go中，定义了一个新的路由方法DemoOrm，在这个方法中，我们先从容器中获取到gorm.DB的实例，然后使用db.AutoMigrate 同步数据表user。</p><p>如果第一次执行的时候，数据库中没有表user，它会自动创建user表，然后分别调用db.Create、db.Save、db.First、db.Delete来对user表进行增删改查操作：</p><pre><code class="language-go">// DemoOrm Orm的路由方法\nfunc (api *DemoApi) DemoOrm(c *gin.Context) {\n    logger := c.MustMakeLog()\n    logger.Info(c, "request start", nil)\n\n    // 初始化一个orm.DB\n    gormService := c.MustMake(contract.ORMKey).(contract.ORMService)\n    db, err := gormService.GetDB(orm.WithConfigPath("database.default"))\n    if err != nil {\n        logger.Error(c, err.Error(), nil)\n        c.AbortWithError(50001, err)\n        return\n    }\n    db.WithContext(c)\n\n    // 将User模型创建到数据库中\n    err = db.AutoMigrate(&amp;User{})\n    if err != nil {\n        c.AbortWithError(500, err)\n        return\n    }\n    logger.Info(c, "migrate ok", nil)\n\n    // 插入一条数据\n    email := "foo@gmail.com"\n    name := "foo"\n    age := uint8(25)\n    birthday := time.Date(2001, 1, 1, 1, 1, 1, 1, time.Local)\n    user := &amp;User{\n        Name:         name,\n        Email:        &amp;email,\n        Age:          age,\n        Birthday:     &amp;birthday,\n        MemberNumber: sql.NullString{},\n        ActivatedAt:  sql.NullTime{},\n        CreatedAt:    time.Now(),\n        UpdatedAt:    time.Now(),\n    }\n    err = db.Create(user).Error\n    logger.Info(c, "insert user", map[string]interface{}{\n        "id":  user.ID,\n        "err": err,\n    })\n\n    // 更新一条数据\n    user.Name = "bar"\n    err = db.Save(user).Error\n    logger.Info(c, "update user", map[string]interface{}{\n        "err": err,\n        "id":  user.ID,\n    })\n\n    // 查询一条数据\n    queryUser := &amp;User{ID: user.ID}\n\n    err = db.First(queryUser).Error\n    logger.Info(c, "query user", map[string]interface{}{\n        "err":  err,\n        "name": queryUser.Name,\n    })\n\n    // 删除一条数据\n    err = db.Delete(queryUser).Error\n    logger.Info(c, "delete user", map[string]interface{}{\n        "err": err,\n        "id":  user.ID,\n    })\n    c.JSON(200, "ok")\n}\n</code></pre><p>记得修改app/http/module/demo/api.go中的路由注册：</p><pre><code class="language-go">func Register(r *gin.Engine) error {\n   api := NewDemoApi()\n   ...\n   r.GET("/demo/orm", api.DemoOrm)\n   return nil\n}\n</code></pre><p>现在，使用 <code>./hade build self</code> 来重新编译hade文件，使用 <code>./hade app start</code> 启动服务，并挂起在控制台，日志会输出到控制台。浏览器调用 <a href="http://localhost:8888/demo/orm">http://localhost:8888/demo/orm</a> ，控制台打印日志如下：<br>\n<img src="https://static001.geekbang.org/resource/image/1f/a0/1f7ec4246a851faa3e4f6c9eebfbbda0.png?wh=1920x559" alt=""></p><p>可以清晰地通过trace日志看到底层的Insert/Update/Select/Delete的操作，并且可以通过time字段看到这个请求的具体耗时。到这里Gorm融合hade框架就验证完成了。</p><p>本节课我们主要修改了framework目录下的contract/orm.go 和 provider/orm 目录。目录截图如下，供对比查看，所有代码都已经上传到<a href="https://github.com/gohade/coredemo/tree/geekbang/25">geekbang/25</a>分支了。<br>\n<img src="https://static001.geekbang.org/resource/image/07/00/071144ba671c077937f76a9627263000.png?wh=922x1618" alt=""></p><h3>小结</h3><p>对于Gorm这样比较庞大的库，要把Gorm完美集成到hade框架，更好地支持业务对数据库频繁的增删改查操作，我们并不是一开始就动手修改代码，而是先把Gorm的实例化部分的源码都理清楚了，再动手集成才不会出现问题。</p><p>现在我们可以在hade框架中方便获取到gorm.DB了。但是在具体开发业务的时候，如何使用好Gorm来为业务服务，也是一个非常值得花心思研究的课题。好在我们的技术选型是目前Golang业界最火的Gorm，网络上关于如何使用Gorm的课程有非常多了，在具体开发业务的时候，你可以自己参考和研究。</p><h3>思考题</h3><p>在ORM框架中，model层的存放位置一直是个很有争论的话题。比如geekbang/25 分支上model层的User结构，我存放在app/http/module/demo中，有同学会觉得model层放在 app/http/model目录比较好么？具体model是否应该单独作为一个文件夹出来呢？</p><p>欢迎在留言区分享你的思考。感谢你的收听，如果你觉得今天的内容对你有所帮助，也欢迎分享给你身边的朋友，邀请他一起学习。我们下节课见～</p>',
        article_title: "26｜GORM（下）：数据库的使用必不可少",
      },
      {
        title: "27｜缓存服务：如何基于Redis实现封装？",
        id: 445827,
        content:
          '<p>你好，我是轩脉刃。</p><p>上面两节课把数据库操作接入到hade框架中了，现在我们能使用容器中的ORM服务来操作数据库了。在实际工作中，一旦数据库出现性能瓶颈，除了优化数据库本身之外，另外一个常用的方法是使用缓存来优化业务请求。所以这节课，我们来讨论一下，hade框架如何提供缓存支持。</p><p>现在的Web业务，大部分都是使用Redis来做缓存实现。但是，缓存的实现方式远不止Redis一种，比如在Redis出现之前，Memcached一般是缓存首选；在单机上，还可以使用文件来存储数据，又或者直接使用进程的内存也可以进行缓存实现。</p><p>缓存服务的底层使用哪个存储方式，和具体的业务架构原型相关。我个人在不同业务场景中用过不少的缓存存储方案，不过业界用的最多的Redis，还是优点比较突出。相比文件存储，它能集中分布式管理；而相比Memcached，优势在于多维度的存储数据结构。所以，顺应潮流，我们hade框架主要也针对使用Redis来实现缓存服务。</p><p>我们这节课会创建两个服务，一个是Redis服务，提供对Redis的封装，另外一个是缓存服务，提供一系列对“缓存”的统一操作。而这些统一操作，具体底层是由Redis还是内存进行驱动的，这个可以根据配置决定。</p><!-- [[[read_end]]] --><p>下面我们一个个来讨论吧。</p><h2>Redis服务</h2><p>首先封装一个可以对Redis进行操作的服务。和封装ORM一样，我们自己并不实现Redis的底层传输协议和操作封装，只将Redis“创建连接”的过程封装在hade中就行了。</p><p>这里我们就选择<a href="https://github.com/go-redis/redis">go-redis</a>这个库来实现对Redis的连接。这个库目前也是Golang开源社区最常用的Redis库，有12.8k的star数，使用的是BSD 协议，可以引用，可以修改，但是修改的同时要保留版权声明，这里我们并不需要修改，所以BSD已经足够了。这个库目前是v8版本，可以使用 <code>go get github.com/go-redis/redis/v8</code> 来引入它。</p><p>go-redis的连接非常简单，我们看官网的例子，就看创建连接部分：</p><pre><code class="language-go">import (\n&nbsp; &nbsp; "context"\n&nbsp; &nbsp; "github.com/go-redis/redis/v8"\n)\n\nvar ctx = context.Background()\n\nfunc ExampleClient() {\n    // 创建连接\n&nbsp; &nbsp; rdb := redis.NewClient(&amp;redis.Options{\n&nbsp; &nbsp; &nbsp; &nbsp; Addr:&nbsp; &nbsp; &nbsp;"localhost:6379",\n&nbsp; &nbsp; &nbsp; &nbsp; Password: "", // no password set\n&nbsp; &nbsp; &nbsp; &nbsp; DB:&nbsp; &nbsp; &nbsp; &nbsp;0,&nbsp; // use default DB\n&nbsp; &nbsp; })\n\n&nbsp; &nbsp; ...\n}\n</code></pre><p><strong>核心的redis.NewClient方法，返回的是一个*redis.Client结构，它就相当于Gorm中的DB数据结构，就是我们要实例化Redis的实例</strong>。这个结构是一个封装了300+个Redis操作的数据结构，你可以使用 <code>go doc github.com/go-redis/redis/v8.Client</code> 来观察它封装的Redis操作。</p><h3>配置</h3><p>redis.NewClient方法还有一个参数：*redis.Options 数据结构。这个数据结构就相当于Gorm中的gorm.Config，里面封装了实例化redis.Client的各种配置信息，来看一些重要的配置，都做了注释：</p><pre><code class="language-go">// redis的连接配置\ntype Options struct {\n   // 网络情况\n   // Default is tcp.\n   Network string\n   // host:port 格式的地址\n   Addr string\n   \n   // redis的用户名\n   Username string\n   // redis密码\n   Password string\n   // redis的database\n   DB int\n   \n   // 连接超时\n   // Default is 5 seconds.\n   DialTimeout time.Duration\n   // 读超时\n   // Default is 3 seconds.\n   ReadTimeout time.Duration\n   // 写超时\n   // Default is ReadTimeout.\n   WriteTimeout time.Duration\n   \n   // 最小空闲连接数\n   MinIdleConns int\n   // 最大连接时长\n   MaxConnAge time.Duration\n   \n   // 空闲连接时长\n   // Default is 5 minutes. -1 disables idle timeout check.\n   IdleTimeout time.Duration\n   ...\n}\n</code></pre><p>这些配置项相信你也非常熟悉了，既有连接请求的配置项，也有连接池的配置项。</p><p>和Gorm的配置封装一样，我们想要给用户提供一个配置即用的缓存服务，需要做如下三个事情：</p><ul>\n<li>自定义一个数据结构，封装redis.Options结构</li>\n<li>让刚才自定义的结构能生成一个唯一标识（类似Gorm的DSN）</li>\n<li>支持通过配置文件加载这个结构，同时，支持通过Option可变参数来修改它</li>\n</ul><p>在framework/contract/redis.go中，我们首先定义<strong>RedisConfig数据结构</strong>，这个结构单纯封装redis.Options就行了，没有其他额外的参数需要设置：</p><pre><code class="language-go">// RedisConfig 为hade定义的Redis配置结构\ntype RedisConfig struct {\n   *redis.Options\n</code></pre><p>同时为这个RedisConfig定义一个唯一标识，来标识一个redis.Client。这里我们选用了Addr、DB、UserName、Network 四个字段值来标识。<strong>基本上这四个字段加起来能标识“用什么账号登录哪个Redis地址的哪个database”了</strong>：</p><pre><code class="language-go">// UniqKey 用来唯一标识一个RedisConfig配置\nfunc (config *RedisConfig) UniqKey() string {\n   return fmt.Sprintf("%v_%v_%v_%v", config.Addr, config.DB, config.Username, config.Network)\n}\n</code></pre><p>RedisConfig结构定义完成，下面想要把它加载并支持可修改，我们要结合实例化redis.Client对象来说。</p><h3>初始化连接</h3><p>如何封装Redis的连接实例，这个同Gorm的封装一样，使用Option可变参数的方式。还是在 framework/contract/redis.go中继续写入：</p><pre><code class="language-go">package contract\n\n...\n\nconst RedisKey = "hade:redis"\n\n// RedisOption 代表初始化的时候的选项\ntype RedisOption func(container framework.Container, config *RedisConfig) error\n\n// RedisService 表示一个redis服务\ntype RedisService interface {\n   // GetClient 获取redis连接实例\n   GetClient(option ...RedisOption) (*redis.Client, error)\n}\n</code></pre><p>定义了一个RedisService，表示Redis服务对外提供的协议，它只有一个GetClient方法，通过这个方法能获取到Redis的一个连接实例redis.Client。</p><p>你能看到GetClient方法有一个可变参数RedisOption，这个可变参数是一个函数结构，参数中带有传递进入了的RedisConfig指针，所以<strong>这个RedisOption是有修改RedisConfig结构的能力的</strong>。</p><p>那具体提供哪些RedisOption函数呢？和ORM一样，我们要提供多层次的修改方案，包括默认配置、按照配置项进行配置，以及手动配置：</p><ul>\n<li>GetBaseConfig获取redis.yaml根目录下的Redis配置，作为默认配置</li>\n<li>GetConfigPath 根据指定配置路径获取Redis配置</li>\n<li>WithRedisConfig 可以直接修改RedisConfig中的redis.Options配置信息</li>\n</ul><p>在实现这三个函数之前，有必要先看一下我们的Redis配置文件cofig/testing/redis.yaml：</p><pre><code class="language-yaml">timeout: 10s # 连接超时\nread_timeout: 2s # 读超时\nwrite_timeout: 2s # 写超时\n\nwrite:\n    host: localhost # ip地址\n    port: 3306 # 端口\n    db: 0 #db\n    username: jianfengye # 用户名\n    password: "123456789" # 密码\n    timeout: 10s # 连接超时\n    read_timeout: 2s # 读超时\n    write_timeout: 2s # 写超时\n    conn_min_idle: 10 # 连接池最小空闲连接数\n    conn_max_open: 20 # 连接池最大连接数\n    conn_max_lifetime: 1h # 连接数最大生命周期\n    conn_max_idletime: 1h # 连接数空闲时长\n</code></pre><p>和database.yaml的配置一样，根级别的作为默认配置，二级配置作为单个Redis的配置，并且二级配置会覆盖默认配置。这里还有一个小心思，特意将这些配置项都和database.yaml保持一致了，这样使用者在配置的时候能减少学习成本。</p><p>这三个方法的具体实现和Gorm没有什么太大的区别。基本方法就是使用容器中的配置服务、读取配置信息，然后修改参数中的RedisConfig指针，你可以参考分支中的代码文件<a href="https://github.com/gohade/coredemo/blob/geekbang/27/framework/provider/redis/config.go">framework/provider/redis/config.go</a>。</p><p>我们重点把注意力放在<strong>GetClient方法的实现</strong>上，写在framework/provider/redis/service.go中。类似gorm的GetDB方法，它是一个单例模式，就是一个RedisConfig，只产生一个redis.Client，用一个map加上一个lock来初始化Redis实例：</p><pre><code class="language-go">// HadeRedis 代表hade框架的redis实现\ntype HadeRedis struct {\n    container framework.Container      // 服务容器\n    clients   map[string]*redis.Client // key为uniqKey, value为redis.Client (连接池）\n\n    lock *sync.RWMutex\n}\n</code></pre><p>在GetClient函数中，首先还是获取基本Redis配置 redisConfig，使用参数opts对redisConfig进行修改，最后判断当前redisConfig是否已经实例化了：</p><ul>\n<li>如果已经实例化，返回实例化redis.Client；</li>\n<li>如果未实例化，实例化redis.Client，返回实例化的redis.Client。</li>\n</ul><pre><code class="language-go">// GetClient 获取Client实例\nfunc (app *HadeRedis) GetClient(option ...contract.RedisOption) (*redis.Client, error) {\n    // 读取默认配置\n    config := GetBaseConfig(app.container)\n\n    // option对opt进行修改\n    for _, opt := range option {\n        if err := opt(app.container, config); err != nil {\n            return nil, err\n        }\n    }\n\n    // 如果最终的config没有设置dsn,就生成dsn\n    key := config.UniqKey()\n\n    // 判断是否已经实例化了redis.Client\n    app.lock.RLock()\n    if db, ok := app.clients[key]; ok {\n        app.lock.RUnlock()\n        return db, nil\n    }\n    app.lock.RUnlock()\n\n    // 没有实例化gorm.DB，那么就要进行实例化操作\n    app.lock.Lock()\n    defer app.lock.Unlock()\n\n    // 实例化gorm.DB\n    client := redis.NewClient(config.Options)\n\n    // 挂载到map中，结束配置\n    app.clients[key] = client\n\n    return client, nil\n}\n</code></pre><p>这里只讲了Redis服务的接口和服务实现的关键函数，其中provider的实现基本上和ORM的一致，没有什么特别，就不在这里重复列出代码了。</p><p>到这里我们就将Redis的服务融合进入hade框架了。但Redis只是缓存服务的一种实现，我们这节课最终目标是想实现一个缓存服务。</p><h2>缓存服务</h2><p>缓存服务的使用方式其实非常多，我们可以设置有超时/无超时的缓存，也可以使用计数器缓存，一份好的缓存接口的设计，能对应用的缓存使用帮助很大。</p><p>所以这一部分，相比缓存服务的具体实现，<strong>缓存服务的协议设计直接影响了这个服务的可用性</strong>，我们要重点理解对缓存协议的设计。</p><h3>协议</h3><p>实现一个服务的三步骤，服务协议、服务提供者、服务实例。就先从协议开始，我们希望这个缓存服务提供哪些能力呢？</p><p>首先，缓存协议一定是有两个方法，一个设置缓存、一个获取缓存。设定为Get方法为获取缓存，Set方法为设置缓存。</p><pre><code class="language-go">// Get 获取某个key对应的值\nGet(ctx context.Context, key string) (string, error)\n// Set 设置某个key和值到缓存，带超时时间\nSet(ctx context.Context, key string, val string, timeout time.Duration) error\n</code></pre><p>同时，注意设置缓存的时候，又区分出两种需求，我们需要设置带超时时间的缓存，也需要设置不带超时时间的、永久的缓存。所以，Set方法衍生出Set和SetForever两种。</p><pre><code class="language-go">// SetForever 设置某个key和值到缓存，不带超时时间\nSetForever(ctx context.Context, key string, val string) error\n</code></pre><p>在设置了某个key之后，会不会需要修改这个缓存key的缓存时长呢？完全是有可能的，比如将某个key的缓存时长加大，或者想要获取某个key的缓存时长，所以我们再把注意力放在缓存时长的操作上，提供对缓存时长的操作函数SetTTL和GetTTL：</p><pre><code class="language-go">// SetTTL 设置某个key的超时时间\nSetTTL(ctx context.Context, key string, timeout time.Duration) error\n// GetTTL 获取某个key的超时时间\nGetTTL(ctx context.Context, key string) (time.Duration, error)\n</code></pre><p>再来，Get和Set目前对应的value值为string，但是我们希望value值能不仅仅是一个字符串，它还可以直接是一个对象，这样缓存服务就能存储和获取一个对象出来，能大大方便缓存需求。</p><p>所以我们定义两个GetObj和SetObj方法，来实现对象的缓存存储和获取，但是这个对象在实际存储的时候，又势必要进行序列化和反序列的过程，所以我们对存储和获取的对象再增加一个要求，让它实现官方库的BinaryMarshaler和BinaryUnMarshaler接口：</p><pre><code class="language-go">// GetObj 获取某个key对应的对象, 对象必须实现 https://pkg.go.dev/encoding#BinaryUnMarshaler\nGetObj(ctx context.Context, key string, model interface{}) error\n// SetObj 设置某个key和对象到缓存, 对象必须实现 https://pkg.go.dev/encoding#BinaryMarshaler\nSetObj(ctx context.Context, key string, val interface{}, timeout time.Duration) error\n// SetForeverObj 设置某个key和对象到缓存，不带超时时间，对象必须实现 https://pkg.go.dev/encoding#BinaryMarshaler\nSetForeverObj(ctx context.Context, key string, val interface{}) error\n</code></pre><p>现在，我们已经可以一个key进行缓存获取和设置了，但是有时候要同时对多个key做缓存的获取和设置，来设置对多个key进行操作的方法GetMany和SetMany：</p><pre><code class="language-go">// GetMany 获取某些key对应的值\nGetMany(ctx context.Context, keys []string) (map[string]string, error)\n// SetMany 设置多个key和值到缓存\nSetMany(ctx context.Context, data map[string]string, timeout time.Duration) error\n</code></pre><p>在实际业务中，我们还会有一些计数器的需求，需要将计数器存储到缓存，同时也要能对这个计数器缓存进行增加和减少的操作。可以为计数器缓存设计Calc、Increment、Decrement的接口：</p><pre><code class="language-go">// Calc 往key对应的值中增加step计数\nCalc(ctx context.Context, key string, step int64) (int64, error)\n// Increment 往key对应的值中增加1\nIncrement(ctx context.Context, key string) (int64, error)\n// Decrement 往key对应的值中减去1\nDecrement(ctx context.Context, key string) (int64, error)\n</code></pre><p>缓存的使用有一种Cache-Aside模式，可以提升“获取数据”的性能。可能你没有听过这个名字，但其实我们都用过，这个模式描述的就是在实际操作之前，先去缓存中查看有没有对应的数据，如果有的话，不进行操作，如果没有的话才进行实际操作生成数据，并且把数据存储在缓存中。</p><p>我们希望缓存服务也能支持这种Cache-Aside模式。如何支持呢？</p><p>首先，要有一个生成数据的通用方法结构，我们定义为RememberFunc，让这个函数将服务容器传递进去，这样在具体的实现中，使用者就可以从服务容器中获取各种各样的具体注册服务了，能大大增强这个RemeberFunc的实现能力：</p><pre><code class="language-go">// RememberFunc 缓存的Remember方法使用，Cache-Aside模式对应的对象生成方法\ntype RememberFunc func(ctx context.Context, container framework.Container) (interface{}, error)\n</code></pre><p>然后，我们为缓存服务定义一个Remember方法，来实现这个Cache-Aside模式。</p><pre><code class="language-go">// Remember 实现缓存的Cache-Aside模式, 先去缓存中根据key获取对象，如果有的话，返回，如果没有，调用RememberFunc 生成\nRemember(ctx context.Context, key string, timeout time.Duration, rememberFunc RememberFunc, model interface{}) error\n</code></pre><p>它的参数来仔细看下。除了context之外，有一个key，代表这个缓存使用的key，其次是timeout 代表缓存时长，接着是前面定义的 RememberFunc了，代表如果缓存中没有这个key，就调用RememberFunc函数来生成数据对象。</p><p>这个数据对象从哪里输出呢？就是这里的最后一个参数model了，当然这个Obj必须实现BinaryMarshaler和BinaryUnmarshaler接口。这样定义之后，Remember的具体实现就简单了。</p><p>看这个我在单元测试代码provider/cache/services/redis_test.go中写的测试：</p><pre><code class="language-go">type Bar struct {\n   Name string\n}\nfunc (b *Bar) MarshalBinary() ([]byte, error) {\n   return json.Marshal(b)\n}\nfunc (b *Bar) UnmarshalBinary(bt []byte) error {\n   return json.Unmarshal(bt, b)\n}\n\nConvey("remember op", func() {\n   objNew := Bar{}\n   objNewFunc := func(ctx context.Context, container framework.Container) (interface{}, error) {\n      obj := &amp;Bar{\n         Name: "bar",\n      }\n      return obj, nil\n   }\n   err = mc.Remember(ctx, "foo_remember", 1*time.Minute, objNewFunc, &amp;objNew)\n   So(err, ShouldBeNil)\n   So(objNew.Name, ShouldEqual, "bar")\n})\n</code></pre><p>我们定义了Bar结构，它实现了BinaryMarshaler和BinaryUnmarshaler接口，并且定义了一个objNewFunc方法实现了前面我们定义的RememberFunc。</p><p>之后可以使用Remember方法来为这个方法设置一个Cache-Aside缓存，它的key为foo_remember，缓存时长为1分钟。</p><p>最后回看一下我们对缓存的协议定义，各种缓存的设置和获取方法都有了，还差删除缓存的方法对吧。所以来定义删除单个key的缓存和删除多个key的缓存：</p><pre><code class="language-go">// Del 删除某个key\nDel(ctx context.Context, key string) error\n// DelMany 删除某些key\nDelMany(ctx context.Context, keys []string) error\n</code></pre><p>到这里缓存协议就定义完成了，一共16个方法，要好好理解下这些方法的定义，还是那句话，理解如何定义协议比实现更为重要。<br>\n<img src="https://static001.geekbang.org/resource/image/da/e5/da9b83e6856e5fd523bc270981846fe5.jpg?wh=2364x2273" alt=""></p><h2>实现</h2><p>下面来实现这个缓存服务。前面一再强调了，Redis只是缓存的一种实现，Redis之外，我们可以用不同的存储来实现缓存，甚至，可以使用内存来实现。目前hade框架支持内存和Redis实现缓存，这里我们就先看看如何用Redis来实现缓存。</p><p>由于缓存有不同实现，所以和日志服务一样，<strong>要使用配置文件来cache.yaml中的driver字段，来区别使用哪个缓存</strong>。如果driver为redis，表示使用Redis来实现缓存，如果为memory，表示用内存来实现缓存。当然如果使用Redis的话，就需要同时带上Redis连接的各种参数，参数关键字都类似前面说的Redis服务的配置。</p><p>一个典型的cache.yaml的配置如下：</p><pre><code class="language-go">driver: redis # 连接驱动\nhost: 127.0.0.1 # ip地址\nport: 6379 # 端口\ndb: 0 #db\ntimeout: 10s # 连接超时\nread_timeout: 2s # 读超时\nwrite_timeout: 2s # 写超时\n\n#driver: memory # 连接驱动\n</code></pre><p>那对应到具体实现上，区分使用哪个缓存驱动，我们会在服务提供者provider中来进行。在provider中，注意下Register方法，注册具体的服务实例方法时，要先读取配置中的cache.driver路径：</p><pre><code class="language-go">// Register 注册一个服务实例\nfunc (l *HadeCacheProvider) Register(c framework.Container) framework.NewInstance {\n   if l.Driver == "" {\n      tcs, err := c.Make(contract.ConfigKey)\n      if err != nil {\n         // 默认使用console\n         return services.NewMemoryCache\n      }\n\n      cs := tcs.(contract.Config)\n      l.Driver = strings.ToLower(cs.GetString("cache.driver"))\n   }\n\n   // 根据driver的配置项确定\n   switch l.Driver {\n   case "redis":\n      return services.NewRedisCache\n   case "memory":\n      return services.NewMemoryCache\n   default:\n      return services.NewMemoryCache\n   }\n}\n</code></pre><p>如果是Redis驱动，我们使用service.NewRedisCache来初始化一个Redis连接，定义RedisCache结构来存储redis.Client。</p><p><strong>在初始化的时候，先确定下容器中是否已经绑定了Redis服务，如果没有的话，做一下绑定操作</strong>。这个行为能让我们的缓存容器更为安全。</p><p>接着使用cache.yaml中的配置，来初始化一个redis.Client，这里使用的redisService.GetClient和redis.WithConfigPath，都是上面设计Redis服务的时候刚设计实现的方法。最后将redis.Client 封装到RedisCache中，返回：</p><pre><code class="language-go">import (\n   "context"\n   "errors"\n   redisv8 "github.com/go-redis/redis/v8"\n   "github.com/gohade/hade/framework"\n   "github.com/gohade/hade/framework/contract"\n   "github.com/gohade/hade/framework/provider/redis"\n   "sync"\n   "time"\n)\n\n// RedisCache 代表Redis缓存\ntype RedisCache struct {\n   container framework.Container\n   client    *redisv8.Client\n   lock      sync.RWMutex\n}\n\n// NewRedisCache 初始化redis服务\nfunc NewRedisCache(params ...interface{}) (interface{}, error) {\n   container := params[0].(framework.Container)\n   if !container.IsBind(contract.RedisKey) {\n      err := container.Bind(&amp;redis.RedisProvider{})\n      if err != nil {\n         return nil, err\n      }\n   }\n\n   // 获取redis服务配置，并且实例化redis.Client\n   redisService := container.MustMake(contract.RedisKey).(contract.RedisService)\n   client, err := redisService.GetClient(redis.WithConfigPath("cache"))\n   if err != nil {\n      return nil, err\n   }\n\n   // 返回RedisCache实例\n   obj := &amp;RedisCache{\n      container: container,\n      client:    client,\n      lock:      sync.RWMutex{},\n   }\n   return obj, nil\n}\n</code></pre><p>好，有Redis缓存的实例了，下面来看16个方法的实现。</p><p>Set系列的方法一共有Set/SetObj/SetMany/SetForever/SetForeverObj/SetTTL 6个，其他5个相对简单一些，在生成的redis.Client结构中都有对应实现，我们直接使用redis.Client调用即可，就不赘述了。其中SetMany方法相对复杂些，我们着重说明下。</p><p>在Redis中，SetMany这种为多个key设置缓存的方法，一般可以遍历key，然后一个个调用Set方法，但是这样效率就低了。更好的实现方式是使用pipeline。</p><p>什么是Redis的pipeline呢？Redis的客户端和服务端的交互，采用的是客户端-服务端模式，就是每个客户端的请求发送到Redis服务端，都会有一个完整的响应。所以，向服务端发送n个请求，就对应有n次响应。那么<strong>对于这种n个请求且n个请求没有上下文逻辑关系，我们能不能批量发送，但是只发送一次请求，然后只获取一次响应呢</strong>？</p><p>Redis的pipeline就是这个原理，它将多个请求合成为一个请求，批量发送给Redis服务端，并且只从服务端获取一次数据，拿到这些请求的所有结果。</p><p>我们的SetMany就很符合这个场景。具体的代码如下：</p><pre><code class="language-go">// SetMany 设置多个key和值到缓存\nfunc (r *RedisCache) SetMany(ctx context.Context, data map[string]string, timeout time.Duration) error {\n   pipline := r.client.Pipeline()\n   cmds := make([]*redisv8.StatusCmd, 0, len(data))\n   for k, v := range data {\n      cmds = append(cmds, pipline.Set(ctx, k, v, timeout))\n   }\n   _, err := pipline.Exec(ctx)\n   return err\n}\n</code></pre><p>先用redis.Client.Pipeline() 来创建一个pipeline管道，然后用一个redis.StatusCmd数组来存储要发送的所有命令，最后调用一次pipeline.Exec来一次发送命令。</p><p>Set方法就讲到这里，Get系列的方法一共有4个，Get/GetObj/GetMany/GetTTL。</p><p>在实现Get系列方法的时候有地方需要注意下，因为<strong>Get是有可能Get一个不存在的key的</strong>，对于这种不存在的key是否返回error，是一个可以稍微思考的话题。</p><p>比如Get这个方法，返回的是string和error，如果对于一个不存在的key，返回了空字符串+空error的组合，而对于一个设置了空字符串的key，也返回空字符串+空error的组合，这里其实是丢失了“是否存在key”的信息的。</p><p>所以，对于这些不存在的key，我们设计返回一个 ErrKeyNotFound 的自定义error。像Get函数就实现为如下：</p><pre><code class="language-go">// Get 获取某个key对应的值\nfunc (r *RedisCache) Get(ctx context.Context, key string) (string, error) {\n   val, err := r.client.Get(ctx, key).Result()\n   // 这里判断了key是否为空\n   if errors.Is(err, redisv8.Nil) {\n      return val, ErrKeyNotFound\n   }\n   return val, err\n}\n</code></pre><p>其他Get相关的实现没有什么难点。</p><p>除了Get系列和Set系列，其他的方法有Calc、Increment、Decrement、Del、DelMany 都没有什么太复杂的逻辑，都是redis.Client的具体封装。</p><p>最后看下Remember这个方法：</p><pre><code class="language-go">// Remember 实现缓存的Cache-Aside模式, 先去缓存中根据key获取对象，如果有的话，返回，如果没有，调用RememberFunc 生成\nfunc (r *RedisCache) Remember(ctx context.Context, key string, timeout time.Duration, rememberFunc contract.RememberFunc, obj interface{}) error {\n   err := r.GetObj(ctx, key, obj)\n   // 如果返回为nil，说明有这个key，且有数据，obj已经注入了，返回nil\n   if err == nil {\n      return nil\n   }\n\n   // 有err，但是并不是key不存在，说明是有具体的error的，不能继续往下执行了，返回err\n   if !errors.Is(err, ErrKeyNotFound) {\n      return err\n   }\n\n   // 以下是key不存在的情况, 调用rememberFunc\n   objNew, err := rememberFunc(ctx, r.container)\n   if err != nil {\n      return err\n   }\n\n   // 设置key\n   if err := r.SetObj(ctx, key, objNew, timeout); err != nil {\n      return err\n   }\n   // 用GetObj将数据注入到obj中\n   if err := r.GetObj(ctx, key, obj); err != nil {\n      return err\n   }\n   return nil\n}\n</code></pre><p>前面说过Remember方法是Cache-Aside模式的实现，它的逻辑是先判断缓存中是否有这个key，如果有的话，直接返回对象，如果没有的话，就调用RememberFunc方法来实例化这个对象，并且返回这个实例化对象。</p><p>好了，这里的framework/provider/cache/redis.go我们实现差不多了。</p><h2>验证</h2><p>来做验证，我们为缓存服务写一个简单的路由，在这个路由中：</p><ul>\n<li>获取缓存服务</li>\n<li>设置foo为key的缓存，值为bar</li>\n<li>获取foo为key的缓存，把值打印到控制台</li>\n<li>删除foo为key的缓存</li>\n</ul><pre><code class="language-go">// DemoCache cache的简单例子\nfunc (api *DemoApi) DemoCache(c *gin.Context) {\n   logger := c.MustMakeLog()\n   logger.Info(c, "request start", nil)\n   // 初始化cache服务\n   cacheService := c.MustMake(contract.CacheKey).(contract.CacheService)\n   // 设置key为foo\n   err := cacheService.Set(c, "foo", "bar", 1*time.Hour)\n   if err != nil {\n      c.AbortWithError(500, err)\n      return\n   }\n   // 获取key为foo\n   val, err := cacheService.Get(c, "foo")\n   if err != nil {\n      c.AbortWithError(500, err)\n      return\n   }\n   logger.Info(c, "cache get", map[string]interface{}{\n      "val": val,\n   })\n   // 删除key为foo\n   if err := cacheService.Del(c, "foo"); err != nil {\n      c.AbortWithError(500, err)\n      return\n   }\n   c.JSON(200, "ok")\n}\n</code></pre><p>增加对应的路由：</p><pre><code class="language-go">r.GET("/demo/cache/redis", api.DemoRedis)\n</code></pre><p>在浏览器中请求地址： <a href="http://localhost:8888/demo/cache/redis">http://localhost:8888/demo/cache/redis</a>：<br>\n<img src="https://static001.geekbang.org/resource/image/2a/50/2acd5f030ab6b4d5ce8e05ec0c961850.png?wh=583x174" alt=""></p><p>查看控制台输出的日志：<br>\n<img src="https://static001.geekbang.org/resource/image/6c/14/6cf8ba131ba431303f5f77560015f814.png?wh=617x130" alt=""></p><p>可以明显看到cacheService.Get的数据为bar，打印了出来。验证正确！</p><p>本节课我们主要修改了framework目录下Redis和cache相关的代码。目录截图也放在这里供你对比查看，所有代码都已经上传到<a href="https://github.com/gohade/coredemo/tree/geekbang/27">geekbang/27</a>分支了。<br>\n<img src="https://static001.geekbang.org/resource/image/04/03/04d8a0896596b62ab57848a882d82903.png?wh=355x1116" alt=""></p><h2>小结</h2><p>除DB之外，缓存是我们最常使用的一个存储了，今天我们先是实现了Redis的服务，再用Redis服务实现了一个缓存服务。</p><p>第一部分的Redis服务，同上一节课ORM的逻辑一样，我们只是将go-redis库进行了封装，具体怎么使用，还是依赖你在实际工作中多使用、多琢磨，网上也有很多go-redis库的相关资料。<br>\n<img src="https://static001.geekbang.org/resource/image/da/e5/da9b83e6856e5fd523bc270981846fe5.jpg?wh=2364x2273" alt=""><br>\n在第二部分实现的过程中，相信你现在能理解，<strong>一个服务的接口设计，就是一个“我们想要什么服务”的思考过程</strong>。比如在缓存服务接口设计中，我们定义了16个方法，囊括了Get/Set/Del/Remember等一系列方法，你可以对照思维导图复习一下。但这些方法并不是随便拍脑袋出来的，是因为有设置缓存、获取缓存、删除缓存等需求，才这样设计的。</p><h3>思考题</h3><p>目前hade框架支持内存和Redis实现缓存，我们今天展示了Redis的实现。缓存服务的内存缓存如何实现呢？可以先思考一下，如果是你来实现会如何设计呢？如果有兴趣，你可以自己动手操作一下。完成之后，你可以比对GitHub分支上我已经实现的版本，看看有没有更好的方案。</p><p>欢迎在留言区分享你的思考。感谢你的收听，如果你觉得今天的内容对你有所帮助，也欢迎分享给你身边的朋友，邀请他一起学习。我们下节课见～</p>',
        article_title: "27｜缓存服务：如何基于Redis实现封装？",
      },
      {
        title: "28｜SSH：如何生成发布系统让框架发布自动化？",
        id: 445835,
        content:
          '<p>你好，我是轩脉刃。</p><p>在前面的课程中，我们基本上已经完成了一个能同时生成前端和后端的框架hade，也能很方便对框架进行管理控制。下面两节课，我们来考虑框架的一些周边功能，比如部署自动化。</p><p>部署自动化其实不是一个框架的刚需，有很多方式可以将一个服务进行自动化部署，比如现在比较流行的Docker化或者CI/CD流程。</p><p>但是一些比较个人比较小的项目，比如一个博客、一个官网网站，<strong>这些部署流程往往都太庞大了，更需要一个服务，能快速将在开发机器上写好、调试好的程序上传到目标服务器，并且更新应用程序</strong>。这就是我们今天要实现的框架发布自动化。</p><p>所有的部署自动化工具，基本都依赖本地与远端服务器的连接，这个连接可以是FTP，可以是HTTP，但是更经常的连接是SSH连接。因为一旦我们购买了一个Web服务器，服务器提供商就会提供一个有SSH登录账号的服务器，我们可以通过这个账号登录到服务器上，来进行各种软件的安装，比如FTP、HTTP服务等。</p><p>基本上，SSH账号是我们拿到Web服务器的首要凭证，所以要设计的自动化发布系统也是依赖SSH的。</p><h2>SSH服务</h2><p>那么在Golang中如何SSH连接远端的服务器呢？有一个<a href="https://golang.org/x/crypto/ssh">ssh</a>库能完成SSH的远端连接。</p><!-- [[[read_end]]] --><p>这里介绍一个小知识，你可以看下这个ssh库的git：golang.org/x/crypto/ssh。它是在官网golang.org 下的，但是又不是官方的标准库，因为子目录是x。</p><p>这种库其实也是经过官方认证的，属于实验性的库，我们可以这么理解：<strong>以golang.org/x/ 开头的库，都是官方认为这些库后续有可能成为标准库的一部份</strong>，但是由于种种原因，现在还没有计划放进标准库中，需要更多时间打磨。但是这种库的维护者和开发者一般已经是Golang官方组的人员了。比如现在今年讨论热度很大的Golang泛型，据说也会先以实验库的形式出现。</p><p>不管怎么样，这种以golang.org/x/开头的库，成熟度已经非常高了，我们是可以放心使用的。来了解一下这个ssh库：</p><pre><code class="language-go">package main\n\nimport (\n\t"bytes"\n\t"fmt"\n\t"log"\n\n\t"golang.org/x/crypto/ssh"\n)\n\nfunc main() {\n\tvar hostKey ssh.PublicKey\n\n\t// ssh相关配置\n\tconfig := &amp;ssh.ClientConfig{\n\t\tUser: "username",\n\t\tAuth: []ssh.AuthMethod{\n\t\t\tssh.Password("yourpassword"),\n\t\t},\n\t\tHostKeyCallback: ssh.FixedHostKey(hostKey),\n\t}\n    // 创建client\n\tclient, err := ssh.Dial("tcp", "yourserver.com:22", config)\n\tif err != nil {\n\t\tlog.Fatal("Failed to dial: ", err)\n\t}\n\tdefer client.Close()\n\n    // 使用client做各种操作\n\t\n\tsession, err := client.NewSession()\n\tif err != nil {\n\t\tlog.Fatal("Failed to create session: ", err)\n\t}\n\tdefer session.Close()\n\n\tvar b bytes.Buffer\n\tsession.Stdout = &amp;b\n\tif err := session.Run("/usr/bin/whoami"); err != nil {\n\t\tlog.Fatal("Failed to run: " + err.Error())\n\t}\n\tfmt.Println(b.String())\n}\n</code></pre><p>在这个官方示例中，我们可以看到ssh库作为客户端连接，最重要的是创建ssh.Client这个数据结构，而这个数据结构使用ssh.Dail能进行创建，创建的时候依赖ssh.ClientConfig这么一个配置结构。</p><p>是不是非常熟悉？和前面的Gorm、Redis一样，将SSH的连接部分封装成为hade框架的SSH服务，这样我们就能很方便地初始化一个ssh.Client了。</p><p>经过前面几节课，相信你已经非常熟悉这种套路了，我们就简要说明下ssh service的封装和实现思路。这节课的重点在后面对自动化发布系统的实现上。</p><p>ssh service的封装一样有三个部分，服务协议、服务提供者、服务实现。</p><p>服务协议我们提供GetClient方法：</p><pre><code class="language-go">// SSHService 表示一个ssh服务\ntype SSHService interface {\n   // GetClient 获取ssh连接实例\n   GetClient(option ...SSHOption) (*ssh.Client, error)\n}\n</code></pre><p>而其中的SSHOption作为更新SSHConfig的函数：</p><pre><code class="language-go">// SSHOption 代表初始化的时候的选项\ntype SSHOption func(container framework.Container, config *SSHConfig) error\n</code></pre><p>我们封装配置结构为 SSHConfig：</p><pre><code class="language-go">// SSHConfig 为hade定义的SSH配置结构\ntype SSHConfig struct {\n   NetWork string\n   Host    string\n   Port    string\n   *ssh.ClientConfig\n}\n</code></pre><p>对应的配置文件如下 config/testing/ssh.yaml，你可以看看每个配置的说明：</p><pre><code class="language-yaml">timeout: 1s\nnetwork: tcp\nweb-01:\n    host: 118.190.3.55 # ip地址\n    port: 22 # 端口\n    username: yejianfeng # 用户名\n    password: "123456" # 密码\nweb-02:\n    network: tcp\n    host: localhost # ip地址\n    port: 3306 # 端口\n    username: jianfengye # 用户名\n    rsa_key: "/Users/user/.ssh/id_rsa"\n    known_hosts: "/Users/user/.ssh/known_hosts"\n</code></pre><p>这里注意下，SSH的连接方式有两种，一种是直接使用用户名密码来连接远程服务器，还有一种是使用rsa key文件来连接远端服务器，所以这里的配置需要同时支持两种配置。<strong>对于使用rsa key文件的方式，需要设置rsk_key的私钥地址和负责安全验证的known_hosts</strong>。</p><p>定义好了SSH的服务协议，服务提供者和服务实现并没有什么特别，就不展示具体代码了，在GitHub上的<a href="https://github.com/gohade/coredemo/blob/geekbang/28/framework/provider/ssh/provider.go">provider/ssh/provider.go</a> 和<a href="https://github.com/gohade/coredemo/blob/geekbang/28/framework/provider/ssh/service.go">provider/ssh/service.go</a>中。我们简单说一下思路。</p><p>对于服务提供者，我们实现基本的五个函数Register/Boot/IsDefer/Param/Name。另外这个ssh服务并不是框架启动时候必要加载的，所以设置IsDefer为true，而Param我们就照例把服务容器container作为参数，传递给Register设定的实例化方法。</p><p>而SSH服务的具体实现，同样类似Redis，先配置更新，再查询是否已经实例化，若已经实例化，返回实例化对象；若没有实例化，实例化client，并且存在map中。</p><p>完成了SSH的服务协议、服务提供者、服务实例，我们就重点讨论下如何使用SSH的服务协议来实现自动化部署。</p><h2>自动化部署</h2><p>首先还是思考清楚自动化部署的命令设计。我们的hade框架是同时支持前后端的开发框架，所以自动化部署是需要同时支持前后端部署的，也就是说它的命令也需要支持前后端的部署，这里我们设计一个显示帮助信息的一级命令<code>./hade deploy</code> 和四个二级命令：</p><ul>\n<li><code>./hade deploy frontend</code> ，部署前端</li>\n<li><code>./hade  deploy backend</code> ，部署后端</li>\n<li><code>./hade deploy all</code> ，同时部署前后端</li>\n<li><code>./hade deploy rollback</code> ，部署回滚</li>\n</ul><p>同时也设计一下部署配置文件。</p><p>首先，我们是需要知道部署在哪个或者哪几个服务器上的，所以需要有一个数组配置项connections来定义部署服务器。而部署服务器的具体用户名密码配置，在前面SSH的配置里是存在的，所以这里直接把SSH的配置路径放在我们的connections中就可以了。</p><p>其次，还要知道我们要部署的远端服务器的目标文件夹是什么？所以这里需要有一个remote_folder配置项来配置远端文件夹。</p><p>然后就是前端部署的配置frontend了。我们知道，在本地编译之后，会直接编译成了dist目录下的HTML/JS/CSS文件，这些文件直接上传到远端文件夹就是可以使用的了。</p><p>但是，在上传前端编译文件之前和在远端服务器执行一些命令之后，是有可能要做一些操作的。比如上传前先清空远端文件夹、上传后更新nginx等。所以这里，<strong>我们设计两个数组结构pre_action和post_action来分别存放部署的前置命令和部署的后置命令</strong>。</p><p>最后就是后端部署的配置backend。同前端部署一样，我们也有部署的前置命令和后置命令。但是后端编译还有一个不同点。</p><p>因为后端是Golang编译的，而它的编译其实是分平台的，加上Go支持“交叉编译”。就是说，比如我的工作机器是Mac操作系统，Web服务器是Linux操作系统，那么我需要编译Linux操作系统的后端程序，但是我可以直接在Mac操作系统上使用GOOS 和 GOARCH 来编译Linux操作系统的程序：</p><pre><code class="language-go">GOOS=linux GOARCH=amd64 go build ./\n</code></pre><p>这样编译出来的文件就是可以在Linux运行的后端进程了。所以在后端部署的配置项里面，我们增加GOOS 和 GOARCH分别表示后端的交叉编译参数。</p><p>完整的配置文件在config/development/deploy.yaml中：</p><pre><code class="language-yaml">connections: # 要自动化部署的连接\n    - ssh.web-01\n\nremote_folder: "/home/yejianfeng/coredemo/"  # 远端的部署文件夹\n\nfrontend: # 前端部署配置\n    pre_action: # 部署前置命令\n        - "pwd"\n    post_action: # 部署后置命令\n        - "pwd"\n\nbackend: # 后端部署配置\n    goos: linux # 部署目标操作系统\n    goarch: amd64 # 部署目标cpu架构\n    pre_action: # 部署前置命令\n        - "pwd"\n    post_action: # 部署后置命令\n        - "chmod 777 /home/yejianfeng/coredemo/hade"\n        - "/home/yejianfeng/coredemo/hade app restart"\n</code></pre><p>好，配置文件设计好了，下面我们开始实现对应的命令。</p><p>其实估计你对如何实现，已经大致心中有数了。一级命令 <code>./hade deploy</code>  还是并没有什么内容，只是将帮助信息打印出来，之前也做过很多次，就不描述了。二级命令按之前的套路，一般是先编译，再部署，最后上传到目标服务器。</p><h3>部署前端</h3><p>看二级命令  <code>./hade deploy frontend</code>。对于部署前端，我们分为三个步骤：</p><ul>\n<li>创建要部署的文件夹；</li>\n<li>编译前端文件到部署文件夹中；</li>\n<li>上传部署文件夹，并且执行对应的前置和后置的shell。</li>\n</ul><p>在framework/command/deploy.go中：</p><pre><code class="language-go">// deployFrontendCommand 部署前端\nvar deployFrontendCommand = &amp;cobra.Command{\n    Use:   "frontend",\n    Short: "部署前端",\n    RunE: func(c *cobra.Command, args []string) error {\n        container := c.GetContainer()\n\n        // 创建部署文件夹\n        deployFolder, err := createDeployFolder(container)\n        if err != nil {\n            return err\n        }\n\n        // 编译前端到部署文件夹\n        if err := deployBuildFrontend(c, deployFolder); err != nil {\n            return err\n        }\n\n        // 上传部署文件夹并执行对应的shell\n        return deployUploadAction(deployFolder, container, "frontend")\n    },\n}\n</code></pre><p>这里可能你会有个疑惑，为什么要创建一个部署文件夹？我们直接将前端编译的dist目录上传到目标服务器不就行了么？来为你解答下。</p><p>部署服务是一个很小心的过程，因为它会影响现在的线上服务，而每次部署都是有可能失败的，也就很有可能需要进行回滚操作，就是我们前面定义的部署回滚操作命令 <code>./hade deploy rollback</code> 。<strong>而回滚的时候，需要能找到某个特定版本的编译内容，这里就需要部署文件夹</strong>。</p><p>这个部署文件夹我们定义为目录 deploy/xxxxxx，其中的xxxx直接设置为细化到秒的时间。对应的创建部署文件夹的函数如下：</p><pre><code class="language-go">// 创建部署的folder\nfunc createDeployFolder(c framework.Container) (string, error) {\n   appService := c.MustMake(contract.AppKey).(contract.App)\n   deployFolder := appService.DeployFolder()\n\n   // 部署文件夹的名称\n   deployVersion := time.Now().Format("20060102150405")\n   versionFolder := filepath.Join(deployFolder, deployVersion)\n   if !util.Exists(versionFolder) {\n      return versionFolder, os.Mkdir(versionFolder, os.ModePerm)\n   }\n   return versionFolder, nil\n}\n</code></pre><p>这里的appService.DeployFolder() 是我们在appService下创建的一个新的目录deploy，在framework/contract/app.go中：</p><pre><code class="language-go">// App 定义接口\ntype App interface {\n   ...\n   // DeployFolder 存放部署的时候创建的文件夹\n   DeployFolder() string\n   ...\n}\n</code></pre><p>有了这个部署文件夹，每次的发布都有“档案”存储了，这就为回滚命令提供了可能性。我们每次编译的文件，也都会先经过这个部署文件夹，再中转上传到目标服务器。</p><p>第一步创建部署文件夹实现了，我们再回头看下部署前端的第二个步骤，编译前端文件到部署文件夹。可以直接使用 buildFrontendCommand的RunE方法，它会将前端编译到dist目录下，然后我们再将dist目录文件拷贝到部署文件夹中：</p><pre><code class="language-go">func deployBuildFrontend(c *cobra.Command, deployFolder string) error {\n   container := c.GetContainer()\n   appService := container.MustMake(contract.AppKey).(contract.App)\n\n   // 编译前端\n   if err := buildFrontendCommand.RunE(c, []string{}); err != nil {\n      return err\n   }\n\n   // 复制前端文件到deploy文件夹\n   frontendFolder := filepath.Join(deployFolder, "dist")\n   if err := os.Mkdir(frontendFolder, os.ModePerm); err != nil {\n      return err\n   }\n\n   buildFolder := filepath.Join(appService.BaseFolder(), "dist")\n   if err := util.CopyFolder(buildFolder, frontendFolder); err != nil {\n      return err\n   }\n   return nil\n}\n</code></pre><p>第三步，上传部署文件夹，并且执行对应的前置和后置的shell。</p><p>这个步骤的实现是今天这节课的重点了。首先遍历配置文件中的deploy.connections，明确我们要在哪几个远端节点中进行部署；然后对每个远端服务创建一个ssh.Client，由于前面已经写好了SSH服务，所以直接使用GetClient方法就能为每个节点创建一个sshClient了：</p><pre><code class="language-go">for _, node := range deployNodes {\n   sshClient, err := sshService.GetClient(ssh.WithConfigPath(node))\n   if err != nil {\n      return err\n   }\n   ...\n}\n</code></pre><p>接下来就要执行命令了，那怎么执行前置或者后置命令呢？</p><p>我们需要为每个命令创建一个session，然后使用session.CombinedOut来输出这个命令的结果，把每个命令的结果都输出在控制台中。相关代码如下：</p><pre><code class="language-go">for _, action := range preActions {\n   // 创建session\n   session, err := sshClient.NewSession()\n   if err != nil {\n      return err\n   }\n   // 执行命令，并且等待返回\n   bts, err := session.CombinedOutput(action)\n   if err != nil {\n      session.Close()\n      return err\n   }\n   session.Close()\n   \n   // 执行前置命令成功\n   logger.Info(context.Background(), "execute pre action", map[string]interface{}{\n      "cmd":        action,\n      "connection": node,\n      "out":        strings.ReplaceAll(string(bts), "\\n", ""),\n   })\n}\n</code></pre><p>执行了前置命令之后，下面就是要把部署文件夹中的文件上传到目标服务器了。如何通过SSH服务将文件上传到目标服务器呢？</p><p>这里需要使用到一个成熟的第三方库 <a href="https://github.com/pkg/sftp">sftp</a> 了，目前已经有1.1k star，采用BSD-2的开源协议，允许修改商用，但是要保留申明。这个库就是封装SSH的，将SFTP文件传输协议封装了一下。SFTP是什么？它是基于SSH协议来进行文件传输的一个协议，功能与FTP相似，区别就是它的连接通道使用SSH。</p><p>SFTP的底层连接实际上就是SSH，只是把传输的文件内容进行了一下加密等工作，增加了传输的安全性。所以<strong>SFTP本质就是“使用SSH连接来完成文件传输功能”</strong>。这点可以从它的实例化看出，sftp.Client的唯一参数就是ssh.Client。</p><pre><code class="language-go">client, err := sftp.NewClient(sshClient)\nif err != nil {\n   return err\n}\n</code></pre><p>SFTP这个库，在初始化sftp.Client之后，会将这个client封装地和官方的本地操作文件OS库一样，你在使用sftp.Client的时候完全没有障碍。</p><p>比如，OS库创建一个文件是os.Create，在SFTP中就是使用client.Create；OS库获取一个文件信息的函数是os.Stat，在SFTP中就是client.Stat。但是注意下，这里完全是SFTP刻意将这个库函数设计的和OS库一样的，它们之间并没有什么嵌套关系。</p><p>我们使用ssh.Client初始化一个sftp.Client之后，写一个uploadFolderToSFTP的函数来实现将本地文件夹同步到远端文件夹：</p><pre><code class="language-go">// 上传部署文件夹\nfunc uploadFolderToSFTP(container framework.Container, localFolder, remoteFolder string, client *sftp.Client) error {\n    logger := container.MustMake(contract.LogKey).(contract.Log)\n    // 遍历本地文件\n    return filepath.Walk(localFolder, func(path string, info os.FileInfo, err error) error {\n        // 获取除了folder前缀的后续文件名称\n        relPath := strings.Replace(path, localFolder, "", 1)\n        if relPath == "" {\n            return nil\n        }\n        // 如果是遍历到了一个目录\n        if info.IsDir() {\n            logger.Info(context.Background(), "mkdir: "+filepath.Join(remoteFolder, relPath), nil)\n            // 创建这个目录\n            return client.MkdirAll(filepath.Join(remoteFolder, relPath))\n        }\n\n        // 打开本地的文件\n        rf, err := os.Open(filepath.Join(localFolder, relPath))\n        if err != nil {\n            return errors.New("read file " + filepath.Join(localFolder, relPath) + " error:" + err.Error())\n        }\n        // 检查文件大小\n        rfStat, err := rf.Stat()\n        if err != nil {\n            return err\n        }\n        // 打开/创建远端文件\n        f, err := client.Create(filepath.Join(remoteFolder, relPath))\n        if err != nil {\n            return errors.New("create file " + filepath.Join(remoteFolder, relPath) + " error:" + err.Error())\n        }\n\n        // 大于2M的文件显示进度\n        if rfStat.Size() &gt; 2*1024*1024 {\n            logger.Info(context.Background(), "upload local file: "+filepath.Join(localFolder, relPath)+\n                " to remote file: "+filepath.Join(remoteFolder, relPath)+" start", nil)\n            // 开启一个goroutine来不断计算进度\n            go func(localFile, remoteFile string) {\n                // 每10s计算一次\n                ticker := time.NewTicker(2 * time.Second)\n                for range ticker.C {\n                    // 获取远端文件信息\n                    remoteFileInfo, err := client.Stat(remoteFile)\n                    if err != nil {\n                        logger.Error(context.Background(), "stat error", map[string]interface{}{\n                            "err":         err,\n                            "remote_file": remoteFile,\n                        })\n                        continue\n                    }\n                    // 如果远端文件大小等于本地文件大小，说明已经结束了\n                    size := remoteFileInfo.Size()\n                    if size &gt;= rfStat.Size() {\n                        break\n                    }\n                    // 计算进度并且打印进度\n                    percent := int(size * 100 / rfStat.Size())\n                    logger.Info(context.Background(), "upload local file: "+filepath.Join(localFolder, relPath)+\n                        " to remote file: "+filepath.Join(remoteFolder, relPath)+fmt.Sprintf(" %v%% %v/%v", percent, size, rfStat.Size()), nil)\n                }\n            }(filepath.Join(localFolder, relPath), filepath.Join(remoteFolder, relPath))\n        }\n\n        // 将本地文件并发读取到远端文件\n        if _, err := f.ReadFromWithConcurrency(rf, 10); err != nil {\n            return errors.New("Write file " + filepath.Join(remoteFolder, relPath) + " error:" + err.Error())\n        }\n        // 记录成功信息\n        logger.Info(context.Background(), "upload local file: "+filepath.Join(localFolder, relPath)+\n            " to remote file: "+filepath.Join(remoteFolder, relPath)+" finish", nil)\n        return nil\n    })\n}\n</code></pre><p>这段代码长一点。首先我们使用功能filePath.Walk来遍历本地文件夹中的所有文件，如果遍历到的是子文件夹，就创建子文件夹，否则的话，我们就将本地文件上传到远端。而上传远端的操作大致就是三步：打开本地文件、打开远端文件、将本地文件传输到远端文件。</p><p>在上述函数中大致是这几句代码：</p><pre><code class="language-go">// 打开本地的文件\nrf, err := os.Open(filepath.Join(localFolder, relPath))\n\n// 打开/创建远端文件\nf, err := client.Create(filepath.Join(remoteFolder, relPath))\n\n// 将本地文件并发读取到远端文件\nif _, err := f.ReadFromWithConcurrency(rf, 10); err != nil \n</code></pre><p>SFTP提供了并发读取到远端文件ReadFromWithConcurrency的方法，我们可以使用这个并发读的方法提高上传效率。</p><p>但是即使是并发读，对于比较大的文件，还是需要等候比较长的时间。而这个等待时长，对于在控制台敲下部署命令的使用者来说是非常不友好的。我们希望能<strong>每隔一段时间显示一下当前的部署进度</strong>，这个怎么做呢？</p><p>这里我们设计大于2M的文件，执行这个操作。2M是我自己实验出来体验比较差的一个阈值。然后每2s就打印一下当前进度，所以使用了一个ticker，来计算时间。每次这个ticker结束的时候，计算一下远端文件的大小，再计算一下本地文件的大小。两者相除就是这个文件的上传进度，再使用日志打印就能打印出具体的进度了。</p><p>最后的效果如下：<br>\n<img src="https://static001.geekbang.org/resource/image/08/4e/088379171caf4131231de7d635b6e34e.png?wh=1920x157" alt=""></p><p>到这里部署前端的代码就开发完成了。</p><h3>部署后端</h3><p>理解了如何部署前端，部署后端的对应方法基本如出一辙。唯一不同的地方就是编译。</p><p>编译Golang的后端需要指定对应的编译平台和编译CPU架构，就是前面说的GOOS和GOARCH。所以我们就不能直接使用build命令来编译后端了。改成定位go程序，来执行go build，并且需要修改输出文件路径，输出到部署文件夹中。</p><p>当然这个部署文件夹还是按照我们之前的设计为 deploy/xxxxxx，其中的xxxx直接设置为细化到秒的时间，继续在framework/command/deploy.go中写入：</p><pre><code class="language-go">// 编译后端\npath, err := exec.LookPath("go")\nif err != nil {\n   log.Fatalln("hade go: 请在Path路径中先安装go")\n}\n   // 组装命令\ndeployBinFile := filepath.Join(deployFolder, binFile)\ncmd := exec.Command(path, "build", "-o", deployBinFile, "./")\ncmd.Env = os.Environ()\n   // 设置GOOS和GOARCH\nif configService.GetString("deploy.backend.goos") != "" {\n   cmd.Env = append(cmd.Env, "GOOS="+configService.GetString("deploy.backend.goos"))\n}\nif configService.GetString("deploy.backend.goarch") != "" {\n   cmd.Env = append(cmd.Env, "GOARCH="+configService.GetString("deploy.backend.goarch"))\n}\n   // 执行命令\nctx := context.Background()\nout, err := cmd.CombinedOutput()\nif err != nil {\n   logger.Error(ctx, "go build err", map[string]interface{}{\n      "err": err,\n      "out": string(out),\n   })\n   return err\n}\nlogger.Info(ctx, "编译成功", nil)\n</code></pre><p>同时除了生成二进制文件，还要记得把.env文件（如果有的话）、config目标文件传递到本地的部署目录：</p><pre><code class="language-go">// 复制.env\nif util.Exists(filepath.Join(appService.BaseFolder(), ".env")) {\n   if err := util.CopyFile(filepath.Join(appService.BaseFolder(), ".env"), filepath.Join(deployFolder, ".env")); err != nil {\n      return err\n   }\n}\n\n// 复制config文件\ndeployConfigFolder := filepath.Join(deployFolder, "config", env)\nif !util.Exists(deployConfigFolder) {\n   if err := os.MkdirAll(deployConfigFolder, os.ModePerm); err != nil {\n      return err\n   }\n}\nif err := util.CopyFolder(filepath.Join(appService.ConfigFolder(), env), deployConfigFolder); err != nil {\n   return err\n}\n</code></pre><p>自动化部署后端的命令，除了以上的编译文件到部署目录之外，其他部分都和自动化部署前端的命令一致：</p><pre><code class="language-go">// deployBackendCommand 部署后端\nvar deployBackendCommand = &amp;cobra.Command{\n   Use:   "backend",\n   Short: "部署后端",\n   RunE: func(c *cobra.Command, args []string) error {\n      container := c.GetContainer()\n\n      // 创建部署文件夹\n      deployFolder, err := createDeployFolder(container)\n      if err != nil {\n         return err\n      }\n\n      // 编译后端到部署文件夹\n      if err := deployBuildBackend(c, deployFolder); err != nil {\n         return err\n      }\n\n      // 上传部署文件夹并执行对应的shell\n      return deployUploadAction(deployFolder, container, "backend")\n   },\n}\n</code></pre><h3>部署全部</h3><p>而对于同时部署前后端命令，其实就是在编译阶段，把前端和后端同时进行编译，并且最终上传部署文件夹。同样放在framework/command/deploy.go：</p><pre><code class="language-go">var deployAllCommand = &amp;cobra.Command{\n   Use:   "all",\n   Short: "全部部署",\n   RunE: func(c *cobra.Command, args []string) error {\n      container := c.GetContainer()\n\n      deployFolder, err := createDeployFolder(container)\n      if err != nil {\n         return err\n      }\n\n      // 编译前端\n      if err := deployBuildFrontend(c, deployFolder); err != nil {\n         return err\n      }\n\n      // 编译后端\n      if err := deployBuildBackend(c, deployFolder); err != nil {\n         return err\n      }\n\n      // 上传前端+后端，并执行对应的shell\n      return deployUploadAction(deployFolder, container, "all")\n   },\n}\n</code></pre><h3>部署回滚</h3><p>最后就是部署回滚操作，主要明确一下需要传递的参数：</p><p>一个是回滚版本号。这个版本号就是我们的部署目录的名称，前面说过部署目录为deploy/xxxxxx，xxxx设置为细化到秒的时间。比如20211110233354，表示是我们2021年11月10日23点33分54秒创建的版本。</p><p>另外一个就是标记希望回滚前端，还是后端，还是全部回滚。这里主要涉及执行前端的回滚命令，还是执行后端的回滚命令。</p><p>这两个参数我们直接以参数形式，跟在deploy rollback命令之后，如下：</p><pre><code class="language-go">&nbsp;./hade deploy rollback 20211110233354 backend\n</code></pre><p>明确了参数，它的具体实现就很简单了，因为它没有任何的编译过程，我们只需要把回滚版本所在目录的编译结果，上传到目标服务器就可以了，同样，我们把这个命令放在framework/command/deploy.go中：</p><pre><code class="language-go">// deployRollbackCommand 部署回滚\nvar deployRollbackCommand = &amp;cobra.Command{\n   Use:   "rollback",\n   Short: "部署回滚",\n   RunE: func(c *cobra.Command, args []string) error {\n      container := c.GetContainer()\n\n      if len(args) != 2 {\n         return errors.New("参数错误,请按照参数进行回滚 ./hade deploy rollback [version] [frontend/backend/all]")\n      }\n\n      version := args[0]\n      end := args[1]\n\n      // 获取版本信息\n      appService := container.MustMake(contract.AppKey).(contract.App)\n      deployFolder := filepath.Join(appService.DeployFolder(), version)\n\n      // 上传部署文件夹并执行对应的shell\n      return deployUploadAction(deployFolder, container, end)\n   },\n}\n</code></pre><p>到这里四个自动化部署命令就都开发完成。我们来验证一下。</p><h2>验证</h2><p>要验证部署命令，我们当然需要有一个目标部署服务器，这是我设置的web-01服务器配置，在config/development/ssh.yaml中：</p><pre><code class="language-yaml">timeout: 3s\nnetwork: tcp\nweb-01:\n    host: 111.222.333.444 # ip地址\n    port: 22 # 端口\n    username: yejianfeng # 用户名\n    password: "123456" # 密码\n</code></pre><p>而在config/development/deploy.yaml中我的配置如下：</p><pre><code class="language-yaml">connections: # 要自动化部署的连接\n    - ssh.web-01\n\nremote_folder: "/home/yejianfeng/coredemo/"  # 远端的部署文件夹\n\nfrontend: # 前端部署配置\n    pre_action: # 部署前置命令\n        - "pwd"\n    post_action: # 部署后置命令\n        - "pwd"\n\nbackend: # 后端部署配置\n    goos: linux # 部署目标操作系统\n    goarch: amd64 # 部署目标cpu架构\n    pre_action: # 部署前置命令\n        - "rm /home/yejianfeng/coredemo/hade"\n    post_action: # 部署后置命令\n        - "chmod 777 /home/yejianfeng/coredemo/hade"\n        - "/home/yejianfeng/coredemo/hade app restart"\n</code></pre><p>重点看后端部署配置。在部署后端之前，我们先运行一个rm 命令来将旧的hade二进制进程删除，然后部署后端文件，其中包括这个二进制进程。最后执行了两个命令，一个是chmod命令，保证上传上去的二进制进程命令可以执行；第二个就是./hade app restart命令，能将远端的命令启动。</p><p>这里就演示下部署后端服务  <code>./hade deploy backend</code> ，输出结果如下：<br>\n<img src="https://static001.geekbang.org/resource/image/14/ac/14915cb398646c747875c4860e01b6ac.png?wh=1920x440" alt=""><br>\n<img src="https://static001.geekbang.org/resource/image/2e/bb/2e70470a5e55e864aeea7e920e1eaabb.png?wh=1920x283" alt=""></p><p>我们看到，它成功地编译后端服务，到目标文件夹deploy/20211110233533， 并且上传了编译的hade命令，在远端启动了进程。</p><p>接着验证下回滚命令。在之前已经发布过版本 20211110233354 了。所以这里直接运行命令  <code>./hade deploy rollback 20211110233354 backend</code> 将版本回滚到 20211110233354。<br>\n<img src="https://static001.geekbang.org/resource/image/fc/78/fc3280cfd8813169970f8d91c11f6578.png?wh=1920x403" alt=""><br>\n<img src="https://static001.geekbang.org/resource/image/89/90/89390e826834862981bb94344dcfb090.png?wh=1920x297" alt=""></p><p>验证成功！</p><p>本节课我们对framework下的provider、contract、command目录都有修改。目录截图如下，供你对比查看，所有代码都已经上传到<a href="https://github.com/gohade/coredemo/tree/geekbang/28">geekbang/28</a>分支了。<br>\n<img src="https://static001.geekbang.org/resource/image/d8/0b/d89d6aaf4f25fab54dec747ef0f4700b.jpg?wh=2187x1292" alt=""></p><h2>小结</h2><p>今天我们实现了将代码自动化部署到Web服务器的机制。为了实现这个自动化部署，先实现了一个SSH服务，然后定制了一套自动化部署命令，包括部署前端、部署后端、部署全部和部署回滚。</p><p>虽然说这个由框架负责的自动化部署机制在大项目中可能用不上，毕竟现在大项目都采用Docker化和k8s部署了。不过对于小型项目，这种部署机制还是有其便利性的。所以我们的hade框架还是决定提供这个机制。</p><p>在实现这个机制的过程中，要做到熟练掌握Golang对于SSH、SFTP等库的操作。基本上这两个库的操作你熟悉了，就能在一个程序中同时自动化操作多个服务器了。在实际工作中，如果遇到类似的需求，可以按照这节课所展示的技术来自动化你的需求。</p><h3>思考题</h3><p>其实今天的内容涉及自动化运维的范畴了，我们就布置一个课外研究吧。自动化运维范畴中有一个很出名的自动化运维配置框架ansible，你可以去浏览下<a href="https://ansible-tran.readthedocs.io/en/latest">Ansible中文权威指南</a>网站，学习一下ansible有哪些功能，分享一下你的学习心得。</p><p>欢迎在留言区分享你的思考。感谢你的收听，如果你觉得今天的内容对你有所帮助，也欢迎分享给你身边的朋友，邀请他一起学习。我们下节课见。</p>',
        article_title: "28｜SSH：如何生成发布系统让框架发布自动化？",
      },
      {
        title: "29｜周边：框架发布和维护也是重要的一环",
        id: 447331,
        content:
          '<p>你好，我是轩脉刃。</p><p>终于来到框架设计与完善的最后一节课了。在前面的章节中，我们基本上把框架的功能都开发完成了，但是这只是万里长征的第一步。一个工业级的Web框架一定是经过长时间千锤百炼的迭代升级的。在这门课编写完成的时候，我为hade框架锁定了v 1.0.0版本，后续我们会继续为框架增加更多的功能和特性。</p><p>那么随着框架的不断更新和升级，随之而来的问题就是如何为一个开源项目设计一套发布和使用机制，并且为每个发布版本维护一套准确的框架说明文档？这就是我们今天要讨论的内容。</p><h3>版本</h3><p>每个框架发布都需要有一个版本号，这个版本号如何定义，我们在前面的课程中已经不止一次提到过了，这里再正式说明一下。</p><p>所有开源软件的版本号基本上都遵循“<a href="https://semver.org/lang/zh-CN">语义化版本规范</a>”的约定，这份语义化版本规范是由Gravatars 创办者兼 GitHub 共同创办者&nbsp;Tom Preston-Werner&nbsp;所建立的，它定义了三段式的版本规范，格式如下：</p><pre><code class="language-plain">主版本号.次版本号.修订号\n</code></pre><p>我们使用的Golang语言项目也是基于这个规范来实现的。</p><p><strong>主版本号代表如果做了不兼容的API修改</strong>。比如在你的项目中，原先提供的A方法要替换为B方法，所有的参数和返回值都已经变化了，你的使用方必须修改他的代码，这个变动就叫做“不兼容的API修改”。这个时候，主版本号就必须更新了。</p><!-- [[[read_end]]] --><p><strong>次版本号表示当你做了向下兼容的功能性新增</strong>。比如原先你的类中只有A方法，当你新增了一个B方法，但是并不修改原先的A方法，这个时候你的类有A、B两个方法。原先的库使用者并不需要更新他的任何代码，这就是“向下兼容的功能性新增”。这个时候，你不需要更新主版本号，只需要更新次版本号就行。</p><p><strong>修改号，表示当你做了向下兼容的问题修正</strong>。比如原先类中只有A方法，你并没有更新任何的功能，只是修改了A方法中的一个bug，那么这个时候，不需要更新主版本号和次版本号，直接更新修订版本号就行。</p><p>这个语义化版本规范，基本上已经是开源届的共识了，当然也可以不遵循这个规范，但是一旦不遵循，对你开源项目的使用者来说绝对是一个灾难性的事情，进而你的项目也逐渐会失去使用者。</p><p>我们使用的Go语言版本就是严格遵循这个规范的。比如现在使用的Golang版本为1.17.2。主版本为1，次版本为17，修改号为2。基本上我们接触Golang都是从1.0.0之后开始的，目前Go还没发布2.0.0，所以1.0之后的Go版本升级都是向下兼容的。如果有做过Go升级的同学可以思考下，在升级的时候，业务代码有没有做任何变动。</p><p>另外再附带说一下，你也有可能在网络上看到版本号不止三个的，比如1.2.3.4，或者 1.2.3.beta。这些都是对这个语义化规范的扩展使用而已，最后一个字段根据不同的项目可能有不同的意思，比如是否是发行版本。不过前三个版本号都是遵循这个版本规范的。所以见到这些扩展版本号不要吃惊。</p><p>我们的hade框架当然也要基于这个版本规范，在这门课程更新完成之后，我会把这门课程的所有代码锁定为一个发布版本1.0.0，并且从这个版本开始继续迭代更新功能。有新的功能和模块增加，我们会升级次版本号，有任何的bug修复，就升级修订版本号。</p><h3>发布</h3><p>明确了hade的版本号规范之后，要明确我们的发布模式，这个在前面的<a href="https://time.geekbang.org/column/article/435534">第22节课</a>开发自动化脚手架已经简单说过了，这里再正式说明一下。</p><p>我们的框架最终在GitHub上的地址为：<a href="https://github.com/gohade/hade">https://github.com/gohade/hade</a> ，会至少为每一个次版本号打上release版本。<br>\n<img src="https://static001.geekbang.org/resource/image/ca/75/caec1bcef876ba937a5eacf036e58975.png?wh=1920x1025" alt=""></p><p>而对于框架的使用者来说，使用步骤会是这样的。首先需要在工作机器上安装hade命令，我们可以在任何路径调用：</p><pre><code class="language-go">go install github.com/gohade/hade@latest\n</code></pre><p>来安装hade命令。这个hade命令，其实用任何版本都是可以的，这里直接选用最新版本。<br>\n调用了go install 之后，hade命令就被安装到你的$GOPATH/bin目录下了。直接调用 <code>$GOPATH/bin/hade</code> 可以看到安装好的hade命令。<br>\n<img src="https://static001.geekbang.org/resource/image/b8/c0/b8eec8f059ac82a5a5f1de6657dba7c0.png?wh=1920x1172" alt=""></p><p>然后使用 <code>hade new</code> 命令创建一个项目，比如为hellohade。我们可以看到创建出了目标文件夹hellohade。<br>\n<img src="https://static001.geekbang.org/resource/image/c4/fc/c4de7585ff0c36e79ef038bcdf952bfc.png?wh=1920x1312" alt=""></p><p>进入目标文件夹 <code>cd hellohade</code> ，调用  <code>go mod tidy</code> 下载所有的依赖包，调用  <code>go build</code> 编译目录。<br>\n<img src="https://static001.geekbang.org/resource/image/03/92/030ec01edf75260c35782db1413ed192.png?wh=1566x1044" alt=""><br>\n接下来，使用者就可以在这个目标文件夹中开始基于hade开发应用了。<br>\n<img src="https://static001.geekbang.org/resource/image/ea/8e/ea74acc44f15623d50dd4608e1cyy48e.png?wh=1920x1320" alt=""></p><h2>文档维护</h2><p>到这里，我们把框架的版本和发布的流程梳理清楚了。但是随着版本不断迭代更新，框架对应的说明文档也是需要不断更新的，这就涉及框架文档的编写和搭建了。</p><p>对于一个开源项目，说明文档的查看渠道是多种多样的。</p><p>对于比较小型的项目和类库，一般都会选择直接使用markdown来编写。比如我们在之前用到的 <a href="https://github.com/sevlyar/go-daemon">go-daemon</a> 库，功能比较简单，就是创建一个daemon进程，它的使用方式也比较简单，所以，作者就在项目GitHub地址的 README.md 中写所有信息的使用文档了。</p><p>而对于比较大型的项目，大多数项目都会自己开启一个官方网站，来说明项目的各种使用方法，比如<a href="https://github.com/go-gorm/gorm">gorm </a>项目，这个库封装的函数多种多样，所以作者单独创建了一个<a href="https://gorm.io/zh_CN/docs/index.html">网站</a>来列出对gorm项目的说明。</p><p>使用网站来展示项目使用文档有一个额外工作，就是当版本升级的时候，要同时升级官方文档。否则的话，使用者就会经常遇到看旧文档、使用新框架的情况，而导致错误的用法。所以必须及时维护代码和文档的一致性。</p><p>那有没有办法将这两者结合一下呢？我们使用markdown编写说明文档，然后如果能自动将这些markdown文档转化为HTML网站，再将网站部署到服务器上，那就完美了。</p><p>确实是有这样的工具的，<a href="https://vuepress.vuejs.org/zh/guide">vuepress</a>。vuepress是一个Vue工具，基于Vue框架生成了一个vuepress的命令行工具，这个工具能将指定的markdown文件转化为HTML文件，而这个HTML文件是可以直接被使用者访问的。</p><p><strong>vuepress的编译需要两个目录，存放markdown的目录和生成HTML的目标目录</strong>。vuepress是基于Vue的，正好hade框架也已经融合了Vue。所以自然可以想到，直接将存放markdown的目录放在hade框架地址上，然后将生成HTML的目标目录定义为我们的dist目录。这样，就可以在hade框架上使用npm工具来生成HTML了。</p><h2>编写markdown</h2><p>于是我们在根目录下创建docs目录，存放编写的markdown文件。</p><p>这里框架说明的markdown文件我都事先编写完成，也存放在GitHub上了，你可以比对查看。vuepress的markdown文件格式，编写并没有什么特别，只需要你多阅读尝试，心里对哪种格式最终的页面展现是什么样子有理解就行。</p><p>比如想要首页的展示形式是这样：<br>\n<img src="https://static001.geekbang.org/resource/image/ca/2f/cae7c6eb3fc8971f5e4534538e78232f.png?wh=1920x589" alt=""></p><p>它对应的markdown为dos/README.md：</p><pre><code class="language-markdown">---\nhome: true\nactionText: 开始体验\nactionLink: /guide/introduce\nfooter: MIT Licensed | Copyright © 2020-present jianfengye\nfeatures:\n  - title: 基于协议 \n    details: 服务与服务间的协议是基于协议进行交互的。\n  - title: 前后端协同 \n    details: 前后端协同开发 \n  - title: 命令行 \n    details: 有充分的命令行工具 \n  - title: 集成定时服务\n    details: 如果你需要启动定时服务，提供命令进行定时服务的启动 \n  - title: 文档丰富 \n    details: 提供丰富的文档说明，提供丰富的文档说明 \n  - title: 开发模式\n    details: 在开发模式下进行前后端开发，极大提高了开发效率和开发体验\n</code></pre><p>根据vuepress的官方文档，我们需要在docs目录下创建一个.vuepress/config.js ，来给vuepress工具阅读，也就是用来告诉vuepress工具，你需要按照这个配置的信息生成HTML文件。这里的所有配置都在<a href="https://vuepress.vuejs.org/zh/config">官网</a>有说明。</p><p>我们的config.js的配置如下：</p><pre><code class="language-javascript">module.exports = {\n    title: "hade框架", // 设置网站标题\n    description: "一个支持前后端开发的基于协议的框架", //描述\n    dest: "./dist/", // 设置输出目录\n    port: 2333, //端口\n    base: "/v1.0/",\n    head: [["link", {rel: "icon", href: "/assets/img/head.png"}]],\n    themeConfig: {\n        //主题配置\n        // logo: "/assets/img/head.png",\n        // 添加导航栏\n        nav: [\n            {text: "主页", link: "/"}, // 导航条\n            {text: "使用文档", link: "/guide/"},\n            {text: "服务提供者", link: "/provider/"},\n            {\n                text: "github",\n                // 这里是下拉列表展现形式。\n                items: [\n                    {\n                        text: "hade",\n                        link: "https://github.com/gohade/hade",\n                    },\n                ],\n            },\n        ],\n        // 为以下路由添加侧边栏\n        sidebar: {\n            "/guide/": [\n                {\n                    title: "指南",\n                    collapsable: false,\n                    children: [\n                        "introduce",\n                        "install",\n                        "build",\n                        "structure",\n                        "app",\n                        "env",\n                        "dev",\n                        "command",\n                        "cron",\n                        "middleware",\n                        "swagger",\n                        "provider",\n                        "todo",\n                    ],\n                },\n            ],\n            "/provider/": [\n                {\n                    title: "服务提供者",\n                    collapsable: false,\n                    children: [\n                        "app",\n                        "env",\n                        "config",\n                        "log",\n                    ],\n                },\n            ],\n        },\n    },\n};\n\n</code></pre><p>说明下几个重点配置项。</p><p>dest这个配置项指定了我们生成HTML的目标文件夹，这里定义为dist目录。base代表所有页面的访问前缀，我们定义为和版本号一致的/v1.0/。这样设置最终会有什么效果呢？</p><p>由于hade会有多个版本，而我们希望访问地址的URL中带着版本信息，这样就能通过URL来访问不同的版本信息。比如hade.funaio.cn/v1.0/，访问v1.0的版本信息；hade.funaio.cn/v1.1/ 访问v1.1的版本信息。所以使用/v1.0/的base，能让所有的访问信息都带上这个前缀，就能访问到不同版本的框架信息了。</p><p>themeConfig.nav是配置导航栏的，我们的导航栏有四个信息。<br>\n<img src="https://static001.geekbang.org/resource/image/f7/59/f72cd0a32e3d76bf5b67798dbe495e59.png?wh=318x52" alt=""></p><p>所以在themeConfig.nav中需要定义四个子项，子项目的text表示显示文本，而link表示点击这个文本之后的链接地址。比如：</p><pre><code class="language-javascript">{text: "使用文档", link: "/guide/"},\n</code></pre><p>表示“使用文档”这个文本点击之后，会查找/guide/目录下的README文件。</p><p>而/guide/目录下的所有文件是通过themeConfig.sidebar设置侧边栏的，也就是刚才代码的第29到47行。最终通过这段的设置，点击首页的“使用文档”链接，就会进入如下的效果：<br>\n<img src="https://static001.geekbang.org/resource/image/c7/16/c72c2edcdc7f4ed9abe098a3285ae016.png?wh=1308x638" alt=""><br>\n左边的每个链接都对应docs/guide/中的每个markdown文件。</p><h3>生成HTML</h3><p>docs下的markdown文件都编写完成了，下面我们就安装vuepress并且生成HTML。安装vuepress，只需要使用npm命令：</p><pre><code class="language-go">npm install -D vuepress\n</code></pre><p>就能安装最新版本的vuepress。截止11月13日，目前vuepress的2.0还处在beta版本，最稳定版本是1.8.2。在安装过程中你可能会遇到这个错误：</p><pre><code class="language-plain">TypeError: Cannot read property \'createHash\' of undefined\n</code></pre><p>这个错误是提示我们的Webpack版本较低，使用命令升级Webpack就行。</p><pre><code class="language-plain">npm i webpack@4.8.3\n</code></pre><p>安装好vuepress之后，我们就可以在package.json中设置vuepress的调试和编译命令了：</p><pre><code class="language-go">{\n    "name": "hade",\n    ...\n    "scripts": {\n        ...\n        "docs:dev": "vuepress dev docs",\n        "docs:build": "vuepress build docs"\n    },\n</code></pre><p>增加了docs:dev 和 docs:build 来运行vuepress。</p><p>这里我们使用  <code>npm run docs:build</code> ，就能生成对应markdown的HTML了，非常方便。<br>\n<img src="https://static001.geekbang.org/resource/image/85/37/85a2882ca4500282f43d23110fc07537.png?wh=698x518" alt=""></p><p>可以看到dist目录中已经生成了对应的HTML文件：<br>\n<img src="https://static001.geekbang.org/resource/image/f0/9b/f0671ba855661eb73fb4c4a49f65ed9b.png?wh=321x168" alt=""></p><p>最后将这个HTML文件部署到Web服务器中。这里我们部署在目标服务器的的/webroot/hade_doc/dist_1.0目录中。具体部署方法也没有什么难点，通过FTP或者SETP上传dist目录内容到目标目录即可。</p><p>我们的目标服务器配置的Web服务器为Nginx，Nginx如何配置，你可以参考：</p><pre><code class="language-plain">&nbsp; &nbsp; server {\n&nbsp; &nbsp; &nbsp; &nbsp; server_name&nbsp; hade.funaio.cn;\n&nbsp; &nbsp; &nbsp; &nbsp; access_log&nbsp; logs/hade.access.log&nbsp; main;\n&nbsp; &nbsp; &nbsp; &nbsp; error_log&nbsp; logs/hade.error.log ;\n\n&nbsp; &nbsp; &nbsp; &nbsp; location /v1.0/ {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; alias /webroot/hade_doc/dist_1.0/;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; index&nbsp; index.html index.htm;\n&nbsp; &nbsp; &nbsp; &nbsp; }\n\n&nbsp; &nbsp; &nbsp; &nbsp; location / {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; root&nbsp; &nbsp;/webroot/hade_doc/dist_1.0/;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; index&nbsp; index.html index.htm;\n&nbsp; &nbsp; &nbsp; &nbsp; }\n&nbsp; &nbsp; }\n</code></pre><p>配置hade.funaio.cn/v1.0/ 来访问目录路径 /webroot/hade_doc/dist_1.0/ ，同时hade.funaio.cn/也是访问/webroot/hade_doc/dist_1.0/。</p><p>这样每次我们的版本有更新的时候，创建一个新的目标目录存放这个版本的HTML，比如 /webroot/hade_doc/dist_1.1/。而在nginx上，只需要增加一个路径/v1.1/来提供hade.funaio.cn/v1.1/的访问路径，让使用者访问v1.1的文档。</p><p>于是，我们hade框架的网站文档：<a href="http://hade.funaio.cn">http://hade.funaio.cn</a> 就正式搭建起来了。<br>\n<img src="https://static001.geekbang.org/resource/image/c2/6c/c235a8ce622fdfa33e6dc382bfac566c.png?wh=1920x855" alt=""></p><p>看到这里，相信你应该理解了，我们的文档维护是基于hade项目中自带的docs/ 目录下的markdown 来进行的。你可以通过GitHub上的<a href="https://github.com/gohade/coredemo/blob/geekbang/29/README.md">markdown</a> 来查看框架文档，也可以通过网站 hade.funaio.cn 来查看框架文档。这两者本质上都是通过markdown来编写的。</p><p>而markdown会随着hade框架的发布而发布，同时网站也是根据markdown生成的。这种方法既能避免文档和框架不一致的问题，又能大大降低维护网站的成本。</p><p>这节课我们没有修改框架的Go代码，主要创建了包含markdown文件的docs目录。目录截图放在这里供你你参考。所有代码也同步到了<a href="https://github.com/gohade/coredemo/tree/geekbang/29">geekbang/29</a> 分支上了。<br>\n<img src="https://static001.geekbang.org/resource/image/c0/25/c0c15e07407e6a7102913446ed46b725.png?wh=361x670" alt=""></p><h2>小结</h2><p>今天我们为框架的升级和维护设计了一套完整的方案。hade框架的发布和文档维护都有自己的独特设计，比如框架的发布，直接和hade框架的命令行工具进行了关联，只要发布了一个新版本，使用者就能直接用命令行工具使用这个新版本创建一个脚手架。而文档维护，是通过编写markdown以及hade框架已经集成的Vue，来自动生成网站HTML。</p><p>截止到这节课，hade框架的功能就开发完毕了，GitHub上的coredemo项目也就不再更新了，之前的所有代码，我们都会移动到真正的hade项目的 <a href="https://github.com/gohade/hade">https://github.com/gohade/hade</a> 地址，并且我们为代码发布了发布版本：v1.0.0，后续会基于这个版本不断迭代更新，如果你有兴趣，欢迎一起来完善这个框架。</p><h3>思考题</h3><p>马上我们会进入实战环节，使用hade框架开发具体应用，会使用到Vue和Element-UI的知识，当然在后面我们也会稍微介绍一些前端知识，不过如果你之前完全没有接触过，可以花一些时间预习一下，这样学习的时候才能事半功倍。</p><p>所以今天就给你分享一些相关资料：</p><ul>\n<li><a href="https://cn.vuejs.org/index.html">vue中文官网</a>，学习Vue必看内容</li>\n<li><a href="https://element.eleme.io/#/zh-CN">element-ui官网</a>，一款快速搭建网站的UI框架，目前国内最火</li>\n<li><a href="https://github.com/rumengkai/awesome-vue">awesome-vue</a>，收集Vue的一些优秀开源项目，绝对收藏</li>\n<li><a href="https://router.vuejs.org/zh">vue router官网</a>，Vue的路由必备</li>\n<li><a href="https://v4.webpack.docschina.org/concepts">webpack官网</a>，Vue的打包工具</li>\n</ul><p>欢迎在留言区分享你的学习笔记。感谢你的收听，如果你觉得今天的内容对你有所帮助，也欢迎分享给你身边的朋友，邀请他一起学习。我们实战篇见。</p>',
        article_title: "29｜周边：框架发布和维护也是重要的一环",
      },
      {
        title: "大咖助阵｜大明：抽象，抽象，还是抽象",
        id: 443346,
        content:
          '<p>你好，我是大明。</p><p>之前我在极客时间的毛剑老师的Go进阶训练营里，为基础不太好的同学开了一个小课，主要是通过讲如何设计一个 Web 框架来带领学员一起巩固 Go 基础，侧重点在 Go 语法上，没有深入讨论设计本身以及设计理念。</p><p>但是，教会如何用一个框架是个很简单的问题，教会如何做抽象才是一个很难、但很有价值的问题。所以今天我想借这篇加餐的机会，围绕 Web 框架的设计，来分享一下我平时在做设计和落地时对抽象的一些体会。</p><p>在开始讨论之前，我们要先搞清楚一个问题：为什么抽象那么重要？</p><p>因为我认为，<strong>程序是人对现实世界的抽象的形式化描述</strong>。它包含两层含义：第一个含义是要先建立对现实世界抽象；第二个是能够将这个抽象落地为代码，也就是设计。因此，抽象是设计的前提。</p><p>通俗点就是，如果你不能正确认识问题，怎么奢求自己能够正确解决问题呢？所以，我们先稍微讨论一下 Web 框架，看看它背后对应的问题。</p><h2>Web 框架</h2><p>Web 框架要解决的问题是什么？处理 HTTP 请求。进一步细想，我们会想到具体如何处理请求，但这不是 Web 框架的事情，而是用户的事情。比如说用户登录的请求，Web 框架肯定是不知道如何处理的。</p><p>所以我们能够认识到，<strong>Web 框架主要负责：接收请求、找到用户处理逻辑调用一下、再把响应写回去。也就是三件事：接受请求、分发请求、写回响应</strong>。如果用伪代码来描述就是：</p><!-- [[[read_end]]] --><pre><code class="language-go">while:\n  req = next()\n  handler = findHandler(req)\n  response = handler.Handle(req)\n  write(respons)\n</code></pre><p>其中 Go 的 http/net 包帮我们解决了读取请求和写回输出的大部分工作，只剩下路由部分，即根据请求找到用户注册的处理方法，需要我们支持一下。这就是 Web 框架的核心，同时也是最难的地方。</p><p>但是你去看市面上大多数 Web 框架不仅仅只有这个基础功能，还有很多花里胡哨的东西。大致列举一下：</p><ul>\n<li>参数解析校验功能</li>\n<li>文件操作类，比如说上传、下载，或者作为静态资源服务器</li>\n<li>特定格式支持，比如说 JSON、XML 格式支持</li>\n<li>模板支持，主要是用于渲染页面</li>\n<li>AOP 解决方案</li>\n<li>…</li>\n</ul><p>一个框架一般不会在初期把所有都支持好，而是在逐步迭代的过程中，将功能补充上去。所以要求我们在设计框架之初，就要考虑到这一类的功能。但是并不需要提供实现，甚至连接口都不必设计得一步到位，只要藏好细节不暴露出去，后面可以轻易修改而不影响已有的用户。</p><p>所以简单总结下，一个Web框架要解决两大类的问题：</p><ul>\n<li>必须要解决的核心问题，在Web 框架里就是路由问题</li>\n<li>可解决可不解决的次级问题，也就是这里罗列的一大堆</li>\n</ul><p>问题搞清楚，我们再看怎么解决。其实，构建抽象就是解决问题的过程。</p><h2>如何构建抽象</h2><p>我们从前面的伪代码里面，基本上就可以抽取出来第一个也是最重要的抽象：</p><pre><code class="language-go">type Handler interface {\n   ServeHTTP(c *Context)\n   Routable\n}\n</code></pre><p>需要注意的是，这是我设计的接口。不同的人来设计，是可以不同的，只要都能表达这么一种抽象就可以。也就是，重要的是抽象，而抽象的表达形式是多样的。<br>\n<code>ServeHTTP</code> 精准描述了这个Web框架的主要责任，也准确界定了 Web 框架的边界，我称为核心抽象。</p><p>而组合进来的 Routable 接口实际上只是支撑接口，也就是去掉它并不妨碍我们用 <code>Handler</code> 来表达整个 Web 框架的主要责任。所以我把类似的东西称为次级抽象。</p><p><strong>次级抽象并不是描述了整个框架，而是描述了框架的一个方面。次级抽象一般用于支撑核心抽象的实现</strong>。显然，如果我们实现次级接口，自然可能会有支撑该实现的次次级接口。</p><p>因此整个框架的实现过程可以简化为：</p><ol>\n<li>构建抽象，提供实现</li>\n<li>为了特定实现，引入新的抽象</li>\n<li>为新的抽象提供实现</li>\n</ol><p>如此不断迭代，这种设计方式，我一般称为自顶向下的设计，从核心接口的抽象向外延伸。例如在这个 Web 框架里，为了实现 Handler 而引入 Routable，而在实现 Routable 的时候引入 node，它们之间的关系，大体上可以看作是一个同心圆。<br>\n<img src="https://static001.geekbang.org/resource/image/ea/26/eacyy0711c125e86b579c4a2de0a8e26.jpg?wh=1920x1080" alt=""></p><p>一般来说，越是接近核心的接口，越是稳定，缺点则是过于抽象以至于对普通用户来说毫无价值。甚至实现一个核心接口，难度差不多相当于重写整个框架了。</p><p>对应地，远离核心的接口，其抽象程度低，因此也就更加具体化。更加具体化，意味着好扩展，缺点则是表达性弱，只能表达很小的一个点。注重使用感的最外围的接口，大多数时候是框架设计者有意留出来给用户使用的，实现非常简单。</p><p>例如说，为了解决优雅退出，允许用户注册自己的清理动作，我引入了一个新的抽象：</p><pre><code class="language-go">type Hook func(ctx context.Context) error\n</code></pre><p>显而易见地，写一个 Hook 和写一个 Handler 的难度自然是差了好几个数量级。</p><p>到这里我们讨论了如何构建抽象，然而不管我们再怎么自信，都还有一个问题要解决，就是抽象不是一成不变的，随着业务发展，之前的抽象就可能不适用了，或者说至少某个部分不再适用了。因此我们总是要在设计的时候考虑变更的问题。</p><p>想写出能变更的代码，首先要考虑的就是，到底哪些地方要考虑变更？</p><h2>如何识别变更点</h2><p>识别变更，基本上，要么依赖于个人的经验，要么依赖于借鉴类似的框架。</p><p>借鉴这个办法很简单，所谓的太阳底下无新鲜事，在我们这一行尤其如此。大多数时候你都可以找到类似的产品，看看它们是如何设计的。这里就要强调一点，解决同一个问题的框架，它们落地为代码之后，都是千差万别的，<strong>所以借鉴，是要借鉴它们的抽象，而不是它们的代码</strong>。</p><p>此外就是要借鉴缺点，所谓的每与操反，事乃可成。</p><p>例如有的框架内置了处理静态资源的功能，但是该功能和框架的核心路由功能耦合在一起了，缺乏扩展性和可读性，还对用户重构核心功能造成了阻碍。这个设计就不是很好，我们自己设计Web框架功能的时候就可以借鉴这一点。我们可以写一个方法，就像用户写的普通业务方法，这样用户可以按类似用法注册一个路由启用这个功能，更方便。</p><p>我就重点说通过我多年个人经验总结的两个小技巧：假设法和替换法。</p><h3>假设法</h3><p>所谓假设法，就是找到自己实现过程中做的假设。最常见的假设就是，“产品说这个场景不需要考虑，所以我只需要这么做就可以了”，又或者“我觉得这么做就可以了，因为用户不可能需要xxx”……每当在脑海里面出现这一类的语句，就代表了我们做了一些假设。</p><p>但凡假设不成立，就意味着实现要变更。而不管是在中间件设计，还是在业务设计上，我们总是会自觉或者不自觉地引入很多假设。</p><p>比如说，在我学习 Web 框架时写代码，做了一个很重要的假设，朝前匹配，这个假设极大简化了实现的代码。例如两个路由：</p><pre><code class="language-plain">/api/user/*/profile\n/api/user/xiaoming/home\n</code></pre><p>如果我们的请求是  <code>/api/user/xiaoming/profile</code> ，在匹配到 <code>xiaoming</code> 的时候，应该走去第二个路由，但是后面的 <code>profile</code> 和  <code>home</code> 匹配不上。在工业级的 Web 框架里面，显然它们会回溯，找到第一个路由继续匹配。但是这会导致代码非常复杂。</p><p>我并不希望在这个以学习为目标的 Web 框架里面引入这种回溯的机制，所以引入了一个假设——路由匹配总是朝前的。显然，这个假设非常脆弱，但凡我想要把这个 Web 框架支持到工业级，首先就要重写这部分代码以正确匹配上第一个路由。</p><p>这个方法，<strong>难就难在识别不自觉的假设，特别是一些业务规则的假设</strong>。因为我们太熟悉这些业务规则，以至于默认它就是这样的，都不觉得自己做了假设。</p><p>典型的例子是金额，大部分国内开发者在处理金额的时候几乎不会考虑货币的问题，因为我们默认就是人民币，因而接口、数据库都只需要一个数字来表达金额。而一旦业务扩张到外币，就会发现几乎全部接口都缺乏货币的支持，整个改造起来就耗时长范围广了。</p><h3>替换法</h3><p>在讲框架设计的时候，我经常被问到一类问题：这个东西是做成这样还是做成那样？这个时候我都会建议他抽取出来一个接口，先写自己更加偏好的做法。将来在需要的时候，再替换为另外一个实现。这就是典型的替换场景。</p><p>这一类的场景识别起来也很容易，就是解决方案不唯一。不唯一就代表，今天可能用这个，明天可能用那个。<strong>如果你陷入一种进退两难的境地，又或者识别出这一块业界有多种做法，就可以用这个方法</strong>。</p><p>这里依旧用 Web 框架的例子。我在写路由树的时候发现，“某个节点是否匹配某段路径”是一个显而易见的扩展点，也就是方法：</p><pre><code class="language-go">func (h *HandlerBasedOnTree) findMatchChild(root *node, path string) (*node, bool) {\n   for _, child := range root.children {\n      if child.path == path {\n         return child, true\n      }\n   }\n   return nil, false\n}\n</code></pre><p>这是第一版代码，里面是严格匹配路径的，也就是条件 <code>child.path==path</code> 是变更点。为什么这么说呢？因为我使用过别的 Web 框架，知道还可以忽略大小写匹配、通配符匹配、参数路径以及正则匹配之类的匹配方式。</p><p>因此，“如何匹配”就是一个变更点。也可以说，“如何匹配”是一个选择匹配策略的问题。</p><h2>如何适应变更</h2><p>变更的位置我们找出来了，但是问题来了，我们需要为每一个变更点都设计一套接口吗？或者说，需要立刻解决它吗？</p><p>前面金额的例子说到大多数国内开发者并不会有意设计货币。但是在这里即便我识别出来了，如果公司现在没有这一类的业务，我也不会设计货币。因为过早引入货币，会导致前期开发不得不处理这些问题，拖累开发进度。</p><p>但是大多数时候，我们识别出来的变更点都是需要立刻处理的，一般来说我采用“隔离”和“超前一步设计”两个技巧。</p><h3>隔离</h3><p>隔离是最简单的处理方式，一般是抽取出来作为一个方法，或者一个结构体。</p><p>比如说前面的 findMatchChild 方法，就是我隔离出来的方法。因为在最开始的版本里，我知道这个地方会变，也就是说匹配规则是多样的，但是那个时候我还不想理它，又害怕完全不理吧，后面变了会波及其它代码，就抽取出来作为一个单独的方法。</p><p>那么后续不管怎么变，比如说支持路径参数、正则匹配，它都局限在了这个方法内，至多就是修改一下方法签名，传入更多参数。而对于调用方来说，传入更多参数会有点影响，但是影响已经是非常可控的。</p><p>如果抽取得好，遇到变更的时候，完全可以把这个方法升级成为一个接口。实际上，这也是从隔离走向超前一步设计的典型场景。</p><p>抽取结构体这种做法，一般是用于非常复杂的变更点。即这个变更点现有的逻辑就足够复杂，将来也很复杂，所以用一个结构体来封装一系列的方法。</p><p>但是不管是抽成方法还是结构体，就我个人经验而言，隔离的核心是要做到，<strong>隔离出来的是一个可测试的单元</strong>。什么意思呢？就是这个隔离出来的产物，一定要是单独可测试的。</p><p>因为将来变更之后，你可以完全复用当下的测试代码，来测试它变更前后的对外表现出来的行为是否一致。如果不一致，要么是我们的变更有问题，要么就是之前的隔离其实并不充分，这种情况下往往意味着使用方也要大动干戈。</p><h3>超前一步设计</h3><p>在前面我就已经暗示了如何做到超前一步设计。</p><p>超前一步的精髓在于：<strong>设计接口和接入实现的方式，但是不提供多样化的接口实现</strong>。这句话的意思是说，识别出变更点的时候，我们要设计一个接口出来，但是并不需要为所有可能的变更提供实现，只提供当下需要的实现即可。</p><p>设计接口这一步，说简单也简单，只需要参考隔离，把可能变化的逻辑抽取出来作为一个方法，然后这个方法的定义，就是接口内部方法的定义。如果是隔离出来结构体，那这个结构体就可以看作是接口的一个实现了。</p><p>如果说难，那么就难在做到这个接口将来肯定不会发生任何变更，也就是方法的输入、输出一点不变，这近乎不可能了。但是可以尝试减轻这种变更的影响，例如说输入和输出都定义为一个结构体，后续的变更无非就是增加字段而已。</p><p>举个例子，在意识到“如何匹配”是一个变更点之后，我们就可以在 node 中引入另外一个抽象 matchFunc：</p><pre><code class="language-go">type node struct {\n   children []*node\n   // 如果这是叶子节点，\n   // 那么匹配上之后就可以调用该方法\n   handler   handlerFunc\n   matchFunc matchFunc\n   // 原始的 pattern。注意，它不是完整的pattern，\n   // 而是匹配到这个节点的pattern\n   pattern string\n   nodeType int\n}\n</code></pre><p>但是，这个时候需要提供所有可能的实现吗？并不需要，我们只需要提供满足当前需求的实现就可以了。例如说，只支持简单的通配符匹配和路径参数匹配，但是不需要支持正则匹配。毕竟正则匹配比较少用，可以推迟到有用户反馈需要的时候再提供。</p><p>另外一个难点是，如何设计一个优秀的接入方式。因为这个机制要解答两个问题：知道用哪个实现并且得到对应的实例。如果说，<strong>接口的质量决定了你的设计能不能适应变更，那么接入机制就是决定了你能多快适应变更</strong>。</p><p>Go 不同于 Java，没有 SPI，也没有 Spring 这种提供容器的框架，连动态加载包的功能也没有。所以 Go 设计一个好用的接入机制，比较难，手段也比较单一。典型的做法就是 Register + init。</p><p>Register 是指设计一个注册实现的方法。例如在 Web 框架里面注册 Filter 的实现：</p><pre><code class="language-go">var builderMap = make(map[string]FilterBuilder, 4)\nfunc RegisterFilter(name string, builder FilterBuilder)  {\n   builderMap[name] = builder\n}\nfunc GetFilterBuilder(name string) FilterBuilder {\n   return builderMap[name]\n}\n</code></pre><p>这种是比较复杂的，框架内部通过按名索引来获得实例。如果只需要单一实现，那么可以将 map 去掉，直接存储实例。</p><p>Register 要结合 init 方法来注入实现：</p><pre><code class="language-go">// 匿名引入 _ "package/to/this/filters"\nfunc init() {\n   web.RegisterFilter("my-custom", myFilterBuilder)\n}\n</code></pre><p>用户需要在启动的地方，使用匿名引入来注入这个实现。<br>\n在理想情况下，接入机制应该被设计为无侵入式的。也就是替换一个新的实现，不需要修改代码。只不过这很难，在 Go 里面尤其难。前面 Filter 的接入方式就是无侵入式的，框架不需要有任何的修改。</p><p>而 matchFunc 就没有提供任何无侵入式的扩展手段，也就是说用户无法自定义自己的匹配规则，至多是我们在得到用户反馈之后，依据用户的需要，设计一种新的节点。即便如此，也需要稍微修改接入代码，这是因为我们创建 node 的方式是不一样的：</p><pre><code class="language-go">// 静态节点\nfunc newStaticNode(path string) *node {}\n// 通配符 * 节点\nfunc newAnyNode() *node {}\n</code></pre><p>所以 node 的设计在质量上要比 Filter 更差。</p><p>Filter 的抽象和接入机制还体现了另外一个原则：<strong>实现平等原则，接口的所有实现，在地位上是平等的，我怎么接入实现，用户就是怎么接入自己的实现</strong>。有些框架在这方面就做得很差，这些框架无一不是给自己的实现提供了特殊的地位，比如说典型的针对自身提供的实现，做了特殊的处理。</p><h2>总结</h2><p>我们基本上没有讨论 Web 框架的实现细节，只是借助 Web 框架讨论了一些我遵循的基本设计原则。而这一切的前提，就是抽象。</p><p>但你可能有个疑问，很多时候，我们很少设计这样一个完整的框架，那这些知识还有用吗？</p><p>答案是有用的，我们可以用这种思路去分析别的框架的源码。</p><p>我的分析思路供你参考。<strong>我会假设自己是这个框架设计者，分析框架要解决什么、核心的抽象会是什么</strong>。在看到核心抽象后，想象自己会如何实现，然后再去看实现，看实现引入了什么接口、揣度这个接口是表达了什么抽象、为什么要引入这个接口——本质上也是分析这个接口要解决什么问题。不断递归，直到搞明白框架的基本设计方式。</p><p>这里讨论的这种设计方式，我称之为自顶向下的设计方式，也就是从核心抽象出发。它自然也有很强的局限性，最大的局限性就是，如果你不熟悉问题领域，你是连核心抽象都难构建出来的。</p><p>所以这一切，我想用毛主席的一句话来总结：谁是我们的朋友，谁是我们的敌人，是革命的首要问题。</p><p>欢迎在留言区分享你的思考。如果你觉得有收获，也欢迎把今天的内容分享给你身边的朋友。我们下节课见。</p>',
        article_title: "大咖助阵｜大明：抽象，抽象，还是抽象",
      },
      {
        title: "大咖助阵｜飞雪无情：十年面试经验忠告，不要被框架所束缚",
        id: 443349,
        content:
          '<p>你好，我是飞雪无情，在IT互联网行业已经工作十多年了，目前是公司的产品研发负责人，带领100多人的团队。</p><p>作为一位Go语言的布道者，我在自己的博客里，写过<a href="https://www.flysnow.org/2017/07/19/go-in-action-postscript.html">《Go语言实战笔记》</a>系列，共计30篇15万字，也写过<a href="https://www.flysnow.org/2019/12/10/golang-gin-quick-start.html">《Golang Gin实战》</a>系列，共14篇十多万字；也是公众号飞雪无情的主理人，写过不少关于Go和Web框架的文章，积累了小几万粉丝。</p><p>写了这么多，但当我收到极客时间的约稿，是不太敢接的，因为实在不知道写什么你的收获更大。</p><p>如果写框架本身吧，不管是这个专栏，还是我自己的公众号都已经写了很多了，再写就是老生常谈了，你也不一定会感兴趣。如果写管理吧，虽然是个好的话题，结合我的从业经验也能分享一些心得，但是和专栏的主题有点格格不入。</p><p>我仔细思考了很久，正好最近因为频繁招聘，对面试和工作表现差异的感受比较强烈，最终选定了今天这个话题，想结合我自身学习、面试的经验，给你分享一下如何更好地学一门框架、如何不让自己成为框架的附庸，不至于在框架更新换代时落伍，失去了竞争力。</p><h2>误于面试</h2><p>去年我离开了工作十年的老东家金蝶随手记，来到一家不算太大，但是很有朝气、提倡创新的新公司十方教育集团，负责整个产品研发的工作。新的岗位对我来说是有很大挑战的，不管是团队的搭建、流程的建立，还是规范的梳理，都需要投入大精力去做。</p><!-- [[[read_end]]] --><p>这其中最具有挑战的就是团队的扩充以及梯队的搭建。因为公司业务发展，产品研发团队要大量扩充，所以我今年3、4月份的工作大部分都是招聘、面试。</p><p>在面试的过程中我发现，不少面试者讲起来基础还是可以的，问一些基本原理也都能讲明白，一些常用的框架也都用的比较熟。但是，<strong>如果你问他以前做的项目，就会发现很一般，也很少用到他所说的这些面试知识</strong>。当你给他出个题目，想看看他的实战经验，<strong>也看不到3年、5年经验应有的实战能力</strong>。</p><p>比如很多面试者都可以使用Gin框架快速开发一个API、写一个中间件，但是如果要问Gin如何快速匹配到一个路由的？为什么可以这么快？中间件是如何拦截请求的？转交给下一个中间件是如何做到的？能答上来的就很少了，更不用说再细问一步，中间件是使用的哪个设计模式？自己如何实现一个？</p><p>这种虽然能回答一些原理，但深入再问，能答上来的寥寥无几的经典面试情况，就是因为<strong>很多人的原理，是从面经上看的、背下来的，没有自己动手去验证过</strong>。加上市面上有很多现成的框架帮助他们完成日常工作，止步于会用就行，导致了解的知识都是皮毛，经不起考验。</p><p>为了面试而学并不是太新鲜的事情，十多年前也有，但是没有现在那么厉害，最近几年因为就业压力导致刷题盛行，我们只能被逼着去学，不然面试第一关都过不了。</p><p>但是面试不只一关，所经历的公司也不止这一家，止步面试的学习也会明显跟不上技术的迭代。因为就算你面试过了，还有试用期，进入工作后，自己的不足就会暴露出来，甚至出现更严重的问题，影响你的转正。</p><h2>止于工具</h2><p>现在技术更新是日新月异的，框架更是如此，隔一段时间换一个，不同的公司很大可能采用不同的框架，所以你换新工作之后，一般都得重新学习一门新框架，这会让你以前的经验打折扣，如果新公司用的框架你不会，自己的竞争力会大大降低，谈薪水都没底气。</p><p>但是你会发现，有的人能迅速上手新框架，但是有的人接受速度很慢，逐渐就被淘汰了。</p><p>出现这种情况有四层原因：</p><ol>\n<li>进取心不足，没有学习其他框架。</li>\n<li>有进取心，但是太相信自己在用的框架，投入太多，甚至把它当成自己的砝码，没有精力学习其他的，也不想学习。</li>\n<li>有关于框架发展的想法，但是关注度不够，没有跟上趋势。</li>\n<li>有关注也跟上趋势了，但是基础不牢，没有真正理解框架的底层原理，进而学习其他框架比较慢。</li>\n</ol><p>表面看是四层原因，其实深究都是被框架给“拖累”了，没有把主动权抓在自己的手里。</p><p>框架只是一个工具而已，是我们实现自己价值的多种工具中的一种。不止框架是工具，我们的编程语言也可以是工具。所以框架可以一个个的换，编程语言也可以，现在很多服务已经使用Go语言替代Java、Python了。</p><p>就像每一种编程语言都有它的使用场景，每一种框架都有它的优势。如果旧框架被替代，那么说明新框架有旧框架无法满足的优势，<strong>我们要做的就是根据需求，选择更适合的框架，最大程度提升自己的核心竞争力</strong>。</p><p>所以，请把框架当工具，不要让它成为你的负担，框架被淘汰，我们不能跟着一起被淘汰。</p><p>既然为面试而学只能解决一时问题，进入公司后无法更快适应公司技术栈，更快地做出成绩，那么日常怎样学习才能更好地提升自己，让自己越来越具备竞争力，甚至被各大公司抢着要呢？</p><h2>始于基础</h2><p>基础得学牢固这一点我是有切身体会的。这里说的基础指的是，<strong>编程语言本身的功能、概念、语法、模式等，它是编程的地基，不会随着框架的改变而改变</strong>。</p><p>大学时，在学会使用SSH（10年前的J2EE三大经典框架Spring、Hibernate、Struts）框架写出来一个管理系统，那会我感觉自己很牛，其他同学都不会，就我会。后来认识了一位已经工作的学长，他和我说，好好把语言基础打牢，这些框架自然就会了。当时真的是很不理解这句话。</p><p>毕业后因为工作需要，用的框架换来换去，我才深刻理解到这句话的价值。大学我学的是Struts1，毕业后就升级到了Struts2，语法完全不一样，相当于得重新开始学一遍，再过一段时间，又被SpringMVC后来居上了，又再学一遍。现在的新同学估计都没有听过这几个框架。</p><p>几次三番换框架，就算我有进取心想紧跟趋势，也多少有点忙不过来了。又得回头重新巩固对Java基础的理解。</p><p>后来我换到Go语言也一样，比如Go Web框架，有Martini、Beego、Iris、Echo，还有现在流行的Gin以及新兴的Fiber，也是轮转多换，但是对于我们开发者来说，不变的是基础。</p><p>比如Go语言本身的基础，学会了这个，想学其他语言很容易；再比如Go语言 HTTP处理、路由的基础，这是一切Go语言Web框架的前提，研究透了它们，不管你用什么Web框架，都可以庖丁解牛，搞得清清楚楚。</p><p>框架会经常变，但是不变的是这些基础。</p><h2>精于原理</h2><p>基础掌握好了，在学习具体框架的过程中，我们也容易走入另一个误区，那就是止步在使用上，没有把原理搞清楚，面试讲不出内部的实现逻辑、为什么这么实现，工作中面对新框架，也无法快速地熟悉使用，甚至二次开发。</p><p>所以当我们学习一门框架的时候，不仅要熟练地使用它，还要研究它里面的<strong>功能是如何实现的、为什么这么做、如果自己来做，有没有更好的办法</strong>？这样才能更好地使用。同时，在同类新框架出现的时候，也可以很快跟上，因为同一类框架，底层原理都是差不多的，就是一些实现方式、用户体验（开发者是用户）、周边生态等不太一样。</p><p>比如刚才说的那几个Go语言的Web框架，基本上都是基于Go HTTP的封装，让我们开发者可以更好地使用，但是在具体的实现上有所不同而已。如果你基于一个Web框架，把原理搞清楚，那再学习其他Web框架就会非常快，甚至自己撸一个Web框架都没问题。</p><p>对于一个框架的深入学习，<strong>除了内部的实现原理，还要掌握一些模式的应用</strong>。比如MVC模式、设计模式、算法等比较基础的能力，这些是构建一个可扩展、易用、高性能框架的基础；再比如常见的工厂模式、责任链模式等，会被大量用到框架的架构设计中。所以我们也要掌握这些。</p><h2>用于实战</h2><p>实践是检验真理的唯一标准，这句话说的真好，对于我们来说也一样。你说自己掌握了基础、精通了原理，那怎么衡量呢？就是靠实战。这是对结果的衡量，也是能体现自身价值、升职加薪的唯一方式。</p><p>在面试的时候，除了以前做的项目之外，我还比较喜欢问一个问题：<strong>作为5年工作经验的你，为什么认为自己比其他3年工作经验的面试者要强</strong>？</p><p>这个问题考察的点比较多，比如学习能力、总结能力、协调能力、经验等等，但是最终考察的其实是面试者解决问题的能力。能解决问题，才能证明你学的基础、说的原理、把框架当工具的认知有价值了，而不是纸上谈兵，更通俗点就是有用了。</p><p>所以实战，才是我们“始于基础”、“精于原理”的最终目的，靠实战去实现自我的价值。那么怎样才可以提升自己的实战经验呢？这里我给出一些方法供你参考：</p><ol>\n<li>积极参与公司项目，不要只为了完成任务，还要搞懂为什么这么做，背后的技术是什么；遇到问题时，也一定要查到根本原因，这些都可以提升你的实战经验。</li>\n<li>跟着高手学，比如一个项目立项、一个需求评审，都会有资深的开发甚至架构师牵头设计方案，要多跟着他们学，不懂的要多问，尝试自己去设计，来锻炼自己的实战能力。</li>\n<li>如果工作中没有以上机会怎么办呢？自己去找开源项目，先熟悉它、使用它，然后参与贡献代码，这也是个好方法。</li>\n<li>现在很多技术网站都有问答，你可以去这个频道去回答别人的问题，通过这种输出倒逼自己输入的方式，也能提升自己的实战经验。</li>\n</ol><p>其实方法有很多，也不限于以上四种。你只要自己动手去做就对了。</p><h2>总结</h2><p>框架是减少重复代码、提升开发效率的工具，我们可以通过它打开学习框架的大门，研究它背后的原理，理解它的架构设计，进而提升我们自身的能力，但是记住，永远不要被它所束缚。</p><p>欢迎在留言区分享你的思考。如果你觉得有收获，也欢迎把今天的内容分享给你身边的朋友。我们下节课见。</p>',
        article_title: "大咖助阵｜飞雪无情：十年面试经验忠告，不要被框架所束缚",
      },
    ],
  },
  {
    chapterTitle: "实战第4关：实战使用",
    children: [
      {
        title: "30｜设计先于实战：需求设计和框架搭建",
        id: 460612,
        content:
          '<p>你好，我是轩脉刃。</p><p>从标准库开始搭建，到框架核心的替换，到相关功能的完善，我们已经完整地将Golang的Web框架hade打造出来了。我们一起回顾一下，从最初的net/http开始，我们不断构建自己的框架，根据“一切皆服务”的思想，打造了12个服务以及15个命令行工具。这些服务和工具都是围绕实际的业务开发需求而设计的。</p><p>今天我们就来用自己搭好的框架开发一个具体的应用，不过开发什么比较好呢。之前准备的是写一个类论坛的网站，但是课程更新到这里，我突然有了一个更好的新想法。</p><p>在框架的使用过程中，你一定会有各种各样的疑问，使用上的或者代码理解上的，而这些疑问一定会很希望有一个类似知乎那样的地方可以进行答疑，所以这次，我们就为hade框架打造一个类似知乎这样的问答网站。</p><p>这个问答网站的源代码，我们另外开启一个开源项目 <a href="https://github.com/gohade/bbs">https://github.com/gohade/bbs</a> 来存放，并且从零开始一步步演示如何使用hade框架。后续如果你也想试试自己对hade框架的掌握程度，也欢迎一起参与来共建这个项目。</p><p>由于一个网站是由前端和后端协同完成的，前端我们使用的是Vue框架，后端使用的是自己的hade框架。之前也提过，前端Vue的内容是一门很大的课程，我们会介绍一下重点的部分，以不影响对整体网站开发逻辑的理解为主。不过所有的代码都可以在刚才的BBS开源项目中找到，方便你比对和学习。</p><!-- [[[read_end]]] --><p>下面开始我们的实战之旅吧。</p><h2>需求设计</h2><p>相信你肯定逛过各种各样的论坛类网站，这样的网站可以设计得很复杂，可以有用户模块、问答模块、会员模块、积分模块、排行榜模块、广场模块等等。但是对于一个以提出问题和回答问题为主的网站，它最核心的其实就只有两个模块：用户模块和问答模块。</p><h3>用户模块</h3><p>一个网站最基本的是用户模块，毕竟一个使用者在网站中的各种行为，比如提出问题、回答问题等都需要有一个用户身份。作为一个最基本的模块，用户模块负责的功能有注册和登录两个部分：</p><ul>\n<li>用户注册</li>\n</ul><p>用户注册功能负责为网站创建一个新的用户。但是并不是随意用一个用户名密码就可以创建用户，为了安全起见，注册的时候，用户还需要输入注册的邮箱。</p><p>所以，整个用户注册流程分为两个过程：</p><ol>\n<li><strong>预注册过程</strong>。用户在浏览器输入用户名、密码、邮箱，向网站发送注册请求；而网站收到注册请求之后，往用户的邮箱中发送一个邮件，这个邮件中包含一个验证链接。</li>\n<li><strong>注册验证过程</strong>。用户进入邮箱，打开邮件中的验证链接；这个验证链接会往网站中发送一个验证请求；网站在后台验证这个请求的合理性，然后在浏览器中引导用户进入下一步登录的过程。</li>\n</ol><p>用户注册时序图如下：<br>\n<img src="https://static001.geekbang.org/resource/image/4b/12/4b26edc5fa6177ab07113d542cfdda12.png?wh=1362x1216" alt=""></p><ul>\n<li>用户登录</li>\n</ul><p>在用户完成注册之后，每次使用网站需要进行一次用户登录的过程。</p><p>登录的过程大致是，用户在登录页面输入用户名密码，向后端发送登录请求。后端接收到带着一个token的登录请求。</p><p>这个token在前端会种到cookie中，后续所有发送给后端的请求都会带上这个token信息，<strong>而后端的所有请求都会验证一下这个cookie中的token</strong>，只有验证token确实是登录颁发的，才会通过请求，执行所有后续的请求；如果验证失败，则要求用户重新登录。</p><p>整个登录时序图如下：<br>\n<img src="https://static001.geekbang.org/resource/image/41/c9/414d876c07f4ef55edeb1047c09e43c9.png?wh=1140x1166" alt=""></p><p>完成了用户注册和用户登录，基本上用户模块的功能也就完成了。我们看问答模块怎么设计。</p><h3>问答模块</h3><p>问答模块负责用户提问和回答，它包含的页面比较多：</p><ul>\n<li>问题列表页，负责展示问题列表，按照最后更新时间来展示问题的列表页信息。</li>\n<li>问题编写页，负责创建问题，包含问题的标题和问题的内容。</li>\n<li>问题详情页，负责展示问题和问题的所有回答，回答按照最后创建时间倒序排列。</li>\n</ul><p>我们大致描述一下用户在问答模块的具体表现，更多细节在具体实现的时候再讨论。</p><p>用户A通过用户模块的登录页面登录进入网站，先进入的是问题列表页，在问题列表页他可以做两件事情。一是阅读问题列表，对于有兴趣的问题直接点击进入问题详情页，进行回答。另外，他也可以点击右上角的“我要提问”来进入问题编写页，提交问题，并且点击提交，他提出的问题在问题列表页就可以展示出来了。</p><p>问题列表页最终展示图如下：<br>\n<img src="https://static001.geekbang.org/resource/image/1a/59/1a83f05477538yy52yy171aa6b657e59.png?wh=1062x1240" alt="图片"></p><h2>前端准备知识</h2><p>现在我们搞清楚了要完成的两大模块大致有哪些需求。不过不管是什么模块，都离开不了前端页面的编写，如何编写，我们使用的是Vue框架，所以一些后续会用到的基础知识再统一梳理一遍，主要讲 vue、webpack、element-UI、vue-router、vuex、axios 这六个包。</p><h3>vue</h3><p><a href="https://vuejs.org">Vue框架</a>在实现前后端一体化的时候简单介绍过，是尤雨溪的大作，在<a href="https://github.com/vuejs/vue">GitHub上</a>有189k之多的star。</p><p>Vue框架目前是国内用得最多的Web前端框架了，没有之一。据我所见，不论是大厂还是小厂，Vue已经成为了必备的前端开发框架。这个使用率一部分归功于尤大在国内的不断推广，更大一部分要归功于Vue自身的优雅设计和便捷使用。</p><p>Vue的使用方式非常简单，首先在npm的包管理工具package.json中引入它：</p><pre><code class="language-json">"vue": "^2.5.16",\n</code></pre><p>然后我们在首页模板index.html中标记好一个ID为app的元素：</p><pre><code class="language-xml">&lt;body style="margin: 0px;"&gt;\n  &lt;div id="app"&gt;&lt;/div&gt;\n&lt;/body&gt;\n</code></pre><p>接着在页面对应的Vue组件js main.js 中引入Vue的包，并且创建一个Vue对象，把它绑定到ID为app的元素中：</p><pre><code class="language-javascript">import Vue from \'vue\' // 引入vue项目\nimport App from \'./App.vue\' //引入App组件\n...\n\n// 创建vue对象\nnew Vue({\n  el: \'#app\',  // 绑定id为app的元素\n  ...\n  render: h =&gt; h(App) // 将App组建渲染在这个元素中\n})\n</code></pre><p>在Vue中有个很重要的概念，组件，比如上面代码的App.vue就是App组件。什么是组件呢？就是一个包含HTML、JS、CSS的独立展示单元，包含三个部分：</p><pre><code class="language-plain">&lt;template&gt;\n...\n&lt;/template&gt;\n\n&lt;script&gt;\n...\n&lt;/script&gt;\n\n&lt;style&gt;\n...\n&lt;/style&gt;\n</code></pre><p>template 中编写输出的HTML信息，当然其中可能有一些诸如用户名这类的数据信息；这类数据信息是通过 script 中的脚本来获取的，所以Vue组件中的script 编写的是数据，以及获取数据的方法。最后style 里面编写的就是HTML展示的样式信息。</p><h3>webpack</h3><p>前面我们提到了首页模版index.html、页面对应的Vue组件js main.js、Vue组件App.vue，这些都是开发过程中的文件，最终生成的文件其实只有三种HTML、JS、CSS。也就是说，前面定义的各种开发文件，有的可能是我们最终的文件，有的可能并不是，所以这里要有一个<strong>将开发文件编译成为最终的HTML、JS、CSS文件</strong>的过程，这个过程就是<a href="https://webpack.docschina.org">webpack</a>。</p><p>webpack本质也是一个npm包，你同样可以在package.json 中引入：</p><pre><code class="language-json">"webpack": "^2.4.1",\n</code></pre><p>webpack配置项都存在根目录下的webpack.config.js中，你可以在这个配置文件中配置所有需要打包的配置信息。比如入口js：</p><pre><code class="language-javascript">module.exports = (options = {}) =&gt; ({\n  entry: {\n    index: \'./src/main.js\'\n  },\n  ...\n</code></pre><p>入口的HTML模版：</p><pre><code class="language-javascript">plugins: [\n  ...\n  new HtmlWebpackPlugin({\n    template: \'src/index.html\'\n  })\n],\n</code></pre><p>又比如编译后输出的目录和文件名：</p><pre><code class="language-javascript">module.exports = (options = {}) =&gt; ({\n  ...\n  output: {\n    path: resolve(__dirname, \'dist\'), // 输出目录\n    filename: options.dev ? \'[name].js\' : \'[name].js?[chunkhash]\', // 输出文件名\n    ...\n  },\n</code></pre><p>又或者如何阅读vue文件：</p><pre><code class="language-javascript">module: {\n  rules: [{\n      test: /\\.vue$/,\n      use: [\'vue-loader\']\n    },\n</code></pre><p>当然webpack还有许许多多的配置项等你挖掘，所有的配置信息和示例都可以在官网上看到。</p><h3>element-UI</h3><p>有了Vue，也有了打包Vue成为HTML、JS、CSS的打包工具webpack之后，其实我们已经可以编写Vue来生成页面了。但是对于后端甚至前端工程师来说，写出有功能的界面简单，但是如何写出“漂亮”的页面，又成了摆在面前的一道难题了。</p><p>有没有一个UI组件库，我们一旦引入并且使用这个组件库之后，就能很快捷方便地完成一个“漂亮”的页面呢？</p><p><a href="https://element.eleme.cn/#/zh-CN">element-UI</a>就是这么一套组件库，它是由饿了么公司开发并且免费开源出来的项目，目前也是国内最火的一套UI组件库，提供了非常多的UI组件，我们可以很方便地使用这些组件库构建自己想要的样式。</p><p>比如要使用element-UI的一个卡片组件，来生成类似这样的卡片样式：</p><p><img src="https://static001.geekbang.org/resource/image/8f/71/8f617yy7c6ec715d08050930d1b88771.png?wh=809x173" alt="图片"></p><p>首先同样要引入element-UI：</p><pre><code class="language-json">"element-ui": "^2.15.6",\n</code></pre><p>在入口js、main.js中使用Vue.use将ElementUI引入到Vue中：</p><pre><code class="language-javascript">import Vue from \'vue\' // 引入vue项目\nimport ElementUI from \'element-ui\'  // 引入element-ui组件\nimport \'element-ui/lib/theme-chalk/index.css\' // 引入element-ui的css样式\n...\n\nVue.use(ElementUI) // 可以在vue的任何组件中使用elemnt-ui\n\n...\n</code></pre><p>接着在需要使用卡片样式的页面Vue文件的template中直接使用el-card 标签：</p><pre><code class="language-plain">&lt;template&gt;\n  ...\n  &lt;el-card v-for="i in count" class="box-card" shadow="hover"&gt;\n    &lt;div slot="header" class="clearfix"&gt;\n      &lt;span&gt;问题标题{{i}}&lt;/span&gt;\n    &lt;/div&gt;\n    &lt;div class="text item"&gt;\n      这个是问题的具体内容，显示前200个字...\n    &lt;/div&gt;\n    &lt;div class="bottom clearfix"&gt;\n        &lt;time class="time"&gt;2021-10-10 10:10:10 ｜ jianfengye  | 10 回答&lt;/time&gt;\n        &lt;el-button type="text" class="button"&gt;去看看&lt;/el-button&gt;\n    &lt;/div&gt;\n  &lt;/el-card&gt;\n  ...\n&lt;/template&gt;\n</code></pre><p>这样编译出来的HTML文件就会有对应的样式了。</p><h3>vue-router</h3><p>解决了打包和样式问题，在Vue开发中我们遇到各种各样的需求，第一个遇到的就是根据URL展示不同的页面。比如问题列表页和问题详情页，它们的头部都是一样的，但是中间部分不一样，这个应该怎么处理呢？</p><p>我们当然可以每个页面写一个同样的头部，但是更好的办法是<strong>头部固定，让中间部分不固定，根据路由来选择不同Vue组件进行加载</strong>。这种“根据路由加载不同Vue组件”的技术就叫做vue-router。</p><p>vue-router首先也是要在pacakge.json引入：</p><pre><code class="language-json">"vue-router": "^3.5.3",\n</code></pre><p>然后和element-UI一样，通过Vue引入这个router组件：</p><pre><code class="language-javascript">import Vue from \'vue\'\nimport Router from \'vue-router\'\n...\n\nVue.use(Router)\n</code></pre><p>这样，在需要根据路由加载不同组件的地方，就可以使用 router-view 标签来占位一个组件位置：</p><pre><code class="language-plain">&lt;template&gt;\n  &lt;el-container&gt;\n    ...\n    &lt;el-main&gt;\n        &lt;router-view&gt;&lt;/router-view&gt;\n    &lt;/el-main&gt;\n  &lt;/el-container&gt;\n&lt;/template&gt;\n</code></pre><p>而占位的组件具体使用哪个，则是通过创建一个Router对象，并且把Router对象设置进入Vue实例的router字段中实现的：</p><pre><code class="language-plain">import ViewLogin from \'../views/login/index\'\n\nexport const constantRoutes = [\n    {\n        path: \'/login\',\n        component: ViewLogin,\n        hidden: true\n    },\n    ...\n]\n\nconst createRouter = () =&gt; new Router({\n    routes: constantRoutes\n})\n\nconst router = createRouter()\n\nnew Vue({\n  el: \'#app\',  // 绑定id为app的元素\n  router: router, // router字段\n  ...\n})\n</code></pre><p>Vue的组件渲染的时候，遇到占位的 router-view 标签，就会去 constantRoutes 中根据URL进行寻找。</p><h3>vuex</h3><p>Vue的组件和组件之间经常需要传递各种信息，比如用户信息。那么<a href="https://vuex.vuejs.org/zh">vuex</a> 就提供了统一管理这些信息的模块，在这个模块中，我们可以把要存储的内容都放在里面，当页面跳转的时候，只需要操作这个公共模块的内容即可。</p><p>它的使用方式首先也是一样，需要先在package.json 中引入vuex：</p><pre><code class="language-json">"vuex": "^3.6.2"\n</code></pre><p>其次创建一个vue.Store来创建一个store实例保存相应内容，这里的modules是一个key为string、value 为一个vuex对象的映射：</p><pre><code class="language-javascript">const store = new Vuex.Store({\n  modules,\n  getters\n})\n</code></pre><p>在入口的main.js中，我们将vuex创建的store实例，作为Vue的store字段，传递进入：</p><pre><code class="language-javascript">// 创建vue对象\nnew Vue({\n  el: \'#app\',  // 绑定id为app的元素\n  ...\n  store: store, // store设置\n  ...\n})\n</code></pre><p>之后在使用的时候，对应的所有存储状态就可以使用this.$store访问到：</p><pre><code class="language-javascript">const Counter = {\n  template: `&lt;div&gt;{{ count }}&lt;/div&gt;`,\n  computed: {\n    count () {\n      return this.$store.state.count // 访问存储状态\n    }\n  }\n}\n</code></pre><h3>axios</h3><p>前端一定是需要和后端进行交互的，而<a href="https://axios-http.com">axios</a>库就是负责前端给后端发送请求的。axios的使用非常简单。首先同样需要在package.json中引入：</p><pre><code class="language-json">"axios": "^0.24.0",\n</code></pre><p>其实这一步axios的引入就已经完成了，它的使用并不依赖于Vue实例的任何字段。所以它其实是完全可以脱离Vue使用的。</p><p>之后在具体使用它组件的地方，直接import调用它的接口了。</p><pre><code class="language-javascript">import axios from \'axios\'\n\n// Send a POST request\naxios({\n  method: \'post\',\n  url: \'/user/12345\',\n  data: {\n    firstName: \'Fred\',\n    lastName: \'Flintstone\'\n  }\n});\n</code></pre><p>但是在使用它的时候，我们一般会习惯做一个封装。</p><p>一方面，axios的名字还是比较绕口，我们将它的名字封装成为request，会更适合阅读。另一个更重要的，我们不希望直接调用axios，在这个封装中，对所有的请求参数和返回值都可以做一个注入操作。比如统一设置请求超时时间，又比如在返回值中，一旦返回状态不是200，也就是返回了异常，我们就在页面上打印出一个错误信息。</p><p>所以在src/utils/request.js中进行一下封装：</p><pre><code class="language-javascript">import axios from \'axios\'\nimport { Message } from \'element-ui\'\n\n\n\n// 创建一个axios\nconst service = axios.create({\n    withCredentials: true, // 请求携带cookie\n    timeout: 10000 // 统一设置超时\n})\n\n// response中统一做处理\nservice.interceptors.response.use(\n    response =&gt; {\n        // 判断http status是否为200\n        if (response.status !== 200) {\n            Message({\n                message: "请求错误",\n                type: \'error\',\n                duration: 5 * 1000\n            })\n        }\n    },\n    error =&gt; {\n        ...\n    }\n)\n\n\n\nexport default service\n\n</code></pre><p>而在具体使用的时候，直接import这个request.js就可以了：</p><pre><code class="language-javascript">import request from \'../../utils/request\'\n\nsubmitForm: function(e) {\n  ...\n  request({\n    url: \'/user/register\',\n    method: \'post\',\n    params: this.form\n  }).then(function (response) {\n    ...\n  })\n}\n</code></pre><p>好，vue、webpack、element-ui、vue-router、vuex、axios 这些组件基本上是我们这次开发页面会用到的了。不过前端的组件非常多且杂，后续开发过程中如果还有遇到，我们再详细说明。</p><h2>框架搭建</h2><p>首先我们要做的事情是使用hade框架搭建一个新项目。先使用命令：</p><pre><code class="language-go">go install github.com/gohade/hade@latest\n</code></pre><p>安装go命令到我们的$GOPATH/bin 目录下。</p><p>然后使用  <code>hade new</code> 命令创建一个BBS的项目：</p><p><img src="https://static001.geekbang.org/resource/image/04/4c/04ffa0d16fff66fea75a5fff19cd6c4c.png?wh=1920x1215" alt="图片"></p><h3>前端框架</h3><p>我们开始搭建前端，前端需要引入Vue、webpack、element-UI。不过其实我们并不需要一个个引入，element-UI有一个现成的集成了这三者的脚手架项目<a href="https://github.com/ElementUI/element-starter"> element-starter</a>，直接使用这个项目是最快的方式了。</p><p>怎么直接使用这个项目呢？我们做两个步骤：</p><ol>\n<li>将BBS项目中原先的前端文件直接删除</li>\n<li>将element-starter 全部复制到BBS项目中</li>\n</ol><p>BBS项目中原先的前端文件包含 build 目录、docs 目录、src 目录、package.json、package-lock.json 等，下图红色箭头所示：</p><p><img src="https://static001.geekbang.org/resource/image/08/f9/08ac13e99eea0f3d7729e52433c3e9f9.png?wh=842x1250" alt="图片"></p><p>删除之后，将<a href="https://github.com/ElementUI/element-starter"> element-starter</a> 项目直接复制过来，就完成了前端框架的迁移。</p><p><img src="https://static001.geekbang.org/resource/image/3d/ee/3da3a6dd497dcffec8a210bf2184c6ee.png?wh=806x1068" alt="图片"></p><p>我们再来规划一下前端源码 src 目录：</p><p><img src="https://static001.geekbang.org/resource/image/0f/ac/0f3908fe801086d70570ca757af022ac.png?wh=498x622" alt="图片"></p><p>index.html 是我们前面说的页面模版，而main.js 是前面说的前端js入口，这个入口加载的App.vue 就是我们的入口组件，vendor.js 存放一些需要import的第三方组件。</p><p>看这六个目录：</p><ul>\n<li>assets 里面存放的是一些png、jpg等图片信息；</li>\n<li>component 存放一些公共组件，后续多个页面有公共组件的时候，我们会将公共组件抽象放在这个目录中；</li>\n<li>router 存放前端的vue-router对应的路由信息；</li>\n<li>store 存放vuex中存放的存储状态；</li>\n<li>utils 存放一些通用的方法和函数；</li>\n<li>views 存放的是页面组件，这里面的每个组件最终都能渲染成为一个页面。</li>\n</ul><p>当然这套目录结构并不是固定的，只是在前端Vue的开源届，大家都认为这种目录算是一种最佳实践。很多项目都遵照这种目录结构划分，比如这次我们使用的element-UI。</p><p>具体的路由设计，有必要说明一下。前面说了路由vue-router是根据URL来占位展示不同的组件的。但是，我们这里是需要设计一个<strong>双层vue-router</strong>的。看一下这三个页面，登录页面、问题列表页、问题创建页：</p><p><img src="https://static001.geekbang.org/resource/image/83/df/831fec87f7a40a17ab8a4eda42efbddf.png?wh=1920x570" alt="图片"></p><p><img src="https://static001.geekbang.org/resource/image/56/06/56a596353fdc688c461563db5b3eff06.png?wh=1920x672" alt="图片"></p><p><img src="https://static001.geekbang.org/resource/image/08/e6/08c0f4fd5cde8d47ac4d6b13e64d93e6.png?wh=1920x875" alt="图片"></p><p>你可以看到，登录页面和下面两个页面整体布局是不一样的，而下面两个页面的头部header是一样的，body部分不一样。我们需要设计一套布局结构来同时支持这三种布局，所以就用到了二级的vue-router。</p><p>具体代码你可以参考GitHub上BBS的<a href="https://github.com/gohade/bbs/tree/geekbang/30">geekbang/30</a>分支。这里大致说一下逻辑，我们的路由设计为两级路由和一级路由同时存在。在src/router/index.js中：</p><pre><code class="language-javascript">export const constantRoutes = [\n    {\n        path: \'/login\',\n        component: ViewLogin,\n        hidden: true\n    },\n    {\n        path: \'/\',\n        redirect: \'/\',\n        component: ViewContainer,\n        children: [\n            {\n                path: \'\',\n                component: ViewList\n            },\n            {\n                path: \'create\',\n                component: ViewCreate\n            },\n            ...\n        ]\n    },\n]\n</code></pre><p>在入口vue组件App.vue中，我们使用第一层vue-router：</p><pre><code class="language-plain">&lt;template&gt;\n  &lt;div id="app"&gt;\n    &lt;router-view&gt;&lt;/router-view&gt;\n  &lt;/div&gt;\n&lt;/template&gt;\n</code></pre><p>而对于问题列表页和问题创建页，它们会先去加载Container组件；在Container组件src/views/layout/container.vue中我们使用第二层vue-router：</p><pre><code class="language-plain">&lt;template&gt;\n  &lt;el-container&gt;\n    &lt;el-header&gt;\n      &lt;bbs-header&gt;&lt;/bbs-header&gt;\n    &lt;/el-header&gt;\n    &lt;el-main&gt;\n        &lt;router-view&gt;&lt;/router-view&gt;\n    &lt;/el-main&gt;\n  &lt;/el-container&gt;\n&lt;/template&gt;\n</code></pre><p>这样前端两层路由就能满足不同的页面布局需求了。</p><h3>后端框架</h3><p>前端框架搭建差不多了，我们开始后端的框架搭建。</p><p>目录结构已经在hade框架中定义好了，所有的逻辑代码都存放在 app 目录下。</p><p><img src="https://static001.geekbang.org/resource/image/72/06/721227c8f97c0888e9c52a61878d3906.png?wh=880x846" alt="图片"></p><p>可以看到app/module/和/app/provider/下都有两个文件夹user和qa，估计你有点疑惑为什么要这么分层。</p><p>首先基于一切皆服务的逻辑，我们的服务层可以拆分为两个服务，用户服务和问答服务。按照这里需求的划分，分为两个服务的粒度是正好的，每个服务的基本服务接口都能控制在10个左右。当然在一些更大规模的项目中，是有可能分为更细粒度的，比如分为三个用户服务、问题服务、回答服务。这里的服务划分其实就是业务架构师的工作了，基本准则是让每个服务复杂度可控。</p><p>在这里，我们分为两个用户服务和问答服务，每个服务的复杂度基本上都在可控范围内。</p><p>下面就创建服务。回忆创建服务的三步骤，服务协议，服务提供者，服务实现。这里我们使用之前为hade框架提供过的快速创建服务工具： <code>./hade provider new</code> 快速创建两个服务user 和 qa。</p><p><img src="https://static001.geekbang.org/resource/image/4f/c2/4feba3be4e983862cf43c3bb25b3dcc2.png?wh=952x152" alt="图片"></p><p><img src="https://static001.geekbang.org/resource/image/49/51/493bac10cf14189c9eeddfb99729f951.png?wh=927x152" alt="图片"></p><p>我们会将所有的user或者qa的模型都封装在这两个服务（service provider）中。</p><p>那么app/modules下的user 和 qa的模块负责什么呢？这两个模块目前就简化为负责定义接口、定义返回对象、定义服务对象和返回对象的转换，我们分别设计api.go、dto.go、mapper.go 三个文件负责做这个事情。</p><p>这种开发模型就是hade建议的标准模型。还记得<a href="https://time.geekbang.org/column/article/425820">第12章</a>的课后问题让你思考如何设计业务模块的分层模型么？这个就是我的答案。</p><p>service provider层将领域对象封装成一个个的服务；再上面一层是mapper层，将服务结构转化为业务输出的结构；最后经过DTO的数据结构过滤和组织，通过API层输出。这种业务分层和结构设计的基本思想，是面向领域驱动的设计思想DDD，也是《企业应用架构模式》一书中推荐的。这种设计模型如图所示：<br>\n<img src="https://static001.geekbang.org/resource/image/86/e0/86c3dfcd20a08c5a90558665498d4fe0.jpg?wh=1920x1080" alt=""></p><p>在<a href="http://hade.funaio.cn/v1.0/guide/structure.html">官方说明文档</a>中也具体说明了。</p><p>这里还有一个小优化点：一个模块会定义多个接口，你可以把所有接口都放在一个api.go文件中，但是这样一个文件就特别冗长了。所以我建议将每个接口定义一个文件，以api_xxx.go 命名。</p><p>最终对于一个业务模块，比如user，我们会定义两个目录，一个是app/module/user，负责接口设计和返回对象设计，另外一个是app/provider/user，负责实质的业务服务抽象。</p><p><img src="https://static001.geekbang.org/resource/image/bf/a0/bfab7eec2cf7e991690cb1384753d0a0.png?wh=285x671" alt="图片"></p><p>到这里，我们的前后端框架搭建完成了。当然前端部分，可能还有很多细节点，不过今天我们已经把搭建框架的关键点和难点都详细说明了，具体的实现你可以参照GitHub上的BBS项目的<a href="https://github.com/gohade/bbs/tree/geekbang/30">geekbang/30</a>分支比对查看。</p><p>这里也列一下本节课的框架搭建结构：</p><p><img src="https://static001.geekbang.org/resource/image/9c/b5/9cb0d9ebdc9c7f7a85927ddff3a23cb5.png?wh=548x1143" alt="图片"></p><h2>小结</h2><p>这一节课我们进入了实战部分，真正使用hade框架来开发一个类知乎的问答网站。从需求开始设计分析了两个核心的模块，用户模块和问答模块，并且搭建了前端和后端的框架。这节课的内容比较多且杂，特别是前端的准备知识，一个纯后端工程师需要花费一些时间理解，如果你希望更多了解这些前端知识，网上相关资料也很多。</p><p>不过回看今天的后端开发，我们使用了  <code>./hade new</code> 和  <code>./hade provider new</code> 两个命令，这些都是之前实现的hade命令行工具，你是不是切实感受到它们提升了不少开发效率？</p><h3>思考题</h3><p>分析需求的时候，我们画了用户注册和登录的时序图来理解注册/登录逻辑，是不是一下子就简明扼要地说清楚了。其实在实际工作中，使用时序图来解释复杂交互或者服务间调用的逻辑是我们非常必要的技能了。</p><p>这节课的思考题希望你去了解一下时序图的元素和绘制方法，然后对照着文中注册和登录的时序图找出以下几个对应元素，检验一下自己的学习效果：</p><ul>\n<li>角色</li>\n<li>对象</li>\n<li>生命线</li>\n<li>消息</li>\n<li>控制焦点</li>\n<li>控制逻辑</li>\n</ul><p>欢迎在留言区分享你的学习笔记。感谢你的收听，如果你觉得今天的内容对你有所帮助，也欢迎分享给你身边的朋友，邀请他一起学习。下节课我们继续开发用户模块。</p>',
        article_title: "30｜设计先于实战：需求设计和框架搭建",
      },
      {
        title: "31｜通用模块（上）：用户模块开发",
        id: 460622,
        content:
          '<p>你好，我是轩脉刃。</p><p>上一节课分析了一下问答网站的需求，并且搭建起来了前端和后端框架，我们就来填充这个网站的具体内容。今天要做的是用户模块的开发。用户模块基本是所有系统的基础模块，所以如何开发设计用户模块，希望你一定好好掌握。</p><h2>模块设计</h2><p>简单回顾一下用户模块的需求分析，分为两个部分，用户注册和用户登录。我们先细化一下每个部分并且定义好它们的接口。</p><h3>用户注册</h3><p>首先是用户注册，它的时序图再放一下：<br>\n<img src="https://static001.geekbang.org/resource/image/4b/12/4b26edc5fa6177ab07113d542cfdda12.png?wh=1362x1216" alt=""></p><p>其中包含两个页面，第一个页面是预注册过程页面，用户在这个页面中输入用户名、密码、邮箱。这个页面的路径我们设置为/register。</p><p><img src="https://static001.geekbang.org/resource/image/53/b3/53175c922fef8a06f0186b369b54abb3.png?wh=1920x674" alt="图片"></p><p>输入用户名密码之后，它会发送一个邮件到用户的邮箱，在这个邮件中会带着一个确认注册的链接，只有通过点击这个链接，你才算完成验证。发送邮件的邮箱，我使用自己注册的一个126邮箱，最终邮件内容效果是这样的：</p><p><img src="https://static001.geekbang.org/resource/image/ca/cd/ca9872f2c4dc901337956539bab71dcd.png?wh=1200x324" alt="图片"></p><p>用户点击/user/register/verify 链接之后，才算正式注册完毕，接着会引导用户进入登录流程。</p><p>所以我们梳理一下，预注册这个过程前端和后端一共进行了两次交互，也就是说需要两个接口。</p><ul>\n<li>/user/register 预注册接口</li>\n</ul><p>用户在这个接口中带着用户名、密码和邮箱到后端。一般这种注册类接口我们会选择使用POST方法，它的参数为 username、password、email 三个字段。</p><!-- [[[read_end]]] --><p>前端请求这个接口后，后端的行为应该是将用户的信息存储在临时缓存中，并且向用户注册的邮箱发送一封邮件。如果接口请求正确，返回值直接可以是一个文本字符，提示“注册成功，请前往邮箱查看邮件”。</p><ul>\n<li>/user/register/verify 注册验证接口</li>\n</ul><p>这个接口是一个在邮件中的链接，它的参数为token、请求方法为GET，用户点击链接就访问了这个接口。一旦验证成功，就引导用户跳转到登录页面，所以它返回的状态码为重定向301。</p><h3>用户登录</h3><p>梳理完用户注册的页面和接口，我们来明确下用户登录的逻辑和接口。<br>\n<img src="https://static001.geekbang.org/resource/image/41/c9/414d876c07f4ef55edeb1047c09e43c9.png?wh=1140x1166" alt=""></p><p>还是看着用户登录时序图分析，在登录页面，用户输入注册时填写的用户名和密码，登录进入问题列表页。</p><p><img src="https://static001.geekbang.org/resource/image/94/6d/94e7cbfb5313cf7abbe6d91222e15d6d.png?wh=1920x585" alt="图片"></p><p>而在问题列表页的头部，右上角有个登出按钮，这个登出按钮能控制用户进行登出操作。</p><p><img src="https://static001.geekbang.org/resource/image/a9/c0/a9fd4cfce64ac76a15b72819e925bbc0.png?wh=1920x674" alt="图片"></p><p>所以用户模块的登录部分实际上要提供两个接口，登录接口和登出接口。</p><ul>\n<li>/user/login 登录接口<br>\n在这个登录接口，参数为用户登录所需要的用户名username、密码password。同注册一样，这种对服务端请求的接口我们使用POST方法。</li>\n</ul><p>登录接口成功之后，服务端会生成一个代表用户登录态的token，在缓存中将这个token和用户信息进行关联，然后将token返回给前端。所以登录接口的返回值为字符串token。</p><p>之后就是上一节课分析过的，前端获取到token之后，将token种到cookie中，后续所有需要登录的请求都要带上这个cookie；而服务端对每个请求都会验证这个带有token的cookie。</p><ul>\n<li>/user/logout 登出接口<br>\n登出接口并不需要任何的参数，但是它需要用户以登录态来进行这个请求操作。</li>\n</ul><p>怎么判断是登录态呢？服务端可以从cookie中获取这个用户的token，并且根据这个token获取到用户信息，验证用户信息正确，就说明处于登录中。<strong>所以可以在验证后将缓存中的token信息删除，让这个token实际上失效</strong>，后续用户必须再次进行登录操作获取一个新的token了，这样就完成了登出的效果。</p><p>所以这个接口并没有请求参数，由于触发它的是一个链接，所以选用GET方法，返回值就是一个字符串，告诉用户登出成功/失败即可。</p><p>好，梳理一下关于用户模块的需求和接口。我们一共要实现这么四个接口：/user/register 预注册接口、/user/register/verify 注册验证接口、/user/login 登录接口、/user/logout 登出接口。</p><h2>后端开发</h2><p>明确了要实现的四个接口，也明确了各个接口的参数和返回值。下面正式开始我们的后端开发之路。后端开发这块，我们按照这样的步骤：</p><ol>\n<li>接口swagger化</li>\n<li>定义用户服务协议</li>\n<li>开发模块接口</li>\n<li>实现用户服务协议</li>\n</ol><p>这种开发流程每一步都有具体意义。</p><p>由于在实际工作中，前端和后端一般是并行开发的，所以前后端都是通过接口来进行交互的。而前面分析明确的所有接口和参数都是在我们的“脑海”中，需要有一个界面将这些接口和参数都展示出来。这个时候就自然想到了hade框架集成的swagger，所以第一步，我们先将接口swagger化，让前后端并行开发成为可行。</p><p>其次，一切皆服务，我们的用户模块也对应一个用户服务。这个用户服务其实不仅仅给用户模块使用，后续qa模块也会使用到。所以这个用户服务提供哪些服务协议给上层业务模块呢？这个是第二步要思考。</p><p>定义好用户服务提供的协议之后，我们如何确定这个用户服务协议是能满足要求的呢？这就是第三步。如果可以满足我们的模块接口需求，那么这个用户服务协议是ok的，就可以直接使用这些用户协议来开发具体模块接口了。</p><p>最后一步才是最终实现，只需要使用各种其他服务比如ORM、cache等，来实现我们的用户协议，最终就完成了整个后端开发。</p><h3>接口swagger</h3><p>按照步骤，先实现接口的swagger化，回忆一下<a href="https://time.geekbang.org/column/article/435582">第23章</a>讲集成swagger自动生成文件来管理接口，我们着手编写可以生成swagger-UI的swagger注释。</p><p>首先修改 app/http/swagger.go 文件，这个文件以注释形式说明swagger概览，包括基础调用地址、接口版本等。所以这个swagger.go文件，我们只需要增加关于这些信息的注释即可，格式你可以参考swaggo的<a href="https://github.com/swaggo/swag#how-to-use-it-with-gin">官方文档</a>。</p><pre><code class="language-go">// Package http API.\n// @title hadecast\n// @version 1.0\n// @description hade论坛\n// @termsOfService https://github.com/swaggo/swag\n\n// @contact.name jianfengye\n// @contact.email jianfengye\n\n// @license.name Apache 2.0\n// @license.url http://www.apache.org/licenses/LICENSE-2.0.html\n\n// @BasePath /\n...\n</code></pre><p>它最终对应的就是swagger-UI的头部：<br>\n<img src="https://static001.geekbang.org/resource/image/f5/f3/f5bc6d57ee3b8c7f4afba019d9418df3.png?wh=1920x520" alt="图片"></p><p>接着，我们按照上节课的设计，在接口和返回对象的app/module/user目录中，接口不全放在一个文件里，而是一个接口用一个文件存放。那就要定义四个文件分别存放这四个接口：</p><ul>\n<li>app/http/module/user/api_register.go</li>\n<li>app/http/module/user/api_verify.go</li>\n<li>app/http/module/user/api_login.go</li>\n<li>app/http/module/user/api_logout.go</li>\n</ul><p>然后定义好四个接口来实现具体的方法。关键是在方法的头部，要以<a href="https://github.com/swaggo/swag">swaggo</a>的规范填写对这个接口的请求和返回值要求。这里我们就以参数稍微复杂一点的api_register为例，其他接口的实现大同小异，你可以参考GitHub上的代码。</p><pre><code class="language-go">type registerParam struct {\n   UserName string `json:"username" binding:"required"`\n   Password string `json:"password" binding:"required,gte=6"`\n   Email string `json:"email" binding:"required,gte=6"`\n}\n\n// Register 注册\n// @Summary 用户注册\n// @Description 用户注册接口\n// @Accept  json\n// @Produce  json\n// @Tags user\n// @Param registerParam body registerParam true "注册参数"\n// @Success 200 {string} Message "注册成功"\n// @Router /user/register [post]\nfunc (api *UserApi) Register(c *gin.Context)  {\n    // 验证参数\n    userService := c.MustMake(provider.UserKey).(provider.Service)\n    logger := c.MustMake(contract.LogKey).(contract.Log)\n    param := &amp;registerParam{}\n    if err := c.ShouldBind(param); err != nil {\n       c.ISetStatus(404).IText("参数错误"); return\n    }\n    ...\n}\n</code></pre><p>按照前面分析的，Register接口是POST请求，请求参数放在Body体中，有三个字段username、password、email。 所以我们定义一个registerParam结构来解析这些请求参数，并且使用Gin框架自带的c.ShouldBind 方法，把请求Body体中的JSON结构解析为 registerParam结构。</p><p>这里的ShouldBind方法我们第一次遇到，稍微介绍一下。</p><p>ShouldBind方法是Gin框架提供的一个很好用的参数绑定函数，<strong>它不仅能将请求体直接绑定到一个数据结构中，还能根据标签，对每个字段进行参数验证</strong>。比如我们希望Password是必须要填写的，且字段长度必须大于6个字符。那么在定义结构的时候，我可以用tag的形式标记这个规则，就像这样：</p><pre><code class="language-go">Password string `json:"password" binding:"required,gte=6"`\n</code></pre><p>当然绑定tag的写法是要按照Gin的绑定规则来填写的，更多的绑定规则你可以参考<a href="https://gin-gonic.com/zh-cn/docs/examples/binding-and-validation">官网说明</a>。<br>\n定义好了参数结构registerParam，我们把注意力放到函数的swagger注释中。在Register的注释中使用了这些关键字：</p><ul>\n<li>Summary 接口简要说明</li>\n<li>Description 接口详细说明</li>\n<li>Accept 接口接受的请求格式</li>\n<li>Produce 接口返回的response格式</li>\n<li>Tag 接口的标签，便于归类</li>\n<li>Param 接口参数</li>\n<li>Success 接口成功返回的返回值</li>\n<li>Router 接口路由说明</li>\n</ul><p>注释的详细写法你需要参考<a href="https://github.com/swaggo/swag#declarative-comments-format">说明文档</a>。这里还是看下最复杂的Param接口参数说明：</p><pre><code class="language-go">// @Param registerParam body registerParam true "注册参数"\n</code></pre><p>这句话告诉swag：我们的接口参数名称为registerParam，它是一个数据结构，存储在Body体中，参数是必须要填写的，参数说明为“注册参数”。</p><p>这样，register接口的参数定义就完成了，根据23章讲过的使用swagger的方法，我们通过命令</p><p><code>./bbs swagger gen</code> 来生成swagger文件：</p><p><img src="https://static001.geekbang.org/resource/image/a2/81/a286446be2ebd484821a722377879581.png?wh=1772x392" alt="图片"></p><p>将生成的文件编译进入项目中， <code>./bbs build self</code> ：</p><p><img src="https://static001.geekbang.org/resource/image/10/5a/10dabd4e1560e8bf851ba2f25d47285a.png?wh=1082x106" alt="图片"></p><p>然后你可以运行命令 <code>./bbs app start</code> 启动App，或者选择调试模式  <code>./bbs dev backend</code> 来启动swagger-UI，这里因为我们还是在调试状态，所以选择启动调试模式：</p><p><img src="https://static001.geekbang.org/resource/image/02/f3/02f16f255bcec434ddecf764e663acf3.png?wh=1094x344" alt="图片"></p><p>打开浏览器 <a href="http://127.0.0.1:8070/swagger/index.htMl">http://127.0.0.1:8070/swagger/index.html</a>，我们就能看到根据接口注释生成的swagger-UI界面了，并且后续可以通过这个界面直接调用接口请求来进行调试：</p><p><img src="https://static001.geekbang.org/resource/image/74/80/74f8366d6aeba29e8df198488e808c80.png?wh=1920x1030" alt="图片"></p><h3>用户服务设计 - 模型</h3><p>定义好接口，开始定义用户服务了。上节课介绍过了，根据一切皆服务的思想，我们已经创建好了用户模块服务，放在app/provider/user目录中。下面的关键是定义这个用户服务提供哪些服务。</p><p>首先，用户服务，要不要有一个用户结构来代表用户？是需要有的，我们在不同服务之间传递“用户”的实例，包含用户名、密码、邮箱等信息，后续也有可能扩展更多信息，所以<strong>不论是为了服务传递的便捷，还是后续扩展的便捷，都有必要将用户信息封装为一个用户结构</strong>。</p><p>所以，我们在app/provider/user/contract.go中定义一个User结构来表示一个用户，这个user结构中首先有ID字段，代表用户的唯一标识；其次有注册的用户名UserName、密码Password、邮箱Email、创建时间CreatedAt；并且由于用户注册和登录的时候会频繁使用token，我们再定义一个字符串Token字段来存储注册token或者登录token。</p><pre><code class="language-go">// User 代表一个用户，注意这里的用户信息字段在不同接口和参数可能为空\ntype User struct {\n    ID int64  `gorm:"column:id;primaryKey"` // 代表用户id, 只有注册成功之后才有这个id，唯一表示一个用户\n    UserName string `gorm:"column:username"`\n    Password string `gorm:"column:password"`\n    Email string  `gorm:"column:email"`\n    CreatedAt time.Time `gorm:"column:created_at"`\n    \n    Token string `gorm:"-"` // token 可以用作注册token或者登录token\n}\n</code></pre><p>不知道你注意到了没，定义User结构的时候，我<strong>在tag标签里也增加了gorm的标签</strong>，意思是这个User对象，同时也可以作为gorm操作的对象使用的。</p><p>不光是这里有点小设计，其实我在app/http/module/user中还定义了一个User的相关对象：</p><pre><code class="language-go">// UserDTO  表示输出到外部的用户信息\ntype UserDTO struct {\n   ID int64\n   UserName string\n   CreatedAt time.Time\n}\n</code></pre><p>如果你没有太理解，因为这里涉及上一讲提到的分层“模型”的设计，我们来仔细思考一下。</p><p>首先不管分层逻辑是什么样，我们在实现一个业务模块的时候一般会有三种模型的需求。</p><p><strong>第一种模型是数据库模型</strong>，就是说这个这个模型对应数据库中的某个数据，这个也就是我们在第25章提到的ORM的概念，代码中的数据模型和数据表一一对应，这样操作这个模型就相当于能操作数据表。这种模型我们也称之为持久化对象PO（Persistent Object），表示对象与数据库这种持久化层一一映射。</p><p>但是数据库模型和数据表关联太紧密了，一旦数据表修改，我们的数据库模型也需要对应修改，所以就会需要<strong>第二种模型，领域模型，DO</strong>。就是我们在业务中对某个事物的理解和抽象。</p><p>DO模型不一定会依赖数据表的字段，而是依赖于我们对于要建立的业务的抽象。有了这个模型，我们在不同服务、不同模块之间的调用，都直接基于这个领域模型，就能保持各个模块对同一个事物的理解是一致的。</p><p>但是领域模型如果直接输出给用户，比如Web前端用户，有一些是需要进行加工的，比如一些涉及安全的字段需要隐藏、一些字段类型需要转换等。所以输出给前端的是<strong>第三种模型，输出模型</strong>，我们经常叫它DTO，表示最终在网络上传输的数据对象。</p><p>这三种模型从底层到上层依次为PO、DO、DTO。不管我们的业务是如何分层，基本上绕不开这三种模型的设计。<br>\n<img src="https://static001.geekbang.org/resource/image/5e/13/5e1f623yyd5f48fb73786e426c966913.jpg?wh=1920x1080" alt=""></p><p>估计从这段分析中，你也能想到这三种模型之间是存在转换关系的，它们的转换也是一个比较繁琐的过程，比如DO转换为DTO，记得吗我们还专门设计了一个映射层，就是app/http/module/user/mapper.go中定义的各种映射方法。</p><p>那有没有节省代码量，快速开发的方法呢？有的，就是将这三种模型合并。</p><p>至于怎么合并，不同的业务有会有不同的选择了。有的人会选择将领域模型和输出模型合并，就是直接将领域模型输出给前端业务；也有的人选择将领域模型和数据库模型合并，在领域模型中增加数据库的操作字段；当然有更极致的设计将这三种模型统一合并，使用一个模型，不仅操作数据库，也操作前端返回值。</p><p>不同的合并策略各有好处和劣势。不过好处基本一样，能有效降低某些层的代码量，提升开发效率。<strong>而缺点也差不多，就是合并之后，一旦合并的两层有不同的需求，修改起来可能就会非常复杂了</strong>。比如将领域模型和输出模型合并后，如果不断有需求要修改输出模型，原先的name字段要修改为username，或者原先输出的电话号码要将某些位置替换为*号，又需要将其分离。</p><p>所以三层不同“模型”的优化，实际上需要你对业务有足够的理解，才能精准判断出大致哪几层合并后在“未来”不会有重构的需求。</p><p>比如这里我实际上创建了两个模型，UserDTO 和 User，也就是选择将数据库模型和领域模型合并。因为我觉得我们这个网站的数据库模型比较简单，并且基本上和业务领域中的用户逻辑是一致的，只有一两个字段会稍微有些不同。所以我有把握，后续对“用户”这个业务逻辑的需求，都不会影响数据库和业务领域的一致，就做了这个选择。</p><p>但是提醒一下，如果在你的业务中某个逻辑比较复杂，比如“用户”这个逻辑基本上要由几个数据表才能得出一个完整的用户逻辑，那么这种选择就是错误的了。</p><p>另外坚持将UserDTO单独分开，这也是我的经验之谈。<strong>越接近前端，需求变化越频繁</strong>，修改/增加/删除某个前端展示字段的需求在实际工作中比比皆是。所以这个输出层模型我一般习惯单独写出来。</p><p>好讲到这里，相信你就可以理解在“用户服务”中定义模型User会同时带着gorm标签的含义了，就是代表，我会使用这个模型来操作数据库的。</p><p>后端开发剩下的两个步骤，我们下一节课再继续讲解。这节课所有的代码都上传到 <a href="https://github.com/gohade/bbs/tree/geekbang/31">geekbang/31</a>分支了。你可以对比查看。</p><h2>小结</h2><p>分析用户模块的注册和登录两个部分后，我们开始开发后端了，但并不是一上手就开始接口逻辑编写，也不是一开始就考虑我应该用数据库还是缓存实现用户存储。而是依照四个步骤：</p><ol>\n<li>接口swagger化</li>\n<li>定义用户服务协议</li>\n<li>开发模块接口</li>\n<li>实现用户服务协议</li>\n</ol><p>hade框架的整体都是不断在强调“协议优于实现”，接口是后端和前端定义的协议，用户服务是后端模块与模块之间定义的协议。对于一个业务，最重要的是定义好、说明清楚这些协议，然后才是实现好这些协议。希望hade框架带给你的不仅仅是工具和功能上的便利，更多是开发思维和流程的转变。</p><h3>思考题</h3><p>看完关于“模型”的讨论，你一定会有很多观点想要交流，比如你的实际项目中，业务架构师是怎么分层的，在每一层是否有定义对应的模型，是否有合并不同的模型？具体业务中的模型设计方式你是否认可？如果你来重新设计一个模型设计，会怎么设计？</p><p>欢迎在留言区分享你的思考。感谢你的收听，如果觉得今天的内容对你有所帮助，也欢迎分享给你身边的朋友，邀请他一起学习。</p>',
        article_title: "31｜通用模块（上）：用户模块开发",
      },
      {
        title: "32｜通用模块（下）：用户模块开发",
        id: 461966,
        content:
          '<p>你好，我是轩脉刃。</p><p>上一节课我们设计好用户模块的需求后，开始了后端开发。在后端开发中我们明确了开发流程的四个步骤，先将接口swaggger化，再定义用户服务协议，接着开发模块接口，最后实现用户服务协议。而且上节课已经完成了接口swagger化，以及用户服务协议设计的模型部分。</p><p>这节课，我们就继续完成用户服务协议的定义，再开发模块接口和实现用户服务协议。</p><h2>用户服务协议</h2><p>前面我们设计好了一个模型User了，“接口优于实现”，来设计这个服务的接口，看看要提供哪些能力。</p><p>首先用户服务一定要提供的是预注册能力，所以提供了一个Register方法。预注册之后，我们还要提供发送邮件的能力，再提供一个发送邮件的接口SendRegisterMail。当然最后要提供一个确认注册用户的接口VerfityRegister。</p><p>在登录这块，用户服务一定要提供登录、登出的接口Login和Logout。同时由于所有业务请求，比如创建问题等逻辑，我们需要使用token来获取用户信息，所以我们也要提供验证登录的接口VerifyLogin。</p><p>于是整体的接口设计如下，详细信息都写在注释中了：</p><pre><code class="language-go">// Service 用户相关的服务\ntype Service interface {\n\n    // Register 注册用户,注意这里只是将用户注册, 并没有激活, 需要调用\n    // 参数：user必填，username，password, email\n    // 返回值： user 带上token\n    Register(ctx context.Context, user *User) (*User, error)\n    // SendRegisterMail 发送注册的邮件\n    // 参数：user必填： username, password, email, token\n    SendRegisterMail(ctx context.Context, user *User) error\n    // VerifyRegister 注册用户，验证注册信息, 返回验证是否成功\n    VerifyRegister(ctx context.Context, token string) (bool, error)\n\n    // Login 登录相关，使用用户名密码登录，获取完成User信息\n    Login(ctx context.Context, user *User) (*User, error)\n    // Logout 登出\n    Logout(ctx context.Context, user *User) error\n    // VerifyLogin 登录验证\n    VerifyLogin(ctx context.Context, token string) (*User, error)\n}\n</code></pre><!-- [[[read_end]]] --><p>这里也说明一下，要抽象设计出一个服务模块的协议确实不是一件很简单的事情，也不一定能一次性设计好。</p><p>我们说过，<strong>从“服务需要提供哪些对外能力”的角度来思考，会比较完善</strong>。比如这里为什么要设计一个VerfityLogin能力呢？系统对外提供的接口并没有这个服务，但是在内部，我们每次验证token的时候，会需要用token来验证和换取user的。所以这个接口的设计是有“需要”的。</p><p>服务协议的设计从需求出发，当遇到新的需求，不断迭代就可以了。</p><h2>用户模块接口实现</h2><p>设计了用户服务的协议，下一步我们也不是急于实现它，需要先验证下这些服务协议是否能满足我们的“需求”。如何验证呢？可以直接开发用户接口，确认是否有未满足的需求。</p><p>上一节课梳理了，要实现四个接口：</p><ul>\n<li>\n<p>app/http/module/user/api_register.go</p>\n</li>\n<li>\n<p>app/http/module/user/api_verify.go</p>\n</li>\n<li>\n<p>app/http/module/user/api_login.go</p>\n</li>\n<li>\n<p>app/http/module/user/api_logout.go</p>\n</li>\n</ul><p>我们还是拿其中比较复杂的注册接口api_register.go做一下说明，其他接口的实现没什么难点，你可以参考GitHub上的代码。</p><p>注册接口我们要做几个事情？<strong>首先验证接口参数，其次要进行预注册，然后发送预注册的验证邮件，最后返回成功状态</strong>。</p><p>验证接口参数之前讲过，使用定义好的 registerParam结构和Gin带有的binding逻辑就可以做参数的获取和验证了。预注册的逻辑，既然已经定义好了用户服务的预注册接口，这里可以直接调用这个接口Register。同样，发送验证邮件的接口我们也已经在用户服务中定义好了，直接调用SendRegisterMail即可。最终，返回成功状态，我们使用hade框架对Gin扩展的IStatusOk。</p><pre><code class="language-go">func (api *UserApi) Register(c *gin.Context)  {\n   // 验证参数\n   userService := c.MustMake(provider.UserKey).(provider.Service)\n   logger := c.MustMake(contract.LogKey).(contract.Log)\n\n   param := &amp;registerParam{}\n   if err := c.ShouldBind(param); err != nil {\n      c.ISetStatus(400).IText("参数错误"); return\n   }\n\n   // 注册对象\n   model := &amp;provider.User{\n      UserName:  param.UserName,\n      Password:  param.Password,\n      Email: param.Email,\n      CreatedAt: time.Now(),\n   }\n   // 注册\n   userWithToken, err := userService.Register(c, model)\n   if err != nil {\n      logger.Error(c, err.Error(), map[string]interface{}{\n         "stack": fmt.Sprintf("%+v", err),\n      })\n      c.ISetStatus(500).IText(err.Error()); return\n   }\n   if userWithToken == nil {\n      c.ISetStatus(500).IText("注册失败"); return\n   }\n\n   if err := userService.SendRegisterMail(c, userWithToken); err != nil {\n\n      c.ISetStatus(500).IText("发送电子邮件失败"); return\n   }\n\n   c.ISetOkStatus().IText("注册成功，请前往邮箱查看邮件"); return\n}\n\n</code></pre><p>这里使用了之前我们对Gin框架扩展定义的Response结构中的链式方法：</p><pre><code class="language-go">c.ISetOkStatus().IText("注册成功，请前往邮箱查看邮件");\n</code></pre><p>很明显，这种方法确实比Gin框架自带的Response方法更为优雅轻便了。</p><p>实现好Register接口，我们基本确认了之前设计的用户服务中注册部分是满足需求的。再一个个接口 Verify/Login/Logout 都实现一下，基本能确定之前用户服务的设计是可以的。</p><h2>开发模块接口</h2><p>既然我们已经确定了用户服务设计可行，进入最后一步，实现这些用户服务定义的协议方法。在实现中，你能看到很多之前定义的各种服务的具体使用。用户注册的三个相关协议接口的实现，我们详细说一下，其他登录相关的接口协议，你可以参考GitHub上的代码。</p><h3>预注册协议接口</h3><pre><code class="language-go">// Register 注册用户,注意这里只是将用户注册, 并没有激活, 需要调用\n// 参数：user必填，username，password, email\n// 返回值： user 带上token\nRegister(ctx context.Context, user *User) (*User, error)\n</code></pre><p>预注册协议接口的具体实现要做几个事情：</p><ol>\n<li>去数据库判断邮箱是否已经注册用户了，如果邮箱已经注册，那么这个预注册操作是不能执行的；</li>\n<li>去数据库判断用户名是否已经被注册了，如果用户名已经被注册了，那么预注册操作也是不能执行的；</li>\n<li>生成预注册的验证token；</li>\n<li>将要注册的用户存储在缓存中，存储1天，待用户注册验证。</li>\n</ol><p>我们注意到四步操作里<strong>前面两步是去数据库的查询操作，所以可以使用hade框架的ORM服务</strong>，先从容器中获取ORM服务，使用GetDB获取gorm.DB，接着就可以使用gorm的Where、First 等方法了。由于之前已经定义好了User结构作为数据库模型，所以我们直接使用这个模型：</p><pre><code class="language-go">// 判断邮箱是否已经注册了\normService := u.container.MustMake(contract.ORMKey).(contract.ORMService)\ndb, err := ormService.GetDB()\nif err != nil {\n   return nil, err\n}\nuserDB := &amp;User{}\nif db.Where(&amp;User{Email: user.Email}).First(userDB).Error != gorm.ErrRecordNotFound {\n   return nil, errors.New("邮箱已注册用户，不能重复注册")\n}\nif db.Where(&amp;User{UserName: user.UserName}).First(userDB).Error != gorm.ErrRecordNotFound {\n   return nil, errors.New("用户名已经被注册，请换一个用户名")\n}\n</code></pre><p>而第三步生成token，就使用一个简单的随机生成token的算法，直接去一排字符串中随机获取下标来生成token。</p><pre><code class="language-go">const letterBytes = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"\n\nfunc genToken(n int) string {\n   b := make([]byte, n)\n   for i := range b {\n      // 这里是随机获取的\n      b[i] = letterBytes[rand.Intn(len(letterBytes))]\n   }\n   return string(b)\n}\n</code></pre><p>最后一步，需要将User对象存储到缓存中。我们使用key为"user:register:[token]"来存储User对象。</p><pre><code class="language-go">// 将请求注册进入redis，保存一天\ncacheService := u.container.MustMake(contract.CacheKey).(contract.CacheService)\n\nkey := fmt.Sprintf("user:register:%v", user.Token)\nif err := cacheService.SetObj(ctx, key, user, 24*time.Hour); err != nil {\n   return nil, err\n}\nreturn user, nil\n</code></pre><p>但是你还记得吗，<strong>在hade的Cache服务中，如果直接使用SetObj和GetObj操作对象，那么这个对象必须实现BinaryMarshaler和BinaryUnMarshaler</strong>。所以我们再给User对象实现这两个接口。在app/provider/user/service.go中：</p><pre><code class="language-go">// MarshalBinary 实现BinaryMarshaler 接口\nfunc (b *User) MarshalBinary() ([]byte, error) {\n   return json.Marshal(b)\n}\n\n// UnmarshalBinary 实现 BinaryUnMarshaler 接口\nfunc (b *User) UnmarshalBinary(bt []byte) error {\n   return json.Unmarshal(bt, b)\n}\n</code></pre><p>于是，用户服务的Register方法实现就写好了。在这个小小的方法中，我们已经演示了之前定义的ORM服务、Cache服务，所有的这些服务在服务容器中都可以得到。你可以具体感受一下，容器加服务协议在具体的业务代码中带来的便利。</p><h3>发送邮件协议接口</h3><pre><code class="language-go">// SendRegisterMail 发送注册的邮件\n// 参数：user必填： username, password, email, token\nSendRegisterMail(ctx context.Context, user *User) error\n</code></pre><p>发送邮件协议接口要实现的就是一个邮件发送的功能。在Golang中邮件发送功能也是有现成库的，<a href="https://github.com/go-gomail/gomail">gomail</a>。这个库目前已经有3.4k star了，基于限制比较少的MIT协议。</p><p>发送电子邮件的方式其实有很多种，但是我们最好使用SMTP的方式来发送邮件，因为SMTP的服务提供方，基本上都是在互联网上已经认证的服务提供商，比如Gmail、126等。通过这些邮件服务提供商注册的SMTP账号发送邮件，基本上不会进入对方邮箱的“垃圾箱”中。</p><p>不过所有邮件服务提供商的SMTP账号都需要单独申请，但是基本都是免费的。这里是我使用126注册的邮箱申请了一个126的SMTP发送账号。</p><p>我们把SMTP的账号信息存储在配置文件config/development/app.yaml中：</p><pre><code class="language-yaml">domain: "http://hadecast.funaio.cn"\n\nsmtp:\n    host: "smtp.126.com"\n    port: 25\n    from: "jianfengye110@126.com"\n    username: "jianfengye110"\n    password: "123456"\n</code></pre><p>下面来演示如何使用gomail来通过SMTP账号发送邮件，我们直接看app/provider/user/service.go 的具体实现：</p><pre><code class="language-go">func (u *UserService) SendRegisterMail(ctx context.Context, user *User) error {\n   logger := u.container.MustMake(contract.LogKey).(contract.Log)\n   configer := u.container.MustMake(contract.ConfigKey).(contract.Config)\n\n   // 配置服务中获取发送邮件需要的参数\n   host := configer.GetString("app.smtp.host")\n   port := configer.GetInt("app.smtp.port")\n   username := configer.GetString("app.smtp.username")\n   password := configer.GetString("app.smtp.password")\n   from := configer.GetString("app.smtp.from")\n   domain := configer.GetString("app.domain")\n\n   // 实例化gomail\n   d := gomail.NewDialer(host, port, username, password)\n\n   // 组装message\n   m := gomail.NewMessage()\n   m.SetHeader("From", from)\n   m.SetAddressHeader("To", user.Email, user.UserName)\n   m.SetHeader("Subject", "感谢您注册我们的hadecast")\n   link := fmt.Sprintf("%v/user/register/verify?token=%v", domain, user.Token)\n   m.SetBody("text/html", fmt.Sprintf("请点击下面的链接完成注册：%s", link))\n\n   // 发送电子邮件\n   if err := d.DialAndSend(m); err != nil {\n      logger.Error(ctx, "send email error", map[string]interface{}{\n         "err":     err,\n         "message": m,\n      })\n      return err\n   }\n   return nil\n}\n</code></pre><p>首先通过hade的配置服务来获取SMTP的所有配置，使用这些配置实例化一个gomail.Dialer对象；然后创建邮件的内容，内容的From和To分别代表发送方和接收方，接收方自然就是我们的预注册用户填写的邮箱。将链接放在邮件的Body里面。组装好邮件内容之后，我们使用DailAndSend 就可以直接发送一个邮件到预注册的用户的邮箱了。</p><p>在这个过程中，<strong>我们会希望如果发送邮箱失败的话，使用日志记录一下发送失败的原因和内容</strong>。这个是很有必要的，因为后续如果希望有一些脚本能补发邮件，这个日志就很有帮助了。所以使用hade定义的日志服务，这里使用日志服务的Error方法来记录发送邮件错误信息。</p><p>不管配置服务还是日志服务，都是从服务容器中可以获取到。按照上述逻辑，发送邮件的接口就完成了。</p><h3>注册验证协议接口</h3><p>注册相关的最后一个协议接口是验证注册。</p><pre><code class="language-go">// VerifyRegister 注册用户，验证注册信息, 返回验证是否成功\nVerifyRegister(ctx context.Context, token string) (bool, error)\n</code></pre><p>这个协议接口逻辑会复杂一些了。</p><p>它的参数为一个token，我们首先要拿着这个token去缓存中，获取到这个token对应的预注册用户。由于之前已经将User实现了BinaryUnmarshaler接口，这里就使用缓存服务的GetObj方法：</p><pre><code class="language-go">//验证token\ncacheService := u.container.MustMake(contract.CacheKey).(contract.CacheService)\nkey := fmt.Sprintf("user:register:%v", token)\nuser := &amp;User{}\nif err := cacheService.GetObj(ctx, key, user); err != nil {\n   return false, err\n}\nif user.Token != token {\n   return false, nil\n}\n</code></pre><p>然后下一步，<strong>由于预注册和注册验证过程是异步的，中间数据库是有可能发生变化的</strong>，所以我们需要再次验证一下这个用户在数据库中是否已经存在了，他的用户名和邮箱是否是唯一的。</p><pre><code class="language-go">//验证邮箱，用户名的唯一\normService := u.container.MustMake(contract.ORMKey).(contract.ORMService)\ndb, err := ormService.GetDB()\nif err != nil {\n   return false, err\n}\nuserDB := &amp;User{}\nif db.Where(&amp;User{Email: user.Email}).First(userDB).Error != gorm.ErrRecordNotFound {\n   return false, errors.New("邮箱已注册用户，不能重复注册")\n}\nif db.Where(&amp;User{UserName: user.UserName}).First(userDB).Error != gorm.ErrRecordNotFound {\n   return false, errors.New("用户名已经被注册，请换一个用户名")\n}\n</code></pre><p>最后准备将这个缓存中的用户存储进入数据库users表。这里我们知道，缓存中预注册用户的密码是用户填写的真实密码。但是将真实密码直接存储进入数据库，是一个非常不安全的做法。如果我们的数据库被黑客攻击拖库了，这对我们的网站用户是个非常大的影响。所以这里我们<strong>有必要对用户的密码做一次加密操作</strong>。</p><p>Golang的 <a href="https://pkg.go.dev/golang.org/x/crypto/bcrypt">golang.org/x/crypto/bcrypt</a> 库提供了对密码进行加密的标准方法。还记得这种golang.org/x/ 开头的库么，可以说是Golang标准库的预备库，我们可以直接放心使用。在这个库中，提供了加密密码的方法 GenerateFromPassword 和验证密码的方法 CompareHashAndPassword 。</p><p>在这个函数中，我们就使用到加密密码的方法：</p><pre><code class="language-go">// 验证成功将密码存储数据库之前需要加密，不能原文存储进入数据库\nhash, err := bcrypt.GenerateFromPassword([]byte(user.Password), bcrypt.MinCost)\nif err != nil {\n   return false, err\n}\n</code></pre><p>GenerateFromPassword 的第二个参数cost，是表示加密密码的复杂度，最小必须为MinCost。</p><p>最后一步，就是将用户存储到数据库中了。同样使用的是Gorm，其中有个Create方法，能将对象保存进入数据库：</p><pre><code class="language-go">user.Password = string(hash)\n\n// 具体在数据库创建用户\nif err := db.Create(user).Error; err != nil {\n   return false, err\n}\nreturn true, nil\n</code></pre><p>以上，就完成了注册实现的具体方法了。</p><h2>后端调试</h2><p>现在，汇总两节课的成果，我们完成了用户服务、用户模块接口以及swagger的搭建。之后就可以很方便地使用swagger来调试用户模块和用户服务了。</p><p>记得开启hade特有的调试模式：  <code>./bbs dev backend</code></p><p><img src="https://static001.geekbang.org/resource/image/85/c6/8560931d5c87e56860fa87ca1e1b28c6.png?wh=1084x336" alt="图片"></p><p>打开浏览器 <a href="http://localhost:8070/swagger/index.html">http://localhost:8070/swagger/index.html</a> 看到swagger-UI界面。点击要调试接口的 “try it out” 按钮进入接口调用，填写要调用的接口参数，点击“Execute” 调用接口，并且获取接口返回值。</p><p><img src="https://static001.geekbang.org/resource/image/76/aa/765346a7f820dbfc8fa61408faffceaa.png?wh=1920x1111" alt="图片"></p><p><img src="https://static001.geekbang.org/resource/image/2c/25/2cf2bb0168135e98f02fb84016590a25.png?wh=1920x1068" alt="图片"></p><p>如果接口调用错误，我们要修改接口，只需要直接在IDE上修改代码，并且直接保存，hade就会检测到文件更新，并且重新编译重启服务，立刻生效。</p><p><img src="https://static001.geekbang.org/resource/image/9f/b1/9fa0d12a5548781869fd52041e080ab1.png?wh=1078x674" alt="图片"></p><h2>前端开发</h2><p>关于用户接口的前端开发部分，由于并不是我们课程的重点，就简要描述一下关键实现点。</p><p>前端一共就两个页面，注册页面和登录页面，所以我们在src/views/中创建两个文件夹，register和login，分别存储这两个页面。这里我主要也描述一下注册页面的具体实现。</p><p><img src="https://static001.geekbang.org/resource/image/26/08/2669c8cdbbfd66df207e8b97f06ba508.png?wh=788x848" alt="图片"></p><p>在注册页面上，实际上是搭建了一个表单，在element-UI中我们可以使用el-form来方便搭建一个漂亮的表单， 这个表单包含用户名、邮箱、密码等信息，并且这些信息都对应script中的form数据。在表单的按钮，按钮点击行为我们设置成触发submitFrom方法。在src/views/register/index.vue中：</p><pre><code class="language-plain">&lt;el-form v-model="form" class="register-form"&gt;\n  &lt;el-form-item &gt;\n    &lt;el-input v-model="form.username" placeholder="用户名" &gt;&lt;/el-input&gt;\n  &lt;/el-form-item&gt;\n  &lt;el-form-item &gt;\n    &lt;el-input v-model="form.email" placeholder="邮箱"&gt;&lt;/el-input&gt;\n  &lt;/el-form-item&gt;\n  &lt;el-form-item &gt;\n    &lt;el-input\n        placeholder="密码"\n        type="password"\n        v-model="form.password"\n    &gt;&lt;/el-input&gt;\n  &lt;/el-form-item&gt;\n  &lt;el-form-item &gt;\n    &lt;el-input\n        placeholder="确认密码"\n        type="password"\n        v-model="form.repassword"\n    &gt;&lt;/el-input&gt;\n  &lt;/el-form-item&gt;\n  &lt;el-form-item&gt;\n    &lt;el-button\n        :loading="loading"\n        class="login-button"\n        type="primary"\n        native-type="submit"\n        @click="submitForm"\n        block\n    &gt;注册&lt;/el-button&gt;\n  &lt;/el-form-item&gt;\n&lt;/el-form&gt;\n</code></pre><pre><code class="language-plain">&lt;script&gt;\nexport default {\n  name: "register",\n  data() {\n    return {\n      form: {\n        username: \'\', // 用户名\n        password: \'\', // 密码\n        email: \'\', // 邮箱\n        repassword: \'\' // 重复输入密码\n      },\n      loading: false,\n    };\n  },\n</code></pre><p>对应的submitFrom方法，就调用第30节课介绍的封装了axios库的request.js。我们使用request，并且传递上面输入的form对象数据给后端，如果请求返回成功，就返回返回体中的成功信息。</p><pre><code class="language-plain">methods: {\n  submitForm: function(e) {\n    if (this.form.repassword !== this.form.password) {\n      this.$message.error("两次输入密码不一致");\n      return;\n    }\n    const that = this;\n    request({\n      url: \'/user/register\',\n      method: \'post\',\n      data: this.form\n    }).then(function (response) {\n      const msg = response.data\n      that.$message.success(msg);\n    })\n  }\n}\n</code></pre><p>注册界面的开发就完成了，虽然逻辑比较简单，但也是使用了前面介绍的几个前端组件vue、element-Ui、axios，所以如果你看源码，对这几个组件的使用有一些疑惑的话，还是要研究一下每一个前端组件。</p><p>写完前端之后，别忘记我们的hade模块的强大调试功能之一：可以前后端同时调试。</p><p>使用命令 <code>./hade dev all</code> 开启前后端同时调试模式：</p><p><img src="https://static001.geekbang.org/resource/image/94/08/9422ea8fc5a9fc0f33d2348cfc340308.png?wh=1015x733" alt="图片"></p><p>控制台可以看到前端和后端都已经编译运行了。然后我们通过 <a href="http://localhost:8070/#/register">http://localhost:8070/#/register</a> 直接看到前端页面：</p><p><img src="https://static001.geekbang.org/resource/image/c1/b4/c1d21d6f0eb943f48a062d294820e4b4.png?wh=536x484" alt="图片"></p><p>如果我们发现接口或者页面有需要修改的地方，直接修改前后端的代码即可重新编译，直接调试：</p><p><img src="https://static001.geekbang.org/resource/image/bd/6a/bd0148ac02be4e707c9086fb6313036a.png?wh=471x244" alt="图片"></p><p>这节课我们实现了用户模块的前后端的开发，代码改动量较大，已经提交到 <a href="https://github.com/gohade/bbs/tree/geekbang/32">geekbang/32</a> 分支了。欢迎比对查看。</p><h2>小结</h2><p>这节课我们就完完整整做好了用户模块的开发。还是再啰嗦强调一下，后端开发的四个步骤：先将接口swaggger化、再定义用户服务协议、接着开发模块接口、最后实现用户服务协议。<strong>服务模块的协议设计不一定能一次性抽象好，可以从服务需要提供哪些对外能力”的角度来思考，从需求出发，遇到新的需求，不断迭代你的设计就可以</strong>。</p><p>同时关于前端开发，我们重点讲了一下如何使用element-UI来构建页面，以及如何使用axios来向后端发送请求。要掌握前后端都开发完成之后的调试方式，使用dev all 的调试模式来同时调试前后端，这个能让你的开发速度提高不少。</p><h3>思考题</h3><p>对于用户服务来说，我们定义了一个VerifyLogin的接口，根据token来获取对应的user信息。这个你觉得应该在哪里使用？怎么使用呢？</p><p>欢迎在留言区分享你的学习笔记。感谢你的收听，如果觉得今天的内容对你有所帮助，也欢迎分享给你身边的朋友，邀请他一起学习。下节课我们实战继续。</p>',
        article_title: "32｜通用模块（下）：用户模块开发",
      },
      {
        title: "33｜业务开发（上）：问答业务开发",
        id: 464227,
        content:
          '<p>你好，我是轩脉刃。</p><p>上两节课我们开发了一个完整的用户模块的前后端，并且运用了hade框架的不少命令行工具和基础服务。这节课，我们继续开发这个类知乎问答网站的另外一个比较大的业务模块：问答业务模块。</p><p>关于问答业务模块的开发，整体的开发流程和基本的使用方式和用户模块其实差不多，说到底这两个模块都是操作数据库中对应的数据表，我们同样使用先分析需求，再实现后端接口，最后是实现前端接口的流程。</p><p>问答模块，包含问题表、回答表和之前的用户表，这三个表之间有一些关联关系，在GORM中，如何使用这些关联关系建模，并且封装问答服务，接着对这些问答服务的方法提供足够的测试，是我们今天的解说重点。</p><h2>页面和接口设计</h2><p>还是先梳理一下问答模块页面，它包含四个页面：<strong>问题创建页、问题列表页、问题详情页、问题更新页</strong>。名称都很清晰，在问题更新页中，我们可以对某个问题进行更新修改。不过我们暂时不提供回答的修改功能，只提供回答的创建和删除功能。</p><h3>问题创建页</h3><p>在这个页面中，用户可以提出一个问题。提出问题的时候，让用户输入问题的标题和内容。通过点击提交，这个问题就提交进入数据库，并且在列表页面展示了。</p><p><img src="https://static001.geekbang.org/resource/image/ee/cc/eefc121a3a73216454cb31b462f2bacc.png?wh=853x780" alt="图片"></p><p>问题创建页明显就只会和后端有一个接口的交互，问题创建接口 /question/create。它是POST请求，请求参数包括问题标题 title和问题内容 context。我们用一个结构来表示这个接口的请求内容：</p><!-- [[[read_end]]] --><pre><code class="language-go">type questionCreateParam struct {\n   Title   string `json:"title" binding:"required"`\n   Content string `json:"content" binding:"required"`\n}\n</code></pre><p>返回值为问题是否创建成功的字符串说明：“操作成功”。</p><h3>问题列表页</h3><p>在列表页面中，我们按照创建时间顺序展示问题列表。列表页中的每一项都代表一个问题，展示的时候列出问题的标题、问题的内容（只显示200个字）、问题的创建时间、问题的创建者，以及问题的回答数。</p><p><img src="https://static001.geekbang.org/resource/image/1a/59/1a83f05477538yy52yy171aa6b657e59.png?wh=1062x1240" alt="图片"></p><p>考虑到当问题数比较多的时候，一个页面展示不下，我们为列表页设计一个分页逻辑，当页面下拉到底部的时候，会有“加载中”的字样去后端获取更多的列表信息。</p><p><img src="https://static001.geekbang.org/resource/image/21/3c/211596ccc4e13b50e9f4128a47fc1d3c.png?wh=889x715" alt="图片"></p><p>所以问题列表页的接口也比较简单。我们可以把这个页面开始的获取问题列表，和“加载中”功能的接口，设计为同一个：问题列表接口 /question/list。这个接口请求方法为GET，参数需要设计两个，一个参数start表示要从第几个问题开始加载，而另外一个参数size表示请求的问题个数。</p><p>对于页面初始化的问题列表，start为0，size为10，表示页面初始化，我们向后端获取10个问题；而对于后面的“加载中”的功能，我们的start为当前页面已经展示的问题数量，size同样为10，表示再加载10个问题，增加到问题列表页中。</p><p>然后这个接口最终返回的是一个问题数组，包含问题的标题、问题的内容、问题创建时间、问题创建用户，以及问题的回答数。</p><h3>问题详情页</h3><p>到达列表页之后，用户会进入问题详情页查看某个具体的问题，但是这个页面承载的功能远不止查看问题详情这么简单。</p><p>首先因为列表页只显示200字，这个页面要能展示问题详情。用户要能回答这个问题，那么这个页面的最下方还要有用户回答框，如果查看人想对某个问题进行回答，可以输入回答内容进行提交。所以也需要展示这个问题的所有回答列表。</p><p>有了问题和回答的新增，我们当然要考虑删除。这个页面展示的问题如果是查看人创建的，查看人可以操作将这个问题进行删除。同时，如果回答列表中展示的某个回答是查看人创建的，查看人有权限将这个回答进行删除。</p><p><img src="https://static001.geekbang.org/resource/image/33/2a/3374420cc6df2ccd00ee754f5fe30d2a.png?wh=869x919" alt="图片"></p><p>所以问题详情页的接口就比较多了，有4个接口。</p><ul>\n<li>问题详情接口 /question/detail</li>\n</ul><p>查看某个问题详情，并且在这个问题详情中，同时带有这个问题的所有回答，按照回答的创建时间倒序排列。</p><p>这个接口为GET请求，它的参数为一个id，表示问题的ID。返回值是问题详情，这个问题详情基本上和问题列表页中的问题是一个模型，但是还要带有一个回答列表信息，把这个问题的所有回答都返回。</p><ul>\n<li>回答创建接口 /answer/create</li>\n</ul><p>这个接口的功能是创建一个回答，它是POST请求，参数有两个：question_id，代表回答对应的问题ID；content，代表回答的具体内容。我们用一个数据结构来代表这个接口的参数：</p><pre><code class="language-go">type answerCreateParam struct {\n   QuestionID int64  `json:"question_id" binding:"required"`\n   Content    string `json:"content" binding:"required"`\n}\n</code></pre><p>接口的返回值是操作成功或者失败的信息。</p><ul>\n<li>回答删除接口 /answer/delete</li>\n</ul><p>这个接口功能是删除某个回答，它是GET请求，参数为id，表示回答的具体ID。当然在接口的后端逻辑中，我们必须判断这个回答是否是查看人所创建的，如果不是的话，这个接口是不允许进行操作的。接口的返回值就返回操作成功或者失败的信息即可。</p><ul>\n<li>问题删除接口 /question/delete</li>\n</ul><p>这个接口功能是删除某个问题，它是GET请求，参数为id，表示问题的具体ID，和回答的删除接口一个操作。</p><h3>问题更新页</h3><p>在这个页面中，用户可以对某个自己提出的问题的内容进行修改。这个页面和问题创建页有类似的页面布局，不同的是进入的时候，问题标题和内容都是有具体内容的。</p><p><img src="https://static001.geekbang.org/resource/image/17/31/17a7595880f3f688e37c22b380209131.png?wh=864x776" alt="图片"></p><p>问题更新页接口就一个，负责完成更新某个问题的功能。更新问题接口 /question/edit，我们允许更新问题的标题和内容，所以这个接口参数有三个：问题ID，表示更新的哪个问题；标题title，表示更新的问题标题；内容content，表示要更新的问题内容。我们定义一个数据结构来表示这个接口的参数：</p><pre><code class="language-go">type questionEditParam struct {\n   ID      int64  `json:"id" binding:"required"`\n   Title   string `json:"title" binding:"required"`\n   Content string `json:"content" binding:"required"`\n}\n</code></pre><p>返回值是操作成功或者失败的消息。</p><p>好最后我们梳理一下，关于问答模块，一共要开发七个接口。</p><ul>\n<li>问题创建接口 /question/create</li>\n<li>问题列表接口 /question/list</li>\n<li>问题详情接口 /question/detail</li>\n<li>问题删除接口 /question/delete</li>\n<li>更新问题接口 /question/edit</li>\n<li>回答创建接口 /answer/create</li>\n<li>回答删除接口 /answer/delete</li>\n</ul><h2>后端开发</h2><p>接口定义好，下面就是后端开发了。还记得开发用户模块的时候说过的后端开发四个步骤吗，接口swagger化、定义用户服务协议、开发模块接口、实现用户服务协议，这四个步骤具体负责的内容就不赘述了。今天qa模块的开发，我们仍然沿用这四个步骤。</p><h3>接口swagger化</h3><p>首先使用注释将前面定义的七个接口的说明、参数、返回值全部swagger化。</p><p>因为问题列表页面和问题详情页面，都会使用到输出“问题”和“回答”这两种结构，还记得第31章我们讨论的模型设计吗，DTO层模型负责前端和后端接口的数据传输，定义了这个DTO层的模型，前端和后端的同学就能依照这个模型来并行开发了。所以我们设计DTO层的模型。</p><pre><code class="language-go">// QuestionDTO 问题列表返回结构\ntype QuestionDTO struct {\n   ID        int64     `json:"id,omitempty"`\n   Title     string    `json:"title,omitempty"`\n   Context   string    `json:"context,omitempty"` // 在列表页，只显示前200个字符\n   AnswerNum int       `json:"answer_num"`\n   CreatedAt time.Time `json:"created_at"`\n   UpdatedAt time.Time `json:"updated_at"`\n   Author  *user.UserDTO `json:"author,omitempty"`  // 作者\n   Answers []*AnswerDTO  `json:"answers,omitempty"` // 回答\n}\n// AnswerDTO 回答返回结构\ntype AnswerDTO struct {\n   ID        int64     `json:"id,omitempty"`\n   Content   string    `json:"content,omitempty"`\n   CreatedAt time.Time `json:"created_at"`\n   UpdatedAt time.Time `json:"updated_at"`\n   Author *user.UserDTO `json:"author,omitempty"` // 作者\n}\n</code></pre><p>我们可以看到，在DTO层，各个DTO是有关联的，QuestionDTO关联了UserDTO和AnswerDTO，而AnswerDTO 关联了UserDTO。<strong>这样关联其实是非常合理的。后续我们输出给前端的数据模型就固定了</strong>，比如要输出用户，前端就知道我们一定会输出一个UserDTO的数据模型，能减少前后端的沟通障碍。</p><p>然后编写接口方法并注册到路由中：</p><pre><code class="language-go">// RegisterRoutes 注册路由\nfunc RegisterRoutes(r *gin.Engine) error {\n   api := &amp;QAApi{}\n   if !r.IsBind(qa.QaKey) {\n      r.Bind(&amp;qa.QaProvider{})\n   }\n   questionApi := r.Group("/question", auth.AuthMiddleware())\n   {\n      // 问题列表\n      questionApi.GET("/list", api.QuestionList)\n      // 问题详情\n      questionApi.GET("/detail", api.QuestionDetail)\n      // 创建问题\n      questionApi.POST("/create", api.QuestionCreate)\n      // 删除问题\n      questionApi.POST("/delete", api.QuestionDelete)\n      // 更新问题\n      questionApi.POST("/edit", api.QuestionEdit)\n   }\n   answerApi := r.Group("/answer", auth.AuthMiddleware())\n   {\n      // 创建回答\n      answerApi.POST("/create", api.AnswerCreate)\n      // 删除回答\n      answerApi.POST("/delete", api.AnswerDelete)\n   }\n\n   return nil\n}\n</code></pre><p>最后按照swaggo的方式来编写swagger的注释，以获取问题详情的接口为例：</p><pre><code class="language-go">// QuestionDetail 获取问题详情\n// @Summary 获取问题详细\n// @Description 获取问题详情，包括问题的所有回答\n// @Accept  json\n// @Produce  json\n// @Tags qa\n// @Param id query int true "问题id"\n// @Success 200 QuestionDTO question "问题详情，带回答和作者"\n// @Router /question/detail [get]\nfunc (api *QAApi) QuestionDetail(c *gin.Context) {\n    ...\n}\n</code></pre><p>最后我们使用  <code>./bbs swagger gen</code> 生成swagger文件，并且编译 <code>./bbs build self</code> ，编译进入 bbs 文件，最后再使用  <code>./bbs dev backend</code> 展示swagger-UI界面如图：<br>\n<img src="https://static001.geekbang.org/resource/image/4e/39/4e5743b52483ab31e75481d818b05739.png?wh=1920x638" alt="图片"></p><h2>qa服务设计</h2><p>接口swagger化之后，接下来就要设计qa服务了。关于qa服务，我们同样先处理模型，将DO层模型和PO层模型合并，统一使用一个数据模型来定义。</p><h3>问题/回答模型</h3><p>代表问题的模型Question 和代表回答的模型Answer。</p><pre><code class="language-go">// Question 代表问题\ntype Question struct {\n   ID        int64          `gorm:"column:id;primaryKey"`\n   Title     string         `gorm:"column:title;comment:标题"`\n   Context   string         `gorm:"column:context;comment:内容"`\n   AuthorID  int64          `gorm:"column:author_id;comment:作者id;not null;default:0"`\n   AnswerNum int            `gorm:"column:answer_num;comment:回答数;not null;default:0"`\n   CreatedAt time.Time      `gorm:"column:created_at;autoCreateTime;comment:创建时间"`\n   UpdatedAt time.Time      `gorm:"column:updated_at;autoUpdateTime;&lt;-:false;comment:更新时间"`\n   DeletedAt gorm.DeletedAt `gorm:"index"`\n   Author    *user.User     `gorm:"foreignKey:AuthorID"`\n   Answers   []*Answer      `gorm:"foreignKey:QuestionID"`\n}\n\n// Answer 代表一个回答\ntype Answer struct {\n   ID         int64          `gorm:"column:id;primaryKey"`\n   QuestionID int64          `gorm:"column:question_id;index;comment:问题id;not null;default 0"`\n   Content    string         `gorm:"column:context;comment:内容"`\n   AuthorID   int64          `gorm:"column:author_id;comment:作者id;not null;default:0"`\n   CreatedAt  time.Time      `gorm:"column:created_at;autoCreateTime;comment:创建时间"`\n   UpdatedAt  time.Time      `gorm:"column:updated_at;autoUpdateTime;&lt;-:false;comment:更新时间"`\n   DeletedAt  gorm.DeletedAt `gorm:"index"`\n   Author     *user.User     `gorm:"foreignKey:AuthorID"`\n   Question   *Question      `gorm:"foreignKey:QuestionID"`\n}\n</code></pre><p>你可以看到，我们使用了非常丰富的Gorm的tag标签。在Gorm的使用中，一个必须要掌握的就是tag标签的运用，<strong>你的tag标签使用的好，就能节省很多代码量</strong>。这是今天的重点，我们来详细说明一下。</p><ul>\n<li>index</li>\n</ul><p>在我们的数据表中，除了主键索引之外，很有可能需要建立其他某个字段的索引，比如回答模型一定少不了根据问题ID查询出所有的回答。那么我们需要针对问题ID，在回答表中建立一个索引，就可以使用 index 的标签来表示这个索引。</p><pre><code class="language-go">   QuestionID int64          `gorm:"column:question_id;index;comment:问题id;not null;default 0"`\n</code></pre><ul>\n<li>not null 和 default</li>\n</ul><p>还有一个细节，数据库中每个字段默认都是允许为null的，但是我们在获取数据的时候，并不希望这个数据会为null，比如问题表中的回答数字段，我们希望它不为空，默认为0，就可以使用 not null 和 default 两个标签来设置。</p><pre><code class="language-go">   AnswerNum int            `gorm:"column:answer_num;comment:回答数;not null;default:0"`\n</code></pre><ul>\n<li>time</li>\n</ul><p>另外，问题表和回答表都有创建时间和更新时间，其中，创建时间我们希望在使用创建数据的方法Create时自动填充，而更新时间也希望能在更新时自动填充。一方面，这样服务调用者就能少顾虑到一些“时间”方面的逻辑，另一方面，这种“时间”的管理，我们封闭在服务内部，如果调用者逻辑错误，也不会导致这两个时间是有问题的。</p><p>所以我们使用autoCreateTime、autoUpdateTime、&lt;-:false 分别表示创建数据自动更新时间、更新数据自动更新时间、禁止写入。</p><pre><code class="language-go">CreatedAt  time.Time      `gorm:"column:created_at;autoCreateTime;comment:创建时间"`\nUpdatedAt  time.Time      `gorm:"column:updated_at;autoUpdateTime;&lt;-:false;comment:更新时间"`\n</code></pre><ul>\n<li>DeletedAt</li>\n</ul><p>问题和回答的数据一定存在需要删除的行为，但是删除时，我们又不希望真正删除数据，<strong>而是希望采用软删除的方式，也就是为数据某个字段打一个标记来标记删除</strong>。</p><p>这种软删除的方式在实际业务中是有可能有需求的，比如有的问题和回答是先审批再展示出来的，我们可以先标记为软删除，审批完成之后再放出来；或者用户或者运营同学点击了删除某个问题，但是属于误操作，软删除就为恢复数据提供了可能性。</p><p>Gorm提供了 gorm.DeletedAt 的字段类型来表示这个软删除的逻辑，所以在问题表和回答表中我们加上这个DeletedAt字段来标记；同时由于这个字段用来标记是否删除，所以我们在查询的时候一定会经常使用到这个字段进行索引，对这个字段使用index的标签来创建一个索引也是非常必要的。</p><pre><code class="language-go">DeletedAt  gorm.DeletedAt `gorm:"index"`\n</code></pre><ul>\n<li>foreignKey</li>\n</ul><p>最后，对于ORM来说，问题对象和回答对象其实是一对多的关系，它们之间其实是有外键关联的，回答对象中的QuestionID和问题对象的ID字段是关联的。</p><p>我们可以为回答表创建一个外键：</p><pre><code class="language-go">type Answer struct {\n  ...\n  QuestionID int64          `gorm:"column:question_id;index;comment:问题id;not null;default 0"`\n  Question   *Question      `gorm:"foreignKey:QuestionID"`\n}\n</code></pre><p>Answer结构和Question结构是“属于关系”（<a href="https://gorm.io/zh_CN/docs/belongs_to.html">Belongs To</a>），一个回答属于一个问题，所以这里的Question结构，它使用了一个外键，告诉DB，Answer结构中的QuestionID字段，是我的属主的主键，根据QuestionID字段去查找Question结构。</p><p>同时相对应的，我们为问题表创建一个回答表的数组：</p><pre><code class="language-go">type Question struct {\n   ...\n   Answers   []*Answer      `gorm:"foreignKey:QuestionID"`\n}\n</code></pre><p>相反的，Question结构和Answer结构就属于“包含许多”（<a href="https://gorm.io/zh_CN/docs/has_many.html">Has Many</a>）, 一个问题包含许多个回答，它这里的外键tag标记为QuestionID，表示，我这个问题的回答有很多，它们为Answer结构中QuestionID为主键的数据。</p><p>BelongsTo、 HasMany，是Gorm中的关联逻辑，更多的解释和查看用法可以参考官网的<a href="https://gorm.io/zh_CN/docs/belongs_to.html">关联</a>部分的说明。</p><p><strong>ORM做这个外键约束有什么好处呢？它能让Gorm提供的“<a href="https://gorm.io/zh_CN/docs/preload.html">预加载</a>”功能成为可能</strong>。这个预加载的功能在实际开发过程中是非常好用的。比如现在有多个问题的数组对象questions，想要获取每一个问题的所有回答，原本我们是需要自己再手写一个ORM的SQL查询来获取。</p><pre><code class="language-go">questionIds := []int64{}\nfor _, question := range questions {\n  questionIds := append(questionIds, question.ID)\n}\n\ndb.Where(map[string]interface{}{"question_id", questionIds}).Find(&amp;answers)\n</code></pre><p>但是一旦有了外键约束，我们就可以使用预加载的功能，一行代码直接将这些问题数组对应的回答获取回来了：</p><pre><code class="language-go">db.Preload("Answers").Find(questions)\n</code></pre><p>这样在获取的questions中，每个问题对象的Answers字段都带有一个回答数组了，非常方便。</p><h3>分页模型</h3><p>除了问题和回答两个模型，在问题列表页还会根据分页信息来获取每一页的问题列表。所以我们还需要一个分页模型Pager，包含起始位置Start、获取的数据个数Size，还有一个Total代表一共有多少数据。</p><pre><code class="language-go">// Pager 代表分页机制\ntype Pager struct {\n   Total int64 // 共有多少数据，只有返回值使用\n   Start int   // 起始位置\n   Size  int   // 获取的数据个数\n}\n</code></pre><h2>协议</h2><p>模型定义完成，下面我们就要来定义服务对外提供的协议接口了。qa服务虽然接口比较多，但是它的接口逻辑却并不复杂，基本上都围绕问题、回答两个模型的增删改查进行，也就是说，我们qa服务对外提供的协议，基本上也就是围绕这两个对象的增删改查进行的。</p><p>首先围绕问题这个模型。</p><p>需要创建问题的接口PostQuestion，直接把Question模型作为参数即可。创建完问题，我们需要获取问题，那么就要有GetQuestion接口，同时也需要有批量获取Question的接口GetQuestions。创建问题结束，我们可能要修改问题，那么可以有一个修改问题的接口UpdateQuestion。最后就是删除问题接口DeleteQuestion。</p><pre><code class="language-go">// Service 代表qa的服务\ntype Service interface {\n\n   // GetQuestions 获取问题列表，question简化结构\n   GetQuestions(ctx context.Context, pager *Pager) ([]*Question, error)\n   \n   // GetQuestion 获取某个问题详情，question简化结构\n   GetQuestion(ctx context.Context, questionID int64) (*Question, error)\n   \n   // PostQuestion 上传某个问题\n   // ctx必须带操作人id\n   PostQuestion(ctx context.Context, question *Question) error\n\n   // DeleteQuestion 删除问题，同时删除对应的回答\n   // ctx必须带操作人信息\n   DeleteQuestion(ctx context.Context, questionID int64) error\n\n   // UpdateQuestion 代表更新问题, 只会对比其中的context，title两个字段，其他字段不会对比\n   // ctx必须带操作人\n   UpdateQuestion(ctx context.Context, question *Question) error\n}\n</code></pre><p>这里我们关注一下获取问题的两个接口，GetQuestion和GetQuestions，它们返回的是Question模型和Question模型数组。</p><p>但是有一点要注意，在前面，我们定义的Question模型是带有“外键”属性的，比如问题的作者Author、问题的回答Answer。<strong>这些属性，我们希望由上层业务“按需加载”</strong>。</p><p>也就是说在服务层，获取问题和获取问题列表默认是没有作者和回答的，如果上层业务需要的话，请重新调用接口来获取。所以这里我们多出了四个接口：单个问题加载作者、多个问题加载作者、单个问题加载回答、多个问题加载回答。</p><pre><code class="language-go">// Service 代表qa的服务\ntype Service interface {\n\n   // QuestionLoadAuthor 问题加载Author字段\n   QuestionLoadAuthor(ctx context.Context, question *Question) error\n   \n   // QuestionsLoadAuthor 批量加载Author字段\n   QuestionsLoadAuthor(ctx context.Context, questions *[]*Question) error\n\n   // QuestionLoadAnswers 单个问题加载Answers\n   QuestionLoadAnswers(ctx context.Context, question *Question) error\n   \n   // QuestionsLoadAnswers 批量问题加载Answers\n   QuestionsLoadAnswers(ctx context.Context, questions *[]*Question) error\n\n}\n</code></pre><p>在使用的时候注意一下，多个问题加载的方法中，第二个参数传递的是指向slice的指针 *[]*Question。因为我们在调用接口的时候，会重新修改这个指针指向的slice。修改的时候是有可能变更原先slice地址的，所以这里使用了“指向slice的指针”。</p><p>再看围绕“回答”这个模型。</p><p>我们一样需要有创建回答接口PostAnswer、删除回答接口DeleteAnswer、获取回答接口GetAnswer。由于产品设计上并不允许对回答进行修改，所以这里暂时不需要更新回答的接口。</p><p>同样我们也提供“回答”作者信息的按需加载，也就是单个回答的按需加载AnswerLoadAuthor和多个回答的按需加载AnswersLoadAuthor两个方法：</p><pre><code class="language-go">// Service 代表qa的服务\ntype Service interface {\n\n   // PostAnswer 上传某个回答\n   // ctx必须带操作人信息\n   PostAnswer(ctx context.Context, answer *Answer) error\n   \n   // GetAnswer 获取回答\n   GetAnswer(ctx context.Context, answerID int64) (*Answer, error)\n\n   // AnswerLoadAuthor 问题加载Author字段\n   AnswerLoadAuthor(ctx context.Context, question *Answer) error\n   // AnswersLoadAuthor 批量加载Author字段\n   AnswersLoadAuthor(ctx context.Context, questions *[]*Answer) error\n\n   // DeleteAnswer 删除某个回答\n   // ctx必须带操作人信息\n   DeleteAnswer(ctx context.Context, answerID int64) error\n}\n</code></pre><p>好了，qa服务的后端服务协议我们就定义完成了，一共有14个协议接口，代表qa服务对外提供的14种能力。所有代码都存放到 GitHub上的<a href="https://github.com/gohade/bbs/tree/geekbang/33">geekbang/33 </a>上了。对应的文档截图也放在这里，欢迎对比查看。</p><p><img src="https://static001.geekbang.org/resource/image/23/8b/23aac201f21227bc8ab1833ae5605e8b.png?wh=734x1414" alt="图片"></p><h2>小结</h2><p>今天我们主要定义了问答服务的两个协议，一个是前端和后端的协议接口，将接口的输出、输入以swagger-UI的形式表现，另外一个是后端问答服务的协议，一共14个接口。</p><p>除了让你再熟悉一遍后端开发模块的四步骤之外，通过今天的实战，希望你能熟练掌握Gorm的模型定义，Gorm的tag是个非常强大的存在，定义好了这个tag，才能真正将之前我们引入ORM的利益最大化，这一点在下节课实现qa服务协议的时候也会领略到。</p><h3>思考题</h3><p>定义好Gorm模型的tag，不仅仅能节省我们操作数据库的逻辑，还能根据ORM创建数据表，这里需要用到Gorm中提供的<a href="https://gorm.io/zh_CN/docs/migration.html">Auto Migrations</a>功能。实际上，我在单元测试的时候，往测试数据库中创建表就是使用这个功能，你不妨尝试根据这节课定义的Question和Answer，往自己的测试数据库中创建两张表questions和answers。</p><p>欢迎在留言区分享你的学习笔记。感谢你的收听，如果你觉得今天的内容对你有所帮助，也欢迎分享给你身边的朋友，邀请他一起学习。我们下节课实战继续。</p>',
        article_title: "33｜业务开发（上）：问答业务开发",
      },
      {
        title: "34｜业务开发（下）：问答业务开发",
        id: 464834,
        content:
          '<p>你好，我是轩脉刃。</p><p>上节课我们已经完成了问答业务的一部分开发，主要是两部分，前后端接口设计，把接口的输出、输入以swagger-UI的形式表现；以及后端问答服务的接口设计，一共14个接口。这节课我们就继续完成问答的业务开发。</p><p>还是先划一下今天的重点，我们先使用前面定义的问答服务协议接口，来完成业务模块的接口开发，验证问答服务的协议接口是否满足需求，然后再实现我们的问答服务协议。不过因为这次问答服务实现的接口比较多，0 bug有一定难度，所以会为问答服务写一下单元测试，希望你重点掌握。</p><p>最后，我们实现前端的Vue页面，同样，由于前端页面的编写不是课程重点，还是挑重点的实现难点解说一下。</p><p>下面开始我们今天的实战吧。</p><h2>开发模块接口</h2><p>上一节课定义好了问答服务的14个接口，可以使用这14个接口来实现业务模块了。我们的业务模块接口有七个接口需要开发：</p><ul>\n<li>问题创建接口 /question/create</li>\n<li>问题列表接口 /question/list</li>\n<li>问题详情接口 /question/detail</li>\n<li>问题删除接口 /question/delete</li>\n<li>更新问题接口 /question/edit</li>\n<li>回答创建接口 /answer/create</li>\n<li>回答删除接口 /answer/delete</li>\n</ul><!-- [[[read_end]]] --><p>这里就挑选关于问题的两个复杂一点的接口来具体说明一下，问题创建接口/question/create、问题详情接口 /question/detail 。</p><h3>问题创建接口</h3><p>问题创建接口，为post方法，上一节课我们已经定义了它的参数结构questionCreateParam。那么要实现这个接口的剩余步骤就是：</p><ul>\n<li>解析参数</li>\n<li>获取登录用户信息</li>\n<li>使用登录用户创建一个问题</li>\n<li>返回“操作成功”</li>\n</ul><p>解析参数我们在用户模块说过了，使用Gorm的Bind系列方法，能方便解析参数的时候并且验证参数：</p><pre><code class="language-go">param := &amp;questionCreateParam{}\nif err := c.ShouldBind(param); err != nil {\n   c.ISetStatus(400).IText(err.Error())\n   return\n}\n</code></pre><p>获取登录用户信息，也使用在用户模块实现的中间件。</p><p>这个中间件，我们在第32章的课后问题中布置给你作为课后作业，这里也说一下答案。<strong>对于需要用户登录才能操作的接口，我们都让这些接口通过一个中间件Auth</strong>。在Auth中，验证前端传递的cookie，从cookie中获取到token，然后通过token去缓存中获取用户信息。</p><pre><code class="language-go">// AuthMiddleware 登录中间件\nfunc AuthMiddleware() gin.HandlerFunc {\n   return func(c *gin.Context) {\n      envService := c.MustMake(contract.EnvKey).(contract.Env)\n      userService := c.MustMake(user.UserKey).(user.Service)\n      // 如果在调试模式下，根据参数的user_id 获取信息\n      if envService.AppEnv() == contract.EnvDevelopment {\n         userID, exist := c.DefaultQueryInt64("user_id", 0)\n         if exist {\n            authUser, _ := userService.GetUser(c, userID)\n            if authUser != nil {\n               c.Set("auth_user", authUser)\n               c.Next()\n               return\n            }\n         }\n      }\n\n      token, err := c.Cookie("hade_bbs")\n      if err != nil || token == "" {\n         c.ISetStatus(401).IText("请登录后操作")\n         return\n      }\n\n      authUser, err := userService.VerifyLogin(c, token)\n      if err != nil || authUser == nil {\n         c.ISetStatus(401).IText("请登录后操作")\n         return\n      }\n\n      c.Set("auth_user", authUser)\n\n      c.Next()\n   }\n}\n</code></pre><p>在这个中间件中，我们获取到用户信息，将用户信息存储到Gin的context中，key名字为auth_user。同时为这个中间件创建一个获取这个用户信息的方法，GetAuthUser。这个方法比较简单，直接从gin.Context中获取认证用户信息。</p><p>为什么获取用户信息的方法，也定义在Auth中间件中呢？因为这样设计之后，<strong>认证用户的所有逻辑，都放在这个Auth中间件中了，能保证“同类”逻辑封装在一个模块或者一个文件中</strong>，不管是从代码优雅角度，还是查找追查问题角度都很方便，这个算是一个编程经验吧。</p><pre><code class="language-go">// GetAuthUser 获取已经验证的用户\nfunc GetAuthUser(c *gin.Context) *user.User {\n   t, exist := c.Get("auth_user")\n   if !exist {\n      return nil\n   }\n   return t.(*user.User)\n}\n</code></pre><p>回到我们的问题创建接口，在第二步，调用一下Auth中间件的GetAuthUser方法，就能获取到当前的登录用户了。</p><p>第三步，就是最核心的创建问题接口，我们调用用户服务的PostQuestion就能完成这个逻辑了。注意的是，要创建问题的AuthorID字段，我们使用的是上一步的登录用户ID。</p><pre><code class="language-go">question := &amp;provider.Question{\n   Title:    param.Title,\n   Context:  param.Content,\n   AuthorID: user.ID,  // 这里的user是我们的登录用户\n}\n// 创建问题\nif err := qaService.PostQuestion(c, question); err != nil {\n   c.ISetStatus(500).IText(err.Error())\n   return\n}\n</code></pre><p>最后，使用链式调用方法返回操作成功：</p><pre><code class="language-go">c.ISetOkStatus().IText("操作成功")\n</code></pre><h3>问题详情接口</h3><p>问题详情接口，可能是所有接口里面使用qa服务最多的业务接口了，我们单独拿出来梳理一下逻辑，分为六个步骤：</p><ol>\n<li>解析参数</li>\n<li>获取问题详情</li>\n<li>加载问题作者</li>\n<li>加载问题答案</li>\n<li>问题答案加载答案作者</li>\n<li>返回数据</li>\n</ol><p>不过步骤多一点，实现倒不复杂，第二步到第五步，分别使用了qaService的 GetQuestion、QuestionLoadAuthor、QuestionLoadAnswers、AnswersLoadAuthor，代码如下：</p><pre><code class="language-go">func (api *QAApi) QuestionDetail(c *gin.Context) {\n   qaService := c.MustMake(provider.QaKey).(provider.Service)\n   id, exist := c.DefaultQueryInt64("id", 0)\n   if !exist {\n      c.ISetStatus(400).IText("参数错误")\n      return\n   }\n   // 获取问题详情\n   question, err := qaService.GetQuestion(c, id)\n   if err != nil {\n      c.ISetStatus(500).IText(err.Error())\n      return\n   }\n   // 加载问题作者\n   if err := qaService.QuestionLoadAuthor(c, question); err != nil {\n      c.ISetStatus(500).IText(err.Error())\n      return\n   }\n   // 加载所有答案\n   if err := qaService.QuestionLoadAnswers(c, question); err != nil {\n      c.ISetStatus(500).IText(err.Error())\n      return\n   }\n   // 加载答案的所有作者\n   if err := qaService.AnswersLoadAuthor(c, &amp;question.Answers); err != nil {\n      c.ISetStatus(500).IText(err.Error())\n      return\n   }\n   // 输出转换\n   questionDTO := ConvertQuestionToDTO(question, nil)\n   c.ISetOkStatus().IJson(questionDTO)\n}\n\n</code></pre><p>这里就实现了两个接口，问题创建接口和问题详情接口，其他接口的具体实现可以参考GitHub上的 <a href="https://github.com/gohade/bbs/tree/geekbang/34">geekbang/34</a> 分支。</p><h2>实现用户服务协议</h2><p>简单回顾一下上节课定义的qa服务的14个后端服务协议：</p><pre><code class="language-go">// Service 代表qa的服务\ntype Service interface {\n\n   // GetQuestions 获取问题列表，question简化结构\n   GetQuestions(ctx context.Context, pager *Pager) ([]*Question, error)\n   \n   // GetQuestion 获取某个问题详情，question简化结构\n   GetQuestion(ctx context.Context, questionID int64) (*Question, error)\n   \n   // PostQuestion 上传某个问题\n   // ctx必须带操作人id\n   PostQuestion(ctx context.Context, question *Question) error\n\n   // DeleteQuestion 删除问题，同时删除对应的回答\n   // ctx必须带操作人信息\n   DeleteQuestion(ctx context.Context, questionID int64) error\n\n   // UpdateQuestion 代表更新问题, 只会对比其中的context，title两个字段，其他字段不会对比\n   // ctx必须带操作人\n   UpdateQuestion(ctx context.Context, question *Question) error\n\n\n   // QuestionLoadAuthor 问题加载Author字段\n   QuestionLoadAuthor(ctx context.Context, question *Question) error\n   \n   // QuestionsLoadAuthor 批量加载Author字段\n   QuestionsLoadAuthor(ctx context.Context, questions *[]*Question) error\n\n   // QuestionLoadAnswers 单个问题加载Answers\n   QuestionLoadAnswers(ctx context.Context, question *Question) error\n   \n   // QuestionsLoadAnswers 批量问题加载Answers\n   QuestionsLoadAnswers(ctx context.Context, questions *[]*Question) error\n\n\n   // PostAnswer 上传某个回答\n   // ctx必须带操作人信息\n   PostAnswer(ctx context.Context, answer *Answer) error\n   \n   // GetAnswer 获取回答\n   GetAnswer(ctx context.Context, answerID int64) (*Answer, error)\n\n   // AnswerLoadAuthor 问题加载Author字段\n   AnswerLoadAuthor(ctx context.Context, question *Answer) error\n   // AnswersLoadAuthor 批量加载Author字段\n   AnswersLoadAuthor(ctx context.Context, questions *[]*Answer) error\n\n   // DeleteAnswer 删除某个回答\n   // ctx必须带操作人信息\n   DeleteAnswer(ctx context.Context, answerID int64) error\n}\n</code></pre><h3>服务实现</h3><p>下面我们就来实现这14个协议接口，有两个需要注意的函数重点说明一下，PostAnswer、AnswersLoadAuthor。</p><ul>\n<li>PostAnswer</li>\n</ul><p>增加回答的服务PostAnswer，这个接口的逻辑会比其他逻辑复杂一些。</p><pre><code class="language-go">func (q *QaService) PostAnswer(ctx context.Context, answer *Answer) error\n</code></pre><p>可以看到，它的参数就是一个answer结构，但是我们仔细想想，<strong>并不是简单将answer表创建一条新数据就行的，还需要做一个事情，将这个回答所归属问题的回答数+1</strong>。所以这里有一个查询问题。</p><p>我们可以把在answer表创建一条新数据的逻辑，和增加问题回答数的逻辑放在一起。这里会有多次去数据库的操作，需要将它们封成一个事务来做，否则的话，就会出现比如创建回答了，但是问题回答数没有+1；或者两个事务都对一个问题回答数操作，出现脏数据。</p><p>所以需要使用Gorm的事务函数Transaction，将这个函数内的所有数据库操作封装起来。</p><pre><code class="language-go">func (q *QaService) PostAnswer(ctx context.Context, answer *Answer) error {\n   if answer.QuestionID == 0 {\n      return errors.New("问题不存在")\n   }\n   // 必须使用事务\n   err := q.ormDB.WithContext(ctx).Transaction(func(tx *gorm.DB) error {\n      question := &amp;Question{ID: answer.QuestionID}\n      // 获取问题\n      if err := tx.First(question).Error; err != nil {\n         return err\n      }\n      // 增加回答\n      if err := tx.Create(answer).Error; err != nil {\n         return err\n      }\n      // 问题回答数量+1\n      question.AnswerNum = question.AnswerNum + 1\n      if err := tx.Save(question).Error; err != nil {\n         return err\n      }\n      return nil\n   })\n   if err != nil {\n      return err\n   }\n\n   return nil\n}\n</code></pre><p>从上面代码可以看到，我们将查询问题、插入回答、增加问题回答数封装在一个事务中，这样一旦其中有数据库操作失败，那么整个操作都会失败，并且回滚，保证几个数据表的数据一致性。</p><ul>\n<li>AnswersLoadAuthor</li>\n</ul><p>再看一下对多个回答加载回答作者的方法，AnswersLoadAuthor：</p><pre><code class="language-go">func (q *QaService) AnswersLoadAuthor(ctx context.Context, answers *[]*Answer) error\n</code></pre><p>参数中传递了带有回答ID的answers结构，所以我们需要将ID全部查询出来。</p><p>也就是说需要在一个指针数组中，将某个字段查询出来，并且做成数组，怎么做？这里我使用的是第三方库 <a href="https://github.com/jianfengye/collection">collection</a>，我之前开源的一个作品，目前有560+的star，基于 Apache 协议开源。这个库最大的特点就是对“数组”进行一些特殊操作。</p><p>比如这里的，将一个数组指针的ID字段获取出来，组装成一个int64数组，就可以这么用：</p><pre><code class="language-go">answerColl := collection.NewObjPointCollection(*answers)\nids, err := answerColl.Pluck("ID").ToInt64s()\n</code></pre><p>先New一个指针数组，然后使用Pluck，将某个字段获取出来，再使用 toInt64s 将获取出来的数组转位 []int64 数组。</p><p>回到Answer结构，ID已经获取了，怎么查找对应作者呢？</p><p>还记得吗，上一节课我们已经<strong>在Answer结构中，设置了Answer和User结构的Belongs To关系</strong>，所以这里可以直接使用Preload方法，加载Answers中的Author字段：</p><pre><code class="language-go">q.ormDB.WithContext(ctx).Preload("Author").Order("created_at desc").Find(answers, ids)\n</code></pre><p>直接使用Preload，是不是比每个answer foreach来的更为方便了？</p><p>了解了这两个方法中难点的事务使用方式和Preload的使用方式，其他的12个协议接口的实现，基本上，逻辑就和这两个方法差不多了，你可以去GitHub上的 <a href="https://github.com/gohade/bbs/tree/geekbang/34">geekbang/34</a> 上的代码比对查看。</p><h2>单元测试</h2><p>问答服务有14个协议接口这么多，我们编写好这些协议接口之后，是很有可能有错误的，这个时候，我们会非常希望写一下单元测试来验证一下这些服务。那么对于hade框架的服务，怎么编写单元测试呢？我们一起做一下。</p><p>首先，要知道<strong>hade框架最核心的就是一个服务容器container</strong>。所以我们需要创建一个单元测试使用的container。框架的test/env.go中，我写好了初始化服务容器的函数InitBaseContainer：</p><pre><code class="language-go">package test\n\nimport (\n   "github.com/gohade/hade/framework"\n   "github.com/gohade/hade/framework/provider/app"\n   "github.com/gohade/hade/framework/provider/env"\n)\n\nconst (\n   BasePath = "/Users/yejianfeng/Documents/workspace/gohade/bbs"\n)\n\nfunc InitBaseContainer() framework.Container {\n   // 初始化服务容器\n   container := framework.NewHadeContainer()\n   // 绑定App服务提供者\n   container.Bind(&amp;app.HadeAppProvider{BaseFolder: BasePath})\n   // 后续初始化需要绑定的服务提供者...\n   container.Bind(&amp;env.HadeTestingEnvProvider{})\n   return container\n}\n</code></pre><p>这个函数中，我们初始化了一个服务容器，当然这里的BasePath表示框架的初始化路径，在具体环境里，请替换你的项目所在的路径。</p><p>然后这个初始化服务容器先是绑定了AppProvider，再绑定了HadeTestingEnvProvider，其他的服务容器，就需要你在单元测试中自己绑定了。具体在单元测试文件app/provider/qa/service_test.go中，我们将如下的服务绑定到这个容器中：</p><pre><code class="language-go">func Test_QA(t *testing.T) {\n   container := test.InitBaseContainer()\n   container.Bind(&amp;config.HadeConfigProvider{})\n   container.Bind(&amp;log.HadeLogServiceProvider{})\n   container.Bind(&amp;orm.GormProvider{})\n   container.Bind(&amp;redis.RedisProvider{})\n   container.Bind(&amp;cache.HadeCacheProvider{})\n   container.Bind(&amp;user.UserProvider{})\n</code></pre><p>包含config、gorm、redis、cache、user等服务。这里注意下，由于在InitBaseContainer中设置的env服务为HadeTestingEnvProvider，这个服务会将env设置为testing，所以这里config服务的所有配置，都会去config/testing/目录下进行寻找。</p><p>我们是为qa服务写单元测试，qa服务最本质使用的是数据库操作，所以如何模拟数据库操作来模拟单元测试就是绕不开的问题了。</p><h3>模拟数据库操作</h3><p>我们模拟数据库操作其实有多种方式，有的人直接创建一个测试的MySQL数据库，将所有操作在MySQL数据库中进行；也有的人使用一些第三方库，比如 <a href="https://github.com/DATA-DOG/go-sqlmock">go-sqlmock</a>，将所有的数据库操作都进行mock。</p><p>但是这两种方式都有一些弊端，第一种需要单独搭建一个测试MySQL，MySQL搭建在哪里、使用什么镜像，又有很多需要讨论的点；第二种，则需要单独使用sqlmock来写一些mock的代码，增加了代码量。</p><p>hade的模拟数据库操作，我们使用一个更为巧妙的方式：<strong>使用SQLite驱动，并且将SQLite数据在内存中进行操作，来模拟MySQL的操作</strong>。</p><p>因为SQLite数据库和MySQL数据库的操作基本上是一样的，我们对SQLite的操作能等同于对MySQL进行操作，而且SQLite还有一个非常好的功能，只要将DSN设置为"file::memory:?cache=shared"，就能将SQLite的数据库保存在内存中。当然保存在内存中的代价就是，进程结束，这个内存也就消失了。但是这个对于跑一次的单元测试来说并没有什么影响。</p><p>那么具体怎么操作呢？</p><p>我们先把config/testing/database.yaml 配置一下：</p><pre><code class="language-go">driver: sqlite # 连接驱动\ndsn: "file::memory:?cache=shared"\n</code></pre><p>driver代表使用SQLite驱动，dsn代表在内存中创建一个数据库来提供给ORM进行操作。</p><p>然后在测试用例中，我们正常使用hade封装的Gorm就可以了。</p><pre><code class="language-go">ormService := container.MustMake(contract.ORMKey).(contract.ORMService)\ndb, err := ormService.GetDB(orm.WithGormConfig(func(options *contract.DBConfig) {\n   options.DisableForeignKeyConstraintWhenMigrating = true\n}))\n\n// 创建问题1\n{\n   question1.AuthorID = user1.ID\n   err := qaService.PostQuestion(ctx, question1)\n   So(err, ShouldBeNil)\n\n   question1, err = qaService.GetQuestion(ctx, question1.ID)\n   So(err, ShouldBeNil)\n   So(question1.CreatedAt, ShouldNotBeNil)\n}\n</code></pre><p>这样不仅省去了创建测试数据库的操作，也省去了写一些mock方法的代码量。</p><p>关于单元测试的断言，我们就使用一个第三方库<a href="https://github.com/smartystreets/goconvey">goconvey</a>，这个第三方库是SmartyStreets 公司开源的，目前有6.8k个star，使用的是自有<a href="https://github.com/smartystreets/goconvey/blob/master/LICENSE.md">开源协议</a>，协议说明是允许用户使用下载的。</p><p>goconvey是非常好用的一个单元测试的库，我现在的项目基本都是使用这个库来做单元测试的。它的好处有几个：</p><p>一是提供丰富的断言。比如：</p><pre><code class="language-go">So(err, ShouldBeNil)\nSo(question1.CreatedAt, ShouldNotBeNil)\nSo(q.Title, ShouldEqual, question1.Title)\n</code></pre><p>这种So系列，带上一个语义化的函数语法ShouldNotBeNil / ShouldBeNil / ShouldEqual，能让整个断言的判断可读性更高。</p><p>其次这个库有丰富的Web界面。看它提供的一个可视化的工具界面，我们可以使用这个工具快速启动一个小的、简单的测试用例结果库：</p><p><img src="https://static001.geekbang.org/resource/image/c4/cf/c4fb6f284c1514d3121dfd0a9d11dacf.png?wh=1920x972" alt="图片"></p><p>在这个页面中，还有一个编写测试逻辑自动生成测试代码的功能：</p><p><img src="https://static001.geekbang.org/resource/image/37/63/375d2d9fde205eyy74614d0216b8fb63.png?wh=1920x777" alt="图片"></p><p>上图，我们在左侧使用中文输入测试逻辑，在右侧就能生成我们的测试代码。</p><p>当然这个测试代码只有框架，没有具体的逻辑，后续只需要将这个测试代码直接拷贝进入我们的单元测试app/provider/qa/service_test.go中，然后再一个个填充其中的测试方法，就可以了：</p><pre><code class="language-go">Convey("创建问题1", func() {\n   question1 = &amp;Question{\n      Title:     "question1",\n      Context:   "this is context",\n      AnswerNum: 0,\n   }\n\n   question1.AuthorID = user1.ID\n   err := qaService.PostQuestion(ctx, question1)\n   So(err, ShouldBeNil)\n\n   question1, err = qaService.GetQuestion(ctx, question1.ID)\n   So(err, ShouldBeNil)\n   So(question1.CreatedAt, ShouldNotBeNil)\n\n   // 创建问题2\n   Convey("创建问题2", func() {\n      question2 = &amp;Question{\n         Title:     "question2",\n         Context:   "this is context",\n         AnswerNum: 0,\n      }\n\n      question2.AuthorID = user2.ID\n      err := qaService.PostQuestion(ctx, question2)\n      So(err, ShouldBeNil)\n\n      question2, err = qaService.GetQuestion(ctx, question2.ID)\n      So(err, ShouldBeNil)\n\n      Convey("获取问题1", func() {\n         q, err := qaService.GetQuestion(ctx, question1.ID)\n         So(err, ShouldBeNil)\n         So(q.Title, ShouldEqual, question1.Title)\n      })\n</code></pre><p>同时这个Web控制台是实时更新的，我们在编写测试用例的时候，每次保存结束之后，测试结果页面就会同步刷新：</p><p><img src="https://static001.geekbang.org/resource/image/17/3d/179afff268f318f65d59dd7178a9223d.png?wh=1920x859" alt="图片"></p><p>还可以通过控制台直接查看我们的代码覆盖率：</p><p><img src="https://static001.geekbang.org/resource/image/46/5d/462914581ed0552c40f579c2be05205d.png?wh=1920x1388" alt="图片"></p><p>总而言之goconvey是一个非常好用的第三方库，强烈推荐你在后续的项目中使用这个第三方库进行单元测试。</p><p>好我们理解了如何mock数据库，如何使用goconvey，那么问答服务14个接口的单元测试编写逻辑就不是什么难事了，剩下的都是工作量，具体的代码就不在这里展开，可以参考GitHub上的这个<a href="https://github.com/gohade/bbs/blob/geekbang/34/app/provider/qa/service_test.go">service_test.go </a>代码。</p><p>编写好单元测试之后，我们的后端问答服务具体实现就完成了。讲到这里，后端的的四个开发步骤也就都完成了。下面我们来看下前端Vue开发。</p><h3>前端Vue开发</h3><p>前端的Vue开发我们要实现的业务在上一节课也梳理过了，一共4个页面：</p><ul>\n<li>问题创建页</li>\n<li>问题列表页</li>\n<li>问题详情页</li>\n<li>问题更新页</li>\n</ul><p>我们拿比较复杂的“问题详情页”来描述一下。</p><p><img src="https://static001.geekbang.org/resource/image/21/74/213ea5ed1c71574090e472ff90bb3374.png?wh=1222x1844" alt="图片"></p><p><strong>这里其实用了富文本编辑器的两个形式</strong>，一个是富文本编辑器的编辑形式，就是最下方“我来回答”的这个输入框；另外一个是富文本编辑器的查看形式，就是上方问题和所有回答的内容部分。</p><p>Vue的组件开发中最复杂的就是这个富文本编辑器了。</p><p>富文本编辑器，我们使用第三方组件 <a href="https://github.com/nhn/tui.editor">toast-ui-editor</a>，这个组件库提供的viewer模式和editor模式能满足我们编辑和展示的需求。</p><p>首先需要在package.json中引入这个组件库：</p><pre><code class="language-go">"@toast-ui/vue-editor": "^3.1.1",\n</code></pre><p>然后在需要的页面组件，就是这里详情页的组件中import引入组件库：</p><pre><code class="language-javascript">import { Viewer} from \'@toast-ui/vue-editor\';\nimport { Editor } from \'@toast-ui/vue-editor\';\n\nexport default {\n  components: {\n    viewer: Viewer,\n    editor: Editor,\n  },\n</code></pre><p>在需要使用toast-ui-editor viewer模式的地方，直接使用viewer标签来展示内容：</p><pre><code class="language-javascript">&lt;viewer ref="answerViewer" :initialValue="answer.content" /&gt;\n</code></pre><p>这里的answer.context，就是我们从后端接口中返回来的回答内容，这个内容是支持带有HTML标签的富文本的。</p><p>而在需要富文本编辑的回答框中，我们使用editor标签来放置一个编辑器：</p><pre><code class="language-javascript">&lt;editor :options="editorOptions"\n        :initialValue = "answerContext"\n        initialEditType="markdown"\n        ref="toastuiEditor"\n        previewStyle="vertical" /&gt;\n</code></pre><p>注意一下标签的几个属性。:options属性代表这个编辑器的所有属性，它的属性值editorOptions，我们在组件的data数据中进行设置，比如编辑器高度、编辑器头部的编辑功能有哪些等等：</p><pre><code class="language-javascript">editorOptions: {\n  minHeight: \'200px\',\n  language: \'en-US\',\n  useCommandShortcut: true,\n  usageStatistics: true,\n  hideModeSwitch: true,\n  toolbarItems: [\n    [\'heading\', \'bold\', \'italic\', \'strike\'],\n    [\'hr\', \'quote\'],\n    [\'ul\', \'ol\', \'task\', \'indent\', \'outdent\'],\n    [\'table\', \'link\'],\n    [\'code\', \'codeblock\'],\n    [\'scrollSync\'],\n  ]\n}\n</code></pre><p>这些设置项都可以在<a href="https://www.npmjs.com/package/@toast-ui/editor">官网</a>查到说明。</p><p>掌握了如何使用toast-ui-editor作为富文本编辑器之后，前端页面的开发逻辑就并不复杂了。先使用element-UI搭建页面框架：</p><pre><code class="language-plain">&lt;template&gt;\n  &lt;el-row type="flex" justify="center" align="middle"&gt;\n    &lt;el-col :span="8"&gt;\n      &lt;el-card v-if="question" class="box-card" shadow="never"&gt;\n        ...\n        &lt;div&gt;\n          &lt;viewer ref="questionViewer" :options="questionViewerOptions" :initialValue="question.context" /&gt;\n        &lt;/div&gt;\n      &lt;/el-card&gt;\n      ...\n</code></pre><p>在页面加载的时候，调用/question/detail来获取后端数据：</p><pre><code class="language-javascript">methods: {\n  getDetail: function (id) {\n    const that = this\n    this.id = id\n    // 调用后端接口\n    request({\n      url: "/question/detail",\n      method: \'GET\',\n      params: {\n        "id": id\n      }\n    }).then(function (response) {\n      that.question = response.data;\n    })\n  },\n</code></pre><p>在提交回答的时候，触发/answer/create来提交回答数据：</p><pre><code class="language-javascript">postAnswer: function () {\n  // 获取富文本编辑器内容\n  let html = this.$refs.toastuiEditor.$data.editor.getHTML()\n  this.answerContext = html\n  const that = this\n  // 调用后端接口\n  request({\n    method: \'POST\',\n    url: "/answer/create",\n    data: {\n      "question_id": that.id,\n      "context": that.answerContext,\n    },\n  }).then(function () {\n    that.$router.go(0)\n  })\n},\n</code></pre><p>更多代码可以参考 GitHub 上的<a href="https://github.com/gohade/bbs/tree/geekbang/34">geekbang/34</a>分支。</p><p>开发完前端和后端，别忘记使用  <code>./bbs dev all</code> 开启前后端联调模式，进行前后端联调。</p><p>这节课我们开发了问答模块的前端和后端，所有的代码都放在 <a href="https://github.com/gohade/bbs/tree/geekbang/34">geekbang/34</a>分支，你可以对比查看。</p><p><img src="https://static001.geekbang.org/resource/image/5b/51/5bd13d9f475bef425de2b21303265451.jpg?wh=1215x714" alt="图片"></p><h2>小结</h2><p>我们开发了问答模块的前端和后端，开发的流程，基本上和用户模块是一致的。只是其中有一些特殊的地方要注意掌握，比如，如何使用Gorm的预加载功能、如何在单元测试里面用SQLite mock SQL操作、如何使用容器做hade的单元测试、如何使用goconvey做测试框架、如何使用toast-ui-editor做富文本编辑器。这些都是我们问答模块实现的重点和难点。</p><p>到这里课程主体就要结束了。因为是Web框架的搭建课，所以这个课程除了专栏的文字之外，还有很大一部分在GitHub上，也就是代码。我们一共完成了两个项目，一个是hade框架项目，一个是类知乎问答网站 bbs，都是开源项目，每个项目也都保留着按章节的演进步骤和代码。</p><p>当然，专栏的文字不能穷尽所有知识点，有一些代码的实现细节，需要你自己在动手写的时候才能发现，如果有疑惑，不妨去GitHub上对比代码进行查看。非常欢迎你把这两个项目作为自己学习Golang的第一个开源项目，提交并合并你的修改。</p><h3>思考题</h3><p>看GitHub上的代码，bbs项目中的error，我使用的并不是官方的error库，而是github.com/pkg/errors 库。这个库，使用方式和标准的error库是一样的，但是它有很多额外的好处，你可以研究一下这个第三方error库，并且描述下它比官方error库好的地方有哪些么？</p><p>欢迎在留言区分享你的学习笔记。感谢你的收听，如果你觉得今天的内容对你有所帮助，也欢迎分享给你身边的朋友，邀请他一起学习。</p>',
        article_title: "34｜业务开发（下）：问答业务开发",
      },
    ],
  },
  {
    chapterTitle: "结束语",
    children: [
      {
        title: "结束语｜在语言的上升期投入最大热情，是最正确的投资",
        id: 466057,
        content:
          '<p>你好，我是轩脉刃。</p><p>课程到这里就正式结束了。小伙伴们，感谢能一起经历这段Golang的Web之旅。</p><p>我们这门课理论和实践并存，每一节课都有对应的GitHub代码可以演示和查看，对比其他偏理论的课程，可能你需要花更多的时间进行动手、对比查看代码，但是相信我，经历过这门课这么多知识点的动手学习之后，你的开发思维和技能一定会得到提升。</p><p>看完整个系列，你会知道，我们最终会收获两个项目，一个是hade框架，一个是使用hade框架开发的类知乎的bbs项目。因为我知道有很多同学在刚接触Golang的时候，最发愁的有两个点，<strong>一个是开源框架很多，不知道应该学习选择什么框架；另外一个是希望能找到一个业务示例，能演示并参与尝试开发</strong>。</p><p>hade框架希望能解决你的第一个问题。它提供的很多命令行工具，能为使用者节省不少的开发效率，并且整个框架一直在灌输“一切皆接口”的设计理念，所有的流程都让你先开发确定好接口，再落实到具体实现，希望能在一开始就帮助你树立良好的开发习惯。</p><p>而配套的bbs项目，是一个很好的业务示例，有前端，有后端，具体的业务逻辑也并不复杂，很适合给初学者借鉴和学习。</p><p>不过课程虽然结束了，我们的框架之路才刚开始。</p><!-- [[[read_end]]] --><p>所有的框架都需要经过不断迭代打磨的。目前我们的框架正式更新到了1.0版本，后续我会不断优化hade框架，并且在工作中或者工作之外，使用hade开发一些有意思的项目。如果你也有兴趣的话，欢迎一起加入，关注github.com 上的gohade这个<a href="https://github.com/gohade">oranizagion</a>。</p><p>早在开篇词里我解释了为什么要用Go来写Web框架，在课程的最后，我想跟你再聊聊我对Go这门语言及新技术的一些看法和观点。</p><p>不管你现在是学习什么前沿的技术，有这么一句话应该是没有错的：“你所掌握的技术，在你有生之年，是会过时的”。这种过时的生命周期是从后端向前端逐渐缩短的。我这里说的后端和前端的方向，是以靠近真实用户的距离计算的。</p><p>比如数据库、操作系统这种技术，距离用户最远，用户基本不会感知，它们可能几十年都不会过时，从MySQL、Linux大致就能看出来；再往前，中间件、缓存等技术，大致十几年吧；再往前，后端服务技术，我认为生命周期应该是10年之内。再往前，前端技术，我觉得迭代周期应该是5年之内了。如果有工作超过10年的朋友，估计对我算的这个时间也会有所赞同的。</p><p>迭代更新，是伴随着技术红利的，这里的技术红利指的是新技术的培训、人员更新、市场需求。<strong>越是更新换代快的，越容易抢占这个技术红利</strong>。在这个技术红利中，会有一波人才缺口流出，会有一波技术很强的人出现。</p><p>论语言来说，一门好的语言，生命周期是非常长的。Java，1995年出现，到现在已经26年了，仍然在很多领域是唯一选择；Golang是从07年诞生的，至今才14年光景。</p><p>我大概是在2012年接触的Golang了，但是当时研究Golang这门语言的人还非常少，可以参考借鉴的学习资料少之又少，但是所幸在一个同事们技术品味都很相投的团队，大家对新技术的使用并没有多少的抵触情绪，而且团队能保持一个活跃的讨论氛围，当时那一波人后来也被证明了逐渐成长为各个公司的技术大拿。</p><p>而十年后的今天，Golang的生态和参与人数真是以肉眼可见的速度在增长，所有的技术课程、文章真是随处可见。只不过与十年前不同的是，要从这么多资料中筛选出适合你的、描述清晰的资料反而成了一件难事了。</p><p>从语言的生命周期这个角度看，我认为所有的语言技术都有几个时期：尝鲜期、上升期、鼎盛期、衰落期。</p><p>在尝鲜期，大家对一个语言将信将疑，只有少数极客会学习尝试，在生产环境使用新技术的更是少之又少。而到了上升期，很多新的项目基本上都会选择使用这门语言来开发，随着而来的表现就是语言涉及的领域越来越多。在鼎盛时期，在一些领域，这门语言会由于其生态丰富而成为唯一选择了。当然最后也有可能发展到衰弱期，由于有更好的选择，这门语言用的人越来越少了。</p><p>在我看来，Golang这门语言目前正处于上升期，我所见的大厂，腾讯、字节、阿里、滴滴，<strong>都有越来越多的线上服务，选择使用Golang作为其开发语言，甚至会使用它来重构很多的已有业务</strong>。</p><p>要知道，引进新技术和重构业务都会产生出足够的职位需求，也会有人员交替的，所以市面上显而易见的Golang工程师的招聘职位也越来越多了。所以恭喜选择这门课程的你，在语言上升期参与到Golang这门语言的使用和研究，是一个非常明智的选择。</p><p>在之前加餐聊业务架构和基础架构的时候我说过，技术架构和业务架构，这两个方向基本上代表程序员成长的两个方向。</p><p>技术为主，以创建、改变一个新技术为成就感来源，基本上我觉得各个语言的创造者、追随者算是这类人，各种数据库、大型开源项目的创造者、追随者算是这类人。这类人，比如MySQL的精深专家，基本在MySQL这个领域没有什么解决不了的问题，而且对这个领域有持续的贡献能力。</p><p>而业务为主的同学，以创建一个最多人使用的、能改变生活的业务为成就感来源，他们每每兴奋的点在于业务PV/UV的增长。诚然很多业务说到底都是如Web业务一般的CURD，但是如果你CURD的代码，能运行在千万甚至亿级别的用户电脑中，这种成就感，完全不亚于任何技术创新。</p><p>而以我这十年所见，很多的同学其实更属于这类人。这种属性的同学，会在学习、工作过程中，冒出各种各样的想法、点子。当然这些想法、点子并不稀奇，每个人都会有的，但是这种属性的同学就会不断思考，如何将这些点子变成现实、如何使用这些点子改变我们的生活。</p><p>而作为工程师，我们天生的工作就是提升这个能力，<strong>这种业务能力的高低，就是如何快速将想法变为现实，当然，这需要非常顺手的工具</strong>，当我有一个点子的时候，工具能快速将我的点子实现。</p><p>这其实就是我在两年前想动手写这个hade框架的初衷。一切皆服务，当我有一个容器，能将我遇到的所有需求都变成容器中的服务，那么后续我想要实现某个点子的时候，就能通过这个容器很快完成了。</p><p>这些思路和想法，在这次极客时间的专栏中，点点滴滴我都如实记录了下来。当然里面有的观点和方法或许和你的想法各异，但是如果这些想法和点子，能对你的Golang学习之路有所启发和帮助，也就达到了这门课程的目的了。</p><p>总之最后，希望课程看到这里的你，能在自己的技术领域、业务领域不断思考，改变，尽自己的所能影响周边的人和事。</p><p>最后的最后，估计很多小伙伴都是“潜水党”，喜欢默默地学习，在专栏要结束的今天，我也非常希望能听到你的声音，听听你学习这个专栏的感受和收获。</p><p>这里我还为你准备了一份<a href="https://jinshuju.net/f/gZTTVA">毕业问卷</a>，题目不多，希望你可以花两分钟填一下。谢谢关注，我们仗剑天涯，江湖再见～</p>',
        article_title: "结束语｜在语言的上升期投入最大热情，是最正确的投资",
      },
      {
        title: "期末测试｜来赴一场满分之约！",
        id: 468357,
        content:
          '<p>你好，我是轩脉刃。</p><p>《手把手带你写一个Web框架》已经结课了。非常感谢你一直以来的认真学习和支持！</p><p>为了帮你检验自己的学习效果，我特意给你准备了一套结课测试题。这套测试题一共有 20 道多选，考点都来自我们前面讲到的重要知识。点击下面按钮开始测试吧！</p><p><a href="http://time.geekbang.org/quiz/intro?act_id=1263&exam_id=3344"><img src="https://static001.geekbang.org/resource/image/28/a4/28d1be62669b4f3cc01c36466bf811a4.png?wh=1142*201" alt=""></a></p><p>最后，我很希望听听你学习这个专栏的感受。这里我为你准备了一份<a href="https://jinshuju.net/f/gZTTVA">毕业问卷</a>，题目不多，希望你可以花两分钟填一下。</p><!-- [[[read_end]]] -->',
        article_title: "期末测试｜来赴一场满分之约！",
      },
    ],
  },
];
