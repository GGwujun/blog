<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no"
    />
    <link rel="shortcut icon" type="image/x-icon" href="/logo.png" />
    <link rel="stylesheet" href="/blog/umi.css" />
    <script>
      window.routerBase = "/blog";
    </script>
    <script>
      //! umi version: 3.5.17
    </script>
    <script>
      !(function () {
        var e = localStorage.getItem("dumi:prefers-color"),
          t = window.matchMedia("(prefers-color-scheme: dark)").matches,
          r = ["light", "dark", "auto"];
        document.documentElement.setAttribute(
          "data-prefers-color",
          e === r[2] ? (t ? r[1] : r[0]) : r.indexOf(e) > -1 ? e : r[0]
        );
      })();
    </script>
    <title>05｜封装：如何让你的框架更好用？</title>
  </head>
  <body>
    <div id="root"><div class="__dumi-default-layout" data-route="/手把手带你写一个web框架/02.实战第1关从零开始/05" data-show-sidemenu="true" data-show-slugs="true" data-site-mode="true" data-gapless="false"><div class="__dumi-default-navbar" data-mode="site"><button class="__dumi-default-navbar-toggle"></button><a class="__dumi-default-navbar-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog/">大师兄</a><nav><div class="__dumi-default-search"><input type="search" class="__dumi-default-search-input" value=""/><ul></ul></div><span>计算机基础<ul><li><a href="/blog/编译原理之美">编译原理之美</a></li><li><a href="/blog/编译原理实战">编译原理实战</a></li><li><a href="/blog/深入浅出计算机组成原理">深入浅出计算机组成原理</a></li><li><a href="/blog/详解http">详解http</a></li><li><a href="/blog/计算机网络通关29讲">计算机网络通关29讲</a></li><li><a href="/blog/网络排查案例课">网络排查案例课</a></li><li><a href="/blog/linux操作系统">linux操作系统</a></li><li><a href="/blog/linux性能优化实战">linux性能优化实战</a></li><li><a href="/blog/程序员数学基础">程序员数学基础</a></li><li><a href="/blog/趣谈网络协议">趣谈网络协议</a></li><li><a href="/blog/操作系统实战">操作系统实战</a></li><li><a href="/blog/软件工程之美">软件工程之美</a></li><li><a href="/blog/sql必知必会">sql必知必会</a></li><li><a href="/blog/操作系统实战45讲">操作系统实战45讲</a></li><li><a href="/blog/网络编程实战">网络编程实战</a></li></ul></span><span>算法<ul><li><a href="/blog/常用算法25讲">常用算法25讲</a></li><li><a href="/blog/数据结构与算法之美">数据结构与算法之美</a></li><li><a href="/blog/业务开发算法50讲">业务开发算法50讲</a></li><li><a href="/blog/动态规划面试宝典">动态规划面试宝典</a></li></ul></span><span>前端开发<ul><li><a href="/blog/浏览器工作原理与实践">浏览器工作原理与实践</a></li><li><a href="/blog/新时代产品经理进阶之路">新时代产品经理进阶之路</a></li><li><a href="/blog/全栈工程师修炼指南">全栈工程师修炼指南</a></li><li><a href="/blog/flutter核心技术与实战">flutter核心技术与实战</a></li><li><a href="/blog/java-script核心原理解析">java-script核心原理解析</a></li><li><a href="/blog/说透低代码">说透低代码</a></li><li><a href="/blog/nodejs应用开发实战">nodejs应用开发实战</a></li><li><a href="/blog/反爬虫兵法演绎20讲">反爬虫兵法演绎20讲</a></li><li><a href="/blog/reactnative新架构实战课">reactnative新架构实战课</a></li><li><a href="/blog/正则表达式入门">正则表达式入门</a></li><li><a href="/blog/重学前端">重学前端</a></li><li><a href="/blog/serverless入门课">serverless入门课</a></li><li><a href="/blog/type-script入门实战笔记">type-script入门实战笔记</a></li><li><a href="/blog/图解googlev8">图解googlev8</a></li><li><a href="/blog/vue3源码分析">vue3源码分析</a></li><li><a href="/blog/玩转Vue3全家桶">玩转Vue3全家桶</a></li><li><a href="/blog/webassembly入门">webassembly入门</a></li><li><a aria-current="page" class="active" href="/blog/手把手带你写一个Web框架">手把手带你写一个Web框架</a></li><li><a href="/blog/web漏洞挖掘实战">web漏洞挖掘实战</a></li><li><a href="/blog/跟月影学可视化">跟月影学可视化</a></li><li><a href="/blog/搞定音频技术">搞定音频技术</a></li><li><a href="/blog/攻克视频技术">攻克视频技术</a></li></ul></span><span>前端工程化<ul><li><a href="/blog/logger">logger</a></li><li><a href="/blog/webpack">webpack</a></li><li><a href="/blog/webpackChain">webpackChain</a></li></ul></span><span>前端性能优化<ul><li><a href="/blog/react性能调优">react性能调优</a></li></ul></span><span>软件测试<ul><li><a href="/blog/全链路压测实战30讲">全链路压测实战30讲</a></li><li><a href="/blog/性能测试实战30讲">性能测试实战30讲</a></li><li><a href="/blog/自动化测试高手课">自动化测试高手课</a></li><li><a href="/blog/软件测试52讲">软件测试52讲</a></li></ul></span><span>面试<ul><li><a href="/blog/面试现场">面试现场</a></li></ul></span><span>杂谈<ul><li><a href="/blog/超级访谈对话张雪峰">超级访谈对话张雪峰</a></li><li><a href="/blog/Git实战手册">Git实战手册</a></li><li><a href="/blog/NodeJS">NodeJS</a></li><li><a href="/blog/ReactJS">ReactJS</a></li><li><a href="/blog/UI设计">UI设计</a></li><li><a href="/blog/webpack4系列教程">webpack4系列教程</a></li><li><a href="/blog/前端知识体系">前端知识体系</a></li><li><a href="/blog/剑指offer刷题笔记">剑指offer刷题笔记</a></li><li><a href="/blog/思考与成长">思考与成长</a></li><li><a href="/blog/设计模式手册">设计模式手册</a></li></ul></span><div class="__dumi-default-navbar-tool"><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "></div></div></div></nav></div><div class="__dumi-default-menu" data-mode="site"><div class="__dumi-default-menu-inner"><div class="__dumi-default-menu-header"><a class="__dumi-default-menu-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog/"></a><h1>大师兄</h1><p></p></div><div class="__dumi-default-menu-mobile-area"><ul class="__dumi-default-menu-nav-list"><li>计算机基础<ul><li><a href="/blog/编译原理之美">编译原理之美</a></li><li><a href="/blog/编译原理实战">编译原理实战</a></li><li><a href="/blog/深入浅出计算机组成原理">深入浅出计算机组成原理</a></li><li><a href="/blog/详解http">详解http</a></li><li><a href="/blog/计算机网络通关29讲">计算机网络通关29讲</a></li><li><a href="/blog/网络排查案例课">网络排查案例课</a></li><li><a href="/blog/linux操作系统">linux操作系统</a></li><li><a href="/blog/linux性能优化实战">linux性能优化实战</a></li><li><a href="/blog/程序员数学基础">程序员数学基础</a></li><li><a href="/blog/趣谈网络协议">趣谈网络协议</a></li><li><a href="/blog/操作系统实战">操作系统实战</a></li><li><a href="/blog/软件工程之美">软件工程之美</a></li><li><a href="/blog/sql必知必会">sql必知必会</a></li><li><a href="/blog/操作系统实战45讲">操作系统实战45讲</a></li><li><a href="/blog/网络编程实战">网络编程实战</a></li></ul></li><li>算法<ul><li><a href="/blog/常用算法25讲">常用算法25讲</a></li><li><a href="/blog/数据结构与算法之美">数据结构与算法之美</a></li><li><a href="/blog/业务开发算法50讲">业务开发算法50讲</a></li><li><a href="/blog/动态规划面试宝典">动态规划面试宝典</a></li></ul></li><li>前端开发<ul><li><a href="/blog/浏览器工作原理与实践">浏览器工作原理与实践</a></li><li><a href="/blog/新时代产品经理进阶之路">新时代产品经理进阶之路</a></li><li><a href="/blog/全栈工程师修炼指南">全栈工程师修炼指南</a></li><li><a href="/blog/flutter核心技术与实战">flutter核心技术与实战</a></li><li><a href="/blog/java-script核心原理解析">java-script核心原理解析</a></li><li><a href="/blog/说透低代码">说透低代码</a></li><li><a href="/blog/nodejs应用开发实战">nodejs应用开发实战</a></li><li><a href="/blog/反爬虫兵法演绎20讲">反爬虫兵法演绎20讲</a></li><li><a href="/blog/reactnative新架构实战课">reactnative新架构实战课</a></li><li><a href="/blog/正则表达式入门">正则表达式入门</a></li><li><a href="/blog/重学前端">重学前端</a></li><li><a href="/blog/serverless入门课">serverless入门课</a></li><li><a href="/blog/type-script入门实战笔记">type-script入门实战笔记</a></li><li><a href="/blog/图解googlev8">图解googlev8</a></li><li><a href="/blog/vue3源码分析">vue3源码分析</a></li><li><a href="/blog/玩转Vue3全家桶">玩转Vue3全家桶</a></li><li><a href="/blog/webassembly入门">webassembly入门</a></li><li><a aria-current="page" class="active" href="/blog/手把手带你写一个Web框架">手把手带你写一个Web框架</a></li><li><a href="/blog/web漏洞挖掘实战">web漏洞挖掘实战</a></li><li><a href="/blog/跟月影学可视化">跟月影学可视化</a></li><li><a href="/blog/搞定音频技术">搞定音频技术</a></li><li><a href="/blog/攻克视频技术">攻克视频技术</a></li></ul></li><li>前端工程化<ul><li><a href="/blog/logger">logger</a></li><li><a href="/blog/webpack">webpack</a></li><li><a href="/blog/webpackChain">webpackChain</a></li></ul></li><li>前端性能优化<ul><li><a href="/blog/react性能调优">react性能调优</a></li></ul></li><li>软件测试<ul><li><a href="/blog/全链路压测实战30讲">全链路压测实战30讲</a></li><li><a href="/blog/性能测试实战30讲">性能测试实战30讲</a></li><li><a href="/blog/自动化测试高手课">自动化测试高手课</a></li><li><a href="/blog/软件测试52讲">软件测试52讲</a></li></ul></li><li>面试<ul><li><a href="/blog/面试现场">面试现场</a></li></ul></li><li>杂谈<ul><li><a href="/blog/超级访谈对话张雪峰">超级访谈对话张雪峰</a></li><li><a href="/blog/Git实战手册">Git实战手册</a></li><li><a href="/blog/NodeJS">NodeJS</a></li><li><a href="/blog/ReactJS">ReactJS</a></li><li><a href="/blog/UI设计">UI设计</a></li><li><a href="/blog/webpack4系列教程">webpack4系列教程</a></li><li><a href="/blog/前端知识体系">前端知识体系</a></li><li><a href="/blog/剑指offer刷题笔记">剑指offer刷题笔记</a></li><li><a href="/blog/思考与成长">思考与成长</a></li><li><a href="/blog/设计模式手册">设计模式手册</a></li></ul></li></ul><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "><button title="Dark theme" class="__dumi-default-dark-moon "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="3854" width="22" height="22"><path d="M991.816611 674.909091a69.166545 69.166545 0 0 0-51.665455-23.272727 70.795636 70.795636 0 0 0-27.438545 5.585454A415.674182 415.674182 0 0 1 754.993338 698.181818c-209.594182 0-393.472-184.785455-393.472-395.636363 0-52.363636 38.539636-119.621818 69.515637-173.614546 4.887273-8.610909 9.634909-16.756364 14.103272-24.901818A69.818182 69.818182 0 0 0 384.631156 0a70.842182 70.842182 0 0 0-27.438545 5.585455C161.678429 90.298182 14.362065 307.898182 14.362065 512c0 282.298182 238.824727 512 532.38691 512a522.286545 522.286545 0 0 0 453.957818-268.334545A69.818182 69.818182 0 0 0 991.816611 674.909091zM546.679156 954.181818c-248.785455 0-462.941091-192-462.941091-442.181818 0-186.647273 140.637091-372.829091 300.939637-442.181818-36.817455 65.629091-92.578909 151.970909-92.578909 232.727273 0 250.181818 214.109091 465.454545 462.917818 465.454545a488.331636 488.331636 0 0 0 185.181091-46.545455 453.003636 453.003636 0 0 1-393.565091 232.727273z m103.656728-669.323636l-14.266182 83.781818a34.909091 34.909091 0 0 0 50.362182 36.770909l74.775272-39.563636 74.752 39.563636a36.142545 36.142545 0 0 0 16.174546 3.956364 34.909091 34.909091 0 0 0 34.210909-40.727273l-14.289455-83.781818 60.509091-59.345455a35.025455 35.025455 0 0 0-19.223272-59.578182l-83.61891-12.101818-37.376-76.101818a34.56 34.56 0 0 0-62.254545 0l-37.376 76.101818-83.618909 12.101818a34.909091 34.909091 0 0 0-19.246546 59.578182z m70.423272-64.698182a34.280727 34.280727 0 0 0 26.135273-19.083636l14.312727-29.090909 14.336 29.090909a34.257455 34.257455 0 0 0 26.135273 19.083636l32.046546 4.887273-23.272728 22.574545a35.234909 35.234909 0 0 0-10.007272 30.952727l5.46909 32.116364-28.625454-15.127273a34.490182 34.490182 0 0 0-32.302546 0l-28.695272 15.127273 5.469091-32.116364a35.141818 35.141818 0 0 0-9.984-30.952727l-23.272728-22.574545z" p-id="3855"></path></svg></button><button title="Light theme" class="__dumi-default-dark-sun "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="4026" width="22" height="22"><path d="M915.2 476.16h-43.968c-24.704 0-44.736 16-44.736 35.84s20.032 35.904 44.736 35.904H915.2c24.768 0 44.8-16.064 44.8-35.904s-20.032-35.84-44.8-35.84zM512 265.6c-136.704 0-246.464 109.824-246.464 246.4 0 136.704 109.76 246.464 246.464 246.464S758.4 648.704 758.4 512c0-136.576-109.696-246.4-246.4-246.4z m0 425.6c-99.008 0-179.2-80.128-179.2-179.2 0-98.944 80.192-179.2 179.2-179.2S691.2 413.056 691.2 512c0 99.072-80.192 179.2-179.2 179.2zM197.44 512c0-19.84-19.136-35.84-43.904-35.84H108.8c-24.768 0-44.8 16-44.8 35.84s20.032 35.904 44.8 35.904h44.736c24.768 0 43.904-16.064 43.904-35.904zM512 198.464c19.776 0 35.84-20.032 35.84-44.8v-44.8C547.84 84.032 531.84 64 512 64s-35.904 20.032-35.904 44.8v44.8c0 24.768 16.128 44.864 35.904 44.864z m0 627.136c-19.776 0-35.904 20.032-35.904 44.8v44.736C476.096 940.032 492.16 960 512 960s35.84-20.032 35.84-44.8v-44.736c0-24.768-16.064-44.864-35.84-44.864z m329.92-592.832c17.472-17.536 20.288-43.072 6.4-57.024-14.016-14.016-39.488-11.2-57.024 6.336-4.736 4.864-26.496 26.496-31.36 31.36-17.472 17.472-20.288 43.008-6.336 57.024 13.952 14.016 39.488 11.2 57.024-6.336 4.8-4.864 26.496-26.56 31.296-31.36zM213.376 759.936c-4.864 4.8-26.56 26.624-31.36 31.36-17.472 17.472-20.288 42.944-6.4 56.96 14.016 13.952 39.552 11.2 57.024-6.336 4.8-4.736 26.56-26.496 31.36-31.36 17.472-17.472 20.288-43.008 6.336-56.96-14.016-13.952-39.552-11.072-56.96 6.336z m19.328-577.92c-17.536-17.536-43.008-20.352-57.024-6.336-14.08 14.016-11.136 39.488 6.336 57.024 4.864 4.864 26.496 26.56 31.36 31.424 17.536 17.408 43.008 20.288 56.96 6.336 14.016-14.016 11.264-39.488-6.336-57.024-4.736-4.864-26.496-26.56-31.296-31.424z m527.168 628.608c4.864 4.864 26.624 26.624 31.36 31.424 17.536 17.408 43.072 20.224 57.088 6.336 13.952-14.016 11.072-39.552-6.4-57.024-4.864-4.8-26.56-26.496-31.36-31.36-17.472-17.408-43.072-20.288-57.024-6.336-13.952 14.016-11.008 39.488 6.336 56.96z" p-id="4027"></path></svg></button><button title="Default to system" class="__dumi-default-dark-auto "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="11002" width="22" height="22"><path d="M127.658667 492.885333c0-51.882667 10.24-101.717333 30.378666-149.162666s47.786667-88.064 81.92-122.538667 75.093333-61.781333 122.538667-81.92 96.938667-30.378667 149.162667-30.378667 101.717333 10.24 149.162666 30.378667 88.405333 47.786667 122.88 81.92 61.781333 75.093333 81.92 122.538667 30.378667 96.938667 30.378667 149.162666-10.24 101.717333-30.378667 149.162667-47.786667 88.405333-81.92 122.88-75.093333 61.781333-122.88 81.92-97.28 30.378667-149.162666 30.378667-101.717333-10.24-149.162667-30.378667-88.064-47.786667-122.538667-81.92-61.781333-75.093333-81.92-122.88-30.378667-96.938667-30.378666-149.162667z m329.045333 0c0 130.048 13.994667 244.394667 41.984 343.381334h12.970667c46.762667 0 91.136-9.216 133.461333-27.306667s78.848-42.666667 109.568-73.386667 54.954667-67.242667 73.386667-109.568 27.306667-86.698667 27.306666-133.461333c0-46.421333-9.216-90.794667-27.306666-133.12s-42.666667-78.848-73.386667-109.568-67.242667-54.954667-109.568-73.386667-86.698667-27.306667-133.461333-27.306666h-11.605334c-28.672 123.562667-43.349333 237.909333-43.349333 343.722666z" p-id="11003"></path></svg></button></div></div></div><ul class="__dumi-default-menu-list"><li><a href="/blog/">大师兄 - 前端架构师</a></li></ul></div></div><ul role="slug-list" class="__dumi-default-layout-toc"><li title="思考如何封装请求和返回" data-depth="2"><a href="/blog/手把手带你写一个web框架/02.实战第1关从零开始/05#思考如何封装请求和返回"><span>思考如何封装请求和返回</span></a></li><li title="定义接口让封装更明确" data-depth="2"><a href="/blog/手把手带你写一个web框架/02.实战第1关从零开始/05#定义接口让封装更明确"><span>定义接口让封装更明确</span></a></li><li title="IRequest接口定义" data-depth="3"><a href="/blog/手把手带你写一个web框架/02.实战第1关从零开始/05#irequest接口定义"><span>IRequest接口定义</span></a></li><li title="IResponse接口定义" data-depth="3"><a href="/blog/手把手带你写一个web框架/02.实战第1关从零开始/05#iresponse接口定义"><span>IResponse接口定义</span></a></li><li title="实现具体的接口" data-depth="2"><a href="/blog/手把手带你写一个web框架/02.实战第1关从零开始/05#实现具体的接口"><span>实现具体的接口</span></a></li><li title="请求相关接口实现" data-depth="2"><a href="/blog/手把手带你写一个web框架/02.实战第1关从零开始/05#请求相关接口实现"><span>请求相关接口实现</span></a></li><li title="Query 请求方法实现" data-depth="3"><a href="/blog/手把手带你写一个web框架/02.实战第1关从零开始/05#query-请求方法实现"><span>Query 请求方法实现</span></a></li><li title="Param 请求方法实现" data-depth="3"><a href="/blog/手把手带你写一个web框架/02.实战第1关从零开始/05#param-请求方法实现"><span>Param 请求方法实现</span></a></li><li title="Bind 请求方法实现" data-depth="3"><a href="/blog/手把手带你写一个web框架/02.实战第1关从零开始/05#bind-请求方法实现"><span>Bind 请求方法实现</span></a></li><li title="返回相关接口实现" data-depth="2"><a href="/blog/手把手带你写一个web框架/02.实战第1关从零开始/05#返回相关接口实现"><span>返回相关接口实现</span></a></li><li title="JSONP 输出方法实现" data-depth="3"><a href="/blog/手把手带你写一个web框架/02.实战第1关从零开始/05#jsonp-输出方法实现"><span>JSONP 输出方法实现</span></a></li><li title="HTML 输出方法实现" data-depth="3"><a href="/blog/手把手带你写一个web框架/02.实战第1关从零开始/05#html-输出方法实现"><span>HTML 输出方法实现</span></a></li><li title="小结" data-depth="2"><a href="/blog/手把手带你写一个web框架/02.实战第1关从零开始/05#小结"><span>小结</span></a></li><li title="思考题" data-depth="2"><a href="/blog/手把手带你写一个web框架/02.实战第1关从零开始/05#思考题"><span>思考题</span></a></li></ul><div class="__dumi-default-layout-content"><div class="markdown"><h1 id="05封装如何让你的框架更好用"><a aria-hidden="true" tabindex="-1" href="/blog/手把手带你写一个web框架/02.实战第1关从零开始/05#05封装如何让你的框架更好用"><span class="icon icon-link"></span></a>05｜封装：如何让你的框架更好用？</h1><p>你好，我是轩脉刃。</p><p>在前面几节课，我们实现了框架的路由、中间件等机制，并且自定义 context 结构来封装请求。但是回顾在对 context 的封装中，我们只是将 request、response 结构直接放入 context 结构体中，对应的方法并没有很好的封装。所以这节课，我们要做的事情就是为 context 封装更多的方法，让框架更好用。</p><p>在今天的学习中，希望你能认识到，函数封装并不是一件很简单、很随意的事情。相反，如何封装出易用、可读性高的函数是非常需要精心考量的，<strong>框架中每个函数的参数、返回值、命名，都代表着我们作为作者在某个事情上的思考</strong>。想要针对某个功能，封装出一系列比较完美的接口，更要我们从系统性的角度思考。</p><h2 id="思考如何封装请求和返回"><a aria-hidden="true" tabindex="-1" href="/blog/手把手带你写一个web框架/02.实战第1关从零开始/05#思考如何封装请求和返回"><span class="icon icon-link"></span></a>思考如何封装请求和返回</h2><p>我们的目标是尽量在 context 这个数据结构中，封装“读取请求数据”和“封装返回数据”中的方法。在动手之前还是先做到心中有数，我们将请求和返回这两个事情分开思考。</p><ul><li>读取请求数据</li></ul><p>要读取请求数据包含哪些内容呢？第一讲我们提到过，HTTP 消息体分为两个部分：HTTP 头部和 HTTP Body 体。头部描述的一般是和业务无关但与传输相关的信息，比如请求地址、编码格式、缓存时长等；Body 里面主要描述的是与业务相关的信息。</p><p>所以针对请求数据的这两部分，我们应该设计不同的方法。</p><p>Header 信息中，包含 HTTP 的一些基础信息，比如请求地址、请求方法、请求 IP、请求域名、Cookie 信息等，是经常读取使用的，为了方便，我们需要一一提供封装。</p><p>而另外一些更细节的内容编码格式、缓存时长等，由于涉及的 HTTP 协议细节内容比较多，我们很难将每个细节都封装出来，但是它们都是以 key=value 的形式传递到服务端的，所以这里也考虑封装一个通用的方法。</p><p>Body 信息中，HTTP 是已经以某种形式封装好的，可能是 JSON 格式、XML 格式，也有可能是 Form 表单格式。其中 Form 表单注意一下，它可能包含 File 文件，请求参数和返回值肯定和其他的 Form 表单字段是不一样的，需要我们对其单独封装一个函数。</p><ul><li>封装返回数据</li></ul><p>封装返回数据，指的是将处理后的数据返回给浏览器。同样，它也分为两个部分，Header 头部和 Body 体。</p><p>Header 头部，我们经常要设置的是返回状态码和 Cookie，所以单独为其封装。其他的 Header 同样是 key=value 形式设置的，设置一个通用的方法即可。</p><p>返回数据的 Body 体是有不同形式的，比如 JSON、JSONP、XML、HTML或者其他文本格式，所以我们要针对不同的Body体形式，进行不同的封装。</p><p>一路分析下来，再列出这样一个思维导图就非常清晰了。<img src="https://static001.geekbang.org/resource/image/5d/3b/5d7b8554f7cbd074db00a62acdfe5a3b.jpg?wh=2038x2209" alt=""/></p><h2 id="定义接口让封装更明确"><a aria-hidden="true" tabindex="-1" href="/blog/手把手带你写一个web框架/02.实战第1关从零开始/05#定义接口让封装更明确"><span class="icon icon-link"></span></a>定义接口让封装更明确</h2><p>现在分析完需要封装哪些方法了，你已经迫不及待想开始进行封装函数的实现了吧。但是这里，我再给一个编码小建议：<strong>对于比较完整的功能模块，先定义接口，再具体实现</strong>。</p><p>首先，定义一个清晰的、包含若干个方法的接口，可以让使用者非常清楚：这个功能模块提供了哪些函数、哪些函数是我要的、哪些函数是我不要的，在用的时候，查找也更方便。如果你有过，在超过 20 个函数的结构体中，查找你需要的函数的惨痛经历，你就会觉得这一点尤为重要了。</p><p>其次，定义接口能做到“实现解耦”。使用接口作为参数、返回值，能够让使用者在写具体函数的时候，有不同的实现；而且在不同实现中，只需要做到接口一致，就能很简单进行替换，而不用修改使用方的任何代码。</p><p>好，明白这两点，我们再回到封装需求上，先定义两个接口：IRequest 和 IResponse，分别对应“读取请求数据”和“封装返回数据” 这两个功能模块。</p><p>我们分别在框架目录下创建request.go和response.go来存放这两个接口及其实现。</p><h3 id="irequest接口定义"><a aria-hidden="true" tabindex="-1" href="/blog/手把手带你写一个web框架/02.实战第1关从零开始/05#irequest接口定义"><span class="icon icon-link"></span></a>IRequest接口定义</h3><p>读取请求数据 IRequest，我们定义的方法如下，在request.go中进行修改：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// 代表请求包含的方法</span></div><div class="token-line"><span class="token plain">    type IRequest interface {</span></div><div class="token-line"><span class="token plain">    	// 请求地址 url 中带的参数</span></div><div class="token-line"><span class="token plain">    	// 形如: foo.com?a=1&amp;b=bar&amp;c[]=bar</span></div><div class="token-line"><span class="token plain">    	QueryInt(key string, def int) (int, bool)</span></div><div class="token-line"><span class="token plain">    	QueryInt64(key string, def int64) (int64, bool)</span></div><div class="token-line"><span class="token plain">    	QueryFloat64(key string, def float64) (float64, bool)</span></div><div class="token-line"><span class="token plain">    	QueryFloat32(key string, def float32) (float32, bool)</span></div><div class="token-line"><span class="token plain">    	QueryBool(key string, def bool) (bool, bool)</span></div><div class="token-line"><span class="token plain">    	QueryString(key string, def string) (string, bool)</span></div><div class="token-line"><span class="token plain">    	QueryStringSlice(key string, def []string) ([]string, bool)</span></div><div class="token-line"><span class="token plain">    	Query(key string) interface{}</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    	// 路由匹配中带的参数</span></div><div class="token-line"><span class="token plain">    	// 形如 /book/:id</span></div><div class="token-line"><span class="token plain">    	ParamInt(key string, def int) (int, bool)</span></div><div class="token-line"><span class="token plain">    	ParamInt64(key string, def int64) (int64, bool)</span></div><div class="token-line"><span class="token plain">    	ParamFloat64(key string, def float64) (float64, bool)</span></div><div class="token-line"><span class="token plain">    	ParamFloat32(key string, def float32) (float32, bool)</span></div><div class="token-line"><span class="token plain">    	ParamBool(key string, def bool) (bool, bool)</span></div><div class="token-line"><span class="token plain">    	ParamString(key string, def string) (string, bool)</span></div><div class="token-line"><span class="token plain">    	Param(key string) interface{}</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    	// form 表单中带的参数</span></div><div class="token-line"><span class="token plain">    	FormInt(key string, def int) (int, bool)</span></div><div class="token-line"><span class="token plain">    	FormInt64(key string, def int64) (int64, bool)</span></div><div class="token-line"><span class="token plain">    	FormFloat64(key string, def float64) (float64, bool)</span></div><div class="token-line"><span class="token plain">    	FormFloat32(key string, def float32) (float32, bool)</span></div><div class="token-line"><span class="token plain">    	FormBool(key string, def bool) (bool, bool)</span></div><div class="token-line"><span class="token plain">    	FormString(key string, def string) (string, bool)</span></div><div class="token-line"><span class="token plain">    	FormStringSlice(key string, def []string) ([]string, bool)</span></div><div class="token-line"><span class="token plain">    	FormFile(key string) (*multipart.FileHeader, error)</span></div><div class="token-line"><span class="token plain">    	Form(key string) interface{}</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    	// json body</span></div><div class="token-line"><span class="token plain">    	BindJson(obj interface{}) error</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    	// xml body</span></div><div class="token-line"><span class="token plain">    	BindXml(obj interface{}) error</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    	// 其他格式</span></div><div class="token-line"><span class="token plain">    	GetRawData() ([]byte, error)</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    	// 基础信息</span></div><div class="token-line"><span class="token plain">    	Uri() string</span></div><div class="token-line"><span class="token plain">    	Method() string</span></div><div class="token-line"><span class="token plain">    	Host() string</span></div><div class="token-line"><span class="token plain">    	ClientIp() string</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    	// header</span></div><div class="token-line"><span class="token plain">    	Headers() map[string][]string</span></div><div class="token-line"><span class="token plain">    	Header(key string) (string, bool)</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    	// cookie</span></div><div class="token-line"><span class="token plain">    	Cookies() map[string]string</span></div><div class="token-line"><span class="token plain">    	Cookie(key string) (string, bool)</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>简单说明一下，我们使用了 QueryXXX 的系列方法来代表从 URL 的参数后缀中获取的参数；使用 ParamXXX 的系列方法来代表从路由匹配中获取的参数；使用 FormXXX 的系列方法来代表从 Body 的 form 表单中获取的参数。</p><p>不知道你发现了没有，<strong>这三个系列的方法，我们统一了参数和返回值</strong>。</p><ul><li>参数一般都有两个：一个是 key，代表从参数列表中查找参数的关键词；另外一个是 def，代表如果查找不到关键词，会使用哪个默认值进行返回。</li><li>返回值返回两个：一个代表对应 key 的匹配值，而另一个 bool 返回值代表是否有这个返回值。</li></ul><p>这样的设计，在获取参数的时候，能让需要处理的两个逻辑，默认参数和是否有参数，都得到很好的处理；同时对于 JSON 格式、XML 格式的 Body 结构读取，也提供了对应的方法。</p><p>对基础信息，我们提供了 URI、Method、Host、ClinetIp 等方法；对 Header 头，我们提供根据 key 获取 Header 值的通用方法；同时，也对 Cookie 单独提供了批量获取 Cookie 和按照关键词获取 Cookie 的两个方法。</p><p>这些都对应我们第一部分分析的思维导图中“读取请求数据”部分。</p><h3 id="iresponse接口定义"><a aria-hidden="true" tabindex="-1" href="/blog/手把手带你写一个web框架/02.实战第1关从零开始/05#iresponse接口定义"><span class="icon icon-link"></span></a>IResponse接口定义</h3><p>对于封装返回数据 IResponse，我们在response.go中定义的方法如下：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// IResponse 代表返回方法</span></div><div class="token-line"><span class="token plain">    type IResponse interface {</span></div><div class="token-line"><span class="token plain">    	// Json 输出</span></div><div class="token-line"><span class="token plain">    	Json(obj interface{}) IResponse</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    	// Jsonp 输出</span></div><div class="token-line"><span class="token plain">    	Jsonp(obj interface{}) IResponse</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    	//xml 输出</span></div><div class="token-line"><span class="token plain">    	Xml(obj interface{}) IResponse</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    	// html 输出</span></div><div class="token-line"><span class="token plain">    	Html(template string, obj interface{}) IResponse</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    	// string</span></div><div class="token-line"><span class="token plain">    	Text(format string, values ...interface{}) IResponse</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    	// 重定向</span></div><div class="token-line"><span class="token plain">    	Redirect(path string) IResponse</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    	// header</span></div><div class="token-line"><span class="token plain">    	SetHeader(key string, val string) IResponse</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    	// Cookie</span></div><div class="token-line"><span class="token plain">    	SetCookie(key string, val string, maxAge int, path, domain string, secure, httpOnly bool) IResponse</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    	// 设置状态码</span></div><div class="token-line"><span class="token plain">    	SetStatus(code int) IResponse</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    	// 设置 200 状态</span></div><div class="token-line"><span class="token plain">    	SetOkStatus() IResponse</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>对于 Header 部分，我们设计了状态码的设置函数 SetStatus/SetOkStatus/Redirect，还设计了 Cookie 的设置函数 SetCookie，同时，我们提供了通用的设置 Header 的函数 SetHeader。</p><p>对于 Body 部分，我们设计了 JSON、JSONP、XML、HTML、Text 等方法来输出不同格式的 Body。</p><p>这里注意下，<strong>很多方法的返回值使用 IResponse 接口本身， 这个设计能允许使用方进行链式调用</strong>。链式调用的好处是，能很大提升代码的阅读性，比如在业务逻辑代码controller.go里这个调用方法：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">c.SetOkStatus().Json(&quot;ok, UserLoginController: &quot; + foo)</span></div></pre></div><p>就能很好地阅读：“返回成功，并且输出 JSON 字符串”。这种通过返回值返回接口本身的小技巧，我们后面会经常用到。</p><h2 id="实现具体的接口"><a aria-hidden="true" tabindex="-1" href="/blog/手把手带你写一个web框架/02.实战第1关从零开始/05#实现具体的接口"><span class="icon icon-link"></span></a>实现具体的接口</h2><p>接下来，我们需要实现这两个接口，直接将 Context 这个数据结构，实现这两个接口定义的方法就行了。<strong>因为在 Golang 中，只要包含了接口所带的函数就是实现了接口，并不需要显式标记继承</strong>。</p><p>由于这些接口有的比较重复，所以这里只解说几个重点的实现，具体可以参考 <a target="_blank" rel="noopener noreferrer" href="https://github.com/gohade/coredemo/tree/geekbang/05">GitHub 仓库<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>。</p><h2 id="请求相关接口实现"><a aria-hidden="true" tabindex="-1" href="/blog/手把手带你写一个web框架/02.实战第1关从零开始/05#请求相关接口实现"><span class="icon icon-link"></span></a>请求相关接口实现</h2><p>我们先将注意力专注在 Request 请求相关的方法上，首先处理刚才在request.go中定义的 Query 相关的参数请求方法。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// 请求地址 url 中带的参数</span></div><div class="token-line"><span class="token plain">    	// 形如: foo.com?a=1&amp;b=bar&amp;c[]=bar</span></div><div class="token-line"><span class="token plain">    	QueryInt(key string, def int) (int, bool)</span></div><div class="token-line"><span class="token plain">    	QueryInt64(key string, def int64) (int64, bool)</span></div><div class="token-line"><span class="token plain">    	QueryFloat64(key string, def float64) (float64, bool)</span></div><div class="token-line"><span class="token plain">    	QueryFloat32(key string, def float32) (float32, bool)</span></div><div class="token-line"><span class="token plain">    	QueryBool(key string, def bool) (bool, bool)</span></div><div class="token-line"><span class="token plain">    	QueryString(key string, def string) (string, bool)</span></div><div class="token-line"><span class="token plain">    	QueryStringSlice(key string, def []string) ([]string, bool)</span></div><div class="token-line"><span class="token plain">    	Query(key string) interface{}</span></div></pre></div><p>如何获取请求参数呢，我们可以从 http.Request 结构中，通过 Query 方法，获取到请求 URL 中的参数。</p><h3 id="query-请求方法实现"><a aria-hidden="true" tabindex="-1" href="/blog/手把手带你写一个web框架/02.实战第1关从零开始/05#query-请求方法实现"><span class="icon icon-link"></span></a>Query 请求方法实现</h3><p>所以，在request.go中，我们先创建一个 QueryAll() 方法。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// 获取请求地址中所有参数</span></div><div class="token-line"><span class="token plain">    func (ctx *Context) QueryAll() map[string][]string {</span></div><div class="token-line"><span class="token plain">    	if ctx.request != nil {</span></div><div class="token-line"><span class="token plain">    		return map[string][]string(ctx.request.URL.Query())</span></div><div class="token-line"><span class="token plain">    	}</span></div><div class="token-line"><span class="token plain">    	return map[string][]string{}</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>接着要做的，就是将这个 QueryAll 查询出来的 map 结构根据 key 查询，并且转换为其他类型的数据结构，比如 Int、Int64、Float64、Float32 等。</p><p>这里我推荐一个<a target="_blank" rel="noopener noreferrer" href="https://github.com/spf13/cast">第三方库cast<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>，这个库实现了多种常见类型之间的相互转换，返回最符合直觉的结果，通过<a target="_blank" rel="noopener noreferrer" href="https://pkg.go.dev/">这个网站<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>可以查看其提供的所有方法，这里展示部分你可以看看：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">...</span></div><div class="token-line"><span class="token plain">    func ToUint(i interface{}) uint</span></div><div class="token-line"><span class="token plain">    func ToUint16(i interface{}) uint16</span></div><div class="token-line"><span class="token plain">    func ToUint16E(i interface{}) (uint16, error)</span></div><div class="token-line"><span class="token plain">    func ToUint32(i interface{}) uint32</span></div><div class="token-line"><span class="token plain">    func ToUint32E(i interface{}) (uint32, error)</span></div><div class="token-line"><span class="token plain">    func ToUint64(i interface{}) uint64</span></div><div class="token-line"><span class="token plain">    func ToUint64E(i interface{}) (uint64, error)</span></div><div class="token-line"><span class="token plain">    func ToUint8(i interface{}) uint8</span></div><div class="token-line"><span class="token plain">    func ToUint8E(i interface{}) (uint8, error)</span></div><div class="token-line"><span class="token plain">    func ToUintE(i interface{}) (uint, error)</span></div><div class="token-line"><span class="token plain">    ...</span></div></pre></div><p>归纳起来，cast 提供类型转换方法，参数可以是任意类型，转换为对应的目标类型，每种转换会提供两组方法，一组是带 error 返回值的方法，一组是不带 error 返回值的。如果使用 cast 库，我们将request.go中 QueryXXX 方式的实现修改一下：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// 获取 Int 类型的请求参数</span></div><div class="token-line"><span class="token plain">    func (ctx *Context) QueryInt(key string, def int) (int, bool) {</span></div><div class="token-line"><span class="token plain">    	params := ctx.QueryAll()</span></div><div class="token-line"><span class="token plain">    	if vals, ok := params[key]; ok {</span></div><div class="token-line"><span class="token plain">    		if len(vals) &gt; 0 {</span></div><div class="token-line"><span class="token plain">    			// 使用 cast 库将 string 转换为 Int</span></div><div class="token-line"><span class="token plain">    			return cast.ToInt(vals[0]), true</span></div><div class="token-line"><span class="token plain">    		}</span></div><div class="token-line"><span class="token plain">    	}</span></div><div class="token-line"><span class="token plain">    	return def, false</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>QueryAll返回一个map结构，根据key查找出对应的参数值，并且通过cast库将对应的参数值转化成目标数据结构。</p><p>Query 的参数请求方法就实现完成了。<strong>Form 表单相关的请求方法是从 HTTP Body 中获取参数，同 Query 方法相类似，我们就不再重复</strong>，简单说下思路：可以从 http.Request 中获取到 Form 的请求参数，然后再用 cast 库进行类型转换。</p><h3 id="param-请求方法实现"><a aria-hidden="true" tabindex="-1" href="/blog/手把手带你写一个web框架/02.实战第1关从零开始/05#param-请求方法实现"><span class="icon icon-link"></span></a>Param 请求方法实现</h3><p>接下来，我们需要实现 Param 相关的请求方法。</p><p>Param 的请求方法是：通过路由解析请求地址，抽取请求地址中包含通配符的段。比如路由规则为 /subject/:id，真实请求 URI 为 /subject/1，那么获取 key 为 id 的 Param 值就为 1。</p><p>怎么实现我们得回顾第三节课讲的路由，用 trie 树实现了路由规则。当请求进入的时候，将请求的 URI 地址根据分隔符分成不同的段，用这个段去匹配 trie 树。只有当每个段都匹配 trie 树中某个路径的时候，我们才将路径终止节点里的 Handlers ，作为这个请求的最终处理函数。<br/><img src="https://static001.geekbang.org/resource/image/68/98/6837822864392bbb5e7345518448b098.jpg?wh=1920x1080" alt=""/></p><p>而在这个匹配路径中，有的节点是根据通配符进行匹配的，这些节点就是我们要查找的 Param 参数。</p><p>现在就要获取路由解析过程中的这些通配符参数，<strong>最朴素的想法就是：查找出这个匹配路径，然后查找出其中的通配符节点，再和请求 URI 对应，获取这些通配符参数</strong>。我们看这个想法如何实现。</p><p>之前查找路由的时候，查到的是匹配路径的最终节点，如何追溯到整个匹配路径呢？这里我们可以考虑构造一个双向链表：改造 node 节点，增加一个 parent 指针，指向父节点，将 trie 树变成一个双向指针。来修改框架目录中的trie.go：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// 代表节点</span></div><div class="token-line"><span class="token plain">    type node struct {</span></div><div class="token-line"><span class="token plain">    	...</span></div><div class="token-line"><span class="token plain">    	parent   *node               // 父节点，双向指针</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>在增加路由规则（AddRouter）的时候，创建子节点也要同时修改这个 parent 指针，继续写：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">func (tree *Tree) AddRouter(uri string, handlers []ControllerHandler) error {</span></div><div class="token-line"><span class="token plain">    	...</span></div><div class="token-line"><span class="token plain">    	// 对每个 segment</span></div><div class="token-line"><span class="token plain">    	for index, segment := range segments {</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    		...</span></div><div class="token-line"><span class="token plain">    		if objNode == nil {</span></div><div class="token-line"><span class="token plain">    			// 创建一个当前 node 的节点</span></div><div class="token-line"><span class="token plain">    			cnode := newNode()</span></div><div class="token-line"><span class="token plain">    			cnode.segment = segment</span></div><div class="token-line"><span class="token plain">    			if isLast {</span></div><div class="token-line"><span class="token plain">    				cnode.isLast = true</span></div><div class="token-line"><span class="token plain">    				cnode.handlers = handlers</span></div><div class="token-line"><span class="token plain">    			}</span></div><div class="token-line"><span class="token plain">    			// 父节点指针修改</span></div><div class="token-line"><span class="token plain">    			cnode.parent = n</span></div><div class="token-line"><span class="token plain">    			n.childs = append(n.childs, cnode)</span></div><div class="token-line"><span class="token plain">    			objNode = cnode</span></div><div class="token-line"><span class="token plain">    		}</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    		n = objNode</span></div><div class="token-line"><span class="token plain">    	}</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    	return nil</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>这样，双向链表就修改完了。接着就根据最终匹配的节点和请求 URI，查找出整个匹配链路中的通配符节点和对应 URI 中的分段，还是在trie.go里继续写：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// 将 uri 解析为 params</span></div><div class="token-line"><span class="token plain">    func (n *node) parseParamsFromEndNode(uri string) map[string]string {</span></div><div class="token-line"><span class="token plain">    	ret := map[string]string{}</span></div><div class="token-line"><span class="token plain">    	segments := strings.Split(uri, &quot;/&quot;)</span></div><div class="token-line"><span class="token plain">    	cnt := len(segments)</span></div><div class="token-line"><span class="token plain">    	cur := n</span></div><div class="token-line"><span class="token plain">    	for i := cnt - 1; i &gt;= 0; i-- {</span></div><div class="token-line"><span class="token plain">    		if cur.segment == &quot;&quot; {</span></div><div class="token-line"><span class="token plain">    			break</span></div><div class="token-line"><span class="token plain">    		}</span></div><div class="token-line"><span class="token plain">    		// 如果是通配符节点</span></div><div class="token-line"><span class="token plain">    		if isWildSegment(cur.segment) {</span></div><div class="token-line"><span class="token plain">    			// 设置 params</span></div><div class="token-line"><span class="token plain">    			ret[cur.segment[1:]] = segments[i]</span></div><div class="token-line"><span class="token plain">    		}</span></div><div class="token-line"><span class="token plain">    		cur = cur.parent</span></div><div class="token-line"><span class="token plain">    	}</span></div><div class="token-line"><span class="token plain">    	return ret</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>接下来，为了让 context 中有 map 结构的路由参数，我们将解析出来的 params 存储到 context 结构中。这里修改框架目录中的core.go文件：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// 所有请求都进入这个函数, 这个函数负责路由分发</span></div><div class="token-line"><span class="token plain">    func (c *Core) ServeHTTP(response http.ResponseWriter, request *http.Request) {</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    	// 封装自定义 context</span></div><div class="token-line"><span class="token plain">    	ctx := NewContext(request, response)</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    	// 寻找路由</span></div><div class="token-line"><span class="token plain">    	node := c.FindRouteNodeByRequest(request)</span></div><div class="token-line"><span class="token plain">    	...</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    	// 设置路由参数</span></div><div class="token-line"><span class="token plain">    	params := node.parseParamsFromEndNode(request.URL.Path)</span></div><div class="token-line"><span class="token plain">    	ctx.SetParams(params)</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    	...</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>最后，回到框架目录的request.go，我们还是使用 cast 库来将这个 Param 系列方法完成：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// 获取路由参数</span></div><div class="token-line"><span class="token plain">    func (ctx *Context) Param(key string) interface{} {</span></div><div class="token-line"><span class="token plain">    	if ctx.params != nil {</span></div><div class="token-line"><span class="token plain">    		if val, ok := ctx.params[key]; ok {</span></div><div class="token-line"><span class="token plain">    			return val</span></div><div class="token-line"><span class="token plain">    		}</span></div><div class="token-line"><span class="token plain">    	}</span></div><div class="token-line"><span class="token plain">    	return nil</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    // 路由匹配中带的参数</span></div><div class="token-line"><span class="token plain">    // 形如 /book/:id</span></div><div class="token-line"><span class="token plain">    func (ctx *Context) ParamInt(key string, def int) (int, bool) {</span></div><div class="token-line"><span class="token plain">    	if val := ctx.Param(key); val != nil {</span></div><div class="token-line"><span class="token plain">    		// 通过 cast 进行类型转换</span></div><div class="token-line"><span class="token plain">    		return cast.ToInt(val), true</span></div><div class="token-line"><span class="token plain">    	}</span></div><div class="token-line"><span class="token plain">    	return def, false</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><h3 id="bind-请求方法实现"><a aria-hidden="true" tabindex="-1" href="/blog/手把手带你写一个web框架/02.实战第1关从零开始/05#bind-请求方法实现"><span class="icon icon-link"></span></a>Bind 请求方法实现</h3><p>到这里，ParamXXX系列函数就完成了，接下来我们看下 BindXXX 系列函数，比如 BindJson。它的实现只需要简单2步：读取 Body 中的文本、解析 body 文本到结构体。所以修改response.go中的函数：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// 将 body 文本解析到 obj 结构体中</span></div><div class="token-line"><span class="token plain">    func (ctx *Context) BindJson(obj interface{}) error {</span></div><div class="token-line"><span class="token plain">    	if ctx.request != nil {</span></div><div class="token-line"><span class="token plain">    		// 读取文本</span></div><div class="token-line"><span class="token plain">    		body, err := ioutil.ReadAll(ctx.request.Body)</span></div><div class="token-line"><span class="token plain">    		if err != nil {</span></div><div class="token-line"><span class="token plain">    			return err</span></div><div class="token-line"><span class="token plain">    		}</span></div><div class="token-line"><span class="token plain">    		// 重新填充 request.Body，为后续的逻辑二次读取做准备</span></div><div class="token-line"><span class="token plain">    		ctx.request.Body = ioutil.NopCloser(bytes.NewBuffer(body))</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    		// 解析到 obj 结构体中</span></div><div class="token-line"><span class="token plain">    		err = json.Unmarshal(body, obj)</span></div><div class="token-line"><span class="token plain">    		if err != nil {</span></div><div class="token-line"><span class="token plain">    			return err</span></div><div class="token-line"><span class="token plain">    		}</span></div><div class="token-line"><span class="token plain">    	} else {</span></div><div class="token-line"><span class="token plain">    		return errors.New(&quot;ctx.request empty&quot;)</span></div><div class="token-line"><span class="token plain">    	}</span></div><div class="token-line"><span class="token plain">    	return nil</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>读取 Body 中的文本，我们使用 ioutil.ReadAll 方法，解析 Body 文本到结构体中，我们使用 json.Unmarshal 方法。</p><p>这里要注意，<strong>request.Body 的读取是一次性的</strong>，读取一次之后，下个逻辑再去 request.Body 中是读取不到数据内容的。所以我们读取完 request.Body 之后，还要再复制一份 Body 内容，填充到 request.Body 里。</p><h2 id="返回相关接口实现"><a aria-hidden="true" tabindex="-1" href="/blog/手把手带你写一个web框架/02.实战第1关从零开始/05#返回相关接口实现"><span class="icon icon-link"></span></a>返回相关接口实现</h2><p>返回接口中的 JSON、XML、TEXT 的输出是比较简单的，将输出数据结构进行序列化就行，这里我们重点讲比较复杂的两种实现 JSONP 输出和 HTML 输出。</p><h3 id="jsonp-输出方法实现"><a aria-hidden="true" tabindex="-1" href="/blog/手把手带你写一个web框架/02.实战第1关从零开始/05#jsonp-输出方法实现"><span class="icon icon-link"></span></a>JSONP 输出方法实现</h3><p>JSONP 是一种我们常用的解决跨域资源共享的方法，简要介绍下这个方法的原理。</p><p>在 JavaScript 中使用 HTTP 请求（Ajax）会受到同源策略的限制。比如说 A 网站的页面不能在 JavaScript 中跨域访问 B 网站的资源。但是，如果我们希望能跨域访问怎么办？</p><p>我们知道 HTML 中标签&lt;script&gt;中的请求是不受同源策略影响的，<strong>那如果能将B网站的资源数据，通过script标签返回来，是不是就直接解决了跨域问题</strong>？确实，JSONP就是这么设计的，通过script标签的源地址，返回数据资源+ JavaScript代码。</p><p>比如 A 网站的网页如下，它希望从 B 网站中获取数据，填充进 id 为&quot;context&quot;的 div 标签中。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">&lt;html&gt;</span></div><div class="token-line"><span class="token plain">      &lt;body&gt;</span></div><div class="token-line"><span class="token plain">        &lt;div id=&quot;context&quot;&gt;&lt;/div&gt;</span></div><div class="token-line"><span class="token plain">      &lt;/body&gt;</span></div><div class="token-line"><span class="token plain">    &lt;/html&gt;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    &lt;script&gt;</span></div><div class="token-line"><span class="token plain">      function callfun(data) {</span></div><div class="token-line"><span class="token plain">         document.getElementById(&#x27;context&#x27;).innerHTML = data;</span></div><div class="token-line"><span class="token plain">      }</span></div><div class="token-line"><span class="token plain">    &lt;/script&gt;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    &lt;script src=&quot;http://B.com/jsonp?callback=callfun&quot;&gt;&lt;/script&gt;</span></div></pre></div><p>使用 ajax 请求的时候，我们是做不到这一点的，因为同源策略限制了网页和数据必须在同一个源下。但是如果 B 网站的接口支持了 JSONP，它能根据请求参数返回一段 JavaScript 代码，类似：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">callfunc({&quot;id&quot;:1, &quot;name&quot;: jianfengye})</span></div></pre></div><p>这时 A 网站的网页，就能直接调用 callfunc 方法，并且获取到 B 网站返回的数据。</p><p>了解了 JSONP 的原理，我们回到服务端实现 JSONP 的方法中。这个方法要做的事情就是：<strong>获取请求中的参数作为函数名，获取要返回的数据 JSON 作为函数参数，将函数名+函数参数作为返回文本</strong>。</p><p>我们在response.go中补充Jsonp方法。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// Jsonp 输出</span></div><div class="token-line"><span class="token plain">    func (ctx *Context) Jsonp(obj interface{}) IResponse {</span></div><div class="token-line"><span class="token plain">    	// 获取请求参数 callback</span></div><div class="token-line"><span class="token plain">    	callbackFunc, _ := ctx.QueryString(&quot;callback&quot;, &quot;callback_function&quot;)</span></div><div class="token-line"><span class="token plain">    	ctx.SetHeader(&quot;Content-Type&quot;, &quot;application/javascript&quot;)</span></div><div class="token-line"><span class="token plain">    	// 输出到前端页面的时候需要注意下进行字符过滤，否则有可能造成 XSS 攻击</span></div><div class="token-line"><span class="token plain">    	callback := template.JSEscapeString(callbackFunc)</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    	// 输出函数名</span></div><div class="token-line"><span class="token plain">    	_, err := ctx.responseWriter.Write([]byte(callback))</span></div><div class="token-line"><span class="token plain">    	if err != nil {</span></div><div class="token-line"><span class="token plain">    		return ctx</span></div><div class="token-line"><span class="token plain">    	}</span></div><div class="token-line"><span class="token plain">    	// 输出左括号</span></div><div class="token-line"><span class="token plain">    	_, err = ctx.responseWriter.Write([]byte(&quot;(&quot;))</span></div><div class="token-line"><span class="token plain">    	if err != nil {</span></div><div class="token-line"><span class="token plain">    		return ctx</span></div><div class="token-line"><span class="token plain">    	}</span></div><div class="token-line"><span class="token plain">    	// 数据函数参数</span></div><div class="token-line"><span class="token plain">    	ret, err := json.Marshal(obj)</span></div><div class="token-line"><span class="token plain">    	if err != nil {</span></div><div class="token-line"><span class="token plain">    		return ctx</span></div><div class="token-line"><span class="token plain">    	}</span></div><div class="token-line"><span class="token plain">    	_, err = ctx.responseWriter.Write(ret)</span></div><div class="token-line"><span class="token plain">    	if err != nil {</span></div><div class="token-line"><span class="token plain">    		return ctx</span></div><div class="token-line"><span class="token plain">    	}</span></div><div class="token-line"><span class="token plain">    	// 输出右括号</span></div><div class="token-line"><span class="token plain">    	_, err = ctx.responseWriter.Write([]byte(&quot;)&quot;))</span></div><div class="token-line"><span class="token plain">    	if err != nil {</span></div><div class="token-line"><span class="token plain">    		return ctx</span></div><div class="token-line"><span class="token plain">    	}</span></div><div class="token-line"><span class="token plain">    	return ctx</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><h3 id="html-输出方法实现"><a aria-hidden="true" tabindex="-1" href="/blog/手把手带你写一个web框架/02.实战第1关从零开始/05#html-输出方法实现"><span class="icon icon-link"></span></a>HTML 输出方法实现</h3><p>接下来我们分析下 HTML 输出。</p><p>HTML 函数输出的就是一个纯 HTML 页面。现在的 HTML 页面，基本都是动态页面，也就是说页面基本内容都是一样，但是根据不同请求、不同逻辑，页面中的数据部分是不同的。所以，我们在输出 HTML 页面内容的时候，常用“模版+数据”的方式。</p><p>模版中存放的是页面基本内容，包括布局信息（CSS）、通用脚本（JavaScript）、页面整体结构（HTML）。但是页面结构中，某个标签的具体内容、具体数值，就表示成数据，在模版中保留数据的位置，在最终渲染 HTML 内容的时候，把数据填充进入模版就行了。</p><p>在 Golang 中，这种“模版+数据”的文本渲染方式是有一个官方库来实现的 <a target="_blank" rel="noopener noreferrer" href="https://golang.org/pkg/html/template/">html/template<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> ，它的模版使用<!-- -->{<!-- -->{<!-- -->.XX<!-- -->}<!-- -->}<!-- --> 作为数据的占位符，表示传入的数据结构的某个字段：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">&lt;h1&gt;{{.PageTitle}}&lt;/h1&gt;</span></div><div class="token-line"><span class="token plain">    &lt;ul&gt;</span></div><div class="token-line"><span class="token plain">        {{range .Todos}}</span></div><div class="token-line"><span class="token plain">            {{if .Done}}</span></div><div class="token-line"><span class="token plain">                &lt;li class=&quot;done&quot;&gt;{{.Title}}&lt;/li&gt;</span></div><div class="token-line"><span class="token plain">            {{else}}</span></div><div class="token-line"><span class="token plain">                &lt;li&gt;{{.Title}}&lt;/li&gt;</span></div><div class="token-line"><span class="token plain">            {{end}}</span></div><div class="token-line"><span class="token plain">        {{end}}</span></div><div class="token-line"><span class="token plain">    &lt;/ul&gt;</span></div></pre></div><p>传入的数据结构为：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">data := TodoPageData{</span></div><div class="token-line"><span class="token plain">        PageTitle: &quot;My TODO list&quot;,</span></div><div class="token-line"><span class="token plain">        Todos: []Todo{</span></div><div class="token-line"><span class="token plain">            {Title: &quot;Task 1&quot;, Done: false},</span></div><div class="token-line"><span class="token plain">            {Title: &quot;Task 2&quot;, Done: true},</span></div><div class="token-line"><span class="token plain">            {Title: &quot;Task 3&quot;, Done: true},</span></div><div class="token-line"><span class="token plain">        },</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>所以具体的渲染可以分成两步：<strong>先根据模版创造出 template 结构；再使用 template.Execute 将传入数据和模版结合</strong>。</p><p>我们的 HTML 函数可以使用 html/template，修改框架目录response.go中的Html方法：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// html 输出</span></div><div class="token-line"><span class="token plain">    func (ctx *Context) Html(file string, obj interface{}) IResponse {</span></div><div class="token-line"><span class="token plain">    	// 读取模版文件，创建 template 实例</span></div><div class="token-line"><span class="token plain">    	t, err := template.New(&quot;output&quot;).ParseFiles(file)</span></div><div class="token-line"><span class="token plain">    	if err != nil {</span></div><div class="token-line"><span class="token plain">    		return ctx</span></div><div class="token-line"><span class="token plain">    	}</span></div><div class="token-line"><span class="token plain">    	// 执行 Execute 方法将 obj 和模版进行结合</span></div><div class="token-line"><span class="token plain">    	if err := t.Execute(ctx.responseWriter, obj); err != nil {</span></div><div class="token-line"><span class="token plain">    		return ctx</span></div><div class="token-line"><span class="token plain">    	}</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    	ctx.SetHeader(&quot;Content-Type&quot;, &quot;application/html&quot;)</span></div><div class="token-line"><span class="token plain">    	return ctx</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>参数为模版文件和输出对象，先使用 ParseFiles 来读取模版文件，创建一个 template 数据结构，然后使用 Execute 方法，将数据对象和模版进行结合，并且输出到 responseWriter 中。</p><p>这节课的代码结构放在这里了，完整的代码在GitHub上的<a target="_blank" rel="noopener noreferrer" href="https://github.com/gohade/coredemo/tree/geekbang/05">geekbang/05<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>分支上。<br/><img src="https://static001.geekbang.org/resource/image/f3/37/f352fyyb3443eeed2ce318859638bb37.png?wh=746x1398" alt=""/></p><h2 id="小结"><a aria-hidden="true" tabindex="-1" href="/blog/手把手带你写一个web框架/02.实战第1关从零开始/05#小结"><span class="icon icon-link"></span></a>小结</h2><p>我们这节课在 context 这个数据结构中，封装和实现“读取请求数据”和“封装返回数据”的方法。首先系统思考这两个需求功能的封装；再设计IRequest和IResponse两个接口，定义了对应的方法，并且让context实现这两个接口；最后，我们对这两个接口的方法进行了具体实现。</p><p>你现在是不是认识到了，为什么我在开头会说，函数封装并不是一件很简单、很随意的事情，如何封装出易用、可读性高的函数是需要我们精心考量的。</p><p>如果说一定要记住一句话，希望你能记住，在实现“读取请求数据”和“封装返回数据”的过程中，采用“<strong>先系统设计，再定义接口，最后具体实现</strong>”的系统思考方法。如果你一接到要开发某些功能模块需求，不先想清楚就立刻上手，最终实现的代码，细节会非常混乱，复用性极差。</p><p>请记住，设计永远优于实现！</p><h2 id="思考题"><a aria-hidden="true" tabindex="-1" href="/blog/手把手带你写一个web框架/02.实战第1关从零开始/05#思考题"><span class="icon icon-link"></span></a>思考题</h2><p>作为一个Web框架，安全性是很关键的一个环节，我们在实现JSONP方法的时候，有这一行代码：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">//输出到前端页面的时候需要注意下进行字符过滤，否则有可能造成 XSS 攻击</span></div><div class="token-line"><span class="token plain">    callback := template.JSEscapeString(callbackFunc)</span></div></pre></div><p>请你思考下，如果我直接将callbackFunc输出到页面上，会有什么不安全的问题吗？什么是XSS攻击？</p><p>欢迎在留言区分享你的思考。感谢你的收听，如果你觉得今天的内容对你有所帮助，也欢迎分享给你身边的朋友，邀请他一起学习。下节课见～</p></div><div class="__dumi-default-layout-footer-meta"><a target="_blank" rel="noopener noreferrer" href="https://github.com/GGwujun/blog/edit/master/docs/手把手带你写一个Web框架/02.实战第1关从零开始/05.md">在 GitHub 上编辑此页<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a><span data-updated-text="最后更新时间：">5/2/2022 10:56:58</span></div></div></div></div>
	<script>
  window.g_useSSR = true;
  window.g_initialProps = {};
	</script>

    <script>
      (function () {
        if (!location.port) {
          (function (i, s, o, g, r, a, m) {
            i["GoogleAnalyticsObject"] = r;
            (i[r] =
              i[r] ||
              function () {
                (i[r].q = i[r].q || []).push(arguments);
              }),
              (i[r].l = 1 * new Date());
            (a = s.createElement(o)), (m = s.getElementsByTagName(o)[0]);
            a.async = 1;
            a.src = g;
            m.parentNode.insertBefore(a, m);
          })(
            window,
            document,
            "script",
            "//www.google-analytics.com/analytics.js",
            "ga"
          );
          ga("create", "UA-149864185-1", "auto");
          ga("send", "pageview");
        }
      })();
    </script>
    <script src="/blog/umi.js"></script>
  </body>
</html>
