<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no"
    />
    <link rel="shortcut icon" type="image/x-icon" href="/logo.png" />
    <link rel="stylesheet" href="/blog/umi.css" />
    <script>
      window.routerBase = "/blog";
    </script>
    <script>
      //! umi version: 3.5.17
    </script>
    <script>
      !(function () {
        var e = localStorage.getItem("dumi:prefers-color"),
          t = window.matchMedia("(prefers-color-scheme: dark)").matches,
          r = ["light", "dark", "auto"];
        document.documentElement.setAttribute(
          "data-prefers-color",
          e === r[2] ? (t ? r[1] : r[0]) : r.indexOf(e) > -1 ? e : r[0]
        );
      })();
    </script>
    <title>大咖助阵｜大明：抽象，抽象，还是抽象</title>
  </head>
  <body>
    <div id="root"><div class="__dumi-default-layout" data-route="/手把手带你写一个web框架/04.实战第3关完善功能/13" data-show-sidemenu="true" data-show-slugs="true" data-site-mode="true" data-gapless="false"><div class="__dumi-default-navbar" data-mode="site"><button class="__dumi-default-navbar-toggle"></button><a class="__dumi-default-navbar-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog/">大师兄</a><nav><div class="__dumi-default-search"><input type="search" class="__dumi-default-search-input" value=""/><ul></ul></div><span>计算机基础<ul><li><a href="/blog/编译原理之美">编译原理之美</a></li><li><a href="/blog/编译原理实战">编译原理实战</a></li><li><a href="/blog/深入浅出计算机组成原理">深入浅出计算机组成原理</a></li><li><a href="/blog/详解http">详解http</a></li><li><a href="/blog/计算机网络通关29讲">计算机网络通关29讲</a></li><li><a href="/blog/网络排查案例课">网络排查案例课</a></li><li><a href="/blog/linux操作系统">linux操作系统</a></li><li><a href="/blog/linux性能优化实战">linux性能优化实战</a></li><li><a href="/blog/程序员数学基础">程序员数学基础</a></li><li><a href="/blog/趣谈网络协议">趣谈网络协议</a></li><li><a href="/blog/操作系统实战">操作系统实战</a></li><li><a href="/blog/软件工程之美">软件工程之美</a></li><li><a href="/blog/sql必知必会">sql必知必会</a></li><li><a href="/blog/操作系统实战45讲">操作系统实战45讲</a></li><li><a href="/blog/网络编程实战">网络编程实战</a></li></ul></span><span>算法<ul><li><a href="/blog/常用算法25讲">常用算法25讲</a></li><li><a href="/blog/数据结构与算法之美">数据结构与算法之美</a></li><li><a href="/blog/业务开发算法50讲">业务开发算法50讲</a></li><li><a href="/blog/动态规划面试宝典">动态规划面试宝典</a></li></ul></span><span>前端开发<ul><li><a href="/blog/浏览器工作原理与实践">浏览器工作原理与实践</a></li><li><a href="/blog/新时代产品经理进阶之路">新时代产品经理进阶之路</a></li><li><a href="/blog/全栈工程师修炼指南">全栈工程师修炼指南</a></li><li><a href="/blog/flutter核心技术与实战">flutter核心技术与实战</a></li><li><a href="/blog/java-script核心原理解析">java-script核心原理解析</a></li><li><a href="/blog/说透低代码">说透低代码</a></li><li><a href="/blog/nodejs应用开发实战">nodejs应用开发实战</a></li><li><a href="/blog/反爬虫兵法演绎20讲">反爬虫兵法演绎20讲</a></li><li><a href="/blog/reactnative新架构实战课">reactnative新架构实战课</a></li><li><a href="/blog/正则表达式入门">正则表达式入门</a></li><li><a href="/blog/重学前端">重学前端</a></li><li><a href="/blog/serverless入门课">serverless入门课</a></li><li><a href="/blog/type-script入门实战笔记">type-script入门实战笔记</a></li><li><a href="/blog/图解googlev8">图解googlev8</a></li><li><a href="/blog/vue3源码分析">vue3源码分析</a></li><li><a href="/blog/玩转Vue3全家桶">玩转Vue3全家桶</a></li><li><a href="/blog/webassembly入门">webassembly入门</a></li><li><a aria-current="page" class="active" href="/blog/手把手带你写一个Web框架">手把手带你写一个Web框架</a></li><li><a href="/blog/web漏洞挖掘实战">web漏洞挖掘实战</a></li><li><a href="/blog/跟月影学可视化">跟月影学可视化</a></li><li><a href="/blog/搞定音频技术">搞定音频技术</a></li><li><a href="/blog/攻克视频技术">攻克视频技术</a></li></ul></span><span>前端工程化<ul><li><a href="/blog/logger">logger</a></li><li><a href="/blog/webpack">webpack</a></li><li><a href="/blog/webpackChain">webpackChain</a></li></ul></span><span>前端性能优化<ul><li><a href="/blog/react性能调优">react性能调优</a></li></ul></span><span>软件测试<ul><li><a href="/blog/全链路压测实战30讲">全链路压测实战30讲</a></li><li><a href="/blog/性能测试实战30讲">性能测试实战30讲</a></li><li><a href="/blog/自动化测试高手课">自动化测试高手课</a></li><li><a href="/blog/软件测试52讲">软件测试52讲</a></li></ul></span><span>面试<ul><li><a href="/blog/面试现场">面试现场</a></li></ul></span><span>杂谈<ul><li><a href="/blog/超级访谈对话张雪峰">超级访谈对话张雪峰</a></li><li><a href="/blog/Git实战手册">Git实战手册</a></li><li><a href="/blog/NodeJS">NodeJS</a></li><li><a href="/blog/ReactJS">ReactJS</a></li><li><a href="/blog/UI设计">UI设计</a></li><li><a href="/blog/webpack4系列教程">webpack4系列教程</a></li><li><a href="/blog/前端知识体系">前端知识体系</a></li><li><a href="/blog/剑指offer刷题笔记">剑指offer刷题笔记</a></li><li><a href="/blog/思考与成长">思考与成长</a></li><li><a href="/blog/设计模式手册">设计模式手册</a></li></ul></span><div class="__dumi-default-navbar-tool"><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "></div></div></div></nav></div><div class="__dumi-default-menu" data-mode="site"><div class="__dumi-default-menu-inner"><div class="__dumi-default-menu-header"><a class="__dumi-default-menu-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog/"></a><h1>大师兄</h1><p></p></div><div class="__dumi-default-menu-mobile-area"><ul class="__dumi-default-menu-nav-list"><li>计算机基础<ul><li><a href="/blog/编译原理之美">编译原理之美</a></li><li><a href="/blog/编译原理实战">编译原理实战</a></li><li><a href="/blog/深入浅出计算机组成原理">深入浅出计算机组成原理</a></li><li><a href="/blog/详解http">详解http</a></li><li><a href="/blog/计算机网络通关29讲">计算机网络通关29讲</a></li><li><a href="/blog/网络排查案例课">网络排查案例课</a></li><li><a href="/blog/linux操作系统">linux操作系统</a></li><li><a href="/blog/linux性能优化实战">linux性能优化实战</a></li><li><a href="/blog/程序员数学基础">程序员数学基础</a></li><li><a href="/blog/趣谈网络协议">趣谈网络协议</a></li><li><a href="/blog/操作系统实战">操作系统实战</a></li><li><a href="/blog/软件工程之美">软件工程之美</a></li><li><a href="/blog/sql必知必会">sql必知必会</a></li><li><a href="/blog/操作系统实战45讲">操作系统实战45讲</a></li><li><a href="/blog/网络编程实战">网络编程实战</a></li></ul></li><li>算法<ul><li><a href="/blog/常用算法25讲">常用算法25讲</a></li><li><a href="/blog/数据结构与算法之美">数据结构与算法之美</a></li><li><a href="/blog/业务开发算法50讲">业务开发算法50讲</a></li><li><a href="/blog/动态规划面试宝典">动态规划面试宝典</a></li></ul></li><li>前端开发<ul><li><a href="/blog/浏览器工作原理与实践">浏览器工作原理与实践</a></li><li><a href="/blog/新时代产品经理进阶之路">新时代产品经理进阶之路</a></li><li><a href="/blog/全栈工程师修炼指南">全栈工程师修炼指南</a></li><li><a href="/blog/flutter核心技术与实战">flutter核心技术与实战</a></li><li><a href="/blog/java-script核心原理解析">java-script核心原理解析</a></li><li><a href="/blog/说透低代码">说透低代码</a></li><li><a href="/blog/nodejs应用开发实战">nodejs应用开发实战</a></li><li><a href="/blog/反爬虫兵法演绎20讲">反爬虫兵法演绎20讲</a></li><li><a href="/blog/reactnative新架构实战课">reactnative新架构实战课</a></li><li><a href="/blog/正则表达式入门">正则表达式入门</a></li><li><a href="/blog/重学前端">重学前端</a></li><li><a href="/blog/serverless入门课">serverless入门课</a></li><li><a href="/blog/type-script入门实战笔记">type-script入门实战笔记</a></li><li><a href="/blog/图解googlev8">图解googlev8</a></li><li><a href="/blog/vue3源码分析">vue3源码分析</a></li><li><a href="/blog/玩转Vue3全家桶">玩转Vue3全家桶</a></li><li><a href="/blog/webassembly入门">webassembly入门</a></li><li><a aria-current="page" class="active" href="/blog/手把手带你写一个Web框架">手把手带你写一个Web框架</a></li><li><a href="/blog/web漏洞挖掘实战">web漏洞挖掘实战</a></li><li><a href="/blog/跟月影学可视化">跟月影学可视化</a></li><li><a href="/blog/搞定音频技术">搞定音频技术</a></li><li><a href="/blog/攻克视频技术">攻克视频技术</a></li></ul></li><li>前端工程化<ul><li><a href="/blog/logger">logger</a></li><li><a href="/blog/webpack">webpack</a></li><li><a href="/blog/webpackChain">webpackChain</a></li></ul></li><li>前端性能优化<ul><li><a href="/blog/react性能调优">react性能调优</a></li></ul></li><li>软件测试<ul><li><a href="/blog/全链路压测实战30讲">全链路压测实战30讲</a></li><li><a href="/blog/性能测试实战30讲">性能测试实战30讲</a></li><li><a href="/blog/自动化测试高手课">自动化测试高手课</a></li><li><a href="/blog/软件测试52讲">软件测试52讲</a></li></ul></li><li>面试<ul><li><a href="/blog/面试现场">面试现场</a></li></ul></li><li>杂谈<ul><li><a href="/blog/超级访谈对话张雪峰">超级访谈对话张雪峰</a></li><li><a href="/blog/Git实战手册">Git实战手册</a></li><li><a href="/blog/NodeJS">NodeJS</a></li><li><a href="/blog/ReactJS">ReactJS</a></li><li><a href="/blog/UI设计">UI设计</a></li><li><a href="/blog/webpack4系列教程">webpack4系列教程</a></li><li><a href="/blog/前端知识体系">前端知识体系</a></li><li><a href="/blog/剑指offer刷题笔记">剑指offer刷题笔记</a></li><li><a href="/blog/思考与成长">思考与成长</a></li><li><a href="/blog/设计模式手册">设计模式手册</a></li></ul></li></ul><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "><button title="Dark theme" class="__dumi-default-dark-moon "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="3854" width="22" height="22"><path d="M991.816611 674.909091a69.166545 69.166545 0 0 0-51.665455-23.272727 70.795636 70.795636 0 0 0-27.438545 5.585454A415.674182 415.674182 0 0 1 754.993338 698.181818c-209.594182 0-393.472-184.785455-393.472-395.636363 0-52.363636 38.539636-119.621818 69.515637-173.614546 4.887273-8.610909 9.634909-16.756364 14.103272-24.901818A69.818182 69.818182 0 0 0 384.631156 0a70.842182 70.842182 0 0 0-27.438545 5.585455C161.678429 90.298182 14.362065 307.898182 14.362065 512c0 282.298182 238.824727 512 532.38691 512a522.286545 522.286545 0 0 0 453.957818-268.334545A69.818182 69.818182 0 0 0 991.816611 674.909091zM546.679156 954.181818c-248.785455 0-462.941091-192-462.941091-442.181818 0-186.647273 140.637091-372.829091 300.939637-442.181818-36.817455 65.629091-92.578909 151.970909-92.578909 232.727273 0 250.181818 214.109091 465.454545 462.917818 465.454545a488.331636 488.331636 0 0 0 185.181091-46.545455 453.003636 453.003636 0 0 1-393.565091 232.727273z m103.656728-669.323636l-14.266182 83.781818a34.909091 34.909091 0 0 0 50.362182 36.770909l74.775272-39.563636 74.752 39.563636a36.142545 36.142545 0 0 0 16.174546 3.956364 34.909091 34.909091 0 0 0 34.210909-40.727273l-14.289455-83.781818 60.509091-59.345455a35.025455 35.025455 0 0 0-19.223272-59.578182l-83.61891-12.101818-37.376-76.101818a34.56 34.56 0 0 0-62.254545 0l-37.376 76.101818-83.618909 12.101818a34.909091 34.909091 0 0 0-19.246546 59.578182z m70.423272-64.698182a34.280727 34.280727 0 0 0 26.135273-19.083636l14.312727-29.090909 14.336 29.090909a34.257455 34.257455 0 0 0 26.135273 19.083636l32.046546 4.887273-23.272728 22.574545a35.234909 35.234909 0 0 0-10.007272 30.952727l5.46909 32.116364-28.625454-15.127273a34.490182 34.490182 0 0 0-32.302546 0l-28.695272 15.127273 5.469091-32.116364a35.141818 35.141818 0 0 0-9.984-30.952727l-23.272728-22.574545z" p-id="3855"></path></svg></button><button title="Light theme" class="__dumi-default-dark-sun "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="4026" width="22" height="22"><path d="M915.2 476.16h-43.968c-24.704 0-44.736 16-44.736 35.84s20.032 35.904 44.736 35.904H915.2c24.768 0 44.8-16.064 44.8-35.904s-20.032-35.84-44.8-35.84zM512 265.6c-136.704 0-246.464 109.824-246.464 246.4 0 136.704 109.76 246.464 246.464 246.464S758.4 648.704 758.4 512c0-136.576-109.696-246.4-246.4-246.4z m0 425.6c-99.008 0-179.2-80.128-179.2-179.2 0-98.944 80.192-179.2 179.2-179.2S691.2 413.056 691.2 512c0 99.072-80.192 179.2-179.2 179.2zM197.44 512c0-19.84-19.136-35.84-43.904-35.84H108.8c-24.768 0-44.8 16-44.8 35.84s20.032 35.904 44.8 35.904h44.736c24.768 0 43.904-16.064 43.904-35.904zM512 198.464c19.776 0 35.84-20.032 35.84-44.8v-44.8C547.84 84.032 531.84 64 512 64s-35.904 20.032-35.904 44.8v44.8c0 24.768 16.128 44.864 35.904 44.864z m0 627.136c-19.776 0-35.904 20.032-35.904 44.8v44.736C476.096 940.032 492.16 960 512 960s35.84-20.032 35.84-44.8v-44.736c0-24.768-16.064-44.864-35.84-44.864z m329.92-592.832c17.472-17.536 20.288-43.072 6.4-57.024-14.016-14.016-39.488-11.2-57.024 6.336-4.736 4.864-26.496 26.496-31.36 31.36-17.472 17.472-20.288 43.008-6.336 57.024 13.952 14.016 39.488 11.2 57.024-6.336 4.8-4.864 26.496-26.56 31.296-31.36zM213.376 759.936c-4.864 4.8-26.56 26.624-31.36 31.36-17.472 17.472-20.288 42.944-6.4 56.96 14.016 13.952 39.552 11.2 57.024-6.336 4.8-4.736 26.56-26.496 31.36-31.36 17.472-17.472 20.288-43.008 6.336-56.96-14.016-13.952-39.552-11.072-56.96 6.336z m19.328-577.92c-17.536-17.536-43.008-20.352-57.024-6.336-14.08 14.016-11.136 39.488 6.336 57.024 4.864 4.864 26.496 26.56 31.36 31.424 17.536 17.408 43.008 20.288 56.96 6.336 14.016-14.016 11.264-39.488-6.336-57.024-4.736-4.864-26.496-26.56-31.296-31.424z m527.168 628.608c4.864 4.864 26.624 26.624 31.36 31.424 17.536 17.408 43.072 20.224 57.088 6.336 13.952-14.016 11.072-39.552-6.4-57.024-4.864-4.8-26.56-26.496-31.36-31.36-17.472-17.408-43.072-20.288-57.024-6.336-13.952 14.016-11.008 39.488 6.336 56.96z" p-id="4027"></path></svg></button><button title="Default to system" class="__dumi-default-dark-auto "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="11002" width="22" height="22"><path d="M127.658667 492.885333c0-51.882667 10.24-101.717333 30.378666-149.162666s47.786667-88.064 81.92-122.538667 75.093333-61.781333 122.538667-81.92 96.938667-30.378667 149.162667-30.378667 101.717333 10.24 149.162666 30.378667 88.405333 47.786667 122.88 81.92 61.781333 75.093333 81.92 122.538667 30.378667 96.938667 30.378667 149.162666-10.24 101.717333-30.378667 149.162667-47.786667 88.405333-81.92 122.88-75.093333 61.781333-122.88 81.92-97.28 30.378667-149.162666 30.378667-101.717333-10.24-149.162667-30.378667-88.064-47.786667-122.538667-81.92-61.781333-75.093333-81.92-122.88-30.378667-96.938667-30.378666-149.162667z m329.045333 0c0 130.048 13.994667 244.394667 41.984 343.381334h12.970667c46.762667 0 91.136-9.216 133.461333-27.306667s78.848-42.666667 109.568-73.386667 54.954667-67.242667 73.386667-109.568 27.306667-86.698667 27.306666-133.461333c0-46.421333-9.216-90.794667-27.306666-133.12s-42.666667-78.848-73.386667-109.568-67.242667-54.954667-109.568-73.386667-86.698667-27.306667-133.461333-27.306666h-11.605334c-28.672 123.562667-43.349333 237.909333-43.349333 343.722666z" p-id="11003"></path></svg></button></div></div></div><ul class="__dumi-default-menu-list"><li><a href="/blog/">大师兄 - 前端架构师</a></li></ul></div></div><ul role="slug-list" class="__dumi-default-layout-toc"><li title="Web 框架" data-depth="2"><a href="/blog/手把手带你写一个web框架/04.实战第3关完善功能/13#web-框架"><span>Web 框架</span></a></li><li title="如何构建抽象" data-depth="2"><a href="/blog/手把手带你写一个web框架/04.实战第3关完善功能/13#如何构建抽象"><span>如何构建抽象</span></a></li><li title="如何识别变更点" data-depth="2"><a href="/blog/手把手带你写一个web框架/04.实战第3关完善功能/13#如何识别变更点"><span>如何识别变更点</span></a></li><li title="假设法" data-depth="3"><a href="/blog/手把手带你写一个web框架/04.实战第3关完善功能/13#假设法"><span>假设法</span></a></li><li title="替换法" data-depth="3"><a href="/blog/手把手带你写一个web框架/04.实战第3关完善功能/13#替换法"><span>替换法</span></a></li><li title="如何适应变更" data-depth="2"><a href="/blog/手把手带你写一个web框架/04.实战第3关完善功能/13#如何适应变更"><span>如何适应变更</span></a></li><li title="隔离" data-depth="3"><a href="/blog/手把手带你写一个web框架/04.实战第3关完善功能/13#隔离"><span>隔离</span></a></li><li title="超前一步设计" data-depth="3"><a href="/blog/手把手带你写一个web框架/04.实战第3关完善功能/13#超前一步设计"><span>超前一步设计</span></a></li><li title="总结" data-depth="2"><a href="/blog/手把手带你写一个web框架/04.实战第3关完善功能/13#总结"><span>总结</span></a></li></ul><div class="__dumi-default-layout-content"><div class="markdown"><h1 id="大咖助阵大明抽象抽象还是抽象"><a aria-hidden="true" tabindex="-1" href="/blog/手把手带你写一个web框架/04.实战第3关完善功能/13#大咖助阵大明抽象抽象还是抽象"><span class="icon icon-link"></span></a>大咖助阵｜大明：抽象，抽象，还是抽象</h1><p>你好，我是大明。</p><p>之前我在极客时间的毛剑老师的Go进阶训练营里，为基础不太好的同学开了一个小课，主要是通过讲如何设计一个 Web 框架来带领学员一起巩固 Go 基础，侧重点在 Go 语法上，没有深入讨论设计本身以及设计理念。</p><p>但是，教会如何用一个框架是个很简单的问题，教会如何做抽象才是一个很难、但很有价值的问题。所以今天我想借这篇加餐的机会，围绕 Web 框架的设计，来分享一下我平时在做设计和落地时对抽象的一些体会。</p><p>在开始讨论之前，我们要先搞清楚一个问题：为什么抽象那么重要？</p><p>因为我认为，<strong>程序是人对现实世界的抽象的形式化描述</strong>。它包含两层含义：第一个含义是要先建立对现实世界抽象；第二个是能够将这个抽象落地为代码，也就是设计。因此，抽象是设计的前提。</p><p>通俗点就是，如果你不能正确认识问题，怎么奢求自己能够正确解决问题呢？所以，我们先稍微讨论一下 Web 框架，看看它背后对应的问题。</p><h2 id="web-框架"><a aria-hidden="true" tabindex="-1" href="/blog/手把手带你写一个web框架/04.实战第3关完善功能/13#web-框架"><span class="icon icon-link"></span></a>Web 框架</h2><p>Web 框架要解决的问题是什么？处理 HTTP 请求。进一步细想，我们会想到具体如何处理请求，但这不是 Web 框架的事情，而是用户的事情。比如说用户登录的请求，Web 框架肯定是不知道如何处理的。</p><p>所以我们能够认识到，<strong>Web 框架主要负责：接收请求、找到用户处理逻辑调用一下、再把响应写回去。也就是三件事：接受请求、分发请求、写回响应</strong>。如果用伪代码来描述就是：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">while:</span></div><div class="token-line"><span class="token plain">      req = next()</span></div><div class="token-line"><span class="token plain">      handler = findHandler(req)</span></div><div class="token-line"><span class="token plain">      response = handler.Handle(req)</span></div><div class="token-line"><span class="token plain">      write(respons)</span></div></pre></div><p>其中 Go 的 http/net 包帮我们解决了读取请求和写回输出的大部分工作，只剩下路由部分，即根据请求找到用户注册的处理方法，需要我们支持一下。这就是 Web 框架的核心，同时也是最难的地方。</p><p>但是你去看市面上大多数 Web 框架不仅仅只有这个基础功能，还有很多花里胡哨的东西。大致列举一下：</p><ul><li>参数解析校验功能</li><li>文件操作类，比如说上传、下载，或者作为静态资源服务器</li><li>特定格式支持，比如说 JSON、XML 格式支持</li><li>模板支持，主要是用于渲染页面</li><li>AOP 解决方案</li><li>…</li></ul><p>一个框架一般不会在初期把所有都支持好，而是在逐步迭代的过程中，将功能补充上去。所以要求我们在设计框架之初，就要考虑到这一类的功能。但是并不需要提供实现，甚至连接口都不必设计得一步到位，只要藏好细节不暴露出去，后面可以轻易修改而不影响已有的用户。</p><p>所以简单总结下，一个Web框架要解决两大类的问题：</p><ul><li>必须要解决的核心问题，在Web 框架里就是路由问题</li><li>可解决可不解决的次级问题，也就是这里罗列的一大堆</li></ul><p>问题搞清楚，我们再看怎么解决。其实，构建抽象就是解决问题的过程。</p><h2 id="如何构建抽象"><a aria-hidden="true" tabindex="-1" href="/blog/手把手带你写一个web框架/04.实战第3关完善功能/13#如何构建抽象"><span class="icon icon-link"></span></a>如何构建抽象</h2><p>我们从前面的伪代码里面，基本上就可以抽取出来第一个也是最重要的抽象：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">type Handler interface {</span></div><div class="token-line"><span class="token plain">       ServeHTTP(c *Context)</span></div><div class="token-line"><span class="token plain">       Routable</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>需要注意的是，这是我设计的接口。不同的人来设计，是可以不同的，只要都能表达这么一种抽象就可以。也就是，重要的是抽象，而抽象的表达形式是多样的。<br/><code>ServeHTTP</code> 精准描述了这个Web框架的主要责任，也准确界定了 Web 框架的边界，我称为核心抽象。</p><p>而组合进来的 Routable 接口实际上只是支撑接口，也就是去掉它并不妨碍我们用 <code>Handler</code> 来表达整个 Web 框架的主要责任。所以我把类似的东西称为次级抽象。</p><p><strong>次级抽象并不是描述了整个框架，而是描述了框架的一个方面。次级抽象一般用于支撑核心抽象的实现</strong>。显然，如果我们实现次级接口，自然可能会有支撑该实现的次次级接口。</p><p>因此整个框架的实现过程可以简化为：</p><ol><li>构建抽象，提供实现</li><li>为了特定实现，引入新的抽象</li><li>为新的抽象提供实现</li></ol><p>如此不断迭代，这种设计方式，我一般称为自顶向下的设计，从核心接口的抽象向外延伸。例如在这个 Web 框架里，为了实现 Handler 而引入 Routable，而在实现 Routable 的时候引入 node，它们之间的关系，大体上可以看作是一个同心圆。<br/><img src="https://static001.geekbang.org/resource/image/ea/26/eacyy0711c125e86b579c4a2de0a8e26.jpg?wh=1920x1080" alt=""/></p><p>一般来说，越是接近核心的接口，越是稳定，缺点则是过于抽象以至于对普通用户来说毫无价值。甚至实现一个核心接口，难度差不多相当于重写整个框架了。</p><p>对应地，远离核心的接口，其抽象程度低，因此也就更加具体化。更加具体化，意味着好扩展，缺点则是表达性弱，只能表达很小的一个点。注重使用感的最外围的接口，大多数时候是框架设计者有意留出来给用户使用的，实现非常简单。</p><p>例如说，为了解决优雅退出，允许用户注册自己的清理动作，我引入了一个新的抽象：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">type Hook func(ctx context.Context) error</span></div></pre></div><p>显而易见地，写一个 Hook 和写一个 Handler 的难度自然是差了好几个数量级。</p><p>到这里我们讨论了如何构建抽象，然而不管我们再怎么自信，都还有一个问题要解决，就是抽象不是一成不变的，随着业务发展，之前的抽象就可能不适用了，或者说至少某个部分不再适用了。因此我们总是要在设计的时候考虑变更的问题。</p><p>想写出能变更的代码，首先要考虑的就是，到底哪些地方要考虑变更？</p><h2 id="如何识别变更点"><a aria-hidden="true" tabindex="-1" href="/blog/手把手带你写一个web框架/04.实战第3关完善功能/13#如何识别变更点"><span class="icon icon-link"></span></a>如何识别变更点</h2><p>识别变更，基本上，要么依赖于个人的经验，要么依赖于借鉴类似的框架。</p><p>借鉴这个办法很简单，所谓的太阳底下无新鲜事，在我们这一行尤其如此。大多数时候你都可以找到类似的产品，看看它们是如何设计的。这里就要强调一点，解决同一个问题的框架，它们落地为代码之后，都是千差万别的，<strong>所以借鉴，是要借鉴它们的抽象，而不是它们的代码</strong>。</p><p>此外就是要借鉴缺点，所谓的每与操反，事乃可成。</p><p>例如有的框架内置了处理静态资源的功能，但是该功能和框架的核心路由功能耦合在一起了，缺乏扩展性和可读性，还对用户重构核心功能造成了阻碍。这个设计就不是很好，我们自己设计Web框架功能的时候就可以借鉴这一点。我们可以写一个方法，就像用户写的普通业务方法，这样用户可以按类似用法注册一个路由启用这个功能，更方便。</p><p>我就重点说通过我多年个人经验总结的两个小技巧：假设法和替换法。</p><h3 id="假设法"><a aria-hidden="true" tabindex="-1" href="/blog/手把手带你写一个web框架/04.实战第3关完善功能/13#假设法"><span class="icon icon-link"></span></a>假设法</h3><p>所谓假设法，就是找到自己实现过程中做的假设。最常见的假设就是，“产品说这个场景不需要考虑，所以我只需要这么做就可以了”，又或者“我觉得这么做就可以了，因为用户不可能需要xxx”……每当在脑海里面出现这一类的语句，就代表了我们做了一些假设。</p><p>但凡假设不成立，就意味着实现要变更。而不管是在中间件设计，还是在业务设计上，我们总是会自觉或者不自觉地引入很多假设。</p><p>比如说，在我学习 Web 框架时写代码，做了一个很重要的假设，朝前匹配，这个假设极大简化了实现的代码。例如两个路由：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">/api/user/*/profile</span></div><div class="token-line"><span class="token plain">    /api/user/xiaoming/home</span></div></pre></div><p>如果我们的请求是 <code>/api/user/xiaoming/profile</code> ，在匹配到 <code>xiaoming</code> 的时候，应该走去第二个路由，但是后面的 <code>profile</code> 和 <code>home</code> 匹配不上。在工业级的 Web 框架里面，显然它们会回溯，找到第一个路由继续匹配。但是这会导致代码非常复杂。</p><p>我并不希望在这个以学习为目标的 Web 框架里面引入这种回溯的机制，所以引入了一个假设——路由匹配总是朝前的。显然，这个假设非常脆弱，但凡我想要把这个 Web 框架支持到工业级，首先就要重写这部分代码以正确匹配上第一个路由。</p><p>这个方法，<strong>难就难在识别不自觉的假设，特别是一些业务规则的假设</strong>。因为我们太熟悉这些业务规则，以至于默认它就是这样的，都不觉得自己做了假设。</p><p>典型的例子是金额，大部分国内开发者在处理金额的时候几乎不会考虑货币的问题，因为我们默认就是人民币，因而接口、数据库都只需要一个数字来表达金额。而一旦业务扩张到外币，就会发现几乎全部接口都缺乏货币的支持，整个改造起来就耗时长范围广了。</p><h3 id="替换法"><a aria-hidden="true" tabindex="-1" href="/blog/手把手带你写一个web框架/04.实战第3关完善功能/13#替换法"><span class="icon icon-link"></span></a>替换法</h3><p>在讲框架设计的时候，我经常被问到一类问题：这个东西是做成这样还是做成那样？这个时候我都会建议他抽取出来一个接口，先写自己更加偏好的做法。将来在需要的时候，再替换为另外一个实现。这就是典型的替换场景。</p><p>这一类的场景识别起来也很容易，就是解决方案不唯一。不唯一就代表，今天可能用这个，明天可能用那个。<strong>如果你陷入一种进退两难的境地，又或者识别出这一块业界有多种做法，就可以用这个方法</strong>。</p><p>这里依旧用 Web 框架的例子。我在写路由树的时候发现，“某个节点是否匹配某段路径”是一个显而易见的扩展点，也就是方法：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">func (h *HandlerBasedOnTree) findMatchChild(root *node, path string) (*node, bool) {</span></div><div class="token-line"><span class="token plain">       for _, child := range root.children {</span></div><div class="token-line"><span class="token plain">          if child.path == path {</span></div><div class="token-line"><span class="token plain">             return child, true</span></div><div class="token-line"><span class="token plain">          }</span></div><div class="token-line"><span class="token plain">       }</span></div><div class="token-line"><span class="token plain">       return nil, false</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>这是第一版代码，里面是严格匹配路径的，也就是条件 <code>child.path==path</code> 是变更点。为什么这么说呢？因为我使用过别的 Web 框架，知道还可以忽略大小写匹配、通配符匹配、参数路径以及正则匹配之类的匹配方式。</p><p>因此，“如何匹配”就是一个变更点。也可以说，“如何匹配”是一个选择匹配策略的问题。</p><h2 id="如何适应变更"><a aria-hidden="true" tabindex="-1" href="/blog/手把手带你写一个web框架/04.实战第3关完善功能/13#如何适应变更"><span class="icon icon-link"></span></a>如何适应变更</h2><p>变更的位置我们找出来了，但是问题来了，我们需要为每一个变更点都设计一套接口吗？或者说，需要立刻解决它吗？</p><p>前面金额的例子说到大多数国内开发者并不会有意设计货币。但是在这里即便我识别出来了，如果公司现在没有这一类的业务，我也不会设计货币。因为过早引入货币，会导致前期开发不得不处理这些问题，拖累开发进度。</p><p>但是大多数时候，我们识别出来的变更点都是需要立刻处理的，一般来说我采用“隔离”和“超前一步设计”两个技巧。</p><h3 id="隔离"><a aria-hidden="true" tabindex="-1" href="/blog/手把手带你写一个web框架/04.实战第3关完善功能/13#隔离"><span class="icon icon-link"></span></a>隔离</h3><p>隔离是最简单的处理方式，一般是抽取出来作为一个方法，或者一个结构体。</p><p>比如说前面的 findMatchChild 方法，就是我隔离出来的方法。因为在最开始的版本里，我知道这个地方会变，也就是说匹配规则是多样的，但是那个时候我还不想理它，又害怕完全不理吧，后面变了会波及其它代码，就抽取出来作为一个单独的方法。</p><p>那么后续不管怎么变，比如说支持路径参数、正则匹配，它都局限在了这个方法内，至多就是修改一下方法签名，传入更多参数。而对于调用方来说，传入更多参数会有点影响，但是影响已经是非常可控的。</p><p>如果抽取得好，遇到变更的时候，完全可以把这个方法升级成为一个接口。实际上，这也是从隔离走向超前一步设计的典型场景。</p><p>抽取结构体这种做法，一般是用于非常复杂的变更点。即这个变更点现有的逻辑就足够复杂，将来也很复杂，所以用一个结构体来封装一系列的方法。</p><p>但是不管是抽成方法还是结构体，就我个人经验而言，隔离的核心是要做到，<strong>隔离出来的是一个可测试的单元</strong>。什么意思呢？就是这个隔离出来的产物，一定要是单独可测试的。</p><p>因为将来变更之后，你可以完全复用当下的测试代码，来测试它变更前后的对外表现出来的行为是否一致。如果不一致，要么是我们的变更有问题，要么就是之前的隔离其实并不充分，这种情况下往往意味着使用方也要大动干戈。</p><h3 id="超前一步设计"><a aria-hidden="true" tabindex="-1" href="/blog/手把手带你写一个web框架/04.实战第3关完善功能/13#超前一步设计"><span class="icon icon-link"></span></a>超前一步设计</h3><p>在前面我就已经暗示了如何做到超前一步设计。</p><p>超前一步的精髓在于：<strong>设计接口和接入实现的方式，但是不提供多样化的接口实现</strong>。这句话的意思是说，识别出变更点的时候，我们要设计一个接口出来，但是并不需要为所有可能的变更提供实现，只提供当下需要的实现即可。</p><p>设计接口这一步，说简单也简单，只需要参考隔离，把可能变化的逻辑抽取出来作为一个方法，然后这个方法的定义，就是接口内部方法的定义。如果是隔离出来结构体，那这个结构体就可以看作是接口的一个实现了。</p><p>如果说难，那么就难在做到这个接口将来肯定不会发生任何变更，也就是方法的输入、输出一点不变，这近乎不可能了。但是可以尝试减轻这种变更的影响，例如说输入和输出都定义为一个结构体，后续的变更无非就是增加字段而已。</p><p>举个例子，在意识到“如何匹配”是一个变更点之后，我们就可以在 node 中引入另外一个抽象 matchFunc：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">type node struct {</span></div><div class="token-line"><span class="token plain">       children []*node</span></div><div class="token-line"><span class="token plain">       // 如果这是叶子节点，</span></div><div class="token-line"><span class="token plain">       // 那么匹配上之后就可以调用该方法</span></div><div class="token-line"><span class="token plain">       handler   handlerFunc</span></div><div class="token-line"><span class="token plain">       matchFunc matchFunc</span></div><div class="token-line"><span class="token plain">       // 原始的 pattern。注意，它不是完整的pattern，</span></div><div class="token-line"><span class="token plain">       // 而是匹配到这个节点的pattern</span></div><div class="token-line"><span class="token plain">       pattern string</span></div><div class="token-line"><span class="token plain">       nodeType int</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>但是，这个时候需要提供所有可能的实现吗？并不需要，我们只需要提供满足当前需求的实现就可以了。例如说，只支持简单的通配符匹配和路径参数匹配，但是不需要支持正则匹配。毕竟正则匹配比较少用，可以推迟到有用户反馈需要的时候再提供。</p><p>另外一个难点是，如何设计一个优秀的接入方式。因为这个机制要解答两个问题：知道用哪个实现并且得到对应的实例。如果说，<strong>接口的质量决定了你的设计能不能适应变更，那么接入机制就是决定了你能多快适应变更</strong>。</p><p>Go 不同于 Java，没有 SPI，也没有 Spring 这种提供容器的框架，连动态加载包的功能也没有。所以 Go 设计一个好用的接入机制，比较难，手段也比较单一。典型的做法就是 Register + init。</p><p>Register 是指设计一个注册实现的方法。例如在 Web 框架里面注册 Filter 的实现：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">var builderMap = make(map[string]FilterBuilder, 4)</span></div><div class="token-line"><span class="token plain">    func RegisterFilter(name string, builder FilterBuilder)  {</span></div><div class="token-line"><span class="token plain">       builderMap[name] = builder</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    func GetFilterBuilder(name string) FilterBuilder {</span></div><div class="token-line"><span class="token plain">       return builderMap[name]</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>这种是比较复杂的，框架内部通过按名索引来获得实例。如果只需要单一实现，那么可以将 map 去掉，直接存储实例。</p><p>Register 要结合 init 方法来注入实现：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// 匿名引入 _ &quot;package/to/this/filters&quot;</span></div><div class="token-line"><span class="token plain">    func init() {</span></div><div class="token-line"><span class="token plain">       web.RegisterFilter(&quot;my-custom&quot;, myFilterBuilder)</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>用户需要在启动的地方，使用匿名引入来注入这个实现。<br/>在理想情况下，接入机制应该被设计为无侵入式的。也就是替换一个新的实现，不需要修改代码。只不过这很难，在 Go 里面尤其难。前面 Filter 的接入方式就是无侵入式的，框架不需要有任何的修改。</p><p>而 matchFunc 就没有提供任何无侵入式的扩展手段，也就是说用户无法自定义自己的匹配规则，至多是我们在得到用户反馈之后，依据用户的需要，设计一种新的节点。即便如此，也需要稍微修改接入代码，这是因为我们创建 node 的方式是不一样的：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// 静态节点</span></div><div class="token-line"><span class="token plain">    func newStaticNode(path string) *node {}</span></div><div class="token-line"><span class="token plain">    // 通配符 * 节点</span></div><div class="token-line"><span class="token plain">    func newAnyNode() *node {}</span></div></pre></div><p>所以 node 的设计在质量上要比 Filter 更差。</p><p>Filter 的抽象和接入机制还体现了另外一个原则：<strong>实现平等原则，接口的所有实现，在地位上是平等的，我怎么接入实现，用户就是怎么接入自己的实现</strong>。有些框架在这方面就做得很差，这些框架无一不是给自己的实现提供了特殊的地位，比如说典型的针对自身提供的实现，做了特殊的处理。</p><h2 id="总结"><a aria-hidden="true" tabindex="-1" href="/blog/手把手带你写一个web框架/04.实战第3关完善功能/13#总结"><span class="icon icon-link"></span></a>总结</h2><p>我们基本上没有讨论 Web 框架的实现细节，只是借助 Web 框架讨论了一些我遵循的基本设计原则。而这一切的前提，就是抽象。</p><p>但你可能有个疑问，很多时候，我们很少设计这样一个完整的框架，那这些知识还有用吗？</p><p>答案是有用的，我们可以用这种思路去分析别的框架的源码。</p><p>我的分析思路供你参考。<strong>我会假设自己是这个框架设计者，分析框架要解决什么、核心的抽象会是什么</strong>。在看到核心抽象后，想象自己会如何实现，然后再去看实现，看实现引入了什么接口、揣度这个接口是表达了什么抽象、为什么要引入这个接口——本质上也是分析这个接口要解决什么问题。不断递归，直到搞明白框架的基本设计方式。</p><p>这里讨论的这种设计方式，我称之为自顶向下的设计方式，也就是从核心抽象出发。它自然也有很强的局限性，最大的局限性就是，如果你不熟悉问题领域，你是连核心抽象都难构建出来的。</p><p>所以这一切，我想用毛主席的一句话来总结：谁是我们的朋友，谁是我们的敌人，是革命的首要问题。</p><p>欢迎在留言区分享你的思考。如果你觉得有收获，也欢迎把今天的内容分享给你身边的朋友。我们下节课见。</p></div><div class="__dumi-default-layout-footer-meta"><a target="_blank" rel="noopener noreferrer" href="https://github.com/GGwujun/blog/edit/master/docs/手把手带你写一个Web框架/04.实战第3关完善功能/13.md">在 GitHub 上编辑此页<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a><span data-updated-text="最后更新时间：">5/2/2022 10:56:58</span></div></div></div></div>
	<script>
  window.g_useSSR = true;
  window.g_initialProps = {};
	</script>

    <script>
      (function () {
        if (!location.port) {
          (function (i, s, o, g, r, a, m) {
            i["GoogleAnalyticsObject"] = r;
            (i[r] =
              i[r] ||
              function () {
                (i[r].q = i[r].q || []).push(arguments);
              }),
              (i[r].l = 1 * new Date());
            (a = s.createElement(o)), (m = s.getElementsByTagName(o)[0]);
            a.async = 1;
            a.src = g;
            m.parentNode.insertBefore(a, m);
          })(
            window,
            document,
            "script",
            "//www.google-analytics.com/analytics.js",
            "ga"
          );
          ga("create", "UA-149864185-1", "auto");
          ga("send", "pageview");
        }
      })();
    </script>
    <script src="/blog/umi.js"></script>
  </body>
</html>
