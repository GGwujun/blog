<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no"
    />
    <link rel="shortcut icon" type="image/x-icon" href="/logo.png" />
    <link rel="stylesheet" href="/blog/umi.css" />
    <script>
      window.routerBase = "/blog";
    </script>
    <script>
      //! umi version: 3.5.17
    </script>
    <script>
      !(function () {
        var e = localStorage.getItem("dumi:prefers-color"),
          t = window.matchMedia("(prefers-color-scheme: dark)").matches,
          r = ["light", "dark", "auto"];
        document.documentElement.setAttribute(
          "data-prefers-color",
          e === r[2] ? (t ? r[1] : r[0]) : r.indexOf(e) > -1 ? e : r[0]
        );
      })();
    </script>
    <title>27｜缓存服务：如何基于Redis实现封装？</title>
  </head>
  <body>
    <div id="root"><div class="__dumi-default-layout" data-route="/手把手带你写一个web框架/04.实战第3关完善功能/10" data-show-sidemenu="true" data-show-slugs="true" data-site-mode="true" data-gapless="false"><div class="__dumi-default-navbar" data-mode="site"><button class="__dumi-default-navbar-toggle"></button><a class="__dumi-default-navbar-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog/">大师兄</a><nav><div class="__dumi-default-search"><input type="search" class="__dumi-default-search-input" value=""/><ul></ul></div><span>计算机基础<ul><li><a href="/blog/编译原理之美">编译原理之美</a></li><li><a href="/blog/编译原理实战">编译原理实战</a></li><li><a href="/blog/深入浅出计算机组成原理">深入浅出计算机组成原理</a></li><li><a href="/blog/详解http">详解http</a></li><li><a href="/blog/计算机网络通关29讲">计算机网络通关29讲</a></li><li><a href="/blog/网络排查案例课">网络排查案例课</a></li><li><a href="/blog/linux操作系统">linux操作系统</a></li><li><a href="/blog/linux性能优化实战">linux性能优化实战</a></li><li><a href="/blog/程序员数学基础">程序员数学基础</a></li><li><a href="/blog/趣谈网络协议">趣谈网络协议</a></li><li><a href="/blog/操作系统实战">操作系统实战</a></li><li><a href="/blog/软件工程之美">软件工程之美</a></li><li><a href="/blog/sql必知必会">sql必知必会</a></li><li><a href="/blog/操作系统实战45讲">操作系统实战45讲</a></li><li><a href="/blog/网络编程实战">网络编程实战</a></li></ul></span><span>算法<ul><li><a href="/blog/常用算法25讲">常用算法25讲</a></li><li><a href="/blog/数据结构与算法之美">数据结构与算法之美</a></li><li><a href="/blog/业务开发算法50讲">业务开发算法50讲</a></li><li><a href="/blog/动态规划面试宝典">动态规划面试宝典</a></li></ul></span><span>前端开发<ul><li><a href="/blog/浏览器工作原理与实践">浏览器工作原理与实践</a></li><li><a href="/blog/新时代产品经理进阶之路">新时代产品经理进阶之路</a></li><li><a href="/blog/全栈工程师修炼指南">全栈工程师修炼指南</a></li><li><a href="/blog/flutter核心技术与实战">flutter核心技术与实战</a></li><li><a href="/blog/java-script核心原理解析">java-script核心原理解析</a></li><li><a href="/blog/说透低代码">说透低代码</a></li><li><a href="/blog/nodejs应用开发实战">nodejs应用开发实战</a></li><li><a href="/blog/反爬虫兵法演绎20讲">反爬虫兵法演绎20讲</a></li><li><a href="/blog/reactnative新架构实战课">reactnative新架构实战课</a></li><li><a href="/blog/正则表达式入门">正则表达式入门</a></li><li><a href="/blog/重学前端">重学前端</a></li><li><a href="/blog/serverless入门课">serverless入门课</a></li><li><a href="/blog/type-script入门实战笔记">type-script入门实战笔记</a></li><li><a href="/blog/图解googlev8">图解googlev8</a></li><li><a href="/blog/vue3源码分析">vue3源码分析</a></li><li><a href="/blog/玩转Vue3全家桶">玩转Vue3全家桶</a></li><li><a href="/blog/webassembly入门">webassembly入门</a></li><li><a aria-current="page" class="active" href="/blog/手把手带你写一个Web框架">手把手带你写一个Web框架</a></li><li><a href="/blog/web漏洞挖掘实战">web漏洞挖掘实战</a></li><li><a href="/blog/跟月影学可视化">跟月影学可视化</a></li><li><a href="/blog/搞定音频技术">搞定音频技术</a></li><li><a href="/blog/攻克视频技术">攻克视频技术</a></li></ul></span><span>前端工程化<ul><li><a href="/blog/logger">logger</a></li><li><a href="/blog/webpack">webpack</a></li><li><a href="/blog/webpackChain">webpackChain</a></li></ul></span><span>前端性能优化<ul><li><a href="/blog/react性能调优">react性能调优</a></li></ul></span><span>软件测试<ul><li><a href="/blog/全链路压测实战30讲">全链路压测实战30讲</a></li><li><a href="/blog/性能测试实战30讲">性能测试实战30讲</a></li><li><a href="/blog/自动化测试高手课">自动化测试高手课</a></li><li><a href="/blog/软件测试52讲">软件测试52讲</a></li></ul></span><span>面试<ul><li><a href="/blog/面试现场">面试现场</a></li></ul></span><span>杂谈<ul><li><a href="/blog/超级访谈对话张雪峰">超级访谈对话张雪峰</a></li><li><a href="/blog/Git实战手册">Git实战手册</a></li><li><a href="/blog/NodeJS">NodeJS</a></li><li><a href="/blog/ReactJS">ReactJS</a></li><li><a href="/blog/UI设计">UI设计</a></li><li><a href="/blog/webpack4系列教程">webpack4系列教程</a></li><li><a href="/blog/前端知识体系">前端知识体系</a></li><li><a href="/blog/剑指offer刷题笔记">剑指offer刷题笔记</a></li><li><a href="/blog/思考与成长">思考与成长</a></li><li><a href="/blog/设计模式手册">设计模式手册</a></li></ul></span><div class="__dumi-default-navbar-tool"><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "></div></div></div></nav></div><div class="__dumi-default-menu" data-mode="site"><div class="__dumi-default-menu-inner"><div class="__dumi-default-menu-header"><a class="__dumi-default-menu-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog/"></a><h1>大师兄</h1><p></p></div><div class="__dumi-default-menu-mobile-area"><ul class="__dumi-default-menu-nav-list"><li>计算机基础<ul><li><a href="/blog/编译原理之美">编译原理之美</a></li><li><a href="/blog/编译原理实战">编译原理实战</a></li><li><a href="/blog/深入浅出计算机组成原理">深入浅出计算机组成原理</a></li><li><a href="/blog/详解http">详解http</a></li><li><a href="/blog/计算机网络通关29讲">计算机网络通关29讲</a></li><li><a href="/blog/网络排查案例课">网络排查案例课</a></li><li><a href="/blog/linux操作系统">linux操作系统</a></li><li><a href="/blog/linux性能优化实战">linux性能优化实战</a></li><li><a href="/blog/程序员数学基础">程序员数学基础</a></li><li><a href="/blog/趣谈网络协议">趣谈网络协议</a></li><li><a href="/blog/操作系统实战">操作系统实战</a></li><li><a href="/blog/软件工程之美">软件工程之美</a></li><li><a href="/blog/sql必知必会">sql必知必会</a></li><li><a href="/blog/操作系统实战45讲">操作系统实战45讲</a></li><li><a href="/blog/网络编程实战">网络编程实战</a></li></ul></li><li>算法<ul><li><a href="/blog/常用算法25讲">常用算法25讲</a></li><li><a href="/blog/数据结构与算法之美">数据结构与算法之美</a></li><li><a href="/blog/业务开发算法50讲">业务开发算法50讲</a></li><li><a href="/blog/动态规划面试宝典">动态规划面试宝典</a></li></ul></li><li>前端开发<ul><li><a href="/blog/浏览器工作原理与实践">浏览器工作原理与实践</a></li><li><a href="/blog/新时代产品经理进阶之路">新时代产品经理进阶之路</a></li><li><a href="/blog/全栈工程师修炼指南">全栈工程师修炼指南</a></li><li><a href="/blog/flutter核心技术与实战">flutter核心技术与实战</a></li><li><a href="/blog/java-script核心原理解析">java-script核心原理解析</a></li><li><a href="/blog/说透低代码">说透低代码</a></li><li><a href="/blog/nodejs应用开发实战">nodejs应用开发实战</a></li><li><a href="/blog/反爬虫兵法演绎20讲">反爬虫兵法演绎20讲</a></li><li><a href="/blog/reactnative新架构实战课">reactnative新架构实战课</a></li><li><a href="/blog/正则表达式入门">正则表达式入门</a></li><li><a href="/blog/重学前端">重学前端</a></li><li><a href="/blog/serverless入门课">serverless入门课</a></li><li><a href="/blog/type-script入门实战笔记">type-script入门实战笔记</a></li><li><a href="/blog/图解googlev8">图解googlev8</a></li><li><a href="/blog/vue3源码分析">vue3源码分析</a></li><li><a href="/blog/玩转Vue3全家桶">玩转Vue3全家桶</a></li><li><a href="/blog/webassembly入门">webassembly入门</a></li><li><a aria-current="page" class="active" href="/blog/手把手带你写一个Web框架">手把手带你写一个Web框架</a></li><li><a href="/blog/web漏洞挖掘实战">web漏洞挖掘实战</a></li><li><a href="/blog/跟月影学可视化">跟月影学可视化</a></li><li><a href="/blog/搞定音频技术">搞定音频技术</a></li><li><a href="/blog/攻克视频技术">攻克视频技术</a></li></ul></li><li>前端工程化<ul><li><a href="/blog/logger">logger</a></li><li><a href="/blog/webpack">webpack</a></li><li><a href="/blog/webpackChain">webpackChain</a></li></ul></li><li>前端性能优化<ul><li><a href="/blog/react性能调优">react性能调优</a></li></ul></li><li>软件测试<ul><li><a href="/blog/全链路压测实战30讲">全链路压测实战30讲</a></li><li><a href="/blog/性能测试实战30讲">性能测试实战30讲</a></li><li><a href="/blog/自动化测试高手课">自动化测试高手课</a></li><li><a href="/blog/软件测试52讲">软件测试52讲</a></li></ul></li><li>面试<ul><li><a href="/blog/面试现场">面试现场</a></li></ul></li><li>杂谈<ul><li><a href="/blog/超级访谈对话张雪峰">超级访谈对话张雪峰</a></li><li><a href="/blog/Git实战手册">Git实战手册</a></li><li><a href="/blog/NodeJS">NodeJS</a></li><li><a href="/blog/ReactJS">ReactJS</a></li><li><a href="/blog/UI设计">UI设计</a></li><li><a href="/blog/webpack4系列教程">webpack4系列教程</a></li><li><a href="/blog/前端知识体系">前端知识体系</a></li><li><a href="/blog/剑指offer刷题笔记">剑指offer刷题笔记</a></li><li><a href="/blog/思考与成长">思考与成长</a></li><li><a href="/blog/设计模式手册">设计模式手册</a></li></ul></li></ul><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "><button title="Dark theme" class="__dumi-default-dark-moon "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="3854" width="22" height="22"><path d="M991.816611 674.909091a69.166545 69.166545 0 0 0-51.665455-23.272727 70.795636 70.795636 0 0 0-27.438545 5.585454A415.674182 415.674182 0 0 1 754.993338 698.181818c-209.594182 0-393.472-184.785455-393.472-395.636363 0-52.363636 38.539636-119.621818 69.515637-173.614546 4.887273-8.610909 9.634909-16.756364 14.103272-24.901818A69.818182 69.818182 0 0 0 384.631156 0a70.842182 70.842182 0 0 0-27.438545 5.585455C161.678429 90.298182 14.362065 307.898182 14.362065 512c0 282.298182 238.824727 512 532.38691 512a522.286545 522.286545 0 0 0 453.957818-268.334545A69.818182 69.818182 0 0 0 991.816611 674.909091zM546.679156 954.181818c-248.785455 0-462.941091-192-462.941091-442.181818 0-186.647273 140.637091-372.829091 300.939637-442.181818-36.817455 65.629091-92.578909 151.970909-92.578909 232.727273 0 250.181818 214.109091 465.454545 462.917818 465.454545a488.331636 488.331636 0 0 0 185.181091-46.545455 453.003636 453.003636 0 0 1-393.565091 232.727273z m103.656728-669.323636l-14.266182 83.781818a34.909091 34.909091 0 0 0 50.362182 36.770909l74.775272-39.563636 74.752 39.563636a36.142545 36.142545 0 0 0 16.174546 3.956364 34.909091 34.909091 0 0 0 34.210909-40.727273l-14.289455-83.781818 60.509091-59.345455a35.025455 35.025455 0 0 0-19.223272-59.578182l-83.61891-12.101818-37.376-76.101818a34.56 34.56 0 0 0-62.254545 0l-37.376 76.101818-83.618909 12.101818a34.909091 34.909091 0 0 0-19.246546 59.578182z m70.423272-64.698182a34.280727 34.280727 0 0 0 26.135273-19.083636l14.312727-29.090909 14.336 29.090909a34.257455 34.257455 0 0 0 26.135273 19.083636l32.046546 4.887273-23.272728 22.574545a35.234909 35.234909 0 0 0-10.007272 30.952727l5.46909 32.116364-28.625454-15.127273a34.490182 34.490182 0 0 0-32.302546 0l-28.695272 15.127273 5.469091-32.116364a35.141818 35.141818 0 0 0-9.984-30.952727l-23.272728-22.574545z" p-id="3855"></path></svg></button><button title="Light theme" class="__dumi-default-dark-sun "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="4026" width="22" height="22"><path d="M915.2 476.16h-43.968c-24.704 0-44.736 16-44.736 35.84s20.032 35.904 44.736 35.904H915.2c24.768 0 44.8-16.064 44.8-35.904s-20.032-35.84-44.8-35.84zM512 265.6c-136.704 0-246.464 109.824-246.464 246.4 0 136.704 109.76 246.464 246.464 246.464S758.4 648.704 758.4 512c0-136.576-109.696-246.4-246.4-246.4z m0 425.6c-99.008 0-179.2-80.128-179.2-179.2 0-98.944 80.192-179.2 179.2-179.2S691.2 413.056 691.2 512c0 99.072-80.192 179.2-179.2 179.2zM197.44 512c0-19.84-19.136-35.84-43.904-35.84H108.8c-24.768 0-44.8 16-44.8 35.84s20.032 35.904 44.8 35.904h44.736c24.768 0 43.904-16.064 43.904-35.904zM512 198.464c19.776 0 35.84-20.032 35.84-44.8v-44.8C547.84 84.032 531.84 64 512 64s-35.904 20.032-35.904 44.8v44.8c0 24.768 16.128 44.864 35.904 44.864z m0 627.136c-19.776 0-35.904 20.032-35.904 44.8v44.736C476.096 940.032 492.16 960 512 960s35.84-20.032 35.84-44.8v-44.736c0-24.768-16.064-44.864-35.84-44.864z m329.92-592.832c17.472-17.536 20.288-43.072 6.4-57.024-14.016-14.016-39.488-11.2-57.024 6.336-4.736 4.864-26.496 26.496-31.36 31.36-17.472 17.472-20.288 43.008-6.336 57.024 13.952 14.016 39.488 11.2 57.024-6.336 4.8-4.864 26.496-26.56 31.296-31.36zM213.376 759.936c-4.864 4.8-26.56 26.624-31.36 31.36-17.472 17.472-20.288 42.944-6.4 56.96 14.016 13.952 39.552 11.2 57.024-6.336 4.8-4.736 26.56-26.496 31.36-31.36 17.472-17.472 20.288-43.008 6.336-56.96-14.016-13.952-39.552-11.072-56.96 6.336z m19.328-577.92c-17.536-17.536-43.008-20.352-57.024-6.336-14.08 14.016-11.136 39.488 6.336 57.024 4.864 4.864 26.496 26.56 31.36 31.424 17.536 17.408 43.008 20.288 56.96 6.336 14.016-14.016 11.264-39.488-6.336-57.024-4.736-4.864-26.496-26.56-31.296-31.424z m527.168 628.608c4.864 4.864 26.624 26.624 31.36 31.424 17.536 17.408 43.072 20.224 57.088 6.336 13.952-14.016 11.072-39.552-6.4-57.024-4.864-4.8-26.56-26.496-31.36-31.36-17.472-17.408-43.072-20.288-57.024-6.336-13.952 14.016-11.008 39.488 6.336 56.96z" p-id="4027"></path></svg></button><button title="Default to system" class="__dumi-default-dark-auto "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="11002" width="22" height="22"><path d="M127.658667 492.885333c0-51.882667 10.24-101.717333 30.378666-149.162666s47.786667-88.064 81.92-122.538667 75.093333-61.781333 122.538667-81.92 96.938667-30.378667 149.162667-30.378667 101.717333 10.24 149.162666 30.378667 88.405333 47.786667 122.88 81.92 61.781333 75.093333 81.92 122.538667 30.378667 96.938667 30.378667 149.162666-10.24 101.717333-30.378667 149.162667-47.786667 88.405333-81.92 122.88-75.093333 61.781333-122.88 81.92-97.28 30.378667-149.162666 30.378667-101.717333-10.24-149.162667-30.378667-88.064-47.786667-122.538667-81.92-61.781333-75.093333-81.92-122.88-30.378667-96.938667-30.378666-149.162667z m329.045333 0c0 130.048 13.994667 244.394667 41.984 343.381334h12.970667c46.762667 0 91.136-9.216 133.461333-27.306667s78.848-42.666667 109.568-73.386667 54.954667-67.242667 73.386667-109.568 27.306667-86.698667 27.306666-133.461333c0-46.421333-9.216-90.794667-27.306666-133.12s-42.666667-78.848-73.386667-109.568-67.242667-54.954667-109.568-73.386667-86.698667-27.306667-133.461333-27.306666h-11.605334c-28.672 123.562667-43.349333 237.909333-43.349333 343.722666z" p-id="11003"></path></svg></button></div></div></div><ul class="__dumi-default-menu-list"><li><a href="/blog/">大师兄 - 前端架构师</a></li></ul></div></div><ul role="slug-list" class="__dumi-default-layout-toc"><li title="Redis服务" data-depth="2"><a href="/blog/手把手带你写一个web框架/04.实战第3关完善功能/10#redis服务"><span>Redis服务</span></a></li><li title="配置" data-depth="3"><a href="/blog/手把手带你写一个web框架/04.实战第3关完善功能/10#配置"><span>配置</span></a></li><li title="初始化连接" data-depth="3"><a href="/blog/手把手带你写一个web框架/04.实战第3关完善功能/10#初始化连接"><span>初始化连接</span></a></li><li title="缓存服务" data-depth="2"><a href="/blog/手把手带你写一个web框架/04.实战第3关完善功能/10#缓存服务"><span>缓存服务</span></a></li><li title="协议" data-depth="3"><a href="/blog/手把手带你写一个web框架/04.实战第3关完善功能/10#协议"><span>协议</span></a></li><li title="实现" data-depth="2"><a href="/blog/手把手带你写一个web框架/04.实战第3关完善功能/10#实现"><span>实现</span></a></li><li title="验证" data-depth="2"><a href="/blog/手把手带你写一个web框架/04.实战第3关完善功能/10#验证"><span>验证</span></a></li><li title="小结" data-depth="2"><a href="/blog/手把手带你写一个web框架/04.实战第3关完善功能/10#小结"><span>小结</span></a></li><li title="思考题" data-depth="3"><a href="/blog/手把手带你写一个web框架/04.实战第3关完善功能/10#思考题"><span>思考题</span></a></li></ul><div class="__dumi-default-layout-content"><div class="markdown"><h1 id="27缓存服务如何基于redis实现封装"><a aria-hidden="true" tabindex="-1" href="/blog/手把手带你写一个web框架/04.实战第3关完善功能/10#27缓存服务如何基于redis实现封装"><span class="icon icon-link"></span></a>27｜缓存服务：如何基于Redis实现封装？</h1><p>你好，我是轩脉刃。</p><p>上面两节课把数据库操作接入到hade框架中了，现在我们能使用容器中的ORM服务来操作数据库了。在实际工作中，一旦数据库出现性能瓶颈，除了优化数据库本身之外，另外一个常用的方法是使用缓存来优化业务请求。所以这节课，我们来讨论一下，hade框架如何提供缓存支持。</p><p>现在的Web业务，大部分都是使用Redis来做缓存实现。但是，缓存的实现方式远不止Redis一种，比如在Redis出现之前，Memcached一般是缓存首选；在单机上，还可以使用文件来存储数据，又或者直接使用进程的内存也可以进行缓存实现。</p><p>缓存服务的底层使用哪个存储方式，和具体的业务架构原型相关。我个人在不同业务场景中用过不少的缓存存储方案，不过业界用的最多的Redis，还是优点比较突出。相比文件存储，它能集中分布式管理；而相比Memcached，优势在于多维度的存储数据结构。所以，顺应潮流，我们hade框架主要也针对使用Redis来实现缓存服务。</p><p>我们这节课会创建两个服务，一个是Redis服务，提供对Redis的封装，另外一个是缓存服务，提供一系列对“缓存”的统一操作。而这些统一操作，具体底层是由Redis还是内存进行驱动的，这个可以根据配置决定。</p><p>下面我们一个个来讨论吧。</p><h2 id="redis服务"><a aria-hidden="true" tabindex="-1" href="/blog/手把手带你写一个web框架/04.实战第3关完善功能/10#redis服务"><span class="icon icon-link"></span></a>Redis服务</h2><p>首先封装一个可以对Redis进行操作的服务。和封装ORM一样，我们自己并不实现Redis的底层传输协议和操作封装，只将Redis“创建连接”的过程封装在hade中就行了。</p><p>这里我们就选择<a target="_blank" rel="noopener noreferrer" href="https://github.com/go-redis/redis">go-redis<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>这个库来实现对Redis的连接。这个库目前也是Golang开源社区最常用的Redis库，有12.8k的star数，使用的是BSD 协议，可以引用，可以修改，但是修改的同时要保留版权声明，这里我们并不需要修改，所以BSD已经足够了。这个库目前是v8版本，可以使用 <code>go get github.com/go-redis/redis/v8</code> 来引入它。</p><p>go-redis的连接非常简单，我们看官网的例子，就看创建连接部分：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">import (</span></div><div class="token-line"><span class="token plain">        &quot;context&quot;</span></div><div class="token-line"><span class="token plain">        &quot;github.com/go-redis/redis/v8&quot;</span></div><div class="token-line"><span class="token plain">    )</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    var ctx = context.Background()</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    func ExampleClient() {</span></div><div class="token-line"><span class="token plain">        // 创建连接</span></div><div class="token-line"><span class="token plain">        rdb := redis.NewClient(&amp;redis.Options{</span></div><div class="token-line"><span class="token plain">            Addr:     &quot;localhost:6379&quot;,</span></div><div class="token-line"><span class="token plain">            Password: &quot;&quot;, // no password set</span></div><div class="token-line"><span class="token plain">            DB:       0,  // use default DB</span></div><div class="token-line"><span class="token plain">        })</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        ...</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p><strong>核心的redis.NewClient方法，返回的是一个*redis.Client结构，它就相当于Gorm中的DB数据结构，就是我们要实例化Redis的实例</strong>。这个结构是一个封装了300+个Redis操作的数据结构，你可以使用 <code>go doc github.com/go-redis/redis/v8.Client</code> 来观察它封装的Redis操作。</p><h3 id="配置"><a aria-hidden="true" tabindex="-1" href="/blog/手把手带你写一个web框架/04.实战第3关完善功能/10#配置"><span class="icon icon-link"></span></a>配置</h3><p>redis.NewClient方法还有一个参数：*redis.Options 数据结构。这个数据结构就相当于Gorm中的gorm.Config，里面封装了实例化redis.Client的各种配置信息，来看一些重要的配置，都做了注释：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// redis的连接配置</span></div><div class="token-line"><span class="token plain">    type Options struct {</span></div><div class="token-line"><span class="token plain">       // 网络情况</span></div><div class="token-line"><span class="token plain">       // Default is tcp.</span></div><div class="token-line"><span class="token plain">       Network string</span></div><div class="token-line"><span class="token plain">       // host:port 格式的地址</span></div><div class="token-line"><span class="token plain">       Addr string</span></div><div class="token-line"><span class="token plain">       </span></div><div class="token-line"><span class="token plain">       // redis的用户名</span></div><div class="token-line"><span class="token plain">       Username string</span></div><div class="token-line"><span class="token plain">       // redis密码</span></div><div class="token-line"><span class="token plain">       Password string</span></div><div class="token-line"><span class="token plain">       // redis的database</span></div><div class="token-line"><span class="token plain">       DB int</span></div><div class="token-line"><span class="token plain">       </span></div><div class="token-line"><span class="token plain">       // 连接超时</span></div><div class="token-line"><span class="token plain">       // Default is 5 seconds.</span></div><div class="token-line"><span class="token plain">       DialTimeout time.Duration</span></div><div class="token-line"><span class="token plain">       // 读超时</span></div><div class="token-line"><span class="token plain">       // Default is 3 seconds.</span></div><div class="token-line"><span class="token plain">       ReadTimeout time.Duration</span></div><div class="token-line"><span class="token plain">       // 写超时</span></div><div class="token-line"><span class="token plain">       // Default is ReadTimeout.</span></div><div class="token-line"><span class="token plain">       WriteTimeout time.Duration</span></div><div class="token-line"><span class="token plain">       </span></div><div class="token-line"><span class="token plain">       // 最小空闲连接数</span></div><div class="token-line"><span class="token plain">       MinIdleConns int</span></div><div class="token-line"><span class="token plain">       // 最大连接时长</span></div><div class="token-line"><span class="token plain">       MaxConnAge time.Duration</span></div><div class="token-line"><span class="token plain">       </span></div><div class="token-line"><span class="token plain">       // 空闲连接时长</span></div><div class="token-line"><span class="token plain">       // Default is 5 minutes. -1 disables idle timeout check.</span></div><div class="token-line"><span class="token plain">       IdleTimeout time.Duration</span></div><div class="token-line"><span class="token plain">       ...</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>这些配置项相信你也非常熟悉了，既有连接请求的配置项，也有连接池的配置项。</p><p>和Gorm的配置封装一样，我们想要给用户提供一个配置即用的缓存服务，需要做如下三个事情：</p><ul><li>自定义一个数据结构，封装redis.Options结构</li><li>让刚才自定义的结构能生成一个唯一标识（类似Gorm的DSN）</li><li>支持通过配置文件加载这个结构，同时，支持通过Option可变参数来修改它</li></ul><p>在framework/contract/redis.go中，我们首先定义<strong>RedisConfig数据结构</strong>，这个结构单纯封装redis.Options就行了，没有其他额外的参数需要设置：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// RedisConfig 为hade定义的Redis配置结构</span></div><div class="token-line"><span class="token plain">    type RedisConfig struct {</span></div><div class="token-line"><span class="token plain">       *redis.Options</span></div></pre></div><p>同时为这个RedisConfig定义一个唯一标识，来标识一个redis.Client。这里我们选用了Addr、DB、UserName、Network 四个字段值来标识。<strong>基本上这四个字段加起来能标识“用什么账号登录哪个Redis地址的哪个database”了</strong>：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// UniqKey 用来唯一标识一个RedisConfig配置</span></div><div class="token-line"><span class="token plain">    func (config *RedisConfig) UniqKey() string {</span></div><div class="token-line"><span class="token plain">       return fmt.Sprintf(&quot;%v_%v_%v_%v&quot;, config.Addr, config.DB, config.Username, config.Network)</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>RedisConfig结构定义完成，下面想要把它加载并支持可修改，我们要结合实例化redis.Client对象来说。</p><h3 id="初始化连接"><a aria-hidden="true" tabindex="-1" href="/blog/手把手带你写一个web框架/04.实战第3关完善功能/10#初始化连接"><span class="icon icon-link"></span></a>初始化连接</h3><p>如何封装Redis的连接实例，这个同Gorm的封装一样，使用Option可变参数的方式。还是在 framework/contract/redis.go中继续写入：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">package contract</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    ...</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    const RedisKey = &quot;hade:redis&quot;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    // RedisOption 代表初始化的时候的选项</span></div><div class="token-line"><span class="token plain">    type RedisOption func(container framework.Container, config *RedisConfig) error</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    // RedisService 表示一个redis服务</span></div><div class="token-line"><span class="token plain">    type RedisService interface {</span></div><div class="token-line"><span class="token plain">       // GetClient 获取redis连接实例</span></div><div class="token-line"><span class="token plain">       GetClient(option ...RedisOption) (*redis.Client, error)</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>定义了一个RedisService，表示Redis服务对外提供的协议，它只有一个GetClient方法，通过这个方法能获取到Redis的一个连接实例redis.Client。</p><p>你能看到GetClient方法有一个可变参数RedisOption，这个可变参数是一个函数结构，参数中带有传递进入了的RedisConfig指针，所以<strong>这个RedisOption是有修改RedisConfig结构的能力的</strong>。</p><p>那具体提供哪些RedisOption函数呢？和ORM一样，我们要提供多层次的修改方案，包括默认配置、按照配置项进行配置，以及手动配置：</p><ul><li>GetBaseConfig获取redis.yaml根目录下的Redis配置，作为默认配置</li><li>GetConfigPath 根据指定配置路径获取Redis配置</li><li>WithRedisConfig 可以直接修改RedisConfig中的redis.Options配置信息</li></ul><p>在实现这三个函数之前，有必要先看一下我们的Redis配置文件cofig/testing/redis.yaml：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">timeout: 10s # 连接超时</span></div><div class="token-line"><span class="token plain">    read_timeout: 2s # 读超时</span></div><div class="token-line"><span class="token plain">    write_timeout: 2s # 写超时</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    write:</span></div><div class="token-line"><span class="token plain">        host: localhost # ip地址</span></div><div class="token-line"><span class="token plain">        port: 3306 # 端口</span></div><div class="token-line"><span class="token plain">        db: 0 #db</span></div><div class="token-line"><span class="token plain">        username: jianfengye # 用户名</span></div><div class="token-line"><span class="token plain">        password: &quot;123456789&quot; # 密码</span></div><div class="token-line"><span class="token plain">        timeout: 10s # 连接超时</span></div><div class="token-line"><span class="token plain">        read_timeout: 2s # 读超时</span></div><div class="token-line"><span class="token plain">        write_timeout: 2s # 写超时</span></div><div class="token-line"><span class="token plain">        conn_min_idle: 10 # 连接池最小空闲连接数</span></div><div class="token-line"><span class="token plain">        conn_max_open: 20 # 连接池最大连接数</span></div><div class="token-line"><span class="token plain">        conn_max_lifetime: 1h # 连接数最大生命周期</span></div><div class="token-line"><span class="token plain">        conn_max_idletime: 1h # 连接数空闲时长</span></div></pre></div><p>和database.yaml的配置一样，根级别的作为默认配置，二级配置作为单个Redis的配置，并且二级配置会覆盖默认配置。这里还有一个小心思，特意将这些配置项都和database.yaml保持一致了，这样使用者在配置的时候能减少学习成本。</p><p>这三个方法的具体实现和Gorm没有什么太大的区别。基本方法就是使用容器中的配置服务、读取配置信息，然后修改参数中的RedisConfig指针，你可以参考分支中的代码文件<a target="_blank" rel="noopener noreferrer" href="https://github.com/gohade/coredemo/blob/geekbang/27/framework/provider/redis/config.go">framework/provider/redis/config.go<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>。</p><p>我们重点把注意力放在<strong>GetClient方法的实现</strong>上，写在framework/provider/redis/service.go中。类似gorm的GetDB方法，它是一个单例模式，就是一个RedisConfig，只产生一个redis.Client，用一个map加上一个lock来初始化Redis实例：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// HadeRedis 代表hade框架的redis实现</span></div><div class="token-line"><span class="token plain">    type HadeRedis struct {</span></div><div class="token-line"><span class="token plain">        container framework.Container      // 服务容器</span></div><div class="token-line"><span class="token plain">        clients   map[string]*redis.Client // key为uniqKey, value为redis.Client (连接池）</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        lock *sync.RWMutex</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>在GetClient函数中，首先还是获取基本Redis配置 redisConfig，使用参数opts对redisConfig进行修改，最后判断当前redisConfig是否已经实例化了：</p><ul><li>如果已经实例化，返回实例化redis.Client；</li><li>如果未实例化，实例化redis.Client，返回实例化的redis.Client。</li></ul><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// GetClient 获取Client实例</span></div><div class="token-line"><span class="token plain">    func (app *HadeRedis) GetClient(option ...contract.RedisOption) (*redis.Client, error) {</span></div><div class="token-line"><span class="token plain">        // 读取默认配置</span></div><div class="token-line"><span class="token plain">        config := GetBaseConfig(app.container)</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        // option对opt进行修改</span></div><div class="token-line"><span class="token plain">        for _, opt := range option {</span></div><div class="token-line"><span class="token plain">            if err := opt(app.container, config); err != nil {</span></div><div class="token-line"><span class="token plain">                return nil, err</span></div><div class="token-line"><span class="token plain">            }</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        // 如果最终的config没有设置dsn,就生成dsn</span></div><div class="token-line"><span class="token plain">        key := config.UniqKey()</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        // 判断是否已经实例化了redis.Client</span></div><div class="token-line"><span class="token plain">        app.lock.RLock()</span></div><div class="token-line"><span class="token plain">        if db, ok := app.clients[key]; ok {</span></div><div class="token-line"><span class="token plain">            app.lock.RUnlock()</span></div><div class="token-line"><span class="token plain">            return db, nil</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        app.lock.RUnlock()</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        // 没有实例化gorm.DB，那么就要进行实例化操作</span></div><div class="token-line"><span class="token plain">        app.lock.Lock()</span></div><div class="token-line"><span class="token plain">        defer app.lock.Unlock()</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        // 实例化gorm.DB</span></div><div class="token-line"><span class="token plain">        client := redis.NewClient(config.Options)</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        // 挂载到map中，结束配置</span></div><div class="token-line"><span class="token plain">        app.clients[key] = client</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        return client, nil</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>这里只讲了Redis服务的接口和服务实现的关键函数，其中provider的实现基本上和ORM的一致，没有什么特别，就不在这里重复列出代码了。</p><p>到这里我们就将Redis的服务融合进入hade框架了。但Redis只是缓存服务的一种实现，我们这节课最终目标是想实现一个缓存服务。</p><h2 id="缓存服务"><a aria-hidden="true" tabindex="-1" href="/blog/手把手带你写一个web框架/04.实战第3关完善功能/10#缓存服务"><span class="icon icon-link"></span></a>缓存服务</h2><p>缓存服务的使用方式其实非常多，我们可以设置有超时/无超时的缓存，也可以使用计数器缓存，一份好的缓存接口的设计，能对应用的缓存使用帮助很大。</p><p>所以这一部分，相比缓存服务的具体实现，<strong>缓存服务的协议设计直接影响了这个服务的可用性</strong>，我们要重点理解对缓存协议的设计。</p><h3 id="协议"><a aria-hidden="true" tabindex="-1" href="/blog/手把手带你写一个web框架/04.实战第3关完善功能/10#协议"><span class="icon icon-link"></span></a>协议</h3><p>实现一个服务的三步骤，服务协议、服务提供者、服务实例。就先从协议开始，我们希望这个缓存服务提供哪些能力呢？</p><p>首先，缓存协议一定是有两个方法，一个设置缓存、一个获取缓存。设定为Get方法为获取缓存，Set方法为设置缓存。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// Get 获取某个key对应的值</span></div><div class="token-line"><span class="token plain">    Get(ctx context.Context, key string) (string, error)</span></div><div class="token-line"><span class="token plain">    // Set 设置某个key和值到缓存，带超时时间</span></div><div class="token-line"><span class="token plain">    Set(ctx context.Context, key string, val string, timeout time.Duration) error</span></div></pre></div><p>同时，注意设置缓存的时候，又区分出两种需求，我们需要设置带超时时间的缓存，也需要设置不带超时时间的、永久的缓存。所以，Set方法衍生出Set和SetForever两种。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// SetForever 设置某个key和值到缓存，不带超时时间</span></div><div class="token-line"><span class="token plain">    SetForever(ctx context.Context, key string, val string) error</span></div></pre></div><p>在设置了某个key之后，会不会需要修改这个缓存key的缓存时长呢？完全是有可能的，比如将某个key的缓存时长加大，或者想要获取某个key的缓存时长，所以我们再把注意力放在缓存时长的操作上，提供对缓存时长的操作函数SetTTL和GetTTL：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// SetTTL 设置某个key的超时时间</span></div><div class="token-line"><span class="token plain">    SetTTL(ctx context.Context, key string, timeout time.Duration) error</span></div><div class="token-line"><span class="token plain">    // GetTTL 获取某个key的超时时间</span></div><div class="token-line"><span class="token plain">    GetTTL(ctx context.Context, key string) (time.Duration, error)</span></div></pre></div><p>再来，Get和Set目前对应的value值为string，但是我们希望value值能不仅仅是一个字符串，它还可以直接是一个对象，这样缓存服务就能存储和获取一个对象出来，能大大方便缓存需求。</p><p>所以我们定义两个GetObj和SetObj方法，来实现对象的缓存存储和获取，但是这个对象在实际存储的时候，又势必要进行序列化和反序列的过程，所以我们对存储和获取的对象再增加一个要求，让它实现官方库的BinaryMarshaler和BinaryUnMarshaler接口：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// GetObj 获取某个key对应的对象, 对象必须实现 https://pkg.go.dev/encoding#BinaryUnMarshaler</span></div><div class="token-line"><span class="token plain">    GetObj(ctx context.Context, key string, model interface{}) error</span></div><div class="token-line"><span class="token plain">    // SetObj 设置某个key和对象到缓存, 对象必须实现 https://pkg.go.dev/encoding#BinaryMarshaler</span></div><div class="token-line"><span class="token plain">    SetObj(ctx context.Context, key string, val interface{}, timeout time.Duration) error</span></div><div class="token-line"><span class="token plain">    // SetForeverObj 设置某个key和对象到缓存，不带超时时间，对象必须实现 https://pkg.go.dev/encoding#BinaryMarshaler</span></div><div class="token-line"><span class="token plain">    SetForeverObj(ctx context.Context, key string, val interface{}) error</span></div></pre></div><p>现在，我们已经可以一个key进行缓存获取和设置了，但是有时候要同时对多个key做缓存的获取和设置，来设置对多个key进行操作的方法GetMany和SetMany：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// GetMany 获取某些key对应的值</span></div><div class="token-line"><span class="token plain">    GetMany(ctx context.Context, keys []string) (map[string]string, error)</span></div><div class="token-line"><span class="token plain">    // SetMany 设置多个key和值到缓存</span></div><div class="token-line"><span class="token plain">    SetMany(ctx context.Context, data map[string]string, timeout time.Duration) error</span></div></pre></div><p>在实际业务中，我们还会有一些计数器的需求，需要将计数器存储到缓存，同时也要能对这个计数器缓存进行增加和减少的操作。可以为计数器缓存设计Calc、Increment、Decrement的接口：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// Calc 往key对应的值中增加step计数</span></div><div class="token-line"><span class="token plain">    Calc(ctx context.Context, key string, step int64) (int64, error)</span></div><div class="token-line"><span class="token plain">    // Increment 往key对应的值中增加1</span></div><div class="token-line"><span class="token plain">    Increment(ctx context.Context, key string) (int64, error)</span></div><div class="token-line"><span class="token plain">    // Decrement 往key对应的值中减去1</span></div><div class="token-line"><span class="token plain">    Decrement(ctx context.Context, key string) (int64, error)</span></div></pre></div><p>缓存的使用有一种Cache-Aside模式，可以提升“获取数据”的性能。可能你没有听过这个名字，但其实我们都用过，这个模式描述的就是在实际操作之前，先去缓存中查看有没有对应的数据，如果有的话，不进行操作，如果没有的话才进行实际操作生成数据，并且把数据存储在缓存中。</p><p>我们希望缓存服务也能支持这种Cache-Aside模式。如何支持呢？</p><p>首先，要有一个生成数据的通用方法结构，我们定义为RememberFunc，让这个函数将服务容器传递进去，这样在具体的实现中，使用者就可以从服务容器中获取各种各样的具体注册服务了，能大大增强这个RemeberFunc的实现能力：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// RememberFunc 缓存的Remember方法使用，Cache-Aside模式对应的对象生成方法</span></div><div class="token-line"><span class="token plain">    type RememberFunc func(ctx context.Context, container framework.Container) (interface{}, error)</span></div></pre></div><p>然后，我们为缓存服务定义一个Remember方法，来实现这个Cache-Aside模式。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// Remember 实现缓存的Cache-Aside模式, 先去缓存中根据key获取对象，如果有的话，返回，如果没有，调用RememberFunc 生成</span></div><div class="token-line"><span class="token plain">    Remember(ctx context.Context, key string, timeout time.Duration, rememberFunc RememberFunc, model interface{}) error</span></div></pre></div><p>它的参数来仔细看下。除了context之外，有一个key，代表这个缓存使用的key，其次是timeout 代表缓存时长，接着是前面定义的 RememberFunc了，代表如果缓存中没有这个key，就调用RememberFunc函数来生成数据对象。</p><p>这个数据对象从哪里输出呢？就是这里的最后一个参数model了，当然这个Obj必须实现BinaryMarshaler和BinaryUnmarshaler接口。这样定义之后，Remember的具体实现就简单了。</p><p>看这个我在单元测试代码provider/cache/services/redis_test.go中写的测试：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">type Bar struct {</span></div><div class="token-line"><span class="token plain">       Name string</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    func (b *Bar) MarshalBinary() ([]byte, error) {</span></div><div class="token-line"><span class="token plain">       return json.Marshal(b)</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    func (b *Bar) UnmarshalBinary(bt []byte) error {</span></div><div class="token-line"><span class="token plain">       return json.Unmarshal(bt, b)</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    Convey(&quot;remember op&quot;, func() {</span></div><div class="token-line"><span class="token plain">       objNew := Bar{}</span></div><div class="token-line"><span class="token plain">       objNewFunc := func(ctx context.Context, container framework.Container) (interface{}, error) {</span></div><div class="token-line"><span class="token plain">          obj := &amp;Bar{</span></div><div class="token-line"><span class="token plain">             Name: &quot;bar&quot;,</span></div><div class="token-line"><span class="token plain">          }</span></div><div class="token-line"><span class="token plain">          return obj, nil</span></div><div class="token-line"><span class="token plain">       }</span></div><div class="token-line"><span class="token plain">       err = mc.Remember(ctx, &quot;foo_remember&quot;, 1*time.Minute, objNewFunc, &amp;objNew)</span></div><div class="token-line"><span class="token plain">       So(err, ShouldBeNil)</span></div><div class="token-line"><span class="token plain">       So(objNew.Name, ShouldEqual, &quot;bar&quot;)</span></div><div class="token-line"><span class="token plain">    })</span></div></pre></div><p>我们定义了Bar结构，它实现了BinaryMarshaler和BinaryUnmarshaler接口，并且定义了一个objNewFunc方法实现了前面我们定义的RememberFunc。</p><p>之后可以使用Remember方法来为这个方法设置一个Cache-Aside缓存，它的key为foo_remember，缓存时长为1分钟。</p><p>最后回看一下我们对缓存的协议定义，各种缓存的设置和获取方法都有了，还差删除缓存的方法对吧。所以来定义删除单个key的缓存和删除多个key的缓存：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// Del 删除某个key</span></div><div class="token-line"><span class="token plain">    Del(ctx context.Context, key string) error</span></div><div class="token-line"><span class="token plain">    // DelMany 删除某些key</span></div><div class="token-line"><span class="token plain">    DelMany(ctx context.Context, keys []string) error</span></div></pre></div><p>到这里缓存协议就定义完成了，一共16个方法，要好好理解下这些方法的定义，还是那句话，理解如何定义协议比实现更为重要。<br/><img src="https://static001.geekbang.org/resource/image/da/e5/da9b83e6856e5fd523bc270981846fe5.jpg?wh=2364x2273" alt=""/></p><h2 id="实现"><a aria-hidden="true" tabindex="-1" href="/blog/手把手带你写一个web框架/04.实战第3关完善功能/10#实现"><span class="icon icon-link"></span></a>实现</h2><p>下面来实现这个缓存服务。前面一再强调了，Redis只是缓存的一种实现，Redis之外，我们可以用不同的存储来实现缓存，甚至，可以使用内存来实现。目前hade框架支持内存和Redis实现缓存，这里我们就先看看如何用Redis来实现缓存。</p><p>由于缓存有不同实现，所以和日志服务一样，<strong>要使用配置文件来cache.yaml中的driver字段，来区别使用哪个缓存</strong>。如果driver为redis，表示使用Redis来实现缓存，如果为memory，表示用内存来实现缓存。当然如果使用Redis的话，就需要同时带上Redis连接的各种参数，参数关键字都类似前面说的Redis服务的配置。</p><p>一个典型的cache.yaml的配置如下：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">driver: redis # 连接驱动</span></div><div class="token-line"><span class="token plain">    host: 127.0.0.1 # ip地址</span></div><div class="token-line"><span class="token plain">    port: 6379 # 端口</span></div><div class="token-line"><span class="token plain">    db: 0 #db</span></div><div class="token-line"><span class="token plain">    timeout: 10s # 连接超时</span></div><div class="token-line"><span class="token plain">    read_timeout: 2s # 读超时</span></div><div class="token-line"><span class="token plain">    write_timeout: 2s # 写超时</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    #driver: memory # 连接驱动</span></div></pre></div><p>那对应到具体实现上，区分使用哪个缓存驱动，我们会在服务提供者provider中来进行。在provider中，注意下Register方法，注册具体的服务实例方法时，要先读取配置中的cache.driver路径：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// Register 注册一个服务实例</span></div><div class="token-line"><span class="token plain">    func (l *HadeCacheProvider) Register(c framework.Container) framework.NewInstance {</span></div><div class="token-line"><span class="token plain">       if l.Driver == &quot;&quot; {</span></div><div class="token-line"><span class="token plain">          tcs, err := c.Make(contract.ConfigKey)</span></div><div class="token-line"><span class="token plain">          if err != nil {</span></div><div class="token-line"><span class="token plain">             // 默认使用console</span></div><div class="token-line"><span class="token plain">             return services.NewMemoryCache</span></div><div class="token-line"><span class="token plain">          }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">          cs := tcs.(contract.Config)</span></div><div class="token-line"><span class="token plain">          l.Driver = strings.ToLower(cs.GetString(&quot;cache.driver&quot;))</span></div><div class="token-line"><span class="token plain">       }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">       // 根据driver的配置项确定</span></div><div class="token-line"><span class="token plain">       switch l.Driver {</span></div><div class="token-line"><span class="token plain">       case &quot;redis&quot;:</span></div><div class="token-line"><span class="token plain">          return services.NewRedisCache</span></div><div class="token-line"><span class="token plain">       case &quot;memory&quot;:</span></div><div class="token-line"><span class="token plain">          return services.NewMemoryCache</span></div><div class="token-line"><span class="token plain">       default:</span></div><div class="token-line"><span class="token plain">          return services.NewMemoryCache</span></div><div class="token-line"><span class="token plain">       }</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>如果是Redis驱动，我们使用service.NewRedisCache来初始化一个Redis连接，定义RedisCache结构来存储redis.Client。</p><p><strong>在初始化的时候，先确定下容器中是否已经绑定了Redis服务，如果没有的话，做一下绑定操作</strong>。这个行为能让我们的缓存容器更为安全。</p><p>接着使用cache.yaml中的配置，来初始化一个redis.Client，这里使用的redisService.GetClient和redis.WithConfigPath，都是上面设计Redis服务的时候刚设计实现的方法。最后将redis.Client 封装到RedisCache中，返回：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">import (</span></div><div class="token-line"><span class="token plain">       &quot;context&quot;</span></div><div class="token-line"><span class="token plain">       &quot;errors&quot;</span></div><div class="token-line"><span class="token plain">       redisv8 &quot;github.com/go-redis/redis/v8&quot;</span></div><div class="token-line"><span class="token plain">       &quot;github.com/gohade/hade/framework&quot;</span></div><div class="token-line"><span class="token plain">       &quot;github.com/gohade/hade/framework/contract&quot;</span></div><div class="token-line"><span class="token plain">       &quot;github.com/gohade/hade/framework/provider/redis&quot;</span></div><div class="token-line"><span class="token plain">       &quot;sync&quot;</span></div><div class="token-line"><span class="token plain">       &quot;time&quot;</span></div><div class="token-line"><span class="token plain">    )</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    // RedisCache 代表Redis缓存</span></div><div class="token-line"><span class="token plain">    type RedisCache struct {</span></div><div class="token-line"><span class="token plain">       container framework.Container</span></div><div class="token-line"><span class="token plain">       client    *redisv8.Client</span></div><div class="token-line"><span class="token plain">       lock      sync.RWMutex</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    // NewRedisCache 初始化redis服务</span></div><div class="token-line"><span class="token plain">    func NewRedisCache(params ...interface{}) (interface{}, error) {</span></div><div class="token-line"><span class="token plain">       container := params[0].(framework.Container)</span></div><div class="token-line"><span class="token plain">       if !container.IsBind(contract.RedisKey) {</span></div><div class="token-line"><span class="token plain">          err := container.Bind(&amp;redis.RedisProvider{})</span></div><div class="token-line"><span class="token plain">          if err != nil {</span></div><div class="token-line"><span class="token plain">             return nil, err</span></div><div class="token-line"><span class="token plain">          }</span></div><div class="token-line"><span class="token plain">       }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">       // 获取redis服务配置，并且实例化redis.Client</span></div><div class="token-line"><span class="token plain">       redisService := container.MustMake(contract.RedisKey).(contract.RedisService)</span></div><div class="token-line"><span class="token plain">       client, err := redisService.GetClient(redis.WithConfigPath(&quot;cache&quot;))</span></div><div class="token-line"><span class="token plain">       if err != nil {</span></div><div class="token-line"><span class="token plain">          return nil, err</span></div><div class="token-line"><span class="token plain">       }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">       // 返回RedisCache实例</span></div><div class="token-line"><span class="token plain">       obj := &amp;RedisCache{</span></div><div class="token-line"><span class="token plain">          container: container,</span></div><div class="token-line"><span class="token plain">          client:    client,</span></div><div class="token-line"><span class="token plain">          lock:      sync.RWMutex{},</span></div><div class="token-line"><span class="token plain">       }</span></div><div class="token-line"><span class="token plain">       return obj, nil</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>好，有Redis缓存的实例了，下面来看16个方法的实现。</p><p>Set系列的方法一共有Set/SetObj/SetMany/SetForever/SetForeverObj/SetTTL 6个，其他5个相对简单一些，在生成的redis.Client结构中都有对应实现，我们直接使用redis.Client调用即可，就不赘述了。其中SetMany方法相对复杂些，我们着重说明下。</p><p>在Redis中，SetMany这种为多个key设置缓存的方法，一般可以遍历key，然后一个个调用Set方法，但是这样效率就低了。更好的实现方式是使用pipeline。</p><p>什么是Redis的pipeline呢？Redis的客户端和服务端的交互，采用的是客户端-服务端模式，就是每个客户端的请求发送到Redis服务端，都会有一个完整的响应。所以，向服务端发送n个请求，就对应有n次响应。那么<strong>对于这种n个请求且n个请求没有上下文逻辑关系，我们能不能批量发送，但是只发送一次请求，然后只获取一次响应呢</strong>？</p><p>Redis的pipeline就是这个原理，它将多个请求合成为一个请求，批量发送给Redis服务端，并且只从服务端获取一次数据，拿到这些请求的所有结果。</p><p>我们的SetMany就很符合这个场景。具体的代码如下：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// SetMany 设置多个key和值到缓存</span></div><div class="token-line"><span class="token plain">    func (r *RedisCache) SetMany(ctx context.Context, data map[string]string, timeout time.Duration) error {</span></div><div class="token-line"><span class="token plain">       pipline := r.client.Pipeline()</span></div><div class="token-line"><span class="token plain">       cmds := make([]*redisv8.StatusCmd, 0, len(data))</span></div><div class="token-line"><span class="token plain">       for k, v := range data {</span></div><div class="token-line"><span class="token plain">          cmds = append(cmds, pipline.Set(ctx, k, v, timeout))</span></div><div class="token-line"><span class="token plain">       }</span></div><div class="token-line"><span class="token plain">       _, err := pipline.Exec(ctx)</span></div><div class="token-line"><span class="token plain">       return err</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>先用redis.Client.Pipeline() 来创建一个pipeline管道，然后用一个redis.StatusCmd数组来存储要发送的所有命令，最后调用一次pipeline.Exec来一次发送命令。</p><p>Set方法就讲到这里，Get系列的方法一共有4个，Get/GetObj/GetMany/GetTTL。</p><p>在实现Get系列方法的时候有地方需要注意下，因为<strong>Get是有可能Get一个不存在的key的</strong>，对于这种不存在的key是否返回error，是一个可以稍微思考的话题。</p><p>比如Get这个方法，返回的是string和error，如果对于一个不存在的key，返回了空字符串+空error的组合，而对于一个设置了空字符串的key，也返回空字符串+空error的组合，这里其实是丢失了“是否存在key”的信息的。</p><p>所以，对于这些不存在的key，我们设计返回一个 ErrKeyNotFound 的自定义error。像Get函数就实现为如下：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// Get 获取某个key对应的值</span></div><div class="token-line"><span class="token plain">    func (r *RedisCache) Get(ctx context.Context, key string) (string, error) {</span></div><div class="token-line"><span class="token plain">       val, err := r.client.Get(ctx, key).Result()</span></div><div class="token-line"><span class="token plain">       // 这里判断了key是否为空</span></div><div class="token-line"><span class="token plain">       if errors.Is(err, redisv8.Nil) {</span></div><div class="token-line"><span class="token plain">          return val, ErrKeyNotFound</span></div><div class="token-line"><span class="token plain">       }</span></div><div class="token-line"><span class="token plain">       return val, err</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>其他Get相关的实现没有什么难点。</p><p>除了Get系列和Set系列，其他的方法有Calc、Increment、Decrement、Del、DelMany 都没有什么太复杂的逻辑，都是redis.Client的具体封装。</p><p>最后看下Remember这个方法：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// Remember 实现缓存的Cache-Aside模式, 先去缓存中根据key获取对象，如果有的话，返回，如果没有，调用RememberFunc 生成</span></div><div class="token-line"><span class="token plain">    func (r *RedisCache) Remember(ctx context.Context, key string, timeout time.Duration, rememberFunc contract.RememberFunc, obj interface{}) error {</span></div><div class="token-line"><span class="token plain">       err := r.GetObj(ctx, key, obj)</span></div><div class="token-line"><span class="token plain">       // 如果返回为nil，说明有这个key，且有数据，obj已经注入了，返回nil</span></div><div class="token-line"><span class="token plain">       if err == nil {</span></div><div class="token-line"><span class="token plain">          return nil</span></div><div class="token-line"><span class="token plain">       }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">       // 有err，但是并不是key不存在，说明是有具体的error的，不能继续往下执行了，返回err</span></div><div class="token-line"><span class="token plain">       if !errors.Is(err, ErrKeyNotFound) {</span></div><div class="token-line"><span class="token plain">          return err</span></div><div class="token-line"><span class="token plain">       }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">       // 以下是key不存在的情况, 调用rememberFunc</span></div><div class="token-line"><span class="token plain">       objNew, err := rememberFunc(ctx, r.container)</span></div><div class="token-line"><span class="token plain">       if err != nil {</span></div><div class="token-line"><span class="token plain">          return err</span></div><div class="token-line"><span class="token plain">       }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">       // 设置key</span></div><div class="token-line"><span class="token plain">       if err := r.SetObj(ctx, key, objNew, timeout); err != nil {</span></div><div class="token-line"><span class="token plain">          return err</span></div><div class="token-line"><span class="token plain">       }</span></div><div class="token-line"><span class="token plain">       // 用GetObj将数据注入到obj中</span></div><div class="token-line"><span class="token plain">       if err := r.GetObj(ctx, key, obj); err != nil {</span></div><div class="token-line"><span class="token plain">          return err</span></div><div class="token-line"><span class="token plain">       }</span></div><div class="token-line"><span class="token plain">       return nil</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>前面说过Remember方法是Cache-Aside模式的实现，它的逻辑是先判断缓存中是否有这个key，如果有的话，直接返回对象，如果没有的话，就调用RememberFunc方法来实例化这个对象，并且返回这个实例化对象。</p><p>好了，这里的framework/provider/cache/redis.go我们实现差不多了。</p><h2 id="验证"><a aria-hidden="true" tabindex="-1" href="/blog/手把手带你写一个web框架/04.实战第3关完善功能/10#验证"><span class="icon icon-link"></span></a>验证</h2><p>来做验证，我们为缓存服务写一个简单的路由，在这个路由中：</p><ul><li>获取缓存服务</li><li>设置foo为key的缓存，值为bar</li><li>获取foo为key的缓存，把值打印到控制台</li><li>删除foo为key的缓存</li></ul><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// DemoCache cache的简单例子</span></div><div class="token-line"><span class="token plain">    func (api *DemoApi) DemoCache(c *gin.Context) {</span></div><div class="token-line"><span class="token plain">       logger := c.MustMakeLog()</span></div><div class="token-line"><span class="token plain">       logger.Info(c, &quot;request start&quot;, nil)</span></div><div class="token-line"><span class="token plain">       // 初始化cache服务</span></div><div class="token-line"><span class="token plain">       cacheService := c.MustMake(contract.CacheKey).(contract.CacheService)</span></div><div class="token-line"><span class="token plain">       // 设置key为foo</span></div><div class="token-line"><span class="token plain">       err := cacheService.Set(c, &quot;foo&quot;, &quot;bar&quot;, 1*time.Hour)</span></div><div class="token-line"><span class="token plain">       if err != nil {</span></div><div class="token-line"><span class="token plain">          c.AbortWithError(500, err)</span></div><div class="token-line"><span class="token plain">          return</span></div><div class="token-line"><span class="token plain">       }</span></div><div class="token-line"><span class="token plain">       // 获取key为foo</span></div><div class="token-line"><span class="token plain">       val, err := cacheService.Get(c, &quot;foo&quot;)</span></div><div class="token-line"><span class="token plain">       if err != nil {</span></div><div class="token-line"><span class="token plain">          c.AbortWithError(500, err)</span></div><div class="token-line"><span class="token plain">          return</span></div><div class="token-line"><span class="token plain">       }</span></div><div class="token-line"><span class="token plain">       logger.Info(c, &quot;cache get&quot;, map[string]interface{}{</span></div><div class="token-line"><span class="token plain">          &quot;val&quot;: val,</span></div><div class="token-line"><span class="token plain">       })</span></div><div class="token-line"><span class="token plain">       // 删除key为foo</span></div><div class="token-line"><span class="token plain">       if err := cacheService.Del(c, &quot;foo&quot;); err != nil {</span></div><div class="token-line"><span class="token plain">          c.AbortWithError(500, err)</span></div><div class="token-line"><span class="token plain">          return</span></div><div class="token-line"><span class="token plain">       }</span></div><div class="token-line"><span class="token plain">       c.JSON(200, &quot;ok&quot;)</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>增加对应的路由：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">r.GET(&quot;/demo/cache/redis&quot;, api.DemoRedis)</span></div></pre></div><p>在浏览器中请求地址： <a target="_blank" rel="noopener noreferrer" href="http://localhost:8888/demo/cache/redis">http://localhost:8888/demo/cache/redis<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>：<br/><img src="https://static001.geekbang.org/resource/image/2a/50/2acd5f030ab6b4d5ce8e05ec0c961850.png?wh=583x174" alt=""/></p><p>查看控制台输出的日志：<br/><img src="https://static001.geekbang.org/resource/image/6c/14/6cf8ba131ba431303f5f77560015f814.png?wh=617x130" alt=""/></p><p>可以明显看到cacheService.Get的数据为bar，打印了出来。验证正确！</p><p>本节课我们主要修改了framework目录下Redis和cache相关的代码。目录截图也放在这里供你对比查看，所有代码都已经上传到<a target="_blank" rel="noopener noreferrer" href="https://github.com/gohade/coredemo/tree/geekbang/27">geekbang/27<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>分支了。<br/><img src="https://static001.geekbang.org/resource/image/04/03/04d8a0896596b62ab57848a882d82903.png?wh=355x1116" alt=""/></p><h2 id="小结"><a aria-hidden="true" tabindex="-1" href="/blog/手把手带你写一个web框架/04.实战第3关完善功能/10#小结"><span class="icon icon-link"></span></a>小结</h2><p>除DB之外，缓存是我们最常使用的一个存储了，今天我们先是实现了Redis的服务，再用Redis服务实现了一个缓存服务。</p><p>第一部分的Redis服务，同上一节课ORM的逻辑一样，我们只是将go-redis库进行了封装，具体怎么使用，还是依赖你在实际工作中多使用、多琢磨，网上也有很多go-redis库的相关资料。<br/><img src="https://static001.geekbang.org/resource/image/da/e5/da9b83e6856e5fd523bc270981846fe5.jpg?wh=2364x2273" alt=""/><br/>在第二部分实现的过程中，相信你现在能理解，<strong>一个服务的接口设计，就是一个“我们想要什么服务”的思考过程</strong>。比如在缓存服务接口设计中，我们定义了16个方法，囊括了Get/Set/Del/Remember等一系列方法，你可以对照思维导图复习一下。但这些方法并不是随便拍脑袋出来的，是因为有设置缓存、获取缓存、删除缓存等需求，才这样设计的。</p><h3 id="思考题"><a aria-hidden="true" tabindex="-1" href="/blog/手把手带你写一个web框架/04.实战第3关完善功能/10#思考题"><span class="icon icon-link"></span></a>思考题</h3><p>目前hade框架支持内存和Redis实现缓存，我们今天展示了Redis的实现。缓存服务的内存缓存如何实现呢？可以先思考一下，如果是你来实现会如何设计呢？如果有兴趣，你可以自己动手操作一下。完成之后，你可以比对GitHub分支上我已经实现的版本，看看有没有更好的方案。</p><p>欢迎在留言区分享你的思考。感谢你的收听，如果你觉得今天的内容对你有所帮助，也欢迎分享给你身边的朋友，邀请他一起学习。我们下节课见～</p></div><div class="__dumi-default-layout-footer-meta"><a target="_blank" rel="noopener noreferrer" href="https://github.com/GGwujun/blog/edit/master/docs/手把手带你写一个Web框架/04.实战第3关完善功能/10.md">在 GitHub 上编辑此页<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a><span data-updated-text="最后更新时间：">5/2/2022 10:56:58</span></div></div></div></div>
	<script>
  window.g_useSSR = true;
  window.g_initialProps = {};
	</script>

    <script>
      (function () {
        if (!location.port) {
          (function (i, s, o, g, r, a, m) {
            i["GoogleAnalyticsObject"] = r;
            (i[r] =
              i[r] ||
              function () {
                (i[r].q = i[r].q || []).push(arguments);
              }),
              (i[r].l = 1 * new Date());
            (a = s.createElement(o)), (m = s.getElementsByTagName(o)[0]);
            a.async = 1;
            a.src = g;
            m.parentNode.insertBefore(a, m);
          })(
            window,
            document,
            "script",
            "//www.google-analytics.com/analytics.js",
            "ga"
          );
          ga("create", "UA-149864185-1", "auto");
          ga("send", "pageview");
        }
      })();
    </script>
    <script src="/blog/umi.js"></script>
  </body>
</html>
