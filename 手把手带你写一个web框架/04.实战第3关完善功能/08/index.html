<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no"
    />
    <link rel="shortcut icon" type="image/x-icon" href="/logo.png" />
    <link rel="stylesheet" href="/blog/umi.css" />
    <script>
      window.routerBase = "/blog";
    </script>
    <script>
      //! umi version: 3.5.17
    </script>
    <script>
      !(function () {
        var e = localStorage.getItem("dumi:prefers-color"),
          t = window.matchMedia("(prefers-color-scheme: dark)").matches,
          r = ["light", "dark", "auto"];
        document.documentElement.setAttribute(
          "data-prefers-color",
          e === r[2] ? (t ? r[1] : r[0]) : r.indexOf(e) > -1 ? e : r[0]
        );
      })();
    </script>
    <title>25｜GORM（上）：数据库的使用必不可少</title>
  </head>
  <body>
    <div id="root"><div class="__dumi-default-layout" data-route="/手把手带你写一个web框架/04.实战第3关完善功能/08" data-show-sidemenu="true" data-show-slugs="true" data-site-mode="true" data-gapless="false"><div class="__dumi-default-navbar" data-mode="site"><button class="__dumi-default-navbar-toggle"></button><a class="__dumi-default-navbar-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog/">大师兄</a><nav><div class="__dumi-default-search"><input type="search" class="__dumi-default-search-input" value=""/><ul></ul></div><span>计算机基础<ul><li><a href="/blog/编译原理之美">编译原理之美</a></li><li><a href="/blog/编译原理实战">编译原理实战</a></li><li><a href="/blog/深入浅出计算机组成原理">深入浅出计算机组成原理</a></li><li><a href="/blog/详解http">详解http</a></li><li><a href="/blog/计算机网络通关29讲">计算机网络通关29讲</a></li><li><a href="/blog/网络排查案例课">网络排查案例课</a></li><li><a href="/blog/linux操作系统">linux操作系统</a></li><li><a href="/blog/linux性能优化实战">linux性能优化实战</a></li><li><a href="/blog/程序员数学基础">程序员数学基础</a></li><li><a href="/blog/趣谈网络协议">趣谈网络协议</a></li><li><a href="/blog/操作系统实战">操作系统实战</a></li><li><a href="/blog/软件工程之美">软件工程之美</a></li><li><a href="/blog/sql必知必会">sql必知必会</a></li><li><a href="/blog/操作系统实战45讲">操作系统实战45讲</a></li><li><a href="/blog/网络编程实战">网络编程实战</a></li></ul></span><span>算法<ul><li><a href="/blog/常用算法25讲">常用算法25讲</a></li><li><a href="/blog/数据结构与算法之美">数据结构与算法之美</a></li><li><a href="/blog/业务开发算法50讲">业务开发算法50讲</a></li><li><a href="/blog/动态规划面试宝典">动态规划面试宝典</a></li></ul></span><span>前端开发<ul><li><a href="/blog/浏览器工作原理与实践">浏览器工作原理与实践</a></li><li><a href="/blog/新时代产品经理进阶之路">新时代产品经理进阶之路</a></li><li><a href="/blog/全栈工程师修炼指南">全栈工程师修炼指南</a></li><li><a href="/blog/flutter核心技术与实战">flutter核心技术与实战</a></li><li><a href="/blog/java-script核心原理解析">java-script核心原理解析</a></li><li><a href="/blog/说透低代码">说透低代码</a></li><li><a href="/blog/nodejs应用开发实战">nodejs应用开发实战</a></li><li><a href="/blog/反爬虫兵法演绎20讲">反爬虫兵法演绎20讲</a></li><li><a href="/blog/reactnative新架构实战课">reactnative新架构实战课</a></li><li><a href="/blog/正则表达式入门">正则表达式入门</a></li><li><a href="/blog/重学前端">重学前端</a></li><li><a href="/blog/serverless入门课">serverless入门课</a></li><li><a href="/blog/type-script入门实战笔记">type-script入门实战笔记</a></li><li><a href="/blog/图解googlev8">图解googlev8</a></li><li><a href="/blog/vue3源码分析">vue3源码分析</a></li><li><a href="/blog/玩转Vue3全家桶">玩转Vue3全家桶</a></li><li><a href="/blog/webassembly入门">webassembly入门</a></li><li><a aria-current="page" class="active" href="/blog/手把手带你写一个Web框架">手把手带你写一个Web框架</a></li><li><a href="/blog/web漏洞挖掘实战">web漏洞挖掘实战</a></li><li><a href="/blog/跟月影学可视化">跟月影学可视化</a></li><li><a href="/blog/搞定音频技术">搞定音频技术</a></li><li><a href="/blog/攻克视频技术">攻克视频技术</a></li></ul></span><span>前端工程化<ul><li><a href="/blog/logger">logger</a></li><li><a href="/blog/webpack">webpack</a></li><li><a href="/blog/webpackChain">webpackChain</a></li></ul></span><span>前端性能优化<ul><li><a href="/blog/react性能调优">react性能调优</a></li></ul></span><span>软件测试<ul><li><a href="/blog/全链路压测实战30讲">全链路压测实战30讲</a></li><li><a href="/blog/性能测试实战30讲">性能测试实战30讲</a></li><li><a href="/blog/自动化测试高手课">自动化测试高手课</a></li><li><a href="/blog/软件测试52讲">软件测试52讲</a></li></ul></span><span>面试<ul><li><a href="/blog/面试现场">面试现场</a></li></ul></span><span>杂谈<ul><li><a href="/blog/超级访谈对话张雪峰">超级访谈对话张雪峰</a></li><li><a href="/blog/Git实战手册">Git实战手册</a></li><li><a href="/blog/NodeJS">NodeJS</a></li><li><a href="/blog/ReactJS">ReactJS</a></li><li><a href="/blog/UI设计">UI设计</a></li><li><a href="/blog/webpack4系列教程">webpack4系列教程</a></li><li><a href="/blog/前端知识体系">前端知识体系</a></li><li><a href="/blog/剑指offer刷题笔记">剑指offer刷题笔记</a></li><li><a href="/blog/思考与成长">思考与成长</a></li><li><a href="/blog/设计模式手册">设计模式手册</a></li></ul></span><div class="__dumi-default-navbar-tool"><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "></div></div></div></nav></div><div class="__dumi-default-menu" data-mode="site"><div class="__dumi-default-menu-inner"><div class="__dumi-default-menu-header"><a class="__dumi-default-menu-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog/"></a><h1>大师兄</h1><p></p></div><div class="__dumi-default-menu-mobile-area"><ul class="__dumi-default-menu-nav-list"><li>计算机基础<ul><li><a href="/blog/编译原理之美">编译原理之美</a></li><li><a href="/blog/编译原理实战">编译原理实战</a></li><li><a href="/blog/深入浅出计算机组成原理">深入浅出计算机组成原理</a></li><li><a href="/blog/详解http">详解http</a></li><li><a href="/blog/计算机网络通关29讲">计算机网络通关29讲</a></li><li><a href="/blog/网络排查案例课">网络排查案例课</a></li><li><a href="/blog/linux操作系统">linux操作系统</a></li><li><a href="/blog/linux性能优化实战">linux性能优化实战</a></li><li><a href="/blog/程序员数学基础">程序员数学基础</a></li><li><a href="/blog/趣谈网络协议">趣谈网络协议</a></li><li><a href="/blog/操作系统实战">操作系统实战</a></li><li><a href="/blog/软件工程之美">软件工程之美</a></li><li><a href="/blog/sql必知必会">sql必知必会</a></li><li><a href="/blog/操作系统实战45讲">操作系统实战45讲</a></li><li><a href="/blog/网络编程实战">网络编程实战</a></li></ul></li><li>算法<ul><li><a href="/blog/常用算法25讲">常用算法25讲</a></li><li><a href="/blog/数据结构与算法之美">数据结构与算法之美</a></li><li><a href="/blog/业务开发算法50讲">业务开发算法50讲</a></li><li><a href="/blog/动态规划面试宝典">动态规划面试宝典</a></li></ul></li><li>前端开发<ul><li><a href="/blog/浏览器工作原理与实践">浏览器工作原理与实践</a></li><li><a href="/blog/新时代产品经理进阶之路">新时代产品经理进阶之路</a></li><li><a href="/blog/全栈工程师修炼指南">全栈工程师修炼指南</a></li><li><a href="/blog/flutter核心技术与实战">flutter核心技术与实战</a></li><li><a href="/blog/java-script核心原理解析">java-script核心原理解析</a></li><li><a href="/blog/说透低代码">说透低代码</a></li><li><a href="/blog/nodejs应用开发实战">nodejs应用开发实战</a></li><li><a href="/blog/反爬虫兵法演绎20讲">反爬虫兵法演绎20讲</a></li><li><a href="/blog/reactnative新架构实战课">reactnative新架构实战课</a></li><li><a href="/blog/正则表达式入门">正则表达式入门</a></li><li><a href="/blog/重学前端">重学前端</a></li><li><a href="/blog/serverless入门课">serverless入门课</a></li><li><a href="/blog/type-script入门实战笔记">type-script入门实战笔记</a></li><li><a href="/blog/图解googlev8">图解googlev8</a></li><li><a href="/blog/vue3源码分析">vue3源码分析</a></li><li><a href="/blog/玩转Vue3全家桶">玩转Vue3全家桶</a></li><li><a href="/blog/webassembly入门">webassembly入门</a></li><li><a aria-current="page" class="active" href="/blog/手把手带你写一个Web框架">手把手带你写一个Web框架</a></li><li><a href="/blog/web漏洞挖掘实战">web漏洞挖掘实战</a></li><li><a href="/blog/跟月影学可视化">跟月影学可视化</a></li><li><a href="/blog/搞定音频技术">搞定音频技术</a></li><li><a href="/blog/攻克视频技术">攻克视频技术</a></li></ul></li><li>前端工程化<ul><li><a href="/blog/logger">logger</a></li><li><a href="/blog/webpack">webpack</a></li><li><a href="/blog/webpackChain">webpackChain</a></li></ul></li><li>前端性能优化<ul><li><a href="/blog/react性能调优">react性能调优</a></li></ul></li><li>软件测试<ul><li><a href="/blog/全链路压测实战30讲">全链路压测实战30讲</a></li><li><a href="/blog/性能测试实战30讲">性能测试实战30讲</a></li><li><a href="/blog/自动化测试高手课">自动化测试高手课</a></li><li><a href="/blog/软件测试52讲">软件测试52讲</a></li></ul></li><li>面试<ul><li><a href="/blog/面试现场">面试现场</a></li></ul></li><li>杂谈<ul><li><a href="/blog/超级访谈对话张雪峰">超级访谈对话张雪峰</a></li><li><a href="/blog/Git实战手册">Git实战手册</a></li><li><a href="/blog/NodeJS">NodeJS</a></li><li><a href="/blog/ReactJS">ReactJS</a></li><li><a href="/blog/UI设计">UI设计</a></li><li><a href="/blog/webpack4系列教程">webpack4系列教程</a></li><li><a href="/blog/前端知识体系">前端知识体系</a></li><li><a href="/blog/剑指offer刷题笔记">剑指offer刷题笔记</a></li><li><a href="/blog/思考与成长">思考与成长</a></li><li><a href="/blog/设计模式手册">设计模式手册</a></li></ul></li></ul><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "><button title="Dark theme" class="__dumi-default-dark-moon "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="3854" width="22" height="22"><path d="M991.816611 674.909091a69.166545 69.166545 0 0 0-51.665455-23.272727 70.795636 70.795636 0 0 0-27.438545 5.585454A415.674182 415.674182 0 0 1 754.993338 698.181818c-209.594182 0-393.472-184.785455-393.472-395.636363 0-52.363636 38.539636-119.621818 69.515637-173.614546 4.887273-8.610909 9.634909-16.756364 14.103272-24.901818A69.818182 69.818182 0 0 0 384.631156 0a70.842182 70.842182 0 0 0-27.438545 5.585455C161.678429 90.298182 14.362065 307.898182 14.362065 512c0 282.298182 238.824727 512 532.38691 512a522.286545 522.286545 0 0 0 453.957818-268.334545A69.818182 69.818182 0 0 0 991.816611 674.909091zM546.679156 954.181818c-248.785455 0-462.941091-192-462.941091-442.181818 0-186.647273 140.637091-372.829091 300.939637-442.181818-36.817455 65.629091-92.578909 151.970909-92.578909 232.727273 0 250.181818 214.109091 465.454545 462.917818 465.454545a488.331636 488.331636 0 0 0 185.181091-46.545455 453.003636 453.003636 0 0 1-393.565091 232.727273z m103.656728-669.323636l-14.266182 83.781818a34.909091 34.909091 0 0 0 50.362182 36.770909l74.775272-39.563636 74.752 39.563636a36.142545 36.142545 0 0 0 16.174546 3.956364 34.909091 34.909091 0 0 0 34.210909-40.727273l-14.289455-83.781818 60.509091-59.345455a35.025455 35.025455 0 0 0-19.223272-59.578182l-83.61891-12.101818-37.376-76.101818a34.56 34.56 0 0 0-62.254545 0l-37.376 76.101818-83.618909 12.101818a34.909091 34.909091 0 0 0-19.246546 59.578182z m70.423272-64.698182a34.280727 34.280727 0 0 0 26.135273-19.083636l14.312727-29.090909 14.336 29.090909a34.257455 34.257455 0 0 0 26.135273 19.083636l32.046546 4.887273-23.272728 22.574545a35.234909 35.234909 0 0 0-10.007272 30.952727l5.46909 32.116364-28.625454-15.127273a34.490182 34.490182 0 0 0-32.302546 0l-28.695272 15.127273 5.469091-32.116364a35.141818 35.141818 0 0 0-9.984-30.952727l-23.272728-22.574545z" p-id="3855"></path></svg></button><button title="Light theme" class="__dumi-default-dark-sun "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="4026" width="22" height="22"><path d="M915.2 476.16h-43.968c-24.704 0-44.736 16-44.736 35.84s20.032 35.904 44.736 35.904H915.2c24.768 0 44.8-16.064 44.8-35.904s-20.032-35.84-44.8-35.84zM512 265.6c-136.704 0-246.464 109.824-246.464 246.4 0 136.704 109.76 246.464 246.464 246.464S758.4 648.704 758.4 512c0-136.576-109.696-246.4-246.4-246.4z m0 425.6c-99.008 0-179.2-80.128-179.2-179.2 0-98.944 80.192-179.2 179.2-179.2S691.2 413.056 691.2 512c0 99.072-80.192 179.2-179.2 179.2zM197.44 512c0-19.84-19.136-35.84-43.904-35.84H108.8c-24.768 0-44.8 16-44.8 35.84s20.032 35.904 44.8 35.904h44.736c24.768 0 43.904-16.064 43.904-35.904zM512 198.464c19.776 0 35.84-20.032 35.84-44.8v-44.8C547.84 84.032 531.84 64 512 64s-35.904 20.032-35.904 44.8v44.8c0 24.768 16.128 44.864 35.904 44.864z m0 627.136c-19.776 0-35.904 20.032-35.904 44.8v44.736C476.096 940.032 492.16 960 512 960s35.84-20.032 35.84-44.8v-44.736c0-24.768-16.064-44.864-35.84-44.864z m329.92-592.832c17.472-17.536 20.288-43.072 6.4-57.024-14.016-14.016-39.488-11.2-57.024 6.336-4.736 4.864-26.496 26.496-31.36 31.36-17.472 17.472-20.288 43.008-6.336 57.024 13.952 14.016 39.488 11.2 57.024-6.336 4.8-4.864 26.496-26.56 31.296-31.36zM213.376 759.936c-4.864 4.8-26.56 26.624-31.36 31.36-17.472 17.472-20.288 42.944-6.4 56.96 14.016 13.952 39.552 11.2 57.024-6.336 4.8-4.736 26.56-26.496 31.36-31.36 17.472-17.472 20.288-43.008 6.336-56.96-14.016-13.952-39.552-11.072-56.96 6.336z m19.328-577.92c-17.536-17.536-43.008-20.352-57.024-6.336-14.08 14.016-11.136 39.488 6.336 57.024 4.864 4.864 26.496 26.56 31.36 31.424 17.536 17.408 43.008 20.288 56.96 6.336 14.016-14.016 11.264-39.488-6.336-57.024-4.736-4.864-26.496-26.56-31.296-31.424z m527.168 628.608c4.864 4.864 26.624 26.624 31.36 31.424 17.536 17.408 43.072 20.224 57.088 6.336 13.952-14.016 11.072-39.552-6.4-57.024-4.864-4.8-26.56-26.496-31.36-31.36-17.472-17.408-43.072-20.288-57.024-6.336-13.952 14.016-11.008 39.488 6.336 56.96z" p-id="4027"></path></svg></button><button title="Default to system" class="__dumi-default-dark-auto "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="11002" width="22" height="22"><path d="M127.658667 492.885333c0-51.882667 10.24-101.717333 30.378666-149.162666s47.786667-88.064 81.92-122.538667 75.093333-61.781333 122.538667-81.92 96.938667-30.378667 149.162667-30.378667 101.717333 10.24 149.162666 30.378667 88.405333 47.786667 122.88 81.92 61.781333 75.093333 81.92 122.538667 30.378667 96.938667 30.378667 149.162666-10.24 101.717333-30.378667 149.162667-47.786667 88.405333-81.92 122.88-75.093333 61.781333-122.88 81.92-97.28 30.378667-149.162666 30.378667-101.717333-10.24-149.162667-30.378667-88.064-47.786667-122.538667-81.92-61.781333-75.093333-81.92-122.88-30.378667-96.938667-30.378666-149.162667z m329.045333 0c0 130.048 13.994667 244.394667 41.984 343.381334h12.970667c46.762667 0 91.136-9.216 133.461333-27.306667s78.848-42.666667 109.568-73.386667 54.954667-67.242667 73.386667-109.568 27.306667-86.698667 27.306666-133.461333c0-46.421333-9.216-90.794667-27.306666-133.12s-42.666667-78.848-73.386667-109.568-67.242667-54.954667-109.568-73.386667-86.698667-27.306667-133.461333-27.306666h-11.605334c-28.672 123.562667-43.349333 237.909333-43.349333 343.722666z" p-id="11003"></path></svg></button></div></div></div><ul class="__dumi-default-menu-list"><li><a href="/blog/">大师兄 - 前端架构师</a></li></ul></div></div><ul role="slug-list" class="__dumi-default-layout-toc"><li title="ORM" data-depth="2"><a href="/blog/手把手带你写一个web框架/04.实战第3关完善功能/08#orm"><span>ORM</span></a></li><li title="Gorm" data-depth="2"><a href="/blog/手把手带你写一个web框架/04.实战第3关完善功能/08#gorm"><span>Gorm</span></a></li><li title="数据结构" data-depth="2"><a href="/blog/手把手带你写一个web框架/04.实战第3关完善功能/08#数据结构"><span>数据结构</span></a></li><li title="Dialector" data-depth="2"><a href="/blog/手把手带你写一个web框架/04.实战第3关完善功能/08#dialector"><span>Dialector</span></a></li><li title="Option" data-depth="2"><a href="/blog/手把手带你写一个web框架/04.实战第3关完善功能/08#option"><span>Option</span></a></li><li title="gorm.DB" data-depth="2"><a href="/blog/手把手带你写一个web框架/04.实战第3关完善功能/08#gormdb"><span>gorm.DB</span></a></li><li title="Logger" data-depth="3"><a href="/blog/手把手带你写一个web框架/04.实战第3关完善功能/08#logger"><span>Logger</span></a></li><li title="ConnPool" data-depth="3"><a href="/blog/手把手带你写一个web框架/04.实战第3关完善功能/08#connpool"><span>ConnPool</span></a></li><li title="callbacks" data-depth="3"><a href="/blog/手把手带你写一个web框架/04.实战第3关完善功能/08#callbacks"><span>callbacks</span></a></li><li title="源码" data-depth="2"><a href="/blog/手把手带你写一个web框架/04.实战第3关完善功能/08#源码"><span>源码</span></a></li><li title="gorm.Open" data-depth="3"><a href="/blog/手把手带你写一个web框架/04.实战第3关完善功能/08#gormopen"><span>gorm.Open</span></a></li><li title="db.Create" data-depth="3"><a href="/blog/手把手带你写一个web框架/04.实战第3关完善功能/08#dbcreate"><span>db.Create</span></a></li><li title="小结" data-depth="2"><a href="/blog/手把手带你写一个web框架/04.实战第3关完善功能/08#小结"><span>小结</span></a></li><li title="思考题" data-depth="3"><a href="/blog/手把手带你写一个web框架/04.实战第3关完善功能/08#思考题"><span>思考题</span></a></li></ul><div class="__dumi-default-layout-content"><div class="markdown"><h1 id="25gorm上数据库的使用必不可少"><a aria-hidden="true" tabindex="-1" href="/blog/手把手带你写一个web框架/04.实战第3关完善功能/08#25gorm上数据库的使用必不可少"><span class="icon icon-link"></span></a>25｜GORM（上）：数据库的使用必不可少</h1><p>你好，我是轩脉刃。</p><p>一个 Web 应用，有很大部分功能是对数据库中数据的获取和加工。比如一个用户管理系统，我们在业务代码中需要频繁增加用户、删除用户、修改用户等，而用户的数据都存放在数据库中。所以对数据库的增删改查，是做 Web 应用必须实现的功能。而我们的 hade 框架如何更好地支持数据库操作呢？这两节课我们就要讨论这个内容。</p><h2 id="orm"><a aria-hidden="true" tabindex="-1" href="/blog/手把手带你写一个web框架/04.实战第3关完善功能/08#orm"><span class="icon icon-link"></span></a>ORM</h2><p>提到数据库，就不得不提ORM了，有的同学一接触 Web 开发，就上手使用 ORM 了，这里我们要明确一点：ORM 并不等同于数据库操作。</p><p>数据库操作，本质上是使用 SQL 语句对数据库发送命令来操作数据。而 ORM 是一种将数据库中的数据映射到代码中对象的技术，这个技术的需求出发点就是，<strong>代码中有类，数据库中有数据表，我们可以将类和数据表进行映射，从而使得在代码中操作类就等同于操作数据库中的数据表了</strong>。</p><p>ORM 这个概念出现的时间无从考究了，基本上从面向对象的编程思想出来的时候就有讨论了。但是到现在，是否要使用 ORM 的讨论也一直没有停止。</p><p>不支持使用 ORM 的阵营的观点基本上是使用 ORM 会影响性能，且会让使用者不了解底层的具体最终拼接出来的SQL，容易造成用不上索引或者最终拼接错误的情况。而支持使用 ORM 的阵营的观点主要是它能切切实实加速应用开发。</p><p>就我个人的观点和经验，我还是支持使用 ORM 的。我认为 ORM 不仅仅是一种映射技术，也是一种建模思想。<strong>因为数据库是和业务紧密关联起来的，建立数据库表结构的时候，也是建立了一个业务模型</strong>。使用代码中的类定义，比如定义了一个 User 类，基本上就定义了一个 User 表，这样也是一个建立业务模型的过程。</p><p>其实不论 ORM 的讨论如何激烈，基本上各个语言都已经有了 ORM 的实现，比如 Java 的 Hibernate、PHP 的 Doctrine、Ruby 的 ActiveRecord。而在 Golang 中，现在最流行的 ORM 库是国人的开源项目<a target="_blank" rel="noopener noreferrer" href="https://github.com/go-gorm/gorm">Gorm<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 。</p><p>Gorm 作者 Jinzhu 目前是字节跳动的员工，他在 GitHub 上开源共享了诸如 copier、configer 等开源项目，Gorm 目前 star 数有 26k 之多，使用 MIT 的许可证协议，项目启动于 2013 年，目前是 v2 版本。</p><p>这个 <strong>v2 版本对应 Gorm GitHub 上 v1.20 以上的 tag</strong>，这点我们要额外注意。因为网上的分析文章很多都是基于Gorm 的 v1 版本写的，但Gorm 的 v1 和 v2 版本相差比较大。所以在看 Gorm 文章的时候需要先明确下是什么版本。</p><p>我们的框架侧重于整合，站在巨人的肩膀上才更符合现代化框架的要求。基于此， hade 框架并不打算重新开发一套 ORM 框架，而是会直接融合 Gorm 框架成为我们容器中的一个服务 orm service。</p><p>版本选择的是 Gorm 截止 2021/10/23 日最新的 v1.21.16 的 tag。毕竟 Gorm 是个有一定体量的项目，而且理解它的重点部分源码的实现原理，对使用者来说非常重要，值得我们先花一章来学习理解。如何融合 Gorm，我们下节课继续学。</p><h2 id="gorm"><a aria-hidden="true" tabindex="-1" href="/blog/手把手带你写一个web框架/04.实战第3关完善功能/08#gorm"><span class="icon icon-link"></span></a>Gorm</h2><p>一个 ORM 库，最核心要了解两个部分。一个部分是数据库连接，它是怎么和数据库建立连接的，第二部分是数据库操作，即它是怎么操作数据库的。</p><p>我们看一个最精简的 Gorm 的使用例子：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">package main</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    import (</span></div><div class="token-line"><span class="token plain">      &quot;gorm.io/gorm&quot;</span></div><div class="token-line"><span class="token plain">      &quot;gorm.io/driver/mysql&quot;</span></div><div class="token-line"><span class="token plain">    )</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    // 定义一个 gorm 类</span></div><div class="token-line"><span class="token plain">    type User struct {</span></div><div class="token-line"><span class="token plain">       ID           uint</span></div><div class="token-line"><span class="token plain">       Name         string</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    func main() {</span></div><div class="token-line"><span class="token plain">      // 创建 mysql 连接</span></div><div class="token-line"><span class="token plain">      dsn := &quot;xxxxxxx&quot;</span></div><div class="token-line"><span class="token plain">      db, err := gorm.Open(mysql.Open(dsn), &amp;gorm.Config{})</span></div><div class="token-line"><span class="token plain">      ...</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">      // 插入一条数据</span></div><div class="token-line"><span class="token plain">      db.Create(&amp;User{Name: &quot;jianfengye&quot;})</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">      ...</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>main 函数，先创建一个 MySQL 连接，再插入一条数据，这个 User 数据是通过事先定义好的 User 结构来进行设置的。<strong>其中的 gorm.Open 就是一个快速连接数据库的接口，而后续的 Create 是如何操作数据库的接口</strong>。</p><p>我们今天的任务就是理解这几行代码的实现原理，后面会不断拿这个例子举例。</p><h2 id="数据结构"><a aria-hidden="true" tabindex="-1" href="/blog/手把手带你写一个web框架/04.实战第3关完善功能/08#数据结构"><span class="icon icon-link"></span></a>数据结构</h2><p>先把重点放在理解这个 Open 函数上，因为这个函数包含了 Gorm 中关键的几个对象，把这些关键数据结构一一理解透，再跟踪具体的源码能事半功倍。另外也推荐你边看边自己画出这几个关键参数的关系，非常有助于理解和记忆，每个参数讲完之后我也会展示一下我画的分析图供你参考。</p><p>来看它的源码定义：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// 初始化数据库连接</span></div><div class="token-line"><span class="token plain">    func Open(dialector Dialector, opts ...Option) (db *DB, err error)</span></div></pre></div><p>这个初始化数据库链接的Open函数有两个参数dialector、opts，和两个返回值gorm.DB、error。我们先理解下这几个参数的意义。</p><h2 id="dialector"><a aria-hidden="true" tabindex="-1" href="/blog/手把手带你写一个web框架/04.实战第3关完善功能/08#dialector"><span class="icon icon-link"></span></a>Dialector</h2><p>第一个参数是 Dialector，这是什么呢？它代表数据库连接器。这里也是一个面向接口编程的思想，连接器结构 Dialector 是一个接口，代表如果你要使用 Gorm 来连接你的数据库，那么，只需要实现这个接口定义的所有方法，就可以使用 Gorm 来操作你的数据库了。</p><p>所以，这个接口 Dialecotor 中定义的所有方法，都是在后续的查询、更新、数据库迁移等操作中会使用到的。具体每个方法在哪里使用到的，如果你感兴趣可以跟踪下去，如果你不感兴趣也无所谓，只需要记得在后续某个 gorm 接口的具体实现中会用到就行。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// Dialector GORM database dialector</span></div><div class="token-line"><span class="token plain">    type Dialector interface {</span></div><div class="token-line"><span class="token plain">       Name() string // 连接器名称</span></div><div class="token-line"><span class="token plain">       Initialize(*DB) error // 连接器初始化连接方法</span></div><div class="token-line"><span class="token plain">       Migrator(db *DB) Migrator // 数据库迁移方法</span></div><div class="token-line"><span class="token plain">       DataTypeOf(*schema.Field) string // 类中每个字段的类型对应到 sql 语句</span></div><div class="token-line"><span class="token plain">       DefaultValueOf(*schema.Field) clause.Expression // 每个字段的默认值对应到 sql 语句</span></div><div class="token-line"><span class="token plain">       BindVarTo(writer clause.Writer, stmt *Statement, v interface{}) // 使用预编译模式的时候使用</span></div><div class="token-line"><span class="token plain">       QuoteTo(clause.Writer, string) // 将类中的注释对应到 sql 语句中</span></div><div class="token-line"><span class="token plain">       Explain(sql string, vars ...interface{}) string // 将有占位符的 sql 解析为无占位符 sql，常用于日志打印等</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>不同的数据库有不同的 Dialector 实现，我们称之为“驱动”。每个数据库的驱动，都有一个 git 地址进行存放。目前 gorm 官方支持五种数据库驱动：</p><ul><li>MySQL 的 Gorm 驱动地址为 <a target="_blank" rel="noopener noreferrer" href="http://gorm.io/driver/mysql"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> gorm.io/driver/mysql</li><li>Postgres 的 Gorm 驱动地址为 gorm.io/driver/postgres</li><li>SQLite 的 gorm 驱动地址为 gorm.io/driver/sqlite</li><li>SQL Server 的 gorm 驱动地址为 gorm.io/driver/sqlserver</li><li>ClickHouse 的 gorm 驱动地址为 gorm.io/driver/clickhouse</li></ul><p><strong>如果要创建对应数据库的连接，要先引入对应的驱动</strong>。而在对应的驱动库中都有一个约定的 Open 方法，来创建一个新的数据库驱动。比如要创建 MySQL 的连接，使用下面这个例子：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">import (</span></div><div class="token-line"><span class="token plain">      &quot;gorm.io/driver/mysql&quot;</span></div><div class="token-line"><span class="token plain">      &quot;gorm.io/gorm&quot;</span></div><div class="token-line"><span class="token plain">    )</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    // 创建连接</span></div><div class="token-line"><span class="token plain">    dsn := &quot;gorm:gorm@tcp(localhost:9910)/gorm?charset=utf8&amp;parseTime=True&amp;loc=Local&quot;</span></div><div class="token-line"><span class="token plain">    db, err := gorm.Open(mysql.Open(dsn), &amp;gorm.Config{})</span></div></pre></div><p>我们看到这里有个 mysql.Open，就是创建MySQL 的 Gorm 驱动用的。而这个 Open 函数只有一个字符串参数 DSN，这个参数可能有的同学还不是很了解，我们一起研究下。</p><h4 id="dsn"><a aria-hidden="true" tabindex="-1" href="/blog/手把手带你写一个web框架/04.实战第3关完善功能/08#dsn"><span class="icon icon-link"></span></a>DSN</h4><p>DSN 全称叫 Data Source Name，数据库的源名称。</p><p>DSN 定义了一个数据库的连接方式及信息，包含用户名、密码、数据库 IP、数据库端口、数据库字符集、数据库时区等信息。可以说<strong>一个 DSN 就是一个数据源的描述</strong>。但是 DSN 并没有明确的官方文档要求其格式，每个语言、每个平台都可以自己定义 DSN 格式，只要定义和解析能对得上就行。</p><p>在社区中，大家普遍会按照以下这种格式来进行定义：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">scheme://username:password@host:port/dbname?param1=value1&amp;param2=value2&amp;...</span></div></pre></div><p>比如通过 Unix 的 socket 句柄连接本机 MySQL：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">mysql://user@unix(/path/to/socket)/dbname</span></div></pre></div><p>通过 TCP 连接远端 postgres：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">pgsql://user:pass@tcp(localhost:5555)/dbname</span></div></pre></div><p>DSN在gorm中的使用就如下图所示，我们使用这个dsn结合具体的驱动来生成Open函数的第一个参数，数据库连接器。<br/><img src="https://static001.geekbang.org/resource/image/64/e0/6484f9f91a60120d485a0ea2020fb7e0.jpg?wh=2185x1256" alt=""/></p><p>在具体使用中，我们当然可以直接执行字符串拼接，来拼接出一个 DSN，但是我们更希望能<strong>通过定义一个 Golang 的数据结构自动拼接出一个 DSN，或者是从一个 DSN 字符串反序列化生成这个数据结构</strong>。</p><p>在 Golang 中有一个第三方库 github.com/go-sql-driver/mysql 就提供了这样的功能。这个库用来对 Go 中的 SQL 提供 MySQL 驱动，其中定义了一个 Config 结构，能映射到 DSN 字符串。Config 结构中一些比较重要的字段说明，我写在注释中了：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">type Config struct {</span></div><div class="token-line"><span class="token plain">       User             string            // 用户名</span></div><div class="token-line"><span class="token plain">       Passwd           string            // 密码 (requires User)</span></div><div class="token-line"><span class="token plain">       Net              string            // 网络类型</span></div><div class="token-line"><span class="token plain">       Addr             string            // 地址 (requires Net)</span></div><div class="token-line"><span class="token plain">       DBName           string            // 数据库名</span></div><div class="token-line"><span class="token plain">       Params           map[string]string // 其他连接参数</span></div><div class="token-line"><span class="token plain">       Collation        string            // 字符集</span></div><div class="token-line"><span class="token plain">       Loc              *time.Location    // 时区</span></div><div class="token-line"><span class="token plain">       MaxAllowedPacket int               // 最大包大小</span></div><div class="token-line"><span class="token plain">       ServerPubKey     string            // 连接公钥名称</span></div><div class="token-line"><span class="token plain">       pubKey           *rsa.PublicKey    // 连接公钥 key</span></div><div class="token-line"><span class="token plain">       TLSConfig        string            // TLS 的配置名称</span></div><div class="token-line"><span class="token plain">       tls              *tls.Config       // TLS 的配置项</span></div><div class="token-line"><span class="token plain">       Timeout          time.Duration     // 连接超时</span></div><div class="token-line"><span class="token plain">       ReadTimeout      time.Duration     // 读超时</span></div><div class="token-line"><span class="token plain">       WriteTimeout     time.Duration     // 写超时</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">       ...</span></div><div class="token-line"><span class="token plain">       CheckConnLiveness       bool // 在使用连接前确认连接可用</span></div><div class="token-line"><span class="token plain">       ...</span></div><div class="token-line"><span class="token plain">       ParseTime               bool // 是否解析时间格式</span></div><div class="token-line"><span class="token plain">       ...</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>从 DSN 到这个 Config 结构，我们使用 github.com/go-sql-driver/mysql 的 <a target="_blank" rel="noopener noreferrer" href="https://github.com/go-sql-driver/mysql/blob/master/dsn.go">ParseDSN<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> ，而从 Config 结构到 DSN 我们使用 <a target="_blank" rel="noopener noreferrer" href="https://github.com/go-sql-driver/mysql/blob/master/dsn.go">FormatDSN<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 方法：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// 解析 dsn</span></div><div class="token-line"><span class="token plain">    func ParseDSN(dsn string) (cfg *Config, err error) </span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    // 生成 dsn</span></div><div class="token-line"><span class="token plain">    func (cfg *Config) FormatDSN() string</span></div></pre></div><p>这两个方法都先记下，下节课会用到。</p><h2 id="option"><a aria-hidden="true" tabindex="-1" href="/blog/手把手带你写一个web框架/04.实战第3关完善功能/08#option"><span class="icon icon-link"></span></a>Option</h2><p>第一个初始化数据库的参数 dialector 以及之前必要的驱动引入相关参数DSN，就讲解到这里。我们回头继续看 Open 函数：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// 初始化数据库连接</span></div><div class="token-line"><span class="token plain">    func Open(dialector Dialector, opts ...Option) (db *DB, err error)</span></div></pre></div><p>第二个参数 opts是 Option 的可变参数，而这个 Option 是一个实现了 Apply 和 AfterInitialize 的接口：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// Option 接口</span></div><div class="token-line"><span class="token plain">    type Option interface {</span></div><div class="token-line"><span class="token plain">       Apply(*Config) error</span></div><div class="token-line"><span class="token plain">       AfterInitialize(*DB) error</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>这种可变参数如何使用呢？我们看下 Open 的源码：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// Open 初始化 DB 的 Session</span></div><div class="token-line"><span class="token plain">    func Open(dialector Dialector, opts ...Option) (db *DB, err error) {</span></div><div class="token-line"><span class="token plain">       config := &amp;Config{}</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">       ...</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">       for _, opt := range opts {</span></div><div class="token-line"><span class="token plain">          if opt != nil {</span></div><div class="token-line"><span class="token plain">             // 先调用 Apply 初始化 Config</span></div><div class="token-line"><span class="token plain">             if err := opt.Apply(config); err != nil {</span></div><div class="token-line"><span class="token plain">                return nil, err</span></div><div class="token-line"><span class="token plain">             }</span></div><div class="token-line"><span class="token plain">             // Open 最后结束后调用 AfterInitialize</span></div><div class="token-line"><span class="token plain">             defer func(opt Option) {</span></div><div class="token-line"><span class="token plain">                if errr := opt.AfterInitialize(db); errr != nil {</span></div><div class="token-line"><span class="token plain">                   err = errr</span></div><div class="token-line"><span class="token plain">                }</span></div><div class="token-line"><span class="token plain">             }(opt)</span></div><div class="token-line"><span class="token plain">          }</span></div><div class="token-line"><span class="token plain">       }</span></div></pre></div><p>可以看到，对每一个option，我们直接调用它的Apply方法来对数据库的配置config进行修改。Option 的这种编程方式常用在初始化一个比较复杂的结构里面。</p><p>比如这里在 Gorm 中，要初始化一个 Gorm 的构造配置 gorm.Config，而这个 Config 结构有非常多的配置项，我们希望在创建初始化的时候，能对这个配置进行调整。所以就可以在 Option 方法中再定义一个 Apply 方法，它的参数是 gorm.Config 指针：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">func (c *Config) Apply(config *Config) error</span></div></pre></div><p>这样，可以遍历所有的 Option，挨个调用它们的 Apply 方法对 Config 进行设置，最终我们获取的就是经过所有 Option 处理后的 Config。</p><p>这种 Option 的编程方法在 Golang 中十分常用，要好好掌握，下一节课，我们也会用这种方式为 hade 的 ORM 服务来注册参数。</p><p>Gorm 这里还有一个比较巧妙的设计，Config 结构本身也实现了 Option 接口。按照这个设计实现之后，你会发现，Config 本身也可以作为一个 Option 在 Open 的第二个参数中出现。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">func (c *Config) Apply(config *Config) error {</span></div><div class="token-line"><span class="token plain">       if config != c {</span></div><div class="token-line"><span class="token plain">          *config = *c</span></div><div class="token-line"><span class="token plain">       }</span></div><div class="token-line"><span class="token plain">       return nil</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    func (c *Config) AfterInitialize(db *DB) error {</span></div><div class="token-line"><span class="token plain">       if db != nil {</span></div><div class="token-line"><span class="token plain">          for _, plugin := range c.Plugins {</span></div><div class="token-line"><span class="token plain">             if err := plugin.Initialize(db); err != nil {</span></div><div class="token-line"><span class="token plain">                return err</span></div><div class="token-line"><span class="token plain">             }</span></div><div class="token-line"><span class="token plain">          }</span></div><div class="token-line"><span class="token plain">       }</span></div><div class="token-line"><span class="token plain">       return nil</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>讲到这里相信你能画出第二个参数的要点了，Gorm实现的时候使用的是gorm.Config，之所以它可以匹配Open函数定义的Option的参数的原因是Config结构本身也实现了Option接口。<br/><img src="https://static001.geekbang.org/resource/image/de/76/deda009d08f4bf80e384f85dc0d9ce76.jpg?wh=2185x1256" alt=""/></p><p>通过上图我们就理解了Open函数在使用的时候，第一个参数和第二个参数是如何对应函数定义两个参数的了。</p><p>所以 Gorm 官方连接<a target="_blank" rel="noopener noreferrer" href="https://gorm.io/zh_CN/docs/connecting_to_the_database.html">MySQL的示例<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>就很好理解了，看注释：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">import (</span></div><div class="token-line"><span class="token plain">      &quot;gorm.io/driver/mysql&quot;</span></div><div class="token-line"><span class="token plain">      &quot;gorm.io/gorm&quot;</span></div><div class="token-line"><span class="token plain">    )</span></div><div class="token-line"><span class="token plain">    func main() {</span></div><div class="token-line"><span class="token plain">      // 参考 https://github.com/go-sql-driver/mysql#dsn-data-source-name 获取详情</span></div><div class="token-line"><span class="token plain">      dsn := &quot;user:pass@tcp(127.0.0.1:3306)/dbname?charset=utf8mb4&amp;parseTime=True&amp;loc=Local&quot;</span></div><div class="token-line"><span class="token plain">      // 第一个参数是 dialector</span></div><div class="token-line"><span class="token plain">      // 第二个参数是 option，但是由于 gorm.Config 实现了 option，所以可以这么使用</span></div><div class="token-line"><span class="token plain">      db, err := gorm.Open(mysql.Open(dsn), &amp;gorm.Config{})</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><h2 id="gormdb"><a aria-hidden="true" tabindex="-1" href="/blog/手把手带你写一个web框架/04.实战第3关完善功能/08#gormdb"><span class="icon icon-link"></span></a>gorm.DB</h2><p>两个传入参数讲完了，我们继续看Open 的返回结构，除了常规的 error 外，还有一个 gorm.DB 的结构指针，定义如下：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">type DB struct {</span></div><div class="token-line"><span class="token plain">    	*Config</span></div><div class="token-line"><span class="token plain">    	Error        error</span></div><div class="token-line"><span class="token plain">    	RowsAffected int64</span></div><div class="token-line"><span class="token plain">    	Statement    *Statement</span></div><div class="token-line"><span class="token plain">    	// Has unexported fields.</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>它具有丰富的操作数据库的方法，比如增加数据的 Create 方法、更新数据的 Update 方法。</p><p>我们研究下 gorm.DB 的结构，它嵌套了一层 gorm.Config 结构，里面有几个关键字段：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// Config GORM config</span></div><div class="token-line"><span class="token plain">    type Config struct {</span></div><div class="token-line"><span class="token plain">       ...</span></div><div class="token-line"><span class="token plain">       // gorm 的日志输出</span></div><div class="token-line"><span class="token plain">       Logger logger.Interface</span></div><div class="token-line"><span class="token plain">       ...</span></div><div class="token-line"><span class="token plain">       </span></div><div class="token-line"><span class="token plain">       // db 的具体连接</span></div><div class="token-line"><span class="token plain">       ConnPool ConnPool</span></div><div class="token-line"><span class="token plain">       // db 驱动器</span></div><div class="token-line"><span class="token plain">       Dialector</span></div><div class="token-line"><span class="token plain">       ...</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">       callbacks  *callbacks  // 回调方法</span></div><div class="token-line"><span class="token plain">       ...</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>其中的 Logger 、 ConnPool 和 Callback字段，值得详细研究一下。</p><h3 id="logger"><a aria-hidden="true" tabindex="-1" href="/blog/手把手带你写一个web框架/04.实战第3关完善功能/08#logger"><span class="icon icon-link"></span></a>Logger</h3><p>我们从 Open 看到了，一个 gorm.DB 结构就代表一个数据库连接，而这个数据库连接的所有日志操作输出在哪里呢？就是通过这个 Logger 字段配置的。</p><p>Logger 字段是一个接口，表示如果有一个实现了 logger.Interface 接口的日志输出类，我就能让这个 DB 的所有数据库操作的日志，都输出到这个类中。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// Interface logger interface</span></div><div class="token-line"><span class="token plain">    type Interface interface {</span></div><div class="token-line"><span class="token plain">       LogMode(LogLevel) Interface</span></div><div class="token-line"><span class="token plain">       Info(context.Context, string, ...interface{})</span></div><div class="token-line"><span class="token plain">       Warn(context.Context, string, ...interface{})</span></div><div class="token-line"><span class="token plain">       Error(context.Context, string, ...interface{})</span></div><div class="token-line"><span class="token plain">       Trace(ctx context.Context, begin time.Time, fc func() (sql string, rowsAffected int64), err error)</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>Gorm 使用 Logger 接口的方法，和我们 hade 框架定义 Logger 服务的方法如出一辙，它<strong>不定义具体的实现类，而是定义了具体的接口</strong>。所以下一节课，我们将 Gorm 融合进入 hade 框架的时候，要做的事情就是封装一个实现了 Gorm 的 logger.Interface 接口的实现类，而这个实现类的具体实现方法，使用 hade 框架的日志服务类来实现。</p><h3 id="connpool"><a aria-hidden="true" tabindex="-1" href="/blog/手把手带你写一个web框架/04.实战第3关完善功能/08#connpool"><span class="icon icon-link"></span></a>ConnPool</h3><p>ConnPool 也定义了一个接口，它代表数据库的真实连接所在的连接池。这个接口的定义，我认为是Gorm 中最精妙的一个地方了：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// ConnPool db conns pool interface</span></div><div class="token-line"><span class="token plain">    type ConnPool interface {</span></div><div class="token-line"><span class="token plain">       PrepareContext(ctx context.Context, query string) (*sql.Stmt, error)</span></div><div class="token-line"><span class="token plain">       ExecContext(ctx context.Context, query string, args ...interface{}) (sql.Result, error)</span></div><div class="token-line"><span class="token plain">       QueryContext(ctx context.Context, query string, args ...interface{}) (*sql.Rows, error)</span></div><div class="token-line"><span class="token plain">       QueryRowContext(ctx context.Context, query string, args ...interface{}) *sql.Row</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>这个接口定义了四个方法，但它们并不是随便定义的，而是根据 Golang 标准库的 database/sql 的 Conn 结构来定义的，这是什么意思呢？</p><p>首先我们要知道，Golang 的标准库 database/sql 其实定义了一套数据库连接规范。官方的基本思想就是，数据库的种类非常多，我不可能对每一个数据库都实现一套定制化的类库，所以我定义一套基本数据结构和方法，并且提供每个数据库需要实现的驱动接口。<strong>使用者只需要实现驱动接口，就能使用这套基本数据结构和方法了</strong>。</p><p>是不是和前面说的 Gorm 的驱动逻辑一样？是的。Golang 中所有的 ORM 库，底层都是基于标准库的 database/sql 来实现数据库的连接和基本操作。只是在具体操作上，会封装一层逻辑，当使用不同驱动接口的时候，实现不一样的接口操作。</p><p>这里的 ConnPool 就是 Gorm 对 database/sql 的数据结构的封装。换句话说，开头的 Gorm 使用例子，在底层 database/sql 的简要实现大致如下：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">package main</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    import (</span></div><div class="token-line"><span class="token plain">    	&quot;database/sql&quot;</span></div><div class="token-line"><span class="token plain">    )</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    func main() {</span></div><div class="token-line"><span class="token plain">    	</span></div><div class="token-line"><span class="token plain">    	dsn := &quot;xxxx&quot;</span></div><div class="token-line"><span class="token plain">    	...</span></div><div class="token-line"><span class="token plain">    	db, err = sql.Open(&quot;mysql&quot;, *dsn)</span></div><div class="token-line"><span class="token plain">    	...</span></div><div class="token-line"><span class="token plain">        </span></div><div class="token-line"><span class="token plain">        result, err := db.ExecContext(ctx, &quot;INSERT INTO user (name) values (&#x27;jianfengye&#x27;)&quot;)</span></div><div class="token-line"><span class="token plain">        ...</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>这里 sql.Open 创建的 sql.DB 结构，就包含 ConnPool 中定义的四个接口：PrepareContext、ExecContext、QueryContext、QueryRowContext。也就是说：<strong>database/sql 的 sql.DB 结构实现了 Gorm 库的 ConnPool 接口</strong>。</p><p>而实际上，database/sql 里面的 sql.DB 结构就是一个连接池结构，我们可以通过以下四个方法设置连接池的不同属性：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// 设置连接的最大空闲时长</span></div><div class="token-line"><span class="token plain">    func (db *DB) SetConnMaxIdleTime(d time.Duration)</span></div><div class="token-line"><span class="token plain">    // 设置连接的最大生命时长</span></div><div class="token-line"><span class="token plain">    func (db *DB) SetConnMaxLifetime(d time.Duration)</span></div><div class="token-line"><span class="token plain">    // 设置最大空闲连接数</span></div><div class="token-line"><span class="token plain">    func (db *DB) SetMaxIdleConns(n int)</span></div><div class="token-line"><span class="token plain">    // 设置最大打开连接数</span></div><div class="token-line"><span class="token plain">    func (db *DB) SetMaxOpenConns(n int)</span></div></pre></div><p>所以 gorm.DB 里面的 ConnPool 实际上存放的就是 database/sql 的 sql.DB 结构。</p><h3 id="callbacks"><a aria-hidden="true" tabindex="-1" href="/blog/手把手带你写一个web框架/04.实战第3关完善功能/08#callbacks"><span class="icon icon-link"></span></a>callbacks</h3><p>最后看 gorm.DB 里面的 callbacks 字段，它存放的是所有具体函数的调用方法。callback 指针指向的数据结构也是叫做同名的 callbacks：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// callbacks gorm callbacks manager</span></div><div class="token-line"><span class="token plain">    type callbacks struct {</span></div><div class="token-line"><span class="token plain">       processors map[string]*processor</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>它里面使用的 map 包含多个 processor。一个 processor 就是一种操作的处理器。processer 的结构定义为：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">type processor struct {</span></div><div class="token-line"><span class="token plain">       db        *DB // 对应的 gorm.DB</span></div><div class="token-line"><span class="token plain">       Clauses   []string  // 处理器对应的 sql 片段</span></div><div class="token-line"><span class="token plain">       fns       []func(*DB) // 这个处理器对应的处理函数</span></div><div class="token-line"><span class="token plain">       callbacks []*callback // 这个处理器对应的回调函数，生成 fns</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>开头的那个例子，我们调用了 gorm.DB 的 Create 方法，它会去 gorm.DB 的 callbacks 中的 processors 里，寻找 key 为“create”的处理器 processor。然后逐个调用处理器中设置好的 fns。下面分析源码的时候也会看到具体的实现逻辑。<br/><img src="https://static001.geekbang.org/resource/image/59/9c/591e738e8aa8af160fac58fd44d8639c.jpg?wh=2185x1256" alt=""/></p><h2 id="源码"><a aria-hidden="true" tabindex="-1" href="/blog/手把手带你写一个web框架/04.实战第3关完善功能/08#源码"><span class="icon icon-link"></span></a>源码</h2><p>现在理解了 Gorm 在创建连接过程中涉及的几个关键对象，我们就再从源码开始梳理一下 Gorm 的核心逻辑，理解下 Gorm 是怎么使用 Open 创建数据库连接、怎么使用创建的数据库连接的 Create 方法来创建一条数据的。再把开头官网的例子拿出来。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">package main</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    import (</span></div><div class="token-line"><span class="token plain">      &quot;gorm.io/gorm&quot;</span></div><div class="token-line"><span class="token plain">      &quot;gorm.io/driver/mysql&quot;</span></div><div class="token-line"><span class="token plain">    )</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    type Product struct {</span></div><div class="token-line"><span class="token plain">      gorm.Model</span></div><div class="token-line"><span class="token plain">      Code  string</span></div><div class="token-line"><span class="token plain">      Price uint</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    func main() {</span></div><div class="token-line"><span class="token plain">      dsn := &quot;xxxxxxx&quot;</span></div><div class="token-line"><span class="token plain">      db, err := gorm.Open(mysql.Open(dsn), &amp;gorm.Config{})</span></div><div class="token-line"><span class="token plain">      if err != nil {</span></div><div class="token-line"><span class="token plain">        panic(&quot;failed to connect database&quot;)</span></div><div class="token-line"><span class="token plain">      }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">      ...</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">      // Create</span></div><div class="token-line"><span class="token plain">      db.Create(&amp;Product{Code: &quot;D42&quot;, Price: 100})</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">      ...</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>用第一节课教的思维导图的方式来分析这个 Gorm 的主流程，主要就是 gorm.Open 和 db.Create 两个方法。</p><h3 id="gormopen"><a aria-hidden="true" tabindex="-1" href="/blog/手把手带你写一个web框架/04.实战第3关完善功能/08#gormopen"><span class="icon icon-link"></span></a>gorm.Open</h3><p>首先是 gorm.Open：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">db, err := gorm.Open(mysql.Open(dsn), &amp;gorm.Config{})</span></div></pre></div><p>我们将函数源码分为四个大步：<br/><img src="https://static001.geekbang.org/resource/image/a9/cf/a9afa90a5dba63aa3f2c341c47517ecf.png?wh=1356x1364" alt=""/></p><p>第一大步，初始化 gorm.Config 结构。通过使用参数中的 Option 可变参数的 Apply 接口，对最终的配置结构 gorm.Config进行相应的修改，其中包括修改输出的 Logger 结构。</p><p>第二步，初始化 gorm.DB 结构：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">db = &amp;DB{Config: config, clone: 1}</span></div></pre></div><p>第三步，初始化 gorm.DB 的 callbacks。<br/><img src="https://static001.geekbang.org/resource/image/f4/4a/f482ff99aa62eb3cd3991867d967f74a.png?wh=1920x814" alt=""/></p><p>这里我们只拆解了这个例子的 create 函数相关的 callback。核心的关键函数在 Gorm 库 callback.go 的 RegisterDefaultCallbacks 方法。比如下列的代码，就是创建 create 相关的执行方法 fns：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">createCallback := db.Callback().Create()</span></div><div class="token-line"><span class="token plain">    createCallback.Match(enableTransaction).Register(&quot;gorm:begin_transaction&quot;, BeginTransaction)</span></div><div class="token-line"><span class="token plain">    createCallback.Register(&quot;gorm:before_create&quot;, BeforeCreate)</span></div><div class="token-line"><span class="token plain">    createCallback.Register(&quot;gorm:save_before_associations&quot;, SaveBeforeAssociations(true))</span></div><div class="token-line"><span class="token plain">    createCallback.Register(&quot;gorm:create&quot;, Create(config))</span></div><div class="token-line"><span class="token plain">    createCallback.Register(&quot;gorm:save_after_associations&quot;, SaveAfterAssociations(true))</span></div><div class="token-line"><span class="token plain">    createCallback.Register(&quot;gorm:after_create&quot;, AfterCreate)</span></div><div class="token-line"><span class="token plain">    createCallback.Match(enableTransaction).Register(&quot;gorm:commit_or_rollback_transaction&quot;, CommitOrRollbackTransaction)</span></div><div class="token-line"><span class="token plain">    if len(config.CreateClauses) == 0 {</span></div><div class="token-line"><span class="token plain">       config.CreateClauses = createClauses</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    createCallback.Clauses = config.CreateClauses</span></div></pre></div><p>我们可以看到，Gorm 在一个 create 方法，定义了 7 个执行方法 fns，分别是：BeginTransaction、BeforeCreate、SaveBeforeAssociations、Create、SaveAfterAssociations、AfterCreate、CommitOrRollbackTransaction。这七个执行方法就是按照顺序，从上到下每个 Create 函数都会执行的方法。</p><p>其中关注一下 Create 方法，它又分为五个步骤：<br/><img src="https://static001.geekbang.org/resource/image/74/97/74168a832a7ea27fc84548cc980d1297.png?wh=1920x719" alt=""/></p><p>我们看到了熟悉的 ExecContent 函数，这个就对应上了 Golang 标准库的 database/sql 中 sql.DB 的 ExecContext 方法。原来它藏在这里！</p><p>那前面说的 database/sql 的 sql.DB 的 Open 方法，又放在哪里呢？就在 gorm.Open 的第四大步中：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">db.ConnPool, err = sql.Open(dialector.DriverName, dialector.DSN)</span></div></pre></div><p>将 database/sql 中生成的 sql.DB 结构，设置在了 gorm.DB 的 ConnPool 上。</p><h3 id="dbcreate"><a aria-hidden="true" tabindex="-1" href="/blog/手把手带你写一个web框架/04.实战第3关完善功能/08#dbcreate"><span class="icon icon-link"></span></a>db.Create</h3><p>下面再来看 gorm.DB 的 Create 方法。它的任务就很简单了：触发启动 processor 中的 fns 方法。具体最核心的代码就在 Gorm 的 callback.go 中的 Execute 函数里。<br/><img src="https://static001.geekbang.org/resource/image/d4/7a/d41214f972f885c9c18da6aeb7e2e77a.png?wh=1920x566" alt=""/></p><p>可以看到，在 Execute 函数中，最核心的是遍历 fns，调用 fn(db) 方法，其中就有我们前面定义的 Create 方法了，也就是执行了 database/sql 的 db.ExecContext 方法。</p><p>这里我们就根据思维导图找到了 Gorm 封装的 database/sql 的两个关键步骤：</p><ul><li>sql.Open</li><li>db.ExecContext</li></ul><p>理解了这一点，就基本理解了 Gorm 最核心的实现原理了。<br/><img src="https://static001.geekbang.org/resource/image/ee/88/eec03fdb85d622202f8e7c8ac7e70488.jpg?wh=4861x3258" alt=""/></p><p>当然 Gorm 中还有一个部分，是将我们定义的 Model解析成为 SQL 语句，这里又是 Gorm 定义的一套非常庞大的数据结构支撑的了，其中包括 Statement、Schema、Field、Relationship 等和数据表操作相关的数据结构。</p><p>这需要用另外一个篇幅来描述了。不过这块 Model 解析，对我们下一章 hade 框架融合 Gorm 的影响并不大。有兴趣的同学可以追着上述 Create 方法中的 stmt.Parse 方法进一步分析。</p><p>今天我们还没有涉及代码修改，思维导图保存在 GitHub 上的 <a target="_blank" rel="noopener noreferrer" href="https://github.com/gohade/coredemo/tree/geekbang/25">geekbang/25<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 分支中根目录的 mysql.xmind 中了。</p><h2 id="小结"><a aria-hidden="true" tabindex="-1" href="/blog/手把手带你写一个web框架/04.实战第3关完善功能/08#小结"><span class="icon icon-link"></span></a>小结</h2><p>我们分析了 Gorm 的具体数据结构和创建连接的核心源码流程。想要检验自己是否理解这节课也很简单，你可以对照开头为 user 表插入一行的代码，看看能不能清晰分析出它的底层是如何封装标准库的 database/sql 来实现的。</p><p>我们在阅读 Gorm 源码的同时，也是在学习它的优秀编码方式，比如今天讲到的 Option 方式、定义驱动、ConnPool 定义实现标准库方法的接口。这些都是 Gorm 设计精妙的地方。</p><p>当然 Gorm 的代码远不是一篇文章能说透的。其中包含的 Model 解析，以及更多的具体细节实现，都得靠你在后续使用过程中多看<a target="_blank" rel="noopener noreferrer" href="https://gorm.io/zh_CN/">官网<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>、多思考、多解析，才能完全吃透这个库。</p><h3 id="思考题"><a aria-hidden="true" tabindex="-1" href="/blog/手把手带你写一个web框架/04.实战第3关完善功能/08#思考题"><span class="icon icon-link"></span></a>思考题</h3><p>GORM 有一个功能我非常喜欢，DryRun 空跑，这个设置是在 gorm.DB 结构中的。如果我们设置了 gorm.DB 的 DryRun，能让我在这个 DB 中的所有 SQL 操作并不真正执行，这个功能在调试的时候是非常有用的。你能再顺着思维导图，分析出 DryRun 是怎么做到这一点的么？</p><p>欢迎在留言区分享你的思考。感谢你的收听，如果你觉得今天的内容对你有所帮助，也欢迎分享给身边的朋友，邀请他一起学习。我们下节课见～</p></div><div class="__dumi-default-layout-footer-meta"><a target="_blank" rel="noopener noreferrer" href="https://github.com/GGwujun/blog/edit/master/docs/手把手带你写一个Web框架/04.实战第3关完善功能/08.md">在 GitHub 上编辑此页<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a><span data-updated-text="最后更新时间：">5/2/2022 10:56:58</span></div></div></div></div>
	<script>
  window.g_useSSR = true;
  window.g_initialProps = {};
	</script>

    <script>
      (function () {
        if (!location.port) {
          (function (i, s, o, g, r, a, m) {
            i["GoogleAnalyticsObject"] = r;
            (i[r] =
              i[r] ||
              function () {
                (i[r].q = i[r].q || []).push(arguments);
              }),
              (i[r].l = 1 * new Date());
            (a = s.createElement(o)), (m = s.getElementsByTagName(o)[0]);
            a.async = 1;
            a.src = g;
            m.parentNode.insertBefore(a, m);
          })(
            window,
            document,
            "script",
            "//www.google-analytics.com/analytics.js",
            "ga"
          );
          ga("create", "UA-149864185-1", "auto");
          ga("send", "pageview");
        }
      })();
    </script>
    <script src="/blog/umi.js"></script>
  </body>
</html>
