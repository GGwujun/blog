<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no"
    />
    <link rel="shortcut icon" type="image/x-icon" href="/logo.png" />
    <link rel="stylesheet" href="/blog/umi.css" />
    <script>
      window.routerBase = "/blog";
    </script>
    <script>
      //! umi version: 3.5.17
    </script>
    <script>
      !(function () {
        var e = localStorage.getItem("dumi:prefers-color"),
          t = window.matchMedia("(prefers-color-scheme: dark)").matches,
          r = ["light", "dark", "auto"];
        document.documentElement.setAttribute(
          "data-prefers-color",
          e === r[2] ? (t ? r[1] : r[0]) : r.indexOf(e) > -1 ? e : r[0]
        );
      })();
    </script>
    <title>24｜管理进程：如何设计完善的运行命令？</title>
  </head>
  <body>
    <div id="root"><div class="__dumi-default-layout" data-route="/手把手带你写一个web框架/04.实战第3关完善功能/07" data-show-sidemenu="true" data-show-slugs="true" data-site-mode="true" data-gapless="false"><div class="__dumi-default-navbar" data-mode="site"><button class="__dumi-default-navbar-toggle"></button><a class="__dumi-default-navbar-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog/">大师兄</a><nav><div class="__dumi-default-search"><input type="search" class="__dumi-default-search-input" value=""/><ul></ul></div><span>计算机基础<ul><li><a href="/blog/编译原理之美">编译原理之美</a></li><li><a href="/blog/编译原理实战">编译原理实战</a></li><li><a href="/blog/深入浅出计算机组成原理">深入浅出计算机组成原理</a></li><li><a href="/blog/详解http">详解http</a></li><li><a href="/blog/计算机网络通关29讲">计算机网络通关29讲</a></li><li><a href="/blog/网络排查案例课">网络排查案例课</a></li><li><a href="/blog/linux操作系统">linux操作系统</a></li><li><a href="/blog/linux性能优化实战">linux性能优化实战</a></li><li><a href="/blog/程序员数学基础">程序员数学基础</a></li><li><a href="/blog/趣谈网络协议">趣谈网络协议</a></li><li><a href="/blog/操作系统实战">操作系统实战</a></li><li><a href="/blog/软件工程之美">软件工程之美</a></li><li><a href="/blog/sql必知必会">sql必知必会</a></li><li><a href="/blog/操作系统实战45讲">操作系统实战45讲</a></li><li><a href="/blog/网络编程实战">网络编程实战</a></li></ul></span><span>算法<ul><li><a href="/blog/常用算法25讲">常用算法25讲</a></li><li><a href="/blog/数据结构与算法之美">数据结构与算法之美</a></li><li><a href="/blog/业务开发算法50讲">业务开发算法50讲</a></li><li><a href="/blog/动态规划面试宝典">动态规划面试宝典</a></li></ul></span><span>前端开发<ul><li><a href="/blog/浏览器工作原理与实践">浏览器工作原理与实践</a></li><li><a href="/blog/新时代产品经理进阶之路">新时代产品经理进阶之路</a></li><li><a href="/blog/全栈工程师修炼指南">全栈工程师修炼指南</a></li><li><a href="/blog/flutter核心技术与实战">flutter核心技术与实战</a></li><li><a href="/blog/java-script核心原理解析">java-script核心原理解析</a></li><li><a href="/blog/说透低代码">说透低代码</a></li><li><a href="/blog/nodejs应用开发实战">nodejs应用开发实战</a></li><li><a href="/blog/反爬虫兵法演绎20讲">反爬虫兵法演绎20讲</a></li><li><a href="/blog/reactnative新架构实战课">reactnative新架构实战课</a></li><li><a href="/blog/正则表达式入门">正则表达式入门</a></li><li><a href="/blog/重学前端">重学前端</a></li><li><a href="/blog/serverless入门课">serverless入门课</a></li><li><a href="/blog/type-script入门实战笔记">type-script入门实战笔记</a></li><li><a href="/blog/图解googlev8">图解googlev8</a></li><li><a href="/blog/vue3源码分析">vue3源码分析</a></li><li><a href="/blog/玩转Vue3全家桶">玩转Vue3全家桶</a></li><li><a href="/blog/webassembly入门">webassembly入门</a></li><li><a aria-current="page" class="active" href="/blog/手把手带你写一个Web框架">手把手带你写一个Web框架</a></li><li><a href="/blog/web漏洞挖掘实战">web漏洞挖掘实战</a></li><li><a href="/blog/跟月影学可视化">跟月影学可视化</a></li><li><a href="/blog/搞定音频技术">搞定音频技术</a></li><li><a href="/blog/攻克视频技术">攻克视频技术</a></li></ul></span><span>前端工程化<ul><li><a href="/blog/logger">logger</a></li><li><a href="/blog/webpack">webpack</a></li><li><a href="/blog/webpackChain">webpackChain</a></li></ul></span><span>前端性能优化<ul><li><a href="/blog/react性能调优">react性能调优</a></li></ul></span><span>软件测试<ul><li><a href="/blog/全链路压测实战30讲">全链路压测实战30讲</a></li><li><a href="/blog/性能测试实战30讲">性能测试实战30讲</a></li><li><a href="/blog/自动化测试高手课">自动化测试高手课</a></li><li><a href="/blog/软件测试52讲">软件测试52讲</a></li></ul></span><span>面试<ul><li><a href="/blog/面试现场">面试现场</a></li></ul></span><span>杂谈<ul><li><a href="/blog/超级访谈对话张雪峰">超级访谈对话张雪峰</a></li><li><a href="/blog/Git实战手册">Git实战手册</a></li><li><a href="/blog/NodeJS">NodeJS</a></li><li><a href="/blog/ReactJS">ReactJS</a></li><li><a href="/blog/UI设计">UI设计</a></li><li><a href="/blog/webpack4系列教程">webpack4系列教程</a></li><li><a href="/blog/前端知识体系">前端知识体系</a></li><li><a href="/blog/剑指offer刷题笔记">剑指offer刷题笔记</a></li><li><a href="/blog/思考与成长">思考与成长</a></li><li><a href="/blog/设计模式手册">设计模式手册</a></li></ul></span><div class="__dumi-default-navbar-tool"><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "></div></div></div></nav></div><div class="__dumi-default-menu" data-mode="site"><div class="__dumi-default-menu-inner"><div class="__dumi-default-menu-header"><a class="__dumi-default-menu-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog/"></a><h1>大师兄</h1><p></p></div><div class="__dumi-default-menu-mobile-area"><ul class="__dumi-default-menu-nav-list"><li>计算机基础<ul><li><a href="/blog/编译原理之美">编译原理之美</a></li><li><a href="/blog/编译原理实战">编译原理实战</a></li><li><a href="/blog/深入浅出计算机组成原理">深入浅出计算机组成原理</a></li><li><a href="/blog/详解http">详解http</a></li><li><a href="/blog/计算机网络通关29讲">计算机网络通关29讲</a></li><li><a href="/blog/网络排查案例课">网络排查案例课</a></li><li><a href="/blog/linux操作系统">linux操作系统</a></li><li><a href="/blog/linux性能优化实战">linux性能优化实战</a></li><li><a href="/blog/程序员数学基础">程序员数学基础</a></li><li><a href="/blog/趣谈网络协议">趣谈网络协议</a></li><li><a href="/blog/操作系统实战">操作系统实战</a></li><li><a href="/blog/软件工程之美">软件工程之美</a></li><li><a href="/blog/sql必知必会">sql必知必会</a></li><li><a href="/blog/操作系统实战45讲">操作系统实战45讲</a></li><li><a href="/blog/网络编程实战">网络编程实战</a></li></ul></li><li>算法<ul><li><a href="/blog/常用算法25讲">常用算法25讲</a></li><li><a href="/blog/数据结构与算法之美">数据结构与算法之美</a></li><li><a href="/blog/业务开发算法50讲">业务开发算法50讲</a></li><li><a href="/blog/动态规划面试宝典">动态规划面试宝典</a></li></ul></li><li>前端开发<ul><li><a href="/blog/浏览器工作原理与实践">浏览器工作原理与实践</a></li><li><a href="/blog/新时代产品经理进阶之路">新时代产品经理进阶之路</a></li><li><a href="/blog/全栈工程师修炼指南">全栈工程师修炼指南</a></li><li><a href="/blog/flutter核心技术与实战">flutter核心技术与实战</a></li><li><a href="/blog/java-script核心原理解析">java-script核心原理解析</a></li><li><a href="/blog/说透低代码">说透低代码</a></li><li><a href="/blog/nodejs应用开发实战">nodejs应用开发实战</a></li><li><a href="/blog/反爬虫兵法演绎20讲">反爬虫兵法演绎20讲</a></li><li><a href="/blog/reactnative新架构实战课">reactnative新架构实战课</a></li><li><a href="/blog/正则表达式入门">正则表达式入门</a></li><li><a href="/blog/重学前端">重学前端</a></li><li><a href="/blog/serverless入门课">serverless入门课</a></li><li><a href="/blog/type-script入门实战笔记">type-script入门实战笔记</a></li><li><a href="/blog/图解googlev8">图解googlev8</a></li><li><a href="/blog/vue3源码分析">vue3源码分析</a></li><li><a href="/blog/玩转Vue3全家桶">玩转Vue3全家桶</a></li><li><a href="/blog/webassembly入门">webassembly入门</a></li><li><a aria-current="page" class="active" href="/blog/手把手带你写一个Web框架">手把手带你写一个Web框架</a></li><li><a href="/blog/web漏洞挖掘实战">web漏洞挖掘实战</a></li><li><a href="/blog/跟月影学可视化">跟月影学可视化</a></li><li><a href="/blog/搞定音频技术">搞定音频技术</a></li><li><a href="/blog/攻克视频技术">攻克视频技术</a></li></ul></li><li>前端工程化<ul><li><a href="/blog/logger">logger</a></li><li><a href="/blog/webpack">webpack</a></li><li><a href="/blog/webpackChain">webpackChain</a></li></ul></li><li>前端性能优化<ul><li><a href="/blog/react性能调优">react性能调优</a></li></ul></li><li>软件测试<ul><li><a href="/blog/全链路压测实战30讲">全链路压测实战30讲</a></li><li><a href="/blog/性能测试实战30讲">性能测试实战30讲</a></li><li><a href="/blog/自动化测试高手课">自动化测试高手课</a></li><li><a href="/blog/软件测试52讲">软件测试52讲</a></li></ul></li><li>面试<ul><li><a href="/blog/面试现场">面试现场</a></li></ul></li><li>杂谈<ul><li><a href="/blog/超级访谈对话张雪峰">超级访谈对话张雪峰</a></li><li><a href="/blog/Git实战手册">Git实战手册</a></li><li><a href="/blog/NodeJS">NodeJS</a></li><li><a href="/blog/ReactJS">ReactJS</a></li><li><a href="/blog/UI设计">UI设计</a></li><li><a href="/blog/webpack4系列教程">webpack4系列教程</a></li><li><a href="/blog/前端知识体系">前端知识体系</a></li><li><a href="/blog/剑指offer刷题笔记">剑指offer刷题笔记</a></li><li><a href="/blog/思考与成长">思考与成长</a></li><li><a href="/blog/设计模式手册">设计模式手册</a></li></ul></li></ul><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "><button title="Dark theme" class="__dumi-default-dark-moon "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="3854" width="22" height="22"><path d="M991.816611 674.909091a69.166545 69.166545 0 0 0-51.665455-23.272727 70.795636 70.795636 0 0 0-27.438545 5.585454A415.674182 415.674182 0 0 1 754.993338 698.181818c-209.594182 0-393.472-184.785455-393.472-395.636363 0-52.363636 38.539636-119.621818 69.515637-173.614546 4.887273-8.610909 9.634909-16.756364 14.103272-24.901818A69.818182 69.818182 0 0 0 384.631156 0a70.842182 70.842182 0 0 0-27.438545 5.585455C161.678429 90.298182 14.362065 307.898182 14.362065 512c0 282.298182 238.824727 512 532.38691 512a522.286545 522.286545 0 0 0 453.957818-268.334545A69.818182 69.818182 0 0 0 991.816611 674.909091zM546.679156 954.181818c-248.785455 0-462.941091-192-462.941091-442.181818 0-186.647273 140.637091-372.829091 300.939637-442.181818-36.817455 65.629091-92.578909 151.970909-92.578909 232.727273 0 250.181818 214.109091 465.454545 462.917818 465.454545a488.331636 488.331636 0 0 0 185.181091-46.545455 453.003636 453.003636 0 0 1-393.565091 232.727273z m103.656728-669.323636l-14.266182 83.781818a34.909091 34.909091 0 0 0 50.362182 36.770909l74.775272-39.563636 74.752 39.563636a36.142545 36.142545 0 0 0 16.174546 3.956364 34.909091 34.909091 0 0 0 34.210909-40.727273l-14.289455-83.781818 60.509091-59.345455a35.025455 35.025455 0 0 0-19.223272-59.578182l-83.61891-12.101818-37.376-76.101818a34.56 34.56 0 0 0-62.254545 0l-37.376 76.101818-83.618909 12.101818a34.909091 34.909091 0 0 0-19.246546 59.578182z m70.423272-64.698182a34.280727 34.280727 0 0 0 26.135273-19.083636l14.312727-29.090909 14.336 29.090909a34.257455 34.257455 0 0 0 26.135273 19.083636l32.046546 4.887273-23.272728 22.574545a35.234909 35.234909 0 0 0-10.007272 30.952727l5.46909 32.116364-28.625454-15.127273a34.490182 34.490182 0 0 0-32.302546 0l-28.695272 15.127273 5.469091-32.116364a35.141818 35.141818 0 0 0-9.984-30.952727l-23.272728-22.574545z" p-id="3855"></path></svg></button><button title="Light theme" class="__dumi-default-dark-sun "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="4026" width="22" height="22"><path d="M915.2 476.16h-43.968c-24.704 0-44.736 16-44.736 35.84s20.032 35.904 44.736 35.904H915.2c24.768 0 44.8-16.064 44.8-35.904s-20.032-35.84-44.8-35.84zM512 265.6c-136.704 0-246.464 109.824-246.464 246.4 0 136.704 109.76 246.464 246.464 246.464S758.4 648.704 758.4 512c0-136.576-109.696-246.4-246.4-246.4z m0 425.6c-99.008 0-179.2-80.128-179.2-179.2 0-98.944 80.192-179.2 179.2-179.2S691.2 413.056 691.2 512c0 99.072-80.192 179.2-179.2 179.2zM197.44 512c0-19.84-19.136-35.84-43.904-35.84H108.8c-24.768 0-44.8 16-44.8 35.84s20.032 35.904 44.8 35.904h44.736c24.768 0 43.904-16.064 43.904-35.904zM512 198.464c19.776 0 35.84-20.032 35.84-44.8v-44.8C547.84 84.032 531.84 64 512 64s-35.904 20.032-35.904 44.8v44.8c0 24.768 16.128 44.864 35.904 44.864z m0 627.136c-19.776 0-35.904 20.032-35.904 44.8v44.736C476.096 940.032 492.16 960 512 960s35.84-20.032 35.84-44.8v-44.736c0-24.768-16.064-44.864-35.84-44.864z m329.92-592.832c17.472-17.536 20.288-43.072 6.4-57.024-14.016-14.016-39.488-11.2-57.024 6.336-4.736 4.864-26.496 26.496-31.36 31.36-17.472 17.472-20.288 43.008-6.336 57.024 13.952 14.016 39.488 11.2 57.024-6.336 4.8-4.864 26.496-26.56 31.296-31.36zM213.376 759.936c-4.864 4.8-26.56 26.624-31.36 31.36-17.472 17.472-20.288 42.944-6.4 56.96 14.016 13.952 39.552 11.2 57.024-6.336 4.8-4.736 26.56-26.496 31.36-31.36 17.472-17.472 20.288-43.008 6.336-56.96-14.016-13.952-39.552-11.072-56.96 6.336z m19.328-577.92c-17.536-17.536-43.008-20.352-57.024-6.336-14.08 14.016-11.136 39.488 6.336 57.024 4.864 4.864 26.496 26.56 31.36 31.424 17.536 17.408 43.008 20.288 56.96 6.336 14.016-14.016 11.264-39.488-6.336-57.024-4.736-4.864-26.496-26.56-31.296-31.424z m527.168 628.608c4.864 4.864 26.624 26.624 31.36 31.424 17.536 17.408 43.072 20.224 57.088 6.336 13.952-14.016 11.072-39.552-6.4-57.024-4.864-4.8-26.56-26.496-31.36-31.36-17.472-17.408-43.072-20.288-57.024-6.336-13.952 14.016-11.008 39.488 6.336 56.96z" p-id="4027"></path></svg></button><button title="Default to system" class="__dumi-default-dark-auto "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="11002" width="22" height="22"><path d="M127.658667 492.885333c0-51.882667 10.24-101.717333 30.378666-149.162666s47.786667-88.064 81.92-122.538667 75.093333-61.781333 122.538667-81.92 96.938667-30.378667 149.162667-30.378667 101.717333 10.24 149.162666 30.378667 88.405333 47.786667 122.88 81.92 61.781333 75.093333 81.92 122.538667 30.378667 96.938667 30.378667 149.162666-10.24 101.717333-30.378667 149.162667-47.786667 88.405333-81.92 122.88-75.093333 61.781333-122.88 81.92-97.28 30.378667-149.162666 30.378667-101.717333-10.24-149.162667-30.378667-88.064-47.786667-122.538667-81.92-61.781333-75.093333-81.92-122.88-30.378667-96.938667-30.378666-149.162667z m329.045333 0c0 130.048 13.994667 244.394667 41.984 343.381334h12.970667c46.762667 0 91.136-9.216 133.461333-27.306667s78.848-42.666667 109.568-73.386667 54.954667-67.242667 73.386667-109.568 27.306667-86.698667 27.306666-133.461333c0-46.421333-9.216-90.794667-27.306666-133.12s-42.666667-78.848-73.386667-109.568-67.242667-54.954667-109.568-73.386667-86.698667-27.306667-133.461333-27.306666h-11.605334c-28.672 123.562667-43.349333 237.909333-43.349333 343.722666z" p-id="11003"></path></svg></button></div></div></div><ul class="__dumi-default-menu-list"><li><a href="/blog/">大师兄 - 前端架构师</a></li></ul></div></div><ul role="slug-list" class="__dumi-default-layout-toc"><li title="运行命令的设计" data-depth="3"><a href="/blog/手把手带你写一个web框架/04.实战第3关完善功能/07#运行命令的设计"><span>运行命令的设计</span></a></li><li title="启动命令" data-depth="3"><a href="/blog/手把手带你写一个web框架/04.实战第3关完善功能/07#启动命令"><span>启动命令</span></a></li><li title="获取进程" data-depth="3"><a href="/blog/手把手带你写一个web框架/04.实战第3关完善功能/07#获取进程"><span>获取进程</span></a></li><li title="停止命令" data-depth="3"><a href="/blog/手把手带你写一个web框架/04.实战第3关完善功能/07#停止命令"><span>停止命令</span></a></li><li title="重启命令" data-depth="3"><a href="/blog/手把手带你写一个web框架/04.实战第3关完善功能/07#重启命令"><span>重启命令</span></a></li><li title="测试" data-depth="3"><a href="/blog/手把手带你写一个web框架/04.实战第3关完善功能/07#测试"><span>测试</span></a></li><li title="小结" data-depth="3"><a href="/blog/手把手带你写一个web框架/04.实战第3关完善功能/07#小结"><span>小结</span></a></li><li title="思考题" data-depth="3"><a href="/blog/手把手带你写一个web框架/04.实战第3关完善功能/07#思考题"><span>思考题</span></a></li></ul><div class="__dumi-default-layout-content"><div class="markdown"><h1 id="24管理进程如何设计完善的运行命令"><a aria-hidden="true" tabindex="-1" href="/blog/手把手带你写一个web框架/04.实战第3关完善功能/07#24管理进程如何设计完善的运行命令"><span class="icon icon-link"></span></a>24｜管理进程：如何设计完善的运行命令？</h1><p>你好，我是轩脉刃。</p><p>在<a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/426765">第13章<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>我们引入命令行的时候，将Web启动方式改成了一个命令行。但是当时只完成了一个最简单的启动Web服务的命令，这节课，我们要做的是完善这个Web服务运行命令，让Web服务的运行有完整的启动、停止、重启、查询的进程管理功能。</p><p>这套完整的进程管理功能，能让应用管理者非常方便地通过一套命令来统一管控一个应用，降低应用管理者的管理成本，后续也能为实现应用自动化部署到远端服务的工具提供了基础。下面我们来具体看下如何设计这套命令并且实现它吧。</p><h3 id="运行命令的设计"><a aria-hidden="true" tabindex="-1" href="/blog/手把手带你写一个web框架/04.实战第3关完善功能/07#运行命令的设计"><span class="icon icon-link"></span></a>运行命令的设计</h3><p>首先照惯例需要设计一下运行命令，一级命令为 app，二级命令设计如下：</p><ul><li><code>./hade app start</code> 二级命令，启动一个app服务</li><li><code>./hade app state</code> 二级命令，获取启动的app的信息</li><li><code>./hade app stop</code> 二级命令，停止已经启动的app服务</li><li><code>./hade app restart</code> 二级命令，重新启动一个app服务</li></ul><p>这四个二级命令，有app服务的启动、停止、重启、查询，基本上已经把一个app服务启动的状态变更都包含了，能基本满足后面我们对于一个应用的管理需求。下面来讨论下每个命令的功能和设计。</p><h3 id="启动命令"><a aria-hidden="true" tabindex="-1" href="/blog/手把手带你写一个web框架/04.实战第3关完善功能/07#启动命令"><span class="icon icon-link"></span></a>启动命令</h3><p>首先是start这个命令，写在framework/command/app.go中。我们先分析下参数。</p><p>想要启动app服务，至少需要一个参数，就是<strong>启动服务的监听地址</strong>。如何获取呢？首先可以直接从默认配置获取，另外因为这是一个控制台命令，也一定可以直接从命令行获取。除了这两种方式，我们回顾下之前的配置项获取方法，还有环境变量和配置项。</p><p>所以总结起来，环境变量这个参数我们设计为有四个方式可以获取，一个是直接从命令行参数获取address参数，二是从环境变量ADDRESS中获取，然后是从配置文件中获取配置项app.address，最后如果以上三个方式都没有设置，就使用默认值:8888。关键的代码逻辑如下：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">if appAddress == &quot;&quot; {</span></div><div class="token-line"><span class="token plain">        envService := container.MustMake(contract.EnvKey).(contract.Env)</span></div><div class="token-line"><span class="token plain">        if envService.Get(&quot;ADDRESS&quot;) != &quot;&quot; {</span></div><div class="token-line"><span class="token plain">            appAddress = envService.Get(&quot;ADDRESS&quot;)</span></div><div class="token-line"><span class="token plain">        } else {</span></div><div class="token-line"><span class="token plain">            configService := container.MustMake(contract.ConfigKey).(contract.Config)</span></div><div class="token-line"><span class="token plain">            if configService.IsExist(&quot;app.address&quot;) {</span></div><div class="token-line"><span class="token plain">                appAddress = configService.GetString(&quot;app.address&quot;)</span></div><div class="token-line"><span class="token plain">            } else {</span></div><div class="token-line"><span class="token plain">                appAddress = &quot;:8888&quot;</span></div><div class="token-line"><span class="token plain">            }</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>除了监听地址的参数，回忆之前cron命令运行的时候，启动app服务，我们是有两种启动方式的，一种是启动后直接挂在控制台，这种启动方式适合调试开发使用；而另外一种，以守护进程daemon的方式启动，直接挂载在后台。所以，对于这两种启动方式，我们也需要有一个参数daemon，标记是使用哪种方式启动。</p><p>有了appAddress、daemon这两个参数，我们顺着继续想<strong>启动服务时需要的记录文件</strong>。</p><p>不管是使用挂载方式，还是daemon方式启动进程，都能获取到一个进程PID，启动app服务的时候，要将这个PID记录在一个文件中，这里我们就存储在 app/storage/runtime/app.pid 文件中。在运行时候，需要保证这个目录和文件是存在的。</p><p>同时也会产生日志，日志存放在app/storage/log/app.log中，所以我们要确认这个目录是否存在。</p><p>关于app.pid和app.log对应的代码：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">appService := container.MustMake(contract.AppKey).(contract.App)</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    pidFolder := appService.RuntimeFolder()</span></div><div class="token-line"><span class="token plain">    if !util.Exists(pidFolder) {</span></div><div class="token-line"><span class="token plain">        if err := os.MkdirAll(pidFolder, os.ModePerm); err != nil {</span></div><div class="token-line"><span class="token plain">            return err</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    serverPidFile := filepath.Join(pidFolder, &quot;app.pid&quot;)</span></div><div class="token-line"><span class="token plain">    logFolder := appService.LogFolder()</span></div><div class="token-line"><span class="token plain">    if !util.Exists(logFolder) {</span></div><div class="token-line"><span class="token plain">        if err := os.MkdirAll(logFolder, os.ModePerm); err != nil {</span></div><div class="token-line"><span class="token plain">            return err</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    // 应用日志</span></div><div class="token-line"><span class="token plain">    serverLogFile := filepath.Join(logFolder, &quot;app.log&quot;)</span></div><div class="token-line"><span class="token plain">    currentFolder := util.GetExecDirectory()</span></div></pre></div><p>好到这里，准备工作都做好了，我们看看Web服务的启动，逻辑和之前设计的基本上没有什么区别，使用net/http来启动一个Web服务。</p><p><strong>重点是启动的时候注意设置优雅关闭机制</strong>。先使用<a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/421354">第六章<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>实现的优雅关闭机制：开启一个Goroutine启动服务，主Goroutine监听信号，当获取到信号之后，等待所有请求都结束或者超过最长等待时长，就结束信号。当然，这里的最长等待时长可以设置为配置项，从app.close_wait配置项中获取，如果没有配置项，我们默认使用5s的最长等待时长。</p><p>启动相关代码：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// 启动AppServer, 这个函数会将当前goroutine阻塞</span></div><div class="token-line"><span class="token plain">    func startAppServe(server *http.Server, c framework.Container) error {</span></div><div class="token-line"><span class="token plain">        // 这个goroutine是启动服务的goroutine</span></div><div class="token-line"><span class="token plain">        go func() {</span></div><div class="token-line"><span class="token plain">            server.ListenAndServe()</span></div><div class="token-line"><span class="token plain">        }()</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        // 当前的goroutine等待信号量</span></div><div class="token-line"><span class="token plain">        quit := make(chan os.Signal)</span></div><div class="token-line"><span class="token plain">        // 监控信号：SIGINT, SIGTERM, SIGQUIT</span></div><div class="token-line"><span class="token plain">        signal.Notify(quit, syscall.SIGINT, syscall.SIGTERM, syscall.SIGQUIT)</span></div><div class="token-line"><span class="token plain">        // 这里会阻塞当前goroutine等待信号</span></div><div class="token-line"><span class="token plain">        &lt;-quit</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        // 调用Server.Shutdown graceful结束</span></div><div class="token-line"><span class="token plain">        closeWait := 5</span></div><div class="token-line"><span class="token plain">        configService := c.MustMake(contract.ConfigKey).(contract.Config)</span></div><div class="token-line"><span class="token plain">        if configService.IsExist(&quot;app.close_wait&quot;) {</span></div><div class="token-line"><span class="token plain">            closeWait = configService.GetInt(&quot;app.close_wait&quot;)</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        timeoutCtx, cancel := context.WithTimeout(context.Background(), time.Duration(closeWait)*time.Second)</span></div><div class="token-line"><span class="token plain">        defer cancel()</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        if err := server.Shutdown(timeoutCtx); err != nil {</span></div><div class="token-line"><span class="token plain">            return err</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        return nil</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>但是这里还出现了一个问题，挂在控制台的启动，比较简单，直接调用封装好的 startAppServe 就行了。但daemon方式如何启动呢？它是不能直接在主进程中调用startAppServe方法的，会把主进程给阻塞挂起来了，怎么办呢？</p><p>这个其实在<a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/427090">第十四章<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>定时任务中有说到，我们可以使用和定时任务一样的实现机制，使用开源库 <a target="_blank" rel="noopener noreferrer" href="https://github.com/sevlyar/go-daemon">go-daemon<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>。比较重要，所以这里再啰嗦一下，<strong>理解go-daemon库的使用，要理解最核心的daemon.Context结构</strong>。</p><p>在我们框架这个需求中，daemon方式启动命令为 <code>./hade app start \--daemon=true</code> 。所以在daemon.Context结构中的Args参数填写如下：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// 创建一个Context</span></div><div class="token-line"><span class="token plain">    cntxt := &amp;daemon.Context{</span></div><div class="token-line"><span class="token plain">       ...</span></div><div class="token-line"><span class="token plain">       // 子进程的参数，按照这个参数设置，子进程的命令为 ./hade app start --daemon=true</span></div><div class="token-line"><span class="token plain">       Args: []string{&quot;&quot;, &quot;app&quot;, &quot;start&quot;, &quot;--daemon=true&quot;},</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    // 启动子进程，d不为空表示当前是父进程，d为空表示当前是子进程</span></div><div class="token-line"><span class="token plain">    d, err := cntxt.Reborn()</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    if d != nil {</span></div><div class="token-line"><span class="token plain">       // 父进程直接打印启动成功信息，不做任何操作</span></div><div class="token-line"><span class="token plain">       fmt.Println(&quot;app启动成功，pid:&quot;, d.Pid)</span></div><div class="token-line"><span class="token plain">       fmt.Println(&quot;日志文件:&quot;, serverLogFile)</span></div><div class="token-line"><span class="token plain">       return nil</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    ...</span></div></pre></div><p>有的同学对这个启动子进程的Reborn可能有些疑惑。</p><p>我们把Reborn理解成fork，当调用这个函数的时候，父进程会继续往下走，但是返回值d不为空，它的信息是子进程的进程号等信息。而子进程会重新运行对应的命令，再次进入到Reborn函数的时候，返回的d就为nil。所以<strong>在Reborn的后面，我们让父进程直接return，而让子进程继续往后进行操作，这样就达到了fork一个子进程的效果了</strong>。</p><p>理解了这一点，对应的代码就很简单了：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// daemon 模式</span></div><div class="token-line"><span class="token plain">    if appDaemon {</span></div><div class="token-line"><span class="token plain">        // 创建一个Context</span></div><div class="token-line"><span class="token plain">        cntxt := &amp;daemon.Context{</span></div><div class="token-line"><span class="token plain">            // 设置pid文件</span></div><div class="token-line"><span class="token plain">            PidFileName: serverPidFile,</span></div><div class="token-line"><span class="token plain">            PidFilePerm: 0664,</span></div><div class="token-line"><span class="token plain">            // 设置日志文件</span></div><div class="token-line"><span class="token plain">            LogFileName: serverLogFile,</span></div><div class="token-line"><span class="token plain">            LogFilePerm: 0640,</span></div><div class="token-line"><span class="token plain">            // 设置工作路径</span></div><div class="token-line"><span class="token plain">            WorkDir: currentFolder,</span></div><div class="token-line"><span class="token plain">            // 设置所有设置文件的mask，默认为750</span></div><div class="token-line"><span class="token plain">            Umask: 027,</span></div><div class="token-line"><span class="token plain">            // 子进程的参数，按照这个参数设置，子进程的命令为 ./hade app start --daemon=true</span></div><div class="token-line"><span class="token plain">            Args: []string{&quot;&quot;, &quot;app&quot;, &quot;start&quot;, &quot;--daemon=true&quot;},</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        // 启动子进程，d不为空表示当前是父进程，d为空表示当前是子进程</span></div><div class="token-line"><span class="token plain">        d, err := cntxt.Reborn()</span></div><div class="token-line"><span class="token plain">        if err != nil {</span></div><div class="token-line"><span class="token plain">            return err</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        if d != nil {</span></div><div class="token-line"><span class="token plain">            // 父进程直接打印启动成功信息，不做任何操作</span></div><div class="token-line"><span class="token plain">            fmt.Println(&quot;app启动成功，pid:&quot;, d.Pid)</span></div><div class="token-line"><span class="token plain">            fmt.Println(&quot;日志文件:&quot;, serverLogFile)</span></div><div class="token-line"><span class="token plain">            return nil</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        defer cntxt.Release()</span></div><div class="token-line"><span class="token plain">        // 子进程执行真正的app启动操作</span></div><div class="token-line"><span class="token plain">        fmt.Println(&quot;deamon started&quot;)</span></div><div class="token-line"><span class="token plain">        gspt.SetProcTitle(&quot;hade app&quot;)</span></div><div class="token-line"><span class="token plain">        if err := startAppServe(server, container); err != nil {</span></div><div class="token-line"><span class="token plain">            fmt.Println(err)</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        return nil</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>到这里服务的进程启动成功，最后还有一点细节，对于启动的进程，我们一般都希望能自定义它的进程名称。</p><p>这里可以使用一个第三方库 <a target="_blank" rel="noopener noreferrer" href="https://github.com/erikdubbelboer/gspt">gspt<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>。它使用MIT协议，虽然star数不多，但是我个人亲测是功能齐全且有效的。在Golang中没有现成的设置进程名称的方法，只能调用C的设置进程名称的方法 setproctitle。所以这个库使用的方式是，使用cgo从Go中调用C的方法来实现进程名称的修改。</p><p>它的使用非常简单，就是一个函数SetProcTitle方法：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">gspt.SetProcTitle(&quot;hade app&quot;)</span></div></pre></div><p>现在，进程的启动就基本完成了。当然最后还有非常重要的关闭逻辑也记得加上。</p><p>好了，以上我们讨论了start的关键设计，再回头梳理一遍这个命令的实现步骤：</p><ul><li>从四个方式获取参数appAddress</li><li>获取参数daemon</li><li>确认runtime目录和PID文件存在</li><li>确认log目录的log文件存在</li><li>判断是否是daemon方式。如果是，就使用go-daemon来启动一个子进程；如果不是，直接进行后续调用</li><li>使用gspt来设置当前进程名称</li><li>启动app服务</li></ul><p>具体的实现步骤相信你已经很清楚了，完整代码我们写在 <a target="_blank" rel="noopener noreferrer" href="https://github.com/gohade/coredemo/blob/geekbang/24/framework/command/app.go">framework/command/app.go<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>中了。</p><h3 id="获取进程"><a aria-hidden="true" tabindex="-1" href="/blog/手把手带你写一个web框架/04.实战第3关完善功能/07#获取进程"><span class="icon icon-link"></span></a>获取进程</h3><p>已经完成了启动进程的命令，那么第二个获取进程PID的命令就非常简单了。因为启动命令的时候创建了一个PID文件，app/storage/runtime/app.pid，读取这个文件就可以获取到进程的PID信息了。</p><p>但是这里我们可以更谨慎一些加一步，获取到PID之后，去操作系统中查询这个PID的进程是否存在，存在的话，就确定这个PID是可行的。</p><p>如何根据PID查询一个进程是否存在呢？常用的比如Linux的ps和grep命令，基本上都是通过Linux的其他命令来检查输出，<strong>但最为可靠的方式是直接使用信号对接要查询的进程：通过给进程发送信号来检测，这个信号就是信号0</strong>。</p><p>给进程发送信号0之后什么都不会操作，如果进程存在，不返回错误信息；如果进程不存在，会返回不存在进程的错误信息。在Golang中，我们可以用os库的Process结构来发送信号。</p><p>代码在 framework/util/exec.go 中，逻辑也很清晰，先用os.FindProcess来获取这个PID对应的进程，然后给进程发送signal 0， 如果返回nil，代表进程存在，否则进程不存在。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// CheckProcessExist 检查进程pid是否存在，如果存在的话，返回true</span></div><div class="token-line"><span class="token plain">    func CheckProcessExist(pid int) bool {</span></div><div class="token-line"><span class="token plain">       // 查询这个pid</span></div><div class="token-line"><span class="token plain">       process, err := os.FindProcess(pid)</span></div><div class="token-line"><span class="token plain">       if err != nil {</span></div><div class="token-line"><span class="token plain">          return false</span></div><div class="token-line"><span class="token plain">       }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">       // 给进程发送signal 0, 如果返回nil，代表进程存在, 否则进程不存在</span></div><div class="token-line"><span class="token plain">       err = process.Signal(syscall.Signal(0))</span></div><div class="token-line"><span class="token plain">       if err != nil {</span></div><div class="token-line"><span class="token plain">          return false</span></div><div class="token-line"><span class="token plain">       }</span></div><div class="token-line"><span class="token plain">       return true</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>这个关键函数实现之后，其他的就很容易了。</p><p>这里我们也简单说一下进程获取的具体步骤：获取PID文件内容之后，做判断，如果有PID文件且有内容就继续，否则返回无进程；然后：</p><ul><li>将内容转换为PID的int类型，转换失败视为无进程；</li><li><strong>使用signal 0 确认这个进程是否存在，存在返回结果有进程，不存在返回结构无进程</strong>。</li></ul><p>具体代码如下，存放在 framework/command/app.go文件中：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// 获取启动的app的pid</span></div><div class="token-line"><span class="token plain">    var appStateCommand = &amp;cobra.Command{</span></div><div class="token-line"><span class="token plain">       Use:   &quot;state&quot;,</span></div><div class="token-line"><span class="token plain">       Short: &quot;获取启动的app的pid&quot;,</span></div><div class="token-line"><span class="token plain">       RunE: func(c *cobra.Command, args []string) error {</span></div><div class="token-line"><span class="token plain">          container := c.GetContainer()</span></div><div class="token-line"><span class="token plain">          appService := container.MustMake(contract.AppKey).(contract.App)</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">          // 获取pid</span></div><div class="token-line"><span class="token plain">          serverPidFile := filepath.Join(appService.RuntimeFolder(), &quot;app.pid&quot;)</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">          content, err := ioutil.ReadFile(serverPidFile)</span></div><div class="token-line"><span class="token plain">          if err != nil {</span></div><div class="token-line"><span class="token plain">             return err</span></div><div class="token-line"><span class="token plain">          }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">          if content != nil &amp;&amp; len(content) &gt; 0 {</span></div><div class="token-line"><span class="token plain">             pid, err := strconv.Atoi(string(content))</span></div><div class="token-line"><span class="token plain">             if err != nil {</span></div><div class="token-line"><span class="token plain">                return err</span></div><div class="token-line"><span class="token plain">             }</span></div><div class="token-line"><span class="token plain">             if util.CheckProcessExist(pid) {</span></div><div class="token-line"><span class="token plain">                fmt.Println(&quot;app服务已经启动, pid:&quot;, pid)</span></div><div class="token-line"><span class="token plain">                return nil</span></div><div class="token-line"><span class="token plain">             }</span></div><div class="token-line"><span class="token plain">          }</span></div><div class="token-line"><span class="token plain">          fmt.Println(&quot;没有app服务存在&quot;)</span></div><div class="token-line"><span class="token plain">          return nil</span></div><div class="token-line"><span class="token plain">       },</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><h3 id="停止命令"><a aria-hidden="true" tabindex="-1" href="/blog/手把手带你写一个web框架/04.实战第3关完善功能/07#停止命令"><span class="icon icon-link"></span></a>停止命令</h3><p>命令的启动和获取完成了，就到了第三个停止命令了。既然有了进程号，需要停止一个进程，我们还是可以使用第六章说的信号量方法，回顾下当时说的四个关闭信号：<br/><img src="https://static001.geekbang.org/resource/image/e9/50/e93163afd641b744b2b3f8faf46f4e50.jpg?wh=1920x1080" alt=""/></p><p>由于启动进程监听了SIGINT、SIGQUIT、SIGTERM 这三个信号，所以我们在这三个信号中选取一个发送给PID所在的进程即可，这里就选择更符合“关闭”语义的SIGTERM信号。</p><p>同样实现步骤也很清晰，获取PID文件内容之后，判断如果有PID文件且有内容再继续，否则什么都不做，之后就是：</p><ul><li>将内容转换为PID的int类型，转换失败则什么都不做</li><li>直接给这个PID进程发送SIGTERM信号</li><li>将PID文件内容清空</li></ul><p>对应代码同样在framework/command/app.go中：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// 停止一个已经启动的app服务</span></div><div class="token-line"><span class="token plain">    var appStopCommand = &amp;cobra.Command{</span></div><div class="token-line"><span class="token plain">       Use:   &quot;stop&quot;,</span></div><div class="token-line"><span class="token plain">       Short: &quot;停止一个已经启动的app服务&quot;,</span></div><div class="token-line"><span class="token plain">       RunE: func(c *cobra.Command, args []string) error {</span></div><div class="token-line"><span class="token plain">          container := c.GetContainer()</span></div><div class="token-line"><span class="token plain">          appService := container.MustMake(contract.AppKey).(contract.App)</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">          // GetPid</span></div><div class="token-line"><span class="token plain">          serverPidFile := filepath.Join(appService.RuntimeFolder(), &quot;app.pid&quot;)</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">          content, err := ioutil.ReadFile(serverPidFile)</span></div><div class="token-line"><span class="token plain">          if err != nil {</span></div><div class="token-line"><span class="token plain">             return err</span></div><div class="token-line"><span class="token plain">          }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">          if content != nil &amp;&amp; len(content) != 0 {</span></div><div class="token-line"><span class="token plain">             pid, err := strconv.Atoi(string(content))</span></div><div class="token-line"><span class="token plain">             if err != nil {</span></div><div class="token-line"><span class="token plain">                return err</span></div><div class="token-line"><span class="token plain">             }</span></div><div class="token-line"><span class="token plain">             // 发送SIGTERM命令</span></div><div class="token-line"><span class="token plain">             if err := syscall.Kill(pid, syscall.SIGTERM); err != nil {</span></div><div class="token-line"><span class="token plain">                return err</span></div><div class="token-line"><span class="token plain">             }</span></div><div class="token-line"><span class="token plain">             if err := ioutil.WriteFile(serverPidFile, []byte{}, 0644); err != nil {</span></div><div class="token-line"><span class="token plain">                return err</span></div><div class="token-line"><span class="token plain">             }</span></div><div class="token-line"><span class="token plain">             fmt.Println(&quot;停止进程:&quot;, pid)</span></div><div class="token-line"><span class="token plain">          }</span></div><div class="token-line"><span class="token plain">          return nil</span></div><div class="token-line"><span class="token plain">       },</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><h3 id="重启命令"><a aria-hidden="true" tabindex="-1" href="/blog/手把手带你写一个web框架/04.实战第3关完善功能/07#重启命令"><span class="icon icon-link"></span></a>重启命令</h3><p>最后我们要完成重启命令，还是在framework/command/app.go中。大致逻辑也很清晰，读取PID文件之后判断，如果PID文件中没有PID，说明没有进程在运行，直接启动新进程；如果PID文件中有PID，检查旧进程是否存在，如果不存在，直接启动新进程，如果存在，这里就有一些需要注意的了。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">//获取pid</span></div><div class="token-line"><span class="token plain">    ...</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    if content != nil &amp;&amp; len(content) != 0 {</span></div><div class="token-line"><span class="token plain">        // 解析pid是否存在</span></div><div class="token-line"><span class="token plain">        if util.CheckProcessExist(pid) {</span></div><div class="token-line"><span class="token plain">            // 关闭旧的pid进程</span></div><div class="token-line"><span class="token plain">            ...</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    appDaemon = true</span></div><div class="token-line"><span class="token plain">    // 启动新的进程</span></div><div class="token-line"><span class="token plain">    return appStartCommand.RunE(c, args)</span></div></pre></div><p>因为重启的逻辑是先结束旧进程，再启动新进程。结束进程和停止命令一样，使用SIGTERM信号就能保证进程的优雅关闭了。但是<strong>由于新、旧进程都是使用同一个端口，所以必须保证旧进程结束，才能启动新的进程</strong>。</p><p>而怎么保证旧进程确实结束了呢？</p><p>这里可以使用前面定义的 CheckProcessExist 方法，每秒做一次轮询，检测PID对应的进程是否已经关闭。那么轮询多少次呢？</p><p>我们知道在启动进程的时候，设置了一个优雅关闭的最大超时时间closeWait，这个closeWait的时间设置为秒。那么<strong>为了轮询检查旧进程是否关闭，我们只需要设置次数超过closeWait的轮询时间即可</strong>。考虑到net/http 在closeWait之后还有一些程序运行的逻辑，这里我们可以设置为2 * closeWait，时间是非常充裕的。关键代码如下：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// 确认进程已经关闭,每秒检测一次， 最多检测closeWait * 2秒</span></div><div class="token-line"><span class="token plain">    for i := 0; i &lt; closeWait*2; i++ {</span></div><div class="token-line"><span class="token plain">        if util.CheckProcessExist(pid) == false {</span></div><div class="token-line"><span class="token plain">            break</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        time.Sleep(1 * time.Second)</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>再严谨一些，可以这么设置，如果在2*closeWait时间内，旧进程还未关闭，那么就不能启动新进程了，需要直接返回错误。所以，在 2 * closeWait 轮询之后，我们还需要再做一次检查，检查进程是否关闭，如果没有关闭的话，直接返回error：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// 确认进程已经关闭,每秒检测一次， 最多检测closeWait * 2秒</span></div><div class="token-line"><span class="token plain">    for i := 0; i &lt; closeWait*2; i++ {</span></div><div class="token-line"><span class="token plain">        if util.CheckProcessExist(pid) == false {</span></div><div class="token-line"><span class="token plain">            break</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        time.Sleep(1 * time.Second)</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    // 如果进程等待了2*closeWait之后还没结束，返回错误，不进行后续的操作</span></div><div class="token-line"><span class="token plain">    if util.CheckProcessExist(pid) == true {</span></div><div class="token-line"><span class="token plain">        fmt.Println(&quot;结束进程失败:&quot;+strconv.Itoa(pid), &quot;请查看原因&quot;)</span></div><div class="token-line"><span class="token plain">        return errors.New(&quot;结束进程失败&quot;)</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>在确认旧进程结束后，记得把PID文件清空，再启动一个新进程。启动进程的逻辑还是比较复杂的，就不重复写了，我们直接调用appStartCommand的RunE方法来实现，会更优雅一些。</p><p>同其他命令一样，这里再梳理一下判断旧进程存在之后详细的实现步骤，如果存在：</p><ul><li>发送SIGTERM信号</li><li>循环2*closeWait次数，每秒执行一次查询进程是否已经结束</li><li>如果某次查询进程已经结束，或者等待2*closeWait循环结束之后，再次查询一次进程</li><li>如果还未结束，返回进程结束失败</li><li>如果已经结束，将PID文件清空，启动新进程</li></ul><p>在framework/command/app.go中，整体代码如下：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// 重新启动一个app服务</span></div><div class="token-line"><span class="token plain">    var appRestartCommand = &amp;cobra.Command{</span></div><div class="token-line"><span class="token plain">       Use:   &quot;restart&quot;,</span></div><div class="token-line"><span class="token plain">       Short: &quot;重新启动一个app服务&quot;,</span></div><div class="token-line"><span class="token plain">       RunE: func(c *cobra.Command, args []string) error {</span></div><div class="token-line"><span class="token plain">          container := c.GetContainer()</span></div><div class="token-line"><span class="token plain">          appService := container.MustMake(contract.AppKey).(contract.App)</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">          // GetPid</span></div><div class="token-line"><span class="token plain">          serverPidFile := filepath.Join(appService.RuntimeFolder(), &quot;app.pid&quot;)</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">          content, err := ioutil.ReadFile(serverPidFile)</span></div><div class="token-line"><span class="token plain">          if err != nil {</span></div><div class="token-line"><span class="token plain">             return err</span></div><div class="token-line"><span class="token plain">          }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">          if content != nil &amp;&amp; len(content) != 0 {</span></div><div class="token-line"><span class="token plain">             pid, err := strconv.Atoi(string(content))</span></div><div class="token-line"><span class="token plain">             if err != nil {</span></div><div class="token-line"><span class="token plain">                return err</span></div><div class="token-line"><span class="token plain">             }</span></div><div class="token-line"><span class="token plain">             if util.CheckProcessExist(pid) {</span></div><div class="token-line"><span class="token plain">                // 杀死进程</span></div><div class="token-line"><span class="token plain">                if err := syscall.Kill(pid, syscall.SIGTERM); err != nil {</span></div><div class="token-line"><span class="token plain">                   return err</span></div><div class="token-line"><span class="token plain">                }</span></div><div class="token-line"><span class="token plain">                if err := ioutil.WriteFile(serverPidFile, []byte{}, 0644); err != nil {</span></div><div class="token-line"><span class="token plain">                   return err</span></div><div class="token-line"><span class="token plain">                }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">                // 获取closeWait</span></div><div class="token-line"><span class="token plain">                closeWait := 5</span></div><div class="token-line"><span class="token plain">                configService := container.MustMake(contract.ConfigKey).(contract.Config)</span></div><div class="token-line"><span class="token plain">                if configService.IsExist(&quot;app.close_wait&quot;) {</span></div><div class="token-line"><span class="token plain">                   closeWait = configService.GetInt(&quot;app.close_wait&quot;)</span></div><div class="token-line"><span class="token plain">                }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">                // 确认进程已经关闭,每秒检测一次， 最多检测closeWait * 2秒</span></div><div class="token-line"><span class="token plain">                for i := 0; i &lt; closeWait*2; i++ {</span></div><div class="token-line"><span class="token plain">                   if util.CheckProcessExist(pid) == false {</span></div><div class="token-line"><span class="token plain">                      break</span></div><div class="token-line"><span class="token plain">                   }</span></div><div class="token-line"><span class="token plain">                   time.Sleep(1 * time.Second)</span></div><div class="token-line"><span class="token plain">                }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">                // 如果进程等待了2*closeWait之后还没结束，返回错误，不进行后续的操作</span></div><div class="token-line"><span class="token plain">                if util.CheckProcessExist(pid) == true {</span></div><div class="token-line"><span class="token plain">                   fmt.Println(&quot;结束进程失败:&quot;+strconv.Itoa(pid), &quot;请查看原因&quot;)</span></div><div class="token-line"><span class="token plain">                   return errors.New(&quot;结束进程失败&quot;)</span></div><div class="token-line"><span class="token plain">                }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">                fmt.Println(&quot;结束进程成功:&quot; + strconv.Itoa(pid))</span></div><div class="token-line"><span class="token plain">             }</span></div><div class="token-line"><span class="token plain">          }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">          appDaemon = true</span></div><div class="token-line"><span class="token plain">          // 直接daemon方式启动apps</span></div><div class="token-line"><span class="token plain">          return appStartCommand.RunE(c, args)</span></div><div class="token-line"><span class="token plain">       },</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><h3 id="测试"><a aria-hidden="true" tabindex="-1" href="/blog/手把手带你写一个web框架/04.实战第3关完善功能/07#测试"><span class="icon icon-link"></span></a>测试</h3><p>下面来测试一下。首先记得使用 <code>./hade build sef</code> 命令编译，我们设置的默认服务启动地址为 “:8888”，这里就不用这个默认启动地址，使用环境变量ADDRESS=:8080 来启动服务。这样能测试到环境变量是否能生效。</p><p>调用命令 <code>ADDRESS=:8080 ./hade app start \--daemon=true</code> 以daemon方式启动一个8080端口的服务：<br/><img src="https://static001.geekbang.org/resource/image/5d/a4/5dc59ecb06330bd5097c79fc2040e6a4.png?wh=1316x150" alt=""/></p><p>使用浏览器打开 localhost:8080/demo/demo：<br/><img src="https://static001.geekbang.org/resource/image/aa/97/aa16b16c741b837d94682664d1c0yy97.png?wh=1458x372" alt=""/></p><p>服务启动成功，且正常提供服务。</p><p>使用 <code>./hade app state</code> 查看进程状态：<br/><img src="https://static001.geekbang.org/resource/image/eb/ee/eb02d0c5f341cbc3632037a6f119dcee.png?wh=922x98" alt=""/><br/>使用命令 <code>ADDRESS=:8080 ./hade app restart</code> 重新启动进程：<br/><img src="https://static001.geekbang.org/resource/image/2a/c4/2a1b9e077e357364529e43b786e943c4.png?wh=1152x194" alt=""/></p><p>再次访问浏览器 localhost:8080/demo/demo，正常提供服务：<br/><img src="https://static001.geekbang.org/resource/image/95/f4/95a1ce5d43a1bf28133a75f773341cf4.png?wh=804x280" alt=""/><br/>最后调用停止进程命令 <code>./hade app stop</code> ：</p><p><img src="https://static001.geekbang.org/resource/image/0f/40/0fb19b39412d970ccb72e43635830040.png?wh=964x100" alt=""/></p><p>到这里，对进程的启动、关闭、查询和重启的命令就验证完成了。</p><p>今天我们的所有代码都保存在GitHub上的<a target="_blank" rel="noopener noreferrer" href="https://github.com/gohade/coredemo/tree/geekbang/24">geekbang/24<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>分支了。只修改了framework/command/app.go 和 framework/util/exec.go文件，其他保持不变。<br/><img src="https://static001.geekbang.org/resource/image/c1/6b/c137079e767c7fb3a4e1bd2292b6ca6b.png?wh=584x1626" alt=""/></p><h3 id="小结"><a aria-hidden="true" tabindex="-1" href="/blog/手把手带你写一个web框架/04.实战第3关完善功能/07#小结"><span class="icon icon-link"></span></a>小结</h3><p>今天我们完成了运行app相关的命令，包括app一级命令和四个二级命令，启动app服务、停止app服务、重启app服务、查询app服务。基本上已经把一个app服务启动的状态变更都包含了。有了这些命令，我们对app的控制就方便很多了。特别是daemon运行模式，为线上运行提供了不少方便。</p><p>在实现这四个命令的过程中，我们使用了不少第三方库，gspt、go-daemon，这些库的使用你要能熟练掌握，特别是go-daemon库，我们已经不止一次使用到它了。确认一个进程是否已经结束，我们使用每秒做一次轮询的 CheckProcessExist 方法实现了检查机制，并仔细考虑了轮训的次数和效果，你可以多多体会这么设计的好处。</p><h3 id="思考题"><a aria-hidden="true" tabindex="-1" href="/blog/手把手带你写一个web框架/04.实战第3关完善功能/07#思考题"><span class="icon icon-link"></span></a>思考题</h3><p>我们在启动应用的时候，使用的地址格式为“:8080”，其实这里也可以为“localhost:8080”、“127.0.0.1:8080”或者“10.11.22.33:8080”（10.11.22.33为本机绑定的IP）。你了解localhost、127.0.0.1、10.11.22.33 以及不填写IP的区别么？</p><p>欢迎在留言区分享你的思考。感谢你的收听，如果你觉得今天的内容对你有所帮助，也欢迎分享给你身边的朋友，邀请他一起学习。我们下节课见～</p></div><div class="__dumi-default-layout-footer-meta"><a target="_blank" rel="noopener noreferrer" href="https://github.com/GGwujun/blog/edit/master/docs/手把手带你写一个Web框架/04.实战第3关完善功能/07.md">在 GitHub 上编辑此页<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a><span data-updated-text="最后更新时间：">5/2/2022 10:56:58</span></div></div></div></div>
	<script>
  window.g_useSSR = true;
  window.g_initialProps = {};
	</script>

    <script>
      (function () {
        if (!location.port) {
          (function (i, s, o, g, r, a, m) {
            i["GoogleAnalyticsObject"] = r;
            (i[r] =
              i[r] ||
              function () {
                (i[r].q = i[r].q || []).push(arguments);
              }),
              (i[r].l = 1 * new Date());
            (a = s.createElement(o)), (m = s.getElementsByTagName(o)[0]);
            a.async = 1;
            a.src = g;
            m.parentNode.insertBefore(a, m);
          })(
            window,
            document,
            "script",
            "//www.google-analytics.com/analytics.js",
            "ga"
          );
          ga("create", "UA-149864185-1", "auto");
          ga("send", "pageview");
        }
      })();
    </script>
    <script src="/blog/umi.js"></script>
  </body>
</html>
