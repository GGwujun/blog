<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no"
    />
    <link rel="shortcut icon" type="image/x-icon" href="/logo.png" />
    <link rel="stylesheet" href="/blog/umi.css" />
    <script>
      window.routerBase = "/blog";
    </script>
    <script>
      //! umi version: 3.5.17
    </script>
    <script>
      !(function () {
        var e = localStorage.getItem("dumi:prefers-color"),
          t = window.matchMedia("(prefers-color-scheme: dark)").matches,
          r = ["light", "dark", "auto"];
        document.documentElement.setAttribute(
          "data-prefers-color",
          e === r[2] ? (t ? r[1] : r[0]) : r.indexOf(e) > -1 ? e : r[0]
        );
      })();
    </script>
    <title>21｜自动化（上）：DRY，如何自动化一切重复性劳动？</title>
  </head>
  <body>
    <div id="root"><div class="__dumi-default-layout" data-route="/手把手带你写一个web框架/04.实战第3关完善功能/04" data-show-sidemenu="true" data-show-slugs="true" data-site-mode="true" data-gapless="false"><div class="__dumi-default-navbar" data-mode="site"><button class="__dumi-default-navbar-toggle"></button><a class="__dumi-default-navbar-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog/">大师兄</a><nav><div class="__dumi-default-search"><input type="search" class="__dumi-default-search-input" value=""/><ul></ul></div><span>计算机基础<ul><li><a href="/blog/编译原理之美">编译原理之美</a></li><li><a href="/blog/编译原理实战">编译原理实战</a></li><li><a href="/blog/深入浅出计算机组成原理">深入浅出计算机组成原理</a></li><li><a href="/blog/详解http">详解http</a></li><li><a href="/blog/计算机网络通关29讲">计算机网络通关29讲</a></li><li><a href="/blog/网络排查案例课">网络排查案例课</a></li><li><a href="/blog/linux操作系统">linux操作系统</a></li><li><a href="/blog/linux性能优化实战">linux性能优化实战</a></li><li><a href="/blog/程序员数学基础">程序员数学基础</a></li><li><a href="/blog/趣谈网络协议">趣谈网络协议</a></li><li><a href="/blog/操作系统实战">操作系统实战</a></li><li><a href="/blog/软件工程之美">软件工程之美</a></li><li><a href="/blog/sql必知必会">sql必知必会</a></li><li><a href="/blog/操作系统实战45讲">操作系统实战45讲</a></li><li><a href="/blog/网络编程实战">网络编程实战</a></li></ul></span><span>算法<ul><li><a href="/blog/常用算法25讲">常用算法25讲</a></li><li><a href="/blog/数据结构与算法之美">数据结构与算法之美</a></li><li><a href="/blog/业务开发算法50讲">业务开发算法50讲</a></li><li><a href="/blog/动态规划面试宝典">动态规划面试宝典</a></li></ul></span><span>前端开发<ul><li><a href="/blog/浏览器工作原理与实践">浏览器工作原理与实践</a></li><li><a href="/blog/新时代产品经理进阶之路">新时代产品经理进阶之路</a></li><li><a href="/blog/全栈工程师修炼指南">全栈工程师修炼指南</a></li><li><a href="/blog/flutter核心技术与实战">flutter核心技术与实战</a></li><li><a href="/blog/java-script核心原理解析">java-script核心原理解析</a></li><li><a href="/blog/说透低代码">说透低代码</a></li><li><a href="/blog/nodejs应用开发实战">nodejs应用开发实战</a></li><li><a href="/blog/反爬虫兵法演绎20讲">反爬虫兵法演绎20讲</a></li><li><a href="/blog/reactnative新架构实战课">reactnative新架构实战课</a></li><li><a href="/blog/正则表达式入门">正则表达式入门</a></li><li><a href="/blog/重学前端">重学前端</a></li><li><a href="/blog/serverless入门课">serverless入门课</a></li><li><a href="/blog/type-script入门实战笔记">type-script入门实战笔记</a></li><li><a href="/blog/图解googlev8">图解googlev8</a></li><li><a href="/blog/vue3源码分析">vue3源码分析</a></li><li><a href="/blog/玩转Vue3全家桶">玩转Vue3全家桶</a></li><li><a href="/blog/webassembly入门">webassembly入门</a></li><li><a aria-current="page" class="active" href="/blog/手把手带你写一个Web框架">手把手带你写一个Web框架</a></li><li><a href="/blog/web漏洞挖掘实战">web漏洞挖掘实战</a></li><li><a href="/blog/跟月影学可视化">跟月影学可视化</a></li><li><a href="/blog/搞定音频技术">搞定音频技术</a></li><li><a href="/blog/攻克视频技术">攻克视频技术</a></li></ul></span><span>前端工程化<ul><li><a href="/blog/logger">logger</a></li><li><a href="/blog/webpack">webpack</a></li><li><a href="/blog/webpackChain">webpackChain</a></li></ul></span><span>前端性能优化<ul><li><a href="/blog/react性能调优">react性能调优</a></li></ul></span><span>软件测试<ul><li><a href="/blog/全链路压测实战30讲">全链路压测实战30讲</a></li><li><a href="/blog/性能测试实战30讲">性能测试实战30讲</a></li><li><a href="/blog/自动化测试高手课">自动化测试高手课</a></li><li><a href="/blog/软件测试52讲">软件测试52讲</a></li></ul></span><span>面试<ul><li><a href="/blog/面试现场">面试现场</a></li></ul></span><span>杂谈<ul><li><a href="/blog/超级访谈对话张雪峰">超级访谈对话张雪峰</a></li><li><a href="/blog/Git实战手册">Git实战手册</a></li><li><a href="/blog/NodeJS">NodeJS</a></li><li><a href="/blog/ReactJS">ReactJS</a></li><li><a href="/blog/UI设计">UI设计</a></li><li><a href="/blog/webpack4系列教程">webpack4系列教程</a></li><li><a href="/blog/前端知识体系">前端知识体系</a></li><li><a href="/blog/剑指offer刷题笔记">剑指offer刷题笔记</a></li><li><a href="/blog/思考与成长">思考与成长</a></li><li><a href="/blog/设计模式手册">设计模式手册</a></li></ul></span><div class="__dumi-default-navbar-tool"><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "></div></div></div></nav></div><div class="__dumi-default-menu" data-mode="site"><div class="__dumi-default-menu-inner"><div class="__dumi-default-menu-header"><a class="__dumi-default-menu-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog/"></a><h1>大师兄</h1><p></p></div><div class="__dumi-default-menu-mobile-area"><ul class="__dumi-default-menu-nav-list"><li>计算机基础<ul><li><a href="/blog/编译原理之美">编译原理之美</a></li><li><a href="/blog/编译原理实战">编译原理实战</a></li><li><a href="/blog/深入浅出计算机组成原理">深入浅出计算机组成原理</a></li><li><a href="/blog/详解http">详解http</a></li><li><a href="/blog/计算机网络通关29讲">计算机网络通关29讲</a></li><li><a href="/blog/网络排查案例课">网络排查案例课</a></li><li><a href="/blog/linux操作系统">linux操作系统</a></li><li><a href="/blog/linux性能优化实战">linux性能优化实战</a></li><li><a href="/blog/程序员数学基础">程序员数学基础</a></li><li><a href="/blog/趣谈网络协议">趣谈网络协议</a></li><li><a href="/blog/操作系统实战">操作系统实战</a></li><li><a href="/blog/软件工程之美">软件工程之美</a></li><li><a href="/blog/sql必知必会">sql必知必会</a></li><li><a href="/blog/操作系统实战45讲">操作系统实战45讲</a></li><li><a href="/blog/网络编程实战">网络编程实战</a></li></ul></li><li>算法<ul><li><a href="/blog/常用算法25讲">常用算法25讲</a></li><li><a href="/blog/数据结构与算法之美">数据结构与算法之美</a></li><li><a href="/blog/业务开发算法50讲">业务开发算法50讲</a></li><li><a href="/blog/动态规划面试宝典">动态规划面试宝典</a></li></ul></li><li>前端开发<ul><li><a href="/blog/浏览器工作原理与实践">浏览器工作原理与实践</a></li><li><a href="/blog/新时代产品经理进阶之路">新时代产品经理进阶之路</a></li><li><a href="/blog/全栈工程师修炼指南">全栈工程师修炼指南</a></li><li><a href="/blog/flutter核心技术与实战">flutter核心技术与实战</a></li><li><a href="/blog/java-script核心原理解析">java-script核心原理解析</a></li><li><a href="/blog/说透低代码">说透低代码</a></li><li><a href="/blog/nodejs应用开发实战">nodejs应用开发实战</a></li><li><a href="/blog/反爬虫兵法演绎20讲">反爬虫兵法演绎20讲</a></li><li><a href="/blog/reactnative新架构实战课">reactnative新架构实战课</a></li><li><a href="/blog/正则表达式入门">正则表达式入门</a></li><li><a href="/blog/重学前端">重学前端</a></li><li><a href="/blog/serverless入门课">serverless入门课</a></li><li><a href="/blog/type-script入门实战笔记">type-script入门实战笔记</a></li><li><a href="/blog/图解googlev8">图解googlev8</a></li><li><a href="/blog/vue3源码分析">vue3源码分析</a></li><li><a href="/blog/玩转Vue3全家桶">玩转Vue3全家桶</a></li><li><a href="/blog/webassembly入门">webassembly入门</a></li><li><a aria-current="page" class="active" href="/blog/手把手带你写一个Web框架">手把手带你写一个Web框架</a></li><li><a href="/blog/web漏洞挖掘实战">web漏洞挖掘实战</a></li><li><a href="/blog/跟月影学可视化">跟月影学可视化</a></li><li><a href="/blog/搞定音频技术">搞定音频技术</a></li><li><a href="/blog/攻克视频技术">攻克视频技术</a></li></ul></li><li>前端工程化<ul><li><a href="/blog/logger">logger</a></li><li><a href="/blog/webpack">webpack</a></li><li><a href="/blog/webpackChain">webpackChain</a></li></ul></li><li>前端性能优化<ul><li><a href="/blog/react性能调优">react性能调优</a></li></ul></li><li>软件测试<ul><li><a href="/blog/全链路压测实战30讲">全链路压测实战30讲</a></li><li><a href="/blog/性能测试实战30讲">性能测试实战30讲</a></li><li><a href="/blog/自动化测试高手课">自动化测试高手课</a></li><li><a href="/blog/软件测试52讲">软件测试52讲</a></li></ul></li><li>面试<ul><li><a href="/blog/面试现场">面试现场</a></li></ul></li><li>杂谈<ul><li><a href="/blog/超级访谈对话张雪峰">超级访谈对话张雪峰</a></li><li><a href="/blog/Git实战手册">Git实战手册</a></li><li><a href="/blog/NodeJS">NodeJS</a></li><li><a href="/blog/ReactJS">ReactJS</a></li><li><a href="/blog/UI设计">UI设计</a></li><li><a href="/blog/webpack4系列教程">webpack4系列教程</a></li><li><a href="/blog/前端知识体系">前端知识体系</a></li><li><a href="/blog/剑指offer刷题笔记">剑指offer刷题笔记</a></li><li><a href="/blog/思考与成长">思考与成长</a></li><li><a href="/blog/设计模式手册">设计模式手册</a></li></ul></li></ul><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "><button title="Dark theme" class="__dumi-default-dark-moon "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="3854" width="22" height="22"><path d="M991.816611 674.909091a69.166545 69.166545 0 0 0-51.665455-23.272727 70.795636 70.795636 0 0 0-27.438545 5.585454A415.674182 415.674182 0 0 1 754.993338 698.181818c-209.594182 0-393.472-184.785455-393.472-395.636363 0-52.363636 38.539636-119.621818 69.515637-173.614546 4.887273-8.610909 9.634909-16.756364 14.103272-24.901818A69.818182 69.818182 0 0 0 384.631156 0a70.842182 70.842182 0 0 0-27.438545 5.585455C161.678429 90.298182 14.362065 307.898182 14.362065 512c0 282.298182 238.824727 512 532.38691 512a522.286545 522.286545 0 0 0 453.957818-268.334545A69.818182 69.818182 0 0 0 991.816611 674.909091zM546.679156 954.181818c-248.785455 0-462.941091-192-462.941091-442.181818 0-186.647273 140.637091-372.829091 300.939637-442.181818-36.817455 65.629091-92.578909 151.970909-92.578909 232.727273 0 250.181818 214.109091 465.454545 462.917818 465.454545a488.331636 488.331636 0 0 0 185.181091-46.545455 453.003636 453.003636 0 0 1-393.565091 232.727273z m103.656728-669.323636l-14.266182 83.781818a34.909091 34.909091 0 0 0 50.362182 36.770909l74.775272-39.563636 74.752 39.563636a36.142545 36.142545 0 0 0 16.174546 3.956364 34.909091 34.909091 0 0 0 34.210909-40.727273l-14.289455-83.781818 60.509091-59.345455a35.025455 35.025455 0 0 0-19.223272-59.578182l-83.61891-12.101818-37.376-76.101818a34.56 34.56 0 0 0-62.254545 0l-37.376 76.101818-83.618909 12.101818a34.909091 34.909091 0 0 0-19.246546 59.578182z m70.423272-64.698182a34.280727 34.280727 0 0 0 26.135273-19.083636l14.312727-29.090909 14.336 29.090909a34.257455 34.257455 0 0 0 26.135273 19.083636l32.046546 4.887273-23.272728 22.574545a35.234909 35.234909 0 0 0-10.007272 30.952727l5.46909 32.116364-28.625454-15.127273a34.490182 34.490182 0 0 0-32.302546 0l-28.695272 15.127273 5.469091-32.116364a35.141818 35.141818 0 0 0-9.984-30.952727l-23.272728-22.574545z" p-id="3855"></path></svg></button><button title="Light theme" class="__dumi-default-dark-sun "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="4026" width="22" height="22"><path d="M915.2 476.16h-43.968c-24.704 0-44.736 16-44.736 35.84s20.032 35.904 44.736 35.904H915.2c24.768 0 44.8-16.064 44.8-35.904s-20.032-35.84-44.8-35.84zM512 265.6c-136.704 0-246.464 109.824-246.464 246.4 0 136.704 109.76 246.464 246.464 246.464S758.4 648.704 758.4 512c0-136.576-109.696-246.4-246.4-246.4z m0 425.6c-99.008 0-179.2-80.128-179.2-179.2 0-98.944 80.192-179.2 179.2-179.2S691.2 413.056 691.2 512c0 99.072-80.192 179.2-179.2 179.2zM197.44 512c0-19.84-19.136-35.84-43.904-35.84H108.8c-24.768 0-44.8 16-44.8 35.84s20.032 35.904 44.8 35.904h44.736c24.768 0 43.904-16.064 43.904-35.904zM512 198.464c19.776 0 35.84-20.032 35.84-44.8v-44.8C547.84 84.032 531.84 64 512 64s-35.904 20.032-35.904 44.8v44.8c0 24.768 16.128 44.864 35.904 44.864z m0 627.136c-19.776 0-35.904 20.032-35.904 44.8v44.736C476.096 940.032 492.16 960 512 960s35.84-20.032 35.84-44.8v-44.736c0-24.768-16.064-44.864-35.84-44.864z m329.92-592.832c17.472-17.536 20.288-43.072 6.4-57.024-14.016-14.016-39.488-11.2-57.024 6.336-4.736 4.864-26.496 26.496-31.36 31.36-17.472 17.472-20.288 43.008-6.336 57.024 13.952 14.016 39.488 11.2 57.024-6.336 4.8-4.864 26.496-26.56 31.296-31.36zM213.376 759.936c-4.864 4.8-26.56 26.624-31.36 31.36-17.472 17.472-20.288 42.944-6.4 56.96 14.016 13.952 39.552 11.2 57.024-6.336 4.8-4.736 26.56-26.496 31.36-31.36 17.472-17.472 20.288-43.008 6.336-56.96-14.016-13.952-39.552-11.072-56.96 6.336z m19.328-577.92c-17.536-17.536-43.008-20.352-57.024-6.336-14.08 14.016-11.136 39.488 6.336 57.024 4.864 4.864 26.496 26.56 31.36 31.424 17.536 17.408 43.008 20.288 56.96 6.336 14.016-14.016 11.264-39.488-6.336-57.024-4.736-4.864-26.496-26.56-31.296-31.424z m527.168 628.608c4.864 4.864 26.624 26.624 31.36 31.424 17.536 17.408 43.072 20.224 57.088 6.336 13.952-14.016 11.072-39.552-6.4-57.024-4.864-4.8-26.56-26.496-31.36-31.36-17.472-17.408-43.072-20.288-57.024-6.336-13.952 14.016-11.008 39.488 6.336 56.96z" p-id="4027"></path></svg></button><button title="Default to system" class="__dumi-default-dark-auto "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="11002" width="22" height="22"><path d="M127.658667 492.885333c0-51.882667 10.24-101.717333 30.378666-149.162666s47.786667-88.064 81.92-122.538667 75.093333-61.781333 122.538667-81.92 96.938667-30.378667 149.162667-30.378667 101.717333 10.24 149.162666 30.378667 88.405333 47.786667 122.88 81.92 61.781333 75.093333 81.92 122.538667 30.378667 96.938667 30.378667 149.162666-10.24 101.717333-30.378667 149.162667-47.786667 88.405333-81.92 122.88-75.093333 61.781333-122.88 81.92-97.28 30.378667-149.162666 30.378667-101.717333-10.24-149.162667-30.378667-88.064-47.786667-122.538667-81.92-61.781333-75.093333-81.92-122.88-30.378667-96.938667-30.378666-149.162667z m329.045333 0c0 130.048 13.994667 244.394667 41.984 343.381334h12.970667c46.762667 0 91.136-9.216 133.461333-27.306667s78.848-42.666667 109.568-73.386667 54.954667-67.242667 73.386667-109.568 27.306667-86.698667 27.306666-133.461333c0-46.421333-9.216-90.794667-27.306666-133.12s-42.666667-78.848-73.386667-109.568-67.242667-54.954667-109.568-73.386667-86.698667-27.306667-133.461333-27.306666h-11.605334c-28.672 123.562667-43.349333 237.909333-43.349333 343.722666z" p-id="11003"></path></svg></button></div></div></div><ul class="__dumi-default-menu-list"><li><a href="/blog/">大师兄 - 前端架构师</a></li></ul></div></div><ul role="slug-list" class="__dumi-default-layout-toc"><li title="自动化创建服务工具" data-depth="2"><a href="/blog/手把手带你写一个web框架/04.实战第3关完善功能/04#自动化创建服务工具"><span>自动化创建服务工具</span></a></li><li title="命令创建" data-depth="3"><a href="/blog/手把手带你写一个web框架/04.实战第3关完善功能/04#命令创建"><span>命令创建</span></a></li><li title="List命令的实现" data-depth="3"><a href="/blog/手把手带你写一个web框架/04.实战第3关完善功能/04#list命令的实现"><span>List命令的实现</span></a></li><li title="new命令的实现" data-depth="3"><a href="/blog/手把手带你写一个web框架/04.实战第3关完善功能/04#new命令的实现"><span>new命令的实现</span></a></li><li title="自动化创建命令行工具" data-depth="2"><a href="/blog/手把手带你写一个web框架/04.实战第3关完善功能/04#自动化创建命令行工具"><span>自动化创建命令行工具</span></a></li><li title="自动化中间件迁移工具" data-depth="2"><a href="/blog/手把手带你写一个web框架/04.实战第3关完善功能/04#自动化中间件迁移工具"><span>自动化中间件迁移工具</span></a></li><li title="小结" data-depth="2"><a href="/blog/手把手带你写一个web框架/04.实战第3关完善功能/04#小结"><span>小结</span></a></li><li title="思考题" data-depth="3"><a href="/blog/手把手带你写一个web框架/04.实战第3关完善功能/04#思考题"><span>思考题</span></a></li></ul><div class="__dumi-default-layout-content"><div class="markdown"><h1 id="21自动化上dry如何自动化一切重复性劳动"><a aria-hidden="true" tabindex="-1" href="/blog/手把手带你写一个web框架/04.实战第3关完善功能/04#21自动化上dry如何自动化一切重复性劳动"><span class="icon icon-link"></span></a>21｜自动化（上）：DRY，如何自动化一切重复性劳动？</h1><p>你好，我是轩脉刃。</p><p>不知道你有没有听过这种说法，优秀程序员应该有三大美德：懒惰、急躁和傲慢，这句话是Perl语言的发明者Larry Wall说的。其中懒惰这一点指的就是，程序员为了懒惰，不重复做同样的事情，会思考是否能把一切重复性的劳动自动化（don’t repeat yourself）。</p><p>而框架开发到这里，我们也需要思考，有哪些重复性劳动可以自动化么？</p><p>从第十章到现在我们一直在说，框架核心是服务提供者，在开发具体应用时，一定会有很多需求要创建各种各样的服务，毕竟“一切皆服务”；而每次创建服务的时候，我们都需要至少编写三个文件，服务接口、服务提供者、服务实例。<strong>如果能自动生成三个文件，提供一个“自动化创建服务的工具”，应该能节省不少的操作</strong>。</p><p>说到创建工具，我们经常需要为了一个事情而创建一个命令行工具，而每次创建命令行工具，也都需要创建固定的Command.go文件，其中有固定的Command结构，这些代码我们能不能偷个懒，“<strong>自动化创建命令行工具</strong>”呢？</p><p>另外之前我们做过几次中间件的迁移，先将源码拷贝复制，再修改对应的Gin路径，这个操作也是颇为繁琐的。那么，我们是否可以写一个“<strong>自动化中间件迁移工具</strong>”，一个命令自动复制和替换呢？</p><p>这些命令都是可以实现的，这节课我们就来尝试完成这三项自动化，“自动化创建服务工具”， “自动化创建命令行工具”，以及“自动化中间件迁移工具”。</p><h2 id="自动化创建服务工具"><a aria-hidden="true" tabindex="-1" href="/blog/手把手带你写一个web框架/04.实战第3关完善功能/04#自动化创建服务工具"><span class="icon icon-link"></span></a>自动化创建服务工具</h2><p>在创建各种各样的服务时，“自动化创建服务工具”能帮我们节省不少开发时间。我们先思考下这个工具应该如何实现。</p><p>既然之前已经引入cobra，将框架修改为可以支持命令行工具，创建命令并不是一个难事，我们来定义一套创建服务的provider 命令即可。照旧先设计好要创建的命令，再一一实现。</p><h3 id="命令创建"><a aria-hidden="true" tabindex="-1" href="/blog/手把手带你写一个web框架/04.实战第3关完善功能/04#命令创建"><span class="icon icon-link"></span></a>命令创建</h3><p>“自动化创建服务工具”如何设计命令层级呢？我们设计一个一级命令和两个二级命令：</p><ul><li><code>./hade provider</code> 一级命令，provider，打印帮助信息；</li><li><code>./hade provider new</code> 二级命令，创建一个服务；</li><li><code>./hade provider list</code> 二级命令，列出容器内的所有服务，列出它们的字符串凭证。</li></ul><p>首先将provider的这两个二级命令，都存放在command/provider.go中。而对应的一级命令 providerCommand 是一个打印帮助信息的空实现。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// providerCommand 一级命令</span></div><div class="token-line"><span class="token plain">    var providerCommand = &amp;cobra.Command{</span></div><div class="token-line"><span class="token plain">       Use:   &quot;provider&quot;,</span></div><div class="token-line"><span class="token plain">       Short: &quot;服务提供相关命令&quot;,</span></div><div class="token-line"><span class="token plain">       RunE: func(c *cobra.Command, args []string) error {</span></div><div class="token-line"><span class="token plain">          if len(args) == 0 {</span></div><div class="token-line"><span class="token plain">             c.Help()</span></div><div class="token-line"><span class="token plain">          }</span></div><div class="token-line"><span class="token plain">          return nil</span></div><div class="token-line"><span class="token plain">       },</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>预先将两个二级命令挂载到这个一级命令中，在 framework/command/provider.go：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// 初始化provider相关服务</span></div><div class="token-line"><span class="token plain">    func initProviderCommand() *cobra.Command {</span></div><div class="token-line"><span class="token plain">       providerCommand.AddCommand(providerCreateCommand)</span></div><div class="token-line"><span class="token plain">       providerCommand.AddCommand(providerListCommand)</span></div><div class="token-line"><span class="token plain">       return providerCommand</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>并且在 framework/command/kernel.go，将这个一级命令挂载到一级命令rootCommand中：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">func AddKernelCommands(root *cobra.Command) {</span></div><div class="token-line"><span class="token plain">       // provider一级命令</span></div><div class="token-line"><span class="token plain">       root.AddCommand(initProviderCommand()</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>下面来实现这两个二级命令new和list。</p><h3 id="list命令的实现"><a aria-hidden="true" tabindex="-1" href="/blog/手把手带你写一个web框架/04.实战第3关完善功能/04#list命令的实现"><span class="icon icon-link"></span></a>List命令的实现</h3><p>先说 <code>./hade provider list</code> 这个命令，因为列出容器内的所有服务是比较简单的。还记得吗，在十一章实现服务容器的时候，其中有一个providers，它存储所有的服务容器提供者，放在文件 framework/container.go 中：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// HadeContainer 是服务容器的具体实现</span></div><div class="token-line"><span class="token plain">    type HadeContainer struct {</span></div><div class="token-line"><span class="token plain">    	...</span></div><div class="token-line"><span class="token plain">    	// providers 存储注册的服务提供者，key 为字符串凭证</span></div><div class="token-line"><span class="token plain">    	providers map[string]ServiceProvider</span></div><div class="token-line"><span class="token plain">        ...</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>我们只需要将这个providers进行遍历，根据其中每个ServiceProvider的Name() 方法，获取字符串凭证列表即可。</p><p>所以，在framework/container.go 的HadeContainer中，增加一个NameList方法，返回所有提供服务者的字符串凭证，方法也很简单，直接遍历这个providers 字段。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// NameList 列出容器中所有服务提供者的字符串凭证</span></div><div class="token-line"><span class="token plain">    func (hade *HadeContainer) NameList() []string {</span></div><div class="token-line"><span class="token plain">       ret := []string{}</span></div><div class="token-line"><span class="token plain">       for _, provider := range hade.providers {</span></div><div class="token-line"><span class="token plain">          name := provider.Name()</span></div><div class="token-line"><span class="token plain">          ret = append(ret, name)</span></div><div class="token-line"><span class="token plain">       }</span></div><div class="token-line"><span class="token plain">       return ret</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>而在 framework/command/provider.go 中的providerListCommand 命令中，我们调用这个命令并且打印出来。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// providerListCommand 列出容器内的所有服务</span></div><div class="token-line"><span class="token plain">    var providerListCommand = &amp;cobra.Command{</span></div><div class="token-line"><span class="token plain">       Use:   &quot;list&quot;,</span></div><div class="token-line"><span class="token plain">       Short: &quot;列出容器内的所有服务&quot;,</span></div><div class="token-line"><span class="token plain">       RunE: func(c *cobra.Command, args []string) error {</span></div><div class="token-line"><span class="token plain">          container := c.GetContainer()</span></div><div class="token-line"><span class="token plain">          hadeContainer := container.(*framework.HadeContainer)</span></div><div class="token-line"><span class="token plain">          // 获取字符串凭证</span></div><div class="token-line"><span class="token plain">          list := hadeContainer.NameList()</span></div><div class="token-line"><span class="token plain">          // 打印</span></div><div class="token-line"><span class="token plain">          for _, line := range list {</span></div><div class="token-line"><span class="token plain">             println(line)</span></div><div class="token-line"><span class="token plain">          }</span></div><div class="token-line"><span class="token plain">          return nil</span></div><div class="token-line"><span class="token plain">       },</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>可以验证一下。编译 <code>./hade build self</code> 并且执行 <code>./hade provider list</code> ，可以看到如下信息：<br/><img src="https://static001.geekbang.org/resource/image/0c/35/0c4d1fb73cd17aabc02fe7c3b5f2f335.png?wh=481x215" alt=""/></p><p>你可以很清晰看到容器中绑定了哪些服务提供者，它们的字符串凭证是什么。这样我们在定义一个新的服务的时候，可以很方便看到哪些服务提供者的关键字已经被使用了，避免使用已有的服务关键字。</p><p>下面我们来说稍微复杂一点的创建服务的命令 <code>./hade provider new</code> 。</p><h3 id="new命令的实现"><a aria-hidden="true" tabindex="-1" href="/blog/手把手带你写一个web框架/04.实战第3关完善功能/04#new命令的实现"><span class="icon icon-link"></span></a>new命令的实现</h3><p>在实际业务开发过程中，我们一想到一个服务，比如去某个用户系统获取信息，一定会想到创建服务的三步骤：创建一个用户系统的交互协议contract.go、再创建一个提供协议的用户服务提供者 provider.go、最后才实现具体的用户服务实例 service.go。</p><p>每次都需要创建这三个文件，且这三个文件的文件大框架都有套路可言。那我们如何将这些重复的套路性的代码自动化生成呢？</p><p>首先这里有一个增加参数的过程，我们需要知道要创建服务的服务名是什么？创建这个服务的文件夹名字是什么？当然了，这些参数也可以使用在命令后面增加flag参数的方式来表示。但是其实还有一种更便捷的方式：交互。</p><p>交互的表现形式如：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">输入：./hade provider new (我想创建一个服务)</span></div><div class="token-line"><span class="token plain">    输出：请输入服务名称(服务凭证):</span></div><div class="token-line"><span class="token plain">    输入：demo</span></div><div class="token-line"><span class="token plain">    输出：请求输入服务目录名称(默认和服务名称相同)：</span></div><div class="token-line"><span class="token plain">    输入：demo</span></div><div class="token-line"><span class="token plain">    输出：创建服务成功, 文件夹地址：xxxxx</span></div><div class="token-line"><span class="token plain">    输出：请不要忘记挂载新创建的服务</span></div></pre></div><p>这种命令行交互的方式是不是更智能化？但是如何实现呢？</p><p>这里我们借助一个第三方库 <a target="_blank" rel="noopener noreferrer" href="https://github.com/AlecAivazis/survey">survey<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>。这个库目前在GitHub上已经有2.7k个star，最新版本是v2版本，使用的是MIT License协议，可以放心使用。这个survey库支持多种交互模式：单行输入、多行输入、单选、多选、y/n 确认选择，在<a target="_blank" rel="noopener noreferrer" href="https://github.com/AlecAivazis/survey">项目GitHub首页<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>上就能很清晰看到这个库的使用方式。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">name := false</span></div><div class="token-line"><span class="token plain">    // 使用survey.XXX 的方式来选择交互形式</span></div><div class="token-line"><span class="token plain">    prompt := &amp;survey.Confirm{</span></div><div class="token-line"><span class="token plain">        Message: &quot;Do you like pie?&quot;,</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    // 使用&amp;将最终的选择存储进入变量</span></div><div class="token-line"><span class="token plain">    survey.AskOne(prompt, &amp;name)</span></div></pre></div><p>在provider new命令中，我们也可以用survey 来增加交互性。通过交互，我们可以确认用户想创建的服务凭证，以及想把这个服务创建在 app/provider/ 下的哪个目录中。</p><p>当然，<strong>在用户通过交互输入了服务凭证和服务目录之后，是需要进行参数判断的</strong>。服务凭证需要和容器中已注册服务的字符串凭证进行比较，如果已经存在了，应该报错；而服务目录如果已经存在，也应该直接报错。</p><p>如果都验证ok了，最后一步就是在 app/provider/ 下创建对应的服务目录，在目录下创建contract.go、provider.go、service.go 三个文件，并且在三个文件中根据预先定义好的模版填充内容。这里我们如何实现呢？使用模版、变更模版中的某些字段、形成新的文本，这个你应该能联想到 Golang 标准库中的 <a target="_blank" rel="noopener noreferrer" href="https://pkg.go.dev/text/template">text/template<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 库。</p><p>这个库的使用方法比较多，我这里把我们用得到的方法解说一下，解析contract.go文件的生成过程，就可以了解其使用方法了。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// 创建title这个模版方法</span></div><div class="token-line"><span class="token plain">    funcs := template.FuncMap{&quot;title&quot;: strings.Title}</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">       //  创建contract.go</span></div><div class="token-line"><span class="token plain">       file := filepath.Join(pFolder, folder, &quot;contract.go&quot;)</span></div><div class="token-line"><span class="token plain">       f, err := os.Create(file)</span></div><div class="token-line"><span class="token plain">       if err != nil {</span></div><div class="token-line"><span class="token plain">          return errors.Cause(err)</span></div><div class="token-line"><span class="token plain">       }</span></div><div class="token-line"><span class="token plain">       // 使用contractTmp模版来初始化template，并且让这个模版支持title方法，即支持{{.|title}}</span></div><div class="token-line"><span class="token plain">       t := template.Must(template.New(&quot;contract&quot;).Funcs(funcs).Parse(contractTmp))</span></div><div class="token-line"><span class="token plain">       // 将name传递进入到template中渲染，并且输出到contract.go 中</span></div><div class="token-line"><span class="token plain">       if err := t.Execute(f, name); err != nil {</span></div><div class="token-line"><span class="token plain">          return errors.Cause(err)</span></div><div class="token-line"><span class="token plain">       }</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>上面代码的逻辑最核心的就是创建模版的template.Must 和渲染模版的t.Execute方法。</p><p>但是在创建模版之前，我们使用了一个<strong>template.FuncMap方法，它比较不好理解，主要作用就是在模版中，让我们可以使用定义的模版方法来控制渲染效果</strong>。这个FuncMap结构定义了模版中支持的模版方法，比如我支持title这个方法，这个方法实际调用的是string.Title 函数，把字符串首字母大写。</p><p>在刚才的代码中，我们使用contractTmp来创建模版，在渲染contractTmp的时候，传递了一个name变量。假设这个name变量代表的是字符串user，而我希望创建一个字符串“NameKey”的变量，可以这么定义contractTmp：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">var contractTmp string = `package {{.}}</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    const {{.|title}}Key = &quot;{{.}}&quot;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    type Service interface {</span></div><div class="token-line"><span class="token plain">       // 请在这里定义你的方法</span></div><div class="token-line"><span class="token plain">        Foo() string</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    `</span></div></pre></div><p>注意到了么，其中的<!-- -->{<!-- -->{<!-- -->.|title<!-- -->}<!-- -->}<!-- --> 实际上是相当于调用了strings.Title(name) 的方法填充，能将字符串name替换为字符串Name。</p><p>而定义好了FuncMap之后，我们随后使用了os.Create创建contract.go文件，然后初始化template：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">t := template.Must(template.New(&quot;contract&quot;).Funcs(funcs).Parse(contractTmp))</span></div></pre></div><p>这行代码的几个函数我们来看看。</p><p><strong>template.Must 表示后面的template创建必须成功，否则会panic</strong>。这种Must的方法来简化代码的error处理逻辑，在标准库中经常使用。我们的hade框架的MustMake也是同样的原理。</p><p>template.New() 方法，创建一个text/template 的 Template结构，其中的参数contract字符串是为这个Template结构命名的，后面的Funcs() 方法是将签名定义的模版函数注册到这个Template结构中，最后的Parse()是使用这个Template结构解析具体的模版文本。</p><p>定义好了模版t之后，使用代码：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">t.Execute(f, name)</span></div></pre></div><p>来将变量name 注册进入模版t，并且输出到f。这里的f，是我们之前创建的contract.go文件。也就是使用变量name解析模版t，输出到contract.go文件中。</p><p>这里的变量可以是一个struct结构，也可以是基础变量，比如我们这里定义的字符串。在模版中<!-- -->{<!-- -->{<!-- -->.<!-- -->}<!-- -->}<!-- --> 就代表这个结构。所以再回顾前面定义的contractTmp模版，你会看出其中变量name为字符串user的时候，最终的显示是什么吗？</p><p>好，创建服务命令的所有思路我们就梳理清楚了，最后也贴出完整的代码供你参考，关键步骤都在注释中详细说明了，实现并不难：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// providerCreateCommand 创建一个新的服务，包括服务提供者，服务接口协议，服务实例</span></div><div class="token-line"><span class="token plain">    var providerCreateCommand = &amp;cobra.Command{</span></div><div class="token-line"><span class="token plain">       Use:     &quot;new&quot;,</span></div><div class="token-line"><span class="token plain">       Aliases: []string{&quot;create&quot;, &quot;init&quot;},</span></div><div class="token-line"><span class="token plain">       Short:   &quot;创建一个服务&quot;,</span></div><div class="token-line"><span class="token plain">       RunE: func(c *cobra.Command, args []string) error {</span></div><div class="token-line"><span class="token plain">          container := c.GetContainer()</span></div><div class="token-line"><span class="token plain">          fmt.Println(&quot;创建一个服务&quot;)</span></div><div class="token-line"><span class="token plain">          var name string</span></div><div class="token-line"><span class="token plain">          var folder string</span></div><div class="token-line"><span class="token plain">          {</span></div><div class="token-line"><span class="token plain">             prompt := &amp;survey.Input{</span></div><div class="token-line"><span class="token plain">                Message: &quot;请输入服务名称(服务凭证)：&quot;,</span></div><div class="token-line"><span class="token plain">             }</span></div><div class="token-line"><span class="token plain">             err := survey.AskOne(prompt, &amp;name)</span></div><div class="token-line"><span class="token plain">             if err != nil {</span></div><div class="token-line"><span class="token plain">                return err</span></div><div class="token-line"><span class="token plain">             }</span></div><div class="token-line"><span class="token plain">          }</span></div><div class="token-line"><span class="token plain">          {</span></div><div class="token-line"><span class="token plain">             prompt := &amp;survey.Input{</span></div><div class="token-line"><span class="token plain">                Message: &quot;请输入服务所在目录名称(默认: 同服务名称):&quot;,</span></div><div class="token-line"><span class="token plain">             }</span></div><div class="token-line"><span class="token plain">             err := survey.AskOne(prompt, &amp;folder)</span></div><div class="token-line"><span class="token plain">             if err != nil {</span></div><div class="token-line"><span class="token plain">                return err</span></div><div class="token-line"><span class="token plain">             }</span></div><div class="token-line"><span class="token plain">          }</span></div><div class="token-line"><span class="token plain">          // 检查服务是否存在</span></div><div class="token-line"><span class="token plain">          providers := container.(*framework.HadeContainer).NameList()</span></div><div class="token-line"><span class="token plain">          providerColl := collection.NewStrCollection(providers)</span></div><div class="token-line"><span class="token plain">          if providerColl.Contains(name) {</span></div><div class="token-line"><span class="token plain">             fmt.Println(&quot;服务名称已经存在&quot;)</span></div><div class="token-line"><span class="token plain">             return nil</span></div><div class="token-line"><span class="token plain">          }</span></div><div class="token-line"><span class="token plain">          if folder == &quot;&quot; {</span></div><div class="token-line"><span class="token plain">             folder = name</span></div><div class="token-line"><span class="token plain">          }</span></div><div class="token-line"><span class="token plain">          app := container.MustMake(contract.AppKey).(contract.App)</span></div><div class="token-line"><span class="token plain">          pFolder := app.ProviderFolder()</span></div><div class="token-line"><span class="token plain">          subFolders, err := util.SubDir(pFolder)</span></div><div class="token-line"><span class="token plain">          if err != nil {</span></div><div class="token-line"><span class="token plain">             return err</span></div><div class="token-line"><span class="token plain">          }</span></div><div class="token-line"><span class="token plain">          subColl := collection.NewStrCollection(subFolders)</span></div><div class="token-line"><span class="token plain">          if subColl.Contains(folder) {</span></div><div class="token-line"><span class="token plain">             fmt.Println(&quot;目录名称已经存在&quot;)</span></div><div class="token-line"><span class="token plain">             return nil</span></div><div class="token-line"><span class="token plain">          }</span></div><div class="token-line"><span class="token plain">          // 开始创建文件</span></div><div class="token-line"><span class="token plain">          if err := os.Mkdir(filepath.Join(pFolder, folder), 0700); err != nil {</span></div><div class="token-line"><span class="token plain">             return err</span></div><div class="token-line"><span class="token plain">          }</span></div><div class="token-line"><span class="token plain">          // 创建title这个模版方法</span></div><div class="token-line"><span class="token plain">          funcs := template.FuncMap{&quot;title&quot;: strings.Title}</span></div><div class="token-line"><span class="token plain">          {</span></div><div class="token-line"><span class="token plain">             //  创建contract.go</span></div><div class="token-line"><span class="token plain">             file := filepath.Join(pFolder, folder, &quot;contract.go&quot;)</span></div><div class="token-line"><span class="token plain">             f, err := os.Create(file)</span></div><div class="token-line"><span class="token plain">             if err != nil {</span></div><div class="token-line"><span class="token plain">                return errors.Cause(err)</span></div><div class="token-line"><span class="token plain">             }</span></div><div class="token-line"><span class="token plain">             // 使用contractTmp模版来初始化template，并且让这个模版支持title方法，即支持{{.|title}}</span></div><div class="token-line"><span class="token plain">             t := template.Must(template.New(&quot;contract&quot;).Funcs(funcs).Parse(contractTmp))</span></div><div class="token-line"><span class="token plain">             // 将name传递进入到template中渲染，并且输出到contract.go 中</span></div><div class="token-line"><span class="token plain">             if err := t.Execute(f, name); err != nil {</span></div><div class="token-line"><span class="token plain">                return errors.Cause(err)</span></div><div class="token-line"><span class="token plain">             }</span></div><div class="token-line"><span class="token plain">          }</span></div><div class="token-line"><span class="token plain">          {</span></div><div class="token-line"><span class="token plain">             // 创建provider.go</span></div><div class="token-line"><span class="token plain">             file := filepath.Join(pFolder, folder, &quot;provider.go&quot;)</span></div><div class="token-line"><span class="token plain">             f, err := os.Create(file)</span></div><div class="token-line"><span class="token plain">             if err != nil {</span></div><div class="token-line"><span class="token plain">                return err</span></div><div class="token-line"><span class="token plain">             }</span></div><div class="token-line"><span class="token plain">             t := template.Must(template.New(&quot;provider&quot;).Funcs(funcs).Parse(providerTmp))</span></div><div class="token-line"><span class="token plain">             if err := t.Execute(f, name); err != nil {</span></div><div class="token-line"><span class="token plain">                return err</span></div><div class="token-line"><span class="token plain">             }</span></div><div class="token-line"><span class="token plain">          }</span></div><div class="token-line"><span class="token plain">          {</span></div><div class="token-line"><span class="token plain">             //  创建service.go</span></div><div class="token-line"><span class="token plain">             file := filepath.Join(pFolder, folder, &quot;service.go&quot;)</span></div><div class="token-line"><span class="token plain">             f, err := os.Create(file)</span></div><div class="token-line"><span class="token plain">             if err != nil {</span></div><div class="token-line"><span class="token plain">                return err</span></div><div class="token-line"><span class="token plain">             }</span></div><div class="token-line"><span class="token plain">             t := template.Must(template.New(&quot;service&quot;).Funcs(funcs).Parse(serviceTmp))</span></div><div class="token-line"><span class="token plain">             if err := t.Execute(f, name); err != nil {</span></div><div class="token-line"><span class="token plain">                return err</span></div><div class="token-line"><span class="token plain">             }</span></div><div class="token-line"><span class="token plain">          }</span></div><div class="token-line"><span class="token plain">          fmt.Println(&quot;创建服务成功, 文件夹地址:&quot;, filepath.Join(pFolder, folder))</span></div><div class="token-line"><span class="token plain">          fmt.Println(&quot;请不要忘记挂载新创建的服务&quot;)</span></div><div class="token-line"><span class="token plain">          return nil</span></div><div class="token-line"><span class="token plain">       },</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    var contractTmp string = `package {{.}}</span></div><div class="token-line"><span class="token plain">    const {{.|title}}Key = &quot;{{.}}&quot;</span></div><div class="token-line"><span class="token plain">    type Service interface {</span></div><div class="token-line"><span class="token plain">       // 请在这里定义你的方法</span></div><div class="token-line"><span class="token plain">        Foo() string</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    `</span></div><div class="token-line"><span class="token plain">    var providerTmp string = `package {{.}}</span></div><div class="token-line"><span class="token plain">    import (</span></div><div class="token-line"><span class="token plain">       &quot;github.com/gohade/hade/framework&quot;</span></div><div class="token-line"><span class="token plain">    )</span></div><div class="token-line"><span class="token plain">    type {{.|title}}Provider struct {</span></div><div class="token-line"><span class="token plain">       framework.ServiceProvider</span></div><div class="token-line"><span class="token plain">       c framework.Container</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    func (sp *{{.|title}}Provider) Name() string {</span></div><div class="token-line"><span class="token plain">       return {{.|title}}Key</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    func (sp *{{.|title}}Provider) Register(c framework.Container) framework.NewInstance {</span></div><div class="token-line"><span class="token plain">       return New{{.|title}}Service</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    func (sp *{{.|title}}Provider) IsDefer() bool {</span></div><div class="token-line"><span class="token plain">       return false</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    func (sp *{{.|title}}Provider) Params(c framework.Container) []interface{} {</span></div><div class="token-line"><span class="token plain">       return []interface{}{c}</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    func (sp *{{.|title}}Provider) Boot(c framework.Container) error {</span></div><div class="token-line"><span class="token plain">       return nil</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    `</span></div><div class="token-line"><span class="token plain">    var serviceTmp string = `package {{.}}</span></div><div class="token-line"><span class="token plain">    import &quot;github.com/gohade/hade/framework&quot;</span></div><div class="token-line"><span class="token plain">    type {{.|title}}Service struct {</span></div><div class="token-line"><span class="token plain">       container framework.Container</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    func New{{.|title}}Service(params ...interface{}) (interface{}, error) {</span></div><div class="token-line"><span class="token plain">       container := params[0].(framework.Container)</span></div><div class="token-line"><span class="token plain">       return &amp;{{.|title}}Service{container: container}, nil</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    func (s *{{.|title}}Service) Foo() string {</span></div><div class="token-line"><span class="token plain">        return &quot;&quot;</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    `</span></div></pre></div><p>最后我们验证一下这个创建服务命令。同样编译./hade 命令之后，执行 <code>./hade provider new</code> , 定义服务凭证为user，目录名称同样为user。<br/><img src="https://static001.geekbang.org/resource/image/b7/3c/b7ae3ba7edee1ce7a216e891d1b8e23c.png?wh=620x193" alt=""/></p><p>能看到 app/provider/ 目录下创建了user文件夹，其中有contract.go、provider.go、service.go三个文件：<br/><img src="https://static001.geekbang.org/resource/image/46/e6/46900bb2ea53135b890763687f4cc0e6.png?wh=376x276" alt=""/></p><p>其中每个文件的定义都完整，且可以直接再次编译通过，验证完成！</p><h2 id="自动化创建命令行工具"><a aria-hidden="true" tabindex="-1" href="/blog/手把手带你写一个web框架/04.实战第3关完善功能/04#自动化创建命令行工具"><span class="icon icon-link"></span></a>自动化创建命令行工具</h2><p>到这里我们就完成了创建服务工具的自动化。开头提到具体运营一个应用的时候，我们也会经常需要创建一个自定义的命令行。比如运营一个网站，可能会创建一个命令来统计网站注册人数，也可能要创建一个命令来定期检查是否有违禁的文章需要封禁等。所以自动创建命令行工具在实际工作中是非常有必要的。</p><p>同服务命令一样，我们可以有一套创建命令行工具的命令。</p><ul><li><code>./hade command</code> 一级命令，显示帮助信息</li><li><code>./hade command list</code> 二级命令，列出所有控制台命令</li><li><code>./hade command new</code> 二级命令，创建一个控制台命令</li></ul><p>command相关的命令和provider的命令的实现基本是一致的。这里我们简要解说下重点，具体对应的代码详情可以参考GitHub上的<a target="_blank" rel="noopener noreferrer" href="https://github.com/gohade/coredemo/blob/geekbang/21/framework/command/cmd.go">framework/command/cmd.go<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 文件。</p><p>一级命令./hade command 我们就不说了，是简单地显示帮助信息。</p><p>二级命令 ./hade command list。功能是列出所有的控制台命令。这个功能实际上和直接调用 ./hade 显示的帮助信息差不多，把一级根命令全部列了出来，只不过我们使用了一个更为语义化的 ./hade command list 来显示。<br/><img src="https://static001.geekbang.org/resource/image/85/9e/85fd992ca12552e3d5fef51994b1079e.png?wh=946x722" alt=""/></p><p>它的实现也并不复杂，具体就是使用Root().Commands() 方法遍历一级跟命令的所有一级命令。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// cmdListCommand 列出所有的控制台命令</span></div><div class="token-line"><span class="token plain">    var cmdListCommand = &amp;cobra.Command{</span></div><div class="token-line"><span class="token plain">       Use:   &quot;list&quot;,</span></div><div class="token-line"><span class="token plain">       Short: &quot;列出所有控制台命令&quot;,</span></div><div class="token-line"><span class="token plain">       RunE: func(c *cobra.Command, args []string) error {</span></div><div class="token-line"><span class="token plain">          cmds := c.Root().Commands()</span></div><div class="token-line"><span class="token plain">          ps := [][]string{}</span></div><div class="token-line"><span class="token plain">          for _, cmd := range cmds {</span></div><div class="token-line"><span class="token plain">             line := []string{cmd.Name(), cmd.Short}</span></div><div class="token-line"><span class="token plain">             ps = append(ps, line)</span></div><div class="token-line"><span class="token plain">          }</span></div><div class="token-line"><span class="token plain">          util.PrettyPrint(ps)</span></div><div class="token-line"><span class="token plain">          return nil</span></div><div class="token-line"><span class="token plain">       },</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>二级命令 ./hade command new创建命令行工具，就是在app/console/command/ 文件夹下增加一个目录，然后在这个目录中存放命令的相关代码。</p><p>比如要创建一个foo命令，就是要在app/console/command/ 目录下创建一个foo目录，其中创建一个foo.go 文件名，这个文件名可以随意起，这里我们就和目录名保持一致。然后在 app/console/command/foo.go 文件中输入模版：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// 命令行工具模版</span></div><div class="token-line"><span class="token plain">    var cmdTmpl string = `package {{.}}</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    import (</span></div><div class="token-line"><span class="token plain">       &quot;fmt&quot;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">       &quot;github.com/gohade/hade/framework/cobra&quot;</span></div><div class="token-line"><span class="token plain">    )</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    var {{.|title}}Command = &amp;cobra.Command{</span></div><div class="token-line"><span class="token plain">       Use:   &quot;{{.}}&quot;,</span></div><div class="token-line"><span class="token plain">       Short: &quot;{{.}}&quot;,</span></div><div class="token-line"><span class="token plain">       RunE: func(c *cobra.Command, args []string) error {</span></div><div class="token-line"><span class="token plain">            container := c.GetContainer()</span></div><div class="token-line"><span class="token plain">          fmt.Println(container)</span></div><div class="token-line"><span class="token plain">          return nil</span></div><div class="token-line"><span class="token plain">       },</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>实现步骤也很简单：survery 交互先要求用户输入命令名称；然后要求用户输入文件夹名称，记得检查命令名称和文件夹名称是否合理；之后创建文件夹 app/console/command/xxx 和文件 app/console/command/xxx/xxx.go；最后使用template将模版写入文件中。</p><h2 id="自动化中间件迁移工具"><a aria-hidden="true" tabindex="-1" href="/blog/手把手带你写一个web框架/04.实战第3关完善功能/04#自动化中间件迁移工具"><span class="icon icon-link"></span></a>自动化中间件迁移工具</h2><p>除了服务工具和命令行工具的创建，对于中间件，我们在开发过程中也是经常会使用创建的，同样的，可以为中间件定义一系列的命令来自动化。</p><ul><li><code>./hade middleware</code> 一级命令，显示帮助信息</li><li><code>./hade middleware list</code> 二级命令，列出所有的业务中间件</li><li><code>./hade middleware new</code> 二级命令，创建一个新的业务中间件</li><li><code>./hade middleware migrate</code> 二级命令，迁移Gin已有的中间件</li></ul><p>其中的前面三个命令基本上和provider、command 命令如出一辙，我们就不赘述了，同样你可以通过GitHub 上的<a target="_blank" rel="noopener noreferrer" href="https://github.com/gohade/coredemo/blob/geekbang/21/framework/command/middleware.go">framework/command/middleware.go 文件<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>参考其具体实现，相信你可以顺利写出来。</p><p>这里重点说一下 <code>./hade middleware migrate</code> 命令。</p><p>不知道你有没有好奇，为什么迁移也要写一个命令？当时在将Gin迁移进入hade框架的时候我们说，Gin作为一个成熟的开源作品，有丰富的中间件库，存放GitHub的一个项目 <a target="_blank" rel="noopener noreferrer" href="https://github.com/gin-contrib/">gin-contrib<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 中。那么在开发过程中，我们一定会经常需要使用到这些中间件。</p><p>但是由于这些中间件使用到的Gin框架的地址为 ：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">github.com/gin-gonic/gin</span></div></pre></div><p>而我们的Gin框架地址为：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">github.com/gohade/hade/framework/gin</span></div></pre></div><p>所以我们不能使用import直接使用这些中间件，那么有没有一个办法，能直接一键迁移gin-contrib下的某个中间件呢？比如 <code>git@github.com:gin-contrib/cors.git</code> ，直接拷贝并且自动修改好Gin框架引用地址，放到我们的 app/http/middleware/ 目录中。</p><p>于是就有了这个 <code>./hade middleware migragte</code> 命令。下面就梳理一下这个命令的逻辑步骤。以下载cors中间件为例，我们的思路是从GitHub上将这个<a target="_blank" rel="noopener noreferrer" href="https://github.com/gin-contrib/cors">cors项目<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>复制下来，<strong>并且删除这个项目的一些不必要的文件</strong>。</p><p>什么是不必要的文件呢？.git目录、go.mod、go.sum，这些都是作为一个“项目”才会需要的，而我们要把项目中的这些删掉，让它成为一个文件，存放在我们的app/http/middleware/cors目录下。最后再遍历这个目录的所有文件，将所有出现“github.com/gin-gonic/gin” 的地方替换为“github.com/gohade/hade/framework/gin”就可以了。</p><p>从git上复制一个项目，在Golang中可以使用一个第三方库 <a target="_blank" rel="noopener noreferrer" href="https://github.com/go-git/go-git">go-git<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>，这个第三方库已经有2.7k 个star，且基于Apache 的Licence，是可以直接import使用的。目前这个库最新的版本为v5。</p><p>它的使用方式如下：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">_, err := git.PlainClone(&quot;/tmp/foo&quot;, false, &amp;git.CloneOptions{</span></div><div class="token-line"><span class="token plain">        URL:      &quot;https://github.com/go-git/go-git&quot;,</span></div><div class="token-line"><span class="token plain">        Progress: os.Stdout,</span></div><div class="token-line"><span class="token plain">    })</span></div></pre></div><p>将某个Git的URL地址使用gitclone，下载到/tmp/foo目录，并且把输出也输出到控制台。</p><p>我们也可以使用这样的方式进行复制。具体的代码逻辑也不难，归纳一下，migrate的实现步骤如下：</p><ol><li>参数中获取中间件名称；</li><li>使用go-git，将对应的gin-contrib的项目clone到目录/app/http/middleware；</li><li>删除不必要的文件go.mod、go.sum、.git；</li><li>替换关键字 “github.com/gin-gonic/gin”。</li></ol><p>在framework/command/middleware.go中，对应的代码如下：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// 从gin-contrib中迁移中间件</span></div><div class="token-line"><span class="token plain">    var middlewareMigrateCommand = &amp;cobra.Command{</span></div><div class="token-line"><span class="token plain">       Use:   &quot;migrate&quot;,</span></div><div class="token-line"><span class="token plain">       Short: &quot;迁移gin-contrib中间件, 迁移地址：https://github.com/gin-contrib/[middleware].git&quot;,</span></div><div class="token-line"><span class="token plain">       RunE: func(c *cobra.Command, args []string) error {</span></div><div class="token-line"><span class="token plain">          container := c.GetContainer()</span></div><div class="token-line"><span class="token plain">          fmt.Println(&quot;迁移一个Gin中间件&quot;)</span></div><div class="token-line"><span class="token plain">          // step1: 获取参数</span></div><div class="token-line"><span class="token plain">          var repo string</span></div><div class="token-line"><span class="token plain">          {</span></div><div class="token-line"><span class="token plain">             prompt := &amp;survey.Input{</span></div><div class="token-line"><span class="token plain">                Message: &quot;请输入中间件名称：&quot;,</span></div><div class="token-line"><span class="token plain">             }</span></div><div class="token-line"><span class="token plain">             err := survey.AskOne(prompt, &amp;repo)</span></div><div class="token-line"><span class="token plain">             if err != nil {</span></div><div class="token-line"><span class="token plain">                return err</span></div><div class="token-line"><span class="token plain">             }</span></div><div class="token-line"><span class="token plain">          }</span></div><div class="token-line"><span class="token plain">          // step2 : 下载git到一个目录中</span></div><div class="token-line"><span class="token plain">          appService := container.MustMake(contract.AppKey).(contract.App)</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">          middlewarePath := appService.MiddlewareFolder()</span></div><div class="token-line"><span class="token plain">          url := &quot;https://github.com/gin-contrib/&quot; + repo + &quot;.git&quot;</span></div><div class="token-line"><span class="token plain">          fmt.Println(&quot;下载中间件 gin-contrib:&quot;)</span></div><div class="token-line"><span class="token plain">          fmt.Println(url)</span></div><div class="token-line"><span class="token plain">          _, err := git.PlainClone(path.Join(middlewarePath, repo), false, &amp;git.CloneOptions{</span></div><div class="token-line"><span class="token plain">             URL:      url,</span></div><div class="token-line"><span class="token plain">             Progress: os.Stdout,</span></div><div class="token-line"><span class="token plain">          })</span></div><div class="token-line"><span class="token plain">          if err != nil {</span></div><div class="token-line"><span class="token plain">             return err</span></div><div class="token-line"><span class="token plain">          }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">          // step3:删除不必要的文件 go.mod, go.sum, .git</span></div><div class="token-line"><span class="token plain">          repoFolder := path.Join(middlewarePath, repo)</span></div><div class="token-line"><span class="token plain">          fmt.Println(&quot;remove &quot; + path.Join(repoFolder, &quot;go.mod&quot;))</span></div><div class="token-line"><span class="token plain">          os.Remove(path.Join(repoFolder, &quot;go.mod&quot;))</span></div><div class="token-line"><span class="token plain">          fmt.Println(&quot;remove &quot; + path.Join(repoFolder, &quot;go.sum&quot;))</span></div><div class="token-line"><span class="token plain">          os.Remove(path.Join(repoFolder, &quot;go.sum&quot;))</span></div><div class="token-line"><span class="token plain">          fmt.Println(&quot;remove &quot; + path.Join(repoFolder, &quot;.git&quot;))</span></div><div class="token-line"><span class="token plain">          os.RemoveAll(path.Join(repoFolder, &quot;.git&quot;))</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">          // step4 : 替换关键词</span></div><div class="token-line"><span class="token plain">          filepath.Walk(repoFolder, func(path string, info os.FileInfo, err error) error {</span></div><div class="token-line"><span class="token plain">             if info.IsDir() {</span></div><div class="token-line"><span class="token plain">                return nil</span></div><div class="token-line"><span class="token plain">             }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">             if filepath.Ext(path) != &quot;.go&quot; {</span></div><div class="token-line"><span class="token plain">                return nil</span></div><div class="token-line"><span class="token plain">             }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">             c, err := ioutil.ReadFile(path)</span></div><div class="token-line"><span class="token plain">             if err != nil {</span></div><div class="token-line"><span class="token plain">                return err</span></div><div class="token-line"><span class="token plain">             }</span></div><div class="token-line"><span class="token plain">             isContain := bytes.Contains(c, []byte(&quot;github.com/gin-gonic/gin&quot;))</span></div><div class="token-line"><span class="token plain">             if isContain {</span></div><div class="token-line"><span class="token plain">                fmt.Println(&quot;更新文件:&quot; + path)</span></div><div class="token-line"><span class="token plain">                c = bytes.ReplaceAll(c, []byte(&quot;github.com/gin-gonic/gin&quot;), []byte(&quot;github.com/gohade/hade/framework/gin&quot;))</span></div><div class="token-line"><span class="token plain">                err = ioutil.WriteFile(path, c, 0644)</span></div><div class="token-line"><span class="token plain">                if err != nil {</span></div><div class="token-line"><span class="token plain">                   return err</span></div><div class="token-line"><span class="token plain">                }</span></div><div class="token-line"><span class="token plain">             }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">             return nil</span></div><div class="token-line"><span class="token plain">          })</span></div><div class="token-line"><span class="token plain">          return nil</span></div><div class="token-line"><span class="token plain">       },</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>我们可以下载cors项目做一下验证，运行 <code>./hade middleware migrate</code> 命令，并且输入cors。你会在控制台看到这些信息：<br/><img src="https://static001.geekbang.org/resource/image/6f/5f/6fd8197207c92b3b362a89cc4676015f.png?wh=682x384" alt=""/></p><p>并且在目录中看到cors中间件已经完整下载下来了。<br/><img src="https://static001.geekbang.org/resource/image/70/09/709dbbc8c2140byy56459c202aa66909.png?wh=343x610" alt=""/></p><p>然后，可以直接在app/http/route.go中直接使用这个cors中间件：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">...</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    // Routes 绑定业务层路由</span></div><div class="token-line"><span class="token plain">    func Routes(r *gin.Engine) {</span></div><div class="token-line"><span class="token plain">       ...</span></div><div class="token-line"><span class="token plain">       // 使用cors中间件</span></div><div class="token-line"><span class="token plain">       r.Use(cors.Default())</span></div><div class="token-line"><span class="token plain">       ...</span></div><div class="token-line"><span class="token plain">     }</span></div></pre></div><p>验证完成！</p><p>今天所有代码都保存在GitHub上的<a target="_blank" rel="noopener noreferrer" href="https://github.com/gohade/coredemo/tree/geekbang/21">geekbang/21<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>分支了。附上目录结构供你对比查看，只修改了framework/command/目录下的cmd.go、provider.go、middleware.go文件。<br/><img src="https://static001.geekbang.org/resource/image/78/89/7889877151dc4d4e306554a64c550c89.png?wh=476x936" alt=""/></p><h2 id="小结"><a aria-hidden="true" tabindex="-1" href="/blog/手把手带你写一个web框架/04.实战第3关完善功能/04#小结"><span class="icon icon-link"></span></a>小结</h2><p>今天增加的命令不少，自动化创建服务工具、命令行工具，以及中间件迁移工具，这些命令都为我们后续开发应用提供了不少便利。</p><p>其实每个自动化命令行工具实现的思路都是差不多的，先思考清楚对于这个工具我们要自动化生成什么，然后使用代码和对应的模版生成对应的文件，并且替换其中特有的单词。原理不复杂，但是对于实际的工作，是非常有帮助的。</p><p>这一节课你应该可以感受到之前将cobra引入我们的框架是一个多么正确的决定，在cobra之上，我们才能实现这些方便的自动化工具。</p><h3 id="思考题"><a aria-hidden="true" tabindex="-1" href="/blog/手把手带你写一个web框架/04.实战第3关完善功能/04#思考题"><span class="icon icon-link"></span></a>思考题</h3><p>我们实现的自动化服务./hade command list命令，目前只展示了一级命令，在写这篇文章的时候我反思了一下，其实可以扩展成为树形结构展示，同时展示一级/二级/三级/命令。你可以想想如何实现，如果可以的话，可以去github.com/gohade/hade 项目中提交一个merge request 来补充这个功能吧！</p><p>欢迎在留言区分享你的思考。我们下节课见。</p></div><div class="__dumi-default-layout-footer-meta"><a target="_blank" rel="noopener noreferrer" href="https://github.com/GGwujun/blog/edit/master/docs/手把手带你写一个Web框架/04.实战第3关完善功能/04.md">在 GitHub 上编辑此页<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a><span data-updated-text="最后更新时间：">5/2/2022 10:56:58</span></div></div></div></div>
	<script>
  window.g_useSSR = true;
  window.g_initialProps = {};
	</script>

    <script>
      (function () {
        if (!location.port) {
          (function (i, s, o, g, r, a, m) {
            i["GoogleAnalyticsObject"] = r;
            (i[r] =
              i[r] ||
              function () {
                (i[r].q = i[r].q || []).push(arguments);
              }),
              (i[r].l = 1 * new Date());
            (a = s.createElement(o)), (m = s.getElementsByTagName(o)[0]);
            a.async = 1;
            a.src = g;
            m.parentNode.insertBefore(a, m);
          })(
            window,
            document,
            "script",
            "//www.google-analytics.com/analytics.js",
            "ga"
          );
          ga("create", "UA-149864185-1", "auto");
          ga("send", "pageview");
        }
      })();
    </script>
    <script src="/blog/umi.js"></script>
  </body>
</html>
