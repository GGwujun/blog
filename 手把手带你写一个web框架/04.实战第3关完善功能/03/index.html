<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no"
    />
    <link rel="shortcut icon" type="image/x-icon" href="/logo.png" />
    <link rel="stylesheet" href="/blog/umi.css" />
    <script>
      window.routerBase = "/blog";
    </script>
    <script>
      //! umi version: 3.5.17
    </script>
    <script>
      !(function () {
        var e = localStorage.getItem("dumi:prefers-color"),
          t = window.matchMedia("(prefers-color-scheme: dark)").matches,
          r = ["light", "dark", "auto"];
        document.documentElement.setAttribute(
          "data-prefers-color",
          e === r[2] ? (t ? r[1] : r[0]) : r.indexOf(e) > -1 ? e : r[0]
        );
      })();
    </script>
    <title>20｜提效（下）：实现调试模式加速开发效率</title>
  </head>
  <body>
    <div id="root"><div class="__dumi-default-layout" data-route="/手把手带你写一个web框架/04.实战第3关完善功能/03" data-show-sidemenu="true" data-show-slugs="true" data-site-mode="true" data-gapless="false"><div class="__dumi-default-navbar" data-mode="site"><button class="__dumi-default-navbar-toggle"></button><a class="__dumi-default-navbar-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog/">大师兄</a><nav><div class="__dumi-default-search"><input type="search" class="__dumi-default-search-input" value=""/><ul></ul></div><span>计算机基础<ul><li><a href="/blog/编译原理之美">编译原理之美</a></li><li><a href="/blog/编译原理实战">编译原理实战</a></li><li><a href="/blog/深入浅出计算机组成原理">深入浅出计算机组成原理</a></li><li><a href="/blog/详解http">详解http</a></li><li><a href="/blog/计算机网络通关29讲">计算机网络通关29讲</a></li><li><a href="/blog/网络排查案例课">网络排查案例课</a></li><li><a href="/blog/linux操作系统">linux操作系统</a></li><li><a href="/blog/linux性能优化实战">linux性能优化实战</a></li><li><a href="/blog/程序员数学基础">程序员数学基础</a></li><li><a href="/blog/趣谈网络协议">趣谈网络协议</a></li><li><a href="/blog/操作系统实战">操作系统实战</a></li><li><a href="/blog/软件工程之美">软件工程之美</a></li><li><a href="/blog/sql必知必会">sql必知必会</a></li><li><a href="/blog/操作系统实战45讲">操作系统实战45讲</a></li><li><a href="/blog/网络编程实战">网络编程实战</a></li></ul></span><span>算法<ul><li><a href="/blog/常用算法25讲">常用算法25讲</a></li><li><a href="/blog/数据结构与算法之美">数据结构与算法之美</a></li><li><a href="/blog/业务开发算法50讲">业务开发算法50讲</a></li><li><a href="/blog/动态规划面试宝典">动态规划面试宝典</a></li></ul></span><span>前端开发<ul><li><a href="/blog/浏览器工作原理与实践">浏览器工作原理与实践</a></li><li><a href="/blog/新时代产品经理进阶之路">新时代产品经理进阶之路</a></li><li><a href="/blog/全栈工程师修炼指南">全栈工程师修炼指南</a></li><li><a href="/blog/flutter核心技术与实战">flutter核心技术与实战</a></li><li><a href="/blog/java-script核心原理解析">java-script核心原理解析</a></li><li><a href="/blog/说透低代码">说透低代码</a></li><li><a href="/blog/nodejs应用开发实战">nodejs应用开发实战</a></li><li><a href="/blog/反爬虫兵法演绎20讲">反爬虫兵法演绎20讲</a></li><li><a href="/blog/reactnative新架构实战课">reactnative新架构实战课</a></li><li><a href="/blog/正则表达式入门">正则表达式入门</a></li><li><a href="/blog/重学前端">重学前端</a></li><li><a href="/blog/serverless入门课">serverless入门课</a></li><li><a href="/blog/type-script入门实战笔记">type-script入门实战笔记</a></li><li><a href="/blog/图解googlev8">图解googlev8</a></li><li><a href="/blog/vue3源码分析">vue3源码分析</a></li><li><a href="/blog/玩转Vue3全家桶">玩转Vue3全家桶</a></li><li><a href="/blog/webassembly入门">webassembly入门</a></li><li><a aria-current="page" class="active" href="/blog/手把手带你写一个Web框架">手把手带你写一个Web框架</a></li><li><a href="/blog/web漏洞挖掘实战">web漏洞挖掘实战</a></li><li><a href="/blog/跟月影学可视化">跟月影学可视化</a></li><li><a href="/blog/搞定音频技术">搞定音频技术</a></li><li><a href="/blog/攻克视频技术">攻克视频技术</a></li></ul></span><span>前端工程化<ul><li><a href="/blog/logger">logger</a></li><li><a href="/blog/webpack">webpack</a></li><li><a href="/blog/webpackChain">webpackChain</a></li></ul></span><span>前端性能优化<ul><li><a href="/blog/react性能调优">react性能调优</a></li></ul></span><span>软件测试<ul><li><a href="/blog/全链路压测实战30讲">全链路压测实战30讲</a></li><li><a href="/blog/性能测试实战30讲">性能测试实战30讲</a></li><li><a href="/blog/自动化测试高手课">自动化测试高手课</a></li><li><a href="/blog/软件测试52讲">软件测试52讲</a></li></ul></span><span>面试<ul><li><a href="/blog/面试现场">面试现场</a></li></ul></span><span>杂谈<ul><li><a href="/blog/超级访谈对话张雪峰">超级访谈对话张雪峰</a></li><li><a href="/blog/Git实战手册">Git实战手册</a></li><li><a href="/blog/NodeJS">NodeJS</a></li><li><a href="/blog/ReactJS">ReactJS</a></li><li><a href="/blog/UI设计">UI设计</a></li><li><a href="/blog/webpack4系列教程">webpack4系列教程</a></li><li><a href="/blog/前端知识体系">前端知识体系</a></li><li><a href="/blog/剑指offer刷题笔记">剑指offer刷题笔记</a></li><li><a href="/blog/思考与成长">思考与成长</a></li><li><a href="/blog/设计模式手册">设计模式手册</a></li></ul></span><div class="__dumi-default-navbar-tool"><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "></div></div></div></nav></div><div class="__dumi-default-menu" data-mode="site"><div class="__dumi-default-menu-inner"><div class="__dumi-default-menu-header"><a class="__dumi-default-menu-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog/"></a><h1>大师兄</h1><p></p></div><div class="__dumi-default-menu-mobile-area"><ul class="__dumi-default-menu-nav-list"><li>计算机基础<ul><li><a href="/blog/编译原理之美">编译原理之美</a></li><li><a href="/blog/编译原理实战">编译原理实战</a></li><li><a href="/blog/深入浅出计算机组成原理">深入浅出计算机组成原理</a></li><li><a href="/blog/详解http">详解http</a></li><li><a href="/blog/计算机网络通关29讲">计算机网络通关29讲</a></li><li><a href="/blog/网络排查案例课">网络排查案例课</a></li><li><a href="/blog/linux操作系统">linux操作系统</a></li><li><a href="/blog/linux性能优化实战">linux性能优化实战</a></li><li><a href="/blog/程序员数学基础">程序员数学基础</a></li><li><a href="/blog/趣谈网络协议">趣谈网络协议</a></li><li><a href="/blog/操作系统实战">操作系统实战</a></li><li><a href="/blog/软件工程之美">软件工程之美</a></li><li><a href="/blog/sql必知必会">sql必知必会</a></li><li><a href="/blog/操作系统实战45讲">操作系统实战45讲</a></li><li><a href="/blog/网络编程实战">网络编程实战</a></li></ul></li><li>算法<ul><li><a href="/blog/常用算法25讲">常用算法25讲</a></li><li><a href="/blog/数据结构与算法之美">数据结构与算法之美</a></li><li><a href="/blog/业务开发算法50讲">业务开发算法50讲</a></li><li><a href="/blog/动态规划面试宝典">动态规划面试宝典</a></li></ul></li><li>前端开发<ul><li><a href="/blog/浏览器工作原理与实践">浏览器工作原理与实践</a></li><li><a href="/blog/新时代产品经理进阶之路">新时代产品经理进阶之路</a></li><li><a href="/blog/全栈工程师修炼指南">全栈工程师修炼指南</a></li><li><a href="/blog/flutter核心技术与实战">flutter核心技术与实战</a></li><li><a href="/blog/java-script核心原理解析">java-script核心原理解析</a></li><li><a href="/blog/说透低代码">说透低代码</a></li><li><a href="/blog/nodejs应用开发实战">nodejs应用开发实战</a></li><li><a href="/blog/反爬虫兵法演绎20讲">反爬虫兵法演绎20讲</a></li><li><a href="/blog/reactnative新架构实战课">reactnative新架构实战课</a></li><li><a href="/blog/正则表达式入门">正则表达式入门</a></li><li><a href="/blog/重学前端">重学前端</a></li><li><a href="/blog/serverless入门课">serverless入门课</a></li><li><a href="/blog/type-script入门实战笔记">type-script入门实战笔记</a></li><li><a href="/blog/图解googlev8">图解googlev8</a></li><li><a href="/blog/vue3源码分析">vue3源码分析</a></li><li><a href="/blog/玩转Vue3全家桶">玩转Vue3全家桶</a></li><li><a href="/blog/webassembly入门">webassembly入门</a></li><li><a aria-current="page" class="active" href="/blog/手把手带你写一个Web框架">手把手带你写一个Web框架</a></li><li><a href="/blog/web漏洞挖掘实战">web漏洞挖掘实战</a></li><li><a href="/blog/跟月影学可视化">跟月影学可视化</a></li><li><a href="/blog/搞定音频技术">搞定音频技术</a></li><li><a href="/blog/攻克视频技术">攻克视频技术</a></li></ul></li><li>前端工程化<ul><li><a href="/blog/logger">logger</a></li><li><a href="/blog/webpack">webpack</a></li><li><a href="/blog/webpackChain">webpackChain</a></li></ul></li><li>前端性能优化<ul><li><a href="/blog/react性能调优">react性能调优</a></li></ul></li><li>软件测试<ul><li><a href="/blog/全链路压测实战30讲">全链路压测实战30讲</a></li><li><a href="/blog/性能测试实战30讲">性能测试实战30讲</a></li><li><a href="/blog/自动化测试高手课">自动化测试高手课</a></li><li><a href="/blog/软件测试52讲">软件测试52讲</a></li></ul></li><li>面试<ul><li><a href="/blog/面试现场">面试现场</a></li></ul></li><li>杂谈<ul><li><a href="/blog/超级访谈对话张雪峰">超级访谈对话张雪峰</a></li><li><a href="/blog/Git实战手册">Git实战手册</a></li><li><a href="/blog/NodeJS">NodeJS</a></li><li><a href="/blog/ReactJS">ReactJS</a></li><li><a href="/blog/UI设计">UI设计</a></li><li><a href="/blog/webpack4系列教程">webpack4系列教程</a></li><li><a href="/blog/前端知识体系">前端知识体系</a></li><li><a href="/blog/剑指offer刷题笔记">剑指offer刷题笔记</a></li><li><a href="/blog/思考与成长">思考与成长</a></li><li><a href="/blog/设计模式手册">设计模式手册</a></li></ul></li></ul><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "><button title="Dark theme" class="__dumi-default-dark-moon "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="3854" width="22" height="22"><path d="M991.816611 674.909091a69.166545 69.166545 0 0 0-51.665455-23.272727 70.795636 70.795636 0 0 0-27.438545 5.585454A415.674182 415.674182 0 0 1 754.993338 698.181818c-209.594182 0-393.472-184.785455-393.472-395.636363 0-52.363636 38.539636-119.621818 69.515637-173.614546 4.887273-8.610909 9.634909-16.756364 14.103272-24.901818A69.818182 69.818182 0 0 0 384.631156 0a70.842182 70.842182 0 0 0-27.438545 5.585455C161.678429 90.298182 14.362065 307.898182 14.362065 512c0 282.298182 238.824727 512 532.38691 512a522.286545 522.286545 0 0 0 453.957818-268.334545A69.818182 69.818182 0 0 0 991.816611 674.909091zM546.679156 954.181818c-248.785455 0-462.941091-192-462.941091-442.181818 0-186.647273 140.637091-372.829091 300.939637-442.181818-36.817455 65.629091-92.578909 151.970909-92.578909 232.727273 0 250.181818 214.109091 465.454545 462.917818 465.454545a488.331636 488.331636 0 0 0 185.181091-46.545455 453.003636 453.003636 0 0 1-393.565091 232.727273z m103.656728-669.323636l-14.266182 83.781818a34.909091 34.909091 0 0 0 50.362182 36.770909l74.775272-39.563636 74.752 39.563636a36.142545 36.142545 0 0 0 16.174546 3.956364 34.909091 34.909091 0 0 0 34.210909-40.727273l-14.289455-83.781818 60.509091-59.345455a35.025455 35.025455 0 0 0-19.223272-59.578182l-83.61891-12.101818-37.376-76.101818a34.56 34.56 0 0 0-62.254545 0l-37.376 76.101818-83.618909 12.101818a34.909091 34.909091 0 0 0-19.246546 59.578182z m70.423272-64.698182a34.280727 34.280727 0 0 0 26.135273-19.083636l14.312727-29.090909 14.336 29.090909a34.257455 34.257455 0 0 0 26.135273 19.083636l32.046546 4.887273-23.272728 22.574545a35.234909 35.234909 0 0 0-10.007272 30.952727l5.46909 32.116364-28.625454-15.127273a34.490182 34.490182 0 0 0-32.302546 0l-28.695272 15.127273 5.469091-32.116364a35.141818 35.141818 0 0 0-9.984-30.952727l-23.272728-22.574545z" p-id="3855"></path></svg></button><button title="Light theme" class="__dumi-default-dark-sun "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="4026" width="22" height="22"><path d="M915.2 476.16h-43.968c-24.704 0-44.736 16-44.736 35.84s20.032 35.904 44.736 35.904H915.2c24.768 0 44.8-16.064 44.8-35.904s-20.032-35.84-44.8-35.84zM512 265.6c-136.704 0-246.464 109.824-246.464 246.4 0 136.704 109.76 246.464 246.464 246.464S758.4 648.704 758.4 512c0-136.576-109.696-246.4-246.4-246.4z m0 425.6c-99.008 0-179.2-80.128-179.2-179.2 0-98.944 80.192-179.2 179.2-179.2S691.2 413.056 691.2 512c0 99.072-80.192 179.2-179.2 179.2zM197.44 512c0-19.84-19.136-35.84-43.904-35.84H108.8c-24.768 0-44.8 16-44.8 35.84s20.032 35.904 44.8 35.904h44.736c24.768 0 43.904-16.064 43.904-35.904zM512 198.464c19.776 0 35.84-20.032 35.84-44.8v-44.8C547.84 84.032 531.84 64 512 64s-35.904 20.032-35.904 44.8v44.8c0 24.768 16.128 44.864 35.904 44.864z m0 627.136c-19.776 0-35.904 20.032-35.904 44.8v44.736C476.096 940.032 492.16 960 512 960s35.84-20.032 35.84-44.8v-44.736c0-24.768-16.064-44.864-35.84-44.864z m329.92-592.832c17.472-17.536 20.288-43.072 6.4-57.024-14.016-14.016-39.488-11.2-57.024 6.336-4.736 4.864-26.496 26.496-31.36 31.36-17.472 17.472-20.288 43.008-6.336 57.024 13.952 14.016 39.488 11.2 57.024-6.336 4.8-4.864 26.496-26.56 31.296-31.36zM213.376 759.936c-4.864 4.8-26.56 26.624-31.36 31.36-17.472 17.472-20.288 42.944-6.4 56.96 14.016 13.952 39.552 11.2 57.024-6.336 4.8-4.736 26.56-26.496 31.36-31.36 17.472-17.472 20.288-43.008 6.336-56.96-14.016-13.952-39.552-11.072-56.96 6.336z m19.328-577.92c-17.536-17.536-43.008-20.352-57.024-6.336-14.08 14.016-11.136 39.488 6.336 57.024 4.864 4.864 26.496 26.56 31.36 31.424 17.536 17.408 43.008 20.288 56.96 6.336 14.016-14.016 11.264-39.488-6.336-57.024-4.736-4.864-26.496-26.56-31.296-31.424z m527.168 628.608c4.864 4.864 26.624 26.624 31.36 31.424 17.536 17.408 43.072 20.224 57.088 6.336 13.952-14.016 11.072-39.552-6.4-57.024-4.864-4.8-26.56-26.496-31.36-31.36-17.472-17.408-43.072-20.288-57.024-6.336-13.952 14.016-11.008 39.488 6.336 56.96z" p-id="4027"></path></svg></button><button title="Default to system" class="__dumi-default-dark-auto "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="11002" width="22" height="22"><path d="M127.658667 492.885333c0-51.882667 10.24-101.717333 30.378666-149.162666s47.786667-88.064 81.92-122.538667 75.093333-61.781333 122.538667-81.92 96.938667-30.378667 149.162667-30.378667 101.717333 10.24 149.162666 30.378667 88.405333 47.786667 122.88 81.92 61.781333 75.093333 81.92 122.538667 30.378667 96.938667 30.378667 149.162666-10.24 101.717333-30.378667 149.162667-47.786667 88.405333-81.92 122.88-75.093333 61.781333-122.88 81.92-97.28 30.378667-149.162666 30.378667-101.717333-10.24-149.162667-30.378667-88.064-47.786667-122.538667-81.92-61.781333-75.093333-81.92-122.88-30.378667-96.938667-30.378666-149.162667z m329.045333 0c0 130.048 13.994667 244.394667 41.984 343.381334h12.970667c46.762667 0 91.136-9.216 133.461333-27.306667s78.848-42.666667 109.568-73.386667 54.954667-67.242667 73.386667-109.568 27.306667-86.698667 27.306666-133.461333c0-46.421333-9.216-90.794667-27.306666-133.12s-42.666667-78.848-73.386667-109.568-67.242667-54.954667-109.568-73.386667-86.698667-27.306667-133.461333-27.306666h-11.605334c-28.672 123.562667-43.349333 237.909333-43.349333 343.722666z" p-id="11003"></path></svg></button></div></div></div><ul class="__dumi-default-menu-list"><li><a href="/blog/">大师兄 - 前端架构师</a></li></ul></div></div><ul role="slug-list" class="__dumi-default-layout-toc"><li title="配置项的设计" data-depth="2"><a href="/blog/手把手带你写一个web框架/04.实战第3关完善功能/03#配置项的设计"><span>配置项的设计</span></a></li><li title="具体实现" data-depth="2"><a href="/blog/手把手带你写一个web框架/04.实战第3关完善功能/03#具体实现"><span>具体实现</span></a></li><li title="newProxyReverseProxy" data-depth="3"><a href="/blog/手把手带你写一个web框架/04.实战第3关完善功能/03#newproxyreverseproxy"><span>newProxyReverseProxy</span></a></li><li title="rebuildBackend / restartBackend" data-depth="3"><a href="/blog/手把手带你写一个web框架/04.实战第3关完善功能/03#rebuildbackend--restartbackend"><span>rebuildBackend / restartBackend</span></a></li><li title="restartFrontend" data-depth="3"><a href="/blog/手把手带你写一个web框架/04.实战第3关完善功能/03#restartfrontend"><span>restartFrontend</span></a></li><li title="startProxy" data-depth="3"><a href="/blog/手把手带你写一个web框架/04.实战第3关完善功能/03#startproxy"><span>startProxy</span></a></li><li title="monitorBackend" data-depth="3"><a href="/blog/手把手带你写一个web框架/04.实战第3关完善功能/03#monitorbackend"><span>monitorBackend</span></a></li><li title="验证" data-depth="2"><a href="/blog/手把手带你写一个web框架/04.实战第3关完善功能/03#验证"><span>验证</span></a></li><li title="前端验证" data-depth="3"><a href="/blog/手把手带你写一个web框架/04.实战第3关完善功能/03#前端验证"><span>前端验证</span></a></li><li title="后端验证" data-depth="3"><a href="/blog/手把手带你写一个web框架/04.实战第3关完善功能/03#后端验证"><span>后端验证</span></a></li><li title="前后端验证" data-depth="3"><a href="/blog/手把手带你写一个web框架/04.实战第3关完善功能/03#前后端验证"><span>前后端验证</span></a></li><li title="小结" data-depth="2"><a href="/blog/手把手带你写一个web框架/04.实战第3关完善功能/03#小结"><span>小结</span></a></li><li title="思考题" data-depth="2"><a href="/blog/手把手带你写一个web框架/04.实战第3关完善功能/03#思考题"><span>思考题</span></a></li></ul><div class="__dumi-default-layout-content"><div class="markdown"><h1 id="20提效下实现调试模式加速开发效率"><a aria-hidden="true" tabindex="-1" href="/blog/手把手带你写一个web框架/04.实战第3关完善功能/03#20提效下实现调试模式加速开发效率"><span class="icon icon-link"></span></a>20｜提效（下）：实现调试模式加速开发效率</h1><p>你好，我是轩脉刃。</p><p>上一节课，我们讨论了调试模式的整体设计思路和关键的技术难点-反向代理，最后定义了具体的命令设计，包括三个二级命令，能让我们调试前端/后端，或者同时调试。现在，大的框架都建立好了，但是其中的细节实现还没有讨论。成败在于细节，今天我们就撸起袖子开始实现它们。</p><h2 id="配置项的设计"><a aria-hidden="true" tabindex="-1" href="/blog/手把手带你写一个web框架/04.实战第3关完善功能/03#配置项的设计"><span class="icon icon-link"></span></a>配置项的设计</h2><p>简单回顾一下调试模式的架构设计。所有外部请求进入反响代理服务后，会由反向代理服务进行分发，前端请求分发到前端进程，后端请求分发到后端进程。<br/><img src="https://static001.geekbang.org/resource/image/86/16/86d2c8a583a1dafa52ee79fb95f30616.jpg?wh=1920x1080" alt=""/><br/>在这个设计中，前端服务启动的时候占用哪个端口？后端服务启动的时候占用哪个端口？反向代理服务proxy启动的时候占用哪个端口呢？这些都属于配置项，需要在设计之初就规划好，所以我们先设计配置项的具体实现。</p><p>由于调试模式配置项比较多，在framework/command/dev.go 中，我们定义如下的配置结构devConfig来表示配置信息：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// devConfig 代表调试模式的配置信息</span></div><div class="token-line"><span class="token plain">    type devConfig struct {</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">       Port    string   // 调试模式最终监听的端口，默认为8070</span></div><div class="token-line"><span class="token plain">       </span></div><div class="token-line"><span class="token plain">       Backend struct { // 后端调试模式配置</span></div><div class="token-line"><span class="token plain">          RefreshTime   int    // 调试模式后端更新时间，如果文件变更，等待3s才进行一次更新，能让频繁保存变更更为顺畅, 默认1s</span></div><div class="token-line"><span class="token plain">          Port          string // 后端监听端口， 默认 8072</span></div><div class="token-line"><span class="token plain">          MonitorFolder string // 监听文件夹，默认为AppFolder</span></div><div class="token-line"><span class="token plain">       }</span></div><div class="token-line"><span class="token plain">       </span></div><div class="token-line"><span class="token plain">       Frontend struct { // 前端调试模式配置</span></div><div class="token-line"><span class="token plain">          Port string // 前端启动端口, 默认8071</span></div><div class="token-line"><span class="token plain">       }</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>这个结构可以说已经非常清晰了。结构根目录下的Port代表proxy的端口，而根目录下的Backend 和 Frontend 分别代表后端和前端的配置。</p><p>其中，前端只需要配置一个端口Port，<strong>而后端，我们除了配置端口Port之外，还另外多了两个配置，一个是监听的文件夹MonitorFolder，另外一个是监听文件夹的变更时间RefreshTime</strong>，这两个配置都是和后端监听文件夹相关的，具体如何使用，我们在后面写proxy的方法monitorBackend再详细说。</p><p>有了这个配置结构还不够，我们还要定义配置结构中每个值的赋值和默认值，在配置文件app.yaml中对应定义的配置字段如下：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">dev: # 调试模式</span></div><div class="token-line"><span class="token plain">      port: 8070 # 调试模式最终监听的端口，默认为8070</span></div><div class="token-line"><span class="token plain">      backend: # 后端调试模式配置</span></div><div class="token-line"><span class="token plain">        refresh_time: 3  # 调试模式后端更新时间，如果文件变更，等待3s才进行一次更新，能让频繁保存变更更为顺畅, 默认1s</span></div><div class="token-line"><span class="token plain">        port: 8072 # 后端监听端口，默认8072</span></div><div class="token-line"><span class="token plain">        monitor_folder: &quot;&quot; # 监听文件夹地址，为空或者不填默认为AppFolder</span></div><div class="token-line"><span class="token plain">      frontend: # 前端调试模式配置</span></div><div class="token-line"><span class="token plain">        port: 8071 # 前端监听端口, 默认8071</span></div></pre></div><p>之后如果在配置文件中有配置这些字段，就使用配置文件中的字段，否则的话，则使用默认配置。对应到代码上，我们可以在framework/command/dev.go中实现一个initDevConfig。</p><p>实现思路也不难，参数只需要把服务容器传递进入就行了，在这个函数中，我们先定义好默认的配置，然后从容器中获取配置服务，通过配置服务，获取对应的配置文件的设置，如果配置文件有对应字段的话，就进行对应字段的配置。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// 初始化配置文件</span></div><div class="token-line"><span class="token plain">    func initDevConfig(c framework.Container) *devConfig {</span></div><div class="token-line"><span class="token plain">        // 设置默认值</span></div><div class="token-line"><span class="token plain">        devConfig := &amp;devConfig{</span></div><div class="token-line"><span class="token plain">            Port: &quot;8087&quot;,</span></div><div class="token-line"><span class="token plain">            Backend: struct {</span></div><div class="token-line"><span class="token plain">                RefreshTime   int</span></div><div class="token-line"><span class="token plain">                Port          string</span></div><div class="token-line"><span class="token plain">                MonitorFolder string</span></div><div class="token-line"><span class="token plain">            }{</span></div><div class="token-line"><span class="token plain">                1,</span></div><div class="token-line"><span class="token plain">                &quot;8072&quot;,</span></div><div class="token-line"><span class="token plain">                &quot;&quot;,</span></div><div class="token-line"><span class="token plain">            },</span></div><div class="token-line"><span class="token plain">            Frontend: struct {</span></div><div class="token-line"><span class="token plain">                Port string</span></div><div class="token-line"><span class="token plain">            }{</span></div><div class="token-line"><span class="token plain">                &quot;8071&quot;,</span></div><div class="token-line"><span class="token plain">            },</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        // 容器中获取配置服务</span></div><div class="token-line"><span class="token plain">        configer := c.MustMake(contract.ConfigKey).(contract.Config)</span></div><div class="token-line"><span class="token plain">        // 每个配置项进行检查</span></div><div class="token-line"><span class="token plain">        if configer.IsExist(&quot;app.dev.port&quot;) {</span></div><div class="token-line"><span class="token plain">            devConfig.Port = configer.GetString(&quot;app.dev.port&quot;)</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        if configer.IsExist(&quot;app.dev.backend.refresh_time&quot;) {</span></div><div class="token-line"><span class="token plain">            devConfig.Backend.RefreshTime = configer.GetInt(&quot;app.dev.backend.refresh_time&quot;)</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        if configer.IsExist(&quot;app.dev.backend.port&quot;) {</span></div><div class="token-line"><span class="token plain">            devConfig.Backend.Port = configer.GetString(&quot;app.dev.backend.port&quot;)</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        </span></div><div class="token-line"><span class="token plain">        // monitorFolder 默认使用目录服务的AppFolder()</span></div><div class="token-line"><span class="token plain">        monitorFolder := configer.GetString(&quot;app.dev.backend.monitor_folder&quot;)</span></div><div class="token-line"><span class="token plain">        if monitorFolder == &quot;&quot; {</span></div><div class="token-line"><span class="token plain">            appService := c.MustMake(contract.AppKey).(contract.App)</span></div><div class="token-line"><span class="token plain">            devConfig.Backend.MonitorFolder = appService.AppFolder()</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        if configer.IsExist(&quot;app.dev.frontend.port&quot;) {</span></div><div class="token-line"><span class="token plain">            devConfig.Frontend.Port = configer.GetString(&quot;app.dev.frontend.port&quot;)</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        return devConfig</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>这里着重说一下monitorFolder这个配置的逻辑，如果配置文件中有定义这个配置的话，我们就使用配置文件的配置，否则我们就去目录服务中获取AppFolder。其实这种有层次的配置方式，在配置服务那一节我们已经见过了，多使用这种配置方式能让框架可用性更高。</p><p>但是之前<a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/425820">第12节课<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>，定义目录服务接口的时候，没有定义App的服务接口，所以我们得去稍微修改下目录服务接口 framework/contract/app.go，为其增加AppFolder这个目录接口：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// App 定义接口</span></div><div class="token-line"><span class="token plain">    type App interface {</span></div><div class="token-line"><span class="token plain">       ...</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">       // AppFolder 定义业务代码所在的目录，用于监控文件变更使用</span></div><div class="token-line"><span class="token plain">       AppFolder() string</span></div><div class="token-line"><span class="token plain">       ...</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>同时修改其对应实现 framework/provider/app/service.go，增加这个AppFolder的实现：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// AppFolder 代表app目录</span></div><div class="token-line"><span class="token plain">    func (app *HadeApp) AppFolder() string {</span></div><div class="token-line"><span class="token plain">       if val, ok := app.configMap[&quot;app_folder&quot;]; ok {</span></div><div class="token-line"><span class="token plain">          return val</span></div><div class="token-line"><span class="token plain">       }</span></div><div class="token-line"><span class="token plain">       return filepath.Join(app.BaseFolder(), &quot;app&quot;)</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>到这里，配置结构devConfig及配置结构初始化方法 initDevConfig，就实现完成了。</p><h2 id="具体实现"><a aria-hidden="true" tabindex="-1" href="/blog/手把手带你写一个web框架/04.实战第3关完善功能/03#具体实现"><span class="icon icon-link"></span></a>具体实现</h2><p>现在，来完成拼图的最后一个部分，回到framework/command/dev.go中，上节课只定义了Proxy结构，但是Proxy结构中的字段，我们没有讨论。</p><p>首先有了上面定义的devConfig结构之后，Proxy的结构中，应该有一个字段保存这个Proxy的配置信息devConfig。</p><p>其次，在restart前端或者后端的时候，由于<strong>新进程和旧进程都使用一样的端口</strong>，我们一定是先关闭旧的前端进程或者后端进程，才能启动新的前端或者后端进程。所以这里要记录一下前后端进程的进程ID，设置了backendPid和 frontendPid来存储进程ID。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// Proxy 代表serve启动的服务器代理</span></div><div class="token-line"><span class="token plain">    type Proxy struct {</span></div><div class="token-line"><span class="token plain">       devConfig   *devConfig // 配置文件</span></div><div class="token-line"><span class="token plain">       backendPid  int        // 当前的backend服务的pid</span></div><div class="token-line"><span class="token plain">       frontendPid int        // 当前的frontend服务的pid</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>下面我们就针对每个函数的具体实现一一说明，这里把上节课定义的各个函数简单再列一下，如果你对它们的功能有点模糊了，可以再回顾一下第19课。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// 初始化一个Proxy</span></div><div class="token-line"><span class="token plain">    func NewProxy(c framework.Container) *Proxy{}</span></div><div class="token-line"><span class="token plain">    // 重新启动一个proxy网关</span></div><div class="token-line"><span class="token plain">    func (p *Proxy) newProxyReverseProxy(frontend, backend *url.URL) *httputil.ReverseProxy{}</span></div><div class="token-line"><span class="token plain">    // 启动前端服务</span></div><div class="token-line"><span class="token plain">    func (p *Proxy) restartFrontend() error{}</span></div><div class="token-line"><span class="token plain">    // 启动后端服务</span></div><div class="token-line"><span class="token plain">    func (p *Proxy) restartBackend() error {}</span></div><div class="token-line"><span class="token plain">    // 编译后端服务</span></div><div class="token-line"><span class="token plain">    func (p *Proxy) rebuildBackend() error {}</span></div><div class="token-line"><span class="token plain">    // 启动proxy</span></div><div class="token-line"><span class="token plain">    func (p *Proxy) startProxy(startFrontend, startBackend bool) error{}</span></div><div class="token-line"><span class="token plain">    // 监控后端服务源码文件的变更</span></div><div class="token-line"><span class="token plain">    func (p *Proxy) monitorBackend() error{}</span></div></pre></div><h3 id="newproxyreverseproxy"><a aria-hidden="true" tabindex="-1" href="/blog/手把手带你写一个web框架/04.实战第3关完善功能/03#newproxyreverseproxy"><span class="icon icon-link"></span></a>newProxyReverseProxy</h3><p>首先是newProxyReverseProxy，它的核心逻辑就是创建ReverseProxy，设置Director、ModifyResponse、ErrorHandler三个字段。但是我们在细节上要做一些补充。</p><p>首先，既然已经在proxy中存了前后端的PID，那就可以知道当下前端服务或者后端服务是否已经启动了。如果只启动了前端服务，我们直接代理前端就好了；如果只启动后端服务，就直接代理后端。而<strong>只有两个服务都启动了，我们才进行上一节课说的：先请求后端服务，遇到404了，再请求前端服务</strong>。</p><p>同时稍微修改一下director，对于前端一些固定的请求地址，比如 / 或者 /app.js，我们直接将这个地址固定请求前端。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// 重新启动一个proxy网关</span></div><div class="token-line"><span class="token plain">    func (p *Proxy) newProxyReverseProxy(frontend, backend *url.URL) *httputil.ReverseProxy {</span></div><div class="token-line"><span class="token plain">       if p.frontendPid == 0 &amp;&amp; p.backendPid == 0 {</span></div><div class="token-line"><span class="token plain">          fmt.Println(&quot;前端和后端服务都不存在&quot;)</span></div><div class="token-line"><span class="token plain">          return nil</span></div><div class="token-line"><span class="token plain">       }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">       // 后端服务存在</span></div><div class="token-line"><span class="token plain">       if p.frontendPid == 0 &amp;&amp; p.backendPid != 0 {</span></div><div class="token-line"><span class="token plain">          return httputil.NewSingleHostReverseProxy(backend)</span></div><div class="token-line"><span class="token plain">       }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">       // 前端服务存在</span></div><div class="token-line"><span class="token plain">       if p.backendPid == 0 &amp;&amp; p.frontendPid != 0 {</span></div><div class="token-line"><span class="token plain">          return httputil.NewSingleHostReverseProxy(frontend)</span></div><div class="token-line"><span class="token plain">       }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">       // 两个都有进程</span></div><div class="token-line"><span class="token plain">       // 先创建一个后端服务的directory</span></div><div class="token-line"><span class="token plain">       director := func(req *http.Request) {</span></div><div class="token-line"><span class="token plain">          if req.URL.Path == &quot;/&quot; || req.URL.Path == &quot;/app.js&quot; {</span></div><div class="token-line"><span class="token plain">             req.URL.Scheme = frontend.Scheme</span></div><div class="token-line"><span class="token plain">             req.URL.Host = frontend.Host</span></div><div class="token-line"><span class="token plain">          } else {</span></div><div class="token-line"><span class="token plain">             req.URL.Scheme = backend.Scheme</span></div><div class="token-line"><span class="token plain">             req.URL.Host = backend.Host</span></div><div class="token-line"><span class="token plain">          }</span></div><div class="token-line"><span class="token plain">       }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">       // 定义一个NotFoundErr</span></div><div class="token-line"><span class="token plain">       NotFoundErr := errors.New(&quot;response is 404, need to redirect&quot;)</span></div><div class="token-line"><span class="token plain">       return &amp;httputil.ReverseProxy{</span></div><div class="token-line"><span class="token plain">          Director: director, // 先转发到后端服务</span></div><div class="token-line"><span class="token plain">          ModifyResponse: func(response *http.Response) error {</span></div><div class="token-line"><span class="token plain">             // 如果后端服务返回了404，我们返回NotFoundErr 会进入到errorHandler中</span></div><div class="token-line"><span class="token plain">             if response.StatusCode == 404 {</span></div><div class="token-line"><span class="token plain">                return NotFoundErr</span></div><div class="token-line"><span class="token plain">             }</span></div><div class="token-line"><span class="token plain">             return nil</span></div><div class="token-line"><span class="token plain">          },</span></div><div class="token-line"><span class="token plain">          ErrorHandler: func(writer http.ResponseWriter, request *http.Request, err error) {</span></div><div class="token-line"><span class="token plain">             // 判断 Error 是否为NotFoundError, 是的话则进行前端服务的转发，重新修改writer</span></div><div class="token-line"><span class="token plain">             if errors.Is(err, NotFoundErr) {</span></div><div class="token-line"><span class="token plain">                httputil.NewSingleHostReverseProxy(frontend).ServeHTTP(writer, request)</span></div><div class="token-line"><span class="token plain">             }</span></div><div class="token-line"><span class="token plain">          }}</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><h3 id="rebuildbackend--restartbackend"><a aria-hidden="true" tabindex="-1" href="/blog/手把手带你写一个web框架/04.实战第3关完善功能/03#rebuildbackend--restartbackend"><span class="icon icon-link"></span></a>rebuildBackend / restartBackend</h3><p>下一个函数是rebuildBackend。这个函数的作用是重新编译后端。</p><p>那如何编译后端呢？还记得第18课中为编译后端定义了命令行么？所以在“调试命令”中，我们只需要调用“编译命令”就行了。</p><ul><li>编译前端 ./hade build frontend</li><li>编译后端 ./hade build backend</li><li>同时编译前后端 ./hade build all</li><li>自编译 ./hade build self</li></ul><p>所以rebuildBackend 这个函数，我们就是调用一次 <code>./hade build backend</code> 。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// rebuildBackend 重新编译后端</span></div><div class="token-line"><span class="token plain">    func (p *Proxy) rebuildBackend() error {</span></div><div class="token-line"><span class="token plain">       // 重新编译hade</span></div><div class="token-line"><span class="token plain">       cmdBuild := exec.Command(&quot;./hade&quot;, &quot;build&quot;, &quot;backend&quot;)</span></div><div class="token-line"><span class="token plain">       cmdBuild.Stdout = os.Stdout</span></div><div class="token-line"><span class="token plain">       cmdBuild.Stderr = os.Stderr</span></div><div class="token-line"><span class="token plain">       if err := cmdBuild.Start(); err == nil {</span></div><div class="token-line"><span class="token plain">          err = cmdBuild.Wait()</span></div><div class="token-line"><span class="token plain">          if err != nil {</span></div><div class="token-line"><span class="token plain">             return err</span></div><div class="token-line"><span class="token plain">          }</span></div><div class="token-line"><span class="token plain">       }</span></div><div class="token-line"><span class="token plain">       return nil</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>编译后端函数实现了，下面就是重启后端进程restartBackend。</p><p>我们当然也会记得在<a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/425820">第12章<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>将启动Web服务变成一个命令 <code>./hade app start</code> 。所以重启后端服务的步骤就是：</p><ul><li>关闭旧进程（kill）</li><li>启动新进程（./hade app start）</li></ul><p>但是这里有个小问题，<strong>之前启动进程的时候，进程端口是写死的。但是，现在需要固定启动的App的进程端口</strong>。所以要对 <code>./hade app start</code> 命令进行一些改造。</p><p>来修改framework/command/app.go，我们增加一个appAddress地址，这个地址可以传递类似 <code>localhost:8888</code> 或者 <code>:8888</code> 这样的启动服务地址，并且在appStartCommand中使用这个appAddress。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// app启动地址</span></div><div class="token-line"><span class="token plain">    var appAddress = &quot;&quot;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    // initAppCommand 初始化app命令和其子命令</span></div><div class="token-line"><span class="token plain">    func initAppCommand() *cobra.Command {</span></div><div class="token-line"><span class="token plain">       // 设置启动地址</span></div><div class="token-line"><span class="token plain">       appStartCommand.Flags().StringVar(&amp;appAddress, &quot;address&quot;, &quot;:8888&quot;, &quot;设置app启动的地址，默认为:8888&quot;)</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">       appCommand.AddCommand(appStartCommand)</span></div><div class="token-line"><span class="token plain">       return appCommand</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    // appStartCommand 启动一个Web服务</span></div><div class="token-line"><span class="token plain">    var appStartCommand = &amp;cobra.Command{</span></div><div class="token-line"><span class="token plain">       Use:   &quot;start&quot;,</span></div><div class="token-line"><span class="token plain">       Short: &quot;启动一个Web服务&quot;,</span></div><div class="token-line"><span class="token plain">       RunE: func(c *cobra.Command, args []string) error {</span></div><div class="token-line"><span class="token plain">          ...</span></div><div class="token-line"><span class="token plain">          // 创建一个Server服务</span></div><div class="token-line"><span class="token plain">          server := &amp;http.Server{</span></div><div class="token-line"><span class="token plain">             Handler: core,</span></div><div class="token-line"><span class="token plain">             Addr:    appAddress,</span></div><div class="token-line"><span class="token plain">          }</span></div><div class="token-line"><span class="token plain">          // 这个goroutine是启动服务的goroutine</span></div><div class="token-line"><span class="token plain">          go func() {</span></div><div class="token-line"><span class="token plain">             server.ListenAndServe()</span></div><div class="token-line"><span class="token plain">          }()</span></div><div class="token-line"><span class="token plain">          ...</span></div><div class="token-line"><span class="token plain">       },</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>这样，后端进程就可以通过命令 <code>./hade app start \--address=:8888</code> 这样的方式，来指定端口启动服务了。</p><p>小问题解决之后，回到framework/command/dev.go， 我们实现restartBackend方法。先杀死旧的进程，再通过命令 <code>./hade app start</code> 带上参数 address，启动新的后端服务。启动之后，再将启动的进程ID存储到proxy结构的backendPid字段中：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// restartBackend 启动后端服务</span></div><div class="token-line"><span class="token plain">    func (p *Proxy) restartBackend() error {</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">       // 杀死之前的进程</span></div><div class="token-line"><span class="token plain">       if p.backendPid != 0 {</span></div><div class="token-line"><span class="token plain">          syscall.Kill(p.backendPid, syscall.SIGKILL)</span></div><div class="token-line"><span class="token plain">          p.backendPid = 0</span></div><div class="token-line"><span class="token plain">       }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">       // 设置随机端口，真实后端的端口</span></div><div class="token-line"><span class="token plain">       port := p.devConfig.Backend.Port</span></div><div class="token-line"><span class="token plain">       hadeAddress := fmt.Sprintf(&quot;:&quot; + port)</span></div><div class="token-line"><span class="token plain">       // 使用命令行启动后端进程</span></div><div class="token-line"><span class="token plain">       cmd := exec.Command(&quot;./hade&quot;, &quot;app&quot;, &quot;start&quot;, &quot;--address=&quot;+hadeAddress)</span></div><div class="token-line"><span class="token plain">       cmd.Stdout = os.NewFile(0, os.DevNull)</span></div><div class="token-line"><span class="token plain">       cmd.Stderr = os.Stderr</span></div><div class="token-line"><span class="token plain">       fmt.Println(&quot;启动后端服务: &quot;, &quot;http://127.0.0.1:&quot;+port)</span></div><div class="token-line"><span class="token plain">       err := cmd.Start()</span></div><div class="token-line"><span class="token plain">       if err != nil {</span></div><div class="token-line"><span class="token plain">          fmt.Println(err)</span></div><div class="token-line"><span class="token plain">       }</span></div><div class="token-line"><span class="token plain">       p.backendPid = cmd.Process.Pid</span></div><div class="token-line"><span class="token plain">       fmt.Println(&quot;后端服务pid:&quot;, p.backendPid)</span></div><div class="token-line"><span class="token plain">       return nil</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><h3 id="restartfrontend"><a aria-hidden="true" tabindex="-1" href="/blog/手把手带你写一个web框架/04.实战第3关完善功能/03#restartfrontend"><span class="icon icon-link"></span></a>restartFrontend</h3><p>而重启前端服务的函数restartFrontend也是一样的逻辑，先关闭旧的前端进程，然后启动新的前端进程。这里同样也有一个问题，启动前端进程的命令是 <code>npm run dev</code> ，我们怎么固定其端口呢？</p><p>在Vue中，我们可以通过<a target="_blank" rel="noopener noreferrer" href="https://stackoverflow.com/questions/47219819/how-to-change-port-number-in-vue-cli-project">设置环境变量PORT<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>，来规定前端进程的启动端口。也就是让启动命令变为 <code>PORT=8071 npm run dev</code> ，在Golang中启动一个命令，并为命令设置环境变量是这样设置的：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// 运行命令</span></div><div class="token-line"><span class="token plain">    cmd := exec.Command(&quot;npm&quot;, &quot;run&quot;, &quot;dev&quot;)</span></div><div class="token-line"><span class="token plain">    // 为默认的环境变量增加PORT=xxx的变量</span></div><div class="token-line"><span class="token plain">    cmd.Env = os.Environ()</span></div><div class="token-line"><span class="token plain">    cmd.Env = append(cmd.Env, fmt.Sprintf(&quot;%s%s&quot;, &quot;PORT=&quot;, port))</span></div></pre></div><p>所以启动前端服务的逻辑就如下，很简单，重点位置你可以看注释。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// 启动前端服务</span></div><div class="token-line"><span class="token plain">    func (p *Proxy) restartFrontend() error {</span></div><div class="token-line"><span class="token plain">       // 启动前端调试模式</span></div><div class="token-line"><span class="token plain">       // 先杀死旧进程</span></div><div class="token-line"><span class="token plain">       if p.frontendPid != 0 {</span></div><div class="token-line"><span class="token plain">          syscall.Kill(p.frontendPid, syscall.SIGKILL)</span></div><div class="token-line"><span class="token plain">          p.frontendPid = 0</span></div><div class="token-line"><span class="token plain">       }</span></div><div class="token-line"><span class="token plain">       // 否则开启npm run serve</span></div><div class="token-line"><span class="token plain">       port := p.devConfig.Frontend.Port</span></div><div class="token-line"><span class="token plain">       path, err := exec.LookPath(&quot;npm&quot;)</span></div><div class="token-line"><span class="token plain">       if err != nil {</span></div><div class="token-line"><span class="token plain">          return err</span></div><div class="token-line"><span class="token plain">       }</span></div><div class="token-line"><span class="token plain">       cmd := exec.Command(path, &quot;run&quot;, &quot;dev&quot;)</span></div><div class="token-line"><span class="token plain">       cmd.Env = os.Environ()</span></div><div class="token-line"><span class="token plain">       cmd.Env = append(cmd.Env, fmt.Sprintf(&quot;%s%s&quot;, &quot;PORT=&quot;, port))</span></div><div class="token-line"><span class="token plain">       cmd.Stdout = os.NewFile(0, os.DevNull)</span></div><div class="token-line"><span class="token plain">       cmd.Stderr = os.Stderr</span></div><div class="token-line"><span class="token plain">       // 因为npm run serve 是控制台挂起模式，所以这里使用go routine启动</span></div><div class="token-line"><span class="token plain">       err = cmd.Start()</span></div><div class="token-line"><span class="token plain">       fmt.Println(&quot;启动前端服务: &quot;, &quot;http://127.0.0.1:&quot;+port)</span></div><div class="token-line"><span class="token plain">       if err != nil {</span></div><div class="token-line"><span class="token plain">          fmt.Println(err)</span></div><div class="token-line"><span class="token plain">       }</span></div><div class="token-line"><span class="token plain">       p.frontendPid = cmd.Process.Pid</span></div><div class="token-line"><span class="token plain">       fmt.Println(&quot;前端服务pid:&quot;, p.frontendPid)</span></div><div class="token-line"><span class="token plain">       return nil</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><h3 id="startproxy"><a aria-hidden="true" tabindex="-1" href="/blog/手把手带你写一个web框架/04.实战第3关完善功能/03#startproxy"><span class="icon icon-link"></span></a>startProxy</h3><p>下面我们来实现startProxy方法，它有两个参数，表示在启动Proxy时是否要启动前端、后端服务。</p><p>这个方法的逻辑也并不复杂，步骤有四步，先根据参数判断是否启动后端服务，根据参数判断是否启动前端服务，然后使用newProxyReverseProxy来创建新的ReverseProxy，最后启动Proxy服务。在代码中也做了步骤说明了：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// 启动proxy服务，并且根据参数启动前端服务或者后端服务</span></div><div class="token-line"><span class="token plain">    func (p *Proxy) startProxy(startFrontend, startBackend bool) error {</span></div><div class="token-line"><span class="token plain">       var backendURL, frontendURL *url.URL</span></div><div class="token-line"><span class="token plain">       var err error</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">       // 启动后端</span></div><div class="token-line"><span class="token plain">       if startBackend {</span></div><div class="token-line"><span class="token plain">          if err := p.restartBackend(); err != nil {</span></div><div class="token-line"><span class="token plain">             return err</span></div><div class="token-line"><span class="token plain">          }</span></div><div class="token-line"><span class="token plain">       }</span></div><div class="token-line"><span class="token plain">       // 启动前端</span></div><div class="token-line"><span class="token plain">       if startFrontend {</span></div><div class="token-line"><span class="token plain">          if err := p.restartFrontend(); err != nil {</span></div><div class="token-line"><span class="token plain">             return err</span></div><div class="token-line"><span class="token plain">          }</span></div><div class="token-line"><span class="token plain">       }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">       if frontendURL, err = url.Parse(fmt.Sprintf(&quot;%s%s&quot;, &quot;http://127.0.0.1:&quot;, p.devConfig.Frontend.Port)); err != nil {</span></div><div class="token-line"><span class="token plain">          return err</span></div><div class="token-line"><span class="token plain">       }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">       if backendURL, err = url.Parse(fmt.Sprintf(&quot;%s%s&quot;, &quot;http://127.0.0.1:&quot;, p.devConfig.Backend.Port)); err != nil {</span></div><div class="token-line"><span class="token plain">          return err</span></div><div class="token-line"><span class="token plain">       }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">       // 设置反向代理</span></div><div class="token-line"><span class="token plain">       proxyReverse := p.newProxyReverseProxy(frontendURL, backendURL)</span></div><div class="token-line"><span class="token plain">       proxyServer := &amp;http.Server{</span></div><div class="token-line"><span class="token plain">          Addr:    &quot;127.0.0.1:&quot; + p.devConfig.Port,</span></div><div class="token-line"><span class="token plain">          Handler: proxyReverse,</span></div><div class="token-line"><span class="token plain">       }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">       fmt.Println(&quot;代理服务启动:&quot;, &quot;http://&quot;+proxyServer.Addr)</span></div><div class="token-line"><span class="token plain">       // 启动proxy服务</span></div><div class="token-line"><span class="token plain">       err = proxyServer.ListenAndServe()</span></div><div class="token-line"><span class="token plain">       if err != nil {</span></div><div class="token-line"><span class="token plain">          fmt.Println(err)</span></div><div class="token-line"><span class="token plain">       }</span></div><div class="token-line"><span class="token plain">       return nil</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><h3 id="monitorbackend"><a aria-hidden="true" tabindex="-1" href="/blog/手把手带你写一个web框架/04.实战第3关完善功能/03#monitorbackend"><span class="icon icon-link"></span></a>monitorBackend</h3><p>最后是一个monitorBackend方法，监控某个文件夹的变动，并且重新编译并且运行后端服务。</p><p>这个方法我们重点说一下，有些逻辑还是比较绕的。</p><p>首先，在前一节课说过了，可以使用 <a target="_blank" rel="noopener noreferrer" href="https://github.com/fsnotify/fsnotify">fsnotify<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 库对目录进行监控。那么对哪个目录进行监控呢？之前在配置devConfig中，定义了一个Backend.MonitorFolder目录，这个配置默认使用的是AppFolder目录。这个就是我们监控的目标目录。</p><p>其次，每次有变化的时候，都要进行一次编译后端服务、杀死旧进程、重启新进程么？</p><p>在开发过程中我们知道，每次调整一个逻辑的时候，是有可能短时间内重复修改、保存多个文件的，或者保存一个文件多次。而重新编译、重新启动进程的过程，又是有一定耗时的，如果每改一次就重来一次，可以想象这个体验是很差的。</p><p>能怎么优化这种体验呢？我们可以使用一种计时时间机制。</p><p>这个机制的逻辑就是，<strong>每次有文件变动，并不立刻进行实质的操作，而是开启一个计时时间</strong>，如果这个时间内，没有任何后续的文件变动了，那么在计时时间到了之后，我们再进行实质的操作。而如果在计时时间内，有任何更新的文件变动，我们就将计时时间机制重新开始计时。</p><p>这种机制能有一定概率保证，在“更新代码等待一段时间后”进行后端的重启服务。而这里的计时时间我们也变成一个配置，devConfig里面的Backend.RefreshTime，默认时长为1s。</p><p>对应在framework/command/dev.go的monitorBackend代码实现中，我们大致分为这么几步，<strong>先创建watcher，监听目标目录，有变动的时候开启计时时间机制，循环监听</strong>：</p><ul><li>目标目录变更事件，有事件更新计时机制；</li><li>计时机制到点事件，计时到点事件触发，代表有一个或多个目标目录变更已经存在，更新后端服务。</li></ul><p>这里在监听目标目录的时候，我们需要监听AppFolder目录下的所有子目录及孙目录，所以这里需要用到递归 filepath.Walk ，来递归一遍所有子目录及孙目录。如果是目录，就使用watcher.Add 来将目录加入到监控列表中。</p><p>具体的代码逻辑可以看framework/command/dev.go中的monitorBackend：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// monitorBackend 监听应用文件</span></div><div class="token-line"><span class="token plain">    func (p *Proxy) monitorBackend() error {</span></div><div class="token-line"><span class="token plain">       // 监听</span></div><div class="token-line"><span class="token plain">       watcher, err := fsnotify.NewWatcher()</span></div><div class="token-line"><span class="token plain">       if err != nil {</span></div><div class="token-line"><span class="token plain">          return err</span></div><div class="token-line"><span class="token plain">       }</span></div><div class="token-line"><span class="token plain">       defer watcher.Close()</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">       // 开启监听目标文件夹</span></div><div class="token-line"><span class="token plain">       appFolder := p.devConfig.Backend.MonitorFolder</span></div><div class="token-line"><span class="token plain">       fmt.Println(&quot;监控文件夹：&quot;, appFolder)</span></div><div class="token-line"><span class="token plain">       // 监听所有子目录，需要使用filepath.walk</span></div><div class="token-line"><span class="token plain">       filepath.Walk(appFolder, func(path string, info os.FileInfo, err error) error {</span></div><div class="token-line"><span class="token plain">          if info != nil &amp;&amp; !info.IsDir() {</span></div><div class="token-line"><span class="token plain">             return nil</span></div><div class="token-line"><span class="token plain">          }</span></div><div class="token-line"><span class="token plain">          // 如果是隐藏的目录比如 . 或者 .. 则不用进行监控</span></div><div class="token-line"><span class="token plain">          if util.IsHiddenDirectory(path) {</span></div><div class="token-line"><span class="token plain">             return nil</span></div><div class="token-line"><span class="token plain">          }</span></div><div class="token-line"><span class="token plain">          return watcher.Add(path)</span></div><div class="token-line"><span class="token plain">       })</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">       // 开启计时时间机制</span></div><div class="token-line"><span class="token plain">       refreshTime := p.devConfig.Backend.RefreshTime</span></div><div class="token-line"><span class="token plain">       t := time.NewTimer(time.Duration(refreshTime) * time.Second)</span></div><div class="token-line"><span class="token plain">       // 先停止计时器</span></div><div class="token-line"><span class="token plain">       t.Stop()</span></div><div class="token-line"><span class="token plain">       for {</span></div><div class="token-line"><span class="token plain">          select {</span></div><div class="token-line"><span class="token plain">          case &lt;-t.C:</span></div><div class="token-line"><span class="token plain">             // 计时器时间到了，代表之前有文件更新事件重置过计时器</span></div><div class="token-line"><span class="token plain">             // 即有文件更新</span></div><div class="token-line"><span class="token plain">             fmt.Println(&quot;...检测到文件更新，重启服务开始...&quot;)</span></div><div class="token-line"><span class="token plain">             if err := p.rebuildBackend(); err != nil {</span></div><div class="token-line"><span class="token plain">                fmt.Println(&quot;重新编译失败：&quot;, err.Error())</span></div><div class="token-line"><span class="token plain">             } else {</span></div><div class="token-line"><span class="token plain">                if err := p.restartBackend(); err != nil {</span></div><div class="token-line"><span class="token plain">                   fmt.Println(&quot;重新启动失败：&quot;, err.Error())</span></div><div class="token-line"><span class="token plain">                }</span></div><div class="token-line"><span class="token plain">             }</span></div><div class="token-line"><span class="token plain">             fmt.Println(&quot;...检测到文件更新，重启服务结束...&quot;)</span></div><div class="token-line"><span class="token plain">             // 停止计时器</span></div><div class="token-line"><span class="token plain">             t.Stop()</span></div><div class="token-line"><span class="token plain">          case _, ok := &lt;-watcher.Events:</span></div><div class="token-line"><span class="token plain">             if !ok {</span></div><div class="token-line"><span class="token plain">                continue</span></div><div class="token-line"><span class="token plain">             }</span></div><div class="token-line"><span class="token plain">             // 有文件更新事件，重置计时器</span></div><div class="token-line"><span class="token plain">             t.Reset(time.Duration(refreshTime) * time.Second)</span></div><div class="token-line"><span class="token plain">          case err, ok := &lt;-watcher.Errors:</span></div><div class="token-line"><span class="token plain">             if !ok {</span></div><div class="token-line"><span class="token plain">                continue</span></div><div class="token-line"><span class="token plain">             }</span></div><div class="token-line"><span class="token plain">             // 如果有文件监听错误，则停止计时器</span></div><div class="token-line"><span class="token plain">             fmt.Println(&quot;监听文件夹错误：&quot;, err.Error())</span></div><div class="token-line"><span class="token plain">             t.Reset(time.Duration(refreshTime) * time.Second)</span></div><div class="token-line"><span class="token plain">          }</span></div><div class="token-line"><span class="token plain">       }</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><h2 id="验证"><a aria-hidden="true" tabindex="-1" href="/blog/手把手带你写一个web框架/04.实战第3关完善功能/03#验证"><span class="icon icon-link"></span></a>验证</h2><p>到这里Proxy相关的逻辑和调试对应的命令行工具都开发完成了，下面我们来做一下对应的验证，一共三次验证，单独的前端、后端修改，以及同时对前后端的修改。</p><p>先修改一下config/development/app.yaml，增加对应的调试模式配置：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">dev: # 调试模式</span></div><div class="token-line"><span class="token plain">      port: 8070 # 调试模式最终监听的端口，默认为8070</span></div><div class="token-line"><span class="token plain">      backend: # 后端调试模式配置</span></div><div class="token-line"><span class="token plain">        refresh_time: 3  # 调试模式后端更新时间，如果文件变更，等待3s才进行一次更新，能让频繁保存变更更为顺畅, 默认1s</span></div><div class="token-line"><span class="token plain">        port: 8072 # 后端监听端口，默认8072</span></div><div class="token-line"><span class="token plain">        monitor_folder: &quot;&quot; # 监听文件夹地址，为空或者不填默认为AppFolder</span></div><div class="token-line"><span class="token plain">      frontend: # 前端调试模式配置</span></div><div class="token-line"><span class="token plain">        port: 8071 # 前端监听端口, 默认8071</span></div></pre></div><p>这里设置refresh_time为3s，代表后续后端变更后3s后会触发重新编译。对我们的代码进行一次编译，不用go build了，可以使用自定义的build命令了。<br/><img src="https://static001.geekbang.org/resource/image/bc/dc/bccyy36fb507fc398b4ac69d6fab12dc.png?wh=744x53" alt=""/></p><h3 id="前端验证"><a aria-hidden="true" tabindex="-1" href="/blog/手把手带你写一个web框架/04.实战第3关完善功能/03#前端验证"><span class="icon icon-link"></span></a>前端验证</h3><p>首先验证前端调试模式。调用命令 <code>./hade dev front</code>，可以看到如下的控制台信息：<br/><img src="https://static001.geekbang.org/resource/image/69/3f/6932b5eacdd96f46bd7c431388a5663f.png?wh=1837x388" alt=""/></p><p>先是出现几行信息：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">启动前端服务:  http://127.0.0.1:8071</span></div><div class="token-line"><span class="token plain">    前端服务pid: 13750</span></div><div class="token-line"><span class="token plain">    代理服务启动: http://127.0.0.1:8070</span></div></pre></div><p>然后进入到了Vue的调试模式，从上述信息我们知道，代理服务启动在8070端口，使用浏览器打开 <a target="_blank" rel="noopener noreferrer" href="http://127.0.0.1:8070/">http://127.0.0.1:8070<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 看到了熟悉的Vue界面。<br/><img src="https://static001.geekbang.org/resource/image/51/cd/51bbd33f01b482fe38543e09fcf6a8cd.png?wh=821x675" alt=""/></p><p>然后修改首页的前端组件，业务目录下src/components/HelloWorld.vue，将其展示在首页的msg内容：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">&lt;script&gt;</span></div><div class="token-line"><span class="token plain">    export default {</span></div><div class="token-line"><span class="token plain">      name: &#x27;HelloWorld&#x27;,</span></div><div class="token-line"><span class="token plain">      data() {</span></div><div class="token-line"><span class="token plain">        return {</span></div><div class="token-line"><span class="token plain">          msg: &#x27;Welcome to Your Vue.js App &#x27;</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">      }</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    &lt;/script&gt;</span></div></pre></div><p>修改为：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">&lt;script&gt;</span></div><div class="token-line"><span class="token plain">    export default {</span></div><div class="token-line"><span class="token plain">        name: &#x27;HelloWorld&#x27;,</span></div><div class="token-line"><span class="token plain">        data() {</span></div><div class="token-line"><span class="token plain">            return {</span></div><div class="token-line"><span class="token plain">                msg: &#x27;Welcome to Hade Vue.js App &#x27;</span></div><div class="token-line"><span class="token plain">            }</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    &lt;/script&gt;</span></div></pre></div><p>现在你可以看到，前端自动更新：<br/><img src="https://static001.geekbang.org/resource/image/54/3b/54b76e64904e2c38b011e0625317cf3b.png?wh=823x700" alt=""/><br/>前端验证完成。下面验证后端调试模式。</p><h3 id="后端验证"><a aria-hidden="true" tabindex="-1" href="/blog/手把手带你写一个web框架/04.实战第3关完善功能/03#后端验证"><span class="icon icon-link"></span></a>后端验证</h3><p>我们已经在业务代码app/http/module/demo/api.go中，定义了/demo/demo的路由，并且简单输出文字&quot;this is demo&quot;。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">func Register(r *gin.Engine) error {</span></div><div class="token-line"><span class="token plain">       api := NewDemoApi()</span></div><div class="token-line"><span class="token plain">       ...</span></div><div class="token-line"><span class="token plain">       r.GET(&quot;/demo/demo&quot;, api.Demo)</span></div><div class="token-line"><span class="token plain">       ...</span></div><div class="token-line"><span class="token plain">       return nil</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    func (api *DemoApi) Demo(c *gin.Context) {</span></div><div class="token-line"><span class="token plain">       c.JSON(200, &quot;this is demo&quot;)</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>使用命令 <code>./hade dev backend</code> ，有如下输出，可以看到输出中已经把监控文件夹、后端服务端口、代理服务端口完整输出了：<br/><img src="https://static001.geekbang.org/resource/image/a1/71/a140ce0ef5yya414bb7c51879966a871.png?wh=756x126" alt=""/></p><p>访问代理服务 <a target="_blank" rel="noopener noreferrer" href="http://127.0.0.1:8087/demo/demo">http://127.0.0.1:8087/demo/demo<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>：<br/><img src="https://static001.geekbang.org/resource/image/9c/35/9cfabbc9617ea7d382ef7a7656bbyy35.png?wh=819x223" alt=""/></p><p>输出了后端接口内容。</p><p>同时在代码中修改下输出内容之后：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">func (api *DemoApi) Demo(c *gin.Context) {</span></div><div class="token-line"><span class="token plain">       c.JSON(200, &quot;this is demo for dev&quot;)</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>在控制台中我们可以看到，等待了3s后（这里配置文件设置为3s），在控制台看到如下输出：<br/><img src="https://static001.geekbang.org/resource/image/a9/77/a9f482cf449bdd63ab10b9589552f677.png?wh=766x251" alt=""/></p><p>检测到文件更新，重启服务开启。</p><p>这个时候我们再刷新浏览器的接口，输出已经变化了。<br/><img src="https://static001.geekbang.org/resource/image/8d/cd/8d2e45d4e396cda0772855466c864bcd.png?wh=826x257" alt=""/><br/>后端调试模式通过！</p><h3 id="前后端验证"><a aria-hidden="true" tabindex="-1" href="/blog/手把手带你写一个web框架/04.实战第3关完善功能/03#前后端验证"><span class="icon icon-link"></span></a>前后端验证</h3><p>最后同时验证前端和后端，其实和前面单独验证的方法一样，只是启动命令换成了 <code>./hade dev all</code></p><p>这里我们同时打开两个窗口，<a target="_blank" rel="noopener noreferrer" href="http://127.0.0.1:8070/demo/demo">http://127.0.0.1:8070/demo/demo<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>、<a target="_blank" rel="noopener noreferrer" href="http://127.0.0.1:8070/#/">http://127.0.0.1:8070/#/<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>，能同时看到前端和后端信息：<br/><img src="https://static001.geekbang.org/resource/image/94/8b/948ca235cb9aaafafdfd019ec49c6e8b.png?wh=822x648" alt=""/><img src="https://static001.geekbang.org/resource/image/24/a5/244a3f45c561081d2836da782c9d3ba5.png?wh=824x258" alt=""/></p><p>修改前端msg和修改后端内容后，变更生效：<br/><img src="https://static001.geekbang.org/resource/image/b8/4b/b8322b3854a955ddab449324afb8574b.png?wh=822x686" alt=""/><img src="https://static001.geekbang.org/resource/image/3e/8a/3eba5c41cdafd870878609274f05658a.png?wh=825x204" alt=""/><br/>到这里，前后端同时调试模式验证成功！</p><p>今天的主要内容是创建调试模式的三个二级命令。完整的代码示例在GitHub上的 <a target="_blank" rel="noopener noreferrer" href="https://github.com/gohade/coredemo/tree/geekbang/20">geekbang/20<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 分支，欢迎比对查看。本节课我们只在命令文件中增加了一个framework/command/dev.go文件：<br/><img src="https://static001.geekbang.org/resource/image/e7/y3/e7yy0d64af957beed7139733ac2fdyy3.png?wh=296x811" alt=""/></p><h2 id="小结"><a aria-hidden="true" tabindex="-1" href="/blog/手把手带你写一个web框架/04.实战第3关完善功能/03#小结"><span class="icon icon-link"></span></a>小结</h2><p>今天我们具体实现了调试模式，其实了解了上节课对调试模式的设计之后，今天的内容主要是细节上的代码实现了，就是工作量。不过其中的实现细节，也是在工作中不断积累下来的，你可以多多体会。</p><p>比如refresh_time这个计时器窗口设计，在最初版本是没有的，在实际工作中，使用这个调试模式，遇到了频繁重建的困扰，才做了这个设计。总之，整个调试模式支持是非常赞的，它能让我们的Web开发效率提高了一个档次，希望你也能感同身受。</p><h2 id="思考题"><a aria-hidden="true" tabindex="-1" href="/blog/手把手带你写一个web框架/04.实战第3关完善功能/03#思考题"><span class="icon icon-link"></span></a>思考题</h2><p>在回答同学们问题的时候，我发现有不少是其他语言转来Go的，不知道你的经历是怎样的，可以来聊一聊你在使用其他语言时，调试一个程序都是怎么调试的呢？有没有比较好的调试模式？</p><p>欢迎在留言区分享你的思考。感谢你的收听，我们下节课见～</p></div><div class="__dumi-default-layout-footer-meta"><a target="_blank" rel="noopener noreferrer" href="https://github.com/GGwujun/blog/edit/master/docs/手把手带你写一个Web框架/04.实战第3关完善功能/03.md">在 GitHub 上编辑此页<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a><span data-updated-text="最后更新时间：">5/2/2022 10:56:58</span></div></div></div></div>
	<script>
  window.g_useSSR = true;
  window.g_initialProps = {};
	</script>

    <script>
      (function () {
        if (!location.port) {
          (function (i, s, o, g, r, a, m) {
            i["GoogleAnalyticsObject"] = r;
            (i[r] =
              i[r] ||
              function () {
                (i[r].q = i[r].q || []).push(arguments);
              }),
              (i[r].l = 1 * new Date());
            (a = s.createElement(o)), (m = s.getElementsByTagName(o)[0]);
            a.async = 1;
            a.src = g;
            m.parentNode.insertBefore(a, m);
          })(
            window,
            document,
            "script",
            "//www.google-analytics.com/analytics.js",
            "ga"
          );
          ga("create", "UA-149864185-1", "auto");
          ga("send", "pageview");
        }
      })();
    </script>
    <script src="/blog/umi.js"></script>
  </body>
</html>
