<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no"
    />
    <link rel="shortcut icon" type="image/x-icon" href="/logo.png" />
    <link rel="stylesheet" href="/blog/umi.css" />
    <script>
      window.routerBase = "/blog";
    </script>
    <script>
      //! umi version: 3.5.17
    </script>
    <script>
      !(function () {
        var e = localStorage.getItem("dumi:prefers-color"),
          t = window.matchMedia("(prefers-color-scheme: dark)").matches,
          r = ["light", "dark", "auto"];
        document.documentElement.setAttribute(
          "data-prefers-color",
          e === r[2] ? (t ? r[1] : r[0]) : r.indexOf(e) > -1 ? e : r[0]
        );
      })();
    </script>
    <title>23｜管理接口：如何集成swagger自动生成文件？</title>
  </head>
  <body>
    <div id="root"><div class="__dumi-default-layout" data-route="/手把手带你写一个web框架/04.实战第3关完善功能/06" data-show-sidemenu="true" data-show-slugs="true" data-site-mode="true" data-gapless="false"><div class="__dumi-default-navbar" data-mode="site"><button class="__dumi-default-navbar-toggle"></button><a class="__dumi-default-navbar-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog/">大师兄</a><nav><div class="__dumi-default-search"><input type="search" class="__dumi-default-search-input" value=""/><ul></ul></div><span>计算机基础<ul><li><a href="/blog/编译原理之美">编译原理之美</a></li><li><a href="/blog/编译原理实战">编译原理实战</a></li><li><a href="/blog/深入浅出计算机组成原理">深入浅出计算机组成原理</a></li><li><a href="/blog/详解http">详解http</a></li><li><a href="/blog/计算机网络通关29讲">计算机网络通关29讲</a></li><li><a href="/blog/网络排查案例课">网络排查案例课</a></li><li><a href="/blog/linux操作系统">linux操作系统</a></li><li><a href="/blog/linux性能优化实战">linux性能优化实战</a></li><li><a href="/blog/程序员数学基础">程序员数学基础</a></li><li><a href="/blog/趣谈网络协议">趣谈网络协议</a></li><li><a href="/blog/操作系统实战">操作系统实战</a></li><li><a href="/blog/软件工程之美">软件工程之美</a></li><li><a href="/blog/sql必知必会">sql必知必会</a></li><li><a href="/blog/操作系统实战45讲">操作系统实战45讲</a></li><li><a href="/blog/网络编程实战">网络编程实战</a></li></ul></span><span>算法<ul><li><a href="/blog/常用算法25讲">常用算法25讲</a></li><li><a href="/blog/数据结构与算法之美">数据结构与算法之美</a></li><li><a href="/blog/业务开发算法50讲">业务开发算法50讲</a></li><li><a href="/blog/动态规划面试宝典">动态规划面试宝典</a></li></ul></span><span>前端开发<ul><li><a href="/blog/浏览器工作原理与实践">浏览器工作原理与实践</a></li><li><a href="/blog/新时代产品经理进阶之路">新时代产品经理进阶之路</a></li><li><a href="/blog/全栈工程师修炼指南">全栈工程师修炼指南</a></li><li><a href="/blog/flutter核心技术与实战">flutter核心技术与实战</a></li><li><a href="/blog/java-script核心原理解析">java-script核心原理解析</a></li><li><a href="/blog/说透低代码">说透低代码</a></li><li><a href="/blog/nodejs应用开发实战">nodejs应用开发实战</a></li><li><a href="/blog/反爬虫兵法演绎20讲">反爬虫兵法演绎20讲</a></li><li><a href="/blog/reactnative新架构实战课">reactnative新架构实战课</a></li><li><a href="/blog/正则表达式入门">正则表达式入门</a></li><li><a href="/blog/重学前端">重学前端</a></li><li><a href="/blog/serverless入门课">serverless入门课</a></li><li><a href="/blog/type-script入门实战笔记">type-script入门实战笔记</a></li><li><a href="/blog/图解googlev8">图解googlev8</a></li><li><a href="/blog/vue3源码分析">vue3源码分析</a></li><li><a href="/blog/玩转Vue3全家桶">玩转Vue3全家桶</a></li><li><a href="/blog/webassembly入门">webassembly入门</a></li><li><a aria-current="page" class="active" href="/blog/手把手带你写一个Web框架">手把手带你写一个Web框架</a></li><li><a href="/blog/web漏洞挖掘实战">web漏洞挖掘实战</a></li><li><a href="/blog/跟月影学可视化">跟月影学可视化</a></li><li><a href="/blog/搞定音频技术">搞定音频技术</a></li><li><a href="/blog/攻克视频技术">攻克视频技术</a></li></ul></span><span>前端工程化<ul><li><a href="/blog/logger">logger</a></li><li><a href="/blog/webpack">webpack</a></li><li><a href="/blog/webpackChain">webpackChain</a></li></ul></span><span>前端性能优化<ul><li><a href="/blog/react性能调优">react性能调优</a></li></ul></span><span>软件测试<ul><li><a href="/blog/全链路压测实战30讲">全链路压测实战30讲</a></li><li><a href="/blog/性能测试实战30讲">性能测试实战30讲</a></li><li><a href="/blog/自动化测试高手课">自动化测试高手课</a></li><li><a href="/blog/软件测试52讲">软件测试52讲</a></li></ul></span><span>面试<ul><li><a href="/blog/面试现场">面试现场</a></li></ul></span><span>杂谈<ul><li><a href="/blog/超级访谈对话张雪峰">超级访谈对话张雪峰</a></li><li><a href="/blog/Git实战手册">Git实战手册</a></li><li><a href="/blog/NodeJS">NodeJS</a></li><li><a href="/blog/ReactJS">ReactJS</a></li><li><a href="/blog/UI设计">UI设计</a></li><li><a href="/blog/webpack4系列教程">webpack4系列教程</a></li><li><a href="/blog/前端知识体系">前端知识体系</a></li><li><a href="/blog/剑指offer刷题笔记">剑指offer刷题笔记</a></li><li><a href="/blog/思考与成长">思考与成长</a></li><li><a href="/blog/设计模式手册">设计模式手册</a></li></ul></span><div class="__dumi-default-navbar-tool"><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "></div></div></div></nav></div><div class="__dumi-default-menu" data-mode="site"><div class="__dumi-default-menu-inner"><div class="__dumi-default-menu-header"><a class="__dumi-default-menu-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog/"></a><h1>大师兄</h1><p></p></div><div class="__dumi-default-menu-mobile-area"><ul class="__dumi-default-menu-nav-list"><li>计算机基础<ul><li><a href="/blog/编译原理之美">编译原理之美</a></li><li><a href="/blog/编译原理实战">编译原理实战</a></li><li><a href="/blog/深入浅出计算机组成原理">深入浅出计算机组成原理</a></li><li><a href="/blog/详解http">详解http</a></li><li><a href="/blog/计算机网络通关29讲">计算机网络通关29讲</a></li><li><a href="/blog/网络排查案例课">网络排查案例课</a></li><li><a href="/blog/linux操作系统">linux操作系统</a></li><li><a href="/blog/linux性能优化实战">linux性能优化实战</a></li><li><a href="/blog/程序员数学基础">程序员数学基础</a></li><li><a href="/blog/趣谈网络协议">趣谈网络协议</a></li><li><a href="/blog/操作系统实战">操作系统实战</a></li><li><a href="/blog/软件工程之美">软件工程之美</a></li><li><a href="/blog/sql必知必会">sql必知必会</a></li><li><a href="/blog/操作系统实战45讲">操作系统实战45讲</a></li><li><a href="/blog/网络编程实战">网络编程实战</a></li></ul></li><li>算法<ul><li><a href="/blog/常用算法25讲">常用算法25讲</a></li><li><a href="/blog/数据结构与算法之美">数据结构与算法之美</a></li><li><a href="/blog/业务开发算法50讲">业务开发算法50讲</a></li><li><a href="/blog/动态规划面试宝典">动态规划面试宝典</a></li></ul></li><li>前端开发<ul><li><a href="/blog/浏览器工作原理与实践">浏览器工作原理与实践</a></li><li><a href="/blog/新时代产品经理进阶之路">新时代产品经理进阶之路</a></li><li><a href="/blog/全栈工程师修炼指南">全栈工程师修炼指南</a></li><li><a href="/blog/flutter核心技术与实战">flutter核心技术与实战</a></li><li><a href="/blog/java-script核心原理解析">java-script核心原理解析</a></li><li><a href="/blog/说透低代码">说透低代码</a></li><li><a href="/blog/nodejs应用开发实战">nodejs应用开发实战</a></li><li><a href="/blog/反爬虫兵法演绎20讲">反爬虫兵法演绎20讲</a></li><li><a href="/blog/reactnative新架构实战课">reactnative新架构实战课</a></li><li><a href="/blog/正则表达式入门">正则表达式入门</a></li><li><a href="/blog/重学前端">重学前端</a></li><li><a href="/blog/serverless入门课">serverless入门课</a></li><li><a href="/blog/type-script入门实战笔记">type-script入门实战笔记</a></li><li><a href="/blog/图解googlev8">图解googlev8</a></li><li><a href="/blog/vue3源码分析">vue3源码分析</a></li><li><a href="/blog/玩转Vue3全家桶">玩转Vue3全家桶</a></li><li><a href="/blog/webassembly入门">webassembly入门</a></li><li><a aria-current="page" class="active" href="/blog/手把手带你写一个Web框架">手把手带你写一个Web框架</a></li><li><a href="/blog/web漏洞挖掘实战">web漏洞挖掘实战</a></li><li><a href="/blog/跟月影学可视化">跟月影学可视化</a></li><li><a href="/blog/搞定音频技术">搞定音频技术</a></li><li><a href="/blog/攻克视频技术">攻克视频技术</a></li></ul></li><li>前端工程化<ul><li><a href="/blog/logger">logger</a></li><li><a href="/blog/webpack">webpack</a></li><li><a href="/blog/webpackChain">webpackChain</a></li></ul></li><li>前端性能优化<ul><li><a href="/blog/react性能调优">react性能调优</a></li></ul></li><li>软件测试<ul><li><a href="/blog/全链路压测实战30讲">全链路压测实战30讲</a></li><li><a href="/blog/性能测试实战30讲">性能测试实战30讲</a></li><li><a href="/blog/自动化测试高手课">自动化测试高手课</a></li><li><a href="/blog/软件测试52讲">软件测试52讲</a></li></ul></li><li>面试<ul><li><a href="/blog/面试现场">面试现场</a></li></ul></li><li>杂谈<ul><li><a href="/blog/超级访谈对话张雪峰">超级访谈对话张雪峰</a></li><li><a href="/blog/Git实战手册">Git实战手册</a></li><li><a href="/blog/NodeJS">NodeJS</a></li><li><a href="/blog/ReactJS">ReactJS</a></li><li><a href="/blog/UI设计">UI设计</a></li><li><a href="/blog/webpack4系列教程">webpack4系列教程</a></li><li><a href="/blog/前端知识体系">前端知识体系</a></li><li><a href="/blog/剑指offer刷题笔记">剑指offer刷题笔记</a></li><li><a href="/blog/思考与成长">思考与成长</a></li><li><a href="/blog/设计模式手册">设计模式手册</a></li></ul></li></ul><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "><button title="Dark theme" class="__dumi-default-dark-moon "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="3854" width="22" height="22"><path d="M991.816611 674.909091a69.166545 69.166545 0 0 0-51.665455-23.272727 70.795636 70.795636 0 0 0-27.438545 5.585454A415.674182 415.674182 0 0 1 754.993338 698.181818c-209.594182 0-393.472-184.785455-393.472-395.636363 0-52.363636 38.539636-119.621818 69.515637-173.614546 4.887273-8.610909 9.634909-16.756364 14.103272-24.901818A69.818182 69.818182 0 0 0 384.631156 0a70.842182 70.842182 0 0 0-27.438545 5.585455C161.678429 90.298182 14.362065 307.898182 14.362065 512c0 282.298182 238.824727 512 532.38691 512a522.286545 522.286545 0 0 0 453.957818-268.334545A69.818182 69.818182 0 0 0 991.816611 674.909091zM546.679156 954.181818c-248.785455 0-462.941091-192-462.941091-442.181818 0-186.647273 140.637091-372.829091 300.939637-442.181818-36.817455 65.629091-92.578909 151.970909-92.578909 232.727273 0 250.181818 214.109091 465.454545 462.917818 465.454545a488.331636 488.331636 0 0 0 185.181091-46.545455 453.003636 453.003636 0 0 1-393.565091 232.727273z m103.656728-669.323636l-14.266182 83.781818a34.909091 34.909091 0 0 0 50.362182 36.770909l74.775272-39.563636 74.752 39.563636a36.142545 36.142545 0 0 0 16.174546 3.956364 34.909091 34.909091 0 0 0 34.210909-40.727273l-14.289455-83.781818 60.509091-59.345455a35.025455 35.025455 0 0 0-19.223272-59.578182l-83.61891-12.101818-37.376-76.101818a34.56 34.56 0 0 0-62.254545 0l-37.376 76.101818-83.618909 12.101818a34.909091 34.909091 0 0 0-19.246546 59.578182z m70.423272-64.698182a34.280727 34.280727 0 0 0 26.135273-19.083636l14.312727-29.090909 14.336 29.090909a34.257455 34.257455 0 0 0 26.135273 19.083636l32.046546 4.887273-23.272728 22.574545a35.234909 35.234909 0 0 0-10.007272 30.952727l5.46909 32.116364-28.625454-15.127273a34.490182 34.490182 0 0 0-32.302546 0l-28.695272 15.127273 5.469091-32.116364a35.141818 35.141818 0 0 0-9.984-30.952727l-23.272728-22.574545z" p-id="3855"></path></svg></button><button title="Light theme" class="__dumi-default-dark-sun "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="4026" width="22" height="22"><path d="M915.2 476.16h-43.968c-24.704 0-44.736 16-44.736 35.84s20.032 35.904 44.736 35.904H915.2c24.768 0 44.8-16.064 44.8-35.904s-20.032-35.84-44.8-35.84zM512 265.6c-136.704 0-246.464 109.824-246.464 246.4 0 136.704 109.76 246.464 246.464 246.464S758.4 648.704 758.4 512c0-136.576-109.696-246.4-246.4-246.4z m0 425.6c-99.008 0-179.2-80.128-179.2-179.2 0-98.944 80.192-179.2 179.2-179.2S691.2 413.056 691.2 512c0 99.072-80.192 179.2-179.2 179.2zM197.44 512c0-19.84-19.136-35.84-43.904-35.84H108.8c-24.768 0-44.8 16-44.8 35.84s20.032 35.904 44.8 35.904h44.736c24.768 0 43.904-16.064 43.904-35.904zM512 198.464c19.776 0 35.84-20.032 35.84-44.8v-44.8C547.84 84.032 531.84 64 512 64s-35.904 20.032-35.904 44.8v44.8c0 24.768 16.128 44.864 35.904 44.864z m0 627.136c-19.776 0-35.904 20.032-35.904 44.8v44.736C476.096 940.032 492.16 960 512 960s35.84-20.032 35.84-44.8v-44.736c0-24.768-16.064-44.864-35.84-44.864z m329.92-592.832c17.472-17.536 20.288-43.072 6.4-57.024-14.016-14.016-39.488-11.2-57.024 6.336-4.736 4.864-26.496 26.496-31.36 31.36-17.472 17.472-20.288 43.008-6.336 57.024 13.952 14.016 39.488 11.2 57.024-6.336 4.8-4.864 26.496-26.56 31.296-31.36zM213.376 759.936c-4.864 4.8-26.56 26.624-31.36 31.36-17.472 17.472-20.288 42.944-6.4 56.96 14.016 13.952 39.552 11.2 57.024-6.336 4.8-4.736 26.56-26.496 31.36-31.36 17.472-17.472 20.288-43.008 6.336-56.96-14.016-13.952-39.552-11.072-56.96 6.336z m19.328-577.92c-17.536-17.536-43.008-20.352-57.024-6.336-14.08 14.016-11.136 39.488 6.336 57.024 4.864 4.864 26.496 26.56 31.36 31.424 17.536 17.408 43.008 20.288 56.96 6.336 14.016-14.016 11.264-39.488-6.336-57.024-4.736-4.864-26.496-26.56-31.296-31.424z m527.168 628.608c4.864 4.864 26.624 26.624 31.36 31.424 17.536 17.408 43.072 20.224 57.088 6.336 13.952-14.016 11.072-39.552-6.4-57.024-4.864-4.8-26.56-26.496-31.36-31.36-17.472-17.408-43.072-20.288-57.024-6.336-13.952 14.016-11.008 39.488 6.336 56.96z" p-id="4027"></path></svg></button><button title="Default to system" class="__dumi-default-dark-auto "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="11002" width="22" height="22"><path d="M127.658667 492.885333c0-51.882667 10.24-101.717333 30.378666-149.162666s47.786667-88.064 81.92-122.538667 75.093333-61.781333 122.538667-81.92 96.938667-30.378667 149.162667-30.378667 101.717333 10.24 149.162666 30.378667 88.405333 47.786667 122.88 81.92 61.781333 75.093333 81.92 122.538667 30.378667 96.938667 30.378667 149.162666-10.24 101.717333-30.378667 149.162667-47.786667 88.405333-81.92 122.88-75.093333 61.781333-122.88 81.92-97.28 30.378667-149.162666 30.378667-101.717333-10.24-149.162667-30.378667-88.064-47.786667-122.538667-81.92-61.781333-75.093333-81.92-122.88-30.378667-96.938667-30.378666-149.162667z m329.045333 0c0 130.048 13.994667 244.394667 41.984 343.381334h12.970667c46.762667 0 91.136-9.216 133.461333-27.306667s78.848-42.666667 109.568-73.386667 54.954667-67.242667 73.386667-109.568 27.306667-86.698667 27.306666-133.461333c0-46.421333-9.216-90.794667-27.306666-133.12s-42.666667-78.848-73.386667-109.568-67.242667-54.954667-109.568-73.386667-86.698667-27.306667-133.461333-27.306666h-11.605334c-28.672 123.562667-43.349333 237.909333-43.349333 343.722666z" p-id="11003"></path></svg></button></div></div></div><ul class="__dumi-default-menu-list"><li><a href="/blog/">大师兄 - 前端架构师</a></li></ul></div></div><ul role="slug-list" class="__dumi-default-layout-toc"><li title="swagger" data-depth="3"><a href="/blog/手把手带你写一个web框架/04.实战第3关完善功能/06#swagger"><span>swagger</span></a></li><li title="命令设计" data-depth="3"><a href="/blog/手把手带你写一个web框架/04.实战第3关完善功能/06#命令设计"><span>命令设计</span></a></li><li title="swag项目" data-depth="3"><a href="/blog/手把手带你写一个web框架/04.实战第3关完善功能/06#swag项目"><span>swag项目</span></a></li><li title="命令实现" data-depth="3"><a href="/blog/手把手带你写一个web框架/04.实战第3关完善功能/06#命令实现"><span>命令实现</span></a></li><li title="启动swagger-ui" data-depth="3"><a href="/blog/手把手带你写一个web框架/04.实战第3关完善功能/06#启动swagger-ui"><span>启动swagger-ui</span></a></li><li title="gin-swagger原理分析" data-depth="3"><a href="/blog/手把手带你写一个web框架/04.实战第3关完善功能/06#gin-swagger原理分析"><span>gin-swagger原理分析</span></a></li><li title="如何集成" data-depth="3"><a href="/blog/手把手带你写一个web框架/04.实战第3关完善功能/06#如何集成"><span>如何集成</span></a></li><li title="验证" data-depth="3"><a href="/blog/手把手带你写一个web框架/04.实战第3关完善功能/06#验证"><span>验证</span></a></li><li title="小结" data-depth="3"><a href="/blog/手把手带你写一个web框架/04.实战第3关完善功能/06#小结"><span>小结</span></a></li><li title="思考题" data-depth="3"><a href="/blog/手把手带你写一个web框架/04.实战第3关完善功能/06#思考题"><span>思考题</span></a></li></ul><div class="__dumi-default-layout-content"><div class="markdown"><h1 id="23管理接口如何集成swagger自动生成文件"><a aria-hidden="true" tabindex="-1" href="/blog/手把手带你写一个web框架/04.实战第3关完善功能/06#23管理接口如何集成swagger自动生成文件"><span class="icon icon-link"></span></a>23｜管理接口：如何集成swagger自动生成文件？</h1><p>你好，我是轩脉刃。</p><p>不管你是前端页面开发，还是后端服务开发，你一定经历过前后端联调的场景，前后端联调最痛苦的事情，莫过于没有完善的接口文档、没有可以调用调试的接口返回值了，所以一般都会采用形如Postman这样的第三方工具，来进行接口的调用和联调。</p><p>但是这一节课，我们要做的事情，就是为自己的Web应用集成swagger，使用swagger自动生成一个可以查看接口、可以调用执行的页面。</p><h3 id="swagger"><a aria-hidden="true" tabindex="-1" href="/blog/手把手带你写一个web框架/04.实战第3关完善功能/06#swagger"><span class="icon icon-link"></span></a>swagger</h3><p>说到swagger，可能有的同学还比较陌生，我来简要介绍一下。swagger框架在2009年启动，之前是Reverb公司内部开发的一个项目，他们的工程师在与第三方调试REST接口的过程中，为了解决大量的接口与文档问题，就设计了swagger这个项目。</p><p>项目最终成型的方案是，先设计一个JSON规则，开发工程师把所有服务接口按照这种规则来写成一个JSON文件，<strong>这个JSON文件可以直接生成一个交互式UI，可以提供调用者查看、调用调试</strong>。</p><p>swagger的应用是非常广泛的。非常多的开源项目在提供对外接口的时候都使用swagger来进行描述。比如目前最火的Kubernetes项目，每次在发布版本的时候，都会在项目根目录上，带上符合swagger规则的<a target="_blank" rel="noopener noreferrer" href="https://github.com/kubernetes/kubernetes/blob/master/api/openapi-spec/swagger.json">JSON文件<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>，用来向使用者提供内部接口。</p><p>swagger的产品有两类。</p><p>一个是前面说的JSON规则，就是OpenAPI的文档，它说明了我们要写一个接口说明文档的每个字段含义和要求。</p><p>OpenAPI的规则也是有版本的，目前最新版本是3.0，但是3.0版本目前市场上相应的配套支持还不成熟，比如Golang版本的SDK库<a target="_blank" rel="noopener noreferrer" href="https://github.com/go-openapi/spec">spec<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>还不支持。目前市面上对OpenAPI2.0的支持还是最全的。所以我们的hade框架就使用swagger2.0版本。</p><p>swagger的另外一类产品是工具，包括swagger-ui、swagger-editor和swagger-codegen。</p><p><a target="_blank" rel="noopener noreferrer" href="https://editor.swagger.io/">swagger-editor<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>提供一个开源网站，在线编辑swagger文件。<a target="_blank" rel="noopener noreferrer" href="https://swagger.io/tools/swagger-codegen/download/">swagger-codegen<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>提供一个Java命令行工具，通过swagger文件生成client端代码。而<a target="_blank" rel="noopener noreferrer" href="https://petstore.swagger.io/">swagger-ui<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>，通过提供一个开源网站，将swagger接口在线展示出来，并且可以让调用者查看、调试。我们的目标是生成一个可以查看接口，进行调用调试的页面，所以要将swagger-ui集成进hade框架。</p><h3 id="命令设计"><a aria-hidden="true" tabindex="-1" href="/blog/手把手带你写一个web框架/04.实战第3关完善功能/06#命令设计"><span class="icon icon-link"></span></a>命令设计</h3><p>了解了swagger，结合框架，我们照例先思考下希望如何使用它。</p><p>按照swagger的定义，我们应该在业务项目中维护一个JSON文件，这个文件描述了这个业务的所有接口。但是你想过没有，<strong>随着项目的接口数越来越大，维护swagger的JSON描述文档本身，就是一个很大很繁杂的工作量</strong>。</p><p>由于每个接口在代码开发的时候，我们都会有注释，而更新代码的时候，我们是会去更新注释的。所以能不能有一个方法，通过代码的注释，自动生成这个JSON文件呢？</p><p>好，这个就是我们希望定义的一个swagger命令，<code>./hade swagger gen</code> ，能通过注释生成swagger.json文件。</p><p>但是考虑具体的实现设计，怎么用Golang的代码，注释生成swagger.json呢？既然swagger.json是有一定的规则的，那么注释的写法也是有一定规则的吧？是的。目前有一个最流行的将Golang注释转化为swagger.json 的开源项目<a target="_blank" rel="noopener noreferrer" href="https://github.com/swaggo/swag">swag<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>。</p><h3 id="swag项目"><a aria-hidden="true" tabindex="-1" href="/blog/手把手带你写一个web框架/04.实战第3关完善功能/06#swag项目"><span class="icon icon-link"></span></a>swag项目</h3><p>这个swag项目是MIT 协议，目前已经有4.9k 个star了。它的用法和我们想要的一样，生成swagger.json分三步：</p><ul><li>在API接口中编写注释。注释的详细写法需要参考<a target="_blank" rel="noopener noreferrer" href="https://github.com/swaggo/swag#declarative-comments-format">说明文档<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>。</li><li>下载swag工具或者安装swag库</li><li>使用工具或者库将指定代码生成swagger.json</li></ul><p>步骤很简单，不过第一步怎么写swag的注释说明文档，是使用这个技术必须要学习的一个知识，这个的学习确实是有些门槛的，需要熟读对应的说明文档才能写出比较好的注释。这里我们用一个例子来讲解我在编写代码的时候常用的一些字段，供你参考。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// Demo2  for godoc</span></div><div class="token-line"><span class="token plain">    // @Summary 获取所有学生</span></div><div class="token-line"><span class="token plain">    // @Description 获取所有学生，不进行分页</span></div><div class="token-line"><span class="token plain">    // @Produce  json</span></div><div class="token-line"><span class="token plain">    // @Tags demo</span></div><div class="token-line"><span class="token plain">    // @Success 200 {array} []UserDTO</span></div><div class="token-line"><span class="token plain">    // @Router /demo/demo2 [get]</span></div><div class="token-line"><span class="token plain">    func (api *DemoApi) Demo2(c *gin.Context) {</span></div><div class="token-line"><span class="token plain">       demoProvider := c.MustMake(demoService.DemoKey).(demoService.IService)</span></div><div class="token-line"><span class="token plain">       students := demoProvider.GetAllStudent()</span></div><div class="token-line"><span class="token plain">       usersDTO := StudentsToUserDTOs(students)</span></div><div class="token-line"><span class="token plain">       c.JSON(200, usersDTO)</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    type UserDTO struct {</span></div><div class="token-line"><span class="token plain">       ID   int    `json:&quot;id&quot;`</span></div><div class="token-line"><span class="token plain">       Name string `json:&quot;name&quot;`</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>观察注释。第一行 <code>Demo2 for godoc</code> 这个在swagger中并没有实际作用，它是用来给godoc工具生成说明文档的。从第二行开始，就是我们swaggo的注释语法了，使用@符号加上关键字的方式来进行说明。<br/>例子的关键字有这些：</p><ul><li>Summary，为接口增加简要说明</li><li>Description，为接口增加详细说明</li><li>Produce，说明接口返回格式</li><li>Tags，为接口打标签，可以为多个，便于查看者查找</li><li>Success，接口返回成功时候的说明</li><li>Router，接口的路由调用</li></ul><p>具体对应的swagger-ui界面是这样的：<br/><img src="https://static001.geekbang.org/resource/image/94/ec/94c4a5c83dc771be6f8b60527e9951ec.png?wh=2872x1644" alt=""/></p><p>我们对照注释和界面，很容易就看出每个注释的最终显示效果。不过这里再啰嗦解释下比较复杂的Success注释。</p><p>在这个例子中，是这样使用Success注释的：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// @Success 200 {array} UserDTO</span></div></pre></div><p>在成功的时候，返回UserDTO结构的数组，这里，swaggo会自动去项目中寻找UserDTO结构，来生成swagger-ui中的返回结构说明。</p><p>不过这里能这么写，是因为恰好UserDTO是和API放在同一个namespace下，如果你的返回结构放在不同的namespace下，需要在注释中注明返回结构的命名空间。比如：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// @Success 200 {array} model.Account</span></div></pre></div><p>同时，这个返回结构还支持返回对象嵌套，比如下面这个例子：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// 返回了一个JsonResult对象，其中这个对象的data字段是Order结构</span></div><div class="token-line"><span class="token plain">    @success 200 {object} jsonresult.JSONResult{data=proto.Order} &quot;desc&quot;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    type JSONResult struct {</span></div><div class="token-line"><span class="token plain">        Code    int          `json:&quot;code&quot; `</span></div><div class="token-line"><span class="token plain">        Message string       `json:&quot;message&quot;`</span></div><div class="token-line"><span class="token plain">        Data    interface{}  `json:&quot;data&quot;`</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    type Order struct { //in `proto` package</span></div><div class="token-line"><span class="token plain">        Id  uint            `json:&quot;id&quot;`</span></div><div class="token-line"><span class="token plain">        Data  interface{}   `json:&quot;data&quot;`</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>它返回了一个JSONResult对象，这个JSONResult对象中的一个字段data是Order结构。</p><h3 id="命令实现"><a aria-hidden="true" tabindex="-1" href="/blog/手把手带你写一个web框架/04.实战第3关完善功能/06#命令实现"><span class="icon icon-link"></span></a>命令实现</h3><p>现在注释已经标记好了，我们再回到生成JSON文件的命令 <code>./hade swagger gen</code> 。</p><p>这个命令通过swaggo准备好的命令行工具swag或者类库，来生成JSON文件。由于我们的框架已经集成了命令行工具，所以不会选择额外使用swag工具，而是在我们的命令中集成swaggo类库：<a target="_blank" rel="noopener noreferrer" href="https://github.com/swaggo/swag/tree/master/gen">swag/gen<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>。</p><p>这个类库最核心的结构就是<a target="_blank" rel="noopener noreferrer" href="https://github.com/swaggo/swag/blob/master/gen/gen.go">Config结构<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>。来看这个swagger gen命令的具体实现代码，写在framework/command/swagger.go中：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// swaggerGenCommand 生成具体的swagger文档</span></div><div class="token-line"><span class="token plain">    var swaggerGenCommand = &amp;cobra.Command{</span></div><div class="token-line"><span class="token plain">       Use:   &quot;gen&quot;,</span></div><div class="token-line"><span class="token plain">       Short: &quot;生成对应的swagger文件, contain swagger.yaml, doc.go&quot;,</span></div><div class="token-line"><span class="token plain">       Run: func(c *cobra.Command, args []string) {</span></div><div class="token-line"><span class="token plain">          container := c.GetContainer()</span></div><div class="token-line"><span class="token plain">          appService := container.MustMake(contract.AppKey).(contract.App)</span></div><div class="token-line"><span class="token plain">          outputDir := filepath.Join(appService.AppFolder(), &quot;http&quot;, &quot;swagger&quot;)</span></div><div class="token-line"><span class="token plain">          httpFolder := filepath.Join(appService.AppFolder(), &quot;http&quot;)</span></div><div class="token-line"><span class="token plain">          conf := &amp;gen.Config{</span></div><div class="token-line"><span class="token plain">             // 遍历需要查询注释的目录</span></div><div class="token-line"><span class="token plain">             SearchDir: httpFolder,</span></div><div class="token-line"><span class="token plain">             // 不包含哪些文件</span></div><div class="token-line"><span class="token plain">             Excludes: &quot;&quot;,</span></div><div class="token-line"><span class="token plain">             // 输出目录</span></div><div class="token-line"><span class="token plain">             OutputDir: outputDir,</span></div><div class="token-line"><span class="token plain">             // 整个swagger接口的说明文档注释</span></div><div class="token-line"><span class="token plain">             MainAPIFile: &quot;swagger.go&quot;,</span></div><div class="token-line"><span class="token plain">             // 名字的显示策略，比如首字母大写等</span></div><div class="token-line"><span class="token plain">             PropNamingStrategy: &quot;&quot;,</span></div><div class="token-line"><span class="token plain">             // 是否要解析vendor目录</span></div><div class="token-line"><span class="token plain">             ParseVendor: false,</span></div><div class="token-line"><span class="token plain">             // 是否要解析外部依赖库的包</span></div><div class="token-line"><span class="token plain">             ParseDependency: false,</span></div><div class="token-line"><span class="token plain">             // 是否要解析标准库的包</span></div><div class="token-line"><span class="token plain">             ParseInternal: false,</span></div><div class="token-line"><span class="token plain">             // 是否要查找markdown文件，这个markdown文件能用来为tag增加说明格式</span></div><div class="token-line"><span class="token plain">             MarkdownFilesDir: &quot;&quot;,</span></div><div class="token-line"><span class="token plain">             // 是否应该在docs.go中生成时间戳</span></div><div class="token-line"><span class="token plain">             GeneratedTime: false,</span></div><div class="token-line"><span class="token plain">          }</span></div><div class="token-line"><span class="token plain">          err := gen.New().Build(conf)</span></div><div class="token-line"><span class="token plain">          if err != nil {</span></div><div class="token-line"><span class="token plain">             fmt.Println(err)</span></div><div class="token-line"><span class="token plain">          }</span></div><div class="token-line"><span class="token plain">       },</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>结合这个具体实现，我们来看这个Config结构的关键字段SearchDir、OutputDir和MainAPIFile，这几个字段的含义必须完全理解才能设置正确，其他的几个字段如果不理解，直接使用默认值就行。</p><p><strong>第一个 SearchDir 表示要swaggo去哪个目录遍历代码的注释，来生成swagger的JSON文件</strong>。对于我们的hade框架，所有接口文件都存放在app/http文件夹中，所以要遍历的就是这个文件夹了。</p><p>第二个关键字段 OutputDir，表示要输出的swagger文件的存放地址。我们在app/http目录下，创建一个swagger目录，来存放要输出的swagger文件。这里再补充一点，前面说swagger最终会生成JSON文件，但是你运行一次swagger gen 会发现，这个生成目录下除了有swagger.json这个文件，还有两个文件swagger.yaml 和 docs.go。</p><p>对于额外生成的这两个文件，swagger.yaml 是YAML格式的接口说明文档，里面的内容和swagger.json其实是一样的。<strong>而docs.go 是“接口说明文档”的代码，它是为go项目直接引入接口说明文档生成swagger-ui用的</strong>。</p><p>也就是说生成的docs.go，我们的框架只需要import它，就能从这个文件的变量doc中直接获取到“接口说明文档”，不需要用读取文件的方式读取swagger.json 或者swagger.yaml。下一节课我们会使用它来让框架启动服务的时候自动启动swagger-ui。</p><p><strong>第三个关键字段 MainAPIFile，表示整个swagger接口的说明文档</strong>。这是什么意思呢？在最终生成的swagger-ui界面上的头部，你会看到对当前swagger接口的整体说明，包括作者、接口版本、接口licence等信息。<br/><img src="https://static001.geekbang.org/resource/image/8e/a8/8ec3d0027ec7ed8e76587dcfcf7b87a8.png?wh=2918x718" alt=""/></p><p>这些信息也都是使用注释来自动生成的，而这一部分注释，就是存放在这个MainApiFile所指向的Go文件中。</p><p>我们的项目就固定将这个文件命名为swagger.go，存放在app/http/swagger.go 文件中。这个文件只是增加注释，不增加任何的业务逻辑。其中的每个注释的关键字说明，也是参考swaggo的<a target="_blank" rel="noopener noreferrer" href="https://github.com/swaggo/swag#declarative-comments-format">说明文档<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// Package http API.</span></div><div class="token-line"><span class="token plain">    // @title hade</span></div><div class="token-line"><span class="token plain">    // @version 1.1</span></div><div class="token-line"><span class="token plain">    // @description hade测试</span></div><div class="token-line"><span class="token plain">    // @termsOfService https://github.com/swaggo/swag</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    // @contact.name yejianfeng1</span></div><div class="token-line"><span class="token plain">    // @contact.email yejianfeng</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    // @license.name Apache 2.0</span></div><div class="token-line"><span class="token plain">    // @license.url http://www.apache.org/licenses/LICENSE-2.0.html</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    // @BasePath /</span></div><div class="token-line"><span class="token plain">    // @query.collection.format multi</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    // @securityDefinitions.basic BasicAuth</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    // @securityDefinitions.apikey ApiKeyAuth</span></div><div class="token-line"><span class="token plain">    // @in header</span></div><div class="token-line"><span class="token plain">    // @name Authorization</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    // @x-extension-openapi {&quot;example&quot;: &quot;value on a json format&quot;}</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    package http</span></div></pre></div><p>现在按照前面的说明，我们设置好了Config结构，在swaggerGenCommand 命令逻辑的最后，只需调用一次Build方法，就能按照Config配置来生成 docs.go、swagger.json、swagger.yaml这三个文件了。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">err := gen.New().Build(conf)</span></div></pre></div><p>记得将这个二级命令 <code>./hade swagger gen</code> 挂载到一级命令 <code>./hade swagger</code> 下，并且挂载到framework/command/kernel.go 中。这个步骤，前面几章中都已经重复做过了，这里就不赘述了。</p><p>挂载好之后，我们尝试运行一下：<br/><img src="https://static001.geekbang.org/resource/image/2e/b7/2e46d84c14b1b219abdd5cf378d9edb7.png?wh=1650x340" alt=""/></p><p>可以看到，日志信息打印非常详细，包括去哪个目录查找、最终生成哪些文件。</p><p>查看app/http/swagger目录，确实最终生成了docs.go、swagger.json、swagger.yaml 这三个文件：<br/><img src="https://static001.geekbang.org/resource/image/f2/3b/f2f05578d6483d2e4a4d483aee1ecb3b.png?wh=680x574" alt=""/></p><h3 id="启动swagger-ui"><a aria-hidden="true" tabindex="-1" href="/blog/手把手带你写一个web框架/04.实战第3关完善功能/06#启动swagger-ui"><span class="icon icon-link"></span></a>启动swagger-ui</h3><p>有了swagger生成文件了，应该怎么使用它呢？还是先设想，我们希望的是，能在启动服务的时候，同时启动一个swagger-ui页面，给接口使用人员来查看服务接口，并且他们可以直接在这个页面进行接口调用。</p><p>到这里相信你已经想到了，在启动服务的时候，<strong>增加一个打开swagger-ui页面路由</strong>，就可以达到我们的目的了。还是查看swaggo这个项目，<a target="_blank" rel="noopener noreferrer" href="https://github.com/swaggo/swag#how-to-use-it-with-gin">官方文档<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>中有一段如何将swaggo结合Gin来生成路由的方法说明，正好我们框架的路由用的Gin，所以就考虑使用这个方法来开辟一个swagger-ui路由。</p><p>swaggo开发了一个<a target="_blank" rel="noopener noreferrer" href="https://github.com/swaggo/gin-swagger">gin-swagger<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 中间件，来为Gin框架增加路由设置。怎么使用它呢？看官方文档的这个<a target="_blank" rel="noopener noreferrer" href="https://github.com/swaggo/gin-swagger">例子<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">package main</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    import (</span></div><div class="token-line"><span class="token plain">       &quot;github.com/gin-gonic/gin&quot;</span></div><div class="token-line"><span class="token plain">       docs &quot;github.com/go-project-name/docs&quot;</span></div><div class="token-line"><span class="token plain">       swaggerfiles &quot;github.com/swaggo/files&quot;</span></div><div class="token-line"><span class="token plain">       ginSwagger &quot;github.com/swaggo/gin-swagger&quot;</span></div><div class="token-line"><span class="token plain">       &quot;net/http&quot;</span></div><div class="token-line"><span class="token plain">    )</span></div><div class="token-line"><span class="token plain">    // @BasePath /api/v1</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    // PingExample godoc</span></div><div class="token-line"><span class="token plain">    // @Summary ping example</span></div><div class="token-line"><span class="token plain">    // @Schemes</span></div><div class="token-line"><span class="token plain">    // @Description do ping</span></div><div class="token-line"><span class="token plain">    // @Tags example</span></div><div class="token-line"><span class="token plain">    // @Accept json</span></div><div class="token-line"><span class="token plain">    // @Produce json</span></div><div class="token-line"><span class="token plain">    // @Success 200 {string} Helloworld</span></div><div class="token-line"><span class="token plain">    // @Router /example/helloworld [get]</span></div><div class="token-line"><span class="token plain">    func Helloworld(g *gin.Context)  {</span></div><div class="token-line"><span class="token plain">       g.JSON(http.StatusOK,&quot;helloworld&quot;)</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    func main()  {</span></div><div class="token-line"><span class="token plain">       r := gin.Default()</span></div><div class="token-line"><span class="token plain">       docs.SwaggerInfo.BasePath = &quot;/api/v1&quot;</span></div><div class="token-line"><span class="token plain">       v1 := r.Group(&quot;/api/v1&quot;)</span></div><div class="token-line"><span class="token plain">       {</span></div><div class="token-line"><span class="token plain">          eg := v1.Group(&quot;/example&quot;)</span></div><div class="token-line"><span class="token plain">          {</span></div><div class="token-line"><span class="token plain">             eg.GET(&quot;/helloworld&quot;,Helloworld)</span></div><div class="token-line"><span class="token plain">          }</span></div><div class="token-line"><span class="token plain">       }</span></div><div class="token-line"><span class="token plain">       r.GET(&quot;/swagger/*any&quot;, ginSwagger.WrapHandler(swaggerfiles.Handler))</span></div><div class="token-line"><span class="token plain">       r.Run(&quot;:8080&quot;)</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><h3 id="gin-swagger原理分析"><a aria-hidden="true" tabindex="-1" href="/blog/手把手带你写一个web框架/04.实战第3关完善功能/06#gin-swagger原理分析"><span class="icon icon-link"></span></a>gin-swagger原理分析</h3><p>我们着重注意下这几行：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">package main</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    import (</span></div><div class="token-line"><span class="token plain">       ...</span></div><div class="token-line"><span class="token plain">       docs &quot;github.com/go-project-name/docs&quot;</span></div><div class="token-line"><span class="token plain">       swaggerfiles &quot;github.com/swaggo/gin-swagger/swaggerFiles&quot;</span></div><div class="token-line"><span class="token plain">       ginSwagger &quot;github.com/swaggo/gin-swagger&quot;</span></div><div class="token-line"><span class="token plain">       ...</span></div><div class="token-line"><span class="token plain">    )</span></div><div class="token-line"><span class="token plain">    ...</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    func main()  {</span></div><div class="token-line"><span class="token plain">      ...</span></div><div class="token-line"><span class="token plain">       r.GET(&quot;/swagger/*any&quot;, ginSwagger.WrapHandler(swaggerfiles.Handler))</span></div><div class="token-line"><span class="token plain">       ...</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>首先，import的三个文件分别是做什么用的，必须要理解清楚。</p><p>swagger-ui是一个HTML + JSON接口的页面，那么里面分别有动态内容和静态内容，静态内容包括HTML、JS、CSS、png 等，动态内容包括swagger JSON化的结构。也就是说我们现在的<strong>目标是要创建一个包含HTML+JSON的服务</strong>，如何做呢？</p><p>一种方法当然是将这些静态文件直接放在项目中，在服务启动的时候，使用读取文件的方式并返回这些静态文件提供服务。但是这就要求在发布的时候，这些静态文件，必须同时被带着上线，它们成为了服务必须的一部分，特别是作为一个类库提供的时候，如果要求使用者必须带着库的静态文件，是非常不方便的。</p><p>而这里gin-swagger采用了另外一种更为极致的做法，是<strong>将这些静态文件代码化，嵌入到go代码中</strong>，比如让一个变量返回HTML的内容，我们在提供获取HTML页面的服务时，直接将变量返回就可以了。</p><p>这里代码第6行的github.com/swaggo/gin-swagger/swaggerFiles，这个库就做了这个事情，它将swagger-ui的所有HTML、JS、CSS、png 文件都变化成为了go文件，并且作为HTTP服务提供出来。其中的swaggerfiles.Handler 就是实现了net/http 的 <a target="_blank" rel="noopener noreferrer" href="https://pkg.go.dev/net/http#HandlerFunc">HandlerFunc 接口<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>。</p><p>而另外一部分，动态JSON接口，返回的是具体的swagger JSON化的内容。这个怎么获取呢？</p><p>是通过前面我们说的swaggo 生成的几个文件中的doc.go 文件来获取的，在例子中就是第5行引入的 github.com/go-project-name/docs 库，它的原理就是生成doc 全局变量，并且通过 ReadDoc() 方法来提供JSON的内容读取。</p><p>好，现在有了动态JSON接口和静态文件服务接口，如何集成到Gin的Engine里呢？</p><p>要一个中间件就行了，就是第7行 import中引入的 github.com/swaggo/gin-swagger 库。它通过创建一个Gin的中间件，将动态和静态的请求都承接起来，静态请求就请求到swaggo/files库，动态请求就请求到docs库中。</p><p>所以在路由中，我们*<em>创建一个路由/swagger/<em>any，就可以获取swagger-ui 并且读取swaggo 创建的doc.go 文件内容了</em></em>。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">r.GET(&quot;/swagger/*any&quot;, ginSwagger.WrapHandler(swaggerfiles.Handler))</span></div></pre></div><h3 id="如何集成"><a aria-hidden="true" tabindex="-1" href="/blog/手把手带你写一个web框架/04.实战第3关完善功能/06#如何集成"><span class="icon icon-link"></span></a>如何集成</h3><p>好，gin-swagger的原理理解清楚了，如何集成进入我们框架呢？</p><p>gin-swagger本质就是一个Gin中间件。集成Gin的中间件，我们只需要拷贝这个中间件源码，并且将中间件的 github.com/gin-gonic/gin 替换为hade框架的gin地址：github.com/gohade/hade/framework/gin就可以了。</p><p>所以把这个中间件放在framework/middleware/gin-swagger 下。存放完之后的目录截图，你可以对比检查一下：<br/><img src="https://static001.geekbang.org/resource/image/e3/de/e367057db0277465e92141d14cf112de.png?wh=1042x1292" alt=""/></p><p>把gin-swagger中间件处理完，就剩下将路由存放到我们的app业务路由中去了。</p><p>这里再设计一个小细节。<strong>毕竟我们其实并不希望线上服务也提供这么一个swagger路由，也就是说只希望swagger-ui在测试和开发环境使用</strong>，所以可以在配置文件app.yaml 中有这么一个配置项：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">swagger: true</span></div></pre></div><p>来表示是否开启这个swagger路由。<br/>那在应用路由中如何获取到这个配置呢？之前应用路由中的参数只有一个gin.Engine。我们需要为gin.Enigne增加一个获取服务容器的接口，GetContainer()。来修改framework/gin/hade_engine.go：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// GetContainer 从Engine中获取container</span></div><div class="token-line"><span class="token plain">    func (engine *Engine) GetContainer() framework.Container {</span></div><div class="token-line"><span class="token plain">       return engine.container</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>现在就是真正的万事俱备了，我们来改造应用路由app/http/route.go。</p><ul><li>首先要引入gin-swagger提示的三个import。</li></ul><p>这里我将最后一个docs对应的import，放在了同级目录的app/http/swagger.go文件中。</p><p>我是这么考虑的，<strong>docs.go是我们用命令行生成的，而生成的时候swagger的全局说明配置是放在swagger.go中的</strong>，所以这两个文件关系更为紧密，比较适合放在一起。</p><p>app/http/swagger.go文件信息：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// Package http API.</span></div><div class="token-line"><span class="token plain">    // @title hade</span></div><div class="token-line"><span class="token plain">    // @version 1.1</span></div><div class="token-line"><span class="token plain">    // @description hade测试</span></div><div class="token-line"><span class="token plain">    // @termsOfService https://github.com/swaggo/swag</span></div><div class="token-line"><span class="token plain">    ...</span></div><div class="token-line"><span class="token plain">    package http</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    import (</span></div><div class="token-line"><span class="token plain">        _ &quot;github.com/gohade/hade/app/http/swagger&quot;</span></div><div class="token-line"><span class="token plain">    )</span></div></pre></div><p>回到app/http/route.go中。我们引入了另外两个库，并且先判断app.swagger配置项是否为true，如果为true，则开启swagger路由。</p><p>app/http/route.go代码实现，你应该能很容易写出来。要点刚才都详细讲过了：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">package http</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    import (</span></div><div class="token-line"><span class="token plain">       ...</span></div><div class="token-line"><span class="token plain">       ginSwagger &quot;github.com/gohade/hade/framework/middleware/gin-swagger&quot;</span></div><div class="token-line"><span class="token plain">       &quot;github.com/gohade/hade/framework/middleware/gin-swagger/swaggerFiles&quot;</span></div><div class="token-line"><span class="token plain">       ...</span></div><div class="token-line"><span class="token plain">    )</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    // Routes 绑定业务层路由</span></div><div class="token-line"><span class="token plain">    func Routes(r *gin.Engine) {</span></div><div class="token-line"><span class="token plain">       container := r.GetContainer()</span></div><div class="token-line"><span class="token plain">       configService := container.MustMake(contract.ConfigKey).(contract.Config)</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">       ...</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">       // 如果配置了swagger，则显示swagger的中间件</span></div><div class="token-line"><span class="token plain">       if configService.GetBool(&quot;app.swagger&quot;) == true {</span></div><div class="token-line"><span class="token plain">          r.GET(&quot;/swagger/*any&quot;, ginSwagger.WrapHandler(swaggerFiles.Handler))</span></div><div class="token-line"><span class="token plain">       }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">       ...</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>到这里我们就完美将swagger-ui集成进入我们服务了。</p><h3 id="验证"><a aria-hidden="true" tabindex="-1" href="/blog/手把手带你写一个web框架/04.实战第3关完善功能/06#验证"><span class="icon icon-link"></span></a>验证</h3><p>最后做一下验证。先用 <code>./hade swagger gen</code> 命令生成我们要的docs.go文件：<br/><img src="https://static001.geekbang.org/resource/image/6d/dc/6d19784c05ec703a26fd7df34d7dabdc.png?wh=1646x358" alt=""/></p><p>再使用 <code>./hade build self</code> ，将生成的docs.go 打包编译进./hade命令，启动服务 <code>./hade app start</code> ：<br/><img src="https://static001.geekbang.org/resource/image/12/a8/1263d0d128550ca1bf6abfd8631045a8.png?wh=1014x154" alt=""/></p><p>浏览器打开地址 <a target="_blank" rel="noopener noreferrer" href="http://localhost:8888/swagger/index.html">http://localhost:8888/swagger/index.html<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> ，可以看到整个swagger-ui界面：<br/><img src="https://static001.geekbang.org/resource/image/d4/9e/d483de87fa8da4b313cc8eeefb80d19e.png?wh=3584x2904" alt=""/></p><p>并且点击某个接口的 execute 按钮，可以真实地调用这个接口，返回返回数据，进行调试。非常方便：<br/><img src="https://static001.geekbang.org/resource/image/9c/29/9c54d8909aeff6f2752ce8abf4664329.png?wh=2288x1566" alt=""/></p><p>验证完成！</p><p>今天所有代码都保存在GitHub上的<a target="_blank" rel="noopener noreferrer" href="https://github.com/gohade/coredemo/tree/geekbang/23">geekbang/23<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>分支了。附上目录结构供你对比查看。<br/><img src="https://static001.geekbang.org/resource/image/bb/bb/bb80e3120d81cc92668874d5270f2cbb.png?wh=776x890" alt=""/><br/><img src="https://static001.geekbang.org/resource/image/d7/8b/d793238b11b89ccdfa78fbcf2a73988b.png?wh=1122x1570" alt=""/></p><h3 id="小结"><a aria-hidden="true" tabindex="-1" href="/blog/手把手带你写一个web框架/04.实战第3关完善功能/06#小结"><span class="icon icon-link"></span></a>小结</h3><p>这一节课，我们其实就做了一件事情：将swagger融合进入hade框架。</p><p>我们依赖swag项目和gin-swagger中间件，成功地将swagger放到hade框架中，之后使用一个配置，能同时启动hade后端服务和swagger前端调试工具，自动生成一个可以查看接口、可以调用执行的页面。相信在实际工作中开发过后端接口的同学就知道这个工具是有多实用。</p><p>当然熟练使用swagger，以及熟练编写swagger的代码注释，需要对swagger的规则和swag的注释定义有一定了解，这个需要你花时间去掌握。但是相信我，虽然写swagger注释有一些繁琐，但是它能节省大量你和前端同学联调的时间。</p><h3 id="思考题"><a aria-hidden="true" tabindex="-1" href="/blog/手把手带你写一个web框架/04.实战第3关完善功能/06#思考题"><span class="icon icon-link"></span></a>思考题</h3><p>我之前在一个项目中使用swagger的JSON文件自动生成了项目的接口word说明文档。不知道你在实际工作中，是如何使用swagger的呢？能分享一下你/你们公司使用swagger的一些经历么？</p><p>欢迎在留言区分享你的思考。感谢你的收听，如果觉得今天的内容对你有所帮助，也欢迎分享给你身边的朋友，邀请他一起学习。我们下节课见～</p></div><div class="__dumi-default-layout-footer-meta"><a target="_blank" rel="noopener noreferrer" href="https://github.com/GGwujun/blog/edit/master/docs/手把手带你写一个Web框架/04.实战第3关完善功能/06.md">在 GitHub 上编辑此页<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a><span data-updated-text="最后更新时间：">5/2/2022 10:56:58</span></div></div></div></div>
	<script>
  window.g_useSSR = true;
  window.g_initialProps = {};
	</script>

    <script>
      (function () {
        if (!location.port) {
          (function (i, s, o, g, r, a, m) {
            i["GoogleAnalyticsObject"] = r;
            (i[r] =
              i[r] ||
              function () {
                (i[r].q = i[r].q || []).push(arguments);
              }),
              (i[r].l = 1 * new Date());
            (a = s.createElement(o)), (m = s.getElementsByTagName(o)[0]);
            a.async = 1;
            a.src = g;
            m.parentNode.insertBefore(a, m);
          })(
            window,
            document,
            "script",
            "//www.google-analytics.com/analytics.js",
            "ga"
          );
          ga("create", "UA-149864185-1", "auto");
          ga("send", "pageview");
        }
      })();
    </script>
    <script src="/blog/umi.js"></script>
  </body>
</html>
