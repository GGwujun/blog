<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no"
    />
    <link rel="shortcut icon" type="image/x-icon" href="/logo.png" />
    <link rel="stylesheet" href="/blog/umi.css" />
    <script>
      window.routerBase = "/blog";
    </script>
    <script>
      //! umi version: 3.5.17
    </script>
    <script>
      !(function () {
        var e = localStorage.getItem("dumi:prefers-color"),
          t = window.matchMedia("(prefers-color-scheme: dark)").matches,
          r = ["light", "dark", "auto"];
        document.documentElement.setAttribute(
          "data-prefers-color",
          e === r[2] ? (t ? r[1] : r[0]) : r.indexOf(e) > -1 ? e : r[0]
        );
      })();
    </script>
    <title>28｜SSH：如何生成发布系统让框架发布自动化？</title>
  </head>
  <body>
    <div id="root"><div class="__dumi-default-layout" data-route="/手把手带你写一个web框架/04.实战第3关完善功能/11" data-show-sidemenu="true" data-show-slugs="true" data-site-mode="true" data-gapless="false"><div class="__dumi-default-navbar" data-mode="site"><button class="__dumi-default-navbar-toggle"></button><a class="__dumi-default-navbar-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog/">大师兄</a><nav><div class="__dumi-default-search"><input type="search" class="__dumi-default-search-input" value=""/><ul></ul></div><span>计算机基础<ul><li><a href="/blog/编译原理之美">编译原理之美</a></li><li><a href="/blog/编译原理实战">编译原理实战</a></li><li><a href="/blog/深入浅出计算机组成原理">深入浅出计算机组成原理</a></li><li><a href="/blog/详解http">详解http</a></li><li><a href="/blog/计算机网络通关29讲">计算机网络通关29讲</a></li><li><a href="/blog/网络排查案例课">网络排查案例课</a></li><li><a href="/blog/linux操作系统">linux操作系统</a></li><li><a href="/blog/linux性能优化实战">linux性能优化实战</a></li><li><a href="/blog/程序员数学基础">程序员数学基础</a></li><li><a href="/blog/趣谈网络协议">趣谈网络协议</a></li><li><a href="/blog/操作系统实战">操作系统实战</a></li><li><a href="/blog/软件工程之美">软件工程之美</a></li><li><a href="/blog/sql必知必会">sql必知必会</a></li><li><a href="/blog/操作系统实战45讲">操作系统实战45讲</a></li><li><a href="/blog/网络编程实战">网络编程实战</a></li></ul></span><span>算法<ul><li><a href="/blog/常用算法25讲">常用算法25讲</a></li><li><a href="/blog/数据结构与算法之美">数据结构与算法之美</a></li><li><a href="/blog/业务开发算法50讲">业务开发算法50讲</a></li><li><a href="/blog/动态规划面试宝典">动态规划面试宝典</a></li></ul></span><span>前端开发<ul><li><a href="/blog/浏览器工作原理与实践">浏览器工作原理与实践</a></li><li><a href="/blog/新时代产品经理进阶之路">新时代产品经理进阶之路</a></li><li><a href="/blog/全栈工程师修炼指南">全栈工程师修炼指南</a></li><li><a href="/blog/flutter核心技术与实战">flutter核心技术与实战</a></li><li><a href="/blog/java-script核心原理解析">java-script核心原理解析</a></li><li><a href="/blog/说透低代码">说透低代码</a></li><li><a href="/blog/nodejs应用开发实战">nodejs应用开发实战</a></li><li><a href="/blog/反爬虫兵法演绎20讲">反爬虫兵法演绎20讲</a></li><li><a href="/blog/reactnative新架构实战课">reactnative新架构实战课</a></li><li><a href="/blog/正则表达式入门">正则表达式入门</a></li><li><a href="/blog/重学前端">重学前端</a></li><li><a href="/blog/serverless入门课">serverless入门课</a></li><li><a href="/blog/type-script入门实战笔记">type-script入门实战笔记</a></li><li><a href="/blog/图解googlev8">图解googlev8</a></li><li><a href="/blog/vue3源码分析">vue3源码分析</a></li><li><a href="/blog/玩转Vue3全家桶">玩转Vue3全家桶</a></li><li><a href="/blog/webassembly入门">webassembly入门</a></li><li><a aria-current="page" class="active" href="/blog/手把手带你写一个Web框架">手把手带你写一个Web框架</a></li><li><a href="/blog/web漏洞挖掘实战">web漏洞挖掘实战</a></li><li><a href="/blog/跟月影学可视化">跟月影学可视化</a></li><li><a href="/blog/搞定音频技术">搞定音频技术</a></li><li><a href="/blog/攻克视频技术">攻克视频技术</a></li></ul></span><span>前端工程化<ul><li><a href="/blog/logger">logger</a></li><li><a href="/blog/webpack">webpack</a></li><li><a href="/blog/webpackChain">webpackChain</a></li></ul></span><span>前端性能优化<ul><li><a href="/blog/react性能调优">react性能调优</a></li></ul></span><span>软件测试<ul><li><a href="/blog/全链路压测实战30讲">全链路压测实战30讲</a></li><li><a href="/blog/性能测试实战30讲">性能测试实战30讲</a></li><li><a href="/blog/自动化测试高手课">自动化测试高手课</a></li><li><a href="/blog/软件测试52讲">软件测试52讲</a></li></ul></span><span>面试<ul><li><a href="/blog/面试现场">面试现场</a></li></ul></span><span>杂谈<ul><li><a href="/blog/超级访谈对话张雪峰">超级访谈对话张雪峰</a></li><li><a href="/blog/Git实战手册">Git实战手册</a></li><li><a href="/blog/NodeJS">NodeJS</a></li><li><a href="/blog/ReactJS">ReactJS</a></li><li><a href="/blog/UI设计">UI设计</a></li><li><a href="/blog/webpack4系列教程">webpack4系列教程</a></li><li><a href="/blog/前端知识体系">前端知识体系</a></li><li><a href="/blog/剑指offer刷题笔记">剑指offer刷题笔记</a></li><li><a href="/blog/思考与成长">思考与成长</a></li><li><a href="/blog/设计模式手册">设计模式手册</a></li></ul></span><div class="__dumi-default-navbar-tool"><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "></div></div></div></nav></div><div class="__dumi-default-menu" data-mode="site"><div class="__dumi-default-menu-inner"><div class="__dumi-default-menu-header"><a class="__dumi-default-menu-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog/"></a><h1>大师兄</h1><p></p></div><div class="__dumi-default-menu-mobile-area"><ul class="__dumi-default-menu-nav-list"><li>计算机基础<ul><li><a href="/blog/编译原理之美">编译原理之美</a></li><li><a href="/blog/编译原理实战">编译原理实战</a></li><li><a href="/blog/深入浅出计算机组成原理">深入浅出计算机组成原理</a></li><li><a href="/blog/详解http">详解http</a></li><li><a href="/blog/计算机网络通关29讲">计算机网络通关29讲</a></li><li><a href="/blog/网络排查案例课">网络排查案例课</a></li><li><a href="/blog/linux操作系统">linux操作系统</a></li><li><a href="/blog/linux性能优化实战">linux性能优化实战</a></li><li><a href="/blog/程序员数学基础">程序员数学基础</a></li><li><a href="/blog/趣谈网络协议">趣谈网络协议</a></li><li><a href="/blog/操作系统实战">操作系统实战</a></li><li><a href="/blog/软件工程之美">软件工程之美</a></li><li><a href="/blog/sql必知必会">sql必知必会</a></li><li><a href="/blog/操作系统实战45讲">操作系统实战45讲</a></li><li><a href="/blog/网络编程实战">网络编程实战</a></li></ul></li><li>算法<ul><li><a href="/blog/常用算法25讲">常用算法25讲</a></li><li><a href="/blog/数据结构与算法之美">数据结构与算法之美</a></li><li><a href="/blog/业务开发算法50讲">业务开发算法50讲</a></li><li><a href="/blog/动态规划面试宝典">动态规划面试宝典</a></li></ul></li><li>前端开发<ul><li><a href="/blog/浏览器工作原理与实践">浏览器工作原理与实践</a></li><li><a href="/blog/新时代产品经理进阶之路">新时代产品经理进阶之路</a></li><li><a href="/blog/全栈工程师修炼指南">全栈工程师修炼指南</a></li><li><a href="/blog/flutter核心技术与实战">flutter核心技术与实战</a></li><li><a href="/blog/java-script核心原理解析">java-script核心原理解析</a></li><li><a href="/blog/说透低代码">说透低代码</a></li><li><a href="/blog/nodejs应用开发实战">nodejs应用开发实战</a></li><li><a href="/blog/反爬虫兵法演绎20讲">反爬虫兵法演绎20讲</a></li><li><a href="/blog/reactnative新架构实战课">reactnative新架构实战课</a></li><li><a href="/blog/正则表达式入门">正则表达式入门</a></li><li><a href="/blog/重学前端">重学前端</a></li><li><a href="/blog/serverless入门课">serverless入门课</a></li><li><a href="/blog/type-script入门实战笔记">type-script入门实战笔记</a></li><li><a href="/blog/图解googlev8">图解googlev8</a></li><li><a href="/blog/vue3源码分析">vue3源码分析</a></li><li><a href="/blog/玩转Vue3全家桶">玩转Vue3全家桶</a></li><li><a href="/blog/webassembly入门">webassembly入门</a></li><li><a aria-current="page" class="active" href="/blog/手把手带你写一个Web框架">手把手带你写一个Web框架</a></li><li><a href="/blog/web漏洞挖掘实战">web漏洞挖掘实战</a></li><li><a href="/blog/跟月影学可视化">跟月影学可视化</a></li><li><a href="/blog/搞定音频技术">搞定音频技术</a></li><li><a href="/blog/攻克视频技术">攻克视频技术</a></li></ul></li><li>前端工程化<ul><li><a href="/blog/logger">logger</a></li><li><a href="/blog/webpack">webpack</a></li><li><a href="/blog/webpackChain">webpackChain</a></li></ul></li><li>前端性能优化<ul><li><a href="/blog/react性能调优">react性能调优</a></li></ul></li><li>软件测试<ul><li><a href="/blog/全链路压测实战30讲">全链路压测实战30讲</a></li><li><a href="/blog/性能测试实战30讲">性能测试实战30讲</a></li><li><a href="/blog/自动化测试高手课">自动化测试高手课</a></li><li><a href="/blog/软件测试52讲">软件测试52讲</a></li></ul></li><li>面试<ul><li><a href="/blog/面试现场">面试现场</a></li></ul></li><li>杂谈<ul><li><a href="/blog/超级访谈对话张雪峰">超级访谈对话张雪峰</a></li><li><a href="/blog/Git实战手册">Git实战手册</a></li><li><a href="/blog/NodeJS">NodeJS</a></li><li><a href="/blog/ReactJS">ReactJS</a></li><li><a href="/blog/UI设计">UI设计</a></li><li><a href="/blog/webpack4系列教程">webpack4系列教程</a></li><li><a href="/blog/前端知识体系">前端知识体系</a></li><li><a href="/blog/剑指offer刷题笔记">剑指offer刷题笔记</a></li><li><a href="/blog/思考与成长">思考与成长</a></li><li><a href="/blog/设计模式手册">设计模式手册</a></li></ul></li></ul><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "><button title="Dark theme" class="__dumi-default-dark-moon "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="3854" width="22" height="22"><path d="M991.816611 674.909091a69.166545 69.166545 0 0 0-51.665455-23.272727 70.795636 70.795636 0 0 0-27.438545 5.585454A415.674182 415.674182 0 0 1 754.993338 698.181818c-209.594182 0-393.472-184.785455-393.472-395.636363 0-52.363636 38.539636-119.621818 69.515637-173.614546 4.887273-8.610909 9.634909-16.756364 14.103272-24.901818A69.818182 69.818182 0 0 0 384.631156 0a70.842182 70.842182 0 0 0-27.438545 5.585455C161.678429 90.298182 14.362065 307.898182 14.362065 512c0 282.298182 238.824727 512 532.38691 512a522.286545 522.286545 0 0 0 453.957818-268.334545A69.818182 69.818182 0 0 0 991.816611 674.909091zM546.679156 954.181818c-248.785455 0-462.941091-192-462.941091-442.181818 0-186.647273 140.637091-372.829091 300.939637-442.181818-36.817455 65.629091-92.578909 151.970909-92.578909 232.727273 0 250.181818 214.109091 465.454545 462.917818 465.454545a488.331636 488.331636 0 0 0 185.181091-46.545455 453.003636 453.003636 0 0 1-393.565091 232.727273z m103.656728-669.323636l-14.266182 83.781818a34.909091 34.909091 0 0 0 50.362182 36.770909l74.775272-39.563636 74.752 39.563636a36.142545 36.142545 0 0 0 16.174546 3.956364 34.909091 34.909091 0 0 0 34.210909-40.727273l-14.289455-83.781818 60.509091-59.345455a35.025455 35.025455 0 0 0-19.223272-59.578182l-83.61891-12.101818-37.376-76.101818a34.56 34.56 0 0 0-62.254545 0l-37.376 76.101818-83.618909 12.101818a34.909091 34.909091 0 0 0-19.246546 59.578182z m70.423272-64.698182a34.280727 34.280727 0 0 0 26.135273-19.083636l14.312727-29.090909 14.336 29.090909a34.257455 34.257455 0 0 0 26.135273 19.083636l32.046546 4.887273-23.272728 22.574545a35.234909 35.234909 0 0 0-10.007272 30.952727l5.46909 32.116364-28.625454-15.127273a34.490182 34.490182 0 0 0-32.302546 0l-28.695272 15.127273 5.469091-32.116364a35.141818 35.141818 0 0 0-9.984-30.952727l-23.272728-22.574545z" p-id="3855"></path></svg></button><button title="Light theme" class="__dumi-default-dark-sun "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="4026" width="22" height="22"><path d="M915.2 476.16h-43.968c-24.704 0-44.736 16-44.736 35.84s20.032 35.904 44.736 35.904H915.2c24.768 0 44.8-16.064 44.8-35.904s-20.032-35.84-44.8-35.84zM512 265.6c-136.704 0-246.464 109.824-246.464 246.4 0 136.704 109.76 246.464 246.464 246.464S758.4 648.704 758.4 512c0-136.576-109.696-246.4-246.4-246.4z m0 425.6c-99.008 0-179.2-80.128-179.2-179.2 0-98.944 80.192-179.2 179.2-179.2S691.2 413.056 691.2 512c0 99.072-80.192 179.2-179.2 179.2zM197.44 512c0-19.84-19.136-35.84-43.904-35.84H108.8c-24.768 0-44.8 16-44.8 35.84s20.032 35.904 44.8 35.904h44.736c24.768 0 43.904-16.064 43.904-35.904zM512 198.464c19.776 0 35.84-20.032 35.84-44.8v-44.8C547.84 84.032 531.84 64 512 64s-35.904 20.032-35.904 44.8v44.8c0 24.768 16.128 44.864 35.904 44.864z m0 627.136c-19.776 0-35.904 20.032-35.904 44.8v44.736C476.096 940.032 492.16 960 512 960s35.84-20.032 35.84-44.8v-44.736c0-24.768-16.064-44.864-35.84-44.864z m329.92-592.832c17.472-17.536 20.288-43.072 6.4-57.024-14.016-14.016-39.488-11.2-57.024 6.336-4.736 4.864-26.496 26.496-31.36 31.36-17.472 17.472-20.288 43.008-6.336 57.024 13.952 14.016 39.488 11.2 57.024-6.336 4.8-4.864 26.496-26.56 31.296-31.36zM213.376 759.936c-4.864 4.8-26.56 26.624-31.36 31.36-17.472 17.472-20.288 42.944-6.4 56.96 14.016 13.952 39.552 11.2 57.024-6.336 4.8-4.736 26.56-26.496 31.36-31.36 17.472-17.472 20.288-43.008 6.336-56.96-14.016-13.952-39.552-11.072-56.96 6.336z m19.328-577.92c-17.536-17.536-43.008-20.352-57.024-6.336-14.08 14.016-11.136 39.488 6.336 57.024 4.864 4.864 26.496 26.56 31.36 31.424 17.536 17.408 43.008 20.288 56.96 6.336 14.016-14.016 11.264-39.488-6.336-57.024-4.736-4.864-26.496-26.56-31.296-31.424z m527.168 628.608c4.864 4.864 26.624 26.624 31.36 31.424 17.536 17.408 43.072 20.224 57.088 6.336 13.952-14.016 11.072-39.552-6.4-57.024-4.864-4.8-26.56-26.496-31.36-31.36-17.472-17.408-43.072-20.288-57.024-6.336-13.952 14.016-11.008 39.488 6.336 56.96z" p-id="4027"></path></svg></button><button title="Default to system" class="__dumi-default-dark-auto "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="11002" width="22" height="22"><path d="M127.658667 492.885333c0-51.882667 10.24-101.717333 30.378666-149.162666s47.786667-88.064 81.92-122.538667 75.093333-61.781333 122.538667-81.92 96.938667-30.378667 149.162667-30.378667 101.717333 10.24 149.162666 30.378667 88.405333 47.786667 122.88 81.92 61.781333 75.093333 81.92 122.538667 30.378667 96.938667 30.378667 149.162666-10.24 101.717333-30.378667 149.162667-47.786667 88.405333-81.92 122.88-75.093333 61.781333-122.88 81.92-97.28 30.378667-149.162666 30.378667-101.717333-10.24-149.162667-30.378667-88.064-47.786667-122.538667-81.92-61.781333-75.093333-81.92-122.88-30.378667-96.938667-30.378666-149.162667z m329.045333 0c0 130.048 13.994667 244.394667 41.984 343.381334h12.970667c46.762667 0 91.136-9.216 133.461333-27.306667s78.848-42.666667 109.568-73.386667 54.954667-67.242667 73.386667-109.568 27.306667-86.698667 27.306666-133.461333c0-46.421333-9.216-90.794667-27.306666-133.12s-42.666667-78.848-73.386667-109.568-67.242667-54.954667-109.568-73.386667-86.698667-27.306667-133.461333-27.306666h-11.605334c-28.672 123.562667-43.349333 237.909333-43.349333 343.722666z" p-id="11003"></path></svg></button></div></div></div><ul class="__dumi-default-menu-list"><li><a href="/blog/">大师兄 - 前端架构师</a></li></ul></div></div><ul role="slug-list" class="__dumi-default-layout-toc"><li title="SSH服务" data-depth="2"><a href="/blog/手把手带你写一个web框架/04.实战第3关完善功能/11#ssh服务"><span>SSH服务</span></a></li><li title="自动化部署" data-depth="2"><a href="/blog/手把手带你写一个web框架/04.实战第3关完善功能/11#自动化部署"><span>自动化部署</span></a></li><li title="部署前端" data-depth="3"><a href="/blog/手把手带你写一个web框架/04.实战第3关完善功能/11#部署前端"><span>部署前端</span></a></li><li title="部署后端" data-depth="3"><a href="/blog/手把手带你写一个web框架/04.实战第3关完善功能/11#部署后端"><span>部署后端</span></a></li><li title="部署全部" data-depth="3"><a href="/blog/手把手带你写一个web框架/04.实战第3关完善功能/11#部署全部"><span>部署全部</span></a></li><li title="部署回滚" data-depth="3"><a href="/blog/手把手带你写一个web框架/04.实战第3关完善功能/11#部署回滚"><span>部署回滚</span></a></li><li title="验证" data-depth="2"><a href="/blog/手把手带你写一个web框架/04.实战第3关完善功能/11#验证"><span>验证</span></a></li><li title="小结" data-depth="2"><a href="/blog/手把手带你写一个web框架/04.实战第3关完善功能/11#小结"><span>小结</span></a></li><li title="思考题" data-depth="3"><a href="/blog/手把手带你写一个web框架/04.实战第3关完善功能/11#思考题"><span>思考题</span></a></li></ul><div class="__dumi-default-layout-content"><div class="markdown"><h1 id="28ssh如何生成发布系统让框架发布自动化"><a aria-hidden="true" tabindex="-1" href="/blog/手把手带你写一个web框架/04.实战第3关完善功能/11#28ssh如何生成发布系统让框架发布自动化"><span class="icon icon-link"></span></a>28｜SSH：如何生成发布系统让框架发布自动化？</h1><p>你好，我是轩脉刃。</p><p>在前面的课程中，我们基本上已经完成了一个能同时生成前端和后端的框架hade，也能很方便对框架进行管理控制。下面两节课，我们来考虑框架的一些周边功能，比如部署自动化。</p><p>部署自动化其实不是一个框架的刚需，有很多方式可以将一个服务进行自动化部署，比如现在比较流行的Docker化或者CI/CD流程。</p><p>但是一些比较个人比较小的项目，比如一个博客、一个官网网站，<strong>这些部署流程往往都太庞大了，更需要一个服务，能快速将在开发机器上写好、调试好的程序上传到目标服务器，并且更新应用程序</strong>。这就是我们今天要实现的框架发布自动化。</p><p>所有的部署自动化工具，基本都依赖本地与远端服务器的连接，这个连接可以是FTP，可以是HTTP，但是更经常的连接是SSH连接。因为一旦我们购买了一个Web服务器，服务器提供商就会提供一个有SSH登录账号的服务器，我们可以通过这个账号登录到服务器上，来进行各种软件的安装，比如FTP、HTTP服务等。</p><p>基本上，SSH账号是我们拿到Web服务器的首要凭证，所以要设计的自动化发布系统也是依赖SSH的。</p><h2 id="ssh服务"><a aria-hidden="true" tabindex="-1" href="/blog/手把手带你写一个web框架/04.实战第3关完善功能/11#ssh服务"><span class="icon icon-link"></span></a>SSH服务</h2><p>那么在Golang中如何SSH连接远端的服务器呢？有一个<a target="_blank" rel="noopener noreferrer" href="https://golang.org/x/crypto/ssh">ssh<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>库能完成SSH的远端连接。</p><p>这里介绍一个小知识，你可以看下这个ssh库的git：golang.org/x/crypto/ssh。它是在官网golang.org 下的，但是又不是官方的标准库，因为子目录是x。</p><p>这种库其实也是经过官方认证的，属于实验性的库，我们可以这么理解：<strong>以golang.org/x/ 开头的库，都是官方认为这些库后续有可能成为标准库的一部份</strong>，但是由于种种原因，现在还没有计划放进标准库中，需要更多时间打磨。但是这种库的维护者和开发者一般已经是Golang官方组的人员了。比如现在今年讨论热度很大的Golang泛型，据说也会先以实验库的形式出现。</p><p>不管怎么样，这种以golang.org/x/开头的库，成熟度已经非常高了，我们是可以放心使用的。来了解一下这个ssh库：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">package main</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    import (</span></div><div class="token-line"><span class="token plain">    	&quot;bytes&quot;</span></div><div class="token-line"><span class="token plain">    	&quot;fmt&quot;</span></div><div class="token-line"><span class="token plain">    	&quot;log&quot;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    	&quot;golang.org/x/crypto/ssh&quot;</span></div><div class="token-line"><span class="token plain">    )</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    func main() {</span></div><div class="token-line"><span class="token plain">    	var hostKey ssh.PublicKey</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    	// ssh相关配置</span></div><div class="token-line"><span class="token plain">    	config := &amp;ssh.ClientConfig{</span></div><div class="token-line"><span class="token plain">    		User: &quot;username&quot;,</span></div><div class="token-line"><span class="token plain">    		Auth: []ssh.AuthMethod{</span></div><div class="token-line"><span class="token plain">    			ssh.Password(&quot;yourpassword&quot;),</span></div><div class="token-line"><span class="token plain">    		},</span></div><div class="token-line"><span class="token plain">    		HostKeyCallback: ssh.FixedHostKey(hostKey),</span></div><div class="token-line"><span class="token plain">    	}</span></div><div class="token-line"><span class="token plain">        // 创建client</span></div><div class="token-line"><span class="token plain">    	client, err := ssh.Dial(&quot;tcp&quot;, &quot;yourserver.com:22&quot;, config)</span></div><div class="token-line"><span class="token plain">    	if err != nil {</span></div><div class="token-line"><span class="token plain">    		log.Fatal(&quot;Failed to dial: &quot;, err)</span></div><div class="token-line"><span class="token plain">    	}</span></div><div class="token-line"><span class="token plain">    	defer client.Close()</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        // 使用client做各种操作</span></div><div class="token-line"><span class="token plain">    	</span></div><div class="token-line"><span class="token plain">    	session, err := client.NewSession()</span></div><div class="token-line"><span class="token plain">    	if err != nil {</span></div><div class="token-line"><span class="token plain">    		log.Fatal(&quot;Failed to create session: &quot;, err)</span></div><div class="token-line"><span class="token plain">    	}</span></div><div class="token-line"><span class="token plain">    	defer session.Close()</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    	var b bytes.Buffer</span></div><div class="token-line"><span class="token plain">    	session.Stdout = &amp;b</span></div><div class="token-line"><span class="token plain">    	if err := session.Run(&quot;/usr/bin/whoami&quot;); err != nil {</span></div><div class="token-line"><span class="token plain">    		log.Fatal(&quot;Failed to run: &quot; + err.Error())</span></div><div class="token-line"><span class="token plain">    	}</span></div><div class="token-line"><span class="token plain">    	fmt.Println(b.String())</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>在这个官方示例中，我们可以看到ssh库作为客户端连接，最重要的是创建ssh.Client这个数据结构，而这个数据结构使用ssh.Dail能进行创建，创建的时候依赖ssh.ClientConfig这么一个配置结构。</p><p>是不是非常熟悉？和前面的Gorm、Redis一样，将SSH的连接部分封装成为hade框架的SSH服务，这样我们就能很方便地初始化一个ssh.Client了。</p><p>经过前面几节课，相信你已经非常熟悉这种套路了，我们就简要说明下ssh service的封装和实现思路。这节课的重点在后面对自动化发布系统的实现上。</p><p>ssh service的封装一样有三个部分，服务协议、服务提供者、服务实现。</p><p>服务协议我们提供GetClient方法：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// SSHService 表示一个ssh服务</span></div><div class="token-line"><span class="token plain">    type SSHService interface {</span></div><div class="token-line"><span class="token plain">       // GetClient 获取ssh连接实例</span></div><div class="token-line"><span class="token plain">       GetClient(option ...SSHOption) (*ssh.Client, error)</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>而其中的SSHOption作为更新SSHConfig的函数：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// SSHOption 代表初始化的时候的选项</span></div><div class="token-line"><span class="token plain">    type SSHOption func(container framework.Container, config *SSHConfig) error</span></div></pre></div><p>我们封装配置结构为 SSHConfig：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// SSHConfig 为hade定义的SSH配置结构</span></div><div class="token-line"><span class="token plain">    type SSHConfig struct {</span></div><div class="token-line"><span class="token plain">       NetWork string</span></div><div class="token-line"><span class="token plain">       Host    string</span></div><div class="token-line"><span class="token plain">       Port    string</span></div><div class="token-line"><span class="token plain">       *ssh.ClientConfig</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>对应的配置文件如下 config/testing/ssh.yaml，你可以看看每个配置的说明：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">timeout: 1s</span></div><div class="token-line"><span class="token plain">    network: tcp</span></div><div class="token-line"><span class="token plain">    web-01:</span></div><div class="token-line"><span class="token plain">        host: 118.190.3.55 # ip地址</span></div><div class="token-line"><span class="token plain">        port: 22 # 端口</span></div><div class="token-line"><span class="token plain">        username: yejianfeng # 用户名</span></div><div class="token-line"><span class="token plain">        password: &quot;123456&quot; # 密码</span></div><div class="token-line"><span class="token plain">    web-02:</span></div><div class="token-line"><span class="token plain">        network: tcp</span></div><div class="token-line"><span class="token plain">        host: localhost # ip地址</span></div><div class="token-line"><span class="token plain">        port: 3306 # 端口</span></div><div class="token-line"><span class="token plain">        username: jianfengye # 用户名</span></div><div class="token-line"><span class="token plain">        rsa_key: &quot;/Users/user/.ssh/id_rsa&quot;</span></div><div class="token-line"><span class="token plain">        known_hosts: &quot;/Users/user/.ssh/known_hosts&quot;</span></div></pre></div><p>这里注意下，SSH的连接方式有两种，一种是直接使用用户名密码来连接远程服务器，还有一种是使用rsa key文件来连接远端服务器，所以这里的配置需要同时支持两种配置。<strong>对于使用rsa key文件的方式，需要设置rsk_key的私钥地址和负责安全验证的known_hosts</strong>。</p><p>定义好了SSH的服务协议，服务提供者和服务实现并没有什么特别，就不展示具体代码了，在GitHub上的<a target="_blank" rel="noopener noreferrer" href="https://github.com/gohade/coredemo/blob/geekbang/28/framework/provider/ssh/provider.go">provider/ssh/provider.go<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 和<a target="_blank" rel="noopener noreferrer" href="https://github.com/gohade/coredemo/blob/geekbang/28/framework/provider/ssh/service.go">provider/ssh/service.go<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>中。我们简单说一下思路。</p><p>对于服务提供者，我们实现基本的五个函数Register/Boot/IsDefer/Param/Name。另外这个ssh服务并不是框架启动时候必要加载的，所以设置IsDefer为true，而Param我们就照例把服务容器container作为参数，传递给Register设定的实例化方法。</p><p>而SSH服务的具体实现，同样类似Redis，先配置更新，再查询是否已经实例化，若已经实例化，返回实例化对象；若没有实例化，实例化client，并且存在map中。</p><p>完成了SSH的服务协议、服务提供者、服务实例，我们就重点讨论下如何使用SSH的服务协议来实现自动化部署。</p><h2 id="自动化部署"><a aria-hidden="true" tabindex="-1" href="/blog/手把手带你写一个web框架/04.实战第3关完善功能/11#自动化部署"><span class="icon icon-link"></span></a>自动化部署</h2><p>首先还是思考清楚自动化部署的命令设计。我们的hade框架是同时支持前后端的开发框架，所以自动化部署是需要同时支持前后端部署的，也就是说它的命令也需要支持前后端的部署，这里我们设计一个显示帮助信息的一级命令<code>./hade deploy</code> 和四个二级命令：</p><ul><li><code>./hade deploy frontend</code> ，部署前端</li><li><code>./hade deploy backend</code> ，部署后端</li><li><code>./hade deploy all</code> ，同时部署前后端</li><li><code>./hade deploy rollback</code> ，部署回滚</li></ul><p>同时也设计一下部署配置文件。</p><p>首先，我们是需要知道部署在哪个或者哪几个服务器上的，所以需要有一个数组配置项connections来定义部署服务器。而部署服务器的具体用户名密码配置，在前面SSH的配置里是存在的，所以这里直接把SSH的配置路径放在我们的connections中就可以了。</p><p>其次，还要知道我们要部署的远端服务器的目标文件夹是什么？所以这里需要有一个remote_folder配置项来配置远端文件夹。</p><p>然后就是前端部署的配置frontend了。我们知道，在本地编译之后，会直接编译成了dist目录下的HTML/JS/CSS文件，这些文件直接上传到远端文件夹就是可以使用的了。</p><p>但是，在上传前端编译文件之前和在远端服务器执行一些命令之后，是有可能要做一些操作的。比如上传前先清空远端文件夹、上传后更新nginx等。所以这里，<strong>我们设计两个数组结构pre_action和post_action来分别存放部署的前置命令和部署的后置命令</strong>。</p><p>最后就是后端部署的配置backend。同前端部署一样，我们也有部署的前置命令和后置命令。但是后端编译还有一个不同点。</p><p>因为后端是Golang编译的，而它的编译其实是分平台的，加上Go支持“交叉编译”。就是说，比如我的工作机器是Mac操作系统，Web服务器是Linux操作系统，那么我需要编译Linux操作系统的后端程序，但是我可以直接在Mac操作系统上使用GOOS 和 GOARCH 来编译Linux操作系统的程序：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">GOOS=linux GOARCH=amd64 go build ./</span></div></pre></div><p>这样编译出来的文件就是可以在Linux运行的后端进程了。所以在后端部署的配置项里面，我们增加GOOS 和 GOARCH分别表示后端的交叉编译参数。</p><p>完整的配置文件在config/development/deploy.yaml中：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">connections: # 要自动化部署的连接</span></div><div class="token-line"><span class="token plain">        - ssh.web-01</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    remote_folder: &quot;/home/yejianfeng/coredemo/&quot;  # 远端的部署文件夹</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    frontend: # 前端部署配置</span></div><div class="token-line"><span class="token plain">        pre_action: # 部署前置命令</span></div><div class="token-line"><span class="token plain">            - &quot;pwd&quot;</span></div><div class="token-line"><span class="token plain">        post_action: # 部署后置命令</span></div><div class="token-line"><span class="token plain">            - &quot;pwd&quot;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    backend: # 后端部署配置</span></div><div class="token-line"><span class="token plain">        goos: linux # 部署目标操作系统</span></div><div class="token-line"><span class="token plain">        goarch: amd64 # 部署目标cpu架构</span></div><div class="token-line"><span class="token plain">        pre_action: # 部署前置命令</span></div><div class="token-line"><span class="token plain">            - &quot;pwd&quot;</span></div><div class="token-line"><span class="token plain">        post_action: # 部署后置命令</span></div><div class="token-line"><span class="token plain">            - &quot;chmod 777 /home/yejianfeng/coredemo/hade&quot;</span></div><div class="token-line"><span class="token plain">            - &quot;/home/yejianfeng/coredemo/hade app restart&quot;</span></div></pre></div><p>好，配置文件设计好了，下面我们开始实现对应的命令。</p><p>其实估计你对如何实现，已经大致心中有数了。一级命令 <code>./hade deploy</code> 还是并没有什么内容，只是将帮助信息打印出来，之前也做过很多次，就不描述了。二级命令按之前的套路，一般是先编译，再部署，最后上传到目标服务器。</p><h3 id="部署前端"><a aria-hidden="true" tabindex="-1" href="/blog/手把手带你写一个web框架/04.实战第3关完善功能/11#部署前端"><span class="icon icon-link"></span></a>部署前端</h3><p>看二级命令 <code>./hade deploy frontend</code>。对于部署前端，我们分为三个步骤：</p><ul><li>创建要部署的文件夹；</li><li>编译前端文件到部署文件夹中；</li><li>上传部署文件夹，并且执行对应的前置和后置的shell。</li></ul><p>在framework/command/deploy.go中：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// deployFrontendCommand 部署前端</span></div><div class="token-line"><span class="token plain">    var deployFrontendCommand = &amp;cobra.Command{</span></div><div class="token-line"><span class="token plain">        Use:   &quot;frontend&quot;,</span></div><div class="token-line"><span class="token plain">        Short: &quot;部署前端&quot;,</span></div><div class="token-line"><span class="token plain">        RunE: func(c *cobra.Command, args []string) error {</span></div><div class="token-line"><span class="token plain">            container := c.GetContainer()</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">            // 创建部署文件夹</span></div><div class="token-line"><span class="token plain">            deployFolder, err := createDeployFolder(container)</span></div><div class="token-line"><span class="token plain">            if err != nil {</span></div><div class="token-line"><span class="token plain">                return err</span></div><div class="token-line"><span class="token plain">            }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">            // 编译前端到部署文件夹</span></div><div class="token-line"><span class="token plain">            if err := deployBuildFrontend(c, deployFolder); err != nil {</span></div><div class="token-line"><span class="token plain">                return err</span></div><div class="token-line"><span class="token plain">            }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">            // 上传部署文件夹并执行对应的shell</span></div><div class="token-line"><span class="token plain">            return deployUploadAction(deployFolder, container, &quot;frontend&quot;)</span></div><div class="token-line"><span class="token plain">        },</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>这里可能你会有个疑惑，为什么要创建一个部署文件夹？我们直接将前端编译的dist目录上传到目标服务器不就行了么？来为你解答下。</p><p>部署服务是一个很小心的过程，因为它会影响现在的线上服务，而每次部署都是有可能失败的，也就很有可能需要进行回滚操作，就是我们前面定义的部署回滚操作命令 <code>./hade deploy rollback</code> 。<strong>而回滚的时候，需要能找到某个特定版本的编译内容，这里就需要部署文件夹</strong>。</p><p>这个部署文件夹我们定义为目录 deploy/xxxxxx，其中的xxxx直接设置为细化到秒的时间。对应的创建部署文件夹的函数如下：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// 创建部署的folder</span></div><div class="token-line"><span class="token plain">    func createDeployFolder(c framework.Container) (string, error) {</span></div><div class="token-line"><span class="token plain">       appService := c.MustMake(contract.AppKey).(contract.App)</span></div><div class="token-line"><span class="token plain">       deployFolder := appService.DeployFolder()</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">       // 部署文件夹的名称</span></div><div class="token-line"><span class="token plain">       deployVersion := time.Now().Format(&quot;20060102150405&quot;)</span></div><div class="token-line"><span class="token plain">       versionFolder := filepath.Join(deployFolder, deployVersion)</span></div><div class="token-line"><span class="token plain">       if !util.Exists(versionFolder) {</span></div><div class="token-line"><span class="token plain">          return versionFolder, os.Mkdir(versionFolder, os.ModePerm)</span></div><div class="token-line"><span class="token plain">       }</span></div><div class="token-line"><span class="token plain">       return versionFolder, nil</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>这里的appService.DeployFolder() 是我们在appService下创建的一个新的目录deploy，在framework/contract/app.go中：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// App 定义接口</span></div><div class="token-line"><span class="token plain">    type App interface {</span></div><div class="token-line"><span class="token plain">       ...</span></div><div class="token-line"><span class="token plain">       // DeployFolder 存放部署的时候创建的文件夹</span></div><div class="token-line"><span class="token plain">       DeployFolder() string</span></div><div class="token-line"><span class="token plain">       ...</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>有了这个部署文件夹，每次的发布都有“档案”存储了，这就为回滚命令提供了可能性。我们每次编译的文件，也都会先经过这个部署文件夹，再中转上传到目标服务器。</p><p>第一步创建部署文件夹实现了，我们再回头看下部署前端的第二个步骤，编译前端文件到部署文件夹。可以直接使用 buildFrontendCommand的RunE方法，它会将前端编译到dist目录下，然后我们再将dist目录文件拷贝到部署文件夹中：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">func deployBuildFrontend(c *cobra.Command, deployFolder string) error {</span></div><div class="token-line"><span class="token plain">       container := c.GetContainer()</span></div><div class="token-line"><span class="token plain">       appService := container.MustMake(contract.AppKey).(contract.App)</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">       // 编译前端</span></div><div class="token-line"><span class="token plain">       if err := buildFrontendCommand.RunE(c, []string{}); err != nil {</span></div><div class="token-line"><span class="token plain">          return err</span></div><div class="token-line"><span class="token plain">       }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">       // 复制前端文件到deploy文件夹</span></div><div class="token-line"><span class="token plain">       frontendFolder := filepath.Join(deployFolder, &quot;dist&quot;)</span></div><div class="token-line"><span class="token plain">       if err := os.Mkdir(frontendFolder, os.ModePerm); err != nil {</span></div><div class="token-line"><span class="token plain">          return err</span></div><div class="token-line"><span class="token plain">       }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">       buildFolder := filepath.Join(appService.BaseFolder(), &quot;dist&quot;)</span></div><div class="token-line"><span class="token plain">       if err := util.CopyFolder(buildFolder, frontendFolder); err != nil {</span></div><div class="token-line"><span class="token plain">          return err</span></div><div class="token-line"><span class="token plain">       }</span></div><div class="token-line"><span class="token plain">       return nil</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>第三步，上传部署文件夹，并且执行对应的前置和后置的shell。</p><p>这个步骤的实现是今天这节课的重点了。首先遍历配置文件中的deploy.connections，明确我们要在哪几个远端节点中进行部署；然后对每个远端服务创建一个ssh.Client，由于前面已经写好了SSH服务，所以直接使用GetClient方法就能为每个节点创建一个sshClient了：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">for _, node := range deployNodes {</span></div><div class="token-line"><span class="token plain">       sshClient, err := sshService.GetClient(ssh.WithConfigPath(node))</span></div><div class="token-line"><span class="token plain">       if err != nil {</span></div><div class="token-line"><span class="token plain">          return err</span></div><div class="token-line"><span class="token plain">       }</span></div><div class="token-line"><span class="token plain">       ...</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>接下来就要执行命令了，那怎么执行前置或者后置命令呢？</p><p>我们需要为每个命令创建一个session，然后使用session.CombinedOut来输出这个命令的结果，把每个命令的结果都输出在控制台中。相关代码如下：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">for _, action := range preActions {</span></div><div class="token-line"><span class="token plain">       // 创建session</span></div><div class="token-line"><span class="token plain">       session, err := sshClient.NewSession()</span></div><div class="token-line"><span class="token plain">       if err != nil {</span></div><div class="token-line"><span class="token plain">          return err</span></div><div class="token-line"><span class="token plain">       }</span></div><div class="token-line"><span class="token plain">       // 执行命令，并且等待返回</span></div><div class="token-line"><span class="token plain">       bts, err := session.CombinedOutput(action)</span></div><div class="token-line"><span class="token plain">       if err != nil {</span></div><div class="token-line"><span class="token plain">          session.Close()</span></div><div class="token-line"><span class="token plain">          return err</span></div><div class="token-line"><span class="token plain">       }</span></div><div class="token-line"><span class="token plain">       session.Close()</span></div><div class="token-line"><span class="token plain">       </span></div><div class="token-line"><span class="token plain">       // 执行前置命令成功</span></div><div class="token-line"><span class="token plain">       logger.Info(context.Background(), &quot;execute pre action&quot;, map[string]interface{}{</span></div><div class="token-line"><span class="token plain">          &quot;cmd&quot;:        action,</span></div><div class="token-line"><span class="token plain">          &quot;connection&quot;: node,</span></div><div class="token-line"><span class="token plain">          &quot;out&quot;:        strings.ReplaceAll(string(bts), &quot;\n&quot;, &quot;&quot;),</span></div><div class="token-line"><span class="token plain">       })</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>执行了前置命令之后，下面就是要把部署文件夹中的文件上传到目标服务器了。如何通过SSH服务将文件上传到目标服务器呢？</p><p>这里需要使用到一个成熟的第三方库 <a target="_blank" rel="noopener noreferrer" href="https://github.com/pkg/sftp">sftp<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 了，目前已经有1.1k star，采用BSD-2的开源协议，允许修改商用，但是要保留申明。这个库就是封装SSH的，将SFTP文件传输协议封装了一下。SFTP是什么？它是基于SSH协议来进行文件传输的一个协议，功能与FTP相似，区别就是它的连接通道使用SSH。</p><p>SFTP的底层连接实际上就是SSH，只是把传输的文件内容进行了一下加密等工作，增加了传输的安全性。所以<strong>SFTP本质就是“使用SSH连接来完成文件传输功能”</strong>。这点可以从它的实例化看出，sftp.Client的唯一参数就是ssh.Client。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">client, err := sftp.NewClient(sshClient)</span></div><div class="token-line"><span class="token plain">    if err != nil {</span></div><div class="token-line"><span class="token plain">       return err</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>SFTP这个库，在初始化sftp.Client之后，会将这个client封装地和官方的本地操作文件OS库一样，你在使用sftp.Client的时候完全没有障碍。</p><p>比如，OS库创建一个文件是os.Create，在SFTP中就是使用client.Create；OS库获取一个文件信息的函数是os.Stat，在SFTP中就是client.Stat。但是注意下，这里完全是SFTP刻意将这个库函数设计的和OS库一样的，它们之间并没有什么嵌套关系。</p><p>我们使用ssh.Client初始化一个sftp.Client之后，写一个uploadFolderToSFTP的函数来实现将本地文件夹同步到远端文件夹：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// 上传部署文件夹</span></div><div class="token-line"><span class="token plain">    func uploadFolderToSFTP(container framework.Container, localFolder, remoteFolder string, client *sftp.Client) error {</span></div><div class="token-line"><span class="token plain">        logger := container.MustMake(contract.LogKey).(contract.Log)</span></div><div class="token-line"><span class="token plain">        // 遍历本地文件</span></div><div class="token-line"><span class="token plain">        return filepath.Walk(localFolder, func(path string, info os.FileInfo, err error) error {</span></div><div class="token-line"><span class="token plain">            // 获取除了folder前缀的后续文件名称</span></div><div class="token-line"><span class="token plain">            relPath := strings.Replace(path, localFolder, &quot;&quot;, 1)</span></div><div class="token-line"><span class="token plain">            if relPath == &quot;&quot; {</span></div><div class="token-line"><span class="token plain">                return nil</span></div><div class="token-line"><span class="token plain">            }</span></div><div class="token-line"><span class="token plain">            // 如果是遍历到了一个目录</span></div><div class="token-line"><span class="token plain">            if info.IsDir() {</span></div><div class="token-line"><span class="token plain">                logger.Info(context.Background(), &quot;mkdir: &quot;+filepath.Join(remoteFolder, relPath), nil)</span></div><div class="token-line"><span class="token plain">                // 创建这个目录</span></div><div class="token-line"><span class="token plain">                return client.MkdirAll(filepath.Join(remoteFolder, relPath))</span></div><div class="token-line"><span class="token plain">            }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">            // 打开本地的文件</span></div><div class="token-line"><span class="token plain">            rf, err := os.Open(filepath.Join(localFolder, relPath))</span></div><div class="token-line"><span class="token plain">            if err != nil {</span></div><div class="token-line"><span class="token plain">                return errors.New(&quot;read file &quot; + filepath.Join(localFolder, relPath) + &quot; error:&quot; + err.Error())</span></div><div class="token-line"><span class="token plain">            }</span></div><div class="token-line"><span class="token plain">            // 检查文件大小</span></div><div class="token-line"><span class="token plain">            rfStat, err := rf.Stat()</span></div><div class="token-line"><span class="token plain">            if err != nil {</span></div><div class="token-line"><span class="token plain">                return err</span></div><div class="token-line"><span class="token plain">            }</span></div><div class="token-line"><span class="token plain">            // 打开/创建远端文件</span></div><div class="token-line"><span class="token plain">            f, err := client.Create(filepath.Join(remoteFolder, relPath))</span></div><div class="token-line"><span class="token plain">            if err != nil {</span></div><div class="token-line"><span class="token plain">                return errors.New(&quot;create file &quot; + filepath.Join(remoteFolder, relPath) + &quot; error:&quot; + err.Error())</span></div><div class="token-line"><span class="token plain">            }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">            // 大于2M的文件显示进度</span></div><div class="token-line"><span class="token plain">            if rfStat.Size() &gt; 2*1024*1024 {</span></div><div class="token-line"><span class="token plain">                logger.Info(context.Background(), &quot;upload local file: &quot;+filepath.Join(localFolder, relPath)+</span></div><div class="token-line"><span class="token plain">                    &quot; to remote file: &quot;+filepath.Join(remoteFolder, relPath)+&quot; start&quot;, nil)</span></div><div class="token-line"><span class="token plain">                // 开启一个goroutine来不断计算进度</span></div><div class="token-line"><span class="token plain">                go func(localFile, remoteFile string) {</span></div><div class="token-line"><span class="token plain">                    // 每10s计算一次</span></div><div class="token-line"><span class="token plain">                    ticker := time.NewTicker(2 * time.Second)</span></div><div class="token-line"><span class="token plain">                    for range ticker.C {</span></div><div class="token-line"><span class="token plain">                        // 获取远端文件信息</span></div><div class="token-line"><span class="token plain">                        remoteFileInfo, err := client.Stat(remoteFile)</span></div><div class="token-line"><span class="token plain">                        if err != nil {</span></div><div class="token-line"><span class="token plain">                            logger.Error(context.Background(), &quot;stat error&quot;, map[string]interface{}{</span></div><div class="token-line"><span class="token plain">                                &quot;err&quot;:         err,</span></div><div class="token-line"><span class="token plain">                                &quot;remote_file&quot;: remoteFile,</span></div><div class="token-line"><span class="token plain">                            })</span></div><div class="token-line"><span class="token plain">                            continue</span></div><div class="token-line"><span class="token plain">                        }</span></div><div class="token-line"><span class="token plain">                        // 如果远端文件大小等于本地文件大小，说明已经结束了</span></div><div class="token-line"><span class="token plain">                        size := remoteFileInfo.Size()</span></div><div class="token-line"><span class="token plain">                        if size &gt;= rfStat.Size() {</span></div><div class="token-line"><span class="token plain">                            break</span></div><div class="token-line"><span class="token plain">                        }</span></div><div class="token-line"><span class="token plain">                        // 计算进度并且打印进度</span></div><div class="token-line"><span class="token plain">                        percent := int(size * 100 / rfStat.Size())</span></div><div class="token-line"><span class="token plain">                        logger.Info(context.Background(), &quot;upload local file: &quot;+filepath.Join(localFolder, relPath)+</span></div><div class="token-line"><span class="token plain">                            &quot; to remote file: &quot;+filepath.Join(remoteFolder, relPath)+fmt.Sprintf(&quot; %v%% %v/%v&quot;, percent, size, rfStat.Size()), nil)</span></div><div class="token-line"><span class="token plain">                    }</span></div><div class="token-line"><span class="token plain">                }(filepath.Join(localFolder, relPath), filepath.Join(remoteFolder, relPath))</span></div><div class="token-line"><span class="token plain">            }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">            // 将本地文件并发读取到远端文件</span></div><div class="token-line"><span class="token plain">            if _, err := f.ReadFromWithConcurrency(rf, 10); err != nil {</span></div><div class="token-line"><span class="token plain">                return errors.New(&quot;Write file &quot; + filepath.Join(remoteFolder, relPath) + &quot; error:&quot; + err.Error())</span></div><div class="token-line"><span class="token plain">            }</span></div><div class="token-line"><span class="token plain">            // 记录成功信息</span></div><div class="token-line"><span class="token plain">            logger.Info(context.Background(), &quot;upload local file: &quot;+filepath.Join(localFolder, relPath)+</span></div><div class="token-line"><span class="token plain">                &quot; to remote file: &quot;+filepath.Join(remoteFolder, relPath)+&quot; finish&quot;, nil)</span></div><div class="token-line"><span class="token plain">            return nil</span></div><div class="token-line"><span class="token plain">        })</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>这段代码长一点。首先我们使用功能filePath.Walk来遍历本地文件夹中的所有文件，如果遍历到的是子文件夹，就创建子文件夹，否则的话，我们就将本地文件上传到远端。而上传远端的操作大致就是三步：打开本地文件、打开远端文件、将本地文件传输到远端文件。</p><p>在上述函数中大致是这几句代码：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// 打开本地的文件</span></div><div class="token-line"><span class="token plain">    rf, err := os.Open(filepath.Join(localFolder, relPath))</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    // 打开/创建远端文件</span></div><div class="token-line"><span class="token plain">    f, err := client.Create(filepath.Join(remoteFolder, relPath))</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    // 将本地文件并发读取到远端文件</span></div><div class="token-line"><span class="token plain">    if _, err := f.ReadFromWithConcurrency(rf, 10); err != nil</span></div></pre></div><p>SFTP提供了并发读取到远端文件ReadFromWithConcurrency的方法，我们可以使用这个并发读的方法提高上传效率。</p><p>但是即使是并发读，对于比较大的文件，还是需要等候比较长的时间。而这个等待时长，对于在控制台敲下部署命令的使用者来说是非常不友好的。我们希望能<strong>每隔一段时间显示一下当前的部署进度</strong>，这个怎么做呢？</p><p>这里我们设计大于2M的文件，执行这个操作。2M是我自己实验出来体验比较差的一个阈值。然后每2s就打印一下当前进度，所以使用了一个ticker，来计算时间。每次这个ticker结束的时候，计算一下远端文件的大小，再计算一下本地文件的大小。两者相除就是这个文件的上传进度，再使用日志打印就能打印出具体的进度了。</p><p>最后的效果如下：<br/><img src="https://static001.geekbang.org/resource/image/08/4e/088379171caf4131231de7d635b6e34e.png?wh=1920x157" alt=""/></p><p>到这里部署前端的代码就开发完成了。</p><h3 id="部署后端"><a aria-hidden="true" tabindex="-1" href="/blog/手把手带你写一个web框架/04.实战第3关完善功能/11#部署后端"><span class="icon icon-link"></span></a>部署后端</h3><p>理解了如何部署前端，部署后端的对应方法基本如出一辙。唯一不同的地方就是编译。</p><p>编译Golang的后端需要指定对应的编译平台和编译CPU架构，就是前面说的GOOS和GOARCH。所以我们就不能直接使用build命令来编译后端了。改成定位go程序，来执行go build，并且需要修改输出文件路径，输出到部署文件夹中。</p><p>当然这个部署文件夹还是按照我们之前的设计为 deploy/xxxxxx，其中的xxxx直接设置为细化到秒的时间，继续在framework/command/deploy.go中写入：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// 编译后端</span></div><div class="token-line"><span class="token plain">    path, err := exec.LookPath(&quot;go&quot;)</span></div><div class="token-line"><span class="token plain">    if err != nil {</span></div><div class="token-line"><span class="token plain">       log.Fatalln(&quot;hade go: 请在Path路径中先安装go&quot;)</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">       // 组装命令</span></div><div class="token-line"><span class="token plain">    deployBinFile := filepath.Join(deployFolder, binFile)</span></div><div class="token-line"><span class="token plain">    cmd := exec.Command(path, &quot;build&quot;, &quot;-o&quot;, deployBinFile, &quot;./&quot;)</span></div><div class="token-line"><span class="token plain">    cmd.Env = os.Environ()</span></div><div class="token-line"><span class="token plain">       // 设置GOOS和GOARCH</span></div><div class="token-line"><span class="token plain">    if configService.GetString(&quot;deploy.backend.goos&quot;) != &quot;&quot; {</span></div><div class="token-line"><span class="token plain">       cmd.Env = append(cmd.Env, &quot;GOOS=&quot;+configService.GetString(&quot;deploy.backend.goos&quot;))</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    if configService.GetString(&quot;deploy.backend.goarch&quot;) != &quot;&quot; {</span></div><div class="token-line"><span class="token plain">       cmd.Env = append(cmd.Env, &quot;GOARCH=&quot;+configService.GetString(&quot;deploy.backend.goarch&quot;))</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">       // 执行命令</span></div><div class="token-line"><span class="token plain">    ctx := context.Background()</span></div><div class="token-line"><span class="token plain">    out, err := cmd.CombinedOutput()</span></div><div class="token-line"><span class="token plain">    if err != nil {</span></div><div class="token-line"><span class="token plain">       logger.Error(ctx, &quot;go build err&quot;, map[string]interface{}{</span></div><div class="token-line"><span class="token plain">          &quot;err&quot;: err,</span></div><div class="token-line"><span class="token plain">          &quot;out&quot;: string(out),</span></div><div class="token-line"><span class="token plain">       })</span></div><div class="token-line"><span class="token plain">       return err</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    logger.Info(ctx, &quot;编译成功&quot;, nil)</span></div></pre></div><p>同时除了生成二进制文件，还要记得把.env文件（如果有的话）、config目标文件传递到本地的部署目录：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// 复制.env</span></div><div class="token-line"><span class="token plain">    if util.Exists(filepath.Join(appService.BaseFolder(), &quot;.env&quot;)) {</span></div><div class="token-line"><span class="token plain">       if err := util.CopyFile(filepath.Join(appService.BaseFolder(), &quot;.env&quot;), filepath.Join(deployFolder, &quot;.env&quot;)); err != nil {</span></div><div class="token-line"><span class="token plain">          return err</span></div><div class="token-line"><span class="token plain">       }</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    // 复制config文件</span></div><div class="token-line"><span class="token plain">    deployConfigFolder := filepath.Join(deployFolder, &quot;config&quot;, env)</span></div><div class="token-line"><span class="token plain">    if !util.Exists(deployConfigFolder) {</span></div><div class="token-line"><span class="token plain">       if err := os.MkdirAll(deployConfigFolder, os.ModePerm); err != nil {</span></div><div class="token-line"><span class="token plain">          return err</span></div><div class="token-line"><span class="token plain">       }</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    if err := util.CopyFolder(filepath.Join(appService.ConfigFolder(), env), deployConfigFolder); err != nil {</span></div><div class="token-line"><span class="token plain">       return err</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>自动化部署后端的命令，除了以上的编译文件到部署目录之外，其他部分都和自动化部署前端的命令一致：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// deployBackendCommand 部署后端</span></div><div class="token-line"><span class="token plain">    var deployBackendCommand = &amp;cobra.Command{</span></div><div class="token-line"><span class="token plain">       Use:   &quot;backend&quot;,</span></div><div class="token-line"><span class="token plain">       Short: &quot;部署后端&quot;,</span></div><div class="token-line"><span class="token plain">       RunE: func(c *cobra.Command, args []string) error {</span></div><div class="token-line"><span class="token plain">          container := c.GetContainer()</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">          // 创建部署文件夹</span></div><div class="token-line"><span class="token plain">          deployFolder, err := createDeployFolder(container)</span></div><div class="token-line"><span class="token plain">          if err != nil {</span></div><div class="token-line"><span class="token plain">             return err</span></div><div class="token-line"><span class="token plain">          }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">          // 编译后端到部署文件夹</span></div><div class="token-line"><span class="token plain">          if err := deployBuildBackend(c, deployFolder); err != nil {</span></div><div class="token-line"><span class="token plain">             return err</span></div><div class="token-line"><span class="token plain">          }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">          // 上传部署文件夹并执行对应的shell</span></div><div class="token-line"><span class="token plain">          return deployUploadAction(deployFolder, container, &quot;backend&quot;)</span></div><div class="token-line"><span class="token plain">       },</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><h3 id="部署全部"><a aria-hidden="true" tabindex="-1" href="/blog/手把手带你写一个web框架/04.实战第3关完善功能/11#部署全部"><span class="icon icon-link"></span></a>部署全部</h3><p>而对于同时部署前后端命令，其实就是在编译阶段，把前端和后端同时进行编译，并且最终上传部署文件夹。同样放在framework/command/deploy.go：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">var deployAllCommand = &amp;cobra.Command{</span></div><div class="token-line"><span class="token plain">       Use:   &quot;all&quot;,</span></div><div class="token-line"><span class="token plain">       Short: &quot;全部部署&quot;,</span></div><div class="token-line"><span class="token plain">       RunE: func(c *cobra.Command, args []string) error {</span></div><div class="token-line"><span class="token plain">          container := c.GetContainer()</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">          deployFolder, err := createDeployFolder(container)</span></div><div class="token-line"><span class="token plain">          if err != nil {</span></div><div class="token-line"><span class="token plain">             return err</span></div><div class="token-line"><span class="token plain">          }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">          // 编译前端</span></div><div class="token-line"><span class="token plain">          if err := deployBuildFrontend(c, deployFolder); err != nil {</span></div><div class="token-line"><span class="token plain">             return err</span></div><div class="token-line"><span class="token plain">          }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">          // 编译后端</span></div><div class="token-line"><span class="token plain">          if err := deployBuildBackend(c, deployFolder); err != nil {</span></div><div class="token-line"><span class="token plain">             return err</span></div><div class="token-line"><span class="token plain">          }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">          // 上传前端+后端，并执行对应的shell</span></div><div class="token-line"><span class="token plain">          return deployUploadAction(deployFolder, container, &quot;all&quot;)</span></div><div class="token-line"><span class="token plain">       },</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><h3 id="部署回滚"><a aria-hidden="true" tabindex="-1" href="/blog/手把手带你写一个web框架/04.实战第3关完善功能/11#部署回滚"><span class="icon icon-link"></span></a>部署回滚</h3><p>最后就是部署回滚操作，主要明确一下需要传递的参数：</p><p>一个是回滚版本号。这个版本号就是我们的部署目录的名称，前面说过部署目录为deploy/xxxxxx，xxxx设置为细化到秒的时间。比如20211110233354，表示是我们2021年11月10日23点33分54秒创建的版本。</p><p>另外一个就是标记希望回滚前端，还是后端，还是全部回滚。这里主要涉及执行前端的回滚命令，还是执行后端的回滚命令。</p><p>这两个参数我们直接以参数形式，跟在deploy rollback命令之后，如下：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">./hade deploy rollback 20211110233354 backend</span></div></pre></div><p>明确了参数，它的具体实现就很简单了，因为它没有任何的编译过程，我们只需要把回滚版本所在目录的编译结果，上传到目标服务器就可以了，同样，我们把这个命令放在framework/command/deploy.go中：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// deployRollbackCommand 部署回滚</span></div><div class="token-line"><span class="token plain">    var deployRollbackCommand = &amp;cobra.Command{</span></div><div class="token-line"><span class="token plain">       Use:   &quot;rollback&quot;,</span></div><div class="token-line"><span class="token plain">       Short: &quot;部署回滚&quot;,</span></div><div class="token-line"><span class="token plain">       RunE: func(c *cobra.Command, args []string) error {</span></div><div class="token-line"><span class="token plain">          container := c.GetContainer()</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">          if len(args) != 2 {</span></div><div class="token-line"><span class="token plain">             return errors.New(&quot;参数错误,请按照参数进行回滚 ./hade deploy rollback [version] [frontend/backend/all]&quot;)</span></div><div class="token-line"><span class="token plain">          }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">          version := args[0]</span></div><div class="token-line"><span class="token plain">          end := args[1]</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">          // 获取版本信息</span></div><div class="token-line"><span class="token plain">          appService := container.MustMake(contract.AppKey).(contract.App)</span></div><div class="token-line"><span class="token plain">          deployFolder := filepath.Join(appService.DeployFolder(), version)</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">          // 上传部署文件夹并执行对应的shell</span></div><div class="token-line"><span class="token plain">          return deployUploadAction(deployFolder, container, end)</span></div><div class="token-line"><span class="token plain">       },</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>到这里四个自动化部署命令就都开发完成。我们来验证一下。</p><h2 id="验证"><a aria-hidden="true" tabindex="-1" href="/blog/手把手带你写一个web框架/04.实战第3关完善功能/11#验证"><span class="icon icon-link"></span></a>验证</h2><p>要验证部署命令，我们当然需要有一个目标部署服务器，这是我设置的web-01服务器配置，在config/development/ssh.yaml中：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">timeout: 3s</span></div><div class="token-line"><span class="token plain">    network: tcp</span></div><div class="token-line"><span class="token plain">    web-01:</span></div><div class="token-line"><span class="token plain">        host: 111.222.333.444 # ip地址</span></div><div class="token-line"><span class="token plain">        port: 22 # 端口</span></div><div class="token-line"><span class="token plain">        username: yejianfeng # 用户名</span></div><div class="token-line"><span class="token plain">        password: &quot;123456&quot; # 密码</span></div></pre></div><p>而在config/development/deploy.yaml中我的配置如下：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">connections: # 要自动化部署的连接</span></div><div class="token-line"><span class="token plain">        - ssh.web-01</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    remote_folder: &quot;/home/yejianfeng/coredemo/&quot;  # 远端的部署文件夹</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    frontend: # 前端部署配置</span></div><div class="token-line"><span class="token plain">        pre_action: # 部署前置命令</span></div><div class="token-line"><span class="token plain">            - &quot;pwd&quot;</span></div><div class="token-line"><span class="token plain">        post_action: # 部署后置命令</span></div><div class="token-line"><span class="token plain">            - &quot;pwd&quot;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    backend: # 后端部署配置</span></div><div class="token-line"><span class="token plain">        goos: linux # 部署目标操作系统</span></div><div class="token-line"><span class="token plain">        goarch: amd64 # 部署目标cpu架构</span></div><div class="token-line"><span class="token plain">        pre_action: # 部署前置命令</span></div><div class="token-line"><span class="token plain">            - &quot;rm /home/yejianfeng/coredemo/hade&quot;</span></div><div class="token-line"><span class="token plain">        post_action: # 部署后置命令</span></div><div class="token-line"><span class="token plain">            - &quot;chmod 777 /home/yejianfeng/coredemo/hade&quot;</span></div><div class="token-line"><span class="token plain">            - &quot;/home/yejianfeng/coredemo/hade app restart&quot;</span></div></pre></div><p>重点看后端部署配置。在部署后端之前，我们先运行一个rm 命令来将旧的hade二进制进程删除，然后部署后端文件，其中包括这个二进制进程。最后执行了两个命令，一个是chmod命令，保证上传上去的二进制进程命令可以执行；第二个就是./hade app restart命令，能将远端的命令启动。</p><p>这里就演示下部署后端服务 <code>./hade deploy backend</code> ，输出结果如下：<br/><img src="https://static001.geekbang.org/resource/image/14/ac/14915cb398646c747875c4860e01b6ac.png?wh=1920x440" alt=""/><br/><img src="https://static001.geekbang.org/resource/image/2e/bb/2e70470a5e55e864aeea7e920e1eaabb.png?wh=1920x283" alt=""/></p><p>我们看到，它成功地编译后端服务，到目标文件夹deploy/20211110233533， 并且上传了编译的hade命令，在远端启动了进程。</p><p>接着验证下回滚命令。在之前已经发布过版本 20211110233354 了。所以这里直接运行命令 <code>./hade deploy rollback 20211110233354 backend</code> 将版本回滚到 20211110233354。<br/><img src="https://static001.geekbang.org/resource/image/fc/78/fc3280cfd8813169970f8d91c11f6578.png?wh=1920x403" alt=""/><br/><img src="https://static001.geekbang.org/resource/image/89/90/89390e826834862981bb94344dcfb090.png?wh=1920x297" alt=""/></p><p>验证成功！</p><p>本节课我们对framework下的provider、contract、command目录都有修改。目录截图如下，供你对比查看，所有代码都已经上传到<a target="_blank" rel="noopener noreferrer" href="https://github.com/gohade/coredemo/tree/geekbang/28">geekbang/28<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>分支了。<br/><img src="https://static001.geekbang.org/resource/image/d8/0b/d89d6aaf4f25fab54dec747ef0f4700b.jpg?wh=2187x1292" alt=""/></p><h2 id="小结"><a aria-hidden="true" tabindex="-1" href="/blog/手把手带你写一个web框架/04.实战第3关完善功能/11#小结"><span class="icon icon-link"></span></a>小结</h2><p>今天我们实现了将代码自动化部署到Web服务器的机制。为了实现这个自动化部署，先实现了一个SSH服务，然后定制了一套自动化部署命令，包括部署前端、部署后端、部署全部和部署回滚。</p><p>虽然说这个由框架负责的自动化部署机制在大项目中可能用不上，毕竟现在大项目都采用Docker化和k8s部署了。不过对于小型项目，这种部署机制还是有其便利性的。所以我们的hade框架还是决定提供这个机制。</p><p>在实现这个机制的过程中，要做到熟练掌握Golang对于SSH、SFTP等库的操作。基本上这两个库的操作你熟悉了，就能在一个程序中同时自动化操作多个服务器了。在实际工作中，如果遇到类似的需求，可以按照这节课所展示的技术来自动化你的需求。</p><h3 id="思考题"><a aria-hidden="true" tabindex="-1" href="/blog/手把手带你写一个web框架/04.实战第3关完善功能/11#思考题"><span class="icon icon-link"></span></a>思考题</h3><p>其实今天的内容涉及自动化运维的范畴了，我们就布置一个课外研究吧。自动化运维范畴中有一个很出名的自动化运维配置框架ansible，你可以去浏览下<a target="_blank" rel="noopener noreferrer" href="https://ansible-tran.readthedocs.io/en/latest">Ansible中文权威指南<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>网站，学习一下ansible有哪些功能，分享一下你的学习心得。</p><p>欢迎在留言区分享你的思考。感谢你的收听，如果你觉得今天的内容对你有所帮助，也欢迎分享给你身边的朋友，邀请他一起学习。我们下节课见。</p></div><div class="__dumi-default-layout-footer-meta"><a target="_blank" rel="noopener noreferrer" href="https://github.com/GGwujun/blog/edit/master/docs/手把手带你写一个Web框架/04.实战第3关完善功能/11.md">在 GitHub 上编辑此页<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a><span data-updated-text="最后更新时间：">5/2/2022 10:56:58</span></div></div></div></div>
	<script>
  window.g_useSSR = true;
  window.g_initialProps = {};
	</script>

    <script>
      (function () {
        if (!location.port) {
          (function (i, s, o, g, r, a, m) {
            i["GoogleAnalyticsObject"] = r;
            (i[r] =
              i[r] ||
              function () {
                (i[r].q = i[r].q || []).push(arguments);
              }),
              (i[r].l = 1 * new Date());
            (a = s.createElement(o)), (m = s.getElementsByTagName(o)[0]);
            a.async = 1;
            a.src = g;
            m.parentNode.insertBefore(a, m);
          })(
            window,
            document,
            "script",
            "//www.google-analytics.com/analytics.js",
            "ga"
          );
          ga("create", "UA-149864185-1", "auto");
          ga("send", "pageview");
        }
      })();
    </script>
    <script src="/blog/umi.js"></script>
  </body>
</html>
