<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no"
    />
    <link rel="shortcut icon" type="image/x-icon" href="/logo.png" />
    <link rel="stylesheet" href="/blog/umi.css" />
    <script>
      window.routerBase = "/blog";
    </script>
    <script>
      //! umi version: 3.5.17
    </script>
    <script>
      !(function () {
        var e = localStorage.getItem("dumi:prefers-color"),
          t = window.matchMedia("(prefers-color-scheme: dark)").matches,
          r = ["light", "dark", "auto"];
        document.documentElement.setAttribute(
          "data-prefers-color",
          e === r[2] ? (t ? r[1] : r[0]) : r.indexOf(e) > -1 ? e : r[0]
        );
      })();
    </script>
    <title>26｜GORM（下）：数据库的使用必不可少</title>
  </head>
  <body>
    <div id="root"><div class="__dumi-default-layout" data-route="/手把手带你写一个web框架/04.实战第3关完善功能/09" data-show-sidemenu="true" data-show-slugs="true" data-site-mode="true" data-gapless="false"><div class="__dumi-default-navbar" data-mode="site"><button class="__dumi-default-navbar-toggle"></button><a class="__dumi-default-navbar-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog/">大师兄</a><nav><div class="__dumi-default-search"><input type="search" class="__dumi-default-search-input" value=""/><ul></ul></div><span>计算机基础<ul><li><a href="/blog/编译原理之美">编译原理之美</a></li><li><a href="/blog/编译原理实战">编译原理实战</a></li><li><a href="/blog/深入浅出计算机组成原理">深入浅出计算机组成原理</a></li><li><a href="/blog/详解http">详解http</a></li><li><a href="/blog/计算机网络通关29讲">计算机网络通关29讲</a></li><li><a href="/blog/网络排查案例课">网络排查案例课</a></li><li><a href="/blog/linux操作系统">linux操作系统</a></li><li><a href="/blog/linux性能优化实战">linux性能优化实战</a></li><li><a href="/blog/程序员数学基础">程序员数学基础</a></li><li><a href="/blog/趣谈网络协议">趣谈网络协议</a></li><li><a href="/blog/操作系统实战">操作系统实战</a></li><li><a href="/blog/软件工程之美">软件工程之美</a></li><li><a href="/blog/sql必知必会">sql必知必会</a></li><li><a href="/blog/操作系统实战45讲">操作系统实战45讲</a></li><li><a href="/blog/网络编程实战">网络编程实战</a></li></ul></span><span>算法<ul><li><a href="/blog/常用算法25讲">常用算法25讲</a></li><li><a href="/blog/数据结构与算法之美">数据结构与算法之美</a></li><li><a href="/blog/业务开发算法50讲">业务开发算法50讲</a></li><li><a href="/blog/动态规划面试宝典">动态规划面试宝典</a></li></ul></span><span>前端开发<ul><li><a href="/blog/浏览器工作原理与实践">浏览器工作原理与实践</a></li><li><a href="/blog/新时代产品经理进阶之路">新时代产品经理进阶之路</a></li><li><a href="/blog/全栈工程师修炼指南">全栈工程师修炼指南</a></li><li><a href="/blog/flutter核心技术与实战">flutter核心技术与实战</a></li><li><a href="/blog/java-script核心原理解析">java-script核心原理解析</a></li><li><a href="/blog/说透低代码">说透低代码</a></li><li><a href="/blog/nodejs应用开发实战">nodejs应用开发实战</a></li><li><a href="/blog/反爬虫兵法演绎20讲">反爬虫兵法演绎20讲</a></li><li><a href="/blog/reactnative新架构实战课">reactnative新架构实战课</a></li><li><a href="/blog/正则表达式入门">正则表达式入门</a></li><li><a href="/blog/重学前端">重学前端</a></li><li><a href="/blog/serverless入门课">serverless入门课</a></li><li><a href="/blog/type-script入门实战笔记">type-script入门实战笔记</a></li><li><a href="/blog/图解googlev8">图解googlev8</a></li><li><a href="/blog/vue3源码分析">vue3源码分析</a></li><li><a href="/blog/玩转Vue3全家桶">玩转Vue3全家桶</a></li><li><a href="/blog/webassembly入门">webassembly入门</a></li><li><a aria-current="page" class="active" href="/blog/手把手带你写一个Web框架">手把手带你写一个Web框架</a></li><li><a href="/blog/web漏洞挖掘实战">web漏洞挖掘实战</a></li><li><a href="/blog/跟月影学可视化">跟月影学可视化</a></li><li><a href="/blog/搞定音频技术">搞定音频技术</a></li><li><a href="/blog/攻克视频技术">攻克视频技术</a></li></ul></span><span>前端工程化<ul><li><a href="/blog/logger">logger</a></li><li><a href="/blog/webpack">webpack</a></li><li><a href="/blog/webpackChain">webpackChain</a></li></ul></span><span>前端性能优化<ul><li><a href="/blog/react性能调优">react性能调优</a></li></ul></span><span>软件测试<ul><li><a href="/blog/全链路压测实战30讲">全链路压测实战30讲</a></li><li><a href="/blog/性能测试实战30讲">性能测试实战30讲</a></li><li><a href="/blog/自动化测试高手课">自动化测试高手课</a></li><li><a href="/blog/软件测试52讲">软件测试52讲</a></li></ul></span><span>面试<ul><li><a href="/blog/面试现场">面试现场</a></li></ul></span><span>杂谈<ul><li><a href="/blog/超级访谈对话张雪峰">超级访谈对话张雪峰</a></li><li><a href="/blog/Git实战手册">Git实战手册</a></li><li><a href="/blog/NodeJS">NodeJS</a></li><li><a href="/blog/ReactJS">ReactJS</a></li><li><a href="/blog/UI设计">UI设计</a></li><li><a href="/blog/webpack4系列教程">webpack4系列教程</a></li><li><a href="/blog/前端知识体系">前端知识体系</a></li><li><a href="/blog/剑指offer刷题笔记">剑指offer刷题笔记</a></li><li><a href="/blog/思考与成长">思考与成长</a></li><li><a href="/blog/设计模式手册">设计模式手册</a></li></ul></span><div class="__dumi-default-navbar-tool"><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "></div></div></div></nav></div><div class="__dumi-default-menu" data-mode="site"><div class="__dumi-default-menu-inner"><div class="__dumi-default-menu-header"><a class="__dumi-default-menu-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog/"></a><h1>大师兄</h1><p></p></div><div class="__dumi-default-menu-mobile-area"><ul class="__dumi-default-menu-nav-list"><li>计算机基础<ul><li><a href="/blog/编译原理之美">编译原理之美</a></li><li><a href="/blog/编译原理实战">编译原理实战</a></li><li><a href="/blog/深入浅出计算机组成原理">深入浅出计算机组成原理</a></li><li><a href="/blog/详解http">详解http</a></li><li><a href="/blog/计算机网络通关29讲">计算机网络通关29讲</a></li><li><a href="/blog/网络排查案例课">网络排查案例课</a></li><li><a href="/blog/linux操作系统">linux操作系统</a></li><li><a href="/blog/linux性能优化实战">linux性能优化实战</a></li><li><a href="/blog/程序员数学基础">程序员数学基础</a></li><li><a href="/blog/趣谈网络协议">趣谈网络协议</a></li><li><a href="/blog/操作系统实战">操作系统实战</a></li><li><a href="/blog/软件工程之美">软件工程之美</a></li><li><a href="/blog/sql必知必会">sql必知必会</a></li><li><a href="/blog/操作系统实战45讲">操作系统实战45讲</a></li><li><a href="/blog/网络编程实战">网络编程实战</a></li></ul></li><li>算法<ul><li><a href="/blog/常用算法25讲">常用算法25讲</a></li><li><a href="/blog/数据结构与算法之美">数据结构与算法之美</a></li><li><a href="/blog/业务开发算法50讲">业务开发算法50讲</a></li><li><a href="/blog/动态规划面试宝典">动态规划面试宝典</a></li></ul></li><li>前端开发<ul><li><a href="/blog/浏览器工作原理与实践">浏览器工作原理与实践</a></li><li><a href="/blog/新时代产品经理进阶之路">新时代产品经理进阶之路</a></li><li><a href="/blog/全栈工程师修炼指南">全栈工程师修炼指南</a></li><li><a href="/blog/flutter核心技术与实战">flutter核心技术与实战</a></li><li><a href="/blog/java-script核心原理解析">java-script核心原理解析</a></li><li><a href="/blog/说透低代码">说透低代码</a></li><li><a href="/blog/nodejs应用开发实战">nodejs应用开发实战</a></li><li><a href="/blog/反爬虫兵法演绎20讲">反爬虫兵法演绎20讲</a></li><li><a href="/blog/reactnative新架构实战课">reactnative新架构实战课</a></li><li><a href="/blog/正则表达式入门">正则表达式入门</a></li><li><a href="/blog/重学前端">重学前端</a></li><li><a href="/blog/serverless入门课">serverless入门课</a></li><li><a href="/blog/type-script入门实战笔记">type-script入门实战笔记</a></li><li><a href="/blog/图解googlev8">图解googlev8</a></li><li><a href="/blog/vue3源码分析">vue3源码分析</a></li><li><a href="/blog/玩转Vue3全家桶">玩转Vue3全家桶</a></li><li><a href="/blog/webassembly入门">webassembly入门</a></li><li><a aria-current="page" class="active" href="/blog/手把手带你写一个Web框架">手把手带你写一个Web框架</a></li><li><a href="/blog/web漏洞挖掘实战">web漏洞挖掘实战</a></li><li><a href="/blog/跟月影学可视化">跟月影学可视化</a></li><li><a href="/blog/搞定音频技术">搞定音频技术</a></li><li><a href="/blog/攻克视频技术">攻克视频技术</a></li></ul></li><li>前端工程化<ul><li><a href="/blog/logger">logger</a></li><li><a href="/blog/webpack">webpack</a></li><li><a href="/blog/webpackChain">webpackChain</a></li></ul></li><li>前端性能优化<ul><li><a href="/blog/react性能调优">react性能调优</a></li></ul></li><li>软件测试<ul><li><a href="/blog/全链路压测实战30讲">全链路压测实战30讲</a></li><li><a href="/blog/性能测试实战30讲">性能测试实战30讲</a></li><li><a href="/blog/自动化测试高手课">自动化测试高手课</a></li><li><a href="/blog/软件测试52讲">软件测试52讲</a></li></ul></li><li>面试<ul><li><a href="/blog/面试现场">面试现场</a></li></ul></li><li>杂谈<ul><li><a href="/blog/超级访谈对话张雪峰">超级访谈对话张雪峰</a></li><li><a href="/blog/Git实战手册">Git实战手册</a></li><li><a href="/blog/NodeJS">NodeJS</a></li><li><a href="/blog/ReactJS">ReactJS</a></li><li><a href="/blog/UI设计">UI设计</a></li><li><a href="/blog/webpack4系列教程">webpack4系列教程</a></li><li><a href="/blog/前端知识体系">前端知识体系</a></li><li><a href="/blog/剑指offer刷题笔记">剑指offer刷题笔记</a></li><li><a href="/blog/思考与成长">思考与成长</a></li><li><a href="/blog/设计模式手册">设计模式手册</a></li></ul></li></ul><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "><button title="Dark theme" class="__dumi-default-dark-moon "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="3854" width="22" height="22"><path d="M991.816611 674.909091a69.166545 69.166545 0 0 0-51.665455-23.272727 70.795636 70.795636 0 0 0-27.438545 5.585454A415.674182 415.674182 0 0 1 754.993338 698.181818c-209.594182 0-393.472-184.785455-393.472-395.636363 0-52.363636 38.539636-119.621818 69.515637-173.614546 4.887273-8.610909 9.634909-16.756364 14.103272-24.901818A69.818182 69.818182 0 0 0 384.631156 0a70.842182 70.842182 0 0 0-27.438545 5.585455C161.678429 90.298182 14.362065 307.898182 14.362065 512c0 282.298182 238.824727 512 532.38691 512a522.286545 522.286545 0 0 0 453.957818-268.334545A69.818182 69.818182 0 0 0 991.816611 674.909091zM546.679156 954.181818c-248.785455 0-462.941091-192-462.941091-442.181818 0-186.647273 140.637091-372.829091 300.939637-442.181818-36.817455 65.629091-92.578909 151.970909-92.578909 232.727273 0 250.181818 214.109091 465.454545 462.917818 465.454545a488.331636 488.331636 0 0 0 185.181091-46.545455 453.003636 453.003636 0 0 1-393.565091 232.727273z m103.656728-669.323636l-14.266182 83.781818a34.909091 34.909091 0 0 0 50.362182 36.770909l74.775272-39.563636 74.752 39.563636a36.142545 36.142545 0 0 0 16.174546 3.956364 34.909091 34.909091 0 0 0 34.210909-40.727273l-14.289455-83.781818 60.509091-59.345455a35.025455 35.025455 0 0 0-19.223272-59.578182l-83.61891-12.101818-37.376-76.101818a34.56 34.56 0 0 0-62.254545 0l-37.376 76.101818-83.618909 12.101818a34.909091 34.909091 0 0 0-19.246546 59.578182z m70.423272-64.698182a34.280727 34.280727 0 0 0 26.135273-19.083636l14.312727-29.090909 14.336 29.090909a34.257455 34.257455 0 0 0 26.135273 19.083636l32.046546 4.887273-23.272728 22.574545a35.234909 35.234909 0 0 0-10.007272 30.952727l5.46909 32.116364-28.625454-15.127273a34.490182 34.490182 0 0 0-32.302546 0l-28.695272 15.127273 5.469091-32.116364a35.141818 35.141818 0 0 0-9.984-30.952727l-23.272728-22.574545z" p-id="3855"></path></svg></button><button title="Light theme" class="__dumi-default-dark-sun "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="4026" width="22" height="22"><path d="M915.2 476.16h-43.968c-24.704 0-44.736 16-44.736 35.84s20.032 35.904 44.736 35.904H915.2c24.768 0 44.8-16.064 44.8-35.904s-20.032-35.84-44.8-35.84zM512 265.6c-136.704 0-246.464 109.824-246.464 246.4 0 136.704 109.76 246.464 246.464 246.464S758.4 648.704 758.4 512c0-136.576-109.696-246.4-246.4-246.4z m0 425.6c-99.008 0-179.2-80.128-179.2-179.2 0-98.944 80.192-179.2 179.2-179.2S691.2 413.056 691.2 512c0 99.072-80.192 179.2-179.2 179.2zM197.44 512c0-19.84-19.136-35.84-43.904-35.84H108.8c-24.768 0-44.8 16-44.8 35.84s20.032 35.904 44.8 35.904h44.736c24.768 0 43.904-16.064 43.904-35.904zM512 198.464c19.776 0 35.84-20.032 35.84-44.8v-44.8C547.84 84.032 531.84 64 512 64s-35.904 20.032-35.904 44.8v44.8c0 24.768 16.128 44.864 35.904 44.864z m0 627.136c-19.776 0-35.904 20.032-35.904 44.8v44.736C476.096 940.032 492.16 960 512 960s35.84-20.032 35.84-44.8v-44.736c0-24.768-16.064-44.864-35.84-44.864z m329.92-592.832c17.472-17.536 20.288-43.072 6.4-57.024-14.016-14.016-39.488-11.2-57.024 6.336-4.736 4.864-26.496 26.496-31.36 31.36-17.472 17.472-20.288 43.008-6.336 57.024 13.952 14.016 39.488 11.2 57.024-6.336 4.8-4.864 26.496-26.56 31.296-31.36zM213.376 759.936c-4.864 4.8-26.56 26.624-31.36 31.36-17.472 17.472-20.288 42.944-6.4 56.96 14.016 13.952 39.552 11.2 57.024-6.336 4.8-4.736 26.56-26.496 31.36-31.36 17.472-17.472 20.288-43.008 6.336-56.96-14.016-13.952-39.552-11.072-56.96 6.336z m19.328-577.92c-17.536-17.536-43.008-20.352-57.024-6.336-14.08 14.016-11.136 39.488 6.336 57.024 4.864 4.864 26.496 26.56 31.36 31.424 17.536 17.408 43.008 20.288 56.96 6.336 14.016-14.016 11.264-39.488-6.336-57.024-4.736-4.864-26.496-26.56-31.296-31.424z m527.168 628.608c4.864 4.864 26.624 26.624 31.36 31.424 17.536 17.408 43.072 20.224 57.088 6.336 13.952-14.016 11.072-39.552-6.4-57.024-4.864-4.8-26.56-26.496-31.36-31.36-17.472-17.408-43.072-20.288-57.024-6.336-13.952 14.016-11.008 39.488 6.336 56.96z" p-id="4027"></path></svg></button><button title="Default to system" class="__dumi-default-dark-auto "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="11002" width="22" height="22"><path d="M127.658667 492.885333c0-51.882667 10.24-101.717333 30.378666-149.162666s47.786667-88.064 81.92-122.538667 75.093333-61.781333 122.538667-81.92 96.938667-30.378667 149.162667-30.378667 101.717333 10.24 149.162666 30.378667 88.405333 47.786667 122.88 81.92 61.781333 75.093333 81.92 122.538667 30.378667 96.938667 30.378667 149.162666-10.24 101.717333-30.378667 149.162667-47.786667 88.405333-81.92 122.88-75.093333 61.781333-122.88 81.92-97.28 30.378667-149.162666 30.378667-101.717333-10.24-149.162667-30.378667-88.064-47.786667-122.538667-81.92-61.781333-75.093333-81.92-122.88-30.378667-96.938667-30.378666-149.162667z m329.045333 0c0 130.048 13.994667 244.394667 41.984 343.381334h12.970667c46.762667 0 91.136-9.216 133.461333-27.306667s78.848-42.666667 109.568-73.386667 54.954667-67.242667 73.386667-109.568 27.306667-86.698667 27.306666-133.461333c0-46.421333-9.216-90.794667-27.306666-133.12s-42.666667-78.848-73.386667-109.568-67.242667-54.954667-109.568-73.386667-86.698667-27.306667-133.461333-27.306666h-11.605334c-28.672 123.562667-43.349333 237.909333-43.349333 343.722666z" p-id="11003"></path></svg></button></div></div></div><ul class="__dumi-default-menu-list"><li><a href="/blog/">大师兄 - 前端架构师</a></li></ul></div></div><ul role="slug-list" class="__dumi-default-layout-toc"><li title="ORM服务" data-depth="2"><a href="/blog/手把手带你写一个web框架/04.实战第3关完善功能/09#orm服务"><span>ORM服务</span></a></li><li title="服务接口" data-depth="3"><a href="/blog/手把手带你写一个web框架/04.实战第3关完善功能/09#服务接口"><span>服务接口</span></a></li><li title="服务提供者" data-depth="3"><a href="/blog/手把手带你写一个web框架/04.实战第3关完善功能/09#服务提供者"><span>服务提供者</span></a></li><li title="服务实例化" data-depth="2"><a href="/blog/手把手带你写一个web框架/04.实战第3关完善功能/09#服务实例化"><span>服务实例化</span></a></li><li title="配置" data-depth="3"><a href="/blog/手把手带你写一个web框架/04.实战第3关完善功能/09#配置"><span>配置</span></a></li><li title="日志" data-depth="3"><a href="/blog/手把手带你写一个web框架/04.实战第3关完善功能/09#日志"><span>日志</span></a></li><li title="服务实例" data-depth="3"><a href="/blog/手把手带你写一个web框架/04.实战第3关完善功能/09#服务实例"><span>服务实例</span></a></li><li title="测试" data-depth="2"><a href="/blog/手把手带你写一个web框架/04.实战第3关完善功能/09#测试"><span>测试</span></a></li><li title="小结" data-depth="3"><a href="/blog/手把手带你写一个web框架/04.实战第3关完善功能/09#小结"><span>小结</span></a></li><li title="思考题" data-depth="3"><a href="/blog/手把手带你写一个web框架/04.实战第3关完善功能/09#思考题"><span>思考题</span></a></li></ul><div class="__dumi-default-layout-content"><div class="markdown"><h1 id="26gorm下数据库的使用必不可少"><a aria-hidden="true" tabindex="-1" href="/blog/手把手带你写一个web框架/04.实战第3关完善功能/09#26gorm下数据库的使用必不可少"><span class="icon icon-link"></span></a>26｜GORM（下）：数据库的使用必不可少</h1><p>你好，我是轩脉刃。</p><p>上一节课，我们梳理了Gorm的核心逻辑，也通过思维导图，详细分析了Gorm的源码搞清楚它是如何封装database/sql的。这节课我们就要思考和操作，如何将Gorm融合进入hade框架了。</p><p>Gorm的使用分为两个部分，数据库的连接和数据库的操作。</p><p>对于数据库操作接口的封装，Gorm已经做的非常好了，它在gorm.DB中定义了非常多的对数据库的操作接口，这些接口已经是非常易用了，而且每个操作接口在<a target="_blank" rel="noopener noreferrer" href="https://gorm.io/docs/">官方文档<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>中都有对应的说明和使用教程。比如在DB的操作接口列表中，我们可以看到常用的增删改查的逻辑：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">func (db *DB) Create(value interface{}) (tx *DB)</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    func (db *DB) Delete(value interface{}, conds ...interface{}) (tx *DB)</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    func (db *DB) Get(key string) (interface{}, bool)</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    func (db *DB) Update(column string, value interface{}) (tx *DB)</span></div></pre></div><p>同时，<a target="_blank" rel="noopener noreferrer" href="https://gorm.io/docs/">官方首页<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>的例子也把获取到DB后的增删改查操作显示很清楚了，建议你在浏览器收藏这个Gorm的说明文档，因为在具体的应用开发中，你会经常参考使用它的。</p><p>所以今天我们要做的事情，就是封装Gorm的数据库连接部分。</p><h2 id="orm服务"><a aria-hidden="true" tabindex="-1" href="/blog/手把手带你写一个web框架/04.实战第3关完善功能/09#orm服务"><span class="icon icon-link"></span></a>ORM服务</h2><p>按照“一切皆服务”的思想，我们也计划将Gorm封装为一个服务。而服务三要素是服务接口、服务提供者、服务实例化。我们先来定义ORM服务接口。</p><h3 id="服务接口"><a aria-hidden="true" tabindex="-1" href="/blog/手把手带你写一个web框架/04.实战第3关完善功能/09#服务接口"><span class="icon icon-link"></span></a>服务接口</h3><p>这个服务接口并不复杂，它的唯一任务就是能够初始化出gorm.DB 实例。回顾上节课说的Gorm初始化gorm.DB的方法：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">dsn := &quot;xxxxxxx&quot;</span></div><div class="token-line"><span class="token plain">      db, err := gorm.Open(mysql.Open(dsn), &amp;gorm.Config{})</span></div></pre></div><p>参数看起来就这两个部分DSN和gorm.Config。</p><p>不过我们希望设计一个hade框架自定义的配置结构，将所有创建连接需要的配置项整合起来。所以除了DSN和gorm.Config这两个配置项，其实还需要加上连接池的配置，就是上节课说的database/sql中提供的对连接池的配置信息。再回顾一下这四个影响底层创建连接池设置的配置信息：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// 设置连接的最大空闲时长</span></div><div class="token-line"><span class="token plain">    func (db *DB) SetConnMaxIdleTime(d time.Duration)</span></div><div class="token-line"><span class="token plain">    // 设置连接的最大生命时长</span></div><div class="token-line"><span class="token plain">    func (db *DB) SetConnMaxLifetime(d time.Duration)</span></div><div class="token-line"><span class="token plain">    // 设置最大空闲连接数</span></div><div class="token-line"><span class="token plain">    func (db *DB) SetMaxIdleConns(n int)</span></div><div class="token-line"><span class="token plain">    // 设置最大打开连接数</span></div><div class="token-line"><span class="token plain">    func (db *DB) SetMaxOpenConns(n int)</span></div></pre></div><p><strong>所以可以定义这么一个DBConfig结构，将所有的创建DB相关的配置都放在这里面</strong>。代码在framework/contract/orm.go中：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// DBConfig 代表数据库连接的所有配置</span></div><div class="token-line"><span class="token plain">    type DBConfig struct {</span></div><div class="token-line"><span class="token plain">       // 以下配置关于dsn</span></div><div class="token-line"><span class="token plain">       WriteTimeout string `yaml:&quot;write_timeout&quot;` // 写超时时间</span></div><div class="token-line"><span class="token plain">       Loc          string `yaml:&quot;loc&quot;`           // 时区</span></div><div class="token-line"><span class="token plain">       Port         int    `yaml:&quot;port&quot;`          // 端口</span></div><div class="token-line"><span class="token plain">       ReadTimeout  string `yaml:&quot;read_timeout&quot;`  // 读超时时间</span></div><div class="token-line"><span class="token plain">       Charset      string `yaml:&quot;charset&quot;`       // 字符集</span></div><div class="token-line"><span class="token plain">       ParseTime    bool   `yaml:&quot;parse_time&quot;`    // 是否解析时间</span></div><div class="token-line"><span class="token plain">       Protocol     string `yaml:&quot;protocol&quot;`      // 传输协议</span></div><div class="token-line"><span class="token plain">       Dsn          string `yaml:&quot;dsn&quot;`           // 直接传递dsn，如果传递了，其他关于dsn的配置均无效</span></div><div class="token-line"><span class="token plain">       Database     string `yaml:&quot;database&quot;`      // 数据库</span></div><div class="token-line"><span class="token plain">       Collation    string `yaml:&quot;collation&quot;`     // 字符序</span></div><div class="token-line"><span class="token plain">       Timeout      string `yaml:&quot;timeout&quot;`       // 连接超时时间</span></div><div class="token-line"><span class="token plain">       Username     string `yaml:&quot;username&quot;`      // 用户名</span></div><div class="token-line"><span class="token plain">       Password     string `yaml:&quot;password&quot;`      // 密码</span></div><div class="token-line"><span class="token plain">       Driver       string `yaml:&quot;driver&quot;`        // 驱动</span></div><div class="token-line"><span class="token plain">       Host         string `yaml:&quot;host&quot;`          // 数据库地址</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">       // 以下配置关于连接池</span></div><div class="token-line"><span class="token plain">       ConnMaxIdle     int    `yaml:&quot;conn_max_idle&quot;`     // 最大空闲连接数</span></div><div class="token-line"><span class="token plain">       ConnMaxOpen     int    `yaml:&quot;conn_max_open&quot;`     // 最大连接数</span></div><div class="token-line"><span class="token plain">       ConnMaxLifetime string `yaml:&quot;conn_max_lifetime&quot;` // 连接最大生命周期</span></div><div class="token-line"><span class="token plain">       ConnMaxIdletime string `yaml:&quot;conn_max_idletime&quot;` // 空闲最大生命周期</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">       // 以下配置关于gorm</span></div><div class="token-line"><span class="token plain">       *gorm.Config // 集成gorm的配置</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>其中DSN是一个复杂的字符串。但我们又不希望使用者直接设置这些复杂字符串来进行传递，所以这里设置了多个字段来生成这个DSN。</p><p>另外上节课也说过，DSN并没有一个标准的格式约定，不同的数据库可能有不同的解析，所以也同时保留直接设置DSN的权限，如果用户手动设置了Dsn字段，那么其他关于Dsn的字段设置均无效。</p><p>所以这里同时需要实现一个方法，使用DBConfig来生成最终使用的字符串Dsn，使用上节课介绍的 github.com/go-sql-driver/mysql 库，就能很方便地实现了。我们继续写：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">import (</span></div><div class="token-line"><span class="token plain">       &quot;github.com/go-sql-driver/mysql&quot;</span></div><div class="token-line"><span class="token plain">       ...</span></div><div class="token-line"><span class="token plain">    )</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    // FormatDsn 生成dsn</span></div><div class="token-line"><span class="token plain">    func (conf *DBConfig) FormatDsn() (string, error) {</span></div><div class="token-line"><span class="token plain">       port := strconv.Itoa(conf.Port)</span></div><div class="token-line"><span class="token plain">       timeout, err := time.ParseDuration(conf.Timeout)</span></div><div class="token-line"><span class="token plain">       if err != nil {</span></div><div class="token-line"><span class="token plain">          return &quot;&quot;, err</span></div><div class="token-line"><span class="token plain">       }</span></div><div class="token-line"><span class="token plain">       readTimeout, err := time.ParseDuration(conf.ReadTimeout)</span></div><div class="token-line"><span class="token plain">       if err != nil {</span></div><div class="token-line"><span class="token plain">          return &quot;&quot;, err</span></div><div class="token-line"><span class="token plain">       }</span></div><div class="token-line"><span class="token plain">       writeTimeout, err := time.ParseDuration(conf.WriteTimeout)</span></div><div class="token-line"><span class="token plain">       if err != nil {</span></div><div class="token-line"><span class="token plain">          return &quot;&quot;, err</span></div><div class="token-line"><span class="token plain">       }</span></div><div class="token-line"><span class="token plain">       location, err := time.LoadLocation(conf.Loc)</span></div><div class="token-line"><span class="token plain">       if err != nil {</span></div><div class="token-line"><span class="token plain">          return &quot;&quot;, err</span></div><div class="token-line"><span class="token plain">       }</span></div><div class="token-line"><span class="token plain">       driverConf := &amp;mysql.Config{</span></div><div class="token-line"><span class="token plain">          User:         conf.Username,</span></div><div class="token-line"><span class="token plain">          Passwd:       conf.Password,</span></div><div class="token-line"><span class="token plain">          Net:          conf.Protocol,</span></div><div class="token-line"><span class="token plain">          Addr:         net.JoinHostPort(conf.Host, port),</span></div><div class="token-line"><span class="token plain">          DBName:       conf.Database,</span></div><div class="token-line"><span class="token plain">          Collation:    conf.Collation,</span></div><div class="token-line"><span class="token plain">          Loc:          location,</span></div><div class="token-line"><span class="token plain">          Timeout:      timeout,</span></div><div class="token-line"><span class="token plain">          ReadTimeout:  readTimeout,</span></div><div class="token-line"><span class="token plain">          WriteTimeout: writeTimeout,</span></div><div class="token-line"><span class="token plain">          ParseTime:    conf.ParseTime,</span></div><div class="token-line"><span class="token plain">       }</span></div><div class="token-line"><span class="token plain">       return driverConf.FormatDSN(), nil</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>可以看到Gorm配置，我们使用结构嵌套的方式，将gorm.Config直接嵌套进入DBConfig中。你可以琢磨下这种写法，它有两个好处。</p><p><strong>一是可以直接设置DBConfig来设置gorm.Config</strong>。比如这个函数是可行的，它直接设置config.DryRun，就是直接设置gorm.Config：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">func(container framework.Container, config *contract.DBConfig) error {</span></div><div class="token-line"><span class="token plain">       config.DryRun = true</span></div><div class="token-line"><span class="token plain">       return nil</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p><strong>二是DBConfig继承了*gorm.Config的所有方法</strong>。比如这段代码，我们来理解一下：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">config := &amp;contract.DBConfig{}</span></div><div class="token-line"><span class="token plain">    db, err = gorm.Open(mysql.Open(config.Dsn), config)</span></div></pre></div><p>还记得gorm.Open的第二个参数是Option么，它是一个接口，需要实现Apply和AfterInitialize方法，而我们的DBConfig并没有显式实现这两个方法。但是它嵌套了实现了这两个方法的*gorm.Config，所以，默认DB.Config也就实现了这两个方法。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">type Option interface {</span></div><div class="token-line"><span class="token plain">       Apply(*Config) error</span></div><div class="token-line"><span class="token plain">       AfterInitialize(*DB) error</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>现在，gorm.Open的两个参数DSN和gorm.Config都封装在DBConfig中，而修改DBConfig的方法，我们封装为DBOption。</p><p>如何让设置DBOption的方法更为优雅呢？这里就使用到上节课刚学到的Option可变参数的编程方法了。定义一个DBOption的结构，它代表一个可以对DBConfig进行设置的方法，这个结构作为获取ORM服务GetDB方法的参数。在framework/contract/orm.go中：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">package contract</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    // ORMKey 代表 ORM的服务</span></div><div class="token-line"><span class="token plain">    const ORMKey = &quot;hade:orm&quot;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    // ORMService 表示传入的参数</span></div><div class="token-line"><span class="token plain">    type ORMService interface {</span></div><div class="token-line"><span class="token plain">       GetDB(option ...DBOption) (*gorm.DB, error)</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    // DBOption 代表初始化的时候的选项</span></div><div class="token-line"><span class="token plain">    type DBOption func(container framework.Container, config *DBConfig) error</span></div></pre></div><p>这样就能通过设置不同的方法来对DBConfig进行配置。</p><p>比如要设置DBConfig中gorm.Config的DryRun空跑字段，设计了这么一个方法在framework/provider/orm/config.go中：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// WithDryRun 设置空跑模式</span></div><div class="token-line"><span class="token plain">    func WithDryRun() contract.DBOption {</span></div><div class="token-line"><span class="token plain">       return func(container framework.Container, config *contract.DBConfig) error {</span></div><div class="token-line"><span class="token plain">          config.DryRun = true</span></div><div class="token-line"><span class="token plain">          return nil</span></div><div class="token-line"><span class="token plain">       }</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>之后，在使用ORM服务的时候，我们就可以这样设置：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">gormService := c.MustMake(contract.ORMKey).(contract.ORMService)</span></div><div class="token-line"><span class="token plain">    // 可变参数为WithDryRun()</span></div><div class="token-line"><span class="token plain">    db, err := gormService.GetDB(orm.WithDryRun())</span></div></pre></div><h3 id="服务提供者"><a aria-hidden="true" tabindex="-1" href="/blog/手把手带你写一个web框架/04.实战第3关完善功能/09#服务提供者"><span class="icon icon-link"></span></a>服务提供者</h3><p>下一步来完成服务提供者，我们也并不需要过于复杂的设计，只要注意一下两点：</p><ul><li>ORM服务一定是要延迟加载的，因为这个服务并不是一个基础服务。如果设置为非延迟加载，在框架启动的时候就会去建立这个服务，这并不是我们想要的。所以我们设计ORM的provider的时候，需要将IsDefer函数设置为true。</li><li>第二点考虑到我们后续会使用container中的配置服务，来创建具体的gorm.DB实例，传递一个container是必要的。</li></ul><p>所以具体的服务提供者代码如下，在framework/provider/orm/provider.go中：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">package orm</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    import (</span></div><div class="token-line"><span class="token plain">       &quot;github.com/gohade/hade/framework&quot;</span></div><div class="token-line"><span class="token plain">       &quot;github.com/gohade/hade/framework/contract&quot;</span></div><div class="token-line"><span class="token plain">    )</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    // GormProvider 提供App的具体实现方法</span></div><div class="token-line"><span class="token plain">    type GormProvider struct {</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    // Register 注册方法</span></div><div class="token-line"><span class="token plain">    func (h *GormProvider) Register(container framework.Container) framework.NewInstance {</span></div><div class="token-line"><span class="token plain">       return NewHadeGorm</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    // Boot 启动调用</span></div><div class="token-line"><span class="token plain">    func (h *GormProvider) Boot(container framework.Container) error {</span></div><div class="token-line"><span class="token plain">       return nil</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    // IsDefer 是否延迟初始化</span></div><div class="token-line"><span class="token plain">    func (h *GormProvider) IsDefer() bool {</span></div><div class="token-line"><span class="token plain">       return true</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    // Params 获取初始化参数</span></div><div class="token-line"><span class="token plain">    func (h *GormProvider) Params(container framework.Container) []interface{} {</span></div><div class="token-line"><span class="token plain">       return []interface{}{container}</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    // Name 获取字符串凭证</span></div><div class="token-line"><span class="token plain">    func (h *GormProvider) Name() string {</span></div><div class="token-line"><span class="token plain">       return contract.ORMKey</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><h2 id="服务实例化"><a aria-hidden="true" tabindex="-1" href="/blog/手把手带你写一个web框架/04.实战第3关完善功能/09#服务实例化"><span class="icon icon-link"></span></a>服务实例化</h2><p>服务实例化是今天的重点内容，我们先把Gorm的配置结构和日志结构的准备工作完成，再写稍微复杂一点的具体ORM服务的实例 HadeGorm。</p><h3 id="配置"><a aria-hidden="true" tabindex="-1" href="/blog/手把手带你写一个web框架/04.实战第3关完善功能/09#配置"><span class="icon icon-link"></span></a>配置</h3><p>前面定义了hade框架专属的DBConfig配置结构，如何设置它是一个需要讲究的问题。</p><p>虽然已经设计了一种修改配置文件的方式，就是通过GetDB中的Option参数来设置。但是每个字段都这么设置又非常麻烦，我们自然会想到使用配置文件来配置这个结构。另外如果要连接多个数据库，每个数据库都进行同样的配置，还是颇为麻烦，是不是可以有个默认配置呢？</p><p>于是我们的配置文件可以这样设计：在 database.yaml 中保存数据库的默认值，如果想对某个数据库连接有单独的配置，可以用内嵌yaml结构的方式来进行配置。看下面这个配置例子：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">conn_max_idle: 10 # 通用配置，连接池最大空闲连接数</span></div><div class="token-line"><span class="token plain">    conn_max_open: 100 # 通用配置，连接池最大连接数</span></div><div class="token-line"><span class="token plain">    conn_max_lifetime: 1h # 通用配置，连接数最大生命周期</span></div><div class="token-line"><span class="token plain">    protocol: tcp # 通用配置，传输协议</span></div><div class="token-line"><span class="token plain">    loc: Local # 通用配置，时区</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    default:</span></div><div class="token-line"><span class="token plain">        driver: mysql # 连接驱动</span></div><div class="token-line"><span class="token plain">        dsn: &quot;&quot; # dsn，如果设置了dsn, 以下的所有设置都不生效</span></div><div class="token-line"><span class="token plain">        host: localhost # ip地址</span></div><div class="token-line"><span class="token plain">        port: 3306 # 端口</span></div><div class="token-line"><span class="token plain">        database: coredemo # 数据库</span></div><div class="token-line"><span class="token plain">        username: jianfengye # 用户名</span></div><div class="token-line"><span class="token plain">        password: &quot;123456789&quot; # 密码</span></div><div class="token-line"><span class="token plain">        charset: utf8mb4 # 字符集</span></div><div class="token-line"><span class="token plain">        collation: utf8mb4_unicode_ci # 字符序</span></div><div class="token-line"><span class="token plain">        timeout: 10s # 连接超时</span></div><div class="token-line"><span class="token plain">        read_timeout: 2s # 读超时</span></div><div class="token-line"><span class="token plain">        write_timeout: 2s # 写超时</span></div><div class="token-line"><span class="token plain">        parse_time: true # 是否解析时间</span></div><div class="token-line"><span class="token plain">        protocol: tcp # 传输协议</span></div><div class="token-line"><span class="token plain">        loc: Local # 时区</span></div><div class="token-line"><span class="token plain">        conn_max_idle: 10 # 连接池最大空闲连接数</span></div><div class="token-line"><span class="token plain">        conn_max_open: 20 # 连接池最大连接数</span></div><div class="token-line"><span class="token plain">        conn_max_lifetime: 1h # 连接数最大生命周期</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    read:</span></div><div class="token-line"><span class="token plain">        driver: mysql # 连接驱动</span></div><div class="token-line"><span class="token plain">        dsn: &quot;&quot; # dsn，如果设置了dsn, 以下的所有设置都不生效</span></div><div class="token-line"><span class="token plain">        host: localhost # ip地址</span></div><div class="token-line"><span class="token plain">        port: 3306 # 端口</span></div><div class="token-line"><span class="token plain">        database: coredemo # 数据库</span></div><div class="token-line"><span class="token plain">        username: jianfengye # 用户名</span></div><div class="token-line"><span class="token plain">        password: &quot;123456789&quot; # 密码</span></div><div class="token-line"><span class="token plain">        charset: utf8mb4 # 字符集</span></div><div class="token-line"><span class="token plain">        collation: utf8mb4_unicode_ci # 字符序</span></div></pre></div><p>在这个database.yaml中，我们配置了database.default和database.read两个数据源。database.read数据源，并没有设置诸如时区loc、连接池conn_max_open配置，这些缺省的配置要从databse.yaml的根结构中获取。</p><p>要实现这个也并不难，先在framework/provider/orm/service.go中实现一个GetBaseConfig方法，来读取database.yaml根目录的结构：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// GetBaseConfig 读取database.yaml根目录结构</span></div><div class="token-line"><span class="token plain">    func GetBaseConfig(c framework.Container) *contract.DBConfig {</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">       configService := c.MustMake(contract.ConfigKey).(contract.Config)</span></div><div class="token-line"><span class="token plain">       logService := c.MustMake(contract.LogKey).(contract.Log)</span></div><div class="token-line"><span class="token plain">       </span></div><div class="token-line"><span class="token plain">       config := &amp;contract.DBConfig{}</span></div><div class="token-line"><span class="token plain">       // 直接使用配置服务的load方法读取,yaml文件</span></div><div class="token-line"><span class="token plain">       err := configService.Load(&quot;database&quot;, config)</span></div><div class="token-line"><span class="token plain">       if err != nil {</span></div><div class="token-line"><span class="token plain">          // 直接使用logService来打印错误信息</span></div><div class="token-line"><span class="token plain">          logService.Error(context.Background(), &quot;parse database config error&quot;, nil)</span></div><div class="token-line"><span class="token plain">          return nil</span></div><div class="token-line"><span class="token plain">       }</span></div><div class="token-line"><span class="token plain">       return config</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>然后设计一个根据配置路径加载某个配置结构的方法。这里这个方法一定是在具体初始化某个DB实例的时候使用到，所以要封装为一个Option结构，写在framework/provider/orm/config.go中：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// WithConfigPath 加载配置文件地址</span></div><div class="token-line"><span class="token plain">    func WithConfigPath(configPath string) contract.DBOption {</span></div><div class="token-line"><span class="token plain">       return func(container framework.Container, config *contract.DBConfig) error {</span></div><div class="token-line"><span class="token plain">          configService := container.MustMake(contract.ConfigKey).(contract.Config)</span></div><div class="token-line"><span class="token plain">            // 加载configPath配置路径</span></div><div class="token-line"><span class="token plain">          if err := configService.Load(configPath, config); err != nil {</span></div><div class="token-line"><span class="token plain">             return err</span></div><div class="token-line"><span class="token plain">          }</span></div><div class="token-line"><span class="token plain">          return nil</span></div><div class="token-line"><span class="token plain">       }</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>现在，对于使用者来说，要初始化一个配置路径为database.default的数据库，就可以这么使用：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">gormService := c.MustMake(contract.ORMKey).(contract.ORMService)</span></div><div class="token-line"><span class="token plain">    db, err := gormService.GetDB(orm.WithConfigPath(&quot;database.default&quot;), orm.WithDryRun())</span></div></pre></div><h3 id="日志"><a aria-hidden="true" tabindex="-1" href="/blog/手把手带你写一个web框架/04.实战第3关完善功能/09#日志"><span class="icon icon-link"></span></a>日志</h3><p>配置项设计清楚了，我们再来思考下日志这块。上一章介绍过了，Gorm是有自己的输出规范的，在初始化参数 gorm.Config 中定义了一个日志输出接口Interface。我们来仔细看下这个接口的定义：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">const (</span></div><div class="token-line"><span class="token plain">       Silent LogLevel = iota + 1</span></div><div class="token-line"><span class="token plain">       Error</span></div><div class="token-line"><span class="token plain">       Warn</span></div><div class="token-line"><span class="token plain">       Info</span></div><div class="token-line"><span class="token plain">    )</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    // Interface logger interface</span></div><div class="token-line"><span class="token plain">    type Interface interface {</span></div><div class="token-line"><span class="token plain">       LogMode(LogLevel) Interface // 日志级别</span></div><div class="token-line"><span class="token plain">       Info(context.Context, string, ...interface{})</span></div><div class="token-line"><span class="token plain">       Warn(context.Context, string, ...interface{})</span></div><div class="token-line"><span class="token plain">       Error(context.Context, string, ...interface{})</span></div><div class="token-line"><span class="token plain">       Trace(ctx context.Context, begin time.Time, fc func() (sql string, rowsAffected int64), err error)</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>Gorm接口的日志级别分类比较简单：Info、Warn、Error、Trace。恰巧，这几个日志级别都在我们hade框架定义的7个日志级别中，所以完全可以将Gorm的这几个级别，映射到hade的日志级别中。也就是说，Gorm打印的Info级别日志输出到hade的Info日志中、error日志输出到hade的error日志中。</p><p>至于Gorm提供的一个LogMode来调整日志级别，由于我们的hade框架已经可以通过配置进行日志级别设置了，所以LogMode函数对我们来说是没有什么意义的。</p><p>好，了解Gorm的日志接口之后，我们明确了接下来要做的事情：<strong>实现一个Gorm的日志实现类，但是这个日志实现类中的每个方法都用 hade 的日志服务来实现</strong>。</p><p>我们在framework/provider/orm/logger.go中定义一个OrmLogger结构，它带有一个logger属性，这个logger属性存放的是hade容器中的log服务：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// OrmLogger orm的日志实现类, 实现了gorm.Logger.Interface</span></div><div class="token-line"><span class="token plain">    type OrmLogger struct {</span></div><div class="token-line"><span class="token plain">       logger contract.Log // 有一个logger对象存放hade的log服务</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    // NewOrmLogger 初始化一个ormLogger,</span></div><div class="token-line"><span class="token plain">    func NewOrmLogger(logger contract.Log) *OrmLogger {</span></div><div class="token-line"><span class="token plain">       return &amp;OrmLogger{logger: logger}</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>它实现了Gorm的Logger.Interface 接口。其中LogMode什么都不做，Info、Error、Warn、Trace 分别对应hade容器中log服务的Info、Error、Warn、Trace方法：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// Info 对接hade的info输出</span></div><div class="token-line"><span class="token plain">    func (o *OrmLogger) Info(ctx context.Context, s string, i ...interface{}) {</span></div><div class="token-line"><span class="token plain">       fields := map[string]interface{}{</span></div><div class="token-line"><span class="token plain">          &quot;fields&quot;: i,</span></div><div class="token-line"><span class="token plain">       }</span></div><div class="token-line"><span class="token plain">       o.logger.Info(ctx, s, fields)</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    // Warn 对接hade的Warn输出</span></div><div class="token-line"><span class="token plain">    func (o *OrmLogger) Warn(ctx context.Context, s string, i ...interface{}) {</span></div><div class="token-line"><span class="token plain">       fields := map[string]interface{}{</span></div><div class="token-line"><span class="token plain">          &quot;fields&quot;: i,</span></div><div class="token-line"><span class="token plain">       }</span></div><div class="token-line"><span class="token plain">       o.logger.Warn(ctx, s, fields)</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    // Error 对接hade的Error输出</span></div><div class="token-line"><span class="token plain">    func (o *OrmLogger) Error(ctx context.Context, s string, i ...interface{}) {</span></div><div class="token-line"><span class="token plain">       fields := map[string]interface{}{</span></div><div class="token-line"><span class="token plain">          &quot;fields&quot;: i,</span></div><div class="token-line"><span class="token plain">       }</span></div><div class="token-line"><span class="token plain">       o.logger.Error(ctx, s, fields)</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    // Trace 对接hade的Trace输出</span></div><div class="token-line"><span class="token plain">    func (o *OrmLogger) Trace(ctx context.Context, begin time.Time, fc func() (sql string, rowsAffected int64), err error) {</span></div><div class="token-line"><span class="token plain">       sql, rows := fc()</span></div><div class="token-line"><span class="token plain">       elapsed := time.Since(begin)</span></div><div class="token-line"><span class="token plain">       fields := map[string]interface{}{</span></div><div class="token-line"><span class="token plain">          &quot;begin&quot;: begin,</span></div><div class="token-line"><span class="token plain">          &quot;error&quot;: err,</span></div><div class="token-line"><span class="token plain">          &quot;sql&quot;:   sql,</span></div><div class="token-line"><span class="token plain">          &quot;rows&quot;:  rows,</span></div><div class="token-line"><span class="token plain">          &quot;time&quot;:  elapsed,</span></div><div class="token-line"><span class="token plain">       }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">       s := &quot;orm trace sql&quot;</span></div><div class="token-line"><span class="token plain">       o.logger.Trace(ctx, s, fields)</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>这里稍微注意下Trace方法，Gorm的Trace方法的参数中有传递时间戳begin，这个时间戳代表SQL执行的开始时间，而在函数中使用time.Now获取到当前时间之后，两个相减，我们可以获取到这个SQL的实际执行时间，然后作为hade 日志服务的fields map的一个字段输出。除了Trace，其他几个基本上简单封装hade的日志服务方法就好了。</p><h3 id="服务实例"><a aria-hidden="true" tabindex="-1" href="/blog/手把手带你写一个web框架/04.实战第3关完善功能/09#服务实例"><span class="icon icon-link"></span></a>服务实例</h3><p>好了，到现在Gorm的配置结构和日志结构也完成了。万事俱备，下面我们就开始写具体的ORM服务的实例 HadeGorm，在framework/provider/orm/service.go中。</p><p>首先，定义实现contract.ORMService的结构HadeGorm。要明确一点，我们会使用这个结构来生成不同数据库的gorm.DB结构，<strong>所以这个HadeGorm是一个与某个数据库设置无关的结构，而且它应该对单个数据库是一个单例模式</strong>，即在一个服务中，我从HadeGorm两次获取到的default数据库的gorm.DB是同一个。</p><p>设置HadeGrom结构如下：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// HadeGorm 代表hade框架的orm实现</span></div><div class="token-line"><span class="token plain">    type HadeGorm struct {</span></div><div class="token-line"><span class="token plain">       container framework.Container // 服务容器</span></div><div class="token-line"><span class="token plain">       dbs       map[string]*gorm.DB // key为dsn, value为gorm.DB（连接池）</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">       lock *sync.RWMutex</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>dbs就是为了单例存在，它的key直接设计为一个string，也就是连接数据库的DSN字符串，而value就是gorm.DB结构。</p><p>这样我们在拿到一个DSN的时候，从这个map中就能判断出是否已经实例化过这个数据库对应的gorm.DB了；如果没有实例化过，就实例化一个gorm.DB，并且将这个实例挂到这个map中。<strong>不过这个逻辑会对dbs有并发修改操作，所以这里要使用一个读写锁来锁住这个dbs的修改</strong>。</p><p>对应实例化HadeGorm的方法为NewHadeGorm，它的具体实现就是初始化HadeGorm中的每个字段。继续写入这段：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// NewHadeGorm 代表实例化Gorm</span></div><div class="token-line"><span class="token plain">    func NewHadeGorm(params ...interface{}) (interface{}, error) {</span></div><div class="token-line"><span class="token plain">       container := params[0].(framework.Container)</span></div><div class="token-line"><span class="token plain">       dbs := make(map[string]*gorm.DB)</span></div><div class="token-line"><span class="token plain">       lock := &amp;sync.RWMutex{}</span></div><div class="token-line"><span class="token plain">       return &amp;HadeGorm{</span></div><div class="token-line"><span class="token plain">          container: container,</span></div><div class="token-line"><span class="token plain">          dbs:       dbs,</span></div><div class="token-line"><span class="token plain">          lock:      lock,</span></div><div class="token-line"><span class="token plain">       }, nil</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>重头戏在GetDB方法的实现上。</p><p>首先初始化orm.Config，其中包括从配置中获取设置项，也包括初始化内部的Gorm；然后将GetDB的option参数作用于初始化的orm.Config，修改默认配置；通过orm.Config生成DSN字符串。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// 读取默认配置</span></div><div class="token-line"><span class="token plain">        config := GetBaseConfig(app.container)</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        logService := app.container.MustMake(contract.LogKey).(contract.Log)</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        // 设置Logger</span></div><div class="token-line"><span class="token plain">        ormLogger := NewOrmLogger(logService)</span></div><div class="token-line"><span class="token plain">        config.Config = &amp;gorm.Config{</span></div><div class="token-line"><span class="token plain">            Logger: ormLogger,</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        // option对opt进行修改</span></div><div class="token-line"><span class="token plain">        for _, opt := range option {</span></div><div class="token-line"><span class="token plain">            if err := opt(app.container, config); err != nil {</span></div><div class="token-line"><span class="token plain">                return nil, err</span></div><div class="token-line"><span class="token plain">            }</span></div><div class="token-line"><span class="token plain">        }</span></div></pre></div><p><strong>之后根据dsn字符串判断数据库实例gorm.DB是否已经存在了</strong>。如果存在直接返回gorm.DB，如果不存在需要实例化gorm.DB，这一步逻辑稍微复杂一点：</p><ul><li>根据配置项orm.Config中的不同驱动，来实例化gorm.DB（支持MySQL/Postgres/SQLite/SQL Server/ClickHouse）</li><li>根据配置项orm.Config中的连接池配置，设置gorm.DB的连接池</li><li>将实例化后的gorm.DB和DSN放入map映射中</li><li>返回实例化后的gorm.DB</li></ul><p>代码如下：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// 如果最终的config没有设置dsn,就生成dsn</span></div><div class="token-line"><span class="token plain">        if config.Dsn == &quot;&quot; {</span></div><div class="token-line"><span class="token plain">            dsn, err := config.FormatDsn()</span></div><div class="token-line"><span class="token plain">            if err != nil {</span></div><div class="token-line"><span class="token plain">                return nil, err</span></div><div class="token-line"><span class="token plain">            }</span></div><div class="token-line"><span class="token plain">            config.Dsn = dsn</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        // 判断是否已经实例化了gorm.DB</span></div><div class="token-line"><span class="token plain">        app.lock.RLock()</span></div><div class="token-line"><span class="token plain">        if db, ok := app.dbs[config.Dsn]; ok {</span></div><div class="token-line"><span class="token plain">            app.lock.RUnlock()</span></div><div class="token-line"><span class="token plain">            return db, nil</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        app.lock.RUnlock()</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        // 没有实例化gorm.DB，那么就要进行实例化操作</span></div><div class="token-line"><span class="token plain">        app.lock.Lock()</span></div><div class="token-line"><span class="token plain">        defer app.lock.Unlock()</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        // 实例化gorm.DB</span></div><div class="token-line"><span class="token plain">        var db *gorm.DB</span></div><div class="token-line"><span class="token plain">        var err error</span></div><div class="token-line"><span class="token plain">        switch config.Driver {</span></div><div class="token-line"><span class="token plain">        case &quot;mysql&quot;:</span></div><div class="token-line"><span class="token plain">            db, err = gorm.Open(mysql.Open(config.Dsn), config)</span></div><div class="token-line"><span class="token plain">        case &quot;postgres&quot;:</span></div><div class="token-line"><span class="token plain">            db, err = gorm.Open(postgres.Open(config.Dsn), config)</span></div><div class="token-line"><span class="token plain">        case &quot;sqlite&quot;:</span></div><div class="token-line"><span class="token plain">            db, err = gorm.Open(sqlite.Open(config.Dsn), config)</span></div><div class="token-line"><span class="token plain">        case &quot;sqlserver&quot;:</span></div><div class="token-line"><span class="token plain">            db, err = gorm.Open(sqlserver.Open(config.Dsn), config)</span></div><div class="token-line"><span class="token plain">        case &quot;clickhouse&quot;:</span></div><div class="token-line"><span class="token plain">            db, err = gorm.Open(clickhouse.Open(config.Dsn), config)</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        // 设置对应的连接池配置</span></div><div class="token-line"><span class="token plain">        sqlDB, err := db.DB()</span></div><div class="token-line"><span class="token plain">        if err != nil {</span></div><div class="token-line"><span class="token plain">            return db, err</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        if config.ConnMaxIdle &gt; 0 {</span></div><div class="token-line"><span class="token plain">            sqlDB.SetMaxIdleConns(config.ConnMaxIdle)</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        if config.ConnMaxOpen &gt; 0 {</span></div><div class="token-line"><span class="token plain">            sqlDB.SetMaxOpenConns(config.ConnMaxOpen)</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        if config.ConnMaxLifetime != &quot;&quot; {</span></div><div class="token-line"><span class="token plain">            liftTime, err := time.ParseDuration(config.ConnMaxLifetime)</span></div><div class="token-line"><span class="token plain">            if err != nil {</span></div><div class="token-line"><span class="token plain">                logger.Error(context.Background(), &quot;conn max lift time error&quot;, map[string]interface{}{</span></div><div class="token-line"><span class="token plain">                    &quot;err&quot;: err,</span></div><div class="token-line"><span class="token plain">                })</span></div><div class="token-line"><span class="token plain">            } else {</span></div><div class="token-line"><span class="token plain">                sqlDB.SetConnMaxLifetime(liftTime)</span></div><div class="token-line"><span class="token plain">            }</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        if config.ConnMaxIdletime != &quot;&quot; {</span></div><div class="token-line"><span class="token plain">            idleTime, err := time.ParseDuration(config.ConnMaxIdletime)</span></div><div class="token-line"><span class="token plain">            if err != nil {</span></div><div class="token-line"><span class="token plain">                logger.Error(context.Background(), &quot;conn max idle time error&quot;, map[string]interface{}{</span></div><div class="token-line"><span class="token plain">                    &quot;err&quot;: err,</span></div><div class="token-line"><span class="token plain">                })</span></div><div class="token-line"><span class="token plain">            } else {</span></div><div class="token-line"><span class="token plain">                sqlDB.SetConnMaxIdleTime(idleTime)</span></div><div class="token-line"><span class="token plain">            }</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        // 挂载到map中，结束配置</span></div><div class="token-line"><span class="token plain">        if err != nil {</span></div><div class="token-line"><span class="token plain">            app.dbs[config.Dsn] = db</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        return db, err</span></div></pre></div><p>如果前面的内容都理解了，这段代码实现也没有什么难点了。唯一要注意的地方就是锁的使用，<strong>由于对存在gorm.DB的map是读多写少，所以这里也是使用读写锁</strong>，在读取的时候加了一个读锁，如果map中没有我们要的gorm.DB，先把读锁解开，再加一个写锁，初始化完gorm.DB、保存进入map映射后，再把写锁解开。这样能有效防止对map的并发读写。</p><p>完整的GetDB方法可以参考GitHub上的<a target="_blank" rel="noopener noreferrer" href="https://github.com/gohade/coredemo/blob/geekbang/26/framework/provider/orm/service.go">framework/provider/orm/service.go<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>。</p><p>最后记得去业务代码main.go中，把我们的GormProvider注入服务容器：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">func main() {</span></div><div class="token-line"><span class="token plain">       // 初始化服务容器</span></div><div class="token-line"><span class="token plain">       container := framework.NewHadeContainer()</span></div><div class="token-line"><span class="token plain">       ...</span></div><div class="token-line"><span class="token plain">       container.Bind(&amp;orm.GormProvider{})</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">       ...</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">       // 运行root命令</span></div><div class="token-line"><span class="token plain">       console.RunCommand(container)</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>整个Gorm就已经结合到hade框架中了。</p><h2 id="测试"><a aria-hidden="true" tabindex="-1" href="/blog/手把手带你写一个web框架/04.实战第3关完善功能/09#测试"><span class="icon icon-link"></span></a>测试</h2><p>下面来做一下测试。我们用真实的MySQL进行测试。当然你需要在本机/远端/Docker搭建一个MySQL，至于怎么搭建，教程网上有很多了，这里就不详细描述。</p><p>我用的是Mac，使用homebrew 能很方便搭建一个MySQL服务。我的MySQL实例搭建在本机的3306端口，并且搭建完成之后，我创建了一个coredemo的database数据库：<br/><img src="https://static001.geekbang.org/resource/image/e8/68/e81e9f92ea1fe6e27edd3d819f577268.png?wh=1836x1388" alt=""/></p><p>所以我的配置文件config/development/database.yaml配置如下：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">conn_max_idle: 10 # 通用配置，连接池最大空闲连接数</span></div><div class="token-line"><span class="token plain">    conn_max_open: 100 # 通用配置，连接池最大连接数</span></div><div class="token-line"><span class="token plain">    conn_max_lifetime: 1h # 通用配置，连接数最大生命周期</span></div><div class="token-line"><span class="token plain">    protocol: tcp # 通用配置，传输协议</span></div><div class="token-line"><span class="token plain">    loc: Local # 通用配置，时区</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    default:</span></div><div class="token-line"><span class="token plain">        driver: mysql # 连接驱动</span></div><div class="token-line"><span class="token plain">        dsn: &quot;&quot; # dsn，如果设置了dsn, 以下的所有设置都不生效</span></div><div class="token-line"><span class="token plain">        host: localhost # ip地址</span></div><div class="token-line"><span class="token plain">        port: 3306 # 端口</span></div><div class="token-line"><span class="token plain">        database: coredemo # 数据库</span></div><div class="token-line"><span class="token plain">        username: jianfengye # 用户名</span></div><div class="token-line"><span class="token plain">        password: &quot;123456789&quot; # 密码</span></div><div class="token-line"><span class="token plain">        charset: utf8mb4 # 字符集</span></div><div class="token-line"><span class="token plain">        collation: utf8mb4_unicode_ci # 字符序</span></div><div class="token-line"><span class="token plain">        timeout: 10s # 连接超时</span></div><div class="token-line"><span class="token plain">        read_timeout: 2s # 读超时</span></div><div class="token-line"><span class="token plain">        write_timeout: 2s # 写超时</span></div><div class="token-line"><span class="token plain">        parse_time: true # 是否解析时间</span></div><div class="token-line"><span class="token plain">        protocol: tcp # 传输协议</span></div><div class="token-line"><span class="token plain">        loc: Local # 时区</span></div></pre></div><p>我们想在coredemo数据库中增加一个user表，按照Gorm的规范，需要先定义一个数据结构User。在app/http/module/demo/model.go中：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// User is gorm model</span></div><div class="token-line"><span class="token plain">    type User struct {</span></div><div class="token-line"><span class="token plain">       ID           uint</span></div><div class="token-line"><span class="token plain">       Name         string</span></div><div class="token-line"><span class="token plain">       Email        *string</span></div><div class="token-line"><span class="token plain">       Age          uint8</span></div><div class="token-line"><span class="token plain">       Birthday     *time.Time</span></div><div class="token-line"><span class="token plain">       MemberNumber sql.NullString</span></div><div class="token-line"><span class="token plain">       ActivatedAt  sql.NullTime</span></div><div class="token-line"><span class="token plain">       CreatedAt    time.Time</span></div><div class="token-line"><span class="token plain">       UpdatedAt    time.Time</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>然后在应用目录app/http/module/demo/api_orm.go中，定义了一个新的路由方法DemoOrm，在这个方法中，我们先从容器中获取到gorm.DB的实例，然后使用db.AutoMigrate 同步数据表user。</p><p>如果第一次执行的时候，数据库中没有表user，它会自动创建user表，然后分别调用db.Create、db.Save、db.First、db.Delete来对user表进行增删改查操作：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// DemoOrm Orm的路由方法</span></div><div class="token-line"><span class="token plain">    func (api *DemoApi) DemoOrm(c *gin.Context) {</span></div><div class="token-line"><span class="token plain">        logger := c.MustMakeLog()</span></div><div class="token-line"><span class="token plain">        logger.Info(c, &quot;request start&quot;, nil)</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        // 初始化一个orm.DB</span></div><div class="token-line"><span class="token plain">        gormService := c.MustMake(contract.ORMKey).(contract.ORMService)</span></div><div class="token-line"><span class="token plain">        db, err := gormService.GetDB(orm.WithConfigPath(&quot;database.default&quot;))</span></div><div class="token-line"><span class="token plain">        if err != nil {</span></div><div class="token-line"><span class="token plain">            logger.Error(c, err.Error(), nil)</span></div><div class="token-line"><span class="token plain">            c.AbortWithError(50001, err)</span></div><div class="token-line"><span class="token plain">            return</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        db.WithContext(c)</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        // 将User模型创建到数据库中</span></div><div class="token-line"><span class="token plain">        err = db.AutoMigrate(&amp;User{})</span></div><div class="token-line"><span class="token plain">        if err != nil {</span></div><div class="token-line"><span class="token plain">            c.AbortWithError(500, err)</span></div><div class="token-line"><span class="token plain">            return</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        logger.Info(c, &quot;migrate ok&quot;, nil)</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        // 插入一条数据</span></div><div class="token-line"><span class="token plain">        email := &quot;foo@gmail.com&quot;</span></div><div class="token-line"><span class="token plain">        name := &quot;foo&quot;</span></div><div class="token-line"><span class="token plain">        age := uint8(25)</span></div><div class="token-line"><span class="token plain">        birthday := time.Date(2001, 1, 1, 1, 1, 1, 1, time.Local)</span></div><div class="token-line"><span class="token plain">        user := &amp;User{</span></div><div class="token-line"><span class="token plain">            Name:         name,</span></div><div class="token-line"><span class="token plain">            Email:        &amp;email,</span></div><div class="token-line"><span class="token plain">            Age:          age,</span></div><div class="token-line"><span class="token plain">            Birthday:     &amp;birthday,</span></div><div class="token-line"><span class="token plain">            MemberNumber: sql.NullString{},</span></div><div class="token-line"><span class="token plain">            ActivatedAt:  sql.NullTime{},</span></div><div class="token-line"><span class="token plain">            CreatedAt:    time.Now(),</span></div><div class="token-line"><span class="token plain">            UpdatedAt:    time.Now(),</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        err = db.Create(user).Error</span></div><div class="token-line"><span class="token plain">        logger.Info(c, &quot;insert user&quot;, map[string]interface{}{</span></div><div class="token-line"><span class="token plain">            &quot;id&quot;:  user.ID,</span></div><div class="token-line"><span class="token plain">            &quot;err&quot;: err,</span></div><div class="token-line"><span class="token plain">        })</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        // 更新一条数据</span></div><div class="token-line"><span class="token plain">        user.Name = &quot;bar&quot;</span></div><div class="token-line"><span class="token plain">        err = db.Save(user).Error</span></div><div class="token-line"><span class="token plain">        logger.Info(c, &quot;update user&quot;, map[string]interface{}{</span></div><div class="token-line"><span class="token plain">            &quot;err&quot;: err,</span></div><div class="token-line"><span class="token plain">            &quot;id&quot;:  user.ID,</span></div><div class="token-line"><span class="token plain">        })</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        // 查询一条数据</span></div><div class="token-line"><span class="token plain">        queryUser := &amp;User{ID: user.ID}</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        err = db.First(queryUser).Error</span></div><div class="token-line"><span class="token plain">        logger.Info(c, &quot;query user&quot;, map[string]interface{}{</span></div><div class="token-line"><span class="token plain">            &quot;err&quot;:  err,</span></div><div class="token-line"><span class="token plain">            &quot;name&quot;: queryUser.Name,</span></div><div class="token-line"><span class="token plain">        })</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        // 删除一条数据</span></div><div class="token-line"><span class="token plain">        err = db.Delete(queryUser).Error</span></div><div class="token-line"><span class="token plain">        logger.Info(c, &quot;delete user&quot;, map[string]interface{}{</span></div><div class="token-line"><span class="token plain">            &quot;err&quot;: err,</span></div><div class="token-line"><span class="token plain">            &quot;id&quot;:  user.ID,</span></div><div class="token-line"><span class="token plain">        })</span></div><div class="token-line"><span class="token plain">        c.JSON(200, &quot;ok&quot;)</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>记得修改app/http/module/demo/api.go中的路由注册：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">func Register(r *gin.Engine) error {</span></div><div class="token-line"><span class="token plain">       api := NewDemoApi()</span></div><div class="token-line"><span class="token plain">       ...</span></div><div class="token-line"><span class="token plain">       r.GET(&quot;/demo/orm&quot;, api.DemoOrm)</span></div><div class="token-line"><span class="token plain">       return nil</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>现在，使用 <code>./hade build self</code> 来重新编译hade文件，使用 <code>./hade app start</code> 启动服务，并挂起在控制台，日志会输出到控制台。浏览器调用 <a target="_blank" rel="noopener noreferrer" href="http://localhost:8888/demo/orm">http://localhost:8888/demo/orm<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> ，控制台打印日志如下：<br/><img src="https://static001.geekbang.org/resource/image/1f/a0/1f7ec4246a851faa3e4f6c9eebfbbda0.png?wh=1920x559" alt=""/></p><p>可以清晰地通过trace日志看到底层的Insert/Update/Select/Delete的操作，并且可以通过time字段看到这个请求的具体耗时。到这里Gorm融合hade框架就验证完成了。</p><p>本节课我们主要修改了framework目录下的contract/orm.go 和 provider/orm 目录。目录截图如下，供对比查看，所有代码都已经上传到<a target="_blank" rel="noopener noreferrer" href="https://github.com/gohade/coredemo/tree/geekbang/25">geekbang/25<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>分支了。<br/><img src="https://static001.geekbang.org/resource/image/07/00/071144ba671c077937f76a9627263000.png?wh=922x1618" alt=""/></p><h3 id="小结"><a aria-hidden="true" tabindex="-1" href="/blog/手把手带你写一个web框架/04.实战第3关完善功能/09#小结"><span class="icon icon-link"></span></a>小结</h3><p>对于Gorm这样比较庞大的库，要把Gorm完美集成到hade框架，更好地支持业务对数据库频繁的增删改查操作，我们并不是一开始就动手修改代码，而是先把Gorm的实例化部分的源码都理清楚了，再动手集成才不会出现问题。</p><p>现在我们可以在hade框架中方便获取到gorm.DB了。但是在具体开发业务的时候，如何使用好Gorm来为业务服务，也是一个非常值得花心思研究的课题。好在我们的技术选型是目前Golang业界最火的Gorm，网络上关于如何使用Gorm的课程有非常多了，在具体开发业务的时候，你可以自己参考和研究。</p><h3 id="思考题"><a aria-hidden="true" tabindex="-1" href="/blog/手把手带你写一个web框架/04.实战第3关完善功能/09#思考题"><span class="icon icon-link"></span></a>思考题</h3><p>在ORM框架中，model层的存放位置一直是个很有争论的话题。比如geekbang/25 分支上model层的User结构，我存放在app/http/module/demo中，有同学会觉得model层放在 app/http/model目录比较好么？具体model是否应该单独作为一个文件夹出来呢？</p><p>欢迎在留言区分享你的思考。感谢你的收听，如果你觉得今天的内容对你有所帮助，也欢迎分享给你身边的朋友，邀请他一起学习。我们下节课见～</p></div><div class="__dumi-default-layout-footer-meta"><a target="_blank" rel="noopener noreferrer" href="https://github.com/GGwujun/blog/edit/master/docs/手把手带你写一个Web框架/04.实战第3关完善功能/09.md">在 GitHub 上编辑此页<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a><span data-updated-text="最后更新时间：">5/2/2022 10:56:58</span></div></div></div></div>
	<script>
  window.g_useSSR = true;
  window.g_initialProps = {};
	</script>

    <script>
      (function () {
        if (!location.port) {
          (function (i, s, o, g, r, a, m) {
            i["GoogleAnalyticsObject"] = r;
            (i[r] =
              i[r] ||
              function () {
                (i[r].q = i[r].q || []).push(arguments);
              }),
              (i[r].l = 1 * new Date());
            (a = s.createElement(o)), (m = s.getElementsByTagName(o)[0]);
            a.async = 1;
            a.src = g;
            m.parentNode.insertBefore(a, m);
          })(
            window,
            document,
            "script",
            "//www.google-analytics.com/analytics.js",
            "ga"
          );
          ga("create", "UA-149864185-1", "auto");
          ga("send", "pageview");
        }
      })();
    </script>
    <script src="/blog/umi.js"></script>
  </body>
</html>
