<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no"
    />
    <link rel="shortcut icon" type="image/x-icon" href="/logo.png" />
    <link rel="stylesheet" href="/blog/umi.css" />
    <script>
      window.routerBase = "/blog";
    </script>
    <script>
      //! umi version: 3.5.17
    </script>
    <script>
      !(function () {
        var e = localStorage.getItem("dumi:prefers-color"),
          t = window.matchMedia("(prefers-color-scheme: dark)").matches,
          r = ["light", "dark", "auto"];
        document.documentElement.setAttribute(
          "data-prefers-color",
          e === r[2] ? (t ? r[1] : r[0]) : r.indexOf(e) > -1 ? e : r[0]
        );
      })();
    </script>
    <title>19｜提效（上）：实现调试模式加速开发效率</title>
  </head>
  <body>
    <div id="root"><div class="__dumi-default-layout" data-route="/手把手带你写一个web框架/04.实战第3关完善功能/02" data-show-sidemenu="true" data-show-slugs="true" data-site-mode="true" data-gapless="false"><div class="__dumi-default-navbar" data-mode="site"><button class="__dumi-default-navbar-toggle"></button><a class="__dumi-default-navbar-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog/">大师兄</a><nav><div class="__dumi-default-search"><input type="search" class="__dumi-default-search-input" value=""/><ul></ul></div><span>计算机基础<ul><li><a href="/blog/编译原理之美">编译原理之美</a></li><li><a href="/blog/编译原理实战">编译原理实战</a></li><li><a href="/blog/深入浅出计算机组成原理">深入浅出计算机组成原理</a></li><li><a href="/blog/详解http">详解http</a></li><li><a href="/blog/计算机网络通关29讲">计算机网络通关29讲</a></li><li><a href="/blog/网络排查案例课">网络排查案例课</a></li><li><a href="/blog/linux操作系统">linux操作系统</a></li><li><a href="/blog/linux性能优化实战">linux性能优化实战</a></li><li><a href="/blog/程序员数学基础">程序员数学基础</a></li><li><a href="/blog/趣谈网络协议">趣谈网络协议</a></li><li><a href="/blog/操作系统实战">操作系统实战</a></li><li><a href="/blog/软件工程之美">软件工程之美</a></li><li><a href="/blog/sql必知必会">sql必知必会</a></li><li><a href="/blog/操作系统实战45讲">操作系统实战45讲</a></li><li><a href="/blog/网络编程实战">网络编程实战</a></li></ul></span><span>算法<ul><li><a href="/blog/常用算法25讲">常用算法25讲</a></li><li><a href="/blog/数据结构与算法之美">数据结构与算法之美</a></li><li><a href="/blog/业务开发算法50讲">业务开发算法50讲</a></li><li><a href="/blog/动态规划面试宝典">动态规划面试宝典</a></li></ul></span><span>前端开发<ul><li><a href="/blog/浏览器工作原理与实践">浏览器工作原理与实践</a></li><li><a href="/blog/新时代产品经理进阶之路">新时代产品经理进阶之路</a></li><li><a href="/blog/全栈工程师修炼指南">全栈工程师修炼指南</a></li><li><a href="/blog/flutter核心技术与实战">flutter核心技术与实战</a></li><li><a href="/blog/java-script核心原理解析">java-script核心原理解析</a></li><li><a href="/blog/说透低代码">说透低代码</a></li><li><a href="/blog/nodejs应用开发实战">nodejs应用开发实战</a></li><li><a href="/blog/反爬虫兵法演绎20讲">反爬虫兵法演绎20讲</a></li><li><a href="/blog/reactnative新架构实战课">reactnative新架构实战课</a></li><li><a href="/blog/正则表达式入门">正则表达式入门</a></li><li><a href="/blog/重学前端">重学前端</a></li><li><a href="/blog/serverless入门课">serverless入门课</a></li><li><a href="/blog/type-script入门实战笔记">type-script入门实战笔记</a></li><li><a href="/blog/图解googlev8">图解googlev8</a></li><li><a href="/blog/vue3源码分析">vue3源码分析</a></li><li><a href="/blog/玩转Vue3全家桶">玩转Vue3全家桶</a></li><li><a href="/blog/webassembly入门">webassembly入门</a></li><li><a aria-current="page" class="active" href="/blog/手把手带你写一个Web框架">手把手带你写一个Web框架</a></li><li><a href="/blog/web漏洞挖掘实战">web漏洞挖掘实战</a></li><li><a href="/blog/跟月影学可视化">跟月影学可视化</a></li><li><a href="/blog/搞定音频技术">搞定音频技术</a></li><li><a href="/blog/攻克视频技术">攻克视频技术</a></li></ul></span><span>前端工程化<ul><li><a href="/blog/logger">logger</a></li><li><a href="/blog/webpack">webpack</a></li><li><a href="/blog/webpackChain">webpackChain</a></li></ul></span><span>前端性能优化<ul><li><a href="/blog/react性能调优">react性能调优</a></li></ul></span><span>软件测试<ul><li><a href="/blog/全链路压测实战30讲">全链路压测实战30讲</a></li><li><a href="/blog/性能测试实战30讲">性能测试实战30讲</a></li><li><a href="/blog/自动化测试高手课">自动化测试高手课</a></li><li><a href="/blog/软件测试52讲">软件测试52讲</a></li></ul></span><span>面试<ul><li><a href="/blog/面试现场">面试现场</a></li></ul></span><span>杂谈<ul><li><a href="/blog/超级访谈对话张雪峰">超级访谈对话张雪峰</a></li><li><a href="/blog/Git实战手册">Git实战手册</a></li><li><a href="/blog/NodeJS">NodeJS</a></li><li><a href="/blog/ReactJS">ReactJS</a></li><li><a href="/blog/UI设计">UI设计</a></li><li><a href="/blog/webpack4系列教程">webpack4系列教程</a></li><li><a href="/blog/前端知识体系">前端知识体系</a></li><li><a href="/blog/剑指offer刷题笔记">剑指offer刷题笔记</a></li><li><a href="/blog/思考与成长">思考与成长</a></li><li><a href="/blog/设计模式手册">设计模式手册</a></li></ul></span><div class="__dumi-default-navbar-tool"><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "></div></div></div></nav></div><div class="__dumi-default-menu" data-mode="site"><div class="__dumi-default-menu-inner"><div class="__dumi-default-menu-header"><a class="__dumi-default-menu-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog/"></a><h1>大师兄</h1><p></p></div><div class="__dumi-default-menu-mobile-area"><ul class="__dumi-default-menu-nav-list"><li>计算机基础<ul><li><a href="/blog/编译原理之美">编译原理之美</a></li><li><a href="/blog/编译原理实战">编译原理实战</a></li><li><a href="/blog/深入浅出计算机组成原理">深入浅出计算机组成原理</a></li><li><a href="/blog/详解http">详解http</a></li><li><a href="/blog/计算机网络通关29讲">计算机网络通关29讲</a></li><li><a href="/blog/网络排查案例课">网络排查案例课</a></li><li><a href="/blog/linux操作系统">linux操作系统</a></li><li><a href="/blog/linux性能优化实战">linux性能优化实战</a></li><li><a href="/blog/程序员数学基础">程序员数学基础</a></li><li><a href="/blog/趣谈网络协议">趣谈网络协议</a></li><li><a href="/blog/操作系统实战">操作系统实战</a></li><li><a href="/blog/软件工程之美">软件工程之美</a></li><li><a href="/blog/sql必知必会">sql必知必会</a></li><li><a href="/blog/操作系统实战45讲">操作系统实战45讲</a></li><li><a href="/blog/网络编程实战">网络编程实战</a></li></ul></li><li>算法<ul><li><a href="/blog/常用算法25讲">常用算法25讲</a></li><li><a href="/blog/数据结构与算法之美">数据结构与算法之美</a></li><li><a href="/blog/业务开发算法50讲">业务开发算法50讲</a></li><li><a href="/blog/动态规划面试宝典">动态规划面试宝典</a></li></ul></li><li>前端开发<ul><li><a href="/blog/浏览器工作原理与实践">浏览器工作原理与实践</a></li><li><a href="/blog/新时代产品经理进阶之路">新时代产品经理进阶之路</a></li><li><a href="/blog/全栈工程师修炼指南">全栈工程师修炼指南</a></li><li><a href="/blog/flutter核心技术与实战">flutter核心技术与实战</a></li><li><a href="/blog/java-script核心原理解析">java-script核心原理解析</a></li><li><a href="/blog/说透低代码">说透低代码</a></li><li><a href="/blog/nodejs应用开发实战">nodejs应用开发实战</a></li><li><a href="/blog/反爬虫兵法演绎20讲">反爬虫兵法演绎20讲</a></li><li><a href="/blog/reactnative新架构实战课">reactnative新架构实战课</a></li><li><a href="/blog/正则表达式入门">正则表达式入门</a></li><li><a href="/blog/重学前端">重学前端</a></li><li><a href="/blog/serverless入门课">serverless入门课</a></li><li><a href="/blog/type-script入门实战笔记">type-script入门实战笔记</a></li><li><a href="/blog/图解googlev8">图解googlev8</a></li><li><a href="/blog/vue3源码分析">vue3源码分析</a></li><li><a href="/blog/玩转Vue3全家桶">玩转Vue3全家桶</a></li><li><a href="/blog/webassembly入门">webassembly入门</a></li><li><a aria-current="page" class="active" href="/blog/手把手带你写一个Web框架">手把手带你写一个Web框架</a></li><li><a href="/blog/web漏洞挖掘实战">web漏洞挖掘实战</a></li><li><a href="/blog/跟月影学可视化">跟月影学可视化</a></li><li><a href="/blog/搞定音频技术">搞定音频技术</a></li><li><a href="/blog/攻克视频技术">攻克视频技术</a></li></ul></li><li>前端工程化<ul><li><a href="/blog/logger">logger</a></li><li><a href="/blog/webpack">webpack</a></li><li><a href="/blog/webpackChain">webpackChain</a></li></ul></li><li>前端性能优化<ul><li><a href="/blog/react性能调优">react性能调优</a></li></ul></li><li>软件测试<ul><li><a href="/blog/全链路压测实战30讲">全链路压测实战30讲</a></li><li><a href="/blog/性能测试实战30讲">性能测试实战30讲</a></li><li><a href="/blog/自动化测试高手课">自动化测试高手课</a></li><li><a href="/blog/软件测试52讲">软件测试52讲</a></li></ul></li><li>面试<ul><li><a href="/blog/面试现场">面试现场</a></li></ul></li><li>杂谈<ul><li><a href="/blog/超级访谈对话张雪峰">超级访谈对话张雪峰</a></li><li><a href="/blog/Git实战手册">Git实战手册</a></li><li><a href="/blog/NodeJS">NodeJS</a></li><li><a href="/blog/ReactJS">ReactJS</a></li><li><a href="/blog/UI设计">UI设计</a></li><li><a href="/blog/webpack4系列教程">webpack4系列教程</a></li><li><a href="/blog/前端知识体系">前端知识体系</a></li><li><a href="/blog/剑指offer刷题笔记">剑指offer刷题笔记</a></li><li><a href="/blog/思考与成长">思考与成长</a></li><li><a href="/blog/设计模式手册">设计模式手册</a></li></ul></li></ul><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "><button title="Dark theme" class="__dumi-default-dark-moon "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="3854" width="22" height="22"><path d="M991.816611 674.909091a69.166545 69.166545 0 0 0-51.665455-23.272727 70.795636 70.795636 0 0 0-27.438545 5.585454A415.674182 415.674182 0 0 1 754.993338 698.181818c-209.594182 0-393.472-184.785455-393.472-395.636363 0-52.363636 38.539636-119.621818 69.515637-173.614546 4.887273-8.610909 9.634909-16.756364 14.103272-24.901818A69.818182 69.818182 0 0 0 384.631156 0a70.842182 70.842182 0 0 0-27.438545 5.585455C161.678429 90.298182 14.362065 307.898182 14.362065 512c0 282.298182 238.824727 512 532.38691 512a522.286545 522.286545 0 0 0 453.957818-268.334545A69.818182 69.818182 0 0 0 991.816611 674.909091zM546.679156 954.181818c-248.785455 0-462.941091-192-462.941091-442.181818 0-186.647273 140.637091-372.829091 300.939637-442.181818-36.817455 65.629091-92.578909 151.970909-92.578909 232.727273 0 250.181818 214.109091 465.454545 462.917818 465.454545a488.331636 488.331636 0 0 0 185.181091-46.545455 453.003636 453.003636 0 0 1-393.565091 232.727273z m103.656728-669.323636l-14.266182 83.781818a34.909091 34.909091 0 0 0 50.362182 36.770909l74.775272-39.563636 74.752 39.563636a36.142545 36.142545 0 0 0 16.174546 3.956364 34.909091 34.909091 0 0 0 34.210909-40.727273l-14.289455-83.781818 60.509091-59.345455a35.025455 35.025455 0 0 0-19.223272-59.578182l-83.61891-12.101818-37.376-76.101818a34.56 34.56 0 0 0-62.254545 0l-37.376 76.101818-83.618909 12.101818a34.909091 34.909091 0 0 0-19.246546 59.578182z m70.423272-64.698182a34.280727 34.280727 0 0 0 26.135273-19.083636l14.312727-29.090909 14.336 29.090909a34.257455 34.257455 0 0 0 26.135273 19.083636l32.046546 4.887273-23.272728 22.574545a35.234909 35.234909 0 0 0-10.007272 30.952727l5.46909 32.116364-28.625454-15.127273a34.490182 34.490182 0 0 0-32.302546 0l-28.695272 15.127273 5.469091-32.116364a35.141818 35.141818 0 0 0-9.984-30.952727l-23.272728-22.574545z" p-id="3855"></path></svg></button><button title="Light theme" class="__dumi-default-dark-sun "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="4026" width="22" height="22"><path d="M915.2 476.16h-43.968c-24.704 0-44.736 16-44.736 35.84s20.032 35.904 44.736 35.904H915.2c24.768 0 44.8-16.064 44.8-35.904s-20.032-35.84-44.8-35.84zM512 265.6c-136.704 0-246.464 109.824-246.464 246.4 0 136.704 109.76 246.464 246.464 246.464S758.4 648.704 758.4 512c0-136.576-109.696-246.4-246.4-246.4z m0 425.6c-99.008 0-179.2-80.128-179.2-179.2 0-98.944 80.192-179.2 179.2-179.2S691.2 413.056 691.2 512c0 99.072-80.192 179.2-179.2 179.2zM197.44 512c0-19.84-19.136-35.84-43.904-35.84H108.8c-24.768 0-44.8 16-44.8 35.84s20.032 35.904 44.8 35.904h44.736c24.768 0 43.904-16.064 43.904-35.904zM512 198.464c19.776 0 35.84-20.032 35.84-44.8v-44.8C547.84 84.032 531.84 64 512 64s-35.904 20.032-35.904 44.8v44.8c0 24.768 16.128 44.864 35.904 44.864z m0 627.136c-19.776 0-35.904 20.032-35.904 44.8v44.736C476.096 940.032 492.16 960 512 960s35.84-20.032 35.84-44.8v-44.736c0-24.768-16.064-44.864-35.84-44.864z m329.92-592.832c17.472-17.536 20.288-43.072 6.4-57.024-14.016-14.016-39.488-11.2-57.024 6.336-4.736 4.864-26.496 26.496-31.36 31.36-17.472 17.472-20.288 43.008-6.336 57.024 13.952 14.016 39.488 11.2 57.024-6.336 4.8-4.864 26.496-26.56 31.296-31.36zM213.376 759.936c-4.864 4.8-26.56 26.624-31.36 31.36-17.472 17.472-20.288 42.944-6.4 56.96 14.016 13.952 39.552 11.2 57.024-6.336 4.8-4.736 26.56-26.496 31.36-31.36 17.472-17.472 20.288-43.008 6.336-56.96-14.016-13.952-39.552-11.072-56.96 6.336z m19.328-577.92c-17.536-17.536-43.008-20.352-57.024-6.336-14.08 14.016-11.136 39.488 6.336 57.024 4.864 4.864 26.496 26.56 31.36 31.424 17.536 17.408 43.008 20.288 56.96 6.336 14.016-14.016 11.264-39.488-6.336-57.024-4.736-4.864-26.496-26.56-31.296-31.424z m527.168 628.608c4.864 4.864 26.624 26.624 31.36 31.424 17.536 17.408 43.072 20.224 57.088 6.336 13.952-14.016 11.072-39.552-6.4-57.024-4.864-4.8-26.56-26.496-31.36-31.36-17.472-17.408-43.072-20.288-57.024-6.336-13.952 14.016-11.008 39.488 6.336 56.96z" p-id="4027"></path></svg></button><button title="Default to system" class="__dumi-default-dark-auto "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="11002" width="22" height="22"><path d="M127.658667 492.885333c0-51.882667 10.24-101.717333 30.378666-149.162666s47.786667-88.064 81.92-122.538667 75.093333-61.781333 122.538667-81.92 96.938667-30.378667 149.162667-30.378667 101.717333 10.24 149.162666 30.378667 88.405333 47.786667 122.88 81.92 61.781333 75.093333 81.92 122.538667 30.378667 96.938667 30.378667 149.162666-10.24 101.717333-30.378667 149.162667-47.786667 88.405333-81.92 122.88-75.093333 61.781333-122.88 81.92-97.28 30.378667-149.162666 30.378667-101.717333-10.24-149.162667-30.378667-88.064-47.786667-122.538667-81.92-61.781333-75.093333-81.92-122.88-30.378667-96.938667-30.378666-149.162667z m329.045333 0c0 130.048 13.994667 244.394667 41.984 343.381334h12.970667c46.762667 0 91.136-9.216 133.461333-27.306667s78.848-42.666667 109.568-73.386667 54.954667-67.242667 73.386667-109.568 27.306667-86.698667 27.306666-133.461333c0-46.421333-9.216-90.794667-27.306666-133.12s-42.666667-78.848-73.386667-109.568-67.242667-54.954667-109.568-73.386667-86.698667-27.306667-133.461333-27.306666h-11.605334c-28.672 123.562667-43.349333 237.909333-43.349333 343.722666z" p-id="11003"></path></svg></button></div></div></div><ul class="__dumi-default-menu-list"><li><a href="/blog/">大师兄 - 前端架构师</a></li></ul></div></div><ul role="slug-list" class="__dumi-default-layout-toc"><li title="方案思考和设计" data-depth="2"><a href="/blog/手把手带你写一个web框架/04.实战第3关完善功能/02#方案思考和设计"><span>方案思考和设计</span></a></li><li title="实现技术难点分析" data-depth="2"><a href="/blog/手把手带你写一个web框架/04.实战第3关完善功能/02#实现技术难点分析"><span>实现技术难点分析</span></a></li><li title="command 设计" data-depth="2"><a href="/blog/手把手带你写一个web框架/04.实战第3关完善功能/02#command-设计"><span>command 设计</span></a></li><li title="proxy 类的设计" data-depth="2"><a href="/blog/手把手带你写一个web框架/04.实战第3关完善功能/02#proxy-类的设计"><span>proxy 类的设计</span></a></li><li title="小结" data-depth="2"><a href="/blog/手把手带你写一个web框架/04.实战第3关完善功能/02#小结"><span>小结</span></a></li><li title="思考题" data-depth="2"><a href="/blog/手把手带你写一个web框架/04.实战第3关完善功能/02#思考题"><span>思考题</span></a></li></ul><div class="__dumi-default-layout-content"><div class="markdown"><h1 id="19提效上实现调试模式加速开发效率"><a aria-hidden="true" tabindex="-1" href="/blog/手把手带你写一个web框架/04.实战第3关完善功能/02#19提效上实现调试模式加速开发效率"><span class="icon icon-link"></span></a>19｜提效（上）：实现调试模式加速开发效率</h1><p>你好，我是轩脉刃。</p><p>上一节课我们把前端Vue融合进hade框架中，让框架能直接通过命令行启动包含前端和后端的一个应用，今天继续思考优化。</p><p>在使用Vue的时候，你一定使用过 <code>npm run dev</code> 这个命令，为前端开启调试模式，在这个模式下，只要你修改了src下的文件，编译器就会自动重新编译，并且更新浏览器页面上的渲染。这种调试模式，为开发者提高了不少开发效率。</p><p>那这种调试模式能否应用到Golang后端，让前后端都开启这种调试模式，来进一步提升我们开发应用的效率呢？接下来两节课，我们就来尝试实现这种调试模式。</p><h2 id="方案思考和设计"><a aria-hidden="true" tabindex="-1" href="/blog/手把手带你写一个web框架/04.实战第3关完善功能/02#方案思考和设计"><span class="icon icon-link"></span></a>方案思考和设计</h2><p>先来思考下调试模式应该怎么设计？因为分为前端和后端，关于Vue前端，既然已经有了 <code>npm run dev</code> 这种调试模式，自然可以直接使用这种方式，要改的主要就是后端。</p><p>对于后端Golang代码，Golang本身并没有提供任何调试模式的方式进行代码调试，<strong>只能先通过go build 编译出二进制文件，通过运行二进制文件再启动服务</strong>。那我们如何实现刚才的想法，一旦修改代码源文件，就能重新编译运行呢？</p><p>相信你一定很快想到了之前实现过配置文件的热更新。在第16章开发配置服务的时候，我们使用了 <a target="_blank" rel="noopener noreferrer" href="https://github.com/fsnotify/fsnotify">fsnotify<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 库，来对配置目录下的所有文件进行变更监听，一旦修改了配置目录下的文件，就重新更新内存中的配置文件map。</p><p>那这里是否可以如法炮制，将 AppPath 目录下的文件也进行监听呢？一旦这个目录下的文件有了变更，就重新编译运行后端服务？</p><p>是的，原理可行，我们完全可以按照这种想法来构想一下。现在假设我们<strong>监听了后端文件，能变更调试后端服务，也能通过Vue自带命令调试前端</strong>，但这里又遇到难点了，如果需要前后端服务同时调试呢？</p><p>前端启动调试模式的方式和我们之前的编译方式完全不一样，它是直接启动一个端口来服务，并没有在dist下生成最终编译文件。这样，我们上一章设计的后端直接代理最终编译文件的方法就无法使用了。怎么办？</p><p>虽然过程不一样，但启动后的行为是差不多的。后端，实现了监听文件重新编译启动后，也是启动了一个进程来提供服务。思考到这里，自然而然，我们就想到<strong>是否能在前端和后端服务的前面，设计一个反向代理proxy服务呢</strong>？</p><p><img src="https://static001.geekbang.org/resource/image/86/16/86d2c8a583a1dafa52ee79fb95f30616.jpg?wh=1920x1080" alt="图片"/></p><p>让所有外部请求进入这个反响代理服务，然后由反向代理服务进行代理分发，前端请求分发到前端进程，后端请求分发到后端进程。</p><p>方案思路很流畅，我们来看如何实现。</p><h2 id="实现技术难点分析"><a aria-hidden="true" tabindex="-1" href="/blog/手把手带你写一个web框架/04.实战第3关完善功能/02#实现技术难点分析"><span class="icon icon-link"></span></a>实现技术难点分析</h2><p>先攻坚最关键的技术难点，如何实现反向代理。</p><p>所谓反向代理，就是能将一个请求按照条件分发到不同的服务中去。在Golang中的net/http/httputil 包中提供了ReverseProxy 这么一个数据结构，它是实现整个反向代理的关键。</p><p>我们使用命令 <code>go doc net/http/httputil.ReverseProxy</code> 看下这个数据结构的定义，每个字段的说明我详细写在代码注释里面了：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// 反向代理</span></div><div class="token-line"><span class="token plain">    type ReverseProxy struct {</span></div><div class="token-line"><span class="token plain">        // Director这个函数传入的参数是新复制的一个请求，我们可以修改这个请求</span></div><div class="token-line"><span class="token plain">        // 比如修改请求的请求Host或者请求URL等</span></div><div class="token-line"><span class="token plain">    	Director func(*http.Request)</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    	// Transport 代表底层的连接池设置，比如连接最长保持多久等</span></div><div class="token-line"><span class="token plain">        // 如果不填的话，则使用默认的设置</span></div><div class="token-line"><span class="token plain">    	Transport http.RoundTripper</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    	// FlushInterval表示多久将下游的response的数据拷贝到proxy的response</span></div><div class="token-line"><span class="token plain">    	FlushInterval time.Duration</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    	// ErrorLog 表示错误日志打印的句柄</span></div><div class="token-line"><span class="token plain">    	ErrorLog *log.Logger</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    	// BufferPool表示将下游response拷贝到proxy的response的时候使用的缓冲池大小</span></div><div class="token-line"><span class="token plain">    	BufferPool BufferPool</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    	// ModifyResponse 函数表示，如果要将下游的response内容进行修改，再传递给proxy</span></div><div class="token-line"><span class="token plain">        // 的response，这个函数就可以进行设置，但是如果这个函数返回了error，则将response</span></div><div class="token-line"><span class="token plain">        // 传递进入ErrorHandler，否则使用默认设置</span></div><div class="token-line"><span class="token plain">    	ModifyResponse func(*http.Response) error</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    	// ErrorHandler 处理ModifyResponse返回的Error</span></div><div class="token-line"><span class="token plain">    	ErrorHandler func(http.ResponseWriter, *http.Request, error)</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>这里我着重解释一下这次会使用到的三个字段 Director、ModifyResponse、ErrorHandler，Director是必须填写的，而ModifyResponse、ErrorHandler是可选的。</p><p><strong>Director的参数是请求，表示如何对请求进行转发</strong>。最简单的，我们可以修改请求的目标Host，将请求转发到后端的服务。具体如何使用，可以看net/http/httputil库带的NewSingleHostReverseProxy方法，它将请求转发给后端target地址的时候，直接将request的scheme、host、path 都进行了替换。这个方法也是后面我们经常要用到的。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// 将原先的请求转发到target地址</span></div><div class="token-line"><span class="token plain">    func NewSingleHostReverseProxy(target *url.URL) *ReverseProxy {</span></div><div class="token-line"><span class="token plain">       targetQuery := target.RawQuery</span></div><div class="token-line"><span class="token plain">       // 设置director</span></div><div class="token-line"><span class="token plain">       director := func(req *http.Request) {</span></div><div class="token-line"><span class="token plain">          // 将原先的request替换scheme, host，path。</span></div><div class="token-line"><span class="token plain">          req.URL.Scheme = target.Scheme</span></div><div class="token-line"><span class="token plain">          req.URL.Host = target.Host</span></div><div class="token-line"><span class="token plain">          req.URL.Path, req.URL.RawPath = joinURLPath(target, req.URL)</span></div><div class="token-line"><span class="token plain">          ...</span></div><div class="token-line"><span class="token plain">       }</span></div><div class="token-line"><span class="token plain">       return &amp;ReverseProxy{Director: director}</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>其次是<strong>ModifyResponse字段</strong>，在下游response要拷贝给上游proxy的response的时候，会使用到它代表的函数，如果我们要对下游的返回数据进行修改，就可以设置这个字段。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">ModifyResponse func(*http.Response) error</span></div></pre></div><p>这个字段的参数就只有一个，http.Response指针，代表的是下游返回给上游的返回结构，我们可以对这个指针的内容进行操作。而返回值error，代表操作的结果，如果在操作过程中出现错误，会返回error。</p><p>返回的error，就会进入<strong>第三个字段函数 ErrorHandler</strong>中。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">ErrorHandler func(http.ResponseWriter, *http.Request, error)</span></div></pre></div><p>ErrorHandler有三个参数，responseWriter是新proxy的reponse的写句柄，request 是Director修改后给下游的request，而error则是ModifyResponse处理后的error。</p><p>了解清楚这三个字段函数中每个参数和返回值是非常重要的，这样才能准确地使用这些字段。下面我们就活学活用这个ReverseProxy。</p><p><strong>使用ReverseProxy作为反向代理，那么对应的路由规则是什么样的呢？什么样的请求进入后端，什么样的请求进入前端呢</strong>？这里我们需要再思考下。</p><p>还记得么，在上一节课增加前端代码Vue进入hade框架中的时候，我们使用了一个中间件static，来将请求按照规则进行分发：如果请求地址在dist目录中存在，返回对应的请求文件，而如果请求地址在dist目录中不存在，就什么都不做，进行后续的路由规则判定。</p><p>但是在调试模式下，并没有前端编译环境，那我们怎么判断这个请求是进入前端，还是进入后端呢？这里是一个比较难的点。</p><p>可以反过来做。<strong>一个请求到了，直接先请求一下后端服务，如果后端发现请求不存在，返回404 Not Found之后， 我们再将请求再请求到前端服务</strong>，就可以完美解决这个问题。这里用到刚才学习的 ReverseProxy 结构里面的 Director。</p><p>在Director中，将请求设置为转发给后端服务。这样当后端服务查找到路由不存在，返回404的时候，我们是能在 ModifyResponse 中获取到后端返回的StatusCode的。之后再判断如果为404，让 ModifyResponse 返回一个自定义的 NotFoundErr。</p><p>一旦ModifyResponse返回了Error，就会进入到 ErrorHandler 函数中，在这个函数中，我们判断一下参数中的error是否是之前定义的NotFoundErr，如果是的话，就再用NewSingleHostReverseProxy来创建一个前端的Proxy，将这个请求代理到前端服务中。</p><p>把这段实现的网关服务逻辑翻译成代码，在framework/command/dev.go中：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// 重新启动一个proxy网关</span></div><div class="token-line"><span class="token plain">    func (p *Proxy) newProxyReverseProxy(frontend, backend *url.URL) *httputil.ReverseProxy {</span></div><div class="token-line"><span class="token plain">     ...</span></div><div class="token-line"><span class="token plain">     // 先创建一个后端服务的directory</span></div><div class="token-line"><span class="token plain">     director := func(req *http.Request) {</span></div><div class="token-line"><span class="token plain">      req.URL.Scheme = backend.Scheme</span></div><div class="token-line"><span class="token plain">      req.URL.Host = backend.Host</span></div><div class="token-line"><span class="token plain">     }</span></div><div class="token-line"><span class="token plain">     </span></div><div class="token-line"><span class="token plain">     // 定义一个NotFoundErr</span></div><div class="token-line"><span class="token plain">     NotFoundErr := errors.New(&quot;response is 404, need to redirect&quot;)</span></div><div class="token-line"><span class="token plain">     </span></div><div class="token-line"><span class="token plain">     return &amp;httputil.ReverseProxy{</span></div><div class="token-line"><span class="token plain">      Director: director, // 先转发到后端服务</span></div><div class="token-line"><span class="token plain">      </span></div><div class="token-line"><span class="token plain">      ModifyResponse: func(response *http.Response) error {</span></div><div class="token-line"><span class="token plain">       </span></div><div class="token-line"><span class="token plain">       // 如果后端服务返回了404，我们返回NotFoundErr 会进入到errorHandler中</span></div><div class="token-line"><span class="token plain">       if response.StatusCode == 404 {</span></div><div class="token-line"><span class="token plain">        return NotFoundErr</span></div><div class="token-line"><span class="token plain">       }</span></div><div class="token-line"><span class="token plain">       return nil</span></div><div class="token-line"><span class="token plain">      },</span></div><div class="token-line"><span class="token plain">      </span></div><div class="token-line"><span class="token plain">      ErrorHandler: func(writer http.ResponseWriter, request *http.Request, err error) {</span></div><div class="token-line"><span class="token plain">       </span></div><div class="token-line"><span class="token plain">       // 判断 Error 是否为NotFoundError, 是的话则进行前端服务的转发，重新修改writer</span></div><div class="token-line"><span class="token plain">       if errors.Is(err, NotFoundErr) {</span></div><div class="token-line"><span class="token plain">        httputil.NewSingleHostReverseProxy(frontend).ServeHTTP(writer, request)</span></div><div class="token-line"><span class="token plain">       }</span></div><div class="token-line"><span class="token plain">      }}</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><h2 id="command-设计"><a aria-hidden="true" tabindex="-1" href="/blog/手把手带你写一个web框架/04.实战第3关完善功能/02#command-设计"><span class="icon icon-link"></span></a>command 设计</h2><p>思考清楚了技术难点，我们就可以开始设计命令了。这里为我们的框架重新定义一个dev一级命令，这个命令专门是调试模式，没有什么实际的作用，只是显示帮助信息。而它下面有三个二级命令：dev frontend 调试前端、dev backend 调试后端、dev all 前后端同时调试。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">./hade dev //显示帮助信息</span></div><div class="token-line"><span class="token plain">    ./hade dev frontend // 调试前端</span></div><div class="token-line"><span class="token plain">    ./hade dev backend  // 调试后端</span></div><div class="token-line"><span class="token plain">    ./hade dev all  // 显示所有</span></div></pre></div><p>在定义工具命令的时候，如果遇到有前端和后端的，我们应该统一在命令中使用关键字 frontend 和 backend 分别代表前后端，这样可以给使用者不断加深强调这两个关键字，这样我们在使用命令的时候，就能很快反应出前后端对应的命令了。</p><p>创建一个 framework/command/dev.go 来存放这个调试命令：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// 初始化Dev命令</span></div><div class="token-line"><span class="token plain">    func initDevCommand() *cobra.Command {</span></div><div class="token-line"><span class="token plain">     devCommand.AddCommand(devBackendCommand)</span></div><div class="token-line"><span class="token plain">     devCommand.AddCommand(devFrontendCommand)</span></div><div class="token-line"><span class="token plain">     devCommand.AddCommand(devAllCommand)</span></div><div class="token-line"><span class="token plain">     return devCommand</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    // devCommand 为调试模式的一级命令</span></div><div class="token-line"><span class="token plain">    var devCommand = &amp;cobra.Command{</span></div><div class="token-line"><span class="token plain">     Use:   &quot;dev&quot;,</span></div><div class="token-line"><span class="token plain">     Short: &quot;调试模式&quot;,</span></div><div class="token-line"><span class="token plain">     RunE: func(c *cobra.Command, args []string) error {</span></div><div class="token-line"><span class="token plain">      c.Help()</span></div><div class="token-line"><span class="token plain">      return nil</span></div><div class="token-line"><span class="token plain">     },</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    // devBackendCommand 启动后端调试模式</span></div><div class="token-line"><span class="token plain">    var devBackendCommand = &amp;cobra.Command{</span></div><div class="token-line"><span class="token plain">     Use:   &quot;backend&quot;,</span></div><div class="token-line"><span class="token plain">     Short: &quot;启动后端调试模式&quot;,</span></div><div class="token-line"><span class="token plain">     RunE: func(c *cobra.Command, args []string) error {</span></div><div class="token-line"><span class="token plain">      ...</span></div><div class="token-line"><span class="token plain">     },</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    // devFrontendCommand 启动前端调试模式</span></div><div class="token-line"><span class="token plain">    var devFrontendCommand = &amp;cobra.Command{</span></div><div class="token-line"><span class="token plain">     Use:   &quot;frontend&quot;,</span></div><div class="token-line"><span class="token plain">     Short: &quot;前端调试模式&quot;,</span></div><div class="token-line"><span class="token plain">     RunE: func(c *cobra.Command, args []string) error {</span></div><div class="token-line"><span class="token plain">       ...</span></div><div class="token-line"><span class="token plain">     },</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    // 同时启动前端和后端调试</span></div><div class="token-line"><span class="token plain">    var devAllCommand = &amp;cobra.Command{</span></div><div class="token-line"><span class="token plain">     Use:   &quot;all&quot;,</span></div><div class="token-line"><span class="token plain">     Short: &quot;同时启动前端和后端调试&quot;,</span></div><div class="token-line"><span class="token plain">     RunE: func(c *cobra.Command, args []string) error {</span></div><div class="token-line"><span class="token plain">      ...</span></div><div class="token-line"><span class="token plain">     },</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>同时在 framework/command/kernel.go 中，我们加上dev的命令：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// 框架核心命令</span></div><div class="token-line"><span class="token plain">    func AddKernelCommands(root *cobra.Command) {</span></div><div class="token-line"><span class="token plain">     ...</span></div><div class="token-line"><span class="token plain">     // dev 调试命令</span></div><div class="token-line"><span class="token plain">     root.AddCommand(initDevCommand())</span></div></pre></div><h2 id="proxy-类的设计"><a aria-hidden="true" tabindex="-1" href="/blog/手把手带你写一个web框架/04.实战第3关完善功能/02#proxy-类的设计"><span class="icon icon-link"></span></a>proxy 类的设计</h2><p>定义了dev 命令的设计，我们再思考一下它如何实现。首先需要一个结构来承担起调试模式所有的逻辑，这里定义为Proxy结构。proxy结构和proxy结构对应的方法我们都存放在 framework/command/dev.go中：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// Proxy 代表serve启动的服务器代理</span></div><div class="token-line"><span class="token plain">    type Proxy struct {</span></div><div class="token-line"><span class="token plain">      ...</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>同时定义一个NewProxy方法来初始化这个Proxy结构：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">func NewProxy(c framework.Container) *Proxy</span></div></pre></div><p>在初始化proxy的时候，需要容器中的一些服务，比如配置文件服务等，所以这里传递了一个容器的参数。</p><p>这个proxy结构应该有几个方法，按照代理分发的结构示意图，我们要<strong>定义proxy服务需要的方法、前端服务需要的方法和后端服务需要的方法</strong>。</p><p>针对proxy服务，首先需要定义我们在讲反向代理技术难点的时候提到的方法 newProxyReverseProxy，用来创建一个代理前后端的代理ReverseProxy结构。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">func (p *Proxy) newProxyReverseProxy(frontend, backend *url.URL) *httputil.ReverseProxy</span></div></pre></div><p>其次，还需要一个启动proxy的方法 startProxy。它的传入参数就直接设置为两个bool，代表是否要开启前端服务的代理、以及是否要开启后端服务的代理。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">func (p *Proxy) startProxy(startFrontend, startBackend bool) error</span></div></pre></div><p>再来定义前后端服务的方法。明显要有一个方法能启动前端服务、也要有一个方法能启动后端服务：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">func (p *Proxy) restartFrontend() error</span></div><div class="token-line"><span class="token plain">    func (p *Proxy) restartBackend() error</span></div></pre></div><p>这里注意一下，前端服务是直接使用 <code>npm run dev</code> 命令启动调试模式的，而后端服务是先进行 <code>go build</code> 再进行 <code>go run</code> ，所以后端服务是需要进行编译的，所以我们还需要一个编译后端服务的方法：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">func (p *Proxy) rebuildBackend() error</span></div></pre></div><p>同时，由于前端服务已经自己有了监控文件变更的逻辑，不需要我们再监控前端文件是否有变更了。而后端服务需要一个函数来监控源码文件的变更：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">func (p *Proxy) monitorBackend() error</span></div></pre></div><p>这个监控文件我们设计为阻塞式的，在for 循环中不断监控文件的变动，所以在调用的时候，如果不需要在这个函数中阻塞，可以开启一个Goroutine进行监听。</p><p>有了这些函数，我们就串联一下上面的command的设计。</p><p>首先前端调试模式，就非常简单，启动一个只带有前端的proxy就行：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// devFrontendCommand 启动前端调试模式</span></div><div class="token-line"><span class="token plain">    var devFrontendCommand = &amp;cobra.Command{</span></div><div class="token-line"><span class="token plain">     ...</span></div><div class="token-line"><span class="token plain">     RunE: func(c *cobra.Command, args []string) error {</span></div><div class="token-line"><span class="token plain">      // 启动前端服务</span></div><div class="token-line"><span class="token plain">      proxy := NewProxy(c.GetContainer())</span></div><div class="token-line"><span class="token plain">      return proxy.startProxy(true, false)</span></div><div class="token-line"><span class="token plain">     },</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>其次是后端调试模式，先启动一个Goroutine监听后端文件，再启动一个只有后端的proxy：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// devBackendCommand 启动后端调试模式</span></div><div class="token-line"><span class="token plain">    var devBackendCommand = &amp;cobra.Command{</span></div><div class="token-line"><span class="token plain">     ...</span></div><div class="token-line"><span class="token plain">     RunE: func(c *cobra.Command, args []string) error {</span></div><div class="token-line"><span class="token plain">      proxy := NewProxy(c.GetContainer())</span></div><div class="token-line"><span class="token plain">      // 监听后端文件</span></div><div class="token-line"><span class="token plain">      go proxy.monitorBackend()</span></div><div class="token-line"><span class="token plain">      // 启动只有后端的proxy</span></div><div class="token-line"><span class="token plain">      if err := proxy.startProxy(false, true); err != nil {</span></div><div class="token-line"><span class="token plain">       return err</span></div><div class="token-line"><span class="token plain">      }</span></div><div class="token-line"><span class="token plain">      return nil</span></div><div class="token-line"><span class="token plain">     },</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>而前后端同时调试，则是先启动一个Goroutine监听后端文件，再同时启动监听前后端的proxy：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">var devAllCommand = &amp;cobra.Command{</span></div><div class="token-line"><span class="token plain">     ...</span></div><div class="token-line"><span class="token plain">     RunE: func(c *cobra.Command, args []string) error {</span></div><div class="token-line"><span class="token plain">      proxy := NewProxy(c.GetContainer())</span></div><div class="token-line"><span class="token plain">      // 监听后端文件</span></div><div class="token-line"><span class="token plain">      go proxy.monitorBackend()</span></div><div class="token-line"><span class="token plain">      // 启动前后端同时监听的proxy</span></div><div class="token-line"><span class="token plain">      if err := proxy.startProxy(true, true); err != nil {</span></div><div class="token-line"><span class="token plain">       return err</span></div><div class="token-line"><span class="token plain">      }</span></div><div class="token-line"><span class="token plain">      return nil</span></div><div class="token-line"><span class="token plain">     },</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>今天只在framework/command/目录下增加了一个dev.go文件，代码地址在 <a target="_blank" rel="noopener noreferrer" href="https://github.com/gohade/coredemo/tree/geekbang/19">geekbang/19<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 分支上。下节课我们继续完成调试模式的具体实现。<br/><img src="https://static001.geekbang.org/resource/image/4f/62/4f70c9293be8ccdyy55b395bc9705862.png?wh=734x1450" alt=""/></p><h2 id="小结"><a aria-hidden="true" tabindex="-1" href="/blog/手把手带你写一个web框架/04.实战第3关完善功能/02#小结"><span class="icon icon-link"></span></a>小结</h2><p>今天这节课最关键的点就在于ReverseProxy的运用。ReverseProxy是Golang标准库提供的反向代理的实现方式。而反向代理，在实际业务开发过程中实际上是非常好用的。</p><p>比如我们在业务开发过程中很有可能会需要自研网关，来全局代理和监控所有的后端接口；又或者在拆分微服务的时候，需要有一个统一路由层来引导流量。这个ReverseProxy结构的熟练使用就是这些功能的核心关键。</p><p>今天我们为hade框架增加了调试模式，这个模式在很多Golang的框架中是没有的，算是我们的hade框架的一大特色了。大多数框架是依赖于日志进行编译调试。而hade框架之所以能提供这种方便的调试模式，也是依赖于我们前面已经实现的前后端一体、目录服务，配置服务等逻辑。</p><p>在实际工作中，特别在调试的时候，这种调试模式一定能为你带来很大的便利。</p><h2 id="思考题"><a aria-hidden="true" tabindex="-1" href="/blog/手把手带你写一个web框架/04.实战第3关完善功能/02#思考题"><span class="icon icon-link"></span></a>思考题</h2><p>讲ReverseProxy时，我们的逻辑是先请求后端服务，如果后端服务出现404，再请求前端。这里有两个问题你可以思考下：</p><p>1.可以不可以先请求vue的前端服务，如果前端服务出现404，再请求后端呢？</p><p>2.某些vue确定的请求地址，比如&quot;/app.js&quot;, “/” ，是否可以不用走这个先后端服务、再前端服务的逻辑？如果可以，怎么做呢？</p><p>欢迎在留言区分享你的思考。感谢你的收听，如果觉得有收获，也欢迎把今天的内容分享给你身边的朋友，邀他一起学习。我们下节课见～</p></div><div class="__dumi-default-layout-footer-meta"><a target="_blank" rel="noopener noreferrer" href="https://github.com/GGwujun/blog/edit/master/docs/手把手带你写一个Web框架/04.实战第3关完善功能/02.md">在 GitHub 上编辑此页<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a><span data-updated-text="最后更新时间：">5/2/2022 10:56:58</span></div></div></div></div>
	<script>
  window.g_useSSR = true;
  window.g_initialProps = {};
	</script>

    <script>
      (function () {
        if (!location.port) {
          (function (i, s, o, g, r, a, m) {
            i["GoogleAnalyticsObject"] = r;
            (i[r] =
              i[r] ||
              function () {
                (i[r].q = i[r].q || []).push(arguments);
              }),
              (i[r].l = 1 * new Date());
            (a = s.createElement(o)), (m = s.getElementsByTagName(o)[0]);
            a.async = 1;
            a.src = g;
            m.parentNode.insertBefore(a, m);
          })(
            window,
            document,
            "script",
            "//www.google-analytics.com/analytics.js",
            "ga"
          );
          ga("create", "UA-149864185-1", "auto");
          ga("send", "pageview");
        }
      })();
    </script>
    <script src="/blog/umi.js"></script>
  </body>
</html>
