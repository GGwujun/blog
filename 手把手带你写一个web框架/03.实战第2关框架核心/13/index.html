<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no"
    />
    <link rel="shortcut icon" type="image/x-icon" href="/logo.png" />
    <link rel="stylesheet" href="/blog/umi.css" />
    <script>
      window.routerBase = "/blog";
    </script>
    <script>
      //! umi version: 3.5.17
    </script>
    <script>
      !(function () {
        var e = localStorage.getItem("dumi:prefers-color"),
          t = window.matchMedia("(prefers-color-scheme: dark)").matches,
          r = ["light", "dark", "auto"];
        document.documentElement.setAttribute(
          "data-prefers-color",
          e === r[2] ? (t ? r[1] : r[0]) : r.indexOf(e) > -1 ? e : r[0]
        );
      })();
    </script>
    <title>17｜日志：如何设计多输出的日志服务？</title>
  </head>
  <body>
    <div id="root"><div class="__dumi-default-layout" data-route="/手把手带你写一个web框架/03.实战第2关框架核心/13" data-show-sidemenu="true" data-show-slugs="true" data-site-mode="true" data-gapless="false"><div class="__dumi-default-navbar" data-mode="site"><button class="__dumi-default-navbar-toggle"></button><a class="__dumi-default-navbar-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog/">大师兄</a><nav><div class="__dumi-default-search"><input type="search" class="__dumi-default-search-input" value=""/><ul></ul></div><span>计算机基础<ul><li><a href="/blog/编译原理之美">编译原理之美</a></li><li><a href="/blog/编译原理实战">编译原理实战</a></li><li><a href="/blog/深入浅出计算机组成原理">深入浅出计算机组成原理</a></li><li><a href="/blog/详解http">详解http</a></li><li><a href="/blog/计算机网络通关29讲">计算机网络通关29讲</a></li><li><a href="/blog/网络排查案例课">网络排查案例课</a></li><li><a href="/blog/linux操作系统">linux操作系统</a></li><li><a href="/blog/linux性能优化实战">linux性能优化实战</a></li><li><a href="/blog/程序员数学基础">程序员数学基础</a></li><li><a href="/blog/趣谈网络协议">趣谈网络协议</a></li><li><a href="/blog/操作系统实战">操作系统实战</a></li><li><a href="/blog/软件工程之美">软件工程之美</a></li><li><a href="/blog/sql必知必会">sql必知必会</a></li><li><a href="/blog/操作系统实战45讲">操作系统实战45讲</a></li><li><a href="/blog/网络编程实战">网络编程实战</a></li></ul></span><span>算法<ul><li><a href="/blog/常用算法25讲">常用算法25讲</a></li><li><a href="/blog/数据结构与算法之美">数据结构与算法之美</a></li><li><a href="/blog/业务开发算法50讲">业务开发算法50讲</a></li><li><a href="/blog/动态规划面试宝典">动态规划面试宝典</a></li></ul></span><span>前端开发<ul><li><a href="/blog/浏览器工作原理与实践">浏览器工作原理与实践</a></li><li><a href="/blog/新时代产品经理进阶之路">新时代产品经理进阶之路</a></li><li><a href="/blog/全栈工程师修炼指南">全栈工程师修炼指南</a></li><li><a href="/blog/flutter核心技术与实战">flutter核心技术与实战</a></li><li><a href="/blog/java-script核心原理解析">java-script核心原理解析</a></li><li><a href="/blog/说透低代码">说透低代码</a></li><li><a href="/blog/nodejs应用开发实战">nodejs应用开发实战</a></li><li><a href="/blog/反爬虫兵法演绎20讲">反爬虫兵法演绎20讲</a></li><li><a href="/blog/reactnative新架构实战课">reactnative新架构实战课</a></li><li><a href="/blog/正则表达式入门">正则表达式入门</a></li><li><a href="/blog/重学前端">重学前端</a></li><li><a href="/blog/serverless入门课">serverless入门课</a></li><li><a href="/blog/type-script入门实战笔记">type-script入门实战笔记</a></li><li><a href="/blog/图解googlev8">图解googlev8</a></li><li><a href="/blog/vue3源码分析">vue3源码分析</a></li><li><a href="/blog/玩转Vue3全家桶">玩转Vue3全家桶</a></li><li><a href="/blog/webassembly入门">webassembly入门</a></li><li><a aria-current="page" class="active" href="/blog/手把手带你写一个Web框架">手把手带你写一个Web框架</a></li><li><a href="/blog/web漏洞挖掘实战">web漏洞挖掘实战</a></li><li><a href="/blog/跟月影学可视化">跟月影学可视化</a></li><li><a href="/blog/搞定音频技术">搞定音频技术</a></li><li><a href="/blog/攻克视频技术">攻克视频技术</a></li></ul></span><span>前端工程化<ul><li><a href="/blog/logger">logger</a></li><li><a href="/blog/webpack">webpack</a></li><li><a href="/blog/webpackChain">webpackChain</a></li></ul></span><span>前端性能优化<ul><li><a href="/blog/react性能调优">react性能调优</a></li></ul></span><span>软件测试<ul><li><a href="/blog/全链路压测实战30讲">全链路压测实战30讲</a></li><li><a href="/blog/性能测试实战30讲">性能测试实战30讲</a></li><li><a href="/blog/自动化测试高手课">自动化测试高手课</a></li><li><a href="/blog/软件测试52讲">软件测试52讲</a></li></ul></span><span>面试<ul><li><a href="/blog/面试现场">面试现场</a></li></ul></span><span>杂谈<ul><li><a href="/blog/超级访谈对话张雪峰">超级访谈对话张雪峰</a></li><li><a href="/blog/Git实战手册">Git实战手册</a></li><li><a href="/blog/NodeJS">NodeJS</a></li><li><a href="/blog/ReactJS">ReactJS</a></li><li><a href="/blog/UI设计">UI设计</a></li><li><a href="/blog/webpack4系列教程">webpack4系列教程</a></li><li><a href="/blog/前端知识体系">前端知识体系</a></li><li><a href="/blog/剑指offer刷题笔记">剑指offer刷题笔记</a></li><li><a href="/blog/思考与成长">思考与成长</a></li><li><a href="/blog/设计模式手册">设计模式手册</a></li></ul></span><div class="__dumi-default-navbar-tool"><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "></div></div></div></nav></div><div class="__dumi-default-menu" data-mode="site"><div class="__dumi-default-menu-inner"><div class="__dumi-default-menu-header"><a class="__dumi-default-menu-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog/"></a><h1>大师兄</h1><p></p></div><div class="__dumi-default-menu-mobile-area"><ul class="__dumi-default-menu-nav-list"><li>计算机基础<ul><li><a href="/blog/编译原理之美">编译原理之美</a></li><li><a href="/blog/编译原理实战">编译原理实战</a></li><li><a href="/blog/深入浅出计算机组成原理">深入浅出计算机组成原理</a></li><li><a href="/blog/详解http">详解http</a></li><li><a href="/blog/计算机网络通关29讲">计算机网络通关29讲</a></li><li><a href="/blog/网络排查案例课">网络排查案例课</a></li><li><a href="/blog/linux操作系统">linux操作系统</a></li><li><a href="/blog/linux性能优化实战">linux性能优化实战</a></li><li><a href="/blog/程序员数学基础">程序员数学基础</a></li><li><a href="/blog/趣谈网络协议">趣谈网络协议</a></li><li><a href="/blog/操作系统实战">操作系统实战</a></li><li><a href="/blog/软件工程之美">软件工程之美</a></li><li><a href="/blog/sql必知必会">sql必知必会</a></li><li><a href="/blog/操作系统实战45讲">操作系统实战45讲</a></li><li><a href="/blog/网络编程实战">网络编程实战</a></li></ul></li><li>算法<ul><li><a href="/blog/常用算法25讲">常用算法25讲</a></li><li><a href="/blog/数据结构与算法之美">数据结构与算法之美</a></li><li><a href="/blog/业务开发算法50讲">业务开发算法50讲</a></li><li><a href="/blog/动态规划面试宝典">动态规划面试宝典</a></li></ul></li><li>前端开发<ul><li><a href="/blog/浏览器工作原理与实践">浏览器工作原理与实践</a></li><li><a href="/blog/新时代产品经理进阶之路">新时代产品经理进阶之路</a></li><li><a href="/blog/全栈工程师修炼指南">全栈工程师修炼指南</a></li><li><a href="/blog/flutter核心技术与实战">flutter核心技术与实战</a></li><li><a href="/blog/java-script核心原理解析">java-script核心原理解析</a></li><li><a href="/blog/说透低代码">说透低代码</a></li><li><a href="/blog/nodejs应用开发实战">nodejs应用开发实战</a></li><li><a href="/blog/反爬虫兵法演绎20讲">反爬虫兵法演绎20讲</a></li><li><a href="/blog/reactnative新架构实战课">reactnative新架构实战课</a></li><li><a href="/blog/正则表达式入门">正则表达式入门</a></li><li><a href="/blog/重学前端">重学前端</a></li><li><a href="/blog/serverless入门课">serverless入门课</a></li><li><a href="/blog/type-script入门实战笔记">type-script入门实战笔记</a></li><li><a href="/blog/图解googlev8">图解googlev8</a></li><li><a href="/blog/vue3源码分析">vue3源码分析</a></li><li><a href="/blog/玩转Vue3全家桶">玩转Vue3全家桶</a></li><li><a href="/blog/webassembly入门">webassembly入门</a></li><li><a aria-current="page" class="active" href="/blog/手把手带你写一个Web框架">手把手带你写一个Web框架</a></li><li><a href="/blog/web漏洞挖掘实战">web漏洞挖掘实战</a></li><li><a href="/blog/跟月影学可视化">跟月影学可视化</a></li><li><a href="/blog/搞定音频技术">搞定音频技术</a></li><li><a href="/blog/攻克视频技术">攻克视频技术</a></li></ul></li><li>前端工程化<ul><li><a href="/blog/logger">logger</a></li><li><a href="/blog/webpack">webpack</a></li><li><a href="/blog/webpackChain">webpackChain</a></li></ul></li><li>前端性能优化<ul><li><a href="/blog/react性能调优">react性能调优</a></li></ul></li><li>软件测试<ul><li><a href="/blog/全链路压测实战30讲">全链路压测实战30讲</a></li><li><a href="/blog/性能测试实战30讲">性能测试实战30讲</a></li><li><a href="/blog/自动化测试高手课">自动化测试高手课</a></li><li><a href="/blog/软件测试52讲">软件测试52讲</a></li></ul></li><li>面试<ul><li><a href="/blog/面试现场">面试现场</a></li></ul></li><li>杂谈<ul><li><a href="/blog/超级访谈对话张雪峰">超级访谈对话张雪峰</a></li><li><a href="/blog/Git实战手册">Git实战手册</a></li><li><a href="/blog/NodeJS">NodeJS</a></li><li><a href="/blog/ReactJS">ReactJS</a></li><li><a href="/blog/UI设计">UI设计</a></li><li><a href="/blog/webpack4系列教程">webpack4系列教程</a></li><li><a href="/blog/前端知识体系">前端知识体系</a></li><li><a href="/blog/剑指offer刷题笔记">剑指offer刷题笔记</a></li><li><a href="/blog/思考与成长">思考与成长</a></li><li><a href="/blog/设计模式手册">设计模式手册</a></li></ul></li></ul><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "><button title="Dark theme" class="__dumi-default-dark-moon "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="3854" width="22" height="22"><path d="M991.816611 674.909091a69.166545 69.166545 0 0 0-51.665455-23.272727 70.795636 70.795636 0 0 0-27.438545 5.585454A415.674182 415.674182 0 0 1 754.993338 698.181818c-209.594182 0-393.472-184.785455-393.472-395.636363 0-52.363636 38.539636-119.621818 69.515637-173.614546 4.887273-8.610909 9.634909-16.756364 14.103272-24.901818A69.818182 69.818182 0 0 0 384.631156 0a70.842182 70.842182 0 0 0-27.438545 5.585455C161.678429 90.298182 14.362065 307.898182 14.362065 512c0 282.298182 238.824727 512 532.38691 512a522.286545 522.286545 0 0 0 453.957818-268.334545A69.818182 69.818182 0 0 0 991.816611 674.909091zM546.679156 954.181818c-248.785455 0-462.941091-192-462.941091-442.181818 0-186.647273 140.637091-372.829091 300.939637-442.181818-36.817455 65.629091-92.578909 151.970909-92.578909 232.727273 0 250.181818 214.109091 465.454545 462.917818 465.454545a488.331636 488.331636 0 0 0 185.181091-46.545455 453.003636 453.003636 0 0 1-393.565091 232.727273z m103.656728-669.323636l-14.266182 83.781818a34.909091 34.909091 0 0 0 50.362182 36.770909l74.775272-39.563636 74.752 39.563636a36.142545 36.142545 0 0 0 16.174546 3.956364 34.909091 34.909091 0 0 0 34.210909-40.727273l-14.289455-83.781818 60.509091-59.345455a35.025455 35.025455 0 0 0-19.223272-59.578182l-83.61891-12.101818-37.376-76.101818a34.56 34.56 0 0 0-62.254545 0l-37.376 76.101818-83.618909 12.101818a34.909091 34.909091 0 0 0-19.246546 59.578182z m70.423272-64.698182a34.280727 34.280727 0 0 0 26.135273-19.083636l14.312727-29.090909 14.336 29.090909a34.257455 34.257455 0 0 0 26.135273 19.083636l32.046546 4.887273-23.272728 22.574545a35.234909 35.234909 0 0 0-10.007272 30.952727l5.46909 32.116364-28.625454-15.127273a34.490182 34.490182 0 0 0-32.302546 0l-28.695272 15.127273 5.469091-32.116364a35.141818 35.141818 0 0 0-9.984-30.952727l-23.272728-22.574545z" p-id="3855"></path></svg></button><button title="Light theme" class="__dumi-default-dark-sun "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="4026" width="22" height="22"><path d="M915.2 476.16h-43.968c-24.704 0-44.736 16-44.736 35.84s20.032 35.904 44.736 35.904H915.2c24.768 0 44.8-16.064 44.8-35.904s-20.032-35.84-44.8-35.84zM512 265.6c-136.704 0-246.464 109.824-246.464 246.4 0 136.704 109.76 246.464 246.464 246.464S758.4 648.704 758.4 512c0-136.576-109.696-246.4-246.4-246.4z m0 425.6c-99.008 0-179.2-80.128-179.2-179.2 0-98.944 80.192-179.2 179.2-179.2S691.2 413.056 691.2 512c0 99.072-80.192 179.2-179.2 179.2zM197.44 512c0-19.84-19.136-35.84-43.904-35.84H108.8c-24.768 0-44.8 16-44.8 35.84s20.032 35.904 44.8 35.904h44.736c24.768 0 43.904-16.064 43.904-35.904zM512 198.464c19.776 0 35.84-20.032 35.84-44.8v-44.8C547.84 84.032 531.84 64 512 64s-35.904 20.032-35.904 44.8v44.8c0 24.768 16.128 44.864 35.904 44.864z m0 627.136c-19.776 0-35.904 20.032-35.904 44.8v44.736C476.096 940.032 492.16 960 512 960s35.84-20.032 35.84-44.8v-44.736c0-24.768-16.064-44.864-35.84-44.864z m329.92-592.832c17.472-17.536 20.288-43.072 6.4-57.024-14.016-14.016-39.488-11.2-57.024 6.336-4.736 4.864-26.496 26.496-31.36 31.36-17.472 17.472-20.288 43.008-6.336 57.024 13.952 14.016 39.488 11.2 57.024-6.336 4.8-4.864 26.496-26.56 31.296-31.36zM213.376 759.936c-4.864 4.8-26.56 26.624-31.36 31.36-17.472 17.472-20.288 42.944-6.4 56.96 14.016 13.952 39.552 11.2 57.024-6.336 4.8-4.736 26.56-26.496 31.36-31.36 17.472-17.472 20.288-43.008 6.336-56.96-14.016-13.952-39.552-11.072-56.96 6.336z m19.328-577.92c-17.536-17.536-43.008-20.352-57.024-6.336-14.08 14.016-11.136 39.488 6.336 57.024 4.864 4.864 26.496 26.56 31.36 31.424 17.536 17.408 43.008 20.288 56.96 6.336 14.016-14.016 11.264-39.488-6.336-57.024-4.736-4.864-26.496-26.56-31.296-31.424z m527.168 628.608c4.864 4.864 26.624 26.624 31.36 31.424 17.536 17.408 43.072 20.224 57.088 6.336 13.952-14.016 11.072-39.552-6.4-57.024-4.864-4.8-26.56-26.496-31.36-31.36-17.472-17.408-43.072-20.288-57.024-6.336-13.952 14.016-11.008 39.488 6.336 56.96z" p-id="4027"></path></svg></button><button title="Default to system" class="__dumi-default-dark-auto "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="11002" width="22" height="22"><path d="M127.658667 492.885333c0-51.882667 10.24-101.717333 30.378666-149.162666s47.786667-88.064 81.92-122.538667 75.093333-61.781333 122.538667-81.92 96.938667-30.378667 149.162667-30.378667 101.717333 10.24 149.162666 30.378667 88.405333 47.786667 122.88 81.92 61.781333 75.093333 81.92 122.538667 30.378667 96.938667 30.378667 149.162666-10.24 101.717333-30.378667 149.162667-47.786667 88.405333-81.92 122.88-75.093333 61.781333-122.88 81.92-97.28 30.378667-149.162666 30.378667-101.717333-10.24-149.162667-30.378667-88.064-47.786667-122.538667-81.92-61.781333-75.093333-81.92-122.88-30.378667-96.938667-30.378666-149.162667z m329.045333 0c0 130.048 13.994667 244.394667 41.984 343.381334h12.970667c46.762667 0 91.136-9.216 133.461333-27.306667s78.848-42.666667 109.568-73.386667 54.954667-67.242667 73.386667-109.568 27.306667-86.698667 27.306666-133.461333c0-46.421333-9.216-90.794667-27.306666-133.12s-42.666667-78.848-73.386667-109.568-67.242667-54.954667-109.568-73.386667-86.698667-27.306667-133.461333-27.306666h-11.605334c-28.672 123.562667-43.349333 237.909333-43.349333 343.722666z" p-id="11003"></path></svg></button></div></div></div><ul class="__dumi-default-menu-list"><li><a href="/blog/">大师兄 - 前端架构师</a></li></ul></div></div><ul role="slug-list" class="__dumi-default-layout-toc"><li title="日志接口协议" data-depth="2"><a href="/blog/手把手带你写一个web框架/03.实战第2关框架核心/13#日志接口协议"><span>日志接口协议</span></a></li><li title="日志级别" data-depth="3"><a href="/blog/手把手带你写一个web框架/03.实战第2关框架核心/13#日志级别"><span>日志级别</span></a></li><li title="日志格式" data-depth="3"><a href="/blog/手把手带你写一个web框架/03.实战第2关框架核心/13#日志格式"><span>日志格式</span></a></li><li title="日志输出" data-depth="3"><a href="/blog/手把手带你写一个web框架/03.实战第2关框架核心/13#日志输出"><span>日志输出</span></a></li><li title="日志服务提供者" data-depth="2"><a href="/blog/手把手带你写一个web框架/03.实战第2关框架核心/13#日志服务提供者"><span>日志服务提供者</span></a></li><li title="日志服务的具体实现" data-depth="2"><a href="/blog/手把手带你写一个web框架/03.实战第2关框架核心/13#日志服务的具体实现"><span>日志服务的具体实现</span></a></li><li title="小结" data-depth="2"><a href="/blog/手把手带你写一个web框架/03.实战第2关框架核心/13#小结"><span>小结</span></a></li><li title="思考题" data-depth="2"><a href="/blog/手把手带你写一个web框架/03.实战第2关框架核心/13#思考题"><span>思考题</span></a></li></ul><div class="__dumi-default-layout-content"><div class="markdown"><h1 id="17日志如何设计多输出的日志服务"><a aria-hidden="true" tabindex="-1" href="/blog/手把手带你写一个web框架/03.实战第2关框架核心/13#17日志如何设计多输出的日志服务"><span class="icon icon-link"></span></a>17｜日志：如何设计多输出的日志服务？</h1><p>你好，我是轩脉刃。</p><p>上面两节课，我们将环境变量和配置服务作为一个服务注册到容器中了。这样，在业务中就能很方便获取环境变量和配置了。不知道你有没有逐渐体会到这种“一切皆服务”思想的好处。</p><p>就像堆积积木，只要想好了一个服务的接口，我们逐步实现服务之后，这一个服务就是一块积木，之后可以用相同的思路实现各种服务的积木块，用它们来拼出我们需要的业务逻辑。这节课，我们就来实现另一个框架最核心的积木：日志服务。</p><p>实现一个框架的服务，我们习惯了要创建三个文件：接口协议文件 framework/contract/log.go、服务提供者 framework/provider/log/provider.go、接口实例framework/provider/log/service.go。</p><h2 id="日志接口协议"><a aria-hidden="true" tabindex="-1" href="/blog/手把手带你写一个web框架/03.实战第2关框架核心/13#日志接口协议"><span class="icon icon-link"></span></a>日志接口协议</h2><p>说到日志服务，最先冒出来的一定是三个问题：什么样的日志需要输出？日志输出哪些内容？日志输出到哪里？一个个来分析。</p><h3 id="日志级别"><a aria-hidden="true" tabindex="-1" href="/blog/手把手带你写一个web框架/03.实战第2关框架核心/13#日志级别"><span class="icon icon-link"></span></a>日志级别</h3><p>什么样的日志需要输出，这是个关于日志级别的问题。我们想要把日志分为几个级别？每个级别代表什么？这个日志级别其实在不同系统中有不同划分，比如Linux的<a target="_blank" rel="noopener noreferrer" href="https://datatracker.ietf.org/doc/html/rfc5424">syslog<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>中将系统划分为以下八种日志级别：<br/><img src="https://static001.geekbang.org/resource/image/f5/ea/f5382bc685494efb2c024f31f25aa2ea.png?wh=912x438" alt=""/><br/>而Java的<a target="_blank" rel="noopener noreferrer" href="https://zh.wikipedia.org/wiki/Log4j">log4j<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>将日志分为以下七种日志级别：<br/><img src="https://static001.geekbang.org/resource/image/e0/78/e07a0aefb9039788d17921e192394f78.jpg?wh=1920x1080" alt=""/></p><p>其实仔细看，它们的日志级别差别都不大。比如都同意用Error级别代表运行时的错误情况，而Warn级别代表运行时可以弥补的错误、Info级别代表运行时信息、debug代表调试的时候需要打印的信息。</p><p>不同点就在是否有trace级别以及Error级别往上的级别定义。syslog没有trace级别，而在Error级别往上分别定义了Emergency级别、Alert级别、Critical级别。而log4j在ERROR上定义了两个级别FATAL和OFF，也同时保留了Trace级别。</p><p>在我看来，syslog和log4j的日志区分主要是由于场景不同。syslog比较偏向于<strong>操作系统的使用场景</strong>，它的分级语义更多是告诉我们系统的情况，比如Alert这个级别表示“系统有问题，需要立即采取行动”；而log4j的日志级别定义是<strong>从一个应用出发的</strong>，它的影响范围理论上会小一些，所以它很难定义比如像“需要立即采取行动”这样的级别。</p><p>所以，这里我们主要参考log4j的日志级别方法，并做了一些小调整，归并为下列七种日志级别：</p><ul><li>panic，表示会导致整个程序出现崩溃的日志信息</li><li>fatal，表示会导致当前这个请求出现提前终止的错误信息</li><li>error，表示出现错误，但是不一定影响后续请求逻辑的错误信息</li><li>warn，表示出现错误，但是一定不影响后续请求逻辑的报警信息</li><li>info，表示正常的日志信息输出</li><li>debug，表示在调试状态下打印出来的日志信息</li><li>trace，表示最详细的信息，一般信息量比较大，可能包含调用堆栈等信息</li></ul><p>在error级别之上，我们把导致程序崩溃和导致请求结束的错误拆分出来，分为panic和fatal两个类型来定义级别。而其他的error、warn、info、debug 都和其他的日志系统一致。另外也增加一个trace级别，当需要打印调用堆栈等这些比较详细的信息的时候，可以使用这种日志级别。</p><p><strong>日志级别是按照严重顺序从下往上排列的</strong>。也就是说，如果我们设置了日志输出级别为info，那么info级别的日志及info级别往上，日志级别更高的warn、error、fatal、panic的日志，也需要被打印出来。</p><p>按照这个思路，我们在framework/contract/log.go中定义的接口协议如下：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">package contract</span></div><div class="token-line"><span class="token plain">    import (</span></div><div class="token-line"><span class="token plain">       &quot;context&quot;</span></div><div class="token-line"><span class="token plain">       &quot;io&quot;</span></div><div class="token-line"><span class="token plain">       &quot;time&quot;</span></div><div class="token-line"><span class="token plain">    )</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    // 协议关键字</span></div><div class="token-line"><span class="token plain">    const LogKey = &quot;hade:log&quot;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    type LogLevel uint32</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    const (</span></div><div class="token-line"><span class="token plain">       // UnknownLevel 表示未知的日志级别</span></div><div class="token-line"><span class="token plain">       UnknownLevel LogLevel = iota</span></div><div class="token-line"><span class="token plain">       // PanicLevel level, panic 表示会导致整个程序出现崩溃的日志信息</span></div><div class="token-line"><span class="token plain">       PanicLevel</span></div><div class="token-line"><span class="token plain">       // FatalLevel level. fatal 表示会导致当前这个请求出现提前终止的错误信息</span></div><div class="token-line"><span class="token plain">       FatalLevel</span></div><div class="token-line"><span class="token plain">       // ErrorLevel level. error 表示出现错误，但是不一定影响后续请求逻辑的错误信息</span></div><div class="token-line"><span class="token plain">       ErrorLevel</span></div><div class="token-line"><span class="token plain">       // WarnLevel level. warn 表示出现错误，但是一定不影响后续请求逻辑的报警信息</span></div><div class="token-line"><span class="token plain">       WarnLevel</span></div><div class="token-line"><span class="token plain">       // InfoLevel level. info 表示正常的日志信息输出</span></div><div class="token-line"><span class="token plain">       InfoLevel</span></div><div class="token-line"><span class="token plain">       // DebugLevel level. debug 表示在调试状态下打印出来的日志信息</span></div><div class="token-line"><span class="token plain">       DebugLevel</span></div><div class="token-line"><span class="token plain">       // TraceLevel level. trace 表示最详细的信息，一般信息量比较大，可能包含调用堆栈等信息</span></div><div class="token-line"><span class="token plain">       TraceLevel</span></div><div class="token-line"><span class="token plain">    )</span></div><div class="token-line"><span class="token plain">    ...</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    // Log define interface for log</span></div><div class="token-line"><span class="token plain">    type Log interface {</span></div><div class="token-line"><span class="token plain">       // Panic 表示会导致整个程序出现崩溃的日志信息</span></div><div class="token-line"><span class="token plain">       Panic(ctx context.Context, msg string, fields map[string]interface{})</span></div><div class="token-line"><span class="token plain">       // Fatal 表示会导致当前这个请求出现提前终止的错误信息</span></div><div class="token-line"><span class="token plain">       Fatal(ctx context.Context, msg string, fields map[string]interface{})</span></div><div class="token-line"><span class="token plain">       // Error 表示出现错误，但是不一定影响后续请求逻辑的错误信息</span></div><div class="token-line"><span class="token plain">       Error(ctx context.Context, msg string, fields map[string]interface{})</span></div><div class="token-line"><span class="token plain">       // Warn 表示出现错误，但是一定不影响后续请求逻辑的报警信息</span></div><div class="token-line"><span class="token plain">       Warn(ctx context.Context, msg string, fields map[string]interface{})</span></div><div class="token-line"><span class="token plain">       // Info 表示正常的日志信息输出</span></div><div class="token-line"><span class="token plain">       Info(ctx context.Context, msg string, fields map[string]interface{})</span></div><div class="token-line"><span class="token plain">       // Debug 表示在调试状态下打印出来的日志信息</span></div><div class="token-line"><span class="token plain">       Debug(ctx context.Context, msg string, fields map[string]interface{})</span></div><div class="token-line"><span class="token plain">       // Trace 表示最详细的信息，一般信息量比较大，可能包含调用堆栈等信息</span></div><div class="token-line"><span class="token plain">       Trace(ctx context.Context, msg string, fields map[string]interface{})</span></div><div class="token-line"><span class="token plain">       // SetLevel 设置日志级别</span></div><div class="token-line"><span class="token plain">       SetLevel(level LogLevel)</span></div><div class="token-line"><span class="token plain">       ...</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>在接口中，我们针对七种日志级别设置了七个不同的方法，并且提供SetLevel方法，来设置当前这个日志服务需要输出的日志级别。</p><h3 id="日志格式"><a aria-hidden="true" tabindex="-1" href="/blog/手把手带你写一个web框架/03.实战第2关框架核心/13#日志格式"><span class="icon icon-link"></span></a>日志格式</h3><p>定义好了日志级别，下面该定义日志格式了。日志格式包括输出哪些内容、如何输出？</p><p>首先明确下需要输出的日志信息，不外乎有下面四个部分：</p><ul><li>日志级别，输出当前日志的级别信息。</li><li>日志时间，输出当前日志的打印时间。</li><li>日志简要信息，输出当前日志的简要描述信息，一句话说明日志错误。</li><li>日志上下文字段，输出当前日志的附带信息。这些字段代表日志打印的上下文。</li></ul><p>比如这就是一个完整的日志信息：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">[Info]  2021-09-22T00:04:21+08:00       &quot;demo test error&quot;       map[api:demo/demo cspan_id: parent_id: span_id:c55051d94815vbl56i2g trace_id:c55051d94815vbl56i20 user:jianfengye]</span></div></pre></div><p>上面那条日志，日志级别为Info，时间为2021-09-21年15:40:03，时区为+08:00。简要信息demo test error 表示这个日志希望打印的信息，剩下的map表示的key、value为补充的日志上下文字段。</p><p>它对应的调用函数如下：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">logger.Info(c, &quot;demo test error&quot;, map[string]interface{}{</span></div><div class="token-line"><span class="token plain">       &quot;api&quot;:  &quot;demo/demo&quot;,</span></div><div class="token-line"><span class="token plain">       &quot;user&quot;: &quot;jianfengye&quot;,</span></div><div class="token-line"><span class="token plain">    })</span></div></pre></div><p>这里我额外说一下日志上下文字段。它是一个map值，来源可能有两个：一个是用户在打印日志的时候传递的map，比如上面代码中的api和user；而另外一部分数据是可能来自context，因为在具体业务开发中，我们很有可能把一些通用信息，比如trace_id等放在context里，这一部分信息也会希望取出放在日志的上下文字段中。</p><p>所以这里有一个从context中获取日志上下文字段的方法。在framework/contract/log.go中定义其为CtxFielder。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// CtxFielder 定义了从context中获取信息的方法</span></div><div class="token-line"><span class="token plain">    type CtxFielder func(ctx context.Context) map[string]interface{}</span></div></pre></div><p>明确了打印哪些信息，更要明确这些信息按照什么输出格式输出。这个输出格式也是一个通用方法Fomatter，它的传入参数就是刚才的四个日志信息。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// Formatter 定义了将日志信息组织成字符串的通用方法</span></div><div class="token-line"><span class="token plain">    type Formatter func(level LogLevel, t time.Time, msg string, fields map[string]interface{}) ([]byte, error)</span></div></pre></div><p>同时在log服务协议中增加了SetFormatter 和 SetCtxFielder的方法。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// Log 定义了日志服务协议</span></div><div class="token-line"><span class="token plain">    type Log interface {</span></div><div class="token-line"><span class="token plain">       ...</span></div><div class="token-line"><span class="token plain">       // SetCtxFielder 从context中获取上下文字段field</span></div><div class="token-line"><span class="token plain">       SetCtxFielder(handler CtxFielder)</span></div><div class="token-line"><span class="token plain">       // SetFormatter 设置输出格式</span></div><div class="token-line"><span class="token plain">       SetFormatter(formatter Formatter)</span></div><div class="token-line"><span class="token plain">       ...</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><h3 id="日志输出"><a aria-hidden="true" tabindex="-1" href="/blog/手把手带你写一个web框架/03.实战第2关框架核心/13#日志输出"><span class="icon icon-link"></span></a>日志输出</h3><p>已经解决了前两个问题，明确了日志的级别和输出格式，那日志可以输出在哪些地方？</p><p>其实我们在定义接口的时候，并不知道它会输出到哪里。但是只需要知道一定会输出到某个输出管道就可以了，之后在每个应用中使用的时候，我们再根据每个应用的配置，来确认具体的输出管道实现。</p><p>目前这个输出管道我们使用io.Writer来进行设置：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// Log 定义了日志服务协议</span></div><div class="token-line"><span class="token plain">    type Log interface {</span></div><div class="token-line"><span class="token plain">       ...</span></div><div class="token-line"><span class="token plain">       // SetOutput 设置输出管道</span></div><div class="token-line"><span class="token plain">       SetOutput(out io.Writer)</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><h2 id="日志服务提供者"><a aria-hidden="true" tabindex="-1" href="/blog/手把手带你写一个web框架/03.实战第2关框架核心/13#日志服务提供者"><span class="icon icon-link"></span></a>日志服务提供者</h2><p>日志接口协议文件就完成了，下面来实现日志的服务提供者，在framework/provider/log/provider.go中。</p><p>在编写服务提供者的时候，我们需要先明确最终会提供哪些服务。对于日志服务，按照我们平时的使用情况，可以分为四类：</p><ul><li>控制台输出</li><li>本地单个日志文件输出</li><li>本地单个日志文件，自动进行切割输出</li><li>自定义输出</li></ul><p>这四种输出我们都各自定义一个服务，分别放在framework/provider/log/service/ 目录下的四个文件里：</p><ul><li>console.go 表示控制台输出，定义初始化实例方法NewHadeConsoleLog；</li><li>single.go 表述单个日志文件输出，定义初始化实例方法NewHadeSingleLog；</li><li>rotate.go 表示单个文件输出，但是自动进行切割，定义初始化实例方法NewHadeRotateLog；</li><li>custom.go 表示自定义输出，定义实例化方法NewHadeCustomLog。</li></ul><p>那在服务提供者的Register注册服务实例方法中，我们设计成根据配置项“log.driver” ，来选择不同的实例化方法，默认为NewHadeConsoleLog 方法。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// Register 注册一个服务实例</span></div><div class="token-line"><span class="token plain">    func (l *HadeLogServiceProvider) Register(c framework.Container) framework.NewInstance {</span></div><div class="token-line"><span class="token plain">       if l.Driver == &quot;&quot; {</span></div><div class="token-line"><span class="token plain">          tcs, err := c.Make(contract.ConfigKey)</span></div><div class="token-line"><span class="token plain">          if err != nil {</span></div><div class="token-line"><span class="token plain">             // 默认使用console</span></div><div class="token-line"><span class="token plain">             return services.NewHadeConsoleLog</span></div><div class="token-line"><span class="token plain">          }</span></div><div class="token-line"><span class="token plain">          cs := tcs.(contract.Config)</span></div><div class="token-line"><span class="token plain">          l.Driver = strings.ToLower(cs.GetString(&quot;log.Driver&quot;))</span></div><div class="token-line"><span class="token plain">       }</span></div><div class="token-line"><span class="token plain">       // 根据driver的配置项确定</span></div><div class="token-line"><span class="token plain">       switch l.Driver {</span></div><div class="token-line"><span class="token plain">       case &quot;single&quot;:</span></div><div class="token-line"><span class="token plain">          return services.NewHadeSingleLog</span></div><div class="token-line"><span class="token plain">       case &quot;rotate&quot;:</span></div><div class="token-line"><span class="token plain">          return services.NewHadeRotateLog</span></div><div class="token-line"><span class="token plain">       case &quot;console&quot;:</span></div><div class="token-line"><span class="token plain">          return services.NewHadeConsoleLog</span></div><div class="token-line"><span class="token plain">       case &quot;custom&quot;:</span></div><div class="token-line"><span class="token plain">          return services.NewHadeCustomLog</span></div><div class="token-line"><span class="token plain">       default:</span></div><div class="token-line"><span class="token plain">          return services.NewHadeConsoleLog</span></div><div class="token-line"><span class="token plain">       }</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>而上一节里面分析的，日志的几个配置：日志级别、输出格式方法、context内容获取方法、输出方法，都以服务提供者provider.go 中参数的方式提供。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// HadeLogServiceProvider 服务提供者</span></div><div class="token-line"><span class="token plain">    type HadeLogServiceProvider struct {</span></div><div class="token-line"><span class="token plain">       ...</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">       // 日志级别</span></div><div class="token-line"><span class="token plain">       Level contract.LogLevel</span></div><div class="token-line"><span class="token plain">       // 日志输出格式方法</span></div><div class="token-line"><span class="token plain">       Formatter contract.Formatter</span></div><div class="token-line"><span class="token plain">       // 日志context上下文信息获取函数</span></div><div class="token-line"><span class="token plain">       CtxFielder contract.CtxFielder</span></div><div class="token-line"><span class="token plain">       // 日志输出信息</span></div><div class="token-line"><span class="token plain">       Output io.Writer</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>默认提供两种输出格式，一种是文本输出形式，比如上面举的那个例子，</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">[Info]  2021-09-22T00:04:21+08:00       &quot;demo test error&quot;       map[api:demo/demo cspan_id: parent_id: span_id:c55051d94815vbl56i2g trace_id:c55051d94815vbl56i20 user:jianfengye]</span></div></pre></div><p>另外一种是JSON输出形式，如下：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">{&quot;api&quot;:&quot;demo/demo&quot;,&quot;cspan_id&quot;:&quot;&quot;,&quot;level&quot;:5,&quot;msg&quot;:&quot;demo1&quot;,&quot;parent_id&quot;:&quot;&quot;,&quot;span_id&quot;:&quot;c54v0tt9481537jasreg&quot;,&quot;timestamp&quot;:&quot;2021-09-21T22:47:19+08:00&quot;,&quot;trace_id&quot;:&quot;c54v0tt9481537jasre0&quot;,&quot;user&quot;:&quot;jianfengye&quot;}</span></div></pre></div><p>这两种输出除了格式不同，其中的内容应该是相同的。具体使用起来，文本输出更便于我们阅读，而JSON输出更便于机器或者程序阅读。</p><p>在实现文件夹framework/provider/log/formatter/ 里，我们增加两个文件json.go和text.go表示两种格式输出，对应的TextFormatter和JsonFormatter是对应的文本格式输出方法，</p><p>这里就贴出text.go的具体实现，很简单，其他的差别不大，可以参考<a target="_blank" rel="noopener noreferrer" href="https://github.com/gohade/coredemo/blob/geekbang/17/framework/provider/log/formatter/text.go">G<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a><a target="_blank" rel="noopener noreferrer" href="https://github.com/gohade/coredemo/blob/geekbang/17/framework/provider/log/formatter/text.go">it<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a><a target="_blank" rel="noopener noreferrer" href="https://github.com/gohade/coredemo/blob/geekbang/17/framework/provider/log/formatter/text.go">H<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a><a target="_blank" rel="noopener noreferrer" href="https://github.com/gohade/coredemo/blob/geekbang/17/framework/provider/log/formatter/text.go">ub<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// TextFormatter 表示文本格式输出</span></div><div class="token-line"><span class="token plain">    func TextFormatter(level contract.LogLevel, t time.Time, msg string, fields map[string]interface{}) ([]byte, error) {</span></div><div class="token-line"><span class="token plain">       bf := bytes.NewBuffer([]byte{})</span></div><div class="token-line"><span class="token plain">       Separator := &quot;\t&quot;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">       // 先输出日志级别</span></div><div class="token-line"><span class="token plain">       prefix := Prefix(level)</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">       bf.WriteString(prefix)</span></div><div class="token-line"><span class="token plain">       bf.WriteString(Separator)</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">       // 输出时间</span></div><div class="token-line"><span class="token plain">       ts := t.Format(time.RFC3339)</span></div><div class="token-line"><span class="token plain">       bf.WriteString(ts)</span></div><div class="token-line"><span class="token plain">       bf.WriteString(Separator)</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">       // 输出msg</span></div><div class="token-line"><span class="token plain">       bf.WriteString(&quot;\&quot;&quot;)</span></div><div class="token-line"><span class="token plain">       bf.WriteString(msg)</span></div><div class="token-line"><span class="token plain">       bf.WriteString(&quot;\&quot;&quot;)</span></div><div class="token-line"><span class="token plain">       bf.WriteString(Separator)</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">       // 输出map</span></div><div class="token-line"><span class="token plain">       bf.WriteString(fmt.Sprint(fields))</span></div><div class="token-line"><span class="token plain">       return bf.Bytes(), nil</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>再回到 framework/provider/log/provider.go，定义服务提供者的Params方法。比如获取格式化方法Formatter，我们就设定成，先判断在初始化的时候，是否定义了服务提供者；如果没有，再判断配置项log.formatter是否指定了格式化方法 json/text，设置最终的Formatter，并且传递实例化的方法。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// Params 定义要传递给实例化方法的参数</span></div><div class="token-line"><span class="token plain">    func (l *HadeLogServiceProvider) Params(c framework.Container) []interface{} {</span></div><div class="token-line"><span class="token plain">       // 获取configService</span></div><div class="token-line"><span class="token plain">       configService := c.MustMake(contract.ConfigKey).(contract.Config)</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">       // 设置参数formatter</span></div><div class="token-line"><span class="token plain">       if l.Formatter == nil {</span></div><div class="token-line"><span class="token plain">          l.Formatter = formatter.TextFormatter</span></div><div class="token-line"><span class="token plain">          if configService.IsExist(&quot;log.formatter&quot;) {</span></div><div class="token-line"><span class="token plain">             v := configService.GetString(&quot;log.formatter&quot;)</span></div><div class="token-line"><span class="token plain">             if v == &quot;json&quot; {</span></div><div class="token-line"><span class="token plain">                l.Formatter = formatter.JsonFormatter</span></div><div class="token-line"><span class="token plain">             } else if v == &quot;text&quot; {</span></div><div class="token-line"><span class="token plain">                l.Formatter = formatter.TextFormatter</span></div><div class="token-line"><span class="token plain">             }</span></div><div class="token-line"><span class="token plain">          }</span></div><div class="token-line"><span class="token plain">       }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">       if l.Level == contract.UnknownLevel {</span></div><div class="token-line"><span class="token plain">          l.Level = contract.InfoLevel</span></div><div class="token-line"><span class="token plain">          if configService.IsExist(&quot;log.level&quot;) {</span></div><div class="token-line"><span class="token plain">             l.Level = logLevel(configService.GetString(&quot;log.level&quot;))</span></div><div class="token-line"><span class="token plain">          }</span></div><div class="token-line"><span class="token plain">       }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">       // 定义5个参数</span></div><div class="token-line"><span class="token plain">       return []interface{}{c, l.Level, l.CtxFielder, l.Formatter, l.Output}</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>至于日志服务提供者的其他几个方法（Register、Boot、IsDefer、Name），就不在这里说明了，可以参考<a target="_blank" rel="noopener noreferrer" href="https://github.com/gohade/coredemo/blob/geekbang/17/framework/provider/log/provider.go">GitHub<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>上的代码。</p><h2 id="日志服务的具体实现"><a aria-hidden="true" tabindex="-1" href="/blog/手把手带你写一个web框架/03.实战第2关框架核心/13#日志服务的具体实现"><span class="icon icon-link"></span></a>日志服务的具体实现</h2><p>最后就到具体的日志服务的实现了。上面我们说，针对四种不同的输出方式，定义了四个不同的服务实例，<strong>这四个不同的服务实例都需要实现前面定义的日志服务协议。如果每个实例都实现一遍，还是非常麻烦的。这里可以使用一个技巧：类型嵌套</strong>。</p><p>我们先创建一个通用的服务实例HadeLog，在HadeLog中存放通用的字段，比如上述日志服务提供者传递的五个参数：container、level、ctxFielder、formatter、output。</p><p>在 provider/log/services/log.go中定义这个结构：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// HadeLog 的通用实例</span></div><div class="token-line"><span class="token plain">    type HadeLog struct {</span></div><div class="token-line"><span class="token plain">       // 五个必要参数</span></div><div class="token-line"><span class="token plain">       level      contract.LogLevel   // 日志级别</span></div><div class="token-line"><span class="token plain">       formatter  contract.Formatter  // 日志格式化方法</span></div><div class="token-line"><span class="token plain">       ctxFielder contract.CtxFielder // ctx获取上下文字段</span></div><div class="token-line"><span class="token plain">       output     io.Writer           // 输出</span></div><div class="token-line"><span class="token plain">       c          framework.Container // 容器</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>接着在通用实例中，使用这几个必要的参数，就能实现日志协议的所有接口了，这里展示了Info方法是怎么打印信息的：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// Info 会打印出普通的日志信息</span></div><div class="token-line"><span class="token plain">    func (log *HadeLog) Info(ctx context.Context, msg string, fields map[string]interface{}) {</span></div><div class="token-line"><span class="token plain">       log.logf(contract.InfoLevel, ctx, msg, fields)</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    // logf 为打印日志的核心函数</span></div><div class="token-line"><span class="token plain">    func (log *HadeLog) logf(level contract.LogLevel, ctx context.Context, msg string, fields map[string]interface{}) error {</span></div><div class="token-line"><span class="token plain">       // 先判断日志级别</span></div><div class="token-line"><span class="token plain">       if !log.IsLevelEnable(level) {</span></div><div class="token-line"><span class="token plain">          return nil</span></div><div class="token-line"><span class="token plain">       }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">       // 使用ctxFielder 获取context中的信息</span></div><div class="token-line"><span class="token plain">       fs := fields</span></div><div class="token-line"><span class="token plain">       if log.ctxFielder != nil {</span></div><div class="token-line"><span class="token plain">          t := log.ctxFielder(ctx)</span></div><div class="token-line"><span class="token plain">          if t != nil {</span></div><div class="token-line"><span class="token plain">             for k, v := range t {</span></div><div class="token-line"><span class="token plain">                fs[k] = v</span></div><div class="token-line"><span class="token plain">             }</span></div><div class="token-line"><span class="token plain">          }</span></div><div class="token-line"><span class="token plain">       }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">       ...</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">       // 将日志信息按照formatter序列化为字符串</span></div><div class="token-line"><span class="token plain">       if log.formatter == nil {</span></div><div class="token-line"><span class="token plain">          log.formatter = formatter.TextFormatter</span></div><div class="token-line"><span class="token plain">       }</span></div><div class="token-line"><span class="token plain">       ct, err := log.formatter(level, time.Now(), msg, fs)</span></div><div class="token-line"><span class="token plain">       if err != nil {</span></div><div class="token-line"><span class="token plain">          return err</span></div><div class="token-line"><span class="token plain">       }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">       // 如果是panic级别，则使用log进行panic</span></div><div class="token-line"><span class="token plain">       if level == contract.PanicLevel {</span></div><div class="token-line"><span class="token plain">          pkgLog.Panicln(string(ct))</span></div><div class="token-line"><span class="token plain">          return nil</span></div><div class="token-line"><span class="token plain">       }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">       // 通过output进行输出</span></div><div class="token-line"><span class="token plain">       log.output.Write(ct)</span></div><div class="token-line"><span class="token plain">       log.output.Write([]byte(&quot;\r\n&quot;))</span></div><div class="token-line"><span class="token plain">       return nil</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>可以看到，Info打印最终调用logf 方法，而logf方法的实现步骤也很清晰，简单梳理一下：</p><ul><li>先判断日志级别是否符合要求，如果不符合要求，则直接返回，不进行打印；</li><li>再使用ctxFielder，从context中获取信息放在上下文字段中；</li><li>接着将日志信息按照formatter序列化为字符串；</li><li>最后通过output进行输出。</li></ul><p>HadeLog其他方法的实现和Info大同小异，这里就不展示所有代码了。实现了基础的HadeLog实例，接下来，就实现对应的四个不同输出类型的实例HadeConsoleLog、HadeSingleLog、HadeRotateLog、HadeCustomLog。<br/><img src="https://static001.geekbang.org/resource/image/f2/a5/f2a9c4d54dyy468f00ce97f8888049a5.jpg?wh=1920x1080" alt=""/></p><p>这里四个具体实例使用类型嵌套的方式，就能自动拥有HadeLog已经实现了的那些方法。</p><p>比如在 framework/provider/log/service/console.log 中，使用类型嵌套实现 HadeConsoleLog：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// HadeConsoleLog 代表控制台输出</span></div><div class="token-line"><span class="token plain">    type HadeConsoleLog struct {</span></div><div class="token-line"><span class="token plain">       // 类型嵌套HadeLog</span></div><div class="token-line"><span class="token plain">       HadeLog</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>相当于 HadeConsoleLog 就已经实现了日志服务协议了。我们唯一要做的就是在实例化HadeConosoleLog的时候，将基础HadeLog中的通用字段进行填充。比如 HadeConsoleLog 最重要就是将输出类型output设置为控制台os.stdout：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// NewHadeConsoleLog 实例化HadeConsoleLog</span></div><div class="token-line"><span class="token plain">    func NewHadeConsoleLog(params ...interface{}) (interface{}, error) {</span></div><div class="token-line"><span class="token plain">       c := params[0].(framework.Container)</span></div><div class="token-line"><span class="token plain">       level := params[1].(contract.LogLevel)</span></div><div class="token-line"><span class="token plain">       ctxFielder := params[2].(contract.CtxFielder)</span></div><div class="token-line"><span class="token plain">       formatter := params[3].(contract.Formatter)</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">       log := &amp;HadeConsoleLog{}</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">       log.SetLevel(level)</span></div><div class="token-line"><span class="token plain">       log.SetCtxFielder(ctxFielder)</span></div><div class="token-line"><span class="token plain">       log.SetFormatter(formatter)</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">       // 最重要的将内容输出到控制台</span></div><div class="token-line"><span class="token plain">       log.SetOutput(os.Stdout)</span></div><div class="token-line"><span class="token plain">       log.c = c</span></div><div class="token-line"><span class="token plain">       return log, nil</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>四种输出文件其实都大同小异，这里就挑选一个最复杂的带有日志切割的HadeRotateLog来讲解。</p><p>Golang中日志切割有个非常好用的 <a target="_blank" rel="noopener noreferrer" href="https://github.com/lestrrat-go/file-rotatelogs">file-rotatelogs<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>，这个库的使用方法也不复杂，最核心的就是一个初始化操作New：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">func New(p string, options ...Option) (*RotateLogs, error)</span></div></pre></div><p>它有两个参数，第一个参数p是带目录的日志地址，可以允许有通配符代表日期的日志文件名。这里的通配符符合Linux的strftime的定义，具体哪个通配符代表日期、小时、分钟等可以参考strftime的<a target="_blank" rel="noopener noreferrer" href="https://man7.org/linux/man-pages/man3/strftime.3.html">文档说明<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>。而第二个参数是Option数组，表示这个切割日志的一些配置，比如多久切割一次日志文件、切割后的日志文件保存多少天等。</p><p>使用很简单，直接看我们对HadeRotateLog的具体实现。大致思路就是<strong>先定义结构，再实现初始化方法，在初始化方法中，我们实例化file-rotatelogs的初始化操作New</strong>。</p><p>首先定义了 HadeRotateLog 的结构，其中嵌套了基础实例结构HadeLog，同时有这个结构特定的字段folder和file：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// HadeRotateLog 代表会进行切割的日志文件存储</span></div><div class="token-line"><span class="token plain">    type HadeRotateLog struct {</span></div><div class="token-line"><span class="token plain">       HadeLog</span></div><div class="token-line"><span class="token plain">       // 日志文件存储目录</span></div><div class="token-line"><span class="token plain">       folder string</span></div><div class="token-line"><span class="token plain">       // 日志文件名</span></div><div class="token-line"><span class="token plain">       file string</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>实例化的NewHadeRotateLog 先获取参数，然后从配置文件中获取参数属性folder、file、date_format、rotate_count、rotate_size、max_age、rotate_time，这些属性都和 file-rotatelogs 库实例化的Option参数一一对应。</p><p>所以这里也展示一下我们的log.yaml配置文件可配置的rotate：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">driver: rotate # 切割日志</span></div><div class="token-line"><span class="token plain">    level: trace # 日志级别</span></div><div class="token-line"><span class="token plain">    file: coredemo.log # 保存的日志文件</span></div><div class="token-line"><span class="token plain">    rotate_count: 10  # 最多日志文件个数</span></div><div class="token-line"><span class="token plain">    rotate_size: 120000 # 每个日志大小</span></div><div class="token-line"><span class="token plain">    rotate_time: &quot;1m&quot; # 切割时间</span></div><div class="token-line"><span class="token plain">    max_age: &quot;10d&quot; # 文件保存时间</span></div><div class="token-line"><span class="token plain">    date_format: &quot;%Y-%m-%d-%H-%M&quot; # 文件后缀格式</span></div></pre></div><p>再回到 NewHadeRotateLog，设置了这些配置属性之后，我们实例化 file-rotatelogs，得到了一个符合io.Writer的输出，将这个输出使用 SetOutput 设置到嵌套的 HadeLog 中即可。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// NewHadeRotateLog 实例化HadeRotateLog</span></div><div class="token-line"><span class="token plain">    func NewHadeRotateLog(params ...interface{}) (interface{}, error) {</span></div><div class="token-line"><span class="token plain">       // 参数解析</span></div><div class="token-line"><span class="token plain">       c := params[0].(framework.Container)</span></div><div class="token-line"><span class="token plain">       level := params[1].(contract.LogLevel)</span></div><div class="token-line"><span class="token plain">       ctxFielder := params[2].(contract.CtxFielder)</span></div><div class="token-line"><span class="token plain">       formatter := params[3].(contract.Formatter)</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">       appService := c.MustMake(contract.AppKey).(contract.App)</span></div><div class="token-line"><span class="token plain">       configService := c.MustMake(contract.ConfigKey).(contract.Config)</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">       // 从配置文件中获取folder信息，否则使用默认的LogFolder文件夹</span></div><div class="token-line"><span class="token plain">       folder := appService.LogFolder()</span></div><div class="token-line"><span class="token plain">       if configService.IsExist(&quot;log.folder&quot;) {</span></div><div class="token-line"><span class="token plain">          folder = configService.GetString(&quot;log.folder&quot;)</span></div><div class="token-line"><span class="token plain">       }</span></div><div class="token-line"><span class="token plain">       // 如果folder不存在，则创建</span></div><div class="token-line"><span class="token plain">       if !util.Exists(folder) {</span></div><div class="token-line"><span class="token plain">          os.MkdirAll(folder, os.ModePerm)</span></div><div class="token-line"><span class="token plain">       }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">       // 从配置文件中获取file信息，否则使用默认的hade.log</span></div><div class="token-line"><span class="token plain">       file := &quot;hade.log&quot;</span></div><div class="token-line"><span class="token plain">       if configService.IsExist(&quot;log.file&quot;) {</span></div><div class="token-line"><span class="token plain">          file = configService.GetString(&quot;log.file&quot;)</span></div><div class="token-line"><span class="token plain">       }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">       // 从配置文件获取date_format信息</span></div><div class="token-line"><span class="token plain">       dateFormat := &quot;%Y%m%d%H&quot;</span></div><div class="token-line"><span class="token plain">       if configService.IsExist(&quot;log.date_format&quot;) {</span></div><div class="token-line"><span class="token plain">          dateFormat = configService.GetString(&quot;log.date_format&quot;)</span></div><div class="token-line"><span class="token plain">       }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">       linkName := rotatelogs.WithLinkName(filepath.Join(folder, file))</span></div><div class="token-line"><span class="token plain">       options := []rotatelogs.Option{linkName}</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">       // 从配置文件获取rotate_count信息</span></div><div class="token-line"><span class="token plain">       if configService.IsExist(&quot;log.rotate_count&quot;) {</span></div><div class="token-line"><span class="token plain">          rotateCount := configService.GetInt(&quot;log.rotate_count&quot;)</span></div><div class="token-line"><span class="token plain">          options = append(options, rotatelogs.WithRotationCount(uint(rotateCount)))</span></div><div class="token-line"><span class="token plain">       }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">       // 从配置文件获取rotate_size信息</span></div><div class="token-line"><span class="token plain">       if configService.IsExist(&quot;log.rotate_size&quot;) {</span></div><div class="token-line"><span class="token plain">          rotateSize := configService.GetInt(&quot;log.rotate_size&quot;)</span></div><div class="token-line"><span class="token plain">          options = append(options, rotatelogs.WithRotationSize(int64(rotateSize)))</span></div><div class="token-line"><span class="token plain">       }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">       // 从配置文件获取max_age信息</span></div><div class="token-line"><span class="token plain">       if configService.IsExist(&quot;log.max_age&quot;) {</span></div><div class="token-line"><span class="token plain">          if maxAgeParse, err := time.ParseDuration(configService.GetString(&quot;log.max_age&quot;)); err == nil {</span></div><div class="token-line"><span class="token plain">             options = append(options, rotatelogs.WithMaxAge(maxAgeParse))</span></div><div class="token-line"><span class="token plain">          }</span></div><div class="token-line"><span class="token plain">       }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">       // 从配置文件获取rotate_time信息</span></div><div class="token-line"><span class="token plain">       if configService.IsExist(&quot;log.rotate_time&quot;) {</span></div><div class="token-line"><span class="token plain">          if rotateTimeParse, err := time.ParseDuration(configService.GetString(&quot;log.rotate_time&quot;)); err == nil {</span></div><div class="token-line"><span class="token plain">             options = append(options, rotatelogs.WithRotationTime(rotateTimeParse))</span></div><div class="token-line"><span class="token plain">          }</span></div><div class="token-line"><span class="token plain">       }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">       // 设置基础信息</span></div><div class="token-line"><span class="token plain">       log := &amp;HadeRotateLog{}</span></div><div class="token-line"><span class="token plain">       log.SetLevel(level)</span></div><div class="token-line"><span class="token plain">       log.SetCtxFielder(ctxFielder)</span></div><div class="token-line"><span class="token plain">       log.SetFormatter(formatter)</span></div><div class="token-line"><span class="token plain">       log.folder = folder</span></div><div class="token-line"><span class="token plain">       log.file = file</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">       w, err := rotatelogs.New(fmt.Sprintf(&quot;%s.%s&quot;, filepath.Join(log.folder, log.file), dateFormat), options...)</span></div><div class="token-line"><span class="token plain">       if err != nil {</span></div><div class="token-line"><span class="token plain">          return nil, errors.Wrap(err, &quot;new rotatelogs error&quot;)</span></div><div class="token-line"><span class="token plain">       }</span></div><div class="token-line"><span class="token plain">       log.SetOutput(w)</span></div><div class="token-line"><span class="token plain">       log.c = c</span></div><div class="token-line"><span class="token plain">       return log, nil</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>本节课我们只是修改了框架目录中的日志服务相关的文件。文件目录：</p><p><img src="https://static001.geekbang.org/resource/image/8c/a8/8c305493bba44f8787efecdf1a8694a8.png?wh=404x512" alt="图片"/></p><p><img src="https://static001.geekbang.org/resource/image/e7/2e/e78a3a67060e989616fa0440bd792d2e.png?wh=630x1122" alt="图片"/></p><p>所有代码都放在GitHub上的 <a target="_blank" rel="noopener noreferrer" href="https://github.com/gohade/coredemo/tree/geekbang/17">geekbang/17<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 分支，欢迎比对查看。</p><h2 id="小结"><a aria-hidden="true" tabindex="-1" href="/blog/手把手带你写一个web框架/03.实战第2关框架核心/13#小结"><span class="icon icon-link"></span></a>小结</h2><p>我们这节课通过定义了日志级别、日志格式、日志输出，来实现了日志的级别，并且使用类型嵌套方法实现了四种本地日志输出方式。</p><p>回顾今天实现的日志服务，你会发现和其他服务的实现思路是差不多的。我们<strong>在一个服务中，实现了多个实现类，但是所有的实现类都实现了同样的服务接口</strong>，最后能让我们根据配置来决定这个服务使用哪个实现类，其中还使用了嵌套方式，能节省大量重复性的代码。</p><p>希望你能熟练掌握这种实现方式，因为我们的服务会越来越多，越上层的服务，比如数据库、缓存，它的具体实现就越是多种多样，到时候我们都可以用同样的套路来进行。</p><h2 id="思考题"><a aria-hidden="true" tabindex="-1" href="/blog/手把手带你写一个web框架/03.实战第2关框架核心/13#思考题"><span class="icon icon-link"></span></a>思考题</h2><p>在微服务盛行的今天，全链路日志是非常重要的一个需求。全链路日志的需求本质就是在日志中增加trace_id、span_id 这样的链路字段。具体实现有三点：</p><ul><li>在接收请求的时候，从请求request中解析全链路字段，存放进入context中</li><li>在打印日志的时候从context中获取全链路字段序列化进入日志</li><li>在发送请求的时候将全链路字段加入到request中</li></ul><p>你可以思考下这个功能应该怎么实现？</p><p>欢迎在留言区分享你的思考。感谢你的收听，如果觉得有收获，也欢迎把今天的内容分享给你身边的朋友，邀他一起学习。我们下节课见。</p></div><div class="__dumi-default-layout-footer-meta"><a target="_blank" rel="noopener noreferrer" href="https://github.com/GGwujun/blog/edit/master/docs/手把手带你写一个Web框架/03.实战第2关框架核心/13.md">在 GitHub 上编辑此页<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a><span data-updated-text="最后更新时间：">5/2/2022 10:56:58</span></div></div></div></div>
	<script>
  window.g_useSSR = true;
  window.g_initialProps = {};
	</script>

    <script>
      (function () {
        if (!location.port) {
          (function (i, s, o, g, r, a, m) {
            i["GoogleAnalyticsObject"] = r;
            (i[r] =
              i[r] ||
              function () {
                (i[r].q = i[r].q || []).push(arguments);
              }),
              (i[r].l = 1 * new Date());
            (a = s.createElement(o)), (m = s.getElementsByTagName(o)[0]);
            a.async = 1;
            a.src = g;
            m.parentNode.insertBefore(a, m);
          })(
            window,
            document,
            "script",
            "//www.google-analytics.com/analytics.js",
            "ga"
          );
          ga("create", "UA-149864185-1", "auto");
          ga("send", "pageview");
        }
      })();
    </script>
    <script src="/blog/umi.js"></script>
  </body>
</html>
