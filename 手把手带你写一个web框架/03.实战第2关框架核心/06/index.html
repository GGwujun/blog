<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no"
    />
    <link rel="shortcut icon" type="image/x-icon" href="/logo.png" />
    <link rel="stylesheet" href="/blog/umi.css" />
    <script>
      window.routerBase = "/blog";
    </script>
    <script>
      //! umi version: 3.5.17
    </script>
    <script>
      !(function () {
        var e = localStorage.getItem("dumi:prefers-color"),
          t = window.matchMedia("(prefers-color-scheme: dark)").matches,
          r = ["light", "dark", "auto"];
        document.documentElement.setAttribute(
          "data-prefers-color",
          e === r[2] ? (t ? r[1] : r[0]) : r.indexOf(e) > -1 ? e : r[0]
        );
      })();
    </script>
    <title>10｜面向接口编程（上）：一切皆服务，服务基于协议</title>
  </head>
  <body>
    <div id="root"><div class="__dumi-default-layout" data-route="/手把手带你写一个web框架/03.实战第2关框架核心/06" data-show-sidemenu="true" data-show-slugs="true" data-site-mode="true" data-gapless="false"><div class="__dumi-default-navbar" data-mode="site"><button class="__dumi-default-navbar-toggle"></button><a class="__dumi-default-navbar-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog/">大师兄</a><nav><div class="__dumi-default-search"><input type="search" class="__dumi-default-search-input" value=""/><ul></ul></div><span>计算机基础<ul><li><a href="/blog/编译原理之美">编译原理之美</a></li><li><a href="/blog/编译原理实战">编译原理实战</a></li><li><a href="/blog/深入浅出计算机组成原理">深入浅出计算机组成原理</a></li><li><a href="/blog/详解http">详解http</a></li><li><a href="/blog/计算机网络通关29讲">计算机网络通关29讲</a></li><li><a href="/blog/网络排查案例课">网络排查案例课</a></li><li><a href="/blog/linux操作系统">linux操作系统</a></li><li><a href="/blog/linux性能优化实战">linux性能优化实战</a></li><li><a href="/blog/程序员数学基础">程序员数学基础</a></li><li><a href="/blog/趣谈网络协议">趣谈网络协议</a></li><li><a href="/blog/操作系统实战">操作系统实战</a></li><li><a href="/blog/软件工程之美">软件工程之美</a></li><li><a href="/blog/sql必知必会">sql必知必会</a></li><li><a href="/blog/操作系统实战45讲">操作系统实战45讲</a></li><li><a href="/blog/网络编程实战">网络编程实战</a></li></ul></span><span>算法<ul><li><a href="/blog/常用算法25讲">常用算法25讲</a></li><li><a href="/blog/数据结构与算法之美">数据结构与算法之美</a></li><li><a href="/blog/业务开发算法50讲">业务开发算法50讲</a></li><li><a href="/blog/动态规划面试宝典">动态规划面试宝典</a></li></ul></span><span>前端开发<ul><li><a href="/blog/浏览器工作原理与实践">浏览器工作原理与实践</a></li><li><a href="/blog/新时代产品经理进阶之路">新时代产品经理进阶之路</a></li><li><a href="/blog/全栈工程师修炼指南">全栈工程师修炼指南</a></li><li><a href="/blog/flutter核心技术与实战">flutter核心技术与实战</a></li><li><a href="/blog/java-script核心原理解析">java-script核心原理解析</a></li><li><a href="/blog/说透低代码">说透低代码</a></li><li><a href="/blog/nodejs应用开发实战">nodejs应用开发实战</a></li><li><a href="/blog/反爬虫兵法演绎20讲">反爬虫兵法演绎20讲</a></li><li><a href="/blog/reactnative新架构实战课">reactnative新架构实战课</a></li><li><a href="/blog/正则表达式入门">正则表达式入门</a></li><li><a href="/blog/重学前端">重学前端</a></li><li><a href="/blog/serverless入门课">serverless入门课</a></li><li><a href="/blog/type-script入门实战笔记">type-script入门实战笔记</a></li><li><a href="/blog/图解googlev8">图解googlev8</a></li><li><a href="/blog/vue3源码分析">vue3源码分析</a></li><li><a href="/blog/玩转Vue3全家桶">玩转Vue3全家桶</a></li><li><a href="/blog/webassembly入门">webassembly入门</a></li><li><a aria-current="page" class="active" href="/blog/手把手带你写一个Web框架">手把手带你写一个Web框架</a></li><li><a href="/blog/web漏洞挖掘实战">web漏洞挖掘实战</a></li><li><a href="/blog/跟月影学可视化">跟月影学可视化</a></li><li><a href="/blog/搞定音频技术">搞定音频技术</a></li><li><a href="/blog/攻克视频技术">攻克视频技术</a></li></ul></span><span>前端工程化<ul><li><a href="/blog/logger">logger</a></li><li><a href="/blog/webpack">webpack</a></li><li><a href="/blog/webpackChain">webpackChain</a></li></ul></span><span>前端性能优化<ul><li><a href="/blog/react性能调优">react性能调优</a></li></ul></span><span>软件测试<ul><li><a href="/blog/全链路压测实战30讲">全链路压测实战30讲</a></li><li><a href="/blog/性能测试实战30讲">性能测试实战30讲</a></li><li><a href="/blog/自动化测试高手课">自动化测试高手课</a></li><li><a href="/blog/软件测试52讲">软件测试52讲</a></li></ul></span><span>面试<ul><li><a href="/blog/面试现场">面试现场</a></li></ul></span><span>杂谈<ul><li><a href="/blog/超级访谈对话张雪峰">超级访谈对话张雪峰</a></li><li><a href="/blog/Git实战手册">Git实战手册</a></li><li><a href="/blog/NodeJS">NodeJS</a></li><li><a href="/blog/ReactJS">ReactJS</a></li><li><a href="/blog/UI设计">UI设计</a></li><li><a href="/blog/webpack4系列教程">webpack4系列教程</a></li><li><a href="/blog/前端知识体系">前端知识体系</a></li><li><a href="/blog/剑指offer刷题笔记">剑指offer刷题笔记</a></li><li><a href="/blog/思考与成长">思考与成长</a></li><li><a href="/blog/设计模式手册">设计模式手册</a></li></ul></span><div class="__dumi-default-navbar-tool"><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "></div></div></div></nav></div><div class="__dumi-default-menu" data-mode="site"><div class="__dumi-default-menu-inner"><div class="__dumi-default-menu-header"><a class="__dumi-default-menu-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog/"></a><h1>大师兄</h1><p></p></div><div class="__dumi-default-menu-mobile-area"><ul class="__dumi-default-menu-nav-list"><li>计算机基础<ul><li><a href="/blog/编译原理之美">编译原理之美</a></li><li><a href="/blog/编译原理实战">编译原理实战</a></li><li><a href="/blog/深入浅出计算机组成原理">深入浅出计算机组成原理</a></li><li><a href="/blog/详解http">详解http</a></li><li><a href="/blog/计算机网络通关29讲">计算机网络通关29讲</a></li><li><a href="/blog/网络排查案例课">网络排查案例课</a></li><li><a href="/blog/linux操作系统">linux操作系统</a></li><li><a href="/blog/linux性能优化实战">linux性能优化实战</a></li><li><a href="/blog/程序员数学基础">程序员数学基础</a></li><li><a href="/blog/趣谈网络协议">趣谈网络协议</a></li><li><a href="/blog/操作系统实战">操作系统实战</a></li><li><a href="/blog/软件工程之美">软件工程之美</a></li><li><a href="/blog/sql必知必会">sql必知必会</a></li><li><a href="/blog/操作系统实战45讲">操作系统实战45讲</a></li><li><a href="/blog/网络编程实战">网络编程实战</a></li></ul></li><li>算法<ul><li><a href="/blog/常用算法25讲">常用算法25讲</a></li><li><a href="/blog/数据结构与算法之美">数据结构与算法之美</a></li><li><a href="/blog/业务开发算法50讲">业务开发算法50讲</a></li><li><a href="/blog/动态规划面试宝典">动态规划面试宝典</a></li></ul></li><li>前端开发<ul><li><a href="/blog/浏览器工作原理与实践">浏览器工作原理与实践</a></li><li><a href="/blog/新时代产品经理进阶之路">新时代产品经理进阶之路</a></li><li><a href="/blog/全栈工程师修炼指南">全栈工程师修炼指南</a></li><li><a href="/blog/flutter核心技术与实战">flutter核心技术与实战</a></li><li><a href="/blog/java-script核心原理解析">java-script核心原理解析</a></li><li><a href="/blog/说透低代码">说透低代码</a></li><li><a href="/blog/nodejs应用开发实战">nodejs应用开发实战</a></li><li><a href="/blog/反爬虫兵法演绎20讲">反爬虫兵法演绎20讲</a></li><li><a href="/blog/reactnative新架构实战课">reactnative新架构实战课</a></li><li><a href="/blog/正则表达式入门">正则表达式入门</a></li><li><a href="/blog/重学前端">重学前端</a></li><li><a href="/blog/serverless入门课">serverless入门课</a></li><li><a href="/blog/type-script入门实战笔记">type-script入门实战笔记</a></li><li><a href="/blog/图解googlev8">图解googlev8</a></li><li><a href="/blog/vue3源码分析">vue3源码分析</a></li><li><a href="/blog/玩转Vue3全家桶">玩转Vue3全家桶</a></li><li><a href="/blog/webassembly入门">webassembly入门</a></li><li><a aria-current="page" class="active" href="/blog/手把手带你写一个Web框架">手把手带你写一个Web框架</a></li><li><a href="/blog/web漏洞挖掘实战">web漏洞挖掘实战</a></li><li><a href="/blog/跟月影学可视化">跟月影学可视化</a></li><li><a href="/blog/搞定音频技术">搞定音频技术</a></li><li><a href="/blog/攻克视频技术">攻克视频技术</a></li></ul></li><li>前端工程化<ul><li><a href="/blog/logger">logger</a></li><li><a href="/blog/webpack">webpack</a></li><li><a href="/blog/webpackChain">webpackChain</a></li></ul></li><li>前端性能优化<ul><li><a href="/blog/react性能调优">react性能调优</a></li></ul></li><li>软件测试<ul><li><a href="/blog/全链路压测实战30讲">全链路压测实战30讲</a></li><li><a href="/blog/性能测试实战30讲">性能测试实战30讲</a></li><li><a href="/blog/自动化测试高手课">自动化测试高手课</a></li><li><a href="/blog/软件测试52讲">软件测试52讲</a></li></ul></li><li>面试<ul><li><a href="/blog/面试现场">面试现场</a></li></ul></li><li>杂谈<ul><li><a href="/blog/超级访谈对话张雪峰">超级访谈对话张雪峰</a></li><li><a href="/blog/Git实战手册">Git实战手册</a></li><li><a href="/blog/NodeJS">NodeJS</a></li><li><a href="/blog/ReactJS">ReactJS</a></li><li><a href="/blog/UI设计">UI设计</a></li><li><a href="/blog/webpack4系列教程">webpack4系列教程</a></li><li><a href="/blog/前端知识体系">前端知识体系</a></li><li><a href="/blog/剑指offer刷题笔记">剑指offer刷题笔记</a></li><li><a href="/blog/思考与成长">思考与成长</a></li><li><a href="/blog/设计模式手册">设计模式手册</a></li></ul></li></ul><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "><button title="Dark theme" class="__dumi-default-dark-moon "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="3854" width="22" height="22"><path d="M991.816611 674.909091a69.166545 69.166545 0 0 0-51.665455-23.272727 70.795636 70.795636 0 0 0-27.438545 5.585454A415.674182 415.674182 0 0 1 754.993338 698.181818c-209.594182 0-393.472-184.785455-393.472-395.636363 0-52.363636 38.539636-119.621818 69.515637-173.614546 4.887273-8.610909 9.634909-16.756364 14.103272-24.901818A69.818182 69.818182 0 0 0 384.631156 0a70.842182 70.842182 0 0 0-27.438545 5.585455C161.678429 90.298182 14.362065 307.898182 14.362065 512c0 282.298182 238.824727 512 532.38691 512a522.286545 522.286545 0 0 0 453.957818-268.334545A69.818182 69.818182 0 0 0 991.816611 674.909091zM546.679156 954.181818c-248.785455 0-462.941091-192-462.941091-442.181818 0-186.647273 140.637091-372.829091 300.939637-442.181818-36.817455 65.629091-92.578909 151.970909-92.578909 232.727273 0 250.181818 214.109091 465.454545 462.917818 465.454545a488.331636 488.331636 0 0 0 185.181091-46.545455 453.003636 453.003636 0 0 1-393.565091 232.727273z m103.656728-669.323636l-14.266182 83.781818a34.909091 34.909091 0 0 0 50.362182 36.770909l74.775272-39.563636 74.752 39.563636a36.142545 36.142545 0 0 0 16.174546 3.956364 34.909091 34.909091 0 0 0 34.210909-40.727273l-14.289455-83.781818 60.509091-59.345455a35.025455 35.025455 0 0 0-19.223272-59.578182l-83.61891-12.101818-37.376-76.101818a34.56 34.56 0 0 0-62.254545 0l-37.376 76.101818-83.618909 12.101818a34.909091 34.909091 0 0 0-19.246546 59.578182z m70.423272-64.698182a34.280727 34.280727 0 0 0 26.135273-19.083636l14.312727-29.090909 14.336 29.090909a34.257455 34.257455 0 0 0 26.135273 19.083636l32.046546 4.887273-23.272728 22.574545a35.234909 35.234909 0 0 0-10.007272 30.952727l5.46909 32.116364-28.625454-15.127273a34.490182 34.490182 0 0 0-32.302546 0l-28.695272 15.127273 5.469091-32.116364a35.141818 35.141818 0 0 0-9.984-30.952727l-23.272728-22.574545z" p-id="3855"></path></svg></button><button title="Light theme" class="__dumi-default-dark-sun "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="4026" width="22" height="22"><path d="M915.2 476.16h-43.968c-24.704 0-44.736 16-44.736 35.84s20.032 35.904 44.736 35.904H915.2c24.768 0 44.8-16.064 44.8-35.904s-20.032-35.84-44.8-35.84zM512 265.6c-136.704 0-246.464 109.824-246.464 246.4 0 136.704 109.76 246.464 246.464 246.464S758.4 648.704 758.4 512c0-136.576-109.696-246.4-246.4-246.4z m0 425.6c-99.008 0-179.2-80.128-179.2-179.2 0-98.944 80.192-179.2 179.2-179.2S691.2 413.056 691.2 512c0 99.072-80.192 179.2-179.2 179.2zM197.44 512c0-19.84-19.136-35.84-43.904-35.84H108.8c-24.768 0-44.8 16-44.8 35.84s20.032 35.904 44.8 35.904h44.736c24.768 0 43.904-16.064 43.904-35.904zM512 198.464c19.776 0 35.84-20.032 35.84-44.8v-44.8C547.84 84.032 531.84 64 512 64s-35.904 20.032-35.904 44.8v44.8c0 24.768 16.128 44.864 35.904 44.864z m0 627.136c-19.776 0-35.904 20.032-35.904 44.8v44.736C476.096 940.032 492.16 960 512 960s35.84-20.032 35.84-44.8v-44.736c0-24.768-16.064-44.864-35.84-44.864z m329.92-592.832c17.472-17.536 20.288-43.072 6.4-57.024-14.016-14.016-39.488-11.2-57.024 6.336-4.736 4.864-26.496 26.496-31.36 31.36-17.472 17.472-20.288 43.008-6.336 57.024 13.952 14.016 39.488 11.2 57.024-6.336 4.8-4.864 26.496-26.56 31.296-31.36zM213.376 759.936c-4.864 4.8-26.56 26.624-31.36 31.36-17.472 17.472-20.288 42.944-6.4 56.96 14.016 13.952 39.552 11.2 57.024-6.336 4.8-4.736 26.56-26.496 31.36-31.36 17.472-17.472 20.288-43.008 6.336-56.96-14.016-13.952-39.552-11.072-56.96 6.336z m19.328-577.92c-17.536-17.536-43.008-20.352-57.024-6.336-14.08 14.016-11.136 39.488 6.336 57.024 4.864 4.864 26.496 26.56 31.36 31.424 17.536 17.408 43.008 20.288 56.96 6.336 14.016-14.016 11.264-39.488-6.336-57.024-4.736-4.864-26.496-26.56-31.296-31.424z m527.168 628.608c4.864 4.864 26.624 26.624 31.36 31.424 17.536 17.408 43.072 20.224 57.088 6.336 13.952-14.016 11.072-39.552-6.4-57.024-4.864-4.8-26.56-26.496-31.36-31.36-17.472-17.408-43.072-20.288-57.024-6.336-13.952 14.016-11.008 39.488 6.336 56.96z" p-id="4027"></path></svg></button><button title="Default to system" class="__dumi-default-dark-auto "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="11002" width="22" height="22"><path d="M127.658667 492.885333c0-51.882667 10.24-101.717333 30.378666-149.162666s47.786667-88.064 81.92-122.538667 75.093333-61.781333 122.538667-81.92 96.938667-30.378667 149.162667-30.378667 101.717333 10.24 149.162666 30.378667 88.405333 47.786667 122.88 81.92 61.781333 75.093333 81.92 122.538667 30.378667 96.938667 30.378667 149.162666-10.24 101.717333-30.378667 149.162667-47.786667 88.405333-81.92 122.88-75.093333 61.781333-122.88 81.92-97.28 30.378667-149.162666 30.378667-101.717333-10.24-149.162667-30.378667-88.064-47.786667-122.538667-81.92-61.781333-75.093333-81.92-122.88-30.378667-96.938667-30.378666-149.162667z m329.045333 0c0 130.048 13.994667 244.394667 41.984 343.381334h12.970667c46.762667 0 91.136-9.216 133.461333-27.306667s78.848-42.666667 109.568-73.386667 54.954667-67.242667 73.386667-109.568 27.306667-86.698667 27.306666-133.461333c0-46.421333-9.216-90.794667-27.306666-133.12s-42.666667-78.848-73.386667-109.568-67.242667-54.954667-109.568-73.386667-86.698667-27.306667-133.461333-27.306666h-11.605334c-28.672 123.562667-43.349333 237.909333-43.349333 343.722666z" p-id="11003"></path></svg></button></div></div></div><ul class="__dumi-default-menu-list"><li><a href="/blog/">大师兄 - 前端架构师</a></li></ul></div></div><ul role="slug-list" class="__dumi-default-layout-toc"><li title="面向接口编程" data-depth="2"><a href="/blog/手把手带你写一个web框架/03.实战第2关框架核心/06#面向接口编程"><span>面向接口编程</span></a></li><li title="抽象业务" data-depth="3"><a href="/blog/手把手带你写一个web框架/03.实战第2关框架核心/06#抽象业务"><span>抽象业务</span></a></li><li title="屏蔽具体实现" data-depth="3"><a href="/blog/手把手带你写一个web框架/03.实战第2关框架核心/06#屏蔽具体实现"><span>屏蔽具体实现</span></a></li><li title="面向接口/对象/过程" data-depth="3"><a href="/blog/手把手带你写一个web框架/03.实战第2关框架核心/06#面向接口对象过程"><span>面向接口/对象/过程</span></a></li><li title="接口服务的理论基础" data-depth="2"><a href="/blog/手把手带你写一个web框架/03.实战第2关框架核心/06#接口服务的理论基础"><span>接口服务的理论基础</span></a></li><li title="服务提供者的接口定义" data-depth="2"><a href="/blog/手把手带你写一个web框架/03.实战第2关框架核心/06#服务提供者的接口定义"><span>服务提供者的接口定义</span></a></li><li title="基本功能" data-depth="3"><a href="/blog/手把手带你写一个web框架/03.实战第2关框架核心/06#基本功能"><span>基本功能</span></a></li><li title="实例化过程的控制" data-depth="3"><a href="/blog/手把手带你写一个web框架/03.实战第2关框架核心/06#实例化过程的控制"><span>实例化过程的控制</span></a></li><li title="小结" data-depth="2"><a href="/blog/手把手带你写一个web框架/03.实战第2关框架核心/06#小结"><span>小结</span></a></li><li title="思考题" data-depth="2"><a href="/blog/手把手带你写一个web框架/03.实战第2关框架核心/06#思考题"><span>思考题</span></a></li></ul><div class="__dumi-default-layout-content"><div class="markdown"><h1 id="10面向接口编程上一切皆服务服务基于协议"><a aria-hidden="true" tabindex="-1" href="/blog/手把手带你写一个web框架/03.实战第2关框架核心/06#10面向接口编程上一切皆服务服务基于协议"><span class="icon icon-link"></span></a>10｜面向接口编程（上）：一切皆服务，服务基于协议</h1><p>你好，我是轩脉刃。</p><p>在上一节课我们已经将 Gin 框架迁移到自己的 hade 框架中，但是如果 hade 框架只止步于 Gin 的已有功能：支持 Context、路由、中间件这些框架最简单的功能，显然背离了我们设计这个框架的初衷，毕竟我们的目标是搭建一个生产中可用且具有丰富功能模块的框架。</p><p>那么如何组织这些功能模块更好地协作，就是我们今天要讨论的问题。</p><p>组织的方法也很简单，之前提到过。如果你还记得我们第五课封装请求和返回结构的时候，先定义了 IRequest 和 IResponse 接口，再一一实现具体的函数方法，<strong>这种先接口后实现的方式，其实不仅仅是一种代码优化手段，更是一种编程思想：面向接口编程</strong>，这其实就是我们组织功能模块的核心思路。</p><h2 id="面向接口编程"><a aria-hidden="true" tabindex="-1" href="/blog/手把手带你写一个web框架/03.实战第2关框架核心/06#面向接口编程"><span class="icon icon-link"></span></a>面向接口编程</h2><p>面向接口编程的思想到底是什么含义？我们从关键词“接口”开始思考。</p><p>不知道你考虑过这个问题没有，现在的高级语言，比如 PHP、Golang、Java 等，除了函数、对象等定义之外，都无一例外地拥有“接口”。但是为什么这些高级语言会需要有“接口”这个定义呢？我们从接口做到了什么的角度来反向思考。</p><h3 id="抽象业务"><a aria-hidden="true" tabindex="-1" href="/blog/手把手带你写一个web框架/03.实战第2关框架核心/06#抽象业务"><span class="icon icon-link"></span></a>抽象业务</h3><p>首先，接口实现了对业务逻辑的抽象，设计接口就是抽象业务的过程。</p><p>因为在工作、生活中，我们需要把业务转换到代码中。但是一个真实的业务需求往往有很多复杂的描述，有些描述是某个业务特有的，而有些描述是所有同类型业务共有的，我们需要把描述的相同点抽象出来，成为一个个的步骤。而每个步骤实际上都是一个通过输入、产生输出的方法，把这些方法聚合起来，就是一个接口。</p><p>这段话说得有点抽象，我们结合一个具体例子来加深理解。在《面向接口设计（Interface Oriented Design）》这本书中，作者举了寻找一个 pizza 店并购买pizza的例子，很简单也便于理解，这里我们是为了明白接口实现了什么，所以就不再另外举例，直接看这个例子就好。</p><p>在找pizza店之前我们首先要知道pizza店是什么，所以先来定义一个pizza店，并且来寻找所有pizza店共性的地方。</p><p>作者发现购买 pizza 的流程基本都是相似的，先确认大小、再确认佐料、再确认收货地址、最后被告知送货时间，<strong>所以可以将“购买 pizza”这个业务逻辑，抽象成一个接口结构：PizzaOrdering</strong>。它包含四个方法：set_size、set_toppings、set_address、get_time_till_delivered。</p><ul><li>set_size 的参数是一个枚举，代表 pizza 的预设大小；</li><li>set_toppings 的输入是一个数组，代表不同的佐料；</li><li>set_address 的输入是一个字符串，代表收货地址；</li><li>get_time_till_delivered 的输入为空，但是输出为时间格式，代表预估的送货到达时间。<br/><img src="https://static001.geekbang.org/resource/image/05/ed/05d91d7cbdc8fc05f3a0a66032f419ed.jpg?wh=1920x1080" alt=""/></li></ul><p>所以“寻找 pizza 店”这个事情，也可以抽象成为一个接口：PizzaOrderingFinder。它实现的方法有三个，都返回对于pizza店的 PizzaOrdering 接口。</p><ul><li><code>PizzaOrdering find_implementation_by_name(String name_of_pizza_shop)</code> 根据名字查询对应的 pizza 店；</li><li><code>PizzaOrdering find_first_implementation()</code> 查找第一个 pizza 店；</li><li><code>PizzaOrdering find_last_implementation()</code> 查找最后一个 pizza 店。</li></ul><p>从上面这个例子我们可以看出，一个业务可以由一个或者多个接口组成。针对去 pizza 店预订 pizza 这个业务，我们定义了两个接口：寻找 pizza 店的接口、pizza 店的接口。</p><p>其中寻找 pizza 店的接口，它提供多种筛选能力，比如按名字查询、按正序/倒序第一查询；pizza 店的接口拥有四个能力，它们有自己的输入输出，这四个能力聚合组成了 pizza 店的抽象接口。</p><p>这就是一种业务抽象，用一个接口结构抽象可以购买 pizza 的店铺所具有的能力，用另外一个接口数据抽象查询 pizza 店铺的方法。当设计完一个业务的接口之后，我们实际上就完成了对这个业务从实际生活到代码世界的抽象和建模。</p><h3 id="屏蔽具体实现"><a aria-hidden="true" tabindex="-1" href="/blog/手把手带你写一个web框架/03.实战第2关框架核心/06#屏蔽具体实现"><span class="icon icon-link"></span></a>屏蔽具体实现</h3><p>其次，接口的使用能让调用方对能力敏感，而对具体实现不敏感。</p><p>拿我们在第五章设计的 IRequest 接口举例，如果一个对象实现了这个接口，那么不管在什么模块调用这个对象，我们都能知道它拥有的能力有哪些、能通过哪些方式来获取到这些能力。</p><p>具体来说在写业务的时候，如果我们要从 URL 中获取请求参数，可以寻找实现了 IRequest 接口的对象，不管是什么对象，只要实现了IRequest接口，它就能满足我们的需求。比如在我们这个框架中就是 context 数据结构。从 context 这个对象中，通过 IRequest 中封装的 QueryXXX 系列的接口，就能获取到 URL 中的参数。<img src="https://static001.geekbang.org/resource/image/72/ee/72eca7562af15da8de58f8dd5705a7ee.jpg?wh=1920x1080" alt=""/></p><p>当模块之间的调用有了接口，调用方就无需关心被调用模块的具体实现。因为在调用方逻辑中，不会出现被调用者具体实现的数据结构名称，只会出现被调用者承诺能力的一个简单接口。</p><p>这对调用方是非常友好的。一方面调用方不用担心被调用方内部的结构调整，只要被调用方按照承诺的能力提供服务；另一方面，调用方可以随时换掉被调用方，只要替换者也提供同等的能力即可。</p><p>比如上面那个寻找 Pizza 店的业务，PizzaOrderFinder 这个结构中的方法 find_implementation_by_name 返回的，就直接是接口 PizzaOrdering。意思是，要查询的是满足 PizzaOrdering 定义的一个店铺，只要有定义中的四个能力，顾客就能购买到 Pizza。所以，不管这个店铺是 pizza 店还是超市，只要提供了 pizza 店有的四个能力，就能将店铺放进寻找范围内。</p><h3 id="面向接口对象过程"><a aria-hidden="true" tabindex="-1" href="/blog/手把手带你写一个web框架/03.实战第2关框架核心/06#面向接口对象过程"><span class="icon icon-link"></span></a>面向接口/对象/过程</h3><p>理解了接口的优势，我们来思考下“面向接口编程”的意义，它和“面向对象编程”、“面向过程编程”又有什么区别。</p><p>其实，这三个名词描述的都是思维方式，就是我们在抽象业务的时候如何思考问题。</p><ul><li>“面向过程编程”是指进行业务抽象的时候，<strong>我们定义一个一个的过程方法，通过这些过程方法的串联完成具体的业务</strong>。</li></ul><p>还是拿查询 Pizza 店的业务举例，面向过程编程的思考思路可能是最符合我们平时的思维逻辑：第一步，先查找附近的所有店铺；第二步，过滤出 pizza 店；第三步，按照自定义规则再过滤，查找出我要的 pizza 店。<img src="https://static001.geekbang.org/resource/image/21/1e/218ba4dd6036168ca472793e2byy3f1e.jpg?wh=1920x1080" alt=""/></p><p>所以面向过程编程的整个思路就是实现思路，它的思维方式比较直接简单，按照目标一步步实现。<strong>但缺点是一旦需求有一些变化，整个链路的改动都会受影响</strong>。</p><p>比如最终的目标从按照 pizza 店铺的名字进行搜索，变化成按照店铺中的座位数进行搜索，那么由于这个需求变化，第二步过滤的逻辑，原本只返回 pizza 店铺的名字，就要增加返回 pizza 店铺的座位。这种改动往往涉及到全链路的改动，影响比较大。</p><ul><li>“面向对象编程”表示的是在业务抽象的时候，<strong>我们先定义业务中的对象，通过这些对象之间的关联来表示整个业务</strong>。</li></ul><p>对于寻找 Pizza 店的例子，我们会将所有的 pizza 店铺抽象成一个数据结构 Pizza 店，这个 Pizza 店铺提供购买 pizza 的能力和一些属性。这个时候过滤这些店铺就比较简单了，直接按照某些属性进行过滤。<img src="https://static001.geekbang.org/resource/image/8e/e6/8e8c304b5841d38e0f6ddf3161ayy0e6.jpg?wh=1920x1080" alt=""/></p><p>所以面向对象编程抽象性就很强了，但是它的问题就是调用方依赖具体的数据结构pizza。比如还是按照座位号过滤，调用方会根据pizza结构中的座位号字段来过滤，但是pizza中的座位号这个字段我定义成什么变量，这个其实调用方并不想知道。所以我们其实还可以再进一步抽象，就是面向接口编程。</p><p>面对业务，我们并不先定义具体的对象、思考对象有哪些属性，而是<strong>先思考如何抽象接口，把接口的定义放在第一步，然后多个模块之间梳理如何通过接口进行交互，最后才是实现具体的模块</strong>。<img src="https://static001.geekbang.org/resource/image/2c/ff/2c99bcc53aa920f7b678c84d8b4699ff.jpg?wh=1920x1080" alt=""/></p><h2 id="接口服务的理论基础"><a aria-hidden="true" tabindex="-1" href="/blog/手把手带你写一个web框架/03.实战第2关框架核心/06#接口服务的理论基础"><span class="icon icon-link"></span></a>接口服务的理论基础</h2><p>现在理解了面向接口编程的理念，就可以将这个理念运用到我们的 hade 框架中了。在框架中会包含很多模块，这些模块会和框架主体交互，也会互相交互，所以如果从功能的交互上看，整体会是一个非常复杂的网状结构。<br/><img src="https://static001.geekbang.org/resource/image/66/b7/664016abbd655007de0f91b9f95d81b7.jpg?wh=1920x1080" alt=""/></p><p>如果改变一下思路，按照面向接口编程的理念，将每个模块看成是一个服务，服务的具体实现我们其实并不关心，我们关心的是服务提供的能力，即接口协议。那么框架主体真正要做的事情是什么呢？其实是：<strong>定义好每个模块服务的接口协议，规范服务与服务之间的调用，并且管理每个服务的具体实现。</strong></p><p>所有的服务都去框架主体中注册自身的模块接口协议，其他的服务调用功能模块的时候，并不是直接去这个服务获取实例，而是从框架主体中获取有这个接口协议的服务实例。</p><p>这样，所有的模块服务都不和具体的服务进行交互，而是和框架主体进行交互，所有的接口也都注册在框架主体中，非常方便管理。<br/><img src="https://static001.geekbang.org/resource/image/72/18/72cc85773ccce8634fd90cda78c2dd18.jpg?wh=1920x1080" alt=""/></p><p>每个模块服务都做两件事情：一是它和自己提供的接口协议做绑定，这样当其他人要使用这个接口协议时能找到自己；二是它使用到其他接口协议的时候，去框架主体中寻找。</p><p>所以，这个时候，每个模块服务都是一个“<strong>服务提供者</strong>”（service provider），而我们主体框架需要承担起来的角色叫做“<strong>服务容器</strong>”（service container），服务容器中绑定了多个接口协议，每个接口协议都由一个服务提供者提供服务。</p><p>在框架初始化启动的时候，我们可以选择在服务容器中绑定多个服务提供者，每个服务提供者对应一个凭证。当要使用到某个服务的时候，再根据这个凭证去服务容器中，获取这个服务提供者提供的服务。这样就能很方便地获取服务了。</p><p>这两个结构的逻辑非常重要，这里我再强调一下。我们的设计是将每个服务，不管是配置、还是日志、还是缓存，都看成是一个服务。</p><p><strong>这个服务，通过提供一个服务提供者注册到服务容器中。服务提供者提供的是“创建服务实例的方法”，服务容器提供的是“实例化服务的方法”</strong>。至于这个服务实例拥有哪些能力，即符合哪个接口协议，是预先在框架主体中定义好的。</p><p>讲完服务提供者和服务容器的理论基础，就要讲具体实现了，今天我们先了解服务提供者如何实现，下一课接着学服务容器。</p><h2 id="服务提供者的接口定义"><a aria-hidden="true" tabindex="-1" href="/blog/手把手带你写一个web框架/03.实战第2关框架核心/06#服务提供者的接口定义"><span class="icon icon-link"></span></a>服务提供者的接口定义</h2><p>按照面向接口编程的逻辑，一个服务提供者需要有哪些能力呢？一共有五个能力，先简单看一眼做到心中有数，再来详细理解为什么要设计这些能力：</p><ul><li>获取服务凭证的能力 Name；</li><li>创建服务实例化方法的能力 Register；</li><li>获取服务实例化方法参数的能力 Params；</li><li>两个与实例化控制相关的方法，控制实例化时机方法 IsDefer、实例化预处理的方法Boot。</li></ul><p>我们将服务提供者的接口定义放在框架目录的framework/provider.go中。</p><h3 id="基本功能"><a aria-hidden="true" tabindex="-1" href="/blog/手把手带你写一个web框架/03.实战第2关框架核心/06#基本功能"><span class="icon icon-link"></span></a>基本功能</h3><p>首先因为要和服务容器做绑定，所以一个服务提供者需要有一个凭证，绑定时作为凭证关联。这里的凭证我们就直接设计为一个字符串结构，即<strong>服务提供者首先有一个获取凭证字符串的方法 Name()</strong>。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// Name 代表了这个服务提供者的凭证</span></div><div class="token-line"><span class="token plain">    Name() string</span></div></pre></div><p><strong>然后一个服务提供者需要有创建服务实例方法的能力</strong>。因为在服务容器中绑定后，如果服务容器要初始化一个服务实例，就需要调用服务提供者中创建服务实例的方法。</p><p>按照面向接口编程的思想，每个具体服务“创建服务实例”的方法不一样，比如日志服务初始化的时候可能需要有日志输出地址，但是配置服务初始化的时候需要有配置文件地址，但是我们这里需要规范它们的输入和输出，使用 Golang 中的 function type，也叫函数定义，是可以做这个事情的。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// NewInstance 定义了如何创建一个新实例，所有服务容器的创建服务</span></div><div class="token-line"><span class="token plain">    type NewInstance func(...interface{}) (interface{}, error)</span></div></pre></div><p>这个 NewInstance 就是一个函数定义，它规定所有创建服务实例的方法必须：有相同的参数interface<!-- -->{<!-- -->}<!-- --> 数组，并且返回 interface<!-- -->{<!-- -->}<!-- -->和错误信息这两个数据结构。</p><ul><li>interface<!-- -->{<!-- -->}<!-- --> 数组代表实例化一个服务所需要的参数，我们这里设计为可变参数，为的是适配不同数量、不同类型的参数需求；</li><li>返回值返回的 interface<!-- -->{<!-- -->}<!-- --> 结构代表了具体的服务实例。</li></ul><p>定义好了“创建服务实例的方法”的函数，我们再看服务提供者的创建能力如何实现，也就是 NewInstance 方法，它的返回值就是刚才写的 NewInstance 的函数定义。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// Register 在服务容器中注册了一个实例化服务的方法，是否在注册的时候就实例化这个服务，需要参考 IsDefer 接口。</span></div><div class="token-line"><span class="token plain">    Register(Container) NewInstance</span></div></pre></div><p>而对于方法的输入参数，将服务容器传进来是因为，如果后续希望根据一个服务的某个能力，比如配置服务的获取某个配置的能力，返回定义好的不同 NewInstance 函数，那我们就需要先从服务容器中获取配置服务，才能判断返回哪个 NewInstance。</p><p>所以这里我们将服务容器作为传入参数。（这个服务容器的结构我们下节课再具体讨论，这里先用 Container 名称代替。）</p><p>“创建服务实例的方法”的能力，除了实现 NewInstance 方法之外，还需要注册 NewInstance 方法的参数，即可变的 interface<!-- -->{<!-- -->}<!-- -->参数。<strong>所以我们的服务提供者还需要提供一个获取服务参数的能力</strong>。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// Params params 定义传递给 NewInstance 的参数，可以自定义多个，建议将 container 作为第一个参数</span></div><div class="token-line"><span class="token plain">    Params(Container) []interface{}</span></div></pre></div><h3 id="实例化过程的控制"><a aria-hidden="true" tabindex="-1" href="/blog/手把手带你写一个web框架/03.实战第2关框架核心/06#实例化过程的控制"><span class="icon icon-link"></span></a>实例化过程的控制</h3><p>到这里服务提供者的能力已经基本设计好了。不过我们可以再思考下实例化的过程，看看还有没有什么讲究。</p><ul><li>实例化的时机，可以在服务提供者注册的时候，也可以是第一次获取服务的时候，即是注册的时候就实例化，还是延迟到获取服务的时候实例化。</li></ul><p>所以我们需要有一个能力能控制实例化的时机，对应到服务提供者上，要提供告知服务容器是否延迟实例化的方法 IsDefer。同样在framework/provider.go中。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// IsDefer 决定是否在注册的时候实例化这个服务，如果不是注册的时候实例化，那就是在第一次 make 的时候进行实例化操作</span></div><div class="token-line"><span class="token plain">    // false 表示不需要延迟实例化，在注册的时候就实例化。true 表示延迟实例化</span></div><div class="token-line"><span class="token plain">    IsDefer() bool</span></div></pre></div><ul><li>实例化之前有可能需要做一些准备工作，比如在每次实例化之前，想记录一下日志，或者想通过确认某些配置，修改一下实例化参数。</li></ul><p>所以这里我们需要设计一个在实例化前调用准备工作的函数 Boot。它的参数是服务容器，返回值是一个 error，在实例化服务的时候，如果准备工作 Boot 失败了，那么我们就不进行后续的实例化操作了，将这个 error 直接返回给获取服务的方法。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// Boot 在调用实例化服务的时候会调用，可以把一些准备工作：基础配置，初始化参数的操作放在这个里面。</span></div><div class="token-line"><span class="token plain">    // 如果 Boot 返回 error，整个服务实例化就会实例化失败，返回错误</span></div><div class="token-line"><span class="token plain">    Boot(Container) error</span></div></pre></div><p>到这里，我们就定义好了服务提供者的接口了。再简单回顾一下，有三个基础能力、两个控制相关的能力：</p><ul><li>获取服务凭证的能力 Name；</li><li>注册服务实例化的方法的能力 Register；</li><li>获取服务实例化方法参数的能力 Params；</li><li>两个与实例化控制相关的方法，控制实例化时机方法 IsDefer、实例化预处理的方法Boot。</li></ul><p>framework/provider.go中完整代码如下：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">package framework</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    // NewInstance 定义了如何创建一个新实例，所有服务容器的创建服务</span></div><div class="token-line"><span class="token plain">    type NewInstance func(...interface{}) (interface{}, error){}</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    // ServiceProvider 定义一个服务提供者需要实现的接口</span></div><div class="token-line"><span class="token plain">    type ServiceProvider interface {</span></div><div class="token-line"><span class="token plain">    	// Register 在服务容器中注册了一个实例化服务的方法，是否在注册的时候就实例化这个服务，需要参考 IsDefer 接口。</span></div><div class="token-line"><span class="token plain">    	Register(Container) NewInstance</span></div><div class="token-line"><span class="token plain">    	// Boot 在调用实例化服务的时候会调用，可以把一些准备工作：基础配置，初始化参数的操作放在这个里面。</span></div><div class="token-line"><span class="token plain">    	// 如果 Boot 返回 error，整个服务实例化就会实例化失败，返回错误</span></div><div class="token-line"><span class="token plain">    	Boot(Container) error</span></div><div class="token-line"><span class="token plain">    	// IsDefer 决定是否在注册的时候实例化这个服务，如果不是注册的时候实例化，那就是在第一次 make 的时候进行实例化操作</span></div><div class="token-line"><span class="token plain">    	// false 表示不需要延迟实例化，在注册的时候就实例化。true 表示延迟实例化</span></div><div class="token-line"><span class="token plain">    	IsDefer() bool</span></div><div class="token-line"><span class="token plain">    	// Params params 定义传递给 NewInstance 的参数，可以自定义多个，建议将 container 作为第一个参数</span></div><div class="token-line"><span class="token plain">    	Params(Container) []interface{}</span></div><div class="token-line"><span class="token plain">    	// Name 代表了这个服务提供者的凭证</span></div><div class="token-line"><span class="token plain">    	Name() string</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>今天主要说明了面向接口编程的逻辑，以及服务提供者、服务容器、服务之间的关系。代码层面我们只增加了一个provider.go。代码我已经上传到了GitHub上的<a target="_blank" rel="noopener noreferrer" href="https://github.com/gohade/coredemo/tree/geekbang/10">geekbang/10<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 分支。但是在定义Provider的时候，我们在参数中使用了下节课需要定义的服务容器结构Container，所以目前这个分支的代码暂时还是不能运行的。<br/><img src="https://static001.geekbang.org/resource/image/9e/93/9e1d9d6b52913ea14dffab052c709c93.png?wh=754x784" alt=""/></p><h2 id="小结"><a aria-hidden="true" tabindex="-1" href="/blog/手把手带你写一个web框架/03.实战第2关框架核心/06#小结"><span class="icon icon-link"></span></a>小结</h2><p>结合面向接口编程的理念，我们希望设计出的框架是一个服务容器，也就是说，并不是在它的内部实现各种各样的功能模块，而是在框架中，<strong>定义好每个模块服务的接口，规范服务与服务之间的调用，并且管理每个服务的具体实现。</strong></p><p>具体功能模块的实现由绑定的服务提供者进行，我们只需要规范服务提供者的能力，就能获取到具体的服务实例了。</p><p>今天的内容比较偏向理论，一直围绕“面向接口编程”的概念讨论。但是希望你不要觉得枯燥，还是那句话，不仅要知其然，还要知其所以然。先搞清楚为什么要这么设计我们的 hade 框架、它的理论基础是什么，才能顺利实现，并且在后期灵活调整和拓展。下一讲我们继续学习服务容器的实现。</p><h2 id="思考题"><a aria-hidden="true" tabindex="-1" href="/blog/手把手带你写一个web框架/03.实战第2关框架核心/06#思考题"><span class="icon icon-link"></span></a>思考题</h2><p>今天花了很大篇幅来解释面向接口的思想，我们会将这个思想贯穿在Web框架的整个设计中。其实面向接口思想不仅仅应用在编程分层中，在架构设计、微服务中也都有所体现，你可以想想在工作生活中有遇到使用面向接口思想的一些实例么？</p><p>欢迎在留言区分享你的思考。感谢你的收听，如果你觉得有收获，也欢迎你把今天的内容分享给你身边的朋友，邀他一起学习。我们下节课见。</p></div><div class="__dumi-default-layout-footer-meta"><a target="_blank" rel="noopener noreferrer" href="https://github.com/GGwujun/blog/edit/master/docs/手把手带你写一个Web框架/03.实战第2关框架核心/06.md">在 GitHub 上编辑此页<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a><span data-updated-text="最后更新时间：">5/2/2022 10:56:58</span></div></div></div></div>
	<script>
  window.g_useSSR = true;
  window.g_initialProps = {};
	</script>

    <script>
      (function () {
        if (!location.port) {
          (function (i, s, o, g, r, a, m) {
            i["GoogleAnalyticsObject"] = r;
            (i[r] =
              i[r] ||
              function () {
                (i[r].q = i[r].q || []).push(arguments);
              }),
              (i[r].l = 1 * new Date());
            (a = s.createElement(o)), (m = s.getElementsByTagName(o)[0]);
            a.async = 1;
            a.src = g;
            m.parentNode.insertBefore(a, m);
          })(
            window,
            document,
            "script",
            "//www.google-analytics.com/analytics.js",
            "ga"
          );
          ga("create", "UA-149864185-1", "auto");
          ga("send", "pageview");
        }
      })();
    </script>
    <script src="/blog/umi.js"></script>
  </body>
</html>
