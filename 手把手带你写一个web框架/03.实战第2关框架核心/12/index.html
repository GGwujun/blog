<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no"
    />
    <link rel="shortcut icon" type="image/x-icon" href="/logo.png" />
    <link rel="stylesheet" href="/blog/umi.css" />
    <script>
      window.routerBase = "/blog";
    </script>
    <script>
      //! umi version: 3.5.17
    </script>
    <script>
      !(function () {
        var e = localStorage.getItem("dumi:prefers-color"),
          t = window.matchMedia("(prefers-color-scheme: dark)").matches,
          r = ["light", "dark", "auto"];
        document.documentElement.setAttribute(
          "data-prefers-color",
          e === r[2] ? (t ? r[1] : r[0]) : r.indexOf(e) > -1 ? e : r[0]
        );
      })();
    </script>
    <title>16｜配置和环境（下）：配置服务中的设计思路</title>
  </head>
  <body>
    <div id="root"><div class="__dumi-default-layout" data-route="/手把手带你写一个web框架/03.实战第2关框架核心/12" data-show-sidemenu="true" data-show-slugs="true" data-site-mode="true" data-gapless="false"><div class="__dumi-default-navbar" data-mode="site"><button class="__dumi-default-navbar-toggle"></button><a class="__dumi-default-navbar-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog/">大师兄</a><nav><div class="__dumi-default-search"><input type="search" class="__dumi-default-search-input" value=""/><ul></ul></div><span>计算机基础<ul><li><a href="/blog/编译原理之美">编译原理之美</a></li><li><a href="/blog/编译原理实战">编译原理实战</a></li><li><a href="/blog/深入浅出计算机组成原理">深入浅出计算机组成原理</a></li><li><a href="/blog/详解http">详解http</a></li><li><a href="/blog/计算机网络通关29讲">计算机网络通关29讲</a></li><li><a href="/blog/网络排查案例课">网络排查案例课</a></li><li><a href="/blog/linux操作系统">linux操作系统</a></li><li><a href="/blog/linux性能优化实战">linux性能优化实战</a></li><li><a href="/blog/程序员数学基础">程序员数学基础</a></li><li><a href="/blog/趣谈网络协议">趣谈网络协议</a></li><li><a href="/blog/操作系统实战">操作系统实战</a></li><li><a href="/blog/软件工程之美">软件工程之美</a></li><li><a href="/blog/sql必知必会">sql必知必会</a></li><li><a href="/blog/操作系统实战45讲">操作系统实战45讲</a></li><li><a href="/blog/网络编程实战">网络编程实战</a></li></ul></span><span>算法<ul><li><a href="/blog/常用算法25讲">常用算法25讲</a></li><li><a href="/blog/数据结构与算法之美">数据结构与算法之美</a></li><li><a href="/blog/业务开发算法50讲">业务开发算法50讲</a></li><li><a href="/blog/动态规划面试宝典">动态规划面试宝典</a></li></ul></span><span>前端开发<ul><li><a href="/blog/浏览器工作原理与实践">浏览器工作原理与实践</a></li><li><a href="/blog/新时代产品经理进阶之路">新时代产品经理进阶之路</a></li><li><a href="/blog/全栈工程师修炼指南">全栈工程师修炼指南</a></li><li><a href="/blog/flutter核心技术与实战">flutter核心技术与实战</a></li><li><a href="/blog/java-script核心原理解析">java-script核心原理解析</a></li><li><a href="/blog/说透低代码">说透低代码</a></li><li><a href="/blog/nodejs应用开发实战">nodejs应用开发实战</a></li><li><a href="/blog/反爬虫兵法演绎20讲">反爬虫兵法演绎20讲</a></li><li><a href="/blog/reactnative新架构实战课">reactnative新架构实战课</a></li><li><a href="/blog/正则表达式入门">正则表达式入门</a></li><li><a href="/blog/重学前端">重学前端</a></li><li><a href="/blog/serverless入门课">serverless入门课</a></li><li><a href="/blog/type-script入门实战笔记">type-script入门实战笔记</a></li><li><a href="/blog/图解googlev8">图解googlev8</a></li><li><a href="/blog/vue3源码分析">vue3源码分析</a></li><li><a href="/blog/玩转Vue3全家桶">玩转Vue3全家桶</a></li><li><a href="/blog/webassembly入门">webassembly入门</a></li><li><a aria-current="page" class="active" href="/blog/手把手带你写一个Web框架">手把手带你写一个Web框架</a></li><li><a href="/blog/web漏洞挖掘实战">web漏洞挖掘实战</a></li><li><a href="/blog/跟月影学可视化">跟月影学可视化</a></li><li><a href="/blog/搞定音频技术">搞定音频技术</a></li><li><a href="/blog/攻克视频技术">攻克视频技术</a></li></ul></span><span>前端工程化<ul><li><a href="/blog/logger">logger</a></li><li><a href="/blog/webpack">webpack</a></li><li><a href="/blog/webpackChain">webpackChain</a></li></ul></span><span>前端性能优化<ul><li><a href="/blog/react性能调优">react性能调优</a></li></ul></span><span>软件测试<ul><li><a href="/blog/全链路压测实战30讲">全链路压测实战30讲</a></li><li><a href="/blog/性能测试实战30讲">性能测试实战30讲</a></li><li><a href="/blog/自动化测试高手课">自动化测试高手课</a></li><li><a href="/blog/软件测试52讲">软件测试52讲</a></li></ul></span><span>面试<ul><li><a href="/blog/面试现场">面试现场</a></li></ul></span><span>杂谈<ul><li><a href="/blog/超级访谈对话张雪峰">超级访谈对话张雪峰</a></li><li><a href="/blog/Git实战手册">Git实战手册</a></li><li><a href="/blog/NodeJS">NodeJS</a></li><li><a href="/blog/ReactJS">ReactJS</a></li><li><a href="/blog/UI设计">UI设计</a></li><li><a href="/blog/webpack4系列教程">webpack4系列教程</a></li><li><a href="/blog/前端知识体系">前端知识体系</a></li><li><a href="/blog/剑指offer刷题笔记">剑指offer刷题笔记</a></li><li><a href="/blog/思考与成长">思考与成长</a></li><li><a href="/blog/设计模式手册">设计模式手册</a></li></ul></span><div class="__dumi-default-navbar-tool"><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "></div></div></div></nav></div><div class="__dumi-default-menu" data-mode="site"><div class="__dumi-default-menu-inner"><div class="__dumi-default-menu-header"><a class="__dumi-default-menu-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog/"></a><h1>大师兄</h1><p></p></div><div class="__dumi-default-menu-mobile-area"><ul class="__dumi-default-menu-nav-list"><li>计算机基础<ul><li><a href="/blog/编译原理之美">编译原理之美</a></li><li><a href="/blog/编译原理实战">编译原理实战</a></li><li><a href="/blog/深入浅出计算机组成原理">深入浅出计算机组成原理</a></li><li><a href="/blog/详解http">详解http</a></li><li><a href="/blog/计算机网络通关29讲">计算机网络通关29讲</a></li><li><a href="/blog/网络排查案例课">网络排查案例课</a></li><li><a href="/blog/linux操作系统">linux操作系统</a></li><li><a href="/blog/linux性能优化实战">linux性能优化实战</a></li><li><a href="/blog/程序员数学基础">程序员数学基础</a></li><li><a href="/blog/趣谈网络协议">趣谈网络协议</a></li><li><a href="/blog/操作系统实战">操作系统实战</a></li><li><a href="/blog/软件工程之美">软件工程之美</a></li><li><a href="/blog/sql必知必会">sql必知必会</a></li><li><a href="/blog/操作系统实战45讲">操作系统实战45讲</a></li><li><a href="/blog/网络编程实战">网络编程实战</a></li></ul></li><li>算法<ul><li><a href="/blog/常用算法25讲">常用算法25讲</a></li><li><a href="/blog/数据结构与算法之美">数据结构与算法之美</a></li><li><a href="/blog/业务开发算法50讲">业务开发算法50讲</a></li><li><a href="/blog/动态规划面试宝典">动态规划面试宝典</a></li></ul></li><li>前端开发<ul><li><a href="/blog/浏览器工作原理与实践">浏览器工作原理与实践</a></li><li><a href="/blog/新时代产品经理进阶之路">新时代产品经理进阶之路</a></li><li><a href="/blog/全栈工程师修炼指南">全栈工程师修炼指南</a></li><li><a href="/blog/flutter核心技术与实战">flutter核心技术与实战</a></li><li><a href="/blog/java-script核心原理解析">java-script核心原理解析</a></li><li><a href="/blog/说透低代码">说透低代码</a></li><li><a href="/blog/nodejs应用开发实战">nodejs应用开发实战</a></li><li><a href="/blog/反爬虫兵法演绎20讲">反爬虫兵法演绎20讲</a></li><li><a href="/blog/reactnative新架构实战课">reactnative新架构实战课</a></li><li><a href="/blog/正则表达式入门">正则表达式入门</a></li><li><a href="/blog/重学前端">重学前端</a></li><li><a href="/blog/serverless入门课">serverless入门课</a></li><li><a href="/blog/type-script入门实战笔记">type-script入门实战笔记</a></li><li><a href="/blog/图解googlev8">图解googlev8</a></li><li><a href="/blog/vue3源码分析">vue3源码分析</a></li><li><a href="/blog/玩转Vue3全家桶">玩转Vue3全家桶</a></li><li><a href="/blog/webassembly入门">webassembly入门</a></li><li><a aria-current="page" class="active" href="/blog/手把手带你写一个Web框架">手把手带你写一个Web框架</a></li><li><a href="/blog/web漏洞挖掘实战">web漏洞挖掘实战</a></li><li><a href="/blog/跟月影学可视化">跟月影学可视化</a></li><li><a href="/blog/搞定音频技术">搞定音频技术</a></li><li><a href="/blog/攻克视频技术">攻克视频技术</a></li></ul></li><li>前端工程化<ul><li><a href="/blog/logger">logger</a></li><li><a href="/blog/webpack">webpack</a></li><li><a href="/blog/webpackChain">webpackChain</a></li></ul></li><li>前端性能优化<ul><li><a href="/blog/react性能调优">react性能调优</a></li></ul></li><li>软件测试<ul><li><a href="/blog/全链路压测实战30讲">全链路压测实战30讲</a></li><li><a href="/blog/性能测试实战30讲">性能测试实战30讲</a></li><li><a href="/blog/自动化测试高手课">自动化测试高手课</a></li><li><a href="/blog/软件测试52讲">软件测试52讲</a></li></ul></li><li>面试<ul><li><a href="/blog/面试现场">面试现场</a></li></ul></li><li>杂谈<ul><li><a href="/blog/超级访谈对话张雪峰">超级访谈对话张雪峰</a></li><li><a href="/blog/Git实战手册">Git实战手册</a></li><li><a href="/blog/NodeJS">NodeJS</a></li><li><a href="/blog/ReactJS">ReactJS</a></li><li><a href="/blog/UI设计">UI设计</a></li><li><a href="/blog/webpack4系列教程">webpack4系列教程</a></li><li><a href="/blog/前端知识体系">前端知识体系</a></li><li><a href="/blog/剑指offer刷题笔记">剑指offer刷题笔记</a></li><li><a href="/blog/思考与成长">思考与成长</a></li><li><a href="/blog/设计模式手册">设计模式手册</a></li></ul></li></ul><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "><button title="Dark theme" class="__dumi-default-dark-moon "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="3854" width="22" height="22"><path d="M991.816611 674.909091a69.166545 69.166545 0 0 0-51.665455-23.272727 70.795636 70.795636 0 0 0-27.438545 5.585454A415.674182 415.674182 0 0 1 754.993338 698.181818c-209.594182 0-393.472-184.785455-393.472-395.636363 0-52.363636 38.539636-119.621818 69.515637-173.614546 4.887273-8.610909 9.634909-16.756364 14.103272-24.901818A69.818182 69.818182 0 0 0 384.631156 0a70.842182 70.842182 0 0 0-27.438545 5.585455C161.678429 90.298182 14.362065 307.898182 14.362065 512c0 282.298182 238.824727 512 532.38691 512a522.286545 522.286545 0 0 0 453.957818-268.334545A69.818182 69.818182 0 0 0 991.816611 674.909091zM546.679156 954.181818c-248.785455 0-462.941091-192-462.941091-442.181818 0-186.647273 140.637091-372.829091 300.939637-442.181818-36.817455 65.629091-92.578909 151.970909-92.578909 232.727273 0 250.181818 214.109091 465.454545 462.917818 465.454545a488.331636 488.331636 0 0 0 185.181091-46.545455 453.003636 453.003636 0 0 1-393.565091 232.727273z m103.656728-669.323636l-14.266182 83.781818a34.909091 34.909091 0 0 0 50.362182 36.770909l74.775272-39.563636 74.752 39.563636a36.142545 36.142545 0 0 0 16.174546 3.956364 34.909091 34.909091 0 0 0 34.210909-40.727273l-14.289455-83.781818 60.509091-59.345455a35.025455 35.025455 0 0 0-19.223272-59.578182l-83.61891-12.101818-37.376-76.101818a34.56 34.56 0 0 0-62.254545 0l-37.376 76.101818-83.618909 12.101818a34.909091 34.909091 0 0 0-19.246546 59.578182z m70.423272-64.698182a34.280727 34.280727 0 0 0 26.135273-19.083636l14.312727-29.090909 14.336 29.090909a34.257455 34.257455 0 0 0 26.135273 19.083636l32.046546 4.887273-23.272728 22.574545a35.234909 35.234909 0 0 0-10.007272 30.952727l5.46909 32.116364-28.625454-15.127273a34.490182 34.490182 0 0 0-32.302546 0l-28.695272 15.127273 5.469091-32.116364a35.141818 35.141818 0 0 0-9.984-30.952727l-23.272728-22.574545z" p-id="3855"></path></svg></button><button title="Light theme" class="__dumi-default-dark-sun "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="4026" width="22" height="22"><path d="M915.2 476.16h-43.968c-24.704 0-44.736 16-44.736 35.84s20.032 35.904 44.736 35.904H915.2c24.768 0 44.8-16.064 44.8-35.904s-20.032-35.84-44.8-35.84zM512 265.6c-136.704 0-246.464 109.824-246.464 246.4 0 136.704 109.76 246.464 246.464 246.464S758.4 648.704 758.4 512c0-136.576-109.696-246.4-246.4-246.4z m0 425.6c-99.008 0-179.2-80.128-179.2-179.2 0-98.944 80.192-179.2 179.2-179.2S691.2 413.056 691.2 512c0 99.072-80.192 179.2-179.2 179.2zM197.44 512c0-19.84-19.136-35.84-43.904-35.84H108.8c-24.768 0-44.8 16-44.8 35.84s20.032 35.904 44.8 35.904h44.736c24.768 0 43.904-16.064 43.904-35.904zM512 198.464c19.776 0 35.84-20.032 35.84-44.8v-44.8C547.84 84.032 531.84 64 512 64s-35.904 20.032-35.904 44.8v44.8c0 24.768 16.128 44.864 35.904 44.864z m0 627.136c-19.776 0-35.904 20.032-35.904 44.8v44.736C476.096 940.032 492.16 960 512 960s35.84-20.032 35.84-44.8v-44.736c0-24.768-16.064-44.864-35.84-44.864z m329.92-592.832c17.472-17.536 20.288-43.072 6.4-57.024-14.016-14.016-39.488-11.2-57.024 6.336-4.736 4.864-26.496 26.496-31.36 31.36-17.472 17.472-20.288 43.008-6.336 57.024 13.952 14.016 39.488 11.2 57.024-6.336 4.8-4.864 26.496-26.56 31.296-31.36zM213.376 759.936c-4.864 4.8-26.56 26.624-31.36 31.36-17.472 17.472-20.288 42.944-6.4 56.96 14.016 13.952 39.552 11.2 57.024-6.336 4.8-4.736 26.56-26.496 31.36-31.36 17.472-17.472 20.288-43.008 6.336-56.96-14.016-13.952-39.552-11.072-56.96 6.336z m19.328-577.92c-17.536-17.536-43.008-20.352-57.024-6.336-14.08 14.016-11.136 39.488 6.336 57.024 4.864 4.864 26.496 26.56 31.36 31.424 17.536 17.408 43.008 20.288 56.96 6.336 14.016-14.016 11.264-39.488-6.336-57.024-4.736-4.864-26.496-26.56-31.296-31.424z m527.168 628.608c4.864 4.864 26.624 26.624 31.36 31.424 17.536 17.408 43.072 20.224 57.088 6.336 13.952-14.016 11.072-39.552-6.4-57.024-4.864-4.8-26.56-26.496-31.36-31.36-17.472-17.408-43.072-20.288-57.024-6.336-13.952 14.016-11.008 39.488 6.336 56.96z" p-id="4027"></path></svg></button><button title="Default to system" class="__dumi-default-dark-auto "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="11002" width="22" height="22"><path d="M127.658667 492.885333c0-51.882667 10.24-101.717333 30.378666-149.162666s47.786667-88.064 81.92-122.538667 75.093333-61.781333 122.538667-81.92 96.938667-30.378667 149.162667-30.378667 101.717333 10.24 149.162666 30.378667 88.405333 47.786667 122.88 81.92 61.781333 75.093333 81.92 122.538667 30.378667 96.938667 30.378667 149.162666-10.24 101.717333-30.378667 149.162667-47.786667 88.405333-81.92 122.88-75.093333 61.781333-122.88 81.92-97.28 30.378667-149.162666 30.378667-101.717333-10.24-149.162667-30.378667-88.064-47.786667-122.538667-81.92-61.781333-75.093333-81.92-122.88-30.378667-96.938667-30.378666-149.162667z m329.045333 0c0 130.048 13.994667 244.394667 41.984 343.381334h12.970667c46.762667 0 91.136-9.216 133.461333-27.306667s78.848-42.666667 109.568-73.386667 54.954667-67.242667 73.386667-109.568 27.306667-86.698667 27.306666-133.461333c0-46.421333-9.216-90.794667-27.306666-133.12s-42.666667-78.848-73.386667-109.568-67.242667-54.954667-109.568-73.386667-86.698667-27.306667-133.461333-27.306666h-11.605334c-28.672 123.562667-43.349333 237.909333-43.349333 343.722666z" p-id="11003"></path></svg></button></div></div></div><ul class="__dumi-default-menu-list"><li><a href="/blog/">大师兄 - 前端架构师</a></li></ul></div></div><ul role="slug-list" class="__dumi-default-layout-toc"><li title="配置服务的设计" data-depth="2"><a href="/blog/手把手带你写一个web框架/03.实战第2关框架核心/12#配置服务的设计"><span>配置服务的设计</span></a></li><li title="配置文件的读取" data-depth="3"><a href="/blog/手把手带你写一个web框架/03.实战第2关框架核心/12#配置文件的读取"><span>配置文件的读取</span></a></li><li title="配置文件的替换" data-depth="3"><a href="/blog/手把手带你写一个web框架/03.实战第2关框架核心/12#配置文件的替换"><span>配置文件的替换</span></a></li><li title="配置项的解析" data-depth="3"><a href="/blog/手把手带你写一个web框架/03.实战第2关框架核心/12#配置项的解析"><span>配置项的解析</span></a></li><li title="配置服务的代码实现" data-depth="2"><a href="/blog/手把手带你写一个web框架/03.实战第2关框架核心/12#配置服务的代码实现"><span>配置服务的代码实现</span></a></li><li title="配置文件更新App服务" data-depth="2"><a href="/blog/手把手带你写一个web框架/03.实战第2关框架核心/12#配置文件更新app服务"><span>配置文件更新App服务</span></a></li><li title="配置文件热更新" data-depth="2"><a href="/blog/手把手带你写一个web框架/03.实战第2关框架核心/12#配置文件热更新"><span>配置文件热更新</span></a></li><li title="验证" data-depth="2"><a href="/blog/手把手带你写一个web框架/03.实战第2关框架核心/12#验证"><span>验证</span></a></li><li title="小结" data-depth="2"><a href="/blog/手把手带你写一个web框架/03.实战第2关框架核心/12#小结"><span>小结</span></a></li><li title="思考题" data-depth="2"><a href="/blog/手把手带你写一个web框架/03.实战第2关框架核心/12#思考题"><span>思考题</span></a></li></ul><div class="__dumi-default-layout-content"><div class="markdown"><h1 id="16配置和环境下配置服务中的设计思路"><a aria-hidden="true" tabindex="-1" href="/blog/手把手带你写一个web框架/03.实战第2关框架核心/12#16配置和环境下配置服务中的设计思路"><span class="icon icon-link"></span></a>16｜配置和环境（下）：配置服务中的设计思路</h1><p>你好，我是轩脉刃。</p><p>上一节课，我们已经定义好了配置文件服务的接口，这节课就来实现这些接口。先来规划配置文件服务目录，按照上一节课分析的，多个配置文件按类别放在不同配置文件夹中，在框架文件夹中，我们将配置文件接口代码写在框架文件夹下的contract/config.go文件中，将具体实现放在provider/config/目录中。</p><h2 id="配置服务的设计"><a aria-hidden="true" tabindex="-1" href="/blog/手把手带你写一个web框架/03.实战第2关框架核心/12#配置服务的设计"><span class="icon icon-link"></span></a>配置服务的设计</h2><p>不过设计优于实现，动手之前我们先思考下实现这个接口要如何设计。</p><p>首先，要读取一下配置文件夹中的文件。上节课说了，最终的配置文件夹地址为，应用服务的 ConfigFolder 下的环境变量对应的文件夹，比如 ConfigFolder/development。但是还有一个问题，就是配置文件的格式的选择。</p><p><strong>目前市面上的配置文件格式非常多，但是很难说哪种配置文件比较好，完全是不同平台、不同时代下的产物</strong>。比如Windows开发的配置常用INI、Java开发配置常用Properties，我这里选择了使用YAML格式。</p><h3 id="配置文件的读取"><a aria-hidden="true" tabindex="-1" href="/blog/手把手带你写一个web框架/03.实战第2关框架核心/12#配置文件的读取"><span class="icon icon-link"></span></a>配置文件的读取</h3><p>YAML格式是在Golang的项目中比较通用的一种格式，比如Kubernetes、Docker、Swagger等项目，都是使用YAML作为其配置文件的。YAML配置文件除了能表达基础类型比如string、int、float 之外，也能表达复杂的数组、结构等数据类型。</p><p>目前最新的YAML版本为1.2版本，配置的说明文档在<a target="_blank" rel="noopener noreferrer" href="https://yaml.org/">官网<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>上。它提供多种语言的解析库，其中<a target="_blank" rel="noopener noreferrer" href="https://github.com/go-yaml/yaml">go-yaml<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 就是非常通用的一个Go解析库，这个库的封装性非常好。</p><p>我们通过第一节课讲的快速阅读一个库的命令 <code>go doc github.com/go-yaml/yaml |grep &#x27;^func&#x27;</code>，可以看出来这个库对外提供的方法非常明确，一共三个方法：</p><ul><li>Marshal 表示序列化一个结构成为YAML格式；</li><li>Unmarshal表示反序列化一个YAML格式文本成为一个结构；</li><li>还有一个UnmarshalStrict 函数，表示严格反序列化，比如如果YAML格式文件中包含重复key的字段，那么使用UnmarshalStrict 函数反序列化会出现错误。</li></ul><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// 序列化</span></div><div class="token-line"><span class="token plain">    func Marshal(in interface{}) (out []byte, err error)</span></div><div class="token-line"><span class="token plain">    // 反序列化</span></div><div class="token-line"><span class="token plain">    func Unmarshal(in []byte, out interface{}) (err error)</span></div><div class="token-line"><span class="token plain">    // 严格反序列化</span></div><div class="token-line"><span class="token plain">    func UnmarshalStrict(in []byte, out interface{}) (err error)</span></div></pre></div><p>我们选择Unmarshal的函数进行反序列化，因为这样能提高框架对配置文件的容错性和易用性。好，读取配置文件的格式和对应工具搞定，下一步就是想清楚怎么替换了。</p><h3 id="配置文件的替换"><a aria-hidden="true" tabindex="-1" href="/blog/手把手带你写一个web框架/03.实战第2关框架核心/12#配置文件的替换"><span class="icon icon-link"></span></a>配置文件的替换</h3><p>在上一节课说的环境变量服务中，存放了包括.env中设置的环境变量，那么我们自然会希望使用上这些环境变量，把配置文件中有的字段使用环境变量替换掉。那么这里在配置文件中就需要有一个“占位符”。这个占位符表示当前这个字段去环境变量中进行阅读。</p><p>这个占位符的设计只有一个要求：够特别。只要这个占位符能和其他配置文件字符区分开就行，所以这里设计占位符为比较有语义的“env(XXXX)”。比如app/config/development/database.yaml 文件中的数据库密码，使用占位符表示如下：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">mysql:</span></div><div class="token-line"><span class="token plain">      hostname: 127.0.0.1</span></div><div class="token-line"><span class="token plain">      username: yejianfeng</span></div><div class="token-line"><span class="token plain">      password: env(DB_PASSWORD)</span></div><div class="token-line"><span class="token plain">      timeout: 1</span></div><div class="token-line"><span class="token plain">      readtime: 2.3</span></div></pre></div><p>要实现这个功能，其实也很简单，可以在读取YAML配置文件内容之后，进行完整的文本匹配，将所有环境变量env(xxx) 的字符替换为环境变量。我们应该能设计出替换文本的函数。</p><p>在框架目录的provider/config/service.go中，可以先实现这个方法。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// replace 表示使用环境变量maps替换context中的env(xxx)的环境变量</span></div><div class="token-line"><span class="token plain">    func replace(content []byte, maps map[string]string) []byte {</span></div><div class="token-line"><span class="token plain">       if maps == nil {</span></div><div class="token-line"><span class="token plain">          return content</span></div><div class="token-line"><span class="token plain">       }</span></div><div class="token-line"><span class="token plain">       // 直接使用ReplaceAll替换。这个性能可能不是最优，但是配置文件加载，频率是比较低的，可以接受</span></div><div class="token-line"><span class="token plain">       for key, val := range maps {</span></div><div class="token-line"><span class="token plain">          reKey := &quot;env(&quot; + key + &quot;)&quot;</span></div><div class="token-line"><span class="token plain">          content = bytes.ReplaceAll(content, []byte(reKey), []byte(val))</span></div><div class="token-line"><span class="token plain">       }</span></div><div class="token-line"><span class="token plain">       return content</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><h3 id="配置项的解析"><a aria-hidden="true" tabindex="-1" href="/blog/手把手带你写一个web框架/03.实战第2关框架核心/12#配置项的解析"><span class="icon icon-link"></span></a>配置项的解析</h3><p>读取并解析完配置文件内容，接下来就要根据path来解析某个配置项了。上一节课说，我们使用点号分割的路径读取方式，比如database.mysql.password 表示在配置文件夹中的database.yaml文件，其中的mysql配置，对应的是数据结构中的password字段。</p><p>那这种根据path来读取字段应该怎么实现呢？</p><p>在获取配置项的时候，我们已经通过go-yaml库将配置文件解析到一个map数据结构中了，而这个map数据结构的子项，明显也有可能是一个map数据结构。所以按照path路径查找，这明显应该是一个<strong>函数递归逻辑</strong>。</p><p>还是用刚才的database.mysql.password举例，可以拆分为3个结构。database 去根map中寻找；如果有这个key，就拿着mysql.password的path，去 database这个key对应的value中进行寻找；而递归寻找到了最后一级path为password，发现这个path没有下一级了，就停止递归。</p><p>详细的代码方法如下，同样存放在框架目录的provider/config/service.go中。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// 查找某个路径的配置项</span></div><div class="token-line"><span class="token plain">    func searchMap(source map[string]interface{}, path []string) interface{} {</span></div><div class="token-line"><span class="token plain">       if len(path) == 0 {</span></div><div class="token-line"><span class="token plain">          return source</span></div><div class="token-line"><span class="token plain">       }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">       // 判断是否有下个路径</span></div><div class="token-line"><span class="token plain">       next, ok := source[path[0]]</span></div><div class="token-line"><span class="token plain">       if ok {</span></div><div class="token-line"><span class="token plain">          // 判断这个路径是否为1</span></div><div class="token-line"><span class="token plain">          if len(path) == 1 {</span></div><div class="token-line"><span class="token plain">             return next</span></div><div class="token-line"><span class="token plain">          }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">          // 判断下一个路径的类型</span></div><div class="token-line"><span class="token plain">          switch next.(type) {</span></div><div class="token-line"><span class="token plain">          case map[interface{}]interface{}:</span></div><div class="token-line"><span class="token plain">             // 如果是interface的map，使用cast进行下value转换</span></div><div class="token-line"><span class="token plain">             return searchMap(cast.ToStringMap(next), path[1:])</span></div><div class="token-line"><span class="token plain">          case map[string]interface{}:</span></div><div class="token-line"><span class="token plain">             // 如果是map[string]，直接循环调用</span></div><div class="token-line"><span class="token plain">             return searchMap(next.(map[string]interface{}), path[1:])</span></div><div class="token-line"><span class="token plain">          default:</span></div><div class="token-line"><span class="token plain">             // 否则的话，返回nil</span></div><div class="token-line"><span class="token plain">             return nil</span></div><div class="token-line"><span class="token plain">          }</span></div><div class="token-line"><span class="token plain">       }</span></div><div class="token-line"><span class="token plain">       return nil</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    // 通过path获取某个元素</span></div><div class="token-line"><span class="token plain">    func (conf *HadeConfig) find(key string) interface{} {</span></div><div class="token-line"><span class="token plain">       ...</span></div><div class="token-line"><span class="token plain">       return searchMap(conf.confMaps, strings.Split(key, conf.keyDelim))</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>想通了以上三个核心实现难点，我们就可以着手整体代码实现了。</p><h2 id="配置服务的代码实现"><a aria-hidden="true" tabindex="-1" href="/blog/手把手带你写一个web框架/03.实战第2关框架核心/12#配置服务的代码实现"><span class="icon icon-link"></span></a>配置服务的代码实现</h2><p>首先，在框架文件夹的provider/config/service.go 中，创建一个配置文件服务HadeConfig。它有几个属性：folder代表配置本地配置文件所在的文件夹；keyDelim代表路径中的分割符号，也就是点；envMaps存放所有的环境变量；而confMaps存放每个配置解析后的结构，confRaws存放每个配置的原始文件信息。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// HadeConfig  表示hade框架的配置文件服务</span></div><div class="token-line"><span class="token plain">    type HadeConfig struct {</span></div><div class="token-line"><span class="token plain">       c        framework.Container    // 容器</span></div><div class="token-line"><span class="token plain">       folder   string                 // 文件夹</span></div><div class="token-line"><span class="token plain">       keyDelim string                 // 路径的分隔符，默认为点</span></div><div class="token-line"><span class="token plain">       ...</span></div><div class="token-line"><span class="token plain">       envMaps  map[string]string      // 所有的环境变量</span></div><div class="token-line"><span class="token plain">       confMaps map[string]interface{} // 配置文件结构，key为文件名</span></div><div class="token-line"><span class="token plain">       confRaws map[string][]byte      // 配置文件的原始信息</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>我们初始化这个HadeConfig的函数，它从服务提供者provider/config/provider.go中获取到三个参数，除了容器之外，另外两个是文件夹地址和所有的环境变量。</p><p>我们这里对provider.go 只列一下参数函数，其他的四个服务提供者函数(Register、Boot、IsDefer、Name) 可以参考<a target="_blank" rel="noopener noreferrer" href="https://github.com/gohade/coredemo/blob/geekbang/16/framework/provider/config/provider.go">GitHub上的代码<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// Paramas 服务提供者实例化的时候参数</span></div><div class="token-line"><span class="token plain">    func (provider *HadeConfigProvider) Params(c framework.Container) []interface{} {</span></div><div class="token-line"><span class="token plain">       appService := c.MustMake(contract.AppKey).(contract.App)</span></div><div class="token-line"><span class="token plain">       envService := c.MustMake(contract.EnvKey).(contract.Env)</span></div><div class="token-line"><span class="token plain">       env := envService.AppEnv()</span></div><div class="token-line"><span class="token plain">       // 配置文件夹地址</span></div><div class="token-line"><span class="token plain">       configFolder := appService.ConfigFolder()</span></div><div class="token-line"><span class="token plain">       envFolder := filepath.Join(configFolder, env)</span></div><div class="token-line"><span class="token plain">       // 传递容器，配置文件夹地址，所有环境变量</span></div><div class="token-line"><span class="token plain">       return []interface{}{c, envFolder, envService.All()}</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>那么在provider/config/service.go中，实例化的函数逻辑如下：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// NewHadeConfig 初始化Config方法</span></div><div class="token-line"><span class="token plain">    func NewHadeConfig(params ...interface{}) (interface{}, error) {</span></div><div class="token-line"><span class="token plain">       container := params[0].(framework.Container)</span></div><div class="token-line"><span class="token plain">       envFolder := params[1].(string)</span></div><div class="token-line"><span class="token plain">       envMaps := params[2].(map[string]string)</span></div><div class="token-line"><span class="token plain">       </span></div><div class="token-line"><span class="token plain">       // 检查文件夹是否存在</span></div><div class="token-line"><span class="token plain">       if _, err := os.Stat(envFolder); os.IsNotExist(err) {</span></div><div class="token-line"><span class="token plain">          return nil, errors.New(&quot;folder &quot; + envFolder + &quot; not exist: &quot; + err.Error())</span></div><div class="token-line"><span class="token plain">       }</span></div><div class="token-line"><span class="token plain">       // 实例化</span></div><div class="token-line"><span class="token plain">       hadeConf := &amp;HadeConfig{</span></div><div class="token-line"><span class="token plain">          c:        container,</span></div><div class="token-line"><span class="token plain">          folder:   envFolder,</span></div><div class="token-line"><span class="token plain">          envMaps:  envMaps,</span></div><div class="token-line"><span class="token plain">          confMaps: map[string]interface{}{},</span></div><div class="token-line"><span class="token plain">          confRaws: map[string][]byte{},</span></div><div class="token-line"><span class="token plain">          keyDelim: &quot;.&quot;,</span></div><div class="token-line"><span class="token plain">          lock:     sync.RWMutex{},</span></div><div class="token-line"><span class="token plain">       }</span></div><div class="token-line"><span class="token plain">       // 读取每个文件</span></div><div class="token-line"><span class="token plain">       files, err := ioutil.ReadDir(envFolder)</span></div><div class="token-line"><span class="token plain">       if err != nil {</span></div><div class="token-line"><span class="token plain">          return nil, errors.WithStack(err)</span></div><div class="token-line"><span class="token plain">       }</span></div><div class="token-line"><span class="token plain">       for _, file := range files {</span></div><div class="token-line"><span class="token plain">          fileName := file.Name()</span></div><div class="token-line"><span class="token plain">          err := hadeConf.loadConfigFile(envFolder, fileName)</span></div><div class="token-line"><span class="token plain">          if err != nil {</span></div><div class="token-line"><span class="token plain">             log.Println(err)</span></div><div class="token-line"><span class="token plain">             continue</span></div><div class="token-line"><span class="token plain">          }</span></div><div class="token-line"><span class="token plain">       }</span></div><div class="token-line"><span class="token plain">       ...</span></div><div class="token-line"><span class="token plain">       return hadeConf, nil</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    // 读取某个配置文件</span></div><div class="token-line"><span class="token plain">    func (conf *HadeConfig) loadConfigFile(folder string, file string) error {</span></div><div class="token-line"><span class="token plain">       conf.lock.Lock()</span></div><div class="token-line"><span class="token plain">       defer conf.lock.Unlock()</span></div><div class="token-line"><span class="token plain">       //  判断文件是否以yaml或者yml作为后缀</span></div><div class="token-line"><span class="token plain">       s := strings.Split(file, &quot;.&quot;)</span></div><div class="token-line"><span class="token plain">       if len(s) == 2 &amp;&amp; (s[1] == &quot;yaml&quot; || s[1] == &quot;yml&quot;) {</span></div><div class="token-line"><span class="token plain">          name := s[0]</span></div><div class="token-line"><span class="token plain">          // 读取文件内容</span></div><div class="token-line"><span class="token plain">          bf, err := ioutil.ReadFile(filepath.Join(folder, file))</span></div><div class="token-line"><span class="token plain">          if err != nil {</span></div><div class="token-line"><span class="token plain">             return err</span></div><div class="token-line"><span class="token plain">          }</span></div><div class="token-line"><span class="token plain">          // 直接针对文本做环境变量的替换</span></div><div class="token-line"><span class="token plain">          bf = replace(bf, conf.envMaps)</span></div><div class="token-line"><span class="token plain">          // 解析对应的文件</span></div><div class="token-line"><span class="token plain">          c := map[string]interface{}{}</span></div><div class="token-line"><span class="token plain">          if err := yaml.Unmarshal(bf, &amp;c); err != nil {</span></div><div class="token-line"><span class="token plain">             return err</span></div><div class="token-line"><span class="token plain">          }</span></div><div class="token-line"><span class="token plain">          conf.confMaps[name] = c</span></div><div class="token-line"><span class="token plain">          conf.confRaws[name] = bf</span></div><div class="token-line"><span class="token plain">       }</span></div><div class="token-line"><span class="token plain">       return nil</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>逻辑非常清晰。先检查配置文件夹是否存在，然后读取文件夹中的每个以yaml或者yml后缀的文件；读取之后，先用replace对环境变量进行一次替换；替换之后使用 go-yaml，对文件进行解析。</p><p>初始化实例就是一个完整的 解析文件的过程，解析结束之后，confMaps里存放的就是解析之后的结果。</p><p>配置文件的获取接口上节课已经写好了，定义了接口的系列方法，这里我们就详细实现Get/GetBool/GetInt，其他方法大同小异，就不贴出来了，你可以直接参考<a target="_blank" rel="noopener noreferrer" href="https://github.com/gohade/coredemo/blob/geekbang/16/framework/provider/config/service.go">GitHub上的代码<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>。</p><p>前面已经想好了，用方法find，通过path，从一个嵌套map confMaps中获取数据。所以Get方法就是调用一下find方法而已，同样也在service.go中：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// Get 获取某个配置项</span></div><div class="token-line"><span class="token plain">    func (conf *HadeConfig) Get(key string) interface{} {</span></div><div class="token-line"><span class="token plain">       return conf.find(key)</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>而对应的Get系列的方法我们使用cast库进行类型转换，比如：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// GetBool 获取bool类型配置</span></div><div class="token-line"><span class="token plain">    func (conf *HadeConfig) GetBool(key string) bool {</span></div><div class="token-line"><span class="token plain">       return cast.ToBool(conf.find(key))</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    // GetInt 获取int类型配置</span></div><div class="token-line"><span class="token plain">    func (conf *HadeConfig) GetInt(key string) int {</span></div><div class="token-line"><span class="token plain">       return cast.ToInt(conf.find(key))</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>到这里，配置服务的代码已经基本成型了。但是实际上还有两个细节我们需要认真思考。</p><p>首先，因为之前我们设置过App服务，将一个App服务的目录都安排好了，但是如果之后有需求要改变这些目录的配置呢？如果有的话，是否可以通过配置来进行修改呢？所以第一个问题就是，我们要思考配置文件更新App服务的操作。</p><p>其次，假设现在配置服务能从文件中获取配置了，但是如果文件修改了，我们是否需要重新启动应用呢？是否有能不启动应用的方法呢？</p><p>下面我们来一一解决这两个问题。</p><h2 id="配置文件更新app服务"><a aria-hidden="true" tabindex="-1" href="/blog/手把手带你写一个web框架/03.实战第2关框架核心/12#配置文件更新app服务"><span class="icon icon-link"></span></a>配置文件更新App服务</h2><p>现在有了配置文件服务，但在没有配置文件服务之前，我们启动服务的appService，也是有可能要修改这个服务的配置的。回忆<a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/423982">第十二<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a><a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/423982">课<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>，appService中存放了启动这个业务实例默认设置的文件夹目录和地址。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">//BaseFolder 定义项目基础地址</span></div><div class="token-line"><span class="token plain">    BaseFolder() string</span></div><div class="token-line"><span class="token plain">    // ConfigFolder 定义了配置文件的路径</span></div><div class="token-line"><span class="token plain">    ConfigFolder() string</span></div><div class="token-line"><span class="token plain">    // LogFolder 定义了日志所在路径</span></div><div class="token-line"><span class="token plain">    LogFolder() string</span></div><div class="token-line"><span class="token plain">    // ProviderFolder 定义业务自己的服务提供者地址</span></div><div class="token-line"><span class="token plain">    ProviderFolder() string</span></div><div class="token-line"><span class="token plain">    // MiddlewareFolder 定义业务自己定义的中间件</span></div><div class="token-line"><span class="token plain">    MiddlewareFolder() string</span></div><div class="token-line"><span class="token plain">    // CommandFolder 定义业务定义的命令</span></div><div class="token-line"><span class="token plain">    CommandFolder() string</span></div><div class="token-line"><span class="token plain">    // RuntimeFolder 定义业务的运行中间态信息</span></div><div class="token-line"><span class="token plain">    RuntimeFolder() string</span></div><div class="token-line"><span class="token plain">    // TestFolder 存放测试所需要的信息</span></div><div class="token-line"><span class="token plain">    TestFolder() string</span></div></pre></div><p>现在有需求将这些文件夹目录，在配置文件中进行配置并修改。所以应该在加载到配置服务时，再更新下appService。加载逻辑如下：</p><p><img src="https://static001.geekbang.org/resource/image/f5/ee/f5141333501ce140314fb985b75c6eee.jpg?wh=1920x1080" alt="图片"/></p><p>可以把设定App的这些配置文件，存放在配置文件夹的app.yaml文件的path设置项下，其中每个配置项的key，对应appService中每个对应的服务。比如log_folder对应LogFolder目录：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">path:</span></div><div class="token-line"><span class="token plain">      log_folder: &quot;/home/jianfengye/hade/log/&quot;</span></div><div class="token-line"><span class="token plain">      runtime_folder: &quot;/home/jianfengye/hade/runtime/&quot;</span></div></pre></div><p>现在加载配置服务的时候，当读取到配置服务app.path下有内容，就需要更新appService的配置。首先需要修改appService，修改框架目录下的provider/app/service.go文件。</p><p>将HadeApp增加一个configMap字段：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// HadeApp 代表hade框架的App实现</span></div><div class="token-line"><span class="token plain">    type HadeApp struct {</span></div><div class="token-line"><span class="token plain">       ...</span></div><div class="token-line"><span class="token plain">       configMap map[string]string // 配置加载</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>同时为HadeApp增加LoadAppConfig方法，用于读取配置文件中的信息：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// LoadAppConfig 加载配置map</span></div><div class="token-line"><span class="token plain">    func (app *HadeApp) LoadAppConfig(kv map[string]string) {</span></div><div class="token-line"><span class="token plain">       for key, val := range kv {</span></div><div class="token-line"><span class="token plain">          app.configMap[key] = val</span></div><div class="token-line"><span class="token plain">       }</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>再修改对应的LogFolder等一系列XXXFolder的方法，先读取configMap中的值，如果有的话，先用configMap中的值：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// LogFolder 表示日志存放地址</span></div><div class="token-line"><span class="token plain">    func (app HadeApp) LogFolder() string {</span></div><div class="token-line"><span class="token plain">       if val, ok := app.configMap[&quot;log_folder&quot;]; ok {</span></div><div class="token-line"><span class="token plain">          return val</span></div><div class="token-line"><span class="token plain">       }</span></div><div class="token-line"><span class="token plain">       return filepath.Join(app.StorageFolder(), &quot;log&quot;)</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>这样，对appService的修改就完成了。</p><p>在configService，读取配置文件loadConfigFile的时候，要注意，如果当前的配置文件是app.yaml， 我们需要调用appService的LoadAppConfig方法：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// 读取某个配置文件</span></div><div class="token-line"><span class="token plain">    func (conf *HadeConfig) loadConfigFile(folder string, file string) error {</span></div><div class="token-line"><span class="token plain">       ...</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">       //  判断文件是否以yaml或者yml作为后缀</span></div><div class="token-line"><span class="token plain">       s := strings.Split(file, &quot;.&quot;)</span></div><div class="token-line"><span class="token plain">       if len(s) == 2 &amp;&amp; (s[1] == &quot;yaml&quot; || s[1] == &quot;yml&quot;) {</span></div><div class="token-line"><span class="token plain">          name := s[0]</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">          ...</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">          // 读取app.path中的信息，更新app对应的folder</span></div><div class="token-line"><span class="token plain">          if name == &quot;app&quot; &amp;&amp; conf.c.IsBind(contract.AppKey) {</span></div><div class="token-line"><span class="token plain">             if p, ok := c[&quot;path&quot;]; ok {</span></div><div class="token-line"><span class="token plain">                appService := conf.c.MustMake(contract.AppKey).(contract.App)</span></div><div class="token-line"><span class="token plain">                appService.LoadAppConfig(cast.ToStringMapString(p))</span></div><div class="token-line"><span class="token plain">             }</span></div><div class="token-line"><span class="token plain">          }</span></div><div class="token-line"><span class="token plain">       }</span></div><div class="token-line"><span class="token plain">       return nil</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>这样在加载app.yaml的配置文件的时候，就同时更新了appService 里面的配置。</p><h2 id="配置文件热更新"><a aria-hidden="true" tabindex="-1" href="/blog/手把手带你写一个web框架/03.实战第2关框架核心/12#配置文件热更新"><span class="icon icon-link"></span></a>配置文件热更新</h2><p>正常来说，在程序启动的时候会读取一次配置文件，但是在程序运行过程中，我们难免会遇到需要修改配置文件的操作。也就是之前思考的第二个问题。</p><p>这个时候，是否需要重新启动一次程序再加载一次配置文件呢？这当然是没有问题的，但是更为强大的是，<strong>我们可以自动监控配置文件目录下的所有文件，当配置文件有修改和更新的时候，能自动更新程序中的配置文件信息，也就是实现配置文件热更新</strong>。</p><p>这个热更新看起来很麻烦，其实在Golang中是非常简单的事情。我们使用 <a target="_blank" rel="noopener noreferrer" href="https://github.com/fsnotify/fsnotify">fsnotify<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 库能很方便对一个文件夹进行监控，当文件夹中有文件增/删/改的时候，会通过channel进行事件回调。</p><p>这个库的使用方式很简单。大致思路就是先使用NewWatcher创建一个监控器watcher，然后使用Add来监控某个文件夹，通过watcher设置的events来判断文件是否有变化，如果有变化，就进行对应的操作，比如更新内存中配置服务存储的map结构。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// NewHadeConfig 初始化Config方法</span></div><div class="token-line"><span class="token plain">    func NewHadeConfig(params ...interface{}) (interface{}, error) {</span></div><div class="token-line"><span class="token plain">       ...</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">       // 监控文件夹文件</span></div><div class="token-line"><span class="token plain">       watch, err := fsnotify.NewWatcher()</span></div><div class="token-line"><span class="token plain">       if err != nil {</span></div><div class="token-line"><span class="token plain">          return nil, err</span></div><div class="token-line"><span class="token plain">       }</span></div><div class="token-line"><span class="token plain">       err = watch.Add(envFolder)</span></div><div class="token-line"><span class="token plain">       if err != nil {</span></div><div class="token-line"><span class="token plain">          return nil, err</span></div><div class="token-line"><span class="token plain">       }</span></div><div class="token-line"><span class="token plain">       go func() {</span></div><div class="token-line"><span class="token plain">          defer func() {</span></div><div class="token-line"><span class="token plain">             if err := recover(); err != nil {</span></div><div class="token-line"><span class="token plain">                fmt.Println(err)</span></div><div class="token-line"><span class="token plain">             }</span></div><div class="token-line"><span class="token plain">          }()</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">          for {</span></div><div class="token-line"><span class="token plain">             select {</span></div><div class="token-line"><span class="token plain">             case ev := &lt;-watch.Events:</span></div><div class="token-line"><span class="token plain">                {</span></div><div class="token-line"><span class="token plain">                   //判断事件发生的类型，如下5种</span></div><div class="token-line"><span class="token plain">                   // Create 创建</span></div><div class="token-line"><span class="token plain">                   // Write 写入</span></div><div class="token-line"><span class="token plain">                   // Remove 删除</span></div><div class="token-line"><span class="token plain">                   path, _ := filepath.Abs(ev.Name)</span></div><div class="token-line"><span class="token plain">                   index := strings.LastIndex(path, string(os.PathSeparator))</span></div><div class="token-line"><span class="token plain">                   folder := path[:index]</span></div><div class="token-line"><span class="token plain">                   fileName := path[index+1:]</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">                   if ev.Op&amp;fsnotify.Create == fsnotify.Create {</span></div><div class="token-line"><span class="token plain">                      log.Println(&quot;创建文件 : &quot;, ev.Name)</span></div><div class="token-line"><span class="token plain">                      hadeConf.loadConfigFile(folder, fileName)</span></div><div class="token-line"><span class="token plain">                   }</span></div><div class="token-line"><span class="token plain">                   if ev.Op&amp;fsnotify.Write == fsnotify.Write {</span></div><div class="token-line"><span class="token plain">                      log.Println(&quot;写入文件 : &quot;, ev.Name)</span></div><div class="token-line"><span class="token plain">                      hadeConf.loadConfigFile(folder, fileName)</span></div><div class="token-line"><span class="token plain">                   }</span></div><div class="token-line"><span class="token plain">                   if ev.Op&amp;fsnotify.Remove == fsnotify.Remove {</span></div><div class="token-line"><span class="token plain">                      log.Println(&quot;删除文件 : &quot;, ev.Name)</span></div><div class="token-line"><span class="token plain">                      hadeConf.removeConfigFile(folder, fileName)</span></div><div class="token-line"><span class="token plain">                   }</span></div><div class="token-line"><span class="token plain">                }</span></div><div class="token-line"><span class="token plain">             case err := &lt;-watch.Errors:</span></div><div class="token-line"><span class="token plain">                {</span></div><div class="token-line"><span class="token plain">                   log.Println(&quot;error : &quot;, err)</span></div><div class="token-line"><span class="token plain">                   return</span></div><div class="token-line"><span class="token plain">                }</span></div><div class="token-line"><span class="token plain">             }</span></div><div class="token-line"><span class="token plain">          }</span></div><div class="token-line"><span class="token plain">       }()</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">       return hadeConf, nil</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>代码如上，我们使用NewWatcher创建一个监听器，监听配置文件目录，接着启动一个新的Goroutine作为监听协程。在监听协程中，监听配置文件的创建、更新、删除操作。创建和更新对应 LoadConfigFile 操作。</p><p>而删除，对应的是 removeConfigFile操作，这个操作的内容就是删除配置服务中的confMaps中对应的key。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// 删除文件的操作</span></div><div class="token-line"><span class="token plain">    func (conf *HadeConfig) removeConfigFile(folder string, file string) error {</span></div><div class="token-line"><span class="token plain">       conf.lock.Lock()</span></div><div class="token-line"><span class="token plain">       defer conf.lock.Unlock()</span></div><div class="token-line"><span class="token plain">       s := strings.Split(file, &quot;.&quot;)</span></div><div class="token-line"><span class="token plain">       // 只有yaml或者yml后缀才执行</span></div><div class="token-line"><span class="token plain">       if len(s) == 2 &amp;&amp; (s[1] == &quot;yaml&quot; || s[1] == &quot;yml&quot;) {</span></div><div class="token-line"><span class="token plain">          name := s[0]</span></div><div class="token-line"><span class="token plain">          // 删除内存中对应的key</span></div><div class="token-line"><span class="token plain">          delete(conf.confRaws, name)</span></div><div class="token-line"><span class="token plain">          delete(conf.confMaps, name)</span></div><div class="token-line"><span class="token plain">       }</span></div><div class="token-line"><span class="token plain">       return nil</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>这里注意下，由于在运行时增加了对confMaps的写操作，所以需要对confMaps进行锁设置，以防止在写confMaps的时候，读操作进入读取了错误信息。</p><p>分析目前的这个场景，读明显多于写。所以我们的锁应该是一个读写锁，读写锁可以让多个读并发读，但是只要有一个写操作，读和写都需要等待。这个很符合当前这个场景。</p><p>所以在框架目录的provider/config/service.go中的HadeConfig，我们增加了一个读写锁lock。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// HadeConfig  表示hade框架的配置文件服务</span></div><div class="token-line"><span class="token plain">    type HadeConfig struct {</span></div><div class="token-line"><span class="token plain">       ...</span></div><div class="token-line"><span class="token plain">       lock     sync.RWMutex           // 配置文件读写锁</span></div><div class="token-line"><span class="token plain">       ...</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>而在loadConfigFile和removeConfigFile这两个对配置有修改的情况，使用写锁锁住HadeConfig。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// 读取某个配置文件</span></div><div class="token-line"><span class="token plain">    func (conf *HadeConfig) loadConfigFile(folder string, file string) error {</span></div><div class="token-line"><span class="token plain">       conf.lock.Lock()</span></div><div class="token-line"><span class="token plain">       defer conf.lock.Unlock()</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">       ...</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>在Get系列方法调用的find函数中，使用读锁来进行读操作。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// 通过path来获取某个配置项</span></div><div class="token-line"><span class="token plain">    func (conf *HadeConfig) find(key string) interface{} {</span></div><div class="token-line"><span class="token plain">       conf.lock.RLock()</span></div><div class="token-line"><span class="token plain">       defer conf.lock.RUnlock()</span></div><div class="token-line"><span class="token plain">       ...</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>这样，配置服务就开发完成了。</p><h2 id="验证"><a aria-hidden="true" tabindex="-1" href="/blog/手把手带你写一个web框架/03.实战第2关框架核心/12#验证"><span class="icon icon-link"></span></a>验证</h2><p>我们先测试环境变量注入配置文件的功能。将业务目录下的config/development/database.yaml 中的mysql.password，使用环境变量进行替换。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">mysql:</span></div><div class="token-line"><span class="token plain">      hostname: 127.0.0.1</span></div><div class="token-line"><span class="token plain">      username: yejianfeng</span></div><div class="token-line"><span class="token plain">      password: env(DB_PASSWORD)</span></div><div class="token-line"><span class="token plain">      timeout: 1</span></div><div class="token-line"><span class="token plain">      readtime: 2.3</span></div></pre></div><p>然后修改业务目录下的module/demo/api.go，替换其中/demo/demo对应的路由方法。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">func (api *DemoApi) Demo(c *gin.Context) {</span></div><div class="token-line"><span class="token plain">       // 获取password</span></div><div class="token-line"><span class="token plain">       configService := c.MustMake(contract.ConfigKey).(contract.Config)</span></div><div class="token-line"><span class="token plain">       password := configService.GetString(&quot;database.mysql.password&quot;)</span></div><div class="token-line"><span class="token plain">       // 打印出来</span></div><div class="token-line"><span class="token plain">       c.JSON(200, password)</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>最后使用命令行 <code>./hade app start</code> 启动服务。打开浏览器，看到输出：</p><p><img src="https://static001.geekbang.org/resource/image/27/f1/275ddfb18f04549dd62e6b45fc3cccf1.png?wh=478x86" alt="图片"/></p><p>说明此时还没注入环境变量。下面使用命令行：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">DB_PASSWORD=123 ./hade app start</span></div></pre></div><p>启动服务。这个命令注入了DB_PASSWORD这个环境变量。<br/>重启打开浏览器看到输出。</p><p><img src="https://static001.geekbang.org/resource/image/33/b6/33f14f5277ea8294458141d5393269b6.png?wh=405x90" alt="图片"/></p><p>环境变量注入成功！</p><p>这个时候我们不停止进程，直接修改配置文件database.yaml中的mysql.password：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">mysql:</span></div><div class="token-line"><span class="token plain">      hostname: 127.0.0.1</span></div><div class="token-line"><span class="token plain">      username: yejianfeng</span></div><div class="token-line"><span class="token plain">      password: 456789</span></div><div class="token-line"><span class="token plain">      timeout: 1</span></div><div class="token-line"><span class="token plain">      readtime: 2.3</span></div></pre></div><p>打开浏览器，输出已经变化了。</p><p><img src="https://static001.geekbang.org/resource/image/6c/b7/6c86bf1f4f055d94fb17c756415a94b7.png?wh=377x82" alt="图片"/></p><p>说明热更新已经生效了，测试成功。</p><p>今天所有代码的目录结构截图，也贴在这里供你对比检查，代码放在GitHub上的 <a target="_blank" rel="noopener noreferrer" href="https://github.com/gohade/coredemo/tree/geekbang/16">16分支<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 里。</p><p><img src="https://static001.geekbang.org/resource/image/6c/38/6c9b9046f41e4b5c0719fe205540c438.png?wh=351x1140" alt="图片"/></p><h2 id="小结"><a aria-hidden="true" tabindex="-1" href="/blog/手把手带你写一个web框架/03.实战第2关框架核心/12#小结"><span class="icon icon-link"></span></a>小结</h2><p>配置服务在框架中是一个非常基础且重要的服务。</p><p>我们考虑了整个配置服务的实现，先读取配置文件，再替换环境变量，最后再根据路径获取配置项，这样三步走完成了基本的配置服务。在配置服务的基础上，我们又补充了配置服务加载时对App服务的更新，并且为配置服务增加了热更新的机制。</p><p>我个人认为，配置服务是一个App中最常用到的服务了，有非常方便的配置服务接口，能为业务代码节省不少的代码量。<strong>提供多种设置配置的方式，是真实从业务需求出发的</strong>。</p><p>比如在实际工作中，有的需求要求数据库密码不能进入git库，必须通过环境变量获取，我们就可以通过环境变量获取配置；而有的需求要求在一个服务器上调试测试和预发布环境，我们可以通过.env切换不同环境。所以，有个多层次的环境配置机制，对于一个框架来说是非常必要的。</p><h2 id="思考题"><a aria-hidden="true" tabindex="-1" href="/blog/手把手带你写一个web框架/03.实战第2关框架核心/12#思考题"><span class="icon icon-link"></span></a>思考题</h2><p>现在有配置文件服务了，但是根据路径、获取某个配置却只能在代码中获取。这里我们希望有一个命令行工具 <code>./hade config get &quot;database.mysql&quot;</code> 能获取到这个path路径对应的配置。你可以尝试实现么？</p><p>欢迎在留言区分享你的思考。感谢你的收听，如果觉得有收获，也欢迎把今天的内容分享给你身边的朋友，邀他一起学习。我们下节课见～</p></div><div class="__dumi-default-layout-footer-meta"><a target="_blank" rel="noopener noreferrer" href="https://github.com/GGwujun/blog/edit/master/docs/手把手带你写一个Web框架/03.实战第2关框架核心/12.md">在 GitHub 上编辑此页<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a><span data-updated-text="最后更新时间：">5/2/2022 10:56:58</span></div></div></div></div>
	<script>
  window.g_useSSR = true;
  window.g_initialProps = {};
	</script>

    <script>
      (function () {
        if (!location.port) {
          (function (i, s, o, g, r, a, m) {
            i["GoogleAnalyticsObject"] = r;
            (i[r] =
              i[r] ||
              function () {
                (i[r].q = i[r].q || []).push(arguments);
              }),
              (i[r].l = 1 * new Date());
            (a = s.createElement(o)), (m = s.getElementsByTagName(o)[0]);
            a.async = 1;
            a.src = g;
            m.parentNode.insertBefore(a, m);
          })(
            window,
            document,
            "script",
            "//www.google-analytics.com/analytics.js",
            "ga"
          );
          ga("create", "UA-149864185-1", "auto");
          ga("send", "pageview");
        }
      })();
    </script>
    <script src="/blog/umi.js"></script>
  </body>
</html>
