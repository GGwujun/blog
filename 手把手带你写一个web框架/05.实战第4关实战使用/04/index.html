<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no"
    />
    <link rel="shortcut icon" type="image/x-icon" href="/logo.png" />
    <link rel="stylesheet" href="/blog/umi.css" />
    <script>
      window.routerBase = "/blog";
    </script>
    <script>
      //! umi version: 3.5.17
    </script>
    <script>
      !(function () {
        var e = localStorage.getItem("dumi:prefers-color"),
          t = window.matchMedia("(prefers-color-scheme: dark)").matches,
          r = ["light", "dark", "auto"];
        document.documentElement.setAttribute(
          "data-prefers-color",
          e === r[2] ? (t ? r[1] : r[0]) : r.indexOf(e) > -1 ? e : r[0]
        );
      })();
    </script>
    <title>33｜业务开发（上）：问答业务开发</title>
  </head>
  <body>
    <div id="root"><div class="__dumi-default-layout" data-route="/手把手带你写一个web框架/05.实战第4关实战使用/04" data-show-sidemenu="true" data-show-slugs="true" data-site-mode="true" data-gapless="false"><div class="__dumi-default-navbar" data-mode="site"><button class="__dumi-default-navbar-toggle"></button><a class="__dumi-default-navbar-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog/">大师兄</a><nav><div class="__dumi-default-search"><input type="search" class="__dumi-default-search-input" value=""/><ul></ul></div><span>计算机基础<ul><li><a href="/blog/编译原理之美">编译原理之美</a></li><li><a href="/blog/编译原理实战">编译原理实战</a></li><li><a href="/blog/深入浅出计算机组成原理">深入浅出计算机组成原理</a></li><li><a href="/blog/详解http">详解http</a></li><li><a href="/blog/计算机网络通关29讲">计算机网络通关29讲</a></li><li><a href="/blog/网络排查案例课">网络排查案例课</a></li><li><a href="/blog/linux操作系统">linux操作系统</a></li><li><a href="/blog/linux性能优化实战">linux性能优化实战</a></li><li><a href="/blog/程序员数学基础">程序员数学基础</a></li><li><a href="/blog/趣谈网络协议">趣谈网络协议</a></li><li><a href="/blog/操作系统实战">操作系统实战</a></li><li><a href="/blog/软件工程之美">软件工程之美</a></li><li><a href="/blog/sql必知必会">sql必知必会</a></li><li><a href="/blog/操作系统实战45讲">操作系统实战45讲</a></li><li><a href="/blog/网络编程实战">网络编程实战</a></li></ul></span><span>算法<ul><li><a href="/blog/常用算法25讲">常用算法25讲</a></li><li><a href="/blog/数据结构与算法之美">数据结构与算法之美</a></li><li><a href="/blog/业务开发算法50讲">业务开发算法50讲</a></li><li><a href="/blog/动态规划面试宝典">动态规划面试宝典</a></li></ul></span><span>前端开发<ul><li><a href="/blog/浏览器工作原理与实践">浏览器工作原理与实践</a></li><li><a href="/blog/新时代产品经理进阶之路">新时代产品经理进阶之路</a></li><li><a href="/blog/全栈工程师修炼指南">全栈工程师修炼指南</a></li><li><a href="/blog/flutter核心技术与实战">flutter核心技术与实战</a></li><li><a href="/blog/java-script核心原理解析">java-script核心原理解析</a></li><li><a href="/blog/说透低代码">说透低代码</a></li><li><a href="/blog/nodejs应用开发实战">nodejs应用开发实战</a></li><li><a href="/blog/反爬虫兵法演绎20讲">反爬虫兵法演绎20讲</a></li><li><a href="/blog/reactnative新架构实战课">reactnative新架构实战课</a></li><li><a href="/blog/正则表达式入门">正则表达式入门</a></li><li><a href="/blog/重学前端">重学前端</a></li><li><a href="/blog/serverless入门课">serverless入门课</a></li><li><a href="/blog/type-script入门实战笔记">type-script入门实战笔记</a></li><li><a href="/blog/图解googlev8">图解googlev8</a></li><li><a href="/blog/vue3源码分析">vue3源码分析</a></li><li><a href="/blog/玩转Vue3全家桶">玩转Vue3全家桶</a></li><li><a href="/blog/webassembly入门">webassembly入门</a></li><li><a aria-current="page" class="active" href="/blog/手把手带你写一个Web框架">手把手带你写一个Web框架</a></li><li><a href="/blog/web漏洞挖掘实战">web漏洞挖掘实战</a></li><li><a href="/blog/跟月影学可视化">跟月影学可视化</a></li><li><a href="/blog/搞定音频技术">搞定音频技术</a></li><li><a href="/blog/攻克视频技术">攻克视频技术</a></li></ul></span><span>前端工程化<ul><li><a href="/blog/logger">logger</a></li><li><a href="/blog/webpack">webpack</a></li><li><a href="/blog/webpackChain">webpackChain</a></li></ul></span><span>前端性能优化<ul><li><a href="/blog/react性能调优">react性能调优</a></li></ul></span><span>软件测试<ul><li><a href="/blog/全链路压测实战30讲">全链路压测实战30讲</a></li><li><a href="/blog/性能测试实战30讲">性能测试实战30讲</a></li><li><a href="/blog/自动化测试高手课">自动化测试高手课</a></li><li><a href="/blog/软件测试52讲">软件测试52讲</a></li></ul></span><span>面试<ul><li><a href="/blog/面试现场">面试现场</a></li></ul></span><span>杂谈<ul><li><a href="/blog/超级访谈对话张雪峰">超级访谈对话张雪峰</a></li><li><a href="/blog/Git实战手册">Git实战手册</a></li><li><a href="/blog/NodeJS">NodeJS</a></li><li><a href="/blog/ReactJS">ReactJS</a></li><li><a href="/blog/UI设计">UI设计</a></li><li><a href="/blog/webpack4系列教程">webpack4系列教程</a></li><li><a href="/blog/前端知识体系">前端知识体系</a></li><li><a href="/blog/剑指offer刷题笔记">剑指offer刷题笔记</a></li><li><a href="/blog/思考与成长">思考与成长</a></li><li><a href="/blog/设计模式手册">设计模式手册</a></li></ul></span><div class="__dumi-default-navbar-tool"><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "></div></div></div></nav></div><div class="__dumi-default-menu" data-mode="site"><div class="__dumi-default-menu-inner"><div class="__dumi-default-menu-header"><a class="__dumi-default-menu-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog/"></a><h1>大师兄</h1><p></p></div><div class="__dumi-default-menu-mobile-area"><ul class="__dumi-default-menu-nav-list"><li>计算机基础<ul><li><a href="/blog/编译原理之美">编译原理之美</a></li><li><a href="/blog/编译原理实战">编译原理实战</a></li><li><a href="/blog/深入浅出计算机组成原理">深入浅出计算机组成原理</a></li><li><a href="/blog/详解http">详解http</a></li><li><a href="/blog/计算机网络通关29讲">计算机网络通关29讲</a></li><li><a href="/blog/网络排查案例课">网络排查案例课</a></li><li><a href="/blog/linux操作系统">linux操作系统</a></li><li><a href="/blog/linux性能优化实战">linux性能优化实战</a></li><li><a href="/blog/程序员数学基础">程序员数学基础</a></li><li><a href="/blog/趣谈网络协议">趣谈网络协议</a></li><li><a href="/blog/操作系统实战">操作系统实战</a></li><li><a href="/blog/软件工程之美">软件工程之美</a></li><li><a href="/blog/sql必知必会">sql必知必会</a></li><li><a href="/blog/操作系统实战45讲">操作系统实战45讲</a></li><li><a href="/blog/网络编程实战">网络编程实战</a></li></ul></li><li>算法<ul><li><a href="/blog/常用算法25讲">常用算法25讲</a></li><li><a href="/blog/数据结构与算法之美">数据结构与算法之美</a></li><li><a href="/blog/业务开发算法50讲">业务开发算法50讲</a></li><li><a href="/blog/动态规划面试宝典">动态规划面试宝典</a></li></ul></li><li>前端开发<ul><li><a href="/blog/浏览器工作原理与实践">浏览器工作原理与实践</a></li><li><a href="/blog/新时代产品经理进阶之路">新时代产品经理进阶之路</a></li><li><a href="/blog/全栈工程师修炼指南">全栈工程师修炼指南</a></li><li><a href="/blog/flutter核心技术与实战">flutter核心技术与实战</a></li><li><a href="/blog/java-script核心原理解析">java-script核心原理解析</a></li><li><a href="/blog/说透低代码">说透低代码</a></li><li><a href="/blog/nodejs应用开发实战">nodejs应用开发实战</a></li><li><a href="/blog/反爬虫兵法演绎20讲">反爬虫兵法演绎20讲</a></li><li><a href="/blog/reactnative新架构实战课">reactnative新架构实战课</a></li><li><a href="/blog/正则表达式入门">正则表达式入门</a></li><li><a href="/blog/重学前端">重学前端</a></li><li><a href="/blog/serverless入门课">serverless入门课</a></li><li><a href="/blog/type-script入门实战笔记">type-script入门实战笔记</a></li><li><a href="/blog/图解googlev8">图解googlev8</a></li><li><a href="/blog/vue3源码分析">vue3源码分析</a></li><li><a href="/blog/玩转Vue3全家桶">玩转Vue3全家桶</a></li><li><a href="/blog/webassembly入门">webassembly入门</a></li><li><a aria-current="page" class="active" href="/blog/手把手带你写一个Web框架">手把手带你写一个Web框架</a></li><li><a href="/blog/web漏洞挖掘实战">web漏洞挖掘实战</a></li><li><a href="/blog/跟月影学可视化">跟月影学可视化</a></li><li><a href="/blog/搞定音频技术">搞定音频技术</a></li><li><a href="/blog/攻克视频技术">攻克视频技术</a></li></ul></li><li>前端工程化<ul><li><a href="/blog/logger">logger</a></li><li><a href="/blog/webpack">webpack</a></li><li><a href="/blog/webpackChain">webpackChain</a></li></ul></li><li>前端性能优化<ul><li><a href="/blog/react性能调优">react性能调优</a></li></ul></li><li>软件测试<ul><li><a href="/blog/全链路压测实战30讲">全链路压测实战30讲</a></li><li><a href="/blog/性能测试实战30讲">性能测试实战30讲</a></li><li><a href="/blog/自动化测试高手课">自动化测试高手课</a></li><li><a href="/blog/软件测试52讲">软件测试52讲</a></li></ul></li><li>面试<ul><li><a href="/blog/面试现场">面试现场</a></li></ul></li><li>杂谈<ul><li><a href="/blog/超级访谈对话张雪峰">超级访谈对话张雪峰</a></li><li><a href="/blog/Git实战手册">Git实战手册</a></li><li><a href="/blog/NodeJS">NodeJS</a></li><li><a href="/blog/ReactJS">ReactJS</a></li><li><a href="/blog/UI设计">UI设计</a></li><li><a href="/blog/webpack4系列教程">webpack4系列教程</a></li><li><a href="/blog/前端知识体系">前端知识体系</a></li><li><a href="/blog/剑指offer刷题笔记">剑指offer刷题笔记</a></li><li><a href="/blog/思考与成长">思考与成长</a></li><li><a href="/blog/设计模式手册">设计模式手册</a></li></ul></li></ul><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "><button title="Dark theme" class="__dumi-default-dark-moon "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="3854" width="22" height="22"><path d="M991.816611 674.909091a69.166545 69.166545 0 0 0-51.665455-23.272727 70.795636 70.795636 0 0 0-27.438545 5.585454A415.674182 415.674182 0 0 1 754.993338 698.181818c-209.594182 0-393.472-184.785455-393.472-395.636363 0-52.363636 38.539636-119.621818 69.515637-173.614546 4.887273-8.610909 9.634909-16.756364 14.103272-24.901818A69.818182 69.818182 0 0 0 384.631156 0a70.842182 70.842182 0 0 0-27.438545 5.585455C161.678429 90.298182 14.362065 307.898182 14.362065 512c0 282.298182 238.824727 512 532.38691 512a522.286545 522.286545 0 0 0 453.957818-268.334545A69.818182 69.818182 0 0 0 991.816611 674.909091zM546.679156 954.181818c-248.785455 0-462.941091-192-462.941091-442.181818 0-186.647273 140.637091-372.829091 300.939637-442.181818-36.817455 65.629091-92.578909 151.970909-92.578909 232.727273 0 250.181818 214.109091 465.454545 462.917818 465.454545a488.331636 488.331636 0 0 0 185.181091-46.545455 453.003636 453.003636 0 0 1-393.565091 232.727273z m103.656728-669.323636l-14.266182 83.781818a34.909091 34.909091 0 0 0 50.362182 36.770909l74.775272-39.563636 74.752 39.563636a36.142545 36.142545 0 0 0 16.174546 3.956364 34.909091 34.909091 0 0 0 34.210909-40.727273l-14.289455-83.781818 60.509091-59.345455a35.025455 35.025455 0 0 0-19.223272-59.578182l-83.61891-12.101818-37.376-76.101818a34.56 34.56 0 0 0-62.254545 0l-37.376 76.101818-83.618909 12.101818a34.909091 34.909091 0 0 0-19.246546 59.578182z m70.423272-64.698182a34.280727 34.280727 0 0 0 26.135273-19.083636l14.312727-29.090909 14.336 29.090909a34.257455 34.257455 0 0 0 26.135273 19.083636l32.046546 4.887273-23.272728 22.574545a35.234909 35.234909 0 0 0-10.007272 30.952727l5.46909 32.116364-28.625454-15.127273a34.490182 34.490182 0 0 0-32.302546 0l-28.695272 15.127273 5.469091-32.116364a35.141818 35.141818 0 0 0-9.984-30.952727l-23.272728-22.574545z" p-id="3855"></path></svg></button><button title="Light theme" class="__dumi-default-dark-sun "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="4026" width="22" height="22"><path d="M915.2 476.16h-43.968c-24.704 0-44.736 16-44.736 35.84s20.032 35.904 44.736 35.904H915.2c24.768 0 44.8-16.064 44.8-35.904s-20.032-35.84-44.8-35.84zM512 265.6c-136.704 0-246.464 109.824-246.464 246.4 0 136.704 109.76 246.464 246.464 246.464S758.4 648.704 758.4 512c0-136.576-109.696-246.4-246.4-246.4z m0 425.6c-99.008 0-179.2-80.128-179.2-179.2 0-98.944 80.192-179.2 179.2-179.2S691.2 413.056 691.2 512c0 99.072-80.192 179.2-179.2 179.2zM197.44 512c0-19.84-19.136-35.84-43.904-35.84H108.8c-24.768 0-44.8 16-44.8 35.84s20.032 35.904 44.8 35.904h44.736c24.768 0 43.904-16.064 43.904-35.904zM512 198.464c19.776 0 35.84-20.032 35.84-44.8v-44.8C547.84 84.032 531.84 64 512 64s-35.904 20.032-35.904 44.8v44.8c0 24.768 16.128 44.864 35.904 44.864z m0 627.136c-19.776 0-35.904 20.032-35.904 44.8v44.736C476.096 940.032 492.16 960 512 960s35.84-20.032 35.84-44.8v-44.736c0-24.768-16.064-44.864-35.84-44.864z m329.92-592.832c17.472-17.536 20.288-43.072 6.4-57.024-14.016-14.016-39.488-11.2-57.024 6.336-4.736 4.864-26.496 26.496-31.36 31.36-17.472 17.472-20.288 43.008-6.336 57.024 13.952 14.016 39.488 11.2 57.024-6.336 4.8-4.864 26.496-26.56 31.296-31.36zM213.376 759.936c-4.864 4.8-26.56 26.624-31.36 31.36-17.472 17.472-20.288 42.944-6.4 56.96 14.016 13.952 39.552 11.2 57.024-6.336 4.8-4.736 26.56-26.496 31.36-31.36 17.472-17.472 20.288-43.008 6.336-56.96-14.016-13.952-39.552-11.072-56.96 6.336z m19.328-577.92c-17.536-17.536-43.008-20.352-57.024-6.336-14.08 14.016-11.136 39.488 6.336 57.024 4.864 4.864 26.496 26.56 31.36 31.424 17.536 17.408 43.008 20.288 56.96 6.336 14.016-14.016 11.264-39.488-6.336-57.024-4.736-4.864-26.496-26.56-31.296-31.424z m527.168 628.608c4.864 4.864 26.624 26.624 31.36 31.424 17.536 17.408 43.072 20.224 57.088 6.336 13.952-14.016 11.072-39.552-6.4-57.024-4.864-4.8-26.56-26.496-31.36-31.36-17.472-17.408-43.072-20.288-57.024-6.336-13.952 14.016-11.008 39.488 6.336 56.96z" p-id="4027"></path></svg></button><button title="Default to system" class="__dumi-default-dark-auto "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="11002" width="22" height="22"><path d="M127.658667 492.885333c0-51.882667 10.24-101.717333 30.378666-149.162666s47.786667-88.064 81.92-122.538667 75.093333-61.781333 122.538667-81.92 96.938667-30.378667 149.162667-30.378667 101.717333 10.24 149.162666 30.378667 88.405333 47.786667 122.88 81.92 61.781333 75.093333 81.92 122.538667 30.378667 96.938667 30.378667 149.162666-10.24 101.717333-30.378667 149.162667-47.786667 88.405333-81.92 122.88-75.093333 61.781333-122.88 81.92-97.28 30.378667-149.162666 30.378667-101.717333-10.24-149.162667-30.378667-88.064-47.786667-122.538667-81.92-61.781333-75.093333-81.92-122.88-30.378667-96.938667-30.378666-149.162667z m329.045333 0c0 130.048 13.994667 244.394667 41.984 343.381334h12.970667c46.762667 0 91.136-9.216 133.461333-27.306667s78.848-42.666667 109.568-73.386667 54.954667-67.242667 73.386667-109.568 27.306667-86.698667 27.306666-133.461333c0-46.421333-9.216-90.794667-27.306666-133.12s-42.666667-78.848-73.386667-109.568-67.242667-54.954667-109.568-73.386667-86.698667-27.306667-133.461333-27.306666h-11.605334c-28.672 123.562667-43.349333 237.909333-43.349333 343.722666z" p-id="11003"></path></svg></button></div></div></div><ul class="__dumi-default-menu-list"><li><a href="/blog/">大师兄 - 前端架构师</a></li></ul></div></div><ul role="slug-list" class="__dumi-default-layout-toc"><li title="页面和接口设计" data-depth="2"><a href="/blog/手把手带你写一个web框架/05.实战第4关实战使用/04#页面和接口设计"><span>页面和接口设计</span></a></li><li title="问题创建页" data-depth="3"><a href="/blog/手把手带你写一个web框架/05.实战第4关实战使用/04#问题创建页"><span>问题创建页</span></a></li><li title="问题列表页" data-depth="3"><a href="/blog/手把手带你写一个web框架/05.实战第4关实战使用/04#问题列表页"><span>问题列表页</span></a></li><li title="问题详情页" data-depth="3"><a href="/blog/手把手带你写一个web框架/05.实战第4关实战使用/04#问题详情页"><span>问题详情页</span></a></li><li title="问题更新页" data-depth="3"><a href="/blog/手把手带你写一个web框架/05.实战第4关实战使用/04#问题更新页"><span>问题更新页</span></a></li><li title="后端开发" data-depth="2"><a href="/blog/手把手带你写一个web框架/05.实战第4关实战使用/04#后端开发"><span>后端开发</span></a></li><li title="接口swagger化" data-depth="3"><a href="/blog/手把手带你写一个web框架/05.实战第4关实战使用/04#接口swagger化"><span>接口swagger化</span></a></li><li title="qa服务设计" data-depth="2"><a href="/blog/手把手带你写一个web框架/05.实战第4关实战使用/04#qa服务设计"><span>qa服务设计</span></a></li><li title="问题/回答模型" data-depth="3"><a href="/blog/手把手带你写一个web框架/05.实战第4关实战使用/04#问题回答模型"><span>问题/回答模型</span></a></li><li title="分页模型" data-depth="3"><a href="/blog/手把手带你写一个web框架/05.实战第4关实战使用/04#分页模型"><span>分页模型</span></a></li><li title="协议" data-depth="2"><a href="/blog/手把手带你写一个web框架/05.实战第4关实战使用/04#协议"><span>协议</span></a></li><li title="小结" data-depth="2"><a href="/blog/手把手带你写一个web框架/05.实战第4关实战使用/04#小结"><span>小结</span></a></li><li title="思考题" data-depth="3"><a href="/blog/手把手带你写一个web框架/05.实战第4关实战使用/04#思考题"><span>思考题</span></a></li></ul><div class="__dumi-default-layout-content"><div class="markdown"><h1 id="33业务开发上问答业务开发"><a aria-hidden="true" tabindex="-1" href="/blog/手把手带你写一个web框架/05.实战第4关实战使用/04#33业务开发上问答业务开发"><span class="icon icon-link"></span></a>33｜业务开发（上）：问答业务开发</h1><p>你好，我是轩脉刃。</p><p>上两节课我们开发了一个完整的用户模块的前后端，并且运用了hade框架的不少命令行工具和基础服务。这节课，我们继续开发这个类知乎问答网站的另外一个比较大的业务模块：问答业务模块。</p><p>关于问答业务模块的开发，整体的开发流程和基本的使用方式和用户模块其实差不多，说到底这两个模块都是操作数据库中对应的数据表，我们同样使用先分析需求，再实现后端接口，最后是实现前端接口的流程。</p><p>问答模块，包含问题表、回答表和之前的用户表，这三个表之间有一些关联关系，在GORM中，如何使用这些关联关系建模，并且封装问答服务，接着对这些问答服务的方法提供足够的测试，是我们今天的解说重点。</p><h2 id="页面和接口设计"><a aria-hidden="true" tabindex="-1" href="/blog/手把手带你写一个web框架/05.实战第4关实战使用/04#页面和接口设计"><span class="icon icon-link"></span></a>页面和接口设计</h2><p>还是先梳理一下问答模块页面，它包含四个页面：<strong>问题创建页、问题列表页、问题详情页、问题更新页</strong>。名称都很清晰，在问题更新页中，我们可以对某个问题进行更新修改。不过我们暂时不提供回答的修改功能，只提供回答的创建和删除功能。</p><h3 id="问题创建页"><a aria-hidden="true" tabindex="-1" href="/blog/手把手带你写一个web框架/05.实战第4关实战使用/04#问题创建页"><span class="icon icon-link"></span></a>问题创建页</h3><p>在这个页面中，用户可以提出一个问题。提出问题的时候，让用户输入问题的标题和内容。通过点击提交，这个问题就提交进入数据库，并且在列表页面展示了。</p><p><img src="https://static001.geekbang.org/resource/image/ee/cc/eefc121a3a73216454cb31b462f2bacc.png?wh=853x780" alt="图片"/></p><p>问题创建页明显就只会和后端有一个接口的交互，问题创建接口 /question/create。它是POST请求，请求参数包括问题标题 title和问题内容 context。我们用一个结构来表示这个接口的请求内容：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">type questionCreateParam struct {</span></div><div class="token-line"><span class="token plain">       Title   string `json:&quot;title&quot; binding:&quot;required&quot;`</span></div><div class="token-line"><span class="token plain">       Content string `json:&quot;content&quot; binding:&quot;required&quot;`</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>返回值为问题是否创建成功的字符串说明：“操作成功”。</p><h3 id="问题列表页"><a aria-hidden="true" tabindex="-1" href="/blog/手把手带你写一个web框架/05.实战第4关实战使用/04#问题列表页"><span class="icon icon-link"></span></a>问题列表页</h3><p>在列表页面中，我们按照创建时间顺序展示问题列表。列表页中的每一项都代表一个问题，展示的时候列出问题的标题、问题的内容（只显示200个字）、问题的创建时间、问题的创建者，以及问题的回答数。</p><p><img src="https://static001.geekbang.org/resource/image/1a/59/1a83f05477538yy52yy171aa6b657e59.png?wh=1062x1240" alt="图片"/></p><p>考虑到当问题数比较多的时候，一个页面展示不下，我们为列表页设计一个分页逻辑，当页面下拉到底部的时候，会有“加载中”的字样去后端获取更多的列表信息。</p><p><img src="https://static001.geekbang.org/resource/image/21/3c/211596ccc4e13b50e9f4128a47fc1d3c.png?wh=889x715" alt="图片"/></p><p>所以问题列表页的接口也比较简单。我们可以把这个页面开始的获取问题列表，和“加载中”功能的接口，设计为同一个：问题列表接口 /question/list。这个接口请求方法为GET，参数需要设计两个，一个参数start表示要从第几个问题开始加载，而另外一个参数size表示请求的问题个数。</p><p>对于页面初始化的问题列表，start为0，size为10，表示页面初始化，我们向后端获取10个问题；而对于后面的“加载中”的功能，我们的start为当前页面已经展示的问题数量，size同样为10，表示再加载10个问题，增加到问题列表页中。</p><p>然后这个接口最终返回的是一个问题数组，包含问题的标题、问题的内容、问题创建时间、问题创建用户，以及问题的回答数。</p><h3 id="问题详情页"><a aria-hidden="true" tabindex="-1" href="/blog/手把手带你写一个web框架/05.实战第4关实战使用/04#问题详情页"><span class="icon icon-link"></span></a>问题详情页</h3><p>到达列表页之后，用户会进入问题详情页查看某个具体的问题，但是这个页面承载的功能远不止查看问题详情这么简单。</p><p>首先因为列表页只显示200字，这个页面要能展示问题详情。用户要能回答这个问题，那么这个页面的最下方还要有用户回答框，如果查看人想对某个问题进行回答，可以输入回答内容进行提交。所以也需要展示这个问题的所有回答列表。</p><p>有了问题和回答的新增，我们当然要考虑删除。这个页面展示的问题如果是查看人创建的，查看人可以操作将这个问题进行删除。同时，如果回答列表中展示的某个回答是查看人创建的，查看人有权限将这个回答进行删除。</p><p><img src="https://static001.geekbang.org/resource/image/33/2a/3374420cc6df2ccd00ee754f5fe30d2a.png?wh=869x919" alt="图片"/></p><p>所以问题详情页的接口就比较多了，有4个接口。</p><ul><li>问题详情接口 /question/detail</li></ul><p>查看某个问题详情，并且在这个问题详情中，同时带有这个问题的所有回答，按照回答的创建时间倒序排列。</p><p>这个接口为GET请求，它的参数为一个id，表示问题的ID。返回值是问题详情，这个问题详情基本上和问题列表页中的问题是一个模型，但是还要带有一个回答列表信息，把这个问题的所有回答都返回。</p><ul><li>回答创建接口 /answer/create</li></ul><p>这个接口的功能是创建一个回答，它是POST请求，参数有两个：question_id，代表回答对应的问题ID；content，代表回答的具体内容。我们用一个数据结构来代表这个接口的参数：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">type answerCreateParam struct {</span></div><div class="token-line"><span class="token plain">       QuestionID int64  `json:&quot;question_id&quot; binding:&quot;required&quot;`</span></div><div class="token-line"><span class="token plain">       Content    string `json:&quot;content&quot; binding:&quot;required&quot;`</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>接口的返回值是操作成功或者失败的信息。</p><ul><li>回答删除接口 /answer/delete</li></ul><p>这个接口功能是删除某个回答，它是GET请求，参数为id，表示回答的具体ID。当然在接口的后端逻辑中，我们必须判断这个回答是否是查看人所创建的，如果不是的话，这个接口是不允许进行操作的。接口的返回值就返回操作成功或者失败的信息即可。</p><ul><li>问题删除接口 /question/delete</li></ul><p>这个接口功能是删除某个问题，它是GET请求，参数为id，表示问题的具体ID，和回答的删除接口一个操作。</p><h3 id="问题更新页"><a aria-hidden="true" tabindex="-1" href="/blog/手把手带你写一个web框架/05.实战第4关实战使用/04#问题更新页"><span class="icon icon-link"></span></a>问题更新页</h3><p>在这个页面中，用户可以对某个自己提出的问题的内容进行修改。这个页面和问题创建页有类似的页面布局，不同的是进入的时候，问题标题和内容都是有具体内容的。</p><p><img src="https://static001.geekbang.org/resource/image/17/31/17a7595880f3f688e37c22b380209131.png?wh=864x776" alt="图片"/></p><p>问题更新页接口就一个，负责完成更新某个问题的功能。更新问题接口 /question/edit，我们允许更新问题的标题和内容，所以这个接口参数有三个：问题ID，表示更新的哪个问题；标题title，表示更新的问题标题；内容content，表示要更新的问题内容。我们定义一个数据结构来表示这个接口的参数：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">type questionEditParam struct {</span></div><div class="token-line"><span class="token plain">       ID      int64  `json:&quot;id&quot; binding:&quot;required&quot;`</span></div><div class="token-line"><span class="token plain">       Title   string `json:&quot;title&quot; binding:&quot;required&quot;`</span></div><div class="token-line"><span class="token plain">       Content string `json:&quot;content&quot; binding:&quot;required&quot;`</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>返回值是操作成功或者失败的消息。</p><p>好最后我们梳理一下，关于问答模块，一共要开发七个接口。</p><ul><li>问题创建接口 /question/create</li><li>问题列表接口 /question/list</li><li>问题详情接口 /question/detail</li><li>问题删除接口 /question/delete</li><li>更新问题接口 /question/edit</li><li>回答创建接口 /answer/create</li><li>回答删除接口 /answer/delete</li></ul><h2 id="后端开发"><a aria-hidden="true" tabindex="-1" href="/blog/手把手带你写一个web框架/05.实战第4关实战使用/04#后端开发"><span class="icon icon-link"></span></a>后端开发</h2><p>接口定义好，下面就是后端开发了。还记得开发用户模块的时候说过的后端开发四个步骤吗，接口swagger化、定义用户服务协议、开发模块接口、实现用户服务协议，这四个步骤具体负责的内容就不赘述了。今天qa模块的开发，我们仍然沿用这四个步骤。</p><h3 id="接口swagger化"><a aria-hidden="true" tabindex="-1" href="/blog/手把手带你写一个web框架/05.实战第4关实战使用/04#接口swagger化"><span class="icon icon-link"></span></a>接口swagger化</h3><p>首先使用注释将前面定义的七个接口的说明、参数、返回值全部swagger化。</p><p>因为问题列表页面和问题详情页面，都会使用到输出“问题”和“回答”这两种结构，还记得第31章我们讨论的模型设计吗，DTO层模型负责前端和后端接口的数据传输，定义了这个DTO层的模型，前端和后端的同学就能依照这个模型来并行开发了。所以我们设计DTO层的模型。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// QuestionDTO 问题列表返回结构</span></div><div class="token-line"><span class="token plain">    type QuestionDTO struct {</span></div><div class="token-line"><span class="token plain">       ID        int64     `json:&quot;id,omitempty&quot;`</span></div><div class="token-line"><span class="token plain">       Title     string    `json:&quot;title,omitempty&quot;`</span></div><div class="token-line"><span class="token plain">       Context   string    `json:&quot;context,omitempty&quot;` // 在列表页，只显示前200个字符</span></div><div class="token-line"><span class="token plain">       AnswerNum int       `json:&quot;answer_num&quot;`</span></div><div class="token-line"><span class="token plain">       CreatedAt time.Time `json:&quot;created_at&quot;`</span></div><div class="token-line"><span class="token plain">       UpdatedAt time.Time `json:&quot;updated_at&quot;`</span></div><div class="token-line"><span class="token plain">       Author  *user.UserDTO `json:&quot;author,omitempty&quot;`  // 作者</span></div><div class="token-line"><span class="token plain">       Answers []*AnswerDTO  `json:&quot;answers,omitempty&quot;` // 回答</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    // AnswerDTO 回答返回结构</span></div><div class="token-line"><span class="token plain">    type AnswerDTO struct {</span></div><div class="token-line"><span class="token plain">       ID        int64     `json:&quot;id,omitempty&quot;`</span></div><div class="token-line"><span class="token plain">       Content   string    `json:&quot;content,omitempty&quot;`</span></div><div class="token-line"><span class="token plain">       CreatedAt time.Time `json:&quot;created_at&quot;`</span></div><div class="token-line"><span class="token plain">       UpdatedAt time.Time `json:&quot;updated_at&quot;`</span></div><div class="token-line"><span class="token plain">       Author *user.UserDTO `json:&quot;author,omitempty&quot;` // 作者</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>我们可以看到，在DTO层，各个DTO是有关联的，QuestionDTO关联了UserDTO和AnswerDTO，而AnswerDTO 关联了UserDTO。<strong>这样关联其实是非常合理的。后续我们输出给前端的数据模型就固定了</strong>，比如要输出用户，前端就知道我们一定会输出一个UserDTO的数据模型，能减少前后端的沟通障碍。</p><p>然后编写接口方法并注册到路由中：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// RegisterRoutes 注册路由</span></div><div class="token-line"><span class="token plain">    func RegisterRoutes(r *gin.Engine) error {</span></div><div class="token-line"><span class="token plain">       api := &amp;QAApi{}</span></div><div class="token-line"><span class="token plain">       if !r.IsBind(qa.QaKey) {</span></div><div class="token-line"><span class="token plain">          r.Bind(&amp;qa.QaProvider{})</span></div><div class="token-line"><span class="token plain">       }</span></div><div class="token-line"><span class="token plain">       questionApi := r.Group(&quot;/question&quot;, auth.AuthMiddleware())</span></div><div class="token-line"><span class="token plain">       {</span></div><div class="token-line"><span class="token plain">          // 问题列表</span></div><div class="token-line"><span class="token plain">          questionApi.GET(&quot;/list&quot;, api.QuestionList)</span></div><div class="token-line"><span class="token plain">          // 问题详情</span></div><div class="token-line"><span class="token plain">          questionApi.GET(&quot;/detail&quot;, api.QuestionDetail)</span></div><div class="token-line"><span class="token plain">          // 创建问题</span></div><div class="token-line"><span class="token plain">          questionApi.POST(&quot;/create&quot;, api.QuestionCreate)</span></div><div class="token-line"><span class="token plain">          // 删除问题</span></div><div class="token-line"><span class="token plain">          questionApi.POST(&quot;/delete&quot;, api.QuestionDelete)</span></div><div class="token-line"><span class="token plain">          // 更新问题</span></div><div class="token-line"><span class="token plain">          questionApi.POST(&quot;/edit&quot;, api.QuestionEdit)</span></div><div class="token-line"><span class="token plain">       }</span></div><div class="token-line"><span class="token plain">       answerApi := r.Group(&quot;/answer&quot;, auth.AuthMiddleware())</span></div><div class="token-line"><span class="token plain">       {</span></div><div class="token-line"><span class="token plain">          // 创建回答</span></div><div class="token-line"><span class="token plain">          answerApi.POST(&quot;/create&quot;, api.AnswerCreate)</span></div><div class="token-line"><span class="token plain">          // 删除回答</span></div><div class="token-line"><span class="token plain">          answerApi.POST(&quot;/delete&quot;, api.AnswerDelete)</span></div><div class="token-line"><span class="token plain">       }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">       return nil</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>最后按照swaggo的方式来编写swagger的注释，以获取问题详情的接口为例：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// QuestionDetail 获取问题详情</span></div><div class="token-line"><span class="token plain">    // @Summary 获取问题详细</span></div><div class="token-line"><span class="token plain">    // @Description 获取问题详情，包括问题的所有回答</span></div><div class="token-line"><span class="token plain">    // @Accept  json</span></div><div class="token-line"><span class="token plain">    // @Produce  json</span></div><div class="token-line"><span class="token plain">    // @Tags qa</span></div><div class="token-line"><span class="token plain">    // @Param id query int true &quot;问题id&quot;</span></div><div class="token-line"><span class="token plain">    // @Success 200 QuestionDTO question &quot;问题详情，带回答和作者&quot;</span></div><div class="token-line"><span class="token plain">    // @Router /question/detail [get]</span></div><div class="token-line"><span class="token plain">    func (api *QAApi) QuestionDetail(c *gin.Context) {</span></div><div class="token-line"><span class="token plain">        ...</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>最后我们使用 <code>./bbs swagger gen</code> 生成swagger文件，并且编译 <code>./bbs build self</code> ，编译进入 bbs 文件，最后再使用 <code>./bbs dev backend</code> 展示swagger-UI界面如图：<br/><img src="https://static001.geekbang.org/resource/image/4e/39/4e5743b52483ab31e75481d818b05739.png?wh=1920x638" alt="图片"/></p><h2 id="qa服务设计"><a aria-hidden="true" tabindex="-1" href="/blog/手把手带你写一个web框架/05.实战第4关实战使用/04#qa服务设计"><span class="icon icon-link"></span></a>qa服务设计</h2><p>接口swagger化之后，接下来就要设计qa服务了。关于qa服务，我们同样先处理模型，将DO层模型和PO层模型合并，统一使用一个数据模型来定义。</p><h3 id="问题回答模型"><a aria-hidden="true" tabindex="-1" href="/blog/手把手带你写一个web框架/05.实战第4关实战使用/04#问题回答模型"><span class="icon icon-link"></span></a>问题/回答模型</h3><p>代表问题的模型Question 和代表回答的模型Answer。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// Question 代表问题</span></div><div class="token-line"><span class="token plain">    type Question struct {</span></div><div class="token-line"><span class="token plain">       ID        int64          `gorm:&quot;column:id;primaryKey&quot;`</span></div><div class="token-line"><span class="token plain">       Title     string         `gorm:&quot;column:title;comment:标题&quot;`</span></div><div class="token-line"><span class="token plain">       Context   string         `gorm:&quot;column:context;comment:内容&quot;`</span></div><div class="token-line"><span class="token plain">       AuthorID  int64          `gorm:&quot;column:author_id;comment:作者id;not null;default:0&quot;`</span></div><div class="token-line"><span class="token plain">       AnswerNum int            `gorm:&quot;column:answer_num;comment:回答数;not null;default:0&quot;`</span></div><div class="token-line"><span class="token plain">       CreatedAt time.Time      `gorm:&quot;column:created_at;autoCreateTime;comment:创建时间&quot;`</span></div><div class="token-line"><span class="token plain">       UpdatedAt time.Time      `gorm:&quot;column:updated_at;autoUpdateTime;&lt;-:false;comment:更新时间&quot;`</span></div><div class="token-line"><span class="token plain">       DeletedAt gorm.DeletedAt `gorm:&quot;index&quot;`</span></div><div class="token-line"><span class="token plain">       Author    *user.User     `gorm:&quot;foreignKey:AuthorID&quot;`</span></div><div class="token-line"><span class="token plain">       Answers   []*Answer      `gorm:&quot;foreignKey:QuestionID&quot;`</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    // Answer 代表一个回答</span></div><div class="token-line"><span class="token plain">    type Answer struct {</span></div><div class="token-line"><span class="token plain">       ID         int64          `gorm:&quot;column:id;primaryKey&quot;`</span></div><div class="token-line"><span class="token plain">       QuestionID int64          `gorm:&quot;column:question_id;index;comment:问题id;not null;default 0&quot;`</span></div><div class="token-line"><span class="token plain">       Content    string         `gorm:&quot;column:context;comment:内容&quot;`</span></div><div class="token-line"><span class="token plain">       AuthorID   int64          `gorm:&quot;column:author_id;comment:作者id;not null;default:0&quot;`</span></div><div class="token-line"><span class="token plain">       CreatedAt  time.Time      `gorm:&quot;column:created_at;autoCreateTime;comment:创建时间&quot;`</span></div><div class="token-line"><span class="token plain">       UpdatedAt  time.Time      `gorm:&quot;column:updated_at;autoUpdateTime;&lt;-:false;comment:更新时间&quot;`</span></div><div class="token-line"><span class="token plain">       DeletedAt  gorm.DeletedAt `gorm:&quot;index&quot;`</span></div><div class="token-line"><span class="token plain">       Author     *user.User     `gorm:&quot;foreignKey:AuthorID&quot;`</span></div><div class="token-line"><span class="token plain">       Question   *Question      `gorm:&quot;foreignKey:QuestionID&quot;`</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>你可以看到，我们使用了非常丰富的Gorm的tag标签。在Gorm的使用中，一个必须要掌握的就是tag标签的运用，<strong>你的tag标签使用的好，就能节省很多代码量</strong>。这是今天的重点，我们来详细说明一下。</p><ul><li>index</li></ul><p>在我们的数据表中，除了主键索引之外，很有可能需要建立其他某个字段的索引，比如回答模型一定少不了根据问题ID查询出所有的回答。那么我们需要针对问题ID，在回答表中建立一个索引，就可以使用 index 的标签来表示这个索引。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">QuestionID int64          `gorm:&quot;column:question_id;index;comment:问题id;not null;default 0&quot;`</span></div></pre></div><ul><li>not null 和 default</li></ul><p>还有一个细节，数据库中每个字段默认都是允许为null的，但是我们在获取数据的时候，并不希望这个数据会为null，比如问题表中的回答数字段，我们希望它不为空，默认为0，就可以使用 not null 和 default 两个标签来设置。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">AnswerNum int            `gorm:&quot;column:answer_num;comment:回答数;not null;default:0&quot;`</span></div></pre></div><ul><li>time</li></ul><p>另外，问题表和回答表都有创建时间和更新时间，其中，创建时间我们希望在使用创建数据的方法Create时自动填充，而更新时间也希望能在更新时自动填充。一方面，这样服务调用者就能少顾虑到一些“时间”方面的逻辑，另一方面，这种“时间”的管理，我们封闭在服务内部，如果调用者逻辑错误，也不会导致这两个时间是有问题的。</p><p>所以我们使用autoCreateTime、autoUpdateTime、&lt;-:false 分别表示创建数据自动更新时间、更新数据自动更新时间、禁止写入。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">CreatedAt  time.Time      `gorm:&quot;column:created_at;autoCreateTime;comment:创建时间&quot;`</span></div><div class="token-line"><span class="token plain">    UpdatedAt  time.Time      `gorm:&quot;column:updated_at;autoUpdateTime;&lt;-:false;comment:更新时间&quot;`</span></div></pre></div><ul><li>DeletedAt</li></ul><p>问题和回答的数据一定存在需要删除的行为，但是删除时，我们又不希望真正删除数据，<strong>而是希望采用软删除的方式，也就是为数据某个字段打一个标记来标记删除</strong>。</p><p>这种软删除的方式在实际业务中是有可能有需求的，比如有的问题和回答是先审批再展示出来的，我们可以先标记为软删除，审批完成之后再放出来；或者用户或者运营同学点击了删除某个问题，但是属于误操作，软删除就为恢复数据提供了可能性。</p><p>Gorm提供了 gorm.DeletedAt 的字段类型来表示这个软删除的逻辑，所以在问题表和回答表中我们加上这个DeletedAt字段来标记；同时由于这个字段用来标记是否删除，所以我们在查询的时候一定会经常使用到这个字段进行索引，对这个字段使用index的标签来创建一个索引也是非常必要的。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">DeletedAt  gorm.DeletedAt `gorm:&quot;index&quot;`</span></div></pre></div><ul><li>foreignKey</li></ul><p>最后，对于ORM来说，问题对象和回答对象其实是一对多的关系，它们之间其实是有外键关联的，回答对象中的QuestionID和问题对象的ID字段是关联的。</p><p>我们可以为回答表创建一个外键：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">type Answer struct {</span></div><div class="token-line"><span class="token plain">      ...</span></div><div class="token-line"><span class="token plain">      QuestionID int64          `gorm:&quot;column:question_id;index;comment:问题id;not null;default 0&quot;`</span></div><div class="token-line"><span class="token plain">      Question   *Question      `gorm:&quot;foreignKey:QuestionID&quot;`</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>Answer结构和Question结构是“属于关系”（<a target="_blank" rel="noopener noreferrer" href="https://gorm.io/zh_CN/docs/belongs_to.html">Belongs To<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>），一个回答属于一个问题，所以这里的Question结构，它使用了一个外键，告诉DB，Answer结构中的QuestionID字段，是我的属主的主键，根据QuestionID字段去查找Question结构。</p><p>同时相对应的，我们为问题表创建一个回答表的数组：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">type Question struct {</span></div><div class="token-line"><span class="token plain">       ...</span></div><div class="token-line"><span class="token plain">       Answers   []*Answer      `gorm:&quot;foreignKey:QuestionID&quot;`</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>相反的，Question结构和Answer结构就属于“包含许多”（<a target="_blank" rel="noopener noreferrer" href="https://gorm.io/zh_CN/docs/has_many.html">Has Many<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>）, 一个问题包含许多个回答，它这里的外键tag标记为QuestionID，表示，我这个问题的回答有很多，它们为Answer结构中QuestionID为主键的数据。</p><p>BelongsTo、 HasMany，是Gorm中的关联逻辑，更多的解释和查看用法可以参考官网的<a target="_blank" rel="noopener noreferrer" href="https://gorm.io/zh_CN/docs/belongs_to.html">关联<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>部分的说明。</p><p><strong>ORM做这个外键约束有什么好处呢？它能让Gorm提供的“<a target="_blank" rel="noopener noreferrer" href="https://gorm.io/zh_CN/docs/preload.html">预加载<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>”功能成为可能</strong>。这个预加载的功能在实际开发过程中是非常好用的。比如现在有多个问题的数组对象questions，想要获取每一个问题的所有回答，原本我们是需要自己再手写一个ORM的SQL查询来获取。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">questionIds := []int64{}</span></div><div class="token-line"><span class="token plain">    for _, question := range questions {</span></div><div class="token-line"><span class="token plain">      questionIds := append(questionIds, question.ID)</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    db.Where(map[string]interface{}{&quot;question_id&quot;, questionIds}).Find(&amp;answers)</span></div></pre></div><p>但是一旦有了外键约束，我们就可以使用预加载的功能，一行代码直接将这些问题数组对应的回答获取回来了：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">db.Preload(&quot;Answers&quot;).Find(questions)</span></div></pre></div><p>这样在获取的questions中，每个问题对象的Answers字段都带有一个回答数组了，非常方便。</p><h3 id="分页模型"><a aria-hidden="true" tabindex="-1" href="/blog/手把手带你写一个web框架/05.实战第4关实战使用/04#分页模型"><span class="icon icon-link"></span></a>分页模型</h3><p>除了问题和回答两个模型，在问题列表页还会根据分页信息来获取每一页的问题列表。所以我们还需要一个分页模型Pager，包含起始位置Start、获取的数据个数Size，还有一个Total代表一共有多少数据。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// Pager 代表分页机制</span></div><div class="token-line"><span class="token plain">    type Pager struct {</span></div><div class="token-line"><span class="token plain">       Total int64 // 共有多少数据，只有返回值使用</span></div><div class="token-line"><span class="token plain">       Start int   // 起始位置</span></div><div class="token-line"><span class="token plain">       Size  int   // 获取的数据个数</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><h2 id="协议"><a aria-hidden="true" tabindex="-1" href="/blog/手把手带你写一个web框架/05.实战第4关实战使用/04#协议"><span class="icon icon-link"></span></a>协议</h2><p>模型定义完成，下面我们就要来定义服务对外提供的协议接口了。qa服务虽然接口比较多，但是它的接口逻辑却并不复杂，基本上都围绕问题、回答两个模型的增删改查进行，也就是说，我们qa服务对外提供的协议，基本上也就是围绕这两个对象的增删改查进行的。</p><p>首先围绕问题这个模型。</p><p>需要创建问题的接口PostQuestion，直接把Question模型作为参数即可。创建完问题，我们需要获取问题，那么就要有GetQuestion接口，同时也需要有批量获取Question的接口GetQuestions。创建问题结束，我们可能要修改问题，那么可以有一个修改问题的接口UpdateQuestion。最后就是删除问题接口DeleteQuestion。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// Service 代表qa的服务</span></div><div class="token-line"><span class="token plain">    type Service interface {</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">       // GetQuestions 获取问题列表，question简化结构</span></div><div class="token-line"><span class="token plain">       GetQuestions(ctx context.Context, pager *Pager) ([]*Question, error)</span></div><div class="token-line"><span class="token plain">       </span></div><div class="token-line"><span class="token plain">       // GetQuestion 获取某个问题详情，question简化结构</span></div><div class="token-line"><span class="token plain">       GetQuestion(ctx context.Context, questionID int64) (*Question, error)</span></div><div class="token-line"><span class="token plain">       </span></div><div class="token-line"><span class="token plain">       // PostQuestion 上传某个问题</span></div><div class="token-line"><span class="token plain">       // ctx必须带操作人id</span></div><div class="token-line"><span class="token plain">       PostQuestion(ctx context.Context, question *Question) error</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">       // DeleteQuestion 删除问题，同时删除对应的回答</span></div><div class="token-line"><span class="token plain">       // ctx必须带操作人信息</span></div><div class="token-line"><span class="token plain">       DeleteQuestion(ctx context.Context, questionID int64) error</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">       // UpdateQuestion 代表更新问题, 只会对比其中的context，title两个字段，其他字段不会对比</span></div><div class="token-line"><span class="token plain">       // ctx必须带操作人</span></div><div class="token-line"><span class="token plain">       UpdateQuestion(ctx context.Context, question *Question) error</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>这里我们关注一下获取问题的两个接口，GetQuestion和GetQuestions，它们返回的是Question模型和Question模型数组。</p><p>但是有一点要注意，在前面，我们定义的Question模型是带有“外键”属性的，比如问题的作者Author、问题的回答Answer。<strong>这些属性，我们希望由上层业务“按需加载”</strong>。</p><p>也就是说在服务层，获取问题和获取问题列表默认是没有作者和回答的，如果上层业务需要的话，请重新调用接口来获取。所以这里我们多出了四个接口：单个问题加载作者、多个问题加载作者、单个问题加载回答、多个问题加载回答。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// Service 代表qa的服务</span></div><div class="token-line"><span class="token plain">    type Service interface {</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">       // QuestionLoadAuthor 问题加载Author字段</span></div><div class="token-line"><span class="token plain">       QuestionLoadAuthor(ctx context.Context, question *Question) error</span></div><div class="token-line"><span class="token plain">       </span></div><div class="token-line"><span class="token plain">       // QuestionsLoadAuthor 批量加载Author字段</span></div><div class="token-line"><span class="token plain">       QuestionsLoadAuthor(ctx context.Context, questions *[]*Question) error</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">       // QuestionLoadAnswers 单个问题加载Answers</span></div><div class="token-line"><span class="token plain">       QuestionLoadAnswers(ctx context.Context, question *Question) error</span></div><div class="token-line"><span class="token plain">       </span></div><div class="token-line"><span class="token plain">       // QuestionsLoadAnswers 批量问题加载Answers</span></div><div class="token-line"><span class="token plain">       QuestionsLoadAnswers(ctx context.Context, questions *[]*Question) error</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>在使用的时候注意一下，多个问题加载的方法中，第二个参数传递的是指向slice的指针 *[]*Question。因为我们在调用接口的时候，会重新修改这个指针指向的slice。修改的时候是有可能变更原先slice地址的，所以这里使用了“指向slice的指针”。</p><p>再看围绕“回答”这个模型。</p><p>我们一样需要有创建回答接口PostAnswer、删除回答接口DeleteAnswer、获取回答接口GetAnswer。由于产品设计上并不允许对回答进行修改，所以这里暂时不需要更新回答的接口。</p><p>同样我们也提供“回答”作者信息的按需加载，也就是单个回答的按需加载AnswerLoadAuthor和多个回答的按需加载AnswersLoadAuthor两个方法：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// Service 代表qa的服务</span></div><div class="token-line"><span class="token plain">    type Service interface {</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">       // PostAnswer 上传某个回答</span></div><div class="token-line"><span class="token plain">       // ctx必须带操作人信息</span></div><div class="token-line"><span class="token plain">       PostAnswer(ctx context.Context, answer *Answer) error</span></div><div class="token-line"><span class="token plain">       </span></div><div class="token-line"><span class="token plain">       // GetAnswer 获取回答</span></div><div class="token-line"><span class="token plain">       GetAnswer(ctx context.Context, answerID int64) (*Answer, error)</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">       // AnswerLoadAuthor 问题加载Author字段</span></div><div class="token-line"><span class="token plain">       AnswerLoadAuthor(ctx context.Context, question *Answer) error</span></div><div class="token-line"><span class="token plain">       // AnswersLoadAuthor 批量加载Author字段</span></div><div class="token-line"><span class="token plain">       AnswersLoadAuthor(ctx context.Context, questions *[]*Answer) error</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">       // DeleteAnswer 删除某个回答</span></div><div class="token-line"><span class="token plain">       // ctx必须带操作人信息</span></div><div class="token-line"><span class="token plain">       DeleteAnswer(ctx context.Context, answerID int64) error</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>好了，qa服务的后端服务协议我们就定义完成了，一共有14个协议接口，代表qa服务对外提供的14种能力。所有代码都存放到 GitHub上的<a target="_blank" rel="noopener noreferrer" href="https://github.com/gohade/bbs/tree/geekbang/33">geekbang/33<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 上了。对应的文档截图也放在这里，欢迎对比查看。</p><p><img src="https://static001.geekbang.org/resource/image/23/8b/23aac201f21227bc8ab1833ae5605e8b.png?wh=734x1414" alt="图片"/></p><h2 id="小结"><a aria-hidden="true" tabindex="-1" href="/blog/手把手带你写一个web框架/05.实战第4关实战使用/04#小结"><span class="icon icon-link"></span></a>小结</h2><p>今天我们主要定义了问答服务的两个协议，一个是前端和后端的协议接口，将接口的输出、输入以swagger-UI的形式表现，另外一个是后端问答服务的协议，一共14个接口。</p><p>除了让你再熟悉一遍后端开发模块的四步骤之外，通过今天的实战，希望你能熟练掌握Gorm的模型定义，Gorm的tag是个非常强大的存在，定义好了这个tag，才能真正将之前我们引入ORM的利益最大化，这一点在下节课实现qa服务协议的时候也会领略到。</p><h3 id="思考题"><a aria-hidden="true" tabindex="-1" href="/blog/手把手带你写一个web框架/05.实战第4关实战使用/04#思考题"><span class="icon icon-link"></span></a>思考题</h3><p>定义好Gorm模型的tag，不仅仅能节省我们操作数据库的逻辑，还能根据ORM创建数据表，这里需要用到Gorm中提供的<a target="_blank" rel="noopener noreferrer" href="https://gorm.io/zh_CN/docs/migration.html">Auto Migrations<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>功能。实际上，我在单元测试的时候，往测试数据库中创建表就是使用这个功能，你不妨尝试根据这节课定义的Question和Answer，往自己的测试数据库中创建两张表questions和answers。</p><p>欢迎在留言区分享你的学习笔记。感谢你的收听，如果你觉得今天的内容对你有所帮助，也欢迎分享给你身边的朋友，邀请他一起学习。我们下节课实战继续。</p></div><div class="__dumi-default-layout-footer-meta"><a target="_blank" rel="noopener noreferrer" href="https://github.com/GGwujun/blog/edit/master/docs/手把手带你写一个Web框架/05.实战第4关实战使用/04.md">在 GitHub 上编辑此页<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a><span data-updated-text="最后更新时间：">5/2/2022 10:56:59</span></div></div></div></div>
	<script>
  window.g_useSSR = true;
  window.g_initialProps = {};
	</script>

    <script>
      (function () {
        if (!location.port) {
          (function (i, s, o, g, r, a, m) {
            i["GoogleAnalyticsObject"] = r;
            (i[r] =
              i[r] ||
              function () {
                (i[r].q = i[r].q || []).push(arguments);
              }),
              (i[r].l = 1 * new Date());
            (a = s.createElement(o)), (m = s.getElementsByTagName(o)[0]);
            a.async = 1;
            a.src = g;
            m.parentNode.insertBefore(a, m);
          })(
            window,
            document,
            "script",
            "//www.google-analytics.com/analytics.js",
            "ga"
          );
          ga("create", "UA-149864185-1", "auto");
          ga("send", "pageview");
        }
      })();
    </script>
    <script src="/blog/umi.js"></script>
  </body>
</html>
