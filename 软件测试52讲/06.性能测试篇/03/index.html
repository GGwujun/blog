<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no"
    />
    <link rel="shortcut icon" type="image/x-icon" href="/logo.png" />
    <link rel="stylesheet" href="/blog/umi.css" />
    <script>
      window.routerBase = "/blog";
    </script>
    <script>
      //! umi version: 3.5.17
    </script>
    <script>
      !(function () {
        var e = localStorage.getItem("dumi:prefers-color"),
          t = window.matchMedia("(prefers-color-scheme: dark)").matches,
          r = ["light", "dark", "auto"];
        document.documentElement.setAttribute(
          "data-prefers-color",
          e === r[2] ? (t ? r[1] : r[0]) : r.indexOf(e) > -1 ? e : r[0]
        );
      })();
    </script>
    <title>
      30 | 工欲善其事必先利其器：后端性能测试工具原理与行业常用工具简介
    </title>
  </head>
  <body>
    <div id="root"><div class="__dumi-default-layout" data-route="/软件测试52讲/06.性能测试篇/03" data-show-sidemenu="true" data-show-slugs="true" data-site-mode="true" data-gapless="false"><div class="__dumi-default-navbar" data-mode="site"><button class="__dumi-default-navbar-toggle"></button><a class="__dumi-default-navbar-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog/">大师兄</a><nav><div class="__dumi-default-search"><input type="search" class="__dumi-default-search-input" value=""/><ul></ul></div><span>计算机基础<ul><li><a href="/blog/编译原理之美">编译原理之美</a></li><li><a href="/blog/编译原理实战">编译原理实战</a></li><li><a href="/blog/深入浅出计算机组成原理">深入浅出计算机组成原理</a></li><li><a href="/blog/详解http">详解http</a></li><li><a href="/blog/计算机网络通关29讲">计算机网络通关29讲</a></li><li><a href="/blog/网络排查案例课">网络排查案例课</a></li><li><a href="/blog/linux操作系统">linux操作系统</a></li><li><a href="/blog/linux性能优化实战">linux性能优化实战</a></li><li><a href="/blog/程序员数学基础">程序员数学基础</a></li><li><a href="/blog/趣谈网络协议">趣谈网络协议</a></li><li><a href="/blog/操作系统实战">操作系统实战</a></li><li><a href="/blog/软件工程之美">软件工程之美</a></li><li><a href="/blog/sql必知必会">sql必知必会</a></li><li><a href="/blog/操作系统实战45讲">操作系统实战45讲</a></li><li><a href="/blog/网络编程实战">网络编程实战</a></li></ul></span><span>算法<ul><li><a href="/blog/常用算法25讲">常用算法25讲</a></li><li><a href="/blog/数据结构与算法之美">数据结构与算法之美</a></li><li><a href="/blog/业务开发算法50讲">业务开发算法50讲</a></li><li><a href="/blog/动态规划面试宝典">动态规划面试宝典</a></li></ul></span><span>前端开发<ul><li><a href="/blog/浏览器工作原理与实践">浏览器工作原理与实践</a></li><li><a href="/blog/新时代产品经理进阶之路">新时代产品经理进阶之路</a></li><li><a href="/blog/全栈工程师修炼指南">全栈工程师修炼指南</a></li><li><a href="/blog/flutter核心技术与实战">flutter核心技术与实战</a></li><li><a href="/blog/java-script核心原理解析">java-script核心原理解析</a></li><li><a href="/blog/说透低代码">说透低代码</a></li><li><a href="/blog/nodejs应用开发实战">nodejs应用开发实战</a></li><li><a href="/blog/反爬虫兵法演绎20讲">反爬虫兵法演绎20讲</a></li><li><a href="/blog/reactnative新架构实战课">reactnative新架构实战课</a></li><li><a href="/blog/正则表达式入门">正则表达式入门</a></li><li><a href="/blog/重学前端">重学前端</a></li><li><a href="/blog/serverless入门课">serverless入门课</a></li><li><a href="/blog/type-script入门实战笔记">type-script入门实战笔记</a></li><li><a href="/blog/图解googlev8">图解googlev8</a></li><li><a href="/blog/vue3源码分析">vue3源码分析</a></li><li><a href="/blog/玩转Vue3全家桶">玩转Vue3全家桶</a></li><li><a href="/blog/webassembly入门">webassembly入门</a></li><li><a href="/blog/手把手带你写一个Web框架">手把手带你写一个Web框架</a></li><li><a href="/blog/web漏洞挖掘实战">web漏洞挖掘实战</a></li><li><a href="/blog/跟月影学可视化">跟月影学可视化</a></li><li><a href="/blog/搞定音频技术">搞定音频技术</a></li><li><a href="/blog/攻克视频技术">攻克视频技术</a></li></ul></span><span>前端工程化<ul><li><a href="/blog/logger">logger</a></li><li><a href="/blog/webpack">webpack</a></li><li><a href="/blog/webpackChain">webpackChain</a></li></ul></span><span>前端性能优化<ul><li><a href="/blog/react性能调优">react性能调优</a></li></ul></span><span>软件测试<ul><li><a href="/blog/全链路压测实战30讲">全链路压测实战30讲</a></li><li><a href="/blog/性能测试实战30讲">性能测试实战30讲</a></li><li><a href="/blog/自动化测试高手课">自动化测试高手课</a></li><li><a aria-current="page" class="active" href="/blog/软件测试52讲">软件测试52讲</a></li></ul></span><span>面试<ul><li><a href="/blog/面试现场">面试现场</a></li></ul></span><span>杂谈<ul><li><a href="/blog/超级访谈对话张雪峰">超级访谈对话张雪峰</a></li><li><a href="/blog/Git实战手册">Git实战手册</a></li><li><a href="/blog/NodeJS">NodeJS</a></li><li><a href="/blog/ReactJS">ReactJS</a></li><li><a href="/blog/UI设计">UI设计</a></li><li><a href="/blog/webpack4系列教程">webpack4系列教程</a></li><li><a href="/blog/前端知识体系">前端知识体系</a></li><li><a href="/blog/剑指offer刷题笔记">剑指offer刷题笔记</a></li><li><a href="/blog/思考与成长">思考与成长</a></li><li><a href="/blog/设计模式手册">设计模式手册</a></li></ul></span><div class="__dumi-default-navbar-tool"><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "></div></div></div></nav></div><div class="__dumi-default-menu" data-mode="site"><div class="__dumi-default-menu-inner"><div class="__dumi-default-menu-header"><a class="__dumi-default-menu-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog/"></a><h1>大师兄</h1><p></p></div><div class="__dumi-default-menu-mobile-area"><ul class="__dumi-default-menu-nav-list"><li>计算机基础<ul><li><a href="/blog/编译原理之美">编译原理之美</a></li><li><a href="/blog/编译原理实战">编译原理实战</a></li><li><a href="/blog/深入浅出计算机组成原理">深入浅出计算机组成原理</a></li><li><a href="/blog/详解http">详解http</a></li><li><a href="/blog/计算机网络通关29讲">计算机网络通关29讲</a></li><li><a href="/blog/网络排查案例课">网络排查案例课</a></li><li><a href="/blog/linux操作系统">linux操作系统</a></li><li><a href="/blog/linux性能优化实战">linux性能优化实战</a></li><li><a href="/blog/程序员数学基础">程序员数学基础</a></li><li><a href="/blog/趣谈网络协议">趣谈网络协议</a></li><li><a href="/blog/操作系统实战">操作系统实战</a></li><li><a href="/blog/软件工程之美">软件工程之美</a></li><li><a href="/blog/sql必知必会">sql必知必会</a></li><li><a href="/blog/操作系统实战45讲">操作系统实战45讲</a></li><li><a href="/blog/网络编程实战">网络编程实战</a></li></ul></li><li>算法<ul><li><a href="/blog/常用算法25讲">常用算法25讲</a></li><li><a href="/blog/数据结构与算法之美">数据结构与算法之美</a></li><li><a href="/blog/业务开发算法50讲">业务开发算法50讲</a></li><li><a href="/blog/动态规划面试宝典">动态规划面试宝典</a></li></ul></li><li>前端开发<ul><li><a href="/blog/浏览器工作原理与实践">浏览器工作原理与实践</a></li><li><a href="/blog/新时代产品经理进阶之路">新时代产品经理进阶之路</a></li><li><a href="/blog/全栈工程师修炼指南">全栈工程师修炼指南</a></li><li><a href="/blog/flutter核心技术与实战">flutter核心技术与实战</a></li><li><a href="/blog/java-script核心原理解析">java-script核心原理解析</a></li><li><a href="/blog/说透低代码">说透低代码</a></li><li><a href="/blog/nodejs应用开发实战">nodejs应用开发实战</a></li><li><a href="/blog/反爬虫兵法演绎20讲">反爬虫兵法演绎20讲</a></li><li><a href="/blog/reactnative新架构实战课">reactnative新架构实战课</a></li><li><a href="/blog/正则表达式入门">正则表达式入门</a></li><li><a href="/blog/重学前端">重学前端</a></li><li><a href="/blog/serverless入门课">serverless入门课</a></li><li><a href="/blog/type-script入门实战笔记">type-script入门实战笔记</a></li><li><a href="/blog/图解googlev8">图解googlev8</a></li><li><a href="/blog/vue3源码分析">vue3源码分析</a></li><li><a href="/blog/玩转Vue3全家桶">玩转Vue3全家桶</a></li><li><a href="/blog/webassembly入门">webassembly入门</a></li><li><a href="/blog/手把手带你写一个Web框架">手把手带你写一个Web框架</a></li><li><a href="/blog/web漏洞挖掘实战">web漏洞挖掘实战</a></li><li><a href="/blog/跟月影学可视化">跟月影学可视化</a></li><li><a href="/blog/搞定音频技术">搞定音频技术</a></li><li><a href="/blog/攻克视频技术">攻克视频技术</a></li></ul></li><li>前端工程化<ul><li><a href="/blog/logger">logger</a></li><li><a href="/blog/webpack">webpack</a></li><li><a href="/blog/webpackChain">webpackChain</a></li></ul></li><li>前端性能优化<ul><li><a href="/blog/react性能调优">react性能调优</a></li></ul></li><li>软件测试<ul><li><a href="/blog/全链路压测实战30讲">全链路压测实战30讲</a></li><li><a href="/blog/性能测试实战30讲">性能测试实战30讲</a></li><li><a href="/blog/自动化测试高手课">自动化测试高手课</a></li><li><a aria-current="page" class="active" href="/blog/软件测试52讲">软件测试52讲</a></li></ul></li><li>面试<ul><li><a href="/blog/面试现场">面试现场</a></li></ul></li><li>杂谈<ul><li><a href="/blog/超级访谈对话张雪峰">超级访谈对话张雪峰</a></li><li><a href="/blog/Git实战手册">Git实战手册</a></li><li><a href="/blog/NodeJS">NodeJS</a></li><li><a href="/blog/ReactJS">ReactJS</a></li><li><a href="/blog/UI设计">UI设计</a></li><li><a href="/blog/webpack4系列教程">webpack4系列教程</a></li><li><a href="/blog/前端知识体系">前端知识体系</a></li><li><a href="/blog/剑指offer刷题笔记">剑指offer刷题笔记</a></li><li><a href="/blog/思考与成长">思考与成长</a></li><li><a href="/blog/设计模式手册">设计模式手册</a></li></ul></li></ul><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "><button title="Dark theme" class="__dumi-default-dark-moon "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="3854" width="22" height="22"><path d="M991.816611 674.909091a69.166545 69.166545 0 0 0-51.665455-23.272727 70.795636 70.795636 0 0 0-27.438545 5.585454A415.674182 415.674182 0 0 1 754.993338 698.181818c-209.594182 0-393.472-184.785455-393.472-395.636363 0-52.363636 38.539636-119.621818 69.515637-173.614546 4.887273-8.610909 9.634909-16.756364 14.103272-24.901818A69.818182 69.818182 0 0 0 384.631156 0a70.842182 70.842182 0 0 0-27.438545 5.585455C161.678429 90.298182 14.362065 307.898182 14.362065 512c0 282.298182 238.824727 512 532.38691 512a522.286545 522.286545 0 0 0 453.957818-268.334545A69.818182 69.818182 0 0 0 991.816611 674.909091zM546.679156 954.181818c-248.785455 0-462.941091-192-462.941091-442.181818 0-186.647273 140.637091-372.829091 300.939637-442.181818-36.817455 65.629091-92.578909 151.970909-92.578909 232.727273 0 250.181818 214.109091 465.454545 462.917818 465.454545a488.331636 488.331636 0 0 0 185.181091-46.545455 453.003636 453.003636 0 0 1-393.565091 232.727273z m103.656728-669.323636l-14.266182 83.781818a34.909091 34.909091 0 0 0 50.362182 36.770909l74.775272-39.563636 74.752 39.563636a36.142545 36.142545 0 0 0 16.174546 3.956364 34.909091 34.909091 0 0 0 34.210909-40.727273l-14.289455-83.781818 60.509091-59.345455a35.025455 35.025455 0 0 0-19.223272-59.578182l-83.61891-12.101818-37.376-76.101818a34.56 34.56 0 0 0-62.254545 0l-37.376 76.101818-83.618909 12.101818a34.909091 34.909091 0 0 0-19.246546 59.578182z m70.423272-64.698182a34.280727 34.280727 0 0 0 26.135273-19.083636l14.312727-29.090909 14.336 29.090909a34.257455 34.257455 0 0 0 26.135273 19.083636l32.046546 4.887273-23.272728 22.574545a35.234909 35.234909 0 0 0-10.007272 30.952727l5.46909 32.116364-28.625454-15.127273a34.490182 34.490182 0 0 0-32.302546 0l-28.695272 15.127273 5.469091-32.116364a35.141818 35.141818 0 0 0-9.984-30.952727l-23.272728-22.574545z" p-id="3855"></path></svg></button><button title="Light theme" class="__dumi-default-dark-sun "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="4026" width="22" height="22"><path d="M915.2 476.16h-43.968c-24.704 0-44.736 16-44.736 35.84s20.032 35.904 44.736 35.904H915.2c24.768 0 44.8-16.064 44.8-35.904s-20.032-35.84-44.8-35.84zM512 265.6c-136.704 0-246.464 109.824-246.464 246.4 0 136.704 109.76 246.464 246.464 246.464S758.4 648.704 758.4 512c0-136.576-109.696-246.4-246.4-246.4z m0 425.6c-99.008 0-179.2-80.128-179.2-179.2 0-98.944 80.192-179.2 179.2-179.2S691.2 413.056 691.2 512c0 99.072-80.192 179.2-179.2 179.2zM197.44 512c0-19.84-19.136-35.84-43.904-35.84H108.8c-24.768 0-44.8 16-44.8 35.84s20.032 35.904 44.8 35.904h44.736c24.768 0 43.904-16.064 43.904-35.904zM512 198.464c19.776 0 35.84-20.032 35.84-44.8v-44.8C547.84 84.032 531.84 64 512 64s-35.904 20.032-35.904 44.8v44.8c0 24.768 16.128 44.864 35.904 44.864z m0 627.136c-19.776 0-35.904 20.032-35.904 44.8v44.736C476.096 940.032 492.16 960 512 960s35.84-20.032 35.84-44.8v-44.736c0-24.768-16.064-44.864-35.84-44.864z m329.92-592.832c17.472-17.536 20.288-43.072 6.4-57.024-14.016-14.016-39.488-11.2-57.024 6.336-4.736 4.864-26.496 26.496-31.36 31.36-17.472 17.472-20.288 43.008-6.336 57.024 13.952 14.016 39.488 11.2 57.024-6.336 4.8-4.864 26.496-26.56 31.296-31.36zM213.376 759.936c-4.864 4.8-26.56 26.624-31.36 31.36-17.472 17.472-20.288 42.944-6.4 56.96 14.016 13.952 39.552 11.2 57.024-6.336 4.8-4.736 26.56-26.496 31.36-31.36 17.472-17.472 20.288-43.008 6.336-56.96-14.016-13.952-39.552-11.072-56.96 6.336z m19.328-577.92c-17.536-17.536-43.008-20.352-57.024-6.336-14.08 14.016-11.136 39.488 6.336 57.024 4.864 4.864 26.496 26.56 31.36 31.424 17.536 17.408 43.008 20.288 56.96 6.336 14.016-14.016 11.264-39.488-6.336-57.024-4.736-4.864-26.496-26.56-31.296-31.424z m527.168 628.608c4.864 4.864 26.624 26.624 31.36 31.424 17.536 17.408 43.072 20.224 57.088 6.336 13.952-14.016 11.072-39.552-6.4-57.024-4.864-4.8-26.56-26.496-31.36-31.36-17.472-17.408-43.072-20.288-57.024-6.336-13.952 14.016-11.008 39.488 6.336 56.96z" p-id="4027"></path></svg></button><button title="Default to system" class="__dumi-default-dark-auto "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="11002" width="22" height="22"><path d="M127.658667 492.885333c0-51.882667 10.24-101.717333 30.378666-149.162666s47.786667-88.064 81.92-122.538667 75.093333-61.781333 122.538667-81.92 96.938667-30.378667 149.162667-30.378667 101.717333 10.24 149.162666 30.378667 88.405333 47.786667 122.88 81.92 61.781333 75.093333 81.92 122.538667 30.378667 96.938667 30.378667 149.162666-10.24 101.717333-30.378667 149.162667-47.786667 88.405333-81.92 122.88-75.093333 61.781333-122.88 81.92-97.28 30.378667-149.162666 30.378667-101.717333-10.24-149.162667-30.378667-88.064-47.786667-122.538667-81.92-61.781333-75.093333-81.92-122.88-30.378667-96.938667-30.378666-149.162667z m329.045333 0c0 130.048 13.994667 244.394667 41.984 343.381334h12.970667c46.762667 0 91.136-9.216 133.461333-27.306667s78.848-42.666667 109.568-73.386667 54.954667-67.242667 73.386667-109.568 27.306667-86.698667 27.306666-133.461333c0-46.421333-9.216-90.794667-27.306666-133.12s-42.666667-78.848-73.386667-109.568-67.242667-54.954667-109.568-73.386667-86.698667-27.306667-133.461333-27.306666h-11.605334c-28.672 123.562667-43.349333 237.909333-43.349333 343.722666z" p-id="11003"></path></svg></button></div></div></div><ul class="__dumi-default-menu-list"><li><a href="/blog/软件测试52讲">软件测试52讲</a></li><li><a href="/blog/软件测试52讲/01.开篇词">01.开篇词</a><ul><li><a href="/blog/软件测试52讲/01.开篇词/01"><span>开篇词 | 从“小工”到“专家”，我的软件测试修炼之道</span></a></li></ul></li><li><a href="/blog/软件测试52讲/02.测试基础知识篇">02.测试基础知识篇</a><ul><li><a href="/blog/软件测试52讲/02.测试基础知识篇/01"><span>01 | 你真的懂测试吗？从“用户登录”测试谈起</span></a></li><li><a href="/blog/软件测试52讲/02.测试基础知识篇/02"><span>02 | 如何设计一个“好的”测试用例？</span></a></li><li><a href="/blog/软件测试52讲/02.测试基础知识篇/03"><span>03 | 什么是单元测试？如何做好单元测试？</span></a></li><li><a href="/blog/软件测试52讲/02.测试基础知识篇/04"><span>04 | 为什么要做自动化测试？什么样的项目适合做自动化测试？</span></a></li><li><a href="/blog/软件测试52讲/02.测试基础知识篇/05"><span>05 | 你知道软件开发各阶段都有哪些自动化测试技术吗？</span></a></li><li><a href="/blog/软件测试52讲/02.测试基础知识篇/06"><span>06 | 你真的懂测试覆盖率吗？</span></a></li><li><a href="/blog/软件测试52讲/02.测试基础知识篇/07"><span>07 | 如何高效填写软件缺陷报告？</span></a></li><li><a href="/blog/软件测试52讲/02.测试基础知识篇/08"><span>08 | 以终为始，如何才能做好测试计划？</span></a></li><li><a href="/blog/软件测试52讲/02.测试基础知识篇/09"><span>09 | 软件测试工程师的核心竞争力是什么？</span></a></li><li><a href="/blog/软件测试52讲/02.测试基础知识篇/10"><span>10 | 软件测试工程师需要掌握的非测试知识有哪些？</span></a></li><li><a href="/blog/软件测试52讲/02.测试基础知识篇/11"><span>11 | 互联网产品的测试策略应该如何设计？</span></a></li></ul></li><li><a href="/blog/软件测试52讲/03.gui自动化测试篇">03.GUI自动化测试篇</a><ul><li><a href="/blog/软件测试52讲/03.gui自动化测试篇/01"><span>12 | 从0到1：你的第一个GUI自动化测试</span></a></li><li><a href="/blog/软件测试52讲/03.gui自动化测试篇/02"><span>13 | 效率为王：脚本与数据的解耦 + Page Object模型</span></a></li><li><a href="/blog/软件测试52讲/03.gui自动化测试篇/03"><span>14 | 更接近业务的抽象：让自动化测试脚本更好地描述业务</span></a></li><li><a href="/blog/软件测试52讲/03.gui自动化测试篇/04"><span>15 | 过不了的坎：聊聊GUI自动化过程中的测试数据</span></a></li><li><a href="/blog/软件测试52讲/03.gui自动化测试篇/05"><span>16 | 脑洞大开：GUI测试还能这么玩（Page Code Gen + Data Gen + Headless）？</span></a></li><li><a href="/blog/软件测试52讲/03.gui自动化测试篇/06"><span>17 | 精益求精：聊聊提高GUI测试稳定性的关键技术</span></a></li><li><a href="/blog/软件测试52讲/03.gui自动化测试篇/07"><span>18 | 眼前一亮：带你玩转GUI自动化的测试报告</span></a></li><li><a href="/blog/软件测试52讲/03.gui自动化测试篇/08"><span>19 | 真实的战场：如何在大型项目中设计GUI自动化测试策略</span></a></li><li><a href="/blog/软件测试52讲/03.gui自动化测试篇/09"><span>20 | 与时俱进：浅谈移动应用测试方法与思路</span></a></li><li><a href="/blog/软件测试52讲/03.gui自动化测试篇/10"><span>21 | 移动测试神器：带你玩转Appium</span></a></li></ul></li><li><a href="/blog/软件测试52讲/04.api自动化测试篇">04.API自动化测试篇</a><ul><li><a href="/blog/软件测试52讲/04.api自动化测试篇/01"><span>22 | 从0到1：API测试怎么做？常用API测试工具简介</span></a></li><li><a href="/blog/软件测试52讲/04.api自动化测试篇/02"><span>23 | 知其然知其所以然：聊聊API自动化测试框架的前世今生</span></a></li><li><a href="/blog/软件测试52讲/04.api自动化测试篇/03"><span>24 | 紧跟时代步伐：微服务模式下API测试要怎么做？</span></a></li></ul></li><li><a href="/blog/软件测试52讲/05.代码测试篇">05.代码测试篇</a><ul><li><a href="/blog/软件测试52讲/05.代码测试篇/01"><span>25 | 不破不立：掌握代码级测试的基本理念与方法</span></a></li><li><a href="/blog/软件测试52讲/05.代码测试篇/02"><span>26 | 深入浅出之静态测试方法</span></a></li><li><a href="/blog/软件测试52讲/05.代码测试篇/03"><span>27 | 深入浅出之动态测试方法</span></a></li></ul></li><li><a aria-current="page" class="active" href="/blog/软件测试52讲/06.性能测试篇">06.性能测试篇</a><ul><li><a href="/blog/软件测试52讲/06.性能测试篇/01"><span>28 | 带你一起解读不同视角的软件性能与性能指标</span></a></li><li><a href="/blog/软件测试52讲/06.性能测试篇/02"><span>29 | 聊聊性能测试的基本方法与应用领域</span></a></li><li><a aria-current="page" class="active" href="/blog/软件测试52讲/06.性能测试篇/03"><span>30 | 工欲善其事必先利其器：后端性能测试工具原理与行业常用工具简介</span></a></li><li><a href="/blog/软件测试52讲/06.性能测试篇/04"><span>31 | 工欲善其事必先利其器：前端性能测试工具原理与行业常用工具简介</span></a></li><li><a href="/blog/软件测试52讲/06.性能测试篇/05"><span>32 | 无实例无真相：基于LoadRunner实现企业级服务器端性能测试的实践（上）</span></a></li><li><a href="/blog/软件测试52讲/06.性能测试篇/06"><span>33 | 无实例无真相：基于LoadRunner实现企业级服务器端性能测试的实践（下）</span></a></li><li><a href="/blog/软件测试52讲/06.性能测试篇/07"><span>34 | 站在巨人的肩膀：企业级实际性能测试案例与经验分享</span></a></li></ul></li><li><a href="/blog/软件测试52讲/07.测试数据准备篇">07.测试数据准备篇</a><ul><li><a href="/blog/软件测试52讲/07.测试数据准备篇/01"><span>35 | 如何准备测试数据？</span></a></li><li><a href="/blog/软件测试52讲/07.测试数据准备篇/02"><span>36 | 浅谈测试数据的痛点</span></a></li><li><a href="/blog/软件测试52讲/07.测试数据准备篇/03"><span>37 | 测试数据的“银弹”- 统一测试数据平台（上）</span></a></li><li><a href="/blog/软件测试52讲/07.测试数据准备篇/04"><span>38 | 测试数据的“银弹”- 统一测试数据平台（下）</span></a></li></ul></li><li><a href="/blog/软件测试52讲/08.测试基础架构篇">08.测试基础架构篇</a><ul><li><a href="/blog/软件测试52讲/08.测试基础架构篇/01"><span>39 | 从小作坊到工厂：什么是Selenium Grid？如何搭建Selenium Grid？</span></a></li><li><a href="/blog/软件测试52讲/08.测试基础架构篇/02"><span>40 | 从小工到专家：聊聊测试执行环境的架构设计（上）</span></a></li><li><a href="/blog/软件测试52讲/08.测试基础架构篇/03"><span>41 | 从小工到专家：聊聊测试执行环境的架构设计（下）</span></a></li><li><a href="/blog/软件测试52讲/08.测试基础架构篇/04"><span>42 | 实战：大型全球化电商的测试基础架构设计</span></a></li></ul></li><li><a href="/blog/软件测试52讲/09.测试新技术篇">09.测试新技术篇</a><ul><li><a href="/blog/软件测试52讲/09.测试新技术篇/01"><span>43 | 发挥人的潜能：探索式测试</span></a></li><li><a href="/blog/软件测试52讲/09.测试新技术篇/02"><span>44 | 测试先行：测试驱动开发(TDD)</span></a></li><li><a href="/blog/软件测试52讲/09.测试新技术篇/03"><span>45 | 打蛇打七寸：精准测试</span></a></li><li><a href="/blog/软件测试52讲/09.测试新技术篇/04"><span>46 | 安全第一：渗透测试</span></a></li><li><a href="/blog/软件测试52讲/09.测试新技术篇/05"><span>47 | 用机器设计测试用例：基于模型的测试</span></a></li></ul></li><li><a href="/blog/软件测试52讲/10.测试人员的互联网架构核心知识篇">10.测试人员的互联网架构核心知识篇</a><ul><li><a href="/blog/软件测试52讲/10.测试人员的互联网架构核心知识篇/01"><span>48 | 优秀的测试工程师为什么要懂大型网站的架构设计？</span></a></li><li><a href="/blog/软件测试52讲/10.测试人员的互联网架构核心知识篇/02"><span>49 | 深入浅出网站高性能架构设计</span></a></li><li><a href="/blog/软件测试52讲/10.测试人员的互联网架构核心知识篇/03"><span>50 | 深入浅出网站高可用架构设计</span></a></li><li><a href="/blog/软件测试52讲/10.测试人员的互联网架构核心知识篇/04"><span>51 | 深入浅出网站伸缩性架构设计</span></a></li><li><a href="/blog/软件测试52讲/10.测试人员的互联网架构核心知识篇/05"><span>52 | 深入浅出网站可扩展性架构设计</span></a></li></ul></li><li><a href="/blog/软件测试52讲/11.特别放送篇">11.特别放送篇</a><ul><li><a href="/blog/软件测试52讲/11.特别放送篇/01"><span>测试专栏特别放送 | 答疑解惑第一期</span></a></li><li><a href="/blog/软件测试52讲/11.特别放送篇/02"><span>测试专栏特别放送 | 答疑解惑第二期</span></a></li><li><a href="/blog/软件测试52讲/11.特别放送篇/03"><span>测试专栏特别放送 | 答疑解惑第三期</span></a></li><li><a href="/blog/软件测试52讲/11.特别放送篇/04"><span>测试专栏特别放送 | 答疑解惑第四期</span></a></li><li><a href="/blog/软件测试52讲/11.特别放送篇/05"><span>测试专栏特别放送 | 答疑解惑第五期</span></a></li><li><a href="/blog/软件测试52讲/11.特别放送篇/06"><span>测试专栏特别放送 | 答疑解惑第六期</span></a></li><li><a href="/blog/软件测试52讲/11.特别放送篇/07"><span>测试专栏特别放送 | 答疑解惑第七期</span></a></li><li><a href="/blog/软件测试52讲/11.特别放送篇/08"><span>测试专栏特别放送 | 浅谈全链路压测</span></a></li></ul></li><li><a href="/blog/软件测试52讲/12.测一测">12.测一测</a><ul><li><a href="/blog/软件测试52讲/12.测一测/01"><span>测一测 | 这些软件测试题目，你都掌握了吗？</span></a></li></ul></li><li><a href="/blog/软件测试52讲/13.结束语">13.结束语</a><ul><li><a href="/blog/软件测试52讲/13.结束语/01"><span>结束语 | 不是结束，而是开始</span></a></li></ul></li><li><a href="/blog/软件测试52讲/summary">软件测试52讲</a></li></ul></div></div><ul role="slug-list" class="__dumi-default-layout-toc"><li title="后端性能测试和后端性能测试工具之间的关系是什么？" data-depth="2"><a href="/blog/软件测试52讲/06.性能测试篇/03#后端性能测试和后端性能测试工具之间的关系是什么"><span>后端性能测试和后端性能测试工具之间的关系是什么？</span></a></li><li title="后端性能测试工具和GUI自动化测试工具最大的区别是什么？" data-depth="2"><a href="/blog/软件测试52讲/06.性能测试篇/03#后端性能测试工具和gui自动化测试工具最大的区别是什么"><span>后端性能测试工具和GUI自动化测试工具最大的区别是什么？</span></a></li><li title="后端性能测试工具的原理是什么？" data-depth="2"><a href="/blog/软件测试52讲/06.性能测试篇/03#后端性能测试工具的原理是什么"><span>后端性能测试工具的原理是什么？</span></a></li><li title="后端性能测试场景设计是什么意思，具体会涉及哪些内容？" data-depth="2"><a href="/blog/软件测试52讲/06.性能测试篇/03#后端性能测试场景设计是什么意思具体会涉及哪些内容"><span>后端性能测试场景设计是什么意思，具体会涉及哪些内容？</span></a></li><li title="业内主流的后端性能测试工具有哪些？" data-depth="2"><a href="/blog/软件测试52讲/06.性能测试篇/03#业内主流的后端性能测试工具有哪些"><span>业内主流的后端性能测试工具有哪些？</span></a></li><li title="总结" data-depth="2"><a href="/blog/软件测试52讲/06.性能测试篇/03#总结"><span>总结</span></a></li><li title="思考题" data-depth="2"><a href="/blog/软件测试52讲/06.性能测试篇/03#思考题"><span>思考题</span></a></li></ul><div class="__dumi-default-layout-content"><div class="markdown"><h1 id="30--工欲善其事必先利其器后端性能测试工具原理与行业常用工具简介"><a aria-hidden="true" tabindex="-1" href="/blog/软件测试52讲/06.性能测试篇/03#30--工欲善其事必先利其器后端性能测试工具原理与行业常用工具简介"><span class="icon icon-link"></span></a>30 | 工欲善其事必先利其器：后端性能测试工具原理与行业常用工具简介</h1><p>你好，我是茹炳晟。今天我和你分享的主题是：工欲善其事必先利其器之后端性能测试工具原理与行业常用工具简介。</p><p>我在《聊聊性能测试的基本方法与应用领域》这个主题里介绍了七种测试方法，但不管是什么类型的性能测试方法，都需要去模拟大量并发用户的同时执行，所以性能测试基本都是靠工具实现。没有工具，性能测试将寸步难行。</p><p>所以，我今天就从后端性能测试的工具讲起，和你一起讨论它们的实现原理，以及如何用于后端的性能测试。另外，我还会和你分享一些中大型互联网企业选择的性能测试工具。</p><p>由于我今天要分享的知识点比较多，而且是相对独立的，所以我会采用问答的形式展开这些内容。我希望通过今天的分享，你能够对以下的问题和知识点有完整、清晰的理解与认识：</p><ul><li>后端性能测试和后端性能测试工具之间的关系是什么？</li><li>后端性能测试工具和GUI自动化测试工具最大的区别是什么？</li><li>后端性能测试工具的原理是什么？</li><li>后端性能测试中，性能测试场景设计是什么意思，具体会涉及哪些内容？</li><li>业内主流的后端性能测试工具有哪些？</li></ul><h2 id="后端性能测试和后端性能测试工具之间的关系是什么"><a aria-hidden="true" tabindex="-1" href="/blog/软件测试52讲/06.性能测试篇/03#后端性能测试和后端性能测试工具之间的关系是什么"><span class="icon icon-link"></span></a>后端性能测试和后端性能测试工具之间的关系是什么？</h2><p>后端性能测试工具是实现后端性能测试的技术手段，但是千万不要简单地把使用后端性能测试工具等同于后端性能测试，它只是后端性能测试中的一个必要步骤而已。</p><p><strong>完整的后端性能测试应该包括性能需求获取、性能场景设计、性能测试脚本开发、性能场景实现、性能测试执行、性能结果报告分析、性能优化和再验证。</strong></p><p>在这其中，后端性能测试工具主要在性能测试脚本开发、性能场景实现、性能测试执行这三个步骤中发挥作用，而其他环节都要依靠性能测试工程师的专业知识完成。</p><p>是不是感觉有点抽象，难以理解呢？我来做个类比吧。</p><p>假如你现在要去医院看病，医生会根据你对身体不适的描述，要求你先去验血，并确定需要检查的血液指标。验血是通过专业的医疗仪器分析你的血样，并得到验血报告。</p><p>医生拿到验血报告后，根据常年积累的专业知识，然后结合验血报告的各项指标以及指标之间的相互关系判断你的病情，并给出诊断结果以及相应的治疗措施。</p><p>同样的验血报告，如果给不懂医术的人看，就是一堆没有意义的数据；如果给一个初级医生看，他可能只能基于单个指标的高低给出可能的推测；但是，如果是给一个具有丰富临床经验的医生看，他往往可以根据这些指标以及它们之间的相互关系给出很明确的诊断结果。</p><p>现在，我把这个过程和性能测试做个类比，把性能测试对应到整个看病的过程：</p><ul><li>需求获取对应的是你向医生描述身体不适细节的过程，医生需要知道要帮你解决什么问题；</li><li>设计性能场景对应的是医生决定需要检查哪些血液指标的过程；</li><li>使用性能测试工具对应的是使用医疗仪器分析血样的过程;</li><li>性能测试报告对应的就是验血报告;</li><li>性能测试人员分析性能结果报告的过程，对应的是医生解读验血报告的过程；</li><li>性能测试人员根据性能报告进行性能优化的过程，对应的是医生根据验血报告判断你的病情，并给出相应治疗措施的过程。</li></ul><p>所以，在我看来<strong>使用性能测试工具获得性能测试报告只是性能测试过程中的一个必要步骤而已，而得出报告的目的是让性能测试工程师去做进一步的分析，以得出最终结论，并给出性能优化的措施。</strong></p><h2 id="后端性能测试工具和gui自动化测试工具最大的区别是什么"><a aria-hidden="true" tabindex="-1" href="/blog/软件测试52讲/06.性能测试篇/03#后端性能测试工具和gui自动化测试工具最大的区别是什么"><span class="icon icon-link"></span></a>后端性能测试工具和GUI自动化测试工具最大的区别是什么？</h2><p>虽然后端性能测试工具和GUI自动化测试工具都是通过自动化的手段模拟终端用户使用系统的行为，但是两者实现的原理截然不同。</p><p><strong>第一个显著区别是，模拟用户行为的方式。</strong></p><p>GUI自动化测试工具模拟的是用户的界面操作，因此测试脚本记录的是用户在界面上对控件的操作；而性能测试工具模拟的是用户的客户端与服务器之间的通信协议和数据，这些通信协议和数据往往是用户在界面上执行GUI操作时产生的。</p><p>明白了这一点，你自然就能明白为什么录制虚拟用户性能测试脚本时，我们需要先选定录制协议了。</p><p>另外，正是由于脚本的模拟是基于协议的，所以我们才能比较方便地模拟成千上万并发用户同时使用系统的场景；否则，如果性能测试基于GUI发起，那我们就需要成千上万的浏览器同时执行用例，而这显然是不可能的。</p><p><strong>第二个显著的区别是，测试的执行方式。</strong></p><p>GUI自动化测试的执行，一般是单用户执行并验证功能结果；而性能测试的执行，往往需要同时模拟大量的并发用户，不仅需要验证业务功能是否成功完成，还要收集各种性能监控指标，会涉及到压力产生器、并发用户调度控制、实时监控收集等内容，所以性能测试的执行控制要比GUI自动化测试复杂得多。</p><p>这部分内容，我稍后在第32和33这两篇文章中详细展开。</p><h2 id="后端性能测试工具的原理是什么"><a aria-hidden="true" tabindex="-1" href="/blog/软件测试52讲/06.性能测试篇/03#后端性能测试工具的原理是什么"><span class="icon icon-link"></span></a>后端性能测试工具的原理是什么？</h2><p>虽然后端性能测试工具种类很多，但是由于都不能通过GUI的方式来模拟并发，所以其基本原理和主要概念基本一致。</p><p><strong>首先，后端性能测试工具会基于客户端与服务器端的通信协议，构建模拟业务操作的虚拟用户脚本</strong>。对于目前主流的Web应用，通常是基于HTTP/HTTPS协议；对于Web Service应用，是基于Web Service协议；至于具体基于哪种协议，你需要和开发人员或者架构师确认，当然现在有些后端性能测试工具也可以直接帮你检测协议的种类。</p><p>我们把这些基于协议模拟用户行为的脚本称为虚拟用户脚本，而把开发和产生这些脚本的工具称为<strong>虚拟用户脚本生成器</strong>。</p><p>不同后端性能测试工具的虚拟用户脚本生成器，在使用上的区别比较大：比如，LoadRunner是通过录制后再修改的方式生成虚拟用户脚本；而JMeter主要是通过添加各种组件，然后对组件进行配置的方式生成虚拟用户脚本。</p><p>虽然LoadRunner也支持采用直接开发的方式产生虚拟用户脚本，但是因为开发难度太大，所以基本上都是采用先录制再开发的方式，不会直接去开发。另外，虽然JMeter也支持录制，但是JMeter的录制功能是通过设置代理完成的，而且录制出来的脚本都是原始的http请求，并没有经过适当的封装，所以录制功能比较弱。</p><p>虽然不同工具的使用方式各有特色，但其本质上都是通过协议模拟用户的行为。</p><p><strong>然后，开发完成了虚拟用户脚本之后，后端性能测试工具会以多线程或多进程的方式并发执行虚拟用户脚本，来模拟大量并发用户的同时访问，从而对服务器施加测试负载。</strong></p><p>其中，我们把实际发起测试负载的机器称为<strong>压力产生器</strong>。受限于CPU、内存，以及网络带宽等硬件资源，一台压力产生器能够承载的虚拟用户数量是有限的，当需要发起的并发用户数量超过了单台压力产生器能够提供的极限时，就需要引入多台压力产生器合作发起需要的测试负载。</p><p>一旦有了多台压力产生器，那就需要一个专门的控制器来统一管理与协调这些压力产生器，我们把这个专门的控制器称为<strong>压力控制器</strong>。压力控制器会根据性能测试场景的设计，来控制和协调多台压力产生器上的多线程或多进程执行的虚拟用户脚本，最终模拟出性能测试场景中的测试负载。</p><p><strong>接着，在施加测试负载的整个过程中，后端性能测试工具除了需要监控和收集被测系统的各种性能数据以外，还需要监控被测系统各个服务器的各种软硬件资源</strong>。比如，后端性能测试工具需要监控应用服务器、数据库服务器、消息队列服务器、缓存服务器等各种资源的占用率。我们通常把完成监控和数据收集的模块称为<strong>系统监控器</strong>。</p><p>在性能测试执行过程中，系统监控器的数据显示界面是性能测试工程师最密切关注的部分，性能测试工程师会根据实时的数据显示来判断测试负载情况下的系统健康状况。</p><p>不同的后端测试工具中，系统监控器能力差别也比较大。比如，LoadRunner的系统监控器就很强大，支持收集各种操作系统的系统参数，还支持与SiteScope等第三方专业监控工具的无缝集成。</p><p><strong>最后，测试执行完成后，后端性能测试工具会将系统监控器收集的所有信息汇总为完整测试报告</strong>，后端性能测试工具通常能够基于该报告生成各类指标的各种图表，还能将多个指标关联在一起进行综合分析来找出各个指标之间的关联性。我们把完成这部分工作的模块称为<strong>测试结果分析器</strong>。</p><p>需要强调的是，测试结果分析器只是按需提供多种不同维度和表现形式的数据展现工作，而对数据的分析工作，还是要依赖于具有丰富经验的性能测试工程师。</p><h2 id="后端性能测试场景设计是什么意思具体会涉及哪些内容"><a aria-hidden="true" tabindex="-1" href="/blog/软件测试52讲/06.性能测试篇/03#后端性能测试场景设计是什么意思具体会涉及哪些内容"><span class="icon icon-link"></span></a>后端性能测试场景设计是什么意思，具体会涉及哪些内容？</h2><p>性能测试场景设计，是后端性能测试中的重要概念，也是压力控制器发起测试负载的依据。</p><p>性能测试场景设计，目的是要描述性能测试过程中所有与测试负载以及监控相关的内容。通常来讲，性能测试场景设计主要会涉及以下部分：</p><ul><li>并发用户数是多少？</li><li>测试刚开始时，以什么样的速率来添加并发用户？比如，每秒增加5个并发用户。</li><li>达到最大并发用户数后持续多长时间？</li><li>测试结束时，以什么样的速率来减少并发用户？比如，每秒减少5个并发用户。</li><li>需要包含哪些业务操作，各个业务操作的占比是多少？比如，10%的用户在做登录操作，70%的用户在做查询操作，其他20%的用户在做订单操作。</li><li>一轮虚拟用户脚本执行结束后，需要等待多长时间开始下一次执行？</li><li>同一虚拟用户脚本中，各个操作之间的等待时间是多少？</li><li>需要监控哪些被测服务器的哪些指标？</li><li>脚本出错时的处理方式是什么？比如，错误率达到10%时，自动停止该脚本。</li><li>需要使用多少台压力产生器？</li></ul><p>以上这些场景组合在一起，就构成了性能测试场景设计的主要内容。也就是说，性能测试场景会对测试负载组成、负载策略、资源监控范围定义、终止方式，以及负载产生规划作出定义，而其中的每一项还会包含更多的内容。具体请参见如图1所示的思维导图。</p><p><img src="https://static001.geekbang.org/resource/image/4f/02/4f4f3d91ba710fe1f39cac341d296402.png" alt=""/></p><p>图1 性能测试场景的设计</p><h2 id="业内主流的后端性能测试工具有哪些"><a aria-hidden="true" tabindex="-1" href="/blog/软件测试52讲/06.性能测试篇/03#业内主流的后端性能测试工具有哪些"><span class="icon icon-link"></span></a>业内主流的后端性能测试工具有哪些？</h2><p>目前，业内有很多成熟的后端性能测试工具，比如传统的LoadRunner、JMeter、NeoLoad等。另外，现在还有很多云端部署的后端性能测试工具或平台，比如CloudTest、Loadstorm、阿里的PTS等。</p><p>其中，最为常用的商业工具是HP软件（现在已经被Micro Focus收购）的LoadRunner，由于其强大的功能和广泛的协议支持，几乎已经成了性能测试工具的代名词。大量的传统软件企业，也基本都使用LoadRunner实施性能测试，所以我在后面分享企业级服务器端性能测试的实践时，也是以LoadRunner为基础展开的。</p><p>另外，JMeter是目前开源领域最主流的性能测试工具。JMeter的功能非常灵活，能够支持HTTP、FTP、数据库的性能测试，也能够充当HTTP代理来录制浏览器的HTTP请求，还可以根据Apache等Web服务器的日志文件回放HTTP流量，还可以通过扩展支持海量的并发。</p><p>然后，再加上JMeter开源免费的特点，已经被很多互联网企业广泛应用。比如，饿了么就是使用JMeter来完成系统的全链路压力测试。</p><p>其实，传统软件企业偏向于使用LoadRunner，而互联网企业普遍采用JMeter，是有原因的。</p><p>LoadRunner License是按照并发用户数收费的，并发用户数越高收费也越贵，但是LoadRunner的脚本开发功能、执行控制、系统监控以及报告功能都非常强大，易学易用。</p><p>而传统软件企业，需要测试的并发用户数并不会太高，通常是在几百到十几万这个数量级，而且它们很在意软件的易用性和官方支持能力，所以往往热衷于直接选择成熟的商业工具LoadRunner。</p><p>但是，互联网企业的并发用户请求数量很高，很多软件都会达到百万，甚至是千万的级别。那么，如果使用LoadRunner的话：</p><ol><li><p>费用会高的离谱；</p></li><li><p>LoadRunner对海量并发的测试支持并不太好；</p></li><li><p>很多互联网企业还会有特定的工具需求，这些特定的需求很难在LoadRunner中实现，而在开源的JMeter中，用户完全可以根据需求进行扩展。</p></li></ol><p>所以互联网企业往往选用JMeter方案，而且通常会自己维护扩展版本。</p><h2 id="总结"><a aria-hidden="true" tabindex="-1" href="/blog/软件测试52讲/06.性能测试篇/03#总结"><span class="icon icon-link"></span></a>总结</h2><p>今天，我以问答的形式，和你分享了后端性能测试的理论，以及工具使用的问题。</p><p>首先，我和你解释了后端性能测试和后端性能测试工具之间的关系。在我看来使用性能测试工具获得性能测试报告，只是性能测试过程中的一个必要步骤而已，而得出报告的目的是让性能测试工程师去分析并给出性能优化的措施。</p><p>然后，我解释了后端性能测试工具和GUI自动化测试工具最大的区别，即它们模拟用户行为的方式以及测试的执行方式不同。</p><p>接着，我介绍了后端性能测试工具的基本原理。它首先通过虚拟用户脚本生成器生成虚拟用户脚本；然后根据性能测试场景设计的要求，通过压力控制器控制协调各个压力产生器以并发的方式执行虚拟用户脚本；同时，在测试执行过程中，通过系统监控器收集各种性能指标以及系统资源占用率；最后，通过测试结果分析器展示测试结果数据。</p><p>最后，我介绍了性能测试场景设计，并分析了业内主流的后端性能测试工具LoadRunner和JMeter，以及传统软件企业和互联网企业在选择后端性能测试工具时的考量。</p><h2 id="思考题"><a aria-hidden="true" tabindex="-1" href="/blog/软件测试52讲/06.性能测试篇/03#思考题"><span class="icon icon-link"></span></a>思考题</h2><p>除了我今天提到的后端性能测试工具外，你还接触过哪些后端性能测试工具？这些后端性能测试工具中又有哪些好的设计呢？</p><p>感谢你的收听，欢迎你给我留言。</p></div><div class="__dumi-default-layout-footer-meta"><a target="_blank" rel="noopener noreferrer" href="https://github.com/GGwujun/blog/edit/master/docs/软件测试52讲/06.性能测试篇/03.md">在 GitHub 上编辑此页<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a><span data-updated-text="最后更新时间：">5/2/2022 10:57:11</span></div></div></div></div>
	<script>
  window.g_useSSR = true;
  window.g_initialProps = {};
	</script>

    <script>
      (function () {
        if (!location.port) {
          (function (i, s, o, g, r, a, m) {
            i["GoogleAnalyticsObject"] = r;
            (i[r] =
              i[r] ||
              function () {
                (i[r].q = i[r].q || []).push(arguments);
              }),
              (i[r].l = 1 * new Date());
            (a = s.createElement(o)), (m = s.getElementsByTagName(o)[0]);
            a.async = 1;
            a.src = g;
            m.parentNode.insertBefore(a, m);
          })(
            window,
            document,
            "script",
            "//www.google-analytics.com/analytics.js",
            "ga"
          );
          ga("create", "UA-149864185-1", "auto");
          ga("send", "pageview");
        }
      })();
    </script>
    <script src="/blog/umi.js"></script>
  </body>
</html>
