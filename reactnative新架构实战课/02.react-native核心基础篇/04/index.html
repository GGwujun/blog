<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no"
    />
    <link rel="shortcut icon" type="image/x-icon" href="/logo.png" />
    <link rel="stylesheet" href="/blog/umi.css" />
    <script>
      window.routerBase = "/blog";
    </script>
    <script>
      //! umi version: 3.5.17
    </script>
    <script>
      !(function () {
        var e = localStorage.getItem("dumi:prefers-color"),
          t = window.matchMedia("(prefers-color-scheme: dark)").matches,
          r = ["light", "dark", "auto"];
        document.documentElement.setAttribute(
          "data-prefers-color",
          e === r[2] ? (t ? r[1] : r[0]) : r.indexOf(e) > -1 ? e : r[0]
        );
      })();
    </script>
    <title>04｜State：如何让页面“动”起来？</title>
  </head>
  <body>
    <div id="root"><div class="__dumi-default-layout" data-route="/reactnative新架构实战课/02.react-native核心基础篇/04" data-show-sidemenu="true" data-show-slugs="true" data-site-mode="true" data-gapless="false"><div class="__dumi-default-navbar" data-mode="site"><button class="__dumi-default-navbar-toggle"></button><a class="__dumi-default-navbar-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog/">大师兄</a><nav><div class="__dumi-default-search"><input type="search" class="__dumi-default-search-input" value=""/><ul></ul></div><span>计算机基础<ul><li><a href="/blog/编译原理之美">编译原理之美</a></li><li><a href="/blog/编译原理实战">编译原理实战</a></li><li><a href="/blog/深入浅出计算机组成原理">深入浅出计算机组成原理</a></li><li><a href="/blog/详解http">详解http</a></li><li><a href="/blog/计算机网络通关29讲">计算机网络通关29讲</a></li><li><a href="/blog/网络排查案例课">网络排查案例课</a></li><li><a href="/blog/linux操作系统">linux操作系统</a></li><li><a href="/blog/linux性能优化实战">linux性能优化实战</a></li><li><a href="/blog/程序员数学基础">程序员数学基础</a></li><li><a href="/blog/趣谈网络协议">趣谈网络协议</a></li><li><a href="/blog/操作系统实战">操作系统实战</a></li><li><a href="/blog/软件工程之美">软件工程之美</a></li><li><a href="/blog/sql必知必会">sql必知必会</a></li><li><a href="/blog/操作系统实战45讲">操作系统实战45讲</a></li><li><a href="/blog/网络编程实战">网络编程实战</a></li></ul></span><span>算法<ul><li><a href="/blog/常用算法25讲">常用算法25讲</a></li><li><a href="/blog/数据结构与算法之美">数据结构与算法之美</a></li><li><a href="/blog/业务开发算法50讲">业务开发算法50讲</a></li><li><a href="/blog/动态规划面试宝典">动态规划面试宝典</a></li></ul></span><span>前端开发<ul><li><a href="/blog/浏览器工作原理与实践">浏览器工作原理与实践</a></li><li><a href="/blog/新时代产品经理进阶之路">新时代产品经理进阶之路</a></li><li><a href="/blog/全栈工程师修炼指南">全栈工程师修炼指南</a></li><li><a href="/blog/flutter核心技术与实战">flutter核心技术与实战</a></li><li><a href="/blog/java-script核心原理解析">java-script核心原理解析</a></li><li><a href="/blog/说透低代码">说透低代码</a></li><li><a href="/blog/nodejs应用开发实战">nodejs应用开发实战</a></li><li><a href="/blog/反爬虫兵法演绎20讲">反爬虫兵法演绎20讲</a></li><li><a aria-current="page" class="active" href="/blog/reactnative新架构实战课">reactnative新架构实战课</a></li><li><a href="/blog/正则表达式入门">正则表达式入门</a></li><li><a href="/blog/重学前端">重学前端</a></li><li><a href="/blog/serverless入门课">serverless入门课</a></li><li><a href="/blog/type-script入门实战笔记">type-script入门实战笔记</a></li><li><a href="/blog/图解googlev8">图解googlev8</a></li><li><a href="/blog/vue3源码分析">vue3源码分析</a></li><li><a href="/blog/玩转Vue3全家桶">玩转Vue3全家桶</a></li><li><a href="/blog/webassembly入门">webassembly入门</a></li><li><a href="/blog/手把手带你写一个Web框架">手把手带你写一个Web框架</a></li><li><a href="/blog/web漏洞挖掘实战">web漏洞挖掘实战</a></li><li><a href="/blog/跟月影学可视化">跟月影学可视化</a></li><li><a href="/blog/搞定音频技术">搞定音频技术</a></li><li><a href="/blog/攻克视频技术">攻克视频技术</a></li></ul></span><span>前端工程化<ul><li><a href="/blog/logger">logger</a></li><li><a href="/blog/webpack">webpack</a></li><li><a href="/blog/webpackChain">webpackChain</a></li></ul></span><span>前端性能优化<ul><li><a href="/blog/react性能调优">react性能调优</a></li></ul></span><span>软件测试<ul><li><a href="/blog/全链路压测实战30讲">全链路压测实战30讲</a></li><li><a href="/blog/性能测试实战30讲">性能测试实战30讲</a></li><li><a href="/blog/自动化测试高手课">自动化测试高手课</a></li><li><a href="/blog/软件测试52讲">软件测试52讲</a></li></ul></span><span>面试<ul><li><a href="/blog/面试现场">面试现场</a></li></ul></span><span>杂谈<ul><li><a href="/blog/超级访谈对话张雪峰">超级访谈对话张雪峰</a></li><li><a href="/blog/Git实战手册">Git实战手册</a></li><li><a href="/blog/NodeJS">NodeJS</a></li><li><a href="/blog/ReactJS">ReactJS</a></li><li><a href="/blog/UI设计">UI设计</a></li><li><a href="/blog/webpack4系列教程">webpack4系列教程</a></li><li><a href="/blog/前端知识体系">前端知识体系</a></li><li><a href="/blog/剑指offer刷题笔记">剑指offer刷题笔记</a></li><li><a href="/blog/思考与成长">思考与成长</a></li><li><a href="/blog/设计模式手册">设计模式手册</a></li></ul></span><div class="__dumi-default-navbar-tool"><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "></div></div></div></nav></div><div class="__dumi-default-menu" data-mode="site"><div class="__dumi-default-menu-inner"><div class="__dumi-default-menu-header"><a class="__dumi-default-menu-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog/"></a><h1>大师兄</h1><p></p></div><div class="__dumi-default-menu-mobile-area"><ul class="__dumi-default-menu-nav-list"><li>计算机基础<ul><li><a href="/blog/编译原理之美">编译原理之美</a></li><li><a href="/blog/编译原理实战">编译原理实战</a></li><li><a href="/blog/深入浅出计算机组成原理">深入浅出计算机组成原理</a></li><li><a href="/blog/详解http">详解http</a></li><li><a href="/blog/计算机网络通关29讲">计算机网络通关29讲</a></li><li><a href="/blog/网络排查案例课">网络排查案例课</a></li><li><a href="/blog/linux操作系统">linux操作系统</a></li><li><a href="/blog/linux性能优化实战">linux性能优化实战</a></li><li><a href="/blog/程序员数学基础">程序员数学基础</a></li><li><a href="/blog/趣谈网络协议">趣谈网络协议</a></li><li><a href="/blog/操作系统实战">操作系统实战</a></li><li><a href="/blog/软件工程之美">软件工程之美</a></li><li><a href="/blog/sql必知必会">sql必知必会</a></li><li><a href="/blog/操作系统实战45讲">操作系统实战45讲</a></li><li><a href="/blog/网络编程实战">网络编程实战</a></li></ul></li><li>算法<ul><li><a href="/blog/常用算法25讲">常用算法25讲</a></li><li><a href="/blog/数据结构与算法之美">数据结构与算法之美</a></li><li><a href="/blog/业务开发算法50讲">业务开发算法50讲</a></li><li><a href="/blog/动态规划面试宝典">动态规划面试宝典</a></li></ul></li><li>前端开发<ul><li><a href="/blog/浏览器工作原理与实践">浏览器工作原理与实践</a></li><li><a href="/blog/新时代产品经理进阶之路">新时代产品经理进阶之路</a></li><li><a href="/blog/全栈工程师修炼指南">全栈工程师修炼指南</a></li><li><a href="/blog/flutter核心技术与实战">flutter核心技术与实战</a></li><li><a href="/blog/java-script核心原理解析">java-script核心原理解析</a></li><li><a href="/blog/说透低代码">说透低代码</a></li><li><a href="/blog/nodejs应用开发实战">nodejs应用开发实战</a></li><li><a href="/blog/反爬虫兵法演绎20讲">反爬虫兵法演绎20讲</a></li><li><a aria-current="page" class="active" href="/blog/reactnative新架构实战课">reactnative新架构实战课</a></li><li><a href="/blog/正则表达式入门">正则表达式入门</a></li><li><a href="/blog/重学前端">重学前端</a></li><li><a href="/blog/serverless入门课">serverless入门课</a></li><li><a href="/blog/type-script入门实战笔记">type-script入门实战笔记</a></li><li><a href="/blog/图解googlev8">图解googlev8</a></li><li><a href="/blog/vue3源码分析">vue3源码分析</a></li><li><a href="/blog/玩转Vue3全家桶">玩转Vue3全家桶</a></li><li><a href="/blog/webassembly入门">webassembly入门</a></li><li><a href="/blog/手把手带你写一个Web框架">手把手带你写一个Web框架</a></li><li><a href="/blog/web漏洞挖掘实战">web漏洞挖掘实战</a></li><li><a href="/blog/跟月影学可视化">跟月影学可视化</a></li><li><a href="/blog/搞定音频技术">搞定音频技术</a></li><li><a href="/blog/攻克视频技术">攻克视频技术</a></li></ul></li><li>前端工程化<ul><li><a href="/blog/logger">logger</a></li><li><a href="/blog/webpack">webpack</a></li><li><a href="/blog/webpackChain">webpackChain</a></li></ul></li><li>前端性能优化<ul><li><a href="/blog/react性能调优">react性能调优</a></li></ul></li><li>软件测试<ul><li><a href="/blog/全链路压测实战30讲">全链路压测实战30讲</a></li><li><a href="/blog/性能测试实战30讲">性能测试实战30讲</a></li><li><a href="/blog/自动化测试高手课">自动化测试高手课</a></li><li><a href="/blog/软件测试52讲">软件测试52讲</a></li></ul></li><li>面试<ul><li><a href="/blog/面试现场">面试现场</a></li></ul></li><li>杂谈<ul><li><a href="/blog/超级访谈对话张雪峰">超级访谈对话张雪峰</a></li><li><a href="/blog/Git实战手册">Git实战手册</a></li><li><a href="/blog/NodeJS">NodeJS</a></li><li><a href="/blog/ReactJS">ReactJS</a></li><li><a href="/blog/UI设计">UI设计</a></li><li><a href="/blog/webpack4系列教程">webpack4系列教程</a></li><li><a href="/blog/前端知识体系">前端知识体系</a></li><li><a href="/blog/剑指offer刷题笔记">剑指offer刷题笔记</a></li><li><a href="/blog/思考与成长">思考与成长</a></li><li><a href="/blog/设计模式手册">设计模式手册</a></li></ul></li></ul><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "><button title="Dark theme" class="__dumi-default-dark-moon "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="3854" width="22" height="22"><path d="M991.816611 674.909091a69.166545 69.166545 0 0 0-51.665455-23.272727 70.795636 70.795636 0 0 0-27.438545 5.585454A415.674182 415.674182 0 0 1 754.993338 698.181818c-209.594182 0-393.472-184.785455-393.472-395.636363 0-52.363636 38.539636-119.621818 69.515637-173.614546 4.887273-8.610909 9.634909-16.756364 14.103272-24.901818A69.818182 69.818182 0 0 0 384.631156 0a70.842182 70.842182 0 0 0-27.438545 5.585455C161.678429 90.298182 14.362065 307.898182 14.362065 512c0 282.298182 238.824727 512 532.38691 512a522.286545 522.286545 0 0 0 453.957818-268.334545A69.818182 69.818182 0 0 0 991.816611 674.909091zM546.679156 954.181818c-248.785455 0-462.941091-192-462.941091-442.181818 0-186.647273 140.637091-372.829091 300.939637-442.181818-36.817455 65.629091-92.578909 151.970909-92.578909 232.727273 0 250.181818 214.109091 465.454545 462.917818 465.454545a488.331636 488.331636 0 0 0 185.181091-46.545455 453.003636 453.003636 0 0 1-393.565091 232.727273z m103.656728-669.323636l-14.266182 83.781818a34.909091 34.909091 0 0 0 50.362182 36.770909l74.775272-39.563636 74.752 39.563636a36.142545 36.142545 0 0 0 16.174546 3.956364 34.909091 34.909091 0 0 0 34.210909-40.727273l-14.289455-83.781818 60.509091-59.345455a35.025455 35.025455 0 0 0-19.223272-59.578182l-83.61891-12.101818-37.376-76.101818a34.56 34.56 0 0 0-62.254545 0l-37.376 76.101818-83.618909 12.101818a34.909091 34.909091 0 0 0-19.246546 59.578182z m70.423272-64.698182a34.280727 34.280727 0 0 0 26.135273-19.083636l14.312727-29.090909 14.336 29.090909a34.257455 34.257455 0 0 0 26.135273 19.083636l32.046546 4.887273-23.272728 22.574545a35.234909 35.234909 0 0 0-10.007272 30.952727l5.46909 32.116364-28.625454-15.127273a34.490182 34.490182 0 0 0-32.302546 0l-28.695272 15.127273 5.469091-32.116364a35.141818 35.141818 0 0 0-9.984-30.952727l-23.272728-22.574545z" p-id="3855"></path></svg></button><button title="Light theme" class="__dumi-default-dark-sun "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="4026" width="22" height="22"><path d="M915.2 476.16h-43.968c-24.704 0-44.736 16-44.736 35.84s20.032 35.904 44.736 35.904H915.2c24.768 0 44.8-16.064 44.8-35.904s-20.032-35.84-44.8-35.84zM512 265.6c-136.704 0-246.464 109.824-246.464 246.4 0 136.704 109.76 246.464 246.464 246.464S758.4 648.704 758.4 512c0-136.576-109.696-246.4-246.4-246.4z m0 425.6c-99.008 0-179.2-80.128-179.2-179.2 0-98.944 80.192-179.2 179.2-179.2S691.2 413.056 691.2 512c0 99.072-80.192 179.2-179.2 179.2zM197.44 512c0-19.84-19.136-35.84-43.904-35.84H108.8c-24.768 0-44.8 16-44.8 35.84s20.032 35.904 44.8 35.904h44.736c24.768 0 43.904-16.064 43.904-35.904zM512 198.464c19.776 0 35.84-20.032 35.84-44.8v-44.8C547.84 84.032 531.84 64 512 64s-35.904 20.032-35.904 44.8v44.8c0 24.768 16.128 44.864 35.904 44.864z m0 627.136c-19.776 0-35.904 20.032-35.904 44.8v44.736C476.096 940.032 492.16 960 512 960s35.84-20.032 35.84-44.8v-44.736c0-24.768-16.064-44.864-35.84-44.864z m329.92-592.832c17.472-17.536 20.288-43.072 6.4-57.024-14.016-14.016-39.488-11.2-57.024 6.336-4.736 4.864-26.496 26.496-31.36 31.36-17.472 17.472-20.288 43.008-6.336 57.024 13.952 14.016 39.488 11.2 57.024-6.336 4.8-4.864 26.496-26.56 31.296-31.36zM213.376 759.936c-4.864 4.8-26.56 26.624-31.36 31.36-17.472 17.472-20.288 42.944-6.4 56.96 14.016 13.952 39.552 11.2 57.024-6.336 4.8-4.736 26.56-26.496 31.36-31.36 17.472-17.472 20.288-43.008 6.336-56.96-14.016-13.952-39.552-11.072-56.96 6.336z m19.328-577.92c-17.536-17.536-43.008-20.352-57.024-6.336-14.08 14.016-11.136 39.488 6.336 57.024 4.864 4.864 26.496 26.56 31.36 31.424 17.536 17.408 43.008 20.288 56.96 6.336 14.016-14.016 11.264-39.488-6.336-57.024-4.736-4.864-26.496-26.56-31.296-31.424z m527.168 628.608c4.864 4.864 26.624 26.624 31.36 31.424 17.536 17.408 43.072 20.224 57.088 6.336 13.952-14.016 11.072-39.552-6.4-57.024-4.864-4.8-26.56-26.496-31.36-31.36-17.472-17.408-43.072-20.288-57.024-6.336-13.952 14.016-11.008 39.488 6.336 56.96z" p-id="4027"></path></svg></button><button title="Default to system" class="__dumi-default-dark-auto "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="11002" width="22" height="22"><path d="M127.658667 492.885333c0-51.882667 10.24-101.717333 30.378666-149.162666s47.786667-88.064 81.92-122.538667 75.093333-61.781333 122.538667-81.92 96.938667-30.378667 149.162667-30.378667 101.717333 10.24 149.162666 30.378667 88.405333 47.786667 122.88 81.92 61.781333 75.093333 81.92 122.538667 30.378667 96.938667 30.378667 149.162666-10.24 101.717333-30.378667 149.162667-47.786667 88.405333-81.92 122.88-75.093333 61.781333-122.88 81.92-97.28 30.378667-149.162666 30.378667-101.717333-10.24-149.162667-30.378667-88.064-47.786667-122.538667-81.92-61.781333-75.093333-81.92-122.88-30.378667-96.938667-30.378666-149.162667z m329.045333 0c0 130.048 13.994667 244.394667 41.984 343.381334h12.970667c46.762667 0 91.136-9.216 133.461333-27.306667s78.848-42.666667 109.568-73.386667 54.954667-67.242667 73.386667-109.568 27.306667-86.698667 27.306666-133.461333c0-46.421333-9.216-90.794667-27.306666-133.12s-42.666667-78.848-73.386667-109.568-67.242667-54.954667-109.568-73.386667-86.698667-27.306667-133.461333-27.306666h-11.605334c-28.672 123.562667-43.349333 237.909333-43.349333 343.722666z" p-id="11003"></path></svg></button></div></div></div><ul class="__dumi-default-menu-list"><li><a href="/blog/reactnative新架构实战课">reactnative新架构实战课</a></li><li><a href="/blog/reactnative新架构实战课/01.开篇词">01.开篇词</a><ul><li><a href="/blog/reactnative新架构实战课/01.开篇词/01"><span>开篇词｜为什么要选择 React Native 做你的跨端方案？</span></a></li></ul></li><li><a aria-current="page" class="active" href="/blog/reactnative新架构实战课/02.react-native核心基础篇">02.ReactNative核心基础篇</a><ul><li><a href="/blog/reactnative新架构实战课/02.react-native核心基础篇/01"><span>01｜学习 React Native，你需要掌握哪些知识？</span></a></li><li><a href="/blog/reactnative新架构实战课/02.react-native核心基础篇/02"><span>02｜Component：搭建静态页面的正确思路是什么？</span></a></li><li><a href="/blog/reactnative新架构实战课/02.react-native核心基础篇/03"><span>03｜Style：关于样式你需要知道的三件事</span></a></li><li><a aria-current="page" class="active" href="/blog/reactnative新架构实战课/02.react-native核心基础篇/04"><span>04｜State：如何让页面“动”起来？</span></a></li><li><a href="/blog/reactnative新架构实战课/02.react-native核心基础篇/05"><span>05｜Image：选择适合你的图片加载方式</span></a></li><li><a href="/blog/reactnative新架构实战课/02.react-native核心基础篇/06"><span>06｜Pressable：如何实现一个体验好的点按组件？</span></a></li><li><a href="/blog/reactnative新架构实战课/02.react-native核心基础篇/07"><span>07｜TextInput：如何实现一个体验好的输入框？</span></a></li><li><a href="/blog/reactnative新架构实战课/02.react-native核心基础篇/08"><span>08｜List：如何实现高性能的无限列表？</span></a></li><li><a href="/blog/reactnative新架构实战课/02.react-native核心基础篇/09"><span>09｜Fast Refresh：提高 UI 调试效率神器</span></a></li><li><a href="/blog/reactnative新架构实战课/02.react-native核心基础篇/10"><span>10｜Debug：解决 BUG 思路有哪些？</span></a></li><li><a href="/blog/reactnative新架构实战课/02.react-native核心基础篇/11"><span>11｜组件实战：如何实现瀑布流？</span></a></li><li><a href="/blog/reactnative新架构实战课/02.react-native核心基础篇/12"><span>12｜页面实战：如何搭建一个电商首页？</span></a></li><li><a href="/blog/reactnative新架构实战课/02.react-native核心基础篇/13"><span>直播加餐｜七年，我的跨端实践和探索</span></a></li></ul></li><li><a href="/blog/reactnative新架构实战课/03.react-native社区生态篇">03.ReactNative社区生态篇</a><ul><li><a href="/blog/reactnative新架构实战课/03.react-native社区生态篇/01"><span>13｜生态：React Native Awesome</span></a></li><li><a href="/blog/reactnative新架构实战课/03.react-native社区生态篇/02"><span>14｜Reanimated：如何让动画变得更流畅？</span></a></li></ul></li><li><a href="/blog/reactnative新架构实战课/summary">reactnative新架构实战课</a></li></ul></div></div><ul role="slug-list" class="__dumi-default-layout-toc"><li title="第一步：状态初选" data-depth="2"><a href="/blog/reactnative新架构实战课/02.react-native核心基础篇/04#第一步状态初选"><span>第一步：状态初选</span></a></li><li title="第二步：状态确定" data-depth="2"><a href="/blog/reactnative新架构实战课/02.react-native核心基础篇/04#第二步状态确定"><span>第二步：状态确定</span></a></li><li title="第三步：状态声明" data-depth="2"><a href="/blog/reactnative新架构实战课/02.react-native核心基础篇/04#第三步状态声明"><span>第三步：状态声明</span></a></li><li title="第四步：状态更新" data-depth="2"><a href="/blog/reactnative新架构实战课/02.react-native核心基础篇/04#第四步状态更新"><span>第四步：状态更新</span></a></li><li title="总结" data-depth="2"><a href="/blog/reactnative新架构实战课/02.react-native核心基础篇/04#总结"><span>总结</span></a></li><li title="附加材料" data-depth="2"><a href="/blog/reactnative新架构实战课/02.react-native核心基础篇/04#附加材料"><span>附加材料</span></a></li><li title="作业" data-depth="2"><a href="/blog/reactnative新架构实战课/02.react-native核心基础篇/04#作业"><span>作业</span></a></li></ul><div class="__dumi-default-layout-content"><div class="markdown"><h1 id="04state如何让页面动起来"><a aria-hidden="true" tabindex="-1" href="/blog/reactnative新架构实战课/02.react-native核心基础篇/04#04state如何让页面动起来"><span class="icon icon-link"></span></a>04｜State：如何让页面“动”起来？</h1><p>你好，我是蒋宏伟。</p><p>那么这一讲，我们来讲搭建页面的第二步，让页面“动”起来，这里的“动”说的是在不同场景下，让页面展示出不同的内容。</p><p>怎么让页面“动”起来呢？这就要用到状态 State 了。</p><p>一个页面也好，一个应用也好，只有把状态设计清楚了，程序才能写得好。讲到状态，有些人可能会说，状态不就是页面中那些会“动”的数据吗？这很简单，还有什么好讲的。</p><p>这没错，状态确实是页面中会“动”的数据，但是要把状态用好不容易，有时候容易把状态设计复杂了，不仅代码要写得更多，还容易导致程序维护起来更麻烦。</p><p>这次，我会以搭建一个会“动”的简易购物车页面为例，和你分享下我在这方面的经验。简易购物车页面是这样的：</p><p><img src="https://static001.geekbang.org/resource/image/dd/9e/dd69765bb8fcb1f9dffyy2df4d2b789e.png?wh=1000x784" alt="图片"/></p><p>它比上一讲的商品表单页多了一些交互，它的所有数据都是从网络请求过来的，这些数据包括商品名称、商品价格、商品数量，数据从网络请求回来后会展示在页面上。你可以点击页面中的加号或减号，来添加数量或减少商品数量，底部的结算总价会随着商品数量的变化而变化。</p><p>要实现这个简易购物车的静态很简单，它只包括两个组件，商品表单组件 ProductTable 和商品组件 ProductRow。完成静态页面的搭建后，接下来就<strong>要让页面“动”起来了</strong>，我把这个过程分成了 4 步来实现，状态初选、状态确定、状态声明、状态更新。</p><h2 id="第一步状态初选"><a aria-hidden="true" tabindex="-1" href="/blog/reactnative新架构实战课/02.react-native核心基础篇/04#第一步状态初选"><span class="icon icon-link"></span></a>第一步：状态初选</h2><p>状态初选说的是，先看看页面那些数据是会变化的，这些会变化的数据都可能是状态，我们先把它们找出来。</p><p>程序本身的事件和用户操作都有可能导致页面发生变化，因此我们从这两个方向来进行初选。</p><p>程序本身的事件，比如网络请求、 setTimeout，都可能导致页面发生变化。在购物车页面中，商品列表的数据是从服务端请求过来，在列表数据从服务端回来之前，页面是空白的，在请求过程中会有加载提示，请求成功后购物车页面就会展示出来，当然还要把请求失败的情况考虑进去。</p><p>所以，我圈选出来的第一条动态数据是请求过程，第二条是可能的请求失败情况；第三条是商品表单本身，第四条是所有商品的结算总价。</p><p>用户操作，比如点击、滑动、缩放，也可能导致页面发生变化。在购物车页面中，用户点击加号购物车中的商品数量会增加，点击减号数量会减少。反映商品数量的数据，就是第五条的动态数据。</p><p>现在，我已经把这 5 个初选的状态给你在图中标出来了：</p><p><img src="https://static001.geekbang.org/resource/image/43/f3/43bc848544fb40b449c097e6054ac0f3.png?wh=1920x1541" alt="图片"/></p><h2 id="第二步状态确定"><a aria-hidden="true" tabindex="-1" href="/blog/reactnative新架构实战课/02.react-native核心基础篇/04#第二步状态确定"><span class="icon icon-link"></span></a>第二步：状态确定</h2><p>有些人完成状态初选这一步后，就直接写起代码来了，一口气声明了 5 个状态，然后想办法去操作这 5 个状态如何变化。</p><p>但我的经验是，状态初选完成后，不能急着写代码，要先确定一下这些初选状态中那些是真正的状态，把其中无用的状态剔除掉，然后再去写代码。这样代码写得少、写得快，代码逻辑也会更简单一些，也更难出 BUG 一些。</p><p>这些都是我们要在状态确定这一步要做的，我总结了三条经验：</p><p>**首先，一件事情一个状态。**我发现有些同学写代码的时候，在定义请求状态时，喜欢用布尔值 isLoading 来表示空闲状态或请求中的状态，用 isError 来表示成功状态或失败状态，明明就是网络请求这一件事，却用了两个状态来表示，这就有点多余了，甚至在一些不好测试的边界条件下可能还会留坑。</p><p>这时其实只需要定义一个状态 ，代码示例如下：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">const requestStatus = {</span></div><div class="token-line"><span class="token plain">      IDLE : &#x27;IDLE&#x27;,</span></div><div class="token-line"><span class="token plain">      PENDING : &#x27;PENDING&#x27;,</span></div><div class="token-line"><span class="token plain">      SUCCESS : &#x27;SUCCESS&#x27;,</span></div><div class="token-line"><span class="token plain">      ERROR : &#x27;ERROR&#x27;,</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>这里，我定义的是一个枚举对象 requestStatus，用它来表示请求状态。这个对象有 4 个值，包括请求空闲IDLE、请求中PENDING、请求成功SUCCESS、请求失败ERROR。你看，用一个状态是不是比用两个状态更加贴合请求的实际情况呢？</p><p>**第二，重复状态不是状态。**商品组件 ProductRow 中的这个商品数量确实是一个状态，但它却和从网络请求中回来的商品表单状态重复了。从代码层面上，我们确实有办法同时保留两个状态，但这样做就绕弯子了。</p><p>更好的做法是，把这两个在不同组件之间的重复状态进行合并，去掉底层组件的重复状态，只保留顶层组件中的商品数量作为唯一的状态。</p><p>**最后，可计算出来的状态不是状态。**一个状态必须不能通过其他状态、属性或变量直接计算出来，能通过其他值计算出来的状态，都不是状态。比如，在购物车页面中，结算总价这个动态数据，是可以通过对所有商品的单价和数量的积进行求和得出来的，所以它不是状态。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">结算总价 = ∑(商品的单价 * 数量)</span></div></pre></div><p>初选的状态经过以上三步筛选之后，合并了①请求中和②请求失败，避免了重复数据③商品列表和⑤商品数量，根据已有状态推导出了④结算总价。初选状态一共 5 个，最终确定下来就只剩下网络请求状态和商品列表这两个状态了。</p><p>只有确定状态这一步做好了，你声明状态和改变状态，才会变得容易。</p><h2 id="第三步状态声明"><a aria-hidden="true" tabindex="-1" href="/blog/reactnative新架构实战课/02.react-native核心基础篇/04#第三步状态声明"><span class="icon icon-link"></span></a>第三步：状态声明</h2><p>React 提供了 useState 状态声明函数，你可以用它来管理函数组件的状态。</p><p>使用 useState 声明状态时，状态和组件是绑定的关系，useState 在哪个组件中使用，它生成的状态就属于那个组件。由于单向数据流的原因，React 把父组件的状态传给子组件只需要传一次，传给子子组件需要传递两次。</p><p>因此，你在定义状态的时候，一定要先考虑好把状态绑定到哪个组件上。我建议你用<strong>就近原则</strong>来绑定状态，就近原则的意思是哪个组件用上了状态，就优先考虑将状态绑定到该组件上，如果有多个组件使用了同一个状态，则将其绑定到最近的父组件上。这样做能让使用 props 传递状态的次数最少。</p><p>在我们的购物车案例里，你使用就近原则判断一下，<del>你</del>就可以确定购物车页面的两个状态，其实放在 ProductTable 组件中比较合适。</p><p>那接下来的问题是，状态声明代码应该如何写？</p><p>首先，我需要和你强调的是，在 React/React Native 中，所有使用 use 开头的函数，比如接下来要用到 useState 函数，它们都叫<strong>钩子函数（hook function）</strong>。和普通函数不同，你不能把钩子函数写在 if 条件判断中、事件循环中、嵌套的函数中，这些都会导致报错。</p><p>钩子函数类似于 JavaScript 的 <code>import</code> ，你最好在函数组件的顶部使用它们。</p><p>具体声明商品表单状态 products 和请求状态 requestStatus 代码是这样的：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">import React, {useState} from &#x27;react&#x27;;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    export default function ProductTable() {</span></div><div class="token-line"><span class="token plain">      const [products, setProducts] = useState([]);</span></div><div class="token-line"><span class="token plain">      const [requestStatus, setRequestStatus] = useState(&#x27;IDLE&#x27;);</span></div><div class="token-line"><span class="token plain">      // ...</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>在文件的第一行代码中，我们从 React 中引入 useState 函数，然后在函数组件 ProductTable 的顶部使用了 useState 声明了两个状态。</p><p>useState 函数的入参是状态的默认值，函数的返回值是状态和更新该状态的函数。第一次调用 useState 函数后，就生成了默认值是空数组<code>[]</code> 的商品表单状态 <code>products</code> ，以及设置该状态的函数<code>setProducts</code>。第二次调用 useState 函数后生成了默认值是字符串<code>&#x27;IDLE&#x27;</code> 的请求状态 requestStatus ，以及设置该状态的函数叫做<code>setRequestStatus</code>。</p><p>如果在 if 中使用了任何的钩子函数，就会报错：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">import React, {useState, useEffect} from &#x27;react&#x27;;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    // 错误</span></div><div class="token-line"><span class="token plain">    export default function ProductTable() {</span></div><div class="token-line"><span class="token plain">      const [requestStatus, setRequestStatus] = useState(&#x27;IDLE&#x27;);</span></div><div class="token-line"><span class="token plain">      // ...</span></div><div class="token-line"><span class="token plain">      if(requestStatus === &#x27;ERROR&#x27;) return &lt;Text&gt;网络出错了&lt;/Text&gt;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">      // 在 else 分支中，使用任何 use 开头的钩子函数，都会报错</span></div><div class="token-line"><span class="token plain">      const [products, setProducts] = useState([]);</span></div><div class="token-line"><span class="token plain">      useEffect(() =&gt; {})</span></div><div class="token-line"><span class="token plain">      </span></div><div class="token-line"><span class="token plain">      return &lt;Text&gt;购物车页面&lt;/Text&gt;</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>在这个错误示例中，我们先使用了 <code>if(requestStatus === &#x27;ERROR&#x27;)</code> 判断了网络请求状态。如果请求失败，则提示用户“网络出错了”，否则就返回真正的购物车页面。但 <code>if return</code> 后面的代码，就相当于<code>else</code>分支，在分支中使用了钩子函数，比如 useState、useEffect，代码就会报错。</p><p>出现这种报错，是因为 if 破坏了 React 的 <a target="_blank" rel="noopener noreferrer" href="https://zh-hans.reactjs.org/docs/hooks-rules.html">Hook 规则<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>。在 React 的 Hook 机制中，是把 Hook 的调用顺序作为索引，用它把 React 框架内部 state 和其函数组件的 useState 返回值中的 state 给关联起来了。当你使用了 if 的时候，就容易破坏 Hook 的调用顺序，导致 React 不能正确地将框架内部 state 与函数组件 useState 的返回值关联起来，因此 React 在执行的时候就会报错。</p><p>有时候一个函数组件很长，写到后面了，前面的一些逻辑就记不那么清楚了，如果代码写到哪就在哪儿声明一个新状态，一不小心就可能会踩坑。因此，你应该把 use 开头的钩子函数都写在组件的顶部，把 JSX 都写在函数组件的最后面，并使用 <a target="_blank" rel="noopener noreferrer" href="https://www.npmjs.com/package/eslint-plugin-react-hooks">eslint-plugin-react-hooks<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 插件来保障 Hook 规则的会被正确执行。</p><h2 id="第四步状态更新"><a aria-hidden="true" tabindex="-1" href="/blog/reactnative新架构实战课/02.react-native核心基础篇/04#第四步状态更新"><span class="icon icon-link"></span></a>第四步：状态更新</h2><p>现在，到了最后一步了。不过，这一步中涉及购物车页面业务实现逻辑的部分，我就不一一介绍了，具体实现代码我放到了附加材料中，这里我想重点和你强调的是如何更新对象类型的状态。</p><p>在 JavaScript 中的数据类型可以分为两类，对象数据类型（Objects）和原始数据类型（Primitive values），对象数据类型包括对象（Object）、数组（Array），原始数据类型有 7 种，比如数字（number）、字符串（string）等等。</p><p>在 React/React Native 中，使用这两类数据类型作为状态都是可以的，但是更新这两类状态的方法不一样，如果你没有理解清楚二者的区别，就容易出现一些低级的 BUG。</p><p>我们先来看原始数据类型的状态如何更新。</p><p>在购物车页面中，商品数量可以通过点击加号进行加一，通过点击减号减一。我们用原始数据类型数字来表示商品数量状态，其代码实现如下：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">export default function Count() {</span></div><div class="token-line"><span class="token plain">      const [count, setCount] = useState(0);</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">      return (</span></div><div class="token-line"><span class="token plain">        &lt;View&gt;</span></div><div class="token-line"><span class="token plain">          &lt;Text&gt;{count}&lt;/Text&gt;</span></div><div class="token-line"><span class="token plain">          &lt;Button title=&quot;+&quot; onPress={() =&gt; setCount(count + 1)} /&gt;</span></div><div class="token-line"><span class="token plain">          &lt;Button title=&quot;-&quot; onPress={() =&gt; setCount(count - 1 &gt;=0? count - 1: 0)} /&gt;</span></div><div class="token-line"><span class="token plain">        &lt;/View&gt;</span></div><div class="token-line"><span class="token plain">    )};</span></div></pre></div><p>你可以看到，我们使用 useState 声明了商品数量状态 count 和更新状态的函数 setCount。<br/>组件初始化时，也就是组件函数第一次调用时，商品数量状态 count 的默认值是 0，页面展示的数字就是 0.</p><p>当你点击页面中的加号（“+”）时，就会触发加号（“+”）点按组件（Button）的点击事件（onPress），此时会调用 setCount 函数更新状态。</p><p>setCount 函数的入参是 count + 1，其中 count 取的是组件第一次调用的默认值 0，0 + 1 = 1，因此新状态就是 1，之后 React/ React Native 会再调用一次组件函数，这一次调用时 useState 声明的状态 count 的值就是新状态的值 1，此时 Text 组件收到的值也是 1，最后页面刷新展示新状态 1。</p><p>第二次点击加号时，也是先更新 React/ React Native 内部的<del>新</del>状态，将它更新到 2，然后再执行一次组件函数，将内部的新状态同步给 count，最后刷新页面展示新状态 2。</p><p>以此类推，<strong>对于原始数据类型而言，调用 setCount 更新原始数据类型状态的值，页面就会发生更新。</strong></p><p>那对象和数组类型的状态如何更新呢？</p><p>我们先声明一个对象状态和一个数组状态，代码如下：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">const [countObject, setCountObject] = useState({num: 0});</span></div><div class="token-line"><span class="token plain">    const [countArray, setCountArray] = useState([0]);</span></div></pre></div><p>这段代码中，调用了两次 useState，声明一个对象状态 countObject 和一个数组状态 countArray，以及对应的状态更新函数。</p><p>理论上，你可以直接改变对象状态或数组状态的值，再调用状态更新函数，代码如下：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">countObject.num++;</span></div><div class="token-line"><span class="token plain">    setCountObject(countObject)</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    countArray[0]++;</span></div><div class="token-line"><span class="token plain">    setCountArray(countArray)</span></div></pre></div><p>但是你试过后会发现，调用状态更新函数后，页面什么变化都没有，这是为什么呢？<br/>弄清楚了对象数据类型（Objects）和原始数据类型的区别后，你就明白了。我给你举个例子：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">const countObject = {num: 0}</span></div><div class="token-line"><span class="token plain">    countObject.num++;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    countObject.num === countObject.num // false</span></div><div class="token-line"><span class="token plain">    countObject === countObject // true</span></div><div class="token-line"><span class="token plain">    setCountObject(countObject) // 不更新</span></div></pre></div><p>你看，当你更新 countObject.num 时，countObject.num 确实更新了，但是 countObject 的引用并没有更新，所以调用 setCountObject 更新状态时，页面没有任何变化。</p><p>这是因为，对象它是一种复合数据类型，它内部的值是可变的（mutable），但它的引用是不可变了（immutable），你更新了对象的内部值后，它的引用并没有发生变化。</p><p>那状态是对象或数组时，应该怎么更新呢？</p><p>业内也有形似 mutable 的更新方案 useImmer，可以通过直接修改变量的值来更新状态。但其底层原理也是，新建一个对象或数组传给状态更新函数，让状态更新函数知道对象或数组确实发生了变化，这时 React/React Native 框架才会帮你更新页面。</p><p>这里，我用的也是直接新建对象、新建数组的方式，代码如下：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">setCountObject({...countObject, num: countObject.num+1});</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    const newCountArray = [...newCountArray]</span></div><div class="token-line"><span class="token plain">    newCountArray[0]++;</span></div><div class="token-line"><span class="token plain">    setCountArray(newCountArray)</span></div></pre></div><p>你可以看到，对于对象状态的更新我是这么处理的，我先创建了一个新对象<code>{<!-- -->}</code>，然后用<code>...</code>的解构的方式将老对象 countObject 的内部值重新赋值给了新对象<code>{<!-- -->}</code>，再指定<code>num</code>属性进行了复写。对于数组状态的更新也是类似的，你可以自己试试。</p><h2 id="总结"><a aria-hidden="true" tabindex="-1" href="/blog/reactnative新架构实战课/02.react-native核心基础篇/04#总结"><span class="icon icon-link"></span></a>总结</h2><p>这一讲，我们完成搭建页面的第二步：让页面“动”起来。让页面“动”起来，就要用到状态，我们这一讲的具体实现分为 4 个步骤，状态初选、状态确定、状态声明、状态更新。</p><ul><li>状态初选，就是把设计稿中的那些会“动”的数据先选出来；</li><li>状态确定，就是合并同类状态、删除无用状态和衍生状态；</li><li>状态声明，在当前的初学阶段，只需要学会使用 useState 来声明组件状态即可；</li><li>状态更新是最后一步。交互事件和程序事件会触发状态的更新，但状态更新函数并不会帮我们自动合并上一个状态，因此在处理对象状态和数组状态时，每次更新时必须新建一个完整的对象或数组。</li></ul><p>行军作战是兵马未动粮草先行，讲究的是谋而后动。搭建页面、开发组件也是如此，我们也要<strong>代码未动构思先行</strong>，先把组件状态设计好了，简单即美，要是没想清楚弄复杂了，后面填坑成本会很高。</p><h2 id="附加材料"><a aria-hidden="true" tabindex="-1" href="/blog/reactnative新架构实战课/02.react-native核心基础篇/04#附加材料"><span class="icon icon-link"></span></a>附加材料</h2><ol><li>再次强调，学习 React 最好的材料就是 React 新官网，我推荐你去读一读<a target="_blank" rel="noopener noreferrer" href="https://beta.reactjs.org/learn/reacting-to-input-with-state">《如何使用状态响应用户的输入时间》<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>、<a target="_blank" rel="noopener noreferrer" href="https://beta.reactjs.org/learn/updating-objects-in-state">《更新状态对象》<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>和<a target="_blank" rel="noopener noreferrer" href="https://beta.reactjs.org/learn/updating-arrays-in-state">《更新状态数组》<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>。</li><li>实现购物车页面的完整代码，我放在了<a target="_blank" rel="noopener noreferrer" href="https://github.com/jiangleo/react-native-classroom/tree/main/src/04_State">GitHub<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>上。</li></ol><h2 id="作业"><a aria-hidden="true" tabindex="-1" href="/blog/reactnative新架构实战课/02.react-native核心基础篇/04#作业"><span class="icon icon-link"></span></a>作业</h2><ol><li>请你实现一个井字棋。井字棋的规则和五子棋类似，两人在 3 * 3 格子上进行连珠游戏，任意 3 个标记形成一条直线，则为获胜。在写之前，推荐你先玩一下这个井字棋，了解一下<a target="_blank" rel="noopener noreferrer" href="https://codepen.io/gaearon/pen/aWWQOG?editors=0010">井字棋的最终效果<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>。</li><li>请你思考一下实现一个井字棋，最少需要声明几个状态？</li></ol><p><img src="https://static001.geekbang.org/resource/image/59/e0/599257d6cc84ceda0fc5ebe8174af7e0.png?wh=474x347" alt="图片"/></p><p>欢迎在留言区分享你的想法。下一节课我们将来讨论React Native中图片组件的用法和最佳实践，你可以做些准备。我是蒋宏伟，咱们下节课见。</p></div><div class="__dumi-default-layout-footer-meta"><a target="_blank" rel="noopener noreferrer" href="https://github.com/GGwujun/blog/edit/master/docs/reactnative新架构实战课/02.ReactNative核心基础篇/04.md">在 GitHub 上编辑此页<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a><span data-updated-text="最后更新时间：">5/2/2022 10:56:47</span></div></div></div></div>
	<script>
  window.g_useSSR = true;
  window.g_initialProps = {};
	</script>

    <script>
      (function () {
        if (!location.port) {
          (function (i, s, o, g, r, a, m) {
            i["GoogleAnalyticsObject"] = r;
            (i[r] =
              i[r] ||
              function () {
                (i[r].q = i[r].q || []).push(arguments);
              }),
              (i[r].l = 1 * new Date());
            (a = s.createElement(o)), (m = s.getElementsByTagName(o)[0]);
            a.async = 1;
            a.src = g;
            m.parentNode.insertBefore(a, m);
          })(
            window,
            document,
            "script",
            "//www.google-analytics.com/analytics.js",
            "ga"
          );
          ga("create", "UA-149864185-1", "auto");
          ga("send", "pageview");
        }
      })();
    </script>
    <script src="/blog/umi.js"></script>
  </body>
</html>
