<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no"
    />
    <link rel="shortcut icon" type="image/x-icon" href="/logo.png" />
    <link rel="stylesheet" href="/blog/umi.css" />
    <script>
      window.routerBase = "/blog";
    </script>
    <script>
      //! umi version: 3.5.17
    </script>
    <script>
      !(function () {
        var e = localStorage.getItem("dumi:prefers-color"),
          t = window.matchMedia("(prefers-color-scheme: dark)").matches,
          r = ["light", "dark", "auto"];
        document.documentElement.setAttribute(
          "data-prefers-color",
          e === r[2] ? (t ? r[1] : r[0]) : r.indexOf(e) > -1 ? e : r[0]
        );
      })();
    </script>
    <title>17 | 如何实现一个 WebAssembly 在线多媒体处理应用（三）？</title>
  </head>
  <body>
    <div id="root"><div class="__dumi-default-layout" data-route="/webassembly入门/04.实战篇/03" data-show-sidemenu="true" data-show-slugs="true" data-site-mode="true" data-gapless="false"><div class="__dumi-default-navbar" data-mode="site"><button class="__dumi-default-navbar-toggle"></button><a class="__dumi-default-navbar-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog/">大师兄</a><nav><div class="__dumi-default-search"><input type="search" class="__dumi-default-search-input" value=""/><ul></ul></div><span>计算机基础<ul><li><a href="/blog/编译原理之美">编译原理之美</a></li><li><a href="/blog/编译原理实战">编译原理实战</a></li><li><a href="/blog/深入浅出计算机组成原理">深入浅出计算机组成原理</a></li><li><a href="/blog/详解http">详解http</a></li><li><a href="/blog/计算机网络通关29讲">计算机网络通关29讲</a></li><li><a href="/blog/网络排查案例课">网络排查案例课</a></li><li><a href="/blog/linux操作系统">linux操作系统</a></li><li><a href="/blog/linux性能优化实战">linux性能优化实战</a></li><li><a href="/blog/程序员数学基础">程序员数学基础</a></li><li><a href="/blog/趣谈网络协议">趣谈网络协议</a></li><li><a href="/blog/操作系统实战">操作系统实战</a></li><li><a href="/blog/软件工程之美">软件工程之美</a></li><li><a href="/blog/sql必知必会">sql必知必会</a></li><li><a href="/blog/操作系统实战45讲">操作系统实战45讲</a></li><li><a href="/blog/网络编程实战">网络编程实战</a></li></ul></span><span>算法<ul><li><a href="/blog/常用算法25讲">常用算法25讲</a></li><li><a href="/blog/数据结构与算法之美">数据结构与算法之美</a></li><li><a href="/blog/业务开发算法50讲">业务开发算法50讲</a></li><li><a href="/blog/动态规划面试宝典">动态规划面试宝典</a></li></ul></span><span>前端开发<ul><li><a href="/blog/浏览器工作原理与实践">浏览器工作原理与实践</a></li><li><a href="/blog/新时代产品经理进阶之路">新时代产品经理进阶之路</a></li><li><a href="/blog/全栈工程师修炼指南">全栈工程师修炼指南</a></li><li><a href="/blog/flutter核心技术与实战">flutter核心技术与实战</a></li><li><a href="/blog/java-script核心原理解析">java-script核心原理解析</a></li><li><a href="/blog/说透低代码">说透低代码</a></li><li><a href="/blog/nodejs应用开发实战">nodejs应用开发实战</a></li><li><a href="/blog/反爬虫兵法演绎20讲">反爬虫兵法演绎20讲</a></li><li><a href="/blog/reactnative新架构实战课">reactnative新架构实战课</a></li><li><a href="/blog/正则表达式入门">正则表达式入门</a></li><li><a href="/blog/重学前端">重学前端</a></li><li><a href="/blog/serverless入门课">serverless入门课</a></li><li><a href="/blog/type-script入门实战笔记">type-script入门实战笔记</a></li><li><a href="/blog/图解googlev8">图解googlev8</a></li><li><a href="/blog/vue3源码分析">vue3源码分析</a></li><li><a href="/blog/玩转Vue3全家桶">玩转Vue3全家桶</a></li><li><a aria-current="page" class="active" href="/blog/webassembly入门">webassembly入门</a></li><li><a href="/blog/手把手带你写一个Web框架">手把手带你写一个Web框架</a></li><li><a href="/blog/web漏洞挖掘实战">web漏洞挖掘实战</a></li><li><a href="/blog/跟月影学可视化">跟月影学可视化</a></li><li><a href="/blog/搞定音频技术">搞定音频技术</a></li><li><a href="/blog/攻克视频技术">攻克视频技术</a></li></ul></span><span>前端工程化<ul><li><a href="/blog/logger">logger</a></li><li><a href="/blog/webpack">webpack</a></li><li><a href="/blog/webpackChain">webpackChain</a></li></ul></span><span>前端性能优化<ul><li><a href="/blog/react性能调优">react性能调优</a></li></ul></span><span>软件测试<ul><li><a href="/blog/全链路压测实战30讲">全链路压测实战30讲</a></li><li><a href="/blog/性能测试实战30讲">性能测试实战30讲</a></li><li><a href="/blog/自动化测试高手课">自动化测试高手课</a></li><li><a href="/blog/软件测试52讲">软件测试52讲</a></li></ul></span><span>面试<ul><li><a href="/blog/面试现场">面试现场</a></li></ul></span><span>杂谈<ul><li><a href="/blog/超级访谈对话张雪峰">超级访谈对话张雪峰</a></li><li><a href="/blog/Git实战手册">Git实战手册</a></li><li><a href="/blog/NodeJS">NodeJS</a></li><li><a href="/blog/ReactJS">ReactJS</a></li><li><a href="/blog/UI设计">UI设计</a></li><li><a href="/blog/webpack4系列教程">webpack4系列教程</a></li><li><a href="/blog/前端知识体系">前端知识体系</a></li><li><a href="/blog/剑指offer刷题笔记">剑指offer刷题笔记</a></li><li><a href="/blog/思考与成长">思考与成长</a></li><li><a href="/blog/设计模式手册">设计模式手册</a></li></ul></span><div class="__dumi-default-navbar-tool"><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "></div></div></div></nav></div><div class="__dumi-default-menu" data-mode="site"><div class="__dumi-default-menu-inner"><div class="__dumi-default-menu-header"><a class="__dumi-default-menu-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog/"></a><h1>大师兄</h1><p></p></div><div class="__dumi-default-menu-mobile-area"><ul class="__dumi-default-menu-nav-list"><li>计算机基础<ul><li><a href="/blog/编译原理之美">编译原理之美</a></li><li><a href="/blog/编译原理实战">编译原理实战</a></li><li><a href="/blog/深入浅出计算机组成原理">深入浅出计算机组成原理</a></li><li><a href="/blog/详解http">详解http</a></li><li><a href="/blog/计算机网络通关29讲">计算机网络通关29讲</a></li><li><a href="/blog/网络排查案例课">网络排查案例课</a></li><li><a href="/blog/linux操作系统">linux操作系统</a></li><li><a href="/blog/linux性能优化实战">linux性能优化实战</a></li><li><a href="/blog/程序员数学基础">程序员数学基础</a></li><li><a href="/blog/趣谈网络协议">趣谈网络协议</a></li><li><a href="/blog/操作系统实战">操作系统实战</a></li><li><a href="/blog/软件工程之美">软件工程之美</a></li><li><a href="/blog/sql必知必会">sql必知必会</a></li><li><a href="/blog/操作系统实战45讲">操作系统实战45讲</a></li><li><a href="/blog/网络编程实战">网络编程实战</a></li></ul></li><li>算法<ul><li><a href="/blog/常用算法25讲">常用算法25讲</a></li><li><a href="/blog/数据结构与算法之美">数据结构与算法之美</a></li><li><a href="/blog/业务开发算法50讲">业务开发算法50讲</a></li><li><a href="/blog/动态规划面试宝典">动态规划面试宝典</a></li></ul></li><li>前端开发<ul><li><a href="/blog/浏览器工作原理与实践">浏览器工作原理与实践</a></li><li><a href="/blog/新时代产品经理进阶之路">新时代产品经理进阶之路</a></li><li><a href="/blog/全栈工程师修炼指南">全栈工程师修炼指南</a></li><li><a href="/blog/flutter核心技术与实战">flutter核心技术与实战</a></li><li><a href="/blog/java-script核心原理解析">java-script核心原理解析</a></li><li><a href="/blog/说透低代码">说透低代码</a></li><li><a href="/blog/nodejs应用开发实战">nodejs应用开发实战</a></li><li><a href="/blog/反爬虫兵法演绎20讲">反爬虫兵法演绎20讲</a></li><li><a href="/blog/reactnative新架构实战课">reactnative新架构实战课</a></li><li><a href="/blog/正则表达式入门">正则表达式入门</a></li><li><a href="/blog/重学前端">重学前端</a></li><li><a href="/blog/serverless入门课">serverless入门课</a></li><li><a href="/blog/type-script入门实战笔记">type-script入门实战笔记</a></li><li><a href="/blog/图解googlev8">图解googlev8</a></li><li><a href="/blog/vue3源码分析">vue3源码分析</a></li><li><a href="/blog/玩转Vue3全家桶">玩转Vue3全家桶</a></li><li><a aria-current="page" class="active" href="/blog/webassembly入门">webassembly入门</a></li><li><a href="/blog/手把手带你写一个Web框架">手把手带你写一个Web框架</a></li><li><a href="/blog/web漏洞挖掘实战">web漏洞挖掘实战</a></li><li><a href="/blog/跟月影学可视化">跟月影学可视化</a></li><li><a href="/blog/搞定音频技术">搞定音频技术</a></li><li><a href="/blog/攻克视频技术">攻克视频技术</a></li></ul></li><li>前端工程化<ul><li><a href="/blog/logger">logger</a></li><li><a href="/blog/webpack">webpack</a></li><li><a href="/blog/webpackChain">webpackChain</a></li></ul></li><li>前端性能优化<ul><li><a href="/blog/react性能调优">react性能调优</a></li></ul></li><li>软件测试<ul><li><a href="/blog/全链路压测实战30讲">全链路压测实战30讲</a></li><li><a href="/blog/性能测试实战30讲">性能测试实战30讲</a></li><li><a href="/blog/自动化测试高手课">自动化测试高手课</a></li><li><a href="/blog/软件测试52讲">软件测试52讲</a></li></ul></li><li>面试<ul><li><a href="/blog/面试现场">面试现场</a></li></ul></li><li>杂谈<ul><li><a href="/blog/超级访谈对话张雪峰">超级访谈对话张雪峰</a></li><li><a href="/blog/Git实战手册">Git实战手册</a></li><li><a href="/blog/NodeJS">NodeJS</a></li><li><a href="/blog/ReactJS">ReactJS</a></li><li><a href="/blog/UI设计">UI设计</a></li><li><a href="/blog/webpack4系列教程">webpack4系列教程</a></li><li><a href="/blog/前端知识体系">前端知识体系</a></li><li><a href="/blog/剑指offer刷题笔记">剑指offer刷题笔记</a></li><li><a href="/blog/思考与成长">思考与成长</a></li><li><a href="/blog/设计模式手册">设计模式手册</a></li></ul></li></ul><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "><button title="Dark theme" class="__dumi-default-dark-moon "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="3854" width="22" height="22"><path d="M991.816611 674.909091a69.166545 69.166545 0 0 0-51.665455-23.272727 70.795636 70.795636 0 0 0-27.438545 5.585454A415.674182 415.674182 0 0 1 754.993338 698.181818c-209.594182 0-393.472-184.785455-393.472-395.636363 0-52.363636 38.539636-119.621818 69.515637-173.614546 4.887273-8.610909 9.634909-16.756364 14.103272-24.901818A69.818182 69.818182 0 0 0 384.631156 0a70.842182 70.842182 0 0 0-27.438545 5.585455C161.678429 90.298182 14.362065 307.898182 14.362065 512c0 282.298182 238.824727 512 532.38691 512a522.286545 522.286545 0 0 0 453.957818-268.334545A69.818182 69.818182 0 0 0 991.816611 674.909091zM546.679156 954.181818c-248.785455 0-462.941091-192-462.941091-442.181818 0-186.647273 140.637091-372.829091 300.939637-442.181818-36.817455 65.629091-92.578909 151.970909-92.578909 232.727273 0 250.181818 214.109091 465.454545 462.917818 465.454545a488.331636 488.331636 0 0 0 185.181091-46.545455 453.003636 453.003636 0 0 1-393.565091 232.727273z m103.656728-669.323636l-14.266182 83.781818a34.909091 34.909091 0 0 0 50.362182 36.770909l74.775272-39.563636 74.752 39.563636a36.142545 36.142545 0 0 0 16.174546 3.956364 34.909091 34.909091 0 0 0 34.210909-40.727273l-14.289455-83.781818 60.509091-59.345455a35.025455 35.025455 0 0 0-19.223272-59.578182l-83.61891-12.101818-37.376-76.101818a34.56 34.56 0 0 0-62.254545 0l-37.376 76.101818-83.618909 12.101818a34.909091 34.909091 0 0 0-19.246546 59.578182z m70.423272-64.698182a34.280727 34.280727 0 0 0 26.135273-19.083636l14.312727-29.090909 14.336 29.090909a34.257455 34.257455 0 0 0 26.135273 19.083636l32.046546 4.887273-23.272728 22.574545a35.234909 35.234909 0 0 0-10.007272 30.952727l5.46909 32.116364-28.625454-15.127273a34.490182 34.490182 0 0 0-32.302546 0l-28.695272 15.127273 5.469091-32.116364a35.141818 35.141818 0 0 0-9.984-30.952727l-23.272728-22.574545z" p-id="3855"></path></svg></button><button title="Light theme" class="__dumi-default-dark-sun "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="4026" width="22" height="22"><path d="M915.2 476.16h-43.968c-24.704 0-44.736 16-44.736 35.84s20.032 35.904 44.736 35.904H915.2c24.768 0 44.8-16.064 44.8-35.904s-20.032-35.84-44.8-35.84zM512 265.6c-136.704 0-246.464 109.824-246.464 246.4 0 136.704 109.76 246.464 246.464 246.464S758.4 648.704 758.4 512c0-136.576-109.696-246.4-246.4-246.4z m0 425.6c-99.008 0-179.2-80.128-179.2-179.2 0-98.944 80.192-179.2 179.2-179.2S691.2 413.056 691.2 512c0 99.072-80.192 179.2-179.2 179.2zM197.44 512c0-19.84-19.136-35.84-43.904-35.84H108.8c-24.768 0-44.8 16-44.8 35.84s20.032 35.904 44.8 35.904h44.736c24.768 0 43.904-16.064 43.904-35.904zM512 198.464c19.776 0 35.84-20.032 35.84-44.8v-44.8C547.84 84.032 531.84 64 512 64s-35.904 20.032-35.904 44.8v44.8c0 24.768 16.128 44.864 35.904 44.864z m0 627.136c-19.776 0-35.904 20.032-35.904 44.8v44.736C476.096 940.032 492.16 960 512 960s35.84-20.032 35.84-44.8v-44.736c0-24.768-16.064-44.864-35.84-44.864z m329.92-592.832c17.472-17.536 20.288-43.072 6.4-57.024-14.016-14.016-39.488-11.2-57.024 6.336-4.736 4.864-26.496 26.496-31.36 31.36-17.472 17.472-20.288 43.008-6.336 57.024 13.952 14.016 39.488 11.2 57.024-6.336 4.8-4.864 26.496-26.56 31.296-31.36zM213.376 759.936c-4.864 4.8-26.56 26.624-31.36 31.36-17.472 17.472-20.288 42.944-6.4 56.96 14.016 13.952 39.552 11.2 57.024-6.336 4.8-4.736 26.56-26.496 31.36-31.36 17.472-17.472 20.288-43.008 6.336-56.96-14.016-13.952-39.552-11.072-56.96 6.336z m19.328-577.92c-17.536-17.536-43.008-20.352-57.024-6.336-14.08 14.016-11.136 39.488 6.336 57.024 4.864 4.864 26.496 26.56 31.36 31.424 17.536 17.408 43.008 20.288 56.96 6.336 14.016-14.016 11.264-39.488-6.336-57.024-4.736-4.864-26.496-26.56-31.296-31.424z m527.168 628.608c4.864 4.864 26.624 26.624 31.36 31.424 17.536 17.408 43.072 20.224 57.088 6.336 13.952-14.016 11.072-39.552-6.4-57.024-4.864-4.8-26.56-26.496-31.36-31.36-17.472-17.408-43.072-20.288-57.024-6.336-13.952 14.016-11.008 39.488 6.336 56.96z" p-id="4027"></path></svg></button><button title="Default to system" class="__dumi-default-dark-auto "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="11002" width="22" height="22"><path d="M127.658667 492.885333c0-51.882667 10.24-101.717333 30.378666-149.162666s47.786667-88.064 81.92-122.538667 75.093333-61.781333 122.538667-81.92 96.938667-30.378667 149.162667-30.378667 101.717333 10.24 149.162666 30.378667 88.405333 47.786667 122.88 81.92 61.781333 75.093333 81.92 122.538667 30.378667 96.938667 30.378667 149.162666-10.24 101.717333-30.378667 149.162667-47.786667 88.405333-81.92 122.88-75.093333 61.781333-122.88 81.92-97.28 30.378667-149.162666 30.378667-101.717333-10.24-149.162667-30.378667-88.064-47.786667-122.538667-81.92-61.781333-75.093333-81.92-122.88-30.378667-96.938667-30.378666-149.162667z m329.045333 0c0 130.048 13.994667 244.394667 41.984 343.381334h12.970667c46.762667 0 91.136-9.216 133.461333-27.306667s78.848-42.666667 109.568-73.386667 54.954667-67.242667 73.386667-109.568 27.306667-86.698667 27.306666-133.461333c0-46.421333-9.216-90.794667-27.306666-133.12s-42.666667-78.848-73.386667-109.568-67.242667-54.954667-109.568-73.386667-86.698667-27.306667-133.461333-27.306666h-11.605334c-28.672 123.562667-43.349333 237.909333-43.349333 343.722666z" p-id="11003"></path></svg></button></div></div></div><ul class="__dumi-default-menu-list"><li><a href="/blog/webassembly入门">webassembly入门</a></li><li><a href="/blog/webassembly入门/01.课前必读">01.课前必读</a><ul><li><a href="/blog/webassembly入门/01.课前必读/01"><span>开篇词 | 我们为什么要了解 WebAssembly？</span></a></li><li><a href="/blog/webassembly入门/01.课前必读/02"><span>01 | 基础篇：学习此课程你需要了解哪些基础知识？</span></a></li><li><a href="/blog/webassembly入门/01.课前必读/03"><span>02 | 历史篇：为什么会有 WebAssembly 这样一门技术？</span></a></li></ul></li><li><a href="/blog/webassembly入门/02.核心原理篇">02.核心原理篇</a><ul><li><a href="/blog/webassembly入门/02.核心原理篇/01"><span>03 | WebAssembly 是一门新的编程语言吗？</span></a></li><li><a href="/blog/webassembly入门/02.核心原理篇/02"><span>04 | WebAssembly 模块的基本组成结构到底有多简单？</span></a></li><li><a href="/blog/webassembly入门/02.核心原理篇/03"><span>05 | 二进制编码：WebAssembly 微观世界的基本数据规则是什么？</span></a></li><li><a href="/blog/webassembly入门/02.核心原理篇/04"><span>06 | WAT：如何让一个 WebAssembly 二进制模块的内容易于解读？</span></a></li><li><a href="/blog/webassembly入门/02.核心原理篇/05"><span>07 | WASI：你听说过 WebAssembly 操作系统接口吗？</span></a></li><li><a href="/blog/webassembly入门/02.核心原理篇/06"><span>08 | API：在 WebAssembly MVP 标准下你能做到哪些事？</span></a></li></ul></li><li><a href="/blog/webassembly入门/03.应用篇">03.应用篇</a><ul><li><a href="/blog/webassembly入门/03.应用篇/01"><span>09 | WebAssembly 能够为 Web 前端框架赋能吗？</span></a></li><li><a href="/blog/webassembly入门/03.应用篇/02"><span>10 | 有哪些已经投入生产的 WebAssembly 真实案例？</span></a></li><li><a href="/blog/webassembly入门/03.应用篇/03"><span>11 | WebAssembly 在物联网、多媒体与云技术方面有哪些创新实践？</span></a></li><li><a href="/blog/webassembly入门/03.应用篇/04"><span>12 | 有哪些优秀的 WebAssembly 编译器与运行时？</span></a></li><li><a href="/blog/webassembly入门/03.应用篇/05"><span>13 | LLVM：如何将自定义的语言编译到 WebAssembly？</span></a></li><li><a href="/blog/webassembly入门/03.应用篇/06"><span>14 | 有哪些正在行进中的 WebAssembly Post-MVP 提案？</span></a></li></ul></li><li><a aria-current="page" class="active" href="/blog/webassembly入门/04.实战篇">04.实战篇</a><ul><li><a href="/blog/webassembly入门/04.实战篇/01"><span>15 | 如何实现一个 WebAssembly 在线多媒体处理应用（一）？</span></a></li><li><a href="/blog/webassembly入门/04.实战篇/02"><span>16 | 如何实现一个 WebAssembly 在线多媒体处理应用（二）？</span></a></li><li><a aria-current="page" class="active" href="/blog/webassembly入门/04.实战篇/03"><span>17 | 如何实现一个 WebAssembly 在线多媒体处理应用（三）？</span></a></li><li><a href="/blog/webassembly入门/04.实战篇/04"><span>18 | 如何进行 Wasm 应用的调试与分析？</span></a></li><li><a href="/blog/webassembly入门/04.实战篇/05"><span>19 | 如何应用 WASI 及其相关生态？</span></a></li><li><a href="/blog/webassembly入门/04.实战篇/06"><span>20 | 总结与答疑</span></a></li></ul></li><li><a href="/blog/webassembly入门/05.结束语">05.结束语</a><ul><li><a href="/blog/webassembly入门/05.结束语/01"><span>结束语 | WebAssembly，未来已来</span></a></li></ul></li><li><a href="/blog/webassembly入门/06.测试题">06.测试题</a><ul><li><a href="/blog/webassembly入门/06.测试题/01"><span>期末测试｜这些 WebAssembly 的问题，你都掌握了吗？</span></a></li></ul></li><li><a href="/blog/webassembly入门/summary">webassembly入门</a></li></ul></div></div><ul role="slug-list" class="__dumi-default-layout-toc"><li title="编写 C/C++ 函数源码" data-depth="2"><a href="/blog/webassembly入门/04.实战篇/03#编写-cc-函数源码"><span>编写 C/C++ 函数源码</span></a></li><li title="使用 Emscripten 进行编译" data-depth="2"><a href="/blog/webassembly入门/04.实战篇/03#使用-emscripten-进行编译"><span>使用 Emscripten 进行编译</span></a></li><li title="整合上下文资源" data-depth="2"><a href="/blog/webassembly入门/04.实战篇/03#整合上下文资源"><span>整合上下文资源</span></a></li><li title="性能对比" data-depth="2"><a href="/blog/webassembly入门/04.实战篇/03#性能对比"><span>性能对比</span></a></li><li title="总结" data-depth="2"><a href="/blog/webassembly入门/04.实战篇/03#总结"><span>总结</span></a></li><li title="课后练习" data-depth="2"><a href="/blog/webassembly入门/04.实战篇/03#课后练习"><span>课后练习</span></a></li></ul><div class="__dumi-default-layout-content"><div class="markdown"><h1 id="17--如何实现一个-webassembly-在线多媒体处理应用三"><a aria-hidden="true" tabindex="-1" href="/blog/webassembly入门/04.实战篇/03#17--如何实现一个-webassembly-在线多媒体处理应用三"><span class="icon icon-link"></span></a>17 | 如何实现一个 WebAssembly 在线多媒体处理应用（三）？</h1><p>你好，我是于航。</p><p>在上一节课中，我们已经完成了本次实践项目的其中一个核心部分，也就是由 JavaScript 实现的滤镜函数。并且还同时完成了整个 Web 应用与用户的 UI 交互控制部分、视频图像的渲染和绘制逻辑，以及帧率计算逻辑及显示逻辑。</p><p>在这节课里，我们将一起来完成整个应用的另外一个核心部分，同时也是整个实践的主角。让我们来看看，相较于 JavaScript 滤镜函数，由 Wasm 实现的同版本滤镜函数会带来怎样的性能提升呢？</p><h2 id="编写-cc-函数源码"><a aria-hidden="true" tabindex="-1" href="/blog/webassembly入门/04.实战篇/03#编写-cc-函数源码"><span class="icon icon-link"></span></a>编写 C/C++ 函数源码</h2><p>首先，为了能够得到对应 Wasm 字节码格式的函数实现，我们需要首先准备由 C/C++ 等高级语言编写的源代码，然后再通过 Emscripten 将其编译到 Wasm 格式。这部分代码的主要逻辑，与上一篇中的 JavaScript 版本滤镜函数其实现逻辑基本相同。代码如下所示：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// dip.cc</span></div><div class="token-line"><span class="token plain">    // 引入必要的头文件；</span></div><div class="token-line"><span class="token plain">    #include &lt;emscripten.h&gt;</span></div><div class="token-line"><span class="token plain">    #include &lt;cmath&gt;</span></div><div class="token-line"><span class="token plain">    // 宏常量定义，表示卷积核矩阵的高和宽；</span></div><div class="token-line"><span class="token plain">    #define KH 3</span></div><div class="token-line"><span class="token plain">    #define KW 3</span></div><div class="token-line"><span class="token plain">    // 声明两个数组，分别用于存放卷积核数据与每一帧对应的像素点数据；</span></div><div class="token-line"><span class="token plain">    char kernel[KH][KW];</span></div><div class="token-line"><span class="token plain">    unsigned char data[921600];</span></div><div class="token-line"><span class="token plain">    // 将被导出的函数，放置在 extern &quot;C&quot; 中防止 Name Mangling；</span></div><div class="token-line"><span class="token plain">    extern &quot;C&quot; {</span></div><div class="token-line"><span class="token plain">      // 获取卷积核数组的首地址；</span></div><div class="token-line"><span class="token plain">      EMSCRIPTEN_KEEPALIVE auto* cppGetkernelPtr() { return kernel; }</span></div><div class="token-line"><span class="token plain">      // 获取帧像素数组的首地址；</span></div><div class="token-line"><span class="token plain">      EMSCRIPTEN_KEEPALIVE auto* cppGetDataPtr() { return data; }</span></div><div class="token-line"><span class="token plain">      // 滤镜函数；</span></div><div class="token-line"><span class="token plain">      EMSCRIPTEN_KEEPALIVE void cppConvFilter(</span></div><div class="token-line"><span class="token plain">        int width, </span></div><div class="token-line"><span class="token plain">        int height,</span></div><div class="token-line"><span class="token plain">        int divisor) {</span></div><div class="token-line"><span class="token plain">        const int half = std::floor(KH / 2);</span></div><div class="token-line"><span class="token plain">        for (int y = half; y &lt; height - half; ++y) {</span></div><div class="token-line"><span class="token plain">          for (int x = half; x &lt; width - half; ++x) {</span></div><div class="token-line"><span class="token plain">            int px = (y * width + x) * 4;</span></div><div class="token-line"><span class="token plain">            int r = 0, g = 0, b = 0;</span></div><div class="token-line"><span class="token plain">            for (int cy = 0; cy &lt; KH; ++cy) {</span></div><div class="token-line"><span class="token plain">              for (int cx = 0; cx &lt; KW; ++cx) {</span></div><div class="token-line"><span class="token plain">                const int cpx = ((y + (cy - half)) * width + (x + (cx - half))) * 4;</span></div><div class="token-line"><span class="token plain">                r += data[cpx + 0] * kernel[cy][cx];</span></div><div class="token-line"><span class="token plain">                g += data[cpx + 1] * kernel[cy][cx];</span></div><div class="token-line"><span class="token plain">                b += data[cpx + 2] * kernel[cy][cx];</span></div><div class="token-line"><span class="token plain">              }</span></div><div class="token-line"><span class="token plain">            }                 </span></div><div class="token-line"><span class="token plain">            data[px + 0] = ((r / divisor) &gt; 255) ? 255 : ((r / divisor) &lt; 0) ? 0 : r / divisor;</span></div><div class="token-line"><span class="token plain">            data[px + 1] = ((g / divisor) &gt; 255) ? 255 : ((g / divisor) &lt; 0) ? 0 : g / divisor;</span></div><div class="token-line"><span class="token plain">            data[px + 2] = ((b / divisor) &gt; 255) ? 255 : ((b / divisor) &lt; 0) ? 0 : b / divisor;</span></div><div class="token-line"><span class="token plain">          }</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">      }</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>在这段代码中，我们将定义的所有函数均以 “cpp” 作为其前缀来命名，表明这个函数的实际定义来自于对应的 C/C++ 代码实现。其中，“cppConvFilter” 函数为主要的滤镜计算函数。在该函数中，我们保持着几乎与上一节课中，JavaScript 版滤镜函数同样的实现逻辑。</p><p>在代码的开始，我们首先以 “#include” 的方式，包含了很多需要使用到的 C/C++ 头文件。其中 “emscripten.h” 头文件便由 Emscripten 工具链提供，其中包含着众多与 Wasm 编译相关的宏和函数定义。</p><p>另外的 “cmath” 头文件，是原始 C 标准库中的 “math.h” 头文件在 C++ 中的对应。两者在所提供函数的功能上基本没有区别。我们将使用该头文件中提供的 “std::floor” 函数，去参与滤镜的计算过程。</p><p>接下来，我们使用 “#define” 定义了两个宏常量 “KH” 与 “KW”，分别表示卷积核的“高”与“宽”。并同时使用这两个常量，定义了用来存放实际卷积核矩阵数据的二维数组 “kernel”。类似的，我们还定义了用来存放每一帧对应像素数据的一维数组 “data”。</p><p>这里要注意的是，由于在 C/C++ 中，无法声明全局的动态大小数组，因此我们需要提前计算出，由 Web API “CanvasRenderingContext2D.getImageData” 所返回的，存放有每一帧对应像素数据的那个 Uint8ClampedArray 数组，在 C/C++ 中对应到 unsigned char 类型数组时的大小。</p><p>由于这两个数组所存储的单个元素其类型完全相同，因此我们直接使用这个得到的 Uint8ClampedArray 数组的大小，来作为对应 C/C++ 中 “data” 数组的大小。经过实践，我们得到的数组大小为 “921600”。</p><p>在 <code>extern &quot;C&quot; <!-- -->{<!-- -->}</code> 结构中，我们声明了所有需要导出到外部宿主环境（这里为浏览器的 JavaScript 环境）中使用的函数。其中除了 cppConvFilter 函数以外，还有另外的 cppGetkernelPtr 和 cppGetDataPtr 函数。这两个函数主要用来获取先前声明的数组 kernel 与 data 的首地址。通过这种方式，我们便可以在外部的 JavaScript 环境中，向定义在 C/C++ 中的这两个数组结构填充实际的运行时数据了。</p><h2 id="使用-emscripten-进行编译"><a aria-hidden="true" tabindex="-1" href="/blog/webassembly入门/04.实战篇/03#使用-emscripten-进行编译"><span class="icon icon-link"></span></a>使用 Emscripten 进行编译</h2><p>当 C/C++ 源代码准备完毕后，我们便可以使用 Emscripten 来进行编译。与我们在实践项目的第一节课中介绍的 Emscripten 编译方式不同，这次我们不需要它帮助我们生成 JavaScript 胶水文件以及 HTML 文件，我们需要的仅是一个根据 C/C++ 代码生成的 Wasm 二进制模块文件，对于其他部分，我们将基于之前已经构建好的 JavaScript 和 HTML 代码来进行开发。</p><p>相较于 Emscripten 之前同时生成 JavaScript 胶水文件和 HTML 文件的方式，这种仅生成 Wasm 模块文件的方式，我们通常将其称为 “Standalone 模式”。对应的编译命令如下所示：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">emcc dip.cc -s WASM=1 -O3 --no-entry -o dip.wasm</span></div></pre></div><p>相比于之前的编译命令，这里我们做了两个更改。首先，我们将 “-o” 参数所指定的输出文件格式由原来 “.html” 变更为 “.wasm”。这样，我们可以告诉 Emscripten 我们希望以 “Standalone” 的方式来编译输入的 C/C++ 源码。“–no-entry” 参数告诉编译器，我们的 Wasm 模块没有声明 “main” 函数，因此不需要与 CRT（C Runtime Library）相关的功能进行交互。</p><p>在上述命令行执行完毕后，我们将会得到一个名为 “dip.wasm” 的 Wasm 二进制模块文件。</p><h2 id="整合上下文资源"><a aria-hidden="true" tabindex="-1" href="/blog/webassembly入门/04.实战篇/03#整合上下文资源"><span class="icon icon-link"></span></a>整合上下文资源</h2><p>至此，我们便可以将这个通过 Emscripten 编译得到的名为 “dip.wasm” 的 Wasm 模块文件，整合到现阶段项目的 JavaScript 代码中。这里我们将使用 “WebAssembly.instantiate” 的方式来加载这个模块文件。对应的代码如下所示：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">let bytes = await (await fetch(&#x27;./dip.wasm&#x27;)).arrayBuffer();</span></div><div class="token-line"><span class="token plain">    let { instance, module } = await WebAssembly.instantiate(bytes);</span></div><div class="token-line"><span class="token plain">    let { </span></div><div class="token-line"><span class="token plain">      cppConvFilter, </span></div><div class="token-line"><span class="token plain">      cppGetkernelPtr, </span></div><div class="token-line"><span class="token plain">      cppGetDataPtr, </span></div><div class="token-line"><span class="token plain">      memory } = instance.exports;</span></div></pre></div><p>可以看到，通过 <code>fetch</code> 方法返回的 Respose 对象上的 arrayBuffer 函数，会将请求返回的内容解析为对应的 ArrayBuffer 形式。而这个 ArrayBuffer ，随后便会作为 WebAssembly.instantiate 方法的实际调用参数。</p><p>函数返回的 Promise 对象在被 resolve 之后，我们可以得到对应的 WebAssembly.Instance 实例对象和 WebAssembly.Module 模块对象（这里分别对应到名为 instance 和 module 的属性上）。然后在名为 instance 的变量中，我们便可以获得从 Wasm 模块导出的所有方法。</p><p>眼尖的你一定发现了，上面的代码除了从 instance.exports 对象中导出了定义在 Wasm 模块内的函数以外，还有另一个名为 memory 的对象。这个 memory 对象便代表着模块实例所使用到的线性内存段。线性内存段在 JavaScript 中的表示形式，也就是我们上文中提到的，是一个 ArrayBuffer 对象。</p><p>当然，这里 memory 实际上是一个名为 WebAssembly.Memory 的包装类对象，而该对象上的 “buffer” 属性中，便实际存放着对应模块线性内存的 ArrayBuffer 对象。</p><p>下面，我们便可以通过调用相应的方法来完成 Wasm 滤镜函数与 Web 应用的整合。</p><p>首先，我们需要将在 JavaScript 代码中获得到的卷积核矩阵数据，以及每一帧所对应的画面像素数据，填充到我们之前在 C/C++ 代码中定义的相应数组中。为了完成这一步，我们需要首先调用从模块实例中导出的 “cppGetDataPtr” 和 “cppGetkernelPtr” 两个方法，来分别获得这两个数组的首地址，也就是在模块实例线性内存段中的具体偏移位置。</p><p>然后，我们将使用 “Uint8Array” 与 “Int8Array” 这两个 TypedArray 类型来作为模块线性内存的操作视图，并向其中写入数据。</p><p>待数据填充完毕后，我们便可以调用从模块中导出的 “cppConvFilter” 方法来为原始的像素数据添加滤镜。</p><p>待方法调用完毕后，我们将通过 TypedArray 的 subarray 方法来返回一个，包含有已处理完毕像素数据的新的 TypedArray，这些数据随后将会通过名为 CanvasRenderingContext2D.putImageData() 的 API 被重新绘制在 <code>&lt;canvas&gt;</code> 对象上，以实现画面的更新。</p><p>这部分功能对应的代码如下所示：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// 获取 C/C++ 中存有卷积核矩阵和帧像素数据的数组，在 Wasm 线性内存段中的偏移位置；</span></div><div class="token-line"><span class="token plain">    const dataOffset = cppGetDataPtr();</span></div><div class="token-line"><span class="token plain">    const kernOffset = cppGetkernelPtr();</span></div><div class="token-line"><span class="token plain">    // 扁平化卷积核的二维数组到一位数组，以方便数据的填充；</span></div><div class="token-line"><span class="token plain">    const flatKernel = kernel.reduce((acc, cur) =&gt; acc.concat(cur), []);</span></div><div class="token-line"><span class="token plain">    // 为 Wasm 模块的线性内存段设置两个用于进行数据操作的视图，分别对应卷积核矩阵和帧像素数据；</span></div><div class="token-line"><span class="token plain">    let Uint8View = new Uint8Array(memory.buffer);</span></div><div class="token-line"><span class="token plain">    let Int8View = new Int8Array(memory.buffer);</span></div><div class="token-line"><span class="token plain">    // 填充卷积核矩阵数据；</span></div><div class="token-line"><span class="token plain">    Int8View.set(flatKernel, kernOffset);</span></div><div class="token-line"><span class="token plain">    // 封装的 Wasm 滤镜处理函数；</span></div><div class="token-line"><span class="token plain">    function filterWASM (pixelData, width, height) {</span></div><div class="token-line"><span class="token plain">      const arLen = pixelData.length;</span></div><div class="token-line"><span class="token plain">      // 填充当前帧画面的像素数据；</span></div><div class="token-line"><span class="token plain">      Uint8View.set(pixelData, dataOffset);</span></div><div class="token-line"><span class="token plain">      // 调用滤镜处理函数；</span></div><div class="token-line"><span class="token plain">      cppConvFilter(width, height, 4);</span></div><div class="token-line"><span class="token plain">      // 返回经过处理的数据；</span></div><div class="token-line"><span class="token plain">      return Uint8View.subarray(dataOffset, dataOffset + arLen);</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>这里需要注意的是，我们之前在 JavaScript 中使用的卷积核矩阵数组，实际上是以二维数组的形式存在的。而为了能够方便地将这部分数据填充到 Wasm 线性内存中，这里我们将其扁平化成了一维数组，并存放到变量 flatKernel 中。</p><p>另外，我们仅将那些在视频播放过程中可能会发生变化的部分（这里主要是指每一帧需要填充到 Wasm 模块实例线性内存的像素数据），都单独整和到了名为 filterWasm 的函数中，这样在动画的播放过程中，可以减少不必要的数据传递过程。</p><h2 id="性能对比"><a aria-hidden="true" tabindex="-1" href="/blog/webassembly入门/04.实战篇/03#性能对比"><span class="icon icon-link"></span></a>性能对比</h2><p>最后我们选择了如下两款市面上最为常见的浏览器，来分别测量我们构建的这个 DIP Web 应用在 JavaScript 滤镜和 Wasm 滤镜这两个选项下的视频播放帧率。</p><ul><li>Chrome Version 84.0.4147.89 (Official Build) (64-bit)</li><li>Firefox Version 79.0</li></ul><p>实际测试结果的截图如下所示。其中左侧为 JavaScript 版本滤镜函数，右侧为对应的 Wasm 版本滤镜函数。</p><p>首先是 Chrome：</p><p><img src="https://static001.geekbang.org/resource/image/a4/e9/a4eb93d61be5af9e716ed706654669e9.png?wh=1920*845" alt=""/></p><p>然后是 Firefox：</p><p><img src="https://static001.geekbang.org/resource/image/78/c6/78ae36409a42d36cf3156c66ece069c6.png?wh=1920*850" alt=""/></p><p>可以看到，同样逻辑的滤镜函数，在对应的 JavaScript 实现版本和 Wasm 实现版本下有着极大的性能差异。Wasm 版本函数的帧画面实时处理效率几乎是对应 JavaScript 版本函数的一倍之多。当然，上述的性能对比结果仅供参考，应用的实际表现是一个综合性的结果，与浏览器版本、代码实现细节、编译器版本甚至操作系统版本都有着密切的关系。</p><p>如果再通过 Chrome 的 Performance 工具来查看，jsConvFilter 与 cppConvFilter 这两个分别对应的 JavaScript 滤镜实现与 Wasm 滤镜实现函数的运行耗时，你可以发现如下所示的结果：</p><p><img src="https://static001.geekbang.org/resource/image/a1/a0/a1790yyc7172bf7a49a0b13a11bdcca0.png?wh=1442*298" alt="" title="Wasm 滤镜函数实现的耗时"/></p><p><img src="https://static001.geekbang.org/resource/image/29/cb/296bf7d7c3e2ec40bc1db0408f9bffcb.png?wh=1444*290" alt="" title="JavaScript 滤镜函数实现的耗时"/></p><p>可以看到，JavaScript 滤镜函数实现的运行耗时是 Wasm 版本的将近 3 倍。但由于 getImageData 函数在应用实际运行时也会占用一部分时间，因此使得在每一帧画面的刷新和滤镜渲染过程中，整个 Wasm 滤镜处理过程的耗时只能被优化到对应 JavaScript 版本的一半时间左右。同样的，Wasm 实现下通过 Uint8View.set 向 Wasm 实例线性内存段中填充像素数据的过程也同样会占用一定的额外耗时，但这部分的比例相对很小。</p><h2 id="总结"><a aria-hidden="true" tabindex="-1" href="/blog/webassembly入门/04.实战篇/03#总结"><span class="icon icon-link"></span></a>总结</h2><p>好了，讲到这，今天的内容也就基本结束了。最后我来给你总结一下。</p><p>通过完整的三节课，我们讲解了如何从第一行代码开始着手编写一个完整的 Wasm Web 应用。在构建应用的过程中，我们知道了如何使用 Emscripten 来直接编译输入的 C/C++ 代码到一个完整的、可以直接运行的 Web 应用；或者是基于 “Standalone 模式”来仅仅输出源代码对应的 Wasm 二进制模块文件。</p><p>不仅如此，我们还知道了 Emscripten 在被作为工具链使用时，它还为我们提供了诸如 EMSCRIPTEN_KEEPALIVE 等宏函数，以支持编译过程的正常进行。Emscripten 为我们提供了极其强大的宏函数支持以及对 Web API 的无缝整合。</p><p>甚至你可以直接将基于 OpenGL 编写的 C/C++ 应用编译成 Wasm Web 应用，而无需做任何源代码上的修改。Emscripten 会通过相应的 JavaScript 胶水代码来处理好 OpenGL 与 WebGL 的调用映射关系，让你真正地做到“无痛迁移”。</p><p>在编译完成后，我们还学习了如何通过 Web API 和 JavaScript API 来加载并实例化一个 Wasm 模块对象。WebAssembly.instantiate 与 WebAssembly.instantiateStreaming 这两个主要用来实例化 Wasm 对象的 Web API 在模块实例化效率上的不同。基于“流式编译”的特性，后者往往通常会有着更高的模块实例化性能。</p><p>最后，你应该知道了如何通过 TypedArray 向 Wasm 模块实例的线性内存段中填充数据，以及如何从中读取数据。在本文这个实例中，我们分别使用了 set 与 subarray 这两个 TypedArray 对象上的方法来分别达到这两个目的。</p><p>通过本次实践，我们在最后的性能对比中，也清楚地看到了 Wasm 所带来的 Web 应用的性能提升。希望你也能够通过这次实践，亲身体会到 Wasm 在不久的将来，所能够带给 Web 应用的一系列变革。</p><h2 id="课后练习"><a aria-hidden="true" tabindex="-1" href="/blog/webassembly入门/04.实战篇/03#课后练习"><span class="icon icon-link"></span></a><strong>课后练习</strong></h2><p>最后，我们来做一个小练习吧。</p><p>你可以尝试在其他的，诸如 Edge 和 Safari 浏览器中运行这个 Wasm Web 应用， 并查看在这些浏览器中，当分别使用 JavaScript 版滤镜函数和 Wasm 滤镜函数时的画面实时处理帧率。</p><p>今天的课程就结束了，希望可以帮助到你，也希望你在下方的留言区和我参与讨论，同时欢迎你把这节课分享给你的朋友或者同事，一起交流一下。</p></div><div class="__dumi-default-layout-footer-meta"><a target="_blank" rel="noopener noreferrer" href="https://github.com/GGwujun/blog/edit/master/docs/webassembly入门/04.实战篇/03.md">在 GitHub 上编辑此页<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a><span data-updated-text="最后更新时间：">5/2/2022 10:56:57</span></div></div></div></div>
	<script>
  window.g_useSSR = true;
  window.g_initialProps = {};
	</script>

    <script>
      (function () {
        if (!location.port) {
          (function (i, s, o, g, r, a, m) {
            i["GoogleAnalyticsObject"] = r;
            (i[r] =
              i[r] ||
              function () {
                (i[r].q = i[r].q || []).push(arguments);
              }),
              (i[r].l = 1 * new Date());
            (a = s.createElement(o)), (m = s.getElementsByTagName(o)[0]);
            a.async = 1;
            a.src = g;
            m.parentNode.insertBefore(a, m);
          })(
            window,
            document,
            "script",
            "//www.google-analytics.com/analytics.js",
            "ga"
          );
          ga("create", "UA-149864185-1", "auto");
          ga("send", "pageview");
        }
      })();
    </script>
    <script src="/blog/umi.js"></script>
  </body>
</html>
